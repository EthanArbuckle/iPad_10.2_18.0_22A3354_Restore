uint64_t re::DotVector3Compile(uint64_t a1, __n128 **a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v7;
  uint64_t v8;
  __n128 *v9;
  _QWORD *v10;
  __n128 *v11;
  __n128 *v12;
  unint64_t v13;
  __n128 *v14;
  _QWORD *v15;
  __n128 *v16;
  __n128 *v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t result;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (!a3)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v7 = *a4;
  v8 = *(_QWORD *)(a1 + 8);
  v9 = *a2;
  if ((*a2)[6].n128_u8[0] == 1)
  {
    v10 = (_QWORD *)v9[1].n128_u64[0];
    v11 = v9 + 7;
    LODWORD(v22) = 7;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v10 + 243), (uint64_t)&v22);
    v22 = v10[245] - 1;
    re::DynamicArray<unsigned long>::add(v10 + 36, &v22);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v10 + 76), v11);
    v12 = (__n128 *)(v10[40] + 8 * v10[38] - 8);
  }
  else
  {
    v12 = v9 + 11;
  }
  if (a3 <= 1)
    goto LABEL_13;
  v13 = v12->n128_u64[0];
  v14 = a2[1];
  if (v14[6].n128_u8[0] == 1)
  {
    v15 = (_QWORD *)v14[1].n128_u64[0];
    v16 = v14 + 7;
    LODWORD(v22) = 7;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 243), (uint64_t)&v22);
    v22 = v15[245] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 36, &v22);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v15 + 76), v16);
    v17 = (__n128 *)(v15[40] + 8 * v15[38] - 8);
  }
  else
  {
    v17 = v14 + 11;
  }
  v18 = v17->n128_u64[0];
  LODWORD(v22) = 22;
  v24 = 0;
  v25 = 0;
  v23 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 1744), (uint64_t)&v22);
  v19 = *(_QWORD *)(v8 + 1760) - 1;
  v20 = re::DynamicEvaluationRegisterTable::evaluationRegister<float>(v8 + 1664, v19);
  *(_QWORD *)(v20 + 8) = v13;
  *(_QWORD *)(v20 + 16) = v18;
  *(_BYTE *)(v7 + 96) = 2;
  *(_QWORD *)(v7 + 176) = v19;
  return 1;
}

uint64_t re::DotVector2Compile(uint64_t a1, _QWORD *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  uint64_t *v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t result;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (!a3)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v7 = *a4;
  v8 = *(_QWORD *)(a1 + 8);
  v9 = (_QWORD *)*a2;
  if (*(_BYTE *)(*a2 + 96) == 1)
  {
    v10 = (_QWORD *)v9[2];
    v11 = v9 + 14;
    LODWORD(v22) = 6;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v10 + 238), (uint64_t)&v22);
    v22 = v10[240] - 1;
    re::DynamicArray<unsigned long>::add(v10 + 31, &v22);
    re::DynamicArray<unsigned long>::add(v10 + 71, v11);
    v12 = (uint64_t *)(v10[35] + 8 * v10[33] - 8);
  }
  else
  {
    v12 = v9 + 22;
  }
  if (a3 <= 1)
    goto LABEL_13;
  v13 = *v12;
  v14 = a2[1];
  if (*(_BYTE *)(v14 + 96) == 1)
  {
    v15 = *(_QWORD **)(v14 + 16);
    v16 = (_QWORD *)(v14 + 112);
    LODWORD(v22) = 6;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 238), (uint64_t)&v22);
    v22 = v15[240] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 31, &v22);
    re::DynamicArray<unsigned long>::add(v15 + 71, v16);
    v17 = (uint64_t *)(v15[35] + 8 * v15[33] - 8);
  }
  else
  {
    v17 = (uint64_t *)(v14 + 176);
  }
  v18 = *v17;
  LODWORD(v22) = 23;
  v24 = 0;
  v25 = 0;
  v23 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 1744), (uint64_t)&v22);
  v19 = *(_QWORD *)(v8 + 1760) - 1;
  v20 = re::DynamicEvaluationRegisterTable::evaluationRegister<float>(v8 + 1664, v19);
  *(_QWORD *)(v20 + 8) = v13;
  *(_QWORD *)(v20 + 16) = v18;
  *(_BYTE *)(v7 + 96) = 2;
  *(_QWORD *)(v7 + 176) = v19;
  return 1;
}

uint64_t re::TransformPositionCompile(uint64_t a1, _QWORD *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  __n128 *v14;
  _QWORD *v15;
  __n128 *v16;
  __n128 *v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t result;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (!a3)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v7 = *a4;
  v8 = *(_QWORD *)(a1 + 8);
  v9 = *a2;
  if (*(_BYTE *)(*a2 + 96) == 1)
  {
    v10 = *(_QWORD **)(v9 + 16);
    v11 = v9 + 112;
    LODWORD(v22) = 4;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v10 + 228), (uint64_t)&v22);
    v22 = v10[230] - 1;
    re::DynamicArray<unsigned long>::add(v10 + 21, &v22);
    re::DynamicArray<re::Matrix4x4<float>>::add((_anonymous_namespace_ *)(v10 + 61), v11);
    v12 = (uint64_t *)(v10[25] + 8 * v10[23] - 8);
  }
  else
  {
    v12 = (uint64_t *)(v9 + 176);
  }
  if (a3 <= 1)
    goto LABEL_13;
  v13 = *v12;
  v14 = (__n128 *)a2[1];
  if (v14[6].n128_u8[0] == 1)
  {
    v15 = (_QWORD *)v14[1].n128_u64[0];
    v16 = v14 + 7;
    LODWORD(v22) = 7;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 243), (uint64_t)&v22);
    v22 = v15[245] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 36, &v22);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v15 + 76), v16);
    v17 = (__n128 *)(v15[40] + 8 * v15[38] - 8);
  }
  else
  {
    v17 = v14 + 11;
  }
  v18 = v17->n128_u64[0];
  LODWORD(v22) = 43;
  v24 = 0;
  v25 = 0;
  v23 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 1944), (uint64_t)&v22);
  v19 = *(_QWORD *)(v8 + 1960) - 1;
  v20 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v8 + 1664, v19);
  *(_QWORD *)(v20 + 8) = v13;
  *(_QWORD *)(v20 + 16) = v18;
  *(_BYTE *)(v7 + 96) = 2;
  *(_QWORD *)(v7 + 176) = v19;
  return 1;
}

uint64_t re::TransformDirectionByMatrix4x4Compile(uint64_t a1, _QWORD *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  __n128 *v14;
  _QWORD *v15;
  __n128 *v16;
  __n128 *v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t result;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (!a3)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v7 = *a4;
  v8 = *(_QWORD *)(a1 + 8);
  v9 = *a2;
  if (*(_BYTE *)(*a2 + 96) == 1)
  {
    v10 = *(_QWORD **)(v9 + 16);
    v11 = v9 + 112;
    LODWORD(v22) = 4;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v10 + 228), (uint64_t)&v22);
    v22 = v10[230] - 1;
    re::DynamicArray<unsigned long>::add(v10 + 21, &v22);
    re::DynamicArray<re::Matrix4x4<float>>::add((_anonymous_namespace_ *)(v10 + 61), v11);
    v12 = (uint64_t *)(v10[25] + 8 * v10[23] - 8);
  }
  else
  {
    v12 = (uint64_t *)(v9 + 176);
  }
  if (a3 <= 1)
    goto LABEL_13;
  v13 = *v12;
  v14 = (__n128 *)a2[1];
  if (v14[6].n128_u8[0] == 1)
  {
    v15 = (_QWORD *)v14[1].n128_u64[0];
    v16 = v14 + 7;
    LODWORD(v22) = 7;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 243), (uint64_t)&v22);
    v22 = v15[245] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 36, &v22);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v15 + 76), v16);
    v17 = (__n128 *)(v15[40] + 8 * v15[38] - 8);
  }
  else
  {
    v17 = v14 + 11;
  }
  v18 = v17->n128_u64[0];
  LODWORD(v22) = 42;
  v24 = 0;
  v25 = 0;
  v23 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 1944), (uint64_t)&v22);
  v19 = *(_QWORD *)(v8 + 1960) - 1;
  v20 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v8 + 1664, v19);
  *(_QWORD *)(v20 + 8) = v13;
  *(_QWORD *)(v20 + 16) = v18;
  *(_BYTE *)(v7 + 96) = 2;
  *(_QWORD *)(v7 + 176) = v19;
  return 1;
}

uint64_t re::TransformDirectionByMatrix3x3Compile(uint64_t a1, _QWORD *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  __n128 *v14;
  _QWORD *v15;
  __n128 *v16;
  __n128 *v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t result;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (!a3)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v7 = *a4;
  v8 = *(_QWORD *)(a1 + 8);
  v9 = *a2;
  if (*(_BYTE *)(*a2 + 96) == 1)
  {
    v10 = *(_QWORD **)(v9 + 16);
    v11 = v9 + 112;
    LODWORD(v22) = 3;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v10 + 223), (uint64_t)&v22);
    v22 = v10[225] - 1;
    re::DynamicArray<unsigned long>::add(v10 + 16, &v22);
    re::DynamicArray<re::Matrix3x3<float>>::add((_anonymous_namespace_ *)(v10 + 56), v11);
    v12 = (uint64_t *)(v10[20] + 8 * v10[18] - 8);
  }
  else
  {
    v12 = (uint64_t *)(v9 + 176);
  }
  if (a3 <= 1)
    goto LABEL_13;
  v13 = *v12;
  v14 = (__n128 *)a2[1];
  if (v14[6].n128_u8[0] == 1)
  {
    v15 = (_QWORD *)v14[1].n128_u64[0];
    v16 = v14 + 7;
    LODWORD(v22) = 7;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 243), (uint64_t)&v22);
    v22 = v15[245] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 36, &v22);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v15 + 76), v16);
    v17 = (__n128 *)(v15[40] + 8 * v15[38] - 8);
  }
  else
  {
    v17 = v14 + 11;
  }
  v18 = v17->n128_u64[0];
  LODWORD(v22) = 41;
  v24 = 0;
  v25 = 0;
  v23 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 1944), (uint64_t)&v22);
  v19 = *(_QWORD *)(v8 + 1960) - 1;
  v20 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v8 + 1664, v19);
  *(_QWORD *)(v20 + 8) = v13;
  *(_QWORD *)(v20 + 16) = v18;
  *(_BYTE *)(v7 + 96) = 2;
  *(_QWORD *)(v7 + 176) = v19;
  return 1;
}

uint64_t re::ConstructMatrix4x4Compile(uint64_t a1, __n128 **a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v7;
  _QWORD *v8;
  __n128 *v9;
  _QWORD *v10;
  __n128 *v11;
  uint64_t *v12;
  uint64_t v13;
  __n128 *v14;
  _QWORD *v15;
  __n128 *v16;
  uint64_t *v17;
  uint64_t v18;
  __n128 *v19;
  _QWORD *v20;
  __n128 *v21;
  uint64_t *v22;
  unint64_t v23;
  uint64_t result;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;

  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_16;
  }
  if (!a3)
  {
LABEL_16:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_17:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    _os_crash();
    __break(1u);
LABEL_18:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v7 = *a4;
  v8 = *(_QWORD **)(a1 + 8);
  v9 = *a2;
  if ((*a2)[6].n128_u8[0] == 1)
  {
    v10 = (_QWORD *)v9[1].n128_u64[0];
    v11 = v9 + 7;
    LODWORD(v25) = 7;
    v27 = 0;
    v28 = 0;
    v26 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v10 + 243), (uint64_t)&v25);
    v25 = v10[245] - 1;
    re::DynamicArray<unsigned long>::add(v10 + 36, &v25);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v10 + 76), v11);
    v12 = (uint64_t *)(v10[40] + 8 * v10[38] - 8);
  }
  else
  {
    v12 = (uint64_t *)&v9[11];
  }
  if (a3 <= 1)
    goto LABEL_17;
  v13 = *v12;
  v14 = a2[1];
  if (v14[6].n128_u8[0] == 1)
  {
    v15 = (_QWORD *)v14[1].n128_u64[0];
    v16 = v14 + 7;
    LODWORD(v25) = 5;
    v27 = 0;
    v28 = 0;
    v26 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 233), (uint64_t)&v25);
    v25 = v15[235] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 26, &v25);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v15 + 66), v16);
    v17 = (uint64_t *)(v15[30] + 8 * v15[28] - 8);
  }
  else
  {
    v17 = (uint64_t *)&v14[11];
  }
  if (a3 <= 2)
    goto LABEL_18;
  v18 = *v17;
  v19 = a2[2];
  if (v19[6].n128_u8[0] == 1)
  {
    v20 = (_QWORD *)v19[1].n128_u64[0];
    v21 = v19 + 7;
    LODWORD(v25) = 7;
    v27 = 0;
    v28 = 0;
    v26 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v20 + 243), (uint64_t)&v25);
    v25 = v20[245] - 1;
    re::DynamicArray<unsigned long>::add(v20 + 36, &v25);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v20 + 76), v21);
    v22 = (uint64_t *)(v20[40] + 8 * v20[38] - 8);
  }
  else
  {
    v22 = (uint64_t *)&v19[11];
  }
  v23 = re::EvaluationTree::constructMatrix4x4(v8, v13, v18, *v22);
  *(_BYTE *)(v7 + 96) = 2;
  *(_QWORD *)(v7 + 176) = v23;
  return 1;
}

uint64_t re::ConstructMatrix4x4FromMatrix3x3Compile(uint64_t a1, _QWORD *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  __n128 *v14;
  _QWORD *v15;
  __n128 *v16;
  __n128 *v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t result;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (!a3)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v7 = *a4;
  v8 = *(_QWORD *)(a1 + 8);
  v9 = *a2;
  if (*(_BYTE *)(*a2 + 96) == 1)
  {
    v10 = *(_QWORD **)(v9 + 16);
    v11 = v9 + 112;
    LODWORD(v22) = 3;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v10 + 223), (uint64_t)&v22);
    v22 = v10[225] - 1;
    re::DynamicArray<unsigned long>::add(v10 + 16, &v22);
    re::DynamicArray<re::Matrix3x3<float>>::add((_anonymous_namespace_ *)(v10 + 56), v11);
    v12 = (uint64_t *)(v10[20] + 8 * v10[18] - 8);
  }
  else
  {
    v12 = (uint64_t *)(v9 + 176);
  }
  if (a3 <= 1)
    goto LABEL_13;
  v13 = *v12;
  v14 = (__n128 *)a2[1];
  if (v14[6].n128_u8[0] == 1)
  {
    v15 = (_QWORD *)v14[1].n128_u64[0];
    v16 = v14 + 7;
    LODWORD(v22) = 7;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 243), (uint64_t)&v22);
    v22 = v15[245] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 36, &v22);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v15 + 76), v16);
    v17 = (__n128 *)(v15[40] + 8 * v15[38] - 8);
  }
  else
  {
    v17 = v14 + 11;
  }
  v18 = v17->n128_u64[0];
  LODWORD(v22) = 40;
  v24 = 0;
  v25 = 0;
  v23 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 1824), (uint64_t)&v22);
  v19 = *(_QWORD *)(v8 + 1840) - 1;
  v20 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix4x4<float>>(v8 + 1664, v19);
  *(_QWORD *)(v20 + 8) = v13;
  *(_QWORD *)(v20 + 16) = v18;
  *(_BYTE *)(v7 + 96) = 2;
  *(_QWORD *)(v7 + 176) = v19;
  return 1;
}

uint64_t re::ConstructMatrix4x4FromSRTCompile(uint64_t a1, const re::RigDataValue **a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  uint64_t result;
  uint64_t v9[3];

  if (a5)
  {
    if (a3)
    {
      v5 = *a4;
      v6 = *(_QWORD **)(a1 + 8);
      v7 = re::EvaluationTree::constructMatrix4x4(v6, v9[0], v9[1], v9[2]);
      *(_BYTE *)(v5 + 96) = 2;
      *(_QWORD *)(v5 + 176) = v7;
      return 1;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
  }
  re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::ConstructSRTFromMatrix4x4Compile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t Rotation;
  unint64_t Scale;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t result;
  const char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char v33;

  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_20:
    re::internal::assertLog((re::internal *)6, v18, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v8 = *(_QWORD *)a2;
  if (*(_BYTE *)(*(_QWORD *)a2 + 96) == 1)
  {
    v9 = *(_QWORD **)(v8 + 16);
    v10 = v8 + 112;
    LODWORD(v29) = 4;
    v31 = 0;
    v32 = 0;
    v30 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v9 + 228), (uint64_t)&v29);
    v29 = v9[230] - 1;
    re::DynamicArray<unsigned long>::add(v9 + 21, &v29);
    re::DynamicArray<re::Matrix4x4<float>>::add((_anonymous_namespace_ *)(v9 + 61), v10);
    v11 = (uint64_t *)(v9[25] + 8 * v9[23] - 8);
  }
  else
  {
    v11 = (uint64_t *)(v8 + 176);
  }
  v12 = *v11;
  v13 = *(_QWORD *)(a1 + 8);
  v14 = v13 + 1664;
  LODWORD(v29) = 37;
  v31 = 0;
  v32 = 0;
  v30 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v13 + 1944), (uint64_t)&v29);
  v15 = *(_QWORD *)(v13 + 1960) - 1;
  *(_QWORD *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v14, v15) + 8) = v12;
  Rotation = re::EvaluationTree::extractRotation(*(_QWORD **)(a1 + 8), v12);
  Scale = re::EvaluationTree::extractScale(*(_QWORD **)(a1 + 8), v12);
  if (!a5)
    goto LABEL_20;
  v19 = Scale;
  v20 = *a4;
  v27 = "scale";
  v28 = 5;
  re::RigDataValue::attributeValue(v20, (uint64_t)&v27, (uint64_t)&v29);
  v21 = v30;
  *(_BYTE *)(v30 + 96) = 2;
  *(_QWORD *)(v21 + 176) = v19;
  if (!(_BYTE)v29 && v32 && (v33 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v32 + 40))();
  v22 = *a4;
  v27 = "rotation";
  v28 = 8;
  re::RigDataValue::attributeValue(v22, (uint64_t)&v27, (uint64_t)&v29);
  v23 = v30;
  *(_BYTE *)(v30 + 96) = 2;
  *(_QWORD *)(v23 + 176) = Rotation;
  if (!(_BYTE)v29 && v32 && (v33 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v32 + 40))();
  v24 = *a4;
  v27 = "translation";
  v28 = 11;
  re::RigDataValue::attributeValue(v24, (uint64_t)&v27, (uint64_t)&v29);
  v25 = v30;
  *(_BYTE *)(v30 + 96) = 2;
  *(_QWORD *)(v25 + 176) = v15;
  if (!(_BYTE)v29 && v32 && (v33 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v32 + 40))();
  return 1;
}

uint64_t re::ConstructMatrix3x3Compile(uint64_t a1, __n128 **a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v7;
  uint64_t v8;
  __n128 *v9;
  _QWORD *v10;
  __n128 *v11;
  __n128 *v12;
  unint64_t v13;
  __n128 *v14;
  _QWORD *v15;
  __n128 *v16;
  __n128 *v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t result;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (!a3)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v7 = *a4;
  v8 = *(_QWORD *)(a1 + 8);
  v9 = *a2;
  if ((*a2)[6].n128_u8[0] == 1)
  {
    v10 = (_QWORD *)v9[1].n128_u64[0];
    v11 = v9 + 7;
    LODWORD(v22) = 7;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v10 + 243), (uint64_t)&v22);
    v22 = v10[245] - 1;
    re::DynamicArray<unsigned long>::add(v10 + 36, &v22);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v10 + 76), v11);
    v12 = (__n128 *)(v10[40] + 8 * v10[38] - 8);
  }
  else
  {
    v12 = v9 + 11;
  }
  if (a3 <= 1)
    goto LABEL_13;
  v13 = v12->n128_u64[0];
  v14 = a2[1];
  if (v14[6].n128_u8[0] == 1)
  {
    v15 = (_QWORD *)v14[1].n128_u64[0];
    v16 = v14 + 7;
    LODWORD(v22) = 5;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 233), (uint64_t)&v22);
    v22 = v15[235] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 26, &v22);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v15 + 66), v16);
    v17 = (__n128 *)(v15[30] + 8 * v15[28] - 8);
  }
  else
  {
    v17 = v14 + 11;
  }
  v18 = v17->n128_u64[0];
  LODWORD(v22) = 39;
  v24 = 0;
  v25 = 0;
  v23 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 1784), (uint64_t)&v22);
  v19 = *(_QWORD *)(v8 + 1800) - 1;
  v20 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix3x3<float>>(v8 + 1664, v19);
  *(_QWORD *)(v20 + 8) = v13;
  *(_QWORD *)(v20 + 16) = v18;
  *(_BYTE *)(v7 + 96) = 2;
  *(_QWORD *)(v7 + 176) = v19;
  return 1;
}

uint64_t re::ConstructMatrix3x3FromVector3sCompile(uint64_t a1, __n128 **a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v7;
  uint64_t v8;
  __n128 *v9;
  _QWORD *v10;
  __n128 *v11;
  __n128 *v12;
  unint64_t v13;
  __n128 *v14;
  _QWORD *v15;
  __n128 *v16;
  __n128 *v17;
  unint64_t v18;
  __n128 *v19;
  _QWORD *v20;
  __n128 *v21;
  __n128 *v22;
  unint64_t v23;
  unint64_t v24;
  _QWORD *v25;
  uint64_t result;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;

  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_16;
  }
  if (!a3)
  {
LABEL_16:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_17:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    _os_crash();
    __break(1u);
LABEL_18:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v7 = *a4;
  v8 = *(_QWORD *)(a1 + 8);
  v9 = *a2;
  if ((*a2)[6].n128_u8[0] == 1)
  {
    v10 = (_QWORD *)v9[1].n128_u64[0];
    v11 = v9 + 7;
    LODWORD(v27) = 7;
    v29 = 0;
    v30 = 0;
    v28 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v10 + 243), (uint64_t)&v27);
    v27 = v10[245] - 1;
    re::DynamicArray<unsigned long>::add(v10 + 36, &v27);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v10 + 76), v11);
    v12 = (__n128 *)(v10[40] + 8 * v10[38] - 8);
  }
  else
  {
    v12 = v9 + 11;
  }
  if (a3 <= 1)
    goto LABEL_17;
  v13 = v12->n128_u64[0];
  v14 = a2[1];
  if (v14[6].n128_u8[0] == 1)
  {
    v15 = (_QWORD *)v14[1].n128_u64[0];
    v16 = v14 + 7;
    LODWORD(v27) = 7;
    v29 = 0;
    v30 = 0;
    v28 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 243), (uint64_t)&v27);
    v27 = v15[245] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 36, &v27);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v15 + 76), v16);
    v17 = (__n128 *)(v15[40] + 8 * v15[38] - 8);
  }
  else
  {
    v17 = v14 + 11;
  }
  if (a3 <= 2)
    goto LABEL_18;
  v18 = v17->n128_u64[0];
  v19 = a2[2];
  if (v19[6].n128_u8[0] == 1)
  {
    v20 = (_QWORD *)v19[1].n128_u64[0];
    v21 = v19 + 7;
    LODWORD(v27) = 7;
    v29 = 0;
    v30 = 0;
    v28 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v20 + 243), (uint64_t)&v27);
    v27 = v20[245] - 1;
    re::DynamicArray<unsigned long>::add(v20 + 36, &v27);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v20 + 76), v21);
    v22 = (__n128 *)(v20[40] + 8 * v20[38] - 8);
  }
  else
  {
    v22 = v19 + 11;
  }
  v23 = v22->n128_u64[0];
  LODWORD(v27) = 38;
  v29 = 0;
  v30 = 0;
  v28 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 1784), (uint64_t)&v27);
  v24 = *(_QWORD *)(v8 + 1800) - 1;
  v25 = (_QWORD *)re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix3x3<float>>(v8 + 1664, v24);
  v25[1] = v13;
  v25[2] = v18;
  v25[3] = v23;
  *(_BYTE *)(v7 + 96) = 2;
  *(_QWORD *)(v7 + 176) = v24;
  return 1;
}

uint64_t re::ExtractTranslationMatrix4x4Compile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t result;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_8;
  }
  if (!a3)
  {
LABEL_8:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v5 = *a4;
  v6 = *(_QWORD *)(a1 + 8);
  v7 = *(_QWORD *)a2;
  if (*(_BYTE *)(*(_QWORD *)a2 + 96) == 1)
  {
    v8 = *(_QWORD **)(v7 + 16);
    v9 = v7 + 112;
    LODWORD(v14) = 4;
    v16 = 0;
    v17 = 0;
    v15 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 228), (uint64_t)&v14);
    v14 = v8[230] - 1;
    re::DynamicArray<unsigned long>::add(v8 + 21, &v14);
    re::DynamicArray<re::Matrix4x4<float>>::add((_anonymous_namespace_ *)(v8 + 61), v9);
    v10 = (uint64_t *)(v8[25] + 8 * v8[23] - 8);
  }
  else
  {
    v10 = (uint64_t *)(v7 + 176);
  }
  v11 = *v10;
  LODWORD(v14) = 37;
  v16 = 0;
  v17 = 0;
  v15 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v6 + 1944), (uint64_t)&v14);
  v12 = *(_QWORD *)(v6 + 1960) - 1;
  *(_QWORD *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v6 + 1664, v12) + 8) = v11;
  *(_BYTE *)(v5 + 96) = 2;
  *(_QWORD *)(v5 + 176) = v12;
  return 1;
}

uint64_t re::ExtractScaleMatrix4x4Compile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t *v10;
  unint64_t Scale;
  uint64_t result;
  _QWORD v13[4];

  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_8;
  }
  if (!a3)
  {
LABEL_8:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v5 = *a4;
  v6 = *(_QWORD **)(a1 + 8);
  v7 = *(_QWORD *)a2;
  if (*(_BYTE *)(*(_QWORD *)a2 + 96) == 1)
  {
    v8 = *(_QWORD **)(v7 + 16);
    v9 = v7 + 112;
    LODWORD(v13[0]) = 4;
    memset(&v13[1], 0, 24);
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 228), (uint64_t)v13);
    v13[0] = v8[230] - 1;
    re::DynamicArray<unsigned long>::add(v8 + 21, v13);
    re::DynamicArray<re::Matrix4x4<float>>::add((_anonymous_namespace_ *)(v8 + 61), v9);
    v10 = (uint64_t *)(v8[25] + 8 * v8[23] - 8);
  }
  else
  {
    v10 = (uint64_t *)(v7 + 176);
  }
  Scale = re::EvaluationTree::extractScale(v6, *v10);
  *(_BYTE *)(v5 + 96) = 2;
  *(_QWORD *)(v5 + 176) = Scale;
  return 1;
}

uint64_t re::ExtractRotationMatrix4x4Compile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t *v10;
  unint64_t Rotation;
  uint64_t result;
  _QWORD v13[4];

  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_8;
  }
  if (!a3)
  {
LABEL_8:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v5 = *a4;
  v6 = *(_QWORD **)(a1 + 8);
  v7 = *(_QWORD *)a2;
  if (*(_BYTE *)(*(_QWORD *)a2 + 96) == 1)
  {
    v8 = *(_QWORD **)(v7 + 16);
    v9 = v7 + 112;
    LODWORD(v13[0]) = 4;
    memset(&v13[1], 0, 24);
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 228), (uint64_t)v13);
    v13[0] = v8[230] - 1;
    re::DynamicArray<unsigned long>::add(v8 + 21, v13);
    re::DynamicArray<re::Matrix4x4<float>>::add((_anonymous_namespace_ *)(v8 + 61), v9);
    v10 = (uint64_t *)(v8[25] + 8 * v8[23] - 8);
  }
  else
  {
    v10 = (uint64_t *)(v7 + 176);
  }
  Rotation = re::EvaluationTree::extractRotation(v6, *v10);
  *(_BYTE *)(v5 + 96) = 2;
  *(_QWORD *)(v5 + 176) = Rotation;
  return 1;
}

uint64_t re::ExtractRotationMatrix3x3Compile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t result;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_8;
  }
  if (!a3)
  {
LABEL_8:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v5 = *a4;
  v6 = *(_QWORD *)(a1 + 8);
  v7 = *(_QWORD *)a2;
  if (*(_BYTE *)(*(_QWORD *)a2 + 96) == 1)
  {
    v8 = *(_QWORD **)(v7 + 16);
    v9 = v7 + 112;
    LODWORD(v14) = 3;
    v16 = 0;
    v17 = 0;
    v15 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 223), (uint64_t)&v14);
    v14 = v8[225] - 1;
    re::DynamicArray<unsigned long>::add(v8 + 16, &v14);
    re::DynamicArray<re::Matrix3x3<float>>::add((_anonymous_namespace_ *)(v8 + 56), v9);
    v10 = (uint64_t *)(v8[20] + 8 * v8[18] - 8);
  }
  else
  {
    v10 = (uint64_t *)(v7 + 176);
  }
  v11 = *v10;
  LODWORD(v14) = 35;
  v16 = 0;
  v17 = 0;
  v15 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v6 + 1864), (uint64_t)&v14);
  v12 = *(_QWORD *)(v6 + 1880) - 1;
  *(_QWORD *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Quaternion<float>>(v6 + 1664, v12) + 8) = v11;
  *(_BYTE *)(v5 + 96) = 2;
  *(_QWORD *)(v5 + 176) = v12;
  return 1;
}

uint64_t re::ExtractMinorMatrix4x4Compile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t result;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_8;
  }
  if (!a3)
  {
LABEL_8:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v5 = *a4;
  v6 = *(_QWORD *)(a1 + 8);
  v7 = *(_QWORD *)a2;
  if (*(_BYTE *)(*(_QWORD *)a2 + 96) == 1)
  {
    v8 = *(_QWORD **)(v7 + 16);
    v9 = v7 + 112;
    LODWORD(v14) = 4;
    v16 = 0;
    v17 = 0;
    v15 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 228), (uint64_t)&v14);
    v14 = v8[230] - 1;
    re::DynamicArray<unsigned long>::add(v8 + 21, &v14);
    re::DynamicArray<re::Matrix4x4<float>>::add((_anonymous_namespace_ *)(v8 + 61), v9);
    v10 = (uint64_t *)(v8[25] + 8 * v8[23] - 8);
  }
  else
  {
    v10 = (uint64_t *)(v7 + 176);
  }
  v11 = *v10;
  LODWORD(v14) = 34;
  v16 = 0;
  v17 = 0;
  v15 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v6 + 1784), (uint64_t)&v14);
  v12 = *(_QWORD *)(v6 + 1800) - 1;
  *(_QWORD *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix3x3<float>>(v6 + 1664, v12) + 8) = v11;
  *(_BYTE *)(v5 + 96) = 2;
  *(_QWORD *)(v5 + 176) = v12;
  return 1;
}

uint64_t re::TransposeMatrix3x3Compile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t result;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_8;
  }
  if (!a3)
  {
LABEL_8:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v5 = *a4;
  v6 = *(_QWORD *)(a1 + 8);
  v7 = *(_QWORD *)a2;
  if (*(_BYTE *)(*(_QWORD *)a2 + 96) == 1)
  {
    v8 = *(_QWORD **)(v7 + 16);
    v9 = v7 + 112;
    LODWORD(v14) = 3;
    v16 = 0;
    v17 = 0;
    v15 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 223), (uint64_t)&v14);
    v14 = v8[225] - 1;
    re::DynamicArray<unsigned long>::add(v8 + 16, &v14);
    re::DynamicArray<re::Matrix3x3<float>>::add((_anonymous_namespace_ *)(v8 + 56), v9);
    v10 = (uint64_t *)(v8[20] + 8 * v8[18] - 8);
  }
  else
  {
    v10 = (uint64_t *)(v7 + 176);
  }
  v11 = *v10;
  LODWORD(v14) = 33;
  v16 = 0;
  v17 = 0;
  v15 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v6 + 1784), (uint64_t)&v14);
  v12 = *(_QWORD *)(v6 + 1800) - 1;
  *(_QWORD *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix3x3<float>>(v6 + 1664, v12) + 8) = v11;
  *(_BYTE *)(v5 + 96) = 2;
  *(_QWORD *)(v5 + 176) = v12;
  return 1;
}

uint64_t re::PassthroughRigHierarchyCompile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  __int128 *v5;
  uint64_t v6;
  __int128 v7;
  uint64_t result;

  if (a5)
  {
    if (a3)
    {
      v5 = *(__int128 **)(*(_QWORD *)a2 + 184);
      v6 = *(_QWORD *)(*(_QWORD *)a4 + 184);
      v7 = *v5;
      *(_QWORD *)(v6 + 16) = *((_QWORD *)v5 + 2);
      *(_OWORD *)v6 = v7;
      re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v6 + 24, (uint64_t)v5 + 24);
      re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v6 + 72, (uint64_t)v5 + 72);
      re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::operator=(v6 + 120, (uint64_t *)v5 + 15);
      re::DynamicArray<re::DynamicArray<re::RigDataValue>>::operator=(v6 + 160, (uint64_t *)v5 + 20);
      re::DynamicArray<re::StringID>::operator=(v6 + 200, (uint64_t *)v5 + 25);
      re::DynamicArray<unsigned long>::operator=(v6 + 240, (uint64_t *)v5 + 30);
      re::DynamicArray<re::RigHierarchyJointTransform>::operator=(v6 + 280, (uint64_t *)v5 + 35);
      re::DynamicArray<unsigned long>::operator=(v6 + 320, (uint64_t *)v5 + 40);
      return 1;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
  }
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::GetBindPoseRigHierarchyCompile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  __int128 v7;
  uint64_t result;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13[5];
  uint64_t v14[5];
  uint64_t v15[5];
  uint64_t v16[5];
  uint64_t v17[5];
  uint64_t v18[5];

  if (a5)
  {
    if (a3)
    {
      v5 = *a4;
      re::RigHierarchy::getBindPoseHierarchy(*(re::RigHierarchy **)(*(_QWORD *)a2 + 184), a2, (uint64_t)&v9);
      v6 = *(_QWORD *)(v5 + 184);
      v7 = v9;
      *(_QWORD *)(v6 + 16) = v10;
      *(_OWORD *)v6 = v7;
      re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v6 + 24, (uint64_t)&v11);
      re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v6 + 72, (uint64_t)&v12);
      re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::operator=(v6 + 120, v13);
      re::DynamicArray<re::DynamicArray<re::RigDataValue>>::operator=(v6 + 160, v14);
      re::DynamicArray<re::StringID>::operator=(v6 + 200, v15);
      re::DynamicArray<unsigned long>::operator=(v6 + 240, v16);
      re::DynamicArray<re::RigHierarchyJointTransform>::operator=(v6 + 280, v17);
      re::DynamicArray<unsigned long>::operator=(v6 + 320, v18);
      re::RigHierarchy::~RigHierarchy((re::RigHierarchy *)&v9);
      return 1;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
  }
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::AddVector3Compile(uint64_t a1, __n128 **a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v7;
  uint64_t v8;
  __n128 *v9;
  _QWORD *v10;
  __n128 *v11;
  __n128 *v12;
  unint64_t v13;
  __n128 *v14;
  _QWORD *v15;
  __n128 *v16;
  __n128 *v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t result;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (!a3)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v7 = *a4;
  v8 = *(_QWORD *)(a1 + 8);
  v9 = *a2;
  if ((*a2)[6].n128_u8[0] == 1)
  {
    v10 = (_QWORD *)v9[1].n128_u64[0];
    v11 = v9 + 7;
    LODWORD(v22) = 7;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v10 + 243), (uint64_t)&v22);
    v22 = v10[245] - 1;
    re::DynamicArray<unsigned long>::add(v10 + 36, &v22);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v10 + 76), v11);
    v12 = (__n128 *)(v10[40] + 8 * v10[38] - 8);
  }
  else
  {
    v12 = v9 + 11;
  }
  if (a3 <= 1)
    goto LABEL_13;
  v13 = v12->n128_u64[0];
  v14 = a2[1];
  if (v14[6].n128_u8[0] == 1)
  {
    v15 = (_QWORD *)v14[1].n128_u64[0];
    v16 = v14 + 7;
    LODWORD(v22) = 7;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 243), (uint64_t)&v22);
    v22 = v15[245] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 36, &v22);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v15 + 76), v16);
    v17 = (__n128 *)(v15[40] + 8 * v15[38] - 8);
  }
  else
  {
    v17 = v14 + 11;
  }
  v18 = v17->n128_u64[0];
  LODWORD(v22) = 8;
  v24 = 0;
  v25 = 0;
  v23 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 1944), (uint64_t)&v22);
  v19 = *(_QWORD *)(v8 + 1960) - 1;
  v20 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v8 + 1664, v19);
  *(_QWORD *)(v20 + 8) = v13;
  *(_QWORD *)(v20 + 16) = v18;
  *(_BYTE *)(v7 + 96) = 2;
  *(_QWORD *)(v7 + 176) = v19;
  return 1;
}

uint64_t re::AddVector2Compile(uint64_t a1, _QWORD *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  uint64_t *v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t result;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (!a3)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v7 = *a4;
  v8 = *(_QWORD *)(a1 + 8);
  v9 = (_QWORD *)*a2;
  if (*(_BYTE *)(*a2 + 96) == 1)
  {
    v10 = (_QWORD *)v9[2];
    v11 = v9 + 14;
    LODWORD(v22) = 6;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v10 + 238), (uint64_t)&v22);
    v22 = v10[240] - 1;
    re::DynamicArray<unsigned long>::add(v10 + 31, &v22);
    re::DynamicArray<unsigned long>::add(v10 + 71, v11);
    v12 = (uint64_t *)(v10[35] + 8 * v10[33] - 8);
  }
  else
  {
    v12 = v9 + 22;
  }
  if (a3 <= 1)
    goto LABEL_13;
  v13 = *v12;
  v14 = a2[1];
  if (*(_BYTE *)(v14 + 96) == 1)
  {
    v15 = *(_QWORD **)(v14 + 16);
    v16 = (_QWORD *)(v14 + 112);
    LODWORD(v22) = 6;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 238), (uint64_t)&v22);
    v22 = v15[240] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 31, &v22);
    re::DynamicArray<unsigned long>::add(v15 + 71, v16);
    v17 = (uint64_t *)(v15[35] + 8 * v15[33] - 8);
  }
  else
  {
    v17 = (uint64_t *)(v14 + 176);
  }
  v18 = *v17;
  LODWORD(v22) = 9;
  v24 = 0;
  v25 = 0;
  v23 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 1904), (uint64_t)&v22);
  v19 = *(_QWORD *)(v8 + 1920) - 1;
  v20 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector2<float>>(v8 + 1664, v19);
  *(_QWORD *)(v20 + 8) = v13;
  *(_QWORD *)(v20 + 16) = v18;
  *(_BYTE *)(v7 + 96) = 2;
  *(_QWORD *)(v7 + 176) = v19;
  return 1;
}

uint64_t re::AddFloatCompile(uint64_t a1, _QWORD *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  float *v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  float *v16;
  uint64_t *v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t result;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (!a3)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v7 = *a4;
  v8 = *(_QWORD *)(a1 + 8);
  v9 = *a2;
  if (*(_BYTE *)(*a2 + 96) == 1)
  {
    v10 = *(_QWORD **)(v9 + 16);
    v11 = (float *)(v9 + 112);
    LODWORD(v22) = 2;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v10 + 218), (uint64_t)&v22);
    v22 = v10[220] - 1;
    re::DynamicArray<unsigned long>::add(v10 + 11, &v22);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v10 + 51), v11);
    v12 = (uint64_t *)(v10[15] + 8 * v10[13] - 8);
  }
  else
  {
    v12 = (uint64_t *)(v9 + 176);
  }
  if (a3 <= 1)
    goto LABEL_13;
  v13 = *v12;
  v14 = a2[1];
  if (*(_BYTE *)(v14 + 96) == 1)
  {
    v15 = *(_QWORD **)(v14 + 16);
    v16 = (float *)(v14 + 112);
    LODWORD(v22) = 2;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 218), (uint64_t)&v22);
    v22 = v15[220] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 11, &v22);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v15 + 51), v16);
    v17 = (uint64_t *)(v15[15] + 8 * v15[13] - 8);
  }
  else
  {
    v17 = (uint64_t *)(v14 + 176);
  }
  v18 = *v17;
  LODWORD(v22) = 49;
  v24 = 0;
  v25 = 0;
  v23 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 1744), (uint64_t)&v22);
  v19 = *(_QWORD *)(v8 + 1760) - 1;
  v20 = re::DynamicEvaluationRegisterTable::evaluationRegister<float>(v8 + 1664, v19);
  *(_QWORD *)(v20 + 8) = v13;
  *(_QWORD *)(v20 + 16) = v18;
  *(_BYTE *)(v7 + 96) = 2;
  *(_QWORD *)(v7 + 176) = v19;
  return 1;
}

uint64_t re::SubtractVector3Compile(uint64_t a1, __n128 **a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v7;
  uint64_t v8;
  __n128 *v9;
  _QWORD *v10;
  __n128 *v11;
  __n128 *v12;
  unint64_t v13;
  __n128 *v14;
  _QWORD *v15;
  __n128 *v16;
  __n128 *v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t result;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (!a3)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v7 = *a4;
  v8 = *(_QWORD *)(a1 + 8);
  v9 = *a2;
  if ((*a2)[6].n128_u8[0] == 1)
  {
    v10 = (_QWORD *)v9[1].n128_u64[0];
    v11 = v9 + 7;
    LODWORD(v22) = 7;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v10 + 243), (uint64_t)&v22);
    v22 = v10[245] - 1;
    re::DynamicArray<unsigned long>::add(v10 + 36, &v22);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v10 + 76), v11);
    v12 = (__n128 *)(v10[40] + 8 * v10[38] - 8);
  }
  else
  {
    v12 = v9 + 11;
  }
  if (a3 <= 1)
    goto LABEL_13;
  v13 = v12->n128_u64[0];
  v14 = a2[1];
  if (v14[6].n128_u8[0] == 1)
  {
    v15 = (_QWORD *)v14[1].n128_u64[0];
    v16 = v14 + 7;
    LODWORD(v22) = 7;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 243), (uint64_t)&v22);
    v22 = v15[245] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 36, &v22);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v15 + 76), v16);
    v17 = (__n128 *)(v15[40] + 8 * v15[38] - 8);
  }
  else
  {
    v17 = v14 + 11;
  }
  v18 = v17->n128_u64[0];
  LODWORD(v22) = 31;
  v24 = 0;
  v25 = 0;
  v23 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 1944), (uint64_t)&v22);
  v19 = *(_QWORD *)(v8 + 1960) - 1;
  v20 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v8 + 1664, v19);
  *(_QWORD *)(v20 + 8) = v13;
  *(_QWORD *)(v20 + 16) = v18;
  *(_BYTE *)(v7 + 96) = 2;
  *(_QWORD *)(v7 + 176) = v19;
  return 1;
}

uint64_t re::SubtractVector2Compile(uint64_t a1, _QWORD *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  uint64_t *v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t result;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (!a3)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v7 = *a4;
  v8 = *(_QWORD *)(a1 + 8);
  v9 = (_QWORD *)*a2;
  if (*(_BYTE *)(*a2 + 96) == 1)
  {
    v10 = (_QWORD *)v9[2];
    v11 = v9 + 14;
    LODWORD(v22) = 6;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v10 + 238), (uint64_t)&v22);
    v22 = v10[240] - 1;
    re::DynamicArray<unsigned long>::add(v10 + 31, &v22);
    re::DynamicArray<unsigned long>::add(v10 + 71, v11);
    v12 = (uint64_t *)(v10[35] + 8 * v10[33] - 8);
  }
  else
  {
    v12 = v9 + 22;
  }
  if (a3 <= 1)
    goto LABEL_13;
  v13 = *v12;
  v14 = a2[1];
  if (*(_BYTE *)(v14 + 96) == 1)
  {
    v15 = *(_QWORD **)(v14 + 16);
    v16 = (_QWORD *)(v14 + 112);
    LODWORD(v22) = 6;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 238), (uint64_t)&v22);
    v22 = v15[240] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 31, &v22);
    re::DynamicArray<unsigned long>::add(v15 + 71, v16);
    v17 = (uint64_t *)(v15[35] + 8 * v15[33] - 8);
  }
  else
  {
    v17 = (uint64_t *)(v14 + 176);
  }
  v18 = *v17;
  LODWORD(v22) = 32;
  v24 = 0;
  v25 = 0;
  v23 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 1904), (uint64_t)&v22);
  v19 = *(_QWORD *)(v8 + 1920) - 1;
  v20 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector2<float>>(v8 + 1664, v19);
  *(_QWORD *)(v20 + 8) = v13;
  *(_QWORD *)(v20 + 16) = v18;
  *(_BYTE *)(v7 + 96) = 2;
  *(_QWORD *)(v7 + 176) = v19;
  return 1;
}

uint64_t re::SubtractFloatCompile(uint64_t a1, _QWORD *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  float *v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  float *v16;
  uint64_t *v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t result;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (!a3)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v7 = *a4;
  v8 = *(_QWORD *)(a1 + 8);
  v9 = *a2;
  if (*(_BYTE *)(*a2 + 96) == 1)
  {
    v10 = *(_QWORD **)(v9 + 16);
    v11 = (float *)(v9 + 112);
    LODWORD(v22) = 2;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v10 + 218), (uint64_t)&v22);
    v22 = v10[220] - 1;
    re::DynamicArray<unsigned long>::add(v10 + 11, &v22);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v10 + 51), v11);
    v12 = (uint64_t *)(v10[15] + 8 * v10[13] - 8);
  }
  else
  {
    v12 = (uint64_t *)(v9 + 176);
  }
  if (a3 <= 1)
    goto LABEL_13;
  v13 = *v12;
  v14 = a2[1];
  if (*(_BYTE *)(v14 + 96) == 1)
  {
    v15 = *(_QWORD **)(v14 + 16);
    v16 = (float *)(v14 + 112);
    LODWORD(v22) = 2;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 218), (uint64_t)&v22);
    v22 = v15[220] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 11, &v22);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v15 + 51), v16);
    v17 = (uint64_t *)(v15[15] + 8 * v15[13] - 8);
  }
  else
  {
    v17 = (uint64_t *)(v14 + 176);
  }
  v18 = *v17;
  LODWORD(v22) = 50;
  v24 = 0;
  v25 = 0;
  v23 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 1744), (uint64_t)&v22);
  v19 = *(_QWORD *)(v8 + 1760) - 1;
  v20 = re::DynamicEvaluationRegisterTable::evaluationRegister<float>(v8 + 1664, v19);
  *(_QWORD *)(v20 + 8) = v13;
  *(_QWORD *)(v20 + 16) = v18;
  *(_BYTE *)(v7 + 96) = 2;
  *(_QWORD *)(v7 + 176) = v19;
  return 1;
}

uint64_t re::DivideQuaternionCompile(uint64_t a1, __n128 **a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v7;
  uint64_t v8;
  __n128 *v9;
  _QWORD *v10;
  __n128 *v11;
  __n128 *v12;
  unint64_t v13;
  __n128 *v14;
  _QWORD *v15;
  __n128 *v16;
  __n128 *v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t result;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (!a3)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v7 = *a4;
  v8 = *(_QWORD *)(a1 + 8);
  v9 = *a2;
  if ((*a2)[6].n128_u8[0] == 1)
  {
    v10 = (_QWORD *)v9[1].n128_u64[0];
    v11 = v9 + 7;
    LODWORD(v22) = 5;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v10 + 233), (uint64_t)&v22);
    v22 = v10[235] - 1;
    re::DynamicArray<unsigned long>::add(v10 + 26, &v22);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v10 + 66), v11);
    v12 = (__n128 *)(v10[30] + 8 * v10[28] - 8);
  }
  else
  {
    v12 = v9 + 11;
  }
  if (a3 <= 1)
    goto LABEL_13;
  v13 = v12->n128_u64[0];
  v14 = a2[1];
  if (v14[6].n128_u8[0] == 1)
  {
    v15 = (_QWORD *)v14[1].n128_u64[0];
    v16 = v14 + 7;
    LODWORD(v22) = 5;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 233), (uint64_t)&v22);
    v22 = v15[235] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 26, &v22);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v15 + 66), v16);
    v17 = (__n128 *)(v15[30] + 8 * v15[28] - 8);
  }
  else
  {
    v17 = v14 + 11;
  }
  v18 = v17->n128_u64[0];
  LODWORD(v22) = 16;
  v24 = 0;
  v25 = 0;
  v23 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 1864), (uint64_t)&v22);
  v19 = *(_QWORD *)(v8 + 1880) - 1;
  v20 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Quaternion<float>>(v8 + 1664, v19);
  *(_QWORD *)(v20 + 8) = v13;
  *(_QWORD *)(v20 + 16) = v18;
  *(_BYTE *)(v7 + 96) = 2;
  *(_QWORD *)(v7 + 176) = v19;
  return 1;
}

uint64_t re::DivideFloatCompile(uint64_t a1, _QWORD *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  float *v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  float *v16;
  uint64_t *v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t result;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (!a3)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v7 = *a4;
  v8 = *(_QWORD *)(a1 + 8);
  v9 = *a2;
  if (*(_BYTE *)(*a2 + 96) == 1)
  {
    v10 = *(_QWORD **)(v9 + 16);
    v11 = (float *)(v9 + 112);
    LODWORD(v22) = 2;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v10 + 218), (uint64_t)&v22);
    v22 = v10[220] - 1;
    re::DynamicArray<unsigned long>::add(v10 + 11, &v22);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v10 + 51), v11);
    v12 = (uint64_t *)(v10[15] + 8 * v10[13] - 8);
  }
  else
  {
    v12 = (uint64_t *)(v9 + 176);
  }
  if (a3 <= 1)
    goto LABEL_13;
  v13 = *v12;
  v14 = a2[1];
  if (*(_BYTE *)(v14 + 96) == 1)
  {
    v15 = *(_QWORD **)(v14 + 16);
    v16 = (float *)(v14 + 112);
    LODWORD(v22) = 2;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 218), (uint64_t)&v22);
    v22 = v15[220] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 11, &v22);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v15 + 51), v16);
    v17 = (uint64_t *)(v15[15] + 8 * v15[13] - 8);
  }
  else
  {
    v17 = (uint64_t *)(v14 + 176);
  }
  v18 = *v17;
  LODWORD(v22) = 52;
  v24 = 0;
  v25 = 0;
  v23 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 1744), (uint64_t)&v22);
  v19 = *(_QWORD *)(v8 + 1760) - 1;
  v20 = re::DynamicEvaluationRegisterTable::evaluationRegister<float>(v8 + 1664, v19);
  *(_QWORD *)(v20 + 8) = v13;
  *(_QWORD *)(v20 + 16) = v18;
  *(_BYTE *)(v7 + 96) = 2;
  *(_QWORD *)(v7 + 176) = v19;
  return 1;
}

uint64_t re::MultiplyFloatCompile(uint64_t a1, _QWORD *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  float *v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  float *v16;
  uint64_t *v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t result;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (!a3)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v7 = *a4;
  v8 = *(_QWORD *)(a1 + 8);
  v9 = *a2;
  if (*(_BYTE *)(*a2 + 96) == 1)
  {
    v10 = *(_QWORD **)(v9 + 16);
    v11 = (float *)(v9 + 112);
    LODWORD(v22) = 2;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v10 + 218), (uint64_t)&v22);
    v22 = v10[220] - 1;
    re::DynamicArray<unsigned long>::add(v10 + 11, &v22);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v10 + 51), v11);
    v12 = (uint64_t *)(v10[15] + 8 * v10[13] - 8);
  }
  else
  {
    v12 = (uint64_t *)(v9 + 176);
  }
  if (a3 <= 1)
    goto LABEL_13;
  v13 = *v12;
  v14 = a2[1];
  if (*(_BYTE *)(v14 + 96) == 1)
  {
    v15 = *(_QWORD **)(v14 + 16);
    v16 = (float *)(v14 + 112);
    LODWORD(v22) = 2;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 218), (uint64_t)&v22);
    v22 = v15[220] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 11, &v22);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v15 + 51), v16);
    v17 = (uint64_t *)(v15[15] + 8 * v15[13] - 8);
  }
  else
  {
    v17 = (uint64_t *)(v14 + 176);
  }
  v18 = *v17;
  LODWORD(v22) = 51;
  v24 = 0;
  v25 = 0;
  v23 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 1744), (uint64_t)&v22);
  v19 = *(_QWORD *)(v8 + 1760) - 1;
  v20 = re::DynamicEvaluationRegisterTable::evaluationRegister<float>(v8 + 1664, v19);
  *(_QWORD *)(v20 + 8) = v13;
  *(_QWORD *)(v20 + 16) = v18;
  *(_BYTE *)(v7 + 96) = 2;
  *(_QWORD *)(v7 + 176) = v19;
  return 1;
}

uint64_t re::ConjugateQuaternionCompile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  __n128 *v7;
  _QWORD *v8;
  __n128 *v9;
  __n128 *v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t result;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_8;
  }
  if (!a3)
  {
LABEL_8:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v5 = *a4;
  v6 = *(_QWORD *)(a1 + 8);
  v7 = *(__n128 **)a2;
  if (*(_BYTE *)(*(_QWORD *)a2 + 96) == 1)
  {
    v8 = (_QWORD *)v7[1].n128_u64[0];
    v9 = v7 + 7;
    LODWORD(v14) = 5;
    v16 = 0;
    v17 = 0;
    v15 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 233), (uint64_t)&v14);
    v14 = v8[235] - 1;
    re::DynamicArray<unsigned long>::add(v8 + 26, &v14);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v8 + 66), v9);
    v10 = (__n128 *)(v8[30] + 8 * v8[28] - 8);
  }
  else
  {
    v10 = v7 + 11;
  }
  v11 = v10->n128_u64[0];
  LODWORD(v14) = 18;
  v16 = 0;
  v17 = 0;
  v15 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v6 + 1864), (uint64_t)&v14);
  v12 = *(_QWORD *)(v6 + 1880) - 1;
  *(_QWORD *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Quaternion<float>>(v6 + 1664, v12) + 8) = v11;
  *(_BYTE *)(v5 + 96) = 2;
  *(_QWORD *)(v5 + 176) = v12;
  return 1;
}

uint64_t re::InvertQuaternionCompile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  __n128 *v7;
  _QWORD *v8;
  __n128 *v9;
  __n128 *v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t result;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_8;
  }
  if (!a3)
  {
LABEL_8:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v5 = *a4;
  v6 = *(_QWORD *)(a1 + 8);
  v7 = *(__n128 **)a2;
  if (*(_BYTE *)(*(_QWORD *)a2 + 96) == 1)
  {
    v8 = (_QWORD *)v7[1].n128_u64[0];
    v9 = v7 + 7;
    LODWORD(v14) = 5;
    v16 = 0;
    v17 = 0;
    v15 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 233), (uint64_t)&v14);
    v14 = v8[235] - 1;
    re::DynamicArray<unsigned long>::add(v8 + 26, &v14);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v8 + 66), v9);
    v10 = (__n128 *)(v8[30] + 8 * v8[28] - 8);
  }
  else
  {
    v10 = v7 + 11;
  }
  v11 = v10->n128_u64[0];
  LODWORD(v14) = 21;
  v16 = 0;
  v17 = 0;
  v15 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v6 + 1864), (uint64_t)&v14);
  v12 = *(_QWORD *)(v6 + 1880) - 1;
  *(_QWORD *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Quaternion<float>>(v6 + 1664, v12) + 8) = v11;
  *(_BYTE *)(v5 + 96) = 2;
  *(_QWORD *)(v5 + 176) = v12;
  return 1;
}

uint64_t re::InvertMatrix3x3Compile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t result;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_8;
  }
  if (!a3)
  {
LABEL_8:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v5 = *a4;
  v6 = *(_QWORD *)(a1 + 8);
  v7 = *(_QWORD *)a2;
  if (*(_BYTE *)(*(_QWORD *)a2 + 96) == 1)
  {
    v8 = *(_QWORD **)(v7 + 16);
    v9 = v7 + 112;
    LODWORD(v14) = 3;
    v16 = 0;
    v17 = 0;
    v15 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 223), (uint64_t)&v14);
    v14 = v8[225] - 1;
    re::DynamicArray<unsigned long>::add(v8 + 16, &v14);
    re::DynamicArray<re::Matrix3x3<float>>::add((_anonymous_namespace_ *)(v8 + 56), v9);
    v10 = (uint64_t *)(v8[20] + 8 * v8[18] - 8);
  }
  else
  {
    v10 = (uint64_t *)(v7 + 176);
  }
  v11 = *v10;
  LODWORD(v14) = 19;
  v16 = 0;
  v17 = 0;
  v15 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v6 + 1784), (uint64_t)&v14);
  v12 = *(_QWORD *)(v6 + 1800) - 1;
  *(_QWORD *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix3x3<float>>(v6 + 1664, v12) + 8) = v11;
  *(_BYTE *)(v5 + 96) = 2;
  *(_QWORD *)(v5 + 176) = v12;
  return 1;
}

uint64_t re::InvertMatrix4x4Compile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t result;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_8;
  }
  if (!a3)
  {
LABEL_8:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v5 = *a4;
  v6 = *(_QWORD *)(a1 + 8);
  v7 = *(_QWORD *)a2;
  if (*(_BYTE *)(*(_QWORD *)a2 + 96) == 1)
  {
    v8 = *(_QWORD **)(v7 + 16);
    v9 = v7 + 112;
    LODWORD(v14) = 4;
    v16 = 0;
    v17 = 0;
    v15 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 228), (uint64_t)&v14);
    v14 = v8[230] - 1;
    re::DynamicArray<unsigned long>::add(v8 + 21, &v14);
    re::DynamicArray<re::Matrix4x4<float>>::add((_anonymous_namespace_ *)(v8 + 61), v9);
    v10 = (uint64_t *)(v8[25] + 8 * v8[23] - 8);
  }
  else
  {
    v10 = (uint64_t *)(v7 + 176);
  }
  v11 = *v10;
  LODWORD(v14) = 20;
  v16 = 0;
  v17 = 0;
  v15 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v6 + 1824), (uint64_t)&v14);
  v12 = *(_QWORD *)(v6 + 1840) - 1;
  *(_QWORD *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix4x4<float>>(v6 + 1664, v12) + 8) = v11;
  *(_BYTE *)(v5 + 96) = 2;
  *(_QWORD *)(v5 + 176) = v12;
  return 1;
}

uint64_t re::NormalizeVector3Compile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  __n128 *v7;
  _QWORD *v8;
  __n128 *v9;
  __n128 *v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t result;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_8;
  }
  if (!a3)
  {
LABEL_8:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v5 = *a4;
  v6 = *(_QWORD *)(a1 + 8);
  v7 = *(__n128 **)a2;
  if (*(_BYTE *)(*(_QWORD *)a2 + 96) == 1)
  {
    v8 = (_QWORD *)v7[1].n128_u64[0];
    v9 = v7 + 7;
    LODWORD(v14) = 7;
    v16 = 0;
    v17 = 0;
    v15 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 243), (uint64_t)&v14);
    v14 = v8[245] - 1;
    re::DynamicArray<unsigned long>::add(v8 + 36, &v14);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v8 + 76), v9);
    v10 = (__n128 *)(v8[40] + 8 * v8[38] - 8);
  }
  else
  {
    v10 = v7 + 11;
  }
  v11 = v10->n128_u64[0];
  LODWORD(v14) = 29;
  v16 = 0;
  v17 = 0;
  v15 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v6 + 1944), (uint64_t)&v14);
  v12 = *(_QWORD *)(v6 + 1960) - 1;
  *(_QWORD *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v6 + 1664, v12) + 8) = v11;
  *(_BYTE *)(v5 + 96) = 2;
  *(_QWORD *)(v5 + 176) = v12;
  return 1;
}

uint64_t re::RotateVector3Compile(uint64_t a1, __n128 **a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v7;
  uint64_t v8;
  __n128 *v9;
  _QWORD *v10;
  __n128 *v11;
  __n128 *v12;
  unint64_t v13;
  __n128 *v14;
  _QWORD *v15;
  __n128 *v16;
  __n128 *v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t result;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (!a3)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v7 = *a4;
  v8 = *(_QWORD *)(a1 + 8);
  v9 = *a2;
  if ((*a2)[6].n128_u8[0] == 1)
  {
    v10 = (_QWORD *)v9[1].n128_u64[0];
    v11 = v9 + 7;
    LODWORD(v22) = 5;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v10 + 233), (uint64_t)&v22);
    v22 = v10[235] - 1;
    re::DynamicArray<unsigned long>::add(v10 + 26, &v22);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v10 + 66), v11);
    v12 = (__n128 *)(v10[30] + 8 * v10[28] - 8);
  }
  else
  {
    v12 = v9 + 11;
  }
  if (a3 <= 1)
    goto LABEL_13;
  v13 = v12->n128_u64[0];
  v14 = a2[1];
  if (v14[6].n128_u8[0] == 1)
  {
    v15 = (_QWORD *)v14[1].n128_u64[0];
    v16 = v14 + 7;
    LODWORD(v22) = 7;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 243), (uint64_t)&v22);
    v22 = v15[245] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 36, &v22);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v15 + 76), v16);
    v17 = (__n128 *)(v15[40] + 8 * v15[38] - 8);
  }
  else
  {
    v17 = v14 + 11;
  }
  v18 = v17->n128_u64[0];
  LODWORD(v22) = 30;
  v24 = 0;
  v25 = 0;
  v23 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 1944), (uint64_t)&v22);
  v19 = *(_QWORD *)(v8 + 1960) - 1;
  v20 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v8 + 1664, v19);
  *(_QWORD *)(v20 + 8) = v13;
  *(_QWORD *)(v20 + 16) = v18;
  *(_BYTE *)(v7 + 96) = 2;
  *(_QWORD *)(v7 + 176) = v19;
  return 1;
}

uint64_t re::MultiplyQuaternionCompile(uint64_t a1, __n128 **a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v7;
  uint64_t v8;
  __n128 *v9;
  _QWORD *v10;
  __n128 *v11;
  __n128 *v12;
  unint64_t v13;
  __n128 *v14;
  _QWORD *v15;
  __n128 *v16;
  __n128 *v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t result;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (!a3)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v7 = *a4;
  v8 = *(_QWORD *)(a1 + 8);
  v9 = *a2;
  if ((*a2)[6].n128_u8[0] == 1)
  {
    v10 = (_QWORD *)v9[1].n128_u64[0];
    v11 = v9 + 7;
    LODWORD(v22) = 5;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v10 + 233), (uint64_t)&v22);
    v22 = v10[235] - 1;
    re::DynamicArray<unsigned long>::add(v10 + 26, &v22);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v10 + 66), v11);
    v12 = (__n128 *)(v10[30] + 8 * v10[28] - 8);
  }
  else
  {
    v12 = v9 + 11;
  }
  if (a3 <= 1)
    goto LABEL_13;
  v13 = v12->n128_u64[0];
  v14 = a2[1];
  if (v14[6].n128_u8[0] == 1)
  {
    v15 = (_QWORD *)v14[1].n128_u64[0];
    v16 = v14 + 7;
    LODWORD(v22) = 5;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 233), (uint64_t)&v22);
    v22 = v15[235] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 26, &v22);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v15 + 66), v16);
    v17 = (__n128 *)(v15[30] + 8 * v15[28] - 8);
  }
  else
  {
    v17 = v14 + 11;
  }
  v18 = v17->n128_u64[0];
  LODWORD(v22) = 24;
  v24 = 0;
  v25 = 0;
  v23 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 1864), (uint64_t)&v22);
  v19 = *(_QWORD *)(v8 + 1880) - 1;
  v20 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Quaternion<float>>(v8 + 1664, v19);
  *(_QWORD *)(v20 + 8) = v13;
  *(_QWORD *)(v20 + 16) = v18;
  *(_BYTE *)(v7 + 96) = 2;
  *(_QWORD *)(v7 + 176) = v19;
  return 1;
}

uint64_t re::MultiplyMatrix3x3Compile(uint64_t a1, _QWORD *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t result;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (!a3)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v7 = *a4;
  v8 = *(_QWORD *)(a1 + 8);
  v9 = *a2;
  if (*(_BYTE *)(*a2 + 96) == 1)
  {
    v10 = *(_QWORD **)(v9 + 16);
    v11 = v9 + 112;
    LODWORD(v22) = 3;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v10 + 223), (uint64_t)&v22);
    v22 = v10[225] - 1;
    re::DynamicArray<unsigned long>::add(v10 + 16, &v22);
    re::DynamicArray<re::Matrix3x3<float>>::add((_anonymous_namespace_ *)(v10 + 56), v11);
    v12 = (uint64_t *)(v10[20] + 8 * v10[18] - 8);
  }
  else
  {
    v12 = (uint64_t *)(v9 + 176);
  }
  if (a3 <= 1)
    goto LABEL_13;
  v13 = *v12;
  v14 = a2[1];
  if (*(_BYTE *)(v14 + 96) == 1)
  {
    v15 = *(_QWORD **)(v14 + 16);
    v16 = v14 + 112;
    LODWORD(v22) = 3;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 223), (uint64_t)&v22);
    v22 = v15[225] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 16, &v22);
    re::DynamicArray<re::Matrix3x3<float>>::add((_anonymous_namespace_ *)(v15 + 56), v16);
    v17 = (uint64_t *)(v15[20] + 8 * v15[18] - 8);
  }
  else
  {
    v17 = (uint64_t *)(v14 + 176);
  }
  v18 = *v17;
  LODWORD(v22) = 27;
  v24 = 0;
  v25 = 0;
  v23 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 1784), (uint64_t)&v22);
  v19 = *(_QWORD *)(v8 + 1800) - 1;
  v20 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix3x3<float>>(v8 + 1664, v19);
  *(_QWORD *)(v20 + 8) = v13;
  *(_QWORD *)(v20 + 16) = v18;
  *(_BYTE *)(v7 + 96) = 2;
  *(_QWORD *)(v7 + 176) = v19;
  return 1;
}

uint64_t re::MultiplyMatrix4x4Compile(uint64_t a1, _QWORD *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t result;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (!a3)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v7 = *a4;
  v8 = *(_QWORD *)(a1 + 8);
  v9 = *a2;
  if (*(_BYTE *)(*a2 + 96) == 1)
  {
    v10 = *(_QWORD **)(v9 + 16);
    v11 = v9 + 112;
    LODWORD(v22) = 4;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v10 + 228), (uint64_t)&v22);
    v22 = v10[230] - 1;
    re::DynamicArray<unsigned long>::add(v10 + 21, &v22);
    re::DynamicArray<re::Matrix4x4<float>>::add((_anonymous_namespace_ *)(v10 + 61), v11);
    v12 = (uint64_t *)(v10[25] + 8 * v10[23] - 8);
  }
  else
  {
    v12 = (uint64_t *)(v9 + 176);
  }
  if (a3 <= 1)
    goto LABEL_13;
  v13 = *v12;
  v14 = a2[1];
  if (*(_BYTE *)(v14 + 96) == 1)
  {
    v15 = *(_QWORD **)(v14 + 16);
    v16 = v14 + 112;
    LODWORD(v22) = 4;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 228), (uint64_t)&v22);
    v22 = v15[230] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 21, &v22);
    re::DynamicArray<re::Matrix4x4<float>>::add((_anonymous_namespace_ *)(v15 + 61), v16);
    v17 = (uint64_t *)(v15[25] + 8 * v15[23] - 8);
  }
  else
  {
    v17 = (uint64_t *)(v14 + 176);
  }
  v18 = *v17;
  LODWORD(v22) = 28;
  v24 = 0;
  v25 = 0;
  v23 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 1824), (uint64_t)&v22);
  v19 = *(_QWORD *)(v8 + 1840) - 1;
  v20 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix4x4<float>>(v8 + 1664, v19);
  *(_QWORD *)(v20 + 8) = v13;
  *(_QWORD *)(v20 + 16) = v18;
  *(_BYTE *)(v7 + 96) = 2;
  *(_QWORD *)(v7 + 176) = v19;
  return 1;
}

uint64_t re::MultiplyVector3Compile(uint64_t a1, __n128 **a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v7;
  uint64_t v8;
  __n128 *v9;
  _QWORD *v10;
  __n128 *v11;
  __n128 *v12;
  unint64_t v13;
  __n128 *v14;
  _QWORD *v15;
  __n128 *v16;
  __n128 *v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t result;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (!a3)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v7 = *a4;
  v8 = *(_QWORD *)(a1 + 8);
  v9 = *a2;
  if ((*a2)[6].n128_u8[0] == 1)
  {
    v10 = (_QWORD *)v9[1].n128_u64[0];
    v11 = v9 + 7;
    LODWORD(v22) = 7;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v10 + 243), (uint64_t)&v22);
    v22 = v10[245] - 1;
    re::DynamicArray<unsigned long>::add(v10 + 36, &v22);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v10 + 76), v11);
    v12 = (__n128 *)(v10[40] + 8 * v10[38] - 8);
  }
  else
  {
    v12 = v9 + 11;
  }
  if (a3 <= 1)
    goto LABEL_13;
  v13 = v12->n128_u64[0];
  v14 = a2[1];
  if (v14[6].n128_u8[0] == 1)
  {
    v15 = (_QWORD *)v14[1].n128_u64[0];
    v16 = v14 + 7;
    LODWORD(v22) = 7;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 243), (uint64_t)&v22);
    v22 = v15[245] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 36, &v22);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v15 + 76), v16);
    v17 = (__n128 *)(v15[40] + 8 * v15[38] - 8);
  }
  else
  {
    v17 = v14 + 11;
  }
  v18 = v17->n128_u64[0];
  LODWORD(v22) = 25;
  v24 = 0;
  v25 = 0;
  v23 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 1944), (uint64_t)&v22);
  v19 = *(_QWORD *)(v8 + 1960) - 1;
  v20 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v8 + 1664, v19);
  *(_QWORD *)(v20 + 8) = v13;
  *(_QWORD *)(v20 + 16) = v18;
  *(_BYTE *)(v7 + 96) = 2;
  *(_QWORD *)(v7 + 176) = v19;
  return 1;
}

uint64_t re::ScaleVector3Compile(uint64_t a1, __n128 **a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v7;
  uint64_t v8;
  __n128 *v9;
  _QWORD *v10;
  __n128 *v11;
  __n128 *v12;
  unint64_t v13;
  __n128 *v14;
  _QWORD *v15;
  float *v16;
  __n128 *v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t result;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (!a3)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v7 = *a4;
  v8 = *(_QWORD *)(a1 + 8);
  v9 = *a2;
  if ((*a2)[6].n128_u8[0] == 1)
  {
    v10 = (_QWORD *)v9[1].n128_u64[0];
    v11 = v9 + 7;
    LODWORD(v22) = 7;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v10 + 243), (uint64_t)&v22);
    v22 = v10[245] - 1;
    re::DynamicArray<unsigned long>::add(v10 + 36, &v22);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v10 + 76), v11);
    v12 = (__n128 *)(v10[40] + 8 * v10[38] - 8);
  }
  else
  {
    v12 = v9 + 11;
  }
  if (a3 <= 1)
    goto LABEL_13;
  v13 = v12->n128_u64[0];
  v14 = a2[1];
  if (v14[6].n128_u8[0] == 1)
  {
    v15 = (_QWORD *)v14[1].n128_u64[0];
    v16 = (float *)&v14[7];
    LODWORD(v22) = 2;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 218), (uint64_t)&v22);
    v22 = v15[220] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 11, &v22);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v15 + 51), v16);
    v17 = (__n128 *)(v15[15] + 8 * v15[13] - 8);
  }
  else
  {
    v17 = v14 + 11;
  }
  v18 = v17->n128_u64[0];
  LODWORD(v22) = 26;
  v24 = 0;
  v25 = 0;
  v23 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 1944), (uint64_t)&v22);
  v19 = *(_QWORD *)(v8 + 1960) - 1;
  v20 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v8 + 1664, v19);
  *(_QWORD *)(v20 + 8) = v13;
  *(_QWORD *)(v20 + 16) = v18;
  *(_BYTE *)(v7 + 96) = 2;
  *(_QWORD *)(v7 + 176) = v19;
  return 1;
}

uint64_t re::ClampCompile(re::Allocator **a1, const re::RigDataValue **a2, unint64_t a3, re::RigDataValue **a4, uint64_t a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t result;
  StringID v15;
  _OWORD v16[2];
  int v17;
  _OWORD v18[2];
  int v19;
  uint64_t v20;

  v20 = 0;
  memset(v16, 0, sizeof(v16));
  v17 = 0;
  memset(v18, 0, sizeof(v18));
  v19 = 0;
  re::RigGraphCallbackBuilder::init((re::RigGraphCallbackBuilder *)v16, *a1);
  *(_QWORD *)&v15.var0 = 223945442;
  v15.var1 = "value";
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, v10, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0, *(_QWORD *)&v15.var0, v15.var1);
    _os_crash();
    __break(1u);
    goto LABEL_7;
  }
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v16, &v15, *a2);
  re::StringID::destroyString((re::StringID *)&v15);
  *(_QWORD *)&v15.var0 = 216228;
  v15.var1 = "min";
  if (a3 == 1)
  {
LABEL_7:
    re::internal::assertLog((re::internal *)6, v11, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1, *(_QWORD *)&v15.var0, v15.var1);
    _os_crash();
    __break(1u);
    goto LABEL_8;
  }
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v16, &v15, a2[1]);
  re::StringID::destroyString((re::StringID *)&v15);
  *(_QWORD *)&v15.var0 = 215752;
  v15.var1 = "max";
  if (a3 <= 2)
  {
LABEL_8:
    re::internal::assertLog((re::internal *)6, v12, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2, *(_QWORD *)&v15.var0, v15.var1);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v16, &v15, a2[2]);
  re::StringID::destroyString((re::StringID *)&v15);
  *(_QWORD *)&v15.var0 = 0x188223202;
  v15.var1 = "output";
  if (a5)
  {
    re::RigGraphCallbackBuilder::addOutputParam((re::RigGraphCallbackBuilder *)v16, &v15, *a4);
    re::StringID::destroyString((re::StringID *)&v15);
    re::RigGraphCallbackBuilder::buildCallbackData((unint64_t *)v16, (uint64_t)a1, (uint64_t)re::ClampCompile(re::RigGraphSystem &,re::Slice<re::RigDataValue const*>,re::Slice<re::RigDataValue*>)::$_0::__invoke, 0);
    re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)v18 + 8);
    re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)v16 + 8);
    return 1;
  }
LABEL_9:
  re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0, *(_QWORD *)&v15.var0, v15.var1);
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::ClampVector3Compile(re::Allocator **a1, const re::RigDataValue **a2, unint64_t a3, re::RigDataValue **a4, uint64_t a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t result;
  StringID v15;
  _OWORD v16[2];
  int v17;
  _OWORD v18[2];
  int v19;
  uint64_t v20;

  v20 = 0;
  memset(v16, 0, sizeof(v16));
  v17 = 0;
  memset(v18, 0, sizeof(v18));
  v19 = 0;
  re::RigGraphCallbackBuilder::init((re::RigGraphCallbackBuilder *)v16, *a1);
  *(_QWORD *)&v15.var0 = 223945442;
  v15.var1 = "value";
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, v10, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0, *(_QWORD *)&v15.var0, v15.var1);
    _os_crash();
    __break(1u);
    goto LABEL_7;
  }
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v16, &v15, *a2);
  re::StringID::destroyString((re::StringID *)&v15);
  *(_QWORD *)&v15.var0 = 216228;
  v15.var1 = "min";
  if (a3 == 1)
  {
LABEL_7:
    re::internal::assertLog((re::internal *)6, v11, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1, *(_QWORD *)&v15.var0, v15.var1);
    _os_crash();
    __break(1u);
    goto LABEL_8;
  }
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v16, &v15, a2[1]);
  re::StringID::destroyString((re::StringID *)&v15);
  *(_QWORD *)&v15.var0 = 215752;
  v15.var1 = "max";
  if (a3 <= 2)
  {
LABEL_8:
    re::internal::assertLog((re::internal *)6, v12, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2, *(_QWORD *)&v15.var0, v15.var1);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v16, &v15, a2[2]);
  re::StringID::destroyString((re::StringID *)&v15);
  *(_QWORD *)&v15.var0 = 0x188223202;
  v15.var1 = "output";
  if (a5)
  {
    re::RigGraphCallbackBuilder::addOutputParam((re::RigGraphCallbackBuilder *)v16, &v15, *a4);
    re::StringID::destroyString((re::StringID *)&v15);
    re::RigGraphCallbackBuilder::buildCallbackData((unint64_t *)v16, (uint64_t)a1, (uint64_t)re::ClampVector3Compile(re::RigGraphSystem &,re::Slice<re::RigDataValue const*>,re::Slice<re::RigDataValue*>)::$_0::__invoke, 0);
    re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)v18 + 8);
    re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)v16 + 8);
    return 1;
  }
LABEL_9:
  re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0, *(_QWORD *)&v15.var0, v15.var1);
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::AdditiveBlendSRTCompile(uint64_t a1, const re::RigDataValue **a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t result;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char v25;
  const char *v26;
  uint64_t v27;
  unint64_t v28[3];

  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_18;
  }
  v9 = *(_QWORD **)(a1 + 8);
  if (a3 == 1)
  {
LABEL_18:
    re::internal::assertLog((re::internal *)6, v10, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    _os_crash();
    __break(1u);
    goto LABEL_19;
  }
  re::EvaluationTree::additiveBlend(v9, &v22, (uint64_t *)&v26, v28);
  if (!a5)
  {
LABEL_19:
    re::internal::assertLog((re::internal *)6, v11, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v12 = *a4;
  v26 = "scale";
  v27 = 5;
  re::RigDataValue::attributeValue(v12, (uint64_t)&v26, (uint64_t)&v22);
  v13 = v23;
  v14 = v28[0];
  *(_BYTE *)(v23 + 96) = 2;
  *(_QWORD *)(v13 + 176) = v14;
  if (!(_BYTE)v22 && v24 && (v25 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v24 + 40))();
  v15 = *a4;
  v26 = "rotation";
  v27 = 8;
  re::RigDataValue::attributeValue(v15, (uint64_t)&v26, (uint64_t)&v22);
  v16 = v23;
  v17 = v28[1];
  *(_BYTE *)(v23 + 96) = 2;
  *(_QWORD *)(v16 + 176) = v17;
  if (!(_BYTE)v22 && v24 && (v25 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v24 + 40))();
  v18 = *a4;
  v26 = "translation";
  v27 = 11;
  re::RigDataValue::attributeValue(v18, (uint64_t)&v26, (uint64_t)&v22);
  v19 = v23;
  v20 = v28[2];
  *(_BYTE *)(v23 + 96) = 2;
  *(_QWORD *)(v19 + 176) = v20;
  if (!(_BYTE)v22 && v24 && (v25 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v24 + 40))();
  return 1;
}

uint64_t re::LocalSpaceJointScaleCompile(uint64_t a1, _QWORD *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  _anonymous_namespace_ *v7;
  const char *v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t result;
  _QWORD v14[2];
  _BYTE v15[8];
  uint64_t v16;
  uint64_t v17;
  char v18;

  if (a3 <= 1)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, a3);
    _os_crash();
    __break(1u);
  }
  else
  {
    v7 = *(_anonymous_namespace_ **)(*a2 + 184);
    v8 = *(const char **)(a2[1] + 232);
    v14[0] = v8;
    v14[1] = strlen(v8);
    re::RigHierarchy::getLocalSpaceJointScale(v7, (uint64_t)v14, (uint64_t)v15);
    v10 = v15[0];
    if (!v15[0])
    {
      if (v17)
      {
        if ((v18 & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v17 + 40))();
      }
      return v10 != 0;
    }
    if (a5)
    {
      v11 = *a4;
      v12 = v16;
      *(_BYTE *)(v11 + 96) = 2;
      *(_QWORD *)(v11 + 176) = v12;
      return v10 != 0;
    }
  }
  re::internal::assertLog((re::internal *)6, v9, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::LocalSpaceJointRotationCompile(uint64_t a1, _QWORD *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  _anonymous_namespace_ *v7;
  const char *v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t result;
  _QWORD v14[2];
  _BYTE v15[8];
  uint64_t v16;
  uint64_t v17;
  char v18;

  if (a3 <= 1)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, a3);
    _os_crash();
    __break(1u);
  }
  else
  {
    v7 = *(_anonymous_namespace_ **)(*a2 + 184);
    v8 = *(const char **)(a2[1] + 232);
    v14[0] = v8;
    v14[1] = strlen(v8);
    re::RigHierarchy::getLocalSpaceJointRotation(v7, (uint64_t)v14, (uint64_t)v15);
    v10 = v15[0];
    if (!v15[0])
    {
      if (v17)
      {
        if ((v18 & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v17 + 40))();
      }
      return v10 != 0;
    }
    if (a5)
    {
      v11 = *a4;
      v12 = v16;
      *(_BYTE *)(v11 + 96) = 2;
      *(_QWORD *)(v11 + 176) = v12;
      return v10 != 0;
    }
  }
  re::internal::assertLog((re::internal *)6, v9, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::LocalSpaceJointTranslationCompile(uint64_t a1, _QWORD *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  _anonymous_namespace_ *v7;
  const char *v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t result;
  _QWORD v14[2];
  _BYTE v15[8];
  uint64_t v16;
  uint64_t v17;
  char v18;

  if (a3 <= 1)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, a3);
    _os_crash();
    __break(1u);
  }
  else
  {
    v7 = *(_anonymous_namespace_ **)(*a2 + 184);
    v8 = *(const char **)(a2[1] + 232);
    v14[0] = v8;
    v14[1] = strlen(v8);
    re::RigHierarchy::getLocalSpaceJointTranslation(v7, (uint64_t)v14, (uint64_t)v15);
    v10 = v15[0];
    if (!v15[0])
    {
      if (v17)
      {
        if ((v18 & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v17 + 40))();
      }
      return v10 != 0;
    }
    if (a5)
    {
      v11 = *a4;
      v12 = v16;
      *(_BYTE *)(v11 + 96) = 2;
      *(_QWORD *)(v11 + 176) = v12;
      return v10 != 0;
    }
  }
  re::internal::assertLog((re::internal *)6, v9, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::LocalSpaceJointTransformCompile(uint64_t a1, _QWORD *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  _anonymous_namespace_ *v7;
  const char *v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t result;
  _QWORD v14[2];
  _BYTE v15[8];
  uint64_t v16;
  uint64_t v17;
  char v18;

  if (a3 <= 1)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, a3);
    _os_crash();
    __break(1u);
  }
  else
  {
    v7 = *(_anonymous_namespace_ **)(*a2 + 184);
    v8 = *(const char **)(a2[1] + 232);
    v14[0] = v8;
    v14[1] = strlen(v8);
    re::RigHierarchy::getLocalSpaceJointTransform(v7, (uint64_t)v14, (uint64_t)v15);
    v10 = v15[0];
    if (!v15[0])
    {
      if (v17)
      {
        if ((v18 & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v17 + 40))();
      }
      return v10 != 0;
    }
    if (a5)
    {
      v11 = *a4;
      v12 = v16;
      *(_BYTE *)(v11 + 96) = 2;
      *(_QWORD *)(v11 + 176) = v12;
      return v10 != 0;
    }
  }
  re::internal::assertLog((re::internal *)6, v9, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::ModelSpaceJointScaleCompile(uint64_t a1, _QWORD *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  _anonymous_namespace_ *v7;
  const char *v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t result;
  _QWORD v14[2];
  _BYTE v15[8];
  uint64_t v16;
  uint64_t v17;
  char v18;

  if (a3 <= 1)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, a3);
    _os_crash();
    __break(1u);
  }
  else
  {
    v7 = *(_anonymous_namespace_ **)(*a2 + 184);
    v8 = *(const char **)(a2[1] + 232);
    v14[0] = v8;
    v14[1] = strlen(v8);
    re::RigHierarchy::getModelSpaceJointScale(v7, (uint64_t)v14, (uint64_t)v15);
    v10 = v15[0];
    if (!v15[0])
    {
      if (v17)
      {
        if ((v18 & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v17 + 40))();
      }
      return v10 != 0;
    }
    if (a5)
    {
      v11 = *a4;
      v12 = v16;
      *(_BYTE *)(v11 + 96) = 2;
      *(_QWORD *)(v11 + 176) = v12;
      return v10 != 0;
    }
  }
  re::internal::assertLog((re::internal *)6, v9, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::ModelSpaceJointRotationCompile(uint64_t a1, _QWORD *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  _anonymous_namespace_ *v7;
  const char *v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t result;
  _QWORD v14[2];
  _BYTE v15[8];
  uint64_t v16;
  uint64_t v17;
  char v18;

  if (a3 <= 1)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, a3);
    _os_crash();
    __break(1u);
  }
  else
  {
    v7 = *(_anonymous_namespace_ **)(*a2 + 184);
    v8 = *(const char **)(a2[1] + 232);
    v14[0] = v8;
    v14[1] = strlen(v8);
    re::RigHierarchy::getModelSpaceJointRotation(v7, (uint64_t)v14, (uint64_t)v15);
    v10 = v15[0];
    if (!v15[0])
    {
      if (v17)
      {
        if ((v18 & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v17 + 40))();
      }
      return v10 != 0;
    }
    if (a5)
    {
      v11 = *a4;
      v12 = v16;
      *(_BYTE *)(v11 + 96) = 2;
      *(_QWORD *)(v11 + 176) = v12;
      return v10 != 0;
    }
  }
  re::internal::assertLog((re::internal *)6, v9, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::ModelSpaceJointTranslationCompile(uint64_t a1, _QWORD *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  _anonymous_namespace_ *v7;
  const char *v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t result;
  _QWORD v14[2];
  _BYTE v15[8];
  uint64_t v16;
  uint64_t v17;
  char v18;

  if (a3 <= 1)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, a3);
    _os_crash();
    __break(1u);
  }
  else
  {
    v7 = *(_anonymous_namespace_ **)(*a2 + 184);
    v8 = *(const char **)(a2[1] + 232);
    v14[0] = v8;
    v14[1] = strlen(v8);
    re::RigHierarchy::getModelSpaceJointTranslation(v7, (uint64_t)v14, (uint64_t)v15);
    v10 = v15[0];
    if (!v15[0])
    {
      if (v17)
      {
        if ((v18 & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v17 + 40))();
      }
      return v10 != 0;
    }
    if (a5)
    {
      v11 = *a4;
      v12 = v16;
      *(_BYTE *)(v11 + 96) = 2;
      *(_QWORD *)(v11 + 176) = v12;
      return v10 != 0;
    }
  }
  re::internal::assertLog((re::internal *)6, v9, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::ModelSpaceJointTransformCompile(uint64_t a1, _QWORD *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  _anonymous_namespace_ *v7;
  const char *v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t result;
  _QWORD v14[2];
  _BYTE v15[8];
  uint64_t v16;
  uint64_t v17;
  char v18;

  if (a3 <= 1)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, a3);
    _os_crash();
    __break(1u);
  }
  else
  {
    v7 = *(_anonymous_namespace_ **)(*a2 + 184);
    v8 = *(const char **)(a2[1] + 232);
    v14[0] = v8;
    v14[1] = strlen(v8);
    re::RigHierarchy::getModelSpaceJointTransform(v7, (uint64_t)v14, (uint64_t)v15);
    v10 = v15[0];
    if (!v15[0])
    {
      if (v17)
      {
        if ((v18 & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v17 + 40))();
      }
      return v10 != 0;
    }
    if (a5)
    {
      v11 = *a4;
      v12 = v16;
      *(_BYTE *)(v11 + 96) = 2;
      *(_QWORD *)(v11 + 176) = v12;
      return v10 != 0;
    }
  }
  re::internal::assertLog((re::internal *)6, v9, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::SetLocalSpaceJointScaleCompile(uint64_t a1, _QWORD *a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;
  __int128 *v9;
  uint64_t v10;
  __int128 v11;
  _anonymous_namespace_ *v12;
  uint64_t v13;
  __n128 *v14;
  _QWORD *v15;
  __n128 *v16;
  uint64_t *v17;
  uint64_t result;
  const char *v19[2];
  _BYTE v20[24];
  uint64_t v21;
  char v22;
  _QWORD v23[4];

  if (a3 <= 1)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, a3);
    _os_crash();
    __break(1u);
    goto LABEL_13;
  }
  if (!a5)
  {
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_14;
  }
  v8 = a2[1];
  v9 = *(__int128 **)(*a2 + 184);
  v10 = *(_QWORD *)(*(_QWORD *)a4 + 184);
  v11 = *v9;
  *(_QWORD *)(v10 + 16) = *((_QWORD *)v9 + 2);
  *(_OWORD *)v10 = v11;
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v10 + 24, (uint64_t)v9 + 24);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v10 + 72, (uint64_t)v9 + 72);
  re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::operator=(v10 + 120, (uint64_t *)v9 + 15);
  re::DynamicArray<re::DynamicArray<re::RigDataValue>>::operator=(v10 + 160, (uint64_t *)v9 + 20);
  re::DynamicArray<re::StringID>::operator=(v10 + 200, (uint64_t *)v9 + 25);
  re::DynamicArray<unsigned long>::operator=(v10 + 240, (uint64_t *)v9 + 30);
  re::DynamicArray<re::RigHierarchyJointTransform>::operator=(v10 + 280, (uint64_t *)v9 + 35);
  re::DynamicArray<unsigned long>::operator=(v10 + 320, (uint64_t *)v9 + 40);
  v12 = *(_anonymous_namespace_ **)(*(_QWORD *)a4 + 184);
  v19[0] = *(const char **)(v8 + 232);
  v19[1] = (const char *)strlen(v19[0]);
  if (a3 <= 2)
  {
LABEL_14:
    re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v14 = (__n128 *)a2[2];
  if (v14[6].n128_u8[0] == 1)
  {
    v15 = (_QWORD *)v14[1].n128_u64[0];
    v16 = v14 + 7;
    LODWORD(v23[0]) = 7;
    memset(&v23[1], 0, 24);
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 243), (uint64_t)v23);
    v23[0] = v15[245] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 36, v23);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v15 + 76), v16);
    v17 = (uint64_t *)(v15[40] + 8 * v15[38] - 8);
  }
  else
  {
    v17 = (uint64_t *)&v14[11];
  }
  re::RigHierarchy::setLocalSpaceJointScale(v12, (uint64_t)v19, *v17, (uint64_t)v20);
  if (!v20[0] && v21 && (v22 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v21 + 40))();
  return 1;
}

uint64_t re::SetLocalSpaceJointRotationCompile(uint64_t a1, _QWORD *a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;
  __int128 *v9;
  uint64_t v10;
  __int128 v11;
  _anonymous_namespace_ *v12;
  uint64_t v13;
  __n128 *v14;
  _QWORD *v15;
  __n128 *v16;
  uint64_t *v17;
  uint64_t result;
  const char *v19[2];
  _BYTE v20[24];
  uint64_t v21;
  char v22;
  _QWORD v23[4];

  if (a3 <= 1)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, a3);
    _os_crash();
    __break(1u);
    goto LABEL_13;
  }
  if (!a5)
  {
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_14;
  }
  v8 = a2[1];
  v9 = *(__int128 **)(*a2 + 184);
  v10 = *(_QWORD *)(*(_QWORD *)a4 + 184);
  v11 = *v9;
  *(_QWORD *)(v10 + 16) = *((_QWORD *)v9 + 2);
  *(_OWORD *)v10 = v11;
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v10 + 24, (uint64_t)v9 + 24);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v10 + 72, (uint64_t)v9 + 72);
  re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::operator=(v10 + 120, (uint64_t *)v9 + 15);
  re::DynamicArray<re::DynamicArray<re::RigDataValue>>::operator=(v10 + 160, (uint64_t *)v9 + 20);
  re::DynamicArray<re::StringID>::operator=(v10 + 200, (uint64_t *)v9 + 25);
  re::DynamicArray<unsigned long>::operator=(v10 + 240, (uint64_t *)v9 + 30);
  re::DynamicArray<re::RigHierarchyJointTransform>::operator=(v10 + 280, (uint64_t *)v9 + 35);
  re::DynamicArray<unsigned long>::operator=(v10 + 320, (uint64_t *)v9 + 40);
  v12 = *(_anonymous_namespace_ **)(*(_QWORD *)a4 + 184);
  v19[0] = *(const char **)(v8 + 232);
  v19[1] = (const char *)strlen(v19[0]);
  if (a3 <= 2)
  {
LABEL_14:
    re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v14 = (__n128 *)a2[2];
  if (v14[6].n128_u8[0] == 1)
  {
    v15 = (_QWORD *)v14[1].n128_u64[0];
    v16 = v14 + 7;
    LODWORD(v23[0]) = 5;
    memset(&v23[1], 0, 24);
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 233), (uint64_t)v23);
    v23[0] = v15[235] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 26, v23);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v15 + 66), v16);
    v17 = (uint64_t *)(v15[30] + 8 * v15[28] - 8);
  }
  else
  {
    v17 = (uint64_t *)&v14[11];
  }
  re::RigHierarchy::setLocalSpaceJointRotation(v12, (uint64_t)v19, *v17, (uint64_t)v20);
  if (!v20[0] && v21 && (v22 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v21 + 40))();
  return 1;
}

uint64_t re::SetLocalSpaceJointTranslationCompile(uint64_t a1, _QWORD *a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;
  __int128 *v9;
  uint64_t v10;
  __int128 v11;
  _anonymous_namespace_ *v12;
  uint64_t v13;
  __n128 *v14;
  _QWORD *v15;
  __n128 *v16;
  uint64_t *v17;
  uint64_t result;
  const char *v19[2];
  _BYTE v20[24];
  uint64_t v21;
  char v22;
  _QWORD v23[4];

  if (a3 <= 1)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, a3);
    _os_crash();
    __break(1u);
    goto LABEL_13;
  }
  if (!a5)
  {
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_14;
  }
  v8 = a2[1];
  v9 = *(__int128 **)(*a2 + 184);
  v10 = *(_QWORD *)(*(_QWORD *)a4 + 184);
  v11 = *v9;
  *(_QWORD *)(v10 + 16) = *((_QWORD *)v9 + 2);
  *(_OWORD *)v10 = v11;
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v10 + 24, (uint64_t)v9 + 24);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v10 + 72, (uint64_t)v9 + 72);
  re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::operator=(v10 + 120, (uint64_t *)v9 + 15);
  re::DynamicArray<re::DynamicArray<re::RigDataValue>>::operator=(v10 + 160, (uint64_t *)v9 + 20);
  re::DynamicArray<re::StringID>::operator=(v10 + 200, (uint64_t *)v9 + 25);
  re::DynamicArray<unsigned long>::operator=(v10 + 240, (uint64_t *)v9 + 30);
  re::DynamicArray<re::RigHierarchyJointTransform>::operator=(v10 + 280, (uint64_t *)v9 + 35);
  re::DynamicArray<unsigned long>::operator=(v10 + 320, (uint64_t *)v9 + 40);
  v12 = *(_anonymous_namespace_ **)(*(_QWORD *)a4 + 184);
  v19[0] = *(const char **)(v8 + 232);
  v19[1] = (const char *)strlen(v19[0]);
  if (a3 <= 2)
  {
LABEL_14:
    re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v14 = (__n128 *)a2[2];
  if (v14[6].n128_u8[0] == 1)
  {
    v15 = (_QWORD *)v14[1].n128_u64[0];
    v16 = v14 + 7;
    LODWORD(v23[0]) = 7;
    memset(&v23[1], 0, 24);
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 243), (uint64_t)v23);
    v23[0] = v15[245] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 36, v23);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v15 + 76), v16);
    v17 = (uint64_t *)(v15[40] + 8 * v15[38] - 8);
  }
  else
  {
    v17 = (uint64_t *)&v14[11];
  }
  re::RigHierarchy::setLocalSpaceJointTranslation(v12, (uint64_t)v19, *v17, (uint64_t)v20);
  if (!v20[0] && v21 && (v22 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v21 + 40))();
  return 1;
}

uint64_t re::SetLocalSpaceJointTransformCompile(uint64_t a1, _QWORD *a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;
  __int128 *v9;
  uint64_t v10;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t result;
  const char *v19[2];
  _BYTE v20[24];
  uint64_t v21;
  char v22;
  _QWORD v23[4];

  if (a3 <= 1)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, a3);
    _os_crash();
    __break(1u);
    goto LABEL_13;
  }
  if (!a5)
  {
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_14;
  }
  v8 = a2[1];
  v9 = *(__int128 **)(*a2 + 184);
  v10 = *(_QWORD *)(*(_QWORD *)a4 + 184);
  v11 = *v9;
  *(_QWORD *)(v10 + 16) = *((_QWORD *)v9 + 2);
  *(_OWORD *)v10 = v11;
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v10 + 24, (uint64_t)v9 + 24);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v10 + 72, (uint64_t)v9 + 72);
  re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::operator=(v10 + 120, (uint64_t *)v9 + 15);
  re::DynamicArray<re::DynamicArray<re::RigDataValue>>::operator=(v10 + 160, (uint64_t *)v9 + 20);
  re::DynamicArray<re::StringID>::operator=(v10 + 200, (uint64_t *)v9 + 25);
  re::DynamicArray<unsigned long>::operator=(v10 + 240, (uint64_t *)v9 + 30);
  re::DynamicArray<re::RigHierarchyJointTransform>::operator=(v10 + 280, (uint64_t *)v9 + 35);
  re::DynamicArray<unsigned long>::operator=(v10 + 320, (uint64_t *)v9 + 40);
  v12 = *(_QWORD *)(*(_QWORD *)a4 + 184);
  v19[0] = *(const char **)(v8 + 232);
  v19[1] = (const char *)strlen(v19[0]);
  if (a3 <= 2)
  {
LABEL_14:
    re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v14 = a2[2];
  if (*(_BYTE *)(v14 + 96) == 1)
  {
    v15 = *(_QWORD **)(v14 + 16);
    v16 = v14 + 112;
    LODWORD(v23[0]) = 4;
    memset(&v23[1], 0, 24);
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 228), (uint64_t)v23);
    v23[0] = v15[230] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 21, v23);
    re::DynamicArray<re::Matrix4x4<float>>::add((_anonymous_namespace_ *)(v15 + 61), v16);
    v17 = (uint64_t *)(v15[25] + 8 * v15[23] - 8);
  }
  else
  {
    v17 = (uint64_t *)(v14 + 176);
  }
  re::RigHierarchy::setLocalSpaceJointTransform(v12, (uint64_t)v19, *v17, (uint64_t)v20);
  if (!v20[0] && v21 && (v22 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v21 + 40))();
  return 1;
}

uint64_t re::SetModelSpaceJointScaleCompile(uint64_t a1, _QWORD *a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;
  __int128 *v9;
  uint64_t v10;
  __int128 v11;
  _anonymous_namespace_ *v12;
  uint64_t v13;
  __n128 *v14;
  _QWORD *v15;
  __n128 *v16;
  uint64_t *v17;
  uint64_t result;
  const char *v19[2];
  _BYTE v20[24];
  uint64_t v21;
  char v22;
  _QWORD v23[4];

  if (a3 <= 1)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, a3);
    _os_crash();
    __break(1u);
    goto LABEL_13;
  }
  if (!a5)
  {
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_14;
  }
  v8 = a2[1];
  v9 = *(__int128 **)(*a2 + 184);
  v10 = *(_QWORD *)(*(_QWORD *)a4 + 184);
  v11 = *v9;
  *(_QWORD *)(v10 + 16) = *((_QWORD *)v9 + 2);
  *(_OWORD *)v10 = v11;
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v10 + 24, (uint64_t)v9 + 24);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v10 + 72, (uint64_t)v9 + 72);
  re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::operator=(v10 + 120, (uint64_t *)v9 + 15);
  re::DynamicArray<re::DynamicArray<re::RigDataValue>>::operator=(v10 + 160, (uint64_t *)v9 + 20);
  re::DynamicArray<re::StringID>::operator=(v10 + 200, (uint64_t *)v9 + 25);
  re::DynamicArray<unsigned long>::operator=(v10 + 240, (uint64_t *)v9 + 30);
  re::DynamicArray<re::RigHierarchyJointTransform>::operator=(v10 + 280, (uint64_t *)v9 + 35);
  re::DynamicArray<unsigned long>::operator=(v10 + 320, (uint64_t *)v9 + 40);
  v12 = *(_anonymous_namespace_ **)(*(_QWORD *)a4 + 184);
  v19[0] = *(const char **)(v8 + 232);
  v19[1] = (const char *)strlen(v19[0]);
  if (a3 <= 2)
  {
LABEL_14:
    re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v14 = (__n128 *)a2[2];
  if (v14[6].n128_u8[0] == 1)
  {
    v15 = (_QWORD *)v14[1].n128_u64[0];
    v16 = v14 + 7;
    LODWORD(v23[0]) = 7;
    memset(&v23[1], 0, 24);
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 243), (uint64_t)v23);
    v23[0] = v15[245] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 36, v23);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v15 + 76), v16);
    v17 = (uint64_t *)(v15[40] + 8 * v15[38] - 8);
  }
  else
  {
    v17 = (uint64_t *)&v14[11];
  }
  re::RigHierarchy::setModelSpaceJointScale(v12, (uint64_t)v19, *v17, (uint64_t)v20);
  if (!v20[0] && v21 && (v22 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v21 + 40))();
  return 1;
}

uint64_t re::SetModelSpaceJointRotationCompile(uint64_t a1, _QWORD *a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;
  __int128 *v9;
  uint64_t v10;
  __int128 v11;
  uint64_t *v12;
  uint64_t v13;
  __n128 *v14;
  _QWORD *v15;
  __n128 *v16;
  uint64_t *v17;
  uint64_t v18;
  __int128 v19;
  uint64_t result;
  const char *v21[2];
  _BYTE v22[24];
  __int128 v23;
  __int128 v24;
  _QWORD v25[4];

  if (a3 <= 1)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, a3);
    _os_crash();
    __break(1u);
    goto LABEL_14;
  }
  if (!a5)
  {
LABEL_14:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_15;
  }
  v8 = a2[1];
  v9 = *(__int128 **)(*a2 + 184);
  v10 = *(_QWORD *)(*(_QWORD *)a4 + 184);
  v11 = *v9;
  *(_QWORD *)(v10 + 16) = *((_QWORD *)v9 + 2);
  *(_OWORD *)v10 = v11;
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v10 + 24, (uint64_t)v9 + 24);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v10 + 72, (uint64_t)v9 + 72);
  re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::operator=(v10 + 120, (uint64_t *)v9 + 15);
  re::DynamicArray<re::DynamicArray<re::RigDataValue>>::operator=(v10 + 160, (uint64_t *)v9 + 20);
  re::DynamicArray<re::StringID>::operator=(v10 + 200, (uint64_t *)v9 + 25);
  re::DynamicArray<unsigned long>::operator=(v10 + 240, (uint64_t *)v9 + 30);
  re::DynamicArray<re::RigHierarchyJointTransform>::operator=(v10 + 280, (uint64_t *)v9 + 35);
  re::DynamicArray<unsigned long>::operator=(v10 + 320, (uint64_t *)v9 + 40);
  v12 = *(uint64_t **)(*(_QWORD *)a4 + 184);
  v21[0] = *(const char **)(v8 + 232);
  v21[1] = (const char *)strlen(v21[0]);
  if (a3 <= 2)
  {
LABEL_15:
    re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v14 = (__n128 *)a2[2];
  if (v14[6].n128_u8[0] == 1)
  {
    v15 = (_QWORD *)v14[1].n128_u64[0];
    v16 = v14 + 7;
    LODWORD(v25[0]) = 5;
    memset(&v25[1], 0, 24);
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 233), (uint64_t)v25);
    v25[0] = v15[235] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 26, v25);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v15 + 66), v16);
    v17 = (uint64_t *)(v15[30] + 8 * v15[28] - 8);
  }
  else
  {
    v17 = (uint64_t *)&v14[11];
  }
  re::RigHierarchy::setModelSpaceJointRotation((_anonymous_namespace_ *)v12, (uint64_t)v21, *v17, (uint64_t)v22);
  if (!v22[0] && (_QWORD)v23)
  {
    if ((BYTE8(v23) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v23 + 40))();
    v23 = 0u;
    v24 = 0u;
  }
  v18 = *(_QWORD *)(*(_QWORD *)a4 + 184);
  v19 = *(_OWORD *)v12;
  *(_QWORD *)(v18 + 16) = v12[2];
  *(_OWORD *)v18 = v19;
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v18 + 24, (uint64_t)(v12 + 3));
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v18 + 72, (uint64_t)(v12 + 9));
  re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::operator=(v18 + 120, v12 + 15);
  re::DynamicArray<re::DynamicArray<re::RigDataValue>>::operator=(v18 + 160, v12 + 20);
  re::DynamicArray<re::StringID>::operator=(v18 + 200, v12 + 25);
  re::DynamicArray<unsigned long>::operator=(v18 + 240, v12 + 30);
  re::DynamicArray<re::RigHierarchyJointTransform>::operator=(v18 + 280, v12 + 35);
  re::DynamicArray<unsigned long>::operator=(v18 + 320, v12 + 40);
  return 1;
}

uint64_t re::SetModelSpaceJointTranslationCompile(uint64_t a1, _QWORD *a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;
  __int128 *v9;
  uint64_t v10;
  __int128 v11;
  uint64_t *v12;
  uint64_t v13;
  __n128 *v14;
  _QWORD *v15;
  __n128 *v16;
  uint64_t *v17;
  uint64_t v18;
  __int128 v19;
  uint64_t result;
  const char *v21[2];
  _BYTE v22[24];
  __int128 v23;
  __int128 v24;
  _QWORD v25[4];

  if (a3 <= 1)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, a3);
    _os_crash();
    __break(1u);
    goto LABEL_14;
  }
  if (!a5)
  {
LABEL_14:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_15;
  }
  v8 = a2[1];
  v9 = *(__int128 **)(*a2 + 184);
  v10 = *(_QWORD *)(*(_QWORD *)a4 + 184);
  v11 = *v9;
  *(_QWORD *)(v10 + 16) = *((_QWORD *)v9 + 2);
  *(_OWORD *)v10 = v11;
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v10 + 24, (uint64_t)v9 + 24);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v10 + 72, (uint64_t)v9 + 72);
  re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::operator=(v10 + 120, (uint64_t *)v9 + 15);
  re::DynamicArray<re::DynamicArray<re::RigDataValue>>::operator=(v10 + 160, (uint64_t *)v9 + 20);
  re::DynamicArray<re::StringID>::operator=(v10 + 200, (uint64_t *)v9 + 25);
  re::DynamicArray<unsigned long>::operator=(v10 + 240, (uint64_t *)v9 + 30);
  re::DynamicArray<re::RigHierarchyJointTransform>::operator=(v10 + 280, (uint64_t *)v9 + 35);
  re::DynamicArray<unsigned long>::operator=(v10 + 320, (uint64_t *)v9 + 40);
  v12 = *(uint64_t **)(*(_QWORD *)a4 + 184);
  v21[0] = *(const char **)(v8 + 232);
  v21[1] = (const char *)strlen(v21[0]);
  if (a3 <= 2)
  {
LABEL_15:
    re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v14 = (__n128 *)a2[2];
  if (v14[6].n128_u8[0] == 1)
  {
    v15 = (_QWORD *)v14[1].n128_u64[0];
    v16 = v14 + 7;
    LODWORD(v25[0]) = 7;
    memset(&v25[1], 0, 24);
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 243), (uint64_t)v25);
    v25[0] = v15[245] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 36, v25);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(v15 + 76), v16);
    v17 = (uint64_t *)(v15[40] + 8 * v15[38] - 8);
  }
  else
  {
    v17 = (uint64_t *)&v14[11];
  }
  re::RigHierarchy::setModelSpaceJointTranslation((_anonymous_namespace_ *)v12, (uint64_t)v21, *v17, (uint64_t)v22);
  if (!v22[0] && (_QWORD)v23)
  {
    if ((BYTE8(v23) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v23 + 40))();
    v23 = 0u;
    v24 = 0u;
  }
  v18 = *(_QWORD *)(*(_QWORD *)a4 + 184);
  v19 = *(_OWORD *)v12;
  *(_QWORD *)(v18 + 16) = v12[2];
  *(_OWORD *)v18 = v19;
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v18 + 24, (uint64_t)(v12 + 3));
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v18 + 72, (uint64_t)(v12 + 9));
  re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::operator=(v18 + 120, v12 + 15);
  re::DynamicArray<re::DynamicArray<re::RigDataValue>>::operator=(v18 + 160, v12 + 20);
  re::DynamicArray<re::StringID>::operator=(v18 + 200, v12 + 25);
  re::DynamicArray<unsigned long>::operator=(v18 + 240, v12 + 30);
  re::DynamicArray<re::RigHierarchyJointTransform>::operator=(v18 + 280, v12 + 35);
  re::DynamicArray<unsigned long>::operator=(v18 + 320, v12 + 40);
  return 1;
}

uint64_t re::SetModelSpaceJointTransformCompile(uint64_t a1, _QWORD *a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;
  __int128 *v9;
  uint64_t v10;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t result;
  const char *v19[2];
  _BYTE v20[24];
  uint64_t v21;
  char v22;
  _QWORD v23[4];

  if (a3 <= 1)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, a3);
    _os_crash();
    __break(1u);
    goto LABEL_13;
  }
  if (!a5)
  {
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_14;
  }
  v8 = a2[1];
  v9 = *(__int128 **)(*a2 + 184);
  v10 = *(_QWORD *)(*(_QWORD *)a4 + 184);
  v11 = *v9;
  *(_QWORD *)(v10 + 16) = *((_QWORD *)v9 + 2);
  *(_OWORD *)v10 = v11;
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v10 + 24, (uint64_t)v9 + 24);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v10 + 72, (uint64_t)v9 + 72);
  re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::operator=(v10 + 120, (uint64_t *)v9 + 15);
  re::DynamicArray<re::DynamicArray<re::RigDataValue>>::operator=(v10 + 160, (uint64_t *)v9 + 20);
  re::DynamicArray<re::StringID>::operator=(v10 + 200, (uint64_t *)v9 + 25);
  re::DynamicArray<unsigned long>::operator=(v10 + 240, (uint64_t *)v9 + 30);
  re::DynamicArray<re::RigHierarchyJointTransform>::operator=(v10 + 280, (uint64_t *)v9 + 35);
  re::DynamicArray<unsigned long>::operator=(v10 + 320, (uint64_t *)v9 + 40);
  v12 = *(_QWORD *)(*(_QWORD *)a4 + 184);
  v19[0] = *(const char **)(v8 + 232);
  v19[1] = (const char *)strlen(v19[0]);
  if (a3 <= 2)
  {
LABEL_14:
    re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v14 = a2[2];
  if (*(_BYTE *)(v14 + 96) == 1)
  {
    v15 = *(_QWORD **)(v14 + 16);
    v16 = v14 + 112;
    LODWORD(v23[0]) = 4;
    memset(&v23[1], 0, 24);
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 228), (uint64_t)v23);
    v23[0] = v15[230] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 21, v23);
    re::DynamicArray<re::Matrix4x4<float>>::add((_anonymous_namespace_ *)(v15 + 61), v16);
    v17 = (uint64_t *)(v15[25] + 8 * v15[23] - 8);
  }
  else
  {
    v17 = (uint64_t *)(v14 + 176);
  }
  re::RigHierarchy::setModelSpaceJointTransform(v12, (uint64_t)v19, *v17, (uint64_t)v20);
  if (!v20[0] && v21 && (v22 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v21 + 40))();
  return 1;
}

uint64_t re::JointParentCompile(uint64_t a1, _QWORD *a2, unint64_t a3, re::Allocator ***a4, uint64_t a5)
{
  _anonymous_namespace_ *v7;
  const char *v8;
  _anonymous_namespace_ *v9;
  uint64_t v10;
  int v11;
  re::Allocator **v12;
  const char *v13;
  uint64_t result;
  const char *v15;
  void *v16;
  _BYTE v17[8];
  uint64_t v18;
  uint64_t v19;
  char v20;

  if (a3 <= 1)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, a3);
    _os_crash();
    __break(1u);
  }
  else
  {
    v7 = *(_anonymous_namespace_ **)(*a2 + 184);
    v8 = *(const char **)(a2[1] + 232);
    v15 = v8;
    v16 = (void *)strlen(v8);
    v9 = (_anonymous_namespace_ *)re::RigHierarchy::jointParent(v7, (uint64_t)&v15, 1, (uint64_t)v17);
    v11 = v17[0];
    if (!v17[0])
      goto LABEL_5;
    if (a5)
    {
      v12 = *a4;
      v13 = *(const char **)(v18 + 8);
      v15 = 0;
      v16 = &str_110;
      re::StringID::copy((re::StringID *)(v12 + 28), &v15, *v12);
      re::StringID::destroyString((re::StringID *)&v15);
      if (v17[0])
        return v11 != 0;
LABEL_5:
      if (v19)
      {
        if ((v20 & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v19 + 40))();
      }
      return v11 != 0;
    }
  }
  re::internal::assertLog((re::internal *)6, v10, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::SetJointParentCompile(uint64_t a1, _QWORD *a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;
  __int128 *v9;
  uint64_t v10;
  __int128 v11;
  uint64_t v12;
  size_t v13;
  _anonymous_namespace_ *v14;
  size_t v15;
  uint64_t result;
  _QWORD v17[2];
  _BYTE v18[24];
  uint64_t v19;
  char v20;
  _QWORD v21[2];

  if (a3 <= 1)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, a3);
    _os_crash();
    __break(1u);
    goto LABEL_10;
  }
  if (!a5)
  {
LABEL_10:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_11;
  }
  v8 = a2[1];
  v9 = *(__int128 **)(*a2 + 184);
  v10 = *(_QWORD *)(*(_QWORD *)a4 + 184);
  v11 = *v9;
  *(_QWORD *)(v10 + 16) = *((_QWORD *)v9 + 2);
  *(_OWORD *)v10 = v11;
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v10 + 24, (uint64_t)v9 + 24);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v10 + 72, (uint64_t)v9 + 72);
  re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::operator=(v10 + 120, (uint64_t *)v9 + 15);
  re::DynamicArray<re::DynamicArray<re::RigDataValue>>::operator=(v10 + 160, (uint64_t *)v9 + 20);
  re::DynamicArray<re::StringID>::operator=(v10 + 200, (uint64_t *)v9 + 25);
  re::DynamicArray<unsigned long>::operator=(v10 + 240, (uint64_t *)v9 + 30);
  re::DynamicArray<re::RigHierarchyJointTransform>::operator=(v10 + 280, (uint64_t *)v9 + 35);
  re::DynamicArray<unsigned long>::operator=(v10 + 320, (uint64_t *)v9 + 40);
  if (a3 <= 2)
  {
LABEL_11:
    re::internal::assertLog((re::internal *)6, v12, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v13 = strlen(*(const char **)(a2[2] + 232));
  v21[0] = *(_QWORD *)(a2[2] + 232);
  v21[1] = v13;
  v14 = *(_anonymous_namespace_ **)(*(_QWORD *)a4 + 184);
  v15 = strlen(*(const char **)(v8 + 232));
  v17[0] = *(_QWORD *)(v8 + 232);
  v17[1] = v15;
  re::RigHierarchy::setJointParent(v14, (uint64_t)v17, (uint64_t)v21, (uint64_t)v18);
  if (!v18[0] && v19 && (v20 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v19 + 40))();
  return 1;
}

uint64_t re::AddJointCompile(uint64_t a1, _QWORD *a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  __int128 *v7;
  uint64_t v8;
  __int128 v9;
  uint64_t v10;
  uint64_t result;
  const char *v12[2];
  _BYTE v13[24];
  uint64_t v14;
  char v15;

  if (a3 <= 1)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, a3);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  if (!a5)
  {
LABEL_9:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v6 = a2[1];
  v7 = *(__int128 **)(*a2 + 184);
  v8 = *(_QWORD *)(*(_QWORD *)a4 + 184);
  v9 = *v7;
  *(_QWORD *)(v8 + 16) = *((_QWORD *)v7 + 2);
  *(_OWORD *)v8 = v9;
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v8 + 24, (uint64_t)v7 + 24);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v8 + 72, (uint64_t)v7 + 72);
  re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::operator=(v8 + 120, (uint64_t *)v7 + 15);
  re::DynamicArray<re::DynamicArray<re::RigDataValue>>::operator=(v8 + 160, (uint64_t *)v7 + 20);
  re::DynamicArray<re::StringID>::operator=(v8 + 200, (uint64_t *)v7 + 25);
  re::DynamicArray<unsigned long>::operator=(v8 + 240, (uint64_t *)v7 + 30);
  re::DynamicArray<re::RigHierarchyJointTransform>::operator=(v8 + 280, (uint64_t *)v7 + 35);
  re::DynamicArray<unsigned long>::operator=(v8 + 320, (uint64_t *)v7 + 40);
  v10 = *(_QWORD *)(*(_QWORD *)a4 + 184);
  v12[0] = *(const char **)(v6 + 232);
  v12[1] = (const char *)strlen(v12[0]);
  re::RigHierarchy::addJoint(v10, v12, (uint64_t)v13);
  if (!v13[0] && v14 && (v15 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v14 + 40))();
  return 1;
}

uint64_t re::RemoveJointCompile(uint64_t a1, _QWORD *a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  __int128 *v7;
  uint64_t v8;
  __int128 v9;
  uint64_t v10;
  uint64_t result;
  const char *v12[2];
  _BYTE v13[24];
  uint64_t v14;
  char v15;

  if (a3 <= 1)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, a3);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  if (!a5)
  {
LABEL_9:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v6 = a2[1];
  v7 = *(__int128 **)(*a2 + 184);
  v8 = *(_QWORD *)(*(_QWORD *)a4 + 184);
  v9 = *v7;
  *(_QWORD *)(v8 + 16) = *((_QWORD *)v7 + 2);
  *(_OWORD *)v8 = v9;
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v8 + 24, (uint64_t)v7 + 24);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v8 + 72, (uint64_t)v7 + 72);
  re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::operator=(v8 + 120, (uint64_t *)v7 + 15);
  re::DynamicArray<re::DynamicArray<re::RigDataValue>>::operator=(v8 + 160, (uint64_t *)v7 + 20);
  re::DynamicArray<re::StringID>::operator=(v8 + 200, (uint64_t *)v7 + 25);
  re::DynamicArray<unsigned long>::operator=(v8 + 240, (uint64_t *)v7 + 30);
  re::DynamicArray<re::RigHierarchyJointTransform>::operator=(v8 + 280, (uint64_t *)v7 + 35);
  re::DynamicArray<unsigned long>::operator=(v8 + 320, (uint64_t *)v7 + 40);
  v10 = *(_QWORD *)(*(_QWORD *)a4 + 184);
  v12[0] = *(const char **)(v6 + 232);
  v12[1] = (const char *)strlen(v12[0]);
  re::RigHierarchy::removeJoint(v10, (uint64_t)v12, (uint64_t)v13);
  if (!v13[0] && v14 && (v15 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v14 + 40))();
  return 1;
}

uint64_t re::ClearJointParentCompile(uint64_t a1, _QWORD *a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  __int128 *v7;
  uint64_t v8;
  __int128 v9;
  _anonymous_namespace_ *v10;
  uint64_t result;
  const char *v12[2];
  _BYTE v13[24];
  uint64_t v14;
  char v15;

  if (a3 <= 1)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, a3);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  if (!a5)
  {
LABEL_9:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v6 = a2[1];
  v7 = *(__int128 **)(*a2 + 184);
  v8 = *(_QWORD *)(*(_QWORD *)a4 + 184);
  v9 = *v7;
  *(_QWORD *)(v8 + 16) = *((_QWORD *)v7 + 2);
  *(_OWORD *)v8 = v9;
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v8 + 24, (uint64_t)v7 + 24);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v8 + 72, (uint64_t)v7 + 72);
  re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::operator=(v8 + 120, (uint64_t *)v7 + 15);
  re::DynamicArray<re::DynamicArray<re::RigDataValue>>::operator=(v8 + 160, (uint64_t *)v7 + 20);
  re::DynamicArray<re::StringID>::operator=(v8 + 200, (uint64_t *)v7 + 25);
  re::DynamicArray<unsigned long>::operator=(v8 + 240, (uint64_t *)v7 + 30);
  re::DynamicArray<re::RigHierarchyJointTransform>::operator=(v8 + 280, (uint64_t *)v7 + 35);
  re::DynamicArray<unsigned long>::operator=(v8 + 320, (uint64_t *)v7 + 40);
  v10 = *(_anonymous_namespace_ **)(*(_QWORD *)a4 + 184);
  v12[0] = *(const char **)(v6 + 232);
  v12[1] = (const char *)strlen(v12[0]);
  re::RigHierarchy::clearJointParent(v10, (uint64_t)v12, (uint64_t)v13);
  if (!v13[0] && v14 && (v15 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v14 + 40))();
  return 1;
}

uint64_t re::SinFloatCompile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  float *v9;
  uint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t result;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_8;
  }
  if (!a3)
  {
LABEL_8:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v5 = *a4;
  v6 = *(_QWORD *)(a1 + 8);
  v7 = *(_QWORD *)a2;
  if (*(_BYTE *)(*(_QWORD *)a2 + 96) == 1)
  {
    v8 = *(_QWORD **)(v7 + 16);
    v9 = (float *)(v7 + 112);
    LODWORD(v14) = 2;
    v16 = 0;
    v17 = 0;
    v15 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 218), (uint64_t)&v14);
    v14 = v8[220] - 1;
    re::DynamicArray<unsigned long>::add(v8 + 11, &v14);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v8 + 51), v9);
    v10 = (uint64_t *)(v8[15] + 8 * v8[13] - 8);
  }
  else
  {
    v10 = (uint64_t *)(v7 + 176);
  }
  v11 = *v10;
  LODWORD(v14) = 53;
  v16 = 0;
  v17 = 0;
  v15 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v6 + 1744), (uint64_t)&v14);
  v12 = *(_QWORD *)(v6 + 1760) - 1;
  *(_QWORD *)(re::DynamicEvaluationRegisterTable::evaluationRegister<float>(v6 + 1664, v12) + 8) = v11;
  *(_BYTE *)(v5 + 96) = 2;
  *(_QWORD *)(v5 + 176) = v12;
  return 1;
}

uint64_t re::CosFloatCompile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  float *v9;
  uint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t result;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_8;
  }
  if (!a3)
  {
LABEL_8:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v5 = *a4;
  v6 = *(_QWORD *)(a1 + 8);
  v7 = *(_QWORD *)a2;
  if (*(_BYTE *)(*(_QWORD *)a2 + 96) == 1)
  {
    v8 = *(_QWORD **)(v7 + 16);
    v9 = (float *)(v7 + 112);
    LODWORD(v14) = 2;
    v16 = 0;
    v17 = 0;
    v15 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 218), (uint64_t)&v14);
    v14 = v8[220] - 1;
    re::DynamicArray<unsigned long>::add(v8 + 11, &v14);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v8 + 51), v9);
    v10 = (uint64_t *)(v8[15] + 8 * v8[13] - 8);
  }
  else
  {
    v10 = (uint64_t *)(v7 + 176);
  }
  v11 = *v10;
  LODWORD(v14) = 54;
  v16 = 0;
  v17 = 0;
  v15 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v6 + 1744), (uint64_t)&v14);
  v12 = *(_QWORD *)(v6 + 1760) - 1;
  *(_QWORD *)(re::DynamicEvaluationRegisterTable::evaluationRegister<float>(v6 + 1664, v12) + 8) = v11;
  *(_BYTE *)(v5 + 96) = 2;
  *(_QWORD *)(v5 + 176) = v12;
  return 1;
}

uint64_t re::TanFloatCompile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  float *v9;
  uint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t result;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_8;
  }
  if (!a3)
  {
LABEL_8:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v5 = *a4;
  v6 = *(_QWORD *)(a1 + 8);
  v7 = *(_QWORD *)a2;
  if (*(_BYTE *)(*(_QWORD *)a2 + 96) == 1)
  {
    v8 = *(_QWORD **)(v7 + 16);
    v9 = (float *)(v7 + 112);
    LODWORD(v14) = 2;
    v16 = 0;
    v17 = 0;
    v15 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 218), (uint64_t)&v14);
    v14 = v8[220] - 1;
    re::DynamicArray<unsigned long>::add(v8 + 11, &v14);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v8 + 51), v9);
    v10 = (uint64_t *)(v8[15] + 8 * v8[13] - 8);
  }
  else
  {
    v10 = (uint64_t *)(v7 + 176);
  }
  v11 = *v10;
  LODWORD(v14) = 55;
  v16 = 0;
  v17 = 0;
  v15 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v6 + 1744), (uint64_t)&v14);
  v12 = *(_QWORD *)(v6 + 1760) - 1;
  *(_QWORD *)(re::DynamicEvaluationRegisterTable::evaluationRegister<float>(v6 + 1664, v12) + 8) = v11;
  *(_BYTE *)(v5 + 96) = 2;
  *(_QWORD *)(v5 + 176) = v12;
  return 1;
}

uint64_t re::AsinFloatCompile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  float *v9;
  uint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t result;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_8;
  }
  if (!a3)
  {
LABEL_8:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v5 = *a4;
  v6 = *(_QWORD *)(a1 + 8);
  v7 = *(_QWORD *)a2;
  if (*(_BYTE *)(*(_QWORD *)a2 + 96) == 1)
  {
    v8 = *(_QWORD **)(v7 + 16);
    v9 = (float *)(v7 + 112);
    LODWORD(v14) = 2;
    v16 = 0;
    v17 = 0;
    v15 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 218), (uint64_t)&v14);
    v14 = v8[220] - 1;
    re::DynamicArray<unsigned long>::add(v8 + 11, &v14);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v8 + 51), v9);
    v10 = (uint64_t *)(v8[15] + 8 * v8[13] - 8);
  }
  else
  {
    v10 = (uint64_t *)(v7 + 176);
  }
  v11 = *v10;
  LODWORD(v14) = 56;
  v16 = 0;
  v17 = 0;
  v15 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v6 + 1744), (uint64_t)&v14);
  v12 = *(_QWORD *)(v6 + 1760) - 1;
  *(_QWORD *)(re::DynamicEvaluationRegisterTable::evaluationRegister<float>(v6 + 1664, v12) + 8) = v11;
  *(_BYTE *)(v5 + 96) = 2;
  *(_QWORD *)(v5 + 176) = v12;
  return 1;
}

uint64_t re::AcosFloatCompile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  float *v9;
  uint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t result;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_8;
  }
  if (!a3)
  {
LABEL_8:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v5 = *a4;
  v6 = *(_QWORD *)(a1 + 8);
  v7 = *(_QWORD *)a2;
  if (*(_BYTE *)(*(_QWORD *)a2 + 96) == 1)
  {
    v8 = *(_QWORD **)(v7 + 16);
    v9 = (float *)(v7 + 112);
    LODWORD(v14) = 2;
    v16 = 0;
    v17 = 0;
    v15 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 218), (uint64_t)&v14);
    v14 = v8[220] - 1;
    re::DynamicArray<unsigned long>::add(v8 + 11, &v14);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v8 + 51), v9);
    v10 = (uint64_t *)(v8[15] + 8 * v8[13] - 8);
  }
  else
  {
    v10 = (uint64_t *)(v7 + 176);
  }
  v11 = *v10;
  LODWORD(v14) = 57;
  v16 = 0;
  v17 = 0;
  v15 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v6 + 1744), (uint64_t)&v14);
  v12 = *(_QWORD *)(v6 + 1760) - 1;
  *(_QWORD *)(re::DynamicEvaluationRegisterTable::evaluationRegister<float>(v6 + 1664, v12) + 8) = v11;
  *(_BYTE *)(v5 + 96) = 2;
  *(_QWORD *)(v5 + 176) = v12;
  return 1;
}

uint64_t re::AtanFloatCompile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  float *v9;
  uint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t result;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_8;
  }
  if (!a3)
  {
LABEL_8:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v5 = *a4;
  v6 = *(_QWORD *)(a1 + 8);
  v7 = *(_QWORD *)a2;
  if (*(_BYTE *)(*(_QWORD *)a2 + 96) == 1)
  {
    v8 = *(_QWORD **)(v7 + 16);
    v9 = (float *)(v7 + 112);
    LODWORD(v14) = 2;
    v16 = 0;
    v17 = 0;
    v15 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 218), (uint64_t)&v14);
    v14 = v8[220] - 1;
    re::DynamicArray<unsigned long>::add(v8 + 11, &v14);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v8 + 51), v9);
    v10 = (uint64_t *)(v8[15] + 8 * v8[13] - 8);
  }
  else
  {
    v10 = (uint64_t *)(v7 + 176);
  }
  v11 = *v10;
  LODWORD(v14) = 58;
  v16 = 0;
  v17 = 0;
  v15 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v6 + 1744), (uint64_t)&v14);
  v12 = *(_QWORD *)(v6 + 1760) - 1;
  *(_QWORD *)(re::DynamicEvaluationRegisterTable::evaluationRegister<float>(v6 + 1664, v12) + 8) = v11;
  *(_BYTE *)(v5 + 96) = 2;
  *(_QWORD *)(v5 + 176) = v12;
  return 1;
}

uint64_t re::Atan2FloatCompile(uint64_t a1, _QWORD *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  float *v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  float *v16;
  uint64_t *v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t result;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (!a3)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v7 = *a4;
  v8 = *(_QWORD *)(a1 + 8);
  v9 = *a2;
  if (*(_BYTE *)(*a2 + 96) == 1)
  {
    v10 = *(_QWORD **)(v9 + 16);
    v11 = (float *)(v9 + 112);
    LODWORD(v22) = 2;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v10 + 218), (uint64_t)&v22);
    v22 = v10[220] - 1;
    re::DynamicArray<unsigned long>::add(v10 + 11, &v22);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v10 + 51), v11);
    v12 = (uint64_t *)(v10[15] + 8 * v10[13] - 8);
  }
  else
  {
    v12 = (uint64_t *)(v9 + 176);
  }
  if (a3 <= 1)
    goto LABEL_13;
  v13 = *v12;
  v14 = a2[1];
  if (*(_BYTE *)(v14 + 96) == 1)
  {
    v15 = *(_QWORD **)(v14 + 16);
    v16 = (float *)(v14 + 112);
    LODWORD(v22) = 2;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 218), (uint64_t)&v22);
    v22 = v15[220] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 11, &v22);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v15 + 51), v16);
    v17 = (uint64_t *)(v15[15] + 8 * v15[13] - 8);
  }
  else
  {
    v17 = (uint64_t *)(v14 + 176);
  }
  v18 = *v17;
  LODWORD(v22) = 59;
  v24 = 0;
  v25 = 0;
  v23 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 1744), (uint64_t)&v22);
  v19 = *(_QWORD *)(v8 + 1760) - 1;
  v20 = re::DynamicEvaluationRegisterTable::evaluationRegister<float>(v8 + 1664, v19);
  *(_QWORD *)(v20 + 8) = v13;
  *(_QWORD *)(v20 + 16) = v18;
  *(_BYTE *)(v7 + 96) = 2;
  *(_QWORD *)(v7 + 176) = v19;
  return 1;
}

uint64_t re::GreaterCompile(uint64_t a1, _QWORD *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  float *v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  float *v16;
  uint64_t *v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t result;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (!a3)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v7 = *a4;
  v8 = *(_QWORD *)(a1 + 8);
  v9 = *a2;
  if (*(_BYTE *)(*a2 + 96) == 1)
  {
    v10 = *(_QWORD **)(v9 + 16);
    v11 = (float *)(v9 + 112);
    LODWORD(v22) = 2;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v10 + 218), (uint64_t)&v22);
    v22 = v10[220] - 1;
    re::DynamicArray<unsigned long>::add(v10 + 11, &v22);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v10 + 51), v11);
    v12 = (uint64_t *)(v10[15] + 8 * v10[13] - 8);
  }
  else
  {
    v12 = (uint64_t *)(v9 + 176);
  }
  if (a3 <= 1)
    goto LABEL_13;
  v13 = *v12;
  v14 = a2[1];
  if (*(_BYTE *)(v14 + 96) == 1)
  {
    v15 = *(_QWORD **)(v14 + 16);
    v16 = (float *)(v14 + 112);
    LODWORD(v22) = 2;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 218), (uint64_t)&v22);
    v22 = v15[220] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 11, &v22);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v15 + 51), v16);
    v17 = (uint64_t *)(v15[15] + 8 * v15[13] - 8);
  }
  else
  {
    v17 = (uint64_t *)(v14 + 176);
  }
  v18 = *v17;
  LODWORD(v22) = 61;
  v24 = 0;
  v25 = 0;
  v23 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 1704), (uint64_t)&v22);
  v19 = *(_QWORD *)(v8 + 1720) - 1;
  v20 = re::DynamicEvaluationRegisterTable::evaluationRegister<unsigned int>(v8 + 1664, v19);
  *(_QWORD *)(v20 + 8) = v13;
  *(_QWORD *)(v20 + 16) = v18;
  *(_BYTE *)(v7 + 96) = 2;
  *(_QWORD *)(v7 + 176) = v19;
  return 1;
}

uint64_t re::GreaterEqualCompile(uint64_t a1, _QWORD *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  float *v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  float *v16;
  uint64_t *v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t result;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (!a3)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v7 = *a4;
  v8 = *(_QWORD *)(a1 + 8);
  v9 = *a2;
  if (*(_BYTE *)(*a2 + 96) == 1)
  {
    v10 = *(_QWORD **)(v9 + 16);
    v11 = (float *)(v9 + 112);
    LODWORD(v22) = 2;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v10 + 218), (uint64_t)&v22);
    v22 = v10[220] - 1;
    re::DynamicArray<unsigned long>::add(v10 + 11, &v22);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v10 + 51), v11);
    v12 = (uint64_t *)(v10[15] + 8 * v10[13] - 8);
  }
  else
  {
    v12 = (uint64_t *)(v9 + 176);
  }
  if (a3 <= 1)
    goto LABEL_13;
  v13 = *v12;
  v14 = a2[1];
  if (*(_BYTE *)(v14 + 96) == 1)
  {
    v15 = *(_QWORD **)(v14 + 16);
    v16 = (float *)(v14 + 112);
    LODWORD(v22) = 2;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 218), (uint64_t)&v22);
    v22 = v15[220] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 11, &v22);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v15 + 51), v16);
    v17 = (uint64_t *)(v15[15] + 8 * v15[13] - 8);
  }
  else
  {
    v17 = (uint64_t *)(v14 + 176);
  }
  v18 = *v17;
  LODWORD(v22) = 62;
  v24 = 0;
  v25 = 0;
  v23 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 1704), (uint64_t)&v22);
  v19 = *(_QWORD *)(v8 + 1720) - 1;
  v20 = re::DynamicEvaluationRegisterTable::evaluationRegister<unsigned int>(v8 + 1664, v19);
  *(_QWORD *)(v20 + 8) = v13;
  *(_QWORD *)(v20 + 16) = v18;
  *(_BYTE *)(v7 + 96) = 2;
  *(_QWORD *)(v7 + 176) = v19;
  return 1;
}

uint64_t re::LessCompile(uint64_t a1, _QWORD *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  float *v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  float *v16;
  uint64_t *v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t result;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (!a3)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v7 = *a4;
  v8 = *(_QWORD *)(a1 + 8);
  v9 = *a2;
  if (*(_BYTE *)(*a2 + 96) == 1)
  {
    v10 = *(_QWORD **)(v9 + 16);
    v11 = (float *)(v9 + 112);
    LODWORD(v22) = 2;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v10 + 218), (uint64_t)&v22);
    v22 = v10[220] - 1;
    re::DynamicArray<unsigned long>::add(v10 + 11, &v22);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v10 + 51), v11);
    v12 = (uint64_t *)(v10[15] + 8 * v10[13] - 8);
  }
  else
  {
    v12 = (uint64_t *)(v9 + 176);
  }
  if (a3 <= 1)
    goto LABEL_13;
  v13 = *v12;
  v14 = a2[1];
  if (*(_BYTE *)(v14 + 96) == 1)
  {
    v15 = *(_QWORD **)(v14 + 16);
    v16 = (float *)(v14 + 112);
    LODWORD(v22) = 2;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 218), (uint64_t)&v22);
    v22 = v15[220] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 11, &v22);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v15 + 51), v16);
    v17 = (uint64_t *)(v15[15] + 8 * v15[13] - 8);
  }
  else
  {
    v17 = (uint64_t *)(v14 + 176);
  }
  v18 = *v17;
  LODWORD(v22) = 63;
  v24 = 0;
  v25 = 0;
  v23 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 1704), (uint64_t)&v22);
  v19 = *(_QWORD *)(v8 + 1720) - 1;
  v20 = re::DynamicEvaluationRegisterTable::evaluationRegister<unsigned int>(v8 + 1664, v19);
  *(_QWORD *)(v20 + 8) = v13;
  *(_QWORD *)(v20 + 16) = v18;
  *(_BYTE *)(v7 + 96) = 2;
  *(_QWORD *)(v7 + 176) = v19;
  return 1;
}

uint64_t re::LessEqualCompile(uint64_t a1, _QWORD *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  float *v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  float *v16;
  uint64_t *v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t result;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (!a3)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v7 = *a4;
  v8 = *(_QWORD *)(a1 + 8);
  v9 = *a2;
  if (*(_BYTE *)(*a2 + 96) == 1)
  {
    v10 = *(_QWORD **)(v9 + 16);
    v11 = (float *)(v9 + 112);
    LODWORD(v22) = 2;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v10 + 218), (uint64_t)&v22);
    v22 = v10[220] - 1;
    re::DynamicArray<unsigned long>::add(v10 + 11, &v22);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v10 + 51), v11);
    v12 = (uint64_t *)(v10[15] + 8 * v10[13] - 8);
  }
  else
  {
    v12 = (uint64_t *)(v9 + 176);
  }
  if (a3 <= 1)
    goto LABEL_13;
  v13 = *v12;
  v14 = a2[1];
  if (*(_BYTE *)(v14 + 96) == 1)
  {
    v15 = *(_QWORD **)(v14 + 16);
    v16 = (float *)(v14 + 112);
    LODWORD(v22) = 2;
    v24 = 0;
    v25 = 0;
    v23 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 218), (uint64_t)&v22);
    v22 = v15[220] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 11, &v22);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v15 + 51), v16);
    v17 = (uint64_t *)(v15[15] + 8 * v15[13] - 8);
  }
  else
  {
    v17 = (uint64_t *)(v14 + 176);
  }
  v18 = *v17;
  LODWORD(v22) = 64;
  v24 = 0;
  v25 = 0;
  v23 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 1704), (uint64_t)&v22);
  v19 = *(_QWORD *)(v8 + 1720) - 1;
  v20 = re::DynamicEvaluationRegisterTable::evaluationRegister<unsigned int>(v8 + 1664, v19);
  *(_QWORD *)(v20 + 8) = v13;
  *(_QWORD *)(v20 + 16) = v18;
  *(_BYTE *)(v7 + 96) = 2;
  *(_QWORD *)(v7 + 176) = v19;
  return 1;
}

uint64_t re::SelectFloatCompile(uint64_t a1, _QWORD *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  _DWORD *v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  float *v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  float *v21;
  uint64_t *v22;
  uint64_t v23;
  unint64_t v24;
  _QWORD *v25;
  uint64_t result;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;

  if (!a5)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_16;
  }
  if (!a3)
  {
LABEL_16:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_17:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    _os_crash();
    __break(1u);
LABEL_18:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v7 = *a4;
  v8 = *(_QWORD *)(a1 + 8);
  v9 = *a2;
  if (*(_BYTE *)(*a2 + 96) == 1)
  {
    v10 = *(_QWORD **)(v9 + 16);
    v11 = (_DWORD *)(v9 + 112);
    LODWORD(v27) = 1;
    v29 = 0;
    v30 = 0;
    v28 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v10 + 213), (uint64_t)&v27);
    v27 = v10[215] - 1;
    re::DynamicArray<unsigned long>::add(v10 + 6, &v27);
    re::DynamicArray<int>::add(v10 + 46, v11);
    v12 = (uint64_t *)(v10[10] + 8 * v10[8] - 8);
  }
  else
  {
    v12 = (uint64_t *)(v9 + 176);
  }
  if (a3 <= 1)
    goto LABEL_17;
  v13 = *v12;
  v14 = a2[1];
  if (*(_BYTE *)(v14 + 96) == 1)
  {
    v15 = *(_QWORD **)(v14 + 16);
    v16 = (float *)(v14 + 112);
    LODWORD(v27) = 2;
    v29 = 0;
    v30 = 0;
    v28 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v15 + 218), (uint64_t)&v27);
    v27 = v15[220] - 1;
    re::DynamicArray<unsigned long>::add(v15 + 11, &v27);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v15 + 51), v16);
    v17 = (uint64_t *)(v15[15] + 8 * v15[13] - 8);
  }
  else
  {
    v17 = (uint64_t *)(v14 + 176);
  }
  if (a3 <= 2)
    goto LABEL_18;
  v18 = *v17;
  v19 = a2[2];
  if (*(_BYTE *)(v19 + 96) == 1)
  {
    v20 = *(_QWORD **)(v19 + 16);
    v21 = (float *)(v19 + 112);
    LODWORD(v27) = 2;
    v29 = 0;
    v30 = 0;
    v28 = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v20 + 218), (uint64_t)&v27);
    v27 = v20[220] - 1;
    re::DynamicArray<unsigned long>::add(v20 + 11, &v27);
    re::DynamicArray<float>::add((_anonymous_namespace_ *)(v20 + 51), v21);
    v22 = (uint64_t *)(v20[15] + 8 * v20[13] - 8);
  }
  else
  {
    v22 = (uint64_t *)(v19 + 176);
  }
  v23 = *v22;
  LODWORD(v27) = 60;
  v29 = 0;
  v30 = 0;
  v28 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v8 + 1744), (uint64_t)&v27);
  v24 = *(_QWORD *)(v8 + 1760) - 1;
  v25 = (_QWORD *)re::DynamicEvaluationRegisterTable::evaluationRegister<float>(v8 + 1664, v24);
  v25[1] = v13;
  v25[2] = v18;
  v25[3] = v23;
  *(_BYTE *)(v7 + 96) = 2;
  *(_QWORD *)(v7 + 176) = v24;
  return 1;
}

uint64_t re::BlendRigHierarchyCompile(uint64_t a1, _QWORD *a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  re::RigHierarchy *v8;
  _anonymous_namespace_ *v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  size_t v13;
  size_t v14;
  size_t v15;
  size_t v16;
  size_t v17;
  size_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  _QWORD *v22;
  float *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t *v26;
  size_t v27;
  size_t v28;
  size_t v29;
  uint64_t v30;
  __int128 v31;
  uint64_t result;
  uint64_t v35;
  _anonymous_namespace_ *v36;
  _BYTE v37[24];
  __int128 v38;
  __int128 v39;
  _BYTE v40[24];
  __int128 v41;
  __int128 v42;
  uint64_t v43;
  size_t v44;
  _BYTE v45[24];
  __int128 v46;
  __int128 v47;
  uint64_t v48[3];
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  char v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  char v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  char v60;
  uint64_t v61[3];
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  char v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  char v69;
  _BYTE v70[8];
  uint64_t v71;
  uint64_t v72;
  char v73;
  __int128 v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78[5];
  uint64_t v79[5];
  uint64_t v80[5];
  uint64_t v81[5];
  uint64_t v82[5];
  uint64_t v83[5];
  uint64_t v84;
  size_t v85;
  uint64_t v86;
  uint64_t v87;

  if (!a3)
  {
LABEL_53:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_54;
  }
  if (a3 == 1)
  {
LABEL_54:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    _os_crash();
    __break(1u);
    goto LABEL_55;
  }
  v8 = *(re::RigHierarchy **)(*a2 + 184);
  v9 = *(_anonymous_namespace_ **)(a2[1] + 184);
  re::RigHierarchy::getBindPoseHierarchy(v8, (uint64_t)a2, (uint64_t)&v74);
  if (*((_QWORD *)v8 + 27))
  {
    v11 = 0;
    v35 = a1;
    v36 = v9;
    while (1)
    {
      v12 = re::RigHierarchy::jointName(v8, v11);
      v13 = strlen(*(const char **)(v12 + 8));
      v66 = *(_QWORD *)(v12 + 8);
      v67 = v13;
      re::RigHierarchy::getLocalSpaceJointScale(v8, (uint64_t)&v66, (uint64_t)v70);
      v14 = strlen(*(const char **)(v12 + 8));
      v62 = *(_QWORD *)(v12 + 8);
      v63 = v14;
      re::RigHierarchy::getLocalSpaceJointRotation(v8, (uint64_t)&v62, (uint64_t)&v66);
      v15 = strlen(*(const char **)(v12 + 8));
      v57 = *(_QWORD *)(v12 + 8);
      v58 = v15;
      re::RigHierarchy::getLocalSpaceJointTranslation(v8, (uint64_t)&v57, (uint64_t)&v62);
      v61[0] = v71;
      v61[1] = v67;
      v61[2] = v63;
      v16 = strlen(*(const char **)(v12 + 8));
      v53 = *(_QWORD *)(v12 + 8);
      v54 = v16;
      re::RigHierarchy::getLocalSpaceJointScale(v9, (uint64_t)&v53, (uint64_t)&v57);
      v17 = strlen(*(const char **)(v12 + 8));
      v49 = *(_QWORD *)(v12 + 8);
      v50 = v17;
      re::RigHierarchy::getLocalSpaceJointRotation(v9, (uint64_t)&v49, (uint64_t)&v53);
      v18 = strlen(*(const char **)(v12 + 8));
      v84 = *(_QWORD *)(v12 + 8);
      v85 = v18;
      re::RigHierarchy::getLocalSpaceJointTranslation(v9, (uint64_t)&v84, (uint64_t)&v49);
      v48[0] = v58;
      v48[1] = v54;
      v48[2] = v50;
      if (a3 <= 2)
        break;
      v20 = *(_QWORD **)(a1 + 8);
      v21 = a2[2];
      if (*(_BYTE *)(v21 + 96) == 1)
      {
        v22 = *(_QWORD **)(v21 + 16);
        v23 = (float *)(v21 + 112);
        LODWORD(v84) = 2;
        v86 = 0;
        v87 = 0;
        v85 = 0;
        re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(v22 + 218), (uint64_t)&v84);
        v84 = v22[220] - 1;
        re::DynamicArray<unsigned long>::add(v22 + 11, &v84);
        re::DynamicArray<float>::add((_anonymous_namespace_ *)(v22 + 51), v23);
        v24 = v22[15];
        v25 = v22[13];
        a1 = v35;
        v9 = v36;
        v26 = (uint64_t *)(v24 + 8 * v25 - 8);
      }
      else
      {
        v26 = (uint64_t *)(v21 + 176);
      }
      re::EvaluationTree::lerp(v20, v61, v48, *v26, (unint64_t *)&v84);
      v27 = strlen(*(const char **)(v12 + 8));
      v43 = *(_QWORD *)(v12 + 8);
      v44 = v27;
      re::RigHierarchy::setLocalSpaceJointScale((_anonymous_namespace_ *)&v74, (uint64_t)&v43, v84, (uint64_t)v45);
      if (!v45[0] && (_QWORD)v46)
      {
        if ((BYTE8(v46) & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v46 + 40))();
        v46 = 0u;
        v47 = 0u;
      }
      v28 = strlen(*(const char **)(v12 + 8));
      v43 = *(_QWORD *)(v12 + 8);
      v44 = v28;
      re::RigHierarchy::setLocalSpaceJointRotation((_anonymous_namespace_ *)&v74, (uint64_t)&v43, v85, (uint64_t)v40);
      if (!v40[0] && (_QWORD)v41)
      {
        if ((BYTE8(v41) & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v41 + 40))();
        v41 = 0u;
        v42 = 0u;
      }
      v29 = strlen(*(const char **)(v12 + 8));
      v43 = *(_QWORD *)(v12 + 8);
      v44 = v29;
      re::RigHierarchy::setLocalSpaceJointTranslation((_anonymous_namespace_ *)&v74, (uint64_t)&v43, v86, (uint64_t)v37);
      if (!v37[0] && (_QWORD)v38)
      {
        if ((BYTE8(v38) & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v38 + 40))();
        v38 = 0u;
        v39 = 0u;
      }
      if (!(_BYTE)v49 && v51 && (v52 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v51 + 40))();
      if (!(_BYTE)v53 && v55 && (v56 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v55 + 40))();
      if (!(_BYTE)v57 && v59 && (v60 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v59 + 40))();
      if (!(_BYTE)v62 && v64 && (v65 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v64 + 40))();
      if (!(_BYTE)v66 && v68 && (v69 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v68 + 40))();
      if (!v70[0] && v72 && (v73 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v72 + 40))();
      if (++v11 >= *((_QWORD *)v8 + 27))
        goto LABEL_50;
    }
    re::internal::assertLog((re::internal *)6, v19, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2);
    _os_crash();
    __break(1u);
    goto LABEL_53;
  }
LABEL_50:
  if (a5)
  {
    v30 = *(_QWORD *)(*(_QWORD *)a4 + 184);
    v31 = v74;
    *(_QWORD *)(v30 + 16) = v75;
    *(_OWORD *)v30 = v31;
    re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v30 + 24, (uint64_t)&v76);
    re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v30 + 72, (uint64_t)&v77);
    re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::operator=(v30 + 120, v78);
    re::DynamicArray<re::DynamicArray<re::RigDataValue>>::operator=(v30 + 160, v79);
    re::DynamicArray<re::StringID>::operator=(v30 + 200, v80);
    re::DynamicArray<unsigned long>::operator=(v30 + 240, v81);
    re::DynamicArray<re::RigHierarchyJointTransform>::operator=(v30 + 280, v82);
    re::DynamicArray<unsigned long>::operator=(v30 + 320, v83);
    re::RigHierarchy::~RigHierarchy((re::RigHierarchy *)&v74);
    return 1;
  }
LABEL_55:
  re::internal::assertLog((re::internal *)6, v10, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::BlendAdditiveRigHierarchyCompile(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  re::RigHierarchy *v7;
  _anonymous_namespace_ *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  size_t v12;
  size_t v13;
  size_t v14;
  size_t v15;
  size_t v16;
  size_t v17;
  size_t v18;
  size_t v19;
  const char *v20;
  size_t v21;
  uint64_t v22;
  __int128 v23;
  uint64_t result;
  char v26[24];
  __int128 v27;
  __int128 v28;
  char v29[24];
  __int128 v30;
  __int128 v31;
  const char *v32;
  size_t v33;
  char v34[24];
  __int128 v35;
  __int128 v36;
  unint64_t v37[3];
  uint64_t v38;
  size_t v39;
  size_t v40;
  uint64_t v41;
  size_t v42;
  uint64_t v43;
  char v44;
  uint64_t v45;
  size_t v46;
  uint64_t v47;
  char v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  char v52;
  uint64_t v53[3];
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  char v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  char v61;
  char v62[8];
  uint64_t v63;
  uint64_t v64;
  char v65;
  __int128 v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70[5];
  uint64_t v71[5];
  uint64_t v72[5];
  uint64_t v73[5];
  uint64_t v74[5];
  uint64_t v75[6];

  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_49;
  }
  if (a3 == 1)
  {
LABEL_49:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    _os_crash();
    __break(1u);
    goto LABEL_50;
  }
  v7 = *(re::RigHierarchy **)(*a2 + 184);
  v8 = *(_anonymous_namespace_ **)(a2[1] + 184);
  re::RigHierarchy::getBindPoseHierarchy(v7, (uint64_t)a2, (uint64_t)&v66);
  if (*((_QWORD *)v7 + 27))
  {
    v10 = 0;
    do
    {
      v11 = re::RigHierarchy::jointName(v7, v10);
      v12 = strlen(*(const char **)(v11 + 8));
      v58 = *(_QWORD *)(v11 + 8);
      v59 = v12;
      re::RigHierarchy::getLocalSpaceJointScale(v7, (uint64_t)&v58, (uint64_t)v62);
      v13 = strlen(*(const char **)(v11 + 8));
      v54 = *(_QWORD *)(v11 + 8);
      v55 = v13;
      re::RigHierarchy::getLocalSpaceJointRotation(v7, (uint64_t)&v54, (uint64_t)&v58);
      v14 = strlen(*(const char **)(v11 + 8));
      v49 = *(_QWORD *)(v11 + 8);
      v50 = v14;
      re::RigHierarchy::getLocalSpaceJointTranslation(v7, (uint64_t)&v49, (uint64_t)&v54);
      v53[0] = v63;
      v53[1] = v59;
      v53[2] = v55;
      v15 = strlen(*(const char **)(v11 + 8));
      v45 = *(_QWORD *)(v11 + 8);
      v46 = v15;
      re::RigHierarchy::getLocalSpaceJointScale(v8, (uint64_t)&v45, (uint64_t)&v49);
      v16 = strlen(*(const char **)(v11 + 8));
      v41 = *(_QWORD *)(v11 + 8);
      v42 = v16;
      re::RigHierarchy::getLocalSpaceJointRotation(v8, (uint64_t)&v41, (uint64_t)&v45);
      v17 = strlen(*(const char **)(v11 + 8));
      v38 = *(_QWORD *)(v11 + 8);
      v39 = v17;
      re::RigHierarchy::getLocalSpaceJointTranslation(v8, (uint64_t)&v38, (uint64_t)&v41);
      v38 = v50;
      v39 = v46;
      v40 = v42;
      re::EvaluationTree::additiveBlend(*(_QWORD **)(a1 + 8), v53, &v38, v37);
      v18 = strlen(*(const char **)(v11 + 8));
      v32 = *(const char **)(v11 + 8);
      v33 = v18;
      re::RigHierarchy::setLocalSpaceJointScale((_anonymous_namespace_ *)&v66, (uint64_t)&v32, v37[0], (uint64_t)v34);
      if (!v34[0] && (_QWORD)v35)
      {
        if ((BYTE8(v35) & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v35 + 40))();
        v35 = 0u;
        v36 = 0u;
      }
      v19 = strlen(*(const char **)(v11 + 8));
      v32 = *(const char **)(v11 + 8);
      v33 = v19;
      re::RigHierarchy::setLocalSpaceJointRotation((_anonymous_namespace_ *)&v66, (uint64_t)&v32, v37[1], (uint64_t)v29);
      if (!v29[0] && (_QWORD)v30)
      {
        if ((BYTE8(v30) & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v30 + 40))();
        v30 = 0u;
        v31 = 0u;
      }
      v20 = *(const char **)(v11 + 8);
      v21 = strlen(v20);
      v32 = v20;
      v33 = v21;
      re::RigHierarchy::setLocalSpaceJointTranslation((_anonymous_namespace_ *)&v66, (uint64_t)&v32, v37[2], (uint64_t)v26);
      if (!v26[0] && (_QWORD)v27)
      {
        if ((BYTE8(v27) & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v27 + 40))();
        v27 = 0u;
        v28 = 0u;
      }
      if (!(_BYTE)v41 && v43 && (v44 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v43 + 40))();
      if (!(_BYTE)v45 && v47 && (v48 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v47 + 40))();
      if (!(_BYTE)v49 && v51 && (v52 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v51 + 40))();
      if (!(_BYTE)v54 && v56 && (v57 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v56 + 40))();
      if (!(_BYTE)v58 && v60 && (v61 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v60 + 40))();
      if (!v62[0] && v64 && (v65 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v64 + 40))();
      ++v10;
    }
    while (v10 < *((_QWORD *)v7 + 27));
  }
  if (a5)
  {
    v22 = *(_QWORD *)(*(_QWORD *)a4 + 184);
    v23 = v66;
    *(_QWORD *)(v22 + 16) = v67;
    *(_OWORD *)v22 = v23;
    re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v22 + 24, (uint64_t)&v68);
    re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v22 + 72, (uint64_t)&v69);
    re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::operator=(v22 + 120, v70);
    re::DynamicArray<re::DynamicArray<re::RigDataValue>>::operator=(v22 + 160, v71);
    re::DynamicArray<re::StringID>::operator=(v22 + 200, v72);
    re::DynamicArray<unsigned long>::operator=(v22 + 240, v73);
    re::DynamicArray<re::RigHierarchyJointTransform>::operator=(v22 + 280, v74);
    re::DynamicArray<unsigned long>::operator=(v22 + 320, v75);
    re::RigHierarchy::~RigHierarchy((re::RigHierarchy *)&v66);
    return 1;
  }
LABEL_50:
  re::internal::assertLog((re::internal *)6, v9, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
  result = _os_crash();
  __break(1u);
  return result;
}

void re::RigGraphOperatorDefinition::registerBuiltIns(re::RigGraphOperatorDefinition *this, re::RigEnvironment *a2)
{
  _anonymous_namespace_ *v3;
  _anonymous_namespace_ *v4;
  _anonymous_namespace_ *v5;
  _anonymous_namespace_ *v6;
  _anonymous_namespace_ *v7;
  _anonymous_namespace_ *v8;
  _anonymous_namespace_ *v9;
  _anonymous_namespace_ *v10;
  _anonymous_namespace_ *v11;
  _anonymous_namespace_ *v12;
  _anonymous_namespace_ *v13;
  _anonymous_namespace_ *v14;
  _anonymous_namespace_ *v15;
  _anonymous_namespace_ *v16;
  _anonymous_namespace_ *v17;
  _anonymous_namespace_ *v18;
  _anonymous_namespace_ *v19;
  _anonymous_namespace_ *v20;
  _anonymous_namespace_ *v21;
  _anonymous_namespace_ *v22;
  _anonymous_namespace_ *v23;
  _anonymous_namespace_ *v24;
  _anonymous_namespace_ *v25;
  _anonymous_namespace_ *v26;
  _anonymous_namespace_ *v27;
  _anonymous_namespace_ *v28;
  _anonymous_namespace_ *v29;
  _anonymous_namespace_ *v30;
  _anonymous_namespace_ *v31;
  _anonymous_namespace_ *v32;
  _anonymous_namespace_ *v33;
  _anonymous_namespace_ *v34;
  _anonymous_namespace_ *v35;
  _anonymous_namespace_ *v36;
  _anonymous_namespace_ *v37;
  _anonymous_namespace_ *v38;
  _anonymous_namespace_ *v39;
  _anonymous_namespace_ *v40;
  _anonymous_namespace_ *v41;
  _anonymous_namespace_ *v42;
  _anonymous_namespace_ *v43;
  _anonymous_namespace_ *v44;
  _anonymous_namespace_ *v45;
  _anonymous_namespace_ *v46;
  _anonymous_namespace_ *v47;
  _anonymous_namespace_ *v48;
  _anonymous_namespace_ *v49;
  _anonymous_namespace_ *v50;
  _anonymous_namespace_ *v51;
  _anonymous_namespace_ *v52;
  _anonymous_namespace_ *v53;
  _anonymous_namespace_ *v54;
  _anonymous_namespace_ *v55;
  _anonymous_namespace_ *v56;
  _anonymous_namespace_ *v57;
  _anonymous_namespace_ *v58;
  _anonymous_namespace_ *v59;
  _anonymous_namespace_ *v60;
  _anonymous_namespace_ *v61;
  _anonymous_namespace_ *v62;
  _anonymous_namespace_ *v63;
  _anonymous_namespace_ *v64;
  _anonymous_namespace_ *v65;
  _anonymous_namespace_ *v66;
  _anonymous_namespace_ *v67;
  _anonymous_namespace_ *v68;
  _anonymous_namespace_ *v69;
  _anonymous_namespace_ *v70;
  _anonymous_namespace_ *v71;
  _anonymous_namespace_ *v72;
  _anonymous_namespace_ *v73;
  _anonymous_namespace_ *v74;
  _anonymous_namespace_ *v75;
  _anonymous_namespace_ *v76;
  _anonymous_namespace_ *v77;
  _anonymous_namespace_ *v78;
  _anonymous_namespace_ *v79;
  _anonymous_namespace_ *v80;
  _anonymous_namespace_ *v81;
  _anonymous_namespace_ *v82;
  _anonymous_namespace_ *v83;
  _anonymous_namespace_ *v84;
  _anonymous_namespace_ *v85;
  _anonymous_namespace_ *v86;
  _anonymous_namespace_ *v87;
  _anonymous_namespace_ *v88;
  _anonymous_namespace_ *v89;
  _anonymous_namespace_ *v90;
  _anonymous_namespace_ *v91;
  _anonymous_namespace_ *v92;
  uint64_t v93;
  void *v94;
  unint64_t v95;
  void *v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  uint64_t v100;
  __int128 v101;
  __int128 v102;
  __int128 v103;
  __int128 v104;
  uint64_t v105;

  v105 = *MEMORY[0x24BDAC8D0];
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED212C8;
  v102 = *(_OWORD *)&off_24ED212D8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 1uLL, 1uLL, (unint64_t)re::ConjugateQuaternionCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21308;
  v102 = *(_OWORD *)&off_24ED21318;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 1uLL, 1uLL, (unint64_t)re::InvertMatrix3x3Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED212A8;
  v102 = *(_OWORD *)&off_24ED212B8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 1uLL, 1uLL, (unint64_t)re::InvertMatrix4x4Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED212C8;
  v102 = *(_OWORD *)&off_24ED212D8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 1uLL, 1uLL, (unint64_t)re::InvertQuaternionCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED212E8;
  v102 = *(_OWORD *)&off_24ED212F8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 1uLL, 1uLL, (unint64_t)re::NormalizeVector3Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21308;
  v102 = *(_OWORD *)&off_24ED21318;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 1uLL, 1uLL, (unint64_t)re::TransposeMatrix3x3Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21328;
  v102 = *(_OWORD *)&off_24ED21338;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 1uLL, 1uLL, (unint64_t)re::PassthroughRigHierarchyCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21328;
  v102 = *(_OWORD *)&off_24ED21338;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 1uLL, 1uLL, (unint64_t)re::GetBindPoseRigHierarchyCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21348;
  v102 = *(_OWORD *)&off_24ED21358;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 1uLL, 1uLL, (unint64_t)re::ExtractMinorMatrix4x4Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21368;
  v102 = *(_OWORD *)&off_24ED21378;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 1uLL, 1uLL, (unint64_t)re::ExtractRotationMatrix3x3Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21388;
  v102 = *(_OWORD *)&off_24ED21398;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 1uLL, 1uLL, (unint64_t)re::ExtractRotationMatrix4x4Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED213A8;
  v102 = *(_OWORD *)&off_24ED213B8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 1uLL, 1uLL, (unint64_t)re::ExtractScaleMatrix4x4Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED213A8;
  v102 = *(_OWORD *)&off_24ED213B8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 1uLL, 1uLL, (unint64_t)re::ExtractTranslationMatrix4x4Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED213C8;
  v102 = *(_OWORD *)&off_24ED213D8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 1uLL, 1uLL, (unint64_t)re::ConstructMatrix4x4FromSRTCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED213E8;
  v102 = *(_OWORD *)&off_24ED213F8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 1uLL, 1uLL, (unint64_t)re::ConstructSRTFromMatrix4x4Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21748;
  v102 = *(_OWORD *)&off_24ED21758;
  v103 = xmmword_24ED21768;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::AddVector3Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21408;
  v102 = *(_OWORD *)&off_24ED21418;
  v103 = xmmword_24ED21428;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::AddVector2Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21BE8;
  v102 = *(_OWORD *)&off_24ED21BF8;
  v103 = xmmword_24ED21C08;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::AddFloatCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21748;
  v102 = *(_OWORD *)&off_24ED21758;
  v103 = xmmword_24ED21768;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::SubtractVector3Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21408;
  v102 = *(_OWORD *)&off_24ED21418;
  v103 = xmmword_24ED21428;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::SubtractVector2Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21BE8;
  v102 = *(_OWORD *)&off_24ED21BF8;
  v103 = xmmword_24ED21C08;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::SubtractFloatCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21718;
  v102 = *(_OWORD *)&off_24ED21728;
  v103 = xmmword_24ED21738;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::DivideQuaternionCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21BE8;
  v102 = *(_OWORD *)&off_24ED21BF8;
  v103 = xmmword_24ED21C08;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::DivideFloatCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21BE8;
  v102 = *(_OWORD *)&off_24ED21BF8;
  v103 = xmmword_24ED21C08;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::MultiplyFloatCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21438;
  v102 = *(_OWORD *)&off_24ED21448;
  v103 = xmmword_24ED21458;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::RotateVector3Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21468;
  v102 = *(_OWORD *)&off_24ED21478;
  v103 = xmmword_24ED21488;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::ScaleVector3Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21498;
  v102 = *(_OWORD *)&off_24ED214A8;
  v103 = xmmword_24ED214B8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::ConstructMatrix3x3Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED214C8;
  v102 = *(_OWORD *)&off_24ED214D8;
  v103 = xmmword_24ED214E8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::ConstructMatrix4x4FromMatrix3x3Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED214F8;
  v102 = *(_OWORD *)&off_24ED21508;
  v103 = xmmword_24ED21518;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::TransformDirectionByMatrix3x3Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21528;
  v102 = *(_OWORD *)&off_24ED21538;
  v103 = xmmword_24ED21548;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::TransformDirectionByMatrix4x4Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21528;
  v102 = *(_OWORD *)&off_24ED21538;
  v103 = xmmword_24ED21548;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::TransformPositionCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21618;
  v102 = *(_OWORD *)&off_24ED21628;
  v103 = xmmword_24ED21638;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::DotVector3Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21648;
  v102 = *(_OWORD *)&off_24ED21658;
  v103 = xmmword_24ED21668;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::DotVector2Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21748;
  v102 = *(_OWORD *)&off_24ED21758;
  v103 = xmmword_24ED21768;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::CrossVector3Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21558;
  v102 = *(_OWORD *)&off_24ED21568;
  v103 = xmmword_24ED21578;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::ConvertIntrinsicEulerToQuaternionCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21588;
  v102 = *(_OWORD *)&off_24ED21598;
  v103 = xmmword_24ED215A8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::ConvertQuaternionToIntrinsicEulerCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED215B8;
  v102 = *(_OWORD *)&off_24ED215C8;
  v103 = xmmword_24ED215D8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::ExtractTwistFromQuaternionCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED215E8;
  v102 = *(_OWORD *)&off_24ED215F8;
  v103 = xmmword_24ED21608;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::ConstructQuaternionCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21618;
  v102 = *(_OWORD *)&off_24ED21628;
  v103 = xmmword_24ED21638;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::GetVector3ComponentCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21648;
  v102 = *(_OWORD *)&off_24ED21658;
  v103 = xmmword_24ED21668;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::GetVector2ComponentCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21678;
  v102 = *(_OWORD *)&off_24ED21688;
  v103 = xmmword_24ED21698;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::ConstructVector2Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED216A8;
  v102 = *(_OWORD *)&off_24ED216B8;
  v103 = xmmword_24ED216C8;
  v104 = *(_OWORD *)&off_24ED216D8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 3uLL, 1uLL, (unint64_t)re::ConstructVector3Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED216E8;
  v102 = *(_OWORD *)&off_24ED216F8;
  v103 = xmmword_24ED21708;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::AdditiveBlendSRTCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21718;
  v102 = *(_OWORD *)&off_24ED21728;
  v103 = xmmword_24ED21738;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::MultiplyQuaternionCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21748;
  v102 = *(_OWORD *)&off_24ED21758;
  v103 = xmmword_24ED21768;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::MultiplyVector3Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21778;
  v102 = *(_OWORD *)&off_24ED21788;
  v103 = xmmword_24ED21798;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::MultiplyMatrix3x3Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED217A8;
  v102 = *(_OWORD *)&off_24ED217B8;
  v103 = xmmword_24ED217C8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::MultiplyMatrix4x4Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED217D8;
  v102 = *(_OWORD *)&off_24ED217E8;
  v103 = xmmword_24ED217F8;
  v104 = *(_OWORD *)&off_24ED21808;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 3uLL, 1uLL, (unint64_t)re::ConstructMatrix3x3FromVector3sCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21818;
  v102 = *(_OWORD *)&off_24ED21828;
  v103 = xmmword_24ED21838;
  v104 = *(_OWORD *)&off_24ED21848;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 3uLL, 1uLL, (unint64_t)re::ConstructMatrix4x4Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21858;
  v102 = *(_OWORD *)&off_24ED21868;
  v103 = xmmword_24ED21878;
  v104 = *(_OWORD *)&off_24ED21888;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 3uLL, 1uLL, (unint64_t)re::ComponentLerpVector3Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21898;
  v102 = *(_OWORD *)&off_24ED218A8;
  v103 = xmmword_24ED218B8;
  v104 = *(_OWORD *)&off_24ED218C8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 3uLL, 1uLL, (unint64_t)re::LerpVector3Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED218D8;
  v102 = *(_OWORD *)&off_24ED218E8;
  v103 = xmmword_24ED218F8;
  v104 = *(_OWORD *)&off_24ED21908;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 3uLL, 1uLL, (unint64_t)re::LerpSRTCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21918;
  v102 = *(_OWORD *)&off_24ED21928;
  v103 = xmmword_24ED21938;
  v104 = *(_OWORD *)&off_24ED21948;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 3uLL, 1uLL, (unint64_t)re::SlerpCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21958;
  v102 = *(_OWORD *)&off_24ED21968;
  v103 = xmmword_24ED21978;
  v104 = *(_OWORD *)&off_24ED21988;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 3uLL, 1uLL, (unint64_t)re::ClampCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21998;
  v102 = *(_OWORD *)&off_24ED219A8;
  v103 = xmmword_24ED219B8;
  v104 = *(_OWORD *)&off_24ED219C8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 3uLL, 1uLL, (unint64_t)re::ClampVector3Compile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21A08;
  v102 = *(_OWORD *)&off_24ED21A18;
  v103 = xmmword_24ED21A28;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::LocalSpaceJointScaleCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED219D8;
  v102 = *(_OWORD *)&off_24ED219E8;
  v103 = xmmword_24ED219F8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::LocalSpaceJointRotationCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21A08;
  v102 = *(_OWORD *)&off_24ED21A18;
  v103 = xmmword_24ED21A28;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::LocalSpaceJointTranslationCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21A38;
  v102 = *(_OWORD *)&off_24ED21A48;
  v103 = xmmword_24ED21A58;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::LocalSpaceJointTransformCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21A08;
  v102 = *(_OWORD *)&off_24ED21A18;
  v103 = xmmword_24ED21A28;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::ModelSpaceJointScaleCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED219D8;
  v102 = *(_OWORD *)&off_24ED219E8;
  v103 = xmmword_24ED219F8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::ModelSpaceJointRotationCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21A08;
  v102 = *(_OWORD *)&off_24ED21A18;
  v103 = xmmword_24ED21A28;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::ModelSpaceJointTranslationCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21A38;
  v102 = *(_OWORD *)&off_24ED21A48;
  v103 = xmmword_24ED21A58;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::ModelSpaceJointTransformCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21AA8;
  v102 = *(_OWORD *)&off_24ED21AB8;
  v103 = xmmword_24ED21AC8;
  v104 = *(_OWORD *)&off_24ED21AD8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 3uLL, 1uLL, (unint64_t)re::SetLocalSpaceJointScaleCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21A68;
  v102 = *(_OWORD *)&off_24ED21A78;
  v103 = xmmword_24ED21A88;
  v104 = *(_OWORD *)&off_24ED21A98;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 3uLL, 1uLL, (unint64_t)re::SetLocalSpaceJointRotationCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21AA8;
  v102 = *(_OWORD *)&off_24ED21AB8;
  v103 = xmmword_24ED21AC8;
  v104 = *(_OWORD *)&off_24ED21AD8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 3uLL, 1uLL, (unint64_t)re::SetLocalSpaceJointTranslationCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21AE8;
  v102 = *(_OWORD *)&off_24ED21AF8;
  v103 = xmmword_24ED21B08;
  v104 = *(_OWORD *)&off_24ED21B18;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 3uLL, 1uLL, (unint64_t)re::SetLocalSpaceJointTransformCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21AA8;
  v102 = *(_OWORD *)&off_24ED21AB8;
  v103 = xmmword_24ED21AC8;
  v104 = *(_OWORD *)&off_24ED21AD8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 3uLL, 1uLL, (unint64_t)re::SetModelSpaceJointScaleCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21A68;
  v102 = *(_OWORD *)&off_24ED21A78;
  v103 = xmmword_24ED21A88;
  v104 = *(_OWORD *)&off_24ED21A98;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 3uLL, 1uLL, (unint64_t)re::SetModelSpaceJointRotationCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21AA8;
  v102 = *(_OWORD *)&off_24ED21AB8;
  v103 = xmmword_24ED21AC8;
  v104 = *(_OWORD *)&off_24ED21AD8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 3uLL, 1uLL, (unint64_t)re::SetModelSpaceJointTranslationCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21AE8;
  v102 = *(_OWORD *)&off_24ED21AF8;
  v103 = xmmword_24ED21B08;
  v104 = *(_OWORD *)&off_24ED21B18;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 3uLL, 1uLL, (unint64_t)re::SetModelSpaceJointTransformCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21B28;
  v102 = *(_OWORD *)&off_24ED21B38;
  v103 = xmmword_24ED21B48;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::JointParentCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21B58;
  v102 = *(_OWORD *)&off_24ED21B68;
  v103 = xmmword_24ED21B78;
  v104 = *(_OWORD *)&off_24ED21B88;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 3uLL, 1uLL, (unint64_t)re::SetJointParentCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21B98;
  v102 = *(_OWORD *)&off_24ED21BA8;
  v103 = xmmword_24ED21BB8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::ClearJointParentCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21B98;
  v102 = *(_OWORD *)&off_24ED21BA8;
  v103 = xmmword_24ED21BB8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::AddJointCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21B98;
  v102 = *(_OWORD *)&off_24ED21BA8;
  v103 = xmmword_24ED21BB8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::RemoveJointCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21BC8;
  v102 = *(_OWORD *)&off_24ED21BD8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 1uLL, 1uLL, (unint64_t)re::SinFloatCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21BC8;
  v102 = *(_OWORD *)&off_24ED21BD8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 1uLL, 1uLL, (unint64_t)re::CosFloatCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21BC8;
  v102 = *(_OWORD *)&off_24ED21BD8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 1uLL, 1uLL, (unint64_t)re::TanFloatCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21BC8;
  v102 = *(_OWORD *)&off_24ED21BD8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 1uLL, 1uLL, (unint64_t)re::AsinFloatCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21BC8;
  v102 = *(_OWORD *)&off_24ED21BD8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 1uLL, 1uLL, (unint64_t)re::AcosFloatCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21BC8;
  v102 = *(_OWORD *)&off_24ED21BD8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 1uLL, 1uLL, (unint64_t)re::AtanFloatCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21BE8;
  v102 = *(_OWORD *)&off_24ED21BF8;
  v103 = xmmword_24ED21C08;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::Atan2FloatCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21C18;
  v102 = *(_OWORD *)&off_24ED21C28;
  v103 = xmmword_24ED21C38;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::GreaterCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21C18;
  v102 = *(_OWORD *)&off_24ED21C28;
  v103 = xmmword_24ED21C38;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::GreaterEqualCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21C18;
  v102 = *(_OWORD *)&off_24ED21C28;
  v103 = xmmword_24ED21C38;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::LessCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21C18;
  v102 = *(_OWORD *)&off_24ED21C28;
  v103 = xmmword_24ED21C38;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::LessEqualCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21C48;
  v102 = *(_OWORD *)&off_24ED21C58;
  v103 = xmmword_24ED21C68;
  v104 = *(_OWORD *)&off_24ED21C78;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 3uLL, 1uLL, (unint64_t)re::SelectFloatCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21C88;
  v102 = *(_OWORD *)&off_24ED21C98;
  v103 = xmmword_24ED21CA8;
  v104 = *(_OWORD *)&off_24ED21CB8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 3uLL, 1uLL, (unint64_t)re::LerpFloatCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21CC8;
  v102 = *(_OWORD *)&off_24ED21CD8;
  v103 = xmmword_24ED21CE8;
  v104 = *(_OWORD *)&off_24ED21CF8;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 3uLL, 1uLL, (unint64_t)re::BlendRigHierarchyCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v95 = 0;
  v97 = 0u;
  v96 = &str_110;
  v93 = 0;
  v94 = &str_110;
  v101 = xmmword_24ED21D08;
  v102 = *(_OWORD *)&off_24ED21D18;
  v103 = xmmword_24ED21D28;
  re::RigGraphOperatorDefinition::init(&v95, (uint64_t *)this, &v93, 2uLL, 1uLL, (unint64_t)re::BlendAdditiveRigHierarchyCompile, (const char **)&v101);
  re::StringID::destroyString((re::StringID *)&v93);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v98 + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(&v97);
  re::StringID::destroyString((re::StringID *)&v95);
}

float *re::ClampCompile(re::RigGraphSystem &,re::Slice<re::RigDataValue const*>,re::Slice<re::RigDataValue*>)::$_0::__invoke(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t Runtime;
  uint64_t v12;
  float *v13;
  uint64_t v14;
  uint64_t v15;
  float *v16;
  float *v17;
  uint64_t v18;
  float v19;
  float v20;
  float *result;

  if (!a8)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (!a4)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_13;
  }
  Runtime = re::RigDataValue::getRuntimeValue<float>(a3, a2);
  if (a4 == 1)
  {
LABEL_13:
    re::internal::assertLog((re::internal *)6, v12, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    _os_crash();
    __break(1u);
    goto LABEL_14;
  }
  v13 = (float *)Runtime;
  v14 = re::RigDataValue::getRuntimeValue<float>(a3 + 288, v12);
  if (a4 <= 2)
  {
LABEL_14:
    re::internal::assertLog((re::internal *)6, v15, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2);
    result = (float *)_os_crash();
    __break(1u);
    return result;
  }
  v16 = (float *)v14;
  v17 = (float *)re::RigDataValue::getRuntimeValue<float>(a3 + 576, v15);
  v19 = *v13;
  if (*v13 > *v17)
    v19 = *v17;
  if (v19 >= *v16)
    v20 = v19;
  else
    v20 = *v16;
  result = (float *)re::RigDataValue::getRuntimeValue<float>(a7, v18);
  *result = v20;
  return result;
}

_OWORD *re::ClampVector3Compile(re::RigGraphSystem &,re::Slice<re::RigDataValue const*>,re::Slice<re::RigDataValue*>)::$_0::__invoke(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v12;
  uint64_t v13;
  float32x2_t v14;
  float v15;
  uint64_t v16;
  uint64_t v17;
  float v18;
  float32x2_t v19;
  float32x2_t *v20;
  uint64_t v21;
  __int128 v22;
  float32x2_t v23;
  float v24;
  _OWORD *result;
  __int128 v26;

  if (!a4)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_11;
  }
  v12 = re::RigDataValue::getRuntimeValue<re::Vector3<float>>(a3, a2);
  if (a4 == 1)
  {
LABEL_11:
    re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  v14 = *(float32x2_t *)v12;
  v15 = *(float *)(v12 + 8);
  v16 = re::RigDataValue::getRuntimeValue<re::Vector3<float>>(a3 + 288, v13);
  if (a4 <= 2)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, v17, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2);
    _os_crash();
    __break(1u);
    goto LABEL_13;
  }
  v18 = *(float *)(v16 + 8);
  v19 = *(float32x2_t *)v16;
  v20 = (float32x2_t *)re::RigDataValue::getRuntimeValue<re::Vector3<float>>(a3 + 576, v17);
  if (!a8)
  {
LABEL_13:
    re::internal::assertLog((re::internal *)6, v21, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, 0, 0);
    result = (_OWORD *)_os_crash();
    __break(1u);
    return result;
  }
  v23 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v14, *v20), (int8x8_t)*v20, (int8x8_t)v14);
  *(int8x8_t *)&v22 = vbsl_s8((int8x8_t)vcgt_f32(v19, v23), (int8x8_t)v19, (int8x8_t)v23);
  v24 = v20[1].f32[0];
  if (v15 <= v24)
    v24 = v15;
  if (v24 < v18)
    v24 = v18;
  *((float *)&v22 + 2) = v24;
  v26 = v22;
  result = (_OWORD *)re::RigDataValue::getRuntimeValue<re::Vector3<float>>(a7, v21);
  *result = v26;
  return result;
}

BOOL re::AnimationHelper::makeAdditiveForValues<float>(re *a1, float **a2, float *a3, float *a4)
{
  float *v4;
  float *v5;
  float *v6;
  float *v7;
  float *v8;
  float v9;
  float v10;
  float v11;
  float v12;
  unint64_t v13;
  NSObject *v14;
  _BOOL8 result;
  const char *v16;
  uint8_t *v17;
  uint64_t v18;
  float *v19;
  float *v20;
  float v21;
  __int16 v22;
  __int16 v23;

  if (*((float **)a1 + 1) != a4)
  {
    v14 = *re::animationLogObjects(a1);
    result = os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    v23 = 0;
    v16 = "Cannot make additive values, output values expected to match input values size.";
    v17 = (uint8_t *)&v23;
LABEL_13:
    _os_log_error_impl(&dword_224FE9000, v14, OS_LOG_TYPE_ERROR, v16, v17, 2u);
    return 0;
  }
  v4 = a2[1];
  if (!v4)
  {
    v14 = *re::animationLogObjects(a1);
    result = os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    v22 = 0;
    v16 = "Cannot make additive values, base values array size must not be zero.";
    v17 = (uint8_t *)&v22;
    goto LABEL_13;
  }
  if (a4 < v4)
    v4 = a4;
  if (v4)
  {
    v5 = *(float **)a1;
    v6 = *a2;
    v7 = a3;
    v8 = v4;
    do
    {
      v9 = *v6++;
      v10 = v9;
      v11 = *v5++;
      *v7++ = v11 - v10;
      v8 = (float *)((char *)v8 - 1);
    }
    while (v8);
    v12 = -v10;
    v13 = v4;
  }
  else
  {
    v13 = 0;
    v12 = 0.0;
  }
  v18 = (uint64_t)a4 - v13;
  if ((unint64_t)a4 > v13)
  {
    v19 = &a3[v13];
    v20 = (float *)(*(_QWORD *)a1 + 4 * v13);
    do
    {
      v21 = *v20++;
      *v19++ = v12 + v21;
      --v18;
    }
    while (v18);
  }
  return 1;
}

double re::SampledAnimation<float>::totalDuration(uint64_t a1)
{
  return *(float *)(a1 + 84);
}

uint64_t re::SampledAnimation<float>::evaluateCore(uint64_t result, uint64_t a2, uint64_t a3, float *a4, uint64_t a5, float *a6)
{
  unint64_t v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  unint64_t v13;

  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_24;
  }
  v6 = *(_QWORD *)(result + 96);
  if (v6 == 1)
  {
LABEL_9:
    v7 = **(float **)(result + 104);
    goto LABEL_10;
  }
  if (v6)
  {
    v8 = *(double *)(a2 + 24);
    v9 = *(float *)(result + 80);
    if (v9 < v8)
    {
      if (*(float *)(result + 84) <= v8
        || (v10 = (float)(v8 - v9) / *(float *)(result + 76),
            v11 = floorf(v10),
            v12 = v11 + ceilf(v10 - v11),
            v13 = (unint64_t)(float)(v12 + 0.5),
            v6 < v13))
      {
        v7 = *(float *)(*(_QWORD *)(result + 104) + 4 * v6 - 4);
        goto LABEL_10;
      }
      if (v6 != v13 && *(_BYTE *)(result + 73) != 0)
      {
        if (v6 > v13 - 1)
        {
          if (v6 > v13)
          {
            v7 = (float)((float)(v10 - (float)(v12 + -1.0)) * *(float *)(*(_QWORD *)(result + 104) + 4 * v13))
               + (float)(*(float *)(*(_QWORD *)(result + 104) + 4 * (v13 - 1))
                       * (float)(1.0 - (float)(v10 - (float)(v12 + -1.0))));
            goto LABEL_10;
          }
LABEL_26:
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
LABEL_25:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_26;
      }
      if (v6 <= v13)
        v13 = v6 - 1;
      if (v6 > v13)
      {
        v7 = *(float *)(*(_QWORD *)(result + 104) + 4 * v13);
        goto LABEL_10;
      }
LABEL_24:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_25;
    }
    goto LABEL_9;
  }
  v7 = *a4;
LABEL_10:
  *a6 = v7;
  return result;
}

BOOL re::AnimationHelper::makeAdditiveForValues<double>(re *a1, uint64_t a2, double *a3, unint64_t a4)
{
  unint64_t v4;
  double *v5;
  double *v6;
  double *v7;
  unint64_t v8;
  double v9;
  double v10;
  double v11;
  double v12;
  unint64_t v13;
  NSObject *v14;
  _BOOL8 result;
  const char *v16;
  uint8_t *v17;
  unint64_t v18;
  double *v19;
  double *v20;
  double v21;
  __int16 v22;
  __int16 v23;

  if (*((_QWORD *)a1 + 1) != a4)
  {
    v14 = *re::animationLogObjects(a1);
    result = os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    v23 = 0;
    v16 = "Cannot make additive values, output values expected to match input values size.";
    v17 = (uint8_t *)&v23;
LABEL_13:
    _os_log_error_impl(&dword_224FE9000, v14, OS_LOG_TYPE_ERROR, v16, v17, 2u);
    return 0;
  }
  v4 = *(_QWORD *)(a2 + 8);
  if (!v4)
  {
    v14 = *re::animationLogObjects(a1);
    result = os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    v22 = 0;
    v16 = "Cannot make additive values, base values array size must not be zero.";
    v17 = (uint8_t *)&v22;
    goto LABEL_13;
  }
  if (a4 < v4)
    v4 = a4;
  if (v4)
  {
    v5 = *(double **)a1;
    v6 = *(double **)a2;
    v7 = a3;
    v8 = v4;
    do
    {
      v9 = *v6++;
      v10 = v9;
      v11 = *v5++;
      *v7++ = v11 - v10;
      --v8;
    }
    while (v8);
    v12 = -v10;
    v13 = v4;
  }
  else
  {
    v13 = 0;
    v12 = 0.0;
  }
  v18 = a4 - v13;
  if (a4 > v13)
  {
    v19 = &a3[v13];
    v20 = (double *)(*(_QWORD *)a1 + 8 * v13);
    do
    {
      v21 = *v20++;
      *v19++ = v12 + v21;
      --v18;
    }
    while (v18);
  }
  return 1;
}

double re::SampledAnimation<double>::totalDuration(uint64_t a1)
{
  return *(float *)(a1 + 84);
}

uint64_t re::SampledAnimation<double>::evaluateCore(uint64_t result, uint64_t a2, uint64_t a3, double *a4, uint64_t a5, double *a6)
{
  unint64_t v6;
  double v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  unint64_t v13;

  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_24;
  }
  v6 = *(_QWORD *)(result + 96);
  if (v6 == 1)
  {
LABEL_9:
    v7 = **(double **)(result + 104);
    goto LABEL_10;
  }
  if (v6)
  {
    v8 = *(double *)(a2 + 24);
    v9 = *(float *)(result + 80);
    if (v9 < v8)
    {
      if (*(float *)(result + 84) <= v8
        || (v10 = (float)(v8 - v9) / *(float *)(result + 76),
            v11 = floorf(v10),
            v12 = v11 + ceilf(v10 - v11),
            v13 = (unint64_t)(float)(v12 + 0.5),
            v6 < v13))
      {
        v7 = *(double *)(*(_QWORD *)(result + 104) + 8 * v6 - 8);
        goto LABEL_10;
      }
      if (v6 != v13 && *(_BYTE *)(result + 73) != 0)
      {
        if (v6 > v13 - 1)
        {
          if (v6 > v13)
          {
            v7 = *(double *)(*(_QWORD *)(result + 104) + 8 * v13) * (float)(v10 - (float)(v12 + -1.0))
               + *(double *)(*(_QWORD *)(result + 104) + 8 * (v13 - 1))
               * (float)(1.0 - (float)(v10 - (float)(v12 + -1.0)));
            goto LABEL_10;
          }
LABEL_26:
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
LABEL_25:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_26;
      }
      if (v6 <= v13)
        v13 = v6 - 1;
      if (v6 > v13)
      {
        v7 = *(double *)(*(_QWORD *)(result + 104) + 8 * v13);
        goto LABEL_10;
      }
LABEL_24:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_25;
    }
    goto LABEL_9;
  }
  v7 = *a4;
LABEL_10:
  *a6 = v7;
  return result;
}

uint64_t re::AnimationHelper::makeAdditiveForValues<re::Vector2<float>>(re *a1, _QWORD *a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4;
  float32x2_t v5;
  unint64_t v6;
  uint64_t v8;
  unint64_t v9;
  uint64_t result;
  NSObject *v11;
  const char *v12;
  uint8_t *v13;
  uint8_t buf[2];
  __int16 v15;

  if (*((_QWORD *)a1 + 1) != a4)
  {
    v11 = *re::animationLogObjects(a1);
    result = os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    v15 = 0;
    v12 = "Cannot make additive values, output values expected to match input values size.";
    v13 = (uint8_t *)&v15;
    goto LABEL_25;
  }
  if (!a2[1])
  {
    v11 = *re::animationLogObjects(a1);
    result = os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    *(_WORD *)buf = 0;
    v12 = "Cannot make additive values, base values array size must not be zero.";
    v13 = buf;
LABEL_25:
    _os_log_error_impl(&dword_224FE9000, v11, OS_LOG_TYPE_ERROR, v12, v13, 2u);
    return 0;
  }
  if (!a4)
    return 1;
  v4 = 0;
  do
  {
    if (a4 == v4)
    {
      re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, a4, a4);
      _os_crash();
      __break(1u);
      goto LABEL_27;
    }
    v5 = *(float32x2_t *)(*a2 + 8 * v4);
    *(float32x2_t *)(a3 + 8 * v4) = vsub_f32(*(float32x2_t *)(*(_QWORD *)a1 + 8 * v4), v5);
    ++v4;
    v6 = *((_QWORD *)a1 + 1);
  }
  while (v6 > v4 && a2[1] > v4);
  if (v6 <= v4)
    return 1;
  v8 = v4;
  if (a4 <= v4)
    v9 = v4;
  else
    v9 = a4;
  if (a4 <= v4)
    v4 = v4;
  else
    v4 = a4;
  while (v4 != v8)
  {
    *(float32x2_t *)(a3 + 8 * v8) = vsub_f32(*(float32x2_t *)(*(_QWORD *)a1 + 8 * v8), v5);
    if (*((_QWORD *)a1 + 1) <= (unint64_t)++v8)
      return 1;
  }
LABEL_27:
  re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v9, a4);
  result = _os_crash();
  __break(1u);
  return result;
}

double re::SampledAnimation<re::Vector2<float>>::totalDuration(uint64_t a1)
{
  return *(float *)(a1 + 84);
}

float32x2_t re::SampledAnimation<re::Vector2<float>>::evaluateCore(uint64_t a1, float32x2_t *a2, uint64_t a3, uint64_t *a4, float32x2_t result, uint64_t a6, double *a7)
{
  unint64_t v7;
  uint64_t v8;
  float v9;
  float v10;
  float v11;
  unint64_t v12;

  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_25;
  }
  v7 = *(_QWORD *)(a1 + 96);
  if (v7 == 1)
  {
LABEL_9:
    v8 = **(_QWORD **)(a1 + 104);
    goto LABEL_10;
  }
  if (v7)
  {
    result = a2[3];
    result.f32[0] = *(double *)&result;
    v9 = *(float *)(a1 + 80);
    if (v9 < result.f32[0])
    {
      if (*(float *)(a1 + 84) <= result.f32[0]
        || (result.f32[0] = (float)(result.f32[0] - v9) / *(float *)(a1 + 76),
            v10 = floorf(result.f32[0]),
            v11 = v10 + ceilf(result.f32[0] - v10),
            v12 = (unint64_t)(float)(v11 + 0.5),
            v7 < v12))
      {
        v8 = *(_QWORD *)(*(_QWORD *)(a1 + 104) + 8 * v7 - 8);
        goto LABEL_10;
      }
      if (v7 != v12 && *(_BYTE *)(a1 + 73) != 0)
      {
        if (v7 > v12 - 1)
        {
          if (v7 > v12)
          {
            result = vadd_f32(vmul_n_f32(*(float32x2_t *)(*(_QWORD *)(a1 + 104) + 8 * (v12 - 1)), 1.0 - (float)(result.f32[0] - (float)(v11 + -1.0))), vmul_n_f32(*(float32x2_t *)(*(_QWORD *)(a1 + 104) + 8 * v12), result.f32[0] - (float)(v11 + -1.0)));
            *a7 = *(double *)&result;
            return result;
          }
LABEL_27:
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
LABEL_26:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_27;
      }
      if (v7 <= v12)
        v12 = v7 - 1;
      if (v7 > v12)
      {
        v8 = *(_QWORD *)(*(_QWORD *)(a1 + 104) + 8 * v12);
        goto LABEL_10;
      }
LABEL_25:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_26;
    }
    goto LABEL_9;
  }
  v8 = *a4;
LABEL_10:
  *(_QWORD *)a7 = v8;
  return result;
}

uint64_t re::AnimationHelper::makeAdditiveForValues<re::Vector3<float>>(re *a1, _QWORD *a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4;
  float32x4_t v5;
  unint64_t v6;
  uint64_t v8;
  unint64_t v9;
  uint64_t result;
  NSObject *v11;
  const char *v12;
  uint8_t *v13;
  uint8_t buf[2];
  __int16 v15;

  if (*((_QWORD *)a1 + 1) != a4)
  {
    v11 = *re::animationLogObjects(a1);
    result = os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    v15 = 0;
    v12 = "Cannot make additive values, output values expected to match input values size.";
    v13 = (uint8_t *)&v15;
    goto LABEL_25;
  }
  if (!a2[1])
  {
    v11 = *re::animationLogObjects(a1);
    result = os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    *(_WORD *)buf = 0;
    v12 = "Cannot make additive values, base values array size must not be zero.";
    v13 = buf;
LABEL_25:
    _os_log_error_impl(&dword_224FE9000, v11, OS_LOG_TYPE_ERROR, v12, v13, 2u);
    return 0;
  }
  if (!a4)
    return 1;
  v4 = 0;
  do
  {
    if (a4 == v4)
    {
      re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, a4, a4);
      _os_crash();
      __break(1u);
      goto LABEL_27;
    }
    v5 = *(float32x4_t *)(*a2 + 16 * v4);
    *(float32x4_t *)(a3 + 16 * v4) = vsubq_f32(*(float32x4_t *)(*(_QWORD *)a1 + 16 * v4), v5);
    ++v4;
    v6 = *((_QWORD *)a1 + 1);
  }
  while (v6 > v4 && a2[1] > v4);
  if (v6 <= v4)
    return 1;
  v8 = v4;
  if (a4 <= v4)
    v9 = v4;
  else
    v9 = a4;
  if (a4 <= v4)
    v4 = v4;
  else
    v4 = a4;
  while (v4 != v8)
  {
    *(float32x4_t *)(a3 + 16 * v8) = vsubq_f32(*(float32x4_t *)(*(_QWORD *)a1 + 16 * v8), v5);
    if (*((_QWORD *)a1 + 1) <= (unint64_t)++v8)
      return 1;
  }
LABEL_27:
  re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v9, a4);
  result = _os_crash();
  __break(1u);
  return result;
}

double re::SampledAnimation<re::Vector3<float>>::totalDuration(uint64_t a1)
{
  return *(float *)(a1 + 84);
}

uint64_t re::SampledAnimation<re::Vector3<float>>::evaluateCore(uint64_t result, uint64_t a2, uint64_t a3, float32x4_t *a4, uint64_t a5, float32x4_t *a6)
{
  unint64_t v6;
  float32x4_t v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  unint64_t v13;

  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_24;
  }
  v6 = *(_QWORD *)(result + 96);
  if (v6 == 1)
  {
LABEL_9:
    v7 = *(float32x4_t *)*(_QWORD *)(result + 104);
    goto LABEL_10;
  }
  if (v6)
  {
    v8 = *(double *)(a2 + 24);
    v9 = *(float *)(result + 80);
    if (v9 < v8)
    {
      if (*(float *)(result + 84) <= v8
        || (v10 = (float)(v8 - v9) / *(float *)(result + 76),
            v11 = floorf(v10),
            v12 = v11 + ceilf(v10 - v11),
            v13 = (unint64_t)(float)(v12 + 0.5),
            v6 < v13))
      {
        v7 = *(float32x4_t *)(*(_QWORD *)(result + 104) + 16 * v6 - 16);
        goto LABEL_10;
      }
      if (v6 != v13 && *(_BYTE *)(result + 73) != 0)
      {
        if (v6 > v13 - 1)
        {
          if (v6 > v13)
          {
            v7 = vmlaq_n_f32(vmulq_n_f32(*(float32x4_t *)(*(_QWORD *)(result + 104) + 16 * v13), v10 - (float)(v12 + -1.0)), *(float32x4_t *)(*(_QWORD *)(result + 104) + 16 * (v13 - 1)), 1.0 - (float)(v10 - (float)(v12 + -1.0)));
            goto LABEL_10;
          }
LABEL_26:
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
LABEL_25:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_26;
      }
      if (v6 <= v13)
        v13 = v6 - 1;
      if (v6 > v13)
      {
        v7 = *(float32x4_t *)(*(_QWORD *)(result + 104) + 16 * v13);
        goto LABEL_10;
      }
LABEL_24:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_25;
    }
    goto LABEL_9;
  }
  v7 = *a4;
LABEL_10:
  *a6 = v7;
  return result;
}

double re::SampledAnimation<re::Vector4<float>>::totalDuration(uint64_t a1)
{
  return *(float *)(a1 + 84);
}

uint64_t re::SampledAnimation<re::Vector4<float>>::evaluateCore(uint64_t result, uint64_t a2, uint64_t a3, float32x4_t *a4, uint64_t a5, float32x4_t *a6)
{
  unint64_t v6;
  float32x4_t v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  unint64_t v13;

  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_24;
  }
  v6 = *(_QWORD *)(result + 96);
  if (v6 == 1)
  {
LABEL_9:
    v7 = *(float32x4_t *)*(_QWORD *)(result + 104);
    goto LABEL_10;
  }
  if (v6)
  {
    v8 = *(double *)(a2 + 24);
    v9 = *(float *)(result + 80);
    if (v9 < v8)
    {
      if (*(float *)(result + 84) <= v8
        || (v10 = (float)(v8 - v9) / *(float *)(result + 76),
            v11 = floorf(v10),
            v12 = v11 + ceilf(v10 - v11),
            v13 = (unint64_t)(float)(v12 + 0.5),
            v6 < v13))
      {
        v7 = *(float32x4_t *)(*(_QWORD *)(result + 104) + 16 * v6 - 16);
        goto LABEL_10;
      }
      if (v6 != v13 && *(_BYTE *)(result + 73) != 0)
      {
        if (v6 > v13 - 1)
        {
          if (v6 > v13)
          {
            v7 = vaddq_f32(vmulq_n_f32(*(float32x4_t *)(*(_QWORD *)(result + 104) + 16 * (v13 - 1)), 1.0 - (float)(v10 - (float)(v12 + -1.0))), vmulq_n_f32(*(float32x4_t *)(*(_QWORD *)(result + 104) + 16 * v13), v10 - (float)(v12 + -1.0)));
            goto LABEL_10;
          }
LABEL_26:
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
LABEL_25:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_26;
      }
      if (v6 <= v13)
        v13 = v6 - 1;
      if (v6 > v13)
      {
        v7 = *(float32x4_t *)(*(_QWORD *)(result + 104) + 16 * v13);
        goto LABEL_10;
      }
LABEL_24:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_25;
    }
    goto LABEL_9;
  }
  v7 = *a4;
LABEL_10:
  *a6 = v7;
  return result;
}

uint64_t re::AnimationHelper::makeAdditiveForValues<re::Quaternion<float>>(re *a1, _QWORD *a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4;
  float32x4_t v6;
  float32x4_t v8;
  int8x16_t v9;
  float32x4_t v10;
  unint64_t v16;
  float32x4_t v17;
  unint64_t v19;
  unint64_t v20;
  int8x16_t v22;
  float32x4_t v23;
  uint64_t result;
  NSObject *v26;
  const char *v27;
  uint8_t *v28;
  uint8_t buf[2];
  __int16 v30;

  if (*((_QWORD *)a1 + 1) != a4)
  {
    v26 = *re::animationLogObjects(a1);
    result = os_log_type_enabled(v26, OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    v30 = 0;
    v27 = "Cannot make additive values, output values expected to match input values size.";
    v28 = (uint8_t *)&v30;
    goto LABEL_23;
  }
  if (!a2[1])
  {
    v26 = *re::animationLogObjects(a1);
    result = os_log_type_enabled(v26, OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    *(_WORD *)buf = 0;
    v27 = "Cannot make additive values, base values array size must not be zero.";
    v28 = buf;
LABEL_23:
    _os_log_error_impl(&dword_224FE9000, v26, OS_LOG_TYPE_ERROR, v27, v28, 2u);
    return 0;
  }
  if (!a4)
    return 1;
  v4 = 0;
  do
  {
    if (a4 == v4)
    {
      re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, a4, a4);
      _os_crash();
      __break(1u);
      goto LABEL_25;
    }
    _Q0 = *(float32x4_t *)(*a2 + 16 * v4);
    v6 = vnegq_f32(_Q0);
    _Q4 = *(float32x4_t *)(*(_QWORD *)a1 + 16 * v4);
    v8 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v6, (int32x4_t)v6), (int8x16_t)v6, 0xCuLL);
    v9 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q4, (int32x4_t)_Q4), (int8x16_t)_Q4, 0xCuLL), _Q0), _Q4, v8);
    v10 = vmlsq_laneq_f32(vmlaq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v9, (int32x4_t)v9), v9, 0xCuLL), _Q4, _Q0, 3), _Q0, _Q4, 3);
    _Q4.i32[0] = _Q4.i32[3];
    __asm { FMLA            S6, S4, V0.S[3] }
    v10.i32[3] = _S6;
    *(float32x4_t *)(a3 + 16 * v4++) = v10;
    v16 = *((_QWORD *)a1 + 1);
  }
  while (v16 > v4 && a2[1] > v4);
  if (v16 <= v4)
    return 1;
  v17 = (float32x4_t)vdupq_laneq_s32((int32x4_t)_Q0, 3);
  _S5 = _Q0.i32[3];
  v19 = v4;
  if (a4 <= v4)
    v20 = v4;
  else
    v20 = a4;
  if (a4 <= v4)
    v4 = v4;
  else
    v4 = a4;
  while (v4 != v19)
  {
    _Q6 = *(float32x4_t *)(*(_QWORD *)a1 + 16 * v19);
    v22 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q6, (int32x4_t)_Q6), (int8x16_t)_Q6, 0xCuLL), _Q0), _Q6, v8);
    v23 = vmlaq_laneq_f32(vmlaq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v22, (int32x4_t)v22), v22, 0xCuLL), _Q6, v17), v6, _Q6, 3);
    __asm { FMLA            S16, S5, V6.S[3] }
    v23.i32[3] = _S16;
    *(float32x4_t *)(a3 + 16 * v19++) = v23;
    if (*((_QWORD *)a1 + 1) <= v19)
      return 1;
  }
LABEL_25:
  re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v20, a4);
  result = _os_crash();
  __break(1u);
  return result;
}

double re::SampledAnimation<re::Quaternion<float>>::totalDuration(uint64_t a1)
{
  return *(float *)(a1 + 84);
}

void re::SampledAnimation<re::Quaternion<float>>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4, uint64_t a5, uint64_t *a6)
{
  unint64_t v6;
  __int128 v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  unint64_t v13;

  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_24:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_25;
  }
  v6 = *(_QWORD *)(a1 + 96);
  if (v6 == 1)
    goto LABEL_9;
  if (!v6)
  {
    v7 = *a4;
LABEL_10:
    *(_OWORD *)a6 = v7;
    return;
  }
  v8 = *(double *)(a2 + 24);
  v9 = *(float *)(a1 + 80);
  if (v9 >= v8)
  {
LABEL_9:
    v7 = *(_OWORD *)*(_QWORD *)(a1 + 104);
    goto LABEL_10;
  }
  if (*(float *)(a1 + 84) <= v8
    || (v10 = (float)(v8 - v9) / *(float *)(a1 + 76),
        v11 = floorf(v10),
        v12 = v11 + ceilf(v10 - v11),
        v13 = (unint64_t)(float)(v12 + 0.5),
        v6 < v13))
  {
    v7 = *(_OWORD *)(*(_QWORD *)(a1 + 104) + 16 * v6 - 16);
    goto LABEL_10;
  }
  if (v6 == v13 || *(_BYTE *)(a1 + 73) == 0)
  {
    if (v6 <= v13)
      v13 = v6 - 1;
    if (v6 > v13)
    {
      v7 = *(_OWORD *)(*(_QWORD *)(a1 + 104) + 16 * v13);
      goto LABEL_10;
    }
    goto LABEL_24;
  }
  if (v6 <= v13 - 1)
  {
LABEL_25:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_26:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (v6 <= v13)
    goto LABEL_26;
  re::AnimationValueTraits<re::Quaternion<float>>::interpolate((float32x4_t *)(*(_QWORD *)(a1 + 104) + 16 * (v13 - 1)), (float32x4_t *)(*(_QWORD *)(a1 + 104) + 16 * v13), a6, v10 - (float)(v12 + -1.0));
}

uint64_t re::AnimationHelper::makeAdditiveForValues<re::GenericSRT<float>>(re *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4;
  uint64_t v8;
  unint64_t v9;
  float32x4_t *v15;
  float32x4_t v16;
  float32x4_t v17;
  int8x16_t v18;
  float32x4_t v19;
  float32x4_t v20;
  int8x16_t v21;
  float32x4_t v22;
  float32x4_t v23;
  int8x16_t v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t result;
  NSObject *v29;
  const char *v30;
  float32x4_t v31;
  uint8_t buf[16];
  int8x16_t v33;
  float32x4_t v34;

  if (*((_QWORD *)a1 + 1) != a4)
  {
    v29 = *re::animationLogObjects(a1);
    result = os_log_type_enabled(v29, OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    *(_WORD *)buf = 0;
    v30 = "Cannot make additive values, output values expected to match input values size.";
    goto LABEL_23;
  }
  v4 = a2;
  if (!*(_QWORD *)(a2 + 8))
  {
    v29 = *re::animationLogObjects(a1);
    result = os_log_type_enabled(v29, OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    *(_WORD *)buf = 0;
    v30 = "Cannot make additive values, base values array size must not be zero.";
LABEL_23:
    _os_log_error_impl(&dword_224FE9000, v29, OS_LOG_TYPE_ERROR, v30, buf, 2u);
    return 0;
  }
  *(_QWORD *)buf = 0x3F8000003F800000;
  *(_QWORD *)&buf[8] = 1065353216;
  v33.i64[0] = 0;
  v33.i64[1] = 0x3F80000000000000;
  v34 = 0uLL;
  if (!a4)
    return 1;
  v8 = 0;
  v9 = 0;
  __asm { FMOV            V0.4S, #1.0 }
  v31 = _Q0;
  do
  {
    v15 = (float32x4_t *)(*(_QWORD *)v4 + v8);
    v16 = v15[1];
    v17 = v15[2];
    v18 = (int8x16_t)vnegq_f32(v16);
    v19 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v18, (int32x4_t)v18), v18, 0xCuLL);
    v18.i32[3] = v16.i32[3];
    v20 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v17, (int32x4_t)v17), (int8x16_t)v17, 0xCuLL), v16), v17, v19);
    v21 = (int8x16_t)vaddq_f32(v20, v20);
    v22 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v21, (int32x4_t)v21), v21, 0xCuLL);
    v23 = vaddq_f32(v17, vmulq_laneq_f32(v22, v16, 3));
    v24 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v22, (int32x4_t)v22), (int8x16_t)v22, 0xCuLL), v16), v22, v19);
    *(float32x4_t *)buf = vdivq_f32(v31, *v15);
    v33 = v18;
    v34 = vmulq_f32(vaddq_f32(v23, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v24, (int32x4_t)v24), v24, 0xCuLL)), vnegq_f32(*(float32x4_t *)buf));
    if (a4 == v9)
    {
      re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, a4, a4);
      _os_crash();
      __break(1u);
      goto LABEL_25;
    }
    re::AnimationValueTraits<re::GenericSRT<float>>::combine((float32x4_t *)(*(_QWORD *)a1 + v8), (float32x4_t *)buf, (float32x4_t *)(a3 + v8));
    ++v9;
    v25 = *((_QWORD *)a1 + 1);
    if (v25 <= v9)
      break;
    v8 += 48;
  }
  while (*(_QWORD *)(v4 + 8) > v9);
  if (v25 <= v9)
    return 1;
  v26 = v9;
  if (a4 <= v9)
    v4 = v9;
  else
    v4 = a4;
  v27 = 48 * v9;
  if (a4 <= v9)
    v9 = v9;
  else
    v9 = a4;
  while (v9 != v26)
  {
    re::AnimationValueTraits<re::GenericSRT<float>>::combine((float32x4_t *)(*(_QWORD *)a1 + v27), (float32x4_t *)buf, (float32x4_t *)(a3 + v27));
    ++v26;
    v27 += 48;
    if (*((_QWORD *)a1 + 1) <= v26)
      return 1;
  }
LABEL_25:
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v4, a4);
  result = _os_crash();
  __break(1u);
  return result;
}

double re::SampledAnimation<re::GenericSRT<float>>::totalDuration(uint64_t a1)
{
  return *(float *)(a1 + 84);
}

double re::SampledAnimation<re::GenericSRT<float>>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4, uint64_t a5, _OWORD *a6)
{
  unint64_t v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  unint64_t v16;
  uint64_t v17;
  __int128 *v18;
  __int128 v20;
  float32x4_t v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_26;
  }
  v7 = *(_QWORD *)(a1 + 96);
  if (v7 == 1)
    goto LABEL_9;
  if (!v7)
  {
    v8 = *a4;
    v9 = a4[1];
    v10 = a4[2];
LABEL_11:
    a6[1] = v9;
    a6[2] = v10;
    *a6 = v8;
    return *(double *)&v8;
  }
  v11 = *(double *)(a2 + 24);
  v12 = *(float *)(a1 + 80);
  if (v12 >= v11)
  {
LABEL_9:
    v18 = *(__int128 **)(a1 + 104);
LABEL_10:
    v8 = *v18;
    v9 = v18[1];
    v10 = v18[2];
    goto LABEL_11;
  }
  if (*(float *)(a1 + 84) <= v11
    || (v13 = (float)(v11 - v12) / *(float *)(a1 + 76),
        v14 = floorf(v13),
        v15 = v14 + ceilf(v13 - v14),
        v16 = (unint64_t)(float)(v15 + 0.5),
        v7 < v16))
  {
    v17 = *(_QWORD *)(a1 + 104) + 48 * v7;
    v8 = *(_OWORD *)(v17 - 48);
    v9 = *(_OWORD *)(v17 - 32);
    v10 = *(_OWORD *)(v17 - 16);
    goto LABEL_11;
  }
  if (v7 == v16 || *(_BYTE *)(a1 + 73) == 0)
  {
    if (v7 <= v16)
      v16 = v7 - 1;
    if (v7 > v16)
    {
      v18 = (__int128 *)(*(_QWORD *)(a1 + 104) + 48 * v16);
      goto LABEL_10;
    }
LABEL_26:
    v25 = 0u;
    v26 = 0u;
    v23 = 0u;
    v24 = 0u;
    v22 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_27;
  }
  if (v7 <= v16 - 1)
  {
LABEL_27:
    v25 = 0u;
    v26 = 0u;
    v23 = 0u;
    v24 = 0u;
    v22 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_28:
    v25 = 0u;
    v26 = 0u;
    v23 = 0u;
    v24 = 0u;
    v22 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (v7 <= v16)
    goto LABEL_28;
  re::lerp<float>((float32x4_t *)(*(_QWORD *)(a1 + 104) + 48 * (v16 - 1)), (float32x4_t *)(*(_QWORD *)(a1 + 104) + 48 * v16), &v22, v13 - (float)(v15 + -1.0));
  v20 = v23;
  *a6 = v22;
  a6[1] = v20;
  *(_QWORD *)&v8 = v24;
  a6[2] = v24;
  return *(double *)&v8;
}

uint64_t re::AnimationHelper::makeAdditiveForValues<re::SkeletalPose>(re *a1, _QWORD *a2, uint64_t a3, _QWORD *a4)
{
  _QWORD *v4;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t result;
  NSObject *v16;
  const char *v17;
  uint8_t buf[8];
  void *v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  int v23;
  uint64_t v24;
  uint64_t v25;

  if (*((_QWORD **)a1 + 1) != a4)
  {
    v16 = *re::animationLogObjects(a1);
    result = os_log_type_enabled(v16, OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    *(_WORD *)buf = 0;
    v17 = "Cannot make additive values, output values expected to match input values size.";
    goto LABEL_24;
  }
  v4 = a2;
  if (!a2[1])
  {
    v16 = *re::animationLogObjects(a1);
    result = os_log_type_enabled(v16, OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    *(_WORD *)buf = 0;
    v17 = "Cannot make additive values, base values array size must not be zero.";
LABEL_24:
    _os_log_error_impl(&dword_224FE9000, v16, OS_LOG_TYPE_ERROR, v17, buf, 2u);
    return 0;
  }
  *(_QWORD *)buf = 0;
  v19 = &str_110;
  v20 = 0u;
  v21 = 0u;
  v22 = 0u;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  re::SkeletalPose::init((uint64_t *)buf, (uint64_t *)(*a2 + 80));
  v9 = 0;
  v10 = *((_QWORD *)a1 + 1);
  if (v10 && v4[1])
  {
    v11 = 0;
    v9 = 0;
    while (1)
    {
      re::AnimationValueTraits<re::SkeletalPose>::invert((_QWORD *)(*v4 + v11), buf);
      v13 = *((_QWORD *)a1 + 1);
      if (v13 <= v9)
        break;
      if (a4 == (_QWORD *)v9)
        goto LABEL_27;
      re::AnimationValueTraits<re::SkeletalPose>::combine((_QWORD *)(*(_QWORD *)a1 + v11), buf, (_QWORD *)(a3 + v11));
      ++v9;
      v10 = *((_QWORD *)a1 + 1);
      if (v10 > v9)
      {
        v11 += 88;
        if (v4[1] > v9)
          continue;
      }
      v9 = v9;
      goto LABEL_11;
    }
    re::internal::assertLog((re::internal *)6, v12, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v9, v13);
    _os_crash();
    __break(1u);
  }
  else
  {
LABEL_11:
    if (v10 <= v9)
    {
LABEL_18:
      re::SkeletalPose::deinit((re::SkeletalPose *)buf);
      re::SkeletalPose::~SkeletalPose((re::SkeletalPose *)buf);
      return 1;
    }
    if ((unint64_t)a4 <= v9)
      v4 = (_QWORD *)v9;
    else
      v4 = a4;
    v14 = 88 * v9;
    while (v4 != (_QWORD *)v9)
    {
      re::AnimationValueTraits<re::SkeletalPose>::combine((_QWORD *)(*(_QWORD *)a1 + v14), buf, (_QWORD *)(a3 + v14));
      ++v9;
      v14 += 88;
      if (*((_QWORD *)a1 + 1) <= v9)
        goto LABEL_18;
    }
  }
  re::internal::assertLog((re::internal *)6, v8, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v4, a4);
  _os_crash();
  __break(1u);
LABEL_27:
  re::internal::assertLog((re::internal *)6, v12, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, a4, a4);
  result = _os_crash();
  __break(1u);
  return result;
}

double re::SampledAnimation<re::SkeletalPose>::totalDuration(uint64_t a1)
{
  return *(float *)(a1 + 84);
}

void re::SampledAnimation<re::SkeletalPose>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4, uint64_t a5, _QWORD *a6)
{
  unint64_t v6;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  unint64_t v13;

  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_24:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_25;
  }
  v6 = *(_QWORD *)(a1 + 96);
  if (v6 == 1)
    goto LABEL_9;
  if (!v6)
    goto LABEL_10;
  v8 = *(double *)(a2 + 24);
  v9 = *(float *)(a1 + 80);
  if (v9 >= v8)
  {
LABEL_9:
    a4 = *(_QWORD **)(a1 + 104);
    goto LABEL_10;
  }
  if (*(float *)(a1 + 84) <= v8
    || (v10 = (float)(v8 - v9) / *(float *)(a1 + 76),
        v11 = floorf(v10),
        v12 = v11 + ceilf(v10 - v11),
        v13 = (unint64_t)(float)(v12 + 0.5),
        v6 < v13))
  {
    a4 = (_QWORD *)(*(_QWORD *)(a1 + 104) + 88 * v6 - 88);
LABEL_10:
    re::AnimationValueTraits<re::SkeletalPose>::copy(a4, a6);
    return;
  }
  if (v6 == v13 || *(_BYTE *)(a1 + 73) == 0)
  {
    if (v6 <= v13)
      v13 = v6 - 1;
    if (v6 > v13)
    {
      a4 = (_QWORD *)(*(_QWORD *)(a1 + 104) + 88 * v13);
      goto LABEL_10;
    }
    goto LABEL_24;
  }
  if (v6 <= v13 - 1)
  {
LABEL_25:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_26:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (v6 <= v13)
    goto LABEL_26;
  re::AnimationValueTraits<re::SkeletalPose>::interpolate((_QWORD *)(*(_QWORD *)(a1 + 104) + 88 * (v13 - 1)), (_QWORD *)(*(_QWORD *)(a1 + 104) + 88 * v13), a6, v10 - (float)(v12 + -1.0));
}

double re::SampledAnimation<re::BlendShapeWeights>::totalDuration(uint64_t a1)
{
  return *(float *)(a1 + 84);
}

uint64_t *re::SampledAnimation<re::BlendShapeWeights>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5, uint64_t *a6)
{
  unint64_t v6;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  unint64_t v13;

  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_24:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_25;
  }
  v6 = *(_QWORD *)(a1 + 96);
  if (v6 == 1)
    goto LABEL_9;
  if (!v6)
    return re::AnimationValueTraits<re::BlendShapeWeights>::copy(a4, a6);
  v8 = *(double *)(a2 + 24);
  v9 = *(float *)(a1 + 80);
  if (v9 >= v8)
  {
LABEL_9:
    a4 = *(uint64_t **)(a1 + 104);
    return re::AnimationValueTraits<re::BlendShapeWeights>::copy(a4, a6);
  }
  if (*(float *)(a1 + 84) <= v8
    || (v10 = (float)(v8 - v9) / *(float *)(a1 + 76),
        v11 = floorf(v10),
        v12 = v11 + ceilf(v10 - v11),
        v13 = (unint64_t)(float)(v12 + 0.5),
        v6 < v13))
  {
    a4 = (uint64_t *)(*(_QWORD *)(a1 + 104) + 32 * v6 - 32);
    return re::AnimationValueTraits<re::BlendShapeWeights>::copy(a4, a6);
  }
  if (v6 == v13 || *(_BYTE *)(a1 + 73) == 0)
  {
    if (v6 <= v13)
      v13 = v6 - 1;
    if (v6 > v13)
    {
      a4 = (uint64_t *)(*(_QWORD *)(a1 + 104) + 32 * v13);
      return re::AnimationValueTraits<re::BlendShapeWeights>::copy(a4, a6);
    }
    goto LABEL_24;
  }
  if (v6 <= v13 - 1)
  {
LABEL_25:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_26:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (v6 <= v13)
    goto LABEL_26;
  return (uint64_t *)re::AnimationValueTraits<re::BlendShapeWeights>::interpolate((_anonymous_namespace_ *)(*(_QWORD *)(a1 + 104) + 32 * (v13 - 1)), (_QWORD *)(*(_QWORD *)(a1 + 104) + 32 * v13), a6, v10 - (float)(v12 + -1.0));
}

void re::SkeletalPoseSampledAnimation::evaluateCore(re::SkeletalPoseSampledAnimation *this, uint64_t a2, uint64_t a3, re::SkeletalPose *a4, uint64_t a5, re::SkeletalPose *a6)
{
  unint64_t v9;
  const re::SkeletalPose *v10;
  float32x4_t v11;
  float v12;
  float v13;
  float v14;
  float v15;
  unint64_t v16;
  unint64_t v17;
  float v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  unint64_t *v28;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t *v34;
  uint64_t v35;
  unint64_t *v36;
  _QWORD *v37;
  _QWORD *v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  uint64_t v44;
  _QWORD *v45;
  float v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t *v49;
  unint64_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  int8x16_t v57;
  float32x4_t v58;
  int8x16_t v59;
  float v60;
  float v61;
  float v62;
  float v63;
  float v64;
  float v65;
  float v66;
  float v67;
  float v68;
  float v69;
  float32x2_t v70;
  float32x2_t v71;
  float v72;
  int8x16_t v73;
  float32x2_t v74;
  uint64_t v75;
  uint64_t v76;
  unsigned __int32 v77;
  float32x2_t v78;
  float32x2_t v79;
  uint64_t *v80;
  unint64_t v81;
  uint64_t v82;
  uint64_t v83;
  unint64_t v84;
  uint64_t v85;
  uint64_t v86;
  _QWORD *v87;
  _QWORD *v88;
  uint64_t i;
  uint64_t v90;
  unint64_t *v91;
  unint64_t v92;
  unint64_t v93;
  uint64_t v94;
  uint64_t v95;
  unint64_t v96;
  unint64_t v97;
  uint64_t v98;
  uint64_t v99;
  unint64_t *v100;
  _QWORD *v101;
  _QWORD *v102;
  float v103;
  uint64_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  int8x16_t v111;
  float32x4_t v112;
  int8x16_t v113;
  float v114;
  float v115;
  float v116;
  float v117;
  float v118;
  float v119;
  float v120;
  float v121;
  float v122;
  float v123;
  float32x2_t v124;
  float32x2_t v125;
  float v126;
  int8x16_t v127;
  float32x2_t v128;
  uint64_t v129;
  uint64_t v130;
  unsigned __int32 v131;
  float32x2_t v132;
  float32x2_t v133;
  uint64_t *v134;
  unint64_t v135;
  uint64_t v136;
  unint64_t v137;
  uint64_t v138;
  unint64_t *v139;
  uint64_t v140;
  unint64_t *v141;
  _QWORD *v142;
  float32x4_t v143;
  _QWORD *v144;
  uint64_t v145;
  unint64_t v146;
  uint64_t v147;
  unint64_t v148;
  unint64_t v149;
  uint64_t v150;
  _QWORD *v151;
  unint64_t *v152;
  float32x4_t v153;
  unint64_t *v154;
  _QWORD *v155;
  float v156;
  float v157;
  float32x4_t v158;
  unint64_t *v159;
  unint64_t *v160;
  float32x4_t v161;
  unint64_t *v162;
  float v163;
  float v164;
  unint64_t *v165;
  float32x4_t v166;
  unint64_t *v167;
  float32x4_t v168;
  _QWORD *v169;
  float32x4_t v170;
  float v171;

  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, a2, 0, a4, a5, a6, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_127:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_128:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_129:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_130:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_131:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_132:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_133:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_134:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_135:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_136:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_137:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_138:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_139:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_140:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_141:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_142:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_143:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_144;
  }
  v9 = *((_QWORD *)this + 12);
  v10 = a4;
  if (!v9)
    goto LABEL_23;
  if (v9 == 1
    || (v11.i64[0] = *(_QWORD *)(a2 + 24),
        v11.f32[0] = *(double *)v11.i64,
        v12 = *((float *)this + 20),
        v12 >= v11.f32[0]))
  {
    v10 = (const re::SkeletalPose *)*((_QWORD *)this + 13);
LABEL_23:
    re::SkeletalPoseSampledAnimation::copyPose(this, a4, v10, a6);
    return;
  }
  if (*((float *)this + 21) <= v11.f32[0])
  {
    v10 = (const re::SkeletalPose *)(*((_QWORD *)this + 13) + 88 * v9 - 88);
    goto LABEL_23;
  }
  v13 = (float)(v11.f32[0] - v12) / *((float *)this + 19);
  v14 = floorf(v13);
  v15 = v14 + ceilf(v13 - v14);
  v16 = (unint64_t)(float)(v15 + 0.5);
  if (!*((_BYTE *)this + 73) || v9 == v16)
  {
    if (v9 <= v16)
      v30 = v9 - 1;
    else
      v30 = (unint64_t)(float)(v15 + 0.5);
    if (v9 <= v30)
    {
LABEL_162:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    v10 = (const re::SkeletalPose *)(*((_QWORD *)this + 13) + 88 * v30);
    goto LABEL_23;
  }
  v17 = v16 - 1;
  if (v9 <= v16 - 1)
  {
LABEL_160:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_161;
  }
  if (v9 <= v16)
  {
LABEL_161:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_162;
  }
  v18 = v13 - (float)(v15 + -1.0);
  v19 = *((_QWORD *)a4 + 10);
  v20 = *(_QWORD *)(v19 + 192);
  v149 = (unint64_t)(float)(v15 + 0.5);
  v150 = *((_QWORD *)this + 13);
  v169 = (_QWORD *)(v150 + 88 * v17 + 80);
  v171 = v18;
  v148 = v16 - 1;
  if (*v169 == v19)
  {
    if (*((_BYTE *)this + 112))
    {
      if (v20)
      {
        v31 = 0;
        v32 = 0;
        v33 = v150 + 88 * v17;
        v34 = (unint64_t *)(v33 + 24);
        v35 = v150 + 88 * v16;
        v36 = (unint64_t *)(v35 + 24);
        v37 = (_QWORD *)(v33 + 32);
        v11.f32[0] = 1.0 - v18;
        v11 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 0);
        v38 = (_QWORD *)(v35 + 32);
        while (*v34 > v32)
        {
          if (*v36 <= v32)
            goto LABEL_139;
          if (*((_QWORD *)a6 + 3) <= v32)
            goto LABEL_140;
          *(float32x4_t *)(*((_QWORD *)a6 + 4) + v31) = vmlaq_f32(vmulq_n_f32(*(float32x4_t *)(*v38 + v31), v18), v11, *(float32x4_t *)(*v37 + v31));
          ++v32;
          v31 += 48;
          if (v20 == v32)
            goto LABEL_90;
        }
        goto LABEL_138;
      }
    }
    else if (v20)
    {
      v95 = 0;
      v96 = 0;
      while (*((_QWORD *)a4 + 3) > v96)
      {
        if (*((_QWORD *)a6 + 3) <= v96)
          goto LABEL_155;
        v11 = *(float32x4_t *)(*((_QWORD *)a4 + 4) + v95);
        *(float32x4_t *)(*((_QWORD *)a6 + 4) + v95) = v11;
        ++v96;
        v95 += 48;
        if (v20 == v96)
          goto LABEL_90;
      }
      goto LABEL_154;
    }
LABEL_90:
    if (*((_BYTE *)this + 113))
    {
      if (v20)
      {
        v97 = 0;
        v98 = v150 + 88 * v148;
        v159 = (unint64_t *)(v98 + 24);
        v99 = v150 + 88 * v16;
        v100 = (unint64_t *)(v99 + 24);
        v101 = (_QWORD *)(v98 + 32);
        v102 = (_QWORD *)(v99 + 32);
        v103 = 1.0 - v18;
        v104 = 16;
        while (*v159 > v97)
        {
          if (*v100 <= v97)
            goto LABEL_147;
          v105 = *(float32x4_t *)(*v101 + v104);
          v106 = *(float32x4_t *)(*v102 + v104);
          v107 = vmulq_f32(v105, v106);
          v108 = (float32x4_t)vextq_s8((int8x16_t)v107, (int8x16_t)v107, 8uLL);
          *(float32x2_t *)v107.f32 = vadd_f32(*(float32x2_t *)v107.f32, *(float32x2_t *)v108.f32);
          v107.f32[0] = vaddv_f32(*(float32x2_t *)v107.f32);
          v108.i32[0] = 0;
          v109 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8((int8x16_t)vcgeq_f32(v107, v108)), 0), (int8x16_t)vnegq_f32(v106), (int8x16_t)v106);
          v110 = vsubq_f32(v105, v109);
          v111 = (int8x16_t)vmulq_f32(v110, v110);
          v168 = v109;
          v170 = v105;
          v112 = vaddq_f32(v105, v109);
          v113 = (int8x16_t)vmulq_f32(v112, v112);
          v114 = atan2f(sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v111.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v111, v111, 8uLL)))), sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v113.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v113, v113, 8uLL)))));
          v115 = v114 + v114;
          v116 = 1.0;
          v117 = 1.0;
          if ((float)(v114 + v114) != 0.0)
            v117 = sinf(v114 + v114) / v115;
          if ((float)(v103 * v115) != 0.0)
          {
            v163 = v117;
            v118 = sinf(v103 * v115);
            v117 = v163;
            v116 = v118 / (float)(v103 * v115);
          }
          v119 = v171;
          v120 = v171 * v115;
          v121 = 1.0;
          if (v120 != 0.0)
          {
            v164 = v117;
            v122 = sinf(v120);
            v119 = v171;
            v117 = v164;
            v121 = v122 / v120;
          }
          v123 = v117;
          v124 = vrecpe_f32((float32x2_t)LODWORD(v117));
          v125 = vmul_f32(v124, vrecps_f32((float32x2_t)LODWORD(v123), v124));
          v126 = vmul_f32(v125, vrecps_f32((float32x2_t)LODWORD(v123), v125)).f32[0];
          v125.f32[0] = v103 * (float)(v126 * v116);
          v11 = vmlaq_f32(vmulq_n_f32(v168, v119 * (float)(v126 * v121)), v170, (float32x4_t)vdupq_lane_s32((int32x2_t)v125, 0));
          v127 = (int8x16_t)vmulq_f32(v11, v11);
          v128 = vadd_f32(*(float32x2_t *)v127.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v127, v127, 8uLL));
          if (vaddv_f32(v128) == 0.0)
          {
            v129 = 0;
            v130 = 0x3F80000000000000;
          }
          else
          {
            v131 = vadd_f32(v128, (float32x2_t)vdup_lane_s32((int32x2_t)v128, 1)).u32[0];
            v132 = vrsqrte_f32((float32x2_t)v131);
            v133 = vmul_f32(v132, vrsqrts_f32((float32x2_t)v131, vmul_f32(v132, v132)));
            v11 = vmulq_n_f32(v11, vmul_f32(v133, vrsqrts_f32((float32x2_t)v131, vmul_f32(v133, v133))).f32[0]);
            v130 = v11.i64[1];
            v129 = v11.i64[0];
          }
          if (*((_QWORD *)a6 + 3) <= v97)
            goto LABEL_148;
          v134 = (uint64_t *)(*((_QWORD *)a6 + 4) + v104);
          *v134 = v129;
          v134[1] = v130;
          ++v97;
          v104 += 48;
          if (v20 == v97)
            goto LABEL_112;
        }
        goto LABEL_146;
      }
    }
    else if (v20)
    {
      v135 = 0;
      v136 = 16;
      while (*((_QWORD *)a4 + 3) > v135)
      {
        if (*((_QWORD *)a6 + 3) <= v135)
          goto LABEL_157;
        v11 = *(float32x4_t *)(*((_QWORD *)a4 + 4) + v136);
        *(float32x4_t *)(*((_QWORD *)a6 + 4) + v136) = v11;
        ++v135;
        v136 += 48;
        if (v20 == v135)
          goto LABEL_112;
      }
LABEL_156:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_157:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_158;
    }
LABEL_112:
    if (*((_BYTE *)this + 114))
    {
      if (v20)
      {
        v137 = 0;
        v138 = v150 + 88 * v148;
        v139 = (unint64_t *)(v138 + 24);
        v140 = v150 + 88 * v149;
        v141 = (unint64_t *)(v140 + 24);
        v142 = (_QWORD *)(v138 + 32);
        v11.f32[0] = 1.0 - v171;
        v143 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 0);
        v144 = (_QWORD *)(v140 + 32);
        v145 = 32;
        while (*v139 > v137)
        {
          if (*v141 <= v137)
            goto LABEL_152;
          if (*((_QWORD *)a6 + 3) <= v137)
            goto LABEL_153;
          *(float32x4_t *)(*((_QWORD *)a6 + 4) + v145) = vmlaq_f32(vmulq_n_f32(*(float32x4_t *)(*v144 + v145), v171), v143, *(float32x4_t *)(*v142 + v145));
          ++v137;
          v145 += 48;
          if (v20 == v137)
            return;
        }
        goto LABEL_151;
      }
    }
    else if (v20)
    {
      v146 = 0;
      v147 = 32;
      while (*((_QWORD *)a4 + 3) > v146)
      {
        if (*((_QWORD *)a6 + 3) <= v146)
          goto LABEL_159;
        *(_OWORD *)(*((_QWORD *)a6 + 4) + v147) = *(_OWORD *)(*((_QWORD *)a4 + 4) + v147);
        ++v146;
        v147 += 48;
        if (v20 == v146)
          return;
      }
LABEL_158:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_159:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_160;
    }
  }
  else
  {
    if (*((_BYTE *)this + 112))
    {
      if (v20)
      {
        v21 = 0;
        v22 = 0;
        v23 = 0;
        v24 = v150 + 88 * v148;
        v165 = (unint64_t *)(v24 + 24);
        v25 = v150 + 88 * v149;
        v160 = (unint64_t *)(v25 + 24);
        v155 = (_QWORD *)(v24 + 32);
        v11.f32[0] = 1.0 - v18;
        v153 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 0);
        v26 = (_QWORD *)(v25 + 32);
        do
        {
          v27 = *((_QWORD *)a4 + 10);
          if (*(_QWORD *)(v27 + 192) <= v23)
            goto LABEL_127;
          v28 = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(*v169 + 208, (_QWORD *)(*(_QWORD *)(v27 + 200) + v21));
          if (v28)
          {
            v29 = *v28;
            if (*v165 <= *v28)
              goto LABEL_130;
            if (*v160 <= v29)
              goto LABEL_131;
            if (*((_QWORD *)a6 + 3) <= v23)
              goto LABEL_132;
            v11 = *(float32x4_t *)(*v155 + 48 * v29);
            *(float32x4_t *)(*((_QWORD *)a6 + 4) + v22) = vmlaq_f32(vmulq_n_f32(*(float32x4_t *)(*v26 + 48 * v29), v171), v153, v11);
          }
          ++v23;
          v22 += 48;
          v21 += 16;
        }
        while (v20 != v23);
      }
    }
    else if (v20)
    {
      v39 = 0;
      v40 = 0;
      while (*((_QWORD *)a4 + 3) > v40)
      {
        if (*((_QWORD *)a6 + 3) <= v40)
          goto LABEL_137;
        v11 = *(float32x4_t *)(*((_QWORD *)a4 + 4) + v39);
        *(float32x4_t *)(*((_QWORD *)a6 + 4) + v39) = v11;
        ++v40;
        v39 += 48;
        if (v20 == v40)
          goto LABEL_43;
      }
      goto LABEL_136;
    }
LABEL_43:
    if (*((_BYTE *)this + 113))
    {
      if (v20)
      {
        v41 = 0;
        v42 = 0;
        v43 = v150 + 88 * v148;
        v154 = (unint64_t *)(v43 + 24);
        v44 = v150 + 88 * v149;
        v151 = (_QWORD *)(v43 + 32);
        v152 = (unint64_t *)(v44 + 24);
        v45 = (_QWORD *)(v44 + 32);
        v46 = 1.0 - v171;
        v47 = 16;
        do
        {
          v48 = *((_QWORD *)a4 + 10);
          if (*(_QWORD *)(v48 + 192) <= v42)
            goto LABEL_128;
          v49 = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(*v169 + 208, (_QWORD *)(*(_QWORD *)(v48 + 200) + v41));
          if (v49)
          {
            v50 = *v49;
            if (*v154 <= *v49)
              goto LABEL_133;
            if (*v152 <= v50)
              goto LABEL_134;
            v51 = *(float32x4_t *)(*v151 + 48 * v50 + 16);
            v52 = *(float32x4_t *)(*v45 + 48 * v50 + 16);
            v53 = vmulq_f32(v51, v52);
            v54 = (float32x4_t)vextq_s8((int8x16_t)v53, (int8x16_t)v53, 8uLL);
            *(float32x2_t *)v53.f32 = vadd_f32(*(float32x2_t *)v53.f32, *(float32x2_t *)v54.f32);
            v53.f32[0] = vaddv_f32(*(float32x2_t *)v53.f32);
            v54.i32[0] = 0;
            v55 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8((int8x16_t)vcgeq_f32(v53, v54)), 0), (int8x16_t)vnegq_f32(v52), (int8x16_t)v52);
            v56 = vsubq_f32(v51, v55);
            v57 = (int8x16_t)vmulq_f32(v56, v56);
            v161 = v55;
            v166 = v51;
            v58 = vaddq_f32(v51, v55);
            v59 = (int8x16_t)vmulq_f32(v58, v58);
            v60 = atan2f(sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v57.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v57, v57, 8uLL)))), sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v59.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v59, v59, 8uLL)))));
            v61 = v60 + v60;
            v62 = 1.0;
            v63 = 1.0;
            if ((float)(v60 + v60) != 0.0)
              v63 = sinf(v60 + v60) / v61;
            if ((float)(v46 * v61) != 0.0)
            {
              v156 = v63;
              v64 = sinf(v46 * v61);
              v63 = v156;
              v62 = v64 / (float)(v46 * v61);
            }
            v65 = v171;
            v66 = v171 * v61;
            v67 = 1.0;
            if (v66 != 0.0)
            {
              v157 = v63;
              v68 = sinf(v66);
              v65 = v171;
              v63 = v157;
              v67 = v68 / v66;
            }
            v69 = v63;
            v70 = vrecpe_f32((float32x2_t)LODWORD(v63));
            v71 = vmul_f32(v70, vrecps_f32((float32x2_t)LODWORD(v69), v70));
            v72 = vmul_f32(v71, vrecps_f32((float32x2_t)LODWORD(v69), v71)).f32[0];
            v71.f32[0] = v46 * (float)(v72 * v62);
            v11 = vmlaq_f32(vmulq_n_f32(v161, v65 * (float)(v72 * v67)), v166, (float32x4_t)vdupq_lane_s32((int32x2_t)v71, 0));
            v73 = (int8x16_t)vmulq_f32(v11, v11);
            v74 = vadd_f32(*(float32x2_t *)v73.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v73, v73, 8uLL));
            if (vaddv_f32(v74) == 0.0)
            {
              v75 = 0;
              v76 = 0x3F80000000000000;
            }
            else
            {
              v77 = vadd_f32(v74, (float32x2_t)vdup_lane_s32((int32x2_t)v74, 1)).u32[0];
              v78 = vrsqrte_f32((float32x2_t)v77);
              v79 = vmul_f32(v78, vrsqrts_f32((float32x2_t)v77, vmul_f32(v78, v78)));
              v11 = vmulq_n_f32(v11, vmul_f32(v79, vrsqrts_f32((float32x2_t)v77, vmul_f32(v79, v79))).f32[0]);
              v76 = v11.i64[1];
              v75 = v11.i64[0];
            }
            if (*((_QWORD *)a6 + 3) <= v42)
              goto LABEL_135;
            v80 = (uint64_t *)(*((_QWORD *)a6 + 4) + v47);
            *v80 = v75;
            v80[1] = v76;
          }
          ++v42;
          v47 += 48;
          v41 += 16;
        }
        while (v20 != v42);
      }
    }
    else if (v20)
    {
      v81 = 0;
      v82 = 16;
      while (*((_QWORD *)a4 + 3) > v81)
      {
        if (*((_QWORD *)a6 + 3) <= v81)
          goto LABEL_145;
        v11 = *(float32x4_t *)(*((_QWORD *)a4 + 4) + v82);
        *(float32x4_t *)(*((_QWORD *)a6 + 4) + v82) = v11;
        ++v81;
        v82 += 48;
        if (v20 == v81)
          goto LABEL_68;
      }
LABEL_144:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_145:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_146:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_147:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_148:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_149;
    }
LABEL_68:
    if (*((_BYTE *)this + 114))
    {
      if (v20)
      {
        v83 = 0;
        v84 = 0;
        v85 = v150 + 88 * v148;
        v167 = (unint64_t *)(v85 + 24);
        v86 = v150 + 88 * v149;
        v162 = (unint64_t *)(v86 + 24);
        v87 = (_QWORD *)(v85 + 32);
        v11.f32[0] = 1.0 - v171;
        v158 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 0);
        v88 = (_QWORD *)(v86 + 32);
        for (i = 32; ; i += 48)
        {
          v90 = *((_QWORD *)a4 + 10);
          if (*(_QWORD *)(v90 + 192) <= v84)
            break;
          v91 = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(*v169 + 208, (_QWORD *)(*(_QWORD *)(v90 + 200) + v83));
          if (v91)
          {
            v92 = *v91;
            if (*v167 <= *v91)
              goto LABEL_141;
            if (*v162 <= v92)
              goto LABEL_142;
            if (*((_QWORD *)a6 + 3) <= v84)
              goto LABEL_143;
            *(float32x4_t *)(*((_QWORD *)a6 + 4) + i) = vmlaq_f32(vmulq_n_f32(*(float32x4_t *)(*v88 + 48 * v92 + 32), v171), v158, *(float32x4_t *)(*v87 + 48 * v92 + 32));
          }
          ++v84;
          v83 += 16;
          if (v20 == v84)
            return;
        }
        goto LABEL_129;
      }
    }
    else if (v20)
    {
      v93 = 0;
      v94 = 32;
      while (*((_QWORD *)a4 + 3) > v93)
      {
        if (*((_QWORD *)a6 + 3) <= v93)
          goto LABEL_150;
        *(_OWORD *)(*((_QWORD *)a6 + 4) + v94) = *(_OWORD *)(*((_QWORD *)a4 + 4) + v94);
        ++v93;
        v94 += 48;
        if (v20 == v93)
          return;
      }
LABEL_149:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_150:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_151:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_152:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_153:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_154:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_155:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_156;
    }
  }
}

__n128 re::SkeletalPoseSampledAnimation::copyPose(re::SkeletalPoseSampledAnimation *this, const re::SkeletalPose *a2, const re::SkeletalPose *a3, re::SkeletalPose *a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v10;
  BOOL v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t *v18;
  uint64_t v19;
  const re::SkeletalPose *v20;
  uint64_t *v21;
  __n128 result;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t *v28;
  uint64_t v29;
  const re::SkeletalPose *v30;
  uint64_t *v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t k;
  uint64_t v35;
  _QWORD *v36;
  uint64_t *v37;
  uint64_t v38;
  const re::SkeletalPose *v39;
  uint64_t *v40;
  BOOL v41;
  uint64_t v42;
  unint64_t v43;
  BOOL v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  BOOL v50;
  uint64_t v51;
  uint64_t v52;
  unint64_t v53;
  uint64_t v54;
  _QWORD *v55;
  uint64_t v56;
  unint64_t v57;
  uint64_t v58;
  uint64_t v59;
  _QWORD *v60;
  uint64_t v61;
  unint64_t v62;
  uint64_t i;
  uint64_t v64;
  _QWORD *v65;
  uint64_t v66;
  uint64_t v67;
  unint64_t v68;
  uint64_t v69;
  uint64_t *v70;
  unint64_t v71;
  const re::SkeletalPose *v72;
  uint64_t v73;
  unint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t *v77;
  unint64_t v78;
  const re::SkeletalPose *v79;
  uint64_t v80;
  unint64_t v81;
  uint64_t j;
  uint64_t v83;
  uint64_t *v84;
  unint64_t v85;
  const re::SkeletalPose *v86;

  v6 = *((_QWORD *)a4 + 10);
  v7 = *(_QWORD *)(v6 + 192);
  v8 = *((_QWORD *)a3 + 10);
  if (v8 == v6)
  {
    if (*((_BYTE *)this + 112))
      v41 = v7 == 0;
    else
      v41 = 1;
    if (v41)
    {
LABEL_57:
      if (*((_BYTE *)this + 113))
        v44 = v7 == 0;
      else
        v44 = 1;
      if (v44)
      {
LABEL_65:
        if (!*((_BYTE *)this + 114) || !v7)
          return result;
        v47 = 0;
        v48 = 32;
        while (*((_QWORD *)a3 + 3) > v47)
        {
          if (*((_QWORD *)a4 + 3) <= v47)
            goto LABEL_140;
          result = *(__n128 *)(*((_QWORD *)a3 + 4) + v48);
          *(__n128 *)(*((_QWORD *)a4 + 4) + v48) = result;
          ++v47;
          v48 += 48;
          if (v7 == v47)
            return result;
        }
        goto LABEL_139;
      }
      v45 = 0;
      v46 = 16;
      while (*((_QWORD *)a3 + 3) > v45)
      {
        if (*((_QWORD *)a4 + 3) <= v45)
          goto LABEL_138;
        result = *(__n128 *)(*((_QWORD *)a3 + 4) + v46);
        *(__n128 *)(*((_QWORD *)a4 + 4) + v46) = result;
        ++v45;
        v46 += 48;
        if (v7 == v45)
          goto LABEL_65;
      }
    }
    else
    {
      v42 = 0;
      v43 = 0;
      while (*((_QWORD *)a3 + 3) > v43)
      {
        if (*((_QWORD *)a4 + 3) <= v43)
          goto LABEL_136;
        result = *(__n128 *)(*((_QWORD *)a3 + 4) + v42);
        *(__n128 *)(*((_QWORD *)a4 + 4) + v42) = result;
        ++v43;
        v42 += 48;
        if (v7 == v43)
          goto LABEL_57;
      }
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_136:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_138:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_139:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_140:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_141:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_142:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_143;
  }
  v10 = *((_QWORD *)a2 + 10);
  if (v8 == v10)
  {
    if (*((_BYTE *)this + 112))
      v50 = v7 == 0;
    else
      v50 = 1;
    if (v50)
    {
LABEL_83:
      if (!*((_BYTE *)this + 113) || !v7)
      {
LABEL_92:
        if (!*((_BYTE *)this + 114) || !v7)
          return result;
        v61 = 0;
        v62 = 0;
        for (i = 32; ; i += 48)
        {
          v64 = *((_QWORD *)a4 + 10);
          if (*(_QWORD *)(v64 + 192) <= v62)
            break;
          v65 = (_QWORD *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(*((_QWORD *)a3 + 10) + 208, (_QWORD *)(*(_QWORD *)(v64 + 200) + v61));
          if (v65)
          {
            if (*((_QWORD *)a3 + 3) <= *v65)
              goto LABEL_159;
            if (*((_QWORD *)a4 + 3) <= v62)
              goto LABEL_160;
            result = *(__n128 *)(*((_QWORD *)a3 + 4) + 48 * *v65 + 32);
            *(__n128 *)(*((_QWORD *)a4 + 4) + i) = result;
          }
          ++v62;
          v61 += 16;
          if (v7 == v62)
            return result;
        }
        goto LABEL_146;
      }
      v56 = 0;
      v57 = 0;
      v58 = 16;
      while (1)
      {
        v59 = *((_QWORD *)a4 + 10);
        if (*(_QWORD *)(v59 + 192) <= v57)
          break;
        v60 = (_QWORD *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(*((_QWORD *)a3 + 10) + 208, (_QWORD *)(*(_QWORD *)(v59 + 200) + v56));
        if (v60)
        {
          if (*((_QWORD *)a3 + 3) <= *v60)
            goto LABEL_156;
          if (*((_QWORD *)a4 + 3) <= v57)
            goto LABEL_157;
          result = *(__n128 *)(*((_QWORD *)a3 + 4) + 48 * *v60 + 16);
          *(__n128 *)(*((_QWORD *)a4 + 4) + v58) = result;
        }
        ++v57;
        v58 += 48;
        v56 += 16;
        if (v7 == v57)
          goto LABEL_92;
      }
LABEL_145:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_146:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_147:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_148:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_149:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_150:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_151:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_152:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_153:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_154:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_155;
    }
    v51 = 0;
    v52 = 0;
    v53 = 0;
    while (1)
    {
      v54 = *((_QWORD *)a4 + 10);
      if (*(_QWORD *)(v54 + 192) <= v53)
        break;
      v55 = (_QWORD *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(*((_QWORD *)a3 + 10) + 208, (_QWORD *)(*(_QWORD *)(v54 + 200) + v51));
      if (v55)
      {
        if (*((_QWORD *)a3 + 3) <= *v55)
          goto LABEL_151;
        if (*((_QWORD *)a4 + 3) <= v53)
          goto LABEL_152;
        result = *(__n128 *)(*((_QWORD *)a3 + 4) + 48 * *v55);
        *(__n128 *)(*((_QWORD *)a4 + 4) + v52) = result;
      }
      ++v53;
      v52 += 48;
      v51 += 16;
      if (v7 == v53)
        goto LABEL_83;
    }
LABEL_143:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_144:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_145;
  }
  if (*((_BYTE *)this + 112))
    v11 = v7 == 0;
  else
    v11 = 1;
  v12 = !v11;
  if (v6 == v10)
  {
    if (!v12)
    {
LABEL_112:
      if (!*((_BYTE *)this + 113) || !v7)
      {
LABEL_123:
        if (!*((_BYTE *)this + 114) || !v7)
          return result;
        v80 = 0;
        v81 = 0;
        for (j = 32; ; j += 48)
        {
          v83 = *((_QWORD *)a4 + 10);
          if (*(_QWORD *)(v83 + 192) <= v81)
            break;
          v84 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(*((_QWORD *)a3 + 10) + 208, (_QWORD *)(*(_QWORD *)(v83 + 200) + v80));
          if (v84)
          {
            v85 = *v84;
            if (*((_QWORD *)a3 + 3) <= (unint64_t)*v84)
              goto LABEL_166;
            v86 = a3;
            if (*((_QWORD *)a4 + 3) <= v81)
              goto LABEL_167;
          }
          else
          {
            if (*((_QWORD *)a2 + 3) <= v81)
              goto LABEL_178;
            v86 = a2;
            v85 = v81;
            if (*((_QWORD *)a4 + 3) <= v81)
              goto LABEL_179;
          }
          result = *(__n128 *)(*((_QWORD *)v86 + 4) + 48 * v85 + 32);
          *(__n128 *)(*((_QWORD *)a4 + 4) + j) = result;
          ++v81;
          v80 += 16;
          if (v7 == v81)
            return result;
        }
LABEL_161:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_162:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_163:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_164:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_165:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_166:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_167:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_168:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_169:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_170:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_171:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_172:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_173:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_174:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_175:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_176:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_177:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_178:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_179:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      v73 = 0;
      v74 = 0;
      v75 = 16;
      while (1)
      {
        v76 = *((_QWORD *)a4 + 10);
        if (*(_QWORD *)(v76 + 192) <= v74)
          break;
        v77 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(*((_QWORD *)a3 + 10) + 208, (_QWORD *)(*(_QWORD *)(v76 + 200) + v73));
        if (v77)
        {
          v78 = *v77;
          if (*((_QWORD *)a3 + 3) <= (unint64_t)*v77)
            goto LABEL_164;
          v79 = a3;
          if (*((_QWORD *)a4 + 3) <= v74)
            goto LABEL_165;
        }
        else
        {
          if (*((_QWORD *)a2 + 3) <= v74)
            goto LABEL_176;
          v79 = a2;
          v78 = v74;
          if (*((_QWORD *)a4 + 3) <= v74)
            goto LABEL_177;
        }
        result = *(__n128 *)(*((_QWORD *)v79 + 4) + 48 * v78 + 16);
        *(__n128 *)(*((_QWORD *)a4 + 4) + v75) = result;
        ++v74;
        v73 += 16;
        v75 += 48;
        if (v7 == v74)
          goto LABEL_123;
      }
LABEL_158:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_159:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_160:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_161;
    }
    v66 = 0;
    v67 = 0;
    v68 = 0;
    while (1)
    {
      v69 = *((_QWORD *)a4 + 10);
      if (*(_QWORD *)(v69 + 192) <= v68)
        break;
      v70 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(*((_QWORD *)a3 + 10) + 208, (_QWORD *)(*(_QWORD *)(v69 + 200) + v67));
      if (v70)
      {
        v71 = *v70;
        if (*((_QWORD *)a3 + 3) <= (unint64_t)*v70)
          goto LABEL_162;
        v72 = a3;
        if (*((_QWORD *)a4 + 3) <= v68)
          goto LABEL_163;
      }
      else
      {
        if (*((_QWORD *)a2 + 3) <= v68)
          goto LABEL_174;
        v72 = a2;
        v71 = v68;
        if (*((_QWORD *)a4 + 3) <= v68)
          goto LABEL_175;
      }
      result = *(__n128 *)(*((_QWORD *)v72 + 4) + 48 * v71);
      *(__n128 *)(*((_QWORD *)a4 + 4) + v66) = result;
      ++v68;
      v67 += 16;
      v66 += 48;
      if (v7 == v68)
        goto LABEL_112;
    }
LABEL_155:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_156:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_157:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_158;
  }
  if (v12)
  {
    v13 = 0;
    v14 = 0;
    v15 = 0;
    while (1)
    {
      v16 = *((_QWORD *)a4 + 10);
      if (*(_QWORD *)(v16 + 192) <= v15)
        goto LABEL_141;
      v17 = (_QWORD *)(*(_QWORD *)(v16 + 200) + v14);
      v18 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(*((_QWORD *)a3 + 10) + 208, v17);
      if (v18)
        break;
      v21 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(*((_QWORD *)a2 + 10) + 208, v17);
      if (v21)
      {
        v19 = *v21;
        if (*((_QWORD *)a2 + 3) <= (unint64_t)*v21)
          goto LABEL_168;
        v20 = a2;
        if (*((_QWORD *)a4 + 3) <= v15)
          goto LABEL_169;
        goto LABEL_20;
      }
LABEL_21:
      ++v15;
      v14 += 16;
      v13 += 48;
      if (v7 == v15)
        goto LABEL_22;
    }
    v19 = *v18;
    if (*((_QWORD *)a3 + 3) <= (unint64_t)*v18)
      goto LABEL_147;
    v20 = a3;
    if (*((_QWORD *)a4 + 3) <= v15)
      goto LABEL_148;
LABEL_20:
    result = *(__n128 *)(*((_QWORD *)v20 + 4) + 48 * v19);
    *(__n128 *)(*((_QWORD *)a4 + 4) + v13) = result;
    goto LABEL_21;
  }
LABEL_22:
  if (*((_BYTE *)this + 113) && v7)
  {
    v23 = 0;
    v24 = 0;
    v25 = 16;
    while (1)
    {
      v26 = *((_QWORD *)a4 + 10);
      if (*(_QWORD *)(v26 + 192) <= v24)
        goto LABEL_142;
      v27 = (_QWORD *)(*(_QWORD *)(v26 + 200) + v23);
      v28 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(*((_QWORD *)a3 + 10) + 208, v27);
      if (v28)
        break;
      v31 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(*((_QWORD *)a2 + 10) + 208, v27);
      if (v31)
      {
        v29 = *v31;
        if (*((_QWORD *)a2 + 3) <= (unint64_t)*v31)
          goto LABEL_170;
        v30 = a2;
        if (*((_QWORD *)a4 + 3) <= v24)
          goto LABEL_171;
        goto LABEL_33;
      }
LABEL_34:
      ++v24;
      v23 += 16;
      v25 += 48;
      if (v7 == v24)
        goto LABEL_35;
    }
    v29 = *v28;
    if (*((_QWORD *)a3 + 3) <= (unint64_t)*v28)
      goto LABEL_149;
    v30 = a3;
    if (*((_QWORD *)a4 + 3) <= v24)
      goto LABEL_150;
LABEL_33:
    result = *(__n128 *)(*((_QWORD *)v30 + 4) + 48 * v29 + 16);
    *(__n128 *)(*((_QWORD *)a4 + 4) + v25) = result;
    goto LABEL_34;
  }
LABEL_35:
  if (*((_BYTE *)this + 114) && v7)
  {
    v32 = 0;
    v33 = 0;
    for (k = 32; ; k += 48)
    {
      v35 = *((_QWORD *)a4 + 10);
      if (*(_QWORD *)(v35 + 192) <= v33)
        goto LABEL_144;
      v36 = (_QWORD *)(*(_QWORD *)(v35 + 200) + v32);
      v37 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(*((_QWORD *)a3 + 10) + 208, v36);
      if (v37)
        break;
      v40 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(*((_QWORD *)a2 + 10) + 208, v36);
      if (v40)
      {
        v38 = *v40;
        if (*((_QWORD *)a2 + 3) <= (unint64_t)*v40)
          goto LABEL_172;
        v39 = a2;
        if (*((_QWORD *)a4 + 3) <= v33)
          goto LABEL_173;
        goto LABEL_46;
      }
LABEL_47:
      ++v33;
      v32 += 16;
      if (v7 == v33)
        return result;
    }
    v38 = *v37;
    if (*((_QWORD *)a3 + 3) <= (unint64_t)*v37)
      goto LABEL_153;
    v39 = a3;
    if (*((_QWORD *)a4 + 3) <= v33)
      goto LABEL_154;
LABEL_46:
    result = *(__n128 *)(*((_QWORD *)v39 + 4) + 48 * v38 + 32);
    *(__n128 *)(*((_QWORD *)a4 + 4) + k) = result;
    goto LABEL_47;
  }
  return result;
}

uint64_t re::SampledAnimation<float>::~SampledAnimation(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)a1 = off_24ED21D48;
  v2 = *(_QWORD *)(a1 + 88);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 96))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 104));
      *(_QWORD *)(a1 + 96) = 0;
      *(_QWORD *)(a1 + 104) = 0;
    }
    *(_QWORD *)(a1 + 88) = 0;
  }
  *(_QWORD *)a1 = off_24ED1F350;
  v3 = *(_QWORD *)(a1 + 40);
  if (v3)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 56));
    *(_OWORD *)(a1 + 40) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  return a1;
}

void re::SampledAnimation<float>::~SampledAnimation(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)a1 = off_24ED21D48;
  v2 = *(_QWORD *)(a1 + 88);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 96))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 104));
      *(_QWORD *)(a1 + 96) = 0;
      *(_QWORD *)(a1 + 104) = 0;
    }
    *(_QWORD *)(a1 + 88) = 0;
  }
  *(_QWORD *)a1 = off_24ED1F350;
  v3 = *(_QWORD *)(a1 + 40);
  if (v3)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 56));
    *(_OWORD *)(a1 + 40) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  JUMPOUT(0x2276933B8);
}

uint64_t re::SampledAnimation<double>::~SampledAnimation(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)a1 = off_24ED21DD0;
  v2 = *(_QWORD *)(a1 + 88);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 96))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 104));
      *(_QWORD *)(a1 + 96) = 0;
      *(_QWORD *)(a1 + 104) = 0;
    }
    *(_QWORD *)(a1 + 88) = 0;
  }
  *(_QWORD *)a1 = off_24ED1F350;
  v3 = *(_QWORD *)(a1 + 40);
  if (v3)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 56));
    *(_OWORD *)(a1 + 40) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  return a1;
}

void re::SampledAnimation<double>::~SampledAnimation(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)a1 = off_24ED21DD0;
  v2 = *(_QWORD *)(a1 + 88);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 96))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 104));
      *(_QWORD *)(a1 + 96) = 0;
      *(_QWORD *)(a1 + 104) = 0;
    }
    *(_QWORD *)(a1 + 88) = 0;
  }
  *(_QWORD *)a1 = off_24ED1F350;
  v3 = *(_QWORD *)(a1 + 40);
  if (v3)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 56));
    *(_OWORD *)(a1 + 40) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  JUMPOUT(0x2276933B8);
}

uint64_t re::AnimationImpl<double>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _QWORD *a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)a1 + 112))(a1, a2, a3, a4, *a5);
}

uint64_t re::SampledAnimation<re::Vector2<float>>::~SampledAnimation(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)a1 = off_24ED21E58;
  v2 = *(_QWORD *)(a1 + 88);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 96))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 104));
      *(_QWORD *)(a1 + 96) = 0;
      *(_QWORD *)(a1 + 104) = 0;
    }
    *(_QWORD *)(a1 + 88) = 0;
  }
  *(_QWORD *)a1 = off_24ED1F350;
  v3 = *(_QWORD *)(a1 + 40);
  if (v3)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 56));
    *(_OWORD *)(a1 + 40) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  return a1;
}

void re::SampledAnimation<re::Vector2<float>>::~SampledAnimation(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)a1 = off_24ED21E58;
  v2 = *(_QWORD *)(a1 + 88);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 96))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 104));
      *(_QWORD *)(a1 + 96) = 0;
      *(_QWORD *)(a1 + 104) = 0;
    }
    *(_QWORD *)(a1 + 88) = 0;
  }
  *(_QWORD *)a1 = off_24ED1F350;
  v3 = *(_QWORD *)(a1 + 40);
  if (v3)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 56));
    *(_OWORD *)(a1 + 40) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  JUMPOUT(0x2276933B8);
}

uint64_t re::AnimationImpl<re::Vector2<float>>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _QWORD *a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)a1 + 112))(a1, a2, a3, a4, *a5);
}

uint64_t re::SampledAnimation<re::Vector3<float>>::~SampledAnimation(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)a1 = off_24ED21EE0;
  v2 = *(_QWORD *)(a1 + 88);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 96))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 104));
      *(_QWORD *)(a1 + 96) = 0;
      *(_QWORD *)(a1 + 104) = 0;
    }
    *(_QWORD *)(a1 + 88) = 0;
  }
  *(_QWORD *)a1 = off_24ED1F350;
  v3 = *(_QWORD *)(a1 + 40);
  if (v3)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 56));
    *(_OWORD *)(a1 + 40) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  return a1;
}

void re::SampledAnimation<re::Vector3<float>>::~SampledAnimation(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)a1 = off_24ED21EE0;
  v2 = *(_QWORD *)(a1 + 88);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 96))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 104));
      *(_QWORD *)(a1 + 96) = 0;
      *(_QWORD *)(a1 + 104) = 0;
    }
    *(_QWORD *)(a1 + 88) = 0;
  }
  *(_QWORD *)a1 = off_24ED1F350;
  v3 = *(_QWORD *)(a1 + 40);
  if (v3)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 56));
    *(_OWORD *)(a1 + 40) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  JUMPOUT(0x2276933B8);
}

uint64_t re::AnimationImpl<re::Vector3<float>>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _QWORD *a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)a1 + 112))(a1, a2, a3, a4, *a5);
}

uint64_t re::SampledAnimation<re::Vector4<float>>::~SampledAnimation(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)a1 = off_24ED21F68;
  v2 = *(_QWORD *)(a1 + 88);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 96))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 104));
      *(_QWORD *)(a1 + 96) = 0;
      *(_QWORD *)(a1 + 104) = 0;
    }
    *(_QWORD *)(a1 + 88) = 0;
  }
  *(_QWORD *)a1 = off_24ED1F350;
  v3 = *(_QWORD *)(a1 + 40);
  if (v3)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 56));
    *(_OWORD *)(a1 + 40) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  return a1;
}

void re::SampledAnimation<re::Vector4<float>>::~SampledAnimation(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)a1 = off_24ED21F68;
  v2 = *(_QWORD *)(a1 + 88);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 96))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 104));
      *(_QWORD *)(a1 + 96) = 0;
      *(_QWORD *)(a1 + 104) = 0;
    }
    *(_QWORD *)(a1 + 88) = 0;
  }
  *(_QWORD *)a1 = off_24ED1F350;
  v3 = *(_QWORD *)(a1 + 40);
  if (v3)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 56));
    *(_OWORD *)(a1 + 40) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  JUMPOUT(0x2276933B8);
}

uint64_t re::AnimationImpl<re::Vector4<float>>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _QWORD *a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)a1 + 112))(a1, a2, a3, a4, *a5);
}

uint64_t re::SampledAnimation<re::Quaternion<float>>::~SampledAnimation(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)a1 = off_24ED21FF0;
  v2 = *(_QWORD *)(a1 + 88);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 96))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 104));
      *(_QWORD *)(a1 + 96) = 0;
      *(_QWORD *)(a1 + 104) = 0;
    }
    *(_QWORD *)(a1 + 88) = 0;
  }
  *(_QWORD *)a1 = off_24ED1F350;
  v3 = *(_QWORD *)(a1 + 40);
  if (v3)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 56));
    *(_OWORD *)(a1 + 40) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  return a1;
}

void re::SampledAnimation<re::Quaternion<float>>::~SampledAnimation(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)a1 = off_24ED21FF0;
  v2 = *(_QWORD *)(a1 + 88);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 96))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 104));
      *(_QWORD *)(a1 + 96) = 0;
      *(_QWORD *)(a1 + 104) = 0;
    }
    *(_QWORD *)(a1 + 88) = 0;
  }
  *(_QWORD *)a1 = off_24ED1F350;
  v3 = *(_QWORD *)(a1 + 40);
  if (v3)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 56));
    *(_OWORD *)(a1 + 40) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  JUMPOUT(0x2276933B8);
}

uint64_t re::AnimationImpl<re::Quaternion<float>>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _QWORD *a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)a1 + 112))(a1, a2, a3, a4, *a5);
}

uint64_t re::SampledAnimation<re::GenericSRT<float>>::~SampledAnimation(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)a1 = off_24ED22078;
  v2 = *(_QWORD *)(a1 + 88);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 96))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 104));
      *(_QWORD *)(a1 + 96) = 0;
      *(_QWORD *)(a1 + 104) = 0;
    }
    *(_QWORD *)(a1 + 88) = 0;
  }
  *(_QWORD *)a1 = off_24ED1F350;
  v3 = *(_QWORD *)(a1 + 40);
  if (v3)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 56));
    *(_OWORD *)(a1 + 40) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  return a1;
}

void re::SampledAnimation<re::GenericSRT<float>>::~SampledAnimation(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)a1 = off_24ED22078;
  v2 = *(_QWORD *)(a1 + 88);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 96))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 104));
      *(_QWORD *)(a1 + 96) = 0;
      *(_QWORD *)(a1 + 104) = 0;
    }
    *(_QWORD *)(a1 + 88) = 0;
  }
  *(_QWORD *)a1 = off_24ED1F350;
  v3 = *(_QWORD *)(a1 + 40);
  if (v3)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 56));
    *(_OWORD *)(a1 + 40) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  JUMPOUT(0x2276933B8);
}

uint64_t re::AnimationImpl<re::GenericSRT<float>>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _QWORD *a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)a1 + 112))(a1, a2, a3, a4, *a5);
}

uint64_t re::SampledAnimation<re::SkeletalPose>::~SampledAnimation(uint64_t a1)
{
  uint64_t v2;

  *(_QWORD *)a1 = off_24ED22100;
  re::FixedArray<re::SkeletalPose>::deinit((_QWORD *)(a1 + 88));
  *(_QWORD *)a1 = off_24ED1F350;
  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 56));
    *(_OWORD *)(a1 + 40) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  return a1;
}

void re::SampledAnimation<re::SkeletalPose>::~SampledAnimation(uint64_t a1)
{
  uint64_t v2;

  *(_QWORD *)a1 = off_24ED22100;
  re::FixedArray<re::SkeletalPose>::deinit((_QWORD *)(a1 + 88));
  *(_QWORD *)a1 = off_24ED1F350;
  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 56));
    *(_OWORD *)(a1 + 40) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  JUMPOUT(0x2276933B8);
}

uint64_t re::AnimationImpl<re::SkeletalPose>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _QWORD *a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)a1 + 112))(a1, a2, a3, a4, *a5);
}

void re::SkeletalPoseSampledAnimation::~SkeletalPoseSampledAnimation(re::SkeletalPoseSampledAnimation *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_24ED22100;
  re::FixedArray<re::SkeletalPose>::deinit((_QWORD *)this + 11);
  *(_QWORD *)this = off_24ED1F350;
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    if ((*((_BYTE *)this + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *((_QWORD *)this + 7));
    *(_OWORD *)((char *)this + 40) = 0u;
    *(_OWORD *)((char *)this + 56) = 0u;
  }
  re::StringID::destroyString((re::SkeletalPoseSampledAnimation *)((char *)this + 24));
}

{
  uint64_t v2;

  *(_QWORD *)this = off_24ED22100;
  re::FixedArray<re::SkeletalPose>::deinit((_QWORD *)this + 11);
  *(_QWORD *)this = off_24ED1F350;
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    if ((*((_BYTE *)this + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *((_QWORD *)this + 7));
    *(_OWORD *)((char *)this + 40) = 0u;
    *(_OWORD *)((char *)this + 56) = 0u;
  }
  re::StringID::destroyString((re::SkeletalPoseSampledAnimation *)((char *)this + 24));
  JUMPOUT(0x2276933B8);
}

uint64_t re::SampledAnimation<re::BlendShapeWeights>::~SampledAnimation(uint64_t a1)
{
  uint64_t v2;

  *(_QWORD *)a1 = off_24ED22188;
  re::FixedArray<re::BlendShapeWeights>::deinit((_QWORD *)(a1 + 88));
  *(_QWORD *)a1 = off_24ED1F350;
  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 56));
    *(_OWORD *)(a1 + 40) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  return a1;
}

void re::SampledAnimation<re::BlendShapeWeights>::~SampledAnimation(uint64_t a1)
{
  uint64_t v2;

  *(_QWORD *)a1 = off_24ED22188;
  re::FixedArray<re::BlendShapeWeights>::deinit((_QWORD *)(a1 + 88));
  *(_QWORD *)a1 = off_24ED1F350;
  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 56));
    *(_OWORD *)(a1 + 40) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  JUMPOUT(0x2276933B8);
}

__objc2_class_ro *re::Animation<re::BlendShapeWeights>::animationValueType()
{
  unsigned __int8 v0;
  __objc2_class_ro **p_info;
  int v3;

  p_info = VideoSpillMapMetalSession.info;
  if ((v0 & 1) == 0)
  {
    p_info = (__objc2_class_ro **)(VideoSpillMapMetalSession + 32);
    if (v3)
    {
      re::introspect<re::BlendShapeWeights>(void)::info = re::introspect_BlendShapeWeights(0);
      p_info = (__objc2_class_ro **)(VideoSpillMapMetalSession + 32);
    }
  }
  return p_info[129];
}

float re::AnimationImpl<re::BlendShapeWeights>::timelineDesc@<S0>(_BYTE *a1@<X0>, uint64_t a2@<X8>)
{
  double v4;
  float result;

  v4 = (*(double (**)(_BYTE *))(*(_QWORD *)a1 + 40))(a1);
  *(_DWORD *)a2 = 0;
  result = v4;
  *(float *)(a2 + 4) = result;
  *(_QWORD *)(a2 + 8) = 1065353216;
  *(float *)(a2 + 16) = result;
  *(_DWORD *)(a2 + 20) = 0;
  *(_BYTE *)(a2 + 24) = 0;
  *(_BYTE *)(a2 + 25) = a1[16];
  return result;
}

double re::AnimationImpl<re::BlendShapeWeights>::makeCompositionChain(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  double result;

  v2 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 184, 8);
  result = 0.0;
  *(_OWORD *)(v2 + 8) = 0u;
  *(_OWORD *)(v2 + 24) = 0u;
  *(_DWORD *)(v2 + 40) = 0;
  *(_QWORD *)(v2 + 88) = 0;
  *(_QWORD *)(v2 + 96) = 0;
  *(_BYTE *)(v2 + 104) = 0;
  *(_OWORD *)(v2 + 48) = 0u;
  *(_OWORD *)(v2 + 64) = 0u;
  *(_DWORD *)(v2 + 80) = 0;
  *(_QWORD *)v2 = &off_24ED1EE70;
  *(_BYTE *)(v2 + 112) = 0;
  *(_OWORD *)(v2 + 152) = 0u;
  *(_OWORD *)(v2 + 168) = 0u;
  return result;
}

uint64_t re::AnimationImpl<re::BlendShapeWeights>::isValidBindPoint(int a1, re::BindPoint *this)
{
  unsigned __int8 v2;
  __objc2_class_ro **p_info;
  uint64_t result;
  int v5;
  re::BindPoint *v6;

  if (!*((_QWORD *)this + 3))
    return 0;
  p_info = VideoSpillMapMetalSession.info;
  if ((v2 & 1) == 0)
  {
    v6 = this;
    p_info = (__objc2_class_ro **)(VideoSpillMapMetalSession + 32);
    this = v6;
    if (v5)
    {
      re::introspect<re::BlendShapeWeights>(void)::info = re::introspect_BlendShapeWeights(0);
      p_info = (__objc2_class_ro **)(VideoSpillMapMetalSession + 32);
      this = v6;
    }
  }
  if (p_info[129] != *(__objc2_class_ro **)this)
    return 0;
  result = re::BindPoint::valueUntyped(this);
  if (result)
    return *(_QWORD *)(result + 24) != 0;
  return result;
}

uint64_t re::AnimationImpl<re::BlendShapeWeights>::evaluate(_DWORD *a1, _BYTE *a2, uint64_t a3, uint64_t *a4, uint64_t a5, uint64_t *a6)
{
  BOOL v12;
  uint64_t result;

  if (a3)
  {
    if (a2[16])
      v12 = *a2 == 2;
    else
      v12 = 1;
    if (!v12)
      return (*(uint64_t (**)(_DWORD *, _BYTE *, uint64_t, uint64_t *, uint64_t, uint64_t *))(*(_QWORD *)a1 + 104))(a1, a2, a3, a4, a5, a6);
    result = (uint64_t)re::AnimationValueTraits<re::BlendShapeWeights>::copy(a4, a6);
    if (a1[2] == 49)
      return (*(uint64_t (**)(_DWORD *, _BYTE *, uint64_t, uint64_t *, uint64_t, uint64_t *))(*(_QWORD *)a1 + 104))(a1, a2, a3, a4, a5, a6);
  }
  else
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::AnimationImpl<re::BlendShapeWeights>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _QWORD *a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)a1 + 112))(a1, a2, a3, a4, *a5);
}

_QWORD *re::FixedArray<re::SkeletalPose>::deinit(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  _QWORD *v3;
  re::SkeletalPose *v4;
  uint64_t v5;
  uint64_t v6;

  if (*result)
  {
    v1 = result;
    v3 = result + 1;
    v2 = result[1];
    if (v2)
    {
      v4 = (re::SkeletalPose *)result[2];
      v5 = 88 * v2;
      do
      {
        re::SkeletalPose::~SkeletalPose(v4);
        v4 = (re::SkeletalPose *)(v6 + 88);
        v5 -= 88;
      }
      while (v5);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v1 + 40))(*v1, v1[2]);
      *v3 = 0;
      v3[1] = 0;
    }
    *v1 = 0;
  }
  return result;
}

_QWORD *re::FixedArray<re::BlendShapeWeights>::deinit(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  _QWORD *v3;
  re::BlendShapeWeights *v4;
  uint64_t v5;
  uint64_t v6;

  if (*result)
  {
    v1 = result;
    v3 = result + 1;
    v2 = result[1];
    if (v2)
    {
      v4 = (re::BlendShapeWeights *)result[2];
      v5 = 32 * v2;
      do
      {
        re::BlendShapeWeights::~BlendShapeWeights(v4);
        v4 = (re::BlendShapeWeights *)(v6 + 32);
        v5 -= 32;
      }
      while (v5);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v1 + 40))(*v1, v1[2]);
      *v3 = 0;
      v3[1] = 0;
    }
    *v1 = 0;
  }
  return result;
}

uint64_t re::StateMachineParameterBinding::indexOf@<X0>(uint64_t result@<X0>, _QWORD *a2@<X1>, int a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v5;
  uint64_t v8;
  uint64_t v9;

  v5 = *(_QWORD *)(result + 16);
  if (v5)
  {
    v8 = 0;
    v9 = *(_QWORD *)(result + 32);
    while (1)
    {
      result = re::StringID::operator==((_QWORD *)v9, a2);
      if ((_DWORD)result)
      {
        if (*(unsigned __int8 *)(v9 + 16) == a3)
          break;
      }
      ++v8;
      v9 += 40;
      if (v5 == v8)
        goto LABEL_6;
    }
    *(_BYTE *)a4 = 1;
    *(_QWORD *)(a4 + 8) = v8;
  }
  else
  {
LABEL_6:
    *(_BYTE *)a4 = 0;
  }
  return result;
}

unint64_t *re::StateMachineParameterBinding::setBindTarget(re::StateMachineParameterBinding *this, unint64_t a2, const re::StringID *a3)
{
  unint64_t *result;

  if (*((_QWORD *)this + 2) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  result = re::StringID::operator=((unint64_t *)(*((_QWORD *)this + 4) + 40 * a2 + 24), (uint64_t *)a3);
  ++*((_DWORD *)this + 6);
  return result;
}

void re::StateMachineParameterBinding::add(_QWORD *a1, const StringID *a2, char a3, const StringID *a4)
{
  uint64_t v7[2];
  char v8;
  _BYTE v9[16];

  re::StringID::StringID((re::StringID *)v7, a2);
  v8 = a3;
  re::StringID::StringID((re::StringID *)v9, a4);
  re::DynamicArray<re::StateMachineParameterBindingItem>::add(a1, v7);
  re::StringID::destroyString((re::StringID *)v9);
  re::StringID::destroyString((re::StringID *)v7);
}

_QWORD *re::DynamicArray<re::StateMachineParameterBindingItem>::add(_QWORD *this, uint64_t *a2)
{
  _QWORD *v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v3 = this;
  v4 = this[2];
  if (v4 >= this[1])
  {
    this = re::DynamicArray<re::StateMachineParameterBindingItem>::growCapacity(this, v4 + 1);
    v4 = v3[2];
  }
  v5 = v3[4] + 40 * v4;
  v6 = *a2;
  *(_QWORD *)v5 = *(_QWORD *)v5 & 0xFFFFFFFFFFFFFFFELL | *a2 & 1;
  *(_QWORD *)v5 = *a2 & 0xFFFFFFFFFFFFFFFELL | v6 & 1;
  *(_QWORD *)(v5 + 8) = a2[1];
  *a2 = 0;
  a2[1] = (uint64_t)&str_110;
  *(_BYTE *)(v5 + 16) = *((_BYTE *)a2 + 16);
  v7 = a2[3];
  *(_QWORD *)(v5 + 24) = *(_QWORD *)(v5 + 24) & 0xFFFFFFFFFFFFFFFELL | v7 & 1;
  *(_QWORD *)(v5 + 24) = a2[3] & 0xFFFFFFFFFFFFFFFELL | v7 & 1;
  *(_QWORD *)(v5 + 32) = a2[4];
  a2[3] = 0;
  a2[4] = (uint64_t)&str_110;
  ++v3[2];
  ++*((_DWORD *)v3 + 6);
  return this;
}

void re::DynamicArray<re::StateMachineParameterBindingItem>::removeAt(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  re::StringID *v16;
  _OWORD v17[5];
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 16);
  if (v2 <= a2)
  {
    memset(v17, 0, sizeof(v17));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (v2 - 1 > a2)
  {
    v4 = *(_QWORD *)(a1 + 32);
    v5 = v4 + 40 * v2;
    v6 = v4 + 40 * a2;
    v7 = *(_QWORD *)(v5 - 40);
    v8 = *(_QWORD *)(v5 - 32);
    *(_QWORD *)(v5 - 40) = 0;
    *(_QWORD *)(v5 - 32) = &str_110;
    v9 = *(_QWORD *)(v6 + 8);
    v10 = v7 & 0xFFFFFFFFFFFFFFFELL | *(_QWORD *)v6 & 1;
    *(_QWORD *)(v6 + 8) = v8;
    *(_QWORD *)&v17[0] = v10;
    *((_QWORD *)&v17[0] + 1) = v9;
    *(_QWORD *)v6 = v7;
    re::StringID::destroyString((re::StringID *)v17);
    *(_BYTE *)(v6 + 16) = *(_BYTE *)(v5 - 24);
    v11 = *(_QWORD *)(v5 - 16);
    v12 = *(_QWORD *)(v5 - 8);
    *(_QWORD *)(v5 - 16) = 0;
    *(_QWORD *)(v5 - 8) = &str_110;
    v13 = *(_QWORD *)(v6 + 32);
    v14 = v11 & 0xFFFFFFFFFFFFFFFELL | *(_QWORD *)(v6 + 24) & 1;
    *(_QWORD *)(v6 + 32) = v12;
    *(_QWORD *)&v17[0] = v14;
    *((_QWORD *)&v17[0] + 1) = v13;
    *(_QWORD *)(v6 + 24) = v11;
    re::StringID::destroyString((re::StringID *)v17);
    v2 = *(_QWORD *)(a1 + 16);
  }
  v15 = *(_QWORD *)(a1 + 32) + 40 * v2;
  v16 = (re::StringID *)(v15 - 40);
  re::StringID::destroyString((re::StringID *)(v15 - 16));
  re::StringID::destroyString(v16);
  --*(_QWORD *)(a1 + 16);
  ++*(_DWORD *)(a1 + 24);
}

void re::internal::defaultConstruct<re::StateMachineParameterBindingItem>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = &str_110;
  *(_BYTE *)(a3 + 16) = 0;
  *(_QWORD *)(a3 + 24) = 0;
  *(_QWORD *)(a3 + 32) = &str_110;
}

void re::internal::defaultDestruct<re::StateMachineParameterBindingItem>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::StringID::destroyString((re::StringID *)(a3 + 24));
  re::StringID::destroyString((re::StringID *)a3);
}

uint64_t re::internal::defaultConstructV2<re::StateMachineParameterBindingItem>(uint64_t result)
{
  *(_QWORD *)result = 0;
  *(_QWORD *)(result + 8) = &str_110;
  *(_BYTE *)(result + 16) = 0;
  *(_QWORD *)(result + 24) = 0;
  *(_QWORD *)(result + 32) = &str_110;
  return result;
}

void re::internal::defaultDestructV2<re::StateMachineParameterBindingItem>(uint64_t a1)
{
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  re::StringID::destroyString((re::StringID *)a1);
}

uint64_t *re::allocInfo_StateMachineParameterBinding(re *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  v1 = atomic_load((unsigned __int8 *)&qword_2540F8DC8);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_2540F8DC8))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540F8F20, 0);
    *(_QWORD *)(v3 + 22) = 0;
    qword_2540F8F30 = 0;
    qword_2540F8F40 = 0;
    qword_2540F8F48 = 0xFFFFFFFFLL;
    qword_2540F8F20 = (uint64_t)&off_24ED7DAA8;
    qword_2540F8F50 = (uint64_t)"StateMachineParameterBinding";
    dword_2540F8F58 = 0;
    xmmword_2540F8F60 = 0u;
    unk_2540F8F70 = 0u;
    xmmword_2540F8F80 = 0u;
    qword_2540F8F90 = 0;
    __cxa_guard_release(&qword_2540F8DC8);
  }
  return &qword_2540F8F20;
}

void re::initInfo_StateMachineParameterBinding(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  unsigned __int8 v7;
  uint64_t *v8;
  unsigned __int8 v9;
  const re::IntrospectionBase *v10;
  unsigned __int8 v11;
  int v12;
  re::IntrospectionRegistry *v13;
  const re::IntrospectionBase *v14;
  const char *v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  const re::IntrospectionBase *v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  re *v25;
  uint64_t *v26;
  const re::IntrospectionBase *v27;
  void *v28;
  uint64_t v29;
  const re::IntrospectionBase *v30;
  uint64_t *v31;
  unsigned __int8 v32;
  unsigned __int8 v33;
  uint64_t *v34;
  uint64_t v35;
  unsigned int *v36;
  _anonymous_namespace_ *v37;
  unint64_t v38;
  unint64_t i;
  uint64_t v40;
  char *v41;
  uint64_t v42;
  char v43;
  unsigned __int8 *v44;
  int v45;
  uint64_t v46;
  unint64_t j;
  uint64_t v48;
  char *v49;
  uint64_t v50;
  char v51;
  unsigned __int8 *v52;
  int v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t *v57;
  const re::IntrospectionBase *v58;
  void *v59;
  uint64_t v60;
  re *v61;
  uint64_t *v62;
  re *v63;
  uint64_t *v64;
  re *v65;
  uint64_t *v66;
  re *v67;
  uint64_t *v68;
  uint64_t v69;
  uint64_t v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  StringID v75;
  __int128 v76;
  __int128 v77;
  const char *v78;

  *(_QWORD *)&v77 = 0xFB22E2DC977D02A4;
  *((_QWORD *)&v77 + 1) = "StateMachineParameterBinding";
  re::StringID::destroyString((re::StringID *)&v77);
  *((_OWORD *)this + 2) = v72;
  v4 = atomic_load((unsigned __int8 *)&qword_2540F8DC0);
  if ((v4 & 1) != 0)
    goto LABEL_2;
  v5 = (re *)__cxa_guard_acquire(&qword_2540F8DC0);
  if (!(_DWORD)v5)
    goto LABEL_2;
  v6 = re::introspectionAllocator(v5);
  v7 = atomic_load((unsigned __int8 *)&qword_2540F8DD0);
  if ((v7 & 1) == 0 && __cxa_guard_acquire(&qword_2540F8DD0))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540F8E20, 0);
    *(uint64_t *)((char *)&qword_2540F8E30 + 6) = 0;
    qword_2540F8E30 = 0;
    *(_QWORD *)&xmmword_2540F8E40 = 0;
    *((_QWORD *)&xmmword_2540F8E40 + 1) = 0xFFFFFFFFLL;
    qword_2540F8E20 = (uint64_t)&off_24ED1FA08;
    qword_2540F8E58 = 0;
    re::SerializedReference<re::IntrospectionBase const*>::reset(&qword_2540F8E50);
    qword_2540F8E20 = (uint64_t)&off_24ED223B8;
    __cxa_guard_release(&qword_2540F8DD0);
  }
  if ((byte_2540F8D91 & 1) != 0)
    goto LABEL_20;
  v8 = (uint64_t *)qword_2540F8DB8;
  if (qword_2540F8DB8)
  {
LABEL_10:
    byte_2540F8D91 = 1;
    v12 = *((_DWORD *)v8 + 6);
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540F8E20, 0);
    qword_2540F8E30 = 0x2800000003;
    *(_DWORD *)algn_2540F8E38 = v12;
    *(_WORD *)&algn_2540F8E38[4] = 0;
    *(_QWORD *)&xmmword_2540F8E40 = 0;
    *((_QWORD *)&xmmword_2540F8E40 + 1) = 0xFFFFFFFFLL;
    qword_2540F8E50 = v8;
    qword_2540F8E58 = 0;
    qword_2540F8E20 = (uint64_t)&off_24ED223B8;
    re::IntrospectionRegistry::add(v13, v14);
    re::getPrettyTypeName((re *)&qword_2540F8E20, (const re::IntrospectionBase *)&v77);
    if ((BYTE8(v77) & 1) != 0)
      v15 = v78;
    else
      v15 = (char *)&v77 + 9;
    if ((_QWORD)v77 && (BYTE8(v77) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v77 + 40))();
    v74 = *((_OWORD *)v8 + 2);
    v16 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, &v75);
    if (v16)
    {
      v17 = *v16;
      *((_QWORD *)&v73 + 1) = v17;
    }
    else
    {
      v76 = v74;
      re::TypeBuilder::beginListType((uint64_t)&v77, (uint64_t *)&v75, 1, 0x28uLL, 8uLL, &v76);
      re::TypeBuilder::setConstructor((uint64_t)&v77, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::StateMachineParameterBindingItem>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
      re::TypeBuilder::setDestructor((uint64_t)&v77, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::StateMachineParameterBindingItem>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
      re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v77, 1);
      re::TypeBuilder::setListAccessors((uint64_t)&v77, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::StateMachineParameterBindingItem>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::StateMachineParameterBindingItem>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
      re::TypeBuilder::setListIndexer((uint64_t)&v77, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::StateMachineParameterBindingItem>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
      re::TypeBuilder::setListIterator((uint64_t)&v77, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::StateMachineParameterBindingItem>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::StateMachineParameterBindingItem>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::StateMachineParameterBindingItem>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
      re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v77, v18);
    }
    xmmword_2540F8E40 = v73;
    re::StringID::destroyString((re::StringID *)&v75);
    goto LABEL_20;
  }
  v9 = atomic_load((unsigned __int8 *)&qword_2540F8DB0);
  if ((v9 & 1) == 0 && __cxa_guard_acquire(&qword_2540F8DB0))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540F8EA8, 0);
    *(_QWORD *)(v24 + 22) = 0;
    qword_2540F8EB8 = 0;
    *(_QWORD *)&xmmword_2540F8EC8 = 0;
    *((_QWORD *)&xmmword_2540F8EC8 + 1) = 0xFFFFFFFFLL;
    qword_2540F8EA8 = (uint64_t)&off_24ED7DAA8;
    qword_2540F8ED8 = (uint64_t)"StateMachineParameterBindingItem";
    dword_2540F8EE0 = 0;
    *(_OWORD *)(v24 + 64) = 0u;
    *(_OWORD *)(v24 + 80) = 0u;
    *(_OWORD *)(v24 + 96) = 0u;
    qword_2540F8F18 = 0;
    __cxa_guard_release(&qword_2540F8DB0);
  }
  qword_2540F8DB8 = (uint64_t)&qword_2540F8EA8;
  *(_QWORD *)&v77 = 0x17066B9AB678EF0ALL;
  *((_QWORD *)&v77 + 1) = "StateMachineParameterBindingItem";
  re::StringID::destroyString((re::StringID *)&v77);
  xmmword_2540F8EC8 = v73;
  v11 = atomic_load((unsigned __int8 *)&qword_2540F8DA8);
  if ((v11 & 1) != 0 || (v25 = (re *)__cxa_guard_acquire(&qword_2540F8DA8), !(_DWORD)v25))
  {
LABEL_9:
    qword_2540F8EB8 = 0x2800000008;
    v8 = &qword_2540F8EA8;
    dword_2540F8EC0 = 8;
    word_2540F8EC4 = 0;
    dword_2540F8EE0 = 3;
    qword_2540F8EE8 = (uint64_t)&qword_2540F8DE8;
    unk_2540F8EF0 = re::internal::defaultConstruct<re::StateMachineParameterBindingItem>;
    qword_2540F8EF8 = (uint64_t)re::internal::defaultDestruct<re::StateMachineParameterBindingItem>;
    unk_2540F8F00 = 0;
    qword_2540F8F08 = 0;
    unk_2540F8F10 = re::internal::defaultConstructV2<re::StateMachineParameterBindingItem>;
    qword_2540F8F18 = (uint64_t)re::internal::defaultDestructV2<re::StateMachineParameterBindingItem>;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_2540F8EA8, v10);
    v77 = v73;
    if ((byte_2540F8D91 & 1) == 0)
      goto LABEL_10;
LABEL_20:
    v19 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
    *(_DWORD *)v19 = 1;
    *(_QWORD *)(v19 + 8) = "m_bindings";
    *(_QWORD *)(v19 + 16) = &qword_2540F8E20;
    *(_QWORD *)(v19 + 24) = 0;
    *(_QWORD *)(v19 + 32) = 1;
    *(_DWORD *)(v19 + 40) = 0;
    *(_QWORD *)(v19 + 48) = 0;
    *(_QWORD *)(v19 + 56) = 0;
    *(_DWORD *)(v19 + 64) = 0;
    qword_2540F8DD8 = v19;
    v20 = re::introspectionAllocator((re *)v19);
    v22 = re::introspect_uint32_t((re *)1, v21);
    v23 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v20 + 32))(v20, 72, 8);
    *(_DWORD *)v23 = 1;
    *(_QWORD *)(v23 + 8) = "m_lastArrayVersion";
    *(_QWORD *)(v23 + 16) = v22;
    *(_QWORD *)(v23 + 24) = 0;
    *(_QWORD *)(v23 + 32) = 0x2800000002;
    *(_DWORD *)(v23 + 40) = 0;
    *(_QWORD *)(v23 + 48) = 0;
    *(_QWORD *)(v23 + 56) = 0;
    *(_DWORD *)(v23 + 64) = 0;
    qword_2540F8DE0 = v23;
    __cxa_guard_release(&qword_2540F8DC0);
LABEL_2:
    *((_QWORD *)this + 2) = 0x3000000008;
    *((_DWORD *)this + 6) = 8;
    *((_WORD *)this + 14) = 0;
    *((_DWORD *)this + 14) = 2;
    *((_QWORD *)this + 8) = &qword_2540F8DD8;
    *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::StateMachineParameterBinding>;
    *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::StateMachineParameterBinding>;
    *((_QWORD *)this + 11) = 0;
    *((_QWORD *)this + 12) = 0;
    *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::StateMachineParameterBinding>;
    *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::StateMachineParameterBinding>;
    re::IntrospectionRegistry::add(this, v3);
    v71 = v72;
    return;
  }
  v26 = re::introspectionAllocator(v25);
  v28 = re::IntrospectionInfo<re::StringID>::get(1, v27);
  v29 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v26 + 32))(v26, 72, 8);
  *(_DWORD *)v29 = 1;
  *(_QWORD *)(v29 + 8) = "m_name";
  *(_QWORD *)(v29 + 16) = v28;
  *(_QWORD *)(v29 + 24) = 0;
  *(_QWORD *)(v29 + 32) = 1;
  *(_DWORD *)(v29 + 40) = 0;
  *(_QWORD *)(v29 + 48) = 0;
  *(_QWORD *)(v29 + 56) = 0;
  *(_DWORD *)(v29 + 64) = 0;
  qword_2540F8DE8 = v29;
  v31 = re::introspectionAllocator((re *)v29);
  v32 = atomic_load((unsigned __int8 *)&qword_2540F8D98);
  if ((v32 & 1) == 0)
  {
    v61 = (re *)__cxa_guard_acquire(&qword_2540F8D98);
    if ((_DWORD)v61)
    {
      v62 = re::introspectionAllocator(v61);
      v63 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v62 + 32))(v62, 24, 8);
      *(_DWORD *)v63 = 1;
      *((_QWORD *)v63 + 1) = 0;
      *((_QWORD *)v63 + 2) = "Invalid";
      qword_2540F8E00 = (uint64_t)v63;
      v64 = re::introspectionAllocator(v63);
      v65 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v64 + 32))(v64, 24, 8);
      *(_DWORD *)v65 = 1;
      *((_QWORD *)v65 + 1) = 1;
      *((_QWORD *)v65 + 2) = "Int";
      qword_2540F8E08 = (uint64_t)v65;
      v66 = re::introspectionAllocator(v65);
      v67 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v66 + 32))(v66, 24, 8);
      *(_DWORD *)v67 = 1;
      *((_QWORD *)v67 + 1) = 2;
      *((_QWORD *)v67 + 2) = "Float";
      qword_2540F8E10 = (uint64_t)v67;
      v68 = re::introspectionAllocator(v67);
      v69 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v68 + 32))(v68, 24, 8);
      *(_DWORD *)v69 = 1;
      *(_QWORD *)(v69 + 8) = 3;
      *(_QWORD *)(v69 + 16) = "Bool";
      qword_2540F8E18 = v69;
      __cxa_guard_release(&qword_2540F8D98);
    }
  }
  v33 = atomic_load((unsigned __int8 *)&qword_2540F8DA0);
  if ((v33 & 1) == 0 && __cxa_guard_acquire(&qword_2540F8DA0))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_2540F8E60, "REStateMachineParameterType", 1, 1, 1, 1);
    qword_2540F8E60 = (uint64_t)&off_24ED7D9E8;
    qword_2540F8EA0 = (uint64_t)&introspect_REStateMachineParameterType(BOOL)::enumTable;
    dword_2540F8E70 = 9;
    __cxa_guard_release(&qword_2540F8DA0);
  }
  if ((_MergedGlobals_17 & 1) != 0)
  {
LABEL_55:
    v56 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v31 + 32))(v31, 72, 8);
    *(_DWORD *)v56 = 1;
    *(_QWORD *)(v56 + 8) = "m_type";
    *(_QWORD *)(v56 + 16) = &qword_2540F8E60;
    *(_QWORD *)(v56 + 24) = 0;
    *(_QWORD *)(v56 + 32) = 0x1000000002;
    *(_DWORD *)(v56 + 40) = 0;
    *(_QWORD *)(v56 + 48) = 0;
    *(_QWORD *)(v56 + 56) = 0;
    *(_DWORD *)(v56 + 64) = 0;
    qword_2540F8DF0 = v56;
    v57 = re::introspectionAllocator((re *)v56);
    v59 = re::IntrospectionInfo<re::StringID>::get(1, v58);
    v60 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v57 + 32))(v57, 72, 8);
    *(_DWORD *)v60 = 1;
    *(_QWORD *)(v60 + 8) = "m_bindTarget";
    *(_QWORD *)(v60 + 16) = v59;
    *(_QWORD *)(v60 + 24) = 0;
    *(_QWORD *)(v60 + 32) = 0x1800000003;
    *(_DWORD *)(v60 + 40) = 0;
    *(_QWORD *)(v60 + 48) = 0;
    *(_QWORD *)(v60 + 56) = 0;
    *(_DWORD *)(v60 + 64) = 0;
    qword_2540F8DF8 = v60;
    __cxa_guard_release(&qword_2540F8DA8);
    goto LABEL_9;
  }
  _MergedGlobals_17 = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_2540F8E60, v30);
  *(_QWORD *)&v74 = 0x3F37F4A355D87974;
  *((_QWORD *)&v74 + 1) = "REStateMachineParameterType";
  *(_QWORD *)&v77 = 0x31CD534126;
  *((_QWORD *)&v77 + 1) = "uint8_t";
  v34 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, &v77);
  if (v34)
  {
    v35 = *v34;
    re::StringID::destroyString((re::StringID *)&v77);
    v36 = (unsigned int *)qword_2540F8EA0;
    *((_QWORD *)&v76 + 1) = v35;
    re::TypeBuilder::beginEnumType((uint64_t)&v77, (uint64_t *)&v74, 1, 1, (uint64_t)&v76);
    v38 = *v36;
    if ((_DWORD)v38)
    {
      for (i = 0; i < v38; ++i)
      {
        v40 = *(_QWORD *)(*((_QWORD *)v36 + 1) + 8 * i);
        if (*(_DWORD *)v40 == 1)
        {
          v41 = *(char **)(v40 + 16);
          if (v41)
          {
            v42 = *v41;
            if (*v41)
            {
              v43 = v41[1];
              if (v43)
              {
                v44 = (unsigned __int8 *)(v41 + 2);
                do
                {
                  v42 = 31 * v42 + v43;
                  v45 = *v44++;
                  v43 = v45;
                }
                while (v45);
              }
            }
          }
          else
          {
            v42 = 0;
          }
          v46 = *(_QWORD *)(v40 + 8);
          *(_QWORD *)&v75.var0 = 2 * v42;
          v75.var1 = v41;
          re::TypeBuilder::addEnumConstant((re::TypeBuilder *)&v77, v46, &v75);
          re::StringID::destroyString((re::StringID *)&v75);
          v38 = *v36;
        }
      }
      if (v38)
      {
        for (j = 0; j < v38; ++j)
        {
          v48 = *(_QWORD *)(*((_QWORD *)v36 + 1) + 8 * j);
          if (*(_DWORD *)v48 == 2)
          {
            v49 = *(char **)(v48 + 16);
            if (v49)
            {
              v50 = *v49;
              if (*v49)
              {
                v51 = v49[1];
                if (v51)
                {
                  v52 = (unsigned __int8 *)(v49 + 2);
                  do
                  {
                    v50 = 31 * v50 + v51;
                    v53 = *v52++;
                    v51 = v53;
                  }
                  while (v53);
                }
              }
            }
            else
            {
              v50 = 0;
            }
            v54 = *(_QWORD *)(v48 + 8);
            *(_QWORD *)&v75.var0 = 2 * v50;
            v75.var1 = v49;
            re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)&v77, v54, &v75);
            re::StringID::destroyString((re::StringID *)&v75);
            v38 = *v36;
          }
        }
      }
    }
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v77, v55);
    xmmword_2540F8E80 = (__int128)v75;
    re::StringID::destroyString((re::StringID *)&v74);
    goto LABEL_55;
  }
  re::StringID::destroyString((re::StringID *)&v77);
  re::internal::assertLog((re::internal *)5, v70, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "REStateMachineParameterType");
  _os_crash();
  __break(1u);
}

void re::internal::defaultConstruct<re::StateMachineParameterBinding>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(a3 + 32) = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  *(_QWORD *)a3 = 0;
  *(_DWORD *)(a3 + 24) = 0;
  *(_DWORD *)(a3 + 40) = 0;
}

uint64_t re::internal::defaultDestruct<re::StateMachineParameterBinding>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<re::RigGraphNodeInputParameter>::deinit(a3);
  return re::DynamicArray<re::RigGraphNodeInputParameter>::deinit(a3);
}

uint64_t re::internal::defaultConstructV2<re::StateMachineParameterBinding>(uint64_t result)
{
  *(_QWORD *)(result + 32) = 0;
  *(_QWORD *)(result + 8) = 0;
  *(_QWORD *)(result + 16) = 0;
  *(_QWORD *)result = 0;
  *(_DWORD *)(result + 24) = 0;
  *(_DWORD *)(result + 40) = 0;
  return result;
}

uint64_t re::internal::defaultDestructV2<re::StateMachineParameterBinding>(uint64_t a1)
{
  re::DynamicArray<re::RigGraphNodeInputParameter>::deinit(a1);
  return re::DynamicArray<re::RigGraphNodeInputParameter>::deinit(a1);
}

uint64_t re::introspect_StateMachineParameterBinding(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"StateMachineParameterBinding", (uint64_t (*)(re::internal *))re::allocInfo_StateMachineParameterBinding, (re::IntrospectionBase *(*)(void))re::initInfo_StateMachineParameterBinding, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::StateMachineParameterBinding>, this);
}

_QWORD *re::DynamicArray<re::StateMachineParameterBindingItem>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<re::StateMachineParameterBindingItem>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::StateMachineParameterBindingItem>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

_QWORD *re::DynamicArray<re::StateMachineParameterBindingItem>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  unint64_t *v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t *v10;
  unint64_t *v11;
  uint64_t v12;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::StateMachineParameterBindingItem>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x28uLL))
        {
          v2 = 40 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 40 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_16;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 40, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = (uint64_t *)v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = &v8[5 * v9];
        v11 = v7;
        do
        {
          v12 = *v8;
          *v11 = *v11 & 0xFFFFFFFFFFFFFFFELL | *v8 & 1;
          *v11 = *v8 & 0xFFFFFFFFFFFFFFFELL | v12 & 1;
          v11[1] = v8[1];
          *v8 = 0;
          v8[1] = (uint64_t)&str_110;
          *((_BYTE *)v11 + 16) = *((_BYTE *)v8 + 16);
          LOBYTE(v12) = v8[3];
          v11[3] = v11[3] & 0xFFFFFFFFFFFFFFFELL | v8[3] & 1;
          v11[3] = v8[3] & 0xFFFFFFFFFFFFFFFELL | v12 & 1;
          v11[4] = v8[4];
          v8[4] = (uint64_t)&str_110;
          v8[3] = 0;
          re::StringID::destroyString((re::StringID *)(v8 + 3));
          re::StringID::destroyString((re::StringID *)v8);
          v8 += 5;
          v11 += 5;
        }
        while (v8 != v10);
        v8 = (uint64_t *)v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t *))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::StateMachineParameterBindingItem>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::StateMachineParameterBindingItem>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x2276933B8);
}

void re::IntrospectionDynamicArray<re::StateMachineParameterBindingItem>::construct(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::StateMachineParameterBindingItem>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<re::RigGraphNodeInputParameter>::deinit(a2);
}

_QWORD *re::IntrospectionDynamicArray<re::StateMachineParameterBindingItem>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  re::DynamicArray<re::RigGraphNodeInputParameter>::deinit(a2);
  *(_QWORD *)a2 = a3;
  result = re::DynamicArray<re::StateMachineParameterBindingItem>::setCapacity((_QWORD *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

void re::IntrospectionDynamicArray<re::StateMachineParameterBindingItem>::resize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  unint64_t v10;
  unint64_t i;

  if (!*(_QWORD *)a4)
  {
    *(_QWORD *)a4 = a2;
    re::DynamicArray<re::StateMachineParameterBindingItem>::setCapacity((_QWORD *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  v10 = *(_QWORD *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
      re::DynamicArray<re::StateMachineParameterBindingItem>::resize(a4, a5);
  }
  else
  {
    re::DynamicArray<re::StateMachineParameterBindingItem>::setCapacity((_QWORD *)a4, a5);
    for (i = a5 - *(_QWORD *)(a4 + 16); i; --i)
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, a3, a4);
  }
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::StateMachineParameterBindingItem>::addElement(uint64_t a1, re *a2, int a3, _anonymous_namespace_ *this)
{
  re::IntrospectionBase *v8;
  uint64_t v10[2];
  char v11;
  _QWORD v12[2];

  v10[0] = 0;
  v10[1] = (uint64_t)&str_110;
  v11 = 0;
  v12[0] = 0;
  v12[1] = &str_110;
  re::DynamicArray<re::StateMachineParameterBindingItem>::add(this, v10);
  re::StringID::destroyString((re::StringID *)v12);
  re::StringID::destroyString((re::StringID *)v10);
  v8 = (re::IntrospectionBase *)(*((_QWORD *)this + 4) + 40 * *((_QWORD *)this + 2) - 40);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v8);
  return v8;
}

uint64_t re::IntrospectionDynamicArray<re::StateMachineParameterBindingItem>::size(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::StateMachineParameterBindingItem>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 40 * a3;
}

{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 40 * a3;
}

void re::DynamicArray<re::StateMachineParameterBindingItem>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;

  v4 = *(_QWORD *)(a1 + 16);
  if (v4 >= a2)
  {
    if (v4 <= a2)
      return;
    v8 = 40 * a2;
    v9 = a2;
    do
    {
      v10 = *(_QWORD *)(a1 + 32) + v8;
      re::StringID::destroyString((re::StringID *)(v10 + 24));
      re::StringID::destroyString((re::StringID *)v10);
      ++v9;
      v8 += 40;
    }
    while (v9 < *(_QWORD *)(a1 + 16));
  }
  else
  {
    if (*(_QWORD *)(a1 + 8) < a2)
    {
      re::DynamicArray<re::StateMachineParameterBindingItem>::setCapacity((_QWORD *)a1, a2);
      v4 = *(_QWORD *)(a1 + 16);
    }
    v5 = a2 - v4;
    if (a2 > v4)
    {
      v6 = 40 * v4;
      do
      {
        v7 = *(_QWORD *)(a1 + 32) + v6;
        *(_QWORD *)v7 = 0;
        *(_QWORD *)(v7 + 8) = &str_110;
        *(_BYTE *)(v7 + 16) = 0;
        *(_QWORD *)(v7 + 24) = 0;
        *(_QWORD *)(v7 + 32) = &str_110;
        v6 += 40;
        --v5;
      }
      while (v5);
    }
  }
  *(_QWORD *)(a1 + 16) = a2;
  ++*(_DWORD *)(a1 + 24);
}

_QWORD *re::TypeBuilderHelper::registerDynamicArray<re::StateMachineParameterBindingItem>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)a1 = a3;
  result = re::DynamicArray<re::StateMachineParameterBindingItem>::setCapacity((_QWORD *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::StateMachineParameterBindingItem>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::StateMachineParameterBindingItem>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _anonymous_namespace_ *v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  _BYTE v15[32];
  _BYTE v16[8];
  uint64_t v17;

  if (*(re::Allocator **)a1 == a3)
  {
    v8 = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = 0;
    if (v8)
    {
      v9 = *(_QWORD *)(a1 + 32);
      v10 = 40 * v8;
      do
      {
        re::StringID::destroyString((re::StringID *)(v9 + 24));
        re::StringID::destroyString((re::StringID *)v9);
        v9 += 40;
        v10 -= 40;
      }
      while (v10);
    }
  }
  else
  {
    re::DynamicArray<re::RigGraphNodeInputParameter>::deinit(a1);
    *(_QWORD *)a1 = a3;
    re::DynamicArray<re::StateMachineParameterBindingItem>::setCapacity((_QWORD *)a1, a4);
  }
  ++*(_DWORD *)(a1 + 24);
  re::DynamicArray<re::StateMachineParameterBindingItem>::resize(a1, a4);
  {
    re::TypeRegistry::typeInfo(*(_QWORD **)a2, *(_QWORD *)(*(_QWORD *)(a2 + 16) + 72), v16);
    re::TypeInfo::TypeInfo((uint64_t)v15, (uint64_t)&v17);
    v12 = *(_QWORD *)(a1 + 16);
    if (v12)
    {
      v13 = *(char **)(a1 + 32);
      v14 = 40 * v12;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v15, v13, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v15, (void **)v13, a3, 0);
        v13 += 40;
        v14 -= 40;
      }
      while (v14);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::StateMachineParameterBindingItem>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(_QWORD *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a1 + 32) + 40 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::StateMachineParameterBindingItem>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 16, 8);
  *(_QWORD *)result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::StateMachineParameterBindingItem>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unint64_t v4;
  uint64_t result;

  v2 = *(_QWORD *)a1;
  if (a1[2] == *(_DWORD *)(*(_QWORD *)a1 + 24))
  {
    v3 = a1[3];
    v4 = *(_QWORD *)(v2 + 16);
    if (v3 < (int)v4)
      a1[3] = ++v3;
    if (v4 <= v3)
      return 0;
    else
      return *(_QWORD *)(v2 + 32) + 40 * v3;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::StateMachineParameterBindingItem>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 40))(a2, result);
  return result;
}

void re::validateRigDefinitionData(re *this@<X0>, re::Allocator *a2@<X1>, const re::RigDefinition *a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t m;
  _QWORD *v5;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  BOOL v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  BOOL v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  BOOL v31;
  _QWORD *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float v40;
  float32x4_t v41;
  float32x4_t v42;
  float v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  float32x4_t v47;
  uint64_t v48;
  uint64_t v49;
  BOOL v50;
  unint64_t *v51;
  uint64_t v52;
  unint64_t v53;
  unint64_t v54;
  uint64_t v55;
  _QWORD *v56;
  uint64_t v57;
  unint64_t v58;
  uint64_t v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  unint64_t v63;
  unint64_t v64;
  unint64_t v65;
  unint64_t v66;
  unint64_t v67;
  uint64_t *v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  uint64_t v72;
  _QWORD *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  unint64_t *v77;
  uint64_t v78;
  unint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  unint64_t v83;
  uint64_t v84;
  _QWORD *v85;
  uint64_t v86;
  unint64_t v87;
  uint64_t v88;
  char *v89;
  unint64_t v90;
  unsigned int ExpressionParameterType;
  unint64_t v92;
  unsigned int v93;
  unint64_t v94;
  unint64_t v95;
  float v96;
  float v97;
  uint64_t v98;
  _QWORD *v99;
  uint64_t v100;
  uint64_t v101;
  BOOL v102;
  uint64_t v103;
  BOOL v104;
  unint64_t *v105;
  unint64_t v106;
  uint64_t v107;
  uint64_t v108;
  unint64_t *v109;
  uint64_t v110;
  unint64_t *v111;
  uint64_t v112;
  unint64_t *v113;
  float *v114;
  uint64_t v115;
  float v116;
  float v117;
  float v118;
  unint64_t i;
  unint64_t *v120;
  unint64_t v121;
  uint64_t v122;
  unint64_t v123;
  unint64_t v124;
  _QWORD *v125;
  uint64_t v126;
  uint64_t v127;
  unint64_t *v128;
  unint64_t v129;
  uint64_t v130;
  uint64_t v131;
  unint64_t *v132;
  uint64_t v133;
  unint64_t *v134;
  unint64_t v135;
  unint64_t *v136;
  uint64_t v137;
  uint64_t v138;
  unint64_t v139;
  unint64_t v141;
  unint64_t v143;
  unint64_t v144;
  _QWORD *v145;
  unint64_t v146;
  _QWORD *v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  unint64_t *v153;
  uint64_t v154;
  unint64_t v155;
  unint64_t v156;
  unint64_t v157;
  unint64_t v158;
  unint64_t v159;
  unint64_t j;
  uint64_t v161;
  float32x4_t v162;
  float32x4_t v163;
  uint64_t v164;
  unint64_t v165;
  unint64_t k;
  uint64_t v167;
  int8x16_t v168;
  float v169;
  int8x16_t v170;
  float v171;
  float32x4_t v172;
  float32x4_t v173;
  unint64_t v174;
  uint64_t v175;
  unint64_t v176;
  unsigned __int8 *v177;
  unint64_t v178;
  uint64_t v179;
  _BYTE *v180;
  uint64_t v181;
  unint64_t v182;
  unint64_t v183;
  unint64_t v184;
  BOOL v185;
  uint64_t v186;
  uint64_t v187;
  unint64_t v188;
  uint64_t v189;
  unint64_t *v190;
  unint64_t v191;
  unint64_t v192;
  uint64_t v193;
  unint64_t n;
  unsigned __int8 *v195;
  uint64_t v196;
  uint64_t v197;
  _QWORD *v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  _QWORD *v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  _QWORD *v206;
  uint64_t v207;
  _QWORD *v208;
  uint64_t v209;
  _QWORD *v210;
  uint64_t v211;
  unsigned int *v212;
  char **v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  unint64_t TemporaryValueUsed;
  unsigned __int8 *v219;
  uint64_t v220;
  uint64_t v221;
  _BOOL4 isTemporaryValueUsed;
  unsigned __int8 v223;
  unint64_t v224;
  unint64_t v225;
  uint64_t v226;
  unint64_t v227;
  unint64_t ii;
  unsigned __int8 *v229;
  uint64_t v230;
  unint64_t v231;
  unint64_t v232;
  unint64_t v233;
  unint64_t v234;
  unint64_t jj;
  unsigned __int8 *v236;
  uint64_t v237;
  unint64_t v238;
  unint64_t v239;
  unint64_t v240;
  unint64_t v241;
  unint64_t v242;
  _QWORD *v243;
  _BYTE *v244;
  uint64_t v245;
  uint64_t v246;
  unint64_t v247;
  unint64_t v248;
  uint64_t v249;
  __int128 v250;
  __int128 v251;
  unint64_t v252;
  uint64_t v253;
  __int128 v254;
  uint64_t v255;
  uint64_t v256;
  int v257;
  uint64_t v258;
  uint64_t v259;
  uint64_t v260;
  __int128 v261;
  __int128 v262;
  __int128 v263;
  __int128 v264;
  __int128 v265;
  __int128 v266;
  __int128 v267;
  __int128 v268;
  __int128 v269;
  __int128 v270;
  __int128 v271;
  __int128 v272;
  _BYTE v273[38];
  uint64_t v274;

  v274 = *MEMORY[0x24BDAC8D0];
  v9 = *((_QWORD *)a2 + 2);
  if (v9)
  {
    v10 = 0;
    v11 = *((_QWORD *)a2 + 4);
    do
    {
      v12 = *(_QWORD *)(v11 + 88 * v10 + 24);
      if (!v12)
      {
        re::DynamicString::format(this, (re::Allocator *)"Rig Point Constraint %zu has no constraint nodes.", (re::DynamicString *)&v261, v10);
        goto LABEL_412;
      }
      v13 = *(_QWORD *)(v11 + 88 * v10 + 64);
      if (v13)
        v14 = v13 == v12;
      else
        v14 = 1;
      if (!v14)
      {
        re::DynamicString::format(this, (re::Allocator *)"Rig Point Constraint %zu has an invalid weight count: %zu", (re::DynamicString *)&v261, v10, v13);
        goto LABEL_412;
      }
      v15 = *(_QWORD **)(v11 + 88 * v10 + 40);
      v16 = 8 * v12;
      do
      {
        if (*v15 >= *((_QWORD *)a2 + 130))
        {
          re::DynamicString::format(this, (re::Allocator *)"Rig Point Constraint %zu has an invalid node: %zu.", (re::DynamicString *)&v261, v10, *v15);
          goto LABEL_412;
        }
        ++v15;
        v16 -= 8;
      }
      while (v16);
      ++v10;
    }
    while (v10 != v9);
  }
  v17 = *((_QWORD *)a2 + 7);
  if (v17)
  {
    v18 = 0;
    v19 = *((_QWORD *)a2 + 9);
    do
    {
      v20 = *(_QWORD *)(v19 + 88 * v18 + 24);
      if (!v20)
      {
        re::DynamicString::format(this, (re::Allocator *)"Rig Orient Constraint %zu has no constraint nodes.", (re::DynamicString *)&v261, v18);
        goto LABEL_412;
      }
      v21 = *(_QWORD *)(v19 + 88 * v18 + 64);
      if (v21)
        v22 = v21 == v20;
      else
        v22 = 1;
      if (!v22)
      {
        re::DynamicString::format(this, (re::Allocator *)"Rig Orient Constraint %zu has an invalid weight count: %zu", (re::DynamicString *)&v261, v18, v21);
        goto LABEL_412;
      }
      v23 = *(_QWORD **)(v19 + 88 * v18 + 40);
      v24 = 8 * v20;
      do
      {
        if (*v23 >= *((_QWORD *)a2 + 130))
        {
          re::DynamicString::format(this, (re::Allocator *)"Rig Orient Constraint %zu has an invalid node: %zu.", (re::DynamicString *)&v261, v18, *v23);
          goto LABEL_412;
        }
        ++v23;
        v24 -= 8;
      }
      while (v24);
      ++v18;
    }
    while (v18 != v17);
  }
  v25 = *((_QWORD *)a2 + 12);
  if (v25)
  {
    v26 = 0;
    v27 = *((_QWORD *)a2 + 14);
    do
    {
      v28 = v27 + 80 * v26;
      v29 = *(_QWORD *)(v28 + 16);
      if (!v29)
      {
        re::DynamicString::format(this, (re::Allocator *)"Rig Parent Constraint %zu has no constraint nodes.", (re::DynamicString *)&v261, v26);
        goto LABEL_412;
      }
      v30 = *(_QWORD *)(v27 + 80 * v26 + 56);
      if (v30)
        v31 = v30 == v29;
      else
        v31 = 1;
      if (!v31)
      {
        re::DynamicString::format(this, (re::Allocator *)"Rig Parent Constraint %zu has an invalid weight count: %zu", (re::DynamicString *)&v261, v26, v30);
        goto LABEL_412;
      }
      v32 = *(_QWORD **)(v28 + 32);
      v33 = 8 * v29;
      do
      {
        if (*v32 >= *((_QWORD *)a2 + 130))
        {
          re::DynamicString::format(this, (re::Allocator *)"Rig Parent Constraint %zu has an invalid node: %zu.", (re::DynamicString *)&v261, v26, *v32);
          goto LABEL_412;
        }
        ++v32;
        v33 -= 8;
      }
      while (v33);
      ++v26;
    }
    while (v26 != v25);
  }
  v34 = *((_QWORD *)a2 + 17);
  if (v34)
  {
    v35 = 0;
    v36 = *((_QWORD *)a2 + 19);
    v37 = *((_QWORD *)a2 + 130);
    do
    {
      v38 = *(float32x4_t *)(v36 + 144 * v35 + 16);
      v39 = vmulq_f32(v38, v38);
      v40 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v39, 2), vaddq_f32(v39, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v39.f32, 1))).f32[0];
      if (v40 != 1.0 && fabsf(v40 + -1.0) > 0.000001)
      {
        re::DynamicString::format(this, (re::Allocator *)"Rig Aim Constraint %zu has an invalid aim vector: (%f, %f %f).", (re::DynamicString *)&v261, v35, v38.f32[0], v38.f32[1], v38.f32[2]);
        goto LABEL_412;
      }
      v41 = *(float32x4_t *)(v36 + 144 * v35 + 32);
      v42 = vmulq_f32(v41, v41);
      v43 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v42, 2), vaddq_f32(v42, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v42.f32, 1))).f32[0];
      if (v43 != 1.0 && fabsf(v43 + -1.0) > 0.000001)
      {
        re::DynamicString::format(this, (re::Allocator *)"Rig Aim Constraint %zu has an invalid up vector: (%f, %f %f).", (re::DynamicString *)&v261, v35, v41.f32[0], v41.f32[1], v41.f32[2]);
        goto LABEL_412;
      }
      v44 = v36 + 144 * v35;
      v45 = *(unsigned __int8 *)(v44 + 4);
      v46 = *(unsigned __int8 *)(v44 + 3);
      if ((_DWORD)v45 == (_DWORD)v46)
      {
        v47 = vmulq_f32(v38, v41);
        if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v47, 2), vaddq_f32(v47, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v47.f32, 1))).f32[0]) >= 0.00001)
        {
          re::DynamicString::format(this, (re::Allocator *)"Rig aim constraint %zu must have perpendicular aim/up vectors.", (re::DynamicString *)&v261, v35);
          goto LABEL_412;
        }
      }
      if (v46 >= 2)
      {
        if ((_DWORD)v46 != 2)
        {
          re::DynamicString::format(this, (re::Allocator *)"Rig Aim Constraint %zu has an invalid forward axis type: %u.", (re::DynamicString *)&v261, v35, v46);
          goto LABEL_412;
        }
      }
      else
      {
        v48 = *(_QWORD *)(v36 + 144 * v35 + 64);
        if (!v48)
        {
          re::DynamicString::format(this, (re::Allocator *)"Rig Aim Constraint %zu has no forward nodes.", (re::DynamicString *)&v261, v35);
          goto LABEL_412;
        }
        v49 = *(_QWORD *)(v36 + 144 * v35 + 104);
        if (v49)
          v50 = v49 == v48;
        else
          v50 = 1;
        if (!v50)
        {
          re::DynamicString::format(this, (re::Allocator *)"Rig Aim Constraint %zu has an invalid weight count: %zu", (re::DynamicString *)&v261, v35, v49);
          goto LABEL_412;
        }
        v51 = *(unint64_t **)(v36 + 144 * v35 + 80);
        v52 = 8 * v48;
        do
        {
          if (*v51 >= v37)
          {
            re::DynamicString::format(this, (re::Allocator *)"Rig Aim Constraint %zu has an invalid forward node: %zu.", (re::DynamicString *)&v261, v35, *v51);
            goto LABEL_412;
          }
          ++v51;
          v52 -= 8;
        }
        while (v52);
      }
      if (v45 >= 2)
      {
        if ((_DWORD)v45 != 2)
        {
          re::DynamicString::format(this, (re::Allocator *)"Rig Aim Constraint %zu has an invalid up axis type: %u.", (re::DynamicString *)&v261, v35, v45);
          goto LABEL_412;
        }
      }
      else
      {
        v53 = *(_QWORD *)(v36 + 144 * v35 + 128);
        if (v53 >= v37)
        {
          re::DynamicString::format(this, (re::Allocator *)"Rig Aim Constraint %zu has an invalid up node: %zu.", (re::DynamicString *)&v261, v35, v53);
          goto LABEL_412;
        }
      }
      ++v35;
    }
    while (v35 != v34);
  }
  v54 = *((_QWORD *)a2 + 22);
  if (v54)
  {
    v55 = 0;
    v56 = (_QWORD *)(*((_QWORD *)a2 + 24) + 8);
    do
    {
      v57 = *((unsigned __int8 *)v56 - 8);
      if ((v57 - 1) >= 3)
      {
        re::DynamicString::format(this, (re::Allocator *)"Rig node channel %zu has an invalid channel type: %u.", (re::DynamicString *)&v261, v55, v57);
        goto LABEL_412;
      }
      if (*v56 >= *((_QWORD *)a2 + 130))
      {
        re::DynamicString::format(this, (re::Allocator *)"Rig node channel %zu has an invalid rig node: %zu.", (re::DynamicString *)&v261, v55, *v56);
        goto LABEL_412;
      }
      ++v55;
      v56 += 2;
    }
    while (v54 != v55);
  }
  v58 = *((_QWORD *)a2 + 67);
  if (v58)
  {
    v59 = 0;
    v60 = *((_QWORD *)a2 + 62);
    v61 = *((_QWORD *)a2 + 57);
    v62 = *((_QWORD *)a2 + 52);
    v63 = *((_QWORD *)a2 + 47);
    v64 = *((_QWORD *)a2 + 42);
    v65 = *((_QWORD *)a2 + 37);
    v66 = *((_QWORD *)a2 + 32);
    v67 = *((_QWORD *)a2 + 27);
    v68 = (uint64_t *)(*((_QWORD *)a2 + 69) + 8);
    while (2)
    {
      v69 = *((unsigned __int8 *)v68 - 8);
      if (v69 >= 8)
      {
        re::DynamicString::format(this, (re::Allocator *)"Rig node constant %zu has an constant type: %u.", (re::DynamicString *)&v261, v59, v69);
        goto LABEL_412;
      }
      switch(*((_BYTE *)v68 - 8))
      {
        case 0:
          v70 = *v68;
          if (v67 <= *v68)
            goto LABEL_243;
          goto LABEL_88;
        case 1:
          v70 = *v68;
          if (v66 <= *v68)
            goto LABEL_243;
          goto LABEL_88;
        case 2:
          v70 = *v68;
          if (v65 <= *v68)
            goto LABEL_243;
          goto LABEL_88;
        case 3:
          v70 = *v68;
          if (v64 <= *v68)
            goto LABEL_243;
          goto LABEL_88;
        case 4:
          v70 = *v68;
          if (v63 <= *v68)
            goto LABEL_243;
          goto LABEL_88;
        case 5:
          v70 = *v68;
          if (v62 <= *v68)
            goto LABEL_243;
          goto LABEL_88;
        case 6:
          v70 = *v68;
          if (v61 <= *v68)
            goto LABEL_243;
          goto LABEL_88;
        case 7:
          v70 = *v68;
          if (v60 <= *v68)
          {
LABEL_243:
            re::DynamicString::format(this, (re::Allocator *)"Rig node constant %zu has an invalid constant index: %zu.", (re::DynamicString *)&v261, v59, v70);
            goto LABEL_412;
          }
LABEL_88:
          ++v59;
          v68 += 2;
          if (v58 == v59)
            break;
          continue;
        default:
          re::internal::assertLog((re::internal *)5, (uint64_t)v68, a3, "assertion failure: '%s' (%s:line %i) Invalid Register Type: %u", "!\"Unreachable code\"", "validateRigDefinitionData", 311, v69);
          v225 = _os_crash();
          __break(1u);
          goto LABEL_420;
      }
      break;
    }
  }
  v71 = *((_QWORD *)a2 + 80);
  if (v71)
  {
    v72 = 0;
    v73 = (_QWORD *)(*((_QWORD *)a2 + 82) + 8);
    do
    {
      v74 = *((unsigned __int8 *)v73 - 8);
      if (v74 >= 8)
      {
        re::DynamicString::format(this, (re::Allocator *)"Rig temporary value %zu has an invalid type: %u.", (re::DynamicString *)&v261, v72, v74);
        goto LABEL_412;
      }
      if (*v73 >= *((_QWORD *)a2 + *((unsigned __int8 *)v73 - 8) + 70))
      {
        re::DynamicString::format(this, (re::Allocator *)"Rig temporary value %zu has an invalid index: %zu.", (re::DynamicString *)&v261, v72, *v73);
        goto LABEL_412;
      }
      ++v72;
      v73 += 2;
    }
    while (v71 != v72);
  }
  v75 = *((_QWORD *)a2 + 85);
  if (v75)
  {
    v76 = 0;
    v77 = (unint64_t *)(*((_QWORD *)a2 + 87) + 8);
    do
    {
      v78 = *((unsigned __int8 *)v77 - 8);
      switch((_DWORD)v78)
      {
        case 3:
          if (*v77 >= v71)
          {
            re::DynamicString::format(this, (re::Allocator *)"Rig expression parameter %zu has an invalid temporary value index: %zu.", (re::DynamicString *)&v261, v76, *v77);
            goto LABEL_412;
          }
          break;
        case 2:
          if (*v77 >= v58)
          {
            re::DynamicString::format(this, (re::Allocator *)"Rig expression parameter %zu has an invalid constraint value index: %zu.", (re::DynamicString *)&v261, v76, *v77);
            goto LABEL_412;
          }
          break;
        case 1:
          if (*v77 >= v54)
          {
            re::DynamicString::format(this, (re::Allocator *)"Rig expression parameter %zu has an invalid joint channel: %zu.", (re::DynamicString *)&v261, v76, *v77);
            goto LABEL_412;
          }
          break;
        default:
          re::DynamicString::format(this, (re::Allocator *)"Rig expression parameter %zu has an invalid type: %u.", (re::DynamicString *)&v261, v76, v78);
          goto LABEL_412;
      }
      ++v76;
      v77 += 2;
    }
    while (v75 != v76);
  }
  if (*((_QWORD *)a2 + 90))
  {
    v79 = 0;
    do
    {
      v80 = *((_QWORD *)a2 + 92);
      v81 = *(unsigned int *)(v80 + 24 * v79);
      if (v81 > 0x4D || (_DWORD)v81 == 76)
      {
        re::DynamicString::format(this, (re::Allocator *)"Rig expression command %zu has an invalid type: %u.", (re::DynamicString *)&v261, v79, v81);
        goto LABEL_412;
      }
      v82 = *((unsigned __int8 *)&re::kEvaluationCommandDescriptions + 16 * v81 + 9);
      v83 = *((_QWORD *)a2 + 85);
      if (*((_BYTE *)&re::kEvaluationCommandDescriptions + 16 * v81 + 9))
      {
        v84 = v80 + 24 * v79;
        v86 = *(_QWORD *)(v84 + 8);
        v85 = (_QWORD *)(v84 + 8);
        v87 = v86 + v82;
        if (__CFADD__(v86, v82) || v87 > v83)
        {
          re::DynamicString::format(this, (re::Allocator *)"Rig expression command %zu does not have enough parameters.", (re::DynamicString *)&v261, v79);
          goto LABEL_412;
        }
        v88 = 0;
        v89 = (char *)&re::kEvaluationCommandDescriptions + 16 * v81 + 10;
        do
        {
          v90 = v88 + *v85;
          if (v90 >= *((_QWORD *)a2 + 85))
          {
            re::DynamicString::format(this, (re::Allocator *)"Rig expression %zu has an invalid input parameter: %zu.", (re::DynamicString *)&v261, v79, v90);
            goto LABEL_412;
          }
          if (ExpressionParameterType != v89[v88])
          {
            re::DynamicString::format(this, (re::Allocator *)"Rig expression %zu input parameter %u expected type %u, received %u.", (re::DynamicString *)&v261, v79, v88, v89[v88], ExpressionParameterType);
            goto LABEL_412;
          }
          ++v88;
        }
        while (v82 != v88);
        v83 = *((_QWORD *)a2 + 85);
      }
      v92 = *(_QWORD *)(v80 + 24 * v79 + 16);
      if (v92 >= v83)
      {
        re::DynamicString::format(this, (re::Allocator *)"Rig expression %zu has an invalid output parameter index: %zu.", (re::DynamicString *)&v261, v79, v92);
        goto LABEL_412;
      }
      if (v93 != LOBYTE((&re::kEvaluationCommandDescriptions)[2 * v81 + 1]))
      {
        re::DynamicString::format(this, (re::Allocator *)"Rig expression %zu output parameter expected type %u, received %u.", (re::DynamicString *)&v261, v79, LOBYTE((&re::kEvaluationCommandDescriptions)[2 * v81 + 1]), v93);
        goto LABEL_412;
      }
      ++v79;
    }
    while (v79 < *((_QWORD *)a2 + 90));
  }
  v94 = *((_QWORD *)a2 + 95);
  if (v94)
  {
    v95 = 0;
    v96 = 0.001;
    v97 = 1.001;
    do
    {
      v98 = *((_QWORD *)a2 + 97);
      v99 = (_QWORD *)(v98 + 240 * v95);
      v100 = v99[2];
      if (v100 != v99[7])
      {
        re::DynamicString::format(this, (re::Allocator *)"Rig Two-bone IK handle %zu has mismatching roots and effectors.", (re::DynamicString *)&v261, v95);
        goto LABEL_412;
      }
      if (v100 != *(_QWORD *)(v98 + 240 * v95 + 96))
      {
        re::DynamicString::format(this, (re::Allocator *)"Rig Two-bone IK handle %zu has mismatching roots and targets.", (re::DynamicString *)&v261, v95);
        goto LABEL_412;
      }
      if (v100 != *(_QWORD *)(v98 + 240 * v95 + 136))
      {
        re::DynamicString::format(this, (re::Allocator *)"Rig Two-bone IK handle %zu has mismatching roots and up nodes.", (re::DynamicString *)&v261, v95);
        goto LABEL_412;
      }
      v101 = *(_QWORD *)(v98 + 240 * v95 + 176);
      if (v101)
        v102 = v100 == v101;
      else
        v102 = 1;
      if (!v102)
      {
        re::DynamicString::format(this, (re::Allocator *)"Rig Two-bone IK handle %zu has invalid end twist offsets.", (re::DynamicString *)&v261, v95);
        goto LABEL_412;
      }
      v103 = *(_QWORD *)(v98 + 240 * v95 + 216);
      if (v103)
        v104 = v100 == v103;
      else
        v104 = 1;
      if (!v104)
      {
        re::DynamicString::format(this, (re::Allocator *)"Rig Two-bone IK handle %zu has invalid soft IK percentages.", (re::DynamicString *)&v261, v95);
        goto LABEL_412;
      }
      if (v100)
      {
        v105 = (unint64_t *)v99[4];
        v106 = *((_QWORD *)a2 + 130);
        v107 = 8 * v100;
        v108 = 8 * v100;
        do
        {
          if (*v105 >= v106)
          {
            re::DynamicString::format(this, (re::Allocator *)"Rig Two-bone IK handle %zu has an invalid root node: %zu.", (re::DynamicString *)&v261, v95, *v105);
            goto LABEL_412;
          }
          ++v105;
          v108 -= 8;
        }
        while (v108);
        v109 = *(unint64_t **)(v98 + 240 * v95 + 72);
        v110 = 8 * v100;
        do
        {
          if (*v109 >= v106)
          {
            re::DynamicString::format(this, (re::Allocator *)"Rig Two-bone IK handle %zu has an invalid effector node: %zu.", (re::DynamicString *)&v261, v95, *v109);
            goto LABEL_412;
          }
          ++v109;
          v110 -= 8;
        }
        while (v110);
        v111 = *(unint64_t **)(v98 + 240 * v95 + 112);
        v112 = 8 * v100;
        do
        {
          if (*v111 >= v106)
          {
            re::DynamicString::format(this, (re::Allocator *)"Rig Two-bone IK handle %zu has an invalid target node: %zu.", (re::DynamicString *)&v261, v95, *v111);
            goto LABEL_412;
          }
          ++v111;
          v112 -= 8;
        }
        while (v112);
        v113 = *(unint64_t **)(v98 + 240 * v95 + 152);
        do
        {
          if (*v113 >= v106)
          {
            re::DynamicString::format(this, (re::Allocator *)"Rig Two-bone IK handle %zu has an invalid up node: %zu.", (re::DynamicString *)&v261, v95, *v113);
            goto LABEL_412;
          }
          ++v113;
          v107 -= 8;
        }
        while (v107);
      }
      if (v103)
      {
        v114 = *(float **)(v98 + 240 * v95 + 232);
        v115 = 4 * v103;
        do
        {
          v116 = *v114;
          if (*v114 < v96 || v116 > v97)
          {
            re::DynamicString::format(this, (re::Allocator *)"Rig Two-bone IK handle %zu has an invalid soft IK Percentage: %f.", (re::DynamicString *)&v261, v95, v116);
            goto LABEL_412;
          }
          ++v114;
          v115 -= 4;
        }
        while (v115);
      }
      if (v100)
      {
        v117 = v97;
        v118 = v96;
        for (i = 0; i != v100; ++i)
        {
          v120 = (unint64_t *)re::DynamicArray<unsigned long>::operator[]((uint64_t)(v99 + 5), i);
          v121 = *(_QWORD *)(re::DynamicArray<re::RigNode>::operator[](*((_QWORD *)a2 + 130), *((_QWORD *)a2 + 132), *v120)+ 32);
          if (v121 == -1)
          {
            re::DynamicString::format(this, (re::Allocator *)"Rig Two-bone IK handle %zu has effector with no parent: %zu.", (re::DynamicString *)&v261, v95, i);
            goto LABEL_412;
          }
          v122 = *(_QWORD *)(re::DynamicArray<re::RigNode>::operator[](*((_QWORD *)a2 + 130), *((_QWORD *)a2 + 132), v121)+ 32);
          if (v122 == -1)
          {
            re::DynamicString::format(this, (re::Allocator *)"Rig Two-bone IK handle %zu has middle with no parent: %zu.", (re::DynamicString *)&v261, v95, i);
            goto LABEL_412;
          }
          if (v122 != *(_QWORD *)re::DynamicArray<unsigned long>::operator[]((uint64_t)v99, i))
          {
            re::DynamicString::format(this, (re::Allocator *)"Rig Two-bone IK handle %zu does not have a 2-bone chain: %zu.", (re::DynamicString *)&v261, v95, i);
            goto LABEL_412;
          }
        }
        v94 = *((_QWORD *)a2 + 95);
        v96 = v118;
        v97 = v117;
      }
      ++v95;
    }
    while (v95 < v94);
  }
  v123 = *((_QWORD *)a2 + 100);
  if (v123)
  {
    v124 = 0;
    while (1)
    {
      v125 = (_QWORD *)re::DynamicArray<re::RigSingleChainIKHandles>::operator[](v123, *((_QWORD *)a2 + 102), v124);
      v126 = v125[2];
      if (v126 != v125[7])
      {
        re::DynamicString::format(this, (re::Allocator *)"Rig single chain IK handle %zu has mismatching roots & effectors.", (re::DynamicString *)&v261, v124);
        goto LABEL_412;
      }
      v127 = (uint64_t)v125;
      if (v126 != v125[12])
      {
        re::DynamicString::format(this, (re::Allocator *)"Rig single chain IK handle %zu has mismatching roots & targets.", (re::DynamicString *)&v261, v124);
        goto LABEL_412;
      }
      if (v126)
        break;
LABEL_189:
      ++v124;
      v123 = *((_QWORD *)a2 + 100);
      if (v124 >= v123)
        goto LABEL_190;
    }
    v260 = (uint64_t)(v125 + 5);
    v128 = (unint64_t *)v125[4];
    v129 = *((_QWORD *)a2 + 130);
    v130 = 8 * v126;
    v131 = 8 * v126;
    do
    {
      if (*v128 >= v129)
      {
        re::DynamicString::format(this, (re::Allocator *)"Rig single chain IK handle %zu has an invalid root: %zu.", (re::DynamicString *)&v261, v124, *v128);
        goto LABEL_412;
      }
      ++v128;
      v131 -= 8;
    }
    while (v131);
    v132 = (unint64_t *)v125[9];
    v133 = 8 * v126;
    do
    {
      if (*v132 >= v129)
      {
        re::DynamicString::format(this, (re::Allocator *)"Rig single chain IK handle %zu has an invalid effector: %zu.", (re::DynamicString *)&v261, v124, *v132);
        goto LABEL_412;
      }
      ++v132;
      v133 -= 8;
    }
    while (v133);
    v134 = (unint64_t *)v125[14];
    do
    {
      if (*v134 >= v129)
      {
        re::DynamicString::format(this, (re::Allocator *)"Rig single chain IK handle %zu has an invalid target: %zu.", (re::DynamicString *)&v261, v124, *v134);
        goto LABEL_412;
      }
      ++v134;
      v130 -= 8;
    }
    while (v130);
    v135 = 0;
    while (1)
    {
      v136 = (unint64_t *)re::DynamicArray<unsigned long>::operator[](v260, v135);
      v137 = re::DynamicArray<re::RigNode>::operator[](*((_QWORD *)a2 + 130), *((_QWORD *)a2 + 132), *v136);
      v138 = *(_QWORD *)re::DynamicArray<unsigned long>::operator[](v127, v135);
      v139 = *(_QWORD *)(v137 + 32);
      if (v139 != -1 && v139 != v138)
        break;
LABEL_187:
      if (v139 == -1)
      {
        re::DynamicString::format(this, (re::Allocator *)"Rig single chain IK handle %zu no a valid chain: %zu.", (re::DynamicString *)&v261, v124, v135);
        goto LABEL_412;
      }
      if (++v135 == v126)
        goto LABEL_189;
    }
    v141 = *((_QWORD *)a2 + 130);
    while (v141 > v139)
    {
      v139 = *(_QWORD *)(*((_QWORD *)a2 + 132) + 32 + 56 * v139);
      if (v139 == -1 || v139 == v138)
        goto LABEL_187;
    }
    v264 = 0u;
    v265 = 0u;
    v262 = 0u;
    v263 = 0u;
    v261 = 0u;
    a4 = MEMORY[0x24BDACB70];
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v273 = 136315906;
    *(_QWORD *)&v273[4] = "operator[]";
    *(_WORD *)&v273[12] = 1024;
    *(_DWORD *)&v273[14] = 797;
    *(_WORD *)&v273[18] = 2048;
    *(_QWORD *)&v273[20] = v139;
    *(_WORD *)&v273[28] = 2048;
    *(_QWORD *)&v273[30] = v141;
    v257 = 38;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_389:
    re::DynamicString::format(this, (re::Allocator *)"Rig node %zu does not have a valid name.", (re::DynamicString *)&v261, v124, v257);
    goto LABEL_412;
  }
LABEL_190:
  v143 = *((_QWORD *)a2 + 105);
  if (v143)
  {
    v144 = 0;
    while (1)
    {
      v145 = (_QWORD *)re::DynamicArray<re::RigSplineIKHandle>::operator[](v143, *((_QWORD *)a2 + 107), v144);
      v146 = v145[3];
      if (v146)
      {
        v147 = (_QWORD *)v145[5];
        v148 = 80 * v146;
        do
        {
          if (*v147 >= *((_QWORD *)a2 + 130))
          {
            re::DynamicString::format(this, (re::Allocator *)"Rig Spline IK handle %zu does not have a valid joint node.", (re::DynamicString *)&v261, v144);
            goto LABEL_412;
          }
          v147 += 10;
          v148 -= 80;
        }
        while (v148);
      }
      v149 = v145[8];
      if (!v149)
      {
        re::DynamicString::format(this, (re::Allocator *)"Rig Spline IK handle %zu does not have any control points.", (re::DynamicString *)&v261, v144);
        goto LABEL_412;
      }
      v150 = v145[10];
      v151 = v150 + 96 * v149;
      do
      {
        v152 = *(_QWORD *)(v150 + 16);
        if (v152)
        {
          v153 = *(unint64_t **)(v150 + 32);
          v154 = 8 * v152;
          do
          {
            if (*v153 >= v146)
            {
              re::DynamicString::format(this, (re::Allocator *)"Rig Spline IK handle %zu does not have a valid control point joint influence: %zu", (re::DynamicString *)&v261, v144, *v153);
              goto LABEL_412;
            }
            ++v153;
            v154 -= 8;
          }
          while (v154);
        }
        v150 += 96;
      }
      while (v150 != v151);
      if (v149 + 2 != v145[13])
      {
        re::DynamicString::format(this, (re::Allocator *)"Rig Spline IK handle %zu has %zu knots and needs %zu.", (re::DynamicString *)&v261, v144, v145[13], v149 + 2);
        goto LABEL_412;
      }
      v155 = v145[16];
      v156 = *((_QWORD *)a2 + 130);
      if (v155 >= v156)
      {
        re::DynamicString::format(this, (re::Allocator *)"Rig Spline IK handle %zu does not have a valid root node: %zu", (re::DynamicString *)&v261, v144, v155);
        goto LABEL_412;
      }
      v157 = v145[17];
      if (v157 >= v156)
      {
        re::DynamicString::format(this, (re::Allocator *)"Rig Spline IK handle %zu does not have a valid end effector node: %zu", (re::DynamicString *)&v261, v144, v157);
        goto LABEL_412;
      }
      v158 = v145[18];
      if (v158 >= v156)
        break;
      ++v144;
      v143 = *((_QWORD *)a2 + 105);
      if (v144 >= v143)
        goto LABEL_208;
    }
    re::DynamicString::format(this, (re::Allocator *)"Rig Spline IK handle %zu does not have a valid bind transform node: %zu", (re::DynamicString *)&v261, v144, v158);
LABEL_412:
    v250 = v261;
    v251 = v262;
    *(_BYTE *)a4 = 0;
    *(_QWORD *)(a4 + 8) = 3000;
    *(_QWORD *)(a4 + 16) = &re::AnimationErrorCategory(void)::instance;
    *(_OWORD *)(a4 + 24) = v250;
    *(_OWORD *)(a4 + 40) = v251;
  }
  else
  {
LABEL_208:
    v159 = *((_QWORD *)a2 + 110);
    if (v159)
    {
      for (j = 0; j < v159; ++j)
      {
        v161 = re::DynamicArray<re::RigTransform>::operator[](v159, *((_QWORD *)a2 + 112), j);
        v162 = *(float32x4_t *)(v161 + 32);
        v163 = vmulq_f32(v162, v162);
        if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v163, 2), vaddq_f32(v163, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v163.f32, 1))).f32[0]) < 1.0e-10)
        {
          re::DynamicString::format(this, (re::Allocator *)"Rig transform %zu must have a valid scale value.", (re::DynamicString *)&v261, j);
          goto LABEL_412;
        }
        if (*((_QWORD *)a2 + 120)
          && (v162.f32[0] != v162.f32[1]
           && vabds_f32(v162.f32[0], v162.f32[1]) >= (float)((float)((float)(fabsf(v162.f32[0]) + fabsf(v162.f32[1]))
                                                                   + 1.0)
                                                           * 0.00001)
           || v162.f32[0] != v162.f32[2]
           && vabds_f32(v162.f32[0], v162.f32[2]) >= (float)((float)((float)(fabsf(v162.f32[0]) + fabsf(v162.f32[2]))
                                                                   + 1.0)
                                                           * 0.00001)))
        {
          re::DynamicString::format(this, (re::Allocator *)"Rig transform %zu contains unsupported non-uniform scaling.", (re::DynamicString *)&v261, j);
          goto LABEL_412;
        }
        v164 = *(unsigned __int8 *)(v161 + 48);
        if (v164 >= 6)
        {
          re::DynamicString::format(this, (re::Allocator *)"Rig transform %zu contains an invalid rotation order: %u.", (re::DynamicString *)&v261, j, v164);
          goto LABEL_412;
        }
        v159 = *((_QWORD *)a2 + 110);
      }
    }
    v165 = *((_QWORD *)a2 + 115);
    if (v165)
    {
      for (k = 0; k < v165; ++k)
      {
        v167 = re::DynamicArray<re::RigJoint>::operator[](v165, *((_QWORD *)a2 + 117), k);
        v168 = (int8x16_t)vmulq_f32(*(float32x4_t *)(v167 + 16), *(float32x4_t *)(v167 + 16));
        v169 = vaddv_f32(vadd_f32(*(float32x2_t *)v168.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v168, v168, 8uLL)));
        if (v169 != 1.0 && fabsf(v169 + -1.0) > 0.00001)
        {
          re::DynamicString::format(this, (re::Allocator *)"Rig joint %zu does not have a valid orientation value.", (re::DynamicString *)&v261, k);
          goto LABEL_412;
        }
        v170 = (int8x16_t)vmulq_f32(*(float32x4_t *)(v167 + 48), *(float32x4_t *)(v167 + 48));
        v171 = vaddv_f32(vadd_f32(*(float32x2_t *)v170.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v170, v170, 8uLL)));
        if (v171 != 1.0 && fabsf(v171 + -1.0) > 0.00001)
        {
          re::DynamicString::format(this, (re::Allocator *)"Rig joint %zu does not have a valid scale orientation value.", (re::DynamicString *)&v261, k);
          goto LABEL_412;
        }
        v172 = *(float32x4_t *)(v167 + 64);
        v173 = vmulq_f32(v172, v172);
        if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v173, 2), vaddq_f32(v173, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v173.f32, 1))).f32[0]) < 1.0e-10)
        {
          re::DynamicString::format(this, (re::Allocator *)"Rig joint %zu must have a valid scale value.", (re::DynamicString *)&v261, k);
          goto LABEL_412;
        }
        v174 = *((_QWORD *)a2 + 120);
        if (v174
          && (v172.f32[0] != v172.f32[1]
           && vabds_f32(v172.f32[0], v172.f32[1]) >= (float)((float)((float)(fabsf(v172.f32[0]) + fabsf(v172.f32[1]))
                                                                   + 1.0)
                                                           * 0.00001)
           || v172.f32[0] != v172.f32[2]
           && vabds_f32(v172.f32[0], v172.f32[2]) >= (float)((float)((float)(fabsf(v172.f32[0]) + fabsf(v172.f32[2]))
                                                                   + 1.0)
                                                           * 0.00001)))
        {
          re::DynamicString::format(this, (re::Allocator *)"Rig joint %zu contains unsupported non-uniform scaling.", (re::DynamicString *)&v261, k);
          goto LABEL_412;
        }
        v175 = *(unsigned __int8 *)(v167 + 80);
        if (v175 >= 6)
        {
          re::DynamicString::format(this, (re::Allocator *)"Rig joint %zu contains an invalid rotation order: %u.", (re::DynamicString *)&v261, k, v175);
          goto LABEL_412;
        }
        v165 = *((_QWORD *)a2 + 115);
      }
    }
    else
    {
      v174 = *((_QWORD *)a2 + 120);
    }
    if (v174)
    {
      v176 = 0;
      while (1)
      {
        v177 = (unsigned __int8 *)re::DynamicArray<re::RigNodeChannel>::operator[](v174, *((_QWORD *)a2 + 122), v176);
        switch(*v177)
        {
          case 1u:
            if (*((_QWORD *)v177 + 1) < *((_QWORD *)a2 + 2))
              goto LABEL_290;
            re::DynamicString::format(this, (re::Allocator *)"Rig node constraint %zu is not a valid point constraint.", (re::DynamicString *)&v261, v176);
            goto LABEL_412;
          case 2u:
            if (*((_QWORD *)v177 + 1) < *((_QWORD *)a2 + 7))
              goto LABEL_290;
            re::DynamicString::format(this, (re::Allocator *)"Rig node constraint %zu is not a valid orient constraint.", (re::DynamicString *)&v261, v176);
            goto LABEL_412;
          case 3u:
            if (*((_QWORD *)v177 + 1) < *((_QWORD *)a2 + 12))
              goto LABEL_290;
            re::DynamicString::format(this, (re::Allocator *)"Rig node constraint %zu is not a valid parent constraint.", (re::DynamicString *)&v261, v176);
            goto LABEL_412;
          case 4u:
            if (*((_QWORD *)v177 + 1) < *((_QWORD *)a2 + 17))
              goto LABEL_290;
            re::DynamicString::format(this, (re::Allocator *)"Rig node constraint %zu is not a valid aim constraint.", (re::DynamicString *)&v261, v176);
            goto LABEL_412;
          case 5u:
            if (*((_QWORD *)v177 + 1) >= *((_QWORD *)a2 + 90))
            {
              re::DynamicString::format(this, (re::Allocator *)"Rig node constraint %zu is not a valid expression constraint.", (re::DynamicString *)&v261, v176);
              goto LABEL_412;
            }
LABEL_290:
            ++v176;
            v174 = *((_QWORD *)a2 + 120);
            if (v176 >= v174)
              goto LABEL_291;
            break;
          default:
            re::DynamicString::format(this, (re::Allocator *)"Rig node constraint %zu contains an invalid constraint type: %u.", (re::DynamicString *)&v261, v176, *v177);
            goto LABEL_412;
        }
      }
    }
LABEL_291:
    v178 = *((_QWORD *)a2 + 130);
    if (v178)
    {
      v124 = 0;
      do
      {
        v179 = re::DynamicArray<re::RigNode>::operator[](v178, *((_QWORD *)a2 + 132), v124);
        v180 = *(_BYTE **)(v179 + 8);
        if (!v180 || !*v180)
          goto LABEL_389;
        v181 = *(unsigned __int8 *)(v179 + 16);
        if ((_DWORD)v181 == 2)
        {
          v183 = *(_QWORD *)(v179 + 24);
          if (v183 >= *((_QWORD *)a2 + 115))
          {
            re::DynamicString::format(this, (re::Allocator *)"Rig node %zu (%s) does not specify a valid joint node: %zu.", (re::DynamicString *)&v261, v124, *(_QWORD *)(v179 + 8), v183);
            goto LABEL_412;
          }
        }
        else
        {
          if ((_DWORD)v181 != 1)
          {
            re::DynamicString::format(this, (re::Allocator *)"Rig node %zu (%s) does not specify a valid node type: %u.", (re::DynamicString *)&v261, v124, *(_QWORD *)(v179 + 8), v181);
            goto LABEL_412;
          }
          v182 = *(_QWORD *)(v179 + 24);
          if (v182 >= *((_QWORD *)a2 + 110))
          {
            re::DynamicString::format(this, (re::Allocator *)"Rig node %zu (%s) does not specify a valid transform node: %zu.", (re::DynamicString *)&v261, v124, *(_QWORD *)(v179 + 8), v182);
            goto LABEL_412;
          }
        }
        v184 = *(_QWORD *)(v179 + 32);
        v178 = *((_QWORD *)a2 + 130);
        v185 = v184 != -1 && v184 >= v178;
        if (v185)
        {
          re::DynamicString::format(this, (re::Allocator *)"Rig Node %zu (%s) does not specify a valid parent node: %zu.", (re::DynamicString *)&v261, v124, *(_QWORD *)(v179 + 8), v184);
          goto LABEL_412;
        }
        v186 = *(_QWORD *)(v179 + 40);
        if (v186)
        {
          v187 = *(_QWORD *)(v179 + 48);
          v185 = __CFADD__(v187, v186);
          v188 = v187 + v186;
          if (v185 || v188 > *((_QWORD *)a2 + 120))
          {
            re::DynamicString::format(this, (re::Allocator *)"Rig Node %zu (%s) does not specify valid constraint nodes.", (re::DynamicString *)&v261, v124, v180);
            goto LABEL_412;
          }
        }
      }
      while (++v124 < v178);
    }
    v189 = 0;
    v271 = 0u;
    v272 = 0u;
    v269 = 0u;
    v270 = 0u;
    v267 = 0u;
    v268 = 0u;
    v265 = 0u;
    v266 = 0u;
    v263 = 0u;
    v264 = 0u;
    v190 = (unint64_t *)((char *)a2 + 560);
    v261 = 0u;
    v262 = 0u;
    do
    {
      v191 = *v190++;
      v189 += 24;
    }
    while (v189 != 192);
    v192 = *((_QWORD *)a2 + 130);
    if (v192)
    {
      for (m = 0; m < v192; ++m)
      {
        v193 = re::DynamicArray<re::RigNode>::operator[](v192, *((_QWORD *)a2 + 132), m);
        if (*(_QWORD *)(v193 + 40))
        {
          v5 = (_QWORD *)v193;
          for (n = 0; n < v5[5]; ++n)
          {
            v195 = (unsigned __int8 *)re::DynamicArray<re::RigNodeChannel>::operator[](*((_QWORD *)a2 + 120), *((_QWORD *)a2 + 122), v5[6] + n);
            switch(*v195)
            {
              case 1u:
                v196 = re::DynamicArray<re::RigComponentConstraint>::operator[](*((_QWORD *)a2 + 2), *((_QWORD *)a2 + 4), *((_QWORD *)v195 + 1));
                v197 = *(_QWORD *)(v196 + 24);
                if (!v197)
                  continue;
                v198 = *(_QWORD **)(v196 + 40);
                v199 = 8 * v197;
                do
                {
                  if (*v198 == m)
                  {
                    re::DynamicString::format(this, (re::Allocator *)"Rig Node %zu (%s) point constraint %zu is constrained to itself.", (re::DynamicString *)v273, m, v5[1], n);
                    goto LABEL_421;
                  }
                  ++v198;
                  v199 -= 8;
                }
                while (v199);
                continue;
              case 2u:
                v200 = re::DynamicArray<re::RigComponentConstraint>::operator[](*((_QWORD *)a2 + 7), *((_QWORD *)a2 + 9), *((_QWORD *)v195 + 1));
                v201 = *(_QWORD *)(v200 + 24);
                if (!v201)
                  continue;
                v202 = *(_QWORD **)(v200 + 40);
                v203 = 8 * v201;
                do
                {
                  if (*v202 == m)
                  {
                    re::DynamicString::format(this, (re::Allocator *)"Rig Node %zu (%s) orient constraint %zu is constrained to itself.", (re::DynamicString *)v273, m, v5[1], n);
                    goto LABEL_421;
                  }
                  ++v202;
                  v203 -= 8;
                }
                while (v203);
                continue;
              case 3u:
                v204 = re::DynamicArray<re::RigBasicConstraint>::operator[](*((_QWORD *)a2 + 12), *((_QWORD *)a2 + 14), *((_QWORD *)v195 + 1));
                v205 = *(_QWORD *)(v204 + 16);
                if (!v205)
                  continue;
                v206 = *(_QWORD **)(v204 + 32);
                v207 = 8 * v205;
                do
                {
                  if (*v206 == m)
                  {
                    re::DynamicString::format(this, (re::Allocator *)"Rig Node %zu (%s) parent constraint %zu is constrained to itself.", (re::DynamicString *)v273, m, v5[1], n);
                    goto LABEL_421;
                  }
                  ++v206;
                  v207 -= 8;
                }
                while (v207);
                continue;
              case 4u:
                v208 = (_QWORD *)re::DynamicArray<re::RigAimConstraint>::operator[](*((_QWORD *)a2 + 17), *((_QWORD *)a2 + 19), *((_QWORD *)v195 + 1));
                v209 = v208[8];
                if (!v209)
                  goto LABEL_334;
                v210 = (_QWORD *)v208[10];
                v211 = 8 * v209;
                do
                {
                  if (*v210 == m)
                  {
                    re::DynamicString::format(this, (re::Allocator *)"Rig Node %zu (%s) aim constraint %zu forward is constrained to self.", (re::DynamicString *)v273, m, v5[1], n);
                    goto LABEL_421;
                  }
                  ++v210;
                  v211 -= 8;
                }
                while (v211);
LABEL_334:
                if (v208[16] == m)
                {
                  re::DynamicString::format(this, (re::Allocator *)"Rig Node %zu (%s) aim constraint %zu up is contrained to seld.", (re::DynamicString *)v273, m, v5[1], n);
                  goto LABEL_421;
                }
                continue;
              case 5u:
                v212 = (unsigned int *)re::DynamicArray<re::RigExpression>::operator[](*((_QWORD *)a2 + 90), *((_QWORD *)a2 + 92), *((_QWORD *)v195 + 1));
                v213 = &(&re::kEvaluationCommandDescriptions)[2 * *v212];
                v214 = *((unsigned __int8 *)v213 + 9);
                if (!*((_BYTE *)v213 + 9))
                  goto LABEL_342;
                v215 = 0;
                break;
              default:
                re::DynamicString::format(this, (re::Allocator *)"Rig node constraint %zu contains an invalid constraint type: %u.", (re::DynamicString *)v273, m, *v195);
                goto LABEL_421;
            }
            do
            {
              v216 = re::DynamicArray<re::RigNodeChannel>::operator[](*((_QWORD *)a2 + 85), *((_QWORD *)a2 + 87), v215 + *((_QWORD *)v212 + 1));
              if (*(_BYTE *)v216 == 3)
              {
                v217 = re::DynamicArray<re::RigNodeChannel>::operator[](*((_QWORD *)a2 + 80), *((_QWORD *)a2 + 82), *(_QWORD *)(v216 + 8));
                {
                  re::DynamicString::format(this, (re::Allocator *)"Rig Node %zu (%s) reads from uninitialized temporary value.", (re::DynamicString *)v273, m, v5[1]);
                  goto LABEL_421;
                }
                if (TemporaryValueUsed != m)
                {
                  v248 = TemporaryValueUsed;
                  v249 = v5[1];
                  v258 = *(_QWORD *)(re::DynamicArray<re::RigNode>::operator[](*((_QWORD *)a2 + 130), *((_QWORD *)a2 + 132), TemporaryValueUsed)+ 8);
                  re::DynamicString::format(this, (re::Allocator *)"Rig Node %zu (%s) reads from temporary value initialized by other rig node %zu (%s).", (re::DynamicString *)v273, m, v249, v248, v258);
                  goto LABEL_421;
                }
              }
              ++v215;
            }
            while (v214 != v215);
LABEL_342:
            v219 = (unsigned __int8 *)re::DynamicArray<re::RigNodeChannel>::operator[](*((_QWORD *)a2 + 85), *((_QWORD *)a2 + 87), *((_QWORD *)v212 + 2));
            v220 = *v219;
            if ((_DWORD)v220 == 1)
            {
              v226 = *(_QWORD *)(re::DynamicArray<re::RigNodeChannel>::operator[](*((_QWORD *)a2 + 22), *((_QWORD *)a2 + 24), *((_QWORD *)v219 + 1))+ 8);
              if (v226 != m)
              {
                re::DynamicString::format(this, (re::Allocator *)"Rig Node %zu (%s) constraint %zu outputs for a differing rig node : %zu.", (re::DynamicString *)v273, m, v5[1], n, v226);
                goto LABEL_421;
              }
            }
            else
            {
              if ((_DWORD)v220 != 3)
              {
                re::DynamicString::format(this, (re::Allocator *)"Rig Node %zu (%s) constraint %zu outputs to invalid destination: %u.", (re::DynamicString *)v273, m, v5[1], n, v220);
                goto LABEL_421;
              }
              v221 = re::DynamicArray<re::RigNodeChannel>::operator[](*((_QWORD *)a2 + 80), *((_QWORD *)a2 + 82), *((_QWORD *)v219 + 1));
              v223 = *(_BYTE *)v221;
              v224 = *(_QWORD *)(v221 + 8);
              if (isTemporaryValueUsed)
              {
                if (v225 != m)
                {
LABEL_420:
                  v252 = v225;
                  v253 = v5[1];
                  v259 = *(_QWORD *)(re::DynamicArray<re::RigNode>::operator[](*((_QWORD *)a2 + 130), *((_QWORD *)a2 + 132), v225)+ 8);
                  re::DynamicString::format(this, (re::Allocator *)"Rig Node %zu (%s) initializing temporary value already initialized by other rig node %zu (%s).", (re::DynamicString *)v273, m, v253, v252, v259);
                  goto LABEL_421;
                }
              }
              else
              {
              }
            }
          }
        }
        v192 = *((_QWORD *)a2 + 130);
      }
    }
    v227 = *((_QWORD *)a2 + 125);
    if (v227)
    {
      for (ii = 0; ii < v227; ++ii)
      {
        v229 = (unsigned __int8 *)re::DynamicArray<re::RigNodeChannel>::operator[](v227, *((_QWORD *)a2 + 127), ii);
        v230 = *v229;
        switch((_DWORD)v230)
        {
          case 3:
            v232 = *((_QWORD *)v229 + 1);
            if (v232 >= *((_QWORD *)a2 + 105))
            {
              re::DynamicString::format(this, (re::Allocator *)"Rig IK Handle %zu does not have a valid Spline IK index: %zu.", (re::DynamicString *)v273, ii, v232);
              goto LABEL_421;
            }
            break;
          case 2:
            v233 = *((_QWORD *)v229 + 1);
            if (v233 >= *((_QWORD *)a2 + 100))
            {
              re::DynamicString::format(this, (re::Allocator *)"Rig IK Handle %zu does not have a valid single chain IK index: %zu.", (re::DynamicString *)v273, ii, v233);
              goto LABEL_421;
            }
            break;
          case 1:
            v231 = *((_QWORD *)v229 + 1);
            if (v231 >= *((_QWORD *)a2 + 95))
            {
              re::DynamicString::format(this, (re::Allocator *)"Rig IK Handle %zu does not have a valid two-bone IK index: %zu.", (re::DynamicString *)v273, ii, v231);
              goto LABEL_421;
            }
            break;
          default:
            re::DynamicString::format(this, (re::Allocator *)"Rig IK Handle %zu does not have a valid type: %u.", (re::DynamicString *)v273, ii, v230);
            goto LABEL_421;
        }
        v227 = *((_QWORD *)a2 + 125);
      }
    }
    v234 = *((_QWORD *)a2 + 135);
    if (v234)
    {
      for (jj = 0; jj < v234; ++jj)
      {
        v236 = (unsigned __int8 *)re::DynamicArray<re::RigExpression>::operator[](v234, *((_QWORD *)a2 + 137), jj);
        v237 = *v236;
        if ((_DWORD)v237 == 2)
        {
          v239 = *((_QWORD *)v236 + 1);
          if (v239 >= *((_QWORD *)a2 + 115))
          {
            re::DynamicString::format(this, (re::Allocator *)"Rig pose node %zu does not specify a valid joint node: %zu.", (re::DynamicString *)v273, jj, v239);
            goto LABEL_421;
          }
        }
        else
        {
          if ((_DWORD)v237 != 1)
          {
            re::DynamicString::format(this, (re::Allocator *)"Rig pose node %zu does not specify a valid node type: %u.", (re::DynamicString *)v273, jj, v237);
            goto LABEL_421;
          }
          v238 = *((_QWORD *)v236 + 1);
          if (v238 >= *((_QWORD *)a2 + 110))
          {
            re::DynamicString::format(this, (re::Allocator *)"Rig pose node %zu does not specify a valid transform node: %zu.", (re::DynamicString *)v273, jj, v238);
            goto LABEL_421;
          }
        }
        v240 = *((_QWORD *)v236 + 2);
        if (v240 >= *((_QWORD *)a2 + 130))
        {
          re::DynamicString::format(this, (re::Allocator *)"Rig pose node %zu does not specify a valid rig node to override: %zu.", (re::DynamicString *)v273, jj, v240);
          goto LABEL_421;
        }
        v234 = *((_QWORD *)a2 + 135);
      }
    }
    v241 = *((_QWORD *)a2 + 140);
    if (v241)
    {
      v242 = 0;
      while (1)
      {
        v243 = (_QWORD *)re::DynamicArray<re::RigPose>::operator[](v241, *((_QWORD *)a2 + 142), v242);
        v244 = (_BYTE *)v243[1];
        if (!v244 || !*v244)
        {
          re::DynamicString::format(this, (re::Allocator *)"Rig pose %zu does not have a valid name.", (re::DynamicString *)v273, v242);
          goto LABEL_421;
        }
        v245 = v243[2];
        if (!v245)
        {
          re::DynamicString::format(this, (re::Allocator *)"Rig pose %zu (%s) does not contain any pose nodes.", (re::DynamicString *)v273, v242, v244);
          goto LABEL_421;
        }
        v246 = v243[3];
        v185 = __CFADD__(v246, v245);
        v247 = v246 + v245;
        if (v185 || v247 > *((_QWORD *)a2 + 135))
          break;
        ++v242;
        v241 = *((_QWORD *)a2 + 140);
        if (v242 >= v241)
          goto LABEL_380;
      }
      re::DynamicString::format(this, (re::Allocator *)"Rig pose %zu (%s) does not contain valid pose nodes.", (re::DynamicString *)v273, v242, v244);
LABEL_421:
      v254 = *(_OWORD *)v273;
      v255 = *(_QWORD *)&v273[16];
      v256 = *(_QWORD *)&v273[24];
      *(_BYTE *)a4 = 0;
      *(_QWORD *)(a4 + 8) = 3000;
      *(_QWORD *)(a4 + 16) = &re::AnimationErrorCategory(void)::instance;
      *(_OWORD *)(a4 + 24) = v254;
      *(_QWORD *)(a4 + 40) = v255;
      *(_QWORD *)(a4 + 48) = v256;
    }
    else
    {
LABEL_380:
      *(_BYTE *)a4 = 1;
    }
  }
}

uint64_t re::DynamicArray<re::RigComponentConstraint>::operator[](unint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a1 <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return a2 + 88 * a3;
}

uint64_t re::DynamicArray<re::RigBasicConstraint>::operator[](unint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a1 <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return a2 + 80 * a3;
}

uint64_t re::DynamicArray<re::RigAimConstraint>::operator[](unint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a1 <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return a2 + 144 * a3;
}

uint64_t re::DynamicArray<re::RigNodeChannel>::operator[](unint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a1 <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return a2 + 16 * a3;
}

uint64_t re::DynamicArray<re::RigExpression>::operator[](unint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a1 <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return a2 + 24 * a3;
}

uint64_t re::`anonymous namespace'::getExpressionParameterType(re::_anonymous_namespace_ *this, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t result;

  if (*((_QWORD *)this + 85) <= (unint64_t)a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_13;
  }
  v2 = *((_QWORD *)this + 87);
  v3 = *(unsigned __int8 *)(v2 + 16 * a2);
  if (v3 == 1)
    return 7;
  if (v3 == 3)
  {
    v4 = *(_QWORD *)(v2 + 16 * a2 + 8);
    if (*((_QWORD *)this + 80) > v4)
    {
      v5 = *((_QWORD *)this + 82);
      return *(unsigned __int8 *)(v5 + 16 * v4);
    }
LABEL_14:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (v3 != 2)
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Unexpected parameter type value.", "!\"Unreachable code\"", "getExpressionParameterType", 84);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v4 = *(_QWORD *)(v2 + 16 * a2 + 8);
  if (*((_QWORD *)this + 67) <= v4)
  {
LABEL_13:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_14;
  }
  v5 = *((_QWORD *)this + 69);
  return *(unsigned __int8 *)(v5 + 16 * v4);
}

uint64_t re::DynamicArray<re::RigNode>::operator[](unint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a1 <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return a2 + 56 * a3;
}

uint64_t re::DynamicArray<unsigned long>::operator[](uint64_t a1, unint64_t a2)
{
  if (*(_QWORD *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a1 + 32) + 8 * a2;
}

uint64_t re::DynamicArray<re::RigSingleChainIKHandles>::operator[](unint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a1 <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return a2 + (a3 << 7);
}

uint64_t re::DynamicArray<re::RigSplineIKHandle>::operator[](unint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a1 <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return a2 + 240 * a3;
}

uint64_t re::DynamicArray<re::RigTransform>::operator[](unint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a1 <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return a2 + (a3 << 6);
}

uint64_t re::DynamicArray<re::RigJoint>::operator[](unint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a1 <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return a2 + 96 * a3;
}

BOOL re::`anonymous namespace'::TemporaryValueValidationTable::isTemporaryValueUsed(uint64_t a1, unsigned __int8 a2, unint64_t a3)
{
  if (*(_QWORD *)(a1 + 24 * a2 + 8) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(*(_QWORD *)(a1 + 24 * a2 + 16) + 8 * a3) != -1;
}

uint64_t re::`anonymous namespace'::TemporaryValueValidationTable::getTemporaryValueUsed(uint64_t a1, unsigned __int8 a2, unint64_t a3)
{
  if (*(_QWORD *)(a1 + 24 * a2 + 8) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(*(_QWORD *)(a1 + 24 * a2 + 16) + 8 * a3);
}

uint64_t re::`anonymous namespace'::TemporaryValueValidationTable::setTemporaryValueUsed(uint64_t result, unsigned __int8 a2, unint64_t a3, uint64_t a4)
{
  if (*(_QWORD *)(result + 24 * a2 + 8) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  *(_QWORD *)(*(_QWORD *)(result + 24 * a2 + 16) + 8 * a3) = a4;
  return result;
}

uint64_t re::DynamicArray<re::RigPose>::operator[](unint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a1 <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return a2 + 32 * a3;
}

void re::`anonymous namespace'::TemporaryValueValidationTable::~TemporaryValueValidationTable(re::_anonymous_namespace_::TemporaryValueValidationTable *this)
{
  uint64_t i;
  _QWORD *v3;
  uint64_t v4;

  for (i = 0; i != -192; i -= 24)
  {
    v3 = (_QWORD *)((char *)this + i);
    v4 = *(_QWORD *)((char *)this + i + 168);
    if (v4)
    {
      if (v3[22])
      {
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, *(_QWORD *)((char *)this + i + 184));
        v3[22] = 0;
        v3[23] = 0;
      }
      v3[21] = 0;
    }
  }
}

void re::introspect_RigConstraintType(re *this, const re::IntrospectionBase *a2)
{
  unsigned __int8 v2;
  unsigned __int8 v3;
  uint64_t *v4;
  uint64_t v5;
  unsigned int *v6;
  _anonymous_namespace_ *v7;
  unint64_t v8;
  unint64_t i;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  char v13;
  unsigned __int8 *v14;
  int v15;
  uint64_t v16;
  unint64_t j;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  char v21;
  unsigned __int8 *v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  re *v26;
  uint64_t *v27;
  re *v28;
  uint64_t *v29;
  re *v30;
  uint64_t *v31;
  re *v32;
  uint64_t *v33;
  re *v34;
  uint64_t *v35;
  re *v36;
  uint64_t *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  const char *v41;
  StringID v42;
  _QWORD v43[2];
  _QWORD v44[61];

  v2 = atomic_load((unsigned __int8 *)&qword_2540F8FB8);
  if ((v2 & 1) == 0)
  {
    v26 = (re *)__cxa_guard_acquire(&qword_2540F8FB8);
    if ((_DWORD)v26)
    {
      v27 = re::introspectionAllocator(v26);
      v28 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v27 + 32))(v27, 24, 8);
      *(_DWORD *)v28 = 1;
      *((_QWORD *)v28 + 1) = 0;
      *((_QWORD *)v28 + 2) = "InvalidConstraint";
      qword_2540F9498 = (uint64_t)v28;
      v29 = re::introspectionAllocator(v28);
      v30 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v29 + 32))(v29, 24, 8);
      *(_DWORD *)v30 = 1;
      *((_QWORD *)v30 + 1) = 1;
      *((_QWORD *)v30 + 2) = "PointConstraint";
      qword_2540F94A0 = (uint64_t)v30;
      v31 = re::introspectionAllocator(v30);
      v32 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v31 + 32))(v31, 24, 8);
      *(_DWORD *)v32 = 1;
      *((_QWORD *)v32 + 1) = 2;
      *((_QWORD *)v32 + 2) = "OrientConstraint";
      qword_2540F94A8 = (uint64_t)v32;
      v33 = re::introspectionAllocator(v32);
      v34 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v33 + 32))(v33, 24, 8);
      *(_DWORD *)v34 = 1;
      *((_QWORD *)v34 + 1) = 3;
      *((_QWORD *)v34 + 2) = "ParentConstraint";
      qword_2540F94B0 = (uint64_t)v34;
      v35 = re::introspectionAllocator(v34);
      v36 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v35 + 32))(v35, 24, 8);
      *(_DWORD *)v36 = 1;
      *((_QWORD *)v36 + 1) = 4;
      *((_QWORD *)v36 + 2) = "AimConstraint";
      qword_2540F94B8 = (uint64_t)v36;
      v37 = re::introspectionAllocator(v36);
      v38 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v37 + 32))(v37, 24, 8);
      *(_DWORD *)v38 = 1;
      *(_QWORD *)(v38 + 8) = 5;
      *(_QWORD *)(v38 + 16) = "ExpressionConstraint";
      qword_2540F94C0 = v38;
      __cxa_guard_release(&qword_2540F8FB8);
    }
  }
  v3 = atomic_load((unsigned __int8 *)&qword_2540F8FC0);
  if ((v3 & 1) == 0 && __cxa_guard_acquire(&qword_2540F8FC0))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_2540F9B00, "RigConstraintType", 1, 1, 1, 1);
    qword_2540F9B00 = (uint64_t)&off_24ED7D9E8;
    qword_2540F9B40 = (uint64_t)&re::introspect_RigConstraintType(BOOL)::enumTable;
    dword_2540F9B10 = 9;
    __cxa_guard_release(&qword_2540F8FC0);
  }
  if ((_MergedGlobals_18 & 1) == 0)
  {
    _MergedGlobals_18 = 1;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_2540F9B00, a2);
    v40 = 0x2C7A148B8865178ELL;
    v41 = "RigConstraintType";
    v44[0] = 0x31CD534126;
    v44[1] = "uint8_t";
    v4 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v44);
    if (v4)
    {
      v5 = *v4;
      re::StringID::destroyString((re::StringID *)v44);
      v6 = (unsigned int *)qword_2540F9B40;
      v43[1] = v5;
      re::TypeBuilder::beginEnumType((uint64_t)v44, &v40, 1, 1, (uint64_t)v43);
      v8 = *v6;
      if ((_DWORD)v8)
      {
        for (i = 0; i < v8; ++i)
        {
          v10 = *(_QWORD *)(*((_QWORD *)v6 + 1) + 8 * i);
          if (*(_DWORD *)v10 == 1)
          {
            v11 = *(char **)(v10 + 16);
            if (v11)
            {
              v12 = *v11;
              if (*v11)
              {
                v13 = v11[1];
                if (v13)
                {
                  v14 = (unsigned __int8 *)(v11 + 2);
                  do
                  {
                    v12 = 31 * v12 + v13;
                    v15 = *v14++;
                    v13 = v15;
                  }
                  while (v15);
                }
              }
            }
            else
            {
              v12 = 0;
            }
            v16 = *(_QWORD *)(v10 + 8);
            *(_QWORD *)&v42.var0 = 2 * v12;
            v42.var1 = v11;
            re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v44, v16, &v42);
            re::StringID::destroyString((re::StringID *)&v42);
            v8 = *v6;
          }
        }
        if (v8)
        {
          for (j = 0; j < v8; ++j)
          {
            v18 = *(_QWORD *)(*((_QWORD *)v6 + 1) + 8 * j);
            if (*(_DWORD *)v18 == 2)
            {
              v19 = *(char **)(v18 + 16);
              if (v19)
              {
                v20 = *v19;
                if (*v19)
                {
                  v21 = v19[1];
                  if (v21)
                  {
                    v22 = (unsigned __int8 *)(v19 + 2);
                    do
                    {
                      v20 = 31 * v20 + v21;
                      v23 = *v22++;
                      v21 = v23;
                    }
                    while (v23);
                  }
                }
              }
              else
              {
                v20 = 0;
              }
              v24 = *(_QWORD *)(v18 + 8);
              *(_QWORD *)&v42.var0 = 2 * v20;
              v42.var1 = v19;
              re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v44, v24, &v42);
              re::StringID::destroyString((re::StringID *)&v42);
              v8 = *v6;
            }
          }
        }
      }
      re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v44, v25);
      xmmword_2540F9B20 = (__int128)v42;
      re::StringID::destroyString((re::StringID *)&v40);
    }
    else
    {
      re::StringID::destroyString((re::StringID *)v44);
      re::internal::assertLog((re::internal *)5, v39, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "RigConstraintType", v40, v41);
      _os_crash();
      __break(1u);
    }
  }
}

uint64_t *re::IntrospectionInfo<re::DynamicArray<unsigned long>>::get(int a1, const re::IntrospectionBase *a2)
{
  unsigned __int8 v3;
  int v4;
  re *v5;
  std::__shared_mutex_base *v6;
  re *v7;
  std::__shared_mutex_base *v8;
  uint64_t v10;
  int v11;
  re::IntrospectionRegistry *v12;
  const re::IntrospectionBase *v13;
  const char *v14;
  __int128 v15;
  __int128 v16;
  const char *v17;
  uint64_t v18[2];

  if ((v3 & 1) == 0
  {
    re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&re::IntrospectionInfo<re::DynamicArray<unsigned long>>::get(BOOL)::info);
    re::IntrospectionInfo<re::DynamicArray<unsigned long>>::get(BOOL)::info = (uint64_t)&off_24ED22930;
  }
  if (a1)
  {
    if (re::IntrospectionInfo<re::DynamicArray<unsigned long>>::get(BOOL)::isInitialized)
      return &re::IntrospectionInfo<re::DynamicArray<unsigned long>>::get(BOOL)::info;
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v16);
    v4 = re::IntrospectionInfo<re::DynamicArray<unsigned long>>::get(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v16);
    if (v4)
      return &re::IntrospectionInfo<re::DynamicArray<unsigned long>>::get(BOOL)::info;
    v6 = re::introspectionSharedMutex(v5);
    std::__shared_mutex_base::lock(v6);
  }
  v7 = (re *)re::introspect_size_t((re *)1, a2);
  if (re::IntrospectionInfo<re::DynamicArray<unsigned long>>::get(BOOL)::isInitialized)
  {
    if ((a1 & 1) == 0)
    {
LABEL_9:
      v8 = re::introspectionSharedMutex(v7);
      std::__shared_mutex_base::unlock(v8);
    }
  }
  else
  {
    v10 = (uint64_t)v7;
    re::IntrospectionInfo<re::DynamicArray<unsigned long>>::get(BOOL)::isInitialized = 1;
    v11 = *((_DWORD *)v7 + 6);
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&re::IntrospectionInfo<re::DynamicArray<unsigned long>>::get(BOOL)::info, 0);
    qword_2557FF4A8 = 0x2800000003;
    dword_2557FF4B0 = v11;
    word_2557FF4B4 = 0;
    *(_QWORD *)&xmmword_2557FF4B8 = 0;
    *((_QWORD *)&xmmword_2557FF4B8 + 1) = 0xFFFFFFFFLL;
    qword_2557FF4C8 = v10;
    unk_2557FF4D0 = 0;
    re::IntrospectionInfo<re::DynamicArray<unsigned long>>::get(BOOL)::info = (uint64_t)&off_24ED22930;
    re::IntrospectionRegistry::add(v12, v13);
    re::getPrettyTypeName((re *)&re::IntrospectionInfo<re::DynamicArray<unsigned long>>::get(BOOL)::info, (const re::IntrospectionBase *)&v16);
    if ((BYTE8(v16) & 1) != 0)
      v14 = v17;
    else
      v14 = (char *)&v16 + 9;
    if ((_QWORD)v16 && (BYTE8(v16) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v16 + 40))();
    v16 = *(_OWORD *)(v10 + 32);
    xmmword_2557FF4B8 = v15;
    re::StringID::destroyString((re::StringID *)v18);
    if ((a1 & 1) == 0)
      goto LABEL_9;
  }
  return &re::IntrospectionInfo<re::DynamicArray<unsigned long>>::get(BOOL)::info;
}

uint64_t *re::IntrospectionInfo<re::DynamicArray<float>>::get(int a1, const re::IntrospectionBase *a2)
{
  unsigned __int8 v3;
  int v4;
  re *v5;
  std::__shared_mutex_base *v6;
  re *v7;
  std::__shared_mutex_base *v8;
  uint64_t v10;
  int v11;
  re::IntrospectionRegistry *v12;
  const re::IntrospectionBase *v13;
  const char *v14;
  __int128 v15;
  __int128 v16;
  const char *v17;
  uint64_t v18[2];

  if ((v3 & 1) == 0
  {
    re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&re::IntrospectionInfo<re::DynamicArray<float>>::get(BOOL)::info);
    re::IntrospectionInfo<re::DynamicArray<float>>::get(BOOL)::info = (uint64_t)&off_24ED235A8;
  }
  if (a1)
  {
    if (re::IntrospectionInfo<re::DynamicArray<float>>::get(BOOL)::isInitialized)
      return &re::IntrospectionInfo<re::DynamicArray<float>>::get(BOOL)::info;
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v16);
    v4 = re::IntrospectionInfo<re::DynamicArray<float>>::get(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v16);
    if (v4)
      return &re::IntrospectionInfo<re::DynamicArray<float>>::get(BOOL)::info;
    v6 = re::introspectionSharedMutex(v5);
    std::__shared_mutex_base::lock(v6);
  }
  v7 = (re *)re::introspect_float((re *)1, a2);
  if (re::IntrospectionInfo<re::DynamicArray<float>>::get(BOOL)::isInitialized)
  {
    if ((a1 & 1) == 0)
    {
LABEL_9:
      v8 = re::introspectionSharedMutex(v7);
      std::__shared_mutex_base::unlock(v8);
    }
  }
  else
  {
    v10 = (uint64_t)v7;
    re::IntrospectionInfo<re::DynamicArray<float>>::get(BOOL)::isInitialized = 1;
    v11 = *((_DWORD *)v7 + 6);
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&re::IntrospectionInfo<re::DynamicArray<float>>::get(BOOL)::info, 0);
    qword_2557FF4F8 = 0x2800000003;
    dword_2557FF500 = v11;
    word_2557FF504 = 0;
    *(_QWORD *)&xmmword_2557FF508 = 0;
    *((_QWORD *)&xmmword_2557FF508 + 1) = 0xFFFFFFFFLL;
    qword_2557FF518 = v10;
    unk_2557FF520 = 0;
    re::IntrospectionInfo<re::DynamicArray<float>>::get(BOOL)::info = (uint64_t)&off_24ED235A8;
    re::IntrospectionRegistry::add(v12, v13);
    re::getPrettyTypeName((re *)&re::IntrospectionInfo<re::DynamicArray<float>>::get(BOOL)::info, (const re::IntrospectionBase *)&v16);
    if ((BYTE8(v16) & 1) != 0)
      v14 = v17;
    else
      v14 = (char *)&v16 + 9;
    if ((_QWORD)v16 && (BYTE8(v16) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v16 + 40))();
    v16 = *(_OWORD *)(v10 + 32);
    xmmword_2557FF508 = v15;
    re::StringID::destroyString((re::StringID *)v18);
    if ((a1 & 1) == 0)
      goto LABEL_9;
  }
  return &re::IntrospectionInfo<re::DynamicArray<float>>::get(BOOL)::info;
}

double re::internal::defaultConstruct<re::RigBasicConstraint>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double result;

  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_DWORD *)(a3 + 24) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  *(_QWORD *)(a3 + 72) = 0;
  result = 0.0;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_DWORD *)(a3 + 64) = 0;
  return result;
}

uint64_t re::internal::defaultDestruct<re::RigBasicConstraint>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;

  v5 = (_QWORD *)(a3 + 40);
  v4 = *(_QWORD *)(a3 + 40);
  if (v4)
  {
    if (*(_QWORD *)(a3 + 72))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *(_QWORD *)(a3 + 72) = 0;
    v5[1] = 0;
    v5[2] = 0;
    *v5 = 0;
    ++*(_DWORD *)(a3 + 64);
  }
  result = *(_QWORD *)a3;
  if (*(_QWORD *)a3)
  {
    if (*(_QWORD *)(a3 + 32))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a3 + 32) = 0;
    *(_QWORD *)(a3 + 8) = 0;
    *(_QWORD *)(a3 + 16) = 0;
    *(_QWORD *)a3 = 0;
    ++*(_DWORD *)(a3 + 24);
  }
  return result;
}

double re::internal::defaultConstructV2<re::RigBasicConstraint>(uint64_t a1)
{
  double result;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_DWORD *)(a1 + 64) = 0;
  return result;
}

uint64_t re::internal::defaultDestructV2<re::RigBasicConstraint>(uint64_t a1)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t result;

  v3 = (_QWORD *)(a1 + 40);
  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 72))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *(_QWORD *)(a1 + 72) = 0;
    v3[1] = 0;
    v3[2] = 0;
    *v3 = 0;
    ++*(_DWORD *)(a1 + 64);
  }
  result = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (*(_QWORD *)(a1 + 32))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

void re::IntrospectionInfo<BOOL [3]>::get(uint64_t a1, const re::IntrospectionBase *a2)
{
  unsigned __int8 v2;
  const re::IntrospectionBase *v3;
  re::IntrospectionRegistry *v4;
  const re::IntrospectionBase *v5;
  const char *v6;
  __int128 v7;
  __int128 v8;
  const char *v9;
  uint64_t v10[2];

  v2 = atomic_load((unsigned __int8 *)&qword_2540F9220);
  if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_2540F9220))
  {
    re::IntrospectionCStyleArray::IntrospectionCStyleArray((re::IntrospectionCStyleArray *)&unk_2540F9CB0);
    __cxa_guard_release(&qword_2540F9220);
  }
  if ((byte_2540F8F9E & 1) == 0)
  {
    byte_2540F8F9E = 1;
    v3 = (const re::IntrospectionBase *)re::introspect_BOOL((re *)1, a2);
    re::IntrospectionCStyleArray::IntrospectionCStyleArray((re::IntrospectionCStyleArray *)&unk_2540F9CB0, v3, 3);
    re::IntrospectionRegistry::add(v4, v5);
    re::getPrettyTypeName((re *)&unk_2540F9CB0, (const re::IntrospectionBase *)&v8);
    if ((BYTE8(v8) & 1) != 0)
      v6 = v9;
    else
      v6 = (char *)&v8 + 9;
    if ((_QWORD)v8)
    {
      if ((BYTE8(v8) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v8 + 40))();
    }
    v8 = *((_OWORD *)v3 + 2);
    xmmword_2540F9CD0 = v7;
    re::StringID::destroyString((re::StringID *)v10);
  }
}

double re::internal::defaultConstruct<re::RigComponentConstraint>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double result;

  *(_BYTE *)a3 = 0;
  *(_WORD *)(a3 + 1) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  *(_QWORD *)(a3 + 24) = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_DWORD *)(a3 + 32) = 0;
  *(_QWORD *)(a3 + 80) = 0;
  result = 0.0;
  *(_OWORD *)(a3 + 40) = 0u;
  *(_OWORD *)(a3 + 56) = 0u;
  *(_DWORD *)(a3 + 72) = 0;
  return result;
}

uint64_t re::internal::defaultDestruct<re::RigComponentConstraint>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;

  v5 = (_QWORD *)(a3 + 48);
  v4 = *(_QWORD *)(a3 + 48);
  if (v4)
  {
    if (*(_QWORD *)(a3 + 80))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *(_QWORD *)(a3 + 80) = 0;
    v5[1] = 0;
    v5[2] = 0;
    *v5 = 0;
    ++*(_DWORD *)(a3 + 72);
  }
  result = *(_QWORD *)(a3 + 8);
  if (result)
  {
    if (*(_QWORD *)(a3 + 40))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a3 + 40) = 0;
    *(_QWORD *)(a3 + 16) = 0;
    *(_QWORD *)(a3 + 24) = 0;
    *(_QWORD *)(a3 + 8) = 0;
    ++*(_DWORD *)(a3 + 32);
  }
  return result;
}

double re::internal::defaultConstructV2<re::RigComponentConstraint>(uint64_t a1)
{
  double result;

  *(_BYTE *)a1 = 0;
  *(_WORD *)(a1 + 1) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_DWORD *)(a1 + 72) = 0;
  return result;
}

uint64_t re::internal::defaultDestructV2<re::RigComponentConstraint>(uint64_t a1)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t result;

  v3 = (_QWORD *)(a1 + 48);
  v2 = *(_QWORD *)(a1 + 48);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 80))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *(_QWORD *)(a1 + 80) = 0;
    v3[1] = 0;
    v3[2] = 0;
    *v3 = 0;
    ++*(_DWORD *)(a1 + 72);
  }
  result = *(_QWORD *)(a1 + 8);
  if (result)
  {
    if (*(_QWORD *)(a1 + 40))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a1 + 40) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)(a1 + 24) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    ++*(_DWORD *)(a1 + 32);
  }
  return result;
}

void re::introspect_RigAimAxisType(re *this, const re::IntrospectionBase *a2)
{
  unsigned __int8 v2;
  unsigned __int8 v3;
  uint64_t *v4;
  uint64_t v5;
  unsigned int *v6;
  _anonymous_namespace_ *v7;
  unint64_t v8;
  unint64_t i;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  char v13;
  unsigned __int8 *v14;
  int v15;
  uint64_t v16;
  unint64_t j;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  char v21;
  unsigned __int8 *v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  re *v26;
  uint64_t *v27;
  re *v28;
  uint64_t *v29;
  re *v30;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  const char *v35;
  StringID v36;
  _QWORD v37[2];
  _QWORD v38[61];

  v2 = atomic_load((unsigned __int8 *)&qword_2540F8FF8);
  if ((v2 & 1) == 0)
  {
    v26 = (re *)__cxa_guard_acquire(&qword_2540F8FF8);
    if ((_DWORD)v26)
    {
      v27 = re::introspectionAllocator(v26);
      v28 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v27 + 32))(v27, 24, 8);
      *(_DWORD *)v28 = 1;
      *((_QWORD *)v28 + 1) = 0;
      *((_QWORD *)v28 + 2) = "PointAtConstraintNode";
      qword_2540F9368 = (uint64_t)v28;
      v29 = re::introspectionAllocator(v28);
      v30 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v29 + 32))(v29, 24, 8);
      *(_DWORD *)v30 = 1;
      *((_QWORD *)v30 + 1) = 1;
      *((_QWORD *)v30 + 2) = "ConstraintNodeAxis";
      qword_2540F9370 = (uint64_t)v30;
      v31 = re::introspectionAllocator(v30);
      v32 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v31 + 32))(v31, 24, 8);
      *(_DWORD *)v32 = 1;
      *(_QWORD *)(v32 + 8) = 2;
      *(_QWORD *)(v32 + 16) = "WorldAxis";
      qword_2540F9378 = v32;
      __cxa_guard_release(&qword_2540F8FF8);
    }
  }
  v3 = atomic_load((unsigned __int8 *)&qword_2540F9000);
  if ((v3 & 1) == 0 && __cxa_guard_acquire(&qword_2540F9000))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_2540F9B48, "RigAimAxisType", 1, 1, 1, 1);
    qword_2540F9B48 = (uint64_t)&off_24ED7D9E8;
    qword_2540F9B88 = (uint64_t)&re::introspect_RigAimAxisType(BOOL)::enumTable;
    dword_2540F9B58 = 9;
    __cxa_guard_release(&qword_2540F9000);
  }
  if ((byte_2540F8F99 & 1) == 0)
  {
    byte_2540F8F99 = 1;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_2540F9B48, a2);
    v34 = 0x570029D698AED7A0;
    v35 = "RigAimAxisType";
    v38[0] = 0x31CD534126;
    v38[1] = "uint8_t";
    v4 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v38);
    if (v4)
    {
      v5 = *v4;
      re::StringID::destroyString((re::StringID *)v38);
      v6 = (unsigned int *)qword_2540F9B88;
      v37[1] = v5;
      re::TypeBuilder::beginEnumType((uint64_t)v38, &v34, 1, 1, (uint64_t)v37);
      v8 = *v6;
      if ((_DWORD)v8)
      {
        for (i = 0; i < v8; ++i)
        {
          v10 = *(_QWORD *)(*((_QWORD *)v6 + 1) + 8 * i);
          if (*(_DWORD *)v10 == 1)
          {
            v11 = *(char **)(v10 + 16);
            if (v11)
            {
              v12 = *v11;
              if (*v11)
              {
                v13 = v11[1];
                if (v13)
                {
                  v14 = (unsigned __int8 *)(v11 + 2);
                  do
                  {
                    v12 = 31 * v12 + v13;
                    v15 = *v14++;
                    v13 = v15;
                  }
                  while (v15);
                }
              }
            }
            else
            {
              v12 = 0;
            }
            v16 = *(_QWORD *)(v10 + 8);
            *(_QWORD *)&v36.var0 = 2 * v12;
            v36.var1 = v11;
            re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v38, v16, &v36);
            re::StringID::destroyString((re::StringID *)&v36);
            v8 = *v6;
          }
        }
        if (v8)
        {
          for (j = 0; j < v8; ++j)
          {
            v18 = *(_QWORD *)(*((_QWORD *)v6 + 1) + 8 * j);
            if (*(_DWORD *)v18 == 2)
            {
              v19 = *(char **)(v18 + 16);
              if (v19)
              {
                v20 = *v19;
                if (*v19)
                {
                  v21 = v19[1];
                  if (v21)
                  {
                    v22 = (unsigned __int8 *)(v19 + 2);
                    do
                    {
                      v20 = 31 * v20 + v21;
                      v23 = *v22++;
                      v21 = v23;
                    }
                    while (v23);
                  }
                }
              }
              else
              {
                v20 = 0;
              }
              v24 = *(_QWORD *)(v18 + 8);
              *(_QWORD *)&v36.var0 = 2 * v20;
              v36.var1 = v19;
              re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v38, v24, &v36);
              re::StringID::destroyString((re::StringID *)&v36);
              v8 = *v6;
            }
          }
        }
      }
      re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v38, v25);
      xmmword_2540F9B68 = (__int128)v36;
      re::StringID::destroyString((re::StringID *)&v34);
    }
    else
    {
      re::StringID::destroyString((re::StringID *)v38);
      re::internal::assertLog((re::internal *)5, v33, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "RigAimAxisType", v34, v35);
      _os_crash();
      __break(1u);
    }
  }
}

double re::internal::defaultConstruct<re::RigAimConstraint>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double result;

  *(_DWORD *)a3 = 0;
  *(_BYTE *)(a3 + 4) = 0;
  result = 0.0;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)(a3 + 60) = 0u;
  *(_OWORD *)(a3 + 80) = 0u;
  *(_OWORD *)(a3 + 96) = 0u;
  *(_DWORD *)(a3 + 112) = 0;
  *(_QWORD *)(a3 + 120) = 0;
  *(_QWORD *)(a3 + 128) = -1;
  return result;
}

uint64_t re::internal::defaultDestruct<re::RigAimConstraint>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;

  v5 = (_QWORD *)(a3 + 88);
  v4 = *(_QWORD *)(a3 + 88);
  if (v4)
  {
    if (*(_QWORD *)(a3 + 120))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *(_QWORD *)(a3 + 120) = 0;
    v5[1] = 0;
    v5[2] = 0;
    *v5 = 0;
    ++*(_DWORD *)(a3 + 112);
  }
  result = *(_QWORD *)(a3 + 48);
  if (result)
  {
    if (*(_QWORD *)(a3 + 80))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a3 + 80) = 0;
    *(_QWORD *)(a3 + 56) = 0;
    *(_QWORD *)(a3 + 64) = 0;
    *(_QWORD *)(a3 + 48) = 0;
    ++*(_DWORD *)(a3 + 72);
  }
  return result;
}

double re::internal::defaultConstructV2<re::RigAimConstraint>(uint64_t a1)
{
  double result;

  *(_DWORD *)a1 = 0;
  *(_BYTE *)(a1 + 4) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 60) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_DWORD *)(a1 + 112) = 0;
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 128) = -1;
  return result;
}

uint64_t re::internal::defaultDestructV2<re::RigAimConstraint>(uint64_t a1)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t result;

  v3 = (_QWORD *)(a1 + 88);
  v2 = *(_QWORD *)(a1 + 88);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 120))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *(_QWORD *)(a1 + 120) = 0;
    v3[1] = 0;
    v3[2] = 0;
    *v3 = 0;
    ++*(_DWORD *)(a1 + 112);
  }
  result = *(_QWORD *)(a1 + 48);
  if (result)
  {
    if (*(_QWORD *)(a1 + 80))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a1 + 80) = 0;
    *(_QWORD *)(a1 + 56) = 0;
    *(_QWORD *)(a1 + 64) = 0;
    *(_QWORD *)(a1 + 48) = 0;
    ++*(_DWORD *)(a1 + 72);
  }
  return result;
}

void re::introspect_RigNodeChannelType(re *this, const re::IntrospectionBase *a2)
{
  unsigned __int8 v2;
  unsigned __int8 v3;
  uint64_t *v4;
  uint64_t v5;
  unsigned int *v6;
  _anonymous_namespace_ *v7;
  unint64_t v8;
  unint64_t i;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  char v13;
  unsigned __int8 *v14;
  int v15;
  uint64_t v16;
  unint64_t j;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  char v21;
  unsigned __int8 *v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  re *v26;
  uint64_t *v27;
  re *v28;
  uint64_t *v29;
  re *v30;
  uint64_t *v31;
  re *v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  const char *v37;
  StringID v38;
  _QWORD v39[2];
  _QWORD v40[61];

  v2 = atomic_load((unsigned __int8 *)&qword_2540F9020);
  if ((v2 & 1) == 0)
  {
    v26 = (re *)__cxa_guard_acquire(&qword_2540F9020);
    if ((_DWORD)v26)
    {
      v27 = re::introspectionAllocator(v26);
      v28 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v27 + 32))(v27, 24, 8);
      *(_DWORD *)v28 = 1;
      *((_QWORD *)v28 + 1) = 0;
      *((_QWORD *)v28 + 2) = "Invalid";
      qword_2540F93F8 = (uint64_t)v28;
      v29 = re::introspectionAllocator(v28);
      v30 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v29 + 32))(v29, 24, 8);
      *(_DWORD *)v30 = 1;
      *((_QWORD *)v30 + 1) = 1;
      *((_QWORD *)v30 + 2) = "Rotation";
      qword_2540F9400 = (uint64_t)v30;
      v31 = re::introspectionAllocator(v30);
      v32 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v31 + 32))(v31, 24, 8);
      *(_DWORD *)v32 = 1;
      *((_QWORD *)v32 + 1) = 2;
      *((_QWORD *)v32 + 2) = "Scale";
      qword_2540F9408 = (uint64_t)v32;
      v33 = re::introspectionAllocator(v32);
      v34 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v33 + 32))(v33, 24, 8);
      *(_DWORD *)v34 = 1;
      *(_QWORD *)(v34 + 8) = 3;
      *(_QWORD *)(v34 + 16) = "Translation";
      qword_2540F9410 = v34;
      __cxa_guard_release(&qword_2540F9020);
    }
  }
  v3 = atomic_load((unsigned __int8 *)&qword_2540F9028);
  if ((v3 & 1) == 0 && __cxa_guard_acquire(&qword_2540F9028))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_2540F9B90, "RigNodeChannelType", 1, 1, 1, 1);
    qword_2540F9B90 = (uint64_t)&off_24ED7D9E8;
    qword_2540F9BD0 = (uint64_t)&re::introspect_RigNodeChannelType(BOOL)::enumTable;
    dword_2540F9BA0 = 9;
    __cxa_guard_release(&qword_2540F9028);
  }
  if ((byte_2540F8F9A & 1) == 0)
  {
    byte_2540F8F9A = 1;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_2540F9B90, a2);
    v36 = 0x3CBA80F78C4288D6;
    v37 = "RigNodeChannelType";
    v40[0] = 0x31CD534126;
    v40[1] = "uint8_t";
    v4 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v40);
    if (v4)
    {
      v5 = *v4;
      re::StringID::destroyString((re::StringID *)v40);
      v6 = (unsigned int *)qword_2540F9BD0;
      v39[1] = v5;
      re::TypeBuilder::beginEnumType((uint64_t)v40, &v36, 1, 1, (uint64_t)v39);
      v8 = *v6;
      if ((_DWORD)v8)
      {
        for (i = 0; i < v8; ++i)
        {
          v10 = *(_QWORD *)(*((_QWORD *)v6 + 1) + 8 * i);
          if (*(_DWORD *)v10 == 1)
          {
            v11 = *(char **)(v10 + 16);
            if (v11)
            {
              v12 = *v11;
              if (*v11)
              {
                v13 = v11[1];
                if (v13)
                {
                  v14 = (unsigned __int8 *)(v11 + 2);
                  do
                  {
                    v12 = 31 * v12 + v13;
                    v15 = *v14++;
                    v13 = v15;
                  }
                  while (v15);
                }
              }
            }
            else
            {
              v12 = 0;
            }
            v16 = *(_QWORD *)(v10 + 8);
            *(_QWORD *)&v38.var0 = 2 * v12;
            v38.var1 = v11;
            re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v40, v16, &v38);
            re::StringID::destroyString((re::StringID *)&v38);
            v8 = *v6;
          }
        }
        if (v8)
        {
          for (j = 0; j < v8; ++j)
          {
            v18 = *(_QWORD *)(*((_QWORD *)v6 + 1) + 8 * j);
            if (*(_DWORD *)v18 == 2)
            {
              v19 = *(char **)(v18 + 16);
              if (v19)
              {
                v20 = *v19;
                if (*v19)
                {
                  v21 = v19[1];
                  if (v21)
                  {
                    v22 = (unsigned __int8 *)(v19 + 2);
                    do
                    {
                      v20 = 31 * v20 + v21;
                      v23 = *v22++;
                      v21 = v23;
                    }
                    while (v23);
                  }
                }
              }
              else
              {
                v20 = 0;
              }
              v24 = *(_QWORD *)(v18 + 8);
              *(_QWORD *)&v38.var0 = 2 * v20;
              v38.var1 = v19;
              re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v40, v24, &v38);
              re::StringID::destroyString((re::StringID *)&v38);
              v8 = *v6;
            }
          }
        }
      }
      re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v40, v25);
      xmmword_2540F9BB0 = (__int128)v38;
      re::StringID::destroyString((re::StringID *)&v36);
    }
    else
    {
      re::StringID::destroyString((re::StringID *)v40);
      re::internal::assertLog((re::internal *)5, v35, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "RigNodeChannelType", v36, v37);
      _os_crash();
      __break(1u);
    }
  }
}

void re::internal::defaultConstruct<re::RigNodeChannel>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_BYTE *)a3 = 0;
  *(_QWORD *)(a3 + 8) = -1;
}

uint64_t re::internal::defaultConstructV2<re::RigNodeChannel>(uint64_t result)
{
  *(_BYTE *)result = 0;
  *(_QWORD *)(result + 8) = -1;
  return result;
}

void re::internal::defaultConstruct<re::RigNodeConstant>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_BYTE *)a3 = -1;
  *(_QWORD *)(a3 + 8) = -1;
}

uint64_t re::internal::defaultConstructV2<re::RigNodeConstant>(uint64_t result)
{
  *(_BYTE *)result = -1;
  *(_QWORD *)(result + 8) = -1;
  return result;
}

void re::internal::defaultConstruct<re::RigNodeTemporaryValue>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_BYTE *)a3 = -1;
  *(_QWORD *)(a3 + 8) = -1;
}

uint64_t re::internal::defaultConstructV2<re::RigNodeTemporaryValue>(uint64_t result)
{
  *(_BYTE *)result = -1;
  *(_QWORD *)(result + 8) = -1;
  return result;
}

void re::introspect_RigExpressionParameterType(re *this, const re::IntrospectionBase *a2)
{
  unsigned __int8 v2;
  unsigned __int8 v3;
  uint64_t *v4;
  uint64_t v5;
  unsigned int *v6;
  _anonymous_namespace_ *v7;
  unint64_t v8;
  unint64_t i;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  char v13;
  unsigned __int8 *v14;
  int v15;
  uint64_t v16;
  unint64_t j;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  char v21;
  unsigned __int8 *v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  re *v26;
  uint64_t *v27;
  re *v28;
  uint64_t *v29;
  re *v30;
  uint64_t *v31;
  re *v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  const char *v37;
  StringID v38;
  _QWORD v39[2];
  _QWORD v40[61];

  v2 = atomic_load((unsigned __int8 *)&qword_2540F9078);
  if ((v2 & 1) == 0)
  {
    v26 = (re *)__cxa_guard_acquire(&qword_2540F9078);
    if ((_DWORD)v26)
    {
      v27 = re::introspectionAllocator(v26);
      v28 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v27 + 32))(v27, 24, 8);
      *(_DWORD *)v28 = 1;
      *((_QWORD *)v28 + 1) = 0;
      *((_QWORD *)v28 + 2) = "Invalid";
      qword_2540F9418 = (uint64_t)v28;
      v29 = re::introspectionAllocator(v28);
      v30 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v29 + 32))(v29, 24, 8);
      *(_DWORD *)v30 = 1;
      *((_QWORD *)v30 + 1) = 1;
      *((_QWORD *)v30 + 2) = "NodeChannel";
      qword_2540F9420 = (uint64_t)v30;
      v31 = re::introspectionAllocator(v30);
      v32 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v31 + 32))(v31, 24, 8);
      *(_DWORD *)v32 = 1;
      *((_QWORD *)v32 + 1) = 2;
      *((_QWORD *)v32 + 2) = "ConstantValue";
      qword_2540F9428 = (uint64_t)v32;
      v33 = re::introspectionAllocator(v32);
      v34 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v33 + 32))(v33, 24, 8);
      *(_DWORD *)v34 = 1;
      *(_QWORD *)(v34 + 8) = 3;
      *(_QWORD *)(v34 + 16) = "TemporaryValue";
      qword_2540F9430 = v34;
      __cxa_guard_release(&qword_2540F9078);
    }
  }
  v3 = atomic_load((unsigned __int8 *)&qword_2540F9080);
  if ((v3 & 1) == 0 && __cxa_guard_acquire(&qword_2540F9080))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_2540F9BD8, "RigExpressionParameterType", 1, 1, 1, 1);
    qword_2540F9BD8 = (uint64_t)&off_24ED7D9E8;
    qword_2540F9C18 = (uint64_t)&re::introspect_RigExpressionParameterType(BOOL)::enumTable;
    dword_2540F9BE8 = 9;
    __cxa_guard_release(&qword_2540F9080);
  }
  if ((byte_2540F8F9B & 1) == 0)
  {
    byte_2540F8F9B = 1;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_2540F9BD8, a2);
    v36 = 0x654B278C74D9AF76;
    v37 = "RigExpressionParameterType";
    v40[0] = 0x31CD534126;
    v40[1] = "uint8_t";
    v4 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v40);
    if (v4)
    {
      v5 = *v4;
      re::StringID::destroyString((re::StringID *)v40);
      v6 = (unsigned int *)qword_2540F9C18;
      v39[1] = v5;
      re::TypeBuilder::beginEnumType((uint64_t)v40, &v36, 1, 1, (uint64_t)v39);
      v8 = *v6;
      if ((_DWORD)v8)
      {
        for (i = 0; i < v8; ++i)
        {
          v10 = *(_QWORD *)(*((_QWORD *)v6 + 1) + 8 * i);
          if (*(_DWORD *)v10 == 1)
          {
            v11 = *(char **)(v10 + 16);
            if (v11)
            {
              v12 = *v11;
              if (*v11)
              {
                v13 = v11[1];
                if (v13)
                {
                  v14 = (unsigned __int8 *)(v11 + 2);
                  do
                  {
                    v12 = 31 * v12 + v13;
                    v15 = *v14++;
                    v13 = v15;
                  }
                  while (v15);
                }
              }
            }
            else
            {
              v12 = 0;
            }
            v16 = *(_QWORD *)(v10 + 8);
            *(_QWORD *)&v38.var0 = 2 * v12;
            v38.var1 = v11;
            re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v40, v16, &v38);
            re::StringID::destroyString((re::StringID *)&v38);
            v8 = *v6;
          }
        }
        if (v8)
        {
          for (j = 0; j < v8; ++j)
          {
            v18 = *(_QWORD *)(*((_QWORD *)v6 + 1) + 8 * j);
            if (*(_DWORD *)v18 == 2)
            {
              v19 = *(char **)(v18 + 16);
              if (v19)
              {
                v20 = *v19;
                if (*v19)
                {
                  v21 = v19[1];
                  if (v21)
                  {
                    v22 = (unsigned __int8 *)(v19 + 2);
                    do
                    {
                      v20 = 31 * v20 + v21;
                      v23 = *v22++;
                      v21 = v23;
                    }
                    while (v23);
                  }
                }
              }
              else
              {
                v20 = 0;
              }
              v24 = *(_QWORD *)(v18 + 8);
              *(_QWORD *)&v38.var0 = 2 * v20;
              v38.var1 = v19;
              re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v40, v24, &v38);
              re::StringID::destroyString((re::StringID *)&v38);
              v8 = *v6;
            }
          }
        }
      }
      re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v40, v25);
      xmmword_2540F9BF8 = (__int128)v38;
      re::StringID::destroyString((re::StringID *)&v36);
    }
    else
    {
      re::StringID::destroyString((re::StringID *)v40);
      re::internal::assertLog((re::internal *)5, v35, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "RigExpressionParameterType", v36, v37);
      _os_crash();
      __break(1u);
    }
  }
}

void re::internal::defaultConstruct<re::RigExpressionParameter>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_BYTE *)a3 = 0;
  *(_QWORD *)(a3 + 8) = -1;
}

uint64_t re::internal::defaultConstructV2<re::RigExpressionParameter>(uint64_t result)
{
  *(_BYTE *)result = 0;
  *(_QWORD *)(result + 8) = -1;
  return result;
}

void re::internal::defaultConstruct<re::RigExpression>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)a3 = -1;
  *(_QWORD *)(a3 + 8) = -1;
  *(_QWORD *)(a3 + 16) = -1;
}

uint64_t re::internal::defaultConstructV2<re::RigExpression>(uint64_t result)
{
  *(_DWORD *)result = -1;
  *(_QWORD *)(result + 8) = -1;
  *(_QWORD *)(result + 16) = -1;
  return result;
}

double re::internal::defaultConstruct<re::RigTwoBoneIKHandles>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double result;

  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_DWORD *)(a3 + 24) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  *(_QWORD *)(a3 + 232) = 0;
  result = 0.0;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_DWORD *)(a3 + 64) = 0;
  *(_OWORD *)(a3 + 72) = 0u;
  *(_OWORD *)(a3 + 88) = 0u;
  *(_DWORD *)(a3 + 104) = 0;
  *(_OWORD *)(a3 + 112) = 0u;
  *(_OWORD *)(a3 + 128) = 0u;
  *(_DWORD *)(a3 + 144) = 0;
  *(_OWORD *)(a3 + 152) = 0u;
  *(_OWORD *)(a3 + 168) = 0u;
  *(_DWORD *)(a3 + 184) = 0;
  *(_DWORD *)(a3 + 224) = 0;
  *(_OWORD *)(a3 + 192) = 0u;
  *(_OWORD *)(a3 + 208) = 0u;
  return result;
}

void re::internal::defaultDestruct<re::RigTwoBoneIKHandles>(int a1, int a2, re::RigTwoBoneIKHandles *this)
{
  re::RigTwoBoneIKHandles::~RigTwoBoneIKHandles(this);
}

double re::internal::defaultConstructV2<re::RigTwoBoneIKHandles>(uint64_t a1)
{
  double result;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 232) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_DWORD *)(a1 + 64) = 0;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_DWORD *)(a1 + 104) = 0;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_DWORD *)(a1 + 144) = 0;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_DWORD *)(a1 + 184) = 0;
  *(_DWORD *)(a1 + 224) = 0;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  return result;
}

double re::internal::defaultConstruct<re::RigSingleChainIKHandles>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double result;

  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_DWORD *)(a3 + 24) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  *(_QWORD *)(a3 + 112) = 0;
  result = 0.0;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_DWORD *)(a3 + 64) = 0;
  *(_OWORD *)(a3 + 72) = 0u;
  *(_OWORD *)(a3 + 88) = 0u;
  *(_DWORD *)(a3 + 104) = 0;
  *(_DWORD *)(a3 + 120) = 1008981770;
  return result;
}

uint64_t re::internal::defaultDestruct<re::RigSingleChainIKHandles>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t result;

  v5 = (_QWORD *)(a3 + 80);
  v4 = *(_QWORD *)(a3 + 80);
  if (v4)
  {
    if (*(_QWORD *)(a3 + 112))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *(_QWORD *)(a3 + 112) = 0;
    v5[1] = 0;
    v5[2] = 0;
    *v5 = 0;
    ++*(_DWORD *)(a3 + 104);
  }
  v6 = *(_QWORD *)(a3 + 40);
  if (v6)
  {
    if (*(_QWORD *)(a3 + 72))
      (*(void (**)(uint64_t))(*(_QWORD *)v6 + 40))(v6);
    *(_QWORD *)(a3 + 72) = 0;
    *(_QWORD *)(a3 + 48) = 0;
    *(_QWORD *)(a3 + 56) = 0;
    *(_QWORD *)(a3 + 40) = 0;
    ++*(_DWORD *)(a3 + 64);
  }
  result = *(_QWORD *)a3;
  if (*(_QWORD *)a3)
  {
    if (*(_QWORD *)(a3 + 32))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a3 + 32) = 0;
    *(_QWORD *)(a3 + 8) = 0;
    *(_QWORD *)(a3 + 16) = 0;
    *(_QWORD *)a3 = 0;
    ++*(_DWORD *)(a3 + 24);
  }
  return result;
}

double re::internal::defaultConstructV2<re::RigSingleChainIKHandles>(uint64_t a1)
{
  double result;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 112) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_DWORD *)(a1 + 64) = 0;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_DWORD *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 120) = 1008981770;
  return result;
}

uint64_t re::internal::defaultDestructV2<re::RigSingleChainIKHandles>(uint64_t a1)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t result;

  v3 = (_QWORD *)(a1 + 80);
  v2 = *(_QWORD *)(a1 + 80);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 112))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *(_QWORD *)(a1 + 112) = 0;
    v3[1] = 0;
    v3[2] = 0;
    *v3 = 0;
    ++*(_DWORD *)(a1 + 104);
  }
  v4 = *(_QWORD *)(a1 + 40);
  if (v4)
  {
    if (*(_QWORD *)(a1 + 72))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *(_QWORD *)(a1 + 72) = 0;
    *(_QWORD *)(a1 + 48) = 0;
    *(_QWORD *)(a1 + 56) = 0;
    *(_QWORD *)(a1 + 40) = 0;
    ++*(_DWORD *)(a1 + 64);
  }
  result = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (*(_QWORD *)(a1 + 32))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

double re::internal::defaultConstruct<re::RigSplineIKJoint>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double result;

  *(_QWORD *)a3 = -1;
  result = 0.0;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  return result;
}

double re::internal::defaultConstructV2<re::RigSplineIKJoint>(uint64_t a1)
{
  double result;

  *(_QWORD *)a1 = -1;
  result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  return result;
}

double re::internal::defaultConstruct<re::RigSplineIKControlPoint>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double result;

  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_DWORD *)(a3 + 24) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  result = 0.0;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_DWORD *)(a3 + 64) = 0;
  *(_QWORD *)(a3 + 80) = 0;
  *(_QWORD *)(a3 + 88) = 0;
  *(_QWORD *)(a3 + 72) = 0;
  return result;
}

uint64_t re::internal::defaultDestruct<re::RigSplineIKControlPoint>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;

  v5 = (_QWORD *)(a3 + 40);
  v4 = *(_QWORD *)(a3 + 40);
  if (v4)
  {
    if (*(_QWORD *)(a3 + 72))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *(_QWORD *)(a3 + 72) = 0;
    v5[1] = 0;
    v5[2] = 0;
    *v5 = 0;
    ++*(_DWORD *)(a3 + 64);
  }
  result = *(_QWORD *)a3;
  if (*(_QWORD *)a3)
  {
    if (*(_QWORD *)(a3 + 32))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a3 + 32) = 0;
    *(_QWORD *)(a3 + 8) = 0;
    *(_QWORD *)(a3 + 16) = 0;
    *(_QWORD *)a3 = 0;
    ++*(_DWORD *)(a3 + 24);
  }
  return result;
}

double re::internal::defaultConstructV2<re::RigSplineIKControlPoint>(uint64_t a1)
{
  double result;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_DWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  return result;
}

uint64_t re::internal::defaultDestructV2<re::RigSplineIKControlPoint>(uint64_t a1)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t result;

  v3 = (_QWORD *)(a1 + 40);
  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 72))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *(_QWORD *)(a1 + 72) = 0;
    v3[1] = 0;
    v3[2] = 0;
    *v3 = 0;
    ++*(_DWORD *)(a1 + 64);
  }
  result = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (*(_QWORD *)(a1 + 32))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

void re::IntrospectionInfo<re::DynamicArray<re::RigSplineIKJoint>>::get()
{
  unsigned __int8 v0;
  uint64_t *v1;
  unsigned __int8 v2;
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  int v5;
  re::IntrospectionRegistry *v6;
  const re::IntrospectionBase *v7;
  const char *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  re *v12;
  uint64_t *v13;
  const re::IntrospectionBase *v14;
  void *v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22[2];
  __int128 v23;
  const char *v24;
  __int128 v25;

  v0 = atomic_load((unsigned __int8 *)&qword_2540F9228);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_2540F9228))
  {
    re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_2540F9600);
    qword_2540F9600 = (uint64_t)&off_24ED229C8;
    __cxa_guard_release(&qword_2540F9228);
  }
  if ((byte_2540F8F9F & 1) == 0)
  {
    v1 = (uint64_t *)qword_2540F90F8;
    if (qword_2540F90F8)
      goto LABEL_7;
    v2 = atomic_load((unsigned __int8 *)&qword_2540F90E8);
    v1 = &qword_25582FEF0;
    if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_2540F90E8))
    {
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_25582FEF0, 0);
      *(uint64_t *)((char *)&qword_25582FF00 + 6) = 0;
      qword_25582FF00 = 0;
      *(_QWORD *)&xmmword_25582FF10 = 0;
      *((_QWORD *)&xmmword_25582FF10 + 1) = 0xFFFFFFFFLL;
      qword_25582FEF0 = (uint64_t)&off_24ED7DAA8;
      qword_25582FF20 = (uint64_t)"RigSplineIKJoint";
      dword_25582FF28 = 0;
      xmmword_25582FF30 = 0u;
      *(_OWORD *)&qword_25582FF40 = 0u;
      xmmword_25582FF50 = 0u;
      qword_25582FF60 = 0;
      __cxa_guard_release(&qword_2540F90E8);
    }
    qword_2540F90F8 = (uint64_t)&qword_25582FEF0;
    *(_QWORD *)&v25 = 0x2612B483F7D3490ELL;
    *((_QWORD *)&v25 + 1) = "RigSplineIKJoint";
    re::StringID::destroyString((re::StringID *)&v25);
    xmmword_25582FF10 = v23;
    v4 = atomic_load((unsigned __int8 *)&qword_2540F90F0);
    if ((v4 & 1) == 0)
    {
      v12 = (re *)__cxa_guard_acquire(&qword_2540F90F0);
      if ((_DWORD)v12)
      {
        v13 = re::introspectionAllocator(v12);
        v15 = re::introspect_size_t((re *)1, v14);
        v16 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v13 + 32))(v13, 72, 8);
        *(_DWORD *)v16 = 1;
        *(_QWORD *)(v16 + 8) = "rigNodeIndex";
        *(_QWORD *)(v16 + 16) = v15;
        *(_QWORD *)(v16 + 24) = 0;
        *(_QWORD *)(v16 + 32) = 1;
        *(_DWORD *)(v16 + 40) = 0;
        *(_QWORD *)(v16 + 48) = 0;
        *(_QWORD *)(v16 + 56) = 0;
        *(_DWORD *)(v16 + 64) = 0;
        qword_2540F9320 = v16;
        v17 = re::introspectionAllocator((re *)v16);
        v18 = re::introspect_Matrix4x4F((re::IntrospectionBase **)1);
        v19 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v17 + 32))(v17, 72, 8);
        *(_DWORD *)v19 = 1;
        *(_QWORD *)(v19 + 8) = "inverseBindPose";
        *(_QWORD *)(v19 + 16) = v18;
        *(_QWORD *)(v19 + 24) = 0;
        *(_QWORD *)(v19 + 32) = 0x1000000002;
        *(_DWORD *)(v19 + 40) = 0;
        *(_QWORD *)(v19 + 48) = 0;
        *(_QWORD *)(v19 + 56) = 0;
        *(_DWORD *)(v19 + 64) = 0;
        qword_2540F9328 = v19;
        __cxa_guard_release(&qword_2540F90F0);
      }
    }
    qword_25582FF00 = 0x5000000008;
    dword_25582FF08 = 16;
    word_25582FF0C = 1;
    dword_25582FF28 = 2;
    *(_QWORD *)&xmmword_25582FF30 = &qword_2540F9320;
    *((_QWORD *)&xmmword_25582FF30 + 1) = re::internal::defaultConstruct<re::RigSplineIKJoint>;
    qword_25582FF40 = (uint64_t)re::internal::defaultDestruct<re::RigSplineIKJoint>;
    unk_25582FF48 = 0;
    *(_QWORD *)&xmmword_25582FF50 = 0;
    *((_QWORD *)&xmmword_25582FF50 + 1) = re::internal::defaultConstructV2<re::RigSplineIKJoint>;
    qword_25582FF60 = (uint64_t)re::internal::defaultDestructV2<re::RigSplineIKJoint>;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_25582FEF0, v3);
    v25 = v23;
    if ((byte_2540F8F9F & 1) == 0)
    {
LABEL_7:
      byte_2540F8F9F = 1;
      v5 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540F9600, 0);
      qword_2540F9610 = 0x2800000003;
      dword_2540F9618 = v5;
      word_2540F961C = 0;
      *(_QWORD *)&xmmword_2540F9620 = 0;
      *((_QWORD *)&xmmword_2540F9620 + 1) = 0xFFFFFFFFLL;
      qword_2540F9630 = (uint64_t)v1;
      qword_2540F9638 = 0;
      qword_2540F9600 = (uint64_t)&off_24ED229C8;
      re::IntrospectionRegistry::add(v6, v7);
      re::getPrettyTypeName((re *)&qword_2540F9600, (const re::IntrospectionBase *)&v23);
      if ((BYTE8(v23) & 1) != 0)
        v8 = v24;
      else
        v8 = (char *)&v23 + 9;
      if ((_QWORD)v23 && (BYTE8(v23) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v23 + 40))();
      v21 = *((_OWORD *)v1 + 2);
      v9 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v22);
      if (v9)
      {
        v10 = *v9;
        *((_QWORD *)&v20 + 1) = v10;
      }
      else
      {
        v25 = v21;
        re::TypeBuilder::beginListType((uint64_t)&v23, v22, 1, 0x28uLL, 8uLL, &v25);
        re::TypeBuilder::setConstructor((uint64_t)&v23, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v23, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v23, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v23, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v23, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v23, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v23, v11);
      }
      xmmword_2540F9620 = v20;
      re::StringID::destroyString((re::StringID *)v22);
    }
  }
}

void re::IntrospectionInfo<re::DynamicArray<re::RigSplineIKControlPoint>>::get()
{
  unsigned __int8 v0;
  uint64_t *v1;
  unsigned __int8 v2;
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  int v5;
  re::IntrospectionRegistry *v6;
  const re::IntrospectionBase *v7;
  const char *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  re *v12;
  uint64_t *v13;
  const re::IntrospectionBase *v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t *v17;
  const re::IntrospectionBase *v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26[2];
  __int128 v27;
  const char *v28;
  __int128 v29;

  v0 = atomic_load((unsigned __int8 *)&qword_2540F9230);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_2540F9230))
  {
    re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_2540F9640);
    qword_2540F9640 = (uint64_t)&off_24ED22A60;
    __cxa_guard_release(&qword_2540F9230);
  }
  if ((byte_2540F8FA0 & 1) == 0)
  {
    v1 = (uint64_t *)qword_2540F9110;
    if (qword_2540F9110)
      goto LABEL_7;
    v2 = atomic_load((unsigned __int8 *)&qword_2540F9100);
    v1 = &qword_25582FF68;
    if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_2540F9100))
    {
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_25582FF68, 0);
      *(uint64_t *)((char *)&qword_25582FF78 + 6) = 0;
      qword_25582FF78 = 0;
      *(_QWORD *)&xmmword_25582FF88 = 0;
      *((_QWORD *)&xmmword_25582FF88 + 1) = 0xFFFFFFFFLL;
      qword_25582FF68 = (uint64_t)&off_24ED7DAA8;
      qword_25582FF98 = (uint64_t)"RigSplineIKControlPoint";
      dword_25582FFA0 = 0;
      xmmword_25582FFA8 = 0u;
      *(_OWORD *)&qword_25582FFB8 = 0u;
      xmmword_25582FFC8 = 0u;
      qword_25582FFD8 = 0;
      __cxa_guard_release(&qword_2540F9100);
    }
    qword_2540F9110 = (uint64_t)&qword_25582FF68;
    *(_QWORD *)&v29 = 0xEC09AC94D535DF2CLL;
    *((_QWORD *)&v29 + 1) = "RigSplineIKControlPoint";
    re::StringID::destroyString((re::StringID *)&v29);
    xmmword_25582FF88 = v27;
    v4 = atomic_load((unsigned __int8 *)&qword_2540F9108);
    if ((v4 & 1) == 0)
    {
      v12 = (re *)__cxa_guard_acquire(&qword_2540F9108);
      if ((_DWORD)v12)
      {
        v13 = re::introspectionAllocator(v12);
        v15 = re::IntrospectionInfo<re::DynamicArray<unsigned long>>::get(1, v14);
        v16 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v13 + 32))(v13, 72, 8);
        *(_DWORD *)v16 = 1;
        *(_QWORD *)(v16 + 8) = "jointInfluences";
        *(_QWORD *)(v16 + 16) = v15;
        *(_QWORD *)(v16 + 24) = 0;
        *(_QWORD *)(v16 + 32) = 1;
        *(_DWORD *)(v16 + 40) = 0;
        *(_QWORD *)(v16 + 48) = 0;
        *(_QWORD *)(v16 + 56) = 0;
        *(_DWORD *)(v16 + 64) = 0;
        qword_2540F9398 = v16;
        v17 = re::introspectionAllocator((re *)v16);
        v19 = re::IntrospectionInfo<re::DynamicArray<float>>::get(1, v18);
        v20 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v17 + 32))(v17, 72, 8);
        *(_DWORD *)v20 = 1;
        *(_QWORD *)(v20 + 8) = "jointWeights";
        *(_QWORD *)(v20 + 16) = v19;
        *(_QWORD *)(v20 + 24) = 0;
        *(_QWORD *)(v20 + 32) = 0x2800000002;
        *(_DWORD *)(v20 + 40) = 0;
        *(_QWORD *)(v20 + 48) = 0;
        *(_QWORD *)(v20 + 56) = 0;
        *(_DWORD *)(v20 + 64) = 0;
        qword_2540F93A0 = v20;
        v21 = re::introspectionAllocator((re *)v20);
        v22 = re::introspect_Vector3F((re::IntrospectionBase **)1);
        v23 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v21 + 32))(v21, 72, 8);
        *(_DWORD *)v23 = 1;
        *(_QWORD *)(v23 + 8) = "bindPosition";
        *(_QWORD *)(v23 + 16) = v22;
        *(_QWORD *)(v23 + 24) = 0;
        *(_QWORD *)(v23 + 32) = 0x5000000003;
        *(_DWORD *)(v23 + 40) = 0;
        *(_QWORD *)(v23 + 48) = 0;
        *(_QWORD *)(v23 + 56) = 0;
        *(_DWORD *)(v23 + 64) = 0;
        qword_2540F93A8 = v23;
        __cxa_guard_release(&qword_2540F9108);
      }
    }
    qword_25582FF78 = 0x6000000008;
    dword_25582FF80 = 16;
    word_25582FF84 = 0;
    dword_25582FFA0 = 3;
    *(_QWORD *)&xmmword_25582FFA8 = &qword_2540F9398;
    *((_QWORD *)&xmmword_25582FFA8 + 1) = re::internal::defaultConstruct<re::RigSplineIKControlPoint>;
    qword_25582FFB8 = (uint64_t)re::internal::defaultDestruct<re::RigSplineIKControlPoint>;
    unk_25582FFC0 = 0;
    *(_QWORD *)&xmmword_25582FFC8 = 0;
    *((_QWORD *)&xmmword_25582FFC8 + 1) = re::internal::defaultConstructV2<re::RigSplineIKControlPoint>;
    qword_25582FFD8 = (uint64_t)re::internal::defaultDestructV2<re::RigSplineIKControlPoint>;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_25582FF68, v3);
    v29 = v27;
    if ((byte_2540F8FA0 & 1) == 0)
    {
LABEL_7:
      byte_2540F8FA0 = 1;
      v5 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540F9640, 0);
      qword_2540F9650 = 0x2800000003;
      dword_2540F9658 = v5;
      word_2540F965C = 0;
      *(_QWORD *)&xmmword_2540F9660 = 0;
      *((_QWORD *)&xmmword_2540F9660 + 1) = 0xFFFFFFFFLL;
      qword_2540F9670 = (uint64_t)v1;
      qword_2540F9678 = 0;
      qword_2540F9640 = (uint64_t)&off_24ED22A60;
      re::IntrospectionRegistry::add(v6, v7);
      re::getPrettyTypeName((re *)&qword_2540F9640, (const re::IntrospectionBase *)&v27);
      if ((BYTE8(v27) & 1) != 0)
        v8 = v28;
      else
        v8 = (char *)&v27 + 9;
      if ((_QWORD)v27 && (BYTE8(v27) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v27 + 40))();
      v25 = *((_OWORD *)v1 + 2);
      v9 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v26);
      if (v9)
      {
        v10 = *v9;
        *((_QWORD *)&v24 + 1) = v10;
      }
      else
      {
        v29 = v25;
        re::TypeBuilder::beginListType((uint64_t)&v27, v26, 1, 0x28uLL, 8uLL, &v29);
        re::TypeBuilder::setConstructor((uint64_t)&v27, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKControlPoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v27, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKControlPoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v27, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v27, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKControlPoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKControlPoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v27, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKControlPoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v27, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKControlPoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKControlPoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKControlPoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v27, v11);
      }
      xmmword_2540F9660 = v24;
      re::StringID::destroyString((re::StringID *)v26);
    }
  }
}

double re::internal::defaultConstruct<re::RigSplineIKHandle>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double result;

  *(_DWORD *)a3 = 1008981770;
  *(_QWORD *)(a3 + 16) = 0;
  *(_QWORD *)(a3 + 24) = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_DWORD *)(a3 + 32) = 0;
  result = 0.0;
  *(_OWORD *)(a3 + 40) = 0u;
  *(_OWORD *)(a3 + 56) = 0u;
  *(_DWORD *)(a3 + 72) = 0;
  *(_OWORD *)(a3 + 80) = 0u;
  *(_OWORD *)(a3 + 96) = 0u;
  *(_DWORD *)(a3 + 112) = 0;
  *(_QWORD *)(a3 + 160) = -1;
  *(_QWORD *)(a3 + 168) = -1;
  *(_QWORD *)(a3 + 120) = 0;
  *(_QWORD *)(a3 + 128) = -1;
  *(_QWORD *)(a3 + 136) = -1;
  *(_QWORD *)(a3 + 144) = -1;
  *(_DWORD *)(a3 + 224) = 0;
  *(_OWORD *)(a3 + 192) = 0u;
  *(_OWORD *)(a3 + 208) = 0u;
  *(_OWORD *)(a3 + 176) = 0u;
  return result;
}

uint64_t re::internal::defaultDestruct<re::RigSplineIKHandle>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;

  v5 = (_QWORD *)(a3 + 88);
  v4 = *(_QWORD *)(a3 + 88);
  if (v4)
  {
    if (*(_QWORD *)(a3 + 120))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *(_QWORD *)(a3 + 120) = 0;
    v5[1] = 0;
    v5[2] = 0;
    *v5 = 0;
    ++*(_DWORD *)(a3 + 112);
  }
  re::DynamicArray<re::RigSplineIKControlPoint>::deinit(a3 + 48);
  result = *(_QWORD *)(a3 + 8);
  if (result)
  {
    if (*(_QWORD *)(a3 + 40))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a3 + 40) = 0;
    *(_QWORD *)(a3 + 16) = 0;
    *(_QWORD *)(a3 + 24) = 0;
    *(_QWORD *)(a3 + 8) = 0;
    ++*(_DWORD *)(a3 + 32);
  }
  return result;
}

double re::internal::defaultConstructV2<re::RigSplineIKHandle>(uint64_t a1)
{
  double result;

  *(_DWORD *)a1 = 1008981770;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_DWORD *)(a1 + 72) = 0;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_DWORD *)(a1 + 112) = 0;
  *(_QWORD *)(a1 + 160) = -1;
  *(_QWORD *)(a1 + 168) = -1;
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 128) = -1;
  *(_QWORD *)(a1 + 136) = -1;
  *(_QWORD *)(a1 + 144) = -1;
  *(_DWORD *)(a1 + 224) = 0;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  return result;
}

uint64_t re::internal::defaultDestructV2<re::RigSplineIKHandle>(uint64_t a1)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t result;

  v3 = (_QWORD *)(a1 + 88);
  v2 = *(_QWORD *)(a1 + 88);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 120))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *(_QWORD *)(a1 + 120) = 0;
    v3[1] = 0;
    v3[2] = 0;
    *v3 = 0;
    ++*(_DWORD *)(a1 + 112);
  }
  re::DynamicArray<re::RigSplineIKControlPoint>::deinit(a1 + 48);
  result = *(_QWORD *)(a1 + 8);
  if (result)
  {
    if (*(_QWORD *)(a1 + 40))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a1 + 40) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)(a1 + 24) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    ++*(_DWORD *)(a1 + 32);
  }
  return result;
}

void *re::allocInfo_RigIKTwistControls(re *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  v1 = atomic_load((unsigned __int8 *)&qword_2540F9130);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_2540F9130))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&unk_255830058, 0);
    *(_QWORD *)(v3 + 22) = 0;
    *(_QWORD *)(v3 + 16) = 0;
    *(_QWORD *)(v3 + 32) = 0;
    *(_QWORD *)(v3 + 40) = 0xFFFFFFFFLL;
    *(_QWORD *)v3 = &off_24ED7DAA8;
    *(_QWORD *)(v3 + 48) = "RigIKTwistControls";
    *(_DWORD *)(v3 + 56) = 0;
    *(_OWORD *)(v3 + 64) = 0u;
    *(_OWORD *)(v3 + 80) = 0u;
    *(_OWORD *)(v3 + 96) = 0u;
    *(_QWORD *)(v3 + 112) = 0;
    __cxa_guard_release(&qword_2540F9130);
  }
  return &unk_255830058;
}

void re::initInfo_RigIKTwistControls(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  const re::IntrospectionBase *v7;
  void *v8;
  uint64_t v9;
  uint64_t *v10;
  const re::IntrospectionBase *v11;
  void *v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t *v23;
  const re::IntrospectionBase *v24;
  void *v25;
  uint64_t v26;
  __int128 v27;
  _QWORD v28[2];
  __int128 v29;

  v28[0] = 0x47666560A0227416;
  v28[1] = "RigIKTwistControls";
  re::StringID::destroyString((re::StringID *)v28);
  *((_OWORD *)this + 2) = v29;
  v4 = atomic_load((unsigned __int8 *)&qword_2540F9138);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_2540F9138);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      v8 = re::introspect_size_t((re *)1, v7);
      v9 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
      *(_DWORD *)v9 = 1;
      *(_QWORD *)(v9 + 8) = "startTwistRigNode";
      *(_QWORD *)(v9 + 16) = v8;
      *(_QWORD *)(v9 + 24) = 0;
      *(_QWORD *)(v9 + 32) = 1;
      *(_DWORD *)(v9 + 40) = 0;
      *(_QWORD *)(v9 + 48) = 0;
      *(_QWORD *)(v9 + 56) = 0;
      *(_DWORD *)(v9 + 64) = 0;
      qword_2540F94F8 = v9;
      v10 = re::introspectionAllocator((re *)v9);
      v12 = re::introspect_size_t((re *)1, v11);
      v13 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v10 + 32))(v10, 72, 8);
      *(_DWORD *)v13 = 1;
      *(_QWORD *)(v13 + 8) = "endTwistRigNode";
      *(_QWORD *)(v13 + 16) = v12;
      *(_QWORD *)(v13 + 24) = 0;
      *(_QWORD *)(v13 + 32) = 0x800000002;
      *(_DWORD *)(v13 + 40) = 0;
      *(_QWORD *)(v13 + 48) = 0;
      *(_QWORD *)(v13 + 56) = 0;
      *(_DWORD *)(v13 + 64) = 0;
      qword_2540F9500 = v13;
      v14 = re::introspectionAllocator((re *)v13);
      v15 = re::introspect_Vector3F((re::IntrospectionBase **)1);
      v16 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v14 + 32))(v14, 72, 8);
      *(_DWORD *)v16 = 1;
      *(_QWORD *)(v16 + 8) = "startTwistUpAxis";
      *(_QWORD *)(v16 + 16) = v15;
      *(_QWORD *)(v16 + 24) = 0;
      *(_QWORD *)(v16 + 32) = 0x1000000003;
      *(_DWORD *)(v16 + 40) = 0;
      *(_QWORD *)(v16 + 48) = 0;
      *(_QWORD *)(v16 + 56) = 0;
      *(_DWORD *)(v16 + 64) = 0;
      qword_2540F9508 = v16;
      v17 = re::introspectionAllocator((re *)v16);
      v18 = re::introspect_Vector3F((re::IntrospectionBase **)1);
      v19 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v17 + 32))(v17, 72, 8);
      *(_DWORD *)v19 = 1;
      *(_QWORD *)(v19 + 8) = "endTwistUpAxis";
      *(_QWORD *)(v19 + 16) = v18;
      *(_QWORD *)(v19 + 24) = 0;
      *(_QWORD *)(v19 + 32) = 0x2000000004;
      *(_DWORD *)(v19 + 40) = 0;
      *(_QWORD *)(v19 + 48) = 0;
      *(_QWORD *)(v19 + 56) = 0;
      *(_DWORD *)(v19 + 64) = 0;
      qword_2540F9510 = v19;
      v20 = re::introspectionAllocator((re *)v19);
      v21 = re::introspect_Vector3F((re::IntrospectionBase **)1);
      v22 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v20 + 32))(v20, 72, 8);
      *(_DWORD *)v22 = 1;
      *(_QWORD *)(v22 + 8) = "ikChainUpAxis";
      *(_QWORD *)(v22 + 16) = v21;
      *(_QWORD *)(v22 + 24) = 0;
      *(_QWORD *)(v22 + 32) = 0x3000000005;
      *(_DWORD *)(v22 + 40) = 0;
      *(_QWORD *)(v22 + 48) = 0;
      *(_QWORD *)(v22 + 56) = 0;
      *(_DWORD *)(v22 + 64) = 0;
      qword_2540F9518 = v22;
      v23 = re::introspectionAllocator((re *)v22);
      v25 = re::introspect_float((re *)1, v24);
      v26 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v23 + 32))(v23, 72, 8);
      *(_DWORD *)v26 = 1;
      *(_QWORD *)(v26 + 8) = "twistOffset";
      *(_QWORD *)(v26 + 16) = v25;
      *(_QWORD *)(v26 + 24) = 0;
      *(_QWORD *)(v26 + 32) = 0x4000000006;
      *(_DWORD *)(v26 + 40) = 0;
      *(_QWORD *)(v26 + 48) = 0;
      *(_QWORD *)(v26 + 56) = 0;
      *(_DWORD *)(v26 + 64) = 0;
      qword_2540F9520 = v26;
      __cxa_guard_release(&qword_2540F9138);
    }
  }
  *((_QWORD *)this + 2) = 0x5000000008;
  *((_DWORD *)this + 6) = 16;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 6;
  *((_QWORD *)this + 8) = &qword_2540F94F8;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::RigIKTwistControls>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::RigIKTwistControls>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::RigIKTwistControls>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::RigIKTwistControls>;
  re::IntrospectionRegistry::add(this, v3);
  v27 = v29;
}

double re::internal::defaultConstruct<re::RigIKTwistControls>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double result;

  *(_QWORD *)a3 = -1;
  *(_QWORD *)(a3 + 8) = -1;
  result = 0.0;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_DWORD *)(a3 + 64) = 0;
  return result;
}

double re::internal::defaultConstructV2<re::RigIKTwistControls>(uint64_t a1)
{
  double result;

  *(_QWORD *)a1 = -1;
  *(_QWORD *)(a1 + 8) = -1;
  result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_DWORD *)(a1 + 64) = 0;
  return result;
}

void re::introspect_RigIKHandleType(re *this, const re::IntrospectionBase *a2)
{
  unsigned __int8 v2;
  unsigned __int8 v3;
  uint64_t *v4;
  uint64_t v5;
  unsigned int *v6;
  _anonymous_namespace_ *v7;
  unint64_t v8;
  unint64_t i;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  char v13;
  unsigned __int8 *v14;
  int v15;
  uint64_t v16;
  unint64_t j;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  char v21;
  unsigned __int8 *v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  re *v26;
  uint64_t *v27;
  re *v28;
  uint64_t *v29;
  re *v30;
  uint64_t *v31;
  re *v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  const char *v37;
  StringID v38;
  _QWORD v39[2];
  _QWORD v40[61];

  v2 = atomic_load((unsigned __int8 *)&qword_2540F9148);
  if ((v2 & 1) == 0)
  {
    v26 = (re *)__cxa_guard_acquire(&qword_2540F9148);
    if ((_DWORD)v26)
    {
      v27 = re::introspectionAllocator(v26);
      v28 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v27 + 32))(v27, 24, 8);
      *(_DWORD *)v28 = 1;
      *((_QWORD *)v28 + 1) = 0;
      *((_QWORD *)v28 + 2) = "Invalid";
      qword_2540F9458 = (uint64_t)v28;
      v29 = re::introspectionAllocator(v28);
      v30 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v29 + 32))(v29, 24, 8);
      *(_DWORD *)v30 = 1;
      *((_QWORD *)v30 + 1) = 1;
      *((_QWORD *)v30 + 2) = "TwoBone";
      qword_2540F9460 = (uint64_t)v30;
      v31 = re::introspectionAllocator(v30);
      v32 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v31 + 32))(v31, 24, 8);
      *(_DWORD *)v32 = 1;
      *((_QWORD *)v32 + 1) = 2;
      *((_QWORD *)v32 + 2) = "SingleChain";
      qword_2540F9468 = (uint64_t)v32;
      v33 = re::introspectionAllocator(v32);
      v34 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v33 + 32))(v33, 24, 8);
      *(_DWORD *)v34 = 1;
      *(_QWORD *)(v34 + 8) = 3;
      *(_QWORD *)(v34 + 16) = "Spline";
      qword_2540F9470 = v34;
      __cxa_guard_release(&qword_2540F9148);
    }
  }
  v3 = atomic_load((unsigned __int8 *)&qword_2540F9150);
  if ((v3 & 1) == 0 && __cxa_guard_acquire(&qword_2540F9150))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_2540F9C20, "RigIKHandleType", 1, 1, 1, 1);
    qword_2540F9C20 = (uint64_t)&off_24ED7D9E8;
    qword_2540F9C60 = (uint64_t)&re::introspect_RigIKHandleType(BOOL)::enumTable;
    dword_2540F9C30 = 9;
    __cxa_guard_release(&qword_2540F9150);
  }
  if ((byte_2540F8F9C & 1) == 0)
  {
    byte_2540F8F9C = 1;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_2540F9C20, a2);
    v36 = 0x8DF3E5D041D1B268;
    v37 = "RigIKHandleType";
    v40[0] = 0x31CD534126;
    v40[1] = "uint8_t";
    v4 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v40);
    if (v4)
    {
      v5 = *v4;
      re::StringID::destroyString((re::StringID *)v40);
      v6 = (unsigned int *)qword_2540F9C60;
      v39[1] = v5;
      re::TypeBuilder::beginEnumType((uint64_t)v40, &v36, 1, 1, (uint64_t)v39);
      v8 = *v6;
      if ((_DWORD)v8)
      {
        for (i = 0; i < v8; ++i)
        {
          v10 = *(_QWORD *)(*((_QWORD *)v6 + 1) + 8 * i);
          if (*(_DWORD *)v10 == 1)
          {
            v11 = *(char **)(v10 + 16);
            if (v11)
            {
              v12 = *v11;
              if (*v11)
              {
                v13 = v11[1];
                if (v13)
                {
                  v14 = (unsigned __int8 *)(v11 + 2);
                  do
                  {
                    v12 = 31 * v12 + v13;
                    v15 = *v14++;
                    v13 = v15;
                  }
                  while (v15);
                }
              }
            }
            else
            {
              v12 = 0;
            }
            v16 = *(_QWORD *)(v10 + 8);
            *(_QWORD *)&v38.var0 = 2 * v12;
            v38.var1 = v11;
            re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v40, v16, &v38);
            re::StringID::destroyString((re::StringID *)&v38);
            v8 = *v6;
          }
        }
        if (v8)
        {
          for (j = 0; j < v8; ++j)
          {
            v18 = *(_QWORD *)(*((_QWORD *)v6 + 1) + 8 * j);
            if (*(_DWORD *)v18 == 2)
            {
              v19 = *(char **)(v18 + 16);
              if (v19)
              {
                v20 = *v19;
                if (*v19)
                {
                  v21 = v19[1];
                  if (v21)
                  {
                    v22 = (unsigned __int8 *)(v19 + 2);
                    do
                    {
                      v20 = 31 * v20 + v21;
                      v23 = *v22++;
                      v21 = v23;
                    }
                    while (v23);
                  }
                }
              }
              else
              {
                v20 = 0;
              }
              v24 = *(_QWORD *)(v18 + 8);
              *(_QWORD *)&v38.var0 = 2 * v20;
              v38.var1 = v19;
              re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v40, v24, &v38);
              re::StringID::destroyString((re::StringID *)&v38);
              v8 = *v6;
            }
          }
        }
      }
      re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v40, v25);
      xmmword_2540F9C40 = (__int128)v38;
      re::StringID::destroyString((re::StringID *)&v36);
    }
    else
    {
      re::StringID::destroyString((re::StringID *)v40);
      re::internal::assertLog((re::internal *)5, v35, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "RigIKHandleType", v36, v37);
      _os_crash();
      __break(1u);
    }
  }
}

void re::internal::defaultConstruct<re::RigIKHandles>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_BYTE *)a3 = 0;
  *(_QWORD *)(a3 + 8) = -1;
}

uint64_t re::internal::defaultConstructV2<re::RigIKHandles>(uint64_t result)
{
  *(_BYTE *)result = 0;
  *(_QWORD *)(result + 8) = -1;
  return result;
}

double re::internal::defaultConstruct<re::RigTransform>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double result;

  result = 0.0;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_QWORD *)(a3 + 32) = 0x3F8000003F800000;
  *(_QWORD *)(a3 + 40) = 1065353216;
  *(_BYTE *)(a3 + 48) = 7;
  return result;
}

double re::internal::defaultConstructV2<re::RigTransform>(uint64_t a1)
{
  double result;

  result = 0.0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_QWORD *)(a1 + 32) = 0x3F8000003F800000;
  *(_QWORD *)(a1 + 40) = 1065353216;
  *(_BYTE *)(a1 + 48) = 7;
  return result;
}

double re::internal::defaultConstruct<re::RigJoint>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double result;

  result = 0.0;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = xmmword_2260E5D70;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = xmmword_2260E5D70;
  *(_QWORD *)(a3 + 64) = 0x3F8000003F800000;
  *(_QWORD *)(a3 + 72) = 1065353216;
  *(_BYTE *)(a3 + 80) = 7;
  return result;
}

double re::internal::defaultConstructV2<re::RigJoint>(uint64_t a1)
{
  double result;

  result = 0.0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = xmmword_2260E5D70;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = xmmword_2260E5D70;
  *(_QWORD *)(a1 + 64) = 0x3F8000003F800000;
  *(_QWORD *)(a1 + 72) = 1065353216;
  *(_BYTE *)(a1 + 80) = 7;
  return result;
}

void re::internal::defaultConstruct<re::RigNodeConstraint>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_BYTE *)a3 = 0;
  *(_QWORD *)(a3 + 8) = -1;
}

uint64_t re::internal::defaultConstructV2<re::RigNodeConstraint>(uint64_t result)
{
  *(_BYTE *)result = 0;
  *(_QWORD *)(result + 8) = -1;
  return result;
}

void re::introspect_RigNodeType(re *this, const re::IntrospectionBase *a2)
{
  unsigned __int8 v2;
  unsigned __int8 v3;
  uint64_t *v4;
  uint64_t v5;
  unsigned int *v6;
  _anonymous_namespace_ *v7;
  unint64_t v8;
  unint64_t i;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  char v13;
  unsigned __int8 *v14;
  int v15;
  uint64_t v16;
  unint64_t j;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  char v21;
  unsigned __int8 *v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  re *v26;
  uint64_t *v27;
  re *v28;
  uint64_t *v29;
  re *v30;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  const char *v35;
  StringID v36;
  _QWORD v37[2];
  _QWORD v38[61];

  v2 = atomic_load((unsigned __int8 *)&qword_2540F91B8);
  if ((v2 & 1) == 0)
  {
    v26 = (re *)__cxa_guard_acquire(&qword_2540F91B8);
    if ((_DWORD)v26)
    {
      v27 = re::introspectionAllocator(v26);
      v28 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v27 + 32))(v27, 24, 8);
      *(_DWORD *)v28 = 1;
      *((_QWORD *)v28 + 1) = 0;
      *((_QWORD *)v28 + 2) = "Invalid";
      qword_2540F93B0 = (uint64_t)v28;
      v29 = re::introspectionAllocator(v28);
      v30 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v29 + 32))(v29, 24, 8);
      *(_DWORD *)v30 = 1;
      *((_QWORD *)v30 + 1) = 1;
      *((_QWORD *)v30 + 2) = "Transform";
      qword_2540F93B8 = (uint64_t)v30;
      v31 = re::introspectionAllocator(v30);
      v32 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v31 + 32))(v31, 24, 8);
      *(_DWORD *)v32 = 1;
      *(_QWORD *)(v32 + 8) = 2;
      *(_QWORD *)(v32 + 16) = "Joint";
      qword_2540F93C0 = v32;
      __cxa_guard_release(&qword_2540F91B8);
    }
  }
  v3 = atomic_load((unsigned __int8 *)&qword_2540F91C0);
  if ((v3 & 1) == 0 && __cxa_guard_acquire(&qword_2540F91C0))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_2540F9C68, "RigNodeType", 1, 1, 1, 1);
    qword_2540F9C68 = (uint64_t)&off_24ED7D9E8;
    qword_2540F9CA8 = (uint64_t)&re::introspect_RigNodeType(BOOL)::enumTable;
    dword_2540F9C78 = 9;
    __cxa_guard_release(&qword_2540F91C0);
  }
  if ((byte_2540F8F9D & 1) == 0)
  {
    byte_2540F8F9D = 1;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_2540F9C68, a2);
    v34 = 0x1F1EB17A3692AD8;
    v35 = "RigNodeType";
    v38[0] = 0x31CD534126;
    v38[1] = "uint8_t";
    v4 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v38);
    if (v4)
    {
      v5 = *v4;
      re::StringID::destroyString((re::StringID *)v38);
      v6 = (unsigned int *)qword_2540F9CA8;
      v37[1] = v5;
      re::TypeBuilder::beginEnumType((uint64_t)v38, &v34, 1, 1, (uint64_t)v37);
      v8 = *v6;
      if ((_DWORD)v8)
      {
        for (i = 0; i < v8; ++i)
        {
          v10 = *(_QWORD *)(*((_QWORD *)v6 + 1) + 8 * i);
          if (*(_DWORD *)v10 == 1)
          {
            v11 = *(char **)(v10 + 16);
            if (v11)
            {
              v12 = *v11;
              if (*v11)
              {
                v13 = v11[1];
                if (v13)
                {
                  v14 = (unsigned __int8 *)(v11 + 2);
                  do
                  {
                    v12 = 31 * v12 + v13;
                    v15 = *v14++;
                    v13 = v15;
                  }
                  while (v15);
                }
              }
            }
            else
            {
              v12 = 0;
            }
            v16 = *(_QWORD *)(v10 + 8);
            *(_QWORD *)&v36.var0 = 2 * v12;
            v36.var1 = v11;
            re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v38, v16, &v36);
            re::StringID::destroyString((re::StringID *)&v36);
            v8 = *v6;
          }
        }
        if (v8)
        {
          for (j = 0; j < v8; ++j)
          {
            v18 = *(_QWORD *)(*((_QWORD *)v6 + 1) + 8 * j);
            if (*(_DWORD *)v18 == 2)
            {
              v19 = *(char **)(v18 + 16);
              if (v19)
              {
                v20 = *v19;
                if (*v19)
                {
                  v21 = v19[1];
                  if (v21)
                  {
                    v22 = (unsigned __int8 *)(v19 + 2);
                    do
                    {
                      v20 = 31 * v20 + v21;
                      v23 = *v22++;
                      v21 = v23;
                    }
                    while (v23);
                  }
                }
              }
              else
              {
                v20 = 0;
              }
              v24 = *(_QWORD *)(v18 + 8);
              *(_QWORD *)&v36.var0 = 2 * v20;
              v36.var1 = v19;
              re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v38, v24, &v36);
              re::StringID::destroyString((re::StringID *)&v36);
              v8 = *v6;
            }
          }
        }
      }
      re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v38, v25);
      xmmword_2540F9C88 = (__int128)v36;
      re::StringID::destroyString((re::StringID *)&v34);
    }
    else
    {
      re::StringID::destroyString((re::StringID *)v38);
      re::internal::assertLog((re::internal *)5, v33, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "RigNodeType", v34, v35);
      _os_crash();
      __break(1u);
    }
  }
}

double re::internal::defaultConstruct<re::RigNode>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double result;

  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = &str_110;
  *(_BYTE *)(a3 + 16) = 0;
  *(_QWORD *)(a3 + 24) = -1;
  *(_QWORD *)(a3 + 32) = -1;
  result = 0.0;
  *(_OWORD *)(a3 + 40) = xmmword_2260E7ED0;
  return result;
}

void re::internal::defaultDestruct<re::RigNode>(int a1, int a2, re::StringID *this)
{
  re::StringID::destroyString(this);
}

double re::internal::defaultConstructV2<re::RigNode>(uint64_t a1)
{
  double result;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = &str_110;
  *(_BYTE *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = -1;
  *(_QWORD *)(a1 + 32) = -1;
  result = 0.0;
  *(_OWORD *)(a1 + 40) = xmmword_2260E7ED0;
  return result;
}

void re::internal::defaultConstruct<re::RigPoseNode>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_BYTE *)a3 = 0;
  *(_QWORD *)(a3 + 8) = -1;
  *(_QWORD *)(a3 + 16) = -1;
}

uint64_t re::internal::defaultConstructV2<re::RigPoseNode>(uint64_t result)
{
  *(_BYTE *)result = 0;
  *(_QWORD *)(result + 8) = -1;
  *(_QWORD *)(result + 16) = -1;
  return result;
}

double re::internal::defaultConstruct<re::RigPose>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double result;

  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = &str_110;
  result = 0.0;
  *(_OWORD *)(a3 + 16) = xmmword_2260E7ED0;
  return result;
}

void re::internal::defaultDestruct<re::RigPose>(int a1, int a2, re::StringID *this)
{
  re::StringID::destroyString(this);
}

double re::internal::defaultConstructV2<re::RigPose>(uint64_t a1)
{
  double result;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = &str_110;
  result = 0.0;
  *(_OWORD *)(a1 + 16) = xmmword_2260E7ED0;
  return result;
}

void *re::allocInfo_RigDefinition(re *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  v1 = atomic_load((unsigned __int8 *)&qword_2540F9210);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_2540F9210))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&unk_255830418, 0);
    *(_QWORD *)(v3 + 22) = 0;
    *(_QWORD *)(v3 + 16) = 0;
    *(_QWORD *)(v3 + 32) = 0;
    *(_QWORD *)(v3 + 40) = 0xFFFFFFFFLL;
    *(_QWORD *)v3 = &off_24ED7DAA8;
    *(_QWORD *)(v3 + 48) = "RigDefinition";
    *(_DWORD *)(v3 + 56) = 0;
    *(_OWORD *)(v3 + 64) = 0u;
    *(_OWORD *)(v3 + 80) = 0u;
    *(_OWORD *)(v3 + 96) = 0u;
    *(_QWORD *)(v3 + 112) = 0;
    __cxa_guard_release(&qword_2540F9210);
  }
  return &unk_255830418;
}

void re::initInfo_RigDefinition(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t *v21;
  const re::IntrospectionBase *v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  uint64_t *v30;
  uint64_t v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t *v36;
  uint64_t v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t *v40;
  uint64_t v41;
  uint64_t *v42;
  uint64_t v43;
  uint64_t *v44;
  uint64_t v45;
  uint64_t *v46;
  uint64_t v47;
  uint64_t *v48;
  uint64_t v49;
  __int128 v50;
  _QWORD v51[2];
  __int128 v52;

  v51[0] = 0x4D2193656067CCC6;
  v51[1] = "RigDefinition";
  re::StringID::destroyString((re::StringID *)v51);
  *((_OWORD *)this + 2) = v52;
  v4 = atomic_load((unsigned __int8 *)&qword_2540F9218);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_2540F9218);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      re::IntrospectionInfo<re::DynamicArray<re::RigComponentConstraint>>::get();
      v7 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
      *(_DWORD *)v7 = 1;
      *(_QWORD *)(v7 + 8) = "pointConstraints";
      *(_QWORD *)(v7 + 16) = &qword_2540F9680;
      *(_QWORD *)(v7 + 24) = 0;
      *(_QWORD *)(v7 + 32) = 1;
      *(_DWORD *)(v7 + 40) = 0;
      *(_QWORD *)(v7 + 48) = 0;
      *(_QWORD *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_255830490 = v7;
      v8 = re::introspectionAllocator((re *)v7);
      re::IntrospectionInfo<re::DynamicArray<re::RigComponentConstraint>>::get();
      v9 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v8 + 32))(v8, 72, 8);
      *(_DWORD *)v9 = 1;
      *(_QWORD *)(v9 + 8) = "orientConstraints";
      *(_QWORD *)(v9 + 16) = &qword_2540F9680;
      *(_QWORD *)(v9 + 24) = 0;
      *(_QWORD *)(v9 + 32) = 0x2800000002;
      *(_DWORD *)(v9 + 40) = 0;
      *(_QWORD *)(v9 + 48) = 0;
      *(_QWORD *)(v9 + 56) = 0;
      *(_DWORD *)(v9 + 64) = 0;
      qword_255830498 = v9;
      v10 = re::introspectionAllocator((re *)v9);
      re::IntrospectionInfo<re::DynamicArray<re::RigBasicConstraint>>::get();
      v11 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v10 + 32))(v10, 72, 8);
      *(_DWORD *)v11 = 1;
      *(_QWORD *)(v11 + 8) = "parentConstraints";
      *(_QWORD *)(v11 + 16) = &qword_2540F96C0;
      *(_QWORD *)(v11 + 24) = 0;
      *(_QWORD *)(v11 + 32) = 0x5000000003;
      *(_DWORD *)(v11 + 40) = 0;
      *(_QWORD *)(v11 + 48) = 0;
      *(_QWORD *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_2558304A0 = v11;
      v12 = re::introspectionAllocator((re *)v11);
      re::IntrospectionInfo<re::DynamicArray<re::RigAimConstraint>>::get();
      v13 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v12 + 32))(v12, 72, 8);
      *(_DWORD *)v13 = 1;
      *(_QWORD *)(v13 + 8) = "aimConstraints";
      *(_QWORD *)(v13 + 16) = &qword_2540F9700;
      *(_QWORD *)(v13 + 24) = 0;
      *(_QWORD *)(v13 + 32) = 0x7800000004;
      *(_DWORD *)(v13 + 40) = 0;
      *(_QWORD *)(v13 + 48) = 0;
      *(_QWORD *)(v13 + 56) = 0;
      *(_DWORD *)(v13 + 64) = 0;
      qword_2558304A8 = v13;
      v14 = re::introspectionAllocator((re *)v13);
      re::IntrospectionInfo<re::DynamicArray<re::RigNodeChannel>>::get();
      v15 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v14 + 32))(v14, 72, 8);
      *(_DWORD *)v15 = 1;
      *(_QWORD *)(v15 + 8) = "nodeChannels";
      *(_QWORD *)(v15 + 16) = &qword_2540F9740;
      *(_QWORD *)(v15 + 24) = 0;
      *(_QWORD *)(v15 + 32) = 0xA000000005;
      *(_DWORD *)(v15 + 40) = 0;
      *(_QWORD *)(v15 + 48) = 0;
      *(_QWORD *)(v15 + 56) = 0;
      *(_DWORD *)(v15 + 64) = 0;
      qword_2558304B0 = v15;
      v16 = re::introspectionAllocator((re *)v15);
      v17 = re::introspect_DynamicRegisterTable((re::IntrospectionBase **)1);
      v18 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v16 + 32))(v16, 72, 8);
      *(_DWORD *)v18 = 1;
      *(_QWORD *)(v18 + 8) = "constantValues";
      *(_QWORD *)(v18 + 16) = v17;
      *(_QWORD *)(v18 + 24) = 0;
      *(_QWORD *)(v18 + 32) = 0xC800000006;
      *(_DWORD *)(v18 + 40) = 0;
      *(_QWORD *)(v18 + 48) = 0;
      *(_QWORD *)(v18 + 56) = 0;
      *(_DWORD *)(v18 + 64) = 0;
      qword_2558304B8 = v18;
      v19 = re::introspectionAllocator((re *)v18);
      re::IntrospectionInfo<re::DynamicArray<re::RigNodeConstant>>::get();
      v20 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v19 + 32))(v19, 72, 8);
      *(_DWORD *)v20 = 1;
      *(_QWORD *)(v20 + 8) = "rigNodeConstants";
      *(_QWORD *)(v20 + 16) = &qword_2540F9780;
      *(_QWORD *)(v20 + 24) = 0;
      *(_QWORD *)(v20 + 32) = 0x20800000007;
      *(_DWORD *)(v20 + 40) = 0;
      *(_QWORD *)(v20 + 48) = 0;
      *(_QWORD *)(v20 + 56) = 0;
      *(_DWORD *)(v20 + 64) = 0;
      qword_2558304C0 = v20;
      v21 = re::introspectionAllocator((re *)v20);
      re::IntrospectionInfo<unsigned long [8]>::get((uint64_t)v21, v22);
      v23 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v21 + 32))(v21, 72, 8);
      *(_DWORD *)v23 = 1;
      *(_QWORD *)(v23 + 8) = "temporaryValueCounts";
      *(_QWORD *)(v23 + 16) = &unk_2540F9CF8;
      *(_QWORD *)(v23 + 24) = 0;
      *(_QWORD *)(v23 + 32) = 0x23000000008;
      *(_DWORD *)(v23 + 40) = 0;
      *(_QWORD *)(v23 + 48) = 0;
      *(_QWORD *)(v23 + 56) = 0;
      *(_DWORD *)(v23 + 64) = 0;
      qword_2558304C8 = v23;
      v24 = re::introspectionAllocator((re *)v23);
      re::IntrospectionInfo<re::DynamicArray<re::RigNodeTemporaryValue>>::get();
      v25 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v24 + 32))(v24, 72, 8);
      *(_DWORD *)v25 = 1;
      *(_QWORD *)(v25 + 8) = "rigNodeTemporaryValues";
      *(_QWORD *)(v25 + 16) = &qword_2540F97C0;
      *(_QWORD *)(v25 + 24) = 0;
      *(_QWORD *)(v25 + 32) = 0x27000000009;
      *(_DWORD *)(v25 + 40) = 0;
      *(_QWORD *)(v25 + 48) = 0;
      *(_QWORD *)(v25 + 56) = 0;
      *(_DWORD *)(v25 + 64) = 0;
      qword_2558304D0 = v25;
      v26 = re::introspectionAllocator((re *)v25);
      re::IntrospectionInfo<re::DynamicArray<re::RigExpressionParameter>>::get();
      v27 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v26 + 32))(v26, 72, 8);
      *(_DWORD *)v27 = 1;
      *(_QWORD *)(v27 + 8) = "expressionParameters";
      *(_QWORD *)(v27 + 16) = &qword_2540F9800;
      *(_QWORD *)(v27 + 24) = 0;
      *(_QWORD *)(v27 + 32) = 0x2980000000ALL;
      *(_DWORD *)(v27 + 40) = 0;
      *(_QWORD *)(v27 + 48) = 0;
      *(_QWORD *)(v27 + 56) = 0;
      *(_DWORD *)(v27 + 64) = 0;
      qword_2558304D8 = v27;
      v28 = re::introspectionAllocator((re *)v27);
      re::IntrospectionInfo<re::DynamicArray<re::RigExpression>>::get();
      v29 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v28 + 32))(v28, 72, 8);
      *(_DWORD *)v29 = 1;
      *(_QWORD *)(v29 + 8) = "expressions";
      *(_QWORD *)(v29 + 16) = &qword_2540F9840;
      *(_QWORD *)(v29 + 24) = 0;
      *(_QWORD *)(v29 + 32) = 0x2C00000000BLL;
      *(_DWORD *)(v29 + 40) = 0;
      *(_QWORD *)(v29 + 48) = 0;
      *(_QWORD *)(v29 + 56) = 0;
      *(_DWORD *)(v29 + 64) = 0;
      qword_2558304E0 = v29;
      v30 = re::introspectionAllocator((re *)v29);
      re::IntrospectionInfo<re::DynamicArray<re::RigTwoBoneIKHandles>>::get();
      v31 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v30 + 32))(v30, 72, 8);
      *(_DWORD *)v31 = 1;
      *(_QWORD *)(v31 + 8) = "twoBoneIKHandles";
      *(_QWORD *)(v31 + 16) = &qword_2540F9880;
      *(_QWORD *)(v31 + 24) = 0;
      *(_QWORD *)(v31 + 32) = 0x2E80000000CLL;
      *(_DWORD *)(v31 + 40) = 0;
      *(_QWORD *)(v31 + 48) = 0;
      *(_QWORD *)(v31 + 56) = 0;
      *(_DWORD *)(v31 + 64) = 0;
      qword_2558304E8 = v31;
      v32 = re::introspectionAllocator((re *)v31);
      re::IntrospectionInfo<re::DynamicArray<re::RigSingleChainIKHandles>>::get();
      v33 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v32 + 32))(v32, 72, 8);
      *(_DWORD *)v33 = 1;
      *(_QWORD *)(v33 + 8) = "singleChainIKHandles";
      *(_QWORD *)(v33 + 16) = &qword_2540F98C0;
      *(_QWORD *)(v33 + 24) = 0;
      *(_QWORD *)(v33 + 32) = 0x3100000000DLL;
      *(_DWORD *)(v33 + 40) = 0;
      *(_QWORD *)(v33 + 48) = 0;
      *(_QWORD *)(v33 + 56) = 0;
      *(_DWORD *)(v33 + 64) = 0;
      qword_2558304F0 = v33;
      v34 = re::introspectionAllocator((re *)v33);
      re::IntrospectionInfo<re::DynamicArray<re::RigSplineIKHandle>>::get();
      v35 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v34 + 32))(v34, 72, 8);
      *(_DWORD *)v35 = 1;
      *(_QWORD *)(v35 + 8) = "splineIKHandles";
      *(_QWORD *)(v35 + 16) = &qword_2540F9900;
      *(_QWORD *)(v35 + 24) = 0;
      *(_QWORD *)(v35 + 32) = 0x3380000000ELL;
      *(_DWORD *)(v35 + 40) = 0;
      *(_QWORD *)(v35 + 48) = 0;
      *(_QWORD *)(v35 + 56) = 0;
      *(_DWORD *)(v35 + 64) = 0;
      qword_2558304F8 = v35;
      v36 = re::introspectionAllocator((re *)v35);
      re::IntrospectionInfo<re::DynamicArray<re::RigTransform>>::get();
      v37 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v36 + 32))(v36, 72, 8);
      *(_DWORD *)v37 = 1;
      *(_QWORD *)(v37 + 8) = "transforms";
      *(_QWORD *)(v37 + 16) = &qword_2540F9940;
      *(_QWORD *)(v37 + 24) = 0;
      *(_QWORD *)(v37 + 32) = 0x3600000000FLL;
      *(_DWORD *)(v37 + 40) = 0;
      *(_QWORD *)(v37 + 48) = 0;
      *(_QWORD *)(v37 + 56) = 0;
      *(_DWORD *)(v37 + 64) = 0;
      qword_255830500 = v37;
      v38 = re::introspectionAllocator((re *)v37);
      re::IntrospectionInfo<re::DynamicArray<re::RigJoint>>::get();
      v39 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v38 + 32))(v38, 72, 8);
      *(_DWORD *)v39 = 1;
      *(_QWORD *)(v39 + 8) = "joints";
      *(_QWORD *)(v39 + 16) = &qword_2540F9980;
      *(_QWORD *)(v39 + 24) = 0;
      *(_QWORD *)(v39 + 32) = 0x38800000010;
      *(_DWORD *)(v39 + 40) = 0;
      *(_QWORD *)(v39 + 48) = 0;
      *(_QWORD *)(v39 + 56) = 0;
      *(_DWORD *)(v39 + 64) = 0;
      qword_255830508 = v39;
      v40 = re::introspectionAllocator((re *)v39);
      re::IntrospectionInfo<re::DynamicArray<re::RigNodeConstraint>>::get();
      v41 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v40 + 32))(v40, 72, 8);
      *(_DWORD *)v41 = 1;
      *(_QWORD *)(v41 + 8) = "constraints";
      *(_QWORD *)(v41 + 16) = &qword_2540F99C0;
      *(_QWORD *)(v41 + 24) = 0;
      *(_QWORD *)(v41 + 32) = 0x3B000000011;
      *(_DWORD *)(v41 + 40) = 0;
      *(_QWORD *)(v41 + 48) = 0;
      *(_QWORD *)(v41 + 56) = 0;
      *(_DWORD *)(v41 + 64) = 0;
      qword_255830510 = v41;
      v42 = re::introspectionAllocator((re *)v41);
      re::IntrospectionInfo<re::DynamicArray<re::RigIKHandles>>::get();
      v43 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v42 + 32))(v42, 72, 8);
      *(_DWORD *)v43 = 1;
      *(_QWORD *)(v43 + 8) = "ikHandles";
      *(_QWORD *)(v43 + 16) = &qword_2540F9A00;
      *(_QWORD *)(v43 + 24) = 0;
      *(_QWORD *)(v43 + 32) = 0x3D800000012;
      *(_DWORD *)(v43 + 40) = 0;
      *(_QWORD *)(v43 + 48) = 0;
      *(_QWORD *)(v43 + 56) = 0;
      *(_DWORD *)(v43 + 64) = 0;
      qword_255830518 = v43;
      v44 = re::introspectionAllocator((re *)v43);
      re::IntrospectionInfo<re::DynamicArray<re::RigNode>>::get();
      v45 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v44 + 32))(v44, 72, 8);
      *(_DWORD *)v45 = 1;
      *(_QWORD *)(v45 + 8) = "rigNodes";
      *(_QWORD *)(v45 + 16) = &qword_2540F9A40;
      *(_QWORD *)(v45 + 24) = 0;
      *(_QWORD *)(v45 + 32) = 0x40000000013;
      *(_DWORD *)(v45 + 40) = 0;
      *(_QWORD *)(v45 + 48) = 0;
      *(_QWORD *)(v45 + 56) = 0;
      *(_DWORD *)(v45 + 64) = 0;
      qword_255830520 = v45;
      v46 = re::introspectionAllocator((re *)v45);
      re::IntrospectionInfo<re::DynamicArray<re::RigPoseNode>>::get();
      v47 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v46 + 32))(v46, 72, 8);
      *(_DWORD *)v47 = 1;
      *(_QWORD *)(v47 + 8) = "poseNodes";
      *(_QWORD *)(v47 + 16) = &qword_2540F9A80;
      *(_QWORD *)(v47 + 24) = 0;
      *(_QWORD *)(v47 + 32) = 0x42800000014;
      *(_DWORD *)(v47 + 40) = 0;
      *(_QWORD *)(v47 + 48) = 0;
      *(_QWORD *)(v47 + 56) = 0;
      *(_DWORD *)(v47 + 64) = 0;
      qword_255830528 = v47;
      v48 = re::introspectionAllocator((re *)v47);
      re::IntrospectionInfo<re::DynamicArray<re::RigPose>>::get();
      v49 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v48 + 32))(v48, 72, 8);
      *(_DWORD *)v49 = 1;
      *(_QWORD *)(v49 + 8) = "rigPoses";
      *(_QWORD *)(v49 + 16) = &qword_2540F9AC0;
      *(_QWORD *)(v49 + 24) = 0;
      *(_QWORD *)(v49 + 32) = 0x45000000015;
      *(_DWORD *)(v49 + 40) = 0;
      *(_QWORD *)(v49 + 48) = 0;
      *(_QWORD *)(v49 + 56) = 0;
      *(_DWORD *)(v49 + 64) = 0;
      qword_255830530 = v49;
      __cxa_guard_release(&qword_2540F9218);
    }
  }
  *((_QWORD *)this + 2) = 0x47800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 21;
  *((_QWORD *)this + 8) = &qword_255830490;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::RigDefinition>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::RigDefinition>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::RigDefinition>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::RigDefinition>;
  re::IntrospectionRegistry::add(this, v3);
  v50 = v52;
}

void re::IntrospectionInfo<re::DynamicArray<re::RigComponentConstraint>>::get()
{
  unsigned __int8 v0;
  uint64_t *v1;
  unsigned __int8 v2;
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  int v5;
  re::IntrospectionRegistry *v6;
  const re::IntrospectionBase *v7;
  const char *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  re *v13;
  uint64_t *v14;
  const re::IntrospectionBase *v15;
  uint64_t v16;
  uint64_t *v17;
  const re::IntrospectionBase *v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t *v21;
  const re::IntrospectionBase *v22;
  uint64_t *v23;
  uint64_t v24;
  __int128 v25;
  __int128 v26;
  uint64_t v27[2];
  __int128 v28;
  const char *v29;
  __int128 v30;

  v0 = atomic_load((unsigned __int8 *)&qword_2540F9238);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_2540F9238))
  {
    re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_2540F9680);
    qword_2540F9680 = (uint64_t)&off_24ED22AF8;
    __cxa_guard_release(&qword_2540F9238);
  }
  if ((byte_2540F8FA1 & 1) == 0)
  {
    v1 = (uint64_t *)qword_2540F8FF0;
    if (qword_2540F8FF0)
      goto LABEL_7;
    v2 = atomic_load((unsigned __int8 *)&qword_2540F8FE0);
    if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_2540F8FE0))
    {
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540F9DB8, 0);
      *(_QWORD *)(v12 + 22) = 0;
      qword_2540F9DC8 = 0;
      *(_QWORD *)&xmmword_2540F9DD8 = 0;
      *((_QWORD *)&xmmword_2540F9DD8 + 1) = 0xFFFFFFFFLL;
      qword_2540F9DB8 = (uint64_t)&off_24ED7DAA8;
      qword_2540F9DE8 = (uint64_t)"RigComponentConstraint";
      dword_2540F9DF0 = 0;
      xmmword_2540F9DF8 = 0u;
      xmmword_2540F9E08 = 0u;
      xmmword_2540F9E18 = 0u;
      qword_2540F9E28 = 0;
      __cxa_guard_release(&qword_2540F8FE0);
    }
    qword_2540F8FF0 = (uint64_t)&qword_2540F9DB8;
    *(_QWORD *)&v30 = 0x58E39F8DB27A6F54;
    *((_QWORD *)&v30 + 1) = "RigComponentConstraint";
    re::StringID::destroyString((re::StringID *)&v30);
    xmmword_2540F9DD8 = v28;
    v4 = atomic_load((unsigned __int8 *)&qword_2540F8FE8);
    if ((v4 & 1) == 0)
    {
      v13 = (re *)__cxa_guard_acquire(&qword_2540F8FE8);
      if ((_DWORD)v13)
      {
        v14 = re::introspectionAllocator(v13);
        re::IntrospectionInfo<BOOL [3]>::get((uint64_t)v14, v15);
        v16 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v14 + 32))(v14, 72, 8);
        *(_DWORD *)v16 = 1;
        *(_QWORD *)(v16 + 8) = "constraintComponents";
        *(_QWORD *)(v16 + 16) = &unk_2540F9CB0;
        *(_QWORD *)(v16 + 24) = 0;
        *(_QWORD *)(v16 + 32) = 1;
        *(_DWORD *)(v16 + 40) = 0;
        *(_QWORD *)(v16 + 48) = 0;
        *(_QWORD *)(v16 + 56) = 0;
        *(_DWORD *)(v16 + 64) = 0;
        qword_2540F9350 = v16;
        v17 = re::introspectionAllocator((re *)v16);
        v19 = re::IntrospectionInfo<re::DynamicArray<unsigned long>>::get(1, v18);
        v20 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v17 + 32))(v17, 72, 8);
        *(_DWORD *)v20 = 1;
        *(_QWORD *)(v20 + 8) = "constraintNodeIndices";
        *(_QWORD *)(v20 + 16) = v19;
        *(_QWORD *)(v20 + 24) = 0;
        *(_QWORD *)(v20 + 32) = 0x800000002;
        *(_DWORD *)(v20 + 40) = 0;
        *(_QWORD *)(v20 + 48) = 0;
        *(_QWORD *)(v20 + 56) = 0;
        *(_DWORD *)(v20 + 64) = 0;
        qword_2540F9358 = v20;
        v21 = re::introspectionAllocator((re *)v20);
        v23 = re::IntrospectionInfo<re::DynamicArray<float>>::get(1, v22);
        v24 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v21 + 32))(v21, 72, 8);
        *(_DWORD *)v24 = 1;
        *(_QWORD *)(v24 + 8) = "constraintNodeWeights";
        *(_QWORD *)(v24 + 16) = v23;
        *(_QWORD *)(v24 + 24) = 0;
        *(_QWORD *)(v24 + 32) = 0x3000000003;
        *(_DWORD *)(v24 + 40) = 0;
        *(_QWORD *)(v24 + 48) = 0;
        *(_QWORD *)(v24 + 56) = 0;
        *(_DWORD *)(v24 + 64) = 0;
        qword_2540F9360 = v24;
        __cxa_guard_release(&qword_2540F8FE8);
      }
    }
    qword_2540F9DC8 = 0x5800000008;
    v1 = &qword_2540F9DB8;
    dword_2540F9DD0 = 8;
    word_2540F9DD4 = 0;
    dword_2540F9DF0 = 3;
    *(_QWORD *)&xmmword_2540F9DF8 = &qword_2540F9350;
    *((_QWORD *)&xmmword_2540F9DF8 + 1) = re::internal::defaultConstruct<re::RigComponentConstraint>;
    *(_QWORD *)&xmmword_2540F9E08 = re::internal::defaultDestruct<re::RigComponentConstraint>;
    *(_QWORD *)&xmmword_2540F9E18 = 0;
    *((_QWORD *)&xmmword_2540F9E08 + 1) = 0;
    *((_QWORD *)&xmmword_2540F9E18 + 1) = re::internal::defaultConstructV2<re::RigComponentConstraint>;
    qword_2540F9E28 = (uint64_t)re::internal::defaultDestructV2<re::RigComponentConstraint>;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_2540F9DB8, v3);
    v30 = v28;
    if ((byte_2540F8FA1 & 1) == 0)
    {
LABEL_7:
      byte_2540F8FA1 = 1;
      v5 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540F9680, 0);
      qword_2540F9690 = 0x2800000003;
      dword_2540F9698 = v5;
      word_2540F969C = 0;
      *(_QWORD *)&xmmword_2540F96A0 = 0;
      *((_QWORD *)&xmmword_2540F96A0 + 1) = 0xFFFFFFFFLL;
      qword_2540F96B0 = (uint64_t)v1;
      qword_2540F96B8 = 0;
      qword_2540F9680 = (uint64_t)&off_24ED22AF8;
      re::IntrospectionRegistry::add(v6, v7);
      re::getPrettyTypeName((re *)&qword_2540F9680, (const re::IntrospectionBase *)&v28);
      if ((BYTE8(v28) & 1) != 0)
        v8 = v29;
      else
        v8 = (char *)&v28 + 9;
      if ((_QWORD)v28 && (BYTE8(v28) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v28 + 40))();
      v26 = *((_OWORD *)v1 + 2);
      v9 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v27);
      if (v9)
      {
        v10 = *v9;
        *((_QWORD *)&v25 + 1) = v10;
      }
      else
      {
        v30 = v26;
        re::TypeBuilder::beginListType((uint64_t)&v28, v27, 1, 0x28uLL, 8uLL, &v30);
        re::TypeBuilder::setConstructor((uint64_t)&v28, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigComponentConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v28, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigComponentConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v28, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v28, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigComponentConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigComponentConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v28, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::RigComponentConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v28, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigComponentConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::RigComponentConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigComponentConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v28, v11);
      }
      xmmword_2540F96A0 = v25;
      re::StringID::destroyString((re::StringID *)v27);
    }
  }
}

void re::IntrospectionInfo<re::DynamicArray<re::RigBasicConstraint>>::get()
{
  unsigned __int8 v0;
  uint64_t *v1;
  unsigned __int8 v2;
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  int v5;
  re::IntrospectionRegistry *v6;
  const re::IntrospectionBase *v7;
  const char *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  re *v13;
  uint64_t *v14;
  const re::IntrospectionBase *v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t *v18;
  const re::IntrospectionBase *v19;
  uint64_t *v20;
  uint64_t v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24[2];
  __int128 v25;
  const char *v26;
  __int128 v27;

  v0 = atomic_load((unsigned __int8 *)&qword_2540F9240);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_2540F9240))
  {
    re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_2540F96C0);
    qword_2540F96C0 = (uint64_t)&off_24ED22B90;
    __cxa_guard_release(&qword_2540F9240);
  }
  if ((byte_2540F8FA2 & 1) == 0)
  {
    v1 = (uint64_t *)qword_2540F8FD8;
    if (qword_2540F8FD8)
      goto LABEL_7;
    v2 = atomic_load((unsigned __int8 *)&qword_2540F8FC8);
    if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_2540F8FC8))
    {
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540F9D40, 0);
      *(_QWORD *)(v12 + 22) = 0;
      qword_2540F9D50 = 0;
      *(_QWORD *)&xmmword_2540F9D60 = 0;
      *((_QWORD *)&xmmword_2540F9D60 + 1) = 0xFFFFFFFFLL;
      qword_2540F9D40 = (uint64_t)&off_24ED7DAA8;
      qword_2540F9D70 = (uint64_t)"RigBasicConstraint";
      dword_2540F9D78 = 0;
      *(_OWORD *)(v12 + 64) = 0u;
      *(_OWORD *)(v12 + 80) = 0u;
      *(_OWORD *)(v12 + 96) = 0u;
      qword_2540F9DB0 = 0;
      __cxa_guard_release(&qword_2540F8FC8);
    }
    qword_2540F8FD8 = (uint64_t)&qword_2540F9D40;
    *(_QWORD *)&v27 = 0xA7153225B4A8BB36;
    *((_QWORD *)&v27 + 1) = "RigBasicConstraint";
    re::StringID::destroyString((re::StringID *)&v27);
    xmmword_2540F9D60 = v25;
    v4 = atomic_load((unsigned __int8 *)&qword_2540F8FD0);
    if ((v4 & 1) == 0)
    {
      v13 = (re *)__cxa_guard_acquire(&qword_2540F8FD0);
      if ((_DWORD)v13)
      {
        v14 = re::introspectionAllocator(v13);
        v16 = re::IntrospectionInfo<re::DynamicArray<unsigned long>>::get(1, v15);
        v17 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v14 + 32))(v14, 72, 8);
        *(_DWORD *)v17 = 1;
        *(_QWORD *)(v17 + 8) = "constraintNodeIndices";
        *(_QWORD *)(v17 + 16) = v16;
        *(_QWORD *)(v17 + 24) = 0;
        *(_QWORD *)(v17 + 32) = 1;
        *(_DWORD *)(v17 + 40) = 0;
        *(_QWORD *)(v17 + 48) = 0;
        *(_QWORD *)(v17 + 56) = 0;
        *(_DWORD *)(v17 + 64) = 0;
        qword_2540F92D0 = v17;
        v18 = re::introspectionAllocator((re *)v17);
        v20 = re::IntrospectionInfo<re::DynamicArray<float>>::get(1, v19);
        v21 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v18 + 32))(v18, 72, 8);
        *(_DWORD *)v21 = 1;
        *(_QWORD *)(v21 + 8) = "constraintNodeWeights";
        *(_QWORD *)(v21 + 16) = v20;
        *(_QWORD *)(v21 + 24) = 0;
        *(_QWORD *)(v21 + 32) = 0x2800000002;
        *(_DWORD *)(v21 + 40) = 0;
        *(_QWORD *)(v21 + 48) = 0;
        *(_QWORD *)(v21 + 56) = 0;
        *(_DWORD *)(v21 + 64) = 0;
        qword_2540F92D8 = v21;
        __cxa_guard_release(&qword_2540F8FD0);
      }
    }
    qword_2540F9D50 = 0x5000000008;
    v1 = &qword_2540F9D40;
    dword_2540F9D58 = 8;
    word_2540F9D5C = 0;
    dword_2540F9D78 = 2;
    qword_2540F9D80 = (uint64_t)&qword_2540F92D0;
    qword_2540F9D88 = (uint64_t)re::internal::defaultConstruct<re::RigBasicConstraint>;
    qword_2540F9D90 = (uint64_t)re::internal::defaultDestruct<re::RigBasicConstraint>;
    qword_2540F9DA0 = 0;
    qword_2540F9D98 = 0;
    qword_2540F9DA8 = (uint64_t)re::internal::defaultConstructV2<re::RigBasicConstraint>;
    qword_2540F9DB0 = (uint64_t)re::internal::defaultDestructV2<re::RigBasicConstraint>;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_2540F9D40, v3);
    v27 = v25;
    if ((byte_2540F8FA2 & 1) == 0)
    {
LABEL_7:
      byte_2540F8FA2 = 1;
      v5 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540F96C0, 0);
      qword_2540F96D0 = 0x2800000003;
      dword_2540F96D8 = v5;
      word_2540F96DC = 0;
      *(_QWORD *)&xmmword_2540F96E0 = 0;
      *((_QWORD *)&xmmword_2540F96E0 + 1) = 0xFFFFFFFFLL;
      qword_2540F96F0 = (uint64_t)v1;
      qword_2540F96F8 = 0;
      qword_2540F96C0 = (uint64_t)&off_24ED22B90;
      re::IntrospectionRegistry::add(v6, v7);
      re::getPrettyTypeName((re *)&qword_2540F96C0, (const re::IntrospectionBase *)&v25);
      if ((BYTE8(v25) & 1) != 0)
        v8 = v26;
      else
        v8 = (char *)&v25 + 9;
      if ((_QWORD)v25 && (BYTE8(v25) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v25 + 40))();
      v23 = *((_OWORD *)v1 + 2);
      v9 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v24);
      if (v9)
      {
        v10 = *v9;
        *((_QWORD *)&v22 + 1) = v10;
      }
      else
      {
        v27 = v23;
        re::TypeBuilder::beginListType((uint64_t)&v25, v24, 1, 0x28uLL, 8uLL, &v27);
        re::TypeBuilder::setConstructor((uint64_t)&v25, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigBasicConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v25, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigBasicConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v25, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v25, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigBasicConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigBasicConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v25, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::RigBasicConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v25, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigBasicConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::RigBasicConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigBasicConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v25, v11);
      }
      xmmword_2540F96E0 = v22;
      re::StringID::destroyString((re::StringID *)v24);
    }
  }
}

void re::IntrospectionInfo<re::DynamicArray<re::RigAimConstraint>>::get()
{
  unsigned __int8 v0;
  uint64_t *v1;
  unsigned __int8 v2;
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  int v5;
  re::IntrospectionRegistry *v6;
  const re::IntrospectionBase *v7;
  const char *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  re *v13;
  uint64_t *v14;
  const re::IntrospectionBase *v15;
  uint64_t v16;
  uint64_t *v17;
  const re::IntrospectionBase *v18;
  uint64_t v19;
  uint64_t *v20;
  const re::IntrospectionBase *v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t *v29;
  const re::IntrospectionBase *v30;
  uint64_t *v31;
  uint64_t v32;
  uint64_t *v33;
  const re::IntrospectionBase *v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t *v37;
  const re::IntrospectionBase *v38;
  void *v39;
  uint64_t v40;
  __int128 v41;
  __int128 v42;
  uint64_t v43[2];
  __int128 v44;
  const char *v45;
  __int128 v46;

  v0 = atomic_load((unsigned __int8 *)&qword_2540F9248);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_2540F9248))
  {
    re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_2540F9700);
    qword_2540F9700 = (uint64_t)&off_24ED22C28;
    __cxa_guard_release(&qword_2540F9248);
  }
  if ((byte_2540F8FA3 & 1) == 0)
  {
    v1 = (uint64_t *)qword_2540F9018;
    if (qword_2540F9018)
      goto LABEL_7;
    v2 = atomic_load((unsigned __int8 *)&qword_2540F9008);
    if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_2540F9008))
    {
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540F9E30, 0);
      *(_QWORD *)(v12 + 22) = 0;
      qword_2540F9E40 = 0;
      *(_QWORD *)&xmmword_2540F9E50 = 0;
      *((_QWORD *)&xmmword_2540F9E50 + 1) = 0xFFFFFFFFLL;
      qword_2540F9E30 = (uint64_t)&off_24ED7DAA8;
      qword_2540F9E60 = (uint64_t)"RigAimConstraint";
      dword_2540F9E68 = 0;
      *(_OWORD *)(v12 + 64) = 0u;
      *(_OWORD *)(v12 + 80) = 0u;
      *(_OWORD *)(v12 + 96) = 0u;
      qword_2540F9EA0 = 0;
      __cxa_guard_release(&qword_2540F9008);
    }
    qword_2540F9018 = (uint64_t)&qword_2540F9E30;
    *(_QWORD *)&v46 = 0x979D610D07DC9BE4;
    *((_QWORD *)&v46 + 1) = "RigAimConstraint";
    re::StringID::destroyString((re::StringID *)&v46);
    xmmword_2540F9E50 = v44;
    v4 = atomic_load((unsigned __int8 *)&qword_2540F9010);
    if ((v4 & 1) == 0)
    {
      v13 = (re *)__cxa_guard_acquire(&qword_2540F9010);
      if ((_DWORD)v13)
      {
        v14 = re::introspectionAllocator(v13);
        re::IntrospectionInfo<BOOL [3]>::get((uint64_t)v14, v15);
        v16 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v14 + 32))(v14, 72, 8);
        *(_DWORD *)v16 = 1;
        *(_QWORD *)(v16 + 8) = "constraintComponents";
        *(_QWORD *)(v16 + 16) = &unk_2540F9CB0;
        *(_QWORD *)(v16 + 24) = 0;
        *(_QWORD *)(v16 + 32) = 1;
        *(_DWORD *)(v16 + 40) = 0;
        *(_QWORD *)(v16 + 48) = 0;
        *(_QWORD *)(v16 + 56) = 0;
        *(_DWORD *)(v16 + 64) = 0;
        qword_2540F95C0 = v16;
        v17 = re::introspectionAllocator((re *)v16);
        re::introspect_RigAimAxisType((re *)v17, v18);
        v19 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v17 + 32))(v17, 72, 8);
        *(_DWORD *)v19 = 1;
        *(_QWORD *)(v19 + 8) = "forwardAxisType";
        *(_QWORD *)(v19 + 16) = &qword_2540F9B48;
        *(_QWORD *)(v19 + 24) = 0;
        *(_QWORD *)(v19 + 32) = 0x300000002;
        *(_DWORD *)(v19 + 40) = 0;
        *(_QWORD *)(v19 + 48) = 0;
        *(_QWORD *)(v19 + 56) = 0;
        *(_DWORD *)(v19 + 64) = 0;
        qword_2540F95C8 = v19;
        v20 = re::introspectionAllocator((re *)v19);
        re::introspect_RigAimAxisType((re *)v20, v21);
        v22 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v20 + 32))(v20, 72, 8);
        *(_DWORD *)v22 = 1;
        *(_QWORD *)(v22 + 8) = "upAxisType";
        *(_QWORD *)(v22 + 16) = &qword_2540F9B48;
        *(_QWORD *)(v22 + 24) = 0;
        *(_QWORD *)(v22 + 32) = 0x400000003;
        *(_DWORD *)(v22 + 40) = 0;
        *(_QWORD *)(v22 + 48) = 0;
        *(_QWORD *)(v22 + 56) = 0;
        *(_DWORD *)(v22 + 64) = 0;
        qword_2540F95D0 = v22;
        v23 = re::introspectionAllocator((re *)v22);
        v24 = re::introspect_Vector3F((re::IntrospectionBase **)1);
        v25 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v23 + 32))(v23, 72, 8);
        *(_DWORD *)v25 = 1;
        *(_QWORD *)(v25 + 8) = "aimAxisForward";
        *(_QWORD *)(v25 + 16) = v24;
        *(_QWORD *)(v25 + 24) = 0;
        *(_QWORD *)(v25 + 32) = 0x1000000004;
        *(_DWORD *)(v25 + 40) = 0;
        *(_QWORD *)(v25 + 48) = 0;
        *(_QWORD *)(v25 + 56) = 0;
        *(_DWORD *)(v25 + 64) = 0;
        qword_2540F95D8 = v25;
        v26 = re::introspectionAllocator((re *)v25);
        v27 = re::introspect_Vector3F((re::IntrospectionBase **)1);
        v28 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v26 + 32))(v26, 72, 8);
        *(_DWORD *)v28 = 1;
        *(_QWORD *)(v28 + 8) = "aimAxisUp";
        *(_QWORD *)(v28 + 16) = v27;
        *(_QWORD *)(v28 + 24) = 0;
        *(_QWORD *)(v28 + 32) = 0x2000000005;
        *(_DWORD *)(v28 + 40) = 0;
        *(_QWORD *)(v28 + 48) = 0;
        *(_QWORD *)(v28 + 56) = 0;
        *(_DWORD *)(v28 + 64) = 0;
        qword_2540F95E0 = v28;
        v29 = re::introspectionAllocator((re *)v28);
        v31 = re::IntrospectionInfo<re::DynamicArray<unsigned long>>::get(1, v30);
        v32 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v29 + 32))(v29, 72, 8);
        *(_DWORD *)v32 = 1;
        *(_QWORD *)(v32 + 8) = "forwardConstraintNodeIndices";
        *(_QWORD *)(v32 + 16) = v31;
        *(_QWORD *)(v32 + 24) = 0;
        *(_QWORD *)(v32 + 32) = 0x3000000006;
        *(_DWORD *)(v32 + 40) = 0;
        *(_QWORD *)(v32 + 48) = 0;
        *(_QWORD *)(v32 + 56) = 0;
        *(_DWORD *)(v32 + 64) = 0;
        qword_2540F95E8 = v32;
        v33 = re::introspectionAllocator((re *)v32);
        v35 = re::IntrospectionInfo<re::DynamicArray<float>>::get(1, v34);
        v36 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v33 + 32))(v33, 72, 8);
        *(_DWORD *)v36 = 1;
        *(_QWORD *)(v36 + 8) = "forwardConstraintWeights";
        *(_QWORD *)(v36 + 16) = v35;
        *(_QWORD *)(v36 + 24) = 0;
        *(_QWORD *)(v36 + 32) = 0x5800000007;
        *(_DWORD *)(v36 + 40) = 0;
        *(_QWORD *)(v36 + 48) = 0;
        *(_QWORD *)(v36 + 56) = 0;
        *(_DWORD *)(v36 + 64) = 0;
        qword_2540F95F0 = v36;
        v37 = re::introspectionAllocator((re *)v36);
        v39 = re::introspect_size_t((re *)1, v38);
        v40 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v37 + 32))(v37, 72, 8);
        *(_DWORD *)v40 = 1;
        *(_QWORD *)(v40 + 8) = "upConstraintNodeIndex";
        *(_QWORD *)(v40 + 16) = v39;
        *(_QWORD *)(v40 + 24) = 0;
        *(_QWORD *)(v40 + 32) = 0x8000000008;
        *(_DWORD *)(v40 + 40) = 0;
        *(_QWORD *)(v40 + 48) = 0;
        *(_QWORD *)(v40 + 56) = 0;
        *(_DWORD *)(v40 + 64) = 0;
        qword_2540F95F8 = v40;
        __cxa_guard_release(&qword_2540F9010);
      }
    }
    qword_2540F9E40 = 0x9000000008;
    v1 = &qword_2540F9E30;
    dword_2540F9E48 = 16;
    word_2540F9E4C = 0;
    dword_2540F9E68 = 8;
    qword_2540F9E70 = (uint64_t)&qword_2540F95C0;
    qword_2540F9E78 = (uint64_t)re::internal::defaultConstruct<re::RigAimConstraint>;
    qword_2540F9E80 = (uint64_t)re::internal::defaultDestruct<re::RigAimConstraint>;
    qword_2540F9E90 = 0;
    qword_2540F9E88 = 0;
    qword_2540F9E98 = (uint64_t)re::internal::defaultConstructV2<re::RigAimConstraint>;
    qword_2540F9EA0 = (uint64_t)re::internal::defaultDestructV2<re::RigAimConstraint>;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_2540F9E30, v3);
    v46 = v44;
    if ((byte_2540F8FA3 & 1) == 0)
    {
LABEL_7:
      byte_2540F8FA3 = 1;
      v5 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540F9700, 0);
      qword_2540F9710 = 0x2800000003;
      dword_2540F9718 = v5;
      word_2540F971C = 0;
      *(_QWORD *)&xmmword_2540F9720 = 0;
      *((_QWORD *)&xmmword_2540F9720 + 1) = 0xFFFFFFFFLL;
      qword_2540F9730 = (uint64_t)v1;
      qword_2540F9738 = 0;
      qword_2540F9700 = (uint64_t)&off_24ED22C28;
      re::IntrospectionRegistry::add(v6, v7);
      re::getPrettyTypeName((re *)&qword_2540F9700, (const re::IntrospectionBase *)&v44);
      if ((BYTE8(v44) & 1) != 0)
        v8 = v45;
      else
        v8 = (char *)&v44 + 9;
      if ((_QWORD)v44 && (BYTE8(v44) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v44 + 40))();
      v42 = *((_OWORD *)v1 + 2);
      v9 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v43);
      if (v9)
      {
        v10 = *v9;
        *((_QWORD *)&v41 + 1) = v10;
      }
      else
      {
        v46 = v42;
        re::TypeBuilder::beginListType((uint64_t)&v44, v43, 1, 0x28uLL, 8uLL, &v46);
        re::TypeBuilder::setConstructor((uint64_t)&v44, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigAimConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v44, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigAimConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v44, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v44, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigAimConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigAimConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v44, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::RigAimConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v44, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigAimConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::RigAimConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigAimConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v44, v11);
      }
      xmmword_2540F9720 = v41;
      re::StringID::destroyString((re::StringID *)v43);
    }
  }
}

void re::IntrospectionInfo<re::DynamicArray<re::RigNodeChannel>>::get()
{
  unsigned __int8 v0;
  uint64_t *v1;
  unsigned __int8 v2;
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  int v5;
  re::IntrospectionRegistry *v6;
  const re::IntrospectionBase *v7;
  const char *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  re *v13;
  uint64_t *v14;
  const re::IntrospectionBase *v15;
  uint64_t v16;
  uint64_t *v17;
  const re::IntrospectionBase *v18;
  void *v19;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23[2];
  __int128 v24;
  const char *v25;
  __int128 v26;

  v0 = atomic_load((unsigned __int8 *)&qword_2540F9250);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_2540F9250))
  {
    re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_2540F9740);
    qword_2540F9740 = (uint64_t)&off_24ED22CC0;
    __cxa_guard_release(&qword_2540F9250);
  }
  if ((byte_2540F8FA4 & 1) == 0)
  {
    v1 = (uint64_t *)qword_2540F9040;
    if (qword_2540F9040)
      goto LABEL_7;
    v2 = atomic_load((unsigned __int8 *)&qword_2540F9030);
    if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_2540F9030))
    {
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540F9EA8, 0);
      *(_QWORD *)(v12 + 22) = 0;
      qword_2540F9EB8 = 0;
      *(_QWORD *)&xmmword_2540F9EC8 = 0;
      *((_QWORD *)&xmmword_2540F9EC8 + 1) = 0xFFFFFFFFLL;
      qword_2540F9EA8 = (uint64_t)&off_24ED7DAA8;
      qword_2540F9ED8 = (uint64_t)"RigNodeChannel";
      dword_2540F9EE0 = 0;
      xmmword_2540F9EE8 = 0u;
      xmmword_2540F9EF8 = 0u;
      xmmword_2540F9F08 = 0u;
      qword_2540F9F18 = 0;
      __cxa_guard_release(&qword_2540F9030);
    }
    qword_2540F9040 = (uint64_t)&qword_2540F9EA8;
    *(_QWORD *)&v26 = 0x574CF3CA093CE322;
    *((_QWORD *)&v26 + 1) = "RigNodeChannel";
    re::StringID::destroyString((re::StringID *)&v26);
    xmmword_2540F9EC8 = v24;
    v4 = atomic_load((unsigned __int8 *)&qword_2540F9038);
    if ((v4 & 1) == 0)
    {
      v13 = (re *)__cxa_guard_acquire(&qword_2540F9038);
      if ((_DWORD)v13)
      {
        v14 = re::introspectionAllocator(v13);
        re::introspect_RigNodeChannelType((re *)v14, v15);
        v16 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v14 + 32))(v14, 72, 8);
        *(_DWORD *)v16 = 1;
        *(_QWORD *)(v16 + 8) = "channelType";
        *(_QWORD *)(v16 + 16) = &qword_2540F9B90;
        *(_QWORD *)(v16 + 24) = 0;
        *(_QWORD *)(v16 + 32) = 1;
        *(_DWORD *)(v16 + 40) = 0;
        *(_QWORD *)(v16 + 48) = 0;
        *(_QWORD *)(v16 + 56) = 0;
        *(_DWORD *)(v16 + 64) = 0;
        qword_2540F92E0 = v16;
        v17 = re::introspectionAllocator((re *)v16);
        v19 = re::introspect_size_t((re *)1, v18);
        v20 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v17 + 32))(v17, 72, 8);
        *(_DWORD *)v20 = 1;
        *(_QWORD *)(v20 + 8) = "rigNode";
        *(_QWORD *)(v20 + 16) = v19;
        *(_QWORD *)(v20 + 24) = 0;
        *(_QWORD *)(v20 + 32) = 0x800000002;
        *(_DWORD *)(v20 + 40) = 0;
        *(_QWORD *)(v20 + 48) = 0;
        *(_QWORD *)(v20 + 56) = 0;
        *(_DWORD *)(v20 + 64) = 0;
        qword_2540F92E8 = v20;
        __cxa_guard_release(&qword_2540F9038);
      }
    }
    qword_2540F9EB8 = 0x1000000008;
    v1 = &qword_2540F9EA8;
    dword_2540F9EC0 = 8;
    word_2540F9EC4 = 1;
    dword_2540F9EE0 = 2;
    *(_QWORD *)&xmmword_2540F9EE8 = &qword_2540F92E0;
    *((_QWORD *)&xmmword_2540F9EE8 + 1) = re::internal::defaultConstruct<re::RigNodeChannel>;
    *(_QWORD *)&xmmword_2540F9EF8 = re::internal::defaultDestruct<re::RigNodeChannel>;
    *(_QWORD *)&xmmword_2540F9F08 = 0;
    *((_QWORD *)&xmmword_2540F9EF8 + 1) = 0;
    *((_QWORD *)&xmmword_2540F9F08 + 1) = re::internal::defaultConstructV2<re::RigNodeChannel>;
    qword_2540F9F18 = (uint64_t)re::internal::defaultDestructV2<re::RigNodeChannel>;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_2540F9EA8, v3);
    v26 = v24;
    if ((byte_2540F8FA4 & 1) == 0)
    {
LABEL_7:
      byte_2540F8FA4 = 1;
      v5 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540F9740, 0);
      qword_2540F9750 = 0x2800000003;
      dword_2540F9758 = v5;
      word_2540F975C = 0;
      *(_QWORD *)&xmmword_2540F9760 = 0;
      *((_QWORD *)&xmmword_2540F9760 + 1) = 0xFFFFFFFFLL;
      qword_2540F9770 = (uint64_t)v1;
      qword_2540F9778 = 0;
      qword_2540F9740 = (uint64_t)&off_24ED22CC0;
      re::IntrospectionRegistry::add(v6, v7);
      re::getPrettyTypeName((re *)&qword_2540F9740, (const re::IntrospectionBase *)&v24);
      if ((BYTE8(v24) & 1) != 0)
        v8 = v25;
      else
        v8 = (char *)&v24 + 9;
      if ((_QWORD)v24 && (BYTE8(v24) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v24 + 40))();
      v22 = *((_OWORD *)v1 + 2);
      v9 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v23);
      if (v9)
      {
        v10 = *v9;
        *((_QWORD *)&v21 + 1) = v10;
      }
      else
      {
        v26 = v22;
        re::TypeBuilder::beginListType((uint64_t)&v24, v23, 1, 0x28uLL, 8uLL, &v26);
        re::TypeBuilder::setConstructor((uint64_t)&v24, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigNodeChannel>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v24, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigNodeChannel>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v24, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v24, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigNodeChannel>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigNodeChannel>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v24, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::RigNodeChannel>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v24, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigNodeChannel>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::RigNodeChannel>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigNodeChannel>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v24, v11);
      }
      xmmword_2540F9760 = v21;
      re::StringID::destroyString((re::StringID *)v23);
    }
  }
}

void re::IntrospectionInfo<re::DynamicArray<re::RigNodeConstant>>::get()
{
  unsigned __int8 v0;
  uint64_t *v1;
  unsigned __int8 v2;
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  int v5;
  re::IntrospectionRegistry *v6;
  const re::IntrospectionBase *v7;
  const char *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  re *v12;
  uint64_t *v13;
  const re::IntrospectionBase *v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t *v17;
  const re::IntrospectionBase *v18;
  void *v19;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23[2];
  __int128 v24;
  const char *v25;
  __int128 v26;

  v0 = atomic_load((unsigned __int8 *)&qword_2540F9258);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_2540F9258))
  {
    re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_2540F9780);
    qword_2540F9780 = (uint64_t)&off_24ED22D58;
    __cxa_guard_release(&qword_2540F9258);
  }
  if ((byte_2540F8FA5 & 1) == 0)
  {
    v1 = (uint64_t *)qword_2540F9058;
    if (qword_2540F9058)
      goto LABEL_7;
    v2 = atomic_load((unsigned __int8 *)&qword_2540F9048);
    v1 = &_MergedGlobals_204;
    if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_2540F9048))
    {
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&_MergedGlobals_204, 0);
      *(uint64_t *)((char *)&qword_25582FC30 + 6) = 0;
      qword_25582FC30 = 0;
      *(_QWORD *)&xmmword_25582FC40 = 0;
      *((_QWORD *)&xmmword_25582FC40 + 1) = 0xFFFFFFFFLL;
      _MergedGlobals_204 = (uint64_t)&off_24ED7DAA8;
      qword_25582FC50 = (uint64_t)"RigNodeConstant";
      dword_25582FC58 = 0;
      xmmword_25582FC60 = 0u;
      *(_OWORD *)&qword_25582FC70 = 0u;
      xmmword_25582FC80 = 0u;
      qword_25582FC90 = 0;
      __cxa_guard_release(&qword_2540F9048);
    }
    qword_2540F9058 = (uint64_t)&_MergedGlobals_204;
    *(_QWORD *)&v26 = 0x9251857A2FE701ACLL;
    *((_QWORD *)&v26 + 1) = "RigNodeConstant";
    re::StringID::destroyString((re::StringID *)&v26);
    xmmword_25582FC40 = v24;
    v4 = atomic_load((unsigned __int8 *)&qword_2540F9050);
    if ((v4 & 1) == 0)
    {
      v12 = (re *)__cxa_guard_acquire(&qword_2540F9050);
      if ((_DWORD)v12)
      {
        v13 = re::introspectionAllocator(v12);
        v15 = re::introspect_EvaluationRegisterType((re *)1, v14);
        v16 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v13 + 32))(v13, 72, 8);
        *(_DWORD *)v16 = 1;
        *(_QWORD *)(v16 + 8) = "constantType";
        *(_QWORD *)(v16 + 16) = v15;
        *(_QWORD *)(v16 + 24) = 0;
        *(_QWORD *)(v16 + 32) = 1;
        *(_DWORD *)(v16 + 40) = 0;
        *(_QWORD *)(v16 + 48) = 0;
        *(_QWORD *)(v16 + 56) = 0;
        *(_DWORD *)(v16 + 64) = 0;
        qword_2540F92F0 = v16;
        v17 = re::introspectionAllocator((re *)v16);
        v19 = re::introspect_size_t((re *)1, v18);
        v20 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v17 + 32))(v17, 72, 8);
        *(_DWORD *)v20 = 1;
        *(_QWORD *)(v20 + 8) = "constantIndex";
        *(_QWORD *)(v20 + 16) = v19;
        *(_QWORD *)(v20 + 24) = 0;
        *(_QWORD *)(v20 + 32) = 0x800000002;
        *(_DWORD *)(v20 + 40) = 0;
        *(_QWORD *)(v20 + 48) = 0;
        *(_QWORD *)(v20 + 56) = 0;
        *(_DWORD *)(v20 + 64) = 0;
        qword_2540F92F8 = v20;
        __cxa_guard_release(&qword_2540F9050);
      }
    }
    qword_25582FC30 = 0x1000000008;
    dword_25582FC38 = 8;
    word_25582FC3C = 1;
    dword_25582FC58 = 2;
    *(_QWORD *)&xmmword_25582FC60 = &qword_2540F92F0;
    *((_QWORD *)&xmmword_25582FC60 + 1) = re::internal::defaultConstruct<re::RigNodeConstant>;
    qword_25582FC70 = (uint64_t)re::internal::defaultDestruct<re::RigNodeConstant>;
    unk_25582FC78 = 0;
    *(_QWORD *)&xmmword_25582FC80 = 0;
    *((_QWORD *)&xmmword_25582FC80 + 1) = re::internal::defaultConstructV2<re::RigNodeConstant>;
    qword_25582FC90 = (uint64_t)re::internal::defaultDestructV2<re::RigNodeConstant>;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&_MergedGlobals_204, v3);
    v26 = v24;
    if ((byte_2540F8FA5 & 1) == 0)
    {
LABEL_7:
      byte_2540F8FA5 = 1;
      v5 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540F9780, 0);
      qword_2540F9790 = 0x2800000003;
      dword_2540F9798 = v5;
      word_2540F979C = 0;
      *(_QWORD *)&xmmword_2540F97A0 = 0;
      *((_QWORD *)&xmmword_2540F97A0 + 1) = 0xFFFFFFFFLL;
      qword_2540F97B0 = (uint64_t)v1;
      qword_2540F97B8 = 0;
      qword_2540F9780 = (uint64_t)&off_24ED22D58;
      re::IntrospectionRegistry::add(v6, v7);
      re::getPrettyTypeName((re *)&qword_2540F9780, (const re::IntrospectionBase *)&v24);
      if ((BYTE8(v24) & 1) != 0)
        v8 = v25;
      else
        v8 = (char *)&v24 + 9;
      if ((_QWORD)v24 && (BYTE8(v24) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v24 + 40))();
      v22 = *((_OWORD *)v1 + 2);
      v9 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v23);
      if (v9)
      {
        v10 = *v9;
        *((_QWORD *)&v21 + 1) = v10;
      }
      else
      {
        v26 = v22;
        re::TypeBuilder::beginListType((uint64_t)&v24, v23, 1, 0x28uLL, 8uLL, &v26);
        re::TypeBuilder::setConstructor((uint64_t)&v24, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstant>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v24, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstant>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v24, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v24, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstant>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstant>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v24, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstant>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v24, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstant>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstant>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstant>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v24, v11);
      }
      xmmword_2540F97A0 = v21;
      re::StringID::destroyString((re::StringID *)v23);
    }
  }
}

void re::IntrospectionInfo<unsigned long [8]>::get(uint64_t a1, const re::IntrospectionBase *a2)
{
  unsigned __int8 v2;
  const re::IntrospectionBase *v3;
  re::IntrospectionRegistry *v4;
  const re::IntrospectionBase *v5;
  const char *v6;
  __int128 v7;
  __int128 v8;
  const char *v9;
  uint64_t v10[2];

  v2 = atomic_load((unsigned __int8 *)&qword_2540F9260);
  if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_2540F9260))
  {
    re::IntrospectionCStyleArray::IntrospectionCStyleArray((re::IntrospectionCStyleArray *)&unk_2540F9CF8);
    __cxa_guard_release(&qword_2540F9260);
  }
  if ((byte_2540F8FA6 & 1) == 0)
  {
    byte_2540F8FA6 = 1;
    v3 = (const re::IntrospectionBase *)re::introspect_size_t((re *)1, a2);
    re::IntrospectionCStyleArray::IntrospectionCStyleArray((re::IntrospectionCStyleArray *)&unk_2540F9CF8, v3, 8);
    re::IntrospectionRegistry::add(v4, v5);
    re::getPrettyTypeName((re *)&unk_2540F9CF8, (const re::IntrospectionBase *)&v8);
    if ((BYTE8(v8) & 1) != 0)
      v6 = v9;
    else
      v6 = (char *)&v8 + 9;
    if ((_QWORD)v8)
    {
      if ((BYTE8(v8) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v8 + 40))();
    }
    v8 = *((_OWORD *)v3 + 2);
    xmmword_2540F9D18 = v7;
    re::StringID::destroyString((re::StringID *)v10);
  }
}

void re::IntrospectionInfo<re::DynamicArray<re::RigNodeTemporaryValue>>::get()
{
  unsigned __int8 v0;
  uint64_t *v1;
  unsigned __int8 v2;
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  int v5;
  re::IntrospectionRegistry *v6;
  const re::IntrospectionBase *v7;
  const char *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  re *v12;
  uint64_t *v13;
  const re::IntrospectionBase *v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t *v17;
  const re::IntrospectionBase *v18;
  void *v19;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23[2];
  __int128 v24;
  const char *v25;
  __int128 v26;

  v0 = atomic_load((unsigned __int8 *)&qword_2540F9268);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_2540F9268))
  {
    re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_2540F97C0);
    qword_2540F97C0 = (uint64_t)&off_24ED22DF0;
    __cxa_guard_release(&qword_2540F9268);
  }
  if ((byte_2540F8FA7 & 1) == 0)
  {
    v1 = (uint64_t *)qword_2540F9070;
    if (qword_2540F9070)
      goto LABEL_7;
    v2 = atomic_load((unsigned __int8 *)&qword_2540F9060);
    v1 = &qword_25582FC98;
    if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_2540F9060))
    {
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_25582FC98, 0);
      *(uint64_t *)((char *)&qword_25582FCA8 + 6) = 0;
      qword_25582FCA8 = 0;
      *(_QWORD *)&xmmword_25582FCB8 = 0;
      *((_QWORD *)&xmmword_25582FCB8 + 1) = 0xFFFFFFFFLL;
      qword_25582FC98 = (uint64_t)&off_24ED7DAA8;
      qword_25582FCC8 = (uint64_t)"RigNodeTemporaryValue";
      dword_25582FCD0 = 0;
      xmmword_25582FCD8 = 0u;
      *(_OWORD *)&qword_25582FCE8 = 0u;
      xmmword_25582FCF8 = 0u;
      qword_25582FD08 = 0;
      __cxa_guard_release(&qword_2540F9060);
    }
    qword_2540F9070 = (uint64_t)&qword_25582FC98;
    *(_QWORD *)&v26 = 0xD3DD14C91493BAA4;
    *((_QWORD *)&v26 + 1) = "RigNodeTemporaryValue";
    re::StringID::destroyString((re::StringID *)&v26);
    xmmword_25582FCB8 = v24;
    v4 = atomic_load((unsigned __int8 *)&qword_2540F9068);
    if ((v4 & 1) == 0)
    {
      v12 = (re *)__cxa_guard_acquire(&qword_2540F9068);
      if ((_DWORD)v12)
      {
        v13 = re::introspectionAllocator(v12);
        v15 = re::introspect_EvaluationRegisterType((re *)1, v14);
        v16 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v13 + 32))(v13, 72, 8);
        *(_DWORD *)v16 = 1;
        *(_QWORD *)(v16 + 8) = "temporaryValueType";
        *(_QWORD *)(v16 + 16) = v15;
        *(_QWORD *)(v16 + 24) = 0;
        *(_QWORD *)(v16 + 32) = 1;
        *(_DWORD *)(v16 + 40) = 0;
        *(_QWORD *)(v16 + 48) = 0;
        *(_QWORD *)(v16 + 56) = 0;
        *(_DWORD *)(v16 + 64) = 0;
        qword_2540F9300 = v16;
        v17 = re::introspectionAllocator((re *)v16);
        v19 = re::introspect_size_t((re *)1, v18);
        v20 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v17 + 32))(v17, 72, 8);
        *(_DWORD *)v20 = 1;
        *(_QWORD *)(v20 + 8) = "temporaryValueIndex";
        *(_QWORD *)(v20 + 16) = v19;
        *(_QWORD *)(v20 + 24) = 0;
        *(_QWORD *)(v20 + 32) = 0x800000002;
        *(_DWORD *)(v20 + 40) = 0;
        *(_QWORD *)(v20 + 48) = 0;
        *(_QWORD *)(v20 + 56) = 0;
        *(_DWORD *)(v20 + 64) = 0;
        qword_2540F9308 = v20;
        __cxa_guard_release(&qword_2540F9068);
      }
    }
    qword_25582FCA8 = 0x1000000008;
    dword_25582FCB0 = 8;
    word_25582FCB4 = 1;
    dword_25582FCD0 = 2;
    *(_QWORD *)&xmmword_25582FCD8 = &qword_2540F9300;
    *((_QWORD *)&xmmword_25582FCD8 + 1) = re::internal::defaultConstruct<re::RigNodeTemporaryValue>;
    qword_25582FCE8 = (uint64_t)re::internal::defaultDestruct<re::RigNodeTemporaryValue>;
    unk_25582FCF0 = 0;
    *(_QWORD *)&xmmword_25582FCF8 = 0;
    *((_QWORD *)&xmmword_25582FCF8 + 1) = re::internal::defaultConstructV2<re::RigNodeTemporaryValue>;
    qword_25582FD08 = (uint64_t)re::internal::defaultDestructV2<re::RigNodeTemporaryValue>;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_25582FC98, v3);
    v26 = v24;
    if ((byte_2540F8FA7 & 1) == 0)
    {
LABEL_7:
      byte_2540F8FA7 = 1;
      v5 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540F97C0, 0);
      qword_2540F97D0 = 0x2800000003;
      dword_2540F97D8 = v5;
      word_2540F97DC = 0;
      *(_QWORD *)&xmmword_2540F97E0 = 0;
      *((_QWORD *)&xmmword_2540F97E0 + 1) = 0xFFFFFFFFLL;
      qword_2540F97F0 = (uint64_t)v1;
      qword_2540F97F8 = 0;
      qword_2540F97C0 = (uint64_t)&off_24ED22DF0;
      re::IntrospectionRegistry::add(v6, v7);
      re::getPrettyTypeName((re *)&qword_2540F97C0, (const re::IntrospectionBase *)&v24);
      if ((BYTE8(v24) & 1) != 0)
        v8 = v25;
      else
        v8 = (char *)&v24 + 9;
      if ((_QWORD)v24 && (BYTE8(v24) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v24 + 40))();
      v22 = *((_OWORD *)v1 + 2);
      v9 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v23);
      if (v9)
      {
        v10 = *v9;
        *((_QWORD *)&v21 + 1) = v10;
      }
      else
      {
        v26 = v22;
        re::TypeBuilder::beginListType((uint64_t)&v24, v23, 1, 0x28uLL, 8uLL, &v26);
        re::TypeBuilder::setConstructor((uint64_t)&v24, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigNodeTemporaryValue>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v24, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigNodeTemporaryValue>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v24, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v24, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigNodeTemporaryValue>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigNodeTemporaryValue>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v24, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::RigNodeTemporaryValue>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v24, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigNodeTemporaryValue>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::RigNodeTemporaryValue>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigNodeTemporaryValue>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v24, v11);
      }
      xmmword_2540F97E0 = v21;
      re::StringID::destroyString((re::StringID *)v23);
    }
  }
}

void re::IntrospectionInfo<re::DynamicArray<re::RigExpressionParameter>>::get()
{
  unsigned __int8 v0;
  uint64_t *v1;
  unsigned __int8 v2;
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  int v5;
  re::IntrospectionRegistry *v6;
  const re::IntrospectionBase *v7;
  const char *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  re *v12;
  uint64_t *v13;
  const re::IntrospectionBase *v14;
  uint64_t v15;
  uint64_t *v16;
  const re::IntrospectionBase *v17;
  void *v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22[2];
  __int128 v23;
  const char *v24;
  __int128 v25;

  v0 = atomic_load((unsigned __int8 *)&qword_2540F9270);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_2540F9270))
  {
    re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_2540F9800);
    qword_2540F9800 = (uint64_t)&off_24ED22E88;
    __cxa_guard_release(&qword_2540F9270);
  }
  if ((byte_2540F8FA8 & 1) == 0)
  {
    v1 = (uint64_t *)qword_2540F9098;
    if (qword_2540F9098)
      goto LABEL_7;
    v2 = atomic_load((unsigned __int8 *)&qword_2540F9088);
    v1 = &qword_25582FD10;
    if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_2540F9088))
    {
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_25582FD10, 0);
      *(uint64_t *)((char *)&qword_25582FD20 + 6) = 0;
      qword_25582FD20 = 0;
      *(_QWORD *)&xmmword_25582FD30 = 0;
      *((_QWORD *)&xmmword_25582FD30 + 1) = 0xFFFFFFFFLL;
      qword_25582FD10 = (uint64_t)&off_24ED7DAA8;
      qword_25582FD40 = (uint64_t)"RigExpressionParameter";
      dword_25582FD48 = 0;
      xmmword_25582FD50 = 0u;
      *(_OWORD *)&qword_25582FD60 = 0u;
      xmmword_25582FD70 = 0u;
      qword_25582FD80 = 0;
      __cxa_guard_release(&qword_2540F9088);
    }
    qword_2540F9098 = (uint64_t)&qword_25582FD10;
    *(_QWORD *)&v25 = 0x27D44DBCDBB059C2;
    *((_QWORD *)&v25 + 1) = "RigExpressionParameter";
    re::StringID::destroyString((re::StringID *)&v25);
    xmmword_25582FD30 = v23;
    v4 = atomic_load((unsigned __int8 *)&qword_2540F9090);
    if ((v4 & 1) == 0)
    {
      v12 = (re *)__cxa_guard_acquire(&qword_2540F9090);
      if ((_DWORD)v12)
      {
        v13 = re::introspectionAllocator(v12);
        re::introspect_RigExpressionParameterType((re *)v13, v14);
        v15 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v13 + 32))(v13, 72, 8);
        *(_DWORD *)v15 = 1;
        *(_QWORD *)(v15 + 8) = "type";
        *(_QWORD *)(v15 + 16) = &qword_2540F9BD8;
        *(_QWORD *)(v15 + 24) = 0;
        *(_QWORD *)(v15 + 32) = 1;
        *(_DWORD *)(v15 + 40) = 0;
        *(_QWORD *)(v15 + 48) = 0;
        *(_QWORD *)(v15 + 56) = 0;
        *(_DWORD *)(v15 + 64) = 0;
        qword_2540F9310 = v15;
        v16 = re::introspectionAllocator((re *)v15);
        v18 = re::introspect_size_t((re *)1, v17);
        v19 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v16 + 32))(v16, 72, 8);
        *(_DWORD *)v19 = 1;
        *(_QWORD *)(v19 + 8) = "parameterIndex";
        *(_QWORD *)(v19 + 16) = v18;
        *(_QWORD *)(v19 + 24) = 0;
        *(_QWORD *)(v19 + 32) = 0x800000002;
        *(_DWORD *)(v19 + 40) = 0;
        *(_QWORD *)(v19 + 48) = 0;
        *(_QWORD *)(v19 + 56) = 0;
        *(_DWORD *)(v19 + 64) = 0;
        qword_2540F9318 = v19;
        __cxa_guard_release(&qword_2540F9090);
      }
    }
    qword_25582FD20 = 0x1000000008;
    dword_25582FD28 = 8;
    word_25582FD2C = 1;
    dword_25582FD48 = 2;
    *(_QWORD *)&xmmword_25582FD50 = &qword_2540F9310;
    *((_QWORD *)&xmmword_25582FD50 + 1) = re::internal::defaultConstruct<re::RigExpressionParameter>;
    qword_25582FD60 = (uint64_t)re::internal::defaultDestruct<re::RigExpressionParameter>;
    unk_25582FD68 = 0;
    *(_QWORD *)&xmmword_25582FD70 = 0;
    *((_QWORD *)&xmmword_25582FD70 + 1) = re::internal::defaultConstructV2<re::RigExpressionParameter>;
    qword_25582FD80 = (uint64_t)re::internal::defaultDestructV2<re::RigExpressionParameter>;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_25582FD10, v3);
    v25 = v23;
    if ((byte_2540F8FA8 & 1) == 0)
    {
LABEL_7:
      byte_2540F8FA8 = 1;
      v5 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540F9800, 0);
      qword_2540F9810 = 0x2800000003;
      dword_2540F9818 = v5;
      word_2540F981C = 0;
      *(_QWORD *)&xmmword_2540F9820 = 0;
      *((_QWORD *)&xmmword_2540F9820 + 1) = 0xFFFFFFFFLL;
      qword_2540F9830 = (uint64_t)v1;
      qword_2540F9838 = 0;
      qword_2540F9800 = (uint64_t)&off_24ED22E88;
      re::IntrospectionRegistry::add(v6, v7);
      re::getPrettyTypeName((re *)&qword_2540F9800, (const re::IntrospectionBase *)&v23);
      if ((BYTE8(v23) & 1) != 0)
        v8 = v24;
      else
        v8 = (char *)&v23 + 9;
      if ((_QWORD)v23 && (BYTE8(v23) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v23 + 40))();
      v21 = *((_OWORD *)v1 + 2);
      v9 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v22);
      if (v9)
      {
        v10 = *v9;
        *((_QWORD *)&v20 + 1) = v10;
      }
      else
      {
        v25 = v21;
        re::TypeBuilder::beginListType((uint64_t)&v23, v22, 1, 0x28uLL, 8uLL, &v25);
        re::TypeBuilder::setConstructor((uint64_t)&v23, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigExpressionParameter>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v23, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigExpressionParameter>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v23, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v23, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigExpressionParameter>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigExpressionParameter>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v23, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::RigExpressionParameter>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v23, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigExpressionParameter>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::RigExpressionParameter>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigExpressionParameter>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v23, v11);
      }
      xmmword_2540F9820 = v20;
      re::StringID::destroyString((re::StringID *)v22);
    }
  }
}

void re::IntrospectionInfo<re::DynamicArray<re::RigExpression>>::get()
{
  unsigned __int8 v0;
  uint64_t *v1;
  unsigned __int8 v2;
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  int v5;
  re::IntrospectionRegistry *v6;
  const re::IntrospectionBase *v7;
  const char *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  re *v12;
  uint64_t *v13;
  const re::IntrospectionBase *v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t *v17;
  const re::IntrospectionBase *v18;
  void *v19;
  uint64_t v20;
  uint64_t *v21;
  const re::IntrospectionBase *v22;
  void *v23;
  uint64_t v24;
  __int128 v25;
  __int128 v26;
  uint64_t v27[2];
  __int128 v28;
  const char *v29;
  __int128 v30;

  v0 = atomic_load((unsigned __int8 *)&qword_2540F9278);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_2540F9278))
  {
    re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_2540F9840);
    qword_2540F9840 = (uint64_t)&off_24ED22F20;
    __cxa_guard_release(&qword_2540F9278);
  }
  if ((byte_2540F8FA9 & 1) == 0)
  {
    v1 = (uint64_t *)qword_2540F90B0;
    if (qword_2540F90B0)
      goto LABEL_7;
    v2 = atomic_load((unsigned __int8 *)&qword_2540F90A0);
    v1 = &qword_25582FD88;
    if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_2540F90A0))
    {
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_25582FD88, 0);
      *(uint64_t *)((char *)&qword_25582FD98 + 6) = 0;
      qword_25582FD98 = 0;
      *(_QWORD *)&xmmword_25582FDA8 = 0;
      *((_QWORD *)&xmmword_25582FDA8 + 1) = 0xFFFFFFFFLL;
      qword_25582FD88 = (uint64_t)&off_24ED7DAA8;
      qword_25582FDB8 = (uint64_t)"RigExpression";
      dword_25582FDC0 = 0;
      xmmword_25582FDC8 = 0u;
      *(_OWORD *)&qword_25582FDD8 = 0u;
      xmmword_25582FDE8 = 0u;
      qword_25582FDF8 = 0;
      __cxa_guard_release(&qword_2540F90A0);
    }
    qword_2540F90B0 = (uint64_t)&qword_25582FD88;
    *(_QWORD *)&v30 = 0x4D21E17B034C8750;
    *((_QWORD *)&v30 + 1) = "RigExpression";
    re::StringID::destroyString((re::StringID *)&v30);
    xmmword_25582FDA8 = v28;
    v4 = atomic_load((unsigned __int8 *)&qword_2540F90A8);
    if ((v4 & 1) == 0)
    {
      v12 = (re *)__cxa_guard_acquire(&qword_2540F90A8);
      if ((_DWORD)v12)
      {
        v13 = re::introspectionAllocator(v12);
        v15 = re::introspect_EvaluationCommand((re *)1, v14);
        v16 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v13 + 32))(v13, 72, 8);
        *(_DWORD *)v16 = 1;
        *(_QWORD *)(v16 + 8) = "command";
        *(_QWORD *)(v16 + 16) = v15;
        *(_QWORD *)(v16 + 24) = 0;
        *(_QWORD *)(v16 + 32) = 1;
        *(_DWORD *)(v16 + 40) = 0;
        *(_QWORD *)(v16 + 48) = 0;
        *(_QWORD *)(v16 + 56) = 0;
        *(_DWORD *)(v16 + 64) = 0;
        qword_2540F9380 = v16;
        v17 = re::introspectionAllocator((re *)v16);
        v19 = re::introspect_size_t((re *)1, v18);
        v20 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v17 + 32))(v17, 72, 8);
        *(_DWORD *)v20 = 1;
        *(_QWORD *)(v20 + 8) = "expressionParameterIndexStart";
        *(_QWORD *)(v20 + 16) = v19;
        *(_QWORD *)(v20 + 24) = 0;
        *(_QWORD *)(v20 + 32) = 0x800000002;
        *(_DWORD *)(v20 + 40) = 0;
        *(_QWORD *)(v20 + 48) = 0;
        *(_QWORD *)(v20 + 56) = 0;
        *(_DWORD *)(v20 + 64) = 0;
        qword_2540F9388 = v20;
        v21 = re::introspectionAllocator((re *)v20);
        v23 = re::introspect_size_t((re *)1, v22);
        v24 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v21 + 32))(v21, 72, 8);
        *(_DWORD *)v24 = 1;
        *(_QWORD *)(v24 + 8) = "expressionDestinationParameterIndex";
        *(_QWORD *)(v24 + 16) = v23;
        *(_QWORD *)(v24 + 24) = 0;
        *(_QWORD *)(v24 + 32) = 0x1000000003;
        *(_DWORD *)(v24 + 40) = 0;
        *(_QWORD *)(v24 + 48) = 0;
        *(_QWORD *)(v24 + 56) = 0;
        *(_DWORD *)(v24 + 64) = 0;
        qword_2540F9390 = v24;
        __cxa_guard_release(&qword_2540F90A8);
      }
    }
    qword_25582FD98 = 0x1800000008;
    dword_25582FDA0 = 8;
    word_25582FDA4 = 1;
    dword_25582FDC0 = 3;
    *(_QWORD *)&xmmword_25582FDC8 = &qword_2540F9380;
    *((_QWORD *)&xmmword_25582FDC8 + 1) = re::internal::defaultConstruct<re::RigExpression>;
    qword_25582FDD8 = (uint64_t)re::internal::defaultDestruct<re::RigExpression>;
    unk_25582FDE0 = 0;
    *(_QWORD *)&xmmword_25582FDE8 = 0;
    *((_QWORD *)&xmmword_25582FDE8 + 1) = re::internal::defaultConstructV2<re::RigExpression>;
    qword_25582FDF8 = (uint64_t)re::internal::defaultDestructV2<re::RigExpression>;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_25582FD88, v3);
    v30 = v28;
    if ((byte_2540F8FA9 & 1) == 0)
    {
LABEL_7:
      byte_2540F8FA9 = 1;
      v5 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540F9840, 0);
      qword_2540F9850 = 0x2800000003;
      dword_2540F9858 = v5;
      word_2540F985C = 0;
      *(_QWORD *)&xmmword_2540F9860 = 0;
      *((_QWORD *)&xmmword_2540F9860 + 1) = 0xFFFFFFFFLL;
      qword_2540F9870 = (uint64_t)v1;
      qword_2540F9878 = 0;
      qword_2540F9840 = (uint64_t)&off_24ED22F20;
      re::IntrospectionRegistry::add(v6, v7);
      re::getPrettyTypeName((re *)&qword_2540F9840, (const re::IntrospectionBase *)&v28);
      if ((BYTE8(v28) & 1) != 0)
        v8 = v29;
      else
        v8 = (char *)&v28 + 9;
      if ((_QWORD)v28 && (BYTE8(v28) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v28 + 40))();
      v26 = *((_OWORD *)v1 + 2);
      v9 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v27);
      if (v9)
      {
        v10 = *v9;
        *((_QWORD *)&v25 + 1) = v10;
      }
      else
      {
        v30 = v26;
        re::TypeBuilder::beginListType((uint64_t)&v28, v27, 1, 0x28uLL, 8uLL, &v30);
        re::TypeBuilder::setConstructor((uint64_t)&v28, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigExpression>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v28, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigExpression>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v28, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v28, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigExpression>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigExpression>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v28, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::RigExpression>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v28, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigExpression>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::RigExpression>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigExpression>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v28, v11);
      }
      xmmword_2540F9860 = v25;
      re::StringID::destroyString((re::StringID *)v27);
    }
  }
}

void re::IntrospectionInfo<re::DynamicArray<re::RigTwoBoneIKHandles>>::get()
{
  unsigned __int8 v0;
  uint64_t *v1;
  unsigned __int8 v2;
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  int v5;
  re::IntrospectionRegistry *v6;
  const re::IntrospectionBase *v7;
  const char *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  re *v12;
  uint64_t *v13;
  const re::IntrospectionBase *v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t *v17;
  const re::IntrospectionBase *v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t *v21;
  const re::IntrospectionBase *v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t *v25;
  const re::IntrospectionBase *v26;
  uint64_t *v27;
  uint64_t v28;
  uint64_t *v29;
  const re::IntrospectionBase *v30;
  uint64_t *v31;
  uint64_t v32;
  uint64_t *v33;
  const re::IntrospectionBase *v34;
  uint64_t *v35;
  uint64_t v36;
  __int128 v37;
  __int128 v38;
  uint64_t v39[2];
  __int128 v40;
  const char *v41;
  __int128 v42;

  v0 = atomic_load((unsigned __int8 *)&qword_2540F9280);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_2540F9280))
  {
    re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_2540F9880);
    qword_2540F9880 = (uint64_t)&off_24ED22FB8;
    __cxa_guard_release(&qword_2540F9280);
  }
  if ((byte_2540F8FAA & 1) == 0)
  {
    v1 = (uint64_t *)qword_2540F90C8;
    if (qword_2540F90C8)
      goto LABEL_7;
    v2 = atomic_load((unsigned __int8 *)&qword_2540F90B8);
    v1 = &qword_25582FE00;
    if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_2540F90B8))
    {
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_25582FE00, 0);
      *(uint64_t *)((char *)&qword_25582FE10 + 6) = 0;
      qword_25582FE10 = 0;
      *(_QWORD *)&xmmword_25582FE20 = 0;
      *((_QWORD *)&xmmword_25582FE20 + 1) = 0xFFFFFFFFLL;
      qword_25582FE00 = (uint64_t)&off_24ED7DAA8;
      qword_25582FE30 = (uint64_t)"RigTwoBoneIKHandles";
      dword_25582FE38 = 0;
      xmmword_25582FE40 = 0u;
      *(_OWORD *)&qword_25582FE50 = 0u;
      xmmword_25582FE60 = 0u;
      qword_25582FE70 = 0;
      __cxa_guard_release(&qword_2540F90B8);
    }
    qword_2540F90C8 = (uint64_t)&qword_25582FE00;
    *(_QWORD *)&v42 = 0xCDF945C63DA71752;
    *((_QWORD *)&v42 + 1) = "RigTwoBoneIKHandles";
    re::StringID::destroyString((re::StringID *)&v42);
    xmmword_25582FE20 = v40;
    v4 = atomic_load((unsigned __int8 *)&qword_2540F90C0);
    if ((v4 & 1) == 0)
    {
      v12 = (re *)__cxa_guard_acquire(&qword_2540F90C0);
      if ((_DWORD)v12)
      {
        v13 = re::introspectionAllocator(v12);
        v15 = re::IntrospectionInfo<re::DynamicArray<unsigned long>>::get(1, v14);
        v16 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v13 + 32))(v13, 72, 8);
        *(_DWORD *)v16 = 1;
        *(_QWORD *)(v16 + 8) = "rootRigNodes";
        *(_QWORD *)(v16 + 16) = v15;
        *(_QWORD *)(v16 + 24) = 0;
        *(_QWORD *)(v16 + 32) = 1;
        *(_DWORD *)(v16 + 40) = 0;
        *(_QWORD *)(v16 + 48) = 0;
        *(_QWORD *)(v16 + 56) = 0;
        *(_DWORD *)(v16 + 64) = 0;
        qword_2540F94C8 = v16;
        v17 = re::introspectionAllocator((re *)v16);
        v19 = re::IntrospectionInfo<re::DynamicArray<unsigned long>>::get(1, v18);
        v20 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v17 + 32))(v17, 72, 8);
        *(_DWORD *)v20 = 1;
        *(_QWORD *)(v20 + 8) = "effectorRigNodes";
        *(_QWORD *)(v20 + 16) = v19;
        *(_QWORD *)(v20 + 24) = 0;
        *(_QWORD *)(v20 + 32) = 0x2800000002;
        *(_DWORD *)(v20 + 40) = 0;
        *(_QWORD *)(v20 + 48) = 0;
        *(_QWORD *)(v20 + 56) = 0;
        *(_DWORD *)(v20 + 64) = 0;
        qword_2540F94D0 = v20;
        v21 = re::introspectionAllocator((re *)v20);
        v23 = re::IntrospectionInfo<re::DynamicArray<unsigned long>>::get(1, v22);
        v24 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v21 + 32))(v21, 72, 8);
        *(_DWORD *)v24 = 1;
        *(_QWORD *)(v24 + 8) = "targetRigNodes";
        *(_QWORD *)(v24 + 16) = v23;
        *(_QWORD *)(v24 + 24) = 0;
        *(_QWORD *)(v24 + 32) = 0x5000000003;
        *(_DWORD *)(v24 + 40) = 0;
        *(_QWORD *)(v24 + 48) = 0;
        *(_QWORD *)(v24 + 56) = 0;
        *(_DWORD *)(v24 + 64) = 0;
        qword_2540F94D8 = v24;
        v25 = re::introspectionAllocator((re *)v24);
        v27 = re::IntrospectionInfo<re::DynamicArray<unsigned long>>::get(1, v26);
        v28 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v25 + 32))(v25, 72, 8);
        *(_DWORD *)v28 = 1;
        *(_QWORD *)(v28 + 8) = "upRigNodes";
        *(_QWORD *)(v28 + 16) = v27;
        *(_QWORD *)(v28 + 24) = 0;
        *(_QWORD *)(v28 + 32) = 0x7800000004;
        *(_DWORD *)(v28 + 40) = 0;
        *(_QWORD *)(v28 + 48) = 0;
        *(_QWORD *)(v28 + 56) = 0;
        *(_DWORD *)(v28 + 64) = 0;
        qword_2540F94E0 = v28;
        v29 = re::introspectionAllocator((re *)v28);
        v31 = re::IntrospectionInfo<re::DynamicArray<float>>::get(1, v30);
        v32 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v29 + 32))(v29, 72, 8);
        *(_DWORD *)v32 = 1;
        *(_QWORD *)(v32 + 8) = "twistOffsets";
        *(_QWORD *)(v32 + 16) = v31;
        *(_QWORD *)(v32 + 24) = 0;
        *(_QWORD *)(v32 + 32) = 0xA000000005;
        *(_DWORD *)(v32 + 40) = 0;
        *(_QWORD *)(v32 + 48) = 0;
        *(_QWORD *)(v32 + 56) = 0;
        *(_DWORD *)(v32 + 64) = 0;
        qword_2540F94E8 = v32;
        v33 = re::introspectionAllocator((re *)v32);
        v35 = re::IntrospectionInfo<re::DynamicArray<float>>::get(1, v34);
        v36 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v33 + 32))(v33, 72, 8);
        *(_DWORD *)v36 = 1;
        *(_QWORD *)(v36 + 8) = "softIKPercentages";
        *(_QWORD *)(v36 + 16) = v35;
        *(_QWORD *)(v36 + 24) = 0;
        *(_QWORD *)(v36 + 32) = 0xC800000006;
        *(_DWORD *)(v36 + 40) = 0;
        *(_QWORD *)(v36 + 48) = 0;
        *(_QWORD *)(v36 + 56) = 0;
        *(_DWORD *)(v36 + 64) = 0;
        qword_2540F94F0 = v36;
        __cxa_guard_release(&qword_2540F90C0);
      }
    }
    qword_25582FE10 = 0xF000000008;
    dword_25582FE18 = 8;
    word_25582FE1C = 0;
    dword_25582FE38 = 6;
    *(_QWORD *)&xmmword_25582FE40 = &qword_2540F94C8;
    *((_QWORD *)&xmmword_25582FE40 + 1) = re::internal::defaultConstruct<re::RigTwoBoneIKHandles>;
    qword_25582FE50 = (uint64_t)re::internal::defaultDestruct<re::RigTwoBoneIKHandles>;
    unk_25582FE58 = 0;
    *(_QWORD *)&xmmword_25582FE60 = 0;
    *((_QWORD *)&xmmword_25582FE60 + 1) = re::internal::defaultConstructV2<re::RigTwoBoneIKHandles>;
    qword_25582FE70 = (uint64_t)re::internal::defaultDestructV2<re::RigTwoBoneIKHandles>;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_25582FE00, v3);
    v42 = v40;
    if ((byte_2540F8FAA & 1) == 0)
    {
LABEL_7:
      byte_2540F8FAA = 1;
      v5 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540F9880, 0);
      qword_2540F9890 = 0x2800000003;
      dword_2540F9898 = v5;
      word_2540F989C = 0;
      *(_QWORD *)&xmmword_2540F98A0 = 0;
      *((_QWORD *)&xmmword_2540F98A0 + 1) = 0xFFFFFFFFLL;
      qword_2540F98B0 = (uint64_t)v1;
      qword_2540F98B8 = 0;
      qword_2540F9880 = (uint64_t)&off_24ED22FB8;
      re::IntrospectionRegistry::add(v6, v7);
      re::getPrettyTypeName((re *)&qword_2540F9880, (const re::IntrospectionBase *)&v40);
      if ((BYTE8(v40) & 1) != 0)
        v8 = v41;
      else
        v8 = (char *)&v40 + 9;
      if ((_QWORD)v40 && (BYTE8(v40) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v40 + 40))();
      v38 = *((_OWORD *)v1 + 2);
      v9 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v39);
      if (v9)
      {
        v10 = *v9;
        *((_QWORD *)&v37 + 1) = v10;
      }
      else
      {
        v42 = v38;
        re::TypeBuilder::beginListType((uint64_t)&v40, v39, 1, 0x28uLL, 8uLL, &v42);
        re::TypeBuilder::setConstructor((uint64_t)&v40, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigTwoBoneIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v40, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigTwoBoneIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v40, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v40, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigTwoBoneIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigTwoBoneIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v40, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::RigTwoBoneIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v40, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigTwoBoneIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::RigTwoBoneIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigTwoBoneIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v40, v11);
      }
      xmmword_2540F98A0 = v37;
      re::StringID::destroyString((re::StringID *)v39);
    }
  }
}

void re::IntrospectionInfo<re::DynamicArray<re::RigSingleChainIKHandles>>::get()
{
  unsigned __int8 v0;
  uint64_t *v1;
  unsigned __int8 v2;
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  int v5;
  re::IntrospectionRegistry *v6;
  const re::IntrospectionBase *v7;
  const char *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  re *v12;
  uint64_t *v13;
  const re::IntrospectionBase *v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t *v17;
  const re::IntrospectionBase *v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t *v21;
  const re::IntrospectionBase *v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t *v25;
  const re::IntrospectionBase *v26;
  void *v27;
  uint64_t v28;
  __int128 v29;
  __int128 v30;
  uint64_t v31[2];
  __int128 v32;
  const char *v33;
  __int128 v34;

  v0 = atomic_load((unsigned __int8 *)&qword_2540F9288);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_2540F9288))
  {
    re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_2540F98C0);
    qword_2540F98C0 = (uint64_t)&off_24ED23050;
    __cxa_guard_release(&qword_2540F9288);
  }
  if ((byte_2540F8FAB & 1) == 0)
  {
    v1 = (uint64_t *)qword_2540F90E0;
    if (qword_2540F90E0)
      goto LABEL_7;
    v2 = atomic_load((unsigned __int8 *)&qword_2540F90D0);
    v1 = &qword_25582FE78;
    if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_2540F90D0))
    {
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_25582FE78, 0);
      *(uint64_t *)((char *)&qword_25582FE88 + 6) = 0;
      qword_25582FE88 = 0;
      *(_QWORD *)&xmmword_25582FE98 = 0;
      *((_QWORD *)&xmmword_25582FE98 + 1) = 0xFFFFFFFFLL;
      qword_25582FE78 = (uint64_t)&off_24ED7DAA8;
      qword_25582FEA8 = (uint64_t)"RigSingleChainIKHandles";
      dword_25582FEB0 = 0;
      xmmword_25582FEB8 = 0u;
      *(_OWORD *)&qword_25582FEC8 = 0u;
      xmmword_25582FED8 = 0u;
      qword_25582FEE8 = 0;
      __cxa_guard_release(&qword_2540F90D0);
    }
    qword_2540F90E0 = (uint64_t)&qword_25582FE78;
    *(_QWORD *)&v34 = 0x4FC8F2E06F6B7B40;
    *((_QWORD *)&v34 + 1) = "RigSingleChainIKHandles";
    re::StringID::destroyString((re::StringID *)&v34);
    xmmword_25582FE98 = v32;
    v4 = atomic_load((unsigned __int8 *)&qword_2540F90D8);
    if ((v4 & 1) == 0)
    {
      v12 = (re *)__cxa_guard_acquire(&qword_2540F90D8);
      if ((_DWORD)v12)
      {
        v13 = re::introspectionAllocator(v12);
        v15 = re::IntrospectionInfo<re::DynamicArray<unsigned long>>::get(1, v14);
        v16 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v13 + 32))(v13, 72, 8);
        *(_DWORD *)v16 = 1;
        *(_QWORD *)(v16 + 8) = "rootRigNodes";
        *(_QWORD *)(v16 + 16) = v15;
        *(_QWORD *)(v16 + 24) = 0;
        *(_QWORD *)(v16 + 32) = 1;
        *(_DWORD *)(v16 + 40) = 0;
        *(_QWORD *)(v16 + 48) = 0;
        *(_QWORD *)(v16 + 56) = 0;
        *(_DWORD *)(v16 + 64) = 0;
        qword_2540F9438 = v16;
        v17 = re::introspectionAllocator((re *)v16);
        v19 = re::IntrospectionInfo<re::DynamicArray<unsigned long>>::get(1, v18);
        v20 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v17 + 32))(v17, 72, 8);
        *(_DWORD *)v20 = 1;
        *(_QWORD *)(v20 + 8) = "effectorRigNodes";
        *(_QWORD *)(v20 + 16) = v19;
        *(_QWORD *)(v20 + 24) = 0;
        *(_QWORD *)(v20 + 32) = 0x2800000002;
        *(_DWORD *)(v20 + 40) = 0;
        *(_QWORD *)(v20 + 48) = 0;
        *(_QWORD *)(v20 + 56) = 0;
        *(_DWORD *)(v20 + 64) = 0;
        qword_2540F9440 = v20;
        v21 = re::introspectionAllocator((re *)v20);
        v23 = re::IntrospectionInfo<re::DynamicArray<unsigned long>>::get(1, v22);
        v24 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v21 + 32))(v21, 72, 8);
        *(_DWORD *)v24 = 1;
        *(_QWORD *)(v24 + 8) = "targetRigNodes";
        *(_QWORD *)(v24 + 16) = v23;
        *(_QWORD *)(v24 + 24) = 0;
        *(_QWORD *)(v24 + 32) = 0x5000000003;
        *(_DWORD *)(v24 + 40) = 0;
        *(_QWORD *)(v24 + 48) = 0;
        *(_QWORD *)(v24 + 56) = 0;
        *(_DWORD *)(v24 + 64) = 0;
        qword_2540F9448 = v24;
        v25 = re::introspectionAllocator((re *)v24);
        v27 = re::introspect_float((re *)1, v26);
        v28 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v25 + 32))(v25, 72, 8);
        *(_DWORD *)v28 = 1;
        *(_QWORD *)(v28 + 8) = "tolerance";
        *(_QWORD *)(v28 + 16) = v27;
        *(_QWORD *)(v28 + 24) = 0;
        *(_QWORD *)(v28 + 32) = 0x7800000004;
        *(_DWORD *)(v28 + 40) = 0;
        *(_QWORD *)(v28 + 48) = 0;
        *(_QWORD *)(v28 + 56) = 0;
        *(_DWORD *)(v28 + 64) = 0;
        qword_2540F9450 = v28;
        __cxa_guard_release(&qword_2540F90D8);
      }
    }
    qword_25582FE88 = 0x8000000008;
    dword_25582FE90 = 8;
    word_25582FE94 = 0;
    dword_25582FEB0 = 4;
    *(_QWORD *)&xmmword_25582FEB8 = &qword_2540F9438;
    *((_QWORD *)&xmmword_25582FEB8 + 1) = re::internal::defaultConstruct<re::RigSingleChainIKHandles>;
    qword_25582FEC8 = (uint64_t)re::internal::defaultDestruct<re::RigSingleChainIKHandles>;
    unk_25582FED0 = 0;
    *(_QWORD *)&xmmword_25582FED8 = 0;
    *((_QWORD *)&xmmword_25582FED8 + 1) = re::internal::defaultConstructV2<re::RigSingleChainIKHandles>;
    qword_25582FEE8 = (uint64_t)re::internal::defaultDestructV2<re::RigSingleChainIKHandles>;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_25582FE78, v3);
    v34 = v32;
    if ((byte_2540F8FAB & 1) == 0)
    {
LABEL_7:
      byte_2540F8FAB = 1;
      v5 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540F98C0, 0);
      qword_2540F98D0 = 0x2800000003;
      dword_2540F98D8 = v5;
      word_2540F98DC = 0;
      *(_QWORD *)&xmmword_2540F98E0 = 0;
      *((_QWORD *)&xmmword_2540F98E0 + 1) = 0xFFFFFFFFLL;
      qword_2540F98F0 = (uint64_t)v1;
      qword_2540F98F8 = 0;
      qword_2540F98C0 = (uint64_t)&off_24ED23050;
      re::IntrospectionRegistry::add(v6, v7);
      re::getPrettyTypeName((re *)&qword_2540F98C0, (const re::IntrospectionBase *)&v32);
      if ((BYTE8(v32) & 1) != 0)
        v8 = v33;
      else
        v8 = (char *)&v32 + 9;
      if ((_QWORD)v32 && (BYTE8(v32) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v32 + 40))();
      v30 = *((_OWORD *)v1 + 2);
      v9 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v31);
      if (v9)
      {
        v10 = *v9;
        *((_QWORD *)&v29 + 1) = v10;
      }
      else
      {
        v34 = v30;
        re::TypeBuilder::beginListType((uint64_t)&v32, v31, 1, 0x28uLL, 8uLL, &v34);
        re::TypeBuilder::setConstructor((uint64_t)&v32, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigSingleChainIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v32, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigSingleChainIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v32, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v32, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigSingleChainIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigSingleChainIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v32, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::RigSingleChainIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v32, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigSingleChainIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::RigSingleChainIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigSingleChainIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v32, v11);
      }
      xmmword_2540F98E0 = v29;
      re::StringID::destroyString((re::StringID *)v31);
    }
  }
}

void re::IntrospectionInfo<re::DynamicArray<re::RigSplineIKHandle>>::get()
{
  unsigned __int8 v0;
  uint64_t *v1;
  unsigned __int8 v2;
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  int v5;
  re::IntrospectionRegistry *v6;
  const re::IntrospectionBase *v7;
  const char *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  re *v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t *v17;
  const re::IntrospectionBase *v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t *v21;
  const re::IntrospectionBase *v22;
  void *v23;
  uint64_t v24;
  uint64_t *v25;
  const re::IntrospectionBase *v26;
  void *v27;
  uint64_t v28;
  uint64_t *v29;
  const re::IntrospectionBase *v30;
  void *v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t *v34;
  re *v35;
  re::IntrospectionBase *v36;
  uint64_t v37;
  __int128 v38;
  __int128 v39;
  uint64_t v40[2];
  __int128 v41;
  const char *v42;
  __int128 v43;

  v0 = atomic_load((unsigned __int8 *)&qword_2540F9290);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_2540F9290))
  {
    re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_2540F9900);
    qword_2540F9900 = (uint64_t)&off_24ED230E8;
    __cxa_guard_release(&qword_2540F9290);
  }
  if ((byte_2540F8FAC & 1) == 0)
  {
    v1 = (uint64_t *)qword_2540F9128;
    if (qword_2540F9128)
      goto LABEL_7;
    v2 = atomic_load((unsigned __int8 *)&qword_2540F9118);
    v1 = &qword_25582FFE0;
    if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_2540F9118))
    {
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_25582FFE0, 0);
      *(uint64_t *)((char *)&qword_25582FFF0 + 6) = 0;
      qword_25582FFF0 = 0;
      *(_QWORD *)&xmmword_255830000 = 0;
      *((_QWORD *)&xmmword_255830000 + 1) = 0xFFFFFFFFLL;
      qword_25582FFE0 = (uint64_t)&off_24ED7DAA8;
      qword_255830010 = (uint64_t)"RigSplineIKHandle";
      dword_255830018 = 0;
      xmmword_255830020 = 0u;
      *(_OWORD *)&qword_255830030 = 0u;
      xmmword_255830040 = 0u;
      qword_255830050 = 0;
      __cxa_guard_release(&qword_2540F9118);
    }
    qword_2540F9128 = (uint64_t)&qword_25582FFE0;
    *(_QWORD *)&v43 = 0x9C43DBFAFA3C2396;
    *((_QWORD *)&v43 + 1) = "RigSplineIKHandle";
    re::StringID::destroyString((re::StringID *)&v43);
    xmmword_255830000 = v41;
    v4 = atomic_load((unsigned __int8 *)&qword_2540F9120);
    if ((v4 & 1) == 0)
    {
      v12 = (re *)__cxa_guard_acquire(&qword_2540F9120);
      if ((_DWORD)v12)
      {
        v13 = re::introspectionAllocator(v12);
        re::IntrospectionInfo<re::DynamicArray<re::RigSplineIKJoint>>::get();
        v14 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v13 + 32))(v13, 72, 8);
        *(_DWORD *)v14 = 1;
        *(_QWORD *)(v14 + 8) = "joints";
        *(_QWORD *)(v14 + 16) = &qword_2540F9600;
        *(_QWORD *)(v14 + 24) = 0;
        *(_QWORD *)(v14 + 32) = 0x800000001;
        *(_DWORD *)(v14 + 40) = 0;
        *(_QWORD *)(v14 + 48) = 0;
        *(_QWORD *)(v14 + 56) = 0;
        *(_DWORD *)(v14 + 64) = 0;
        qword_2540F9588 = v14;
        v15 = re::introspectionAllocator((re *)v14);
        re::IntrospectionInfo<re::DynamicArray<re::RigSplineIKControlPoint>>::get();
        v16 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v15 + 32))(v15, 72, 8);
        *(_DWORD *)v16 = 1;
        *(_QWORD *)(v16 + 8) = "controlPoints";
        *(_QWORD *)(v16 + 16) = &qword_2540F9640;
        *(_QWORD *)(v16 + 24) = 0;
        *(_QWORD *)(v16 + 32) = 0x3000000002;
        *(_DWORD *)(v16 + 40) = 0;
        *(_QWORD *)(v16 + 48) = 0;
        *(_QWORD *)(v16 + 56) = 0;
        *(_DWORD *)(v16 + 64) = 0;
        qword_2540F9590 = v16;
        v17 = re::introspectionAllocator((re *)v16);
        v19 = re::IntrospectionInfo<re::DynamicArray<float>>::get(1, v18);
        v20 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v17 + 32))(v17, 72, 8);
        *(_DWORD *)v20 = 1;
        *(_QWORD *)(v20 + 8) = "knots";
        *(_QWORD *)(v20 + 16) = v19;
        *(_QWORD *)(v20 + 24) = 0;
        *(_QWORD *)(v20 + 32) = 0x5800000003;
        *(_DWORD *)(v20 + 40) = 0;
        *(_QWORD *)(v20 + 48) = 0;
        *(_QWORD *)(v20 + 56) = 0;
        *(_DWORD *)(v20 + 64) = 0;
        qword_2540F9598 = v20;
        v21 = re::introspectionAllocator((re *)v20);
        v23 = re::introspect_size_t((re *)1, v22);
        v24 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v21 + 32))(v21, 72, 8);
        *(_DWORD *)v24 = 1;
        *(_QWORD *)(v24 + 8) = "rootRigNode";
        *(_QWORD *)(v24 + 16) = v23;
        *(_QWORD *)(v24 + 24) = 0;
        *(_QWORD *)(v24 + 32) = 0x8000000004;
        *(_DWORD *)(v24 + 40) = 0;
        *(_QWORD *)(v24 + 48) = 0;
        *(_QWORD *)(v24 + 56) = 0;
        *(_DWORD *)(v24 + 64) = 0;
        qword_2540F95A0 = v24;
        v25 = re::introspectionAllocator((re *)v24);
        v27 = re::introspect_size_t((re *)1, v26);
        v28 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v25 + 32))(v25, 72, 8);
        *(_DWORD *)v28 = 1;
        *(_QWORD *)(v28 + 8) = "endEffectorRigNode";
        *(_QWORD *)(v28 + 16) = v27;
        *(_QWORD *)(v28 + 24) = 0;
        *(_QWORD *)(v28 + 32) = 0x8800000005;
        *(_DWORD *)(v28 + 40) = 0;
        *(_QWORD *)(v28 + 48) = 0;
        *(_QWORD *)(v28 + 56) = 0;
        *(_DWORD *)(v28 + 64) = 0;
        qword_2540F95A8 = v28;
        v29 = re::introspectionAllocator((re *)v28);
        v31 = re::introspect_size_t((re *)1, v30);
        v32 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v29 + 32))(v29, 72, 8);
        *(_DWORD *)v32 = 1;
        *(_QWORD *)(v32 + 8) = "splineBindTransformNodeIndex";
        *(_QWORD *)(v32 + 16) = v31;
        *(_QWORD *)(v32 + 24) = 0;
        *(_QWORD *)(v32 + 32) = 0x9000000006;
        *(_DWORD *)(v32 + 40) = 0;
        *(_QWORD *)(v32 + 48) = 0;
        *(_QWORD *)(v32 + 56) = 0;
        *(_DWORD *)(v32 + 64) = 0;
        qword_2540F95B0 = v32;
        v33 = re::introspectionAllocator((re *)v32);
        v34 = v33;
        v35 = (re *)qword_2540F9140;
        if (!qword_2540F9140)
        {
          v35 = (re *)re::allocInfo_RigIKTwistControls((re *)v33);
          qword_2540F9140 = (uint64_t)v35;
          re::initInfo_RigIKTwistControls(v35, v36);
        }
        v37 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v34 + 32))(v34, 72, 8);
        *(_DWORD *)v37 = 1;
        *(_QWORD *)(v37 + 8) = "twistControls";
        *(_QWORD *)(v37 + 16) = v35;
        *(_QWORD *)(v37 + 24) = 0;
        *(_QWORD *)(v37 + 32) = 0xA000000007;
        *(_DWORD *)(v37 + 40) = 0;
        *(_QWORD *)(v37 + 48) = 0;
        *(_QWORD *)(v37 + 56) = 0;
        *(_DWORD *)(v37 + 64) = 0;
        qword_2540F95B8 = v37;
        __cxa_guard_release(&qword_2540F9120);
      }
    }
    qword_25582FFF0 = 0xF000000008;
    dword_25582FFF8 = 16;
    word_25582FFFC = 0;
    dword_255830018 = 7;
    *(_QWORD *)&xmmword_255830020 = &qword_2540F9588;
    *((_QWORD *)&xmmword_255830020 + 1) = re::internal::defaultConstruct<re::RigSplineIKHandle>;
    qword_255830030 = (uint64_t)re::internal::defaultDestruct<re::RigSplineIKHandle>;
    unk_255830038 = 0;
    *(_QWORD *)&xmmword_255830040 = 0;
    *((_QWORD *)&xmmword_255830040 + 1) = re::internal::defaultConstructV2<re::RigSplineIKHandle>;
    qword_255830050 = (uint64_t)re::internal::defaultDestructV2<re::RigSplineIKHandle>;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_25582FFE0, v3);
    v43 = v41;
    if ((byte_2540F8FAC & 1) == 0)
    {
LABEL_7:
      byte_2540F8FAC = 1;
      v5 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540F9900, 0);
      qword_2540F9910 = 0x2800000003;
      dword_2540F9918 = v5;
      word_2540F991C = 0;
      *(_QWORD *)&xmmword_2540F9920 = 0;
      *((_QWORD *)&xmmword_2540F9920 + 1) = 0xFFFFFFFFLL;
      qword_2540F9930 = (uint64_t)v1;
      qword_2540F9938 = 0;
      qword_2540F9900 = (uint64_t)&off_24ED230E8;
      re::IntrospectionRegistry::add(v6, v7);
      re::getPrettyTypeName((re *)&qword_2540F9900, (const re::IntrospectionBase *)&v41);
      if ((BYTE8(v41) & 1) != 0)
        v8 = v42;
      else
        v8 = (char *)&v41 + 9;
      if ((_QWORD)v41 && (BYTE8(v41) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v41 + 40))();
      v39 = *((_OWORD *)v1 + 2);
      v9 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v40);
      if (v9)
      {
        v10 = *v9;
        *((_QWORD *)&v38 + 1) = v10;
      }
      else
      {
        v43 = v39;
        re::TypeBuilder::beginListType((uint64_t)&v41, v40, 1, 0x28uLL, 8uLL, &v43);
        re::TypeBuilder::setConstructor((uint64_t)&v41, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKHandle>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v41, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKHandle>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v41, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v41, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKHandle>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKHandle>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v41, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKHandle>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v41, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKHandle>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKHandle>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKHandle>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v41, v11);
      }
      xmmword_2540F9920 = v38;
      re::StringID::destroyString((re::StringID *)v40);
    }
  }
}

void re::IntrospectionInfo<re::DynamicArray<re::RigTransform>>::get()
{
  unsigned __int8 v0;
  uint64_t *v1;
  unsigned __int8 v2;
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  int v5;
  re::IntrospectionRegistry *v6;
  const re::IntrospectionBase *v7;
  const char *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  re *v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  const re::IntrospectionBase *v23;
  uint64_t *v24;
  uint64_t v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28[2];
  __int128 v29;
  const char *v30;
  __int128 v31;

  v0 = atomic_load((unsigned __int8 *)&qword_2540F9298);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_2540F9298))
  {
    re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_2540F9940);
    qword_2540F9940 = (uint64_t)&off_24ED23180;
    __cxa_guard_release(&qword_2540F9298);
  }
  if ((byte_2540F8FAD & 1) == 0)
  {
    v1 = (uint64_t *)qword_2540F9180;
    if (qword_2540F9180)
      goto LABEL_7;
    v2 = atomic_load((unsigned __int8 *)&qword_2540F9170);
    v1 = &qword_255830148;
    if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_2540F9170))
    {
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_255830148, 0);
      *(uint64_t *)((char *)&qword_255830158 + 6) = 0;
      qword_255830158 = 0;
      *(_QWORD *)&xmmword_255830168 = 0;
      *((_QWORD *)&xmmword_255830168 + 1) = 0xFFFFFFFFLL;
      qword_255830148 = (uint64_t)&off_24ED7DAA8;
      qword_255830178 = (uint64_t)"RigTransform";
      dword_255830180 = 0;
      xmmword_255830188 = 0u;
      *(_OWORD *)&qword_255830198 = 0u;
      xmmword_2558301A8 = 0u;
      qword_2558301B8 = 0;
      __cxa_guard_release(&qword_2540F9170);
    }
    qword_2540F9180 = (uint64_t)&qword_255830148;
    *(_QWORD *)&v31 = 0x3C4B815110E2B0B8;
    *((_QWORD *)&v31 + 1) = "RigTransform";
    re::StringID::destroyString((re::StringID *)&v31);
    xmmword_255830168 = v29;
    v4 = atomic_load((unsigned __int8 *)&qword_2540F9178);
    if ((v4 & 1) == 0)
    {
      v12 = (re *)__cxa_guard_acquire(&qword_2540F9178);
      if ((_DWORD)v12)
      {
        v13 = re::introspectionAllocator(v12);
        v14 = re::introspect_Vector3F((re::IntrospectionBase **)1);
        v15 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v13 + 32))(v13, 72, 8);
        *(_DWORD *)v15 = 1;
        *(_QWORD *)(v15 + 8) = "translation";
        *(_QWORD *)(v15 + 16) = v14;
        *(_QWORD *)(v15 + 24) = 0;
        *(_QWORD *)(v15 + 32) = 1;
        *(_DWORD *)(v15 + 40) = 0;
        *(_QWORD *)(v15 + 48) = 0;
        *(_QWORD *)(v15 + 56) = 0;
        *(_DWORD *)(v15 + 64) = 0;
        qword_2540F9478 = v15;
        v16 = re::introspectionAllocator((re *)v15);
        v17 = re::introspect_Vector3F((re::IntrospectionBase **)1);
        v18 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v16 + 32))(v16, 72, 8);
        *(_DWORD *)v18 = 1;
        *(_QWORD *)(v18 + 8) = "rotation";
        *(_QWORD *)(v18 + 16) = v17;
        *(_QWORD *)(v18 + 24) = 0;
        *(_QWORD *)(v18 + 32) = 0x1000000002;
        *(_DWORD *)(v18 + 40) = 0;
        *(_QWORD *)(v18 + 48) = 0;
        *(_QWORD *)(v18 + 56) = 0;
        *(_DWORD *)(v18 + 64) = 0;
        qword_2540F9480 = v18;
        v19 = re::introspectionAllocator((re *)v18);
        v20 = re::introspect_Vector3F((re::IntrospectionBase **)1);
        v21 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v19 + 32))(v19, 72, 8);
        *(_DWORD *)v21 = 1;
        *(_QWORD *)(v21 + 8) = "scale";
        *(_QWORD *)(v21 + 16) = v20;
        *(_QWORD *)(v21 + 24) = 0;
        *(_QWORD *)(v21 + 32) = 0x2000000003;
        *(_DWORD *)(v21 + 40) = 0;
        *(_QWORD *)(v21 + 48) = 0;
        *(_QWORD *)(v21 + 56) = 0;
        *(_DWORD *)(v21 + 64) = 0;
        qword_2540F9488 = v21;
        v22 = re::introspectionAllocator((re *)v21);
        v24 = re::introspect_RERotationOrder((re *)1, v23);
        v25 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v22 + 32))(v22, 72, 8);
        *(_DWORD *)v25 = 1;
        *(_QWORD *)(v25 + 8) = "rotationOrder";
        *(_QWORD *)(v25 + 16) = v24;
        *(_QWORD *)(v25 + 24) = 0;
        *(_QWORD *)(v25 + 32) = 0x3000000004;
        *(_DWORD *)(v25 + 40) = 0;
        *(_QWORD *)(v25 + 48) = 0;
        *(_QWORD *)(v25 + 56) = 0;
        *(_DWORD *)(v25 + 64) = 0;
        qword_2540F9490 = v25;
        __cxa_guard_release(&qword_2540F9178);
      }
    }
    qword_255830158 = 0x4000000008;
    dword_255830160 = 16;
    word_255830164 = 1;
    dword_255830180 = 4;
    *(_QWORD *)&xmmword_255830188 = &qword_2540F9478;
    *((_QWORD *)&xmmword_255830188 + 1) = re::internal::defaultConstruct<re::RigTransform>;
    qword_255830198 = (uint64_t)re::internal::defaultDestruct<re::RigTransform>;
    unk_2558301A0 = 0;
    *(_QWORD *)&xmmword_2558301A8 = 0;
    *((_QWORD *)&xmmword_2558301A8 + 1) = re::internal::defaultConstructV2<re::RigTransform>;
    qword_2558301B8 = (uint64_t)re::internal::defaultDestructV2<re::RigTransform>;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_255830148, v3);
    v31 = v29;
    if ((byte_2540F8FAD & 1) == 0)
    {
LABEL_7:
      byte_2540F8FAD = 1;
      v5 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540F9940, 0);
      qword_2540F9950 = 0x2800000003;
      dword_2540F9958 = v5;
      word_2540F995C = 0;
      *(_QWORD *)&xmmword_2540F9960 = 0;
      *((_QWORD *)&xmmword_2540F9960 + 1) = 0xFFFFFFFFLL;
      qword_2540F9970 = (uint64_t)v1;
      qword_2540F9978 = 0;
      qword_2540F9940 = (uint64_t)&off_24ED23180;
      re::IntrospectionRegistry::add(v6, v7);
      re::getPrettyTypeName((re *)&qword_2540F9940, (const re::IntrospectionBase *)&v29);
      if ((BYTE8(v29) & 1) != 0)
        v8 = v30;
      else
        v8 = (char *)&v29 + 9;
      if ((_QWORD)v29 && (BYTE8(v29) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v29 + 40))();
      v27 = *((_OWORD *)v1 + 2);
      v9 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v28);
      if (v9)
      {
        v10 = *v9;
        *((_QWORD *)&v26 + 1) = v10;
      }
      else
      {
        v31 = v27;
        re::TypeBuilder::beginListType((uint64_t)&v29, v28, 1, 0x28uLL, 8uLL, &v31);
        re::TypeBuilder::setConstructor((uint64_t)&v29, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigTransform>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v29, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigTransform>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v29, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v29, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigTransform>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigTransform>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v29, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::RigTransform>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v29, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigTransform>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::RigTransform>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigTransform>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v29, v11);
      }
      xmmword_2540F9960 = v26;
      re::StringID::destroyString((re::StringID *)v28);
    }
  }
}

void re::IntrospectionInfo<re::DynamicArray<re::RigJoint>>::get()
{
  unsigned __int8 v0;
  uint64_t *v1;
  unsigned __int8 v2;
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  int v5;
  re::IntrospectionRegistry *v6;
  const re::IntrospectionBase *v7;
  const char *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  re *v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  const re::IntrospectionBase *v29;
  uint64_t *v30;
  uint64_t v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34[2];
  __int128 v35;
  const char *v36;
  __int128 v37;

  v0 = atomic_load((unsigned __int8 *)&qword_2540F92A0);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_2540F92A0))
  {
    re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_2540F9980);
    qword_2540F9980 = (uint64_t)&off_24ED23218;
    __cxa_guard_release(&qword_2540F92A0);
  }
  if ((byte_2540F8FAE & 1) == 0)
  {
    v1 = (uint64_t *)qword_2540F9198;
    if (qword_2540F9198)
      goto LABEL_7;
    v2 = atomic_load((unsigned __int8 *)&qword_2540F9188);
    v1 = &qword_2558301C0;
    if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_2540F9188))
    {
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2558301C0, 0);
      *(uint64_t *)((char *)&qword_2558301D0 + 6) = 0;
      qword_2558301D0 = 0;
      *(_QWORD *)&xmmword_2558301E0 = 0;
      *((_QWORD *)&xmmword_2558301E0 + 1) = 0xFFFFFFFFLL;
      qword_2558301C0 = (uint64_t)&off_24ED7DAA8;
      qword_2558301F0 = (uint64_t)"RigJoint";
      dword_2558301F8 = 0;
      xmmword_255830200 = 0u;
      *(_OWORD *)&qword_255830210 = 0u;
      xmmword_255830220 = 0u;
      qword_255830230 = 0;
      __cxa_guard_release(&qword_2540F9188);
    }
    qword_2540F9198 = (uint64_t)&qword_2558301C0;
    *(_QWORD *)&v37 = 0x44759315AF4;
    *((_QWORD *)&v37 + 1) = "RigJoint";
    re::StringID::destroyString((re::StringID *)&v37);
    xmmword_2558301E0 = v35;
    v4 = atomic_load((unsigned __int8 *)&qword_2540F9190);
    if ((v4 & 1) == 0)
    {
      v12 = (re *)__cxa_guard_acquire(&qword_2540F9190);
      if ((_DWORD)v12)
      {
        v13 = re::introspectionAllocator(v12);
        v14 = re::introspect_Vector3F((re::IntrospectionBase **)1);
        v15 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v13 + 32))(v13, 72, 8);
        *(_DWORD *)v15 = 1;
        *(_QWORD *)(v15 + 8) = "translation";
        *(_QWORD *)(v15 + 16) = v14;
        *(_QWORD *)(v15 + 24) = 0;
        *(_QWORD *)(v15 + 32) = 1;
        *(_DWORD *)(v15 + 40) = 0;
        *(_QWORD *)(v15 + 48) = 0;
        *(_QWORD *)(v15 + 56) = 0;
        *(_DWORD *)(v15 + 64) = 0;
        qword_2540F9528 = v15;
        v16 = re::introspectionAllocator((re *)v15);
        v17 = re::introspect_QuaternionF((re::IntrospectionBase **)1);
        v18 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v16 + 32))(v16, 72, 8);
        *(_DWORD *)v18 = 1;
        *(_QWORD *)(v18 + 8) = "orientation";
        *(_QWORD *)(v18 + 16) = v17;
        *(_QWORD *)(v18 + 24) = 0;
        *(_QWORD *)(v18 + 32) = 0x1000000002;
        *(_DWORD *)(v18 + 40) = 0;
        *(_QWORD *)(v18 + 48) = 0;
        *(_QWORD *)(v18 + 56) = 0;
        *(_DWORD *)(v18 + 64) = 0;
        qword_2540F9530 = v18;
        v19 = re::introspectionAllocator((re *)v18);
        v20 = re::introspect_Vector3F((re::IntrospectionBase **)1);
        v21 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v19 + 32))(v19, 72, 8);
        *(_DWORD *)v21 = 1;
        *(_QWORD *)(v21 + 8) = "rotation";
        *(_QWORD *)(v21 + 16) = v20;
        *(_QWORD *)(v21 + 24) = 0;
        *(_QWORD *)(v21 + 32) = 0x2000000003;
        *(_DWORD *)(v21 + 40) = 0;
        *(_QWORD *)(v21 + 48) = 0;
        *(_QWORD *)(v21 + 56) = 0;
        *(_DWORD *)(v21 + 64) = 0;
        qword_2540F9538 = v21;
        v22 = re::introspectionAllocator((re *)v21);
        v23 = re::introspect_QuaternionF((re::IntrospectionBase **)1);
        v24 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v22 + 32))(v22, 72, 8);
        *(_DWORD *)v24 = 1;
        *(_QWORD *)(v24 + 8) = "scaleOrientation";
        *(_QWORD *)(v24 + 16) = v23;
        *(_QWORD *)(v24 + 24) = 0;
        *(_QWORD *)(v24 + 32) = 0x3000000004;
        *(_DWORD *)(v24 + 40) = 0;
        *(_QWORD *)(v24 + 48) = 0;
        *(_QWORD *)(v24 + 56) = 0;
        *(_DWORD *)(v24 + 64) = 0;
        qword_2540F9540 = v24;
        v25 = re::introspectionAllocator((re *)v24);
        v26 = re::introspect_Vector3F((re::IntrospectionBase **)1);
        v27 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v25 + 32))(v25, 72, 8);
        *(_DWORD *)v27 = 1;
        *(_QWORD *)(v27 + 8) = "scale";
        *(_QWORD *)(v27 + 16) = v26;
        *(_QWORD *)(v27 + 24) = 0;
        *(_QWORD *)(v27 + 32) = 0x4000000005;
        *(_DWORD *)(v27 + 40) = 0;
        *(_QWORD *)(v27 + 48) = 0;
        *(_QWORD *)(v27 + 56) = 0;
        *(_DWORD *)(v27 + 64) = 0;
        qword_2540F9548 = v27;
        v28 = re::introspectionAllocator((re *)v27);
        v30 = re::introspect_RERotationOrder((re *)1, v29);
        v31 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v28 + 32))(v28, 72, 8);
        *(_DWORD *)v31 = 1;
        *(_QWORD *)(v31 + 8) = "rotationOrder";
        *(_QWORD *)(v31 + 16) = v30;
        *(_QWORD *)(v31 + 24) = 0;
        *(_QWORD *)(v31 + 32) = 0x5000000006;
        *(_DWORD *)(v31 + 40) = 0;
        *(_QWORD *)(v31 + 48) = 0;
        *(_QWORD *)(v31 + 56) = 0;
        *(_DWORD *)(v31 + 64) = 0;
        qword_2540F9550 = v31;
        __cxa_guard_release(&qword_2540F9190);
      }
    }
    qword_2558301D0 = 0x6000000008;
    dword_2558301D8 = 16;
    word_2558301DC = 1;
    dword_2558301F8 = 6;
    *(_QWORD *)&xmmword_255830200 = &qword_2540F9528;
    *((_QWORD *)&xmmword_255830200 + 1) = re::internal::defaultConstruct<re::RigJoint>;
    qword_255830210 = (uint64_t)re::internal::defaultDestruct<re::RigJoint>;
    unk_255830218 = 0;
    *(_QWORD *)&xmmword_255830220 = 0;
    *((_QWORD *)&xmmword_255830220 + 1) = re::internal::defaultConstructV2<re::RigJoint>;
    qword_255830230 = (uint64_t)re::internal::defaultDestructV2<re::RigJoint>;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_2558301C0, v3);
    v37 = v35;
    if ((byte_2540F8FAE & 1) == 0)
    {
LABEL_7:
      byte_2540F8FAE = 1;
      v5 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540F9980, 0);
      qword_2540F9990 = 0x2800000003;
      dword_2540F9998 = v5;
      word_2540F999C = 0;
      *(_QWORD *)&xmmword_2540F99A0 = 0;
      *((_QWORD *)&xmmword_2540F99A0 + 1) = 0xFFFFFFFFLL;
      qword_2540F99B0 = (uint64_t)v1;
      qword_2540F99B8 = 0;
      qword_2540F9980 = (uint64_t)&off_24ED23218;
      re::IntrospectionRegistry::add(v6, v7);
      re::getPrettyTypeName((re *)&qword_2540F9980, (const re::IntrospectionBase *)&v35);
      if ((BYTE8(v35) & 1) != 0)
        v8 = v36;
      else
        v8 = (char *)&v35 + 9;
      if ((_QWORD)v35 && (BYTE8(v35) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v35 + 40))();
      v33 = *((_OWORD *)v1 + 2);
      v9 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v34);
      if (v9)
      {
        v10 = *v9;
        *((_QWORD *)&v32 + 1) = v10;
      }
      else
      {
        v37 = v33;
        re::TypeBuilder::beginListType((uint64_t)&v35, v34, 1, 0x28uLL, 8uLL, &v37);
        re::TypeBuilder::setConstructor((uint64_t)&v35, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v35, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v35, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v35, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v35, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::RigJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v35, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::RigJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v35, v11);
      }
      xmmword_2540F99A0 = v32;
      re::StringID::destroyString((re::StringID *)v34);
    }
  }
}

void re::IntrospectionInfo<re::DynamicArray<re::RigNodeConstraint>>::get()
{
  unsigned __int8 v0;
  uint64_t *v1;
  unsigned __int8 v2;
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  int v5;
  re::IntrospectionRegistry *v6;
  const re::IntrospectionBase *v7;
  const char *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  re *v12;
  uint64_t *v13;
  const re::IntrospectionBase *v14;
  uint64_t v15;
  uint64_t *v16;
  const re::IntrospectionBase *v17;
  void *v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22[2];
  __int128 v23;
  const char *v24;
  __int128 v25;

  v0 = atomic_load((unsigned __int8 *)&qword_2540F92A8);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_2540F92A8))
  {
    re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_2540F99C0);
    qword_2540F99C0 = (uint64_t)&off_24ED232B0;
    __cxa_guard_release(&qword_2540F92A8);
  }
  if ((byte_2540F8FAF & 1) == 0)
  {
    v1 = (uint64_t *)qword_2540F91B0;
    if (qword_2540F91B0)
      goto LABEL_7;
    v2 = atomic_load((unsigned __int8 *)&qword_2540F91A0);
    v1 = &qword_255830238;
    if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_2540F91A0))
    {
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_255830238, 0);
      *(uint64_t *)((char *)&qword_255830248 + 6) = 0;
      qword_255830248 = 0;
      *(_QWORD *)&xmmword_255830258 = 0;
      *((_QWORD *)&xmmword_255830258 + 1) = 0xFFFFFFFFLL;
      qword_255830238 = (uint64_t)&off_24ED7DAA8;
      qword_255830268 = (uint64_t)"RigNodeConstraint";
      dword_255830270 = 0;
      xmmword_255830278 = 0u;
      *(_OWORD *)&qword_255830288 = 0u;
      xmmword_255830298 = 0u;
      qword_2558302A8 = 0;
      __cxa_guard_release(&qword_2540F91A0);
    }
    qword_2540F91B0 = (uint64_t)&qword_255830238;
    *(_QWORD *)&v25 = 0x44060FADD4005D1ELL;
    *((_QWORD *)&v25 + 1) = "RigNodeConstraint";
    re::StringID::destroyString((re::StringID *)&v25);
    xmmword_255830258 = v23;
    v4 = atomic_load((unsigned __int8 *)&qword_2540F91A8);
    if ((v4 & 1) == 0)
    {
      v12 = (re *)__cxa_guard_acquire(&qword_2540F91A8);
      if ((_DWORD)v12)
      {
        v13 = re::introspectionAllocator(v12);
        re::introspect_RigConstraintType((re *)v13, v14);
        v15 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v13 + 32))(v13, 72, 8);
        *(_DWORD *)v15 = 1;
        *(_QWORD *)(v15 + 8) = "type";
        *(_QWORD *)(v15 + 16) = &qword_2540F9B00;
        *(_QWORD *)(v15 + 24) = 0;
        *(_QWORD *)(v15 + 32) = 1;
        *(_DWORD *)(v15 + 40) = 0;
        *(_QWORD *)(v15 + 48) = 0;
        *(_QWORD *)(v15 + 56) = 0;
        *(_DWORD *)(v15 + 64) = 0;
        qword_2540F9340 = v15;
        v16 = re::introspectionAllocator((re *)v15);
        v18 = re::introspect_size_t((re *)1, v17);
        v19 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v16 + 32))(v16, 72, 8);
        *(_DWORD *)v19 = 1;
        *(_QWORD *)(v19 + 8) = "constraintIndex";
        *(_QWORD *)(v19 + 16) = v18;
        *(_QWORD *)(v19 + 24) = 0;
        *(_QWORD *)(v19 + 32) = 0x800000002;
        *(_DWORD *)(v19 + 40) = 0;
        *(_QWORD *)(v19 + 48) = 0;
        *(_QWORD *)(v19 + 56) = 0;
        *(_DWORD *)(v19 + 64) = 0;
        qword_2540F9348 = v19;
        __cxa_guard_release(&qword_2540F91A8);
      }
    }
    qword_255830248 = 0x1000000008;
    dword_255830250 = 8;
    word_255830254 = 1;
    dword_255830270 = 2;
    *(_QWORD *)&xmmword_255830278 = &qword_2540F9340;
    *((_QWORD *)&xmmword_255830278 + 1) = re::internal::defaultConstruct<re::RigNodeConstraint>;
    qword_255830288 = (uint64_t)re::internal::defaultDestruct<re::RigNodeConstraint>;
    unk_255830290 = 0;
    *(_QWORD *)&xmmword_255830298 = 0;
    *((_QWORD *)&xmmword_255830298 + 1) = re::internal::defaultConstructV2<re::RigNodeConstraint>;
    qword_2558302A8 = (uint64_t)re::internal::defaultDestructV2<re::RigNodeConstraint>;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_255830238, v3);
    v25 = v23;
    if ((byte_2540F8FAF & 1) == 0)
    {
LABEL_7:
      byte_2540F8FAF = 1;
      v5 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540F99C0, 0);
      qword_2540F99D0 = 0x2800000003;
      dword_2540F99D8 = v5;
      word_2540F99DC = 0;
      *(_QWORD *)&xmmword_2540F99E0 = 0;
      *((_QWORD *)&xmmword_2540F99E0 + 1) = 0xFFFFFFFFLL;
      qword_2540F99F0 = (uint64_t)v1;
      qword_2540F99F8 = 0;
      qword_2540F99C0 = (uint64_t)&off_24ED232B0;
      re::IntrospectionRegistry::add(v6, v7);
      re::getPrettyTypeName((re *)&qword_2540F99C0, (const re::IntrospectionBase *)&v23);
      if ((BYTE8(v23) & 1) != 0)
        v8 = v24;
      else
        v8 = (char *)&v23 + 9;
      if ((_QWORD)v23 && (BYTE8(v23) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v23 + 40))();
      v21 = *((_OWORD *)v1 + 2);
      v9 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v22);
      if (v9)
      {
        v10 = *v9;
        *((_QWORD *)&v20 + 1) = v10;
      }
      else
      {
        v25 = v21;
        re::TypeBuilder::beginListType((uint64_t)&v23, v22, 1, 0x28uLL, 8uLL, &v25);
        re::TypeBuilder::setConstructor((uint64_t)&v23, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v23, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v23, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v23, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v23, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v23, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v23, v11);
      }
      xmmword_2540F99E0 = v20;
      re::StringID::destroyString((re::StringID *)v22);
    }
  }
}

void re::IntrospectionInfo<re::DynamicArray<re::RigIKHandles>>::get()
{
  unsigned __int8 v0;
  uint64_t *v1;
  unsigned __int8 v2;
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  int v5;
  re::IntrospectionRegistry *v6;
  const re::IntrospectionBase *v7;
  const char *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  re *v12;
  uint64_t *v13;
  const re::IntrospectionBase *v14;
  uint64_t v15;
  uint64_t *v16;
  const re::IntrospectionBase *v17;
  void *v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22[2];
  __int128 v23;
  const char *v24;
  __int128 v25;

  v0 = atomic_load((unsigned __int8 *)&qword_2540F92B0);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_2540F92B0))
  {
    re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_2540F9A00);
    qword_2540F9A00 = (uint64_t)&off_24ED23348;
    __cxa_guard_release(&qword_2540F92B0);
  }
  if ((byte_2540F8FB0 & 1) == 0)
  {
    v1 = (uint64_t *)qword_2540F9168;
    if (qword_2540F9168)
      goto LABEL_7;
    v2 = atomic_load((unsigned __int8 *)&qword_2540F9158);
    v1 = &qword_2558300D0;
    if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_2540F9158))
    {
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2558300D0, 0);
      *(uint64_t *)((char *)&qword_2558300E0 + 6) = 0;
      qword_2558300E0 = 0;
      *(_QWORD *)&xmmword_2558300F0 = 0;
      *((_QWORD *)&xmmword_2558300F0 + 1) = 0xFFFFFFFFLL;
      qword_2558300D0 = (uint64_t)&off_24ED7DAA8;
      qword_255830100 = (uint64_t)"RigIKHandles";
      dword_255830108 = 0;
      xmmword_255830110 = 0u;
      *(_OWORD *)&qword_255830120 = 0u;
      xmmword_255830130 = 0u;
      qword_255830140 = 0;
      __cxa_guard_release(&qword_2540F9158);
    }
    qword_2540F9168 = (uint64_t)&qword_2558300D0;
    *(_QWORD *)&v25 = 0x3C4B6E422A8111B2;
    *((_QWORD *)&v25 + 1) = "RigIKHandles";
    re::StringID::destroyString((re::StringID *)&v25);
    xmmword_2558300F0 = v23;
    v4 = atomic_load((unsigned __int8 *)&qword_2540F9160);
    if ((v4 & 1) == 0)
    {
      v12 = (re *)__cxa_guard_acquire(&qword_2540F9160);
      if ((_DWORD)v12)
      {
        v13 = re::introspectionAllocator(v12);
        re::introspect_RigIKHandleType((re *)v13, v14);
        v15 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v13 + 32))(v13, 72, 8);
        *(_DWORD *)v15 = 1;
        *(_QWORD *)(v15 + 8) = "type";
        *(_QWORD *)(v15 + 16) = &qword_2540F9C20;
        *(_QWORD *)(v15 + 24) = 0;
        *(_QWORD *)(v15 + 32) = 1;
        *(_DWORD *)(v15 + 40) = 0;
        *(_QWORD *)(v15 + 48) = 0;
        *(_QWORD *)(v15 + 56) = 0;
        *(_DWORD *)(v15 + 64) = 0;
        qword_2540F9330 = v15;
        v16 = re::introspectionAllocator((re *)v15);
        v18 = re::introspect_size_t((re *)1, v17);
        v19 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v16 + 32))(v16, 72, 8);
        *(_DWORD *)v19 = 1;
        *(_QWORD *)(v19 + 8) = "ikHandleIndex";
        *(_QWORD *)(v19 + 16) = v18;
        *(_QWORD *)(v19 + 24) = 0;
        *(_QWORD *)(v19 + 32) = 0x800000002;
        *(_DWORD *)(v19 + 40) = 0;
        *(_QWORD *)(v19 + 48) = 0;
        *(_QWORD *)(v19 + 56) = 0;
        *(_DWORD *)(v19 + 64) = 0;
        qword_2540F9338 = v19;
        __cxa_guard_release(&qword_2540F9160);
      }
    }
    qword_2558300E0 = 0x1000000008;
    dword_2558300E8 = 8;
    word_2558300EC = 1;
    dword_255830108 = 2;
    *(_QWORD *)&xmmword_255830110 = &qword_2540F9330;
    *((_QWORD *)&xmmword_255830110 + 1) = re::internal::defaultConstruct<re::RigIKHandles>;
    qword_255830120 = (uint64_t)re::internal::defaultDestruct<re::RigIKHandles>;
    unk_255830128 = 0;
    *(_QWORD *)&xmmword_255830130 = 0;
    *((_QWORD *)&xmmword_255830130 + 1) = re::internal::defaultConstructV2<re::RigIKHandles>;
    qword_255830140 = (uint64_t)re::internal::defaultDestructV2<re::RigIKHandles>;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_2558300D0, v3);
    v25 = v23;
    if ((byte_2540F8FB0 & 1) == 0)
    {
LABEL_7:
      byte_2540F8FB0 = 1;
      v5 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540F9A00, 0);
      qword_2540F9A10 = 0x2800000003;
      dword_2540F9A18 = v5;
      word_2540F9A1C = 0;
      *(_QWORD *)&xmmword_2540F9A20 = 0;
      *((_QWORD *)&xmmword_2540F9A20 + 1) = 0xFFFFFFFFLL;
      qword_2540F9A30 = (uint64_t)v1;
      qword_2540F9A38 = 0;
      qword_2540F9A00 = (uint64_t)&off_24ED23348;
      re::IntrospectionRegistry::add(v6, v7);
      re::getPrettyTypeName((re *)&qword_2540F9A00, (const re::IntrospectionBase *)&v23);
      if ((BYTE8(v23) & 1) != 0)
        v8 = v24;
      else
        v8 = (char *)&v23 + 9;
      if ((_QWORD)v23 && (BYTE8(v23) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v23 + 40))();
      v21 = *((_OWORD *)v1 + 2);
      v9 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v22);
      if (v9)
      {
        v10 = *v9;
        *((_QWORD *)&v20 + 1) = v10;
      }
      else
      {
        v25 = v21;
        re::TypeBuilder::beginListType((uint64_t)&v23, v22, 1, 0x28uLL, 8uLL, &v25);
        re::TypeBuilder::setConstructor((uint64_t)&v23, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v23, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v23, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v23, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v23, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::RigIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v23, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::RigIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v23, v11);
      }
      xmmword_2540F9A20 = v20;
      re::StringID::destroyString((re::StringID *)v22);
    }
  }
}

void re::IntrospectionInfo<re::DynamicArray<re::RigNode>>::get()
{
  unsigned __int8 v0;
  uint64_t *v1;
  unsigned __int8 v2;
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  int v5;
  re::IntrospectionRegistry *v6;
  const re::IntrospectionBase *v7;
  const char *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  re *v12;
  uint64_t *v13;
  const re::IntrospectionBase *v14;
  void *v15;
  uint64_t v16;
  uint64_t *v17;
  const re::IntrospectionBase *v18;
  uint64_t v19;
  uint64_t *v20;
  const re::IntrospectionBase *v21;
  void *v22;
  uint64_t v23;
  uint64_t *v24;
  const re::IntrospectionBase *v25;
  void *v26;
  uint64_t v27;
  uint64_t *v28;
  const re::IntrospectionBase *v29;
  void *v30;
  uint64_t v31;
  uint64_t *v32;
  const re::IntrospectionBase *v33;
  void *v34;
  uint64_t v35;
  __int128 v36;
  __int128 v37;
  uint64_t v38[2];
  __int128 v39;
  const char *v40;
  __int128 v41;

  v0 = atomic_load((unsigned __int8 *)&qword_2540F92B8);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_2540F92B8))
  {
    re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_2540F9A40);
    qword_2540F9A40 = (uint64_t)&off_24ED233E0;
    __cxa_guard_release(&qword_2540F92B8);
  }
  if ((byte_2540F8FB1 & 1) == 0)
  {
    v1 = (uint64_t *)qword_2540F91D8;
    if (qword_2540F91D8)
      goto LABEL_7;
    v2 = atomic_load((unsigned __int8 *)&qword_2540F91C8);
    v1 = &qword_2558302B0;
    if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_2540F91C8))
    {
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2558302B0, 0);
      *(uint64_t *)((char *)&qword_2558302C0 + 6) = 0;
      qword_2558302C0 = 0;
      *(_QWORD *)&xmmword_2558302D0 = 0;
      *((_QWORD *)&xmmword_2558302D0 + 1) = 0xFFFFFFFFLL;
      qword_2558302B0 = (uint64_t)&off_24ED7DAA8;
      qword_2558302E0 = (uint64_t)"RigNode";
      dword_2558302E8 = 0;
      xmmword_2558302F0 = 0u;
      *(_OWORD *)&qword_255830300 = 0u;
      xmmword_255830310 = 0u;
      qword_255830320 = 0;
      __cxa_guard_release(&qword_2540F91C8);
    }
    qword_2540F91D8 = (uint64_t)&qword_2558302B0;
    *(_QWORD *)&v41 = 0x235578D624;
    *((_QWORD *)&v41 + 1) = "RigNode";
    re::StringID::destroyString((re::StringID *)&v41);
    xmmword_2558302D0 = v39;
    v4 = atomic_load((unsigned __int8 *)&qword_2540F91D0);
    if ((v4 & 1) == 0)
    {
      v12 = (re *)__cxa_guard_acquire(&qword_2540F91D0);
      if ((_DWORD)v12)
      {
        v13 = re::introspectionAllocator(v12);
        v15 = re::IntrospectionInfo<re::StringID>::get(1, v14);
        v16 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v13 + 32))(v13, 72, 8);
        *(_DWORD *)v16 = 1;
        *(_QWORD *)(v16 + 8) = "name";
        *(_QWORD *)(v16 + 16) = v15;
        *(_QWORD *)(v16 + 24) = 0;
        *(_QWORD *)(v16 + 32) = 1;
        *(_DWORD *)(v16 + 40) = 0;
        *(_QWORD *)(v16 + 48) = 0;
        *(_QWORD *)(v16 + 56) = 0;
        *(_DWORD *)(v16 + 64) = 0;
        qword_2540F9558 = v16;
        v17 = re::introspectionAllocator((re *)v16);
        re::introspect_RigNodeType((re *)v17, v18);
        v19 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v17 + 32))(v17, 72, 8);
        *(_DWORD *)v19 = 1;
        *(_QWORD *)(v19 + 8) = "nodeType";
        *(_QWORD *)(v19 + 16) = &qword_2540F9C68;
        *(_QWORD *)(v19 + 24) = 0;
        *(_QWORD *)(v19 + 32) = 0x1000000002;
        *(_DWORD *)(v19 + 40) = 0;
        *(_QWORD *)(v19 + 48) = 0;
        *(_QWORD *)(v19 + 56) = 0;
        *(_DWORD *)(v19 + 64) = 0;
        qword_2540F9560 = v19;
        v20 = re::introspectionAllocator((re *)v19);
        v22 = re::introspect_size_t((re *)1, v21);
        v23 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v20 + 32))(v20, 72, 8);
        *(_DWORD *)v23 = 1;
        *(_QWORD *)(v23 + 8) = "index";
        *(_QWORD *)(v23 + 16) = v22;
        *(_QWORD *)(v23 + 24) = 0;
        *(_QWORD *)(v23 + 32) = 0x1800000003;
        *(_DWORD *)(v23 + 40) = 0;
        *(_QWORD *)(v23 + 48) = 0;
        *(_QWORD *)(v23 + 56) = 0;
        *(_DWORD *)(v23 + 64) = 0;
        qword_2540F9568 = v23;
        v24 = re::introspectionAllocator((re *)v23);
        v26 = re::introspect_size_t((re *)1, v25);
        v27 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v24 + 32))(v24, 72, 8);
        *(_DWORD *)v27 = 1;
        *(_QWORD *)(v27 + 8) = "parentIndex";
        *(_QWORD *)(v27 + 16) = v26;
        *(_QWORD *)(v27 + 24) = 0;
        *(_QWORD *)(v27 + 32) = 0x2000000004;
        *(_DWORD *)(v27 + 40) = 0;
        *(_QWORD *)(v27 + 48) = 0;
        *(_QWORD *)(v27 + 56) = 0;
        *(_DWORD *)(v27 + 64) = 0;
        qword_2540F9570 = v27;
        v28 = re::introspectionAllocator((re *)v27);
        v30 = re::introspect_size_t((re *)1, v29);
        v31 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v28 + 32))(v28, 72, 8);
        *(_DWORD *)v31 = 1;
        *(_QWORD *)(v31 + 8) = "constraintCount";
        *(_QWORD *)(v31 + 16) = v30;
        *(_QWORD *)(v31 + 24) = 0;
        *(_QWORD *)(v31 + 32) = 0x2800000005;
        *(_DWORD *)(v31 + 40) = 0;
        *(_QWORD *)(v31 + 48) = 0;
        *(_QWORD *)(v31 + 56) = 0;
        *(_DWORD *)(v31 + 64) = 0;
        qword_2540F9578 = v31;
        v32 = re::introspectionAllocator((re *)v31);
        v34 = re::introspect_size_t((re *)1, v33);
        v35 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v32 + 32))(v32, 72, 8);
        *(_DWORD *)v35 = 1;
        *(_QWORD *)(v35 + 8) = "constraintStartIndex";
        *(_QWORD *)(v35 + 16) = v34;
        *(_QWORD *)(v35 + 24) = 0;
        *(_QWORD *)(v35 + 32) = 0x3000000006;
        *(_DWORD *)(v35 + 40) = 0;
        *(_QWORD *)(v35 + 48) = 0;
        *(_QWORD *)(v35 + 56) = 0;
        *(_DWORD *)(v35 + 64) = 0;
        qword_2540F9580 = v35;
        __cxa_guard_release(&qword_2540F91D0);
      }
    }
    qword_2558302C0 = 0x3800000008;
    dword_2558302C8 = 8;
    word_2558302CC = 0;
    dword_2558302E8 = 6;
    *(_QWORD *)&xmmword_2558302F0 = &qword_2540F9558;
    *((_QWORD *)&xmmword_2558302F0 + 1) = re::internal::defaultConstruct<re::RigNode>;
    qword_255830300 = (uint64_t)re::internal::defaultDestruct<re::RigNode>;
    unk_255830308 = 0;
    *(_QWORD *)&xmmword_255830310 = 0;
    *((_QWORD *)&xmmword_255830310 + 1) = re::internal::defaultConstructV2<re::RigNode>;
    qword_255830320 = (uint64_t)re::internal::defaultDestructV2<re::RigNode>;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_2558302B0, v3);
    v41 = v39;
    if ((byte_2540F8FB1 & 1) == 0)
    {
LABEL_7:
      byte_2540F8FB1 = 1;
      v5 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540F9A40, 0);
      qword_2540F9A50 = 0x2800000003;
      dword_2540F9A58 = v5;
      word_2540F9A5C = 0;
      *(_QWORD *)&xmmword_2540F9A60 = 0;
      *((_QWORD *)&xmmword_2540F9A60 + 1) = 0xFFFFFFFFLL;
      qword_2540F9A70 = (uint64_t)v1;
      qword_2540F9A78 = 0;
      qword_2540F9A40 = (uint64_t)&off_24ED233E0;
      re::IntrospectionRegistry::add(v6, v7);
      re::getPrettyTypeName((re *)&qword_2540F9A40, (const re::IntrospectionBase *)&v39);
      if ((BYTE8(v39) & 1) != 0)
        v8 = v40;
      else
        v8 = (char *)&v39 + 9;
      if ((_QWORD)v39 && (BYTE8(v39) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v39 + 40))();
      v37 = *((_OWORD *)v1 + 2);
      v9 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v38);
      if (v9)
      {
        v10 = *v9;
        *((_QWORD *)&v36 + 1) = v10;
      }
      else
      {
        v41 = v37;
        re::TypeBuilder::beginListType((uint64_t)&v39, v38, 1, 0x28uLL, 8uLL, &v41);
        re::TypeBuilder::setConstructor((uint64_t)&v39, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v39, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v39, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v39, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v39, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::RigNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v39, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::RigNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v39, v11);
      }
      xmmword_2540F9A60 = v36;
      re::StringID::destroyString((re::StringID *)v38);
    }
  }
}

void re::IntrospectionInfo<re::DynamicArray<re::RigPoseNode>>::get()
{
  unsigned __int8 v0;
  uint64_t *v1;
  unsigned __int8 v2;
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  int v5;
  re::IntrospectionRegistry *v6;
  const re::IntrospectionBase *v7;
  const char *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  re *v12;
  uint64_t *v13;
  const re::IntrospectionBase *v14;
  uint64_t v15;
  uint64_t *v16;
  const re::IntrospectionBase *v17;
  void *v18;
  uint64_t v19;
  uint64_t *v20;
  const re::IntrospectionBase *v21;
  void *v22;
  uint64_t v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26[2];
  __int128 v27;
  const char *v28;
  __int128 v29;

  v0 = atomic_load((unsigned __int8 *)&qword_2540F92C0);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_2540F92C0))
  {
    re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_2540F9A80);
    qword_2540F9A80 = (uint64_t)&off_24ED23478;
    __cxa_guard_release(&qword_2540F92C0);
  }
  if ((byte_2540F8FB2 & 1) == 0)
  {
    v1 = (uint64_t *)qword_2540F91F0;
    if (qword_2540F91F0)
      goto LABEL_7;
    v2 = atomic_load((unsigned __int8 *)&qword_2540F91E0);
    v1 = &qword_255830328;
    if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_2540F91E0))
    {
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_255830328, 0);
      *(uint64_t *)((char *)&qword_255830338 + 6) = 0;
      qword_255830338 = 0;
      *(_QWORD *)&xmmword_255830348 = 0;
      *((_QWORD *)&xmmword_255830348 + 1) = 0xFFFFFFFFLL;
      qword_255830328 = (uint64_t)&off_24ED7DAA8;
      qword_255830358 = (uint64_t)"RigPoseNode";
      dword_255830360 = 0;
      xmmword_255830368 = 0u;
      *(_OWORD *)&qword_255830378 = 0u;
      xmmword_255830388 = 0u;
      qword_255830398 = 0;
      __cxa_guard_release(&qword_2540F91E0);
    }
    qword_2540F91F0 = (uint64_t)&qword_255830328;
    *(_QWORD *)&v29 = 0x1F1EB3176197E86;
    *((_QWORD *)&v29 + 1) = "RigPoseNode";
    re::StringID::destroyString((re::StringID *)&v29);
    xmmword_255830348 = v27;
    v4 = atomic_load((unsigned __int8 *)&qword_2540F91E8);
    if ((v4 & 1) == 0)
    {
      v12 = (re *)__cxa_guard_acquire(&qword_2540F91E8);
      if ((_DWORD)v12)
      {
        v13 = re::introspectionAllocator(v12);
        re::introspect_RigNodeType((re *)v13, v14);
        v15 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v13 + 32))(v13, 72, 8);
        *(_DWORD *)v15 = 1;
        *(_QWORD *)(v15 + 8) = "nodeType";
        *(_QWORD *)(v15 + 16) = &qword_2540F9C68;
        *(_QWORD *)(v15 + 24) = 0;
        *(_QWORD *)(v15 + 32) = 1;
        *(_DWORD *)(v15 + 40) = 0;
        *(_QWORD *)(v15 + 48) = 0;
        *(_QWORD *)(v15 + 56) = 0;
        *(_DWORD *)(v15 + 64) = 0;
        qword_2540F93C8 = v15;
        v16 = re::introspectionAllocator((re *)v15);
        v18 = re::introspect_size_t((re *)1, v17);
        v19 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v16 + 32))(v16, 72, 8);
        *(_DWORD *)v19 = 1;
        *(_QWORD *)(v19 + 8) = "nodeIndex";
        *(_QWORD *)(v19 + 16) = v18;
        *(_QWORD *)(v19 + 24) = 0;
        *(_QWORD *)(v19 + 32) = 0x800000002;
        *(_DWORD *)(v19 + 40) = 0;
        *(_QWORD *)(v19 + 48) = 0;
        *(_QWORD *)(v19 + 56) = 0;
        *(_DWORD *)(v19 + 64) = 0;
        qword_2540F93D0 = v19;
        v20 = re::introspectionAllocator((re *)v19);
        v22 = re::introspect_size_t((re *)1, v21);
        v23 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v20 + 32))(v20, 72, 8);
        *(_DWORD *)v23 = 1;
        *(_QWORD *)(v23 + 8) = "rigNodeIndex";
        *(_QWORD *)(v23 + 16) = v22;
        *(_QWORD *)(v23 + 24) = 0;
        *(_QWORD *)(v23 + 32) = 0x1000000003;
        *(_DWORD *)(v23 + 40) = 0;
        *(_QWORD *)(v23 + 48) = 0;
        *(_QWORD *)(v23 + 56) = 0;
        *(_DWORD *)(v23 + 64) = 0;
        qword_2540F93D8 = v23;
        __cxa_guard_release(&qword_2540F91E8);
      }
    }
    qword_255830338 = 0x1800000008;
    dword_255830340 = 8;
    word_255830344 = 1;
    dword_255830360 = 3;
    *(_QWORD *)&xmmword_255830368 = &qword_2540F93C8;
    *((_QWORD *)&xmmword_255830368 + 1) = re::internal::defaultConstruct<re::RigPoseNode>;
    qword_255830378 = (uint64_t)re::internal::defaultDestruct<re::RigPoseNode>;
    unk_255830380 = 0;
    *(_QWORD *)&xmmword_255830388 = 0;
    *((_QWORD *)&xmmword_255830388 + 1) = re::internal::defaultConstructV2<re::RigPoseNode>;
    qword_255830398 = (uint64_t)re::internal::defaultDestructV2<re::RigPoseNode>;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_255830328, v3);
    v29 = v27;
    if ((byte_2540F8FB2 & 1) == 0)
    {
LABEL_7:
      byte_2540F8FB2 = 1;
      v5 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540F9A80, 0);
      qword_2540F9A90 = 0x2800000003;
      dword_2540F9A98 = v5;
      word_2540F9A9C = 0;
      *(_QWORD *)&xmmword_2540F9AA0 = 0;
      *((_QWORD *)&xmmword_2540F9AA0 + 1) = 0xFFFFFFFFLL;
      qword_2540F9AB0 = (uint64_t)v1;
      qword_2540F9AB8 = 0;
      qword_2540F9A80 = (uint64_t)&off_24ED23478;
      re::IntrospectionRegistry::add(v6, v7);
      re::getPrettyTypeName((re *)&qword_2540F9A80, (const re::IntrospectionBase *)&v27);
      if ((BYTE8(v27) & 1) != 0)
        v8 = v28;
      else
        v8 = (char *)&v27 + 9;
      if ((_QWORD)v27 && (BYTE8(v27) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v27 + 40))();
      v25 = *((_OWORD *)v1 + 2);
      v9 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v26);
      if (v9)
      {
        v10 = *v9;
        *((_QWORD *)&v24 + 1) = v10;
      }
      else
      {
        v29 = v25;
        re::TypeBuilder::beginListType((uint64_t)&v27, v26, 1, 0x28uLL, 8uLL, &v29);
        re::TypeBuilder::setConstructor((uint64_t)&v27, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigPoseNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v27, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigPoseNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v27, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v27, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigPoseNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigPoseNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v27, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::RigPoseNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v27, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigPoseNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::RigPoseNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigPoseNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v27, v11);
      }
      xmmword_2540F9AA0 = v24;
      re::StringID::destroyString((re::StringID *)v26);
    }
  }
}

void re::IntrospectionInfo<re::DynamicArray<re::RigPose>>::get()
{
  unsigned __int8 v0;
  uint64_t *v1;
  unsigned __int8 v2;
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  int v5;
  re::IntrospectionRegistry *v6;
  const re::IntrospectionBase *v7;
  const char *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  re *v12;
  uint64_t *v13;
  const re::IntrospectionBase *v14;
  void *v15;
  uint64_t v16;
  uint64_t *v17;
  const re::IntrospectionBase *v18;
  void *v19;
  uint64_t v20;
  uint64_t *v21;
  const re::IntrospectionBase *v22;
  void *v23;
  uint64_t v24;
  __int128 v25;
  __int128 v26;
  uint64_t v27[2];
  __int128 v28;
  const char *v29;
  __int128 v30;

  v0 = atomic_load((unsigned __int8 *)&qword_2540F92C8);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_2540F92C8))
  {
    re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_2540F9AC0);
    qword_2540F9AC0 = (uint64_t)&off_24ED23510;
    __cxa_guard_release(&qword_2540F92C8);
  }
  if ((byte_2540F8FB3 & 1) == 0)
  {
    v1 = (uint64_t *)qword_2540F9208;
    if (qword_2540F9208)
      goto LABEL_7;
    v2 = atomic_load((unsigned __int8 *)&qword_2540F91F8);
    v1 = &qword_2558303A0;
    if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_2540F91F8))
    {
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2558303A0, 0);
      *(uint64_t *)((char *)&qword_2558303B0 + 6) = 0;
      qword_2558303B0 = 0;
      *(_QWORD *)&xmmword_2558303C0 = 0;
      *((_QWORD *)&xmmword_2558303C0 + 1) = 0xFFFFFFFFLL;
      qword_2558303A0 = (uint64_t)&off_24ED7DAA8;
      qword_2558303D0 = (uint64_t)"RigPose";
      dword_2558303D8 = 0;
      xmmword_2558303E0 = 0u;
      *(_OWORD *)&qword_2558303F0 = 0u;
      xmmword_255830400 = 0u;
      qword_255830410 = 0;
      __cxa_guard_release(&qword_2540F91F8);
    }
    qword_2540F9208 = (uint64_t)&qword_2558303A0;
    *(_QWORD *)&v30 = 0x23557AAB42;
    *((_QWORD *)&v30 + 1) = "RigPose";
    re::StringID::destroyString((re::StringID *)&v30);
    xmmword_2558303C0 = v28;
    v4 = atomic_load((unsigned __int8 *)&qword_2540F9200);
    if ((v4 & 1) == 0)
    {
      v12 = (re *)__cxa_guard_acquire(&qword_2540F9200);
      if ((_DWORD)v12)
      {
        v13 = re::introspectionAllocator(v12);
        v15 = re::IntrospectionInfo<re::StringID>::get(1, v14);
        v16 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v13 + 32))(v13, 72, 8);
        *(_DWORD *)v16 = 1;
        *(_QWORD *)(v16 + 8) = "name";
        *(_QWORD *)(v16 + 16) = v15;
        *(_QWORD *)(v16 + 24) = 0;
        *(_QWORD *)(v16 + 32) = 1;
        *(_DWORD *)(v16 + 40) = 0;
        *(_QWORD *)(v16 + 48) = 0;
        *(_QWORD *)(v16 + 56) = 0;
        *(_DWORD *)(v16 + 64) = 0;
        qword_2540F93E0 = v16;
        v17 = re::introspectionAllocator((re *)v16);
        v19 = re::introspect_size_t((re *)1, v18);
        v20 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v17 + 32))(v17, 72, 8);
        *(_DWORD *)v20 = 1;
        *(_QWORD *)(v20 + 8) = "poseNodeCount";
        *(_QWORD *)(v20 + 16) = v19;
        *(_QWORD *)(v20 + 24) = 0;
        *(_QWORD *)(v20 + 32) = 0x1000000002;
        *(_DWORD *)(v20 + 40) = 0;
        *(_QWORD *)(v20 + 48) = 0;
        *(_QWORD *)(v20 + 56) = 0;
        *(_DWORD *)(v20 + 64) = 0;
        qword_2540F93E8 = v20;
        v21 = re::introspectionAllocator((re *)v20);
        v23 = re::introspect_size_t((re *)1, v22);
        v24 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v21 + 32))(v21, 72, 8);
        *(_DWORD *)v24 = 1;
        *(_QWORD *)(v24 + 8) = "poseNodeStartIndex";
        *(_QWORD *)(v24 + 16) = v23;
        *(_QWORD *)(v24 + 24) = 0;
        *(_QWORD *)(v24 + 32) = 0x1800000003;
        *(_DWORD *)(v24 + 40) = 0;
        *(_QWORD *)(v24 + 48) = 0;
        *(_QWORD *)(v24 + 56) = 0;
        *(_DWORD *)(v24 + 64) = 0;
        qword_2540F93F0 = v24;
        __cxa_guard_release(&qword_2540F9200);
      }
    }
    qword_2558303B0 = 0x2000000008;
    dword_2558303B8 = 8;
    word_2558303BC = 0;
    dword_2558303D8 = 3;
    *(_QWORD *)&xmmword_2558303E0 = &qword_2540F93E0;
    *((_QWORD *)&xmmword_2558303E0 + 1) = re::internal::defaultConstruct<re::RigPose>;
    qword_2558303F0 = (uint64_t)re::internal::defaultDestruct<re::RigPose>;
    unk_2558303F8 = 0;
    *(_QWORD *)&xmmword_255830400 = 0;
    *((_QWORD *)&xmmword_255830400 + 1) = re::internal::defaultConstructV2<re::RigPose>;
    qword_255830410 = (uint64_t)re::internal::defaultDestructV2<re::RigPose>;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_2558303A0, v3);
    v30 = v28;
    if ((byte_2540F8FB3 & 1) == 0)
    {
LABEL_7:
      byte_2540F8FB3 = 1;
      v5 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540F9AC0, 0);
      qword_2540F9AD0 = 0x2800000003;
      dword_2540F9AD8 = v5;
      word_2540F9ADC = 0;
      *(_QWORD *)&xmmword_2540F9AE0 = 0;
      *((_QWORD *)&xmmword_2540F9AE0 + 1) = 0xFFFFFFFFLL;
      qword_2540F9AF0 = (uint64_t)v1;
      qword_2540F9AF8 = 0;
      qword_2540F9AC0 = (uint64_t)&off_24ED23510;
      re::IntrospectionRegistry::add(v6, v7);
      re::getPrettyTypeName((re *)&qword_2540F9AC0, (const re::IntrospectionBase *)&v28);
      if ((BYTE8(v28) & 1) != 0)
        v8 = v29;
      else
        v8 = (char *)&v28 + 9;
      if ((_QWORD)v28 && (BYTE8(v28) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v28 + 40))();
      v26 = *((_OWORD *)v1 + 2);
      v9 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v27);
      if (v9)
      {
        v10 = *v9;
        *((_QWORD *)&v25 + 1) = v10;
      }
      else
      {
        v30 = v26;
        re::TypeBuilder::beginListType((uint64_t)&v28, v27, 1, 0x28uLL, 8uLL, &v30);
        re::TypeBuilder::setConstructor((uint64_t)&v28, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigPose>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v28, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigPose>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v28, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v28, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigPose>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::RigPose>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v28, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::RigPose>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v28, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigPose>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::RigPose>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::RigPose>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v28, v11);
      }
      xmmword_2540F9AE0 = v25;
      re::StringID::destroyString((re::StringID *)v27);
    }
  }
}

double re::internal::defaultConstruct<re::RigDefinition>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double result;

  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_DWORD *)(a3 + 24) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  result = 0.0;
  *(_OWORD *)(a3 + 232) = 0u;
  *(_OWORD *)(a3 + 248) = 0u;
  *(_DWORD *)(a3 + 264) = 0;
  *(_OWORD *)(a3 + 272) = 0u;
  *(_OWORD *)(a3 + 288) = 0u;
  *(_DWORD *)(a3 + 304) = 0;
  *(_DWORD *)(a3 + 344) = 0;
  *(_OWORD *)(a3 + 312) = 0u;
  *(_OWORD *)(a3 + 328) = 0u;
  *(_OWORD *)(a3 + 352) = 0u;
  *(_OWORD *)(a3 + 368) = 0u;
  *(_DWORD *)(a3 + 384) = 0;
  *(_DWORD *)(a3 + 424) = 0;
  *(_OWORD *)(a3 + 392) = 0u;
  *(_OWORD *)(a3 + 408) = 0u;
  *(_DWORD *)(a3 + 464) = 0;
  *(_OWORD *)(a3 + 432) = 0u;
  *(_OWORD *)(a3 + 448) = 0u;
  *(_DWORD *)(a3 + 504) = 0;
  *(_OWORD *)(a3 + 472) = 0u;
  *(_OWORD *)(a3 + 488) = 0u;
  *(_QWORD *)(a3 + 1136) = 0;
  *(_DWORD *)(a3 + 64) = 0;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)(a3 + 72) = 0u;
  *(_OWORD *)(a3 + 88) = 0u;
  *(_DWORD *)(a3 + 104) = 0;
  *(_OWORD *)(a3 + 112) = 0u;
  *(_OWORD *)(a3 + 128) = 0u;
  *(_DWORD *)(a3 + 144) = 0;
  *(_OWORD *)(a3 + 152) = 0u;
  *(_OWORD *)(a3 + 168) = 0u;
  *(_DWORD *)(a3 + 184) = 0;
  *(_DWORD *)(a3 + 224) = 0;
  *(_OWORD *)(a3 + 192) = 0u;
  *(_OWORD *)(a3 + 208) = 0u;
  *(_DWORD *)(a3 + 544) = 0;
  *(_OWORD *)(a3 + 512) = 0u;
  *(_OWORD *)(a3 + 528) = 0u;
  *(_DWORD *)(a3 + 648) = 0;
  *(_OWORD *)(a3 + 616) = 0u;
  *(_OWORD *)(a3 + 632) = 0u;
  *(_OWORD *)(a3 + 584) = 0u;
  *(_OWORD *)(a3 + 600) = 0u;
  *(_OWORD *)(a3 + 552) = 0u;
  *(_OWORD *)(a3 + 568) = 0u;
  *(_DWORD *)(a3 + 688) = 0;
  *(_OWORD *)(a3 + 656) = 0u;
  *(_OWORD *)(a3 + 672) = 0u;
  *(_OWORD *)(a3 + 696) = 0u;
  *(_OWORD *)(a3 + 712) = 0u;
  *(_DWORD *)(a3 + 728) = 0;
  *(_DWORD *)(a3 + 768) = 0;
  *(_OWORD *)(a3 + 736) = 0u;
  *(_OWORD *)(a3 + 752) = 0u;
  *(_DWORD *)(a3 + 808) = 0;
  *(_OWORD *)(a3 + 776) = 0u;
  *(_OWORD *)(a3 + 792) = 0u;
  *(_DWORD *)(a3 + 848) = 0;
  *(_OWORD *)(a3 + 816) = 0u;
  *(_OWORD *)(a3 + 832) = 0u;
  *(_DWORD *)(a3 + 888) = 0;
  *(_OWORD *)(a3 + 856) = 0u;
  *(_OWORD *)(a3 + 872) = 0u;
  *(_DWORD *)(a3 + 928) = 0;
  *(_OWORD *)(a3 + 896) = 0u;
  *(_OWORD *)(a3 + 912) = 0u;
  *(_DWORD *)(a3 + 968) = 0;
  *(_OWORD *)(a3 + 936) = 0u;
  *(_OWORD *)(a3 + 952) = 0u;
  *(_DWORD *)(a3 + 1008) = 0;
  *(_OWORD *)(a3 + 976) = 0u;
  *(_OWORD *)(a3 + 992) = 0u;
  *(_DWORD *)(a3 + 1048) = 0;
  *(_OWORD *)(a3 + 1016) = 0u;
  *(_OWORD *)(a3 + 1032) = 0u;
  *(_DWORD *)(a3 + 1088) = 0;
  *(_OWORD *)(a3 + 1072) = 0u;
  *(_OWORD *)(a3 + 1056) = 0u;
  *(_DWORD *)(a3 + 1128) = 0;
  *(_OWORD *)(a3 + 1096) = 0u;
  *(_OWORD *)(a3 + 1112) = 0u;
  return result;
}

void re::internal::defaultDestruct<re::RigDefinition>(int a1, int a2, re::RigDefinition *this)
{
  re::RigDefinition::~RigDefinition(this);
}

double re::internal::defaultConstructV2<re::RigDefinition>(uint64_t a1)
{
  double result;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_DWORD *)(a1 + 264) = 0;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_DWORD *)(a1 + 304) = 0;
  *(_DWORD *)(a1 + 344) = 0;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_OWORD *)(a1 + 328) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_DWORD *)(a1 + 384) = 0;
  *(_DWORD *)(a1 + 424) = 0;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(_DWORD *)(a1 + 464) = 0;
  *(_OWORD *)(a1 + 432) = 0u;
  *(_OWORD *)(a1 + 448) = 0u;
  *(_DWORD *)(a1 + 504) = 0;
  *(_OWORD *)(a1 + 472) = 0u;
  *(_OWORD *)(a1 + 488) = 0u;
  *(_QWORD *)(a1 + 1136) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_DWORD *)(a1 + 104) = 0;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_DWORD *)(a1 + 144) = 0;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_DWORD *)(a1 + 184) = 0;
  *(_DWORD *)(a1 + 224) = 0;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_DWORD *)(a1 + 544) = 0;
  *(_OWORD *)(a1 + 512) = 0u;
  *(_OWORD *)(a1 + 528) = 0u;
  *(_DWORD *)(a1 + 648) = 0;
  *(_OWORD *)(a1 + 616) = 0u;
  *(_OWORD *)(a1 + 632) = 0u;
  *(_OWORD *)(a1 + 584) = 0u;
  *(_OWORD *)(a1 + 600) = 0u;
  *(_OWORD *)(a1 + 552) = 0u;
  *(_OWORD *)(a1 + 568) = 0u;
  *(_DWORD *)(a1 + 688) = 0;
  *(_OWORD *)(a1 + 656) = 0u;
  *(_OWORD *)(a1 + 672) = 0u;
  *(_OWORD *)(a1 + 696) = 0u;
  *(_OWORD *)(a1 + 712) = 0u;
  *(_DWORD *)(a1 + 728) = 0;
  *(_DWORD *)(a1 + 768) = 0;
  *(_OWORD *)(a1 + 736) = 0u;
  *(_OWORD *)(a1 + 752) = 0u;
  *(_DWORD *)(a1 + 808) = 0;
  *(_OWORD *)(a1 + 776) = 0u;
  *(_OWORD *)(a1 + 792) = 0u;
  *(_DWORD *)(a1 + 848) = 0;
  *(_OWORD *)(a1 + 816) = 0u;
  *(_OWORD *)(a1 + 832) = 0u;
  *(_DWORD *)(a1 + 888) = 0;
  *(_OWORD *)(a1 + 856) = 0u;
  *(_OWORD *)(a1 + 872) = 0u;
  *(_DWORD *)(a1 + 928) = 0;
  *(_OWORD *)(a1 + 896) = 0u;
  *(_OWORD *)(a1 + 912) = 0u;
  *(_DWORD *)(a1 + 968) = 0;
  *(_OWORD *)(a1 + 936) = 0u;
  *(_OWORD *)(a1 + 952) = 0u;
  *(_DWORD *)(a1 + 1008) = 0;
  *(_OWORD *)(a1 + 976) = 0u;
  *(_OWORD *)(a1 + 992) = 0u;
  *(_DWORD *)(a1 + 1048) = 0;
  *(_OWORD *)(a1 + 1016) = 0u;
  *(_OWORD *)(a1 + 1032) = 0u;
  *(_DWORD *)(a1 + 1088) = 0;
  *(_OWORD *)(a1 + 1072) = 0u;
  *(_OWORD *)(a1 + 1056) = 0u;
  *(_DWORD *)(a1 + 1128) = 0;
  *(_OWORD *)(a1 + 1096) = 0u;
  *(_OWORD *)(a1 + 1112) = 0u;
  return result;
}

uint64_t re::introspect_RigDefinition(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"RigDefinition", (uint64_t (*)(re::internal *))re::allocInfo_RigDefinition, (re::IntrospectionBase *(*)(void))re::initInfo_RigDefinition, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::RigDefinition>, this);
}

_QWORD *re::FixedArray<unsigned long>::init<unsigned long const&>(_QWORD *result, uint64_t a2, unint64_t a3, _QWORD *a4)
{
  _QWORD *v6;
  uint64_t v7;
  unint64_t v8;

  *result = a2;
  result[1] = a3;
  if (!a3)
    return result;
  if (a3 >> 61)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 8, a3);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  v6 = result;
  result = (_QWORD *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 8 * a3, 8);
  v6[2] = result;
  if (!result)
  {
LABEL_9:
    re::internal::assertLog((re::internal *)4, v7, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    result = (_QWORD *)_os_crash();
    __break(1u);
    return result;
  }
  v8 = a3 - 1;
  if (a3 != 1)
  {
    do
    {
      *result++ = *a4;
      --v8;
    }
    while (v8);
  }
  *result = *a4;
  return result;
}

void re::TypeBuilderHelper::registerDynamicArray<unsigned long>(re::TypeRegistry *a1@<X0>, uint64_t *a2@<X1>, __int128 *a3@<X2>, re::TypeRegistry **a4@<X8>)
{
  _anonymous_namespace_ *v8;
  re::TypeRegistry *v9;
  uint64_t v10;
  __int128 v11;
  _BYTE v12[488];

  v8 = (_anonymous_namespace_ *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a1 + 200, a2);
  if (a1 && v8)
  {
    v9 = *(re::TypeRegistry **)v8;
    *a4 = a1;
    a4[1] = v9;
  }
  else
  {
    v11 = *a3;
    re::TypeBuilder::beginListType((uint64_t)v12, a2, 1, 0x28uLL, 8uLL, &v11);
    re::TypeBuilder::setConstructor((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<unsigned long>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
    re::TypeBuilder::setDestructor((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<unsigned long>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
    re::TypeBuilder::setListUsesContiguousStorage((uint64_t)v12, 1);
    re::TypeBuilder::setListAccessors((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<unsigned long>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<unsigned long>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
    re::TypeBuilder::setListIndexer((uint64_t)v12, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<unsigned long>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
    re::TypeBuilder::setListIterator((uint64_t)v12, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<unsigned long>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<unsigned long>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<unsigned long>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
    re::TypeBuilder::commitTo((re::TypeBuilder *)v12, a1, a4);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v12, v10);
  }
}

_QWORD *re::IntrospectionDynamicArray<unsigned long>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<unsigned long>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x2276933B8);
}

void re::IntrospectionDynamicArray<unsigned long>::construct(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<unsigned long>::destroy(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = *(_QWORD *)a2;
  if (*(_QWORD *)a2)
  {
    if (*(_QWORD *)(a2 + 32))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a2 + 32) = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_QWORD *)a2 = 0;
    ++*(_DWORD *)(a2 + 24);
  }
  return result;
}

_QWORD *re::IntrospectionDynamicArray<unsigned long>::init(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  _QWORD *result;

  if (*a2)
  {
    if (a2[4])
      (*(void (**)(_QWORD))(*(_QWORD *)*a2 + 40))(*a2);
    a2[4] = 0;
    a2[1] = 0;
    a2[2] = 0;
    ++*((_DWORD *)a2 + 6);
  }
  *a2 = a3;
  result = re::DynamicArray<re::EvaluationRegisterId<int>>::setCapacity(a2, 0);
  ++*((_DWORD *)a2 + 6);
  return result;
}

void re::IntrospectionDynamicArray<unsigned long>::resize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  unint64_t v10;
  unint64_t i;

  if (!*(_QWORD *)a4)
  {
    *(_QWORD *)a4 = a2;
    re::DynamicArray<re::EvaluationRegisterId<int>>::setCapacity((_QWORD *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  v10 = *(_QWORD *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
      re::DynamicArray<unsigned long>::resize(a4, a5);
  }
  else
  {
    re::DynamicArray<re::EvaluationRegisterId<int>>::setCapacity((_QWORD *)a4, a5);
    for (i = a5 - *(_QWORD *)(a4 + 16); i; --i)
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, a3, a4);
  }
}

re::IntrospectionBase *re::IntrospectionDynamicArray<unsigned long>::addElement(uint64_t a1, re *a2, int a3, _anonymous_namespace_ *this)
{
  re::IntrospectionBase *v8;
  uint64_t v10;

  v10 = 0;
  re::DynamicArray<unsigned long>::add(this, &v10);
  v8 = (re::IntrospectionBase *)(*((_QWORD *)this + 4) + 8 * *((_QWORD *)this + 2) - 8);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v8);
  return v8;
}

uint64_t re::IntrospectionDynamicArray<unsigned long>::size(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<unsigned long>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 8 * a3;
}

{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 8 * a3;
}

void re::DynamicArray<unsigned long>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v4;
  void *v5;
  uint64_t v6;

  v4 = *(_QWORD *)(a1 + 16);
  if (v4 >= a2)
  {
    if (v4 <= a2)
      return;
  }
  else
  {
    if (*(_QWORD *)(a1 + 8) < a2)
    {
      re::DynamicArray<re::EvaluationRegisterId<int>>::setCapacity((_QWORD *)a1, a2);
      v4 = *(_QWORD *)(a1 + 16);
    }
    if (v4 < a2)
    {
      v5 = (void *)(*(_QWORD *)(a1 + 32) + 8 * v4);
      v6 = 8 * a2 - 8 * v4;
      if (v6 >= 1)
        bzero(v5, 8 * (((unint64_t)v6 >> 3) - ((unint64_t)v6 > 7)) + 8);
    }
  }
  *(_QWORD *)(a1 + 16) = a2;
  ++*(_DWORD *)(a1 + 24);
}

_QWORD *re::TypeBuilderHelper::registerDynamicArray<unsigned long>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)a1 = a3;
  result = re::DynamicArray<re::EvaluationRegisterId<int>>::setCapacity((_QWORD *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<unsigned long>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)a1;
  if (result)
  {
    if (*(_QWORD *)(a1 + 32))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<unsigned long>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<unsigned long>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  char v4;

  re::TypeBuilderHelper::registerDynamicArray<unsigned long>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::operator()((uint64_t)&v4, a1, a2, a3, a4);
}

void re::TypeBuilderHelper::registerDynamicArray<unsigned long>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::operator()(uint64_t a1, uint64_t a2, uint64_t a3, re::Allocator *a4, unint64_t a5)
{
  uint64_t v9;
  _anonymous_namespace_ *v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  _BYTE v14[32];
  _BYTE v15[8];
  uint64_t v16;

  v9 = *(_QWORD *)a2;
  if (*(re::Allocator **)a2 == a4)
  {
    *(_QWORD *)(a2 + 16) = 0;
  }
  else
  {
    if (v9)
    {
      if (*(_QWORD *)(a2 + 32))
        (*(void (**)(uint64_t))(*(_QWORD *)v9 + 40))(v9);
      *(_QWORD *)(a2 + 32) = 0;
      *(_QWORD *)(a2 + 8) = 0;
      *(_QWORD *)(a2 + 16) = 0;
      ++*(_DWORD *)(a2 + 24);
    }
    *(_QWORD *)a2 = a4;
    re::DynamicArray<re::EvaluationRegisterId<int>>::setCapacity((_QWORD *)a2, a5);
  }
  ++*(_DWORD *)(a2 + 24);
  re::DynamicArray<unsigned long>::resize(a2, a5);
  {
    re::TypeRegistry::typeInfo(*(_QWORD **)a3, *(_QWORD *)(*(_QWORD *)(a3 + 16) + 72), v15);
    re::TypeInfo::TypeInfo((uint64_t)v14, (uint64_t)&v16);
    v11 = *(_QWORD *)(a2 + 16);
    if (v11)
    {
      v12 = *(char **)(a2 + 32);
      v13 = 8 * v11;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v14, v12, a4, 0);
        re::TypeInfo::construct((re::TypeInfo *)v14, (void **)v12, a4, 0);
        v12 += 8;
        v13 -= 8;
      }
      while (v13);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<unsigned long>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(_QWORD *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a1 + 32) + 8 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<unsigned long>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 16, 8);
  *(_QWORD *)result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<unsigned long>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unint64_t v4;
  uint64_t result;

  v2 = *(_QWORD *)a1;
  if (a1[2] == *(_DWORD *)(*(_QWORD *)a1 + 24))
  {
    v3 = a1[3];
    v4 = *(_QWORD *)(v2 + 16);
    if (v3 < (int)v4)
      a1[3] = ++v3;
    if (v4 <= v3)
      return 0;
    else
      return *(_QWORD *)(v2 + 32) + 8 * v3;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<unsigned long>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 40))(a2, result);
  return result;
}

void re::TypeBuilderHelper::registerDynamicArray<float>(re::TypeRegistry *a1@<X0>, uint64_t *a2@<X1>, __int128 *a3@<X2>, re::TypeRegistry **a4@<X8>)
{
  _anonymous_namespace_ *v8;
  re::TypeRegistry *v9;
  uint64_t v10;
  __int128 v11;
  _BYTE v12[488];

  v8 = (_anonymous_namespace_ *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a1 + 200, a2);
  if (a1 && v8)
  {
    v9 = *(re::TypeRegistry **)v8;
    *a4 = a1;
    a4[1] = v9;
  }
  else
  {
    v11 = *a3;
    re::TypeBuilder::beginListType((uint64_t)v12, a2, 1, 0x28uLL, 8uLL, &v11);
    re::TypeBuilder::setConstructor((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
    re::TypeBuilder::setDestructor((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
    re::TypeBuilder::setListUsesContiguousStorage((uint64_t)v12, 1);
    re::TypeBuilder::setListAccessors((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
    re::TypeBuilder::setListIndexer((uint64_t)v12, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
    re::TypeBuilder::setListIterator((uint64_t)v12, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
    re::TypeBuilder::commitTo((re::TypeBuilder *)v12, a1, a4);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v12, v10);
  }
}

_QWORD *re::IntrospectionDynamicArray<float>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<float>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x2276933B8);
}

void re::IntrospectionDynamicArray<float>::construct(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<float>::destroy(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = *(_QWORD *)a2;
  if (*(_QWORD *)a2)
  {
    if (*(_QWORD *)(a2 + 32))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a2 + 32) = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_QWORD *)a2 = 0;
    ++*(_DWORD *)(a2 + 24);
  }
  return result;
}

_QWORD *re::IntrospectionDynamicArray<float>::init(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  _QWORD *result;

  if (*a2)
  {
    if (a2[4])
      (*(void (**)(_QWORD))(*(_QWORD *)*a2 + 40))(*a2);
    a2[4] = 0;
    a2[1] = 0;
    a2[2] = 0;
    ++*((_DWORD *)a2 + 6);
  }
  *a2 = a3;
  result = re::DynamicArray<int>::setCapacity(a2, 0);
  ++*((_DWORD *)a2 + 6);
  return result;
}

void re::IntrospectionDynamicArray<float>::resize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  unint64_t v10;
  unint64_t i;

  if (!*(_QWORD *)a4)
  {
    *(_QWORD *)a4 = a2;
    re::DynamicArray<int>::setCapacity((_QWORD *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  v10 = *(_QWORD *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
      re::DynamicArray<float>::resize(a4, a5);
  }
  else
  {
    re::DynamicArray<int>::setCapacity((_QWORD *)a4, a5);
    for (i = a5 - *(_QWORD *)(a4 + 16); i; --i)
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, a3, a4);
  }
}

re::IntrospectionBase *re::IntrospectionDynamicArray<float>::addElement(uint64_t a1, re *a2, int a3, _anonymous_namespace_ *this)
{
  re::IntrospectionBase *v8;
  int v10;

  v10 = 0;
  re::DynamicArray<float>::add(this, (float *)&v10);
  v8 = (re::IntrospectionBase *)(*((_QWORD *)this + 4) + 4 * *((_QWORD *)this + 2) - 4);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v8);
  return v8;
}

uint64_t re::IntrospectionDynamicArray<float>::size(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<float>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 4 * a3;
}

{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 4 * a3;
}

void re::DynamicArray<float>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v4;
  void *v5;
  uint64_t v6;

  v4 = *(_QWORD *)(a1 + 16);
  if (v4 >= a2)
  {
    if (v4 <= a2)
      return;
  }
  else
  {
    if (*(_QWORD *)(a1 + 8) < a2)
    {
      re::DynamicArray<int>::setCapacity((_QWORD *)a1, a2);
      v4 = *(_QWORD *)(a1 + 16);
    }
    if (v4 < a2)
    {
      v5 = (void *)(*(_QWORD *)(a1 + 32) + 4 * v4);
      v6 = 4 * a2 - 4 * v4;
      if (v6 >= 1)
        bzero(v5, 4 * (((unint64_t)v6 >> 2) - ((unint64_t)v6 > 3)) + 4);
    }
  }
  *(_QWORD *)(a1 + 16) = a2;
  ++*(_DWORD *)(a1 + 24);
}

_QWORD *re::TypeBuilderHelper::registerDynamicArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)a1 = a3;
  result = re::DynamicArray<int>::setCapacity((_QWORD *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)a1;
  if (result)
  {
    if (*(_QWORD *)(a1 + 32))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  char v4;

  re::TypeBuilderHelper::registerDynamicArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::operator()((uint64_t)&v4, a1, a2, a3, a4);
}

void re::TypeBuilderHelper::registerDynamicArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::operator()(uint64_t a1, uint64_t a2, uint64_t a3, re::Allocator *a4, unint64_t a5)
{
  uint64_t v9;
  _anonymous_namespace_ *v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  _BYTE v14[32];
  _BYTE v15[8];
  uint64_t v16;

  v9 = *(_QWORD *)a2;
  if (*(re::Allocator **)a2 == a4)
  {
    *(_QWORD *)(a2 + 16) = 0;
  }
  else
  {
    if (v9)
    {
      if (*(_QWORD *)(a2 + 32))
        (*(void (**)(uint64_t))(*(_QWORD *)v9 + 40))(v9);
      *(_QWORD *)(a2 + 32) = 0;
      *(_QWORD *)(a2 + 8) = 0;
      *(_QWORD *)(a2 + 16) = 0;
      ++*(_DWORD *)(a2 + 24);
    }
    *(_QWORD *)a2 = a4;
    re::DynamicArray<int>::setCapacity((_QWORD *)a2, a5);
  }
  ++*(_DWORD *)(a2 + 24);
  re::DynamicArray<float>::resize(a2, a5);
  {
    re::TypeRegistry::typeInfo(*(_QWORD **)a3, *(_QWORD *)(*(_QWORD *)(a3 + 16) + 72), v15);
    re::TypeInfo::TypeInfo((uint64_t)v14, (uint64_t)&v16);
    v11 = *(_QWORD *)(a2 + 16);
    if (v11)
    {
      v12 = *(char **)(a2 + 32);
      v13 = 4 * v11;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v14, v12, a4, 0);
        re::TypeInfo::construct((re::TypeInfo *)v14, (void **)v12, a4, 0);
        v12 += 4;
        v13 -= 4;
      }
      while (v13);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(_QWORD *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a1 + 32) + 4 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 16, 8);
  *(_QWORD *)result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unint64_t v4;
  uint64_t result;

  v2 = *(_QWORD *)a1;
  if (a1[2] == *(_DWORD *)(*(_QWORD *)a1 + 24))
  {
    v3 = a1[3];
    v4 = *(_QWORD *)(v2 + 16);
    if (v3 < (int)v4)
      a1[3] = ++v3;
    if (v4 <= v3)
      return 0;
    else
      return *(_QWORD *)(v2 + 32) + 4 * v3;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 40))(a2, result);
  return result;
}

re::IntrospectionCStyleArray *re::IntrospectionCStyleArray::IntrospectionCStyleArray(re::IntrospectionCStyleArray *this)
{
  _QWORD *v2;

  ArcSharedObject::ArcSharedObject(this, 0);
  *(_QWORD *)((char *)v2 + 22) = 0;
  v2[2] = 0;
  v2[4] = 0;
  v2[5] = 0xFFFFFFFFLL;
  *v2 = &off_24ED23640;
  *((_QWORD *)this + 7) = 0;
  re::SerializedReference<re::IntrospectionBase const*>::reset(v2 + 6);
  *((_DWORD *)this + 16) = 0;
  return this;
}

void re::IntrospectionCStyleArray::~IntrospectionCStyleArray(re::IntrospectionCStyleArray *this)
{
  *(_QWORD *)this = &off_24ED23640;
  re::SerializedReference<re::IntrospectionBase const*>::reset((_QWORD *)this + 6);
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  *(_QWORD *)this = &off_24ED23640;
  re::SerializedReference<re::IntrospectionBase const*>::reset((_QWORD *)this + 6);
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

uint64_t re::IntrospectionCStyleArray::childInfoCount(re::IntrospectionCStyleArray *this)
{
  return 1;
}

uint64_t re::IntrospectionCStyleArray::childInfo(re::IntrospectionCStyleArray *this, uint64_t a2)
{
  uint64_t result;

  if (!a2)
    return *((_QWORD *)this + 6);
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Index out of range.", "index == 0", "childInfo", 449);
  result = _os_crash();
  __break(1u);
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::RigSplineIKJoint>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::RigSplineIKJoint>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x2276933B8);
}

void re::IntrospectionDynamicArray<re::RigSplineIKJoint>::construct(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::RigSplineIKJoint>::destroy(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = *(_QWORD *)a2;
  if (*(_QWORD *)a2)
  {
    if (*(_QWORD *)(a2 + 32))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a2 + 32) = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_QWORD *)a2 = 0;
    ++*(_DWORD *)(a2 + 24);
  }
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::RigSplineIKJoint>::init(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  _QWORD *result;

  if (*a2)
  {
    if (a2[4])
      (*(void (**)(_QWORD))(*(_QWORD *)*a2 + 40))(*a2);
    a2[4] = 0;
    a2[1] = 0;
    a2[2] = 0;
    ++*((_DWORD *)a2 + 6);
  }
  *a2 = a3;
  result = re::DynamicArray<re::RigSplineIKJoint>::setCapacity(a2, 0);
  ++*((_DWORD *)a2 + 6);
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::RigSplineIKJoint>::resize(_QWORD *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  _QWORD *v9;
  unint64_t v10;
  unint64_t i;

  v9 = result;
  if (!*(_QWORD *)a4)
  {
    *(_QWORD *)a4 = a2;
    result = re::DynamicArray<re::RigSplineIKJoint>::setCapacity((_QWORD *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  v10 = *(_QWORD *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
      return re::DynamicArray<re::RigSplineIKJoint>::resize((_QWORD *)a4, a5);
  }
  else
  {
    result = re::DynamicArray<re::RigSplineIKJoint>::setCapacity((_QWORD *)a4, a5);
    for (i = a5 - *(_QWORD *)(a4 + 16); i; --i)
      result = (_QWORD *)(*(uint64_t (**)(_QWORD *, uint64_t, uint64_t, uint64_t))(*v9 + 80))(v9, a2, a3, a4);
  }
  return result;
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::RigSplineIKJoint>::addElement(re::Allocator **a1, re *a2, int a3, uint64_t a4)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  BOOL v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  re::IntrospectionBase *v17;

  v8 = *(_QWORD *)(a4 + 8);
  v9 = *(_QWORD *)(a4 + 16);
  if (v9 >= v8)
  {
    v10 = v9 + 1;
    if (v8 < v9 + 1)
    {
      if (*(_QWORD *)a4)
      {
        v11 = 2 * v8;
        v12 = v8 == 0;
        v13 = 8;
        if (!v12)
          v13 = v11;
        if (v13 <= v10)
          v14 = v10;
        else
          v14 = v13;
        re::DynamicArray<re::RigSplineIKJoint>::setCapacity((_QWORD *)a4, v14);
      }
      else
      {
        re::DynamicArray<re::RigSplineIKJoint>::setCapacity((_QWORD *)a4, v10);
        ++*(_DWORD *)(a4 + 24);
      }
    }
    v9 = *(_QWORD *)(a4 + 16);
  }
  v15 = *(_QWORD *)(a4 + 32) + 80 * v9;
  *(_QWORD *)v15 = -1;
  *(_OWORD *)(v15 + 8) = 0u;
  *(_OWORD *)(v15 + 24) = 0u;
  *(_OWORD *)(v15 + 40) = 0u;
  *(_OWORD *)(v15 + 56) = 0u;
  *(_QWORD *)(v15 + 72) = 0;
  v16 = *(_QWORD *)(a4 + 16);
  *(_QWORD *)(a4 + 16) = v16 + 1;
  ++*(_DWORD *)(a4 + 24);
  v17 = (re::IntrospectionBase *)(*(_QWORD *)(a4 + 32) + 80 * v16);
  re::introspectionInitElement(a2, a3, a1[6], v17);
  return v17;
}

uint64_t re::IntrospectionDynamicArray<re::RigSplineIKJoint>::size(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::RigSplineIKJoint>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 80 * a3;
}

{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 80 * a3;
}

_QWORD *re::DynamicArray<re::RigSplineIKJoint>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  void *v7;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (*v5)
      {
        if (!a2)
        {
          v7 = 0;
          if (!v3)
            goto LABEL_9;
          goto LABEL_8;
        }
        if (is_mul_ok(a2, 0x50uLL))
        {
          v2 = 80 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 80 * a2, 16);
          if (result)
          {
            v7 = result;
            if (!v5[1])
            {
LABEL_9:
              v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            memcpy(v7, (const void *)v5[4], 80 * v5[2]);
            result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 80, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
      }
      else
      {
        result = (_QWORD *)re::DynamicArray<re::RigSplineIKJoint>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

_QWORD *re::DynamicArray<re::RigSplineIKJoint>::resize(_QWORD *result, unint64_t a2)
{
  _QWORD *v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  _OWORD v9[4];

  v3 = result;
  v4 = result[2];
  if (v4 >= a2)
  {
    if (v4 <= a2)
      return result;
  }
  else
  {
    if (result[1] < a2)
    {
      result = re::DynamicArray<re::RigSplineIKJoint>::setCapacity(result, a2);
      v4 = v3[2];
    }
    if (v4 < a2)
    {
      v5 = v3[4];
      v6 = v5 + 80 * v4;
      memset((char *)v9 + 8, 0, 56);
      v7 = v5 + 80 * a2 - v6;
      if (v7 >= 1)
      {
        v8 = v7 / 0x50uLL + 1;
        do
        {
          *(_QWORD *)v6 = -1;
          *(_OWORD *)(v6 + 24) = v9[1];
          *(_OWORD *)(v6 + 40) = v9[2];
          *(_OWORD *)(v6 + 56) = v9[3];
          *(_QWORD *)(v6 + 72) = 0;
          --v8;
          *(_OWORD *)(v6 + 8) = v9[0];
          v6 += 80;
        }
        while (v8 > 1);
      }
    }
  }
  v3[2] = a2;
  ++*((_DWORD *)v3 + 6);
  return result;
}

_QWORD *re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)a1 = a3;
  result = re::DynamicArray<re::RigSplineIKJoint>::setCapacity((_QWORD *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)a1;
  if (result)
  {
    if (*(_QWORD *)(a1 + 32))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  re::Allocator *v8;
  _anonymous_namespace_ *v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  _BYTE v13[32];
  _BYTE v14[8];
  uint64_t v15;

  v8 = *(re::Allocator **)a1;
  if (v8 == a3)
  {
    *(_QWORD *)(a1 + 16) = 0;
  }
  else
  {
    if (v8)
    {
      if (*(_QWORD *)(a1 + 32))
        (*(void (**)(re::Allocator *))(*(_QWORD *)v8 + 40))(v8);
      *(_QWORD *)(a1 + 32) = 0;
      *(_QWORD *)(a1 + 8) = 0;
      *(_QWORD *)(a1 + 16) = 0;
      ++*(_DWORD *)(a1 + 24);
    }
    *(_QWORD *)a1 = a3;
    re::DynamicArray<re::RigSplineIKJoint>::setCapacity((_QWORD *)a1, a4);
  }
  ++*(_DWORD *)(a1 + 24);
  v9 = (_anonymous_namespace_ *)re::DynamicArray<re::RigSplineIKJoint>::resize((_QWORD *)a1, a4);
  {
    re::TypeRegistry::typeInfo(*(_QWORD **)a2, *(_QWORD *)(*(_QWORD *)(a2 + 16) + 72), v14);
    re::TypeInfo::TypeInfo((uint64_t)v13, (uint64_t)&v15);
    v10 = *(_QWORD *)(a1 + 16);
    if (v10)
    {
      v11 = *(char **)(a1 + 32);
      v12 = 80 * v10;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v13, v11, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v13, (void **)v11, a3, 0);
        v11 += 80;
        v12 -= 80;
      }
      while (v12);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(_QWORD *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a1 + 32) + 80 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 16, 8);
  *(_QWORD *)result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unint64_t v4;
  uint64_t result;

  v2 = *(_QWORD *)a1;
  if (a1[2] == *(_DWORD *)(*(_QWORD *)a1 + 24))
  {
    v3 = a1[3];
    v4 = *(_QWORD *)(v2 + 16);
    if (v3 < (int)v4)
      a1[3] = ++v3;
    if (v4 <= v3)
      return 0;
    else
      return *(_QWORD *)(v2 + 32) + 80 * v3;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 40))(a2, result);
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::RigSplineIKControlPoint>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::RigSplineIKControlPoint>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x2276933B8);
}

void re::IntrospectionDynamicArray<re::RigSplineIKControlPoint>::construct(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::RigSplineIKControlPoint>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<re::RigSplineIKControlPoint>::deinit(a2);
}

_QWORD *re::IntrospectionDynamicArray<re::RigSplineIKControlPoint>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  re::DynamicArray<re::RigSplineIKControlPoint>::deinit(a2);
  *(_QWORD *)a2 = a3;
  result = re::DynamicArray<re::RigSplineIKControlPoint>::setCapacity((_QWORD *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::RigSplineIKControlPoint>::resize(_QWORD *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  _QWORD *v9;
  unint64_t v10;
  unint64_t i;

  v9 = result;
  if (!*(_QWORD *)a4)
  {
    *(_QWORD *)a4 = a2;
    result = re::DynamicArray<re::RigSplineIKControlPoint>::setCapacity((_QWORD *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  v10 = *(_QWORD *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
      return re::DynamicArray<re::RigSplineIKControlPoint>::resize((_QWORD *)a4, a5);
  }
  else
  {
    result = re::DynamicArray<re::RigSplineIKControlPoint>::setCapacity((_QWORD *)a4, a5);
    for (i = a5 - *(_QWORD *)(a4 + 16); i; --i)
      result = (_QWORD *)(*(uint64_t (**)(_QWORD *, uint64_t, uint64_t, uint64_t))(*v9 + 80))(v9, a2, a3, a4);
  }
  return result;
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::RigSplineIKControlPoint>::addElement(re::Allocator **a1, re *a2, int a3, uint64_t a4)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  BOOL v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  re::IntrospectionBase *v17;

  v8 = *(_QWORD *)(a4 + 8);
  v9 = *(_QWORD *)(a4 + 16);
  if (v9 >= v8)
  {
    v10 = v9 + 1;
    if (v8 < v9 + 1)
    {
      if (*(_QWORD *)a4)
      {
        v11 = 2 * v8;
        v12 = v8 == 0;
        v13 = 8;
        if (!v12)
          v13 = v11;
        if (v13 <= v10)
          v14 = v10;
        else
          v14 = v13;
        re::DynamicArray<re::RigSplineIKControlPoint>::setCapacity((_QWORD *)a4, v14);
      }
      else
      {
        re::DynamicArray<re::RigSplineIKControlPoint>::setCapacity((_QWORD *)a4, v10);
        ++*(_DWORD *)(a4 + 24);
      }
    }
    v9 = *(_QWORD *)(a4 + 16);
  }
  v15 = *(_QWORD *)(a4 + 32) + 96 * v9;
  *(_QWORD *)(v15 + 32) = 0;
  *(_QWORD *)(v15 + 40) = 0;
  *(_QWORD *)(v15 + 8) = 0;
  *(_QWORD *)(v15 + 16) = 0;
  *(_QWORD *)v15 = 0;
  *(_DWORD *)(v15 + 24) = 1;
  *(_DWORD *)(v15 + 64) = 0;
  *(_QWORD *)(v15 + 48) = 0;
  *(_QWORD *)(v15 + 56) = 0;
  *(_DWORD *)(v15 + 64) = 1;
  *(_QWORD *)(v15 + 80) = 0;
  *(_QWORD *)(v15 + 88) = 0;
  *(_QWORD *)(v15 + 72) = 0;
  v16 = *(_QWORD *)(a4 + 16);
  *(_QWORD *)(a4 + 16) = v16 + 1;
  ++*(_DWORD *)(a4 + 24);
  v17 = (re::IntrospectionBase *)(*(_QWORD *)(a4 + 32) + 96 * v16);
  re::introspectionInitElement(a2, a3, a1[6], v17);
  return v17;
}

uint64_t re::IntrospectionDynamicArray<re::RigSplineIKControlPoint>::size(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::RigSplineIKControlPoint>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 96 * a3;
}

{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 96 * a3;
}

uint64_t re::DynamicArray<re::RigSplineIKControlPoint>::deinit(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 96 * v4;
        v6 = (_QWORD *)(v3 + 40);
        do
        {
          v7 = v6 - 5;
          if (*v6)
          {
            if (v6[4])
              (*(void (**)(_QWORD))(*(_QWORD *)*v6 + 40))(*v6);
            v6[4] = 0;
            v6[1] = 0;
            v6[2] = 0;
            *v6 = 0;
            ++*((_DWORD *)v6 + 6);
          }
          if (*v7)
          {
            if (*(v6 - 1))
              (*(void (**)(_QWORD))(*(_QWORD *)*v7 + 40))(*v7);
            *(v6 - 1) = 0;
            *(v6 - 4) = 0;
            *(v6 - 3) = 0;
            *v7 = 0;
            ++*((_DWORD *)v6 - 4);
          }
          v6 += 12;
          v5 -= 96;
        }
        while (v5);
        result = *(_QWORD *)a1;
        v3 = *(_QWORD *)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

_QWORD *re::DynamicArray<re::RigSplineIKControlPoint>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::RigSplineIKControlPoint>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x60uLL))
        {
          v2 = 96 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 96 * a2, 16);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_16;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 96, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = 96 * v9;
        v11 = (uint64_t)v7;
        do
        {
          re::ObjectHelper::move<re::RigSplineIKControlPoint>(v8, v11);
          v8 += 96;
          v11 += 96;
          v10 -= 96;
        }
        while (v10);
        v8 = v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

uint64_t re::ObjectHelper::move<re::RigSplineIKControlPoint>(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t result;

  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
  v3 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a2 = *(_QWORD *)a1;
  *(_QWORD *)(a2 + 8) = v3;
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  v4 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v4;
  v5 = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 32) = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 32) = v5;
  ++*(_DWORD *)(a1 + 24);
  ++*(_DWORD *)(a2 + 24);
  *(_QWORD *)(a2 + 72) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  *(_DWORD *)(a2 + 64) = 0;
  v6 = *(_QWORD *)(a1 + 48);
  v7 = (_QWORD *)(a1 + 40);
  *(_QWORD *)(a2 + 40) = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a2 + 48) = v6;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  v8 = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 56) = *(_QWORD *)(a1 + 56);
  *(_QWORD *)(a1 + 56) = v8;
  v9 = *(_QWORD *)(a2 + 72);
  *(_QWORD *)(a2 + 72) = *(_QWORD *)(a1 + 72);
  *(_QWORD *)(a1 + 72) = v9;
  ++*(_DWORD *)(a1 + 64);
  ++*(_DWORD *)(a2 + 64);
  *(_OWORD *)(a2 + 80) = *(_OWORD *)(a1 + 80);
  v10 = *(_QWORD *)(a1 + 40);
  if (v10)
  {
    if (*(_QWORD *)(a1 + 72))
      (*(void (**)(uint64_t))(*(_QWORD *)v10 + 40))(v10);
    *(_QWORD *)(a1 + 72) = 0;
    v7[1] = 0;
    v7[2] = 0;
    *v7 = 0;
    ++*(_DWORD *)(a1 + 64);
  }
  result = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (*(_QWORD *)(a1 + 32))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

_QWORD *re::DynamicArray<re::RigSplineIKControlPoint>::resize(_QWORD *result, unint64_t a2)
{
  _QWORD *v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v3 = result;
  v4 = result[2];
  if (v4 >= a2)
  {
    if (v4 <= a2)
      return result;
    v8 = 96 * a2;
    v9 = a2;
    do
    {
      v10 = v3[4];
      v11 = v10 + v8;
      v12 = *(_QWORD *)(v10 + v8 + 40);
      if (v12)
      {
        if (*(_QWORD *)(v11 + 72))
          (*(void (**)(uint64_t))(*(_QWORD *)v12 + 40))(v12);
        *(_QWORD *)(v11 + 72) = 0;
        *(_QWORD *)(v10 + v8 + 48) = 0;
        *(_QWORD *)(v10 + v8 + 56) = 0;
        *(_QWORD *)(v10 + v8 + 40) = 0;
        ++*(_DWORD *)(v10 + v8 + 64);
      }
      result = *(_QWORD **)v11;
      if (*(_QWORD *)v11)
      {
        v13 = v10 + v8;
        if (*(_QWORD *)(v13 + 32))
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 40))(result);
        *(_QWORD *)(v13 + 32) = 0;
        *(_QWORD *)(v11 + 8) = 0;
        *(_QWORD *)(v11 + 16) = 0;
        *(_QWORD *)v11 = 0;
        ++*(_DWORD *)(v13 + 24);
      }
      ++v9;
      v8 += 96;
    }
    while (v9 < v3[2]);
  }
  else
  {
    if (result[1] < a2)
    {
      result = re::DynamicArray<re::RigSplineIKControlPoint>::setCapacity(result, a2);
      v4 = v3[2];
    }
    v5 = a2 - v4;
    if (a2 > v4)
    {
      v6 = 96 * v4;
      do
      {
        v7 = v3[4] + v6;
        *(_QWORD *)v7 = 0;
        *(_QWORD *)(v7 + 8) = 0;
        *(_DWORD *)(v7 + 24) = 0;
        *(_QWORD *)(v7 + 16) = 0;
        *(_OWORD *)(v7 + 32) = 0uLL;
        *(_OWORD *)(v7 + 48) = 0uLL;
        *(_DWORD *)(v7 + 64) = 0;
        *(_QWORD *)(v7 + 80) = 0;
        *(_QWORD *)(v7 + 88) = 0;
        *(_QWORD *)(v7 + 72) = 0;
        v6 += 96;
        --v5;
      }
      while (v5);
    }
  }
  v3[2] = a2;
  ++*((_DWORD *)v3 + 6);
  return result;
}

_QWORD *re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKControlPoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)a1 = a3;
  result = re::DynamicArray<re::RigSplineIKControlPoint>::setCapacity((_QWORD *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKControlPoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKControlPoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  _anonymous_namespace_ *v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  _BYTE v12[32];
  _BYTE v13[8];
  uint64_t v14;

  if (*(re::Allocator **)a1 == a3)
  {
    re::DynamicArray<re::RigSplineIKControlPoint>::clear((_QWORD *)a1);
  }
  else
  {
    re::DynamicArray<re::RigSplineIKControlPoint>::deinit(a1);
    *(_QWORD *)a1 = a3;
    re::DynamicArray<re::RigSplineIKControlPoint>::setCapacity((_QWORD *)a1, a4);
    ++*(_DWORD *)(a1 + 24);
  }
  v8 = (_anonymous_namespace_ *)re::DynamicArray<re::RigSplineIKControlPoint>::resize((_QWORD *)a1, a4);
  {
    re::TypeRegistry::typeInfo(*(_QWORD **)a2, *(_QWORD *)(*(_QWORD *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    v9 = *(_QWORD *)(a1 + 16);
    if (v9)
    {
      v10 = *(char **)(a1 + 32);
      v11 = 96 * v9;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 96;
        v11 -= 96;
      }
      while (v11);
    }
  }
}

_QWORD *re::DynamicArray<re::RigSplineIKControlPoint>::clear(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  _QWORD **v5;

  v1 = result;
  v2 = result[2];
  result[2] = 0;
  if (v2)
  {
    v3 = 96 * v2;
    v4 = (_QWORD *)(result[4] + 40);
    do
    {
      v5 = (_QWORD **)(v4 - 5);
      if (*v4)
      {
        if (v4[4])
          (*(void (**)(_QWORD))(*(_QWORD *)*v4 + 40))(*v4);
        v4[4] = 0;
        v4[1] = 0;
        v4[2] = 0;
        *v4 = 0;
        ++*((_DWORD *)v4 + 6);
      }
      result = *v5;
      if (*v5)
      {
        if (*(v4 - 1))
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 40))(result);
        *(v4 - 1) = 0;
        *(v4 - 4) = 0;
        *(v4 - 3) = 0;
        *v5 = 0;
        ++*((_DWORD *)v4 - 4);
      }
      v4 += 12;
      v3 -= 96;
    }
    while (v3);
  }
  ++*((_DWORD *)v1 + 6);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKControlPoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(_QWORD *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a1 + 32) + 96 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKControlPoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 16, 8);
  *(_QWORD *)result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKControlPoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unint64_t v4;
  uint64_t result;

  v2 = *(_QWORD *)a1;
  if (a1[2] == *(_DWORD *)(*(_QWORD *)a1 + 24))
  {
    v3 = a1[3];
    v4 = *(_QWORD *)(v2 + 16);
    if (v3 < (int)v4)
      a1[3] = ++v3;
    if (v4 <= v3)
      return 0;
    else
      return *(_QWORD *)(v2 + 32) + 96 * v3;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKControlPoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 40))(a2, result);
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::RigComponentConstraint>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::RigComponentConstraint>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x2276933B8);
}

void re::IntrospectionDynamicArray<re::RigComponentConstraint>::construct(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::RigComponentConstraint>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<re::RigComponentConstraint>::deinit(a2);
}

_QWORD *re::IntrospectionDynamicArray<re::RigComponentConstraint>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  re::DynamicArray<re::RigComponentConstraint>::deinit(a2);
  *(_QWORD *)a2 = a3;
  result = re::DynamicArray<re::RigComponentConstraint>::setCapacity((_QWORD *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::RigComponentConstraint>::resize(_QWORD *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  _QWORD *v9;
  unint64_t v10;
  unint64_t i;

  v9 = result;
  if (!*(_QWORD *)a4)
  {
    *(_QWORD *)a4 = a2;
    result = re::DynamicArray<re::RigComponentConstraint>::setCapacity((_QWORD *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  v10 = *(_QWORD *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
      return re::DynamicArray<re::RigComponentConstraint>::resize((_QWORD *)a4, a5);
  }
  else
  {
    result = re::DynamicArray<re::RigComponentConstraint>::setCapacity((_QWORD *)a4, a5);
    for (i = a5 - *(_QWORD *)(a4 + 16); i; --i)
      result = (_QWORD *)(*(uint64_t (**)(_QWORD *, uint64_t, uint64_t, uint64_t))(*v9 + 80))(v9, a2, a3, a4);
  }
  return result;
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::RigComponentConstraint>::addElement(uint64_t a1, re *a2, int a3, _anonymous_namespace_ *this)
{
  re::IntrospectionBase *v8;
  _OWORD v10[2];
  __int128 v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;

  v14 = 0;
  v12 = 0u;
  v13 = 0u;
  v11 = 0u;
  memset(v10, 0, sizeof(v10));
  re::DynamicArray<re::RigComponentConstraint>::add(this, (__int16 *)v10);
  if ((_QWORD)v12)
  {
    if (v14)
      (*(void (**)(void))(*(_QWORD *)v12 + 40))();
    v14 = 0;
    *(_QWORD *)&v13 = 0;
    v12 = 0uLL;
    ++DWORD2(v13);
  }
  if (*((_QWORD *)&v10[0] + 1) && *((_QWORD *)&v11 + 1))
    (*(void (**)(void))(**((_QWORD **)&v10[0] + 1) + 40))();
  v8 = (re::IntrospectionBase *)(*((_QWORD *)this + 4) + 88 * *((_QWORD *)this + 2) - 88);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v8);
  return v8;
}

uint64_t re::IntrospectionDynamicArray<re::RigComponentConstraint>::size(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::RigComponentConstraint>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 88 * a3;
}

{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 88 * a3;
}

uint64_t re::DynamicArray<re::RigComponentConstraint>::deinit(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 88 * v4;
        v6 = v3 + 40;
        do
        {
          v7 = *(_QWORD *)(v6 + 8);
          if (v7)
          {
            if (*(_QWORD *)(v6 + 40))
              (*(void (**)(uint64_t))(*(_QWORD *)v7 + 40))(v7);
            *(_QWORD *)(v6 + 40) = 0;
            *(_QWORD *)(v6 + 16) = 0;
            *(_QWORD *)(v6 + 24) = 0;
            *(_QWORD *)(v6 + 8) = 0;
            ++*(_DWORD *)(v6 + 32);
          }
          v8 = *(_QWORD *)(v6 - 32);
          if (v8)
          {
            if (*(_QWORD *)v6)
              (*(void (**)(uint64_t))(*(_QWORD *)v8 + 40))(v8);
            *(_QWORD *)v6 = 0;
            *(_QWORD *)(v6 - 24) = 0;
            *(_QWORD *)(v6 - 16) = 0;
            *(_QWORD *)(v6 - 32) = 0;
            ++*(_DWORD *)(v6 - 8);
          }
          v6 += 88;
          v5 -= 88;
        }
        while (v5);
        result = *(_QWORD *)a1;
        v3 = *(_QWORD *)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

_QWORD *re::DynamicArray<re::RigComponentConstraint>::resize(_QWORD *result, unint64_t a2)
{
  _QWORD *v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  uint64_t v15;

  v3 = result;
  v4 = result[2];
  if (v4 >= a2)
  {
    if (v4 <= a2)
      return result;
    v8 = 88 * a2;
    v9 = a2;
    do
    {
      v10 = v3[4];
      v11 = v10 + v8;
      v12 = *(_QWORD *)(v10 + v8 + 48);
      if (v12)
      {
        if (*(_QWORD *)(v11 + 80))
          (*(void (**)(uint64_t))(*(_QWORD *)v12 + 40))(v12);
        *(_QWORD *)(v11 + 80) = 0;
        *(_QWORD *)(v10 + v8 + 56) = 0;
        *(_QWORD *)(v10 + v8 + 64) = 0;
        *(_QWORD *)(v10 + v8 + 48) = 0;
        ++*(_DWORD *)(v10 + v8 + 72);
      }
      v14 = *(_QWORD **)(v11 + 8);
      v13 = (_QWORD *)(v11 + 8);
      result = v14;
      if (v14)
      {
        v15 = v10 + v8;
        if (*(_QWORD *)(v15 + 40))
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 40))(result);
        *(_QWORD *)(v15 + 40) = 0;
        v13[1] = 0;
        v13[2] = 0;
        *v13 = 0;
        ++*(_DWORD *)(v15 + 32);
      }
      ++v9;
      v8 += 88;
    }
    while (v9 < v3[2]);
  }
  else
  {
    if (result[1] < a2)
    {
      result = re::DynamicArray<re::RigComponentConstraint>::setCapacity(result, a2);
      v4 = v3[2];
    }
    v5 = a2 - v4;
    if (a2 > v4)
    {
      v6 = 88 * v4;
      do
      {
        v7 = v3[4] + v6;
        *(_BYTE *)v7 = 0;
        *(_WORD *)(v7 + 1) = 0;
        *(_QWORD *)(v7 + 16) = 0;
        *(_QWORD *)(v7 + 24) = 0;
        *(_QWORD *)(v7 + 8) = 0;
        *(_DWORD *)(v7 + 32) = 0;
        *(_QWORD *)(v7 + 80) = 0;
        *(_OWORD *)(v7 + 40) = 0uLL;
        *(_OWORD *)(v7 + 56) = 0uLL;
        *(_DWORD *)(v7 + 72) = 0;
        v6 += 88;
        --v5;
      }
      while (v5);
    }
  }
  v3[2] = a2;
  ++*((_DWORD *)v3 + 6);
  return result;
}

_QWORD *re::TypeBuilderHelper::registerDynamicArray<re::RigComponentConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)a1 = a3;
  result = re::DynamicArray<re::RigComponentConstraint>::setCapacity((_QWORD *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigComponentConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::RigComponentConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  _anonymous_namespace_ *v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  _BYTE v12[32];
  _BYTE v13[8];
  uint64_t v14;

  if (*(re::Allocator **)a1 == a3)
  {
    re::DynamicArray<re::RigComponentConstraint>::clear((_QWORD *)a1);
  }
  else
  {
    re::DynamicArray<re::RigComponentConstraint>::deinit(a1);
    *(_QWORD *)a1 = a3;
    re::DynamicArray<re::RigComponentConstraint>::setCapacity((_QWORD *)a1, a4);
    ++*(_DWORD *)(a1 + 24);
  }
  v8 = (_anonymous_namespace_ *)re::DynamicArray<re::RigComponentConstraint>::resize((_QWORD *)a1, a4);
  {
    re::TypeRegistry::typeInfo(*(_QWORD **)a2, *(_QWORD *)(*(_QWORD *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    v9 = *(_QWORD *)(a1 + 16);
    if (v9)
    {
      v10 = *(char **)(a1 + 32);
      v11 = 88 * v9;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 88;
        v11 -= 88;
      }
      while (v11);
    }
  }
}

_QWORD *re::DynamicArray<re::RigComponentConstraint>::clear(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v1 = result;
  v2 = result[2];
  result[2] = 0;
  if (v2)
  {
    v3 = 88 * v2;
    v4 = result[4] + 40;
    do
    {
      v5 = *(_QWORD *)(v4 + 8);
      if (v5)
      {
        if (*(_QWORD *)(v4 + 40))
          (*(void (**)(uint64_t))(*(_QWORD *)v5 + 40))(v5);
        *(_QWORD *)(v4 + 40) = 0;
        *(_QWORD *)(v4 + 16) = 0;
        *(_QWORD *)(v4 + 24) = 0;
        *(_QWORD *)(v4 + 8) = 0;
        ++*(_DWORD *)(v4 + 32);
      }
      result = *(_QWORD **)(v4 - 32);
      if (result)
      {
        if (*(_QWORD *)v4)
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 40))(result);
        *(_QWORD *)v4 = 0;
        *(_QWORD *)(v4 - 24) = 0;
        *(_QWORD *)(v4 - 16) = 0;
        *(_QWORD *)(v4 - 32) = 0;
        ++*(_DWORD *)(v4 - 8);
      }
      v4 += 88;
      v3 -= 88;
    }
    while (v3);
  }
  ++*((_DWORD *)v1 + 6);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigComponentConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(_QWORD *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a1 + 32) + 88 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigComponentConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 16, 8);
  *(_QWORD *)result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigComponentConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unint64_t v4;
  uint64_t result;

  v2 = *(_QWORD *)a1;
  if (a1[2] == *(_DWORD *)(*(_QWORD *)a1 + 24))
  {
    v3 = a1[3];
    v4 = *(_QWORD *)(v2 + 16);
    if (v3 < (int)v4)
      a1[3] = ++v3;
    if (v4 <= v3)
      return 0;
    else
      return *(_QWORD *)(v2 + 32) + 88 * v3;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigComponentConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 40))(a2, result);
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::RigBasicConstraint>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::RigBasicConstraint>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x2276933B8);
}

void re::IntrospectionDynamicArray<re::RigBasicConstraint>::construct(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::RigBasicConstraint>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<re::RigBasicConstraint>::deinit(a2);
}

_QWORD *re::IntrospectionDynamicArray<re::RigBasicConstraint>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  re::DynamicArray<re::RigBasicConstraint>::deinit(a2);
  *(_QWORD *)a2 = a3;
  result = re::DynamicArray<re::RigBasicConstraint>::setCapacity((_QWORD *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::RigBasicConstraint>::resize(_QWORD *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  _QWORD *v9;
  unint64_t v10;
  unint64_t i;

  v9 = result;
  if (!*(_QWORD *)a4)
  {
    *(_QWORD *)a4 = a2;
    result = re::DynamicArray<re::RigBasicConstraint>::setCapacity((_QWORD *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  v10 = *(_QWORD *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
      return re::DynamicArray<re::RigBasicConstraint>::resize((_QWORD *)a4, a5);
  }
  else
  {
    result = re::DynamicArray<re::RigBasicConstraint>::setCapacity((_QWORD *)a4, a5);
    for (i = a5 - *(_QWORD *)(a4 + 16); i; --i)
      result = (_QWORD *)(*(uint64_t (**)(_QWORD *, uint64_t, uint64_t, uint64_t))(*v9 + 80))(v9, a2, a3, a4);
  }
  return result;
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::RigBasicConstraint>::addElement(uint64_t a1, re *a2, int a3, _anonymous_namespace_ *this)
{
  re::IntrospectionBase *v8;
  _OWORD v10[2];
  __int128 v11;
  __int128 v12;
  __int128 v13;

  v12 = 0u;
  v13 = 0u;
  v11 = 0u;
  memset(v10, 0, sizeof(v10));
  re::DynamicArray<re::RigBasicConstraint>::add(this, (uint64_t)v10);
  if (*((_QWORD *)&v11 + 1))
  {
    if (*((_QWORD *)&v13 + 1))
      (*(void (**)(void))(**((_QWORD **)&v11 + 1) + 40))();
    *((_QWORD *)&v13 + 1) = 0;
    v12 = 0uLL;
    *((_QWORD *)&v11 + 1) = 0;
    LODWORD(v13) = v13 + 1;
  }
  if (*(_QWORD *)&v10[0] && (_QWORD)v11)
    (*(void (**)(void))(**(_QWORD **)&v10[0] + 40))();
  v8 = (re::IntrospectionBase *)(*((_QWORD *)this + 4) + 80 * *((_QWORD *)this + 2) - 80);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v8);
  return v8;
}

uint64_t re::IntrospectionDynamicArray<re::RigBasicConstraint>::size(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::RigBasicConstraint>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 80 * a3;
}

{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 80 * a3;
}

uint64_t re::DynamicArray<re::RigBasicConstraint>::deinit(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 80 * v4;
        v6 = (_QWORD *)(v3 + 40);
        do
        {
          v7 = v6 - 5;
          if (*v6)
          {
            if (v6[4])
              (*(void (**)(_QWORD))(*(_QWORD *)*v6 + 40))(*v6);
            v6[4] = 0;
            v6[1] = 0;
            v6[2] = 0;
            *v6 = 0;
            ++*((_DWORD *)v6 + 6);
          }
          if (*v7)
          {
            if (*(v6 - 1))
              (*(void (**)(_QWORD))(*(_QWORD *)*v7 + 40))(*v7);
            *(v6 - 1) = 0;
            *(v6 - 4) = 0;
            *(v6 - 3) = 0;
            *v7 = 0;
            ++*((_DWORD *)v6 - 4);
          }
          v6 += 10;
          v5 -= 80;
        }
        while (v5);
        result = *(_QWORD *)a1;
        v3 = *(_QWORD *)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

_QWORD *re::DynamicArray<re::RigBasicConstraint>::resize(_QWORD *result, unint64_t a2)
{
  _QWORD *v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v3 = result;
  v4 = result[2];
  if (v4 >= a2)
  {
    if (v4 <= a2)
      return result;
    v8 = 80 * a2;
    v9 = a2;
    do
    {
      v10 = v3[4];
      v11 = v10 + v8;
      v12 = *(_QWORD *)(v10 + v8 + 40);
      if (v12)
      {
        if (*(_QWORD *)(v11 + 72))
          (*(void (**)(uint64_t))(*(_QWORD *)v12 + 40))(v12);
        *(_QWORD *)(v11 + 72) = 0;
        *(_QWORD *)(v10 + v8 + 48) = 0;
        *(_QWORD *)(v10 + v8 + 56) = 0;
        *(_QWORD *)(v10 + v8 + 40) = 0;
        ++*(_DWORD *)(v10 + v8 + 64);
      }
      result = *(_QWORD **)v11;
      if (*(_QWORD *)v11)
      {
        v13 = v10 + v8;
        if (*(_QWORD *)(v13 + 32))
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 40))(result);
        *(_QWORD *)(v13 + 32) = 0;
        *(_QWORD *)(v11 + 8) = 0;
        *(_QWORD *)(v11 + 16) = 0;
        *(_QWORD *)v11 = 0;
        ++*(_DWORD *)(v13 + 24);
      }
      ++v9;
      v8 += 80;
    }
    while (v9 < v3[2]);
  }
  else
  {
    if (result[1] < a2)
    {
      result = re::DynamicArray<re::RigBasicConstraint>::setCapacity(result, a2);
      v4 = v3[2];
    }
    v5 = a2 - v4;
    if (a2 > v4)
    {
      v6 = 80 * v4;
      do
      {
        v7 = v3[4] + v6;
        *(_QWORD *)v7 = 0;
        *(_QWORD *)(v7 + 8) = 0;
        *(_DWORD *)(v7 + 24) = 0;
        *(_QWORD *)(v7 + 16) = 0;
        *(_QWORD *)(v7 + 72) = 0;
        *(_OWORD *)(v7 + 32) = 0uLL;
        *(_OWORD *)(v7 + 48) = 0uLL;
        *(_DWORD *)(v7 + 64) = 0;
        v6 += 80;
        --v5;
      }
      while (v5);
    }
  }
  v3[2] = a2;
  ++*((_DWORD *)v3 + 6);
  return result;
}

_QWORD *re::TypeBuilderHelper::registerDynamicArray<re::RigBasicConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)a1 = a3;
  result = re::DynamicArray<re::RigBasicConstraint>::setCapacity((_QWORD *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigBasicConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::RigBasicConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  _anonymous_namespace_ *v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  _BYTE v12[32];
  _BYTE v13[8];
  uint64_t v14;

  if (*(re::Allocator **)a1 == a3)
  {
    re::DynamicArray<re::RigBasicConstraint>::clear((_QWORD *)a1);
  }
  else
  {
    re::DynamicArray<re::RigBasicConstraint>::deinit(a1);
    *(_QWORD *)a1 = a3;
    re::DynamicArray<re::RigBasicConstraint>::setCapacity((_QWORD *)a1, a4);
    ++*(_DWORD *)(a1 + 24);
  }
  v8 = (_anonymous_namespace_ *)re::DynamicArray<re::RigBasicConstraint>::resize((_QWORD *)a1, a4);
  {
    re::TypeRegistry::typeInfo(*(_QWORD **)a2, *(_QWORD *)(*(_QWORD *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    v9 = *(_QWORD *)(a1 + 16);
    if (v9)
    {
      v10 = *(char **)(a1 + 32);
      v11 = 80 * v9;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 80;
        v11 -= 80;
      }
      while (v11);
    }
  }
}

_QWORD *re::DynamicArray<re::RigBasicConstraint>::clear(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  _QWORD **v5;

  v1 = result;
  v2 = result[2];
  result[2] = 0;
  if (v2)
  {
    v3 = 80 * v2;
    v4 = (_QWORD *)(result[4] + 40);
    do
    {
      v5 = (_QWORD **)(v4 - 5);
      if (*v4)
      {
        if (v4[4])
          (*(void (**)(_QWORD))(*(_QWORD *)*v4 + 40))(*v4);
        v4[4] = 0;
        v4[1] = 0;
        v4[2] = 0;
        *v4 = 0;
        ++*((_DWORD *)v4 + 6);
      }
      result = *v5;
      if (*v5)
      {
        if (*(v4 - 1))
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 40))(result);
        *(v4 - 1) = 0;
        *(v4 - 4) = 0;
        *(v4 - 3) = 0;
        *v5 = 0;
        ++*((_DWORD *)v4 - 4);
      }
      v4 += 10;
      v3 -= 80;
    }
    while (v3);
  }
  ++*((_DWORD *)v1 + 6);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigBasicConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(_QWORD *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a1 + 32) + 80 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigBasicConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 16, 8);
  *(_QWORD *)result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigBasicConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unint64_t v4;
  uint64_t result;

  v2 = *(_QWORD *)a1;
  if (a1[2] == *(_DWORD *)(*(_QWORD *)a1 + 24))
  {
    v3 = a1[3];
    v4 = *(_QWORD *)(v2 + 16);
    if (v3 < (int)v4)
      a1[3] = ++v3;
    if (v4 <= v3)
      return 0;
    else
      return *(_QWORD *)(v2 + 32) + 80 * v3;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigBasicConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 40))(a2, result);
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::RigAimConstraint>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::RigAimConstraint>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x2276933B8);
}

void re::IntrospectionDynamicArray<re::RigAimConstraint>::construct(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::RigAimConstraint>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<re::RigAimConstraint>::deinit(a2);
}

_QWORD *re::IntrospectionDynamicArray<re::RigAimConstraint>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  re::DynamicArray<re::RigAimConstraint>::deinit(a2);
  *(_QWORD *)a2 = a3;
  result = re::DynamicArray<re::RigAimConstraint>::setCapacity((_QWORD *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::RigAimConstraint>::resize(_QWORD *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  _QWORD *v9;
  unint64_t v10;
  unint64_t i;

  v9 = result;
  if (!*(_QWORD *)a4)
  {
    *(_QWORD *)a4 = a2;
    result = re::DynamicArray<re::RigAimConstraint>::setCapacity((_QWORD *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  v10 = *(_QWORD *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
      return re::DynamicArray<re::RigAimConstraint>::resize((_QWORD *)a4, a5);
  }
  else
  {
    result = re::DynamicArray<re::RigAimConstraint>::setCapacity((_QWORD *)a4, a5);
    for (i = a5 - *(_QWORD *)(a4 + 16); i; --i)
      result = (_QWORD *)(*(uint64_t (**)(_QWORD *, uint64_t, uint64_t, uint64_t))(*v9 + 80))(v9, a2, a3, a4);
  }
  return result;
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::RigAimConstraint>::addElement(uint64_t a1, re *a2, int a3, _anonymous_namespace_ *this)
{
  __n128 v8;
  re::IntrospectionBase *v9;
  _OWORD v11[3];
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  v16 = 0u;
  v14 = 0u;
  v15 = 0u;
  v12 = 0u;
  v13 = 0u;
  memset(v11, 0, sizeof(v11));
  v17 = 0xFFFFFFFFFFFFFFFFLL;
  v8 = re::DynamicArray<re::RigAimConstraint>::add(this, (uint64_t)v11);
  if (*((_QWORD *)&v14 + 1))
  {
    if (*((_QWORD *)&v16 + 1))
      (*(void (**)(__n128))(**((_QWORD **)&v14 + 1) + 40))(v8);
    *((_QWORD *)&v16 + 1) = 0;
    v15 = 0uLL;
    *((_QWORD *)&v14 + 1) = 0;
    LODWORD(v16) = v16 + 1;
  }
  if ((_QWORD)v12 && (_QWORD)v14)
    (*(void (**)(__n128))(*(_QWORD *)v12 + 40))(v8);
  v9 = (re::IntrospectionBase *)(*((_QWORD *)this + 4) + 144 * *((_QWORD *)this + 2) - 144);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v9);
  return v9;
}

uint64_t re::IntrospectionDynamicArray<re::RigAimConstraint>::size(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::RigAimConstraint>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 144 * a3;
}

{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 144 * a3;
}

uint64_t re::DynamicArray<re::RigAimConstraint>::deinit(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 144 * v4;
        v6 = v3 + 72;
        do
        {
          v7 = *(_QWORD *)(v6 + 16);
          if (v7)
          {
            if (*(_QWORD *)(v6 + 48))
              (*(void (**)(uint64_t))(*(_QWORD *)v7 + 40))(v7);
            *(_QWORD *)(v6 + 48) = 0;
            *(_QWORD *)(v6 + 24) = 0;
            *(_QWORD *)(v6 + 32) = 0;
            *(_QWORD *)(v6 + 16) = 0;
            ++*(_DWORD *)(v6 + 40);
          }
          v8 = *(_QWORD *)(v6 - 24);
          if (v8)
          {
            if (*(_QWORD *)(v6 + 8))
              (*(void (**)(uint64_t))(*(_QWORD *)v8 + 40))(v8);
            *(_QWORD *)(v6 + 8) = 0;
            *(_QWORD *)(v6 - 16) = 0;
            *(_QWORD *)(v6 - 8) = 0;
            *(_QWORD *)(v6 - 24) = 0;
            ++*(_DWORD *)v6;
          }
          v6 += 144;
          v5 -= 144;
        }
        while (v5);
        result = *(_QWORD *)a1;
        v3 = *(_QWORD *)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

_QWORD *re::DynamicArray<re::RigAimConstraint>::resize(_QWORD *result, unint64_t a2)
{
  _QWORD *v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  uint64_t v15;

  v3 = result;
  v4 = result[2];
  if (v4 >= a2)
  {
    if (v4 <= a2)
      return result;
    v8 = 144 * a2;
    v9 = a2;
    do
    {
      v10 = v3[4];
      v11 = v10 + v8;
      v12 = *(_QWORD *)(v10 + v8 + 88);
      if (v12)
      {
        if (*(_QWORD *)(v11 + 120))
          (*(void (**)(uint64_t))(*(_QWORD *)v12 + 40))(v12);
        *(_QWORD *)(v11 + 120) = 0;
        *(_QWORD *)(v10 + v8 + 96) = 0;
        *(_QWORD *)(v10 + v8 + 104) = 0;
        *(_QWORD *)(v10 + v8 + 88) = 0;
        ++*(_DWORD *)(v10 + v8 + 112);
      }
      v14 = *(_QWORD **)(v11 + 48);
      v13 = (_QWORD *)(v11 + 48);
      result = v14;
      if (v14)
      {
        v15 = v10 + v8;
        if (*(_QWORD *)(v15 + 80))
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 40))(result);
        *(_QWORD *)(v15 + 80) = 0;
        v13[1] = 0;
        v13[2] = 0;
        *v13 = 0;
        ++*(_DWORD *)(v15 + 72);
      }
      ++v9;
      v8 += 144;
    }
    while (v9 < v3[2]);
  }
  else
  {
    if (result[1] < a2)
    {
      result = re::DynamicArray<re::RigAimConstraint>::setCapacity(result, a2);
      v4 = v3[2];
    }
    v5 = a2 - v4;
    if (a2 > v4)
    {
      v6 = 144 * v4;
      do
      {
        v7 = v3[4] + v6;
        *(_DWORD *)v7 = 0;
        *(_BYTE *)(v7 + 4) = 0;
        *(_OWORD *)(v7 + 16) = 0uLL;
        *(_OWORD *)(v7 + 32) = 0uLL;
        *(_OWORD *)(v7 + 48) = 0uLL;
        *(_OWORD *)(v7 + 60) = 0uLL;
        *(_OWORD *)(v7 + 80) = 0uLL;
        *(_OWORD *)(v7 + 96) = 0uLL;
        *(_DWORD *)(v7 + 112) = 0;
        *(_QWORD *)(v7 + 120) = 0;
        *(_QWORD *)(v7 + 128) = -1;
        v6 += 144;
        --v5;
      }
      while (v5);
    }
  }
  v3[2] = a2;
  ++*((_DWORD *)v3 + 6);
  return result;
}

_QWORD *re::TypeBuilderHelper::registerDynamicArray<re::RigAimConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)a1 = a3;
  result = re::DynamicArray<re::RigAimConstraint>::setCapacity((_QWORD *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigAimConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::RigAimConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  _anonymous_namespace_ *v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  _BYTE v12[32];
  _BYTE v13[8];
  uint64_t v14;

  if (*(re::Allocator **)a1 == a3)
  {
    re::DynamicArray<re::RigAimConstraint>::clear((_QWORD *)a1);
  }
  else
  {
    re::DynamicArray<re::RigAimConstraint>::deinit(a1);
    *(_QWORD *)a1 = a3;
    re::DynamicArray<re::RigAimConstraint>::setCapacity((_QWORD *)a1, a4);
    ++*(_DWORD *)(a1 + 24);
  }
  v8 = (_anonymous_namespace_ *)re::DynamicArray<re::RigAimConstraint>::resize((_QWORD *)a1, a4);
  {
    re::TypeRegistry::typeInfo(*(_QWORD **)a2, *(_QWORD *)(*(_QWORD *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    v9 = *(_QWORD *)(a1 + 16);
    if (v9)
    {
      v10 = *(char **)(a1 + 32);
      v11 = 144 * v9;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 144;
        v11 -= 144;
      }
      while (v11);
    }
  }
}

_QWORD *re::DynamicArray<re::RigAimConstraint>::clear(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v1 = result;
  v2 = result[2];
  result[2] = 0;
  if (v2)
  {
    v3 = 144 * v2;
    v4 = result[4] + 72;
    do
    {
      v5 = *(_QWORD *)(v4 + 16);
      if (v5)
      {
        if (*(_QWORD *)(v4 + 48))
          (*(void (**)(uint64_t))(*(_QWORD *)v5 + 40))(v5);
        *(_QWORD *)(v4 + 48) = 0;
        *(_QWORD *)(v4 + 24) = 0;
        *(_QWORD *)(v4 + 32) = 0;
        *(_QWORD *)(v4 + 16) = 0;
        ++*(_DWORD *)(v4 + 40);
      }
      result = *(_QWORD **)(v4 - 24);
      if (result)
      {
        if (*(_QWORD *)(v4 + 8))
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 40))(result);
        *(_QWORD *)(v4 + 8) = 0;
        *(_QWORD *)(v4 - 16) = 0;
        *(_QWORD *)(v4 - 8) = 0;
        *(_QWORD *)(v4 - 24) = 0;
        ++*(_DWORD *)v4;
      }
      v4 += 144;
      v3 -= 144;
    }
    while (v3);
  }
  ++*((_DWORD *)v1 + 6);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigAimConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(_QWORD *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a1 + 32) + 144 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigAimConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 16, 8);
  *(_QWORD *)result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigAimConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unint64_t v4;
  uint64_t result;

  v2 = *(_QWORD *)a1;
  if (a1[2] == *(_DWORD *)(*(_QWORD *)a1 + 24))
  {
    v3 = a1[3];
    v4 = *(_QWORD *)(v2 + 16);
    if (v3 < (int)v4)
      a1[3] = ++v3;
    if (v4 <= v3)
      return 0;
    else
      return *(_QWORD *)(v2 + 32) + 144 * v3;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigAimConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 40))(a2, result);
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::RigNodeChannel>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::RigNodeChannel>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x2276933B8);
}

void re::IntrospectionDynamicArray<re::RigNodeChannel>::construct(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::RigNodeChannel>::destroy(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = *(_QWORD *)a2;
  if (*(_QWORD *)a2)
  {
    if (*(_QWORD *)(a2 + 32))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a2 + 32) = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_QWORD *)a2 = 0;
    ++*(_DWORD *)(a2 + 24);
  }
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::RigNodeChannel>::init(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  _QWORD *result;

  if (*a2)
  {
    if (a2[4])
      (*(void (**)(_QWORD))(*(_QWORD *)*a2 + 40))(*a2);
    a2[4] = 0;
    a2[1] = 0;
    a2[2] = 0;
    ++*((_DWORD *)a2 + 6);
  }
  *a2 = a3;
  result = re::DynamicArray<re::RigNodeConstraint>::setCapacity(a2, 0);
  ++*((_DWORD *)a2 + 6);
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::RigNodeChannel>::resize(_QWORD *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  _QWORD *v9;
  unint64_t v10;
  unint64_t i;

  v9 = result;
  if (!*(_QWORD *)a4)
  {
    *(_QWORD *)a4 = a2;
    result = re::DynamicArray<re::RigNodeConstraint>::setCapacity((_QWORD *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  v10 = *(_QWORD *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
      return re::DynamicArray<re::RigNodeChannel>::resize((_QWORD *)a4, a5);
  }
  else
  {
    result = re::DynamicArray<re::RigNodeConstraint>::setCapacity((_QWORD *)a4, a5);
    for (i = a5 - *(_QWORD *)(a4 + 16); i; --i)
      result = (_QWORD *)(*(uint64_t (**)(_QWORD *, uint64_t, uint64_t, uint64_t))(*v9 + 80))(v9, a2, a3, a4);
  }
  return result;
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::RigNodeChannel>::addElement(re::Allocator **a1, re *a2, int a3, uint64_t a4)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  BOOL v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  re::IntrospectionBase *v16;

  v8 = *(_QWORD *)(a4 + 8);
  v9 = *(_QWORD *)(a4 + 16);
  if (v9 >= v8)
  {
    v10 = v9 + 1;
    if (v8 < v9 + 1)
    {
      if (*(_QWORD *)a4)
      {
        v11 = 2 * v8;
        v12 = v8 == 0;
        v13 = 8;
        if (!v12)
          v13 = v11;
        if (v13 <= v10)
          v14 = v10;
        else
          v14 = v13;
        re::DynamicArray<re::RigNodeConstraint>::setCapacity((_QWORD *)a4, v14);
      }
      else
      {
        re::DynamicArray<re::RigNodeConstraint>::setCapacity((_QWORD *)a4, v10);
        ++*(_DWORD *)(a4 + 24);
      }
    }
    v9 = *(_QWORD *)(a4 + 16);
  }
  *(_OWORD *)(*(_QWORD *)(a4 + 32) + 16 * v9) = xmmword_2260E7ED0;
  v15 = *(_QWORD *)(a4 + 16);
  *(_QWORD *)(a4 + 16) = v15 + 1;
  ++*(_DWORD *)(a4 + 24);
  v16 = (re::IntrospectionBase *)(*(_QWORD *)(a4 + 32) + 16 * v15);
  re::introspectionInitElement(a2, a3, a1[6], v16);
  return v16;
}

uint64_t re::IntrospectionDynamicArray<re::RigNodeChannel>::size(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::RigNodeChannel>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 16 * a3;
}

{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 16 * a3;
}

_QWORD *re::DynamicArray<re::RigNodeChannel>::resize(_QWORD *result, unint64_t a2)
{
  _QWORD *v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;

  v3 = result;
  v4 = result[2];
  if (v4 >= a2)
  {
    if (v4 <= a2)
      return result;
  }
  else
  {
    if (result[1] < a2)
    {
      result = re::DynamicArray<re::RigNodeConstraint>::setCapacity(result, a2);
      v4 = v3[2];
    }
    if (v4 < a2)
    {
      v5 = v3[4];
      v6 = v5 + 16 * v4;
      v7 = v5 + 16 * a2 - v6;
      if (v7 >= 1)
      {
        v8 = ((unint64_t)v7 >> 4) + 1;
        do
        {
          *(_BYTE *)v6 = 0;
          *(_QWORD *)(v6 + 8) = -1;
          --v8;
          v6 += 16;
        }
        while (v8 > 1);
      }
    }
  }
  v3[2] = a2;
  ++*((_DWORD *)v3 + 6);
  return result;
}

_QWORD *re::TypeBuilderHelper::registerDynamicArray<re::RigNodeChannel>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)a1 = a3;
  result = re::DynamicArray<re::RigNodeConstraint>::setCapacity((_QWORD *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNodeChannel>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)a1;
  if (result)
  {
    if (*(_QWORD *)(a1 + 32))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNodeChannel>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::RigNodeChannel>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  re::Allocator *v8;
  _anonymous_namespace_ *v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  _BYTE v13[32];
  _BYTE v14[8];
  uint64_t v15;

  v8 = *(re::Allocator **)a1;
  if (v8 == a3)
  {
    *(_QWORD *)(a1 + 16) = 0;
  }
  else
  {
    if (v8)
    {
      if (*(_QWORD *)(a1 + 32))
        (*(void (**)(re::Allocator *))(*(_QWORD *)v8 + 40))(v8);
      *(_QWORD *)(a1 + 32) = 0;
      *(_QWORD *)(a1 + 8) = 0;
      *(_QWORD *)(a1 + 16) = 0;
      ++*(_DWORD *)(a1 + 24);
    }
    *(_QWORD *)a1 = a3;
    re::DynamicArray<re::RigNodeConstraint>::setCapacity((_QWORD *)a1, a4);
  }
  ++*(_DWORD *)(a1 + 24);
  v9 = (_anonymous_namespace_ *)re::DynamicArray<re::RigNodeChannel>::resize((_QWORD *)a1, a4);
  {
    re::TypeRegistry::typeInfo(*(_QWORD **)a2, *(_QWORD *)(*(_QWORD *)(a2 + 16) + 72), v14);
    re::TypeInfo::TypeInfo((uint64_t)v13, (uint64_t)&v15);
    v10 = *(_QWORD *)(a1 + 16);
    if (v10)
    {
      v11 = *(char **)(a1 + 32);
      v12 = 16 * v10;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v13, v11, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v13, (void **)v11, a3, 0);
        v11 += 16;
        v12 -= 16;
      }
      while (v12);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNodeChannel>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(_QWORD *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a1 + 32) + 16 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNodeChannel>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 16, 8);
  *(_QWORD *)result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNodeChannel>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unint64_t v4;
  uint64_t result;

  v2 = *(_QWORD *)a1;
  if (a1[2] == *(_DWORD *)(*(_QWORD *)a1 + 24))
  {
    v3 = a1[3];
    v4 = *(_QWORD *)(v2 + 16);
    if (v3 < (int)v4)
      a1[3] = ++v3;
    if (v4 <= v3)
      return 0;
    else
      return *(_QWORD *)(v2 + 32) + 16 * v3;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNodeChannel>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 40))(a2, result);
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::RigNodeConstant>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::RigNodeConstant>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x2276933B8);
}

void re::IntrospectionDynamicArray<re::RigNodeConstant>::construct(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::RigNodeConstant>::destroy(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = *(_QWORD *)a2;
  if (*(_QWORD *)a2)
  {
    if (*(_QWORD *)(a2 + 32))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a2 + 32) = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_QWORD *)a2 = 0;
    ++*(_DWORD *)(a2 + 24);
  }
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::RigNodeConstant>::init(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  _QWORD *result;

  if (*a2)
  {
    if (a2[4])
      (*(void (**)(_QWORD))(*(_QWORD *)*a2 + 40))(*a2);
    a2[4] = 0;
    a2[1] = 0;
    a2[2] = 0;
    ++*((_DWORD *)a2 + 6);
  }
  *a2 = a3;
  result = re::DynamicArray<re::RigNodeConstraint>::setCapacity(a2, 0);
  ++*((_DWORD *)a2 + 6);
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::RigNodeConstant>::resize(_QWORD *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  _QWORD *v9;
  unint64_t v10;
  unint64_t i;

  v9 = result;
  if (!*(_QWORD *)a4)
  {
    *(_QWORD *)a4 = a2;
    result = re::DynamicArray<re::RigNodeConstraint>::setCapacity((_QWORD *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  v10 = *(_QWORD *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
      return re::DynamicArray<re::RigNodeConstant>::resize((_QWORD *)a4, a5);
  }
  else
  {
    result = re::DynamicArray<re::RigNodeConstraint>::setCapacity((_QWORD *)a4, a5);
    for (i = a5 - *(_QWORD *)(a4 + 16); i; --i)
      result = (_QWORD *)(*(uint64_t (**)(_QWORD *, uint64_t, uint64_t, uint64_t))(*v9 + 80))(v9, a2, a3, a4);
  }
  return result;
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::RigNodeConstant>::addElement(re::Allocator **a1, re *a2, int a3, uint64_t a4)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  BOOL v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  re::IntrospectionBase *v16;

  v8 = *(_QWORD *)(a4 + 8);
  v9 = *(_QWORD *)(a4 + 16);
  if (v9 >= v8)
  {
    v10 = v9 + 1;
    if (v8 < v9 + 1)
    {
      if (*(_QWORD *)a4)
      {
        v11 = 2 * v8;
        v12 = v8 == 0;
        v13 = 8;
        if (!v12)
          v13 = v11;
        if (v13 <= v10)
          v14 = v10;
        else
          v14 = v13;
        re::DynamicArray<re::RigNodeConstraint>::setCapacity((_QWORD *)a4, v14);
      }
      else
      {
        re::DynamicArray<re::RigNodeConstraint>::setCapacity((_QWORD *)a4, v10);
        ++*(_DWORD *)(a4 + 24);
      }
    }
    v9 = *(_QWORD *)(a4 + 16);
  }
  *(_OWORD *)(*(_QWORD *)(a4 + 32) + 16 * v9) = xmmword_2260EC650;
  v15 = *(_QWORD *)(a4 + 16);
  *(_QWORD *)(a4 + 16) = v15 + 1;
  ++*(_DWORD *)(a4 + 24);
  v16 = (re::IntrospectionBase *)(*(_QWORD *)(a4 + 32) + 16 * v15);
  re::introspectionInitElement(a2, a3, a1[6], v16);
  return v16;
}

uint64_t re::IntrospectionDynamicArray<re::RigNodeConstant>::size(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::RigNodeConstant>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 16 * a3;
}

{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 16 * a3;
}

_QWORD *re::DynamicArray<re::RigNodeConstant>::resize(_QWORD *result, unint64_t a2)
{
  _QWORD *v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;

  v3 = result;
  v4 = result[2];
  if (v4 >= a2)
  {
    if (v4 <= a2)
      return result;
  }
  else
  {
    if (result[1] < a2)
    {
      result = re::DynamicArray<re::RigNodeConstraint>::setCapacity(result, a2);
      v4 = v3[2];
    }
    if (v4 < a2)
    {
      v5 = v3[4];
      v6 = v5 + 16 * v4;
      v7 = v5 + 16 * a2 - v6;
      if (v7 >= 1)
      {
        v8 = ((unint64_t)v7 >> 4) + 1;
        do
        {
          *(_BYTE *)v6 = -1;
          *(_QWORD *)(v6 + 8) = -1;
          --v8;
          v6 += 16;
        }
        while (v8 > 1);
      }
    }
  }
  v3[2] = a2;
  ++*((_DWORD *)v3 + 6);
  return result;
}

_QWORD *re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstant>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)a1 = a3;
  result = re::DynamicArray<re::RigNodeConstraint>::setCapacity((_QWORD *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstant>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)a1;
  if (result)
  {
    if (*(_QWORD *)(a1 + 32))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstant>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstant>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  re::Allocator *v8;
  _anonymous_namespace_ *v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  _BYTE v13[32];
  _BYTE v14[8];
  uint64_t v15;

  v8 = *(re::Allocator **)a1;
  if (v8 == a3)
  {
    *(_QWORD *)(a1 + 16) = 0;
  }
  else
  {
    if (v8)
    {
      if (*(_QWORD *)(a1 + 32))
        (*(void (**)(re::Allocator *))(*(_QWORD *)v8 + 40))(v8);
      *(_QWORD *)(a1 + 32) = 0;
      *(_QWORD *)(a1 + 8) = 0;
      *(_QWORD *)(a1 + 16) = 0;
      ++*(_DWORD *)(a1 + 24);
    }
    *(_QWORD *)a1 = a3;
    re::DynamicArray<re::RigNodeConstraint>::setCapacity((_QWORD *)a1, a4);
  }
  ++*(_DWORD *)(a1 + 24);
  v9 = (_anonymous_namespace_ *)re::DynamicArray<re::RigNodeConstant>::resize((_QWORD *)a1, a4);
  {
    re::TypeRegistry::typeInfo(*(_QWORD **)a2, *(_QWORD *)(*(_QWORD *)(a2 + 16) + 72), v14);
    re::TypeInfo::TypeInfo((uint64_t)v13, (uint64_t)&v15);
    v10 = *(_QWORD *)(a1 + 16);
    if (v10)
    {
      v11 = *(char **)(a1 + 32);
      v12 = 16 * v10;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v13, v11, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v13, (void **)v11, a3, 0);
        v11 += 16;
        v12 -= 16;
      }
      while (v12);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstant>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(_QWORD *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a1 + 32) + 16 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstant>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 16, 8);
  *(_QWORD *)result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstant>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unint64_t v4;
  uint64_t result;

  v2 = *(_QWORD *)a1;
  if (a1[2] == *(_DWORD *)(*(_QWORD *)a1 + 24))
  {
    v3 = a1[3];
    v4 = *(_QWORD *)(v2 + 16);
    if (v3 < (int)v4)
      a1[3] = ++v3;
    if (v4 <= v3)
      return 0;
    else
      return *(_QWORD *)(v2 + 32) + 16 * v3;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstant>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 40))(a2, result);
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::RigNodeTemporaryValue>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::RigNodeTemporaryValue>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x2276933B8);
}

void re::IntrospectionDynamicArray<re::RigNodeTemporaryValue>::construct(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::RigNodeTemporaryValue>::destroy(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = *(_QWORD *)a2;
  if (*(_QWORD *)a2)
  {
    if (*(_QWORD *)(a2 + 32))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a2 + 32) = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_QWORD *)a2 = 0;
    ++*(_DWORD *)(a2 + 24);
  }
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::RigNodeTemporaryValue>::init(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  _QWORD *result;

  if (*a2)
  {
    if (a2[4])
      (*(void (**)(_QWORD))(*(_QWORD *)*a2 + 40))(*a2);
    a2[4] = 0;
    a2[1] = 0;
    a2[2] = 0;
    ++*((_DWORD *)a2 + 6);
  }
  *a2 = a3;
  result = re::DynamicArray<re::RigNodeConstraint>::setCapacity(a2, 0);
  ++*((_DWORD *)a2 + 6);
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::RigNodeTemporaryValue>::resize(_QWORD *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  _QWORD *v9;
  unint64_t v10;
  unint64_t i;

  v9 = result;
  if (!*(_QWORD *)a4)
  {
    *(_QWORD *)a4 = a2;
    result = re::DynamicArray<re::RigNodeConstraint>::setCapacity((_QWORD *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  v10 = *(_QWORD *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
      return re::DynamicArray<re::RigNodeConstant>::resize((_QWORD *)a4, a5);
  }
  else
  {
    result = re::DynamicArray<re::RigNodeConstraint>::setCapacity((_QWORD *)a4, a5);
    for (i = a5 - *(_QWORD *)(a4 + 16); i; --i)
      result = (_QWORD *)(*(uint64_t (**)(_QWORD *, uint64_t, uint64_t, uint64_t))(*v9 + 80))(v9, a2, a3, a4);
  }
  return result;
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::RigNodeTemporaryValue>::addElement(re::Allocator **a1, re *a2, int a3, uint64_t a4)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  BOOL v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  re::IntrospectionBase *v16;

  v8 = *(_QWORD *)(a4 + 8);
  v9 = *(_QWORD *)(a4 + 16);
  if (v9 >= v8)
  {
    v10 = v9 + 1;
    if (v8 < v9 + 1)
    {
      if (*(_QWORD *)a4)
      {
        v11 = 2 * v8;
        v12 = v8 == 0;
        v13 = 8;
        if (!v12)
          v13 = v11;
        if (v13 <= v10)
          v14 = v10;
        else
          v14 = v13;
        re::DynamicArray<re::RigNodeConstraint>::setCapacity((_QWORD *)a4, v14);
      }
      else
      {
        re::DynamicArray<re::RigNodeConstraint>::setCapacity((_QWORD *)a4, v10);
        ++*(_DWORD *)(a4 + 24);
      }
    }
    v9 = *(_QWORD *)(a4 + 16);
  }
  *(_OWORD *)(*(_QWORD *)(a4 + 32) + 16 * v9) = xmmword_2260EC650;
  v15 = *(_QWORD *)(a4 + 16);
  *(_QWORD *)(a4 + 16) = v15 + 1;
  ++*(_DWORD *)(a4 + 24);
  v16 = (re::IntrospectionBase *)(*(_QWORD *)(a4 + 32) + 16 * v15);
  re::introspectionInitElement(a2, a3, a1[6], v16);
  return v16;
}

uint64_t re::IntrospectionDynamicArray<re::RigNodeTemporaryValue>::size(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::RigNodeTemporaryValue>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 16 * a3;
}

{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 16 * a3;
}

_QWORD *re::TypeBuilderHelper::registerDynamicArray<re::RigNodeTemporaryValue>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)a1 = a3;
  result = re::DynamicArray<re::RigNodeConstraint>::setCapacity((_QWORD *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNodeTemporaryValue>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)a1;
  if (result)
  {
    if (*(_QWORD *)(a1 + 32))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNodeTemporaryValue>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::RigNodeTemporaryValue>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  re::Allocator *v8;
  _anonymous_namespace_ *v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  _BYTE v13[32];
  _BYTE v14[8];
  uint64_t v15;

  v8 = *(re::Allocator **)a1;
  if (v8 == a3)
  {
    *(_QWORD *)(a1 + 16) = 0;
  }
  else
  {
    if (v8)
    {
      if (*(_QWORD *)(a1 + 32))
        (*(void (**)(re::Allocator *))(*(_QWORD *)v8 + 40))(v8);
      *(_QWORD *)(a1 + 32) = 0;
      *(_QWORD *)(a1 + 8) = 0;
      *(_QWORD *)(a1 + 16) = 0;
      ++*(_DWORD *)(a1 + 24);
    }
    *(_QWORD *)a1 = a3;
    re::DynamicArray<re::RigNodeConstraint>::setCapacity((_QWORD *)a1, a4);
  }
  ++*(_DWORD *)(a1 + 24);
  v9 = (_anonymous_namespace_ *)re::DynamicArray<re::RigNodeConstant>::resize((_QWORD *)a1, a4);
  {
    re::TypeRegistry::typeInfo(*(_QWORD **)a2, *(_QWORD *)(*(_QWORD *)(a2 + 16) + 72), v14);
    re::TypeInfo::TypeInfo((uint64_t)v13, (uint64_t)&v15);
    v10 = *(_QWORD *)(a1 + 16);
    if (v10)
    {
      v11 = *(char **)(a1 + 32);
      v12 = 16 * v10;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v13, v11, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v13, (void **)v11, a3, 0);
        v11 += 16;
        v12 -= 16;
      }
      while (v12);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNodeTemporaryValue>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(_QWORD *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a1 + 32) + 16 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNodeTemporaryValue>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 16, 8);
  *(_QWORD *)result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNodeTemporaryValue>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unint64_t v4;
  uint64_t result;

  v2 = *(_QWORD *)a1;
  if (a1[2] == *(_DWORD *)(*(_QWORD *)a1 + 24))
  {
    v3 = a1[3];
    v4 = *(_QWORD *)(v2 + 16);
    if (v3 < (int)v4)
      a1[3] = ++v3;
    if (v4 <= v3)
      return 0;
    else
      return *(_QWORD *)(v2 + 32) + 16 * v3;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNodeTemporaryValue>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 40))(a2, result);
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::RigExpressionParameter>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::RigExpressionParameter>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x2276933B8);
}

void re::IntrospectionDynamicArray<re::RigExpressionParameter>::construct(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::RigExpressionParameter>::destroy(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = *(_QWORD *)a2;
  if (*(_QWORD *)a2)
  {
    if (*(_QWORD *)(a2 + 32))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a2 + 32) = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_QWORD *)a2 = 0;
    ++*(_DWORD *)(a2 + 24);
  }
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::RigExpressionParameter>::init(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  _QWORD *result;

  if (*a2)
  {
    if (a2[4])
      (*(void (**)(_QWORD))(*(_QWORD *)*a2 + 40))(*a2);
    a2[4] = 0;
    a2[1] = 0;
    a2[2] = 0;
    ++*((_DWORD *)a2 + 6);
  }
  *a2 = a3;
  result = re::DynamicArray<re::RigNodeConstraint>::setCapacity(a2, 0);
  ++*((_DWORD *)a2 + 6);
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::RigExpressionParameter>::resize(_QWORD *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  _QWORD *v9;
  unint64_t v10;
  unint64_t i;

  v9 = result;
  if (!*(_QWORD *)a4)
  {
    *(_QWORD *)a4 = a2;
    result = re::DynamicArray<re::RigNodeConstraint>::setCapacity((_QWORD *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  v10 = *(_QWORD *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
      return re::DynamicArray<re::RigNodeChannel>::resize((_QWORD *)a4, a5);
  }
  else
  {
    result = re::DynamicArray<re::RigNodeConstraint>::setCapacity((_QWORD *)a4, a5);
    for (i = a5 - *(_QWORD *)(a4 + 16); i; --i)
      result = (_QWORD *)(*(uint64_t (**)(_QWORD *, uint64_t, uint64_t, uint64_t))(*v9 + 80))(v9, a2, a3, a4);
  }
  return result;
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::RigExpressionParameter>::addElement(re::Allocator **a1, re *a2, int a3, uint64_t a4)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  BOOL v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  re::IntrospectionBase *v16;

  v8 = *(_QWORD *)(a4 + 8);
  v9 = *(_QWORD *)(a4 + 16);
  if (v9 >= v8)
  {
    v10 = v9 + 1;
    if (v8 < v9 + 1)
    {
      if (*(_QWORD *)a4)
      {
        v11 = 2 * v8;
        v12 = v8 == 0;
        v13 = 8;
        if (!v12)
          v13 = v11;
        if (v13 <= v10)
          v14 = v10;
        else
          v14 = v13;
        re::DynamicArray<re::RigNodeConstraint>::setCapacity((_QWORD *)a4, v14);
      }
      else
      {
        re::DynamicArray<re::RigNodeConstraint>::setCapacity((_QWORD *)a4, v10);
        ++*(_DWORD *)(a4 + 24);
      }
    }
    v9 = *(_QWORD *)(a4 + 16);
  }
  *(_OWORD *)(*(_QWORD *)(a4 + 32) + 16 * v9) = xmmword_2260E7ED0;
  v15 = *(_QWORD *)(a4 + 16);
  *(_QWORD *)(a4 + 16) = v15 + 1;
  ++*(_DWORD *)(a4 + 24);
  v16 = (re::IntrospectionBase *)(*(_QWORD *)(a4 + 32) + 16 * v15);
  re::introspectionInitElement(a2, a3, a1[6], v16);
  return v16;
}

uint64_t re::IntrospectionDynamicArray<re::RigExpressionParameter>::size(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::RigExpressionParameter>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 16 * a3;
}

{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 16 * a3;
}

_QWORD *re::TypeBuilderHelper::registerDynamicArray<re::RigExpressionParameter>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)a1 = a3;
  result = re::DynamicArray<re::RigNodeConstraint>::setCapacity((_QWORD *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigExpressionParameter>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)a1;
  if (result)
  {
    if (*(_QWORD *)(a1 + 32))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigExpressionParameter>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::RigExpressionParameter>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  re::Allocator *v8;
  _anonymous_namespace_ *v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  _BYTE v13[32];
  _BYTE v14[8];
  uint64_t v15;

  v8 = *(re::Allocator **)a1;
  if (v8 == a3)
  {
    *(_QWORD *)(a1 + 16) = 0;
  }
  else
  {
    if (v8)
    {
      if (*(_QWORD *)(a1 + 32))
        (*(void (**)(re::Allocator *))(*(_QWORD *)v8 + 40))(v8);
      *(_QWORD *)(a1 + 32) = 0;
      *(_QWORD *)(a1 + 8) = 0;
      *(_QWORD *)(a1 + 16) = 0;
      ++*(_DWORD *)(a1 + 24);
    }
    *(_QWORD *)a1 = a3;
    re::DynamicArray<re::RigNodeConstraint>::setCapacity((_QWORD *)a1, a4);
  }
  ++*(_DWORD *)(a1 + 24);
  v9 = (_anonymous_namespace_ *)re::DynamicArray<re::RigNodeChannel>::resize((_QWORD *)a1, a4);
  {
    re::TypeRegistry::typeInfo(*(_QWORD **)a2, *(_QWORD *)(*(_QWORD *)(a2 + 16) + 72), v14);
    re::TypeInfo::TypeInfo((uint64_t)v13, (uint64_t)&v15);
    v10 = *(_QWORD *)(a1 + 16);
    if (v10)
    {
      v11 = *(char **)(a1 + 32);
      v12 = 16 * v10;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v13, v11, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v13, (void **)v11, a3, 0);
        v11 += 16;
        v12 -= 16;
      }
      while (v12);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigExpressionParameter>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(_QWORD *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a1 + 32) + 16 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigExpressionParameter>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 16, 8);
  *(_QWORD *)result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigExpressionParameter>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unint64_t v4;
  uint64_t result;

  v2 = *(_QWORD *)a1;
  if (a1[2] == *(_DWORD *)(*(_QWORD *)a1 + 24))
  {
    v3 = a1[3];
    v4 = *(_QWORD *)(v2 + 16);
    if (v3 < (int)v4)
      a1[3] = ++v3;
    if (v4 <= v3)
      return 0;
    else
      return *(_QWORD *)(v2 + 32) + 16 * v3;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigExpressionParameter>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 40))(a2, result);
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::RigExpression>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::RigExpression>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x2276933B8);
}

void re::IntrospectionDynamicArray<re::RigExpression>::construct(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::RigExpression>::destroy(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = *(_QWORD *)a2;
  if (*(_QWORD *)a2)
  {
    if (*(_QWORD *)(a2 + 32))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a2 + 32) = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_QWORD *)a2 = 0;
    ++*(_DWORD *)(a2 + 24);
  }
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::RigExpression>::init(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  _QWORD *result;

  if (*a2)
  {
    if (a2[4])
      (*(void (**)(_QWORD))(*(_QWORD *)*a2 + 40))(*a2);
    a2[4] = 0;
    a2[1] = 0;
    a2[2] = 0;
    ++*((_DWORD *)a2 + 6);
  }
  *a2 = a3;
  result = re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity(a2, 0);
  ++*((_DWORD *)a2 + 6);
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::RigExpression>::resize(_QWORD *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  _QWORD *v9;
  unint64_t v10;
  unint64_t i;

  v9 = result;
  if (!*(_QWORD *)a4)
  {
    *(_QWORD *)a4 = a2;
    result = re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity((_QWORD *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  v10 = *(_QWORD *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
      return re::DynamicArray<re::RigExpression>::resize((_QWORD *)a4, a5);
  }
  else
  {
    result = re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity((_QWORD *)a4, a5);
    for (i = a5 - *(_QWORD *)(a4 + 16); i; --i)
      result = (_QWORD *)(*(uint64_t (**)(_QWORD *, uint64_t, uint64_t, uint64_t))(*v9 + 80))(v9, a2, a3, a4);
  }
  return result;
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::RigExpression>::addElement(re::Allocator **a1, re *a2, int a3, uint64_t a4)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  BOOL v12;
  unint64_t v13;
  unint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  re::IntrospectionBase *v17;

  v8 = *(_QWORD *)(a4 + 8);
  v9 = *(_QWORD *)(a4 + 16);
  if (v9 >= v8)
  {
    v10 = v9 + 1;
    if (v8 < v9 + 1)
    {
      if (*(_QWORD *)a4)
      {
        v11 = 2 * v8;
        v12 = v8 == 0;
        v13 = 8;
        if (!v12)
          v13 = v11;
        if (v13 <= v10)
          v14 = v10;
        else
          v14 = v13;
        re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity((_QWORD *)a4, v14);
      }
      else
      {
        re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity((_QWORD *)a4, v10);
        ++*(_DWORD *)(a4 + 24);
      }
    }
    v9 = *(_QWORD *)(a4 + 16);
  }
  v15 = (_QWORD *)(*(_QWORD *)(a4 + 32) + 24 * v9);
  *v15 = 0xFFFFFFFFLL;
  v15[1] = -1;
  v15[2] = -1;
  v16 = *(_QWORD *)(a4 + 16);
  *(_QWORD *)(a4 + 16) = v16 + 1;
  ++*(_DWORD *)(a4 + 24);
  v17 = (re::IntrospectionBase *)(*(_QWORD *)(a4 + 32) + 24 * v16);
  re::introspectionInitElement(a2, a3, a1[6], v17);
  return v17;
}

uint64_t re::IntrospectionDynamicArray<re::RigExpression>::size(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::RigExpression>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 24 * a3;
}

{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 24 * a3;
}

_QWORD *re::DynamicArray<re::RigExpression>::resize(_QWORD *result, unint64_t a2)
{
  _QWORD *v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;

  v3 = result;
  v4 = result[2];
  if (v4 >= a2)
  {
    if (v4 <= a2)
      return result;
  }
  else
  {
    if (result[1] < a2)
    {
      result = re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity(result, a2);
      v4 = v3[2];
    }
    if (v4 < a2)
    {
      v5 = v3[4];
      v6 = v5 + 24 * v4;
      v7 = v5 + 24 * a2 - v6;
      if (v7 >= 1)
      {
        v8 = v7 / 0x18uLL + 1;
        do
        {
          *(_DWORD *)v6 = -1;
          *(_QWORD *)(v6 + 8) = -1;
          *(_QWORD *)(v6 + 16) = -1;
          --v8;
          v6 += 24;
        }
        while (v8 > 1);
      }
    }
  }
  v3[2] = a2;
  ++*((_DWORD *)v3 + 6);
  return result;
}

_QWORD *re::TypeBuilderHelper::registerDynamicArray<re::RigExpression>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)a1 = a3;
  result = re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity((_QWORD *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigExpression>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)a1;
  if (result)
  {
    if (*(_QWORD *)(a1 + 32))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigExpression>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::RigExpression>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  re::Allocator *v8;
  _anonymous_namespace_ *v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  _BYTE v13[32];
  _BYTE v14[8];
  uint64_t v15;

  v8 = *(re::Allocator **)a1;
  if (v8 == a3)
  {
    *(_QWORD *)(a1 + 16) = 0;
  }
  else
  {
    if (v8)
    {
      if (*(_QWORD *)(a1 + 32))
        (*(void (**)(re::Allocator *))(*(_QWORD *)v8 + 40))(v8);
      *(_QWORD *)(a1 + 32) = 0;
      *(_QWORD *)(a1 + 8) = 0;
      *(_QWORD *)(a1 + 16) = 0;
      ++*(_DWORD *)(a1 + 24);
    }
    *(_QWORD *)a1 = a3;
    re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity((_QWORD *)a1, a4);
  }
  ++*(_DWORD *)(a1 + 24);
  v9 = (_anonymous_namespace_ *)re::DynamicArray<re::RigExpression>::resize((_QWORD *)a1, a4);
  {
    re::TypeRegistry::typeInfo(*(_QWORD **)a2, *(_QWORD *)(*(_QWORD *)(a2 + 16) + 72), v14);
    re::TypeInfo::TypeInfo((uint64_t)v13, (uint64_t)&v15);
    v10 = *(_QWORD *)(a1 + 16);
    if (v10)
    {
      v11 = *(char **)(a1 + 32);
      v12 = 24 * v10;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v13, v11, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v13, (void **)v11, a3, 0);
        v11 += 24;
        v12 -= 24;
      }
      while (v12);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigExpression>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(_QWORD *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a1 + 32) + 24 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigExpression>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 16, 8);
  *(_QWORD *)result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigExpression>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unint64_t v4;
  uint64_t result;

  v2 = *(_QWORD *)a1;
  if (a1[2] == *(_DWORD *)(*(_QWORD *)a1 + 24))
  {
    v3 = a1[3];
    v4 = *(_QWORD *)(v2 + 16);
    if (v3 < (int)v4)
      a1[3] = ++v3;
    if (v4 <= v3)
      return 0;
    else
      return *(_QWORD *)(v2 + 32) + 24 * v3;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigExpression>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 40))(a2, result);
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::RigTwoBoneIKHandles>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::RigTwoBoneIKHandles>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x2276933B8);
}

void re::IntrospectionDynamicArray<re::RigTwoBoneIKHandles>::construct(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::RigTwoBoneIKHandles>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<re::RigTwoBoneIKHandles>::deinit(a2);
}

_QWORD *re::IntrospectionDynamicArray<re::RigTwoBoneIKHandles>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  re::DynamicArray<re::RigTwoBoneIKHandles>::deinit(a2);
  *(_QWORD *)a2 = a3;
  result = re::DynamicArray<re::RigTwoBoneIKHandles>::setCapacity((_QWORD *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

void re::IntrospectionDynamicArray<re::RigTwoBoneIKHandles>::resize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  unint64_t v10;
  unint64_t i;

  if (!*(_QWORD *)a4)
  {
    *(_QWORD *)a4 = a2;
    re::DynamicArray<re::RigTwoBoneIKHandles>::setCapacity((_QWORD *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  v10 = *(_QWORD *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
      re::DynamicArray<re::RigTwoBoneIKHandles>::resize(a4, a5);
  }
  else
  {
    re::DynamicArray<re::RigTwoBoneIKHandles>::setCapacity((_QWORD *)a4, a5);
    for (i = a5 - *(_QWORD *)(a4 + 16); i; --i)
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, a3, a4);
  }
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::RigTwoBoneIKHandles>::addElement(uint64_t a1, re *a2, int a3, _anonymous_namespace_ *this)
{
  re::IntrospectionBase *v8;
  _OWORD v10[2];
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;

  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  v21 = 0u;
  v18 = 0u;
  v19 = 0u;
  v16 = 0u;
  v17 = 0u;
  v14 = 0u;
  v15 = 0u;
  v12 = 0u;
  v13 = 0u;
  v11 = 0u;
  memset(v10, 0, sizeof(v10));
  re::DynamicArray<re::RigTwoBoneIKHandles>::add(this, (uint64_t)v10);
  if (*((_QWORD *)&v21 + 1))
  {
    if (*((_QWORD *)&v23 + 1))
      (*(void (**)(void))(**((_QWORD **)&v21 + 1) + 40))();
    *((_QWORD *)&v23 + 1) = 0;
    v22 = 0uLL;
    *((_QWORD *)&v21 + 1) = 0;
    LODWORD(v23) = v23 + 1;
  }
  if ((_QWORD)v19)
  {
    if ((_QWORD)v21)
      (*(void (**)(void))(*(_QWORD *)v19 + 40))();
    *(_QWORD *)&v21 = 0;
    *(_QWORD *)&v20 = 0;
    v19 = 0uLL;
    ++DWORD2(v20);
  }
  if (*((_QWORD *)&v16 + 1))
  {
    if (*((_QWORD *)&v18 + 1))
      (*(void (**)(void))(**((_QWORD **)&v16 + 1) + 40))();
    *((_QWORD *)&v18 + 1) = 0;
    v17 = 0uLL;
    *((_QWORD *)&v16 + 1) = 0;
    LODWORD(v18) = v18 + 1;
  }
  if ((_QWORD)v14)
  {
    if ((_QWORD)v16)
      (*(void (**)(void))(*(_QWORD *)v14 + 40))();
    *(_QWORD *)&v16 = 0;
    *(_QWORD *)&v15 = 0;
    v14 = 0uLL;
    ++DWORD2(v15);
  }
  if (*((_QWORD *)&v11 + 1))
  {
    if (*((_QWORD *)&v13 + 1))
      (*(void (**)(void))(**((_QWORD **)&v11 + 1) + 40))();
    *((_QWORD *)&v13 + 1) = 0;
    v12 = 0uLL;
    *((_QWORD *)&v11 + 1) = 0;
    LODWORD(v13) = v13 + 1;
  }
  if (*(_QWORD *)&v10[0] && (_QWORD)v11)
    (*(void (**)(void))(**(_QWORD **)&v10[0] + 40))();
  v8 = (re::IntrospectionBase *)(*((_QWORD *)this + 4) + 240 * *((_QWORD *)this + 2) - 240);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v8);
  return v8;
}

uint64_t re::IntrospectionDynamicArray<re::RigTwoBoneIKHandles>::size(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::RigTwoBoneIKHandles>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 240 * a3;
}

{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 240 * a3;
}

uint64_t re::DynamicArray<re::RigTwoBoneIKHandles>::deinit(uint64_t a1)
{
  uint64_t result;
  re::RigTwoBoneIKHandles *v3;
  uint64_t v4;
  uint64_t v5;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(re::RigTwoBoneIKHandles **)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 240 * v4;
        do
        {
          re::RigTwoBoneIKHandles::~RigTwoBoneIKHandles(v3);
          v3 = (re::RigTwoBoneIKHandles *)((char *)v3 + 240);
          v5 -= 240;
        }
        while (v5);
        result = *(_QWORD *)a1;
        v3 = *(re::RigTwoBoneIKHandles **)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, re::RigTwoBoneIKHandles *))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

void re::DynamicArray<re::RigTwoBoneIKHandles>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;

  v4 = *(_QWORD *)(a1 + 16);
  if (v4 >= a2)
  {
    if (v4 <= a2)
      return;
    v8 = 240 * a2;
    v9 = a2;
    do
    {
      re::RigTwoBoneIKHandles::~RigTwoBoneIKHandles((re::RigTwoBoneIKHandles *)(*(_QWORD *)(a1 + 32) + v8));
      ++v9;
      v8 += 240;
    }
    while (v9 < *(_QWORD *)(a1 + 16));
  }
  else
  {
    if (*(_QWORD *)(a1 + 8) < a2)
    {
      re::DynamicArray<re::RigTwoBoneIKHandles>::setCapacity((_QWORD *)a1, a2);
      v4 = *(_QWORD *)(a1 + 16);
    }
    v5 = a2 - v4;
    if (a2 > v4)
    {
      v6 = 240 * v4;
      do
      {
        v7 = *(_QWORD *)(a1 + 32) + v6;
        *(_QWORD *)v7 = 0;
        *(_QWORD *)(v7 + 8) = 0;
        *(_DWORD *)(v7 + 24) = 0;
        *(_QWORD *)(v7 + 16) = 0;
        *(_QWORD *)(v7 + 232) = 0;
        *(_OWORD *)(v7 + 32) = 0uLL;
        *(_OWORD *)(v7 + 48) = 0uLL;
        *(_DWORD *)(v7 + 64) = 0;
        *(_OWORD *)(v7 + 72) = 0uLL;
        *(_OWORD *)(v7 + 88) = 0uLL;
        *(_DWORD *)(v7 + 104) = 0;
        *(_OWORD *)(v7 + 112) = 0uLL;
        *(_OWORD *)(v7 + 128) = 0uLL;
        *(_DWORD *)(v7 + 144) = 0;
        *(_OWORD *)(v7 + 152) = 0uLL;
        *(_OWORD *)(v7 + 168) = 0uLL;
        *(_DWORD *)(v7 + 184) = 0;
        *(_OWORD *)(v7 + 192) = 0uLL;
        *(_OWORD *)(v7 + 208) = 0uLL;
        v6 += 240;
        *(_DWORD *)(v7 + 224) = 0;
        --v5;
      }
      while (v5);
    }
  }
  *(_QWORD *)(a1 + 16) = a2;
  ++*(_DWORD *)(a1 + 24);
}

_QWORD *re::TypeBuilderHelper::registerDynamicArray<re::RigTwoBoneIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)a1 = a3;
  result = re::DynamicArray<re::RigTwoBoneIKHandles>::setCapacity((_QWORD *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigTwoBoneIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::RigTwoBoneIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  _anonymous_namespace_ *v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  _BYTE v12[32];
  _BYTE v13[8];
  uint64_t v14;

  if (*(re::Allocator **)a1 == a3)
  {
    re::DynamicArray<re::RigTwoBoneIKHandles>::clear((re::RigTwoBoneIKHandles *)a1);
  }
  else
  {
    re::DynamicArray<re::RigTwoBoneIKHandles>::deinit(a1);
    *(_QWORD *)a1 = a3;
    re::DynamicArray<re::RigTwoBoneIKHandles>::setCapacity((_QWORD *)a1, a4);
    ++*(_DWORD *)(a1 + 24);
  }
  re::DynamicArray<re::RigTwoBoneIKHandles>::resize(a1, a4);
  {
    re::TypeRegistry::typeInfo(*(_QWORD **)a2, *(_QWORD *)(*(_QWORD *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    v9 = *(_QWORD *)(a1 + 16);
    if (v9)
    {
      v10 = *(char **)(a1 + 32);
      v11 = 240 * v9;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 240;
        v11 -= 240;
      }
      while (v11);
    }
  }
}

re::RigTwoBoneIKHandles *re::DynamicArray<re::RigTwoBoneIKHandles>::clear(re::RigTwoBoneIKHandles *result)
{
  re::RigTwoBoneIKHandles *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v1 = result;
  v2 = *((_QWORD *)result + 2);
  *((_QWORD *)result + 2) = 0;
  if (v2)
  {
    result = (re::RigTwoBoneIKHandles *)*((_QWORD *)result + 4);
    v3 = 240 * v2;
    do
    {
      re::RigTwoBoneIKHandles::~RigTwoBoneIKHandles(result);
      result = (re::RigTwoBoneIKHandles *)(v4 + 240);
      v3 -= 240;
    }
    while (v3);
  }
  ++*((_DWORD *)v1 + 6);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigTwoBoneIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(_QWORD *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a1 + 32) + 240 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigTwoBoneIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 16, 8);
  *(_QWORD *)result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigTwoBoneIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unint64_t v4;
  uint64_t result;

  v2 = *(_QWORD *)a1;
  if (a1[2] == *(_DWORD *)(*(_QWORD *)a1 + 24))
  {
    v3 = a1[3];
    v4 = *(_QWORD *)(v2 + 16);
    if (v3 < (int)v4)
      a1[3] = ++v3;
    if (v4 <= v3)
      return 0;
    else
      return *(_QWORD *)(v2 + 32) + 240 * v3;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigTwoBoneIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 40))(a2, result);
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::RigSingleChainIKHandles>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::RigSingleChainIKHandles>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x2276933B8);
}

void re::IntrospectionDynamicArray<re::RigSingleChainIKHandles>::construct(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::RigSingleChainIKHandles>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<re::RigSingleChainIKHandles>::deinit(a2);
}

_QWORD *re::IntrospectionDynamicArray<re::RigSingleChainIKHandles>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  re::DynamicArray<re::RigSingleChainIKHandles>::deinit(a2);
  *(_QWORD *)a2 = a3;
  result = re::DynamicArray<re::RigSingleChainIKHandles>::setCapacity((_QWORD *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::RigSingleChainIKHandles>::resize(_QWORD *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  _QWORD *v9;
  unint64_t v10;
  unint64_t i;

  v9 = result;
  if (!*(_QWORD *)a4)
  {
    *(_QWORD *)a4 = a2;
    result = re::DynamicArray<re::RigSingleChainIKHandles>::setCapacity((_QWORD *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  v10 = *(_QWORD *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
      return re::DynamicArray<re::RigSingleChainIKHandles>::resize((_QWORD *)a4, a5);
  }
  else
  {
    result = re::DynamicArray<re::RigSingleChainIKHandles>::setCapacity((_QWORD *)a4, a5);
    for (i = a5 - *(_QWORD *)(a4 + 16); i; --i)
      result = (_QWORD *)(*(uint64_t (**)(_QWORD *, uint64_t, uint64_t, uint64_t))(*v9 + 80))(v9, a2, a3, a4);
  }
  return result;
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::RigSingleChainIKHandles>::addElement(uint64_t a1, re *a2, int a3, _anonymous_namespace_ *this)
{
  __n128 v8;
  re::IntrospectionBase *v9;
  _OWORD v11[2];
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;

  v16 = 0u;
  v17 = 0u;
  v14 = 0u;
  v15 = 0u;
  v12 = 0u;
  v13 = 0u;
  memset(v11, 0, sizeof(v11));
  DWORD2(v17) = 1008981770;
  v8.n128_f32[0] = re::DynamicArray<re::RigSingleChainIKHandles>::add(this, (uint64_t)v11);
  if ((_QWORD)v15)
  {
    if ((_QWORD)v17)
      (*(void (**)(float))(*(_QWORD *)v15 + 40))(v8.n128_f32[0]);
    *(_QWORD *)&v17 = 0;
    *(_QWORD *)&v16 = 0;
    v15 = 0uLL;
    ++DWORD2(v16);
  }
  if (*((_QWORD *)&v12 + 1))
  {
    if (*((_QWORD *)&v14 + 1))
      (*(void (**)(__n128))(**((_QWORD **)&v12 + 1) + 40))(v8);
    *((_QWORD *)&v14 + 1) = 0;
    v13 = 0uLL;
    *((_QWORD *)&v12 + 1) = 0;
    LODWORD(v14) = v14 + 1;
  }
  if (*(_QWORD *)&v11[0] && (_QWORD)v12)
    (*(void (**)(__n128))(**(_QWORD **)&v11[0] + 40))(v8);
  v9 = (re::IntrospectionBase *)(*((_QWORD *)this + 4) + (*((_QWORD *)this + 2) << 7) - 128);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v9);
  return v9;
}

uint64_t re::IntrospectionDynamicArray<re::RigSingleChainIKHandles>::size(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::RigSingleChainIKHandles>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + (a3 << 7);
}

{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + (a3 << 7);
}

uint64_t re::DynamicArray<re::RigSingleChainIKHandles>::deinit(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = v4 << 7;
        v6 = v3 + 64;
        do
        {
          v7 = *(_QWORD *)(v6 + 16);
          if (v7)
          {
            if (*(_QWORD *)(v6 + 48))
              (*(void (**)(uint64_t))(*(_QWORD *)v7 + 40))(v7);
            *(_QWORD *)(v6 + 48) = 0;
            *(_QWORD *)(v6 + 24) = 0;
            *(_QWORD *)(v6 + 32) = 0;
            *(_QWORD *)(v6 + 16) = 0;
            ++*(_DWORD *)(v6 + 40);
          }
          v8 = *(_QWORD *)(v6 - 24);
          if (v8)
          {
            if (*(_QWORD *)(v6 + 8))
              (*(void (**)(uint64_t))(*(_QWORD *)v8 + 40))(v8);
            *(_QWORD *)(v6 + 8) = 0;
            *(_QWORD *)(v6 - 16) = 0;
            *(_QWORD *)(v6 - 8) = 0;
            *(_QWORD *)(v6 - 24) = 0;
            ++*(_DWORD *)v6;
          }
          v9 = *(_QWORD *)(v6 - 64);
          if (v9)
          {
            if (*(_QWORD *)(v6 - 32))
              (*(void (**)(uint64_t))(*(_QWORD *)v9 + 40))(v9);
            *(_QWORD *)(v6 - 32) = 0;
            *(_QWORD *)(v6 - 56) = 0;
            *(_QWORD *)(v6 - 48) = 0;
            *(_QWORD *)(v6 - 64) = 0;
            ++*(_DWORD *)(v6 - 40);
          }
          v6 += 128;
          v5 -= 128;
        }
        while (v5);
        result = *(_QWORD *)a1;
        v3 = *(_QWORD *)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

_QWORD *re::DynamicArray<re::RigSingleChainIKHandles>::resize(_QWORD *result, unint64_t a2)
{
  _QWORD *v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v3 = result;
  v4 = result[2];
  if (v4 >= a2)
  {
    if (v4 <= a2)
      return result;
    v8 = (a2 << 7) | 0x40;
    v9 = a2;
    do
    {
      v10 = v3[4];
      v11 = v10 + v8;
      v12 = *(_QWORD *)(v10 + v8 + 16);
      if (v12)
      {
        if (*(_QWORD *)(v11 + 48))
          (*(void (**)(uint64_t))(*(_QWORD *)v12 + 40))(v12);
        *(_QWORD *)(v11 + 48) = 0;
        *(_QWORD *)(v10 + v8 + 24) = 0;
        *(_QWORD *)(v10 + v8 + 32) = 0;
        *(_QWORD *)(v10 + v8 + 16) = 0;
        ++*(_DWORD *)(v10 + v8 + 40);
      }
      v15 = *(_QWORD *)(v11 - 24);
      v14 = (_QWORD *)(v11 - 24);
      v13 = v15;
      if (v15)
      {
        if (*(_QWORD *)(v10 + v8 + 8))
          (*(void (**)(uint64_t))(*(_QWORD *)v13 + 40))(v13);
        *(_QWORD *)(v10 + v8 + 8) = 0;
        v14[1] = 0;
        v14[2] = 0;
        *v14 = 0;
        ++*(_DWORD *)(v10 + v8);
      }
      v16 = v10 + v8 - 64;
      result = *(_QWORD **)v16;
      if (*(_QWORD *)v16)
      {
        v17 = v10 + v8;
        if (*(_QWORD *)(v17 - 32))
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 40))(result);
        *(_QWORD *)(v17 - 32) = 0;
        *(_QWORD *)(v16 + 8) = 0;
        *(_QWORD *)(v16 + 16) = 0;
        *(_QWORD *)v16 = 0;
        ++*(_DWORD *)(v17 - 40);
      }
      ++v9;
      v8 += 128;
    }
    while (v9 < v3[2]);
  }
  else
  {
    if (result[1] < a2)
    {
      result = re::DynamicArray<re::RigSingleChainIKHandles>::setCapacity(result, a2);
      v4 = v3[2];
    }
    v5 = a2 - v4;
    if (a2 > v4)
    {
      v6 = v4 << 7;
      do
      {
        v7 = v3[4] + v6;
        *(_QWORD *)v7 = 0;
        *(_QWORD *)(v7 + 8) = 0;
        *(_DWORD *)(v7 + 24) = 0;
        *(_QWORD *)(v7 + 16) = 0;
        *(_QWORD *)(v7 + 112) = 0;
        *(_OWORD *)(v7 + 32) = 0uLL;
        *(_OWORD *)(v7 + 48) = 0uLL;
        *(_DWORD *)(v7 + 64) = 0;
        *(_OWORD *)(v7 + 72) = 0uLL;
        *(_OWORD *)(v7 + 88) = 0uLL;
        *(_DWORD *)(v7 + 104) = 0;
        v6 += 128;
        *(_DWORD *)(v7 + 120) = 1008981770;
        --v5;
      }
      while (v5);
    }
  }
  v3[2] = a2;
  ++*((_DWORD *)v3 + 6);
  return result;
}

float re::DynamicArray<re::RigSingleChainIKHandles>::add(_anonymous_namespace_ *this, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  float result;

  v4 = *((_QWORD *)this + 2);
  if (v4 >= *((_QWORD *)this + 1))
  {
    re::DynamicArray<re::RigSingleChainIKHandles>::growCapacity(this, v4 + 1);
    v4 = *((_QWORD *)this + 2);
  }
  v5 = *((_QWORD *)this + 4) + (v4 << 7);
  *(_QWORD *)(v5 + 32) = 0;
  *(_QWORD *)(v5 + 8) = 0;
  *(_QWORD *)(v5 + 16) = 0;
  *(_QWORD *)v5 = 0;
  *(_DWORD *)(v5 + 24) = 0;
  v6 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)v5 = *(_QWORD *)a2;
  *(_QWORD *)(v5 + 8) = v6;
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  v7 = *(_QWORD *)(v5 + 16);
  *(_QWORD *)(v5 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v7;
  v8 = *(_QWORD *)(v5 + 32);
  *(_QWORD *)(v5 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 32) = v8;
  ++*(_DWORD *)(a2 + 24);
  ++*(_DWORD *)(v5 + 24);
  *(_QWORD *)(v5 + 72) = 0;
  *(_QWORD *)(v5 + 48) = 0;
  *(_QWORD *)(v5 + 56) = 0;
  *(_QWORD *)(v5 + 40) = 0;
  *(_DWORD *)(v5 + 64) = 0;
  v9 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(v5 + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(v5 + 48) = v9;
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  v10 = *(_QWORD *)(v5 + 56);
  *(_QWORD *)(v5 + 56) = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 56) = v10;
  v11 = *(_QWORD *)(v5 + 72);
  *(_QWORD *)(v5 + 72) = *(_QWORD *)(a2 + 72);
  *(_QWORD *)(a2 + 72) = v11;
  ++*(_DWORD *)(a2 + 64);
  ++*(_DWORD *)(v5 + 64);
  *(_QWORD *)(v5 + 112) = 0;
  *(_QWORD *)(v5 + 88) = 0;
  *(_QWORD *)(v5 + 96) = 0;
  *(_QWORD *)(v5 + 80) = 0;
  *(_DWORD *)(v5 + 104) = 0;
  v12 = *(_QWORD *)(a2 + 88);
  *(_QWORD *)(v5 + 80) = *(_QWORD *)(a2 + 80);
  *(_QWORD *)(v5 + 88) = v12;
  *(_QWORD *)(a2 + 80) = 0;
  *(_QWORD *)(a2 + 88) = 0;
  v13 = *(_QWORD *)(v5 + 96);
  *(_QWORD *)(v5 + 96) = *(_QWORD *)(a2 + 96);
  *(_QWORD *)(a2 + 96) = v13;
  v14 = *(_QWORD *)(v5 + 112);
  *(_QWORD *)(v5 + 112) = *(_QWORD *)(a2 + 112);
  *(_QWORD *)(a2 + 112) = v14;
  ++*(_DWORD *)(a2 + 104);
  ++*(_DWORD *)(v5 + 104);
  result = *(float *)(a2 + 120);
  *(float *)(v5 + 120) = result;
  ++*((_QWORD *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

_QWORD *re::DynamicArray<re::RigSingleChainIKHandles>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<re::RigSingleChainIKHandles>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::RigSingleChainIKHandles>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

_QWORD *re::TypeBuilderHelper::registerDynamicArray<re::RigSingleChainIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)a1 = a3;
  result = re::DynamicArray<re::RigSingleChainIKHandles>::setCapacity((_QWORD *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigSingleChainIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::RigSingleChainIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  _anonymous_namespace_ *v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  _BYTE v12[32];
  _BYTE v13[8];
  uint64_t v14;

  if (*(re::Allocator **)a1 == a3)
  {
    re::DynamicArray<re::RigSingleChainIKHandles>::clear((_QWORD *)a1);
  }
  else
  {
    re::DynamicArray<re::RigSingleChainIKHandles>::deinit(a1);
    *(_QWORD *)a1 = a3;
    re::DynamicArray<re::RigSingleChainIKHandles>::setCapacity((_QWORD *)a1, a4);
    ++*(_DWORD *)(a1 + 24);
  }
  v8 = (_anonymous_namespace_ *)re::DynamicArray<re::RigSingleChainIKHandles>::resize((_QWORD *)a1, a4);
  {
    re::TypeRegistry::typeInfo(*(_QWORD **)a2, *(_QWORD *)(*(_QWORD *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    v9 = *(_QWORD *)(a1 + 16);
    if (v9)
    {
      v10 = *(char **)(a1 + 32);
      v11 = v9 << 7;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 128;
        v11 -= 128;
      }
      while (v11);
    }
  }
}

_QWORD *re::DynamicArray<re::RigSingleChainIKHandles>::clear(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v1 = result;
  v2 = result[2];
  result[2] = 0;
  if (v2)
  {
    v3 = v2 << 7;
    v4 = result[4] + 64;
    do
    {
      v5 = *(_QWORD *)(v4 + 16);
      if (v5)
      {
        if (*(_QWORD *)(v4 + 48))
          (*(void (**)(uint64_t))(*(_QWORD *)v5 + 40))(v5);
        *(_QWORD *)(v4 + 48) = 0;
        *(_QWORD *)(v4 + 24) = 0;
        *(_QWORD *)(v4 + 32) = 0;
        *(_QWORD *)(v4 + 16) = 0;
        ++*(_DWORD *)(v4 + 40);
      }
      v6 = *(_QWORD *)(v4 - 24);
      if (v6)
      {
        if (*(_QWORD *)(v4 + 8))
          (*(void (**)(uint64_t))(*(_QWORD *)v6 + 40))(v6);
        *(_QWORD *)(v4 + 8) = 0;
        *(_QWORD *)(v4 - 16) = 0;
        *(_QWORD *)(v4 - 8) = 0;
        *(_QWORD *)(v4 - 24) = 0;
        ++*(_DWORD *)v4;
      }
      result = *(_QWORD **)(v4 - 64);
      if (result)
      {
        if (*(_QWORD *)(v4 - 32))
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 40))(result);
        *(_QWORD *)(v4 - 32) = 0;
        *(_QWORD *)(v4 - 56) = 0;
        *(_QWORD *)(v4 - 48) = 0;
        *(_QWORD *)(v4 - 64) = 0;
        ++*(_DWORD *)(v4 - 40);
      }
      v4 += 128;
      v3 -= 128;
    }
    while (v3);
  }
  ++*((_DWORD *)v1 + 6);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigSingleChainIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(_QWORD *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a1 + 32) + (a2 << 7);
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigSingleChainIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 16, 8);
  *(_QWORD *)result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigSingleChainIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unint64_t v4;
  uint64_t result;

  v2 = *(_QWORD *)a1;
  if (a1[2] == *(_DWORD *)(*(_QWORD *)a1 + 24))
  {
    v3 = a1[3];
    v4 = *(_QWORD *)(v2 + 16);
    if (v3 < (int)v4)
      a1[3] = ++v3;
    if (v4 <= v3)
      return 0;
    else
      return *(_QWORD *)(v2 + 32) + ((uint64_t)v3 << 7);
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigSingleChainIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 40))(a2, result);
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::RigSplineIKHandle>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::RigSplineIKHandle>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x2276933B8);
}

void re::IntrospectionDynamicArray<re::RigSplineIKHandle>::construct(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::RigSplineIKHandle>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<re::RigSplineIKHandle>::deinit(a2);
}

_QWORD *re::IntrospectionDynamicArray<re::RigSplineIKHandle>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  re::DynamicArray<re::RigSplineIKHandle>::deinit(a2);
  *(_QWORD *)a2 = a3;
  result = re::DynamicArray<re::RigSplineIKHandle>::setCapacity((_QWORD *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::RigSplineIKHandle>::resize(_QWORD *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  _QWORD *v9;
  unint64_t v10;
  unint64_t i;

  v9 = result;
  if (!*(_QWORD *)a4)
  {
    *(_QWORD *)a4 = a2;
    result = re::DynamicArray<re::RigSplineIKHandle>::setCapacity((_QWORD *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  v10 = *(_QWORD *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
      return re::DynamicArray<re::RigSplineIKHandle>::resize((_QWORD *)a4, a5);
  }
  else
  {
    result = re::DynamicArray<re::RigSplineIKHandle>::setCapacity((_QWORD *)a4, a5);
    for (i = a5 - *(_QWORD *)(a4 + 16); i; --i)
      result = (_QWORD *)(*(uint64_t (**)(_QWORD *, uint64_t, uint64_t, uint64_t))(*v9 + 80))(v9, a2, a3, a4);
  }
  return result;
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::RigSplineIKHandle>::addElement(re::Allocator **a1, re *a2, int a3, uint64_t a4)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  BOOL v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  re::IntrospectionBase *v23;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  uint64_t v37;

  v37 = *MEMORY[0x24BDAC8D0];
  v28 = 0u;
  v29 = 0u;
  v26 = 0u;
  v27 = 0u;
  v25 = 0u;
  *(_QWORD *)&v32 = -1;
  *((_QWORD *)&v32 + 1) = -1;
  *(_QWORD *)&v30 = -1;
  *((_QWORD *)&v30 + 1) = -1;
  v31 = 0xFFFFFFFFFFFFFFFFLL;
  v35 = 0u;
  v36 = 0u;
  LODWORD(v36) = 0;
  v33 = 0u;
  v34 = 0u;
  v8 = *(_QWORD *)(a4 + 8);
  v9 = *(_QWORD *)(a4 + 16);
  if (v9 >= v8)
  {
    v10 = v9 + 1;
    if (v8 < v9 + 1)
    {
      if (*(_QWORD *)a4)
      {
        v11 = 2 * v8;
        v12 = v8 == 0;
        v13 = 8;
        if (!v12)
          v13 = v11;
        if (v13 <= v10)
          v14 = v10;
        else
          v14 = v13;
        re::DynamicArray<re::RigSplineIKHandle>::setCapacity((_QWORD *)a4, v14);
      }
      else
      {
        re::DynamicArray<re::RigSplineIKHandle>::setCapacity((_QWORD *)a4, v10);
        ++*(_DWORD *)(a4 + 24);
      }
    }
    v9 = *(_QWORD *)(a4 + 16);
  }
  v15 = *(_QWORD *)(a4 + 32) + 240 * v9;
  *(_DWORD *)v15 = 1008981770;
  *(_QWORD *)(v15 + 16) = 0;
  *(_QWORD *)(v15 + 24) = 0;
  *(_QWORD *)(v15 + 8) = 0;
  *(_DWORD *)(v15 + 32) = 0;
  *(_QWORD *)(v15 + 24) = 0;
  *(_QWORD *)(v15 + 40) = 0;
  ++*(_DWORD *)(v15 + 32);
  *(_QWORD *)(v15 + 56) = 0;
  *(_QWORD *)(v15 + 64) = 0;
  *(_QWORD *)(v15 + 48) = 0;
  *(_DWORD *)(v15 + 72) = 0;
  v25 = 0uLL;
  v16 = *(_QWORD *)(v15 + 64);
  *(_QWORD *)(v15 + 64) = 0;
  *(_QWORD *)&v26 = v16;
  *(_QWORD *)(v15 + 80) = 0;
  *(_QWORD *)&v27 = 0;
  DWORD2(v26) = 1;
  ++*(_DWORD *)(v15 + 72);
  *(_QWORD *)(v15 + 96) = 0;
  *(_QWORD *)(v15 + 104) = 0;
  *(_QWORD *)(v15 + 88) = 0;
  *(_DWORD *)(v15 + 112) = 0;
  *((_QWORD *)&v27 + 1) = 0;
  *(_QWORD *)&v28 = 0;
  v17 = *(_QWORD *)(v15 + 104);
  *(_QWORD *)(v15 + 104) = 0;
  *((_QWORD *)&v28 + 1) = v17;
  *(_QWORD *)(v15 + 120) = 0;
  *((_QWORD *)&v29 + 1) = 0;
  LODWORD(v29) = 1;
  ++*(_DWORD *)(v15 + 112);
  v18 = v30;
  v19 = v32;
  *(_OWORD *)(v15 + 144) = v31;
  *(_OWORD *)(v15 + 160) = v19;
  *(_OWORD *)(v15 + 128) = v18;
  v20 = v33;
  v21 = v34;
  v22 = v35;
  *(_DWORD *)(v15 + 224) = v36;
  *(_OWORD *)(v15 + 192) = v21;
  *(_OWORD *)(v15 + 208) = v22;
  *(_OWORD *)(v15 + 176) = v20;
  ++*(_QWORD *)(a4 + 16);
  ++*(_DWORD *)(a4 + 24);
  re::DynamicArray<re::RigSplineIKControlPoint>::deinit((uint64_t)&v25);
  v23 = (re::IntrospectionBase *)(*(_QWORD *)(a4 + 32) + 240 * *(_QWORD *)(a4 + 16) - 240);
  re::introspectionInitElement(a2, a3, a1[6], v23);
  return v23;
}

uint64_t re::IntrospectionDynamicArray<re::RigSplineIKHandle>::size(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::RigSplineIKHandle>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 240 * a3;
}

{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 240 * a3;
}

uint64_t re::DynamicArray<re::RigSplineIKHandle>::deinit(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 240 * v4;
        v6 = (_QWORD *)(v3 + 120);
        do
        {
          v7 = *(v6 - 4);
          if (v7)
          {
            if (*v6)
              (*(void (**)(uint64_t))(*(_QWORD *)v7 + 40))(v7);
            *v6 = 0;
            *(v6 - 3) = 0;
            *(v6 - 2) = 0;
            *(v6 - 4) = 0;
            ++*((_DWORD *)v6 - 2);
          }
          re::DynamicArray<re::RigSplineIKControlPoint>::deinit((uint64_t)(v6 - 9));
          v8 = *(v6 - 14);
          if (v8)
          {
            if (*(v6 - 10))
              (*(void (**)(uint64_t))(*(_QWORD *)v8 + 40))(v8);
            *(v6 - 10) = 0;
            *(v6 - 13) = 0;
            *(v6 - 12) = 0;
            *(v6 - 14) = 0;
            ++*((_DWORD *)v6 - 22);
          }
          v6 += 30;
          v5 -= 240;
        }
        while (v5);
        result = *(_QWORD *)a1;
        v3 = *(_QWORD *)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

_QWORD *re::DynamicArray<re::RigSplineIKHandle>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::RigSplineIKHandle>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0xF0uLL))
        {
          v2 = 240 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 240 * a2, 16);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_16;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 240, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = 240 * v9;
        v11 = (uint64_t)v7;
        do
        {
          re::ObjectHelper::move<re::RigSplineIKHandle>(v8, v11);
          v8 += 240;
          v11 += 240;
          v10 -= 240;
        }
        while (v10);
        v8 = v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

uint64_t re::ObjectHelper::move<re::RigSplineIKHandle>(uint64_t a1, uint64_t a2)
{
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  uint64_t v20;
  uint64_t result;

  *(_DWORD *)a2 = *(_DWORD *)a1;
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)(a2 + 24) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 32) = 0;
  v3 = (uint64_t *)(a1 + 8);
  v4 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a2 + 8) = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a2 + 16) = v4;
  *(_QWORD *)(a1 + 16) = 0;
  v5 = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = v5;
  v6 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 40) = v6;
  ++*(_DWORD *)(a1 + 32);
  ++*(_DWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 80) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  *(_QWORD *)(a2 + 64) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  *(_DWORD *)(a2 + 72) = 0;
  v7 = a1 + 48;
  v8 = *(_QWORD *)(a1 + 56);
  *(_QWORD *)(a2 + 48) = *(_QWORD *)(a1 + 48);
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a2 + 56) = v8;
  *(_QWORD *)(a1 + 56) = 0;
  v9 = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(a2 + 64) = *(_QWORD *)(a1 + 64);
  *(_QWORD *)(a1 + 64) = v9;
  v10 = *(_QWORD *)(a2 + 80);
  *(_QWORD *)(a2 + 80) = *(_QWORD *)(a1 + 80);
  *(_QWORD *)(a1 + 80) = v10;
  ++*(_DWORD *)(a1 + 72);
  ++*(_DWORD *)(a2 + 72);
  *(_QWORD *)(a2 + 120) = 0;
  *(_QWORD *)(a2 + 96) = 0;
  *(_QWORD *)(a2 + 104) = 0;
  *(_QWORD *)(a2 + 88) = 0;
  *(_DWORD *)(a2 + 112) = 0;
  v11 = *(_QWORD *)(a1 + 96);
  v12 = (_QWORD *)(a1 + 88);
  *(_QWORD *)(a2 + 88) = *(_QWORD *)(a1 + 88);
  *(_QWORD *)(a2 + 96) = v11;
  *(_QWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  v13 = *(_QWORD *)(a2 + 104);
  *(_QWORD *)(a2 + 104) = *(_QWORD *)(a1 + 104);
  *(_QWORD *)(a1 + 104) = v13;
  v14 = *(_QWORD *)(a2 + 120);
  *(_QWORD *)(a2 + 120) = *(_QWORD *)(a1 + 120);
  *(_QWORD *)(a1 + 120) = v14;
  ++*(_DWORD *)(a1 + 112);
  ++*(_DWORD *)(a2 + 112);
  v15 = *(_OWORD *)(a1 + 128);
  v16 = *(_OWORD *)(a1 + 160);
  *(_OWORD *)(a2 + 144) = *(_OWORD *)(a1 + 144);
  *(_OWORD *)(a2 + 160) = v16;
  *(_OWORD *)(a2 + 128) = v15;
  v17 = *(_OWORD *)(a1 + 176);
  v18 = *(_OWORD *)(a1 + 192);
  v19 = *(_OWORD *)(a1 + 208);
  *(_DWORD *)(a2 + 224) = *(_DWORD *)(a1 + 224);
  *(_OWORD *)(a2 + 192) = v18;
  *(_OWORD *)(a2 + 208) = v19;
  *(_OWORD *)(a2 + 176) = v17;
  v20 = *(_QWORD *)(a1 + 88);
  if (v20)
  {
    if (*(_QWORD *)(a1 + 120))
      (*(void (**)(uint64_t))(*(_QWORD *)v20 + 40))(v20);
    *(_QWORD *)(a1 + 120) = 0;
    v12[1] = 0;
    v12[2] = 0;
    *v12 = 0;
    ++*(_DWORD *)(a1 + 112);
  }
  re::DynamicArray<re::RigSplineIKControlPoint>::deinit(v7);
  result = *v3;
  if (*v3)
  {
    if (*(_QWORD *)(a1 + 40))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a1 + 40) = 0;
    v3[1] = 0;
    v3[2] = 0;
    *v3 = 0;
    ++*(_DWORD *)(a1 + 32);
  }
  return result;
}

_QWORD *re::DynamicArray<re::RigSplineIKHandle>::resize(_QWORD *result, unint64_t a2)
{
  _QWORD *v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  uint64_t v16;

  v3 = result;
  v4 = result[2];
  if (v4 >= a2)
  {
    if (v4 <= a2)
      return result;
    v8 = 240 * a2 + 120;
    v9 = a2;
    do
    {
      v10 = v3[4];
      v11 = v10 + v8;
      v12 = *(_QWORD *)(v10 + v8 - 32);
      if (v12)
      {
        if (*(_QWORD *)(v10 + v8))
          (*(void (**)(uint64_t))(*(_QWORD *)v12 + 40))(v12);
        v13 = (_QWORD *)(v10 + v8);
        *v13 = 0;
        *(_QWORD *)(v10 + v8 - 24) = 0;
        *(_QWORD *)(v10 + v8 - 16) = 0;
        *(_QWORD *)(v10 + v8 - 32) = 0;
        *((_DWORD *)v13 - 2) = *(_DWORD *)(v10 + v8 - 8) + 1;
      }
      re::DynamicArray<re::RigSplineIKControlPoint>::deinit(v11 - 72);
      v15 = *(_QWORD **)(v11 - 112);
      v14 = (_QWORD *)(v11 - 112);
      result = v15;
      if (v15)
      {
        v16 = v10 + v8;
        if (*(_QWORD *)(v16 - 80))
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 40))(result);
        *(_QWORD *)(v16 - 80) = 0;
        v14[1] = 0;
        v14[2] = 0;
        *v14 = 0;
        ++*(_DWORD *)(v16 - 88);
      }
      ++v9;
      v8 += 240;
    }
    while (v9 < v3[2]);
  }
  else
  {
    if (result[1] < a2)
    {
      result = re::DynamicArray<re::RigSplineIKHandle>::setCapacity(result, a2);
      v4 = v3[2];
    }
    v5 = a2 - v4;
    if (a2 > v4)
    {
      v6 = 240 * v4 + 176;
      do
      {
        v7 = v3[4] + v6;
        *(_DWORD *)(v7 - 176) = 1008981770;
        *(_QWORD *)(v7 - 160) = 0;
        *(_QWORD *)(v7 - 152) = 0;
        *(_QWORD *)(v7 - 168) = 0;
        *(_DWORD *)(v7 - 144) = 0;
        *(_OWORD *)(v7 - 136) = 0uLL;
        *(_OWORD *)(v7 - 120) = 0uLL;
        *(_DWORD *)(v7 - 104) = 0;
        *(_OWORD *)(v7 - 96) = 0uLL;
        *(_OWORD *)(v7 - 80) = 0uLL;
        *(_DWORD *)(v7 - 64) = 0;
        *(_QWORD *)(v7 - 56) = 0;
        *(_QWORD *)(v7 - 48) = -1;
        *(_QWORD *)(v7 - 40) = -1;
        *(_QWORD *)(v7 - 32) = -1;
        *(_QWORD *)(v7 - 16) = -1;
        *(_QWORD *)(v7 - 8) = -1;
        *(_DWORD *)(v7 + 48) = 0;
        *(_OWORD *)(v7 + 16) = 0uLL;
        *(_OWORD *)(v7 + 32) = 0uLL;
        v6 += 240;
        *(_OWORD *)v7 = 0uLL;
        --v5;
      }
      while (v5);
    }
  }
  v3[2] = a2;
  ++*((_DWORD *)v3 + 6);
  return result;
}

_QWORD *re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKHandle>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)a1 = a3;
  result = re::DynamicArray<re::RigSplineIKHandle>::setCapacity((_QWORD *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKHandle>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKHandle>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  _anonymous_namespace_ *v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  _BYTE v12[32];
  _BYTE v13[8];
  uint64_t v14;

  if (*(re::Allocator **)a1 == a3)
  {
    re::DynamicArray<re::RigSplineIKHandle>::clear((_QWORD *)a1);
  }
  else
  {
    re::DynamicArray<re::RigSplineIKHandle>::deinit(a1);
    *(_QWORD *)a1 = a3;
    re::DynamicArray<re::RigSplineIKHandle>::setCapacity((_QWORD *)a1, a4);
    ++*(_DWORD *)(a1 + 24);
  }
  v8 = (_anonymous_namespace_ *)re::DynamicArray<re::RigSplineIKHandle>::resize((_QWORD *)a1, a4);
  {
    re::TypeRegistry::typeInfo(*(_QWORD **)a2, *(_QWORD *)(*(_QWORD *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    v9 = *(_QWORD *)(a1 + 16);
    if (v9)
    {
      v10 = *(char **)(a1 + 32);
      v11 = 240 * v9;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 240;
        v11 -= 240;
      }
      while (v11);
    }
  }
}

_QWORD *re::DynamicArray<re::RigSplineIKHandle>::clear(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;

  v1 = result;
  v2 = result[2];
  result[2] = 0;
  if (v2)
  {
    v3 = 240 * v2;
    v4 = (_QWORD *)(result[4] + 120);
    do
    {
      v5 = *(v4 - 4);
      if (v5)
      {
        if (*v4)
          (*(void (**)(uint64_t))(*(_QWORD *)v5 + 40))(v5);
        *v4 = 0;
        *(v4 - 3) = 0;
        *(v4 - 2) = 0;
        *(v4 - 4) = 0;
        ++*((_DWORD *)v4 - 2);
      }
      re::DynamicArray<re::RigSplineIKControlPoint>::deinit((uint64_t)(v4 - 9));
      result = (_QWORD *)*(v4 - 14);
      if (result)
      {
        if (*(v4 - 10))
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 40))(result);
        *(v4 - 10) = 0;
        *(v4 - 13) = 0;
        *(v4 - 12) = 0;
        *(v4 - 14) = 0;
        ++*((_DWORD *)v4 - 22);
      }
      v4 += 30;
      v3 -= 240;
    }
    while (v3);
  }
  ++*((_DWORD *)v1 + 6);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKHandle>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(_QWORD *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a1 + 32) + 240 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKHandle>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 16, 8);
  *(_QWORD *)result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKHandle>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unint64_t v4;
  uint64_t result;

  v2 = *(_QWORD *)a1;
  if (a1[2] == *(_DWORD *)(*(_QWORD *)a1 + 24))
  {
    v3 = a1[3];
    v4 = *(_QWORD *)(v2 + 16);
    if (v3 < (int)v4)
      a1[3] = ++v3;
    if (v4 <= v3)
      return 0;
    else
      return *(_QWORD *)(v2 + 32) + 240 * v3;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigSplineIKHandle>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 40))(a2, result);
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::RigTransform>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::RigTransform>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x2276933B8);
}

void re::IntrospectionDynamicArray<re::RigTransform>::construct(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::RigTransform>::destroy(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = *(_QWORD *)a2;
  if (*(_QWORD *)a2)
  {
    if (*(_QWORD *)(a2 + 32))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a2 + 32) = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_QWORD *)a2 = 0;
    ++*(_DWORD *)(a2 + 24);
  }
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::RigTransform>::init(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  _QWORD *result;

  if (*a2)
  {
    if (a2[4])
      (*(void (**)(_QWORD))(*(_QWORD *)*a2 + 40))(*a2);
    a2[4] = 0;
    a2[1] = 0;
    a2[2] = 0;
    ++*((_DWORD *)a2 + 6);
  }
  *a2 = a3;
  result = re::DynamicArray<re::RigTransform>::setCapacity(a2, 0);
  ++*((_DWORD *)a2 + 6);
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::RigTransform>::resize(_QWORD *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  _QWORD *v9;
  unint64_t v10;
  unint64_t i;

  v9 = result;
  if (!*(_QWORD *)a4)
  {
    *(_QWORD *)a4 = a2;
    result = re::DynamicArray<re::RigTransform>::setCapacity((_QWORD *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  v10 = *(_QWORD *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
      return re::DynamicArray<re::RigTransform>::resize((_QWORD *)a4, a5);
  }
  else
  {
    result = re::DynamicArray<re::RigTransform>::setCapacity((_QWORD *)a4, a5);
    for (i = a5 - *(_QWORD *)(a4 + 16); i; --i)
      result = (_QWORD *)(*(uint64_t (**)(_QWORD *, uint64_t, uint64_t, uint64_t))(*v9 + 80))(v9, a2, a3, a4);
  }
  return result;
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::RigTransform>::addElement(uint64_t a1, re *a2, int a3, _anonymous_namespace_ *this)
{
  re::IntrospectionBase *v8;
  _OWORD v10[2];
  uint64_t v11;
  uint64_t v12;
  __int128 v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = 0u;
  memset(v10, 0, sizeof(v10));
  v11 = 0x3F8000003F800000;
  v12 = 1065353216;
  LOBYTE(v13) = 7;
  re::DynamicArray<re::RigTransform>::add(this, (uint64_t)v10);
  v8 = (re::IntrospectionBase *)(*((_QWORD *)this + 4) + (*((_QWORD *)this + 2) << 6) - 64);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v8);
  return v8;
}

uint64_t re::IntrospectionDynamicArray<re::RigTransform>::size(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::RigTransform>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + (a3 << 6);
}

{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + (a3 << 6);
}

_QWORD *re::DynamicArray<re::RigTransform>::resize(_QWORD *result, unint64_t a2)
{
  _QWORD *v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;

  v3 = result;
  v4 = result[2];
  if (v4 >= a2)
  {
    if (v4 <= a2)
      return result;
  }
  else
  {
    if (result[1] < a2)
    {
      result = re::DynamicArray<re::RigTransform>::setCapacity(result, a2);
      v4 = v3[2];
    }
    if (v4 < a2)
    {
      v5 = v3[4];
      v6 = v5 + (v4 << 6);
      v7 = v5 + (a2 << 6) - v6;
      if (v7 >= 1)
      {
        v8 = ((unint64_t)v7 >> 6) + 1;
        do
        {
          *(_OWORD *)v6 = 0uLL;
          *(_OWORD *)(v6 + 16) = 0uLL;
          *(_QWORD *)(v6 + 32) = 0x3F8000003F800000;
          *(_QWORD *)(v6 + 40) = 1065353216;
          --v8;
          *(_BYTE *)(v6 + 48) = 7;
          v6 += 64;
        }
        while (v8 > 1);
      }
    }
  }
  v3[2] = a2;
  ++*((_DWORD *)v3 + 6);
  return result;
}

_QWORD *re::TypeBuilderHelper::registerDynamicArray<re::RigTransform>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)a1 = a3;
  result = re::DynamicArray<re::RigTransform>::setCapacity((_QWORD *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigTransform>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)a1;
  if (result)
  {
    if (*(_QWORD *)(a1 + 32))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigTransform>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::RigTransform>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  re::Allocator *v8;
  _anonymous_namespace_ *v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  _BYTE v13[32];
  _BYTE v14[8];
  uint64_t v15;

  v8 = *(re::Allocator **)a1;
  if (v8 == a3)
  {
    *(_QWORD *)(a1 + 16) = 0;
  }
  else
  {
    if (v8)
    {
      if (*(_QWORD *)(a1 + 32))
        (*(void (**)(re::Allocator *))(*(_QWORD *)v8 + 40))(v8);
      *(_QWORD *)(a1 + 32) = 0;
      *(_QWORD *)(a1 + 8) = 0;
      *(_QWORD *)(a1 + 16) = 0;
      ++*(_DWORD *)(a1 + 24);
    }
    *(_QWORD *)a1 = a3;
    re::DynamicArray<re::RigTransform>::setCapacity((_QWORD *)a1, a4);
  }
  ++*(_DWORD *)(a1 + 24);
  v9 = (_anonymous_namespace_ *)re::DynamicArray<re::RigTransform>::resize((_QWORD *)a1, a4);
  {
    re::TypeRegistry::typeInfo(*(_QWORD **)a2, *(_QWORD *)(*(_QWORD *)(a2 + 16) + 72), v14);
    re::TypeInfo::TypeInfo((uint64_t)v13, (uint64_t)&v15);
    v10 = *(_QWORD *)(a1 + 16);
    if (v10)
    {
      v11 = *(char **)(a1 + 32);
      v12 = v10 << 6;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v13, v11, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v13, (void **)v11, a3, 0);
        v11 += 64;
        v12 -= 64;
      }
      while (v12);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigTransform>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(_QWORD *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a1 + 32) + (a2 << 6);
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigTransform>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 16, 8);
  *(_QWORD *)result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigTransform>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unint64_t v4;
  uint64_t result;

  v2 = *(_QWORD *)a1;
  if (a1[2] == *(_DWORD *)(*(_QWORD *)a1 + 24))
  {
    v3 = a1[3];
    v4 = *(_QWORD *)(v2 + 16);
    if (v3 < (int)v4)
      a1[3] = ++v3;
    if (v4 <= v3)
      return 0;
    else
      return *(_QWORD *)(v2 + 32) + ((uint64_t)v3 << 6);
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigTransform>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 40))(a2, result);
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::RigJoint>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::RigJoint>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x2276933B8);
}

void re::IntrospectionDynamicArray<re::RigJoint>::construct(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::RigJoint>::destroy(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = *(_QWORD *)a2;
  if (*(_QWORD *)a2)
  {
    if (*(_QWORD *)(a2 + 32))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a2 + 32) = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_QWORD *)a2 = 0;
    ++*(_DWORD *)(a2 + 24);
  }
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::RigJoint>::init(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  _QWORD *result;

  if (*a2)
  {
    if (a2[4])
      (*(void (**)(_QWORD))(*(_QWORD *)*a2 + 40))(*a2);
    a2[4] = 0;
    a2[1] = 0;
    a2[2] = 0;
    ++*((_DWORD *)a2 + 6);
  }
  *a2 = a3;
  result = re::DynamicArray<re::RigJoint>::setCapacity(a2, 0);
  ++*((_DWORD *)a2 + 6);
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::RigJoint>::resize(_QWORD *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  _QWORD *v9;
  unint64_t v10;
  unint64_t i;

  v9 = result;
  if (!*(_QWORD *)a4)
  {
    *(_QWORD *)a4 = a2;
    result = re::DynamicArray<re::RigJoint>::setCapacity((_QWORD *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  v10 = *(_QWORD *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
      return re::DynamicArray<re::RigJoint>::resize((_QWORD *)a4, a5);
  }
  else
  {
    result = re::DynamicArray<re::RigJoint>::setCapacity((_QWORD *)a4, a5);
    for (i = a5 - *(_QWORD *)(a4 + 16); i; --i)
      result = (_QWORD *)(*(uint64_t (**)(_QWORD *, uint64_t, uint64_t, uint64_t))(*v9 + 80))(v9, a2, a3, a4);
  }
  return result;
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::RigJoint>::addElement(uint64_t a1, re *a2, int a3, _anonymous_namespace_ *this)
{
  re::IntrospectionBase *v8;
  _OWORD v10[4];
  uint64_t v11;
  uint64_t v12;
  __int128 v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = 0u;
  v10[0] = 0u;
  v10[1] = xmmword_2260E5D70;
  v10[2] = 0u;
  v10[3] = xmmword_2260E5D70;
  v11 = 0x3F8000003F800000;
  v12 = 1065353216;
  LOBYTE(v13) = 7;
  re::DynamicArray<re::RigJoint>::add(this, (uint64_t)v10);
  v8 = (re::IntrospectionBase *)(*((_QWORD *)this + 4) + 96 * *((_QWORD *)this + 2) - 96);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v8);
  return v8;
}

uint64_t re::IntrospectionDynamicArray<re::RigJoint>::size(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::RigJoint>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 96 * a3;
}

{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 96 * a3;
}

_QWORD *re::DynamicArray<re::RigJoint>::resize(_QWORD *result, unint64_t a2)
{
  _QWORD *v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;

  v3 = result;
  v4 = result[2];
  if (v4 >= a2)
  {
    if (v4 <= a2)
      return result;
  }
  else
  {
    if (result[1] < a2)
    {
      result = re::DynamicArray<re::RigJoint>::setCapacity(result, a2);
      v4 = v3[2];
    }
    if (v4 < a2)
    {
      v5 = v3[4];
      v6 = v5 + 96 * v4;
      v7 = v5 + 96 * a2 - v6;
      if (v7 >= 1)
      {
        v8 = v7 / 0x60uLL + 1;
        do
        {
          *(_OWORD *)v6 = 0uLL;
          *(_OWORD *)(v6 + 16) = xmmword_2260E5D70;
          *(_OWORD *)(v6 + 32) = 0uLL;
          *(_OWORD *)(v6 + 48) = xmmword_2260E5D70;
          --v8;
          *(_QWORD *)(v6 + 64) = 0x3F8000003F800000;
          *(_QWORD *)(v6 + 72) = 1065353216;
          *(_BYTE *)(v6 + 80) = 7;
          v6 += 96;
        }
        while (v8 > 1);
      }
    }
  }
  v3[2] = a2;
  ++*((_DWORD *)v3 + 6);
  return result;
}

_QWORD *re::TypeBuilderHelper::registerDynamicArray<re::RigJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)a1 = a3;
  result = re::DynamicArray<re::RigJoint>::setCapacity((_QWORD *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)a1;
  if (result)
  {
    if (*(_QWORD *)(a1 + 32))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::RigJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  re::Allocator *v8;
  _anonymous_namespace_ *v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  _BYTE v13[32];
  _BYTE v14[8];
  uint64_t v15;

  v8 = *(re::Allocator **)a1;
  if (v8 == a3)
  {
    *(_QWORD *)(a1 + 16) = 0;
  }
  else
  {
    if (v8)
    {
      if (*(_QWORD *)(a1 + 32))
        (*(void (**)(re::Allocator *))(*(_QWORD *)v8 + 40))(v8);
      *(_QWORD *)(a1 + 32) = 0;
      *(_QWORD *)(a1 + 8) = 0;
      *(_QWORD *)(a1 + 16) = 0;
      ++*(_DWORD *)(a1 + 24);
    }
    *(_QWORD *)a1 = a3;
    re::DynamicArray<re::RigJoint>::setCapacity((_QWORD *)a1, a4);
  }
  ++*(_DWORD *)(a1 + 24);
  v9 = (_anonymous_namespace_ *)re::DynamicArray<re::RigJoint>::resize((_QWORD *)a1, a4);
  {
    re::TypeRegistry::typeInfo(*(_QWORD **)a2, *(_QWORD *)(*(_QWORD *)(a2 + 16) + 72), v14);
    re::TypeInfo::TypeInfo((uint64_t)v13, (uint64_t)&v15);
    v10 = *(_QWORD *)(a1 + 16);
    if (v10)
    {
      v11 = *(char **)(a1 + 32);
      v12 = 96 * v10;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v13, v11, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v13, (void **)v11, a3, 0);
        v11 += 96;
        v12 -= 96;
      }
      while (v12);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(_QWORD *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a1 + 32) + 96 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 16, 8);
  *(_QWORD *)result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unint64_t v4;
  uint64_t result;

  v2 = *(_QWORD *)a1;
  if (a1[2] == *(_DWORD *)(*(_QWORD *)a1 + 24))
  {
    v3 = a1[3];
    v4 = *(_QWORD *)(v2 + 16);
    if (v3 < (int)v4)
      a1[3] = ++v3;
    if (v4 <= v3)
      return 0;
    else
      return *(_QWORD *)(v2 + 32) + 96 * v3;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigJoint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 40))(a2, result);
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::RigNodeConstraint>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::RigNodeConstraint>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x2276933B8);
}

void re::IntrospectionDynamicArray<re::RigNodeConstraint>::construct(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::RigNodeConstraint>::destroy(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = *(_QWORD *)a2;
  if (*(_QWORD *)a2)
  {
    if (*(_QWORD *)(a2 + 32))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a2 + 32) = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_QWORD *)a2 = 0;
    ++*(_DWORD *)(a2 + 24);
  }
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::RigNodeConstraint>::init(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  _QWORD *result;

  if (*a2)
  {
    if (a2[4])
      (*(void (**)(_QWORD))(*(_QWORD *)*a2 + 40))(*a2);
    a2[4] = 0;
    a2[1] = 0;
    a2[2] = 0;
    ++*((_DWORD *)a2 + 6);
  }
  *a2 = a3;
  result = re::DynamicArray<re::RigNodeConstraint>::setCapacity(a2, 0);
  ++*((_DWORD *)a2 + 6);
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::RigNodeConstraint>::resize(_QWORD *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  _QWORD *v9;
  unint64_t v10;
  unint64_t i;

  v9 = result;
  if (!*(_QWORD *)a4)
  {
    *(_QWORD *)a4 = a2;
    result = re::DynamicArray<re::RigNodeConstraint>::setCapacity((_QWORD *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  v10 = *(_QWORD *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
      return re::DynamicArray<re::RigNodeChannel>::resize((_QWORD *)a4, a5);
  }
  else
  {
    result = re::DynamicArray<re::RigNodeConstraint>::setCapacity((_QWORD *)a4, a5);
    for (i = a5 - *(_QWORD *)(a4 + 16); i; --i)
      result = (_QWORD *)(*(uint64_t (**)(_QWORD *, uint64_t, uint64_t, uint64_t))(*v9 + 80))(v9, a2, a3, a4);
  }
  return result;
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::RigNodeConstraint>::addElement(uint64_t a1, re *a2, int a3, _anonymous_namespace_ *this)
{
  re::IntrospectionBase *v8;
  __int128 v10;

  v10 = xmmword_2260E7ED0;
  re::DynamicArray<re::RigNodeConstraint>::add(this, (__n128 *)&v10);
  v8 = (re::IntrospectionBase *)(*((_QWORD *)this + 4) + 16 * *((_QWORD *)this + 2) - 16);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v8);
  return v8;
}

uint64_t re::IntrospectionDynamicArray<re::RigNodeConstraint>::size(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::RigNodeConstraint>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 16 * a3;
}

{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 16 * a3;
}

_QWORD *re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)a1 = a3;
  result = re::DynamicArray<re::RigNodeConstraint>::setCapacity((_QWORD *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)a1;
  if (result)
  {
    if (*(_QWORD *)(a1 + 32))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  re::Allocator *v8;
  _anonymous_namespace_ *v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  _BYTE v13[32];
  _BYTE v14[8];
  uint64_t v15;

  v8 = *(re::Allocator **)a1;
  if (v8 == a3)
  {
    *(_QWORD *)(a1 + 16) = 0;
  }
  else
  {
    if (v8)
    {
      if (*(_QWORD *)(a1 + 32))
        (*(void (**)(re::Allocator *))(*(_QWORD *)v8 + 40))(v8);
      *(_QWORD *)(a1 + 32) = 0;
      *(_QWORD *)(a1 + 8) = 0;
      *(_QWORD *)(a1 + 16) = 0;
      ++*(_DWORD *)(a1 + 24);
    }
    *(_QWORD *)a1 = a3;
    re::DynamicArray<re::RigNodeConstraint>::setCapacity((_QWORD *)a1, a4);
  }
  ++*(_DWORD *)(a1 + 24);
  v9 = (_anonymous_namespace_ *)re::DynamicArray<re::RigNodeChannel>::resize((_QWORD *)a1, a4);
  {
    re::TypeRegistry::typeInfo(*(_QWORD **)a2, *(_QWORD *)(*(_QWORD *)(a2 + 16) + 72), v14);
    re::TypeInfo::TypeInfo((uint64_t)v13, (uint64_t)&v15);
    v10 = *(_QWORD *)(a1 + 16);
    if (v10)
    {
      v11 = *(char **)(a1 + 32);
      v12 = 16 * v10;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v13, v11, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v13, (void **)v11, a3, 0);
        v11 += 16;
        v12 -= 16;
      }
      while (v12);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(_QWORD *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a1 + 32) + 16 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 16, 8);
  *(_QWORD *)result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unint64_t v4;
  uint64_t result;

  v2 = *(_QWORD *)a1;
  if (a1[2] == *(_DWORD *)(*(_QWORD *)a1 + 24))
  {
    v3 = a1[3];
    v4 = *(_QWORD *)(v2 + 16);
    if (v3 < (int)v4)
      a1[3] = ++v3;
    if (v4 <= v3)
      return 0;
    else
      return *(_QWORD *)(v2 + 32) + 16 * v3;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNodeConstraint>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 40))(a2, result);
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::RigIKHandles>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::RigIKHandles>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x2276933B8);
}

void re::IntrospectionDynamicArray<re::RigIKHandles>::construct(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::RigIKHandles>::destroy(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = *(_QWORD *)a2;
  if (*(_QWORD *)a2)
  {
    if (*(_QWORD *)(a2 + 32))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a2 + 32) = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_QWORD *)a2 = 0;
    ++*(_DWORD *)(a2 + 24);
  }
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::RigIKHandles>::init(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  _QWORD *result;

  if (*a2)
  {
    if (a2[4])
      (*(void (**)(_QWORD))(*(_QWORD *)*a2 + 40))(*a2);
    a2[4] = 0;
    a2[1] = 0;
    a2[2] = 0;
    ++*((_DWORD *)a2 + 6);
  }
  *a2 = a3;
  result = re::DynamicArray<re::RigNodeConstraint>::setCapacity(a2, 0);
  ++*((_DWORD *)a2 + 6);
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::RigIKHandles>::resize(_QWORD *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  _QWORD *v9;
  unint64_t v10;
  unint64_t i;

  v9 = result;
  if (!*(_QWORD *)a4)
  {
    *(_QWORD *)a4 = a2;
    result = re::DynamicArray<re::RigNodeConstraint>::setCapacity((_QWORD *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  v10 = *(_QWORD *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
      return re::DynamicArray<re::RigNodeChannel>::resize((_QWORD *)a4, a5);
  }
  else
  {
    result = re::DynamicArray<re::RigNodeConstraint>::setCapacity((_QWORD *)a4, a5);
    for (i = a5 - *(_QWORD *)(a4 + 16); i; --i)
      result = (_QWORD *)(*(uint64_t (**)(_QWORD *, uint64_t, uint64_t, uint64_t))(*v9 + 80))(v9, a2, a3, a4);
  }
  return result;
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::RigIKHandles>::addElement(uint64_t a1, re *a2, int a3, _anonymous_namespace_ *this)
{
  re::IntrospectionBase *v8;
  __int128 v10;

  v10 = xmmword_2260E7ED0;
  re::DynamicArray<re::RigNodeConstraint>::add(this, (__n128 *)&v10);
  v8 = (re::IntrospectionBase *)(*((_QWORD *)this + 4) + 16 * *((_QWORD *)this + 2) - 16);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v8);
  return v8;
}

uint64_t re::IntrospectionDynamicArray<re::RigIKHandles>::size(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::RigIKHandles>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 16 * a3;
}

{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 16 * a3;
}

_QWORD *re::TypeBuilderHelper::registerDynamicArray<re::RigIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)a1 = a3;
  result = re::DynamicArray<re::RigNodeConstraint>::setCapacity((_QWORD *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)a1;
  if (result)
  {
    if (*(_QWORD *)(a1 + 32))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::RigIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  re::Allocator *v8;
  _anonymous_namespace_ *v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  _BYTE v13[32];
  _BYTE v14[8];
  uint64_t v15;

  v8 = *(re::Allocator **)a1;
  if (v8 == a3)
  {
    *(_QWORD *)(a1 + 16) = 0;
  }
  else
  {
    if (v8)
    {
      if (*(_QWORD *)(a1 + 32))
        (*(void (**)(re::Allocator *))(*(_QWORD *)v8 + 40))(v8);
      *(_QWORD *)(a1 + 32) = 0;
      *(_QWORD *)(a1 + 8) = 0;
      *(_QWORD *)(a1 + 16) = 0;
      ++*(_DWORD *)(a1 + 24);
    }
    *(_QWORD *)a1 = a3;
    re::DynamicArray<re::RigNodeConstraint>::setCapacity((_QWORD *)a1, a4);
  }
  ++*(_DWORD *)(a1 + 24);
  v9 = (_anonymous_namespace_ *)re::DynamicArray<re::RigNodeChannel>::resize((_QWORD *)a1, a4);
  {
    re::TypeRegistry::typeInfo(*(_QWORD **)a2, *(_QWORD *)(*(_QWORD *)(a2 + 16) + 72), v14);
    re::TypeInfo::TypeInfo((uint64_t)v13, (uint64_t)&v15);
    v10 = *(_QWORD *)(a1 + 16);
    if (v10)
    {
      v11 = *(char **)(a1 + 32);
      v12 = 16 * v10;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v13, v11, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v13, (void **)v11, a3, 0);
        v11 += 16;
        v12 -= 16;
      }
      while (v12);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(_QWORD *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a1 + 32) + 16 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 16, 8);
  *(_QWORD *)result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unint64_t v4;
  uint64_t result;

  v2 = *(_QWORD *)a1;
  if (a1[2] == *(_DWORD *)(*(_QWORD *)a1 + 24))
  {
    v3 = a1[3];
    v4 = *(_QWORD *)(v2 + 16);
    if (v3 < (int)v4)
      a1[3] = ++v3;
    if (v4 <= v3)
      return 0;
    else
      return *(_QWORD *)(v2 + 32) + 16 * v3;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigIKHandles>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 40))(a2, result);
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::RigNode>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::RigNode>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x2276933B8);
}

void re::IntrospectionDynamicArray<re::RigNode>::construct(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::RigNode>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<re::RigNode>::deinit(a2);
}

_QWORD *re::IntrospectionDynamicArray<re::RigNode>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  re::DynamicArray<re::RigNode>::deinit(a2);
  *(_QWORD *)a2 = a3;
  result = re::DynamicArray<re::RigNode>::setCapacity((_QWORD *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

void re::IntrospectionDynamicArray<re::RigNode>::resize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  unint64_t v10;
  unint64_t i;

  if (!*(_QWORD *)a4)
  {
    *(_QWORD *)a4 = a2;
    re::DynamicArray<re::RigNode>::setCapacity((_QWORD *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  v10 = *(_QWORD *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
      re::DynamicArray<re::RigNode>::resize(a4, a5);
  }
  else
  {
    re::DynamicArray<re::RigNode>::setCapacity((_QWORD *)a4, a5);
    for (i = a5 - *(_QWORD *)(a4 + 16); i; --i)
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, a3, a4);
  }
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::RigNode>::addElement(uint64_t a1, re *a2, int a3, _anonymous_namespace_ *this)
{
  re::IntrospectionBase *v8;
  __n128 v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  __int128 v14;

  v10.n128_u64[0] = 0;
  v10.n128_u64[1] = (unint64_t)&str_110;
  v11 = 0;
  v12 = -1;
  v13 = -1;
  v14 = xmmword_2260E7ED0;
  re::DynamicArray<re::RigNode>::add(this, &v10);
  re::StringID::destroyString((re::StringID *)&v10);
  v8 = (re::IntrospectionBase *)(*((_QWORD *)this + 4) + 56 * *((_QWORD *)this + 2) - 56);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v8);
  return v8;
}

uint64_t re::IntrospectionDynamicArray<re::RigNode>::size(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::RigNode>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 56 * a3;
}

{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 56 * a3;
}

uint64_t re::DynamicArray<re::RigNode>::deinit(uint64_t a1)
{
  uint64_t result;
  re::StringID *v3;
  uint64_t v4;
  uint64_t v5;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(re::StringID **)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 56 * v4;
        do
        {
          re::StringID::destroyString(v3);
          v3 = (re::StringID *)((char *)v3 + 56);
          v5 -= 56;
        }
        while (v5);
        result = *(_QWORD *)a1;
        v3 = *(re::StringID **)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, re::StringID *))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

void re::DynamicArray<re::RigNode>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;

  v4 = *(_QWORD *)(a1 + 16);
  if (v4 >= a2)
  {
    if (v4 <= a2)
      return;
    v8 = 56 * a2;
    v9 = a2;
    do
    {
      re::StringID::destroyString((re::StringID *)(*(_QWORD *)(a1 + 32) + v8));
      ++v9;
      v8 += 56;
    }
    while (v9 < *(_QWORD *)(a1 + 16));
  }
  else
  {
    if (*(_QWORD *)(a1 + 8) < a2)
    {
      re::DynamicArray<re::RigNode>::setCapacity((_QWORD *)a1, a2);
      v4 = *(_QWORD *)(a1 + 16);
    }
    v5 = a2 - v4;
    if (a2 > v4)
    {
      v6 = 56 * v4;
      do
      {
        v7 = *(_QWORD *)(a1 + 32) + v6;
        *(_QWORD *)v7 = 0;
        *(_QWORD *)(v7 + 8) = &str_110;
        *(_BYTE *)(v7 + 16) = 0;
        *(_QWORD *)(v7 + 24) = -1;
        *(_QWORD *)(v7 + 32) = -1;
        *(_OWORD *)(v7 + 40) = xmmword_2260E7ED0;
        v6 += 56;
        --v5;
      }
      while (v5);
    }
  }
  *(_QWORD *)(a1 + 16) = a2;
  ++*(_DWORD *)(a1 + 24);
}

_QWORD *re::TypeBuilderHelper::registerDynamicArray<re::RigNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)a1 = a3;
  result = re::DynamicArray<re::RigNode>::setCapacity((_QWORD *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::RigNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  _anonymous_namespace_ *v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  _BYTE v12[32];
  _BYTE v13[8];
  uint64_t v14;

  if (*(re::Allocator **)a1 == a3)
  {
    re::DynamicArray<re::RigNode>::clear(a1);
  }
  else
  {
    re::DynamicArray<re::RigNode>::deinit(a1);
    *(_QWORD *)a1 = a3;
    re::DynamicArray<re::RigNode>::setCapacity((_QWORD *)a1, a4);
    ++*(_DWORD *)(a1 + 24);
  }
  re::DynamicArray<re::RigNode>::resize(a1, a4);
  {
    re::TypeRegistry::typeInfo(*(_QWORD **)a2, *(_QWORD *)(*(_QWORD *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    v9 = *(_QWORD *)(a1 + 16);
    if (v9)
    {
      v10 = *(char **)(a1 + 32);
      v11 = 56 * v9;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 56;
        v11 -= 56;
      }
      while (v11);
    }
  }
}

void re::DynamicArray<re::RigNode>::clear(uint64_t a1)
{
  uint64_t v2;
  re::StringID *v3;
  uint64_t v4;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
  {
    v3 = *(re::StringID **)(a1 + 32);
    v4 = 56 * v2;
    do
    {
      re::StringID::destroyString(v3);
      v3 = (re::StringID *)((char *)v3 + 56);
      v4 -= 56;
    }
    while (v4);
  }
  ++*(_DWORD *)(a1 + 24);
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(_QWORD *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a1 + 32) + 56 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 16, 8);
  *(_QWORD *)result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unint64_t v4;
  uint64_t result;

  v2 = *(_QWORD *)a1;
  if (a1[2] == *(_DWORD *)(*(_QWORD *)a1 + 24))
  {
    v3 = a1[3];
    v4 = *(_QWORD *)(v2 + 16);
    if (v3 < (int)v4)
      a1[3] = ++v3;
    if (v4 <= v3)
      return 0;
    else
      return *(_QWORD *)(v2 + 32) + 56 * v3;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 40))(a2, result);
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::RigPoseNode>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::RigPoseNode>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x2276933B8);
}

void re::IntrospectionDynamicArray<re::RigPoseNode>::construct(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::RigPoseNode>::destroy(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = *(_QWORD *)a2;
  if (*(_QWORD *)a2)
  {
    if (*(_QWORD *)(a2 + 32))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a2 + 32) = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_QWORD *)a2 = 0;
    ++*(_DWORD *)(a2 + 24);
  }
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::RigPoseNode>::init(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  _QWORD *result;

  if (*a2)
  {
    if (a2[4])
      (*(void (**)(_QWORD))(*(_QWORD *)*a2 + 40))(*a2);
    a2[4] = 0;
    a2[1] = 0;
    a2[2] = 0;
    ++*((_DWORD *)a2 + 6);
  }
  *a2 = a3;
  result = re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity(a2, 0);
  ++*((_DWORD *)a2 + 6);
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::RigPoseNode>::resize(_QWORD *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  _QWORD *v9;
  unint64_t v10;
  unint64_t i;

  v9 = result;
  if (!*(_QWORD *)a4)
  {
    *(_QWORD *)a4 = a2;
    result = re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity((_QWORD *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  v10 = *(_QWORD *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
      return re::DynamicArray<re::RigPoseNode>::resize((_QWORD *)a4, a5);
  }
  else
  {
    result = re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity((_QWORD *)a4, a5);
    for (i = a5 - *(_QWORD *)(a4 + 16); i; --i)
      result = (_QWORD *)(*(uint64_t (**)(_QWORD *, uint64_t, uint64_t, uint64_t))(*v9 + 80))(v9, a2, a3, a4);
  }
  return result;
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::RigPoseNode>::addElement(re::Allocator **a1, re *a2, int a3, uint64_t a4)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  BOOL v12;
  unint64_t v13;
  unint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  re::IntrospectionBase *v17;

  v8 = *(_QWORD *)(a4 + 8);
  v9 = *(_QWORD *)(a4 + 16);
  if (v9 >= v8)
  {
    v10 = v9 + 1;
    if (v8 < v9 + 1)
    {
      if (*(_QWORD *)a4)
      {
        v11 = 2 * v8;
        v12 = v8 == 0;
        v13 = 8;
        if (!v12)
          v13 = v11;
        if (v13 <= v10)
          v14 = v10;
        else
          v14 = v13;
        re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity((_QWORD *)a4, v14);
      }
      else
      {
        re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity((_QWORD *)a4, v10);
        ++*(_DWORD *)(a4 + 24);
      }
    }
    v9 = *(_QWORD *)(a4 + 16);
  }
  v15 = (_QWORD *)(*(_QWORD *)(a4 + 32) + 24 * v9);
  *v15 = 0;
  v15[1] = -1;
  v15[2] = -1;
  v16 = *(_QWORD *)(a4 + 16);
  *(_QWORD *)(a4 + 16) = v16 + 1;
  ++*(_DWORD *)(a4 + 24);
  v17 = (re::IntrospectionBase *)(*(_QWORD *)(a4 + 32) + 24 * v16);
  re::introspectionInitElement(a2, a3, a1[6], v17);
  return v17;
}

uint64_t re::IntrospectionDynamicArray<re::RigPoseNode>::size(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::RigPoseNode>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 24 * a3;
}

{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 24 * a3;
}

_QWORD *re::DynamicArray<re::RigPoseNode>::resize(_QWORD *result, unint64_t a2)
{
  _QWORD *v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;

  v3 = result;
  v4 = result[2];
  if (v4 >= a2)
  {
    if (v4 <= a2)
      return result;
  }
  else
  {
    if (result[1] < a2)
    {
      result = re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity(result, a2);
      v4 = v3[2];
    }
    if (v4 < a2)
    {
      v5 = v3[4];
      v6 = v5 + 24 * v4;
      v7 = v5 + 24 * a2 - v6;
      if (v7 >= 1)
      {
        v8 = v7 / 0x18uLL + 1;
        do
        {
          *(_BYTE *)v6 = 0;
          *(_QWORD *)(v6 + 8) = -1;
          *(_QWORD *)(v6 + 16) = -1;
          --v8;
          v6 += 24;
        }
        while (v8 > 1);
      }
    }
  }
  v3[2] = a2;
  ++*((_DWORD *)v3 + 6);
  return result;
}

_QWORD *re::TypeBuilderHelper::registerDynamicArray<re::RigPoseNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)a1 = a3;
  result = re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity((_QWORD *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigPoseNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)a1;
  if (result)
  {
    if (*(_QWORD *)(a1 + 32))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigPoseNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::RigPoseNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  re::Allocator *v8;
  _anonymous_namespace_ *v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  _BYTE v13[32];
  _BYTE v14[8];
  uint64_t v15;

  v8 = *(re::Allocator **)a1;
  if (v8 == a3)
  {
    *(_QWORD *)(a1 + 16) = 0;
  }
  else
  {
    if (v8)
    {
      if (*(_QWORD *)(a1 + 32))
        (*(void (**)(re::Allocator *))(*(_QWORD *)v8 + 40))(v8);
      *(_QWORD *)(a1 + 32) = 0;
      *(_QWORD *)(a1 + 8) = 0;
      *(_QWORD *)(a1 + 16) = 0;
      ++*(_DWORD *)(a1 + 24);
    }
    *(_QWORD *)a1 = a3;
    re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity((_QWORD *)a1, a4);
  }
  ++*(_DWORD *)(a1 + 24);
  v9 = (_anonymous_namespace_ *)re::DynamicArray<re::RigPoseNode>::resize((_QWORD *)a1, a4);
  {
    re::TypeRegistry::typeInfo(*(_QWORD **)a2, *(_QWORD *)(*(_QWORD *)(a2 + 16) + 72), v14);
    re::TypeInfo::TypeInfo((uint64_t)v13, (uint64_t)&v15);
    v10 = *(_QWORD *)(a1 + 16);
    if (v10)
    {
      v11 = *(char **)(a1 + 32);
      v12 = 24 * v10;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v13, v11, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v13, (void **)v11, a3, 0);
        v11 += 24;
        v12 -= 24;
      }
      while (v12);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigPoseNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(_QWORD *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a1 + 32) + 24 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigPoseNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 16, 8);
  *(_QWORD *)result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigPoseNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unint64_t v4;
  uint64_t result;

  v2 = *(_QWORD *)a1;
  if (a1[2] == *(_DWORD *)(*(_QWORD *)a1 + 24))
  {
    v3 = a1[3];
    v4 = *(_QWORD *)(v2 + 16);
    if (v3 < (int)v4)
      a1[3] = ++v3;
    if (v4 <= v3)
      return 0;
    else
      return *(_QWORD *)(v2 + 32) + 24 * v3;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigPoseNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 40))(a2, result);
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::RigPose>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::RigPose>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x2276933B8);
}

void re::IntrospectionDynamicArray<re::RigPose>::construct(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::RigPose>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<re::RigPose>::deinit(a2);
}

_QWORD *re::IntrospectionDynamicArray<re::RigPose>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  re::DynamicArray<re::RigPose>::deinit(a2);
  *(_QWORD *)a2 = a3;
  result = re::DynamicArray<re::RigPose>::setCapacity((_QWORD *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

void re::IntrospectionDynamicArray<re::RigPose>::resize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  unint64_t v10;
  unint64_t i;

  if (!*(_QWORD *)a4)
  {
    *(_QWORD *)a4 = a2;
    re::DynamicArray<re::RigPose>::setCapacity((_QWORD *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  v10 = *(_QWORD *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
      re::DynamicArray<re::RigPose>::resize(a4, a5);
  }
  else
  {
    re::DynamicArray<re::RigPose>::setCapacity((_QWORD *)a4, a5);
    for (i = a5 - *(_QWORD *)(a4 + 16); i; --i)
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, a3, a4);
  }
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::RigPose>::addElement(re::Allocator **a1, re *a2, int a3, uint64_t a4)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  BOOL v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  re::IntrospectionBase *v16;
  _QWORD v18[2];
  __int128 v19;

  v19 = xmmword_2260E7ED0;
  v8 = *(_QWORD *)(a4 + 8);
  v9 = *(_QWORD *)(a4 + 16);
  if (v9 >= v8)
  {
    v10 = v9 + 1;
    if (v8 < v9 + 1)
    {
      if (*(_QWORD *)a4)
      {
        v11 = 2 * v8;
        v12 = v8 == 0;
        v13 = 8;
        if (!v12)
          v13 = v11;
        if (v13 <= v10)
          v14 = v10;
        else
          v14 = v13;
        re::DynamicArray<re::RigPose>::setCapacity((_QWORD *)a4, v14);
      }
      else
      {
        re::DynamicArray<re::RigPose>::setCapacity((_QWORD *)a4, v10);
        ++*(_DWORD *)(a4 + 24);
      }
    }
    v9 = *(_QWORD *)(a4 + 16);
  }
  v15 = *(_QWORD *)(a4 + 32) + 32 * v9;
  *(_QWORD *)v15 = 0;
  *(_QWORD *)(v15 + 8) = &str_110;
  v18[0] = 0;
  v18[1] = &str_110;
  *(_OWORD *)(v15 + 16) = v19;
  ++*(_QWORD *)(a4 + 16);
  ++*(_DWORD *)(a4 + 24);
  re::StringID::destroyString((re::StringID *)v18);
  v16 = (re::IntrospectionBase *)(*(_QWORD *)(a4 + 32) + 32 * *(_QWORD *)(a4 + 16) - 32);
  re::introspectionInitElement(a2, a3, a1[6], v16);
  return v16;
}

uint64_t re::IntrospectionDynamicArray<re::RigPose>::size(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::RigPose>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 32 * a3;
}

{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 32 * a3;
}

uint64_t re::DynamicArray<re::RigPose>::deinit(uint64_t a1)
{
  uint64_t result;
  re::StringID *v3;
  uint64_t v4;
  uint64_t v5;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(re::StringID **)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 32 * v4;
        do
        {
          re::StringID::destroyString(v3);
          v3 = (re::StringID *)((char *)v3 + 32);
          v5 -= 32;
        }
        while (v5);
        result = *(_QWORD *)a1;
        v3 = *(re::StringID **)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, re::StringID *))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

_QWORD *re::DynamicArray<re::RigPose>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  unint64_t *v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t *v10;
  unint64_t *v11;
  uint64_t v12;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::RigPose>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (a2 >> 59)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 32, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          v2 = 32 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 32 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_16;
            goto LABEL_11;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = (uint64_t *)v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = &v8[4 * v9];
        v11 = v7;
        do
        {
          v12 = *v8;
          *v11 = *v11 & 0xFFFFFFFFFFFFFFFELL | *v8 & 1;
          *v11 = *v8 & 0xFFFFFFFFFFFFFFFELL | v12 & 1;
          v11[1] = v8[1];
          *v8 = 0;
          v8[1] = (uint64_t)&str_110;
          *((_OWORD *)v11 + 1) = *((_OWORD *)v8 + 1);
          re::StringID::destroyString((re::StringID *)v8);
          v8 += 4;
          v11 += 4;
        }
        while (v8 != v10);
        v8 = (uint64_t *)v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t *))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

void re::DynamicArray<re::RigPose>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;

  v4 = *(_QWORD *)(a1 + 16);
  if (v4 >= a2)
  {
    if (v4 <= a2)
      return;
    v8 = 32 * a2;
    v9 = a2;
    do
    {
      re::StringID::destroyString((re::StringID *)(*(_QWORD *)(a1 + 32) + v8));
      ++v9;
      v8 += 32;
    }
    while (v9 < *(_QWORD *)(a1 + 16));
  }
  else
  {
    if (*(_QWORD *)(a1 + 8) < a2)
    {
      re::DynamicArray<re::RigPose>::setCapacity((_QWORD *)a1, a2);
      v4 = *(_QWORD *)(a1 + 16);
    }
    v5 = a2 - v4;
    if (a2 > v4)
    {
      v6 = 32 * v4;
      do
      {
        v7 = *(_QWORD *)(a1 + 32) + v6;
        *(_QWORD *)v7 = 0;
        *(_QWORD *)(v7 + 8) = &str_110;
        *(_OWORD *)(v7 + 16) = xmmword_2260E7ED0;
        v6 += 32;
        --v5;
      }
      while (v5);
    }
  }
  *(_QWORD *)(a1 + 16) = a2;
  ++*(_DWORD *)(a1 + 24);
}

_QWORD *re::TypeBuilderHelper::registerDynamicArray<re::RigPose>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)a1 = a3;
  result = re::DynamicArray<re::RigPose>::setCapacity((_QWORD *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigPose>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::RigPose>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  _anonymous_namespace_ *v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  _BYTE v12[32];
  _BYTE v13[8];
  uint64_t v14;

  if (*(re::Allocator **)a1 == a3)
  {
    re::DynamicArray<re::RigPose>::clear(a1);
  }
  else
  {
    re::DynamicArray<re::RigPose>::deinit(a1);
    *(_QWORD *)a1 = a3;
    re::DynamicArray<re::RigPose>::setCapacity((_QWORD *)a1, a4);
    ++*(_DWORD *)(a1 + 24);
  }
  re::DynamicArray<re::RigPose>::resize(a1, a4);
  {
    re::TypeRegistry::typeInfo(*(_QWORD **)a2, *(_QWORD *)(*(_QWORD *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    v9 = *(_QWORD *)(a1 + 16);
    if (v9)
    {
      v10 = *(char **)(a1 + 32);
      v11 = 32 * v9;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 32;
        v11 -= 32;
      }
      while (v11);
    }
  }
}

void re::DynamicArray<re::RigPose>::clear(uint64_t a1)
{
  uint64_t v2;
  re::StringID *v3;
  uint64_t v4;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
  {
    v3 = *(re::StringID **)(a1 + 32);
    v4 = 32 * v2;
    do
    {
      re::StringID::destroyString(v3);
      v3 = (re::StringID *)((char *)v3 + 32);
      v4 -= 32;
    }
    while (v4);
  }
  ++*(_DWORD *)(a1 + 24);
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigPose>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(_QWORD *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a1 + 32) + 32 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigPose>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 16, 8);
  *(_QWORD *)result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigPose>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unint64_t v4;
  uint64_t result;

  v2 = *(_QWORD *)a1;
  if (a1[2] == *(_DWORD *)(*(_QWORD *)a1 + 24))
  {
    v3 = a1[3];
    v4 = *(_QWORD *)(v2 + 16);
    if (v3 < (int)v4)
      a1[3] = ++v3;
    if (v4 <= v3)
      return 0;
    else
      return *(_QWORD *)(v2 + 32) + 32 * v3;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::RigPose>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 40))(a2, result);
  return result;
}

void re::RigDefinition::~RigDefinition(re::RigDefinition *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  re::DynamicArray<re::RigPose>::deinit((uint64_t)this + 1104);
  v2 = *((_QWORD *)this + 133);
  if (v2)
  {
    if (*((_QWORD *)this + 137))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *((_QWORD *)this + 137) = 0;
    *((_QWORD *)this + 134) = 0;
    *((_QWORD *)this + 135) = 0;
    *((_QWORD *)this + 133) = 0;
    ++*((_DWORD *)this + 272);
  }
  re::DynamicArray<re::RigNode>::deinit((uint64_t)this + 1024);
  v3 = *((_QWORD *)this + 123);
  if (v3)
  {
    if (*((_QWORD *)this + 127))
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
    *((_QWORD *)this + 127) = 0;
    *((_QWORD *)this + 124) = 0;
    *((_QWORD *)this + 125) = 0;
    *((_QWORD *)this + 123) = 0;
    ++*((_DWORD *)this + 252);
  }
  v4 = *((_QWORD *)this + 118);
  if (v4)
  {
    if (*((_QWORD *)this + 122))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *((_QWORD *)this + 122) = 0;
    *((_QWORD *)this + 119) = 0;
    *((_QWORD *)this + 120) = 0;
    *((_QWORD *)this + 118) = 0;
    ++*((_DWORD *)this + 242);
  }
  v5 = *((_QWORD *)this + 113);
  if (v5)
  {
    if (*((_QWORD *)this + 117))
      (*(void (**)(uint64_t))(*(_QWORD *)v5 + 40))(v5);
    *((_QWORD *)this + 117) = 0;
    *((_QWORD *)this + 114) = 0;
    *((_QWORD *)this + 115) = 0;
    *((_QWORD *)this + 113) = 0;
    ++*((_DWORD *)this + 232);
  }
  v6 = *((_QWORD *)this + 108);
  if (v6)
  {
    if (*((_QWORD *)this + 112))
      (*(void (**)(uint64_t))(*(_QWORD *)v6 + 40))(v6);
    *((_QWORD *)this + 112) = 0;
    *((_QWORD *)this + 109) = 0;
    *((_QWORD *)this + 110) = 0;
    *((_QWORD *)this + 108) = 0;
    ++*((_DWORD *)this + 222);
  }
  re::DynamicArray<re::RigSplineIKHandle>::deinit((uint64_t)this + 824);
  re::DynamicArray<re::RigSingleChainIKHandles>::deinit((uint64_t)this + 784);
  re::DynamicArray<re::RigTwoBoneIKHandles>::deinit((uint64_t)this + 744);
  v7 = *((_QWORD *)this + 88);
  if (v7)
  {
    if (*((_QWORD *)this + 92))
      (*(void (**)(uint64_t))(*(_QWORD *)v7 + 40))(v7);
    *((_QWORD *)this + 92) = 0;
    *((_QWORD *)this + 89) = 0;
    *((_QWORD *)this + 90) = 0;
    *((_QWORD *)this + 88) = 0;
    ++*((_DWORD *)this + 182);
  }
  v8 = *((_QWORD *)this + 83);
  if (v8)
  {
    if (*((_QWORD *)this + 87))
      (*(void (**)(uint64_t))(*(_QWORD *)v8 + 40))(v8);
    *((_QWORD *)this + 87) = 0;
    *((_QWORD *)this + 84) = 0;
    *((_QWORD *)this + 85) = 0;
    *((_QWORD *)this + 83) = 0;
    ++*((_DWORD *)this + 172);
  }
  v9 = *((_QWORD *)this + 78);
  if (v9)
  {
    if (*((_QWORD *)this + 82))
      (*(void (**)(uint64_t))(*(_QWORD *)v9 + 40))(v9);
    *((_QWORD *)this + 82) = 0;
    *((_QWORD *)this + 79) = 0;
    *((_QWORD *)this + 80) = 0;
    *((_QWORD *)this + 78) = 0;
    ++*((_DWORD *)this + 162);
  }
  v10 = *((_QWORD *)this + 65);
  if (v10)
  {
    if (*((_QWORD *)this + 69))
      (*(void (**)(uint64_t))(*(_QWORD *)v10 + 40))(v10);
    *((_QWORD *)this + 69) = 0;
    *((_QWORD *)this + 66) = 0;
    *((_QWORD *)this + 67) = 0;
    *((_QWORD *)this + 65) = 0;
    ++*((_DWORD *)this + 136);
  }
  re::DynamicRegisterIdTable::~DynamicRegisterIdTable((re::RigDefinition *)((char *)this + 200));
  v11 = *((_QWORD *)this + 20);
  if (v11)
  {
    if (*((_QWORD *)this + 24))
      (*(void (**)(uint64_t))(*(_QWORD *)v11 + 40))(v11);
    *((_QWORD *)this + 24) = 0;
    *((_QWORD *)this + 21) = 0;
    *((_QWORD *)this + 22) = 0;
    *((_QWORD *)this + 20) = 0;
    ++*((_DWORD *)this + 46);
  }
  re::DynamicArray<re::RigAimConstraint>::deinit((uint64_t)this + 120);
  re::DynamicArray<re::RigBasicConstraint>::deinit((uint64_t)this + 80);
  re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40);
  re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this);
}

re::internal::AutoRetargetRigGraphNode *re::internal::AutoRetargetRigGraphNode::AutoRetargetRigGraphNode(re::internal::AutoRetargetRigGraphNode *this, re::Allocator *a2, const re::RigHierarchy *a3, const re::RigHierarchy *a4)
{
  unint64_t v7;

  *(_QWORD *)this = 0;
  re::internal::AutoRetargetRigGraphNode::makeJointDefArray(a2, a3, (_QWORD *)this + 1);
  re::internal::AutoRetargetRigGraphNode::makeJointDefArray(a2, a4, (_QWORD *)this + 4);
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 9) = 0;
  v7 = *((_QWORD *)a4 + 27);
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 10) = 0;
  re::FixedArray<CoreIKTransform>::init<>((uint64_t *)this + 10, (uint64_t)a2, v7);
  *((_QWORD *)this + 13) = 0;
  *((_QWORD *)this + 14) = 0;
  *((_BYTE *)this + 128) = 0;
  *((_QWORD *)this + 15) = 0;
  *((_QWORD *)this + 17) = a2;
  return this;
}

void re::internal::AutoRetargetRigGraphNode::makeJointDefArray(re::Allocator *a1@<X1>, const re::RigHierarchy *a2@<X2>, _QWORD *a3@<X8>)
{
  unint64_t v5;
  unint64_t *v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  _QWORD *v11;
  unint64_t v12;
  uint64_t *v13;
  size_t v14;
  _anonymous_namespace_ *v15;
  uint64_t v16;
  void *v17;
  char v18;
  void *v19;
  _BYTE v20[8];
  uint64_t *v21;
  uint64_t v22;
  char v23;
  uint64_t v24;
  char *__s;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  _BYTE v29[18];
  __int16 v30;
  unint64_t v31;
  __int16 v32;
  unint64_t v33;
  _OWORD v34[5];
  uint64_t v35;

  v35 = *MEMORY[0x24BDAC8D0];
  v5 = *((_QWORD *)a2 + 27);
  *a3 = a1;
  a3[1] = v5;
  a3[2] = 0;
  if (v5)
  {
    if (!(v5 >> 59))
    {
      v7 = (unint64_t *)(*(uint64_t (**)(re::Allocator *, unint64_t, uint64_t))(*(_QWORD *)a1 + 32))(a1, 32 * v5, 8);
      a3[2] = v7;
      if (!v7)
        goto LABEL_24;
      v9 = v7;
      v10 = v5 - 1;
      if (v5 == 1)
      {
        *v7 = 0;
        v7[1] = (unint64_t)&str_110;
        v11 = v7 + 3;
        v7[2] = 0;
      }
      else
      {
        v11 = v7 + 3;
        do
        {
          *(v11 - 3) = 0;
          *(v11 - 2) = &str_110;
          *(v11 - 1) = 0;
          *v11 = &str_110;
          v11 += 4;
          --v10;
        }
        while (v10);
        *(v11 - 3) = 0;
        *(v11 - 2) = &str_110;
        *(v11 - 1) = 0;
      }
      v12 = 0;
      *v11 = &str_110;
      while (1)
      {
        v24 = 0;
        __s = (char *)&str_110;
        v26 = 0;
        v27 = &str_110;
        v13 = (uint64_t *)re::RigHierarchy::jointName(a2, v12);
        re::StringID::operator=((unint64_t *)&v24, v13);
        v14 = strlen(__s);
        *(_QWORD *)&v34[0] = __s;
        *((_QWORD *)&v34[0] + 1) = v14;
        v15 = (_anonymous_namespace_ *)re::RigHierarchy::jointParent(a2, (uint64_t)v34, 1, (uint64_t)v20);
        if (!v20[0])
          goto LABEL_13;
        if (v21)
        {
          re::StringID::operator=((unint64_t *)&v26, v21);
        }
        else
        {
LABEL_13:
          *(_QWORD *)v29 = 0;
          *(_QWORD *)&v29[8] = &str_110;
          v16 = *(_QWORD *)v29;
          v17 = *(void **)&v29[8];
          *(_QWORD *)v29 = 0;
          *(_QWORD *)&v29[8] = &str_110;
          v18 = v26;
          v19 = v27;
          v26 = v16;
          v27 = v17;
          *(_QWORD *)&v34[0] = v16 & 0xFFFFFFFFFFFFFFFELL | v18 & 1;
          *((_QWORD *)&v34[0] + 1) = v19;
          re::StringID::destroyString((re::StringID *)v34);
          re::StringID::destroyString((re::StringID *)v29);
        }
        if (v5 == v12)
          break;
        re::StringID::operator=(v9, &v24);
        re::StringID::operator=(v9 + 2, &v26);
        if (!v20[0] && v22 && (v23 & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v22 + 40))();
        re::StringID::destroyString((re::StringID *)&v26);
        re::StringID::destroyString((re::StringID *)&v24);
        ++v12;
        v9 += 4;
        if (v5 == v12)
          return;
      }
      v28 = 0;
      memset(v34, 0, sizeof(v34));
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v29 = 136315906;
      *(_QWORD *)&v29[4] = "operator[]";
      *(_WORD *)&v29[12] = 1024;
      *(_DWORD *)&v29[14] = 468;
      v30 = 2048;
      v31 = v5;
      v32 = 2048;
      v33 = v5;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    re::internal::assertLog((re::internal *)6, (uint64_t)a1, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 32, v5);
    _os_crash();
    __break(1u);
LABEL_24:
    re::internal::assertLog((re::internal *)4, v8, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    _os_crash();
    __break(1u);
  }
}

BOOL re::internal::AutoRetargetRigGraphNode::initialize(re::internal::AutoRetargetRigGraphNode *this, const re::RigDataValue *a2, const re::RigDataValue *a3, const re::RigDataValue *a4, const re::RigDataValue *a5)
{
  _BOOL8 v5;
  float32x4_t v10;
  float32x4_t v11;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t RetargetRig;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  float32x4_t v26[2];
  float32x4_t v27[2];

  if (*((_BYTE *)this + 128))
    return 1;
  re::internal::getSRTFromRDV(a4, v27);
  re::internal::getSRTFromRDV(a5, v26);
  v10 = vmulq_f32(v27[0], v27[0]);
  if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v10, 2), vaddq_f32(v10, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v10.f32, 1))).f32[0]) < 1.0e-10)return 0;
  v11 = vmulq_f32(v26[0], v26[0]);
  if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2), vaddq_f32(v11, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 1))).f32[0]) < 1.0e-10)return 0;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  re::FixedArray<CoreIKBaseJoint>::init<>(&v23, *((_QWORD *)this + 17), *((_QWORD *)a2 + 32));
  re::internal::AutoRetargetRigGraphNode::initialize(re::RigDataValue const&,re::RigDataValue const&,re::RigDataValue const&,re::RigDataValue const&)::$_0::operator()(a2, (uint64_t)this + 8, (uint64_t)&v23);
  v20 = 0;
  v21 = 0;
  v22 = 0;
  re::FixedArray<CoreIKBaseJoint>::init<>(&v20, *((_QWORD *)this + 17), *((_QWORD *)a3 + 32));
  re::internal::AutoRetargetRigGraphNode::initialize(re::RigDataValue const&,re::RigDataValue const&,re::RigDataValue const&,re::RigDataValue const&)::$_0::operator()(a3, (uint64_t)this + 32, (uint64_t)&v20);
  v14 = v21;
  v13 = v22;
  v16 = v24;
  v15 = v25;
  RetargetRig = CoreIKAutoMatchingGenerateRetargetRig();
  v18 = MEMORY[0x2276916F0](RetargetRig);
  if (!*((_QWORD *)this + 7))
    re::FixedArray<CoreIKTransform>::init<>((uint64_t *)this + 7, *((_QWORD *)this + 17), v18);
  if (!*((_QWORD *)this + 13))
    re::FixedArray<unsigned long>::init<>((uint64_t *)this + 13, *((_QWORD *)this + 17), v18);
  CoreIKAutoMatchingGenerateHierarchyToRigMapping();
  v19 = MEMORY[0x227691378](RetargetRig);
  *(_QWORD *)this = v19;
  if (RetargetRig)
  {
    MEMORY[0x2276913A8](RetargetRig);
    v19 = *(_QWORD *)this;
  }
  v5 = v19 != 0;
  *((_BYTE *)this + 128) = v5;
  if (v14 && v20)
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v20 + 40))(v20, v13);
  if (v16 && v23)
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v23 + 40))(v23, v15);
  return v5;
}

void re::FixedArray<CoreIKBaseJoint>::init<>(uint64_t *a1, uint64_t a2, unint64_t a3)
{
  uint64_t v5;
  _OWORD *v6;
  uint64_t v7;
  _OWORD *v8;

  *a1 = a2;
  a1[1] = a3;
  if (!a3)
    return;
  if (a3 >= 0x555555555555556)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 48, a3);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  v5 = 48 * a3;
  v6 = (_OWORD *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 48 * a3, 16);
  a1[2] = (uint64_t)v6;
  if (!v6)
  {
LABEL_9:
    re::internal::assertLog((re::internal *)4, v7, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    _os_crash();
    __break(1u);
    return;
  }
  v8 = v6;
  if (a3 != 1)
  {
    bzero(v6, v5 - 48);
    v8 = (_OWORD *)((char *)v8 + v5 - 48);
  }
  v8[1] = 0u;
  v8[2] = 0u;
  *v8 = 0u;
}

__n128 re::internal::AutoRetargetRigGraphNode::initialize(re::RigDataValue const&,re::RigDataValue const&,re::RigDataValue const&,re::RigDataValue const&)::$_0::operator()(re::RigDataValue *this, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  __n128 result;
  __int128 v15;
  uint64_t v16;
  _BYTE v17[48];
  _BYTE v18[12];
  __int16 v19;
  int v20;
  __int16 v21;
  unint64_t v22;
  __int16 v23;
  unint64_t v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  uint64_t v30;

  v30 = *MEMORY[0x24BDAC8D0];
  if (*((_QWORD *)this + 32))
  {
    v6 = 0;
    v7 = 0;
    v8 = 0;
    do
    {
      v9 = *(_QWORD *)(a2 + 8);
      if (v9 <= v8)
      {
        *(_QWORD *)v18 = 0;
        v28 = 0u;
        v29 = 0u;
        v27 = 0u;
        v25 = 0u;
        v26 = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        *(_DWORD *)v17 = 136315906;
        *(_QWORD *)&v17[4] = "operator[]";
        *(_WORD *)&v17[12] = 1024;
        *(_DWORD *)&v17[14] = 476;
        *(_WORD *)&v17[18] = 2048;
        *(_QWORD *)&v17[20] = v8;
        *(_WORD *)&v17[28] = 2048;
        *(_QWORD *)&v17[30] = v9;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_8:
        v28 = 0u;
        v29 = 0u;
        v27 = 0u;
        v25 = 0u;
        v26 = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        *(_DWORD *)v18 = 136315906;
        *(_QWORD *)&v18[4] = "operator[]";
        v19 = 1024;
        v20 = 468;
        v21 = 2048;
        v22 = v8;
        v23 = 2048;
        v24 = v9;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      v10 = *(_QWORD *)(a2 + 16) + v7;
      v11 = *(_QWORD *)(v10 + 8);
      v12 = *(_QWORD *)(v10 + 24);
      v13 = re::RigDataValue::attributeValue(this, v8);
      *(_QWORD *)&v17[8] = 1065353216;
      *(_QWORD *)&v17[16] = 0;
      *(_QWORD *)v17 = 0x3F8000003F800000;
      *(_QWORD *)&v17[24] = 0x3F80000000000000;
      *(_OWORD *)&v17[32] = 0uLL;
      re::RigDataValue::getRuntimeValue<re::GenericSRT<float>>(v13, v17);
      v9 = *(_QWORD *)(a3 + 8);
      if (v9 <= v8)
        goto LABEL_8;
      v15 = *(_OWORD *)&v17[16];
      result = *(__n128 *)&v17[32];
      v16 = *(_QWORD *)(a3 + 16) + v6;
      *(_QWORD *)v16 = v11;
      *(_QWORD *)(v16 + 8) = v12;
      *(_QWORD *)(v16 + 16) = result.n128_u64[0];
      *(_DWORD *)(v16 + 24) = result.n128_u32[2];
      *(_OWORD *)(v16 + 32) = v15;
      ++v8;
      v7 += 32;
      v6 += 48;
    }
    while (v8 < *((_QWORD *)this + 32));
  }
  return result;
}

uint64_t re::internal::AutoRetargetRigGraphNode::solveAndUpdate(re::internal::AutoRetargetRigGraphNode *this, unint64_t a2, const re::RigDataValue *a3, re::RigDataValue *a4)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  __int128 v15;
  uint64_t v16;
  int v17;
  re::RigDataValue *v18;
  uint64_t v19;
  unint64_t v20;
  __int128 *v21;
  uint64_t v22;
  uint64_t v23;
  __int128 v24;
  unint64_t v25;
  uint64_t result;
  _BYTE v27[48];
  _BYTE v28[12];
  __int16 v29;
  int v30;
  __int16 v31;
  unint64_t v32;
  __int16 v33;
  unint64_t v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  uint64_t v40;

  v40 = *MEMORY[0x24BDAC8D0];
  if (re::internal::enableSignposts(0, 0))
    kdebug_trace();
  if (*((_QWORD *)this + 8))
  {
    v8 = 0;
    v9 = 0;
    v10 = 1065353216;
    while (1)
    {
      v11 = *((_QWORD *)this + 14);
      if (v11 <= v9)
        break;
      v12 = *(_QWORD *)(*((_QWORD *)this + 15) + 8 * v9);
      *(_QWORD *)v27 = 0x3F8000003F800000;
      *(_QWORD *)&v27[8] = 1065353216;
      *(_QWORD *)&v27[16] = 0;
      *(_QWORD *)&v27[24] = 0x3F80000000000000;
      *(_OWORD *)&v27[32] = 0uLL;
      v13 = re::RigDataValue::attributeValue((re::RigDataValue *)a2, v12);
      re::RigDataValue::getRuntimeValue<re::GenericSRT<float>>(v13, v27);
      v11 = *((_QWORD *)this + 8);
      if (v11 <= v9)
        goto LABEL_25;
      v15 = *(_OWORD *)&v27[16];
      v14 = *(_QWORD *)&v27[32];
      v16 = *((_QWORD *)this + 9) + v8;
      *(_DWORD *)(v16 + 8) = *(_DWORD *)&v27[40];
      *(_QWORD *)v16 = v14;
      *(_OWORD *)(v16 + 16) = v15;
      ++v9;
      v8 += 32;
      if (v9 >= *((_QWORD *)this + 8))
        goto LABEL_8;
    }
    *(_QWORD *)v28 = 0;
    v38 = 0u;
    v39 = 0u;
    v37 = 0u;
    v35 = 0u;
    v36 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v27 = 136315906;
    *(_QWORD *)&v27[4] = "operator[]";
    *(_WORD *)&v27[12] = 1024;
    *(_DWORD *)&v27[14] = 468;
    *(_WORD *)&v27[18] = 2048;
    *(_QWORD *)&v27[20] = v9;
    *(_WORD *)&v27[28] = 2048;
    *(_QWORD *)&v27[30] = v11;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_25:
    v38 = 0u;
    v39 = 0u;
    v37 = 0u;
    v35 = 0u;
    v36 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v28 = 136315906;
    *(_QWORD *)&v28[4] = "operator[]";
    v29 = 1024;
    v30 = 468;
    v31 = 2048;
    v32 = v9;
    v33 = 2048;
    v34 = v11;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_26:
    *(_QWORD *)v28 = 0;
    *(_OWORD *)(v10 + 48) = 0u;
    *(_OWORD *)(v10 + 64) = 0u;
    *(_OWORD *)(v10 + 32) = 0u;
    v35 = 0u;
    v36 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v27 = 136315906;
    *(_QWORD *)&v27[4] = "operator[]";
    *(_WORD *)&v27[12] = 1024;
    *(_DWORD *)&v27[14] = 468;
    *(_WORD *)&v27[18] = 2048;
    *(_QWORD *)&v27[20] = a2;
    *(_WORD *)&v27[28] = 2048;
    *(_QWORD *)&v27[30] = v11;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
LABEL_8:
  re::internal::transferPose(a3, (uint64_t)this + 80);
  if (re::internal::enableSignposts(0, 0))
    kdebug_trace();
  if (re::internal::enableSignposts(0, 0))
    kdebug_trace();
  v17 = CoreIKSolve();
  if (re::internal::enableSignposts(0, 0))
  {
    CoreIKSolverGetConstraintCount();
    kdebug_trace();
  }
  v10 = (uint64_t)&v35;
  if (re::internal::enableSignposts(0, 0))
    kdebug_trace();
  re::internal::transferPose((re::RigDataValue *)a2, a4, v18);
  if (!v17 && *((_QWORD *)this + 8))
  {
    v19 = 0;
    a2 = 0;
    do
    {
      v11 = *((_QWORD *)this + 14);
      if (v11 <= a2)
        goto LABEL_26;
      v20 = *(_QWORD *)(*((_QWORD *)this + 15) + 8 * a2);
      v21 = (__int128 *)(*((_QWORD *)this + 9) + v19);
      v22 = *((_QWORD *)v21 + 2);
      v23 = *((_QWORD *)v21 + 3);
      v24 = *v21;
      *(_QWORD *)&v35 = 0x3F8000003F800000;
      *((_QWORD *)&v35 + 1) = 1065353216;
      *(_QWORD *)&v36 = v22;
      *((_QWORD *)&v36 + 1) = v23;
      v37 = v24;
      v25 = re::RigDataValue::attributeValue(a4, v20);
      re::RigDataValue::setRuntimeValue<re::GenericSRT<float>>(v25, &v35);
      ++a2;
      v19 += 32;
    }
    while (a2 < *((_QWORD *)this + 8));
  }
  result = re::internal::enableSignposts(0, 0);
  if ((_DWORD)result)
    return kdebug_trace();
  return result;
}

re::RigDataValue *re::internal::GameRigSettingsUpdateHelper::updateRigJointSettings(re::RigDataValue *this)
{
  re::RigDataValue *v1;
  unint64_t v2;
  re::RigDataValue *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;

  if (*((_QWORD *)this + 32))
  {
    v1 = this;
    v2 = 0;
    do
    {
      v3 = (re::RigDataValue *)re::RigDataValue::attributeValue(v1, v2);
      v4 = re::RigDataValue::attributeValue(v3, 0);
      re::RigDataValue::getRuntimeValue<float>(v4, v5);
      v6 = re::RigDataValue::attributeValue(v3, 1uLL);
      re::RigDataValue::getRuntimeValue<re::Vector3<float>>(v6, v7);
      v8 = re::RigDataValue::attributeValue(v3, 2uLL);
      re::RigDataValue::getRuntimeValue<re::Vector3<float>>(v8, v9);
      CoreIKGenericSolverGetJoint();
      CoreIKJointSetRetargetingGain();
      CoreIKJointSetRetargetingGainDOF();
      this = (re::RigDataValue *)CoreIKJointSetRotationStiffness();
      ++v2;
    }
    while (v2 < *((_QWORD *)v1 + 32));
  }
  return this;
}

re::RigDataValue *re::internal::GameRigSettingsUpdateHelper::updateRigTaskSettings(re::RigDataValue *this, uint64_t a2)
{
  re::RigDataValue *v3;
  unint64_t v4;
  re::RigDataValue *v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  __n128 v13;
  __n128 v14;

  if (*((_QWORD *)this + 32))
  {
    v3 = this;
    v4 = 0;
    do
    {
      v5 = (re::RigDataValue *)re::RigDataValue::attributeValue(v3, v4);
      v6 = re::RigDataValue::attributeValue(v5, 0);
      v14 = *(__n128 *)re::RigDataValue::getRuntimeValue<re::Vector3<float>>(v6, v7);
      v8 = re::RigDataValue::attributeValue(v5, 1uLL);
      v13 = *(__n128 *)re::RigDataValue::getRuntimeValue<re::Vector3<float>>(v8, v9);
      v10 = re::RigDataValue::attributeValue(v5, 2uLL);
      re::RigDataValue::getRuntimeValue<re::Vector3<float>>(v10, v11);
      MEMORY[0x22769154C](a2, v4);
      v12 = MEMORY[0x227691474]();
      MEMORY[0x2276916B4](v14);
      MEMORY[0x2276916A8](v12, v13);
      this = (re::RigDataValue *)CoreIKGenericConstraintSetLookAtAxis();
      ++v4;
    }
    while (v4 < *((_QWORD *)v3 + 32));
  }
  return this;
}

uint64_t re::internal::GameRigSettingsUpdateHelper::updateRigSolverSettings(re::RigDataValue *a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;

  v4 = re::RigDataValue::attributeValue(a1, 0);
  v6 = *(unsigned int *)re::RigDataValue::getRuntimeValue<int>(v4, v5);
  v7 = re::RigDataValue::attributeValue(a1, 1uLL);
  re::RigDataValue::getRuntimeValue<float>(v7, v8);
  MEMORY[0x2276915D0](a2, v6);
  return CoreIKGenericSolverSetRetargetingGain();
}

void re::internal::registerMakeIKLookAtTask(re::internal *this, re::RigEnvironment *a2)
{
  uint64_t v3[2];
  unint64_t v4[2];
  _OWORD v5[3];
  uint64_t v6;
  _OWORD v7[4];
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v6 = 0;
  v4[0] = 0;
  memset(v5, 0, sizeof(v5));
  v4[1] = (unint64_t)&str_110;
  v3[0] = 0;
  v3[1] = (uint64_t)&str_110;
  v7[0] = constinit_5;
  v7[1] = *(_OWORD *)&off_24ED23698;
  v7[2] = xmmword_24ED236A8;
  v7[3] = *(_OWORD *)&off_24ED236B8;
  re::StringID::destroyString((re::StringID *)v3);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v5[1] + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(v5);
  re::StringID::destroyString((re::StringID *)v4);
}

uint64_t `anonymous namespace'::makeIKLookAtTaskCompile(uint64_t a1, uint64_t *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t result;
  const char *v10;
  uint64_t v11;
  _BYTE v12[8];
  _QWORD *v13;
  uint64_t v14;
  char v15;

  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_19;
  }
  if (a3 == 1)
  {
LABEL_19:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    _os_crash();
    __break(1u);
    goto LABEL_20;
  }
  if (a3 <= 2)
  {
LABEL_20:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2);
    _os_crash();
    __break(1u);
    goto LABEL_21;
  }
  if (!a5)
  {
LABEL_21:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v6 = *a2;
  v5 = a2[1];
  v7 = a2[2];
  v8 = *a4;
  v10 = "lookAtTarget";
  v11 = 12;
  re::RigDataValue::attributeValue(v8, (uint64_t)&v10, (uint64_t)v12);
  re::RigDataValue::operator=(v13, v6);
  if (!v12[0] && v14 && (v15 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v14 + 40))();
  v10 = "rotationAlpha";
  v11 = 13;
  re::RigDataValue::attributeValue(v8, (uint64_t)&v10, (uint64_t)v12);
  re::RigDataValue::operator=(v13, v5);
  if (!v12[0] && v14 && (v15 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v14 + 40))();
  v10 = "taskIndex";
  v11 = 9;
  re::RigDataValue::attributeValue(v8, (uint64_t)&v10, (uint64_t)v12);
  re::RigDataValue::operator=(v13, v7);
  if (!v12[0] && v14 && (v15 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v14 + 40))();
  return 1;
}

void re::internal::registerMakeIKTask(re::internal *this, re::RigEnvironment *a2)
{
  uint64_t v3[2];
  unint64_t v4[2];
  _OWORD v5[3];
  uint64_t v6;
  _OWORD v7[4];
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v6 = 0;
  v4[0] = 0;
  memset(v5, 0, sizeof(v5));
  v4[1] = (unint64_t)&str_110;
  v3[0] = 0;
  v3[1] = (uint64_t)&str_110;
  v7[0] = constinit_16;
  v7[1] = *(_OWORD *)&off_24ED236D8;
  v7[2] = xmmword_24ED236E8;
  v7[3] = *(_OWORD *)&off_24ED236F8;
  re::StringID::destroyString((re::StringID *)v3);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v5[1] + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(v5);
  re::StringID::destroyString((re::StringID *)v4);
}

uint64_t `anonymous namespace'::makeIKTaskCompile(uint64_t a1, uint64_t *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t result;
  const char *v10;
  uint64_t v11;
  _BYTE v12[8];
  _QWORD *v13;
  uint64_t v14;
  char v15;

  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_19;
  }
  if (a3 == 1)
  {
LABEL_19:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    _os_crash();
    __break(1u);
    goto LABEL_20;
  }
  if (a3 <= 2)
  {
LABEL_20:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2);
    _os_crash();
    __break(1u);
    goto LABEL_21;
  }
  if (!a5)
  {
LABEL_21:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v6 = *a2;
  v5 = a2[1];
  v7 = a2[2];
  v8 = *a4;
  v10 = "target";
  v11 = 6;
  re::RigDataValue::attributeValue(v8, (uint64_t)&v10, (uint64_t)v12);
  re::RigDataValue::operator=(v13, v6);
  if (!v12[0] && v14 && (v15 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v14 + 40))();
  v10 = "targetAlpha";
  v11 = 11;
  re::RigDataValue::attributeValue(v8, (uint64_t)&v10, (uint64_t)v12);
  re::RigDataValue::operator=(v13, v5);
  if (!v12[0] && v14 && (v15 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v14 + 40))();
  v10 = "taskIndex";
  v11 = 9;
  re::RigDataValue::attributeValue(v8, (uint64_t)&v10, (uint64_t)v12);
  re::RigDataValue::operator=(v13, v7);
  if (!v12[0] && v14 && (v15 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v14 + 40))();
  return 1;
}

void re::internal::registerMakeIKPenetrationCorrectionTask(re::internal *this, re::RigEnvironment *a2)
{
  uint64_t v3[2];
  unint64_t v4[2];
  _OWORD v5[3];
  uint64_t v6;
  _OWORD v7[4];
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v6 = 0;
  v4[0] = 0;
  memset(v5, 0, sizeof(v5));
  v4[1] = (unint64_t)&str_110;
  v3[0] = 0;
  v3[1] = (uint64_t)&str_110;
  v7[0] = constinit_23;
  v7[1] = *(_OWORD *)&off_24ED23718;
  v7[2] = xmmword_24ED23728;
  v7[3] = *(_OWORD *)&off_24ED23738;
  re::StringID::destroyString((re::StringID *)v3);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v5[1] + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(v5);
  re::StringID::destroyString((re::StringID *)v4);
}

uint64_t `anonymous namespace'::makeIKPenetrationCorrectionTask(uint64_t a1, uint64_t *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t result;
  const char *v10;
  uint64_t v11;
  _BYTE v12[8];
  _QWORD *v13;
  uint64_t v14;
  char v15;

  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_19;
  }
  if (a3 == 1)
  {
LABEL_19:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    _os_crash();
    __break(1u);
    goto LABEL_20;
  }
  if (a3 <= 2)
  {
LABEL_20:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2);
    _os_crash();
    __break(1u);
    goto LABEL_21;
  }
  if (!a5)
  {
LABEL_21:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v6 = *a2;
  v5 = a2[1];
  v7 = a2[2];
  v8 = *a4;
  v10 = "inJointName";
  v11 = 11;
  re::RigDataValue::attributeValue(v8, (uint64_t)&v10, (uint64_t)v12);
  re::RigDataValue::operator=(v13, v6);
  if (!v12[0] && v14 && (v15 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v14 + 40))();
  v10 = "inRayCastDirection";
  v11 = 18;
  re::RigDataValue::attributeValue(v8, (uint64_t)&v10, (uint64_t)v12);
  re::RigDataValue::operator=(v13, v5);
  if (!v12[0] && v14 && (v15 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v14 + 40))();
  v10 = "inRayCastLength";
  v11 = 15;
  re::RigDataValue::attributeValue(v8, (uint64_t)&v10, (uint64_t)v12);
  re::RigDataValue::operator=(v13, v7);
  if (!v12[0] && v14 && (v15 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v14 + 40))();
  return 1;
}

void re::internal::registerMakeIKRigJointSettings(re::internal *this, re::RigEnvironment *a2)
{
  uint64_t v3[2];
  unint64_t v4[2];
  _OWORD v5[3];
  uint64_t v6;
  _OWORD v7[5];
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v6 = 0;
  v4[0] = 0;
  memset(v5, 0, sizeof(v5));
  v4[1] = (unint64_t)&str_110;
  v3[0] = 0;
  v3[1] = (uint64_t)&str_110;
  v7[2] = xmmword_24ED23768;
  v7[3] = *(_OWORD *)&off_24ED23778;
  v7[4] = xmmword_24ED23788;
  v7[0] = constinit_30;
  v7[1] = *(_OWORD *)&off_24ED23758;
  re::StringID::destroyString((re::StringID *)v3);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v5[1] + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(v5);
  re::StringID::destroyString((re::StringID *)v4);
}

uint64_t `anonymous namespace'::makeIKRigJointSettings(uint64_t a1, uint64_t *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t result;
  const char *v11;
  uint64_t v12;
  _BYTE v13[8];
  _QWORD *v14;
  uint64_t v15;
  char v16;

  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_24;
  }
  if (a3 == 1)
  {
LABEL_24:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    _os_crash();
    __break(1u);
    goto LABEL_25;
  }
  if (a3 <= 2)
  {
LABEL_25:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2);
    _os_crash();
    __break(1u);
    goto LABEL_26;
  }
  if (a3 == 3)
  {
LABEL_26:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 3, 3);
    _os_crash();
    __break(1u);
    goto LABEL_27;
  }
  if (!a5)
  {
LABEL_27:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v6 = *a2;
  v5 = a2[1];
  v8 = a2[2];
  v7 = a2[3];
  v9 = *a4;
  v11 = "inJointName";
  v12 = 11;
  re::RigDataValue::attributeValue(v9, (uint64_t)&v11, (uint64_t)v13);
  re::RigDataValue::operator=(v14, v6);
  if (!v13[0] && v15 && (v16 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v15 + 40))();
  v11 = "inRetargetingGain";
  v12 = 17;
  re::RigDataValue::attributeValue(v9, (uint64_t)&v11, (uint64_t)v13);
  re::RigDataValue::operator=(v14, v5);
  if (!v13[0] && v15 && (v16 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v15 + 40))();
  v11 = "inRetargetingGainDof";
  v12 = 20;
  re::RigDataValue::attributeValue(v9, (uint64_t)&v11, (uint64_t)v13);
  re::RigDataValue::operator=(v14, v8);
  if (!v13[0] && v15 && (v16 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v15 + 40))();
  v11 = "inStiffness";
  v12 = 11;
  re::RigDataValue::attributeValue(v9, (uint64_t)&v11, (uint64_t)v13);
  re::RigDataValue::operator=(v14, v7);
  if (!v13[0] && v15 && (v16 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v15 + 40))();
  return 1;
}

void re::internal::registerMakeIKRigTaskSettings(re::internal *this, re::RigEnvironment *a2)
{
  uint64_t v3[2];
  unint64_t v4[2];
  _OWORD v5[3];
  uint64_t v6;
  _OWORD v7[5];
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v6 = 0;
  v4[0] = 0;
  memset(v5, 0, sizeof(v5));
  v4[1] = (unint64_t)&str_110;
  v3[0] = 0;
  v3[1] = (uint64_t)&str_110;
  v7[2] = xmmword_24ED237B8;
  v7[3] = *(_OWORD *)&off_24ED237C8;
  v7[4] = xmmword_24ED237D8;
  v7[0] = constinit_38;
  v7[1] = *(_OWORD *)&off_24ED237A8;
  re::StringID::destroyString((re::StringID *)v3);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v5[1] + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(v5);
  re::StringID::destroyString((re::StringID *)v4);
}

uint64_t `anonymous namespace'::makeIKRigTaskSettings(uint64_t a1, uint64_t *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t result;
  const char *v11;
  uint64_t v12;
  _BYTE v13[8];
  _QWORD *v14;
  uint64_t v15;
  char v16;

  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_24;
  }
  if (a3 == 1)
  {
LABEL_24:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    _os_crash();
    __break(1u);
    goto LABEL_25;
  }
  if (a3 <= 2)
  {
LABEL_25:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2);
    _os_crash();
    __break(1u);
    goto LABEL_26;
  }
  if (a3 == 3)
  {
LABEL_26:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 3, 3);
    _os_crash();
    __break(1u);
    goto LABEL_27;
  }
  if (!a5)
  {
LABEL_27:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v6 = *a2;
  v5 = a2[1];
  v8 = a2[2];
  v7 = a2[3];
  v9 = *a4;
  v11 = "inTaskBoneName";
  v12 = 14;
  re::RigDataValue::attributeValue(v9, (uint64_t)&v11, (uint64_t)v13);
  re::RigDataValue::operator=(v14, v6);
  if (!v13[0] && v15 && (v16 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v15 + 40))();
  v11 = "inPositionWeight";
  v12 = 16;
  re::RigDataValue::attributeValue(v9, (uint64_t)&v11, (uint64_t)v13);
  re::RigDataValue::operator=(v14, v5);
  if (!v13[0] && v15 && (v16 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v15 + 40))();
  v11 = "inRotationWeight";
  v12 = 16;
  re::RigDataValue::attributeValue(v9, (uint64_t)&v11, (uint64_t)v13);
  re::RigDataValue::operator=(v14, v8);
  if (!v13[0] && v15 && (v16 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v15 + 40))();
  v11 = "inLookAtAxis";
  v12 = 12;
  re::RigDataValue::attributeValue(v9, (uint64_t)&v11, (uint64_t)v13);
  re::RigDataValue::operator=(v14, v7);
  if (!v13[0] && v15 && (v16 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v15 + 40))();
  return 1;
}

void re::internal::registerMakeIKRigSolverSettings(re::internal *this, re::RigEnvironment *a2)
{
  uint64_t v3[2];
  unint64_t v4[2];
  _OWORD v5[3];
  uint64_t v6;
  _OWORD v7[3];
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v6 = 0;
  v4[0] = 0;
  memset(v5, 0, sizeof(v5));
  v4[1] = (unint64_t)&str_110;
  v3[0] = 0;
  v3[1] = (uint64_t)&str_110;
  v7[0] = constinit_43;
  v7[1] = *(_OWORD *)&off_24ED237F8;
  v7[2] = xmmword_24ED23808;
  re::StringID::destroyString((re::StringID *)v3);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v5[1] + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(v5);
  re::StringID::destroyString((re::StringID *)v4);
}

uint64_t `anonymous namespace'::makeIKRigSolverSettings(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t result;
  const char *v9;
  uint64_t v10;
  _BYTE v11[8];
  _QWORD *v12;
  uint64_t v13;
  char v14;

  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_14;
  }
  if (a3 == 1)
  {
LABEL_14:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    _os_crash();
    __break(1u);
    goto LABEL_15;
  }
  if (!a5)
  {
LABEL_15:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v6 = *a2;
  v5 = a2[1];
  v7 = *a4;
  v9 = "inMaxIterations";
  v10 = 15;
  re::RigDataValue::attributeValue(v7, (uint64_t)&v9, (uint64_t)v11);
  re::RigDataValue::operator=(v12, v6);
  if (!v11[0] && v13 && (v14 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v13 + 40))();
  v9 = "inRetargetingGain";
  v10 = 17;
  re::RigDataValue::attributeValue(v7, (uint64_t)&v9, (uint64_t)v11);
  re::RigDataValue::operator=(v12, v5);
  if (!v11[0] && v13 && (v14 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v13 + 40))();
  return 1;
}

void re::introspect_BlendSpaceType(re *this, const re::IntrospectionBase *a2)
{
  unsigned __int8 v2;
  unsigned __int8 v3;
  uint64_t *v4;
  uint64_t v5;
  unsigned int *v6;
  _anonymous_namespace_ *v7;
  unint64_t v8;
  unint64_t i;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  char v13;
  unsigned __int8 *v14;
  int v15;
  uint64_t v16;
  unint64_t j;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  char v21;
  unsigned __int8 *v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  re *v26;
  uint64_t *v27;
  re *v28;
  uint64_t *v29;
  re *v30;
  uint64_t *v31;
  re *v32;
  uint64_t *v33;
  re *v34;
  uint64_t *v35;
  re *v36;
  uint64_t *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  const char *v41;
  StringID v42;
  _QWORD v43[2];
  _QWORD v44[61];

  v2 = atomic_load((unsigned __int8 *)&qword_2540F9F28);
  if ((v2 & 1) == 0)
  {
    v26 = (re *)__cxa_guard_acquire(&qword_2540F9F28);
    if ((_DWORD)v26)
    {
      v27 = re::introspectionAllocator(v26);
      v28 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v27 + 32))(v27, 24, 8);
      *(_DWORD *)v28 = 1;
      *((_QWORD *)v28 + 1) = 0;
      *((_QWORD *)v28 + 2) = "None";
      qword_2540F9FB8 = (uint64_t)v28;
      v29 = re::introspectionAllocator(v28);
      v30 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v29 + 32))(v29, 24, 8);
      *(_DWORD *)v30 = 1;
      *((_QWORD *)v30 + 1) = 1;
      *((_QWORD *)v30 + 2) = "1DLinearUniform";
      qword_2540F9FC0 = (uint64_t)v30;
      v31 = re::introspectionAllocator(v30);
      v32 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v31 + 32))(v31, 24, 8);
      *(_DWORD *)v32 = 1;
      *((_QWORD *)v32 + 1) = 2;
      *((_QWORD *)v32 + 2) = "1DLinearNonUniform";
      qword_2540F9FC8 = (uint64_t)v32;
      v33 = re::introspectionAllocator(v32);
      v34 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v33 + 32))(v33, 24, 8);
      *(_DWORD *)v34 = 1;
      *((_QWORD *)v34 + 1) = 3;
      *((_QWORD *)v34 + 2) = "2DLinearUniform";
      qword_2540F9FD0 = (uint64_t)v34;
      v35 = re::introspectionAllocator(v34);
      v36 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v35 + 32))(v35, 24, 8);
      *(_DWORD *)v36 = 1;
      *((_QWORD *)v36 + 1) = 4;
      *((_QWORD *)v36 + 2) = "KernelRegression";
      qword_2540F9FD8 = (uint64_t)v36;
      v37 = re::introspectionAllocator(v36);
      v38 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v37 + 32))(v37, 24, 8);
      *(_DWORD *)v38 = 1;
      *(_QWORD *)(v38 + 8) = 5;
      *(_QWORD *)(v38 + 16) = "RBFInterpolation";
      qword_2540F9FE0 = v38;
      __cxa_guard_release(&qword_2540F9F28);
    }
  }
  v3 = atomic_load((unsigned __int8 *)&qword_2540F9F30);
  if ((v3 & 1) == 0 && __cxa_guard_acquire(&qword_2540F9F30))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_2540FA098, "BlendSpaceType", 4, 4, 1, 1);
    qword_2540FA098 = (uint64_t)&off_24ED7D9E8;
    qword_2540FA0D8 = (uint64_t)&re::introspect_BlendSpaceType(BOOL)::enumTable;
    dword_2540FA0A8 = 9;
    __cxa_guard_release(&qword_2540F9F30);
  }
  if ((_MergedGlobals_19 & 1) == 0)
  {
    _MergedGlobals_19 = 1;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_2540FA098, a2);
    v40 = 0x3CA07D4B122E305ELL;
    v41 = "BlendSpaceType";
    v44[0] = 0x607DD0F01DCLL;
    v44[1] = "uint32_t";
    v4 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v44);
    if (v4)
    {
      v5 = *v4;
      re::StringID::destroyString((re::StringID *)v44);
      v6 = (unsigned int *)qword_2540FA0D8;
      v43[1] = v5;
      re::TypeBuilder::beginEnumType((uint64_t)v44, &v40, 1, 1, (uint64_t)v43);
      v8 = *v6;
      if ((_DWORD)v8)
      {
        for (i = 0; i < v8; ++i)
        {
          v10 = *(_QWORD *)(*((_QWORD *)v6 + 1) + 8 * i);
          if (*(_DWORD *)v10 == 1)
          {
            v11 = *(char **)(v10 + 16);
            if (v11)
            {
              v12 = *v11;
              if (*v11)
              {
                v13 = v11[1];
                if (v13)
                {
                  v14 = (unsigned __int8 *)(v11 + 2);
                  do
                  {
                    v12 = 31 * v12 + v13;
                    v15 = *v14++;
                    v13 = v15;
                  }
                  while (v15);
                }
              }
            }
            else
            {
              v12 = 0;
            }
            v16 = *(_QWORD *)(v10 + 8);
            *(_QWORD *)&v42.var0 = 2 * v12;
            v42.var1 = v11;
            re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v44, v16, &v42);
            re::StringID::destroyString((re::StringID *)&v42);
            v8 = *v6;
          }
        }
        if (v8)
        {
          for (j = 0; j < v8; ++j)
          {
            v18 = *(_QWORD *)(*((_QWORD *)v6 + 1) + 8 * j);
            if (*(_DWORD *)v18 == 2)
            {
              v19 = *(char **)(v18 + 16);
              if (v19)
              {
                v20 = *v19;
                if (*v19)
                {
                  v21 = v19[1];
                  if (v21)
                  {
                    v22 = (unsigned __int8 *)(v19 + 2);
                    do
                    {
                      v20 = 31 * v20 + v21;
                      v23 = *v22++;
                      v21 = v23;
                    }
                    while (v23);
                  }
                }
              }
              else
              {
                v20 = 0;
              }
              v24 = *(_QWORD *)(v18 + 8);
              *(_QWORD *)&v42.var0 = 2 * v20;
              v42.var1 = v19;
              re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v44, v24, &v42);
              re::StringID::destroyString((re::StringID *)&v42);
              v8 = *v6;
            }
          }
        }
      }
      re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v44, v25);
      xmmword_2540FA0B8 = (__int128)v42;
      re::StringID::destroyString((re::StringID *)&v40);
    }
    else
    {
      re::StringID::destroyString((re::StringID *)v44);
      re::internal::assertLog((re::internal *)5, v39, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "BlendSpaceType", v40, v41);
      _os_crash();
      __break(1u);
    }
  }
}

void re::internal::defaultConstruct<re::BlendSpaceAxisDefinition>(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  *a3 = 0;
  a3[1] = &str_110;
  a3[2] = 0;
  a3[3] = &str_110;
  a3[4] = 0;
  a3[5] = 0;
}

void re::internal::defaultDestruct<re::BlendSpaceAxisDefinition>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::StringID::destroyString((re::StringID *)(a3 + 16));
  re::StringID::destroyString((re::StringID *)a3);
}

_QWORD *re::internal::defaultConstructV2<re::BlendSpaceAxisDefinition>(_QWORD *result)
{
  *result = 0;
  result[1] = &str_110;
  result[2] = 0;
  result[3] = &str_110;
  result[4] = 0;
  result[5] = 0;
  return result;
}

void re::internal::defaultDestructV2<re::BlendSpaceAxisDefinition>(uint64_t a1)
{
  re::StringID::destroyString((re::StringID *)(a1 + 16));
  re::StringID::destroyString((re::StringID *)a1);
}

void re::internal::defaultConstruct<re::BlendSpaceSampleDefinition>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = &str_110;
  *(_DWORD *)(a3 + 16) = 0;
  *(_QWORD *)(a3 + 56) = 0;
  *(_QWORD *)(a3 + 32) = 0;
  *(_QWORD *)(a3 + 40) = 0;
  *(_QWORD *)(a3 + 24) = 0;
  *(_DWORD *)(a3 + 48) = 0;
}

void re::internal::defaultDestruct<re::BlendSpaceSampleDefinition>(int a1, int a2, re::StringID *this)
{
  uint64_t v4;
  _QWORD *v5;

  v5 = (_QWORD *)((char *)this + 24);
  v4 = *((_QWORD *)this + 3);
  if (v4)
  {
    if (*((_QWORD *)this + 7))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *((_QWORD *)this + 7) = 0;
    v5[1] = 0;
    v5[2] = 0;
    *v5 = 0;
    ++*((_DWORD *)this + 12);
  }
  re::StringID::destroyString(this);
}

uint64_t re::internal::defaultConstructV2<re::BlendSpaceSampleDefinition>(uint64_t result)
{
  *(_QWORD *)result = 0;
  *(_QWORD *)(result + 8) = &str_110;
  *(_DWORD *)(result + 16) = 0;
  *(_QWORD *)(result + 56) = 0;
  *(_QWORD *)(result + 32) = 0;
  *(_QWORD *)(result + 40) = 0;
  *(_QWORD *)(result + 24) = 0;
  *(_DWORD *)(result + 48) = 0;
  return result;
}

void re::internal::defaultDestructV2<re::BlendSpaceSampleDefinition>(re::StringID *this)
{
  uint64_t v2;
  _QWORD *v3;

  v3 = (_QWORD *)((char *)this + 24);
  v2 = *((_QWORD *)this + 3);
  if (v2)
  {
    if (*((_QWORD *)this + 7))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *((_QWORD *)this + 7) = 0;
    v3[1] = 0;
    v3[2] = 0;
    *v3 = 0;
    ++*((_DWORD *)this + 12);
  }
  re::StringID::destroyString(this);
}

uint64_t *re::allocInfo_BlendSpaceDefinition(re *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  v1 = atomic_load((unsigned __int8 *)&qword_2540F9F68);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_2540F9F68))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FA1D0, 0);
    *(_QWORD *)(v3 + 22) = 0;
    qword_2540FA1E0 = 0;
    qword_2540FA1F0 = 0;
    qword_2540FA1F8 = 0xFFFFFFFFLL;
    qword_2540FA1D0 = (uint64_t)&off_24ED7DAA8;
    qword_2540FA200 = (uint64_t)"BlendSpaceDefinition";
    dword_2540FA208 = 0;
    xmmword_2540FA210 = 0u;
    unk_2540FA220 = 0u;
    xmmword_2540FA230 = 0u;
    qword_2540FA240 = 0;
    __cxa_guard_release(&qword_2540F9F68);
  }
  return &qword_2540FA1D0;
}

void re::initInfo_BlendSpaceDefinition(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  const re::IntrospectionBase *v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  __int128 v13;
  _QWORD v14[2];
  __int128 v15;

  v14[0] = 0x32C0B3902874E510;
  v14[1] = "BlendSpaceDefinition";
  re::StringID::destroyString((re::StringID *)v14);
  *((_OWORD *)this + 2) = v15;
  v4 = atomic_load((unsigned __int8 *)&qword_2540F9F70);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_2540F9F70);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      re::introspect_BlendSpaceType((re *)v6, v7);
      v8 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
      *(_DWORD *)v8 = 1;
      *(_QWORD *)(v8 + 8) = "type";
      *(_QWORD *)(v8 + 16) = &qword_2540FA098;
      *(_QWORD *)(v8 + 24) = 0;
      *(_QWORD *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + 40) = 0;
      *(_QWORD *)(v8 + 48) = 0;
      *(_QWORD *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_2540F9FA0 = v8;
      v9 = re::introspectionAllocator((re *)v8);
      re::IntrospectionInfo<re::DynamicArray<re::BlendSpaceAxisDefinition>>::get();
      v10 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v9 + 32))(v9, 72, 8);
      *(_DWORD *)v10 = 1;
      *(_QWORD *)(v10 + 8) = "axes";
      *(_QWORD *)(v10 + 16) = &qword_2540FA018;
      *(_QWORD *)(v10 + 24) = 0;
      *(_QWORD *)(v10 + 32) = 0x800000002;
      *(_DWORD *)(v10 + 40) = 0;
      *(_QWORD *)(v10 + 48) = 0;
      *(_QWORD *)(v10 + 56) = 0;
      *(_DWORD *)(v10 + 64) = 0;
      qword_2540F9FA8 = v10;
      v11 = re::introspectionAllocator((re *)v10);
      re::IntrospectionInfo<re::DynamicArray<re::BlendSpaceSampleDefinition>>::get();
      v12 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v11 + 32))(v11, 72, 8);
      *(_DWORD *)v12 = 1;
      *(_QWORD *)(v12 + 8) = "samples";
      *(_QWORD *)(v12 + 16) = &qword_2540FA058;
      *(_QWORD *)(v12 + 24) = 0;
      *(_QWORD *)(v12 + 32) = 0x3000000003;
      *(_DWORD *)(v12 + 40) = 0;
      *(_QWORD *)(v12 + 48) = 0;
      *(_QWORD *)(v12 + 56) = 0;
      *(_DWORD *)(v12 + 64) = 0;
      qword_2540F9FB0 = v12;
      __cxa_guard_release(&qword_2540F9F70);
    }
  }
  *((_QWORD *)this + 2) = 0x5800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 3;
  *((_QWORD *)this + 8) = &qword_2540F9FA0;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::BlendSpaceDefinition>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::BlendSpaceDefinition>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::BlendSpaceDefinition>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::BlendSpaceDefinition>;
  re::IntrospectionRegistry::add(this, v3);
  v13 = v15;
}

void re::IntrospectionInfo<re::DynamicArray<re::BlendSpaceAxisDefinition>>::get()
{
  unsigned __int8 v0;
  uint64_t *v1;
  unsigned __int8 v2;
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  int v5;
  re::IntrospectionRegistry *v6;
  const re::IntrospectionBase *v7;
  const char *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  re *v13;
  uint64_t *v14;
  const re::IntrospectionBase *v15;
  void *v16;
  uint64_t v17;
  uint64_t *v18;
  const re::IntrospectionBase *v19;
  void *v20;
  uint64_t v21;
  uint64_t *v22;
  const re::IntrospectionBase *v23;
  void *v24;
  uint64_t v25;
  uint64_t *v26;
  const re::IntrospectionBase *v27;
  void *v28;
  uint64_t v29;
  uint64_t *v30;
  const re::IntrospectionBase *v31;
  void *v32;
  uint64_t v33;
  uint64_t *v34;
  const re::IntrospectionBase *v35;
  void *v36;
  uint64_t v37;
  __int128 v38;
  __int128 v39;
  uint64_t v40[2];
  __int128 v41;
  const char *v42;
  __int128 v43;

  v0 = atomic_load((unsigned __int8 *)&qword_2540F9F78);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_2540F9F78))
  {
    re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_2540FA018);
    qword_2540FA018 = (uint64_t)&off_24ED23828;
    __cxa_guard_release(&qword_2540F9F78);
  }
  if ((byte_2540F9F21 & 1) == 0)
  {
    v1 = (uint64_t *)qword_2540F9F48;
    if (qword_2540F9F48)
      goto LABEL_7;
    v2 = atomic_load((unsigned __int8 *)&qword_2540F9F38);
    if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_2540F9F38))
    {
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FA0E0, 0);
      *(_QWORD *)(v12 + 22) = 0;
      qword_2540FA0F0 = 0;
      *(_QWORD *)&xmmword_2540FA100 = 0;
      *((_QWORD *)&xmmword_2540FA100 + 1) = 0xFFFFFFFFLL;
      qword_2540FA0E0 = (uint64_t)&off_24ED7DAA8;
      qword_2540FA110 = (uint64_t)"BlendSpaceAxisDefinition";
      dword_2540FA118 = 0;
      xmmword_2540FA120 = 0u;
      *(_OWORD *)&qword_2540FA130 = 0u;
      xmmword_2540FA140 = 0u;
      qword_2540FA150 = 0;
      __cxa_guard_release(&qword_2540F9F38);
    }
    qword_2540F9F48 = (uint64_t)&qword_2540FA0E0;
    *(_QWORD *)&v43 = 0x65A436012C3C7D12;
    *((_QWORD *)&v43 + 1) = "BlendSpaceAxisDefinition";
    re::StringID::destroyString((re::StringID *)&v43);
    xmmword_2540FA100 = v41;
    v4 = atomic_load((unsigned __int8 *)&qword_2540F9F40);
    if ((v4 & 1) == 0)
    {
      v13 = (re *)__cxa_guard_acquire(&qword_2540F9F40);
      if ((_DWORD)v13)
      {
        v14 = re::introspectionAllocator(v13);
        v16 = re::IntrospectionInfo<re::StringID>::get(1, v15);
        v17 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v14 + 32))(v14, 72, 8);
        *(_DWORD *)v17 = 1;
        *(_QWORD *)(v17 + 8) = "name";
        *(_QWORD *)(v17 + 16) = v16;
        *(_QWORD *)(v17 + 24) = 0;
        *(_QWORD *)(v17 + 32) = 1;
        *(_DWORD *)(v17 + 40) = 0;
        *(_QWORD *)(v17 + 48) = 0;
        *(_QWORD *)(v17 + 56) = 0;
        *(_DWORD *)(v17 + 64) = 0;
        qword_2540F9FE8 = v17;
        v18 = re::introspectionAllocator((re *)v17);
        v20 = re::IntrospectionInfo<re::StringID>::get(1, v19);
        v21 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v18 + 32))(v18, 72, 8);
        *(_DWORD *)v21 = 1;
        *(_QWORD *)(v21 + 8) = "controlValueBindPath";
        *(_QWORD *)(v21 + 16) = v20;
        *(_QWORD *)(v21 + 24) = 0;
        *(_QWORD *)(v21 + 32) = 0x1000000002;
        *(_DWORD *)(v21 + 40) = 0;
        *(_QWORD *)(v21 + 48) = 0;
        *(_QWORD *)(v21 + 56) = 0;
        *(_DWORD *)(v21 + 64) = 0;
        qword_2540F9FF0 = v21;
        v22 = re::introspectionAllocator((re *)v21);
        v24 = re::introspect_float((re *)1, v23);
        v25 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v22 + 32))(v22, 72, 8);
        *(_DWORD *)v25 = 1;
        *(_QWORD *)(v25 + 8) = "minValue";
        *(_QWORD *)(v25 + 16) = v24;
        *(_QWORD *)(v25 + 24) = 0;
        *(_QWORD *)(v25 + 32) = 0x2000000003;
        *(_DWORD *)(v25 + 40) = 0;
        *(_QWORD *)(v25 + 48) = 0;
        *(_QWORD *)(v25 + 56) = 0;
        *(_DWORD *)(v25 + 64) = 0;
        qword_2540F9FF8 = v25;
        v26 = re::introspectionAllocator((re *)v25);
        v28 = re::introspect_float((re *)1, v27);
        v29 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v26 + 32))(v26, 72, 8);
        *(_DWORD *)v29 = 1;
        *(_QWORD *)(v29 + 8) = "maxValue";
        *(_QWORD *)(v29 + 16) = v28;
        *(_QWORD *)(v29 + 24) = 0;
        *(_QWORD *)(v29 + 32) = 0x2400000004;
        *(_DWORD *)(v29 + 40) = 0;
        *(_QWORD *)(v29 + 48) = 0;
        *(_QWORD *)(v29 + 56) = 0;
        *(_DWORD *)(v29 + 64) = 0;
        qword_2540FA000 = v29;
        v30 = re::introspectionAllocator((re *)v29);
        v32 = re::introspect_float((re *)1, v31);
        v33 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v30 + 32))(v30, 72, 8);
        *(_DWORD *)v33 = 1;
        *(_QWORD *)(v33 + 8) = "defaultControlValue";
        *(_QWORD *)(v33 + 16) = v32;
        *(_QWORD *)(v33 + 24) = 0;
        *(_QWORD *)(v33 + 32) = 0x2800000005;
        *(_DWORD *)(v33 + 40) = 0;
        *(_QWORD *)(v33 + 48) = 0;
        *(_QWORD *)(v33 + 56) = 0;
        *(_DWORD *)(v33 + 64) = 0;
        qword_2540FA008 = v33;
        v34 = re::introspectionAllocator((re *)v33);
        v36 = re::introspect_uint32_t((re *)1, v35);
        v37 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v34 + 32))(v34, 72, 8);
        *(_DWORD *)v37 = 1;
        *(_QWORD *)(v37 + 8) = "uniformSampleCount";
        *(_QWORD *)(v37 + 16) = v36;
        *(_QWORD *)(v37 + 24) = 0;
        *(_QWORD *)(v37 + 32) = 0x2C00000006;
        *(_DWORD *)(v37 + 40) = 0;
        *(_QWORD *)(v37 + 48) = 0;
        *(_QWORD *)(v37 + 56) = 0;
        *(_DWORD *)(v37 + 64) = 0;
        qword_2540FA010 = v37;
        __cxa_guard_release(&qword_2540F9F40);
      }
    }
    qword_2540FA0F0 = 0x3000000008;
    v1 = &qword_2540FA0E0;
    dword_2540FA0F8 = 8;
    word_2540FA0FC = 0;
    dword_2540FA118 = 6;
    *(_QWORD *)&xmmword_2540FA120 = &qword_2540F9FE8;
    *((_QWORD *)&xmmword_2540FA120 + 1) = re::internal::defaultConstruct<re::BlendSpaceAxisDefinition>;
    qword_2540FA130 = (uint64_t)re::internal::defaultDestruct<re::BlendSpaceAxisDefinition>;
    *(_QWORD *)&xmmword_2540FA140 = 0;
    qword_2540FA138 = 0;
    *((_QWORD *)&xmmword_2540FA140 + 1) = re::internal::defaultConstructV2<re::BlendSpaceAxisDefinition>;
    qword_2540FA150 = (uint64_t)re::internal::defaultDestructV2<re::BlendSpaceAxisDefinition>;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_2540FA0E0, v3);
    v43 = v41;
    if ((byte_2540F9F21 & 1) == 0)
    {
LABEL_7:
      byte_2540F9F21 = 1;
      v5 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FA018, 0);
      qword_2540FA028 = 0x2800000003;
      dword_2540FA030 = v5;
      word_2540FA034 = 0;
      *(_QWORD *)&xmmword_2540FA038 = 0;
      *((_QWORD *)&xmmword_2540FA038 + 1) = 0xFFFFFFFFLL;
      qword_2540FA048 = (uint64_t)v1;
      unk_2540FA050 = 0;
      qword_2540FA018 = (uint64_t)&off_24ED23828;
      re::IntrospectionRegistry::add(v6, v7);
      re::getPrettyTypeName((re *)&qword_2540FA018, (const re::IntrospectionBase *)&v41);
      if ((BYTE8(v41) & 1) != 0)
        v8 = v42;
      else
        v8 = (char *)&v41 + 9;
      if ((_QWORD)v41 && (BYTE8(v41) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v41 + 40))();
      v39 = *((_OWORD *)v1 + 2);
      v9 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v40);
      if (v9)
      {
        v10 = *v9;
        *((_QWORD *)&v38 + 1) = v10;
      }
      else
      {
        v43 = v39;
        re::TypeBuilder::beginListType((uint64_t)&v41, v40, 1, 0x28uLL, 8uLL, &v43);
        re::TypeBuilder::setConstructor((uint64_t)&v41, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceAxisDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v41, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceAxisDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v41, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v41, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceAxisDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceAxisDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v41, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceAxisDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v41, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceAxisDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceAxisDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceAxisDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v41, v11);
      }
      xmmword_2540FA038 = v38;
      re::StringID::destroyString((re::StringID *)v40);
    }
  }
}

void re::IntrospectionInfo<re::DynamicArray<re::BlendSpaceSampleDefinition>>::get()
{
  unsigned __int8 v0;
  uint64_t *v1;
  unsigned __int8 v2;
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  int v5;
  re::IntrospectionRegistry *v6;
  const re::IntrospectionBase *v7;
  const char *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  re *v13;
  uint64_t *v14;
  const re::IntrospectionBase *v15;
  void *v16;
  uint64_t v17;
  uint64_t *v18;
  const re::IntrospectionBase *v19;
  void *v20;
  uint64_t v21;
  uint64_t *v22;
  const re::IntrospectionBase *v23;
  uint64_t *v24;
  uint64_t v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28[2];
  __int128 v29;
  const char *v30;
  __int128 v31;

  v0 = atomic_load((unsigned __int8 *)&qword_2540F9F80);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_2540F9F80))
  {
    re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_2540FA058);
    qword_2540FA058 = (uint64_t)&off_24ED238C0;
    __cxa_guard_release(&qword_2540F9F80);
  }
  if ((byte_2540F9F22 & 1) == 0)
  {
    v1 = (uint64_t *)qword_2540F9F60;
    if (qword_2540F9F60)
      goto LABEL_7;
    v2 = atomic_load((unsigned __int8 *)&qword_2540F9F50);
    if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_2540F9F50))
    {
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FA158, 0);
      *(_QWORD *)(v12 + 22) = 0;
      qword_2540FA168 = 0;
      *(_QWORD *)&xmmword_2540FA178 = 0;
      *((_QWORD *)&xmmword_2540FA178 + 1) = 0xFFFFFFFFLL;
      qword_2540FA158 = (uint64_t)&off_24ED7DAA8;
      qword_2540FA188 = (uint64_t)"BlendSpaceSampleDefinition";
      dword_2540FA190 = 0;
      *(_OWORD *)(v12 + 64) = 0u;
      *(_OWORD *)(v12 + 80) = 0u;
      *(_OWORD *)(v12 + 96) = 0u;
      qword_2540FA1C8 = 0;
      __cxa_guard_release(&qword_2540F9F50);
    }
    qword_2540F9F60 = (uint64_t)&qword_2540FA158;
    *(_QWORD *)&v31 = 0x63C009CC69597824;
    *((_QWORD *)&v31 + 1) = "BlendSpaceSampleDefinition";
    re::StringID::destroyString((re::StringID *)&v31);
    xmmword_2540FA178 = v29;
    v4 = atomic_load((unsigned __int8 *)&qword_2540F9F58);
    if ((v4 & 1) == 0)
    {
      v13 = (re *)__cxa_guard_acquire(&qword_2540F9F58);
      if ((_DWORD)v13)
      {
        v14 = re::introspectionAllocator(v13);
        v16 = re::IntrospectionInfo<re::StringID>::get(1, v15);
        v17 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v14 + 32))(v14, 72, 8);
        *(_DWORD *)v17 = 1;
        *(_QWORD *)(v17 + 8) = "name";
        *(_QWORD *)(v17 + 16) = v16;
        *(_QWORD *)(v17 + 24) = 0;
        *(_QWORD *)(v17 + 32) = 1;
        *(_DWORD *)(v17 + 40) = 0;
        *(_QWORD *)(v17 + 48) = 0;
        *(_QWORD *)(v17 + 56) = 0;
        *(_DWORD *)(v17 + 64) = 0;
        qword_2540F9F88 = v17;
        v18 = re::introspectionAllocator((re *)v17);
        v20 = re::introspect_float((re *)1, v19);
        v21 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v18 + 32))(v18, 72, 8);
        *(_DWORD *)v21 = 1;
        *(_QWORD *)(v21 + 8) = "falloffParameter";
        *(_QWORD *)(v21 + 16) = v20;
        *(_QWORD *)(v21 + 24) = 0;
        *(_QWORD *)(v21 + 32) = 0x1000000002;
        *(_DWORD *)(v21 + 40) = 0;
        *(_QWORD *)(v21 + 48) = 0;
        *(_QWORD *)(v21 + 56) = 0;
        *(_DWORD *)(v21 + 64) = 0;
        qword_2540F9F90 = v21;
        v22 = re::introspectionAllocator((re *)v21);
        v24 = re::IntrospectionInfo<re::DynamicArray<float>>::get(1, v23);
        v25 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v22 + 32))(v22, 72, 8);
        *(_DWORD *)v25 = 1;
        *(_QWORD *)(v25 + 8) = "position";
        *(_QWORD *)(v25 + 16) = v24;
        *(_QWORD *)(v25 + 24) = 0;
        *(_QWORD *)(v25 + 32) = 0x1800000003;
        *(_DWORD *)(v25 + 40) = 0;
        *(_QWORD *)(v25 + 48) = 0;
        *(_QWORD *)(v25 + 56) = 0;
        *(_DWORD *)(v25 + 64) = 0;
        qword_2540F9F98 = v25;
        __cxa_guard_release(&qword_2540F9F58);
      }
    }
    qword_2540FA168 = 0x4000000008;
    v1 = &qword_2540FA158;
    dword_2540FA170 = 8;
    word_2540FA174 = 0;
    dword_2540FA190 = 3;
    qword_2540FA198 = (uint64_t)&qword_2540F9F88;
    qword_2540FA1A0 = (uint64_t)re::internal::defaultConstruct<re::BlendSpaceSampleDefinition>;
    qword_2540FA1A8 = (uint64_t)re::internal::defaultDestruct<re::BlendSpaceSampleDefinition>;
    qword_2540FA1B8 = 0;
    qword_2540FA1B0 = 0;
    qword_2540FA1C0 = (uint64_t)re::internal::defaultConstructV2<re::BlendSpaceSampleDefinition>;
    qword_2540FA1C8 = (uint64_t)re::internal::defaultDestructV2<re::BlendSpaceSampleDefinition>;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_2540FA158, v3);
    v31 = v29;
    if ((byte_2540F9F22 & 1) == 0)
    {
LABEL_7:
      byte_2540F9F22 = 1;
      v5 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FA058, 0);
      qword_2540FA068 = 0x2800000003;
      dword_2540FA070 = v5;
      word_2540FA074 = 0;
      *(_QWORD *)&xmmword_2540FA078 = 0;
      *((_QWORD *)&xmmword_2540FA078 + 1) = 0xFFFFFFFFLL;
      qword_2540FA088 = (uint64_t)v1;
      unk_2540FA090 = 0;
      qword_2540FA058 = (uint64_t)&off_24ED238C0;
      re::IntrospectionRegistry::add(v6, v7);
      re::getPrettyTypeName((re *)&qword_2540FA058, (const re::IntrospectionBase *)&v29);
      if ((BYTE8(v29) & 1) != 0)
        v8 = v30;
      else
        v8 = (char *)&v29 + 9;
      if ((_QWORD)v29 && (BYTE8(v29) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v29 + 40))();
      v27 = *((_OWORD *)v1 + 2);
      v9 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v28);
      if (v9)
      {
        v10 = *v9;
        *((_QWORD *)&v26 + 1) = v10;
      }
      else
      {
        v31 = v27;
        re::TypeBuilder::beginListType((uint64_t)&v29, v28, 1, 0x28uLL, 8uLL, &v31);
        re::TypeBuilder::setConstructor((uint64_t)&v29, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceSampleDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v29, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceSampleDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v29, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v29, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceSampleDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceSampleDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v29, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceSampleDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v29, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceSampleDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceSampleDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceSampleDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v29, v11);
      }
      xmmword_2540FA078 = v26;
      re::StringID::destroyString((re::StringID *)v28);
    }
  }
}

double re::internal::defaultConstruct<re::BlendSpaceDefinition>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double result;

  *(_DWORD *)a3 = 0;
  *(_QWORD *)(a3 + 16) = 0;
  *(_QWORD *)(a3 + 24) = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_DWORD *)(a3 + 32) = 0;
  *(_QWORD *)(a3 + 80) = 0;
  result = 0.0;
  *(_OWORD *)(a3 + 40) = 0u;
  *(_OWORD *)(a3 + 56) = 0u;
  *(_DWORD *)(a3 + 72) = 0;
  return result;
}

uint64_t re::internal::defaultDestruct<re::BlendSpaceDefinition>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  re::DynamicArray<re::BlendSpaceSampleDefinition>::deinit(a3 + 48);
  return re::DynamicArray<re::BlendSpaceAxisDefinition>::deinit(a3 + 8);
}

double re::internal::defaultConstructV2<re::BlendSpaceDefinition>(uint64_t a1)
{
  double result;

  *(_DWORD *)a1 = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_DWORD *)(a1 + 72) = 0;
  return result;
}

uint64_t re::internal::defaultDestructV2<re::BlendSpaceDefinition>(uint64_t a1)
{
  re::DynamicArray<re::BlendSpaceSampleDefinition>::deinit(a1 + 48);
  return re::DynamicArray<re::BlendSpaceAxisDefinition>::deinit(a1 + 8);
}

uint64_t re::introspect_BlendSpaceDefinition(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"BlendSpaceDefinition", (uint64_t (*)(re::internal *))re::allocInfo_BlendSpaceDefinition, (re::IntrospectionBase *(*)(void))re::initInfo_BlendSpaceDefinition, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::BlendSpaceDefinition>, this);
}

_QWORD *re::IntrospectionDynamicArray<re::BlendSpaceAxisDefinition>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::BlendSpaceAxisDefinition>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x2276933B8);
}

void re::IntrospectionDynamicArray<re::BlendSpaceAxisDefinition>::construct(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::BlendSpaceAxisDefinition>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<re::BlendSpaceAxisDefinition>::deinit(a2);
}

_QWORD *re::IntrospectionDynamicArray<re::BlendSpaceAxisDefinition>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  re::DynamicArray<re::BlendSpaceAxisDefinition>::deinit(a2);
  *(_QWORD *)a2 = a3;
  result = re::DynamicArray<re::BlendSpaceAxisDefinition>::setCapacity((_QWORD *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

void re::IntrospectionDynamicArray<re::BlendSpaceAxisDefinition>::resize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  unint64_t v10;
  unint64_t i;

  if (!*(_QWORD *)a4)
  {
    *(_QWORD *)a4 = a2;
    re::DynamicArray<re::BlendSpaceAxisDefinition>::setCapacity((_QWORD *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  v10 = *(_QWORD *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
      re::DynamicArray<re::BlendSpaceAxisDefinition>::resize(a4, a5);
  }
  else
  {
    re::DynamicArray<re::BlendSpaceAxisDefinition>::setCapacity((_QWORD *)a4, a5);
    for (i = a5 - *(_QWORD *)(a4 + 16); i; --i)
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, a3, a4);
  }
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::BlendSpaceAxisDefinition>::addElement(uint64_t a1, re *a2, int a3, _anonymous_namespace_ *this)
{
  re::IntrospectionBase *v8;
  __n128 v10;
  _QWORD v11[4];

  v10.n128_u64[0] = 0;
  v10.n128_u64[1] = (unint64_t)&str_110;
  v11[0] = 0;
  v11[1] = &str_110;
  v11[2] = 0;
  v11[3] = 0;
  re::DynamicArray<re::BlendSpaceAxisDefinition>::add(this, &v10);
  re::StringID::destroyString((re::StringID *)v11);
  re::StringID::destroyString((re::StringID *)&v10);
  v8 = (re::IntrospectionBase *)(*((_QWORD *)this + 4) + 48 * *((_QWORD *)this + 2) - 48);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v8);
  return v8;
}

uint64_t re::IntrospectionDynamicArray<re::BlendSpaceAxisDefinition>::size(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::BlendSpaceAxisDefinition>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 48 * a3;
}

{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 48 * a3;
}

_QWORD *re::DynamicArray<re::BlendSpaceAxisDefinition>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  unint64_t *v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t *v10;
  unint64_t *v11;
  uint64_t v12;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::BlendSpaceAxisDefinition>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x30uLL))
        {
          v2 = 48 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 48 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_16;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 48, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = (uint64_t *)v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = &v8[6 * v9];
        v11 = v7;
        do
        {
          v12 = *v8;
          *v11 = *v11 & 0xFFFFFFFFFFFFFFFELL | *v8 & 1;
          *v11 = *v8 & 0xFFFFFFFFFFFFFFFELL | v12 & 1;
          v11[1] = v8[1];
          *v8 = 0;
          v8[1] = (uint64_t)&str_110;
          LOBYTE(v12) = v8[2];
          v11[2] = v11[2] & 0xFFFFFFFFFFFFFFFELL | v8[2] & 1;
          v11[2] = v8[2] & 0xFFFFFFFFFFFFFFFELL | v12 & 1;
          v11[3] = v8[3];
          v8[3] = (uint64_t)&str_110;
          v8[2] = 0;
          *((_OWORD *)v11 + 2) = *((_OWORD *)v8 + 2);
          re::StringID::destroyString((re::StringID *)(v8 + 2));
          re::StringID::destroyString((re::StringID *)v8);
          v8 += 6;
          v11 += 6;
        }
        while (v8 != v10);
        v8 = (uint64_t *)v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t *))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

void re::DynamicArray<re::BlendSpaceAxisDefinition>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;

  v4 = *(_QWORD *)(a1 + 16);
  if (v4 >= a2)
  {
    if (v4 <= a2)
      return;
    v8 = 48 * a2;
    v9 = a2;
    do
    {
      v10 = *(_QWORD *)(a1 + 32) + v8;
      re::StringID::destroyString((re::StringID *)(v10 + 16));
      re::StringID::destroyString((re::StringID *)v10);
      ++v9;
      v8 += 48;
    }
    while (v9 < *(_QWORD *)(a1 + 16));
  }
  else
  {
    if (*(_QWORD *)(a1 + 8) < a2)
    {
      re::DynamicArray<re::BlendSpaceAxisDefinition>::setCapacity((_QWORD *)a1, a2);
      v4 = *(_QWORD *)(a1 + 16);
    }
    v5 = a2 - v4;
    if (a2 > v4)
    {
      v6 = 48 * v4;
      do
      {
        v7 = (_QWORD *)(*(_QWORD *)(a1 + 32) + v6);
        *v7 = 0;
        v7[1] = &str_110;
        v7[2] = 0;
        v7[3] = &str_110;
        v7[4] = 0;
        v7[5] = 0;
        v6 += 48;
        --v5;
      }
      while (v5);
    }
  }
  *(_QWORD *)(a1 + 16) = a2;
  ++*(_DWORD *)(a1 + 24);
}

__n128 re::DynamicArray<re::BlendSpaceAxisDefinition>::add(_anonymous_namespace_ *this, __n128 *a2)
{
  unint64_t v4;
  __n128 *v5;
  unint64_t v6;
  unint64_t v7;
  __n128 result;

  v4 = *((_QWORD *)this + 2);
  if (v4 >= *((_QWORD *)this + 1))
  {
    re::DynamicArray<re::BlendSpaceAxisDefinition>::growCapacity(this, v4 + 1);
    v4 = *((_QWORD *)this + 2);
  }
  v5 = (__n128 *)(*((_QWORD *)this + 4) + 48 * v4);
  v6 = a2->n128_u64[0];
  v5->n128_u64[0] = v5->n128_u64[0] & 0xFFFFFFFFFFFFFFFELL | a2->n128_u64[0] & 1;
  v5->n128_u64[0] = a2->n128_u64[0] & 0xFFFFFFFFFFFFFFFELL | v6 & 1;
  v5->n128_u64[1] = a2->n128_u64[1];
  a2->n128_u64[0] = 0;
  a2->n128_u64[1] = (unint64_t)&str_110;
  v7 = a2[1].n128_u64[0];
  v5[1].n128_u64[0] = v5[1].n128_u64[0] & 0xFFFFFFFFFFFFFFFELL | v7 & 1;
  v5[1].n128_u64[0] = a2[1].n128_u64[0] & 0xFFFFFFFFFFFFFFFELL | v7 & 1;
  v5[1].n128_u64[1] = a2[1].n128_u64[1];
  a2[1].n128_u64[0] = 0;
  a2[1].n128_u64[1] = (unint64_t)&str_110;
  result = a2[2];
  v5[2] = result;
  ++*((_QWORD *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

_QWORD *re::DynamicArray<re::BlendSpaceAxisDefinition>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<re::BlendSpaceAxisDefinition>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::BlendSpaceAxisDefinition>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

_QWORD *re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceAxisDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)a1 = a3;
  result = re::DynamicArray<re::BlendSpaceAxisDefinition>::setCapacity((_QWORD *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceAxisDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceAxisDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  _anonymous_namespace_ *v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  _BYTE v12[32];
  _BYTE v13[8];
  uint64_t v14;

  if (*(re::Allocator **)a1 == a3)
  {
    re::DynamicArray<re::BlendSpaceAxisDefinition>::clear(a1);
  }
  else
  {
    re::DynamicArray<re::BlendSpaceAxisDefinition>::deinit(a1);
    *(_QWORD *)a1 = a3;
    re::DynamicArray<re::BlendSpaceAxisDefinition>::setCapacity((_QWORD *)a1, a4);
    ++*(_DWORD *)(a1 + 24);
  }
  re::DynamicArray<re::BlendSpaceAxisDefinition>::resize(a1, a4);
  {
    re::TypeRegistry::typeInfo(*(_QWORD **)a2, *(_QWORD *)(*(_QWORD *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    v9 = *(_QWORD *)(a1 + 16);
    if (v9)
    {
      v10 = *(char **)(a1 + 32);
      v11 = 48 * v9;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 48;
        v11 -= 48;
      }
      while (v11);
    }
  }
}

void re::DynamicArray<re::BlendSpaceAxisDefinition>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
  {
    v3 = *(_QWORD *)(a1 + 32);
    v4 = 48 * v2;
    do
    {
      re::StringID::destroyString((re::StringID *)(v3 + 16));
      re::StringID::destroyString((re::StringID *)v3);
      v3 += 48;
      v4 -= 48;
    }
    while (v4);
  }
  ++*(_DWORD *)(a1 + 24);
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceAxisDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(_QWORD *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a1 + 32) + 48 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceAxisDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 16, 8);
  *(_QWORD *)result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceAxisDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unint64_t v4;
  uint64_t result;

  v2 = *(_QWORD *)a1;
  if (a1[2] == *(_DWORD *)(*(_QWORD *)a1 + 24))
  {
    v3 = a1[3];
    v4 = *(_QWORD *)(v2 + 16);
    if (v3 < (int)v4)
      a1[3] = ++v3;
    if (v4 <= v3)
      return 0;
    else
      return *(_QWORD *)(v2 + 32) + 48 * v3;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceAxisDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 40))(a2, result);
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::BlendSpaceSampleDefinition>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::BlendSpaceSampleDefinition>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x2276933B8);
}

void re::IntrospectionDynamicArray<re::BlendSpaceSampleDefinition>::construct(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::BlendSpaceSampleDefinition>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<re::BlendSpaceSampleDefinition>::deinit(a2);
}

_QWORD *re::IntrospectionDynamicArray<re::BlendSpaceSampleDefinition>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  re::DynamicArray<re::BlendSpaceSampleDefinition>::deinit(a2);
  *(_QWORD *)a2 = a3;
  result = re::DynamicArray<re::BlendSpaceSampleDefinition>::setCapacity((_QWORD *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

void re::IntrospectionDynamicArray<re::BlendSpaceSampleDefinition>::resize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  unint64_t v10;
  unint64_t i;

  if (!*(_QWORD *)a4)
  {
    *(_QWORD *)a4 = a2;
    re::DynamicArray<re::BlendSpaceSampleDefinition>::setCapacity((_QWORD *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  v10 = *(_QWORD *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
      re::DynamicArray<re::BlendSpaceSampleDefinition>::resize(a4, a5);
  }
  else
  {
    re::DynamicArray<re::BlendSpaceSampleDefinition>::setCapacity((_QWORD *)a4, a5);
    for (i = a5 - *(_QWORD *)(a4 + 16); i; --i)
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, a3, a4);
  }
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::BlendSpaceSampleDefinition>::addElement(uint64_t a1, re *a2, int a3, _anonymous_namespace_ *this)
{
  float v8;
  re::IntrospectionBase *v9;
  _QWORD v11[2];
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;

  v11[0] = 0;
  v12 = 0u;
  v14 = 0;
  v15 = 0;
  v11[1] = &str_110;
  v13 = 0uLL;
  v8 = re::DynamicArray<re::BlendSpaceSampleDefinition>::add(this, (float *)v11);
  if (*((_QWORD *)&v12 + 1))
  {
    if (v15)
      (*(void (**)(float))(**((_QWORD **)&v12 + 1) + 40))(v8);
    v15 = 0;
    v13 = 0uLL;
    *((_QWORD *)&v12 + 1) = 0;
    LODWORD(v14) = v14 + 1;
  }
  re::StringID::destroyString((re::StringID *)v11);
  v9 = (re::IntrospectionBase *)(*((_QWORD *)this + 4) + (*((_QWORD *)this + 2) << 6) - 64);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v9);
  return v9;
}

uint64_t re::IntrospectionDynamicArray<re::BlendSpaceSampleDefinition>::size(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::BlendSpaceSampleDefinition>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + (a3 << 6);
}

{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + (a3 << 6);
}

_QWORD *re::DynamicArray<re::BlendSpaceSampleDefinition>::setCapacity(_QWORD *result, unint64_t a2)
{
  unint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  unint64_t *v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t *v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::BlendSpaceSampleDefinition>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (a2 >> 58)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 64, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          v2 = a2 << 6;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, a2 << 6, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_20;
            goto LABEL_11;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_20:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = (uint64_t *)v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = v9 << 6;
        v11 = v7;
        do
        {
          v12 = *v8;
          *v11 = *v11 & 0xFFFFFFFFFFFFFFFELL | *v8 & 1;
          *v11 = *v8 & 0xFFFFFFFFFFFFFFFELL | v12 & 1;
          v11[1] = v8[1];
          *v8 = 0;
          v8[1] = (uint64_t)&str_110;
          v13 = *((_DWORD *)v8 + 4);
          v11[7] = 0;
          v11[4] = 0;
          v11[5] = 0;
          v11[3] = 0;
          *((_DWORD *)v11 + 12) = 0;
          v11[3] = v8[3];
          v8[3] = 0;
          v14 = v11[7];
          v11[7] = v8[7];
          v15 = v8[3];
          v11[4] = v8[4];
          v8[4] = 0;
          v16 = v11[5];
          v11[5] = v8[5];
          v8[5] = v16;
          ++*((_DWORD *)v8 + 12);
          ++*((_DWORD *)v11 + 12);
          *((_DWORD *)v11 + 4) = v13;
          v8[7] = v14;
          if (v15)
          {
            if (v14)
              (*(void (**)(uint64_t))(*(_QWORD *)v15 + 40))(v15);
            v8[7] = 0;
            v8[4] = 0;
            v8[5] = 0;
            v8[3] = 0;
            ++*((_DWORD *)v8 + 12);
          }
          re::StringID::destroyString((re::StringID *)v8);
          v8 += 8;
          v11 += 8;
          v10 -= 64;
        }
        while (v10);
        v8 = (uint64_t *)v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t *))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_20;
    }
  }
  return result;
}

void re::DynamicArray<re::BlendSpaceSampleDefinition>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v4 = *(_QWORD *)(a1 + 16);
  if (v4 >= a2)
  {
    if (v4 <= a2)
      return;
    v8 = a2 << 6;
    v9 = a2;
    do
    {
      v10 = *(_QWORD *)(a1 + 32);
      v11 = v10 + v8;
      v12 = *(_QWORD *)(v10 + v8 + 24);
      if (v12)
      {
        if (*(_QWORD *)(v11 + 56))
          (*(void (**)(uint64_t))(*(_QWORD *)v12 + 40))(v12);
        *(_QWORD *)(v11 + 56) = 0;
        *(_QWORD *)(v10 + v8 + 32) = 0;
        *(_QWORD *)(v10 + v8 + 40) = 0;
        *(_QWORD *)(v10 + v8 + 24) = 0;
        ++*(_DWORD *)(v10 + v8 + 48);
      }
      re::StringID::destroyString((re::StringID *)(v10 + v8));
      ++v9;
      v8 += 64;
    }
    while (v9 < *(_QWORD *)(a1 + 16));
  }
  else
  {
    if (*(_QWORD *)(a1 + 8) < a2)
    {
      re::DynamicArray<re::BlendSpaceSampleDefinition>::setCapacity((_QWORD *)a1, a2);
      v4 = *(_QWORD *)(a1 + 16);
    }
    v5 = a2 - v4;
    if (a2 > v4)
    {
      v6 = v4 << 6;
      do
      {
        v7 = *(_QWORD *)(a1 + 32) + v6;
        *(_QWORD *)v7 = 0;
        *(_QWORD *)(v7 + 8) = &str_110;
        *(_DWORD *)(v7 + 16) = 0;
        *(_QWORD *)(v7 + 56) = 0;
        *(_QWORD *)(v7 + 32) = 0;
        *(_QWORD *)(v7 + 40) = 0;
        *(_QWORD *)(v7 + 24) = 0;
        *(_DWORD *)(v7 + 48) = 0;
        v6 += 64;
        --v5;
      }
      while (v5);
    }
  }
  *(_QWORD *)(a1 + 16) = a2;
  ++*(_DWORD *)(a1 + 24);
}

float re::DynamicArray<re::BlendSpaceSampleDefinition>::add(_anonymous_namespace_ *this, float *a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  float result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v4 = *((_QWORD *)this + 2);
  if (v4 >= *((_QWORD *)this + 1))
  {
    re::DynamicArray<re::BlendSpaceSampleDefinition>::growCapacity(this, v4 + 1);
    v4 = *((_QWORD *)this + 2);
  }
  v5 = *((_QWORD *)this + 4) + (v4 << 6);
  v6 = *(_QWORD *)a2;
  *(_QWORD *)v5 = *(_QWORD *)v5 & 0xFFFFFFFFFFFFFFFELL | *(_QWORD *)a2 & 1;
  *(_QWORD *)v5 = *(_QWORD *)a2 & 0xFFFFFFFFFFFFFFFELL | v6 & 1;
  *(_QWORD *)(v5 + 8) = *((_QWORD *)a2 + 1);
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = &str_110;
  result = a2[4];
  *(float *)(v5 + 16) = result;
  *(_QWORD *)(v5 + 56) = 0;
  *(_DWORD *)(v5 + 48) = 0;
  *(_QWORD *)(v5 + 32) = 0;
  *(_QWORD *)(v5 + 40) = 0;
  *(_QWORD *)(v5 + 24) = 0;
  v8 = *((_QWORD *)a2 + 4);
  *(_QWORD *)(v5 + 24) = *((_QWORD *)a2 + 3);
  *(_QWORD *)(v5 + 32) = v8;
  *((_QWORD *)a2 + 3) = 0;
  *((_QWORD *)a2 + 4) = 0;
  v9 = *(_QWORD *)(v5 + 40);
  *(_QWORD *)(v5 + 40) = *((_QWORD *)a2 + 5);
  *((_QWORD *)a2 + 5) = v9;
  v10 = *(_QWORD *)(v5 + 56);
  *(_QWORD *)(v5 + 56) = *((_QWORD *)a2 + 7);
  *((_QWORD *)a2 + 7) = v10;
  ++*((_DWORD *)a2 + 12);
  ++*(_DWORD *)(v5 + 48);
  ++*((_QWORD *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

_QWORD *re::DynamicArray<re::BlendSpaceSampleDefinition>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<re::BlendSpaceSampleDefinition>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::BlendSpaceSampleDefinition>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

_QWORD *re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceSampleDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)a1 = a3;
  result = re::DynamicArray<re::BlendSpaceSampleDefinition>::setCapacity((_QWORD *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceSampleDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceSampleDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  _anonymous_namespace_ *v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  _BYTE v12[32];
  _BYTE v13[8];
  uint64_t v14;

  if (*(re::Allocator **)a1 == a3)
  {
    re::DynamicArray<re::BlendSpaceSampleDefinition>::clear(a1);
  }
  else
  {
    re::DynamicArray<re::BlendSpaceSampleDefinition>::deinit(a1);
    *(_QWORD *)a1 = a3;
    re::DynamicArray<re::BlendSpaceSampleDefinition>::setCapacity((_QWORD *)a1, a4);
    ++*(_DWORD *)(a1 + 24);
  }
  re::DynamicArray<re::BlendSpaceSampleDefinition>::resize(a1, a4);
  {
    re::TypeRegistry::typeInfo(*(_QWORD **)a2, *(_QWORD *)(*(_QWORD *)(a2 + 16) + 72), v13);
    re::TypeInfo::TypeInfo((uint64_t)v12, (uint64_t)&v14);
    v9 = *(_QWORD *)(a1 + 16);
    if (v9)
    {
      v10 = *(char **)(a1 + 32);
      v11 = v9 << 6;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v12, v10, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v12, (void **)v10, a3, 0);
        v10 += 64;
        v11 -= 64;
      }
      while (v11);
    }
  }
}

void re::DynamicArray<re::BlendSpaceSampleDefinition>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
  {
    v3 = *(_QWORD *)(a1 + 32);
    v4 = v2 << 6;
    do
    {
      v5 = *(_QWORD *)(v3 + 24);
      if (v5)
      {
        if (*(_QWORD *)(v3 + 56))
          (*(void (**)(uint64_t))(*(_QWORD *)v5 + 40))(v5);
        *(_QWORD *)(v3 + 56) = 0;
        *(_QWORD *)(v3 + 32) = 0;
        *(_QWORD *)(v3 + 40) = 0;
        *(_QWORD *)(v3 + 24) = 0;
        ++*(_DWORD *)(v3 + 48);
      }
      re::StringID::destroyString((re::StringID *)v3);
      v3 += 64;
      v4 -= 64;
    }
    while (v4);
  }
  ++*(_DWORD *)(a1 + 24);
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceSampleDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(_QWORD *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a1 + 32) + (a2 << 6);
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceSampleDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 16, 8);
  *(_QWORD *)result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceSampleDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unint64_t v4;
  uint64_t result;

  v2 = *(_QWORD *)a1;
  if (a1[2] == *(_DWORD *)(*(_QWORD *)a1 + 24))
  {
    v3 = a1[3];
    v4 = *(_QWORD *)(v2 + 16);
    if (v3 < (int)v4)
      a1[3] = ++v3;
    if (v4 <= v3)
      return 0;
    else
      return *(_QWORD *)(v2 + 32) + ((uint64_t)v3 << 6);
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BlendSpaceSampleDefinition>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 40))(a2, result);
  return result;
}

void re::StateParameterBlackboard::deinit(re::StateParameterBlackboard *this)
{
  uint64_t v2;
  uint64_t v3;
  int *v4;
  int v5;
  uint64_t v6;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  int *v17;
  int v18;
  uint64_t v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  int v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  int *v30;
  int v31;
  uint64_t v32;
  int v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  int v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  int *v43;
  int v44;
  uint64_t v45;
  int v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  uint64_t v51;
  int v52;
  int v53;

  v2 = *((unsigned int *)this + 10);
  if ((_DWORD)v2)
  {
    v3 = 0;
    v4 = (int *)*((_QWORD *)this + 3);
    while (1)
    {
      v5 = *v4;
      v4 += 8;
      if (v5 < 0)
        break;
      if (v2 == ++v3)
      {
        LODWORD(v3) = *((_DWORD *)this + 10);
        break;
      }
    }
  }
  else
  {
    LODWORD(v3) = 0;
  }
  if ((_DWORD)v2 != (_DWORD)v3)
  {
    v6 = v3;
    do
    {
      re::internal::destroyPersistent<re::StateParameterInt>((re *)"deinit", 8, *(_QWORD **)(*((_QWORD *)this + 3) + 32 * v6 + 24));
      LODWORD(v2) = *((_DWORD *)this + 10);
      if (v2 <= (int)v3 + 1)
        v7 = v3 + 1;
      else
        v7 = *((_DWORD *)this + 10);
      v8 = v3;
      while (1)
      {
        v6 = (v8 + 1);
        if (v7 - 1 == v8)
          break;
        ++v8;
        LODWORD(v3) = v6;
        if ((*(_DWORD *)(*((_QWORD *)this + 3) + 32 * v6) & 0x80000000) != 0)
          goto LABEL_17;
      }
      LODWORD(v3) = v7;
LABEL_17:
      ;
    }
    while ((_DWORD)v2 != (_DWORD)v3);
  }
  if (*((_DWORD *)this + 9))
  {
    v9 = *((unsigned int *)this + 8);
    if ((_DWORD)v9)
    {
      memset_pattern16(*((void **)this + 2), &unk_2260EB7B0, 4 * v9);
      LODWORD(v2) = *((_DWORD *)this + 10);
    }
    if ((_DWORD)v2)
    {
      v10 = 0;
      v11 = 0;
      do
      {
        v12 = *((_QWORD *)this + 3);
        v13 = *(_DWORD *)(v12 + v10);
        if (v13 < 0)
        {
          *(_DWORD *)(v12 + v10) = v13 & 0x7FFFFFFF;
          re::StringID::destroyString((re::StringID *)(v12 + v10 + 8));
          LODWORD(v2) = *((_DWORD *)this + 10);
        }
        ++v11;
        v10 += 32;
      }
      while (v11 < v2);
    }
    *((_DWORD *)this + 9) = 0;
    *((_DWORD *)this + 10) = 0;
    v14 = *((_DWORD *)this + 12) + 1;
    *((_DWORD *)this + 11) = 0x7FFFFFFF;
    *((_DWORD *)this + 12) = v14;
  }
  v15 = *((unsigned int *)this + 22);
  if ((_DWORD)v15)
  {
    v16 = 0;
    v17 = (int *)*((_QWORD *)this + 9);
    while (1)
    {
      v18 = *v17;
      v17 += 8;
      if (v18 < 0)
        break;
      if (v15 == ++v16)
      {
        LODWORD(v16) = *((_DWORD *)this + 22);
        break;
      }
    }
  }
  else
  {
    LODWORD(v16) = 0;
  }
  if ((_DWORD)v15 != (_DWORD)v16)
  {
    v19 = v16;
    do
    {
      re::internal::destroyPersistent<re::StateParameterInt>((re *)"deinit", 13, *(_QWORD **)(*((_QWORD *)this + 9) + 32 * v19 + 24));
      LODWORD(v15) = *((_DWORD *)this + 22);
      if (v15 <= (int)v16 + 1)
        v20 = v16 + 1;
      else
        v20 = *((_DWORD *)this + 22);
      v21 = v16;
      while (1)
      {
        v19 = (v21 + 1);
        if (v20 - 1 == v21)
          break;
        ++v21;
        LODWORD(v16) = v19;
        if ((*(_DWORD *)(*((_QWORD *)this + 9) + 32 * v19) & 0x80000000) != 0)
          goto LABEL_43;
      }
      LODWORD(v16) = v20;
LABEL_43:
      ;
    }
    while ((_DWORD)v15 != (_DWORD)v16);
  }
  if (*((_DWORD *)this + 21))
  {
    v22 = *((unsigned int *)this + 20);
    if ((_DWORD)v22)
    {
      memset_pattern16(*((void **)this + 8), &unk_2260EB7B0, 4 * v22);
      LODWORD(v15) = *((_DWORD *)this + 22);
    }
    if ((_DWORD)v15)
    {
      v23 = 0;
      v24 = 0;
      do
      {
        v25 = *((_QWORD *)this + 9);
        v26 = *(_DWORD *)(v25 + v23);
        if (v26 < 0)
        {
          *(_DWORD *)(v25 + v23) = v26 & 0x7FFFFFFF;
          re::StringID::destroyString((re::StringID *)(v25 + v23 + 8));
          LODWORD(v15) = *((_DWORD *)this + 22);
        }
        ++v24;
        v23 += 32;
      }
      while (v24 < v15);
    }
    *((_DWORD *)this + 21) = 0;
    *((_DWORD *)this + 22) = 0;
    v27 = *((_DWORD *)this + 24) + 1;
    *((_DWORD *)this + 23) = 0x7FFFFFFF;
    *((_DWORD *)this + 24) = v27;
  }
  v28 = *((unsigned int *)this + 34);
  if ((_DWORD)v28)
  {
    v29 = 0;
    v30 = (int *)*((_QWORD *)this + 15);
    while (1)
    {
      v31 = *v30;
      v30 += 8;
      if (v31 < 0)
        break;
      if (v28 == ++v29)
      {
        LODWORD(v29) = *((_DWORD *)this + 34);
        break;
      }
    }
  }
  else
  {
    LODWORD(v29) = 0;
  }
  if ((_DWORD)v28 != (_DWORD)v29)
  {
    v32 = v29;
    do
    {
      re::internal::destroyPersistent<re::StateParameterInt>((re *)"deinit", 18, *(_QWORD **)(*((_QWORD *)this + 15) + 32 * v32 + 24));
      LODWORD(v28) = *((_DWORD *)this + 34);
      if (v28 <= (int)v29 + 1)
        v33 = v29 + 1;
      else
        v33 = *((_DWORD *)this + 34);
      v34 = v29;
      while (1)
      {
        v32 = (v34 + 1);
        if (v33 - 1 == v34)
          break;
        ++v34;
        LODWORD(v29) = v32;
        if ((*(_DWORD *)(*((_QWORD *)this + 15) + 32 * v32) & 0x80000000) != 0)
          goto LABEL_69;
      }
      LODWORD(v29) = v33;
LABEL_69:
      ;
    }
    while ((_DWORD)v28 != (_DWORD)v29);
  }
  if (*((_DWORD *)this + 33))
  {
    v35 = *((unsigned int *)this + 32);
    if ((_DWORD)v35)
    {
      memset_pattern16(*((void **)this + 14), &unk_2260EB7B0, 4 * v35);
      LODWORD(v28) = *((_DWORD *)this + 34);
    }
    if ((_DWORD)v28)
    {
      v36 = 0;
      v37 = 0;
      do
      {
        v38 = *((_QWORD *)this + 15);
        v39 = *(_DWORD *)(v38 + v36);
        if (v39 < 0)
        {
          *(_DWORD *)(v38 + v36) = v39 & 0x7FFFFFFF;
          re::StringID::destroyString((re::StringID *)(v38 + v36 + 8));
          LODWORD(v28) = *((_DWORD *)this + 34);
        }
        ++v37;
        v36 += 32;
      }
      while (v37 < v28);
    }
    *((_DWORD *)this + 33) = 0;
    *((_DWORD *)this + 34) = 0;
    v40 = *((_DWORD *)this + 36) + 1;
    *((_DWORD *)this + 35) = 0x7FFFFFFF;
    *((_DWORD *)this + 36) = v40;
  }
  v41 = *((unsigned int *)this + 46);
  if ((_DWORD)v41)
  {
    v42 = 0;
    v43 = (int *)*((_QWORD *)this + 21);
    while (1)
    {
      v44 = *v43;
      v43 += 8;
      if (v44 < 0)
        break;
      if (v41 == ++v42)
      {
        LODWORD(v42) = *((_DWORD *)this + 46);
        break;
      }
    }
  }
  else
  {
    LODWORD(v42) = 0;
  }
  if ((_DWORD)v41 != (_DWORD)v42)
  {
    v45 = v42;
    do
    {
      re::internal::destroyPersistent<re::StateParameterInt>((re *)"deinit", 23, *(_QWORD **)(*((_QWORD *)this + 21) + 32 * v45 + 24));
      LODWORD(v41) = *((_DWORD *)this + 46);
      if (v41 <= (int)v42 + 1)
        v46 = v42 + 1;
      else
        v46 = *((_DWORD *)this + 46);
      v47 = v42;
      while (1)
      {
        v45 = (v47 + 1);
        if (v46 - 1 == v47)
          break;
        ++v47;
        LODWORD(v42) = v45;
        if ((*(_DWORD *)(*((_QWORD *)this + 21) + 32 * v45) & 0x80000000) != 0)
          goto LABEL_95;
      }
      LODWORD(v42) = v46;
LABEL_95:
      ;
    }
    while ((_DWORD)v41 != (_DWORD)v42);
  }
  if (*((_DWORD *)this + 45))
  {
    v48 = *((unsigned int *)this + 44);
    if ((_DWORD)v48)
    {
      memset_pattern16(*((void **)this + 20), &unk_2260EB7B0, 4 * v48);
      LODWORD(v41) = *((_DWORD *)this + 46);
    }
    if ((_DWORD)v41)
    {
      v49 = 0;
      v50 = 0;
      do
      {
        v51 = *((_QWORD *)this + 21);
        v52 = *(_DWORD *)(v51 + v49);
        if (v52 < 0)
        {
          *(_DWORD *)(v51 + v49) = v52 & 0x7FFFFFFF;
          re::StringID::destroyString((re::StringID *)(v51 + v49 + 8));
          LODWORD(v41) = *((_DWORD *)this + 46);
        }
        ++v50;
        v49 += 32;
      }
      while (v50 < v41);
    }
    *((_DWORD *)this + 45) = 0;
    *((_DWORD *)this + 46) = 0;
    v53 = *((_DWORD *)this + 48) + 1;
    *((_DWORD *)this + 47) = 0x7FFFFFFF;
    *((_DWORD *)this + 48) = v53;
  }
}

re *re::internal::destroyPersistent<re::StateParameterInt>(re *result, uint64_t a2, _QWORD *a3)
{
  uint64_t v4;

  if (a3)
  {
    v4 = re::globalAllocators(result)[2];
    *a3 = off_24ED23958;
    re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)(a3 + 2));
    re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)(a3 + 2));
    return (re *)(*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v4 + 40))(v4, a3);
  }
  return result;
}

BOOL re::StateParameterBlackboard::removeStateParameterInt(re::StateParameterBlackboard *this, const re::StringID *a2)
{
  char *v3;
  _QWORD **v4;
  _QWORD **v5;

  v3 = (char *)this + 8;
  v4 = (_QWORD **)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)this + 8, a2);
  v5 = v4;
  if (v4)
  {
    re::internal::destroyPersistent<re::StateParameterInt>((re *)"removeStateParameterInt", 33, *v4);
    re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::remove((uint64_t)v3, a2);
  }
  return v5 != 0;
}

uint64_t re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::remove(uint64_t a1, _QWORD *a2)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;
  unsigned int v10;
  int v11;
  uint64_t v12;
  int *v13;
  int v14;
  int v15;

  if (!*(_QWORD *)a1)
    return 0;
  v4 = 0xBF58476D1CE4E5B9 * ((*a2 >> 31) ^ (*a2 >> 1));
  v5 = ((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) ^ ((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) >> 31))
     % *(unsigned int *)(a1 + 24);
  v6 = *(_QWORD *)(a1 + 8);
  v7 = *(unsigned int *)(v6 + 4 * v5);
  if ((_DWORD)v7 == 0x7FFFFFFF)
    return 0;
  v9 = *(_QWORD *)(a1 + 16);
  if (!re::StringID::operator==((_QWORD *)(v9 + 32 * v7 + 8), a2))
  {
    while (1)
    {
      v10 = v7;
      v11 = *(_DWORD *)(v9 + 32 * v7);
      v7 = v11 & 0x7FFFFFFF;
      if ((v11 & 0x7FFFFFFF) == 0x7FFFFFFF)
        return 0;
      if (re::StringID::operator==((_QWORD *)(v9 + 32 * v7 + 8), a2))
      {
        *(_DWORD *)(v9 + 32 * v10) = *(_DWORD *)(v9 + 32 * v10) & 0x80000000 | *(_DWORD *)(v9 + 32 * v7) & 0x7FFFFFFF;
        goto LABEL_9;
      }
    }
  }
  *(_DWORD *)(v6 + 4 * v5) = *(_DWORD *)(v9 + 32 * v7) & 0x7FFFFFFF;
LABEL_9:
  v12 = *(_QWORD *)(a1 + 16);
  v13 = (int *)(v12 + 32 * v7);
  v14 = *v13;
  if (*v13 < 0)
  {
    *v13 = v14 & 0x7FFFFFFF;
    re::StringID::destroyString((re::StringID *)(v13 + 2));
    v12 = *(_QWORD *)(a1 + 16);
    v14 = *(_DWORD *)(v12 + 32 * v7);
  }
  v15 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(v12 + 32 * v7) = *(_DWORD *)(a1 + 36) | v14 & 0x80000000;
  --*(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 36) = v7;
  *(_DWORD *)(a1 + 40) = v15 + 1;
  return 1;
}

BOOL re::StateParameterBlackboard::removeStateParameterFloat(re::StateParameterBlackboard *this, const re::StringID *a2)
{
  char *v3;
  _QWORD **v4;
  _QWORD **v5;

  v3 = (char *)this + 56;
  v4 = (_QWORD **)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)this + 56, a2);
  v5 = v4;
  if (v4)
  {
    re::internal::destroyPersistent<re::StateParameterInt>((re *)"removeStateParameterFloat", 43, *v4);
    re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::remove((uint64_t)v3, a2);
  }
  return v5 != 0;
}

BOOL re::StateParameterBlackboard::removeStateParameterBool(re::StateParameterBlackboard *this, const re::StringID *a2)
{
  char *v3;
  _QWORD **v4;
  _QWORD **v5;

  v3 = (char *)this + 104;
  v4 = (_QWORD **)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)this + 104, a2);
  v5 = v4;
  if (v4)
  {
    re::internal::destroyPersistent<re::StateParameterInt>((re *)"removeStateParameterBool", 53, *v4);
    re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::remove((uint64_t)v3, a2);
  }
  return v5 != 0;
}

BOOL re::StateParameterBlackboard::removeStateParameterTrigger(re::StateParameterBlackboard *this, const re::StringID *a2)
{
  char *v3;
  _QWORD **v4;
  _QWORD **v5;

  v3 = (char *)this + 152;
  v4 = (_QWORD **)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)this + 152, a2);
  v5 = v4;
  if (v4)
  {
    re::internal::destroyPersistent<re::StateParameterInt>((re *)"removeStateParameterTrigger", 63, *v4);
    re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::remove((uint64_t)v3, a2);
  }
  return v5 != 0;
}

_BYTE *re::StateParameter::processParameterReset(_BYTE *this)
{
  _BYTE *v1;

  if (this[56])
  {
    v1 = this;
    this = (_BYTE *)(*(uint64_t (**)(_BYTE *))(*(_QWORD *)this + 8))(this);
    v1[56] = 0;
  }
  return this;
}

double re::AnimationManager::AnimationManager(re::AnimationManager *this)
{
  uint64_t v1;
  char *v2;
  uint64_t i;
  char *v4;
  uint64_t v5;
  char *v6;
  uint64_t j;
  char *v8;
  double result;

  *(_QWORD *)this = &off_24ED23988;
  *((_QWORD *)this + 1) = 0;
  *((_WORD *)this + 8) = 259;
  *((_DWORD *)this + 5) = 1023969417;
  *((_BYTE *)this + 24) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 4) = -1;
  *((_WORD *)this + 28) = 0;
  v1 = 72;
  do
  {
    v2 = (char *)this + v1;
    *(_QWORD *)v2 = 0;
    *((_QWORD *)v2 + 1) = 0;
    *((_DWORD *)v2 + 6) = 0;
    *((_QWORD *)v2 + 2) = 0;
    *((_QWORD *)v2 + 4) = 0;
    *((_QWORD *)v2 + 5) = 0;
    *((_DWORD *)v2 + 12) = 0;
    v1 += 64;
    *(_QWORD *)(v2 + 52) = 0x1FFFFFFFFLL;
  }
  while (v2 + 64 != (char *)this + 200);
  for (i = 0; i != 80; i += 40)
  {
    v4 = (char *)this + i;
    *((_QWORD *)v4 + 29) = 0;
    *((_QWORD *)v4 + 26) = 0;
    *((_QWORD *)v4 + 27) = 0;
    *((_QWORD *)v4 + 25) = 0;
    *((_DWORD *)v4 + 56) = 0;
  }
  v5 = 280;
  do
  {
    v6 = (char *)this + v5;
    *((_DWORD *)v6 + 8) = 0;
    *(_OWORD *)v6 = 0uLL;
    *((_OWORD *)v6 + 1) = 0uLL;
    *(_QWORD *)(v6 + 36) = 0x7FFFFFFFLL;
    v5 += 48;
  }
  while (v6 + 48 != (char *)this + 376);
  for (j = 0; j != 80; j += 40)
  {
    v8 = (char *)this + j;
    *((_QWORD *)v8 + 51) = 0;
    *((_QWORD *)v8 + 48) = 0;
    *((_QWORD *)v8 + 49) = 0;
    *((_QWORD *)v8 + 47) = 0;
    *((_DWORD *)v8 + 100) = 0;
  }
  *((_DWORD *)this + 122) = 0;
  result = 0.0;
  *(_OWORD *)((char *)this + 456) = 0u;
  *(_OWORD *)((char *)this + 472) = 0u;
  *(_QWORD *)((char *)this + 492) = 0x7FFFFFFFLL;
  *((_WORD *)this + 252) = 0;
  *((_BYTE *)this + 506) = 0;
  return result;
}

void re::AnimationManager::~AnimationManager(re::AnimationManager *this)
{
  __n128 v2;
  uint64_t i;
  _QWORD *v4;
  uint64_t v5;
  uint64_t j;
  __n128 v7;
  uint64_t k;
  char *v9;
  uint64_t v10;
  uint64_t m;

  re::AnimationManager::deinit((CFTypeRef *)this);
  v2.n128_f64[0] = re::HashSetBase<re::SharedPtr<re::AnimationEventDelegate>,re::SharedPtr<re::AnimationEventDelegate>,re::internal::ValueAsKey<re::SharedPtr<re::AnimationEventDelegate>>,re::Hash<re::SharedPtr<re::AnimationEventDelegate>>,re::EqualTo<re::SharedPtr<re::AnimationEventDelegate>>,true,false>::deinit((uint64_t *)this + 57);
  for (i = 0; i != -80; i -= 40)
  {
    v4 = (_QWORD *)((char *)this + i);
    v5 = *(_QWORD *)((char *)this + i + 416);
    if (v5)
    {
      if (v4[56])
        (*(void (**)(uint64_t, __n128))(*(_QWORD *)v5 + 40))(v5, v2);
      v4[56] = 0;
      v4[53] = 0;
      v4[54] = 0;
      v4[52] = 0;
      ++*(_DWORD *)((char *)this + i + 440);
    }
  }
  for (j = 328; j != 232; j -= 48)
    v7.n128_f64[0] = re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)((char *)this + j));
  for (k = 0; k != -80; k -= 40)
  {
    v9 = (char *)this + k;
    v10 = *(_QWORD *)((char *)this + k + 240);
    if (v10)
    {
      if (*((_QWORD *)v9 + 34))
        (*(void (**)(uint64_t, __n128))(*(_QWORD *)v10 + 40))(v10, v7);
      *((_QWORD *)v9 + 34) = 0;
      *(_QWORD *)((char *)this + k + 248) = 0;
      *(_QWORD *)((char *)this + k + 256) = 0;
      *(_QWORD *)((char *)this + k + 240) = 0;
      ++*(_DWORD *)((char *)this + k + 264);
    }
  }
  for (m = 136; m != 8; m -= 64)
    re::DataArray<re::internal::TimelineTree>::~DataArray((re::AnimationManager *)((char *)this + m));
}

{
  re::AnimationManager::~AnimationManager(this);
  JUMPOUT(0x2276933B8);
}

void re::AnimationManager::deinit(CFTypeRef *this)
{
  uint64_t v2;
  char v3;
  char v4;
  double v5;
  CFTypeRef *v6;
  _QWORD *v7;
  re::internal::AnimationHandoffBehavior **v8;
  re::internal::AnimationHandoffBehavior **v9;
  uint64_t v10;
  uint64_t v11;
  re::internal::AnimationHandoffBehavior *v12;
  uint64_t v13;
  CFTypeRef *v14;
  CFTypeRef v15;
  _QWORD *v16;
  uint64_t v17;
  void (***v18)(_QWORD);
  _QWORD *v19;
  double v20;
  CFTypeRef v21;
  _QWORD *v22;

  if (*((_DWORD *)this + 29))
  {
    v2 = 0;
    v3 = 1;
    do
    {
      v4 = v3;
      re::DataArray<re::internal::TimelineTree>::deinit(&this[8 * v2 + 9]);
      v6 = &this[5 * v2];
      v9 = (re::internal::AnimationHandoffBehavior **)v6[29];
      v7 = v6 + 29;
      v8 = v9;
      v10 = *(v7 - 2);
      if (v10)
      {
        v11 = 8 * v10;
        do
        {
          v12 = *v8;
          if (*v8)
          {
            re::internal::AnimationHandoffBehavior::~AnimationHandoffBehavior(*v8, v5);
          }
          ++v8;
          v11 -= 8;
        }
        while (v11);
      }
      v13 = *(v7 - 4);
      if (v13)
      {
        if (*v7)
          (*(void (**)(uint64_t))(*(_QWORD *)v13 + 40))(v13);
        *v7 = 0;
        *(v7 - 3) = 0;
        *(v7 - 2) = 0;
        *(v7 - 4) = 0;
        ++LODWORD(this[5 * v2 + 28]);
      }
      v14 = &this[5 * v2];
      v15 = v14[49];
      if (v15)
      {
        v16 = v14[51];
        v17 = 8 * (_QWORD)v15;
        do
        {
          v18 = (void (***)(_QWORD))*v16;
          if (*v16)
          {
            (**v18)(*v16);
          }
          ++v16;
          v17 -= 8;
        }
        while (v17);
      }
      v19 = v14 + 47;
      v20 = re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)&this[6 * v2 + 35]);
      v21 = v14[47];
      if (v21)
      {
        v22 = v14 + 51;
        if (*v22)
          (*(void (**)(CFTypeRef, double))(*(_QWORD *)v21 + 40))(v21, v20);
        *v22 = 0;
        v19[1] = 0;
        v19[2] = 0;
        *v19 = 0;
        ++LODWORD(this[5 * v2 + 50]);
      }
      v3 = 0;
      v2 = 1;
    }
    while ((v4 & 1) != 0);
    CFRelease(this[8]);
    this[8] = 0;
    *((_BYTE *)this + 57) = 0;
  }
}

void re::AnimationManager::init(re::AnimationManager *this, CFTypeRef cf, char a3)
{
  _anonymous_namespace_ *v5;
  const __CFAllocator *v6;
  OpaqueCMClock *HostTimeClock;
  uint64_t v8;
  char v9;
  char v10;
  char *v11;
  char *v12;
  uint64_t v13;
  char v14;
  NSObject *v15;
  uint8_t v16[16];

  if (cf)
  {
    *((_BYTE *)this + 57) = 0;
    *((_QWORD *)this + 8) = cf;
    v5 = (_anonymous_namespace_ *)CFRetain(cf);
  }
  else
  {
    *((_BYTE *)this + 57) = 1;
    v6 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
    HostTimeClock = CMClockGetHostTimeClock();
    v5 = (_anonymous_namespace_ *)CMTimebaseCreateWithSourceClock(v6, HostTimeClock, (CMTimebaseRef *)this + 8);
  }
  v8 = 0;
  v9 = 1;
  do
  {
    v10 = v9;
    v11 = (char *)this + 64 * v8;
    v11 += 72;
    re::DynamicArray<re::DataArray<re::internal::TimelineTree>::ElementBlock>::setCapacity(v11, 0);
    ++*((_DWORD *)v11 + 6);
    *((_DWORD *)v11 + 11) = 512;
    re::DataArray<re::internal::TimelineTree>::allocBlock(v11);
    v12 = (char *)this + 40 * v8;
    v12 += 200;
    re::DynamicArray<re::internal::AnimationHandoffBehavior *>::setCapacity(v12, 0x80uLL);
    ++*((_DWORD *)v12 + 6);
    v13 = (uint64_t)re::DynamicArray<re::internal::AnimationHandoffBehavior *>::setCapacity((_QWORD *)v12 + 22, 0x200uLL);
    v9 = 0;
    ++*((_DWORD *)v12 + 50);
    v8 = 1;
  }
  while ((v10 & 1) != 0);
  if ((a3 & 1) != 0 || (v13 = dyld_program_sdk_at_least(), (v13 & 1) == 0))
  {
    v15 = *re::animationLogObjects((re *)v13);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v16 = 0;
      _os_log_impl(&dword_224FE9000, v15, OS_LOG_TYPE_DEFAULT, "Using deprecated animation clock. Please rebuild application using newer SDK.", v16, 2u);
    }
    v14 = 1;
  }
  else
  {
    v14 = 0;
  }
  *((_BYTE *)this + 506) = v14;
}

_DWORD *re::DataArray<re::internal::TimelineTree>::deinit(_DWORD *result)
{
  unint64_t v1;
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  __int128 v12;
  uint64_t v13;
  int v14;
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  unint64_t v19;
  __int16 v20;
  unint64_t v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  if (!result[11])
    return result;
  v2 = result;
  re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::DataArrayIterator((uint64_t)&v22, (uint64_t)result, 0);
  v3 = v22;
  v12 = v22;
  v4 = WORD4(v22);
  if ((_QWORD *)v22 != v2 || WORD4(v22) != 0xFFFFLL || (DWORD2(v22) & 0xFFFF0000) != 4294901760)
  {
    v7 = WORD5(v22);
    while (1)
    {
      v8 = *(_QWORD *)(v3 + 16);
      if (v8 <= v7)
        break;
      re::DataArray<re::internal::TimelineTree>::destroy((uint64_t)v2, ((unint64_t)(*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 32) + 16 * v7 + 8) + 4 * v4) & 0xFFFFFF) << 32) | (v7 << 16) | v4);
      re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::increment(&v12);
      v3 = v12;
      v4 = WORD4(v12);
      v7 = WORD5(v12);
      if ((_QWORD *)v12 == v2 && WORD4(v12) == 0xFFFFLL && WORD5(v12) == 0xFFFFLL)
        goto LABEL_14;
    }
LABEL_32:
    v13 = 0;
    v26 = 0u;
    v24 = 0u;
    v25 = 0u;
    v22 = 0u;
    v23 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v14 = 136315906;
    v15 = "operator[]";
    v16 = 1024;
    v17 = 797;
    v18 = 2048;
    v19 = v7;
    v20 = 2048;
    v21 = v8;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
LABEL_14:
  v9 = v2[2];
  v7 = v9 - 1;
  if (v9 == 1)
    goto LABEL_23;
  v8 = 16 * v9 - 16;
  do
  {
    if (v9 <= v7)
    {
      *(_QWORD *)&v12 = 0;
      v26 = 0u;
      v24 = 0u;
      v25 = 0u;
      v22 = 0u;
      v23 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v14 = 136315906;
      v15 = "operator[]";
      v16 = 1024;
      v17 = 789;
      v18 = 2048;
      v19 = v7;
      v20 = 2048;
      v21 = v9;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_31:
      *(_QWORD *)&v12 = 0;
      v26 = 0u;
      v24 = 0u;
      v25 = 0u;
      v22 = 0u;
      v23 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v14 = 136315906;
      v15 = "removeAt";
      v16 = 1024;
      v17 = 931;
      v18 = 2048;
      v19 = v7;
      v20 = 2048;
      v21 = v1;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_32;
    }
    v10 = (_QWORD *)(v2[4] + v8);
    (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*v2 + 40))(*v2, *v10);
    (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*v2 + 40))(*v2, v10[1]);
    v1 = v2[2];
    if (v1 <= v7)
      goto LABEL_31;
    v9 = v1 - 1;
    if (v1 - 1 > v7)
    {
      *(_OWORD *)(v2[4] + v8) = *(_OWORD *)(v2[4] + 16 * v1 - 16);
      v9 = v2[2] - 1;
    }
    v2[2] = v9;
    ++*((_DWORD *)v2 + 6);
    v8 -= 16;
    --v7;
  }
  while (v7);
  v2[6] = 0xFFFFFFFF00000000;
  if (!v9)
  {
    *(_QWORD *)&v12 = 0;
    v26 = 0u;
    v24 = 0u;
    v25 = 0u;
    v22 = 0u;
    v23 = 0u;
    v2 = (_QWORD *)MEMORY[0x24BDACB70];
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v14 = 136315906;
    v15 = "operator[]";
    v16 = 1024;
    v17 = 789;
    v18 = 2048;
    v19 = 0;
    v20 = 2048;
    v21 = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_23:
    v2[6] = 0xFFFFFFFF00000000;
  }
  v11 = (_QWORD *)v2[4];
  (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*v2 + 40))(*v2, *v11);
  (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*v2 + 40))(*v2, v11[1]);
  result = (_DWORD *)*v2;
  if (*v2)
  {
    if (v2[4])
      result = (_DWORD *)(*(uint64_t (**)(_DWORD *))(*(_QWORD *)result + 40))(result);
    v2[4] = 0;
    v2[1] = 0;
    v2[2] = 0;
    *v2 = 0;
    ++*((_DWORD *)v2 + 6);
  }
  *((_DWORD *)v2 + 11) = 0;
  return result;
}

double re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  double result;

  v2 = *a1;
  if (v2)
  {
    v3 = *((unsigned int *)a1 + 8);
    if ((_DWORD)v3)
    {
      v4 = 0;
      v5 = 32 * v3;
      do
      {
        v6 = a1[2] + v4;
        v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
        v4 += 32;
      }
      while (v5 != v4);
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

uint64_t re::AnimationManager::setTaskOptions(uint64_t result, float *a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;

  v3 = result;
  v4 = *(_QWORD *)(result + 32);
  if (v4 != -1)
    result = re::Scheduler::setTaskOptions(*(re::Scheduler **)(result + 8), v4, a2);
  v5 = *(_QWORD *)a2;
  *(_BYTE *)(v3 + 24) = *((_BYTE *)a2 + 8);
  *(_QWORD *)(v3 + 16) = v5;
  return result;
}

uint64_t re::Scheduler::setTaskOptions(re::Scheduler *a1, unint64_t a2, float *a3)
{
  re::Scheduler::updateTaskSchedule(a1, a2, *(unsigned __int8 *)a3);
  re::Scheduler::setTaskUpdateInterval(a1, a2, a3[1]);
  re::Scheduler::setTaskOverscheduleStrategy((uint64_t)a1, a2, *((_BYTE *)a3 + 1));
  return re::Scheduler::setTaskMaxOverscheduleSubsteps((uint64_t)a1, a2, *((_BYTE *)a3 + 8));
}

void re::AnimationManager::isAnimated(re::AnimationManager *this, const re::BindNode *a2)
{
  re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Not supported. BindNode does not yet have a function to iterate over children.", "!\"Unreachable code\"", "isAnimated", 395);
  _os_crash();
  __break(1u);
}

uint64_t re::AnimationManager::isAnimated(re::AnimationManager *this, const re::BindPoint *a2)
{
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  char v8;
  char v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  re::AnimationManager::updateLookupTableForAllBuckets(this);
  v4 = re::BindPoint::targetIdentifier(a2);
  v5 = 0;
  v6 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (v4 ^ (v4 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v4 ^ (v4 >> 30))) >> 27));
  v7 = v6 ^ (v6 >> 31);
  v8 = 1;
  while (1)
  {
    v9 = v8;
    if (*((_QWORD *)this + 6 * v5 + 35))
    {
      v10 = *(unsigned int *)(*((_QWORD *)this + 6 * v5 + 36) + 4 * (v7 % *((unsigned int *)this + 12 * v5 + 76)));
      if ((_DWORD)v10 != 0x7FFFFFFF)
        break;
    }
LABEL_7:
    v8 = 0;
    v12 = 0;
    v5 = 1;
    if ((v9 & 1) == 0)
      return v12;
  }
  v11 = *((_QWORD *)this + 6 * v5 + 37);
  while (*(_QWORD *)(v11 + 32 * v10 + 16) != v4)
  {
    v10 = *(_DWORD *)(v11 + 32 * v10 + 8) & 0x7FFFFFFF;
    if ((_DWORD)v10 == 0x7FFFFFFF)
      goto LABEL_7;
  }
  return 1;
}

void re::AnimationManager::updateLookupTableForAllBuckets(re::AnimationManager *this)
{
  uint64_t v1;
  char v2;
  char *v3;
  unint64_t v4;
  char *v5;
  uint64_t *v6;
  int *v7;
  unsigned int *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  char v24;
  _DWORD *v25;
  _DWORD *v26;
  _DWORD *v27;
  _QWORD *v28;
  unint64_t *v29;
  _QWORD *v30;
  _QWORD *v31;

  v1 = 0;
  v2 = 1;
  do
  {
    v24 = v2;
    v3 = (char *)this + 40 * v1;
    if ((int)*((_QWORD *)v3 + 49) >= 1)
    {
      v31 = v3 + 392;
      v4 = *((_QWORD *)v3 + 49);
      v29 = (unint64_t *)((char *)this + 48 * v1 + 280);
      v30 = (_QWORD *)((char *)this + 40 * v1 + 408);
      v5 = (char *)this + 48 * v1;
      v27 = v5 + 304;
      v28 = v5 + 288;
      v6 = (uint64_t *)(v5 + 296);
      v7 = (int *)(v5 + 316);
      v8 = (unsigned int *)(v5 + 312);
      v25 = v5 + 320;
      v26 = v5 + 308;
      do
      {
        if (*v31 <= (unint64_t)(v4 - 1))
        {
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        v9 = *(_QWORD *)(*v30 + 8 * (v4 - 1));
        v10 = re::BindPoint::targetIdentifier((re::BindPoint *)(v9 + 8));
        v11 = *(_QWORD *)(v9 + 96);
        if (v11 != v10)
        {
          v12 = v10;
          if (v11)
            re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::remove((uint64_t)v29, v11);
          if (v12)
          {
            v13 = 0x94D049BB133111EBLL
                * ((0xBF58476D1CE4E5B9 * (v12 ^ (v12 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v12 ^ (v12 >> 30))) >> 27));
            v14 = v13 ^ (v13 >> 31);
            v15 = *v29;
            if (!*v29
              || (v15 = v14 % *v27, v16 = *(unsigned int *)(*v28 + 4 * v15), (_DWORD)v16 == 0x7FFFFFFF))
            {
LABEL_14:
              v18 = *v7;
              if ((_DWORD)v18 == 0x7FFFFFFF)
              {
                v18 = *v8;
                v19 = v18;
                if ((_DWORD)v18 == *v27)
                {
                  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::setCapacity((uint64_t)v29, 2 * *v26);
                  v15 = v14 % *v27;
                  v19 = *v8;
                }
                *v8 = v19 + 1;
                v20 = *v6;
                v21 = *(_DWORD *)(*v6 + 32 * v18 + 8);
              }
              else
              {
                v20 = *v6;
                v21 = *(_DWORD *)(*v6 + 32 * v18 + 8);
                *v7 = v21 & 0x7FFFFFFF;
              }
              *(_DWORD *)(v20 + 32 * v18 + 8) = v21 | 0x80000000;
              *(_DWORD *)(*v6 + 32 * v18 + 8) = *(_DWORD *)(*v6 + 32 * v18 + 8) & 0x80000000 | *(_DWORD *)(*v28 + 4 * v15);
              *(_QWORD *)(*v6 + 32 * v18) = v14;
              *(_QWORD *)(*v6 + 32 * v18 + 16) = v12;
              *(_QWORD *)(*v6 + 32 * v18 + 24) = v9;
              *(_DWORD *)(*v28 + 4 * v15) = v18;
              ++*v26;
              ++*v25;
            }
            else
            {
              v17 = *v6;
              while (*(_QWORD *)(v17 + 32 * v16 + 16) != v12)
              {
                v16 = *(_DWORD *)(v17 + 32 * v16 + 8) & 0x7FFFFFFF;
                if ((_DWORD)v16 == 0x7FFFFFFF)
                  goto LABEL_14;
              }
            }
          }
          *(_QWORD *)(v9 + 96) = v12;
        }
      }
      while (v4-- > 1);
    }
    v2 = 0;
    v1 = 1;
  }
  while ((v24 & 1) != 0);
}

uint64_t re::AnimationManager::isAnimated(re::AnimationManager *this, re::BindNode **a2, const re::IntrospectionBase *a3, const char *a4)
{
  uint64_t isAnimated;
  uint64_t v10;
  _BYTE v11[40];
  uint64_t v12;
  _BYTE v13[16];
  uint64_t v14;

  if (v14 && (re::BindPoint::isAlive((re::BindPoint *)&v12) & 1) != 0
        v12 = v10,
        re::DynamicArray<re::RigDataValue>::operator=((uint64_t)v13, (uint64_t)v11),
        re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)v11),
        re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)v11),
        v14)
    && re::BindPoint::isAlive((re::BindPoint *)&v12))
  {
    isAnimated = re::AnimationManager::isAnimated(this, (const re::BindPoint *)&v12);
  }
  else
  {
    isAnimated = 0;
  }
  re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)v13);
  re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)v13);
  return isAnimated;
}

double `anonymous namespace'::findBindPoint(_anonymous_namespace_ *this, re::BindNode **a2, const re::IntrospectionBase *a3, const char *__s, int a5)
{
  double result;
  NSObject *v9;
  const char *v10;
  size_t v11;

  if (__s && *__s)
  {
    if (a5)
    {
      v10 = __s;
      v11 = strlen(__s);
      return re::BindNode::bindPointWithOverride(a2, (uint64_t)a3, (uint64_t *)&v10, (uint64_t)this);
    }
    else
    {
      v10 = __s;
      v11 = strlen(__s);
      return re::BindNode::bindPoint(a2, (uint64_t)a3, (uint64_t *)&v10, (uint64_t)this);
    }
  }
  else
  {
    v9 = *re::animationLogObjects(this);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v10) = 0;
      _os_log_error_impl(&dword_224FE9000, v9, OS_LOG_TYPE_ERROR, "No bind target found for played animation.", (uint8_t *)&v10, 2u);
    }
    *((_QWORD *)this + 5) = 0;
    result = 0.0;
    *(_OWORD *)this = 0u;
    *((_OWORD *)this + 1) = 0u;
    *((_DWORD *)this + 8) = 0;
  }
  return result;
}

re::AnimationManager *re::AnimationManager::startAnimation(uint64_t a1, _anonymous_namespace_ *a2, re::BindNode **a3, __int128 *a4, char a5, _QWORD *a6)
{
  __int128 v7;
  uint64_t v8;

  v7 = *a4;
  v8 = *((_QWORD *)a4 + 2);
  return re::AnimationManager::startAnimation(a1, a2, a3, 0, (unint64_t)&v7, a5, 0, a6);
}

re::AnimationManager *re::AnimationManager::startAnimation(uint64_t a1, _anonymous_namespace_ *this, re::BindNode **a3, _QWORD *a4, unint64_t a5, char a6, re::internal::TimelineTree *a7, _QWORD *a8)
{
  _anonymous_namespace_ *v13;
  re *v15;
  uint64_t v16;
  int v17;
  BOOL v18;
  uint64_t v19;
  uint64_t v20;
  _DWORD *v21;
  unint64_t v22;
  int v23;
  int *v24;
  int v25;
  unint64_t v26;
  re::AnimationManager *v28;
  _QWORD *v29;
  uint64_t v30;
  _DWORD *v31;
  unsigned int v32;
  uint64_t v33;
  _QWORD *v34;
  unint64_t v35;
  unint64_t v36;
  _anonymous_namespace_ *v37;
  unint64_t v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  __n128 v42;
  int v43;
  unint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  int v48;
  uint64_t v49;
  uint64_t v50;
  const re::IntrospectionBase *v51;
  unint64_t *CompositionChain;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t v57;
  unint64_t v58;
  unint64_t v59;
  unint64_t v60;
  unint64_t v61;
  uint64_t v62;
  uint64_t v63;
  unint64_t v64;
  const char *v65;
  re *Alive;
  NSObject *v67;
  unint64_t *v68;
  unint64_t v69;
  unint64_t v70;
  unint64_t v71;
  uint64_t v72;
  unint64_t v73;
  unint64_t v74;
  int v75;
  uint64_t v76;
  unint64_t v77;
  _anonymous_namespace_ *v78;
  uint64_t v79;
  char *v80;
  NSObject *v81;
  uint64_t v83;
  uint64_t v84;
  char v85;
  const char *v86;
  size_t v87;
  re *v88;
  NSObject *v89;
  uint64_t v90;
  _QWORD *v91;
  uint64_t v92;
  NSObject *v93;
  char *v94;
  float v95;
  int v96;
  uint64_t v97;
  unint64_t v98;
  unint64_t i;
  uint64_t v100;
  unint64_t v101;
  unint64_t v102;
  int *v103;
  int v104;
  unint64_t v105;
  unint64_t v106;
  unint64_t v107;
  uint64_t v108;
  __n128 *v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  unint64_t v114;
  re::internal::AnimationHandoffBehavior *v115;
  int v116;
  char v117;
  BOOL v119;
  uint64_t v120;
  _QWORD *v121;
  uint64_t v122;
  unint64_t v123;
  uint64_t v124;
  char *WeakRetained;
  _QWORD *v126;
  uint64_t v127;
  char *v128;
  uint64_t v129;
  uint64_t v130;
  char *v131;
  _QWORD *v132;
  int v133;
  _anonymous_namespace_ *v134;
  uint64_t *v135;
  _QWORD *v136;
  unsigned int *v137;
  _DWORD *v138;
  re::internal::TimelineTree *v139;
  _QWORD *v140;
  unint64_t *v141;
  _DWORD *v142;
  char v143;
  char v144;
  char v145;
  _QWORD *v146;
  char v147;
  unint64_t v148;
  unint64_t *v149;
  char v150;
  re::BindNode **v151;
  re::AnimationManager *v152;
  int v154;
  uint64_t v155;
  unint64_t v156;
  char *v157;
  char v158[4];
  int v159;
  _BYTE v160[38];
  uint64_t v161;
  _QWORD buf[8];
  __int128 v163;
  __int128 v164;
  __int128 v165;
  __int128 v166;
  __int128 v167;
  uint64_t v168;

  v168 = *MEMORY[0x24BDAC8D0];
  if (*(_BYTE *)(a1 + 504))
    return 0;
  v13 = this;
  v17 = DWORD1(v163);
  if ((_BYTE)v163)
    v18 = DWORD1(v163) == 0;
  else
    v18 = 1;
  if (v18)
    goto LABEL_89;
  v151 = a3;
  v152 = (re::AnimationManager *)a1;
  v139 = v13;
  v148 = a5;
  v144 = a6;
  v19 = (a6 & 1) == 0;
  v20 = a1 + (v19 << 6);
  v21 = (_DWORD *)(v20 + 124);
  v13 = (_anonymous_namespace_ *)*(unsigned __int16 *)(v20 + 124);
  v22 = v20 + 72;
  v24 = (int *)(v20 + 128);
  v23 = *(_DWORD *)(v20 + 128);
  v25 = (v23 + 1) >> 24 ? 1 : v23 + 1;
  *v24 = v25;
  v26 = *(unsigned __int16 *)(v20 + 126);
  if (v13 == (_anonymous_namespace_ *)0xFFFF && (_DWORD)v26 == 0xFFFF)
  {
    v32 = *(_DWORD *)(v20 + 120);
    v31 = (_DWORD *)(v20 + 120);
    if (v32 >= *(v31 - 1))
      re::DataArray<re::internal::TimelineTree>::allocBlock((_QWORD *)v22);
    v33 = *(_QWORD *)(v22 + 16);
    v26 = (unsigned __int16)(v33 - 1);
    if (!v33)
      goto LABEL_238;
    v13 = (_anonymous_namespace_ *)*v31;
    if (v13 >= 0x10000)
      goto LABEL_239;
    v34 = (_QWORD *)(*(_QWORD *)(v22 + 32) + 16 * v26);
    *v31 = (_DWORD)v13 + 1;
    *(_DWORD *)(v34[1] + 4 * (_QWORD)v13) = *v24;
    v30 = *v34 + 216 * v13;
  }
  else
  {
    v28 = *(re::AnimationManager **)(v20 + 88);
    if ((unint64_t)v28 <= v26)
    {
LABEL_237:
      *(_QWORD *)v160 = 0;
      v166 = 0u;
      v167 = 0u;
      v164 = 0u;
      v165 = 0u;
      v163 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      LODWORD(buf[0]) = 136315906;
      *(_QWORD *)((char *)buf + 4) = "operator[]";
      WORD2(buf[1]) = 1024;
      *(_DWORD *)((char *)&buf[1] + 6) = 789;
      WORD1(buf[2]) = 2048;
      *(_QWORD *)((char *)&buf[2] + 4) = v26;
      WORD2(buf[3]) = 2048;
      *(_QWORD *)((char *)&buf[3] + 6) = v28;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_238:
      *(_QWORD *)v160 = 0;
      v166 = 0u;
      v167 = 0u;
      v164 = 0u;
      v165 = 0u;
      v163 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      LODWORD(buf[0]) = 136315906;
      *(_QWORD *)((char *)buf + 4) = "operator[]";
      WORD2(buf[1]) = 1024;
      *(_DWORD *)((char *)&buf[1] + 6) = 789;
      WORD1(buf[2]) = 2048;
      *(_QWORD *)((char *)&buf[2] + 4) = v26;
      WORD2(buf[3]) = 2048;
      *(_QWORD *)((char *)&buf[3] + 6) = 0;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_239:
      re::internal::assertLog((re::internal *)5, v16, "assertion failure: '%s' (%s:line %i) m_tailBlockLinearAllocationCount (%u) is too large for a 16-bit unsigned integer", "!overflow", "create", 601, v13);
      _os_crash();
      __break(1u);
    }
    v29 = (_QWORD *)(*(_QWORD *)(v21 - 5) + 16 * v26);
    *(_DWORD *)(v29[1] + 4 * (_QWORD)v13) = v25;
    v30 = *v29 + 216 * v13;
    *v21 = *(_DWORD *)v30;
  }
  ++*(_DWORD *)(a1 + (v19 << 6) + 112);
  *(_QWORD *)(v30 + 208) = 0;
  *(_OWORD *)(v30 + 192) = 0u;
  *(_OWORD *)(v30 + 144) = 0u;
  *(_OWORD *)(v30 + 160) = 0u;
  *(_OWORD *)(v30 + 112) = 0u;
  *(_OWORD *)(v30 + 128) = 0u;
  *(_OWORD *)(v30 + 80) = 0u;
  *(_OWORD *)(v30 + 96) = 0u;
  *(_OWORD *)(v30 + 48) = 0u;
  *(_OWORD *)(v30 + 64) = 0u;
  *(_OWORD *)(v30 + 16) = 0u;
  *(_OWORD *)(v30 + 32) = 0u;
  *(_OWORD *)v30 = 0u;
  *(_OWORD *)(v30 + 176) = 0u;
  objc_initWeak((id *)(v30 + 176), 0);
  *(_WORD *)(v30 + 184) = 767;
  *(_DWORD *)(v30 + 188) = 1065353216;
  *(_QWORD *)(v30 + 200) = 0;
  *(_QWORD *)(v30 + 208) = 0;
  *(_QWORD *)(v30 + 192) = 0;
  v35 = (v26 << 16) | ((unint64_t)(*v24 & 0xFFFFFF) << 32);
  v36 = v35 | (unint64_t)v13;
  v37 = (_anonymous_namespace_ *)re::DataArray<re::internal::TimelineTree>::get(v22, v35 | v13);
  re::internal::TimelineTree::init((uint64_t)v37, v17, v19, *(CMTimebaseRef *)(a1 + 64), a7, a8, *(unsigned __int8 *)(a1 + 506));
  v13 = v139;
  v38 = v36 | (v19 << 56);
  v39 = v148;
  if (!v38)
  {
LABEL_89:
    v81 = *re::animationLogObjects(v15);
    if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR))
    {
      v97 = *((_QWORD *)v13 + 4);
      LODWORD(v163) = 136315138;
      *(_QWORD *)((char *)&v163 + 4) = v97;
      _os_log_error_impl(&dword_224FE9000, v81, OS_LOG_TYPE_ERROR, "Potentially invalid timeline detected. Name of root timeline: %s", (uint8_t *)&v163, 0xCu);
    }
    return 0;
  }
  v40 = re::DataArray<re::internal::TimelineTree>::get(v22, v38);
  re::AnimationManager::updateLookupTableForAllBuckets((re::AnimationManager *)a1);
  v28 = *(re::AnimationManager **)(v40 + 32);
  if ((int)v28 < 1)
  {
LABEL_111:
    v90 = *(_QWORD *)(v40 + 152);
    if (v90)
    {
      v91 = *(_QWORD **)(v40 + 160);
      v92 = 8 * v90;
      while (!*v91)
      {
        ++v91;
        v92 -= 8;
        if (!v92)
          goto LABEL_115;
      }
    }
    else
    {
LABEL_115:
      v93 = *re::animationLogObjects((re *)v41);
      v41 = os_log_type_enabled(v93, OS_LOG_TYPE_DEFAULT);
      if ((_DWORD)v41)
      {
        if ((*((_BYTE *)v13 + 48) & 1) != 0)
          v94 = (char *)*((_QWORD *)v13 + 7);
        else
          v94 = (char *)v13 + 49;
        LODWORD(v163) = 136315138;
        *(_QWORD *)((char *)&v163 + 4) = v94;
        _os_log_impl(&dword_224FE9000, v93, OS_LOG_TYPE_DEFAULT, "Failed to assign animation to target variables. Please check the bind node/point. Make sure the animation type matches the target variable. Failing bind path is: '%s'.", (uint8_t *)&v163, 0xCu);
      }
    }
    v28 = (re::AnimationManager *)*(unsigned int *)(v39 + 12);
    LOBYTE(v151) = (_DWORD)v28 != 0x80000000;
    v95 = *(float *)(v39 + 4);
    v96 = *(_DWORD *)v39;
    switch(*(_DWORD *)v39)
    {
      case 0:
        v98 = *(_QWORD *)(v40 + 152);
        if (v98)
        {
          for (i = 0; i < v98; ++i)
          {
            v41 = *(_QWORD *)(*(_QWORD *)(v40 + 160) + 8 * i);
            if (v41)
            {
              v41 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v41 + 48))(v41);
              v98 = *(_QWORD *)(v40 + 152);
            }
          }
        }
        v22 = 0;
        v150 = 0;
        v145 = 1;
        v147 = 0;
        v154 = 2;
        goto LABEL_134;
      case 1:
        v147 = 0;
        v150 = 0;
        v154 = 1;
        v22 = 4;
        goto LABEL_133;
      case 2:
      case 4:
      case 5:
        v147 = 0;
        v150 = 0;
        if (v96 == 4)
          v22 = 1;
        else
          v22 = 2 * (v96 == 5);
        v154 = *(unsigned __int8 *)(v39 + 8);
LABEL_133:
        v145 = 1;
        goto LABEL_134;
      case 3:
        if (v95 <= 0.0)
          goto LABEL_183;
        v22 = 0;
        v143 = 0;
        v154 = 1;
        v145 = 0;
        v147 = 1;
        v150 = 1;
        break;
      default:
        v22 = 0;
        v154 = 0;
        v150 = 0;
        v145 = 0;
        v147 = 1;
LABEL_134:
        v143 = 1;
        break;
    }
    if ((int)*(_QWORD *)(v40 + 32) >= 1)
    {
      v44 = 0;
      v100 = *(_QWORD *)(v40 + 32);
      v26 = 0x80000000;
      while (1)
      {
        CompositionChain = *(unint64_t **)(v40 + 152);
        if ((unint64_t)CompositionChain <= v44)
          break;
        v13 = *(_anonymous_namespace_ **)(*(_QWORD *)(v40 + 160) + 8 * v44);
        if (v13)
        {
          v39 = (unint64_t)v28;
          if ((_DWORD)v28 == 0x80000000)
          {
            CompositionChain = *(unint64_t **)(v40 + 128);
            if ((unint64_t)CompositionChain <= v44)
              goto LABEL_234;
            v39 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(v40 + 136) + 8 * v44) + 12);
          }
          v101 = *((_QWORD *)v13 + 9);
          if (v101)
          {
            v102 = 0;
            v103 = (int *)(*((_QWORD *)v13 + 11) + 16);
            while (1)
            {
              v104 = *v103;
              v103 += 6;
              if (v104 > (int)v39)
                break;
              if (v101 == ++v102)
              {
                v102 = *((_QWORD *)v13 + 9);
                break;
              }
            }
          }
          else
          {
            v102 = 0;
          }
          CompositionChain = (unint64_t *)(v101 + 1);
          if (v101 + 1 <= v102)
            goto LABEL_230;
          v105 = *((_QWORD *)v13 + 8);
          if (v101 >= v105)
          {
            if (v105 < (unint64_t)CompositionChain)
            {
              if (*((_QWORD *)v13 + 7))
              {
                v106 = 2 * v105;
                if (!v105)
                  v106 = 8;
                if (v106 <= (unint64_t)CompositionChain)
                  v107 = (unint64_t)CompositionChain;
                else
                  v107 = v106;
                v41 = (uint64_t)re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity((_QWORD *)v13 + 7, v107);
              }
              else
              {
                v41 = (uint64_t)re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity((_QWORD *)v13 + 7, (unint64_t)CompositionChain);
                ++*((_DWORD *)v13 + 20);
              }
              v26 = 0x80000000;
            }
            v101 = *((_QWORD *)v13 + 9);
          }
          v108 = *((_QWORD *)v13 + 11);
          v109 = (__n128 *)(v108 + 24 * v101);
          if (v101 > v102)
          {
            v110 = v108 + 24 * v101;
            v42 = *(__n128 *)(v110 - 24);
            *v109 = v42;
            v109[1].n128_u64[0] = *(_QWORD *)(v110 - 8);
            v111 = *((_QWORD *)v13 + 11);
            v112 = v111 + 24 * v102;
            v113 = v111 + 24 * *((_QWORD *)v13 + 9);
            if (v113 - 24 != v112)
            {
              v41 = (uint64_t)memmove((void *)(v112 + 24), (const void *)v112, v113 - 24 - v112 - 3);
              v111 = *((_QWORD *)v13 + 11);
            }
            v109 = (__n128 *)(v111 + 24 * v102);
          }
          v109->n128_u64[0] = v40;
          v109->n128_u32[2] = v44;
          v109[1].n128_u32[0] = v39;
          v109[1].n128_u8[4] = v22;
          ++*((_QWORD *)v13 + 9);
          ++*((_DWORD *)v13 + 20);
        }
        if (++v44 == v100)
          goto LABEL_167;
      }
LABEL_228:
      *(_QWORD *)v160 = 0;
      v166 = 0u;
      v167 = 0u;
      v164 = 0u;
      v165 = 0u;
      v163 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      LODWORD(buf[0]) = 136315906;
      *(_QWORD *)((char *)buf + 4) = "operator[]";
      WORD2(buf[1]) = 1024;
      *(_DWORD *)((char *)&buf[1] + 6) = 468;
      WORD1(buf[2]) = 2048;
      *(_QWORD *)((char *)&buf[2] + 4) = v44;
      WORD2(buf[3]) = 2048;
      *(_QWORD *)((char *)&buf[3] + 6) = CompositionChain;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_229:
      *(_QWORD *)v160 = 0;
      v166 = 0u;
      v167 = 0u;
      v164 = 0u;
      v165 = 0u;
      v163 = 0u;
      v102 = MEMORY[0x24BDACB70];
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      LODWORD(buf[0]) = 136315906;
      *(_QWORD *)((char *)buf + 4) = "operator[]";
      WORD2(buf[1]) = 1024;
      *(_DWORD *)((char *)&buf[1] + 6) = 468;
      WORD1(buf[2]) = 2048;
      *(_QWORD *)((char *)&buf[2] + 4) = v39;
      WORD2(buf[3]) = 2048;
      *(_QWORD *)((char *)&buf[3] + 6) = CompositionChain;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_230:
      *(_QWORD *)v160 = 0;
      v166 = 0u;
      v167 = 0u;
      v164 = 0u;
      v165 = 0u;
      v163 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      LODWORD(buf[0]) = 136315906;
      *(_QWORD *)((char *)buf + 4) = "insert";
      WORD2(buf[1]) = 1024;
      *(_DWORD *)((char *)&buf[1] + 6) = 855;
      WORD1(buf[2]) = 2048;
      *(_QWORD *)((char *)&buf[2] + 4) = v102;
      WORD2(buf[3]) = 2048;
      *(_QWORD *)((char *)&buf[3] + 6) = CompositionChain;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_231:
      v155 = 0;
      v166 = 0u;
      v167 = 0u;
      v164 = 0u;
      v165 = 0u;
      v163 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      LODWORD(buf[0]) = 136315906;
      *(_QWORD *)((char *)buf + 4) = "operator[]";
      WORD2(buf[1]) = 1024;
      *(_DWORD *)((char *)&buf[1] + 6) = 468;
      WORD1(buf[2]) = 2048;
      *(_QWORD *)((char *)&buf[2] + 4) = v13;
      WORD2(buf[3]) = 2048;
      *(_QWORD *)((char *)&buf[3] + 6) = v26;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_232:
      v155 = 0;
      v166 = 0u;
      v167 = 0u;
      v164 = 0u;
      v165 = 0u;
      v163 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      LODWORD(buf[0]) = 136315906;
      *(_QWORD *)((char *)buf + 4) = "operator[]";
      WORD2(buf[1]) = 1024;
      *(_DWORD *)((char *)&buf[1] + 6) = 468;
      WORD1(buf[2]) = 2048;
      *(_QWORD *)((char *)&buf[2] + 4) = v13;
      WORD2(buf[3]) = 2048;
      *(_QWORD *)((char *)&buf[3] + 6) = CompositionChain;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_233:
      v155 = 0;
      v166 = 0u;
      v167 = 0u;
      v164 = 0u;
      v165 = 0u;
      v163 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v160 = 136315906;
      *(_QWORD *)&v160[4] = "operator[]";
      *(_WORD *)&v160[12] = 1024;
      *(_DWORD *)&v160[14] = 476;
      *(_WORD *)&v160[18] = 2048;
      *(_QWORD *)&v160[20] = v22;
      *(_WORD *)&v160[28] = 2048;
      *(_QWORD *)&v160[30] = v13;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_234:
      *(_QWORD *)v160 = 0;
      v166 = 0u;
      v167 = 0u;
      v164 = 0u;
      v165 = 0u;
      v163 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      LODWORD(buf[0]) = 136315906;
      *(_QWORD *)((char *)buf + 4) = "operator[]";
      WORD2(buf[1]) = 1024;
      *(_DWORD *)((char *)&buf[1] + 6) = 468;
      WORD1(buf[2]) = 2048;
      *(_QWORD *)((char *)&buf[2] + 4) = v44;
      WORD2(buf[3]) = 2048;
      *(_QWORD *)((char *)&buf[3] + 6) = CompositionChain;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_235:
      v155 = 0;
      v166 = 0u;
      v167 = 0u;
      v164 = 0u;
      v165 = 0u;
      v163 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      LODWORD(buf[0]) = 136315906;
      *(_QWORD *)((char *)buf + 4) = "operator[]";
      WORD2(buf[1]) = 1024;
      *(_DWORD *)((char *)&buf[1] + 6) = 468;
      WORD1(buf[2]) = 2048;
      *(_QWORD *)((char *)&buf[2] + 4) = v13;
      WORD2(buf[3]) = 2048;
      *(_QWORD *)((char *)&buf[3] + 6) = CompositionChain;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_236:
      re::internal::assertLog((re::internal *)4, v57, "assertion failure: '%s' (%s:line %i) ", "bindPointTargetIdentifier", "addToLookupTable", 930);
      _os_crash();
      __break(1u);
      goto LABEL_237;
    }
LABEL_167:
    if (v95 <= 0.0)
    {
      v114 = v148;
      v116 = v154;
    }
    else
    {
      v114 = v148;
      LODWORD(v163) = *(_DWORD *)v148;
      BYTE4(v163) = v145;
      if ((v147 & 1) == 0)
        DWORD2(v163) = 0;
      BYTE12(v163) = v150;
      if ((v143 & 1) == 0)
        LODWORD(v164) = 0;
      DWORD1(v164) = *(_DWORD *)(v148 + 4);
      v115 = (re::internal::AnimationHandoffBehavior *)re::AnimationManager::addFadeOutHandoffBehavior(v152, v40, &v163);
      if (v154 != 1)
      {
        if (v154 != 2)
        {
LABEL_195:
          v28 = v152;
LABEL_203:
          v120 = *(_QWORD *)(v40 + 152);
          if (v120)
          {
            v121 = *(_QWORD **)(v40 + 160);
            v122 = 8 * v120;
            do
            {
              if (*v121)
                (*(void (**)(_QWORD, __n128))(*(_QWORD *)*v121 + 56))(*v121, v42);
              ++v121;
              v122 -= 8;
            }
            while (v122);
          }
          re::AnimationManager::updateScheduler(v28);
          v123 = *(_QWORD *)(v40 + 32);
          if (!v123)
            return v28;
          v39 = 0;
          v26 = 72;
          v44 = 1;
          while (1)
          {
            CompositionChain = *(unint64_t **)(v40 + 128);
            if ((unint64_t)CompositionChain <= v39)
              goto LABEL_229;
            CompositionChain = *(unint64_t **)(*(_QWORD *)(v40 + 136) + 8 * v39);
            if (*((_DWORD *)CompositionChain + 2) == 49)
            {
              LOWORD(buf[0]) = 255;
              BYTE2(buf[0]) = 0;
              LODWORD(buf[1]) = 0;
              HIDWORD(buf[0]) = 0;
              memset(&buf[2], 0, 41);
              v124 = re::TypedEventTimelineInstance<float>::compositionChain((uint64_t)CompositionChain);
              if (v124)
              {
                buf[5] = v124 + 8;
                *(_BYTE *)(v124 + 104) = 1;
              }
              WeakRetained = (char *)objc_loadWeakRetained((id *)(CompositionChain[16] + 176));
              v126 = (_QWORD *)CompositionChain[16];
              v22 = CompositionChain[18];
              v13 = (_anonymous_namespace_ *)v126[7];
              if ((unint64_t)v13 <= v22)
                goto LABEL_233;
              v127 = v126[21];
              if (WeakRetained)
                v128 = WeakRetained - 8;
              else
                v128 = 0;
              v129 = v126[8];
              v130 = v129 + 72 * v22;
              v22 = (unint64_t)(v128 + 8);
              (*(void (**)(char *, uint64_t, uint64_t, uint64_t, unint64_t, uint64_t, unint64_t *, _QWORD *, double, _QWORD *, int))(*(_QWORD *)v128 + 40))(v128, 12, v127, v130, CompositionChain[17], -1, CompositionChain, buf, *(double *)(v129 + 8), v132, v133);

              v123 = *(_QWORD *)(v40 + 32);
            }
            if (v123 <= ++v39)
              return v28;
          }
        }
LABEL_196:
        if (*(_BYTE *)(v114 + 8))
        {
          v117 = 1;
LABEL_198:
          v158[0] = (char)v151;
          if ((_DWORD)v28 != 0x80000000)
            v159 = (int)v28;
          v28 = v152;
          v42.n128_f64[0] = re::AnimationManager::removeLayerExcept(v152, (_QWORD *)v40, v158, 0);
          if ((v117 & 1) == 0)
            goto LABEL_201;
        }
        else
        {
          v28 = v152;
          v42.n128_f64[0] = re::AnimationManager::removeExcept(v152, (re::internal::TimelineTree *)v40, 0);
        }
        goto LABEL_203;
      }
      if (*(_BYTE *)(v148 + 8))
      {
        LOBYTE(v155) = (_DWORD)v28 != 0x80000000;
        if ((_DWORD)v28 != 0x80000000)
          HIDWORD(v155) = (_DWORD)v28;
        v42.n128_f64[0] = re::AnimationManager::removeLayerExcept(v152, (_QWORD *)v40, &v155, (uint64_t)v115);
      }
      else
      {
        v42.n128_f64[0] = re::AnimationManager::removeExcept(v152, (re::internal::TimelineTree *)v40, v115);
      }
      v116 = 1;
    }
    v119 = v95 > 0.0 || v116 != 1;
    if (v116 != 2 && v119)
      goto LABEL_195;
    goto LABEL_196;
  }
  v26 = 0;
  v43 = 0;
  v146 = (_QWORD *)(a1 + 48 * *(char *)(v40 + 184) + 280);
  v134 = (_anonymous_namespace_ *)(a1 + 40 * *(char *)(v40 + 184) + 376);
  v39 = (unint64_t)&v160[8];
  v44 = (unint64_t)&v163 + 8;
  v45 = a1 + 48 * *(char *)(v40 + 184);
  v137 = (unsigned int *)(v45 + 304);
  v136 = (_QWORD *)(v45 + 288);
  v135 = (uint64_t *)(v45 + 296);
  v138 = (_DWORD *)(v45 + 320);
  v46 = a1 + 40 * *(char *)(v40 + 184);
  v149 = (unint64_t *)(v46 + 392);
  v141 = (unint64_t *)(v46 + 384);
  v142 = (_DWORD *)(v46 + 400);
  v140 = (_QWORD *)(v46 + 408);
  v22 = 1;
  while (1)
  {
    v13 = (_anonymous_namespace_ *)v43;
    v47 = *(_QWORD *)(v40 + 128);
    if (v47 <= v43)
    {
      v155 = 0;
      v166 = 0u;
      v167 = 0u;
      v164 = 0u;
      v165 = 0u;
      v163 = 0u;
      CompositionChain = (unint64_t *)MEMORY[0x24BDACB70];
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      LODWORD(buf[0]) = 136315906;
      *(_QWORD *)((char *)buf + 4) = "operator[]";
      WORD2(buf[1]) = 1024;
      *(_DWORD *)((char *)&buf[1] + 6) = 476;
      WORD1(buf[2]) = 2048;
      *(_QWORD *)((char *)&buf[2] + 4) = v13;
      WORD2(buf[3]) = 2048;
      *(_QWORD *)((char *)&buf[3] + 6) = v47;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_227:
      v155 = 0;
      v166 = 0u;
      v167 = 0u;
      v164 = 0u;
      v165 = 0u;
      v163 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      LODWORD(buf[0]) = 136315906;
      *(_QWORD *)((char *)buf + 4) = "operator[]";
      WORD2(buf[1]) = 1024;
      *(_DWORD *)((char *)&buf[1] + 6) = 468;
      WORD1(buf[2]) = 2048;
      *(_QWORD *)((char *)&buf[2] + 4) = v13;
      WORD2(buf[3]) = 2048;
      *(_QWORD *)((char *)&buf[3] + 6) = CompositionChain;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_228;
    }
    v48 = v43;
    v49 = *(_QWORD *)(*(_QWORD *)(v40 + 136) + 8 * v43);
    v50 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v49 + 16))(v49);
    if (!v50)
    {
LABEL_27:
      v161 = 0;
      memset(v160, 0, 36);
      goto LABEL_28;
    }
    v51 = (const re::IntrospectionBase *)v50;
    if (!a4)
    {
      *((_QWORD *)&v165 + 1) = 0;
      v163 = 0u;
      v164 = 0u;
      LODWORD(v165) = 0;
      v64 = v156 >> 1;
      if ((v156 & 1) == 0)
        v64 = v156 >> 1;
      if (v64)
      {
        v65 = (v156 & 1) != 0 ? v157 : (char *)&v156 + 1;
        *(_QWORD *)&v163 = buf[0];
        re::DynamicArray<re::RigDataValue>::operator=((uint64_t)&v163 + 8, (uint64_t)&buf[1]);
        re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)&buf[1]);
        re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)&buf[1]);
        Alive = (re *)re::BindPoint::makeAlive((uint64_t)&v163);
        if (*((_QWORD *)&v164 + 1))
        {
          if ((const re::IntrospectionBase *)v163 == v51)
          {
            *(_QWORD *)v160 = v51;
            *(_QWORD *)&v160[8] = *((_QWORD *)&v163 + 1);
            *(_OWORD *)&v160[16] = v164;
            *((_QWORD *)&v163 + 1) = 0;
            v164 = 0uLL;
            v161 = *((_QWORD *)&v165 + 1);
            *((_QWORD *)&v165 + 1) = 0;
            LODWORD(v165) = v165 + 1;
            *(_DWORD *)&v160[32] = 1;
            goto LABEL_50;
          }
          v67 = *re::animationLogObjects(Alive);
          if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
          {
            v80 = (char *)&v156 + 1;
            if ((v156 & 1) != 0)
              v80 = v157;
            LODWORD(buf[0]) = 136315138;
            *(_QWORD *)((char *)buf + 4) = v80;
            _os_log_error_impl(&dword_224FE9000, v67, OS_LOG_TYPE_ERROR, "Failed to create bind point. Type mismatch for path: %s", (uint8_t *)buf, 0xCu);
          }
        }
      }
      v161 = 0;
      memset(v160, 0, 36);
LABEL_50:
      re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)&v163 + 8);
      re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)&v163 + 8);
      if (v155 && (v156 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v155 + 40))();
      goto LABEL_28;
    }
    if (*a4 != v50)
      goto LABEL_27;
    *(_QWORD *)v160 = v50;
    re::DynamicArray<re::BindPoint::BindPointData>::DynamicArray((uint64_t)&v160[8], a4 + 1);
LABEL_28:
    CompositionChain = *(unint64_t **)(v40 + 128);
    if (CompositionChain <= (unint64_t *)v13)
      goto LABEL_227;
    v53 = *(_QWORD *)(*(_QWORD *)(v40 + 136) + 8 * (_QWORD)v13);
    if ((*(unsigned int (**)(uint64_t, _BYTE *))(*(_QWORD *)v53 + 72))(v53, v160))
      break;
    v43 = (_DWORD)v13 + 1;
LABEL_84:
    re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)&v160[8]);
    v41 = re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)&v160[8]);
    if (v43 >= (int)v28)
    {
      v13 = v139;
      v39 = v148;
      if ((v26 & 1) == 0)
      {
        *((_QWORD *)&v163 + 1) = 0;
        v164 = 0uLL;
        re::DynamicString::setCapacity(&v163, 0);
        v83 = 0;
        v22 = (unint64_t)", ";
        do
        {
          v39 = v39 & 0xFFFFFFFF00000000 | v83;
          if (v83)
            re::DynamicString::append((re::DynamicString *)&v163, ", ", 2uLL);
          re::DynamicString::append((re::DynamicString *)&v163, "\"", 1uLL);
          v85 = buf[1];
          v84 = buf[2];
          if ((buf[1] & 1) != 0)
            v86 = (const char *)buf[2];
          else
            v86 = (char *)&buf[1] + 1;
          if ((buf[1] & 1) != 0)
            v87 = buf[1] >> 1;
          else
            v87 = LOBYTE(buf[1]) >> 1;
          re::DynamicString::append((re::DynamicString *)&v163, v86, v87);
          v88 = (re *)re::DynamicString::append((re::DynamicString *)&v163, "\"", 1uLL);
          if ((v85 & 1) != 0)
          {
            v88 = (re *)buf[0];
            if (buf[0])
              v88 = (re *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)buf[0] + 40))(buf[0], v84);
          }
          ++v83;
        }
        while (v28 != v83);
        v89 = *re::animationLogObjects(v88);
        if (os_log_type_enabled(v89, OS_LOG_TYPE_ERROR))
        {
          if ((BYTE8(v163) & 1) != 0)
            v131 = (char *)v164;
          else
            v131 = (char *)&v163 + 9;
          LODWORD(buf[0]) = 136315138;
          *(_QWORD *)((char *)buf + 4) = v131;
          _os_log_error_impl(&dword_224FE9000, v89, OS_LOG_TYPE_ERROR, "Cannot find a BindPoint for any bind path: %s", (uint8_t *)buf, 0xCu);
        }
        v41 = v163;
        v39 = v148;
        if ((_QWORD)v163 && (BYTE8(v163) & 1) != 0)
          v41 = (*(uint64_t (**)(void))(*(_QWORD *)v163 + 40))();
      }
      goto LABEL_111;
    }
  }
  CompositionChain = (unint64_t *)re::AnimationManager::getCompositionChain(v152, (const re::BindPoint *)v160);
  if (CompositionChain)
    goto LABEL_69;
  CompositionChain = *(unint64_t **)(v40 + 128);
  if (CompositionChain <= (unint64_t *)v13)
    goto LABEL_235;
  v54 = *(_QWORD *)(*(_QWORD *)(v40 + 136) + 8 * (_QWORD)v13);
  (*(void (**)(unint64_t *, _BYTE *))(*CompositionChain + 16))(CompositionChain, v160);
  v55 = (uint64_t)v146;
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::remove((uint64_t)v146, CompositionChain[12]);
  v56 = re::BindPoint::targetIdentifier((re::BindPoint *)(CompositionChain + 1));
  *(_QWORD *)&v163 = v56;
  if (!v56)
    goto LABEL_236;
  v58 = v56;
  buf[0] = CompositionChain;
  v59 = 0x94D049BB133111EBLL
      * ((0xBF58476D1CE4E5B9 * (v56 ^ (v56 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v56 ^ (v56 >> 30))) >> 27));
  v60 = v59 ^ (v59 >> 31);
  if (!*v146)
  {
    LODWORD(v61) = 0;
    goto LABEL_55;
  }
  v61 = v60 % *v137;
  v62 = *(unsigned int *)(*v136 + 4 * v61);
  if ((_DWORD)v62 == 0x7FFFFFFF)
  {
LABEL_55:
    re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::addAsMove(v55, v61, v60, &v163, buf);
    ++*v138;
    goto LABEL_56;
  }
  v63 = *v135;
  while (*(_QWORD *)(v63 + 32 * v62 + 16) != v56)
  {
    v62 = *(_DWORD *)(v63 + 32 * v62 + 8) & 0x7FFFFFFF;
    if ((_DWORD)v62 == 0x7FFFFFFF)
    {
      v55 = (uint64_t)v146;
      goto LABEL_55;
    }
  }
LABEL_56:
  CompositionChain[12] = v58;
  v68 = v149;
  v69 = *v149;
  v70 = *v141;
  if (*v149 >= *v141)
  {
    v71 = v69 + 1;
    if (v70 < v69 + 1)
    {
      if (*(_QWORD *)v134)
      {
        v72 = 2 * v70;
        v18 = v70 == 0;
        v73 = 8;
        if (!v18)
          v73 = v72;
        if (v73 <= v71)
          v74 = v71;
        else
          v74 = v73;
        re::DynamicArray<re::internal::AnimationHandoffBehavior *>::setCapacity(v134, v74);
      }
      else
      {
        re::DynamicArray<re::internal::AnimationHandoffBehavior *>::setCapacity(v134, v71);
        ++*v142;
      }
    }
    v68 = v149;
    v69 = *v149;
  }
  *(_QWORD *)(*v140 + 8 * v69) = CompositionChain;
  *v68 = v69 + 1;
  ++*v142;
LABEL_69:
  v26 = *(_QWORD *)(v40 + 152);
  if (v26 <= (unint64_t)v13)
    goto LABEL_231;
  *(_QWORD *)(*(_QWORD *)(v40 + 160) + 8 * (_QWORD)v13) = CompositionChain;
  CompositionChain = *(unint64_t **)(v40 + 128);
  if (CompositionChain <= (unint64_t *)v13)
    goto LABEL_232;
  if ((_BYTE)v163)
    v75 = DWORD1(v163);
  else
    v75 = 0;
  v43 = v75 + (_DWORD)v13;
  if (v75 < 1)
  {
LABEL_83:
    v26 = 1;
    goto LABEL_84;
  }
  v77 = *(_QWORD *)(v40 + 128);
  v76 = *(_QWORD *)(v40 + 136);
  if (v77 <= (unint64_t)v13)
    v78 = v13;
  else
    v78 = *(_anonymous_namespace_ **)(v40 + 128);
  while (v78 != v13)
  {
    v79 = *(_QWORD *)(v76 + 8 * (_QWORD)v13);
    if (*(_DWORD *)(v79 + 8) == 49 && *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(v79 + 136) + 80) + 496) != 255)
      *(_BYTE *)(v79 + 120) = 1;
    v13 = (_anonymous_namespace_ *)((char *)v13 + 1);
    if ((uint64_t)v13 >= v43)
      goto LABEL_83;
  }
  v155 = 0;
  v166 = 0u;
  v167 = 0u;
  v164 = 0u;
  v165 = 0u;
  v163 = 0u;
  os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
  LODWORD(buf[0]) = 136315906;
  *(_QWORD *)((char *)buf + 4) = "operator[]";
  WORD2(buf[1]) = 1024;
  *(_DWORD *)((char *)&buf[1] + 6) = 468;
  WORD1(buf[2]) = 2048;
  *(_QWORD *)((char *)&buf[2] + 4) = v78;
  WORD2(buf[3]) = 2048;
  *(_QWORD *)((char *)&buf[3] + 6) = v77;
  v133 = 38;
  v132 = buf;
  _os_log_send_and_compose_impl();
  _os_crash_msg();
  __break(1u);
LABEL_183:
  if (*(_BYTE *)(v39 + 8))
  {
    v117 = 0;
    goto LABEL_198;
  }
  v28 = v152;
  re::AnimationManager::removeExcept(v152, (re::internal::TimelineTree *)v40, 0);
LABEL_201:
  re::AnimationManager::destroyTimelineTree(v28, (re::internal::TimelineTree *)v40);
  return 0;
}

re::AnimationManager *re::AnimationManager::startAnimation(uint64_t a1, _anonymous_namespace_ *a2, _QWORD *a3, __int128 *a4, char a5, re::internal::TimelineTree *a6, _QWORD *a7)
{
  __int128 v8;
  uint64_t v9;

  v8 = *a4;
  v9 = *((_QWORD *)a4 + 2);
  return re::AnimationManager::startAnimation(a1, a2, 0, a3, (unint64_t)&v8, a5, a6, a7);
}

uint64_t re::DataArray<re::internal::TimelineTree>::get(uint64_t a1, int a2)
{
  if (*(_QWORD *)(a1 + 16) <= (unint64_t)HIWORD(a2))
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(*(_QWORD *)(a1 + 32) + 16 * HIWORD(a2)) + 216 * (unsigned __int16)a2;
}

void re::AnimationManager::destroyTimelineTree(re::AnimationManager *this, re::internal::TimelineTree *a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t (***v6)(_QWORD);
  _anonymous_namespace_ *v7;
  char *v8;
  unint64_t v9;

  if (*((_QWORD *)a2 + 16))
  {
    v4 = 0;
    do
    {
      v5 = *(_QWORD *)(*((_QWORD *)a2 + 17) + 8 * v4);
      if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v5 + 88))(v5))
      {
        if (*((_QWORD *)a2 + 16) <= v4)
        {
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_10:
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        v6 = *(uint64_t (****)(_QWORD))(*((_QWORD *)a2 + 17) + 8 * v4);
        v7 = (_anonymous_namespace_ *)(**v6)(v6);
        if (*((_QWORD *)a2 + 16) <= v4)
          goto LABEL_10;
      }
      ++v4;
    }
    while (v4 < *((_QWORD *)a2 + 16));
  }
  v8 = (char *)this + 64 * (uint64_t)*((char *)a2 + 184) + 72;
  v9 = re::DataArray<re::internal::TimelineTree>::handle((uint64_t)v8, (uint64_t)a2);
  re::DataArray<re::internal::TimelineTree>::destroy((uint64_t)v8, v9);
}

double re::AnimationManager::updateScheduler(re::AnimationManager *this)
{
  uint64_t v2;
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  BOOL v7;
  double result;
  unint64_t v9;
  int Bit;
  int v11;

  v2 = 0;
  v3 = *((unsigned __int8 *)this + 56);
  do
  {
    v4 = *(_DWORD *)((char *)this + v2 + 112);
    if (v4)
      break;
    v7 = v2 == 64;
    v2 += 64;
  }
  while (!v7);
  v5 = v4 != 0;
  *((_BYTE *)this + 56) = v5;
  v6 = *((_QWORD *)this + 5);
  v7 = v3 == v5 || v6 == 0;
  if (!v7)
    (*(void (**)(uint64_t, BOOL, _QWORD))(*(_QWORD *)v6 + 16))(v6, v4 != 0, *((_QWORD *)this + 6));
  v9 = *((_QWORD *)this + 4);
  if (v9 != -1)
  {
    Bit = re::DynamicBitset<unsigned long long,256ul>::getBit(*((_QWORD *)this + 1) + 128, v9);
    v11 = *((unsigned __int8 *)this + 56);
    if (v11 != Bit)
    {
      re::Scheduler::setEnabled(*((re::Scheduler **)this + 1), *((_QWORD *)this + 4), v11 != 0);
      if (*((_BYTE *)this + 56))
        return re::Scheduler::resetTaskCurrentTime(*((re::Scheduler **)this + 1), *((_QWORD *)this + 4));
    }
  }
  return result;
}

void re::AnimationManager::stopAnimation(re::AnimationManager *this, const re::BindNode *a2)
{
  re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Not supported. BindNode does not yet have a function to iterate over children.", "!\"Unreachable code\"", "stopAnimation", 538);
  _os_crash();
  __break(1u);
}

uint64_t re::AnimationManager::stopAnimation(re::AnimationManager *this, const re::BindPoint *a2)
{
  return re::AnimationManager::removeCompositionChainsForBindPoint(this, a2, 1);
}

uint64_t re::AnimationManager::removeCompositionChainsForBindPoint(re::AnimationManager *this, const re::BindPoint *a2, BOOL a3)
{
  uint64_t i;
  uint64_t v6;
  uint64_t v8;
  _BYTE v9[40];

  v8 = *(_QWORD *)a2;
  re::DynamicArray<re::BindPoint::BindPointData>::DynamicArray((uint64_t)v9, (uint64_t *)a2 + 1);
  for (i = re::AnimationManager::getCompositionChain(this, (const re::BindPoint *)&v8);
        i;
        i = re::AnimationManager::getCompositionChain(this, (const re::BindPoint *)&v8))
  {
    v6 = *(_QWORD *)(i + 72);
    if (!v6)
      break;
    re::AnimationManager::remove(this, *(re::internal::TimelineTree **)(*(_QWORD *)(i + 88) + 24 * v6 - 24), a3);
  }
  re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)v9);
  return re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)v9);
}

void re::AnimationManager::stopAllAnimations(re::AnimationManager *this)
{
  uint64_t v2;
  char v3;
  char v4;
  char *v5;
  uint64_t v6;
  uint64_t *v7;
  _QWORD *v8;

  v2 = 0;
  v3 = 1;
  do
  {
    v4 = v3;
    v5 = (char *)this + 40 * v2;
    v6 = *((_QWORD *)v5 + 49);
    if (v6)
    {
      v7 = (uint64_t *)(v5 + 392);
      v8 = (_QWORD *)((char *)this + 40 * v2 + 408);
      do
      {
        re::AnimationManager::removeCompositionChainsForBindPoint(this, (const re::BindPoint *)(*(_QWORD *)(*v8 + 8 * v6 - 8) + 8), 0);
        v6 = *v7;
      }
      while (*v7);
    }
    v3 = 0;
    v2 = 1;
  }
  while ((v4 & 1) != 0);
  re::AnimationManager::raiseAnimationEvents(this);
}

void re::AnimationManager::raiseAnimationEvents(re::AnimationManager *this)
{
  uint64_t v2;
  uint64_t v3;
  int *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;

  v2 = *((unsigned int *)this + 122);
  if ((_DWORD)v2)
  {
    v3 = 0;
    v4 = (int *)(*((_QWORD *)this + 59) + 8);
    while (1)
    {
      v5 = *v4;
      v4 += 6;
      if (v5 < 0)
        break;
      if (v2 == ++v3)
      {
        LODWORD(v3) = *((_DWORD *)this + 122);
        break;
      }
    }
  }
  else
  {
    LODWORD(v3) = 0;
  }
  if ((_DWORD)v2 != (_DWORD)v3)
  {
    v6 = v3;
    do
    {
      v7 = *(_QWORD *)(*((_QWORD *)this + 59) + 24 * v6 + 16);
      (*(void (**)(uint64_t))(*(_QWORD *)v7 + 48))(v7);
      if (*((_DWORD *)this + 122) <= (v3 + 1))
        v8 = v3 + 1;
      else
        v8 = *((_DWORD *)this + 122);
      v9 = v3;
      while (1)
      {
        v6 = (v9 + 1);
        if (v8 - 1 == v9)
          break;
        ++v9;
        LODWORD(v3) = v6;
        if ((*(_DWORD *)(*((_QWORD *)this + 59) + 24 * v6 + 8) & 0x80000000) != 0)
          goto LABEL_17;
      }
      LODWORD(v3) = v8;
LABEL_17:
      ;
    }
    while ((_DWORD)v2 != (_DWORD)v3);
  }
  re::HashSetBase<re::SharedPtr<re::AnimationEventDelegate>,re::SharedPtr<re::AnimationEventDelegate>,re::internal::ValueAsKey<re::SharedPtr<re::AnimationEventDelegate>>,re::Hash<re::SharedPtr<re::AnimationEventDelegate>>,re::EqualTo<re::SharedPtr<re::AnimationEventDelegate>>,true,false>::clear((uint64_t)this + 456);
}

const re::Timeline *`anonymous namespace'::setTimelines(_anonymous_namespace_ *this, re::internal::TimelineTree *a2, const re::Timeline *a3, unint64_t a4, const re::BindNode *a5)
{
  unint64_t v5;
  unint64_t v7;
  unint64_t v8;
  _OWORD *v11;
  __int128 v12;
  const re::Timeline *v13;
  _anonymous_namespace_ *v14;
  _anonymous_namespace_ *v15;
  _anonymous_namespace_ *i;
  re::internal::TimelineTree *v17;
  int v18;
  uint64_t v19;
  _OWORD v21[2];
  uint64_t v22;
  int v23;
  const char *v24;
  __int16 v25;
  int v26;
  __int16 v27;
  unint64_t v28;
  __int16 v29;
  unint64_t v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  uint64_t v36;

  v36 = *MEMORY[0x24BDAC8D0];
  v7 = (int)a3;
  v8 = *((_QWORD *)this + 1);
  if (v8 <= (int)a3)
  {
    *(_QWORD *)&v21[0] = 0;
    v34 = 0u;
    v35 = 0u;
    v32 = 0u;
    v33 = 0u;
    v31 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v23 = 136315906;
    v24 = "operator[]";
    v25 = 1024;
    v26 = 468;
    v27 = 2048;
    v28 = v7;
    v29 = 2048;
    v30 = v8;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_9;
  }
  v5 = a4;
  *(_DWORD *)(*((_QWORD *)this + 2) + 4 * (int)a3) = (_DWORD)a5;
  (*(void (**)(_OWORD *__return_ptr, re::internal::TimelineTree *))(*(_QWORD *)a2 + 48))(v21, a2);
  v8 = *((_QWORD *)this + 4);
  if (v8 <= v7)
  {
LABEL_9:
    v22 = 0;
    v34 = 0u;
    v35 = 0u;
    v32 = 0u;
    v33 = 0u;
    v31 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v23 = 136315906;
    v24 = "operator[]";
    v25 = 1024;
    v26 = 468;
    v27 = 2048;
    v28 = v7;
    v29 = 2048;
    v30 = v8;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_10;
  }
  v11 = (_OWORD *)(*((_QWORD *)this + 5) + 28 * (int)v7);
  v12 = v21[0];
  *(_OWORD *)((char *)v11 + 10) = *(_OWORD *)((char *)v21 + 10);
  *v11 = v12;
  v13 = (const re::Timeline *)((_DWORD)a3 + 1);
  v14 = (_anonymous_namespace_ *)(*(uint64_t (**)(re::internal::TimelineTree *))(*(_QWORD *)a2 + 24))(a2);
  if (v14)
  {
    v15 = v14;
    for (i = 0; i != v15; i = (_anonymous_namespace_ *)((char *)i + 1))
    {
      v17 = (re::internal::TimelineTree *)(*(uint64_t (**)(re::internal::TimelineTree *, _anonymous_namespace_ *))(*(_QWORD *)a2 + 32))(a2, i);
      v13 = v14;
    }
  }
  v5 = *((_QWORD *)this + 16);
  if (v5 <= v7)
  {
LABEL_10:
    *(_QWORD *)&v21[0] = 0;
    v34 = 0u;
    v35 = 0u;
    v32 = 0u;
    v33 = 0u;
    v31 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v23 = 136315906;
    v24 = "operator[]";
    v25 = 1024;
    v26 = 468;
    v27 = 2048;
    v28 = v7;
    v29 = 2048;
    v30 = v5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  *(_QWORD *)(*((_QWORD *)this + 17) + 8 * v7) = v19;
  return v13;
}

void re::DataArray<re::internal::TimelineTree>::destroy(uint64_t a1, unint64_t a2)
{
  int v2;
  unint64_t v4;
  re::internal::TimelineTree *v5;
  _DWORD *v6;

  v2 = a2;
  v4 = a2 >> 16;
  v5 = (re::internal::TimelineTree *)re::DataArray<re::internal::TimelineTree>::tryGet(a1, a2 & 0xFFFFFFFF00000000 | ((unint64_t)WORD1(a2) << 16) | (unsigned __int16)a2);
  if (v5)
  {
    re::internal::TimelineTree::~TimelineTree(v5);
    if (*(_QWORD *)(a1 + 16) <= (unint64_t)HIWORD(v2))
    {
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 16 * HIWORD(v2) + 8) + 4 * (unsigned __int16)v2) = 0;
    *v6 = *(_DWORD *)(a1 + 52);
    *(_WORD *)(a1 + 52) = v2;
    *(_WORD *)(a1 + 54) = v4;
    --*(_DWORD *)(a1 + 40);
  }
}

unint64_t re::DataArray<re::internal::TimelineTree>::handle(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t result;

  v2 = *(_QWORD *)(a1 + 16);
  if (v2)
  {
    v3 = 0;
    v4 = 0;
    v5 = (_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    while (v4 != 0x10000)
    {
      v6 = a2 - *(v5 - 1);
      if (v6 >= -215)
      {
        v7 = 0x84BDA12F684BDA13 * (v6 >> 3);
        if (v7 < *(unsigned int *)(a1 + 44))
          goto LABEL_8;
      }
      ++v4;
      v5 += 2;
      v3 += 0x10000;
      if (v2 == v4)
        goto LABEL_7;
    }
    re::internal::assertLog((re::internal *)5, a2, "assertion failure: '%s' (%s:line %i) blockIndex (%zu) is too large for a 16-bit unsigned integer", "!overflow", "handle", 692, 0x10000);
    _os_crash();
    __break(1u);
  }
  else
  {
LABEL_7:
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) element isn't in data array", "!\"Unreachable code\"", "handle", 707);
    _os_crash();
    __break(1u);
LABEL_8:
    if (v7 < 0x10000)
      return v3 & 0xFFFF0000 | ((unint64_t)(*(_DWORD *)(*v5 + 4 * v7) & 0xFFFFFF) << 32) | v7;
  }
  re::internal::assertLog((re::internal *)5, a2, "assertion failure: '%s' (%s:line %i) arrayIndex (%zu) is too large for a 16-bit unsigned integer", "!overflow", "handle", 700, v7);
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::AnimationManager::getCompositionChain(re::AnimationManager *this, const re::BindPoint *a2)
{
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  char i;
  char v9;
  uint64_t v10;
  uint64_t v11;

  re::AnimationManager::updateLookupTableForAllBuckets(this);
  v4 = re::BindPoint::targetIdentifier(a2);
  v5 = 0;
  v6 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (v4 ^ (v4 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v4 ^ (v4 >> 30))) >> 27));
  v7 = v6 ^ (v6 >> 31);
  for (i = 1; ; i = 0)
  {
    v9 = i;
    if (*((_QWORD *)this + 6 * v5 + 35))
    {
      v10 = *(unsigned int *)(*((_QWORD *)this + 6 * v5 + 36) + 4 * (v7 % *((unsigned int *)this + 12 * v5 + 76)));
      if ((_DWORD)v10 != 0x7FFFFFFF)
        break;
    }
LABEL_7:
    v5 = 1;
    if ((v9 & 1) == 0)
      return 0;
  }
  v11 = *((_QWORD *)this + 6 * v5 + 37);
  while (*(_QWORD *)(v11 + 32 * v10 + 16) != v4)
  {
    v10 = *(_DWORD *)(v11 + 32 * v10 + 8) & 0x7FFFFFFF;
    if ((_DWORD)v10 == 0x7FFFFFFF)
      goto LABEL_7;
  }
  return *(_QWORD *)(v11 + 32 * v10 + 24);
}

_QWORD *`anonymous namespace'::getBindPath(_anonymous_namespace_ *a1, _QWORD *a2, int a3)
{
  unint64_t v3;
  _anonymous_namespace_ *v6;
  _QWORD *result;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  size_t v11;
  size_t v12;
  size_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  const char *v17;
  size_t v18;

  LODWORD(v3) = a3;
  *((_QWORD *)a1 + 1) = 0;
  *((_QWORD *)a1 + 2) = 0;
  *((_QWORD *)a1 + 3) = 0;
  v6 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(a1, 0);
  result = re::DynamicString::setCapacity(a1, 0x80uLL);
  if ((v3 & 0x80000000) == 0)
  {
    v3 = v3;
    while (a2[16] > v3)
    {
      v8 = *(_QWORD *)(a2[17] + 8 * v3);
      v9 = *(_QWORD *)(v8 + 48);
      v10 = v9 & 1;
      v11 = v9 >> 1;
      v12 = v9 >> 1;
      if ((*(_QWORD *)(v8 + 48) & 1) != 0)
        v13 = v11;
      else
        v13 = v12;
      if (v13)
      {
        v14 = *((_QWORD *)a1 + 1);
        if ((v14 & 1) != 0)
          v15 = v14 >> 1;
        else
          v15 = v14 >> 1;
        if (v15)
        {
          re::DynamicString::insert(a1, 0, 1, 46);
          v16 = *(_QWORD *)(v8 + 48);
          v10 = v16 & 1;
          v11 = v16 >> 1;
          v12 = v16 >> 1;
        }
        if (v10)
          v17 = *(const char **)(v8 + 56);
        else
          v17 = (const char *)(v8 + 49);
        if (v10)
          v18 = v11;
        else
          v18 = v12;
        result = (_QWORD *)re::DynamicString::insert(a1, 0, v17, v18);
      }
      if (a2[1] <= v3)
        goto LABEL_24;
      v3 = *(unsigned int *)(a2[2] + 4 * v3);
      if ((v3 & 0x80000000) != 0)
        return result;
    }
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_24:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return result;
}

uint64_t re::DataArray<re::internal::TimelineTree>::tryGet(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unsigned int v3;
  uint64_t v4;
  int v5;
  BOOL v6;

  v2 = *(_QWORD *)(a1 + 16);
  if (WORD1(a2) < v2
    && ((unsigned __int16)(v2 - 1) != WORD1(a2) ? (v3 = *(_DWORD *)(a1 + 44)) : (v3 = *(_DWORD *)(a1 + 48)),
        (unsigned __int16)a2 < v3
     && ((v4 = *(_QWORD *)(a1 + 32),
          (v5 = *(_DWORD *)(*(_QWORD *)(v4 + 16 * WORD1(a2) + 8) + 4 * (unsigned __int16)a2)) != 0)
       ? (v6 = v5 == (HIDWORD(a2) & 0xFFFFFF))
       : (v6 = 0),
         v6)))
  {
    return *(_QWORD *)(v4 + 16 * WORD1(a2)) + 216 * (unsigned __int16)a2;
  }
  else
  {
    return 0;
  }
}

uint64_t re::AnimationManager::addFadeOutHandoffBehavior(_anonymous_namespace_ *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v8;

  v8 = re::internal::AnimationHandoffBehavior::AnimationHandoffBehavior(v6, a1, a2, a3);
  re::DynamicArray<re::internal::AnimationHandoffBehavior *>::add((_QWORD *)a1 + 5 * *(char *)(a2 + 184) + 25, &v8);
  return v8;
}

double re::AnimationManager::removeLayerExcept(re::AnimationManager *a1, _QWORD *a2, _BYTE *a3, uint64_t a4)
{
  re::AnimationManager *v4;
  unint64_t v5;
  unint64_t v8;
  uint64_t v9;
  uint64_t v11;
  int *v12;
  unint64_t v13;
  int v14;
  unint64_t v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;
  int *v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int v23;
  int v24;
  int *v27;
  __int128 v28;
  __int128 v29;
  unsigned int v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  const char *v34;
  __int16 v35;
  int v36;
  __int16 v37;
  unint64_t v38;
  __int16 v39;
  unint64_t v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  uint64_t v46;

  v4 = a1;
  v46 = *MEMORY[0x24BDAC8D0];
  v30 = 0;
  v28 = 0u;
  v29 = 0u;
  v31 = 0x7FFFFFFFLL;
  v5 = a2[19];
  if (!v5)
  {
    v17 = 0;
    LODWORD(v18) = 0;
    goto LABEL_25;
  }
  v8 = 0;
  v27 = (int *)(a3 + 4);
  v9 = a4 + 168;
  do
  {
    v11 = *(_QWORD *)(a2[20] + 8 * v8);
    if (!v11)
      goto LABEL_17;
    v12 = v27;
    if (!*a3)
    {
      v13 = a2[16];
      if (v13 <= v8)
        goto LABEL_38;
      v12 = (int *)(*(_QWORD *)(a2[17] + 8 * v8) + 12);
    }
    LODWORD(v13) = *(_DWORD *)(v11 + 72);
    if ((int)v13 - 1 < 0)
      goto LABEL_17;
    v14 = *v12;
    do
    {
      v13 = (v13 - 1);
      v15 = *(_QWORD *)(v11 + 72);
      if (v15 <= v13)
      {
        v32 = 0;
        v44 = 0u;
        v45 = 0u;
        v42 = 0u;
        v43 = 0u;
        v41 = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        v33 = 136315906;
        v34 = "operator[]";
        v35 = 1024;
        v36 = 789;
        v37 = 2048;
        v38 = v13;
        v39 = 2048;
        v40 = v15;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_38:
        v32 = 0;
        v44 = 0u;
        v45 = 0u;
        v42 = 0u;
        v43 = 0u;
        v41 = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        v33 = 136315906;
        v34 = "operator[]";
        v35 = 1024;
        v36 = 468;
        v37 = 2048;
        v38 = v8;
        v39 = 2048;
        v40 = v13;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      v16 = *(_QWORD *)(v11 + 88) + 24 * v13;
      if (*(_DWORD *)(v16 + 16) == v14 && *(_QWORD **)v16 != a2)
      {
        if (a4)
        {
          *(_QWORD *)&v41 = *(_QWORD *)v16;
          re::DynamicOverflowArray<re::internal::TimelineTree const*,4ul>::add(v9, &v41);
        }
        else
        {
          re::HashSetBase<re::internal::TimelineTree *,re::internal::TimelineTree *,re::internal::ValueAsKey<re::internal::TimelineTree *>,re::Hash<re::internal::TimelineTree *>,re::EqualTo<re::internal::TimelineTree *>,true,false>::add((uint64_t)&v28, (uint64_t *)v16);
        }
      }
    }
    while ((int)v13 > 0);
    v5 = a2[19];
LABEL_17:
    ++v8;
  }
  while (v5 > v8);
  v17 = v30;
  if (v30)
  {
    v18 = 0;
    v19 = (int *)(v29 + 8);
    v4 = a1;
    while (1)
    {
      v20 = *v19;
      v19 += 6;
      if (v20 < 0)
        break;
      if (v30 == ++v18)
      {
        LODWORD(v18) = v30;
        break;
      }
    }
  }
  else
  {
    LODWORD(v18) = 0;
    v4 = a1;
  }
LABEL_25:
  if (v17 != (_DWORD)v18)
  {
    v21 = v18;
    v22 = v29;
    do
    {
      re::AnimationManager::remove(v4, *(re::internal::TimelineTree **)(v22 + 24 * v21 + 16), 1);
      if (v30 <= (int)v18 + 1)
        v23 = v18 + 1;
      else
        v23 = v30;
      v24 = v18;
      while (1)
      {
        v21 = (v24 + 1);
        if (v23 - 1 == v24)
          break;
        ++v24;
        LODWORD(v18) = v21;
        if ((*(_DWORD *)(v22 + 24 * v21 + 8) & 0x80000000) != 0)
          goto LABEL_35;
      }
      LODWORD(v18) = v23;
LABEL_35:
      ;
    }
    while (v17 != (_DWORD)v18);
  }
  return re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v28);
}

double re::AnimationManager::removeExcept(re::AnimationManager *this, re::internal::TimelineTree *a2, re::internal::AnimationHandoffBehavior *a3)
{
  unint64_t v4;
  unint64_t v7;
  char *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t *v12;
  unsigned int v13;
  uint64_t v14;
  int *v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  int v20;
  __int128 v22;
  __int128 v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  const char *v28;
  __int16 v29;
  int v30;
  __int16 v31;
  unint64_t v32;
  __int16 v33;
  unint64_t v34;
  _OWORD v35[5];
  uint64_t v36;

  v36 = *MEMORY[0x24BDAC8D0];
  v24 = 0;
  v22 = 0u;
  v23 = 0u;
  v25 = 0x7FFFFFFFLL;
  v4 = *((_QWORD *)a2 + 19);
  if (!v4)
  {
    v13 = 0;
LABEL_19:
    LODWORD(v14) = 0;
    goto LABEL_20;
  }
  v7 = 0;
  v8 = (char *)a3 + 168;
  do
  {
    v9 = *(_QWORD *)(*((_QWORD *)a2 + 20) + 8 * v7);
    if (v9)
    {
      LODWORD(v10) = *(_DWORD *)(v9 + 72);
      if ((int)v10 - 1 >= 0)
      {
        do
        {
          v10 = (v10 - 1);
          v11 = *(_QWORD *)(v9 + 72);
          if (v11 <= v10)
          {
            v26 = 0;
            memset(v35, 0, sizeof(v35));
            os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
            v27 = 136315906;
            v28 = "operator[]";
            v29 = 1024;
            v30 = 789;
            v31 = 2048;
            v32 = v10;
            v33 = 2048;
            v34 = v11;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
          }
          v12 = (uint64_t *)(*(_QWORD *)(v9 + 88) + 24 * v10);
          if ((re::internal::TimelineTree *)*v12 != a2)
          {
            if (a3)
            {
              *(_QWORD *)&v35[0] = *v12;
              re::DynamicOverflowArray<re::internal::TimelineTree const*,4ul>::add((uint64_t)v8, v35);
            }
            else
            {
              re::HashSetBase<re::internal::TimelineTree *,re::internal::TimelineTree *,re::internal::ValueAsKey<re::internal::TimelineTree *>,re::Hash<re::internal::TimelineTree *>,re::EqualTo<re::internal::TimelineTree *>,true,false>::add((uint64_t)&v22, v12);
            }
          }
        }
        while ((int)v10 > 0);
        v4 = *((_QWORD *)a2 + 19);
      }
    }
    ++v7;
  }
  while (v4 > v7);
  v13 = v24;
  if (!v24)
    goto LABEL_19;
  v14 = 0;
  v15 = (int *)(v23 + 8);
  while (1)
  {
    v16 = *v15;
    v15 += 6;
    if (v16 < 0)
      break;
    if (v24 == ++v14)
    {
      LODWORD(v14) = v24;
      break;
    }
  }
LABEL_20:
  if (v13 != (_DWORD)v14)
  {
    v17 = v14;
    v18 = v23;
    do
    {
      re::AnimationManager::remove(this, *(re::internal::TimelineTree **)(v18 + 24 * v17 + 16), 1);
      if (v24 <= (int)v14 + 1)
        v19 = v14 + 1;
      else
        v19 = v24;
      v20 = v14;
      while (1)
      {
        v17 = (v20 + 1);
        if (v19 - 1 == v20)
          break;
        ++v20;
        LODWORD(v14) = v17;
        if ((*(_DWORD *)(v18 + 24 * v17 + 8) & 0x80000000) != 0)
          goto LABEL_30;
      }
      LODWORD(v14) = v19;
LABEL_30:
      ;
    }
    while (v13 != (_DWORD)v14);
  }
  return re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v22);
}

double re::AnimationManager::remove(re::AnimationManager *this, re::internal::TimelineTree *a2, int a3)
{
  char v5;
  char *v6;
  uint64_t v7;
  re::internal::TimelineTree ***v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t i;
  uint64_t v17;
  unint64_t j;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  double v25;
  _anonymous_namespace_ *v26;
  uint64_t v27;
  char v28;
  char v29;
  char *v30;
  char *v31;
  uint64_t v32;
  unint64_t *v33;
  _QWORD *v34;
  uint64_t v35;
  unint64_t v36;
  _QWORD *v37;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  uint64_t v45;

  v45 = *MEMORY[0x24BDAC8D0];
  v5 = *((_BYTE *)a2 + 184);
  v6 = (char *)this + 40 * v5;
  v7 = *((_QWORD *)v6 + 27);
  if (v7)
  {
    v8 = (re::internal::TimelineTree ***)*((_QWORD *)v6 + 29);
    v9 = 8 * v7;
    do
    {
      if (**v8 == a2)
        **v8 = 0;
      ++v8;
      v9 -= 8;
    }
    while (v9);
  }
  if (!*((_BYTE *)this + 504))
    re::AnimationManager::cleanUpHandoffBehaviors(this, v5);
  v10 = *((_QWORD *)a2 + 19);
  if (v10)
  {
    v11 = 0;
    v12 = 0;
    while (*((_QWORD *)a2 + 10) > v12)
    {
      if (*(_BYTE *)(*((_QWORD *)a2 + 11) + v11))
      {
        v13 = *((char *)a2 + 184);
        v14 = re::DataArray<re::internal::TimelineTree>::handle((uint64_t)this + 64 * v13 + 72, (uint64_t)a2);
        re::AnimationManager::blendFactorAsBindPoint(this, v14 & 0xFFFFFFFFFFFFFFLL | ((unint64_t)v13 << 56), v12, (uint64_t)&v40);
        re::AnimationManager::removeCompositionChainsForBindPoint(this, (const re::BindPoint *)&v40, 1);
        re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)&v40 + 8);
        re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)&v40 + 8);
        v10 = *((_QWORD *)a2 + 19);
      }
      ++v12;
      v11 += 12;
      if (v10 <= v12)
        goto LABEL_14;
    }
LABEL_48:
    v43 = 0u;
    v44 = 0u;
    v41 = 0u;
    v42 = 0u;
    v40 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_49:
    v43 = 0u;
    v44 = 0u;
    v41 = 0u;
    v42 = 0u;
    v40 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_50:
    v43 = 0u;
    v44 = 0u;
    v41 = 0u;
    v42 = 0u;
    v40 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    while (1)
    {
LABEL_51:
      v43 = 0u;
      v44 = 0u;
      v41 = 0u;
      v42 = 0u;
      v40 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
LABEL_14:
  v15 = *((_QWORD *)a2 + 4);
  if (v15)
  {
    for (i = 0; i < v15; ++i)
    {
      if (*((_QWORD *)a2 + 16) <= i)
        goto LABEL_49;
      v17 = *(_QWORD *)(*((_QWORD *)a2 + 17) + 8 * i);
      if (*(_DWORD *)(v17 + 8) == 49)
      {
        re::TypedEventTimelineInstance<float>::timelineRemoved(v17);
        v15 = *((_QWORD *)a2 + 4);
      }
    }
    v10 = *((_QWORD *)a2 + 19);
  }
  if (v10)
  {
    for (j = 0; v10 > j; ++j)
    {
      v19 = *(_QWORD *)(*((_QWORD *)a2 + 20) + 8 * j);
      if (v19)
      {
        (*(void (**)(uint64_t))(*(_QWORD *)v19 + 64))(v19);
        v20 = *(_QWORD *)(v19 + 72);
        if (!v20)
          goto LABEL_51;
        v21 = 0;
        v22 = 0;
        v23 = *(_QWORD *)(v19 + 88);
        while (*(re::internal::TimelineTree **)(v23 + v21) != a2 || j != *(_DWORD *)(v23 + v21 + 8))
        {
          ++v22;
          v21 += 24;
          if (v20 == v22)
            goto LABEL_51;
        }
        if (v20 <= v22)
          goto LABEL_51;
        v24 = v20 - 1;
        if (v20 - 1 > v22 && 24 * v20 - 24 != v21)
        {
          memmove((void *)(*(_QWORD *)(v19 + 88) + v21), (const void *)(*(_QWORD *)(v19 + 88) + v21 + 24), 24 * v20 - v21 - 27);
          v24 = *(_QWORD *)(v19 + 72) - 1;
        }
        *(_QWORD *)(v19 + 72) = v24;
        ++*(_DWORD *)(v19 + 80);
        v10 = *((_QWORD *)a2 + 19);
        if (v10 <= j)
          goto LABEL_50;
        *(_QWORD *)(*((_QWORD *)a2 + 20) + 8 * j) = 0;
      }
    }
  }
  v25 = re::internal::TimelineTree::currentTime(a2);
  re::AnimationManager::addAnimationEvent((uint64_t)this, 4, (uint64_t)a2, a3, v25);
  if (!*((_BYTE *)this + 504))
  {
    re::AnimationManager::updateLookupTableForAllBuckets(this);
    v27 = 0;
    v28 = 1;
    while (1)
    {
      v29 = v28;
      v30 = (char *)this + 40 * v27;
      if ((int)*((_QWORD *)v30 + 49) >= 1)
        break;
LABEL_45:
      v28 = 0;
      v27 = 1;
      if ((v29 & 1) == 0)
        goto LABEL_46;
    }
    v31 = (char *)this + 48 * v27 + 280;
    v32 = (uint64_t)(v30 + 376);
    v33 = (unint64_t *)(v30 + 392);
    v34 = (_QWORD *)((char *)this + 40 * v27 + 408);
    v35 = *((_QWORD *)v30 + 49) + 1;
    while (1)
    {
      v36 = (v35 - 2);
      if (*v33 <= v36)
        break;
      v37 = *(_QWORD **)(*v34 + 8 * v36);
      if (!v37[9])
      {
        (*(void (**)(_QWORD))(*v37 + 40))(*(_QWORD *)(*v34 + 8 * v36));
        re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::remove((uint64_t)v31, v37[12]);
        v37[12] = 0;
        re::DynamicArray<re::internal::AnimationCompositionChainBase *>::removeAt(v32, (v35 - 2));
        (*(void (**)(_QWORD *))*v37)(v37);
      }
      if ((unint64_t)--v35 <= 1)
        goto LABEL_45;
    }
    v43 = 0u;
    v44 = 0u;
    v41 = 0u;
    v42 = 0u;
    v40 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_48;
  }
LABEL_46:
  re::AnimationManager::destroyTimelineTree(this, a2);
  return re::AnimationManager::updateScheduler(this);
}

void re::AnimationManager::addAnimationEvent(uint64_t a1, uint64_t a2, uint64_t a3, int a4, double a5)
{
  char *WeakRetained;
  char *v11;
  char *v12;
  void *v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  int v24;
  id v25;
  _QWORD v26[3];
  int v27;
  const char *v28;
  __int16 v29;
  int v30;
  __int16 v31;
  uint64_t v32;
  __int16 v33;
  uint64_t v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  uint64_t v40;

  v40 = *MEMORY[0x24BDAC8D0];
  WeakRetained = (char *)objc_loadWeakRetained((id *)(a3 + 176));
  v11 = WeakRetained - 8;
  if (WeakRetained)
    v12 = WeakRetained - 8;
  else
    v12 = 0;
  if (WeakRetained)
  {
    v13 = WeakRetained;
    v14 = re::DataArray<re::internal::TimelineTree>::handle(a1 + ((uint64_t)*(char *)(a3 + 184) << 6) + 72, a3) & 0xFFFFFFFFFFFFFFLL | ((unint64_t)*(unsigned __int8 *)(a3 + 184) << 56);
    v26[0] = a1;
    v26[1] = v14;
    if (!*(_QWORD *)(a3 + 56))
    {
      v26[2] = 0;
      v38 = 0u;
      v39 = 0u;
      v36 = 0u;
      v37 = 0u;
      v35 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v27 = 136315906;
      v28 = "operator[]";
      v29 = 1024;
      v30 = 476;
      v31 = 2048;
      v32 = 0;
      v33 = 2048;
      v34 = 0;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    (*(void (**)(char *, uint64_t, _QWORD *, _QWORD, double))(*(_QWORD *)v11 + 32))(v11, a2, v26, *(_QWORD *)(a3 + 64), a5);
    if (a4)
    {
      (*(void (**)(char *))(*(_QWORD *)v11 + 48))(v11);
LABEL_8:
      v12 = v11;
LABEL_22:

      return;
    }
    v15 = 0x94D049BB133111EBLL
        * ((0xBF58476D1CE4E5B9 * ((unint64_t)v11 ^ ((unint64_t)v11 >> 30))) ^ ((0xBF58476D1CE4E5B9
                                                                                              * ((unint64_t)v11 ^ ((unint64_t)v11 >> 30))) >> 27));
    v16 = v15 ^ (v15 >> 31);
    v17 = *(unsigned int *)(a1 + 480);
    if ((_DWORD)v17)
    {
      v18 = v16 % v17;
      v19 = *(unsigned int *)(*(_QWORD *)(a1 + 464) + 4 * (v16 % v17));
      if ((_DWORD)v19 != 0x7FFFFFFF)
      {
        v20 = *(_QWORD *)(a1 + 472);
        if (*(char **)(v20 + 24 * v19 + 16) == v11)
          goto LABEL_8;
        while (1)
        {
          LODWORD(v19) = *(_DWORD *)(v20 + 24 * v19 + 8) & 0x7FFFFFFF;
          if ((_DWORD)v19 == 0x7FFFFFFF)
            break;
          if (*(char **)(v20 + 24 * v19 + 16) == v12)
            goto LABEL_22;
        }
      }
    }
    else
    {
      LODWORD(v18) = 0;
    }
    v21 = *(unsigned int *)(a1 + 492);
    if ((_DWORD)v21 == 0x7FFFFFFF)
    {
      v21 = *(unsigned int *)(a1 + 488);
      v22 = v21;
      if ((_DWORD)v21 == (_DWORD)v17)
      {
        re::HashSetBase<re::SharedPtr<re::AnimationEventDelegate>,re::SharedPtr<re::AnimationEventDelegate>,re::internal::ValueAsKey<re::SharedPtr<re::AnimationEventDelegate>>,re::Hash<re::SharedPtr<re::AnimationEventDelegate>>,re::EqualTo<re::SharedPtr<re::AnimationEventDelegate>>,true,false>::setCapacity(a1 + 456, 2 * *(_DWORD *)(a1 + 484));
        LODWORD(v18) = v16 % *(unsigned int *)(a1 + 480);
        v22 = *(_DWORD *)(a1 + 488);
      }
      *(_DWORD *)(a1 + 488) = v22 + 1;
      v23 = *(_QWORD *)(a1 + 472);
      v24 = *(_DWORD *)(v23 + 24 * v21 + 8);
    }
    else
    {
      v23 = *(_QWORD *)(a1 + 472);
      v24 = *(_DWORD *)(v23 + 24 * v21 + 8);
      *(_DWORD *)(a1 + 492) = v24 & 0x7FFFFFFF;
    }
    *(_DWORD *)(v23 + 24 * v21 + 8) = v24 | 0x80000000;
    *(_DWORD *)(*(_QWORD *)(a1 + 472) + 24 * v21 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 472) + 24 * v21 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 464) + 4 * v18);
    *(_QWORD *)(*(_QWORD *)(a1 + 472) + 24 * v21) = v16;
    *(_QWORD *)(*(_QWORD *)(a1 + 472) + 24 * v21 + 16) = v12;
    v25 = v13;
    *(_DWORD *)(*(_QWORD *)(a1 + 464) + 4 * v18) = v21;
    ++*(_DWORD *)(a1 + 484);
    ++*(_DWORD *)(a1 + 496);
    goto LABEL_22;
  }
}

uint64_t re::DynamicArray<re::internal::AnimationCompositionChainBase *>::removeAt(uint64_t result, unint64_t a2)
{
  unint64_t v2;

  v2 = *(_QWORD *)(result + 16);
  if (v2 <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (v2 - 1 > a2)
    *(_QWORD *)(*(_QWORD *)(result + 32) + 8 * a2) = *(_QWORD *)(*(_QWORD *)(result + 32) + 8 * v2 - 8);
  *(_QWORD *)(result + 16) = v2 - 1;
  ++*(_DWORD *)(result + 24);
  return result;
}

uint64_t re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::remove(uint64_t result, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int *v13;
  int v14;
  int v15;

  if (*(_QWORD *)result)
  {
    v2 = 0x94D049BB133111EBLL
       * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
    v3 = (v2 ^ (v2 >> 31)) % *(unsigned int *)(result + 24);
    v4 = *(_QWORD *)(result + 8);
    v5 = *(unsigned int *)(v4 + 4 * v3);
    if ((_DWORD)v5 != 0x7FFFFFFF)
    {
      v6 = *(_QWORD *)(result + 16);
      v7 = v6 + 32 * v5;
      if (*(_QWORD *)(v7 + 16) == a2)
      {
        *(_DWORD *)(v4 + 4 * v3) = *(_DWORD *)(v7 + 8) & 0x7FFFFFFF;
LABEL_8:
        v10 = *(_QWORD *)(result + 16);
        v11 = v10 + 32 * v5;
        v14 = *(_DWORD *)(v11 + 8);
        v13 = (int *)(v11 + 8);
        v12 = v14;
        if (v14 < 0)
        {
          *v13 = v12 & 0x7FFFFFFF;
          v10 = *(_QWORD *)(result + 16);
          v12 = *(_DWORD *)(v10 + 32 * v5 + 8);
        }
        v15 = *(_DWORD *)(result + 40);
        *(_DWORD *)(v10 + 32 * v5 + 8) = *(_DWORD *)(result + 36) | v12 & 0x80000000;
        --*(_DWORD *)(result + 28);
        *(_DWORD *)(result + 36) = v5;
        *(_DWORD *)(result + 40) = v15 + 1;
      }
      else
      {
        while (1)
        {
          v8 = v5;
          v5 = *(_DWORD *)(v6 + 32 * v5 + 8) & 0x7FFFFFFF;
          if ((_DWORD)v5 == 0x7FFFFFFF)
            break;
          v9 = v6 + 32 * v5;
          if (*(_QWORD *)(v9 + 16) == a2)
          {
            *(_DWORD *)(v6 + 32 * v8 + 8) = *(_DWORD *)(v6 + 32 * v8 + 8) & 0x80000000 | *(_DWORD *)(v9 + 8) & 0x7FFFFFFF;
            goto LABEL_8;
          }
        }
      }
    }
  }
  return result;
}

void re::HashSetBase<re::internal::TimelineTree *,re::internal::TimelineTree *,re::internal::ValueAsKey<re::internal::TimelineTree *>,re::Hash<re::internal::TimelineTree *>,re::EqualTo<re::internal::TimelineTree *>,true,false>::add(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  int v14;

  v4 = *a2;
  v5 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v6 = (0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) ^ ((0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) >> 31);
  v7 = *(unsigned int *)(a1 + 24);
  if ((_DWORD)v7)
  {
    v8 = v6 % v7;
    v9 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * (v6 % v7));
    if ((_DWORD)v9 != 0x7FFFFFFF)
    {
      v10 = *(_QWORD *)(a1 + 16);
      if (*(_QWORD *)(v10 + 24 * v9 + 16) == v4)
        return;
      while (1)
      {
        LODWORD(v9) = *(_DWORD *)(v10 + 24 * v9 + 8) & 0x7FFFFFFF;
        if ((_DWORD)v9 == 0x7FFFFFFF)
          break;
        if (*(_QWORD *)(v10 + 24 * v9 + 16) == v4)
          return;
      }
    }
  }
  else
  {
    LODWORD(v8) = 0;
  }
  v11 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v11 == 0x7FFFFFFF)
  {
    v11 = *(unsigned int *)(a1 + 32);
    v12 = v11;
    if ((_DWORD)v11 == (_DWORD)v7)
    {
      re::HashSetBase<re::internal::TimelineTree *,re::internal::TimelineTree *,re::internal::ValueAsKey<re::internal::TimelineTree *>,re::Hash<re::internal::TimelineTree *>,re::EqualTo<re::internal::TimelineTree *>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      LODWORD(v8) = v6 % *(unsigned int *)(a1 + 24);
      v12 = *(_DWORD *)(a1 + 32);
      v4 = *a2;
    }
    *(_DWORD *)(a1 + 32) = v12 + 1;
    v13 = *(_QWORD *)(a1 + 16);
    v14 = *(_DWORD *)(v13 + 24 * v11 + 8);
  }
  else
  {
    v13 = *(_QWORD *)(a1 + 16);
    v14 = *(_DWORD *)(v13 + 24 * v11 + 8);
    *(_DWORD *)(a1 + 36) = v14 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v13 + 24 * v11 + 8) = v14 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v11 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v11 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * v8);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v11) = v6;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v11 + 16) = v4;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * v8) = v11;
  ++*(_DWORD *)(a1 + 28);
  ++*(_DWORD *)(a1 + 40);
}

double re::AnimationManager::removePending(re::AnimationManager *this, re::internal::TimelineTree *a2, const re::internal::AnimationHandoffBehavior *a3)
{
  unint64_t v4;
  unint64_t v7;
  char *v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  unint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;
  int *v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int v23;
  int v24;
  __int128 v26;
  __int128 v27;
  unsigned int v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  const char *v32;
  __int16 v33;
  int v34;
  __int16 v35;
  uint64_t v36;
  __int16 v37;
  unint64_t v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  uint64_t v44;

  v44 = *MEMORY[0x24BDAC8D0];
  v28 = 0;
  v26 = 0u;
  v27 = 0u;
  v29 = 0x7FFFFFFFLL;
  v4 = *((_QWORD *)a2 + 19);
  if (!v4)
  {
    v17 = 0;
LABEL_23:
    LODWORD(v18) = 0;
    goto LABEL_24;
  }
  v7 = 0;
  v8 = (char *)a3 + 192;
  do
  {
    v9 = *(_QWORD *)(*((_QWORD *)a2 + 20) + 8 * v7);
    if (v9)
    {
      v10 = *(_DWORD *)(v9 + 72) - 1;
      if ((v10 & 0x80000000) == 0)
      {
        do
        {
          v11 = v10;
          v12 = *(_QWORD *)(v9 + 72);
          if (v12 <= v10)
          {
            v30 = 0;
            v42 = 0u;
            v43 = 0u;
            v40 = 0u;
            v41 = 0u;
            v39 = 0u;
            os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
            v31 = 136315906;
            v32 = "operator[]";
            v33 = 1024;
            v34 = 789;
            v35 = 2048;
            v36 = v11;
            v37 = 2048;
            v38 = v12;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
          }
          v13 = (_QWORD *)*((_QWORD *)a3 + 25);
          if ((*((_BYTE *)a3 + 184) & 1) != 0)
            v13 = v8;
          v14 = *((_QWORD *)a3 + 22);
          if (v14)
          {
            v15 = (uint64_t *)(*(_QWORD *)(v9 + 88) + 24 * v10);
            v16 = 8 * v14;
            while (*v13 != *v15)
            {
              ++v13;
              v16 -= 8;
              if (!v16)
                goto LABEL_14;
            }
            re::HashSetBase<re::internal::TimelineTree *,re::internal::TimelineTree *,re::internal::ValueAsKey<re::internal::TimelineTree *>,re::Hash<re::internal::TimelineTree *>,re::EqualTo<re::internal::TimelineTree *>,true,false>::add((uint64_t)&v26, v15);
          }
LABEL_14:
          v10 = v11 - 1;
        }
        while ((int)v11 > 0);
        v4 = *((_QWORD *)a2 + 19);
      }
    }
    ++v7;
  }
  while (v4 > v7);
  v17 = v28;
  if (!v28)
    goto LABEL_23;
  v18 = 0;
  v19 = (int *)(v27 + 8);
  while (1)
  {
    v20 = *v19;
    v19 += 6;
    if (v20 < 0)
      break;
    if (v28 == ++v18)
    {
      LODWORD(v18) = v28;
      break;
    }
  }
LABEL_24:
  if (v17 != (_DWORD)v18)
  {
    v21 = v18;
    v22 = v27;
    do
    {
      re::AnimationManager::remove(this, *(re::internal::TimelineTree **)(v22 + 24 * v21 + 16), 1);
      if (v28 <= (int)v18 + 1)
        v23 = v18 + 1;
      else
        v23 = v28;
      v24 = v18;
      while (1)
      {
        v21 = (v24 + 1);
        if (v23 - 1 == v24)
          break;
        ++v24;
        LODWORD(v18) = v21;
        if ((*(_DWORD *)(v22 + 24 * v21 + 8) & 0x80000000) != 0)
          goto LABEL_34;
      }
      LODWORD(v18) = v23;
LABEL_34:
      ;
    }
    while (v17 != (_DWORD)v18);
  }
  return re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v26);
}

_QWORD *re::DynamicArray<re::internal::AnimationHandoffBehavior *>::add(_QWORD *this, _QWORD *a2)
{
  _QWORD *v3;
  unint64_t v4;

  v3 = this;
  v4 = this[2];
  if (v4 >= this[1])
  {
    this = re::DynamicArray<re::internal::AnimationHandoffBehavior *>::growCapacity(this, v4 + 1);
    v4 = v3[2];
  }
  *(_QWORD *)(v3[4] + 8 * v4) = *a2;
  v3[2] = v4 + 1;
  ++*((_DWORD *)v3 + 6);
  return this;
}

void re::AnimationManager::cleanUpHandoffBehaviors(_anonymous_namespace_ *a1, int a2)
{
  char *v4;
  uint64_t v5;
  unint64_t *v6;
  uint64_t v7;
  re::internal::AnimationHandoffBehavior ***v8;
  re::internal::AnimationHandoffBehavior **v9;
  re::internal::AnimationHandoffBehavior **v10;
  _DWORD *v11;
  re::internal::AnimationHandoffBehavior *v12;
  re::internal::AnimationHandoffBehavior **v13;
  unint64_t v14;
  re::internal::AnimationHandoffBehavior **v15;
  uint64_t v16;
  unint64_t v17;

  v4 = (char *)a1 + 40 * a2;
  v7 = *((_QWORD *)v4 + 27);
  v6 = (unint64_t *)(v4 + 216);
  v5 = v7;
  if (v7)
  {
    v8 = (re::internal::AnimationHandoffBehavior ***)(v6 + 2);
    v9 = (re::internal::AnimationHandoffBehavior **)v6[2];
    v10 = &v9[v5];
    v11 = (_DWORD *)((char *)a1 + 40 * a2 + 224);
    do
    {
      v12 = *v9;
      if (!*(_QWORD *)*v9)
      {
        v13 = *v8;
        v14 = *v6;
        v15 = *v8;
        if (*v6)
        {
          v16 = 8 * v14;
          v15 = *v8;
          while (*v15 != v12)
          {
            ++v15;
            v16 -= 8;
            if (!v16)
            {
              v15 = &(*v8)[*v6];
              break;
            }
          }
        }
        v17 = v15 - v13;
        if (v17 != v14)
        {
          if (v14 <= v17)
          {
            os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
          }
          if (v14 - 1 > v17)
            v13[v17] = (*v8)[*v6 - 1];
          *v6 = v14 - 1;
          ++*v11;
          re::internal::AnimationHandoffBehavior::~AnimationHandoffBehavior(v12);
        }
      }
      ++v9;
    }
    while (v9 != v10);
  }
}

void re::AnimationManager::update(re::AnimationManager *this, float a2)
{
  OpaqueCMTimebase *v4;
  CMTime rhs;
  CMTime lhs;
  CMTime time;
  uint64_t v8[2];
  _BYTE v9[16];

  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v9, 1000, (uint64_t)this);
  re::ProfilerTimeGuard<(re::ProfilerStatistic)20>::ProfilerTimeGuard(v8);
  *((_BYTE *)this + 504) = 1;
  if (!*((_BYTE *)this + 57))
    goto LABEL_4;
  if (a2 >= 0.0)
  {
    v4 = (OpaqueCMTimebase *)*((_QWORD *)this + 8);
    CMTimebaseGetTime(&lhs, v4);
    CMTimeMake(&rhs, (unint64_t)(a2 * 18000.0 + 0.5), 18000);
    CMTimeAdd(&time, &lhs, &rhs);
    CMTimebaseSetTime(v4, &time);
LABEL_4:
    re::AnimationManager::update((unint64_t)this, 0);
    re::AnimationManager::applyAnimations(this, 0);
    re::AnimationManager::update((unint64_t)this, 1);
    *((_BYTE *)this + 504) = 0;
  }
  re::ProfilerTimeGuard<(re::ProfilerStatistic)20>::end((uint64_t)v8);
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v9);
}

uint64_t re::AnimationManager::update(unint64_t a1, int a2)
{
  uint64_t v5;
  re::internal::TimelineTree *v8;
  re::AnimationManager *v9;
  uint64_t result;
  unint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  v5 = a1 + ((uint64_t)a2 << 6) + 72;
  re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::DataArrayIterator((uint64_t)&v18, v5, 0);
  if (v5 != v18 || (unsigned __int16)v19 != 0xFFFFLL || (v19 & 0xFFFF0000) != 4294901760)
  {
    do
    {
      v8 = (re::internal::TimelineTree *)re::DataArray<re::internal::TimelineTree>::DataArrayIterator<re::internal::TimelineTree,re::internal::TimelineTree&>::operator*((unsigned __int16 *)&v18);
      re::AnimationManager::updateTime(a1, v8);
      re::AnimationManager::updateBlendFactors(v9, v8);
      re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::increment(&v18);
    }
    while (v18 != v5 || (unsigned __int16)v19 != 0xFFFF || WORD1(v19) != 0xFFFF);
  }
  result = re::AnimationManager::updateHandoffBehaviors(a1, a2);
  v13 = a1 + 40 * a2;
  v14 = *(_QWORD *)(v13 + 392);
  if (v14)
  {
    v15 = *(uint64_t **)(v13 + 408);
    v16 = 8 * v14;
    do
    {
      v17 = *v15++;
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v17 + 32))(v17);
      v16 -= 8;
    }
    while (v16);
  }
  return result;
}

double re::AnimationManager::applyAnimations(_anonymous_namespace_ *a1, int a2)
{
  _BYTE *v4;
  unint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  BOOL v20;
  uint64_t v22;
  uint64_t v26;
  __int128 v27;
  uint64_t v28;
  int v29;
  const char *v30;
  __int16 v31;
  int v32;
  __int16 v33;
  uint64_t v34;
  __int16 v35;
  unint64_t v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  uint64_t v42;

  v42 = *MEMORY[0x24BDAC8D0];
  v26 = a2;
  v4 = (char *)a1 + 40 * a2;
  re::AnimationManager::updateLookupTableForAllBuckets(a1);
  v5 = (unint64_t *)(v4 + 392);
  v6 = *((_QWORD *)v4 + 49);
  if ((int)v6 >= 1)
  {
    v7 = (uint64_t)(v4 + 376);
    v8 = v6 + 1;
    while (1)
    {
      v9 = (v8 - 2);
      v10 = *v5;
      if (*v5 <= v9)
        break;
      v11 = *(_QWORD *)(*((_QWORD *)a1 + 5 * (int)v26 + 51) + 8 * v9);
      if (!*(_QWORD *)(v11 + 72))
      {
        re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::remove((uint64_t)a1 + 48 * a2 + 280, *(_QWORD *)(v11 + 96));
        *(_QWORD *)(v11 + 96) = 0;
        re::DynamicArray<re::internal::AnimationCompositionChainBase *>::removeAt(v7, (v8 - 2));
        (**(void (***)(uint64_t))v11)(v11);
      }
      if ((unint64_t)--v8 <= 1)
        goto LABEL_7;
    }
    *(_QWORD *)&v27 = 0;
    v41 = 0u;
    v39 = 0u;
    v40 = 0u;
    v37 = 0u;
    v38 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v29 = 136315906;
    v30 = "operator[]";
    v31 = 1024;
    v32 = 789;
    v33 = 2048;
    v34 = (v8 - 2);
    v35 = 2048;
    v36 = v10;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_46;
  }
LABEL_7:
  if (!*((_BYTE *)a1 + 506))
  {
    v12 = (uint64_t)a1 + 64 * v26 + 72;
    re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::DataArrayIterator((uint64_t)&v37, v12, 0);
    v27 = v37;
    if (v12 != (_QWORD)v37 || WORD4(v37) != 0xFFFFLL || (DWORD2(v37) & 0xFFFF0000) != 0xFFFF0000)
    {
      while (1)
      {
        v13 = re::DataArray<re::internal::TimelineTree>::DataArrayIterator<re::internal::TimelineTree,re::internal::TimelineTree&>::operator*((unsigned __int16 *)&v27);
        if (!*(_QWORD *)(v13 + 56))
          break;
        if (**(_BYTE **)(v13 + 64) == 1)
          re::AnimationManager::remove(a1, (re::internal::TimelineTree *)v13, 0);
        re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::increment(&v27);
        if ((_QWORD)v27 == v12 && WORD4(v27) == 0xFFFF && WORD5(v27) == 0xFFFF)
          goto LABEL_22;
      }
LABEL_47:
      v28 = 0;
      v41 = 0u;
      v39 = 0u;
      v40 = 0u;
      v37 = 0u;
      v38 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v29 = 136315906;
      v30 = "operator[]";
      v31 = 1024;
      v32 = 468;
      v33 = 2048;
      v34 = 0;
      v35 = 2048;
      v36 = 0;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
LABEL_22:
  if (*v5)
  {
    v16 = (uint64_t *)*((_QWORD *)a1 + 5 * (int)v26 + 51);
    v17 = 8 * *v5;
    do
    {
      v18 = *v16++;
      (*(void (**)(uint64_t))(*(_QWORD *)v18 + 40))(v18);
      v17 -= 8;
    }
    while (v17);
  }
  if (*((_BYTE *)a1 + 506))
  {
    v19 = (uint64_t)a1 + 64 * v26 + 72;
    re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::DataArrayIterator((uint64_t)&v37, v19, 0);
    v27 = v37;
    v20 = v19 == (_QWORD)v37 && WORD4(v37) == 0xFFFFLL;
    if (!v20 || (DWORD2(v37) & 0xFFFF0000) != 4294901760)
    {
      while (1)
      {
        v22 = re::DataArray<re::internal::TimelineTree>::DataArrayIterator<re::internal::TimelineTree,re::internal::TimelineTree&>::operator*((unsigned __int16 *)&v27);
        if (!*(_QWORD *)(v22 + 56))
          break;
        if (**(_BYTE **)(v22 + 64) == 1)
          re::AnimationManager::remove(a1, (re::internal::TimelineTree *)v22, 0);
        re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::increment(&v27);
        if ((_QWORD)v27 == v19 && WORD4(v27) == 0xFFFF && WORD5(v27) == 0xFFFF)
          goto LABEL_44;
      }
LABEL_46:
      v28 = 0;
      v41 = 0u;
      v39 = 0u;
      v40 = 0u;
      v37 = 0u;
      v38 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v29 = 136315906;
      v30 = "operator[]";
      v31 = 1024;
      v32 = 468;
      v33 = 2048;
      v34 = 0;
      v35 = 2048;
      v36 = 0;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_47;
    }
  }
LABEL_44:
  re::AnimationManager::cleanUpHandoffBehaviors(a1, a2);
  return re::AnimationManager::updateScheduler(a1);
}

uint64_t re::DataArray<re::internal::TimelineTree>::DataArrayIterator<re::internal::TimelineTree,re::internal::TimelineTree&>::operator*(unsigned __int16 *a1)
{
  unint64_t v1;

  v1 = a1[5];
  if (*(_QWORD *)(*(_QWORD *)a1 + 16) <= v1)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 32) + 16 * v1) + 216 * a1[4];
}

void re::AnimationManager::updateTime(unint64_t this, re::internal::TimelineTree *a2)
{
  unint64_t v2;
  unint64_t v3;
  re::AnimationManager *v6;
  float *v7;
  int v8;
  float v9;
  re::internal::TimelineTree *v10;
  re::internal::TimelineTree *v11;
  double Rate;
  char *v13;
  float v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  id WeakRetained;
  unsigned __int8 *v20;
  int v21;
  double v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  uint64_t v31;
  __int128 v32;
  __int128 v33;
  int v34;
  _BYTE v35[8];
  uint64_t v36;
  char v37[8];
  Float64 v38;
  uint64_t v39;
  int v40;
  const char *v41;
  __int16 v42;
  int v43;
  __int16 v44;
  unint64_t v45;
  __int16 v46;
  unint64_t v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  uint64_t v53;

  v3 = (unint64_t)&v40;
  v53 = *MEMORY[0x24BDAC8D0];
  if (!*((_QWORD *)a2 + 7))
  {
LABEL_49:
    v39 = 0;
    v51 = 0u;
    v52 = 0u;
    v49 = 0u;
    v50 = 0u;
    v48 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v40 = 136315906;
    v41 = "operator[]";
    v42 = 1024;
    v43 = 468;
    v44 = 2048;
    *(_QWORD *)(v3 + 20) = 0;
    v46 = 2048;
    *(_QWORD *)(v3 + 30) = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_50:
    v39 = 0;
    v51 = 0u;
    v52 = 0u;
    v49 = 0u;
    v50 = 0u;
    v48 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v40 = 136315906;
    v41 = "operator[]";
    v42 = 1024;
    v43 = 468;
    v44 = 2048;
    *(_QWORD *)(v3 + 20) = 0;
    v46 = 2048;
    *(_QWORD *)(v3 + 30) = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_51;
  }
  v6 = (re::AnimationManager *)*((_QWORD *)a2 + 4);
  v7 = (float *)*((_QWORD *)a2 + 8);
  v8 = *(unsigned __int8 *)v7;
  v9 = v7[15];
  v10 = a2;
  do
  {
    v11 = v10;
    v10 = (re::internal::TimelineTree *)*((_QWORD *)v10 + 25);
  }
  while (v10);
  Rate = CMTimebaseGetRate(*((CMTimebaseRef *)v11 + 24));
  if (!*((_QWORD *)a2 + 25) && *((_BYTE *)a2 + 185) == 2)
  {
    CMTimebaseSetRate(*((CMTimebaseRef *)a2 + 24), *((float *)a2 + 47));
    *((_BYTE *)a2 + 185) = 0;
  }
  if (!*((_QWORD *)a2 + 7))
    goto LABEL_50;
  v13 = (char *)*((_QWORD *)a2 + 8);
  v37[0] = 1;
  v38 = re::internal::TimelineTree::currentTime(a2);
  if (!*((_QWORD *)a2 + 4))
  {
LABEL_51:
    v39 = 0;
    v51 = 0u;
    v52 = 0u;
    v49 = 0u;
    v50 = 0u;
    v48 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v40 = 136315906;
    v41 = "operator[]";
    v42 = 1024;
    v43 = 468;
    v44 = 2048;
    v45 = 0;
    v46 = 2048;
    v47 = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_52;
  }
  v14 = Rate;
  re::AnimationClock::update(v13, (uint64_t)v37, *((_QWORD *)a2 + 5), v14);
  if ((unint64_t)v6 >= 2)
  {
    v3 = 1;
    v15 = 28;
    v16 = 72;
    while (1)
    {
      v17 = *((_QWORD *)a2 + 1);
      if (v17 <= v3)
        break;
      v2 = *((_QWORD *)a2 + 7);
      if (v2 <= v3)
        goto LABEL_44;
      v17 = *(int *)(*((_QWORD *)a2 + 2) + 4 * v3);
      if (v2 <= v17)
        goto LABEL_45;
      v18 = *((_QWORD *)a2 + 8);
      v35[0] = *(_BYTE *)(v18 + 72 * (int)v17 + 16);
      if (v35[0])
        v36 = *(_QWORD *)(v18 + 72 * (int)v17 + 24);
      v17 = *((_QWORD *)a2 + 4);
      if (v17 <= v3)
        goto LABEL_46;
      re::AnimationClock::update((char *)(v18 + v16), (uint64_t)v35, *((_QWORD *)a2 + 5) + v15, v14);
      ++v3;
      v15 += 28;
      v16 += 72;
      if (v6 == (re::AnimationManager *)v3)
        goto LABEL_18;
    }
    v39 = 0;
    v51 = 0u;
    v52 = 0u;
    v49 = 0u;
    v50 = 0u;
    v48 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v40 = 136315906;
    v41 = "operator[]";
    v42 = 1024;
    v43 = 468;
    v44 = 2048;
    v45 = v3;
    v46 = 2048;
    v47 = v17;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_44:
    v39 = 0;
    v51 = 0u;
    v52 = 0u;
    v49 = 0u;
    v50 = 0u;
    v48 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v40 = 136315906;
    v41 = "operator[]";
    v42 = 1024;
    v43 = 468;
    v44 = 2048;
    v45 = v3;
    v46 = 2048;
    v47 = v2;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_45:
    v39 = 0;
    v51 = 0u;
    v52 = 0u;
    v49 = 0u;
    v50 = 0u;
    v48 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v40 = 136315906;
    v41 = "operator[]";
    v42 = 1024;
    v43 = 468;
    v44 = 2048;
    v45 = v17;
    v46 = 2048;
    v47 = v2;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_46:
    v39 = 0;
    v51 = 0u;
    v52 = 0u;
    v49 = 0u;
    v50 = 0u;
    v48 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v40 = 136315906;
    v41 = "operator[]";
    v42 = 1024;
    v43 = 468;
    v44 = 2048;
    v45 = v3;
    v46 = 2048;
    v47 = v17;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_47;
  }
LABEL_18:
  if (!*((_QWORD *)a2 + 7))
  {
LABEL_52:
    v39 = 0;
    v51 = 0u;
    v52 = 0u;
    v49 = 0u;
    v50 = 0u;
    v48 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v40 = 136315906;
    v41 = "operator[]";
    v42 = 1024;
    v43 = 468;
    v44 = 2048;
    v45 = 0;
    v46 = 2048;
    v47 = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_53:
    v39 = 0;
    v51 = 0u;
    v52 = 0u;
    v49 = 0u;
    v50 = 0u;
    v48 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v40 = 136315906;
    v41 = "operator[]";
    v42 = 1024;
    v43 = 468;
    v44 = 2048;
    v45 = 0;
    v46 = 2048;
    v47 = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  *(_BYTE *)(*((_QWORD *)a2 + 8) + 32) = 0;
  WeakRetained = objc_loadWeakRetained((id *)a2 + 22);
  if (WeakRetained)
  {
    if (!*((_QWORD *)a2 + 7))
      goto LABEL_53;
    v3 = (unint64_t)WeakRetained;
    v20 = (unsigned __int8 *)*((_QWORD *)a2 + 8);
    v21 = *v20;
    v22 = *((double *)v20 + 1);
    if (v8 == v21)
    {
      if ((LODWORD(v9) & 0x7FFFFFFFu) > 0x7F7FFFFF
        || (*((_DWORD *)v20 + 15) & 0x7FFFFFFFu) > 0x7F7FFFFF
        || floorf(v9) == floorf(*((float *)v20 + 15)))
      {
        goto LABEL_31;
      }
      v23 = 3;
    }
    else if (v21 == 3)
    {
      v23 = 1;
      v20[32] = 1;
    }
    else
    {
      if ((v21 & 0xFFFFFFFB) != 1)
      {
LABEL_31:
        if (v6)
        {
          v24 = 0;
          this = 0;
          while (1)
          {
            v17 = *((_QWORD *)a2 + 16);
            if (v17 <= this)
              break;
            v25 = *(_QWORD *)(*((_QWORD *)a2 + 17) + 8 * this);
            if (*(_DWORD *)(v25 + 8) == 49 && !*(_BYTE *)(v25 + 120))
            {
              v17 = *((_QWORD *)a2 + 7);
              if (v17 <= this)
                goto LABEL_48;
              v26 = *((_QWORD *)a2 + 8) + v24;
              v29 = *(_OWORD *)v26;
              if (*(_BYTE *)(v26 + 16))
                v31 = *(_QWORD *)(v26 + 24);
              v27 = *(_OWORD *)(v26 + 32);
              v28 = *(_OWORD *)(v26 + 48);
              v34 = *(_DWORD *)(v26 + 64);
              v32 = v27;
              v33 = v28;
              re::TypedEventTimelineInstance<float>::processEvents(v25, &v29, 0);
            }
            ++this;
            v24 += 72;
            if (v6 == (re::AnimationManager *)this)
              goto LABEL_41;
          }
LABEL_47:
          v39 = 0;
          v51 = 0u;
          v52 = 0u;
          v49 = 0u;
          v50 = 0u;
          v48 = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          v40 = 136315906;
          v41 = "operator[]";
          v42 = 1024;
          v43 = 468;
          v44 = 2048;
          v45 = this;
          v46 = 2048;
          v47 = v17;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_48:
          v39 = 0;
          v51 = 0u;
          v52 = 0u;
          v49 = 0u;
          v50 = 0u;
          v48 = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          v40 = 136315906;
          v41 = "operator[]";
          v42 = 1024;
          v43 = 468;
          v44 = 2048;
          v45 = this;
          v46 = 2048;
          v47 = v17;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
          goto LABEL_49;
        }
LABEL_41:

        return;
      }
      v23 = 2;
    }
    re::AnimationManager::addAnimationEvent(this, v23, (uint64_t)a2, 0, v22);
    goto LABEL_31;
  }
}

float re::AnimationManager::updateBlendFactors(re::AnimationManager *this, re::internal::TimelineTree *a2)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  _BYTE *v5;
  uint64_t v6;
  float result;
  float *v8;
  uint64_t v9;
  uint64_t v10;
  float *v11;
  uint64_t v12;
  unint64_t v13;
  float *v14;

  v2 = *((_QWORD *)a2 + 10);
  if (!v2)
  {
LABEL_23:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_24:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  v3 = *((_QWORD *)a2 + 13);
  if (!v3)
    goto LABEL_24;
  v4 = *((_QWORD *)a2 + 4);
  v5 = (_BYTE *)*((_QWORD *)a2 + 11);
  v6 = 8;
  if (!*v5)
    v6 = 4;
  result = *(float *)&v5[v6];
  v8 = (float *)*((_QWORD *)a2 + 14);
  *v8 = result;
  if (v4 >= 2)
  {
    v9 = *((_QWORD *)a2 + 2);
    if (*((_QWORD *)a2 + 1) <= 1uLL)
      v10 = 1;
    else
      v10 = *((_QWORD *)a2 + 1);
    v11 = (float *)(v5 + 20);
    v12 = 1;
    while (v10 != v12)
    {
      v13 = *(int *)(v9 + 4 * v12);
      if (v3 <= v13)
        goto LABEL_20;
      if (v2 == v12)
        goto LABEL_21;
      if (v3 == v12)
        goto LABEL_22;
      if (*((_BYTE *)v11 - 8))
        v14 = v11;
      else
        v14 = v11 - 1;
      result = v8[v13] * *v14;
      v8[v12++] = result;
      v11 += 3;
      if (v4 == v12)
        return result;
    }
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_20:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_21:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_22:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_23;
  }
  return result;
}

BOOL re::AnimationManager::updateHandoffBehaviors(_BOOL8 result, int a2)
{
  uint64_t v2;
  uint64_t v3;
  re::AnimationManager *v4;
  re::internal::TimelineTree ***v5;
  uint64_t v6;
  re::internal::TimelineTree **v7;

  v2 = result + 40 * a2;
  v3 = *(_QWORD *)(v2 + 216);
  if (v3)
  {
    v4 = (re::AnimationManager *)result;
    v5 = *(re::internal::TimelineTree ****)(v2 + 232);
    v6 = 8 * v3;
    do
    {
      v7 = *v5;
      if (**v5)
      {
        result = re::internal::AnimationHandoffBehavior::update(*v5, v4);
        if (result)
          *v7 = 0;
      }
      ++v5;
      v6 -= 8;
    }
    while (v6);
  }
  return result;
}

void re::AnimationManager::applyAnimations(re::AnimationManager *this)
{
  uint64_t v2[2];
  _BYTE v3[16];

  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v3, 1002, (uint64_t)this);
  re::ProfilerTimeGuard<(re::ProfilerStatistic)20>::ProfilerTimeGuard(v2);
  *((_BYTE *)this + 505) = 1;
  re::AnimationManager::applyAnimations(this, 1);
  *((_BYTE *)this + 505) = 0;
  re::AnimationManager::raiseAnimationEvents(this);
  re::ProfilerTimeGuard<(re::ProfilerStatistic)20>::end((uint64_t)v2);
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v3);
}

void re::AnimationManager::updateAndApplyAnimations(re::AnimationManager *this, re::internal::TimelineTree *a2)
{
  re::AnimationManager *v3;
  uint64_t v4;
  unint64_t i;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  __int128 v20;
  __int128 v21;
  unsigned int v22;
  uint64_t v23;
  _BYTE v24[120];
  uint64_t v25;
  int v26;
  const char *v27;
  __int16 v28;
  int v29;
  __int16 v30;
  unint64_t v31;
  __int16 v32;
  unint64_t v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  uint64_t v39;

  v39 = *MEMORY[0x24BDAC8D0];
  *((_BYTE *)this + 504) = 1;
  re::AnimationManager::updateTime((unint64_t)this, a2);
  re::AnimationManager::updateBlendFactors(v3, a2);
  v4 = *((_QWORD *)a2 + 4);
  re::StackScratchAllocator::StackScratchAllocator((re::StackScratchAllocator *)v24);
  v22 = 0;
  v20 = 0u;
  v21 = 0u;
  v23 = 0x7FFFFFFFLL;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::init((uint64_t)&v20, (uint64_t)v24, 3);
  if (v4)
  {
    for (i = 0; i != v4; ++i)
    {
      v6 = *((_QWORD *)a2 + 19);
      if (v6 <= i)
      {
        v25 = 0;
        v37 = 0u;
        v38 = 0u;
        v35 = 0u;
        v36 = 0u;
        v34 = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        v26 = 136315906;
        v27 = "operator[]";
        v28 = 1024;
        v29 = 468;
        v30 = 2048;
        v31 = i;
        v32 = 2048;
        v33 = v6;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      v7 = *(_QWORD *)(*((_QWORD *)a2 + 20) + 8 * i);
      if (!v7)
        continue;
      v8 = 0x94D049BB133111EBLL
         * ((0xBF58476D1CE4E5B9 * (v7 ^ (v7 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v7 ^ (v7 >> 30))) >> 27));
      v9 = v8 ^ (v8 >> 31);
      if (DWORD2(v21))
      {
        v10 = *(unsigned int *)(*((_QWORD *)&v20 + 1) + 4 * (v9 % DWORD2(v21)));
        if ((_DWORD)v10 != 0x7FFFFFFF)
        {
          while (*(_QWORD *)(v21 + 24 * v10 + 16) != v7)
          {
            LODWORD(v10) = *(_DWORD *)(v21 + 24 * v10 + 8) & 0x7FFFFFFF;
            if ((_DWORD)v10 == 0x7FFFFFFF)
              goto LABEL_9;
          }
          continue;
        }
LABEL_9:
        v11 = v9 % DWORD2(v21);
        v12 = *(unsigned int *)(*((_QWORD *)&v20 + 1) + 4 * (v9 % DWORD2(v21)));
        if ((_DWORD)v12 != 0x7FFFFFFF)
        {
          while (*(_QWORD *)(v21 + 24 * v12 + 16) != v7)
          {
            LODWORD(v12) = *(_DWORD *)(v21 + 24 * v12 + 8) & 0x7FFFFFFF;
            if ((_DWORD)v12 == 0x7FFFFFFF)
              goto LABEL_14;
          }
          goto LABEL_20;
        }
      }
      else
      {
        v11 = 0;
      }
LABEL_14:
      v13 = v23;
      if ((_DWORD)v23 == 0x7FFFFFFF)
      {
        v13 = v22;
        v14 = v22;
        if (v22 == DWORD2(v21))
        {
          re::HashSetBase<re::internal::TimelineTree *,re::internal::TimelineTree *,re::internal::ValueAsKey<re::internal::TimelineTree *>,re::Hash<re::internal::TimelineTree *>,re::EqualTo<re::internal::TimelineTree *>,true,false>::setCapacity((uint64_t)&v20, 2 * HIDWORD(v21));
          v14 = v22;
          v11 = v9 % DWORD2(v21);
        }
        v22 = v14 + 1;
        v15 = v21;
        v16 = *(_DWORD *)(v21 + 24 * v13 + 8);
      }
      else
      {
        v15 = v21;
        v16 = *(_DWORD *)(v21 + 24 * v23 + 8);
        LODWORD(v23) = v16 & 0x7FFFFFFF;
      }
      v17 = v15 + 24 * v13;
      *(_DWORD *)(v17 + 8) = v16 | 0x80000000;
      v18 = *((_QWORD *)&v20 + 1);
      *(_DWORD *)(v17 + 8) = *(_DWORD *)(*((_QWORD *)&v20 + 1) + 4 * v11) | 0x80000000;
      *(_QWORD *)v17 = v9;
      *(_QWORD *)(v17 + 16) = v7;
      *(_DWORD *)(v18 + 4 * v11) = v13;
      ++HIDWORD(v21);
      ++HIDWORD(v23);
LABEL_20:
      (*(void (**)(unint64_t))(*(_QWORD *)v7 + 32))(v7);
      (*(void (**)(unint64_t))(*(_QWORD *)v7 + 40))(v7);
    }
  }
  *((_BYTE *)this + 504) = 0;
  re::AnimationManager::raiseAnimationEvents(this);
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v20);
  re::StackScratchAllocator::~StackScratchAllocator((re::StackScratchAllocator *)v24);
}

void re::AnimationManager::blendFactorAsBindPoint(re::AnimationManager *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  unsigned __int8 v8;
  __objc2_class_ro **p_info;
  uint64_t v10;
  int v11;
  const re::IntrospectionBase *v12;
  _OWORD v13[2];
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  p_info = VideoSpillMapMetalSession.info;
  if ((v8 & 1) == 0)
  {
    p_info = (__objc2_class_ro **)(VideoSpillMapMetalSession + 32);
    if (v11)
    {
      re::introspect<float>(void)::info = re::introspect_float(0, v12);
      p_info = (__objc2_class_ro **)(VideoSpillMapMetalSession + 32);
    }
  }
  *(_QWORD *)a4 = p_info[7];
  *(_QWORD *)(a4 + 40) = 0;
  *(_QWORD *)(a4 + 16) = 0;
  *(_QWORD *)(a4 + 24) = 0;
  *(_DWORD *)(a4 + 32) = 0;
  *(_QWORD *)(a4 + 8) = 0;
  memset(v13, 0, sizeof(v13));
  re::DynamicArray<re::BindPoint::BindPointData>::add((_anonymous_namespace_ *)(a4 + 8), v13);
  re::BindPoint::BindPointData::deinit((re::BindPoint::BindPointData *)v13);
  v10 = *(_QWORD *)(a4 + 40) + 32 * *(_QWORD *)(a4 + 24);
  *(_QWORD *)(v10 - 32) = &off_24ED23A30;
  *(_QWORD *)(v10 - 24) = this;
  *(_QWORD *)(v10 - 16) = a2;
  *(_QWORD *)(v10 - 8) = a3;
}

void re::HashSetBase<re::SharedPtr<re::AnimationEventDelegate>,re::SharedPtr<re::AnimationEventDelegate>,re::internal::ValueAsKey<re::SharedPtr<re::AnimationEventDelegate>>,re::Hash<re::SharedPtr<re::AnimationEventDelegate>>,re::EqualTo<re::SharedPtr<re::AnimationEventDelegate>>,true,false>::clear(uint64_t a1)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t i;
  uint64_t v6;
  int v7;
  uint64_t v8;
  int v9;

  if (*(_DWORD *)(a1 + 28))
  {
    v2 = *(unsigned int *)(a1 + 24);
    if ((_DWORD)v2)
      memset_pattern16(*(void **)(a1 + 8), &unk_2260EB7B0, 4 * v2);
    v3 = *(unsigned int *)(a1 + 32);
    if ((_DWORD)v3)
    {
      v4 = 0;
      for (i = 0; i < v3; ++i)
      {
        v6 = *(_QWORD *)(a1 + 16) + v4;
        v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
          v8 = *(_QWORD *)(v6 + 16);
          if (v8)
          {

            *(_QWORD *)(v6 + 16) = 0;
            v3 = *(unsigned int *)(a1 + 32);
          }
        }
        v4 += 24;
      }
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    v9 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v9;
  }
}

BOOL re::AnimationManager::isUpdating(re::AnimationManager *this)
{
  return *((_BYTE *)this + 504) || *((_BYTE *)this + 505) != 0;
}

uint64_t re::AnimationManager::rootTimebase(re::AnimationManager *this)
{
  return *((_QWORD *)this + 8);
}

uint64_t re::AnimationManager::taskOptions(re::AnimationManager *this)
{
  return (uint64_t)this + 16;
}

double re::HashSetBase<re::SharedPtr<re::AnimationEventDelegate>,re::SharedPtr<re::AnimationEventDelegate>,re::internal::ValueAsKey<re::SharedPtr<re::AnimationEventDelegate>>,re::Hash<re::SharedPtr<re::AnimationEventDelegate>>,re::EqualTo<re::SharedPtr<re::AnimationEventDelegate>>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t i;
  uint64_t v6;
  int v7;
  uint64_t v8;
  double result;

  v2 = *a1;
  if (v2)
  {
    v3 = *((unsigned int *)a1 + 8);
    if ((_DWORD)v3)
    {
      v4 = 0;
      for (i = 0; i < v3; ++i)
      {
        v6 = a1[2] + v4;
        v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
          v8 = *(_QWORD *)(v6 + 16);
          if (v8)
          {

            *(_QWORD *)(v6 + 16) = 0;
            v3 = *((unsigned int *)a1 + 8);
          }
        }
        v4 += 24;
      }
      v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

uint64_t re::Scheduler::setTaskOverscheduleStrategy(uint64_t result, unint64_t a2, char a3)
{
  if (*(_QWORD *)(result + 472) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  *(_BYTE *)(*(_QWORD *)(result + 480) + a2) = a3;
  return result;
}

uint64_t re::Scheduler::setTaskMaxOverscheduleSubsteps(uint64_t this, unint64_t a2, char a3)
{
  if (*(_QWORD *)(this + 496) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  *(_BYTE *)(*(_QWORD *)(this + 504) + a2) = a3;
  return this;
}

re::internal::AriadneSignpostScopeGuard *re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard(re::internal::AriadneSignpostScopeGuard *this, int a2, uint64_t a3)
{
  *(_DWORD *)this = a2;
  *((_QWORD *)this + 1) = a3;
  if (re::internal::enableSignposts(0, 0))
    kdebug_trace();
  return this;
}

void re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard(re::internal::AriadneSignpostScopeGuard *this)
{
  if (re::internal::enableSignposts(0, 0))
    kdebug_trace();
}

uint64_t re::DynamicBitset<unsigned long long,256ul>::getBit(uint64_t a1, unint64_t a2)
{
  uint64_t v2;

  if (*(_QWORD *)(a1 + 8) <= a2 >> 6)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
    v2 = a1 + 24;
  else
    v2 = *(_QWORD *)(a1 + 32);
  return (*(_QWORD *)(v2 + 8 * (a2 >> 6)) >> a2) & 1;
}

_QWORD *re::DataArray<re::internal::TimelineTree>::~DataArray(_QWORD *a1)
{
  re::DataArray<re::internal::TimelineTree>::deinit(a1);
  if (*a1)
  {
    if (a1[4])
      (*(void (**)(_QWORD))(*(_QWORD *)*a1 + 40))(*a1);
    a1[4] = 0;
    a1[1] = 0;
    a1[2] = 0;
    *a1 = 0;
    ++*((_DWORD *)a1 + 6);
  }
  return a1;
}

_anonymous_namespace_ *re::DataArray<re::internal::TimelineTree>::allocBlock(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _anonymous_namespace_ *result;
  uint64_t v8;
  _anonymous_namespace_ *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t *v15;

  v3 = 216 * *((unsigned int *)a1 + 11);
  v4 = (*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(*(_QWORD *)*a1 + 32))(*a1, v3, 0);
  if (!v4)
  {
    re::internal::assertLog((re::internal *)6, v5, "assertion failure: '%s' (%s:line %i) DataArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "block.elements", "allocBlock", 520, v3, *(_QWORD *)(*a1 + 8));
    _os_crash();
    __break(1u);
    goto LABEL_16;
  }
  v6 = v4;
  v1 = 4 * *((unsigned int *)a1 + 11);
  result = (_anonymous_namespace_ *)(*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(*(_QWORD *)*a1 + 32))(*a1, v1, 0);
  if (!result)
  {
LABEL_16:
    re::internal::assertLog((re::internal *)6, v8, "assertion failure: '%s' (%s:line %i) DataArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "block.allocationCounters", "allocBlock", 528, v1, *(_QWORD *)(*a1 + 8));
    result = (_anonymous_namespace_ *)_os_crash();
    __break(1u);
    return result;
  }
  v9 = result;
  v11 = a1[1];
  v10 = a1[2];
  if (v10 >= v11)
  {
    v12 = v10 + 1;
    if (v11 < v10 + 1)
    {
      if (*a1)
      {
        v13 = 2 * v11;
        if (!v11)
          v13 = 8;
        if (v13 <= v12)
          v14 = v12;
        else
          v14 = v13;
        result = (_anonymous_namespace_ *)re::DynamicArray<re::DataArray<re::internal::TimelineTree>::ElementBlock>::setCapacity(a1, v14);
      }
      else
      {
        result = (_anonymous_namespace_ *)re::DynamicArray<re::DataArray<re::internal::TimelineTree>::ElementBlock>::setCapacity(a1, v12);
        ++*((_DWORD *)a1 + 6);
      }
    }
    v10 = a1[2];
  }
  v15 = (uint64_t *)(a1[4] + 16 * v10);
  *v15 = v6;
  v15[1] = (uint64_t)v9;
  a1[2] = v10 + 1;
  ++*((_DWORD *)a1 + 6);
  *((_DWORD *)a1 + 12) = 0;
  return result;
}

_QWORD *re::DynamicArray<re::DataArray<re::internal::TimelineTree>::ElementBlock>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  void *v7;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (*v5)
      {
        if (!a2)
        {
          v7 = 0;
          if (!v3)
            goto LABEL_9;
          goto LABEL_8;
        }
        if (a2 >> 60)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 16, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          v2 = 16 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 16 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
            {
LABEL_9:
              v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            memcpy(v7, (const void *)v5[4], 16 * v5[2]);
            result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
      }
      else
      {
        result = (_QWORD *)re::DynamicArray<re::DataArray<re::internal::TimelineTree>::ElementBlock>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

_QWORD *re::DynamicArray<re::internal::AnimationHandoffBehavior *>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  void *v7;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (*v5)
      {
        if (!a2)
        {
          v7 = 0;
          if (!v3)
            goto LABEL_9;
          goto LABEL_8;
        }
        if (a2 >> 61)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 8, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          v2 = 8 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 8 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
            {
LABEL_9:
              v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            memcpy(v7, (const void *)v5[4], 8 * v5[2]);
            result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
      }
      else
      {
        result = (_QWORD *)re::DynamicArray<re::internal::AnimationHandoffBehavior *>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

uint64_t re::TypedEventTimelineInstance<float>::compositionChain(uint64_t a1)
{
  unint64_t v1;
  _QWORD *v2;
  uint64_t result;

  v1 = *(unsigned int *)(a1 + 144);
  if ((v1 & 0x80000000) != 0)
    return 0;
  v2 = *(_QWORD **)(a1 + 128);
  do
  {
    if (v2[19] <= v1)
    {
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_11:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    if (v2[1] <= v1)
      goto LABEL_11;
    result = *(_QWORD *)(v2[20] + 8 * v1);
    if (result)
      break;
    v1 = *(unsigned int *)(v2[2] + 4 * v1);
  }
  while ((v1 & 0x80000000) == 0);
  return result;
}

uint64_t re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::addAsMove(uint64_t result, unsigned int a2, unint64_t a3, _QWORD *a4, _QWORD *a5)
{
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  int v12;

  v8 = result;
  v9 = *(unsigned int *)(result + 36);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
    v9 = *(unsigned int *)(result + 32);
    v10 = v9;
    if ((_DWORD)v9 == *(_DWORD *)(result + 24))
    {
      result = re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::setCapacity(result, (2 * *(_DWORD *)(result + 28)));
      a2 = a3 % *(unsigned int *)(v8 + 24);
      v10 = *(_DWORD *)(v8 + 32);
    }
    *(_DWORD *)(v8 + 32) = v10 + 1;
    v11 = *(_QWORD *)(v8 + 16);
    v12 = *(_DWORD *)(v11 + 32 * v9 + 8);
  }
  else
  {
    v11 = *(_QWORD *)(result + 16);
    v12 = *(_DWORD *)(v11 + 32 * v9 + 8);
    *(_DWORD *)(result + 36) = v12 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v11 + 32 * v9 + 8) = v12 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(v8 + 16) + 32 * v9 + 8) = *(_DWORD *)(*(_QWORD *)(v8 + 16) + 32 * v9 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(v8 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(v8 + 16) + 32 * v9) = a3;
  *(_QWORD *)(*(_QWORD *)(v8 + 16) + 32 * v9 + 16) = *a4;
  *(_QWORD *)(*(_QWORD *)(v8 + 16) + 32 * v9 + 24) = *a5;
  *(_DWORD *)(*(_QWORD *)(v8 + 8) + 4 * a2) = v9;
  ++*(_DWORD *)(v8 + 28);
  return result;
}

void re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  _QWORD *v12;
  signed int v13;
  _BYTE v14[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v14, 0, 36);
      *(_QWORD *)&v14[36] = 0x7FFFFFFFLL;
      re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphNode>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init((uint64_t)v14, v4, a2);
      v5 = *(_OWORD *)v14;
      *(_OWORD *)v14 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      v6 = *(_QWORD *)&v14[16];
      v7 = *(_QWORD *)(a1 + 16);
      *(_QWORD *)&v14[16] = v7;
      *(_QWORD *)(a1 + 16) = v6;
      v9 = *(_OWORD *)&v14[24];
      *(_OWORD *)&v14[24] = *(_OWORD *)(a1 + 24);
      v8 = *(_DWORD *)&v14[32];
      *(_OWORD *)(a1 + 24) = v9;
      v10 = v8;
      if (v8)
      {
        v11 = 0;
        v12 = (_QWORD *)(v7 + 16);
        do
        {
          if ((*(_DWORD *)(v12 - 1) & 0x80000000) != 0)
            re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::addAsMove(a1, *(v12 - 2) % (unint64_t)*(unsigned int *)(a1 + 24), *(v12 - 2), v12, v12 + 1);
          ++v11;
          v12 += 4;
        }
        while (v11 < v10);
      }
      re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)v14);
    }
  }
  else
  {
    if (a2)
      v13 = a2;
    else
      v13 = 3;
  }
}

void re::HashSetBase<re::internal::TimelineTree *,re::internal::TimelineTree *,re::internal::ValueAsKey<re::internal::TimelineTree *>,re::Hash<re::internal::TimelineTree *>,re::EqualTo<re::internal::TimelineTree *>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  __int128 v7;
  unsigned int v8;
  __int128 v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  _QWORD *v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  signed int v21;
  _BYTE v22[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v22, 0, 36);
      *(_QWORD *)&v22[36] = 0x7FFFFFFFLL;
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::init((uint64_t)v22, v4, a2);
      v5 = *(_OWORD *)a1;
      *(_QWORD *)a1 = *(_QWORD *)v22;
      v6 = *(_QWORD *)(a1 + 16);
      v7 = *(_OWORD *)&v22[8];
      *(_OWORD *)v22 = v5;
      *(_QWORD *)&v22[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      v9 = *(_OWORD *)&v22[24];
      *(_OWORD *)&v22[24] = *(_OWORD *)(a1 + 24);
      v8 = *(_DWORD *)&v22[32];
      *(_OWORD *)(a1 + 24) = v9;
      v10 = v8;
      if (v8)
      {
        v11 = DWORD1(v9);
        v12 = v7;
        v13 = (_QWORD *)(v6 + 16);
        do
        {
          if ((*(_DWORD *)(v13 - 1) & 0x80000000) != 0)
          {
            v14 = *(v13 - 2);
            v15 = *(unsigned int *)(a1 + 24);
            v16 = v14 % v15;
            v17 = *(unsigned int *)(a1 + 36);
            if ((_DWORD)v17 == 0x7FFFFFFF)
            {
              v17 = *(unsigned int *)(a1 + 32);
              v18 = v17;
              if ((_DWORD)v17 == (_DWORD)v15)
              {
                re::HashSetBase<re::internal::TimelineTree *,re::internal::TimelineTree *,re::internal::ValueAsKey<re::internal::TimelineTree *>,re::Hash<re::internal::TimelineTree *>,re::EqualTo<re::internal::TimelineTree *>,true,false>::setCapacity(a1, (2 * v11));
                v16 = v14 % *(unsigned int *)(a1 + 24);
                v18 = *(_DWORD *)(a1 + 32);
                v12 = *(_QWORD *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v18 + 1;
              v19 = *(_QWORD *)(a1 + 16);
              v20 = *(_DWORD *)(v19 + 24 * v17 + 8);
            }
            else
            {
              v19 = *(_QWORD *)(a1 + 16);
              v20 = *(_DWORD *)(v19 + 24 * v17 + 8);
              *(_DWORD *)(a1 + 36) = v20 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v19 + 24 * v17 + 8) = v20 | 0x80000000;
            *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v17 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v17 + 8) & 0x80000000 | *(_DWORD *)(v12 + 4 * v16);
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v17) = v14;
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v17 + 16) = *v13;
            v12 = *(_QWORD *)(a1 + 8);
            *(_DWORD *)(v12 + 4 * v16) = v17;
            v11 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v11;
          }
          v13 += 3;
          --v10;
        }
        while (v10);
      }
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)v22);
    }
  }
  else
  {
    if (a2)
      v21 = a2;
    else
      v21 = 3;
  }
}

_QWORD *re::DynamicArray<re::internal::AnimationHandoffBehavior *>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<re::internal::AnimationHandoffBehavior *>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::internal::AnimationHandoffBehavior *>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

uint64_t *re::ProfilerTimeGuard<(re::ProfilerStatistic)20>::ProfilerTimeGuard(uint64_t *a1)
{
  re *isStatisticCollectionEnabled;
  uint64_t v3;

  *a1 = 0;
  isStatisticCollectionEnabled = (re *)re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)a1);
  if ((_DWORD)isStatisticCollectionEnabled)
  {
    v3 = re::profilerThreadContext(isStatisticCollectionEnabled);
    *a1 = v3;
    if (*(_QWORD *)(v3 + 152))
      a1[1] = mach_absolute_time();
  }
  return a1;
}

uint64_t re::ProfilerTimeGuard<(re::ProfilerStatistic)20>::end(uint64_t result)
{
  _QWORD *v1;
  uint64_t v2;
  int64x2_t *v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  int64x2_t v7;

  if (*(_QWORD *)result && *(_QWORD *)(*(_QWORD *)result + 152))
  {
    v1 = (_QWORD *)result;
    result = mach_absolute_time();
    v2 = *v1;
    v3 = *(int64x2_t **)(*v1 + 152);
    if (v3)
    {
      v4 = result - v1[1];
      v5 = v3[84].u64[0];
      if (v5 >= v4)
        v5 = result - v1[1];
      v3[84].i64[0] = v5;
      v6 = v3[84].u64[1];
      if (v6 <= v4)
        v6 = v4;
      v3[84].i64[1] = v6;
      v7 = vdupq_n_s64(1uLL);
      v7.i64[0] = v4;
      v3[85] = vaddq_s64(v3[85], v7);
      *(_BYTE *)(v2 + 184) = 0;
    }
    *v1 = 0;
  }
  return result;
}

void re::DynamicArray<re::BindPoint::BindPointData>::add(_anonymous_namespace_ *this, _OWORD *a2)
{
  unint64_t v4;
  re::BindPoint::BindPointData *v5;

  v4 = *((_QWORD *)this + 2);
  if (v4 >= *((_QWORD *)this + 1))
  {
    re::DynamicArray<re::BindPoint::BindPointData>::growCapacity(this, v4 + 1);
    v4 = *((_QWORD *)this + 2);
  }
  v5 = (re::BindPoint::BindPointData *)(*((_QWORD *)this + 4) + 32 * v4);
  *(_OWORD *)v5 = 0u;
  *((_OWORD *)v5 + 1) = 0u;
  re::BindPoint::BindPointData::move(v5, a2);
  ++*((_QWORD *)this + 2);
  ++*((_DWORD *)this + 6);
}

_QWORD *re::DynamicArray<re::BindPoint::BindPointData>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<re::BindPoint::BindPointData>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::BindPoint::BindPointData>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

void re::internal::BlendFactorBindPointImpl::~BlendFactorBindPointImpl(re::internal::BlendFactorBindPointImpl *this)
{
  JUMPOUT(0x2276933B8);
}

const char *re::internal::BindPointImpl<re::internal::BlendFactorBindPointImpl>::implTypeInfo()
{
  return " ";
}

__n128 re::internal::BindPointImpl<re::internal::BlendFactorBindPointImpl>::copyInto(__n128 *a1, __n128 *a2)
{
  unint64_t v2;
  __n128 result;

  v2 = a1->n128_u64[1];
  a2->n128_u64[0] = (unint64_t)&off_24ED23A30;
  a2->n128_u64[1] = v2;
  result = a1[1];
  a2[1] = result;
  return result;
}

__n128 re::internal::BindPointImpl<re::internal::BlendFactorBindPointImpl>::moveInto(__n128 *a1, __n128 *a2)
{
  unint64_t v2;
  __n128 result;

  v2 = a1->n128_u64[1];
  a2->n128_u64[0] = (unint64_t)&off_24ED23A30;
  a2->n128_u64[1] = v2;
  result = a1[1];
  a2[1] = result;
  return result;
}

BOOL re::internal::BindPointImpl<re::internal::BlendFactorBindPointImpl>::equals(_QWORD *a1, _QWORD *a2)
{
  return (char *)(*(uint64_t (**)(_QWORD *))(*a2 + 16))(a2) == " "
      && a1[1] == a2[1]
      && a1[2] == a2[2]
      && a1[3] == a2[3];
}

uint64_t re::internal::BlendFactorBindPointImpl::hash(_QWORD *a1)
{
  unint64_t v1;
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;

  v1 = 0xBF58476D1CE4E5B9 * (a1[1] ^ (a1[1] >> 30));
  v2 = (0x94D049BB133111EBLL * (v1 ^ (v1 >> 27))) ^ ((0x94D049BB133111EBLL * (v1 ^ (v1 >> 27))) >> 31);
  v3 = 0xBF58476D1CE4E5B9 * (a1[2] ^ (a1[2] >> 30));
  v4 = (0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) ^ ((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) >> 31);
  v5 = a1[3] ^ (a1[3] >> 30);
  v6 = 0x94D049BB133111EBLL * ((0xBF58476D1CE4E5B9 * v5) ^ ((0xBF58476D1CE4E5B9 * v5) >> 27));
  return ((v2 << 6)
        + (v2 >> 2)
        - 0x61C8864680B583E9
        + (((v6 ^ (v6 >> 31)) + (v4 << 6) + (v4 >> 2) - 0x61C8864680B583E9) ^ v4)) ^ v2;
}

uint64_t re::internal::BlendFactorBindPointImpl::isWeak()
{
  return 1;
}

BOOL re::internal::BlendFactorBindPointImpl::isAlive(re::internal::BlendFactorBindPointImpl *a1)
{
  return re::internal::BlendFactorBindPointImpl::getBlendFactor(a1) != 0;
}

uint64_t re::internal::BlendFactorBindPointImpl::targetIdentifier(re::internal::BlendFactorBindPointImpl *a1)
{
  uint64_t BlendFactor;

  BlendFactor = re::internal::BlendFactorBindPointImpl::getBlendFactor(a1);
  if (BlendFactor)
    return BlendFactor + 4;
  else
    return 0;
}

uint64_t re::internal::BlendFactorBindPointImpl::baseValueUntyped(re::internal::BlendFactorBindPointImpl *a1)
{
  uint64_t BlendFactor;

  BlendFactor = re::internal::BlendFactorBindPointImpl::getBlendFactor(a1);
  if (BlendFactor)
    return BlendFactor + 4;
  else
    return 0;
}

uint64_t re::internal::BlendFactorBindPointImpl::supportsOverrideValue()
{
  return 1;
}

_BYTE *re::internal::BlendFactorBindPointImpl::isOverridden(re::internal::BlendFactorBindPointImpl *a1)
{
  _BYTE *result;

  result = (_BYTE *)re::internal::BlendFactorBindPointImpl::getBlendFactor(a1);
  if (result)
    return (_BYTE *)(*result != 0);
  return result;
}

_BYTE *re::internal::BlendFactorBindPointImpl::setIsOverridden(re::internal::BlendFactorBindPointImpl *a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
  _BYTE *result;

  result = (_BYTE *)re::internal::BlendFactorBindPointImpl::getBlendFactor(a1);
  if (result)
    *result = a5;
  return result;
}

uint64_t re::internal::BlendFactorBindPointImpl::overrideValueUntyped(re::internal::BlendFactorBindPointImpl *a1)
{
  uint64_t BlendFactor;

  BlendFactor = re::internal::BlendFactorBindPointImpl::getBlendFactor(a1);
  if (BlendFactor)
    return BlendFactor + 8;
  else
    return 0;
}

uint64_t re::internal::BlendFactorBindPointImpl::boundOwner()
{
  return 0;
}

uint64_t re::internal::BlendFactorBindPointImpl::getBlendFactor(re::internal::BlendFactorBindPointImpl *this)
{
  uint64_t result;
  unint64_t v3;

  result = re::DataArray<re::internal::TimelineTree>::tryGet(*((_QWORD *)this + 1) + (*((uint64_t *)this + 2) >> 56 << 6) + 72, *((_QWORD *)this + 2));
  if (result)
  {
    v3 = *((_QWORD *)this + 3);
    if (*(_QWORD *)(result + 80) <= v3)
    {
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    return *(_QWORD *)(result + 88) + 12 * v3;
  }
  return result;
}

void re::HashSetBase<re::SharedPtr<re::AnimationEventDelegate>,re::SharedPtr<re::AnimationEventDelegate>,re::internal::ValueAsKey<re::SharedPtr<re::AnimationEventDelegate>>,re::Hash<re::SharedPtr<re::AnimationEventDelegate>>,re::EqualTo<re::SharedPtr<re::AnimationEventDelegate>>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  __int128 v7;
  unsigned int v8;
  __int128 v9;
  unsigned int v10;
  unint64_t v11;
  uint64_t v12;
  int v13;
  _QWORD *v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  signed int v22;
  _BYTE v23[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v23, 0, 36);
      *(_QWORD *)&v23[36] = 0x7FFFFFFFLL;
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::init((uint64_t)v23, v4, a2);
      v5 = *(_OWORD *)a1;
      *(_QWORD *)a1 = *(_QWORD *)v23;
      v6 = *(_QWORD *)(a1 + 16);
      v7 = *(_OWORD *)&v23[8];
      *(_OWORD *)v23 = v5;
      *(_QWORD *)&v23[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      v9 = *(_OWORD *)&v23[24];
      *(_OWORD *)&v23[24] = *(_OWORD *)(a1 + 24);
      v8 = *(_DWORD *)&v23[32];
      *(_OWORD *)(a1 + 24) = v9;
      v10 = v8;
      if (v8)
      {
        v11 = 0;
        v12 = v7;
        v13 = DWORD1(v9);
        v14 = (_QWORD *)(v6 + 16);
        do
        {
          if ((*(_DWORD *)(v14 - 1) & 0x80000000) != 0)
          {
            v15 = *(v14 - 2);
            v16 = *(unsigned int *)(a1 + 24);
            v17 = v15 % v16;
            v18 = *(unsigned int *)(a1 + 36);
            if ((_DWORD)v18 == 0x7FFFFFFF)
            {
              v18 = *(unsigned int *)(a1 + 32);
              v19 = v18;
              if ((_DWORD)v18 == (_DWORD)v16)
              {
                re::HashSetBase<re::SharedPtr<re::AnimationEventDelegate>,re::SharedPtr<re::AnimationEventDelegate>,re::internal::ValueAsKey<re::SharedPtr<re::AnimationEventDelegate>>,re::Hash<re::SharedPtr<re::AnimationEventDelegate>>,re::EqualTo<re::SharedPtr<re::AnimationEventDelegate>>,true,false>::setCapacity(a1, (2 * v13));
                v17 = v15 % *(unsigned int *)(a1 + 24);
                v19 = *(_DWORD *)(a1 + 32);
                v12 = *(_QWORD *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v19 + 1;
              v20 = *(_QWORD *)(a1 + 16);
              v21 = *(_DWORD *)(v20 + 24 * v18 + 8);
            }
            else
            {
              v20 = *(_QWORD *)(a1 + 16);
              v21 = *(_DWORD *)(v20 + 24 * v18 + 8);
              *(_DWORD *)(a1 + 36) = v21 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v20 + 24 * v18 + 8) = v21 | 0x80000000;
            *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v18 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v18 + 8) & 0x80000000 | *(_DWORD *)(v12 + 4 * v17);
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v18) = v15;
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v18 + 16) = *v14;
            *v14 = 0;
            *(_DWORD *)(v12 + 4 * v17) = v18;
            v13 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v13;
            v10 = *(_DWORD *)&v23[32];
          }
          ++v11;
          v14 += 3;
        }
        while (v11 < v10);
      }
      re::HashSetBase<re::SharedPtr<re::AnimationEventDelegate>,re::SharedPtr<re::AnimationEventDelegate>,re::internal::ValueAsKey<re::SharedPtr<re::AnimationEventDelegate>>,re::Hash<re::SharedPtr<re::AnimationEventDelegate>>,re::EqualTo<re::SharedPtr<re::AnimationEventDelegate>>,true,false>::deinit((uint64_t *)v23);
    }
  }
  else
  {
    if (a2)
      v22 = a2;
    else
      v22 = 3;
  }
}

re::DynamicString *re::RigGraphCompiler::getCurrentCompiledAssetInfo@<X0>(re::RigGraphCompiler *this@<X0>, _QWORD *a2@<X8>)
{
  re::DynamicString *v2;
  _anonymous_namespace_ *v3;
  const char *v4;

  *a2 = 0x100000001;
  v2 = (re::DynamicString *)(a2 + 1);
  v3 = (_anonymous_namespace_ *)re::RigGraphAsset::assetType(this);
  v4 = *(const char **)v3;
}

__objc2_class_ro *re::RigGraphCompiler::assetIntrospectionType(re::RigGraphCompiler *this)
{
  unsigned __int8 v1;
  __objc2_class_ro **p_info;
  int v4;

  p_info = VideoSpillMapMetalSession.info;
  if ((v1 & 1) == 0)
  {
    p_info = (__objc2_class_ro **)(VideoSpillMapMetalSession + 32);
    if (v4)
    {
      re::introspect<re::RigGraphAsset>(void)::info = re::introspect_RigGraphAsset(0);
      p_info = (__objc2_class_ro **)(VideoSpillMapMetalSession + 32);
    }
  }
  return p_info[170];
}

uint64_t re::RigGraphCompiler::getSupportedExtensions@<X0>(uint64_t a1@<X8>)
{
  _QWORD v3[2];
  const char *v4;

  v4 = "reriggraph";
  v3[0] = &v4;
  v3[1] = 1;
  return re::DynamicArray<char const*>::DynamicArray(a1, (uint64_t)v3);
}

uint64_t *re::RigGraphCompiler::compile@<X0>(re::RigGraphCompiler *this@<X0>, char *a2@<X1>, re::AssetSerializationScheme *a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t *v8;
  uint64_t v9;
  char *v10;
  __int128 v11;
  __int128 v12;
  unsigned __int8 v13;
  __objc2_class_ro **p_info;
  uint64_t v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  int v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v24;
  _BYTE v25[8];
  uint64_t v26;
  char v27;
  uint64_t v28;
  _QWORD v29[5];

  v29[4] = *MEMORY[0x24BDAC8D0];
  v8 = re::globalAllocators(this);
  v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v8[2] + 32))(v8[2], 160, 8);
  *(_OWORD *)v9 = 0u;
  *(_OWORD *)(v9 + 16) = 0u;
  *(_OWORD *)(v9 + 32) = 0u;
  *(_OWORD *)(v9 + 48) = 0u;
  *(_OWORD *)(v9 + 64) = 0u;
  *(_OWORD *)(v9 + 80) = 0u;
  *(_OWORD *)(v9 + 96) = 0u;
  *(_OWORD *)(v9 + 112) = 0u;
  *(_OWORD *)(v9 + 128) = 0u;
  *(_OWORD *)(v9 + 144) = 0u;
  v29[3] = v29;
  v28 = v9;
  v29[0] = &off_24ED23B88;
  v10 = strrchr(a2, 46);
  if (!strcasecmp(v10 + 1, "reriggraph"))
  {
    p_info = VideoSpillMapMetalSession.info;
    if ((v13 & 1) == 0)
    {
      p_info = (__objc2_class_ro **)(VideoSpillMapMetalSession + 32);
      if (v20)
      {
        re::introspect<re::RigGraphAsset>(void)::info = re::introspect_RigGraphAsset(0);
        p_info = (__objc2_class_ro **)(VideoSpillMapMetalSession + 32);
      }
    }
    re::AssetUtilities::readSourceJson((re::AssetUtilities *)a2, (const char *)v9, (uint64_t)p_info[170], a3, (uint64_t)v25);
    if (v25[0])
    {
      v15 = v28;
      v28 = 0;
      *(_BYTE *)a4 = 1;
      *(_QWORD *)(a4 + 8) = v15;
    }
    else
    {
      *(_QWORD *)&v21 = 100;
      *((_QWORD *)&v21 + 1) = &re::AssetErrorCategory(void)::instance;
      re::DynamicString::DynamicString((re::DynamicString *)&v22, (const re::DynamicString *)&v26);
      v16 = v22;
      *(_OWORD *)(a4 + 8) = v21;
      v17 = v23;
      v18 = v24;
      *(_BYTE *)a4 = 0;
      *(_OWORD *)(a4 + 24) = v16;
      *(_QWORD *)(a4 + 40) = v17;
      *(_QWORD *)(a4 + 48) = v18;
      if (!v25[0] && v26 && (v27 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v26 + 40))();
    }
  }
  else
  {
    re::DynamicString::format((re::DynamicString *)"Invalid Asset Path: %s.", (re::DynamicString *)&v21, a2);
    v11 = v21;
    v12 = v22;
    *(_BYTE *)a4 = 0;
    *(_QWORD *)(a4 + 8) = 200;
    *(_QWORD *)(a4 + 16) = &re::AssetErrorCategory(void)::instance;
    *(_OWORD *)(a4 + 24) = v11;
    *(_OWORD *)(a4 + 40) = v12;
  }
  return std::unique_ptr<re::RigHierarchy,std::function<void ()(re::RigHierarchy*)>>::~unique_ptr[abi:nn180100](&v28);
}

re *re::RigGraphCompiler::deleteAsset(re::RigGraphCompiler *this, uint64_t a2)
{
  return re::internal::destroyPersistent<re::RigGraphAsset>((re *)"deleteAsset", 56, a2);
}

re *re::internal::destroyPersistent<re::RigGraphAsset>(re *result, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  if (a3)
  {
    v4 = re::globalAllocators(result)[2];
    re::DynamicArray<re::RigGraphNode>::deinit(a3 + 120);
    re::DynamicArray<re::RigGraphBoundInputParameterData>::deinit(a3 + 80);
    re::DynamicArray<re::MeshRigGraphIndex>::deinit(a3 + 40);
    re::DynamicArray<re::RigGraphDefinition>::deinit(a3);
    return (re *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v4 + 40))(v4, a3);
  }
  return result;
}

void re::RigGraphCompiler::~RigGraphCompiler(re::RigGraphCompiler *this)
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::DynamicArray<char const*>::DynamicArray(uint64_t a1, uint64_t a2)
{
  unint64_t v3;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  v3 = *(_QWORD *)(a2 + 8);
  if (v3)
  {
    re::DynamicArray<float *>::setCapacity((_QWORD *)a1, v3);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<char const*>::copy((_QWORD *)a1, 0, *(char **)a2, *(_QWORD *)(a2 + 8));
  }
  return a1;
}

_QWORD *re::DynamicArray<char const*>::copy(_QWORD *this, unint64_t a2, char *__src, uint64_t a4)
{
  uint64_t v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v10;
  char *v11;
  uint64_t v12;
  __int128 v13;

  if (!a4)
    return this;
  v5 = a2;
  v6 = this;
  v7 = this[2];
  if (v7 + 1 <= a2)
  {
    v12 = 0;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    LODWORD(v13) = 136315906;
    *(_QWORD *)((char *)&v13 + 4) = "copy";
    WORD6(v13) = 1024;
    HIWORD(v13) = 643;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_12:
    re::internal::assertLog((re::internal *)7, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::copy(). size = %zu, pos = %zu, count = %zu", "!overflow", "copy", 647, v7, v5, v4, v12, v13);
    _os_crash();
    __break(1u);
  }
  v4 = a4;
  v8 = a2 + a4;
  if (__CFADD__(a2, a4))
    goto LABEL_12;
  if (v7 >= v8)
  {
    this = memmove((void *)(this[4] + 8 * a2), __src, 8 * a4);
  }
  else
  {
    re::DynamicArray<float *>::growCapacity(this, a2 + a4);
    v10 = v6[2] - v5;
    v11 = &__src[8 * v10];
    if (v10)
    {
      memmove((void *)(v6[4] + 8 * v5), __src, 8 * v10);
      v5 = v6[2];
    }
    this = memcpy((void *)(v6[4] + 8 * v5), v11, &__src[8 * v4] - v11);
    v6[2] = v8;
  }
  ++*((_DWORD *)v6 + 6);
  return this;
}

uint64_t re::DynamicArray<re::RigGraphNode>::deinit(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 200 * v4;
        do
        {
          re::DynamicArray<re::Pair<unsigned long,re::StringID,true>>::deinit(v3 + 160);
          re::DynamicArray<re::StringID>::deinit(v3 + 120);
          re::DynamicArray<re::RigGraphNodeChild>::deinit(v3 + 80);
          re::DynamicArray<re::RigGraphNodeInputParameter>::deinit(v3 + 40);
          re::DynamicArray<re::RigGraphNodeInputParameter>::deinit(v3);
          v3 += 200;
          v5 -= 200;
        }
        while (v5);
        result = *(_QWORD *)a1;
        v3 = *(_QWORD *)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::DynamicArray<re::RigGraphBoundInputParameterData>::deinit(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 40 * v4;
        do
        {
          re::StringID::destroyString((re::StringID *)(v3 + 16));
          re::StringID::destroyString((re::StringID *)v3);
          v3 += 40;
          v5 -= 40;
        }
        while (v5);
        result = *(_QWORD *)a1;
        v3 = *(_QWORD *)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::DynamicArray<re::MeshRigGraphIndex>::deinit(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  re::StringID *v6;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = v4 << 6;
        v6 = (re::StringID *)(v3 + 40);
        do
        {
          re::StringID::destroyString(v6);
          re::StringID::destroyString((re::StringID *)((char *)v6 - 16));
          re::StringID::destroyString((re::StringID *)((char *)v6 - 32));
          v6 = (re::StringID *)((char *)v6 + 64);
          v5 -= 64;
        }
        while (v5);
        result = *(_QWORD *)a1;
        v3 = *(_QWORD *)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::DynamicArray<re::RigGraphDefinition>::deinit(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 0;
        v6 = 216 * v4;
        do
        {
          re::DynamicArray<re::RigGraphInputValue>::deinit(v3 + v5 + 176);
          re::DynamicArray<re::RigGraphConnection>::deinit((_QWORD *)(v3 + v5 + 136));
          re::DynamicArray<re::RigDataTypeClass::RigDataTypeAttribute>::deinit(v3 + v5 + 96);
          re::DynamicArray<re::RigGraphParameterProxy>::deinit(v3 + v5 + 56);
          re::DynamicArray<re::RigGraphParameterProxy>::deinit(v3 + v5 + 16);
          re::StringID::destroyString((re::StringID *)(v3 + v5));
          v5 += 216;
        }
        while (v6 != v5);
        result = *(_QWORD *)a1;
        v3 = *(_QWORD *)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

void std::__function::__func<re::RigGraphCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::RigGraphCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,void ()(re::RigGraphAsset *)>::~__func()
{
  JUMPOUT(0x2276933B8);
}

_QWORD *std::__function::__func<re::RigGraphCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::RigGraphCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,void ()(re::RigGraphAsset *)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_24ED23B88;
  return result;
}

void std::__function::__func<re::RigGraphCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::RigGraphCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,void ()(re::RigGraphAsset *)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24ED23B88;
}

re *std::__function::__func<re::RigGraphCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::RigGraphCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,void ()(re::RigGraphAsset *)>::operator()(uint64_t a1, uint64_t *a2)
{
  return re::internal::destroyPersistent<re::RigGraphAsset>((re *)"operator()", 35, *a2);
}

uint64_t std::__function::__func<re::RigGraphCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::RigGraphCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,void ()(re::RigGraphAsset *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::RigGraphCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::RigGraphCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,void ()(re::RigGraphAsset *)>::target_type()
{
}

uint64_t re::solverTwoBoneIK(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10, double a11, double a12, double a13, double a14, __n128 a15, uint64_t a16, unint64_t a17, uint64_t *a18)
{
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  float v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  float32x4_t *v28;
  uint64_t v29;
  float v30;
  float v31;
  float32x4_t *v32;
  float32x4_t v33;
  float32x4_t *v34;
  float32x4_t v35;
  float32x4_t *v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float32x4_t v48;
  float32x4_t v49;
  float v50;
  float v51;
  float32x2_t v52;
  float32x2_t v53;
  int32x4_t v54;
  __float2 v55;
  int32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  int8x16_t v62;
  float32x4_t v63;
  int8x16_t v64;
  float32x4_t v65;
  int32x2_t v66;
  float v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float v71;
  float32x4_t v72;
  float32x4_t v73;
  int32x4_t v74;
  float32x2_t v75;
  float32x2_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  int32x2_t v88;
  float32x4_t v89;
  float32x4_t v90;
  int32x4_t v91;
  float32x2_t v92;
  float32x2_t v93;
  uint64_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  int32x4_t v99;
  float32x2_t v100;
  float32x2_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  int8x16_t v105;
  int32x4_t v106;
  float32x4_t v107;
  int8x16_t v108;
  float32x4_t v109;
  int32x4_t v110;
  int32x4_t v111;
  int32x4_t v112;
  int32x4_t v113;
  int32x4_t v114;
  float32x4_t v115;
  uint64_t v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  uint64_t v120;
  float32x4_t v121;
  float32x4_t v122;
  __n128 v123;
  float32x4_t v124;
  int8x16_t v125;
  int32x4_t v126;
  int8x16_t v127;
  float32x4_t v128;
  int32x4_t v129;
  int32x4_t v130;
  int32x4_t v131;
  int32x4_t v132;
  float32x4_t v133;
  uint64_t v134;
  float32x4_t v135;
  float32x4_t v136;
  float32x4_t v137;
  uint64_t v138;
  int32x4_t v139;
  int32x4_t v140;
  float32x4_t v141;
  float32x4_t v142;
  __n128 v143;
  uint64_t result;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  unint64_t v148;
  unint64_t v149;
  float32x4_t v155;
  float32x4_t v156;
  int32x2_t v157;
  unint64_t v158;
  float32x4_t v159;
  float32x4_t v160;
  float v161;
  float32x4_t v162;
  float32x4_t v163;
  float32x4_t v164;
  int32x2_t v165;
  int32x2_t v166;
  int32x4_t v167;
  int32x4_t v168;
  int32x4_t v169;
  float32x4_t v170;
  float32x4_t v171;
  __n128 v172;

  if (a18)
  {
    v145 = a18[2];
    v146 = *a18;
    v148 = a18[3];
    v149 = a18[1];
    if (a6)
      goto LABEL_3;
    return 1;
  }
  v148 = 0;
  v149 = 0;
  v145 = 0;
  v146 = 0;
  if (!a6)
    return 1;
LABEL_3:
  v20 = 0;
  v21 = a17;
  LOBYTE(v22) = 1;
  v23 = 1.0;
  v147 = a6;
  while (v20 != a8)
  {
    v24 = *(_QWORD *)(a7 + 8 * v20);
    if (a4 <= v24)
      goto LABEL_46;
    v25 = *(_QWORD *)(a5 + 8 * v20);
    v26 = *(unsigned int *)(a3 + 4 * v24);
    v27 = v20;
    v28 = (float32x4_t *)&re::solverTwoBoneIK(re::MutableSlice<re::Matrix4x4<float>>,re::Slice<unsigned int>,re::Slice<unsigned long>,re::Slice<unsigned long>,re::Slice<re::Vector3<float>>,void *)::kDefaultUpPosition;
    if (a6 != v21)
    {
      v27 = 2 * v20;
      if (v21 <= 2 * v20)
        goto LABEL_50;
      v29 = v27 | 1;
      if (v21 <= (v27 | 1uLL))
        goto LABEL_51;
      v28 = (float32x4_t *)(a16 + 16 * v29);
    }
    v30 = 0.0;
    if (v20 < v148)
      v30 = *(float *)(v145 + 4 * v20);
    v31 = 0.05;
    if (v20 < v149)
    {
      v31 = *(float *)(v146 + 4 * v20);
      if (v31 > v23)
        v31 = v23;
      if (v31 < 0.0)
        v31 = 0.0;
    }
    if (a2 <= v25)
      goto LABEL_47;
    if (a2 <= v26)
      goto LABEL_48;
    if (a2 <= v24)
      goto LABEL_49;
    v32 = (float32x4_t *)(a1 + (v25 << 6));
    v33 = v32[3];
    v34 = (float32x4_t *)(a1 + (v26 << 6));
    v35 = v34[3];
    v36 = (float32x4_t *)(a1 + (v24 << 6));
    v37 = *(float32x4_t *)(a16 + 16 * v27);
    v38 = vsubq_f32(v33, v37);
    v159 = vsubq_f32(v33, v35);
    v160 = vsubq_f32(v35, v36[3]);
    v39 = vmulq_f32(v160, v160);
    v40 = vmulq_f32(v159, v159);
    v41 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v40.f32, 1);
    a15.n128_f32[0] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v39, 2), vaddq_f32(v39, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v39.f32, 1))).f32[0]);
    v41.f32[0] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v40, 2), vaddq_f32(v40, v41)).f32[0]);
    v42 = vmulq_f32(v38, v38);
    v43 = vaddq_f32(v42, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v42.f32, 1));
    v43.f32[0] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v42, 2), v43).f32[0]);
    v157 = *(int32x2_t *)v41.f32;
    v158 = a15.n128_u64[0];
    v44 = v31 * (float)(v41.f32[0] + a15.n128_f32[0]);
    v45 = (float)(v41.f32[0] + a15.n128_f32[0]) - v44;
    v161 = v41.f32[0] + a15.n128_f32[0];
    v162 = v33;
    if (v43.f32[0] >= v45)
    {
      v163 = v38;
      v165 = *(int32x2_t *)v43.f32;
      v46 = expf((float)-(float)(v43.f32[0] - v45) / v44);
      v33 = v162;
      v47 = v45 + (float)(v44 * (float)(1.0 - v46));
      v37 = vsubq_f32(v162, vmulq_n_f32(vdivq_f32(v163, (float32x4_t)vdupq_lane_s32(v165, 0)), v47));
      v38 = vsubq_f32(v162, v37);
      v43.i64[0] = __PAIR64__(v163.u32[1], LODWORD(v47));
    }
    v48 = vsubq_f32(v37, v33);
    v49 = vmulq_f32(v48, v48);
    LODWORD(v50) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v49, 2), vaddq_f32(v49, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v49.f32, 1))).u32[0];
    v155 = v37;
    v164 = v38;
    v166 = *(int32x2_t *)v43.f32;
    if (fabsf(v50) >= 1.0e-10)
    {
      v51 = v50;
      v52 = vrsqrte_f32((float32x2_t)LODWORD(v50));
      v53 = vmul_f32(v52, vrsqrts_f32((float32x2_t)LODWORD(v51), vmul_f32(v52, v52)));
      v48 = vmulq_n_f32(v48, vmul_f32(v53, vrsqrts_f32((float32x2_t)LODWORD(v51), vmul_f32(v53, v53))).f32[0]);
    }
    v156 = v48;
    v55 = __sincosf_stret(v30 * 0.5);
    *(float32x2_t *)v56.i8 = vmul_n_f32(*(float32x2_t *)v156.f32, v55.__sinval);
    v56.i32[2] = vmuls_lane_f32(v55.__sinval, v156, 2);
    v57 = v162;
    v58 = vsubq_f32(*v28, v162);
    v59 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v56, v56), (int8x16_t)v56, 0xCuLL);
    v60 = vnegq_f32((float32x4_t)v56);
    v61 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v58, (int32x4_t)v58), (int8x16_t)v58, 0xCuLL), v60), v58, v59);
    v62 = (int8x16_t)vaddq_f32(v61, v61);
    v63 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v62, (int32x4_t)v62), v62, 0xCuLL);
    v64 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v63, (int32x4_t)v63), (int8x16_t)v63, 0xCuLL), v60), v63, v59);
    v65 = vaddq_f32(v162, vaddq_f32(vaddq_f32(v58, vmulq_n_f32(v63, v55.__cosval)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v64, (int32x4_t)v64), v64, 0xCuLL)));
    if (*(float *)v166.i32 >= v161)
    {
      v79 = vdivq_f32(vnegq_f32(v164), (float32x4_t)vdupq_lane_s32(v166, 0));
      v66 = (int32x2_t)v158;
      v78 = (float32x4_t)vdupq_lane_s32(v157, 0);
      v77 = vaddq_f32(v162, vmulq_n_f32(v79, *(float *)v157.i32));
      v69 = vaddq_f32(v162, vmulq_n_f32(v79, v161));
    }
    else
    {
      v66 = (int32x2_t)v158;
      v67 = (float)((float)((float)(*(float *)v66.i32 * *(float *)v66.i32)
                          + (float)(*(float *)v166.i32 * *(float *)v166.i32))
                  - (float)(*(float *)v157.i32 * *(float *)v157.i32))
          / (float)(*(float *)v166.i32 + *(float *)v166.i32);
      v68 = vdivq_f32(v164, (float32x4_t)vdupq_lane_s32(v166, 0));
      v69 = v155;
      v70 = vaddq_f32(v155, vmulq_n_f32(v68, v67));
      v71 = sqrtf((float)(*(float *)v66.i32 * *(float *)v66.i32) - (float)(v67 * v67));
      v72 = vmulq_f32(v68, vsubq_f32(v65, v70));
      v73 = vsubq_f32(vsubq_f32(v65, vmulq_n_f32(v68, vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v72, 2), vaddq_f32(v72, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v72.f32, 1))).f32[0])), v70);
      v74 = (int32x4_t)vmulq_f32(v73, v73);
      v74.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v74, 2), vadd_f32(*(float32x2_t *)v74.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v74.i8, 1))).u32[0];
      v75 = vrsqrte_f32((float32x2_t)v74.u32[0]);
      v76 = vmul_f32(v75, vrsqrts_f32((float32x2_t)v74.u32[0], vmul_f32(v75, v75)));
      v77 = vaddq_f32(v70, vmulq_n_f32(vmulq_n_f32(v73, vmul_f32(v76, vrsqrts_f32((float32x2_t)v74.u32[0], vmul_f32(v76, v76))).f32[0]), v71));
      v78 = (float32x4_t)vdupq_lane_s32(v157, 0);
    }
    v21 = a17;
    a6 = v147;
    v80 = (float32x4_t)vdupq_lane_s32(v66, 0);
    v81 = vdivq_f32(v160, v80);
    v82 = vdivq_f32(v159, v78);
    v83 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v81, (int32x4_t)v81), (int8x16_t)v81, 0xCuLL);
    v84 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v82, (int32x4_t)v82), (int8x16_t)v82, 0xCuLL);
    v85 = vnegq_f32(v81);
    v86 = vmlaq_f32(vmulq_f32(v84, v85), v82, v83);
    v87 = vmulq_f32(v86, v86);
    v88 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v87.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v87, 2), v87)).u64[0];
    *(float *)v88.i32 = sqrtf(*(float *)v88.i32);
    if (*(float *)v88.i32 <= 0.01)
    {
      v90 = v34[2];
      v91 = (int32x4_t)vmulq_f32(v90, v90);
      v91.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v91, 2), vadd_f32(*(float32x2_t *)v91.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v91.i8, 1))).u32[0];
      v92 = vrsqrte_f32((float32x2_t)v91.u32[0]);
      v93 = vmul_f32(v92, vrsqrts_f32((float32x2_t)v91.u32[0], vmul_f32(v92, v92)));
      v89 = vmulq_n_f32(v90, vmul_f32(v93, vrsqrts_f32((float32x2_t)v91.u32[0], vmul_f32(v93, v93))).f32[0]);
    }
    else
    {
      v89 = vdivq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v86, (int32x4_t)v86), (int8x16_t)v86, 0xCuLL), (float32x4_t)vdupq_lane_s32(v88, 0));
    }
    v94 = 0;
    v95 = vsubq_f32(v65, v69);
    v96 = vsubq_f32(v162, v65);
    v97 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v96, (int32x4_t)v96), (int8x16_t)v96, 0xCuLL), vnegq_f32(v95)), v96, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v95, (int32x4_t)v95), (int8x16_t)v95, 0xCuLL));
    v98 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v97, (int32x4_t)v97), (int8x16_t)v97, 0xCuLL);
    v99 = (int32x4_t)vmulq_f32(v97, v97);
    v99.i32[0] = vadd_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v99.i8, 1), vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v99, 2), *(float32x2_t *)v99.i8)).u32[0];
    v100 = vrsqrte_f32((float32x2_t)v99.u32[0]);
    v101 = vmul_f32(v100, vrsqrts_f32((float32x2_t)v99.u32[0], vmul_f32(v100, v100)));
    v102 = vmulq_n_f32(v98, vmul_f32(v101, vrsqrts_f32((float32x2_t)v99.u32[0], vmul_f32(v101, v101))).f32[0]);
    v103 = vdivq_f32(vsubq_f32(v162, v77), v78);
    v104 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v89, (int32x4_t)v89), (int8x16_t)v89, 0xCuLL);
    v105 = (int8x16_t)vmlaq_f32(vmulq_f32(v104, vnegq_f32(v82)), v89, v84);
    v106 = (int32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v105, (int32x4_t)v105), v105, 0xCuLL);
    v107 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v102, (int32x4_t)v102), (int8x16_t)v102, 0xCuLL);
    v108 = (int8x16_t)vmlaq_f32(vmulq_f32(v107, vnegq_f32(v103)), v102, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v103, (int32x4_t)v103), (int8x16_t)v103, 0xCuLL));
    v109 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v108, (int32x4_t)v108), v108, 0xCuLL);
    v110 = vzip1q_s32((int32x4_t)v82, v106);
    v111 = vzip2q_s32((int32x4_t)v82, v106);
    v112 = vzip1q_s32((int32x4_t)v89, (int32x4_t)0);
    v113 = vdupq_laneq_s32((int32x4_t)v89, 2);
    v114 = vzip1q_s32(v110, (int32x4_t)v89);
    v167 = v114;
    v168 = vzip2q_s32(v110, v112);
    v169 = vzip1q_s32(v111, v113);
    do
    {
      v115 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v103, COERCE_FLOAT(*(_OWORD *)((char *)&v167 + v94))), v102, *(float32x2_t *)&v167.i8[v94], 1), v109, *(float32x4_t *)((char *)&v167 + v94), 2);
      *(float32x4_t *)((char *)&v170 + v94) = v115;
      v94 += 16;
    }
    while (v94 != 48);
    v116 = 0;
    v117 = v170;
    v118 = v171;
    v119 = (float32x4_t)v172;
    v115.i64[0] = v32->i64[0];
    v114.i64[0] = v32[1].i64[0];
    v54.i64[0] = v32[2].i64[0];
    v115.i32[2] = v32->i32[2];
    v114.i32[2] = v32[1].i32[2];
    v54.i32[2] = v32[2].i32[2];
    v167 = (int32x4_t)v115;
    v168 = v114;
    v169 = v54;
    do
    {
      *(float32x4_t *)((char *)&v170 + v116) = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v117, COERCE_FLOAT(*(_OWORD *)((char *)&v167 + v116))), v118, *(float32x2_t *)&v167.i8[v116], 1), v119, *(float32x4_t *)((char *)&v167 + v116), 2);
      v116 += 16;
    }
    while (v116 != 48);
    v120 = 0;
    v121 = v170;
    v122 = v171;
    v121.i32[3] = 0;
    v122.i32[3] = 0;
    v123 = v172;
    v123.n128_u32[3] = 0;
    v23 = 1.0;
    v57.i32[3] = 1.0;
    *v32 = v121;
    v32[1] = v122;
    v32[2] = (float32x4_t)v123;
    v32[3] = v57;
    v124 = vdivq_f32(vsubq_f32(v77, v69), v80);
    v125 = (int8x16_t)vmlaq_f32(vmulq_f32(v104, v85), v89, v83);
    v126 = (int32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v125, (int32x4_t)v125), v125, 0xCuLL);
    v127 = (int8x16_t)vmlaq_f32(vmulq_f32(v107, vnegq_f32(v124)), v102, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v124, (int32x4_t)v124), (int8x16_t)v124, 0xCuLL));
    v128 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v127, (int32x4_t)v127), v127, 0xCuLL);
    v129 = vzip1q_s32((int32x4_t)v81, v126);
    v130 = vzip2q_s32((int32x4_t)v81, v126);
    v131 = vzip1q_s32(v129, v112);
    v132 = vzip2q_s32(v129, v112);
    v167 = v131;
    v168 = v132;
    v169 = vzip1q_s32(v130, v113);
    do
    {
      v133 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v124, COERCE_FLOAT(*(_OWORD *)((char *)&v167 + v120))), v102, *(float32x2_t *)&v167.i8[v120], 1), v128, *(float32x4_t *)((char *)&v167 + v120), 2);
      *(float32x4_t *)((char *)&v170 + v120) = v133;
      v120 += 16;
    }
    while (v120 != 48);
    v134 = 0;
    v135 = v170;
    v136 = v171;
    v137 = (float32x4_t)v172;
    v133.i64[0] = v34->i64[0];
    v132.i64[0] = v34[1].i64[0];
    v102.i64[0] = v34[2].i64[0];
    v133.i32[2] = v34->i32[2];
    v132.i32[2] = v34[1].i32[2];
    v102.i32[2] = v34[2].i32[2];
    v167 = (int32x4_t)v133;
    v168 = v132;
    v169 = (int32x4_t)v102;
    do
    {
      *(float32x4_t *)((char *)&v170 + v134) = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v135, COERCE_FLOAT(*(_OWORD *)((char *)&v167 + v134))), v136, *(float32x2_t *)&v167.i8[v134], 1), v137, *(float32x4_t *)((char *)&v167 + v134), 2);
      v134 += 16;
    }
    while (v134 != 48);
    v138 = 0;
    v139 = (int32x4_t)v170;
    v140 = (int32x4_t)v171;
    v139.i32[3] = 0;
    v140.i32[3] = 0;
    a15 = v172;
    a15.n128_u32[3] = 0;
    v77.i32[3] = 1.0;
    *v34 = (float32x4_t)v139;
    v34[1] = (float32x4_t)v140;
    v34[2] = (float32x4_t)a15;
    v34[3] = v77;
    v77.i64[0] = v36->i64[0];
    v139.i64[0] = v36[1].i64[0];
    v140.i64[0] = v36[2].i64[0];
    v77.i32[2] = v36->i32[2];
    v139.i32[2] = v36[1].i32[2];
    v140.i32[2] = v36[2].i32[2];
    v167 = (int32x4_t)v77;
    v168 = v139;
    v169 = v140;
    do
    {
      *(float32x4_t *)((char *)&v170 + v138) = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v135, COERCE_FLOAT(*(_OWORD *)((char *)&v167 + v138))), v136, *(float32x2_t *)&v167.i8[v138], 1), v137, *(float32x4_t *)((char *)&v167 + v138), 2);
      v138 += 16;
    }
    while (v138 != 48);
    v141 = v170;
    v142 = v171;
    v141.i32[3] = 0;
    v142.i32[3] = 0;
    v143 = v172;
    v143.n128_u32[3] = 0;
    v69.i32[3] = 1.0;
    *v36 = v141;
    v36[1] = v142;
    v36[2] = (float32x4_t)v143;
    v36[3] = v69;
    v22 = v22 & (*(float *)v166.i32 < v161);
    if (++v20 == v147)
      return v22;
  }
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, a8, a8);
  _os_crash();
  __break(1u);
LABEL_46:
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v24, a4);
  _os_crash();
  __break(1u);
LABEL_47:
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v25, a2);
  _os_crash();
  __break(1u);
LABEL_48:
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v26, a2);
  _os_crash();
  __break(1u);
LABEL_49:
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v24, a2);
  _os_crash();
  __break(1u);
LABEL_50:
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v27, v21);
  _os_crash();
  __break(1u);
LABEL_51:
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v29, v21);
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::solverFABRIK(uint64_t a1, uint64_t a2, uint64_t a3, int *a4, uint64_t a5, uint64_t a6, uint64_t a7, unint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v18;
  float v20;
  uint64_t v21;
  float v22;
  uint64_t result;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float v34;
  float32x4_t v35;
  float32x4_t v36;
  BOOL v37;
  unint64_t v39;
  float32x4_t v40;
  unsigned int v41;
  __int128 *v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  float32x4_t v46;
  uint64_t v47;
  uint64_t v52;
  int v53;
  uint64_t v54;
  unint64_t v55;
  unsigned int v56;
  unint64_t v57;
  float v58;
  float32x4_t v59;
  uint64_t v60;
  unint64_t v61;
  uint64_t v62;
  uint64_t v63;
  unint64_t v64;
  float32x4_t *v65;
  _QWORD v66[2];
  char v67;
  float32x4_t v68;
  uint64_t v69;
  int v70;
  const char *v71;
  __int16 v72;
  int v73;
  __int16 v74;
  unint64_t v75;
  __int16 v76;
  unint64_t v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  uint64_t v83;

  v14 = a8;
  v15 = a7;
  v18 = a2;
  v83 = *MEMORY[0x24BDAC8D0];
  if (a11)
  {
    v20 = *(float *)a11;
    v56 = *(_DWORD *)(a11 + 4);
  }
  else
  {
    v56 = 32;
    v20 = 0.1;
  }
  if (a6)
  {
    v21 = 0;
    v22 = v20 * v20;
    LODWORD(result) = 1;
    while (1)
    {
      if (v21 == v14)
        goto LABEL_68;
      if (v21 == a10)
        goto LABEL_69;
      v24 = *(_QWORD *)(a5 + 8 * v21);
      if (v18 <= v24)
        goto LABEL_70;
      v25 = *(_QWORD *)(v15 + 8 * v21);
      v68 = *(float32x4_t *)(a1 + (v24 << 6) + 48);
      v26 = 1;
      if (v25 != v24)
        break;
LABEL_13:
      v54 = v21;
      v55 = v25;
      v53 = result;
      v67 = 0;
      v66[0] = &off_24ED42648;
      v66[1] = "Scratch Pad";
      v63 = 0;
      v64 = 0;
      v65 = 0;
      re::FixedArray<re::Vector3<float>>::init<>(&v63, (uint64_t)v66, v26);
      v60 = 0;
      v61 = 0;
      v62 = 0;
      v57 = v26 - 1;
      re::FixedArray<int>::init<>(&v60, (uint64_t)v66, v26 - 1);
      if (v26)
      {
        v13 = 0;
        v29 = v55;
        while (v18 > v29)
        {
          v11 = v64;
          if (v64 <= v13)
            goto LABEL_58;
          v65[v13] = *(float32x4_t *)(a1 + (v29 << 6) + 48);
          if (v13)
          {
            v11 = v64;
            if (v64 <= v13)
              goto LABEL_65;
            v12 = v13 - 1;
            v11 = v61;
            if (v61 <= v13 - 1)
              goto LABEL_66;
            v30 = vsubq_f32(v65[v13], v65[v13 - 1]);
            v31 = vmulq_f32(v30, v30);
            *(float *)(v62 + 4 * v13 - 4) = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v31, 2), vaddq_f32(v31, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v31.f32, 1))).f32[0]);
          }
          if ((unint64_t)a4 <= v29)
            goto LABEL_59;
          ++v13;
          v29 = *(unsigned int *)(a3 + 4 * v29);
          if (v26 == v13)
            goto LABEL_23;
        }
        re::internal::assertLog((re::internal *)6, v28, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v29, v18);
        _os_crash();
        __break(1u);
LABEL_58:
        v69 = 0;
        a4 = &v70;
        v81 = 0u;
        v82 = 0u;
        v79 = 0u;
        v80 = 0u;
        v78 = 0u;
        v18 = MEMORY[0x24BDACB70];
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        v70 = 136315906;
        v71 = "operator[]";
        v72 = 1024;
        v73 = 468;
        v74 = 2048;
        v75 = v13;
        v76 = 2048;
        v77 = v11;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_59:
        re::internal::assertLog((re::internal *)6, v28, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v29, a4);
        _os_crash();
        __break(1u);
LABEL_60:
        re::internal::assertLog((re::internal *)6, v28, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v12, v18);
        _os_crash();
        __break(1u);
LABEL_61:
        v69 = 0;
        v81 = 0u;
        v82 = 0u;
        v79 = 0u;
        v80 = 0u;
        v78 = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        v70 = 136315906;
        v71 = "operator[]";
        v72 = 1024;
        v73 = 468;
        v74 = 2048;
        v75 = v11;
        v76 = 2048;
        v77 = v26;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_62:
        v69 = 0;
        a4 = &v70;
        v81 = 0u;
        v82 = 0u;
        v79 = 0u;
        v80 = 0u;
        v78 = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        v70 = 136315906;
        v71 = "operator[]";
        v72 = 1024;
        v73 = 468;
        v74 = 2048;
        v75 = v14;
        v76 = 2048;
        v77 = v26;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_63:
        re::internal::assertLog((re::internal *)6, v28, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v12, a4);
        _os_crash();
        __break(1u);
LABEL_64:
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v27, a4);
        _os_crash();
        __break(1u);
LABEL_65:
        v69 = 0;
        v81 = 0u;
        v82 = 0u;
        v79 = 0u;
        v80 = 0u;
        v78 = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        v70 = 136315906;
        v71 = "operator[]";
        v72 = 1024;
        v73 = 468;
        v74 = 2048;
        v75 = v13;
        v76 = 2048;
        v77 = v11;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_66:
        v69 = 0;
        v81 = 0u;
        v82 = 0u;
        v79 = 0u;
        v80 = 0u;
        v78 = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        v70 = 136315906;
        v71 = "operator[]";
        v72 = 1024;
        v73 = 468;
        v74 = 2048;
        v75 = v12;
        v76 = 2048;
        v77 = v11;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_67;
      }
LABEL_23:
      if (!v64)
        goto LABEL_71;
      v13 = 1;
      if (v56)
      {
        v26 = a9 + 16 * v54;
        v32 = vsubq_f32(*v65, *(float32x4_t *)v26);
        v33 = vmulq_f32(v32, v32);
        v34 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v33, 2), vaddq_f32(v33, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v33.f32, 1))).f32[0];
        if (v34 > v22)
        {
          LODWORD(v11) = 1;
          while (1)
          {
            v58 = v34;
            if (!v64)
              break;
            v35 = vsubq_f32(*v65, *(float32x4_t *)v26);
            v36 = vmulq_f32(v35, v35);
            v34 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v36, 2), vaddq_f32(v36, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v36.f32, 1))).f32[0];
            v13 = (float)(v58 - v34) > v20;
            v37 = (float)(v58 - v34) <= v20 || v11 >= v56;
            v11 = (v11 + 1);
            if (v37 || v34 <= v22)
              goto LABEL_35;
          }
LABEL_67:
          v69 = 0;
          v81 = 0u;
          v82 = 0u;
          v79 = 0u;
          v80 = 0u;
          v78 = 0u;
          v18 = MEMORY[0x24BDACB70];
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          v70 = 136315906;
          v71 = "operator[]";
          v72 = 1024;
          v73 = 468;
          v74 = 2048;
          v75 = 0;
          v76 = 2048;
          v77 = 0;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_68:
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v14, v14);
          _os_crash();
          __break(1u);
LABEL_69:
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, a10, a10);
          _os_crash();
          __break(1u);
LABEL_70:
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v24, v18);
          _os_crash();
          __break(1u);
LABEL_71:
          v69 = 0;
          a4 = &v70;
          v81 = 0u;
          v82 = 0u;
          v79 = 0u;
          v80 = 0u;
          v78 = 0u;
          v18 = MEMORY[0x24BDACB70];
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          v70 = 136315906;
          v71 = "operator[]";
          v72 = 1024;
          v73 = 468;
          v74 = 2048;
          v75 = 0;
          v76 = 2048;
          v77 = 0;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_72:
          re::internal::assertLog((re::internal *)6, v28, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v39, a4);
          _os_crash();
          __break(1u);
LABEL_73:
          re::internal::assertLog((re::internal *)6, v28, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v39, v18);
          _os_crash();
          __break(1u);
LABEL_74:
          re::internal::assertLog((re::internal *)6, v28, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v12, v18);
          _os_crash();
          __break(1u);
LABEL_75:
          v69 = 0;
          v81 = 0u;
          v82 = 0u;
          v79 = 0u;
          v80 = 0u;
          v78 = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          v70 = 136315906;
          v71 = "operator[]";
          v72 = 1024;
          v73 = 468;
          v74 = 2048;
          v75 = 0;
          v76 = 2048;
          v77 = 0;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
      }
LABEL_35:
      v39 = v55;
      if ((unint64_t)a4 <= v55)
        goto LABEL_72;
      if (v18 <= v55)
        goto LABEL_73;
      v12 = *(unsigned int *)(a3 + 4 * v55);
      v52 = a1 + (v55 << 6);
      if (v57)
      {
        v14 = 0;
        v40 = *(float32x4_t *)(a1 + (v55 << 6) + 48);
        v41 = 1;
        do
        {
          if (v18 <= v12)
            goto LABEL_60;
          v11 = v41;
          v26 = v64;
          if (v64 <= v41)
            goto LABEL_61;
          if (v64 <= v14)
            goto LABEL_62;
          v26 = a1 + (v12 << 6);
          v59 = *(float32x4_t *)(v26 + 48);
          *(_OWORD *)v26 = v78;
          *(_OWORD *)(v26 + 16) = v79;
          *(_OWORD *)(v26 + 32) = v80;
          *(_OWORD *)(v26 + 48) = v81;
          if ((unint64_t)a4 <= v12)
            goto LABEL_63;
          v12 = *(unsigned int *)(a3 + 4 * v12);
          ++v41;
          v40 = v59;
          v14 = v11;
        }
        while (v57 > v11);
        v12 = *(unsigned int *)(a3 + 4 * v55);
        v15 = a7;
        v14 = a8;
      }
      if (v18 <= v12)
        goto LABEL_74;
      v42 = (__int128 *)(a1 + (v12 << 6));
      v43 = v42[3];
      v45 = *v42;
      v44 = v42[1];
      *(_OWORD *)(v52 + 32) = v42[2];
      *(_OWORD *)(v52 + 48) = v43;
      *(_OWORD *)v52 = v45;
      *(_OWORD *)(v52 + 16) = v44;
      if (!v64)
        goto LABEL_75;
      v46 = *v65;
      v46.i32[3] = *(_DWORD *)(v52 + 60);
      *(float32x4_t *)(v52 + 48) = v46;
      if (v60)
      {
        v47 = 1;
        if (v61)
        {
          (*(void (**)(void))(*(_QWORD *)v60 + 40))();
          v47 = v64;
        }
      }
      else
      {
        v47 = 1;
      }
      if (v63)
      {
        if (v47)
          (*(void (**)(void))(*(_QWORD *)v63 + 40))();
      }
      re::Allocator::~Allocator((re::Allocator *)v66);
      result = v53 & v13;
      v21 = v54 + 1;
      if (v54 + 1 == a6)
        return result;
    }
    v27 = v25;
    while ((unint64_t)a4 > v27)
    {
      ++v26;
      v27 = *(unsigned int *)(a3 + 4 * v27);
      if (v24 == v27)
        goto LABEL_13;
    }
    goto LABEL_64;
  }
  return 1;
}

float re::getTwistAngle(uint64_t a1, float32x4_t a2)
{
  float32x4_t v2;
  float32x4_t v3;
  float32x4_t v4;
  float v5;
  float v6;
  float32x2_t v7;
  float32x2_t v8;
  float32x4_t v9;
  float v10;
  float v11;
  float32x2_t v12;
  float32x2_t v13;
  float32x4_t v14;
  int32x2_t v15;
  float v16;
  float32x4_t v17;
  int32x4_t v18;
  float32x2_t v19;
  float32x2_t v20;
  float32x4_t v21;
  int8x16_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  int8x16_t v28;
  float32x4_t v29;
  int8x16_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float v33;
  float v34;
  float32x2_t v35;
  float32x2_t v36;
  float32x4_t v37;
  float v38;
  float32x4_t v39;
  float v40;
  float32x2_t v41;
  float32x2_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float v46;
  float v47;
  float v48;
  float32x4_t v49;
  int32x4_t v50;
  float32x2_t v51;
  float32x2_t v52;
  float32x4_t v53;
  float v54;
  int8x16_t v55;
  float32x4_t v56;
  float32x4_t v57;
  int8x16_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float v61;
  float32x4_t v62;
  float32x4_t v63;
  float v64;
  float32x4_t v65;
  float v66;
  float32x2_t v67;
  float32x2_t v68;
  float v69;
  float32x4_t v70;
  float32x4_t v72;
  float32x4_t v73;

  v2.i64[0] = *(_QWORD *)(a1 + 4);
  v3 = *(float32x4_t *)a1;
  v4 = vmulq_f32(v3, v3);
  LODWORD(v5) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v4, 2), vaddq_f32(v4, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.f32, 1))).u32[0];
  if (fabsf(v5) >= 1.0e-10)
  {
    v6 = v5;
    v7 = vrsqrte_f32((float32x2_t)LODWORD(v5));
    v8 = vmul_f32(v7, vrsqrts_f32((float32x2_t)LODWORD(v6), vmul_f32(v7, v7)));
    v3 = vmulq_n_f32(v3, vmul_f32(v8, vrsqrts_f32((float32x2_t)LODWORD(v6), vmul_f32(v8, v8))).f32[0]);
  }
  v9 = vmulq_f32(a2, a2);
  LODWORD(v10) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v9, 2), vaddq_f32(v9, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v9.f32, 1))).u32[0];
  if (fabsf(v10) >= 1.0e-10)
  {
    v11 = v10;
    v12 = vrsqrte_f32((float32x2_t)LODWORD(v10));
    v13 = vmul_f32(v12, vrsqrts_f32((float32x2_t)LODWORD(v11), vmul_f32(v12, v12)));
    a2 = vmulq_n_f32(a2, vmul_f32(v13, vrsqrts_f32((float32x2_t)LODWORD(v11), vmul_f32(v13, v13))).f32[0]);
  }
  v2.i32[2] = *(_DWORD *)a1;
  v14 = vmulq_f32(v3, a2);
  v15 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 2), vaddq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 1))).u64[0];
  if (*(float *)v15.i32 == -1.0
    || (v16 = (float)((float)(fabsf(*(float *)v15.i32) + 1.0) + 1.0) * 0.00001,
        *(float *)v15.i32 = *(float *)v15.i32 + 1.0,
        fabsf(*(float *)v15.i32) < v16))
  {
    if (fabsf(v3.f32[2]) >= 0.00001)
    {
      v17.i32[0] = 0;
      v17.f32[1] = -v3.f32[2];
      v17.i64[1] = v3.u32[1];
    }
    else
    {
      v17 = (float32x4_t)vtrn1q_s32((int32x4_t)COERCE_UNSIGNED_INT(-v3.f32[1]), (int32x4_t)v3);
    }
    v18 = (int32x4_t)vmulq_f32(v17, v17);
    v18.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v18, 2), vadd_f32(*(float32x2_t *)v18.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v18.i8, 1))).u32[0];
    v19 = vrsqrte_f32((float32x2_t)v18.u32[0]);
    v20 = vmul_f32(v19, vrsqrts_f32((float32x2_t)v18.u32[0], vmul_f32(v19, v19)));
    v21 = vmulq_n_f32(v17, vmul_f32(v20, vrsqrts_f32((float32x2_t)v18.u32[0], vmul_f32(v20, v20))).f32[0]);
    v17.i32[0] = 0;
  }
  else
  {
    v22 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a2, (int32x4_t)a2), (int8x16_t)a2, 0xCuLL), vnegq_f32(v3)), a2, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v3, (int32x4_t)v3), (int8x16_t)v3, 0xCuLL));
    v17 = (float32x4_t)vuzp1q_s32((int32x4_t)v22, (int32x4_t)v22);
    v23 = (float32x4_t)vextq_s8((int8x16_t)v17, v22, 0xCuLL);
    *(float *)v15.i32 = sqrtf(*(float *)v15.i32 + *(float *)v15.i32);
    v17.f32[0] = *(float *)v15.i32 * 0.5;
    v21 = vdivq_f32(v23, (float32x4_t)vdupq_lane_s32(v15, 0));
  }
  v24 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v21, (int32x4_t)v21), (int8x16_t)v21, 0xCuLL);
  v25 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v2, (int32x4_t)v2), (int8x16_t)v2, 0xCuLL);
  v26 = vnegq_f32(v21);
  v27 = vmlaq_f32(vmulq_f32(v25, v26), v2, v24);
  v28 = (int8x16_t)vaddq_f32(v27, v27);
  v29 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v28, (int32x4_t)v28), v28, 0xCuLL);
  v30 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v29, (int32x4_t)v29), (int8x16_t)v29, 0xCuLL), v26), v29, v24);
  v31 = vaddq_f32(vaddq_f32(v2, vmulq_n_f32(v29, v17.f32[0])), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v30, (int32x4_t)v30), v30, 0xCuLL));
  v32 = vmulq_f32(v31, v31);
  LODWORD(v33) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v32, 2), vaddq_f32(v32, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v32.f32, 1))).u32[0];
  if (fabsf(v33) >= 1.0e-10)
  {
    v34 = v33;
    v35 = vrsqrte_f32((float32x2_t)LODWORD(v33));
    v36 = vmul_f32(v35, vrsqrts_f32((float32x2_t)LODWORD(v34), vmul_f32(v35, v35)));
    v31 = vmulq_n_f32(v31, vmul_f32(v36, vrsqrts_f32((float32x2_t)LODWORD(v34), vmul_f32(v36, v36))).f32[0]);
  }
  v37 = vmulq_f32(v2, v2);
  LODWORD(v38) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v37, 2), vaddq_f32(v37, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v37.f32, 1))).u32[0];
  v39 = v2;
  if (fabsf(v38) >= 1.0e-10)
  {
    v40 = v38;
    v41 = vrsqrte_f32((float32x2_t)LODWORD(v38));
    v42 = vmul_f32(v41, vrsqrts_f32((float32x2_t)LODWORD(v40), vmul_f32(v41, v41)));
    v39 = vmulq_n_f32(v2, vmul_f32(v42, vrsqrts_f32((float32x2_t)LODWORD(v40), vmul_f32(v42, v42))).f32[0]);
    v25 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v39, (int32x4_t)v39), (int8x16_t)v39, 0xCuLL);
  }
  v73 = v2;
  v43 = v21;
  v43.i32[3] = v17.i32[0];
  v44 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v17.f32, 0);
  v45 = vmulq_f32(v31, v39);
  v46 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v45, 2), vaddq_f32(v45, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v45.f32, 1))).f32[0];
  if (v46 == -1.0 || (v47 = (float)((float)(fabsf(v46) + 1.0) + 1.0) * 0.00001, v48 = v46 + 1.0, fabsf(v48) < v47))
  {
    if (fabsf(v31.f32[2]) >= 0.00001)
    {
      v49.i32[0] = 0;
      v49.f32[1] = -v31.f32[2];
      v49.i64[1] = v31.u32[1];
    }
    else
    {
      v49 = (float32x4_t)vtrn1q_s32((int32x4_t)COERCE_UNSIGNED_INT(-v31.f32[1]), (int32x4_t)v31);
    }
    v50 = (int32x4_t)vmulq_f32(v49, v49);
    v50.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v50, 2), vadd_f32(*(float32x2_t *)v50.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v50.i8, 1))).u32[0];
    v51 = vrsqrte_f32((float32x2_t)v50.u32[0]);
    v52 = vmul_f32(v51, vrsqrts_f32((float32x2_t)v50.u32[0], vmul_f32(v51, v51)));
    v53 = vmulq_n_f32(v49, vmul_f32(v52, vrsqrts_f32((float32x2_t)v50.u32[0], vmul_f32(v52, v52))).f32[0]);
    v54 = 0.0;
  }
  else
  {
    v55 = (int8x16_t)vmlaq_f32(vmulq_f32(v25, vnegq_f32(v31)), v39, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v31, (int32x4_t)v31), (int8x16_t)v31, 0xCuLL));
    v56 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v55, (int32x4_t)v55), v55, 0xCuLL);
    v39.f32[0] = sqrtf(v48 + v48);
    v54 = v39.f32[0] * 0.5;
    v53 = vdivq_f32(v56, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v39.f32, 0));
  }
  v57 = v53;
  v57.f32[3] = v54;
  v58 = (int8x16_t)vmlaq_f32(vmulq_f32(v24, vnegq_f32(v53)), v21, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v53, (int32x4_t)v53), (int8x16_t)v53, 0xCuLL));
  v59 = vmlaq_f32(vmlaq_n_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v58, (int32x4_t)v58), v58, 0xCuLL), v21, v54), v53, v44);
  v60 = vmulq_f32(v43, v57);
  v61 = -(float)(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v60, 2), vaddq_f32(v60, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v60.f32, 1))).f32[0]- (float)(v54 * v17.f32[0]));
  v62 = v59;
  v62.f32[3] = v61;
  v63 = vmulq_f32(v62, v62);
  LODWORD(v64) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v63, 2), vaddq_f32(v63, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v63.f32, 1))).u32[0];
  v65 = 0uLL;
  if (fabsf(v64) >= 1.0e-10)
  {
    v66 = v64;
    v67 = vrsqrte_f32((float32x2_t)LODWORD(v64));
    v68 = vmul_f32(v67, vrsqrts_f32((float32x2_t)LODWORD(v66), vmul_f32(v67, v67)));
    v65 = vmulq_n_f32(v59, vmul_f32(v68, vrsqrts_f32((float32x2_t)LODWORD(v66), vmul_f32(v68, v68))).f32[0]);
  }
  v72 = v65;
  v69 = acosf(v61);
  v70 = vmulq_f32(v73, v72);
  return (float)(v69 + v69)
       * vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v70, 2), vaddq_f32(v70, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v70.f32, 1))).f32[0];
}

uint64_t re::solverSplineIK(uint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, unint64_t a7, unint64_t a8, int32x4_t *a9, unint64_t a10, unint64_t a11)
{
  unint64_t v11;
  uint64_t v12;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  float v20;
  float v21;
  unint64_t v22;
  float TwistAngle;
  int v24;
  uint64_t v25;
  int32x2_t v26;
  uint64_t v27;
  unint64_t v28;
  int32x4_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  int32x4_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t *v40;
  uint64_t *v41;
  uint64_t *v42;
  uint64_t v43;
  unint64_t v44;
  unint64_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float v48;
  __int16 v49;
  float v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t *v53;
  uint64_t v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  __n128 v63;
  float v64;
  float v65;
  float v66;
  float32x4_t v67;
  float32x4_t v68;
  float v69;
  float v70;
  float v71;
  float32x4_t v73;
  float32x4_t v74;
  unint64_t v75;
  float32x4_t v76;
  float v77;
  float v78;
  unsigned int v79;
  BOOL v80;
  uint64_t v81;
  unint64_t v83;
  uint64_t v84;
  float32x4_t v85;
  int32x4_t v86;
  float32x2_t v87;
  float32x2_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float v93;
  float32x4_t v94;
  float v95;
  unsigned int *v96;
  unint64_t *v97;
  unint64_t v98;
  float v100;
  float v104;
  unint64_t v105;
  float v106;
  uint64_t v107;
  unint64_t v108;
  float v109;
  float32x4_t v110;
  int32x4_t v111;
  int32x2_t v112;
  float32x4_t v113;
  float32x4_t v114;
  uint64_t (**v115)();
  _QWORD v116[2];
  unint64_t v117;
  int v118;
  _OWORD v119[2];
  int v120;
  __int128 v121;
  __int128 v122;
  int v123;
  uint64_t v124;
  uint64_t v125;
  char v126;
  __int16 v127;
  uint64_t v128;
  unint64_t v129;
  uint64_t v130;
  uint64_t v131;
  unint64_t v132;
  unint64_t v133;
  _QWORD v134[2];
  char v135;
  uint64_t v136;
  int v137;
  const char *v138;
  __int16 v139;
  int v140;
  __int16 v141;
  unint64_t v142;
  __int16 v143;
  unint64_t v144;
  int32x4_t v145;
  __int128 v146;
  __int128 v147;
  __int128 v148;
  __int128 v149;
  uint64_t v150;

  v17 = a10;
  v18 = a11;
  v19 = (unint64_t)a9;
  v150 = *MEMORY[0x24BDAC8D0];
  v20 = *(float *)a11;
  v21 = *(float *)(a11 + 64);
  if (*(_BYTE *)(a11 + 25))
  {
    v22 = a10 - 1;
    if (!a10)
    {
LABEL_138:
      re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v22, 0);
      _os_crash();
      __break(1u);
      goto LABEL_139;
    }
    v21 = v21 + re::getTwistAngle(a11 + 48, (float32x4_t)a9[v22]);
  }
  else
  {
    v22 = a10;
  }
  if (*(_BYTE *)(a11 + 24))
  {
    if (a10 <= --v22)
    {
LABEL_139:
      re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v22, v17);
      _os_crash();
      __break(1u);
LABEL_140:
      v136 = 0;
      v148 = 0u;
      v149 = 0u;
      v146 = 0u;
      v147 = 0u;
      v145 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v137 = 136315906;
      v138 = "operator[]";
      v139 = 1024;
      v140 = 468;
      v141 = 2048;
      v142 = v11;
      v143 = 2048;
      v144 = a7;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_141;
    }
    TwistAngle = re::getTwistAngle(a11 + 32, (float32x4_t)a9[v22]);
  }
  else
  {
    TwistAngle = 0.0;
  }
  v118 = 0;
  v116[1] = 0;
  v117 = 0;
  v124 = 0;
  memset(v119, 0, sizeof(v119));
  v120 = 0;
  v121 = 0u;
  v122 = 0u;
  v123 = 0;
  v125 = 0x3F80000000000000;
  v115 = &off_24ED23C18;
  v116[0] = 0;
  v24 = *(_DWORD *)(a11 + 16);
  v11 = (v24 - 5);
  v126 = 1;
  v98 = a8;
  if ((_WORD)v24 == 5)
  {
    v118 = 1;
    v127 = 0;
  }
  else
  {
    re::DynamicArray<re::Vector3<float>>::resize((uint64_t)v116, (unsigned __int16)(3 * (v24 - 5) + 1));
    v127 = v24 - 5;
    if (!v126)
      re::DynamicArray<float>::resize((uint64_t)v119 + 8, (unsigned __int16)(v24 - 5) + 1);
  }
  ((void (*)(uint64_t (***)()))v115[11])(&v115);
  v27 = (v24 - 2);
  if (v27 >= 3)
  {
    a8 = 2;
    while (1)
    {
      v28 = *(_QWORD *)(a11 + 16);
      if (v28 <= a8)
        break;
      ((void (*)(uint64_t (***)(), _QWORD, float))v115[13])(&v115, (a8 - 2), *(float *)(*(_QWORD *)(a11 + 8) + 4 * a8));
      if (v27 == ++a8)
        goto LABEL_17;
    }
LABEL_121:
    re::internal::assertLog((re::internal *)6, v25, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, a8, v28);
    _os_crash();
    __break(1u);
LABEL_122:
    v136 = 0;
    v148 = 0u;
    v149 = 0u;
    v146 = 0u;
    v147 = 0u;
    v145 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v137 = 136315906;
    v138 = "operator[]";
    v139 = 1024;
    v140 = 468;
    v141 = 2048;
    v142 = v11;
    v143 = 2048;
    v144 = a8;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_123:
    v136 = 0;
    v148 = 0u;
    v149 = 0u;
    v146 = 0u;
    v147 = 0u;
    v145 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v137 = 136315906;
    v138 = "operator[]";
    v139 = 1024;
    v140 = 468;
    v141 = 2048;
    v142 = v11;
    v143 = 2048;
    v144 = a8;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_124:
    v136 = 0;
    v148 = 0u;
    v149 = 0u;
    v146 = 0u;
    v147 = 0u;
    v145 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v137 = 136315906;
    v138 = "operator[]";
    v139 = 1024;
    v140 = 468;
    v141 = 2048;
    v142 = v12;
    v143 = 2048;
    v144 = a8;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_125:
    v136 = 0;
    v148 = 0u;
    v149 = 0u;
    v146 = 0u;
    v147 = 0u;
    v145 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v137 = 136315906;
    v138 = "operator[]";
    v139 = 1024;
    v140 = 468;
    v141 = 2048;
    v142 = a7;
    v143 = 2048;
    v144 = a8;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_126:
    v136 = 0;
    v148 = 0u;
    v149 = 0u;
    v146 = 0u;
    v147 = 0u;
    v145 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v137 = 136315906;
    v138 = "operator[]";
    v139 = 1024;
    v140 = 468;
    v141 = 2048;
    v142 = a5;
    v143 = 2048;
    v144 = a8;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_127:
    v136 = 0;
    v148 = 0u;
    v149 = 0u;
    v146 = 0u;
    v147 = 0u;
    v145 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v137 = 136315906;
    v138 = "operator[]";
    v139 = 1024;
    v140 = 468;
    v141 = 2048;
    v142 = a7;
    v143 = 2048;
    v144 = a8;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_128;
  }
LABEL_17:
  if (!v22)
    goto LABEL_131;
  a8 = (unint64_t)&v137;
  if (!v117)
  {
LABEL_132:
    v134[0] = 0;
    v148 = 0u;
    v149 = 0u;
    v146 = 0u;
    v147 = 0u;
    v145 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v137 = 136315906;
    *(_QWORD *)(a8 + 4) = "operator[]";
    v139 = 1024;
    *(_DWORD *)(a8 + 14) = 789;
    v141 = 2048;
    *(_QWORD *)(a8 + 20) = 0;
    v143 = 2048;
    *(_QWORD *)(a8 + 30) = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_133:
    re::internal::assertLog((re::internal *)6, v25, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_134;
  }
  v96 = (unsigned int *)a5;
  v97 = (unint64_t *)a7;
  v29 = *a9;
  **(_OWORD **)&v119[0] = *a9;
  v107 = a1;
  if ((_DWORD)v11)
  {
    a7 = (unint64_t)a9;
    a8 = 0;
    v30 = 0;
    a5 = 1;
    v108 = v22;
    v105 = v11;
    while (1)
    {
      v31 = v30 + 2;
      v32 = *(_QWORD *)(v18 + 16);
      if (v32 <= v30 + 2)
        goto LABEL_112;
      v33 = v30 + 3;
      if (v32 <= v30 + 3)
        break;
      if (v22 == v30)
        goto LABEL_114;
      v34 = *(_QWORD *)(v18 + 8);
      v29.i32[0] = *(_DWORD *)(v34 + 4 * v30 + 8);
      v26.i32[0] = *(_DWORD *)(v34 + 4 * v30 + 12);
      v111 = v29;
      v112 = v26;
      v35 = v34 + a8;
      v29.i32[1] = v29.i32[0];
      v29.i32[2] = v26.i32[0];
      v145 = v29;
      v18 = v36;
      v37 = v111;
      v37.i32[1] = v112.i32[0];
      v37.i32[2] = v112.i32[0];
      v145 = v37;
      a1 = v38;
      v145 = vdupq_lane_s32(v112, 0);
      v11 = a7;
      v19 = (unsigned __int16)a5;
      a7 = v117;
      if (v117 <= (unsigned __int16)a5)
        goto LABEL_115;
      v40 = (unint64_t *)(*(_QWORD *)&v119[0] + 16 * (unsigned __int16)a5);
      *v40 = v22;
      v40[1] = v18;
      v22 = (unsigned __int16)(a5 + 1);
      v18 = v117;
      if (v117 <= v22)
        goto LABEL_116;
      v41 = (uint64_t *)(*(_QWORD *)&v119[0] + 16 * v22);
      *v41 = v12;
      v41[1] = a1;
      v22 = (unsigned __int16)(a5 + 2);
      a1 = v117;
      if (v117 <= v22)
        goto LABEL_117;
      v42 = (uint64_t *)(*(_QWORD *)&v119[0] + 16 * v22);
      *v42 = v39;
      v42[1] = v25;
      a5 = (a5 + 3);
      ++v30;
      a7 = v11 + 16;
      a8 += 4;
      v11 = v105;
      a1 = v107;
      v22 = v108;
      v18 = a11;
      if (v105 == v30)
        goto LABEL_28;
    }
LABEL_113:
    re::internal::assertLog((re::internal *)6, v25, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v33, v32);
    _os_crash();
    __break(1u);
LABEL_114:
    re::internal::assertLog((re::internal *)6, v25, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v22, v22);
    _os_crash();
    __break(1u);
LABEL_115:
    v134[0] = 0;
    v148 = 0u;
    v149 = 0u;
    v146 = 0u;
    v147 = 0u;
    v145 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v137 = 136315906;
    v138 = "operator[]";
    v139 = 1024;
    v140 = 789;
    v141 = 2048;
    v142 = v19;
    v143 = 2048;
    v144 = a7;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_116:
    v134[0] = 0;
    v148 = 0u;
    v149 = 0u;
    v146 = 0u;
    v147 = 0u;
    v145 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v137 = 136315906;
    v138 = "operator[]";
    v139 = 1024;
    v140 = 789;
    v141 = 2048;
    v142 = v22;
    v143 = 2048;
    v144 = v18;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_117:
    v134[0] = 0;
    v148 = 0u;
    v149 = 0u;
    v146 = 0u;
    v147 = 0u;
    v145 = 0u;
    v17 = MEMORY[0x24BDACB70];
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v137 = 136315906;
    v138 = "operator[]";
    v139 = 1024;
    v140 = 789;
    v141 = 2048;
    v142 = v22;
    v143 = 2048;
    v144 = a1;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_118;
  }
LABEL_28:
  if (!a6)
    goto LABEL_133;
  if (!v98)
  {
LABEL_134:
    re::internal::assertLog((re::internal *)6, v25, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_135:
    v136 = 0;
    v148 = 0u;
    v149 = 0u;
    v146 = 0u;
    v147 = 0u;
    v145 = 0u;
    v17 = MEMORY[0x24BDACB70];
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v137 = 136315906;
    v138 = "operator[]";
    v139 = 1024;
    v140 = 468;
    v141 = 2048;
    v142 = v19;
    v143 = 2048;
    v144 = a8;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_136:
    re::internal::assertLog((re::internal *)6, v52, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v18, a1);
    _os_crash();
    __break(1u);
    goto LABEL_137;
  }
  v19 = *v96;
  v18 = *v97;
  v135 = 0;
  v134[0] = &off_24ED42648;
  v134[1] = "Scratch Pad";
  v17 = a2;
  v22 = a2;
  v131 = 0;
  v132 = 0;
  v133 = 0;
  re::FixedArray<re::Vector3<float>>::init<>(&v131, (uint64_t)v134, a2);
  v128 = 0;
  v129 = 0;
  v130 = 0;
  re::FixedArray<int>::init<>(&v128, (uint64_t)v134, a2);
  v44 = a4;
  if ((_DWORD)a2)
  {
    a7 = 0;
    v45 = v18;
    while (a2 > v45)
    {
      a8 = v132;
      if (v132 <= a7)
        goto LABEL_119;
      *(_OWORD *)(v133 + 16 * a7) = *(_OWORD *)(a1 + (v45 << 6) + 48);
      if (a7)
      {
        a8 = v132;
        if (v132 <= a7)
          goto LABEL_125;
        a5 = a7 - 1;
        if (v132 <= a7 - 1)
          goto LABEL_126;
        a8 = v129;
        if (v129 <= a7)
          goto LABEL_127;
        v46 = vsubq_f32(*(float32x4_t *)(v133 + 16 * a7), *(float32x4_t *)(v133 + 16 * a7 - 16));
        v47 = vmulq_f32(v46, v46);
        *(float *)(v130 + 4 * a7) = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v47, 2), vaddq_f32(v47, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v47.f32, 1))).f32[0]);
      }
      if (a4 <= v45)
        goto LABEL_120;
      ++a7;
      v45 = *(unsigned int *)(a3 + 4 * v45);
      if (a2 == a7)
        goto LABEL_41;
    }
LABEL_118:
    re::internal::assertLog((re::internal *)6, v43, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v45, v17);
    _os_crash();
    __break(1u);
LABEL_119:
    v136 = 0;
    v148 = 0u;
    v149 = 0u;
    v146 = 0u;
    v147 = 0u;
    v145 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v137 = 136315906;
    v138 = "operator[]";
    v139 = 1024;
    v140 = 468;
    v141 = 2048;
    v142 = a7;
    v143 = 2048;
    v144 = a8;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_120:
    re::internal::assertLog((re::internal *)6, v43, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v45, v44);
    _os_crash();
    __break(1u);
    goto LABEL_121;
  }
LABEL_41:
  v100 = TwistAngle;
  v106 = v21;
  v48 = ((float (*)(uint64_t (***)(), _QWORD))v115[7])(&v115, 0);
  v49 = ((uint64_t (*)(uint64_t (***)()))v115[6])(&v115);
  v50 = ((float (*)(uint64_t (***)(), _QWORD))v115[7])(&v115, (unsigned __int16)(v49 - 1));
  v51 = ((uint64_t (*)(uint64_t (***)(), float))v115[15])(&v115, v48);
  a8 = v132;
  if (v132 <= v19)
    goto LABEL_135;
  v53 = (uint64_t *)(v133 + 16 * v19);
  *v53 = v51;
  v53[1] = v52;
  v54 = (v19 - 1);
  if ((int)v19 - 1 < 0)
    goto LABEL_79;
  v12 = v19;
  v104 = v20;
  v109 = v50;
LABEL_44:
  v11 = (int)v12;
  a8 = v132;
  if (v132 <= (int)v12)
    goto LABEL_122;
  a8 = v129;
  if (v129 <= (int)v12)
    goto LABEL_123;
  v12 = v54;
  a7 = 0;
  v17 = v133;
  v55 = *(float *)(v130 + 4 * v11) * *(float *)(v130 + 4 * v11);
  a8 = 15;
  v56 = 3.4028e38;
  v57 = v48;
  v58 = 3.4028e38;
  while (1)
  {
    v59 = (float)(v57 + v50) * 0.5;
    v60.i64[0] = ((uint64_t (*)(uint64_t (***)(), float))v115[15])(&v115, v59);
    v60.i64[1] = v52;
    v61 = vsubq_f32(v60, *(float32x4_t *)(v17 + 16 * v11));
    v62 = vmulq_f32(v61, v61);
    v63 = (__n128)vaddq_f32(v62, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v62.f32, 1));
    v62.f32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v62, 2), (float32x4_t)v63).f32[0];
    v64 = v62.f32[0] - v55;
    v65 = vabds_f32(v62.f32[0], v55);
    if (v65 < 0.75)
    {
      if ((int)a7 >= 1)
        goto LABEL_61;
      a7 = 1;
      v58 = v56;
      v50 = (float)(v57 + v50) * 0.5;
      v57 = v48;
      goto LABEL_60;
    }
    if (v64 >= 0.0)
    {
      v50 = (float)(v57 + v50) * 0.5;
      goto LABEL_60;
    }
    if (!(_DWORD)a7 || v59 <= v58)
      break;
    a7 = 1;
    v57 = v50;
LABEL_60:
    a8 = (a8 - 1);
    if (!(_DWORD)a8)
    {
LABEL_61:
      if (v65 >= v104)
      {
        v110 = v60;
        v66 = v64 * v64;
        a8 = 5;
        v50 = v109;
        while (1)
        {
          v113 = v61;
          v67.i64[0] = ((uint64_t (*)(uint64_t (***)(), uint64_t, float))v115[16])(&v115, 1, v59);
          v67.i64[1] = v52;
          v68 = vmulq_f32(v113, v67);
          v63 = (__n128)vaddq_f32(v68, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v68.f32, 1));
          v68.f32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v68, 2), (float32x4_t)v63).f32[0];
          v69 = v68.f32[0] + v68.f32[0];
          v63.n128_f32[0] = fabsf(v69);
          if (v63.n128_f32[0] < 0.01)
            goto LABEL_76;
          v70 = v64 / v69;
          v71 = v59 - v70;
          if ((float)(v59 - v70) < v48 || v71 > v109)
            goto LABEL_76;
          v73.i64[0] = ((uint64_t (*)(uint64_t (***)(), float))v115[15])(&v115, v59 - v70);
          v73.i64[1] = v52;
          v61 = vsubq_f32(v73, *(float32x4_t *)(v17 + 16 * v11));
          v74 = vmulq_f32(v61, v61);
          v63 = (__n128)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v74, 2), vaddq_f32(v74, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v74.f32, 1)));
          v64 = v63.n128_f32[0] - v55;
          v63.n128_f32[0] = v64 * v64;
          if ((float)(v64 * v64) >= v66)
            goto LABEL_76;
          if (fabsf(v64) < v104)
            break;
          v110 = v73;
          v59 = v71;
          v66 = v64 * v64;
          a8 = (a8 - 1);
          if (!(_DWORD)a8)
            goto LABEL_76;
        }
        v48 = v71;
        v60 = v73;
      }
      else
      {
        v48 = v59;
        v50 = v109;
      }
LABEL_77:
      a8 = v132;
      if (v132 <= v12)
        goto LABEL_124;
      *(float32x4_t *)(v133 + 16 * v12) = v60;
      v54 = v12 - 1;
      v19 = (v19 - 1);
      if (v12 <= 0)
        goto LABEL_79;
      goto LABEL_44;
    }
  }
  v56 = fminf(v59, v56);
  if ((_DWORD)a7)
  {
    a7 = 1;
LABEL_59:
    v57 = (float)(v57 + v50) * 0.5;
    goto LABEL_60;
  }
  v63.n128_f32[0] = v109 - v59;
  if ((float)(v109 - v59) >= 0.01)
  {
    a7 = 0;
    goto LABEL_59;
  }
  v110 = 0u;
  v59 = 3.4028e38;
  v50 = v109;
LABEL_76:
  v48 = v59;
  v60 = v110;
  if (v59 <= v50)
    goto LABEL_77;
  a1 = ((uint64_t (*)(uint64_t (***)(), uint64_t, float, __n128))v115[16])(&v115, 1, v50, v63);
  v22 = v83;
  v84 = ((uint64_t (*)(uint64_t (***)(), float))v115[15])(&v115, v50);
  a7 = v132;
  if (v132 <= v11)
    goto LABEL_140;
  a8 = v129;
  if (v129 <= v11)
  {
LABEL_141:
    v136 = 0;
    v148 = 0u;
    v149 = 0u;
    v146 = 0u;
    v147 = 0u;
    v145 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v137 = 136315906;
    v138 = "operator[]";
    v139 = 1024;
    v140 = 468;
    v141 = 2048;
    v142 = v11;
    v143 = 2048;
    v144 = a8;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_142;
  }
  v85.i64[0] = a1;
  v85.i64[1] = v22;
  v86 = (int32x4_t)vmulq_f32(v85, v85);
  v86.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v86, 2), vadd_f32(*(float32x2_t *)v86.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v86.i8, 1))).u32[0];
  v87 = vrsqrte_f32((float32x2_t)v86.u32[0]);
  v88 = vmul_f32(v87, vrsqrts_f32((float32x2_t)v86.u32[0], vmul_f32(v87, v87)));
  v88.i32[0] = vmul_f32(v88, vrsqrts_f32((float32x2_t)v86.u32[0], vmul_f32(v88, v88))).u32[0];
  v89.i64[0] = v84;
  v89.i64[1] = v52;
  v90 = vmulq_n_f32(v85, v88.f32[0]);
  v91 = vsubq_f32(v89, *(float32x4_t *)(v133 + 16 * v11));
  v92 = vmulq_f32(v90, v91);
  LODWORD(v93) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v92, 2), vaddq_f32(v92, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v92.f32, 1))).u32[0];
  v94 = vmulq_f32(v91, v91);
  v95 = vmlas_n_f32(-(float)(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v94, 2), vaddq_f32(v94, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v94.f32, 1))).f32[0]- (float)(*(float *)(v130 + 4 * v11) * *(float *)(v130 + 4 * v11))), v93, v93);
  if (v95 < 0.0)
  {
    v80 = 0;
    v81 = 0;
    goto LABEL_91;
  }
  a8 = v12;
  if (v132 <= v12)
  {
LABEL_142:
    v136 = 0;
    v148 = 0u;
    v149 = 0u;
    v146 = 0u;
    v147 = 0u;
    v145 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v137 = 136315906;
    v138 = "operator[]";
    v139 = 1024;
    v140 = 468;
    v141 = 2048;
    v142 = a8;
    v143 = 2048;
    v144 = a7;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  *(float32x4_t *)(v133 + 16 * v12) = vaddq_f32(vmulq_n_f32(v90, sqrtf(v95) - v93), v89);
  if ((int)v12 >= 1)
  {
    while (1)
    {
      a8 = (v19 - 1);
      a7 = v132;
      if (v132 <= a8)
        break;
      a5 = v129;
      if (v129 <= a8)
        goto LABEL_129;
      a5 = (v19 - 2);
      if (v132 <= a5)
        goto LABEL_130;
      *(float32x4_t *)(v133 + 16 * a5) = vaddq_f32(*(float32x4_t *)(v133 + 16 * a8), vmulq_n_f32(v90, *(float *)(v130 + 4 * a8)));
      v19 = (v19 - 1);
      if (a8 <= 1)
        goto LABEL_79;
    }
LABEL_128:
    v136 = 0;
    v148 = 0u;
    v149 = 0u;
    v146 = 0u;
    v147 = 0u;
    v145 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v137 = 136315906;
    v138 = "operator[]";
    v139 = 1024;
    v140 = 468;
    v141 = 2048;
    v142 = a8;
    v143 = 2048;
    v144 = a7;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_129:
    v136 = 0;
    v148 = 0u;
    v149 = 0u;
    v146 = 0u;
    v147 = 0u;
    v145 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v137 = 136315906;
    v138 = "operator[]";
    v139 = 1024;
    v140 = 468;
    v141 = 2048;
    v142 = a8;
    v143 = 2048;
    v144 = a5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_130:
    v136 = 0;
    v148 = 0u;
    v149 = 0u;
    v146 = 0u;
    v147 = 0u;
    v145 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v137 = 136315906;
    v138 = "operator[]";
    v139 = 1024;
    v140 = 468;
    v141 = 2048;
    v142 = a5;
    v143 = 2048;
    v144 = a7;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_131:
    re::internal::assertLog((re::internal *)6, v25, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_132;
  }
LABEL_79:
  a1 = a4;
  if (a4 <= v18)
    goto LABEL_136;
  v19 = a2;
  if (a2 <= v18)
  {
LABEL_137:
    re::internal::assertLog((re::internal *)6, v52, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v18, v19);
    _os_crash();
    __break(1u);
    goto LABEL_138;
  }
  v11 = a3;
  v75 = *(unsigned int *)(a3 + 4 * v18);
  v12 = v107;
  v76 = *(float32x4_t *)(v107 + (v18 << 6) + 48);
  if (a2 >= 3)
  {
    v77 = v106;
    v78 = (float)(v100 - v106) / (float)(a2 - 2);
    v79 = a2 - 1;
LABEL_85:
    a7 = 0;
    a8 = 0;
    a5 = v79;
    while (a2 > v75)
    {
      ++a8;
      v22 = v132;
      if (v132 <= a8)
        goto LABEL_110;
      v22 = v107 + (v75 << 6);
      v114 = *(float32x4_t *)(v22 + 48);
      *(int32x4_t *)v22 = v145;
      *(_OWORD *)(v22 + 16) = v146;
      *(_OWORD *)(v22 + 32) = v147;
      *(_OWORD *)(v22 + 48) = v148;
      if (a4 <= v75)
        goto LABEL_111;
      v77 = v78 + v77;
      v75 = *(unsigned int *)(a3 + 4 * v75);
      a7 += 16;
      v76 = v114;
      if (a5 == a8)
        goto LABEL_90;
    }
    re::internal::assertLog((re::internal *)6, v52, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v75, a2);
    _os_crash();
    __break(1u);
LABEL_110:
    v136 = 0;
    v148 = 0u;
    v149 = 0u;
    v146 = 0u;
    v147 = 0u;
    v145 = 0u;
    v75 = MEMORY[0x24BDACB70];
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v137 = 136315906;
    v138 = "operator[]";
    v139 = 1024;
    v140 = 468;
    v141 = 2048;
    v142 = a8;
    v143 = 2048;
    v144 = v22;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_111:
    re::internal::assertLog((re::internal *)6, v52, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v75, a4);
    _os_crash();
    __break(1u);
LABEL_112:
    re::internal::assertLog((re::internal *)6, v25, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v31, v32);
    _os_crash();
    __break(1u);
    goto LABEL_113;
  }
  v79 = a2 - 1;
  v77 = v106;
  if ((_DWORD)a2 != 1)
  {
    v78 = 0.0;
    goto LABEL_85;
  }
LABEL_90:
  v80 = v129 == 0;
  v81 = 1;
LABEL_91:
  if (v128 && !v80)
    (*(void (**)(void))(*(_QWORD *)v128 + 40))();
  if (v131 && v132)
    (*(void (**)(void))(*(_QWORD *)v131 + 40))();
  re::Allocator::~Allocator((re::Allocator *)v134);
  re::Spline<re::Vector3<float>>::~Spline((uint64_t)&v115);
  return v81;
}

float32x4_t `anonymous namespace'::calculateFABRIKChain(float32x4_t *a1, uint64_t a2, int a3, uint64_t a4)
{
  unint64_t v4;
  int v5;
  int v6;
  int v7;
  float32x4_t result;
  unint64_t v9;
  uint64_t v10;
  int v11;
  unint64_t v12;
  uint64_t v13;
  float32x4_t v14;
  float32x4_t v15;
  int32x4_t v16;
  float32x2_t v17;
  float32x2_t v18;

  v4 = *(_QWORD *)(a4 + 8);
  if (a3)
    v5 = v4 - 1;
  else
    v5 = 0;
  if (a3)
    v6 = -1;
  else
    v6 = 1;
  if (a3)
    v7 = -1;
  else
    v7 = *(_QWORD *)(a4 + 8);
  if (v4 <= v5)
    goto LABEL_21;
  result = *a1;
  *(float32x4_t *)(*(_QWORD *)(a4 + 16) + 16 * v5) = *a1;
  if (v5 + v6 != v7)
  {
    v9 = v5 + v6;
    v10 = (uint64_t)((unint64_t)(a3 ^ 1u) << 63) >> 63;
    v11 = v7 - v6;
    while (*(_QWORD *)(a2 + 8) > v10 + v9)
    {
      v12 = *(_QWORD *)(a4 + 8);
      if (v12 <= v9)
        goto LABEL_19;
      if (v12 <= v5)
        goto LABEL_20;
      v13 = *(_QWORD *)(a4 + 16);
      v14 = *(float32x4_t *)(v13 + 16 * v5);
      v15 = vsubq_f32(*(float32x4_t *)(v13 + 16 * v9), v14);
      v16 = (int32x4_t)vmulq_f32(v15, v15);
      v16.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v16, 2), vadd_f32(*(float32x2_t *)v16.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v16.i8, 1))).u32[0];
      v17 = vrsqrte_f32((float32x2_t)v16.u32[0]);
      v18 = vmul_f32(v17, vrsqrts_f32((float32x2_t)v16.u32[0], vmul_f32(v17, v17)));
      result = vaddq_f32(v14, vmulq_n_f32(vmulq_n_f32(v15, vmul_f32(v18, vrsqrts_f32((float32x2_t)v16.u32[0], vmul_f32(v18, v18))).f32[0]), *(float *)(*(_QWORD *)(a2 + 16) + 4 * v10 + 4 * v9)));
      *(float32x4_t *)(v13 + 16 * v9) = result;
      v9 += v6;
      v5 += v6;
      if (v11 == v5)
        return result;
    }
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_19:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_20:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_21:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return result;
}

__n128 `anonymous namespace'::lookAtTransformFromReference(uint64_t a1, uint64_t a2, float32x4_t *a3, float32x4_t *a4, int32x4_t a5, float32x4_t a6, float a7)
{
  float32x4_t v12;
  int32x4_t v13;
  float32x2_t v14;
  float32x2_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int32x2_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  int8x16_t v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  float32x4_t v30;
  int32x4_t v31;
  float32x2_t v32;
  float32x2_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float v37;
  float v38;
  float32x2_t v39;
  float32x2_t v40;
  __float2 v41;
  float32x4_t v42;
  float v43;
  float32x4_t v44;
  float32x4_t v45;
  float v46;
  float v47;
  float32x2_t v48;
  float32x2_t v49;
  float32x4_t v50;
  float32x2_t v51;
  float32x2_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float v55;
  float v56;
  float v57;
  float32x4_t v58;
  int32x4_t v59;
  float32x2_t v60;
  float32x2_t v61;
  float32x4_t v62;
  float v63;
  int8x16_t v64;
  float32x4_t v65;
  uint64_t v66;
  float32x4_t v67;
  int8x16_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  int8x16_t v75;
  float32x4_t v76;
  int8x16_t v77;
  float32x4_t v78;
  float32x4_t v79;
  int8x16_t v80;
  float32x4_t v81;
  int8x16_t v82;
  float32x4_t v83;
  __int128 v84;
  __n128 result;
  __int128 v86;
  float32x4_t v87;
  float v88;
  float32x4_t v89;
  float32x4_t v90;
  __int128 v91;
  __int128 v92;
  __n128 v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  __n128 v100;
  __int128 v101;
  __int128 v102;
  __n128 v103;
  __int128 v104;
  __int128 v105;
  simd_float3x3 v106;
  simd_float3x3 v107;

  v12 = vsubq_f32(a6, *(float32x4_t *)(a2 + 48));
  v13 = (int32x4_t)vmulq_f32(v12, v12);
  v13.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v13, 2), vadd_f32(*(float32x2_t *)v13.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v13.i8, 1))).u32[0];
  v14 = vrsqrte_f32((float32x2_t)v13.u32[0]);
  v15 = vmul_f32(v14, vrsqrts_f32((float32x2_t)v13.u32[0], vmul_f32(v14, v14)));
  v16 = vmulq_n_f32(v12, vmul_f32(v15, vrsqrts_f32((float32x2_t)v13.u32[0], vmul_f32(v15, v15))).f32[0]);
  v17 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v16, (int32x4_t)v16), (int8x16_t)v16, 0xCuLL);
  v18 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(a5, a5), (int8x16_t)a5, 0xCuLL);
  v19 = vnegq_f32(v16);
  v20 = vmlaq_f32(vmulq_f32(v18, v19), (float32x4_t)a5, v17);
  v21 = vmulq_f32(v20, v20);
  v22 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v21.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v21, 2), v21)).u64[0];
  if (*(float *)v22.i32 >= 0.0001)
  {
    v24 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v20, (int32x4_t)v20), (int8x16_t)v20, 0xCuLL);
  }
  else
  {
    v23 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v18, (int32x4_t)v18), (int8x16_t)v18, 0xCuLL), v19), v18, v17);
    v24 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v23, (int32x4_t)v23), (int8x16_t)v23, 0xCuLL);
    v25 = vmulq_f32(v23, v23);
    v22 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v25.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v25, 2), v25)).u64[0];
  }
  *(float *)v22.i32 = sqrtf(*(float *)v22.i32);
  v106.columns[2] = (simd_float3)vdivq_f32(v24, (float32x4_t)vdupq_lane_s32(v22, 0));
  v96 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v106.columns[2], (int32x4_t)v106.columns[2]), (int8x16_t)v106.columns[2], 0xCuLL);
  v97 = (float32x4_t)v106.columns[2];
  v26 = (int8x16_t)vmlaq_f32(vmulq_f32(v96, v19), (float32x4_t)v106.columns[2], v17);
  v106.columns[1] = (simd_float3)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v26, (int32x4_t)v26), v26, 0xCuLL);
  v94 = v16;
  v106.columns[0] = (simd_float3)v16;
  v98 = (float32x4_t)v106.columns[1];
  v107 = __invert_f3(v106);
  v27 = 0;
  v28 = *(_OWORD *)(a2 + 16);
  v29 = *(_OWORD *)(a2 + 32);
  v100 = *(__n128 *)a2;
  v101 = v28;
  v102 = v29;
  do
  {
    *(float32x4_t *)((char *)&v103 + v27 * 8) = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v107.columns[0], COERCE_FLOAT(*(_OWORD *)((char *)&v100 + v27 * 8))), (float32x4_t)v107.columns[1], (float32x2_t)v100.n128_u64[v27], 1), (float32x4_t)v107.columns[2], *(float32x4_t *)((char *)&v100 + v27 * 8), 2);
    v27 += 2;
  }
  while (v27 != 6);
  v99 = *a3;
  v30 = vsubq_f32(*a4, *a3);
  v31 = (int32x4_t)vmulq_f32(v30, v30);
  v31.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v31, 2), vadd_f32(*(float32x2_t *)v31.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v31.i8, 1))).u32[0];
  v32 = vrsqrte_f32((float32x2_t)v31.u32[0]);
  v33 = vmul_f32(v32, vrsqrts_f32((float32x2_t)v31.u32[0], vmul_f32(v32, v32)));
  v34 = vmulq_n_f32(v30, vmul_f32(v33, vrsqrts_f32((float32x2_t)v31.u32[0], vmul_f32(v33, v33))).f32[0]);
  v35 = v34;
  v36 = vmulq_f32(v34, v34);
  LODWORD(v37) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v36, 2), vaddq_f32(v36, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v36.f32, 1))).u32[0];
  v38 = fabsf(v37);
  v90 = v34;
  if (v38 >= 1.0e-10)
  {
    v39 = vrsqrte_f32((float32x2_t)LODWORD(v37));
    v40 = vmul_f32(v39, vrsqrts_f32((float32x2_t)LODWORD(v37), vmul_f32(v39, v39)));
    v35 = vmulq_n_f32(v34, vmul_f32(v40, vrsqrts_f32((float32x2_t)LODWORD(v37), vmul_f32(v40, v40))).f32[0]);
  }
  v88 = v37;
  v89 = v35;
  v95 = v34;
  v92 = v104;
  v93 = v103;
  v91 = v105;
  v41 = __sincosf_stret(a7 * 0.5);
  *(float32x2_t *)v42.f32 = vmul_n_f32(*(float32x2_t *)v89.f32, v41.__sinval);
  v43 = vmuls_lane_f32(v41.__sinval, v89, 2);
  v44 = v94;
  v45 = vmulq_f32(v44, v44);
  LODWORD(v46) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v45, 2), vaddq_f32(v45, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v45.f32, 1))).u32[0];
  if (fabsf(v46) >= 1.0e-10)
  {
    v47 = v46;
    v48 = vrsqrte_f32((float32x2_t)LODWORD(v46));
    v49 = vmul_f32(v48, vrsqrts_f32((float32x2_t)LODWORD(v47), vmul_f32(v48, v48)));
    v44 = vmulq_n_f32(v94, vmul_f32(v49, vrsqrts_f32((float32x2_t)LODWORD(v47), vmul_f32(v49, v49))).f32[0]);
  }
  v42.f32[2] = v43;
  v50 = v90;
  if (v38 >= 1.0e-10)
  {
    v51 = vrsqrte_f32((float32x2_t)LODWORD(v88));
    v52 = vmul_f32(v51, vrsqrts_f32((float32x2_t)LODWORD(v88), vmul_f32(v51, v51)));
    v50 = vmulq_n_f32(v95, vmul_f32(v52, vrsqrts_f32((float32x2_t)LODWORD(v88), vmul_f32(v52, v52))).f32[0]);
  }
  v53 = v42;
  v53.i32[3] = LODWORD(v41.__cosval);
  v54 = vmulq_f32(v44, v50);
  v55 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v54, 2), vaddq_f32(v54, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v54.f32, 1))).f32[0];
  if (v55 == -1.0 || (v56 = (float)((float)(fabsf(v55) + 1.0) + 1.0) * 0.00001, v57 = v55 + 1.0, fabsf(v57) < v56))
  {
    if (fabsf(v44.f32[2]) >= 0.00001)
    {
      v58.i32[0] = 0;
      v58.f32[1] = -v44.f32[2];
      v58.i64[1] = v44.u32[1];
    }
    else
    {
      v58 = (float32x4_t)vtrn1q_s32((int32x4_t)COERCE_UNSIGNED_INT(-v44.f32[1]), (int32x4_t)v44);
    }
    v59 = (int32x4_t)vmulq_f32(v58, v58);
    v59.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v59, 2), vadd_f32(*(float32x2_t *)v59.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v59.i8, 1))).u32[0];
    v60 = vrsqrte_f32((float32x2_t)v59.u32[0]);
    v61 = vmul_f32(v60, vrsqrts_f32((float32x2_t)v59.u32[0], vmul_f32(v60, v60)));
    v62 = vmulq_n_f32(v58, vmul_f32(v61, vrsqrts_f32((float32x2_t)v59.u32[0], vmul_f32(v61, v61))).f32[0]);
    v63 = 0.0;
  }
  else
  {
    v64 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v50, (int32x4_t)v50), (int8x16_t)v50, 0xCuLL), vnegq_f32(v44)), v50, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v44, (int32x4_t)v44), (int8x16_t)v44, 0xCuLL));
    v65 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v64, (int32x4_t)v64), v64, 0xCuLL);
    *(float *)v64.i32 = sqrtf(v57 + v57);
    v63 = *(float *)v64.i32 * 0.5;
    v62 = vdivq_f32(v65, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v64.i8, 0));
  }
  v66 = 0;
  v67 = v62;
  v67.f32[3] = v63;
  v68 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v62, (int32x4_t)v62), (int8x16_t)v62, 0xCuLL), vnegq_f32(v42)), v62, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v42, (int32x4_t)v42), (int8x16_t)v42, 0xCuLL));
  v69 = vmlaq_n_f32(vmlaq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v68, (int32x4_t)v68), v68, 0xCuLL), v62, v53, 3), v42, v63);
  v70 = vmulq_f32(v53, v67);
  v71 = -(float)(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v70, 2), vaddq_f32(v70, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v70.f32, 1))).f32[0]- (float)(v41.__cosval * v63));
  v72 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v69, (int32x4_t)v69), (int8x16_t)v69, 0xCuLL);
  v73 = vnegq_f32(v69);
  v74 = vmlaq_f32(vmulq_f32(v96, v73), v97, v72);
  v75 = (int8x16_t)vaddq_f32(v74, v74);
  v76 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v75, (int32x4_t)v75), v75, 0xCuLL);
  v77 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v76, (int32x4_t)v76), (int8x16_t)v76, 0xCuLL), v73), v76, v72);
  v78 = vaddq_f32(vaddq_f32(v97, vmulq_n_f32(v76, v71)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v77, (int32x4_t)v77), v77, 0xCuLL));
  v79 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v98, (int32x4_t)v98), (int8x16_t)v98, 0xCuLL), v73), v98, v72);
  v80 = (int8x16_t)vaddq_f32(v79, v79);
  v81 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v80, (int32x4_t)v80), v80, 0xCuLL);
  v82 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v81, (int32x4_t)v81), (int8x16_t)v81, 0xCuLL), v73), v81, v72);
  v83 = vaddq_f32(vaddq_f32(v98, vmulq_n_f32(v81, v71)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v82, (int32x4_t)v82), v82, 0xCuLL));
  v100 = v93;
  v101 = v92;
  v102 = v91;
  do
  {
    *(float32x4_t *)((char *)&v103 + v66 * 8) = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v95, COERCE_FLOAT(*(_OWORD *)((char *)&v100 + v66 * 8))), v83, (float32x2_t)v100.n128_u64[v66], 1), v78, *(float32x4_t *)((char *)&v100 + v66 * 8), 2);
    v66 += 2;
  }
  while (v66 != 6);
  result = v103;
  v84 = v104;
  result.n128_u32[3] = 0;
  v86 = v105;
  HIDWORD(v84) = 0;
  HIDWORD(v86) = 0;
  v87 = v99;
  v87.i32[3] = 1.0;
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v84;
  *(_OWORD *)(a1 + 32) = v86;
  *(float32x4_t *)(a1 + 48) = v87;
  return result;
}

void re::BezierSpline<re::Vector3<float>>::~BezierSpline(uint64_t a1)
{
  re::Spline<re::Vector3<float>>::~Spline(a1);
  JUMPOUT(0x2276933B8);
}

void re::BezierSpline<re::Vector3<float>>::resizeSpans(uint64_t a1, unsigned int a2)
{
  if (a2)
  {
    re::DynamicArray<re::Vector3<float>>::resize(a1 + 8, (unsigned __int16)(3 * a2 + 1));
    *(_WORD *)(a1 + 138) = a2;
    if (!*(_BYTE *)(a1 + 136))
      re::DynamicArray<float>::resize(a1 + 48, a2 + 1);
  }
  else
  {
    *(_QWORD *)(a1 + 24) = 0;
    ++*(_DWORD *)(a1 + 32);
    *(_WORD *)(a1 + 138) = 0;
    if (!*(_BYTE *)(a1 + 136))
    {
      *(_QWORD *)(a1 + 64) = 0;
      ++*(_DWORD *)(a1 + 72);
    }
  }
}

_QWORD *re::BezierSpline<re::Vector3<float>>::reserveSpans(_QWORD *result, int a2)
{
  unsigned __int16 v2;

  if (a2)
    v2 = 3 * a2 + 1;
  else
    v2 = 0;
  if (result[2] < (unint64_t)v2)
    return re::DynamicArray<re::Quaternion<float>>::setCapacity(result + 1, v2);
  return result;
}

uint64_t re::BezierSpline<re::Vector3<float>>::degree()
{
  return 3;
}

uint64_t re::BezierSpline<re::Vector3<float>>::spanCount(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 138);
}

uint64_t re::Spline<re::Vector3<float>>::knotCount(uint64_t a1)
{
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1))
    return (unsigned __int16)((*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1) + 1);
  else
    return 0;
}

uint64_t re::Spline<re::Vector3<float>>::knotAtIndex(uint64_t result, unsigned int a2)
{
  uint64_t v3;

  v3 = result;
  if (*(_BYTE *)(result + 136))
  {
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    if ((_DWORD)result != a2)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
  }
  else if (*(_QWORD *)(result + 64) <= (unint64_t)a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return result;
}

uint64_t re::BezierSpline<re::Vector3<float>>::findSpanIndex(uint64_t a1, float a2)
{
  float v2;
  unsigned int v3;
  float v4;
  uint64_t result;

  if (*(_BYTE *)(a1 + 136))
  {
    v2 = *(float *)(a1 + 128);
    if (v2 >= a2)
    {
      LOWORD(v3) = 0;
    }
    else
    {
      v3 = *(unsigned __int16 *)(a1 + 138);
      v4 = *(float *)(a1 + 132);
      if (v4 <= a2)
        LOWORD(v3) = v3 - 1;
      else
        v3 = (int)(float)((float)((float)(a2 - v2) / (float)(v4 - v2)) * (float)v3);
    }
    LOWORD(result) = v3;
  }
  else
  {
    LOWORD(result) = re::internal::findNonUniformSpan(a1 + 48, 0, (unsigned __int16)(*(_WORD *)(a1 + 64) - 1), a2);
  }
  return (unsigned __int16)result;
}

BOOL re::Spline<re::Vector3<float>>::areKnotsNormalized(uint64_t a1)
{
  uint64_t v1;
  float *v2;
  float v3;

  v1 = *(_QWORD *)(a1 + 64);
  if (v1)
  {
    v2 = *(float **)(a1 + 80);
    if (fabsf(*v2) < 0.00001)
    {
      v3 = v2[v1 - 1];
      return v3 == 1.0 || fabsf(v3 + -1.0) < (float)((float)((float)(fabsf(v3) + 1.0) + 1.0) * 0.00001);
    }
    return 0;
  }
  if (fabsf(*(float *)(a1 + 128)) >= 0.00001)
    return 0;
  v3 = *(float *)(a1 + 132);
  return v3 == 1.0 || fabsf(v3 + -1.0) < (float)((float)((float)(fabsf(v3) + 1.0) + 1.0) * 0.00001);
}

uint64_t re::Spline<re::Vector3<float>>::normalizeKnots(uint64_t result)
{
  unint64_t v1;
  unint64_t v2;
  float *v3;
  float v4;
  unint64_t v5;
  float v6;
  float v7;
  float *v8;

  v1 = *(_QWORD *)(result + 64);
  v2 = v1 - 2;
  if (v1 >= 2)
  {
    v3 = *(float **)(result + 80);
    v4 = *v3;
    v5 = v1 - 1;
    v6 = v3[v5];
    *v3 = 0.0;
    if (v5 >= 2)
    {
      v7 = v6 - v4;
      v8 = v3 + 1;
      do
      {
        *v8 = (float)(*v8 - v4) / v7;
        ++v8;
        --v2;
      }
      while (v2);
    }
    v3[v5] = 1.0;
  }
  return result;
}

uint64_t re::Spline<re::Vector3<float>>::setNonUniformKnots(uint64_t a1)
{
  unsigned int v2;

  *(_BYTE *)(a1 + 136) = 0;
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1))
  {
    v2 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
    re::DynamicArray<float>::resize(a1 + 48, v2 + 1);
  }
  else
  {
    *(_QWORD *)(a1 + 64) = 0;
    ++*(_DWORD *)(a1 + 72);
  }
  return 1;
}

uint64_t re::Spline<re::Vector3<float>>::setNonUniformKnots(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  _DWORD *v5;

  *(_BYTE *)(a1 + 136) = 0;
  re::DynamicArray<float>::operator=(a1 + 48, a2);
  v4 = a2[2];
  if (!v4)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  v5 = (_DWORD *)a2[4];
  *(_DWORD *)(a1 + 128) = *v5;
  *(_DWORD *)(a1 + 132) = v5[v4 - 1];
  return 1;
}

uint64_t re::Spline<re::Vector3<float>>::setNonUniformKnotAtIndex(uint64_t a1, unsigned int a2, float a3)
{
  if (*(_QWORD *)(a1 + 64) <= (unint64_t)a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  *(float *)(*(_QWORD *)(a1 + 80) + 4 * a2) = a3;
  return 1;
}

uint64_t re::Spline<re::Vector3<float>>::setUniformKnots(uint64_t result, float a2, float a3)
{
  *(_BYTE *)(result + 136) = 1;
  *(_QWORD *)(result + 64) = 0;
  ++*(_DWORD *)(result + 72);
  *(float *)(result + 128) = a2;
  *(float *)(result + 132) = a3;
  return result;
}

double re::BezierSpline<re::Vector3<float>>::evaluateAt(uint64_t a1, float a2)
{
  float v3;
  unsigned int v4;
  float v5;
  float v6;
  unint64_t v7;
  unint64_t NonUniformSpan;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  double result;

  if (*(_BYTE *)(a1 + 136))
  {
    v3 = *(float *)(a1 + 128);
    if (v3 >= a2)
    {
      LOWORD(v4) = 0;
      v7 = 0;
    }
    else
    {
      v4 = *(unsigned __int16 *)(a1 + 138);
      v5 = *(float *)(a1 + 132);
      if (v5 <= a2)
      {
        LOWORD(v4) = v4 - 1;
        v7 = 0x3F80000000000000;
      }
      else
      {
        v6 = (float)((float)(a2 - v3) / (float)(v5 - v3)) * (float)v4;
        v4 = (int)v6;
        v7 = (unint64_t)COERCE_UNSIGNED_INT(v6 - (float)(int)v6) << 32;
      }
    }
    NonUniformSpan = v7 | (unsigned __int16)v4;
  }
  else
  {
    NonUniformSpan = re::internal::findNonUniformSpan(a1 + 48, 0, (unsigned __int16)(*(_WORD *)(a1 + 64) - 1), a2);
  }
  v9 = (unsigned __int16)(3 * NonUniformSpan);
  v10 = *(_QWORD *)(a1 + 24);
  if (v10 <= v9)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_15;
  }
  v11 = (v9 + 1);
  if (v10 <= v11)
  {
LABEL_15:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_16;
  }
  v12 = (v9 + 2);
  if (v10 <= v12)
  {
LABEL_16:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_17:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  v13 = (v9 + 3);
  if (v10 <= v13)
    goto LABEL_17;
  v14 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)&result = vaddq_f32(vaddq_f32(vaddq_f32(vmulq_n_f32(*(float32x4_t *)(v14 + 16 * v9), (float)(1.0 - *((float *)&NonUniformSpan + 1))* (float)((float)(1.0 - *((float *)&NonUniformSpan + 1))* (float)(1.0 - *((float *)&NonUniformSpan + 1)))), vmulq_n_f32(*(float32x4_t *)(v14 + 16 * v11), (float)((float)((float)(1.0 - *((float *)&NonUniformSpan + 1))* (float)(1.0 - *((float *)&NonUniformSpan + 1)))* 3.0)* *((float *)&NonUniformSpan + 1))), vmulq_n_f32(*(float32x4_t *)(v14 + 16 * v12), (float)(*((float *)&NonUniformSpan + 1) * *((float *)&NonUniformSpan + 1))* (float)((float)(1.0 - *((float *)&NonUniformSpan + 1)) * 3.0))), vmulq_n_f32(*(float32x4_t *)(v14 + 16 * v13),
                           (float)(*((float *)&NonUniformSpan + 1) * *((float *)&NonUniformSpan + 1))
                         * *((float *)&NonUniformSpan + 1))).u64[0];
  return result;
}

double re::BezierSpline<re::Vector3<float>>::evaluateDerivativeAt(uint64_t a1, int a2, float a3)
{
  unsigned int v5;
  float v6;
  float v7;
  float v8;
  int v9;
  unint64_t v10;
  unint64_t NonUniformSpan;
  float v12;
  unint64_t v13;
  int v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  double result;
  int v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  float v25;
  uint64_t v26;
  float v27;
  float32x4_t v28;
  int v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  float32x4_t v34;
  unint64_t v35;

  if (*(_BYTE *)(a1 + 136))
  {
    v5 = *(unsigned __int16 *)(a1 + 138);
    v6 = *(float *)(a1 + 128);
    v7 = *(float *)(a1 + 132);
    if (v6 >= a3)
    {
      LOWORD(v9) = 0;
      v10 = 0;
    }
    else if (v7 <= a3)
    {
      LOWORD(v9) = v5 - 1;
      v10 = 0x3F80000000000000;
    }
    else
    {
      v8 = (float)((float)(a3 - v6) / (float)(v7 - v6)) * (float)v5;
      v9 = (int)v8;
      v10 = (unint64_t)COERCE_UNSIGNED_INT(v8 - (float)(int)v8) << 32;
    }
    v12 = (float)v5 / (float)(v7 - v6);
    NonUniformSpan = v10 | (unsigned __int16)v9;
  }
  else
  {
    NonUniformSpan = re::internal::findNonUniformSpan(a1 + 48, 0, (unsigned __int16)(*(_WORD *)(a1 + 64) - 1), a3);
  }
  switch(a2)
  {
    case 0:
      v13 = *(_QWORD *)(a1 + 24);
      if (v13 <= (unsigned __int16)(3 * NonUniformSpan))
      {
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_28:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_29:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_30:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_31;
      }
      v14 = (unsigned __int16)(3 * NonUniformSpan);
      v15 = (v14 + 1);
      if (v13 <= v15)
      {
LABEL_31:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_32;
      }
      v16 = (v14 + 2);
      if (v13 <= v16)
      {
LABEL_32:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_33:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_34:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_35:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_36:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      v17 = (v14 + 3);
      if (v13 <= v17)
        goto LABEL_33;
      v18 = *(_QWORD *)(a1 + 40);
      *(_QWORD *)&result = vaddq_f32(vaddq_f32(vaddq_f32(vmulq_n_f32(*(float32x4_t *)(v18 + 16 * (unsigned __int16)(3 * NonUniformSpan)), (float)(1.0 - *((float *)&NonUniformSpan + 1))* (float)((float)(1.0 - *((float *)&NonUniformSpan + 1))* (float)(1.0 - *((float *)&NonUniformSpan + 1)))), vmulq_n_f32(*(float32x4_t *)(v18 + 16 * v15), (float)((float)((float)(1.0 - *((float *)&NonUniformSpan + 1))* (float)(1.0 - *((float *)&NonUniformSpan + 1)))* 3.0)* *((float *)&NonUniformSpan + 1))), vmulq_n_f32(*(float32x4_t *)(v18 + 16 * v16), (float)(*((float *)&NonUniformSpan + 1) * *((float *)&NonUniformSpan + 1))* (float)((float)(1.0 - *((float *)&NonUniformSpan + 1)) * 3.0))), vmulq_n_f32(*(float32x4_t *)(v18 + 16 * v17),
                               (float)(*((float *)&NonUniformSpan + 1) * *((float *)&NonUniformSpan + 1))
                             * *((float *)&NonUniformSpan + 1))).u64[0];
      return result;
    case 1:
      v20 = (unsigned __int16)(3 * NonUniformSpan);
      v21 = (v20 + 1);
      v22 = *(_QWORD *)(a1 + 24);
      if (v22 <= v21)
        goto LABEL_28;
      v23 = (v20 + 2);
      if (v22 <= v23)
        goto LABEL_34;
      v24 = (v20 + 3);
      if (v22 <= v24)
        goto LABEL_35;
      v25 = v12 * 3.0;
      v26 = *(_QWORD *)(a1 + 40);
      v27 = 1.0 - *((float *)&NonUniformSpan + 1);
      v28 = vaddq_f32(vaddq_f32(vmulq_n_f32(vsubq_f32(*(float32x4_t *)(v26 + 16 * v21), *(float32x4_t *)(v26 + 16 * (unsigned __int16)(3 * NonUniformSpan))), v27 * v27), vmulq_n_f32(vsubq_f32(*(float32x4_t *)(v26 + 16 * v23), *(float32x4_t *)(v26 + 16 * v21)), (float)(v27 + v27) * *((float *)&NonUniformSpan + 1))), vmulq_n_f32(vsubq_f32(*(float32x4_t *)(v26 + 16 * v24), *(float32x4_t *)(v26 + 16 * v23)), *((float *)&NonUniformSpan + 1) * *((float *)&NonUniformSpan + 1)));
LABEL_23:
      *(_QWORD *)&result = vmulq_n_f32(v28, v25).u64[0];
      return result;
    case 2:
      v29 = (unsigned __int16)(3 * NonUniformSpan);
      v30 = (v29 + 2);
      v31 = *(_QWORD *)(a1 + 24);
      if (v31 <= v30)
        goto LABEL_29;
      v32 = (v29 + 3);
      if (v31 <= v32)
        goto LABEL_36;
      v25 = (float)(v12 * 6.0) * v12;
      v33 = *(_QWORD *)(a1 + 40);
      v34 = *(float32x4_t *)(v33 + 16 * (v29 + 1));
      v28 = vaddq_f32(vmulq_n_f32(vaddq_f32(v34, vsubq_f32(*(float32x4_t *)(v33 + 16 * v32), vaddq_f32(*(float32x4_t *)(v33 + 16 * v30), *(float32x4_t *)(v33 + 16 * v30)))), *((float *)&NonUniformSpan + 1)), vmulq_n_f32(vaddq_f32(*(float32x4_t *)(v33 + 16 * (unsigned __int16)(3 * NonUniformSpan)), vsubq_f32(*(float32x4_t *)(v33 + 16 * v30), vaddq_f32(v34, v34))), 1.0 - *((float *)&NonUniformSpan + 1)));
      goto LABEL_23;
    case 3:
      v35 = (unsigned __int16)(3 * NonUniformSpan) + 3;
      if (*(_QWORD *)(a1 + 24) <= v35)
        goto LABEL_30;
      __asm { FMOV            V3.4S, #3.0 }
      *(_QWORD *)&result = vmulq_n_f32(vsubq_f32(vaddq_f32(vsubq_f32(*(float32x4_t *)(*(_QWORD *)(a1 + 40) + 16 * v35), vmulq_f32(*(float32x4_t *)(*(_QWORD *)(a1 + 40)+ 16 * ((unsigned __int16)(3 * NonUniformSpan) + 2)), _Q3)), vmulq_f32(*(float32x4_t *)(*(_QWORD *)(a1 + 40)+ 16 * ((unsigned __int16)(3 * NonUniformSpan) + 1)), _Q3)), *(float32x4_t *)(*(_QWORD *)(a1 + 40) + 16 * (unsigned __int16)(3 * NonUniformSpan))), (float)((float)(v12 * 6.0) * v12) * v12).u64[0];
      return result;
    default:
      return 0.0;
  }
}

float re::BezierSpline<re::Vector3<float>>::evaluateLengthAt(uint64_t a1, float a2)
{
  float v4;
  unsigned int v5;
  float v6;
  unsigned __int16 NonUniformSpan;
  unint64_t v8;
  unint64_t v9;
  float v10;
  uint64_t v11;
  float v12;
  uint64_t v13;
  uint64_t v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float32x4_t v19;
  uint64_t v20;
  float32x4_t v21;

  if (*(_BYTE *)(a1 + 136))
  {
    v4 = *(float *)(a1 + 128);
    if (v4 >= a2)
    {
      LOWORD(v5) = 0;
    }
    else
    {
      v5 = *(unsigned __int16 *)(a1 + 138);
      v6 = *(float *)(a1 + 132);
      if (v6 <= a2)
        LOWORD(v5) = v5 - 1;
      else
        v5 = (int)(float)((float)((float)(a2 - v4) / (float)(v6 - v4)) * (float)v5);
    }
    NonUniformSpan = v5;
  }
  else
  {
    NonUniformSpan = re::internal::findNonUniformSpan(a1 + 48, 0, (unsigned __int16)(*(_WORD *)(a1 + 64) - 1), a2);
  }
  v8 = *(_QWORD *)(a1 + 104);
  if (!v8)
  {
    if (NonUniformSpan)
    {
      v11 = 0;
      v10 = 0.0;
      do
      {
        v10 = v10 + (*(float (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 152))(a1, v11);
        v11 = (v11 + 1);
      }
      while (NonUniformSpan != (_DWORD)v11);
      goto LABEL_18;
    }
LABEL_17:
    v10 = 0.0;
    goto LABEL_18;
  }
  if (!NonUniformSpan)
    goto LABEL_17;
  v9 = NonUniformSpan - 1;
  if (v8 <= v9)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  v10 = *(float *)(*(_QWORD *)(a1 + 120) + 4 * v9);
LABEL_18:
  v12 = (*(float (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 56))(a1, NonUniformSpan);
  v13 = 0;
  v14 = qword_255803708;
  v15 = (float)(v12 + a2) * 0.5;
  v16 = (float)(a2 - v12) * 0.5;
  v17 = 0.0;
  do
  {
    v18 = *(float *)(v14 + v13 + 4);
    v19.i64[0] = (*(uint64_t (**)(uint64_t, uint64_t, float))(*(_QWORD *)a1 + 128))(a1, 1, v15 + (float)(v16 * *(float *)(v14 + v13)));
    v19.i64[1] = v20;
    v21 = vmulq_f32(v19, v19);
    v17 = v17
        + (float)(v18
                * sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v21, 2), vaddq_f32(v21, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v21.f32, 1))).f32[0]));
    v13 += 8;
  }
  while (v13 != 128);
  return v10 + (float)(v16 * v17);
}

uint64_t re::BezierSpline<re::Vector3<float>>::calculateMonomialBasisForSpan(uint64_t a1, __int16 a2, uint64_t a3)
{
  unint64_t v3;
  int v4;
  unint64_t v5;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;

  v3 = (unsigned __int16)(3 * a2);
  if (*(_QWORD *)(a1 + 24) <= v3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_9;
  }
  v4 = (unsigned __int16)(3 * a2);
  *(_OWORD *)a3 = *(_OWORD *)(*(_QWORD *)(a1 + 40) + 16 * v3);
  v5 = (v4 + 1);
  if (*(_QWORD *)(a1 + 24) <= v5)
  {
LABEL_9:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_10;
  }
  __asm { FMOV            V0.4S, #3.0 }
  *(float32x4_t *)(a3 + 16) = vmulq_f32(vsubq_f32(*(float32x4_t *)(*(_QWORD *)(a1 + 40) + 16 * v5), *(float32x4_t *)(*(_QWORD *)(a1 + 40) + 16 * v3)), _Q0);
  v11 = *(_QWORD *)(a1 + 24);
  if (v11 <= v3)
  {
LABEL_10:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_11;
  }
  if (v11 <= v5)
  {
LABEL_11:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_12;
  }
  v12 = (v4 + 2);
  if (v11 <= v12)
  {
LABEL_12:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_13:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  *(float32x4_t *)(a3 + 32) = vmulq_f32(vaddq_f32(*(float32x4_t *)(*(_QWORD *)(a1 + 40) + 16 * v12), vsubq_f32(*(float32x4_t *)(*(_QWORD *)(a1 + 40) + 16 * v3), vaddq_f32(*(float32x4_t *)(*(_QWORD *)(a1 + 40) + 16 * v5), *(float32x4_t *)(*(_QWORD *)(a1 + 40) + 16 * v5)))), _Q0);
  v13 = (v4 + 3);
  if (*(_QWORD *)(a1 + 24) <= v13)
    goto LABEL_13;
  *(float32x4_t *)(a3 + 48) = vsubq_f32(vaddq_f32(*(float32x4_t *)(*(_QWORD *)(a1 + 40) + 16 * v13), vmulq_f32(vsubq_f32(*(float32x4_t *)(*(_QWORD *)(a1 + 40) + 16 * v5), *(float32x4_t *)(*(_QWORD *)(a1 + 40) + 16 * v12)), _Q0)), *(float32x4_t *)(*(_QWORD *)(a1 + 40) + 16 * v3));
  return 4;
}

float re::BezierSpline<re::Vector3<float>>::evaluateSpanLength(uint64_t a1, unsigned __int16 a2)
{
  float v4;
  float v5;
  uint64_t v6;
  uint64_t v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float32x4_t v12;
  uint64_t v13;
  float32x4_t v14;

  v4 = (*(float (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 56))(a1, a2);
  v5 = (*(float (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 56))(a1, (unsigned __int16)(a2 + 1));
  v6 = 0;
  v7 = qword_255803708;
  v8 = (float)(v4 + v5) * 0.5;
  v9 = (float)(v5 - v4) * 0.5;
  v10 = 0.0;
  do
  {
    v11 = *(float *)(v7 + v6 + 4);
    v12.i64[0] = (*(uint64_t (**)(uint64_t, uint64_t, float))(*(_QWORD *)a1 + 128))(a1, 1, v8 + (float)(v9 * *(float *)(v7 + v6)));
    v12.i64[1] = v13;
    v14 = vmulq_f32(v12, v12);
    v10 = v10
        + (float)(v11
                * sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 2), vaddq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 1))).f32[0]));
    v6 += 8;
  }
  while (v6 != 128);
  return v9 * v10;
}

void re::DynamicArray<re::Vector3<float>>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v4;
  void *v5;
  uint64_t v6;

  v4 = *(_QWORD *)(a1 + 16);
  if (v4 >= a2)
  {
    if (v4 <= a2)
      return;
  }
  else
  {
    if (*(_QWORD *)(a1 + 8) < a2)
    {
      re::DynamicArray<re::Quaternion<float>>::setCapacity((_QWORD *)a1, a2);
      v4 = *(_QWORD *)(a1 + 16);
    }
    if (v4 < a2)
    {
      v5 = (void *)(*(_QWORD *)(a1 + 32) + 16 * v4);
      v6 = 16 * a2 - 16 * v4;
      if (v6 >= 1)
        bzero(v5, 16 * (((unint64_t)v6 >> 4) - ((unint64_t)v6 > 0xF)) + 16);
    }
  }
  *(_QWORD *)(a1 + 16) = a2;
  ++*(_DWORD *)(a1 + 24);
}

unint64_t re::internal::findNonUniformSpan(uint64_t a1, unsigned int a2, unsigned int a3, float a4)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  float v7;
  float v8;
  unsigned __int16 v9;
  unint64_t v10;
  float v11;
  float v12;
  float v13;
  float v14;

  v4 = a2;
  v5 = *(_QWORD *)(a1 + 16);
  if (v5 <= a2)
  {
LABEL_25:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_26;
  }
  v6 = *(_QWORD *)(a1 + 32);
  v7 = *(float *)(v6 + 4 * a2);
  if (v7 >= a4)
    goto LABEL_14;
  if (v5 <= a3)
  {
LABEL_26:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_27;
  }
  v8 = *(float *)(v6 + 4 * a3);
  if (v8 > a4)
  {
    v4 = (a3 + a2) >> 1;
    if (v5 > v4)
    {
      v9 = a3;
      while (1)
      {
        v10 = (v4 + 1);
        if (v5 <= v10)
          break;
        if (*(float *)(v6 + 4 * v4) <= a4)
        {
          v8 = *(float *)(v6 + 4 * v10);
          if (v8 >= a4)
            goto LABEL_18;
          a2 = (unsigned __int16)(v4 + 1);
        }
        else
        {
          v9 = v4 - 1;
        }
        v4 = (a2 + v9) >> 1;
        if (v5 <= v4)
          goto LABEL_13;
      }
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_25;
    }
LABEL_13:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_14:
    if (v5 <= v4 + 1)
    {
LABEL_27:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_28:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    v11 = 1.0 / (float)(*(float *)(v6 + 4 * (v4 + 1)) - v7);
    v12 = v7 - v7;
    return v4 | ((unint64_t)COERCE_UNSIGNED_INT(v12 * v11) << 32);
  }
  v4 = (unsigned __int16)(a3 - 1);
  v10 = v4 + 1;
  if (v5 <= v4 + 1)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_18:
    if ((_DWORD)v4 == a3 - 1 || v8 > a4)
    {
      v14 = *(float *)(v6 + 4 * v4);
      v4 = v4;
      v11 = 1.0 / (float)(v8 - v14);
      v12 = a4 - v14;
      return v4 | ((unint64_t)COERCE_UNSIGNED_INT(v12 * v11) << 32);
    }
    v4 = (unsigned __int16)v10;
    v10 = v4 + 1;
    if (v5 <= v4 + 1)
      goto LABEL_28;
  }
  v13 = *(float *)(v6 + 4 * v4);
  v11 = 1.0 / (float)(*(float *)(v6 + 4 * v10) - v13);
  v12 = v8 - v13;
  return v4 | ((unint64_t)COERCE_UNSIGNED_INT(v12 * v11) << 32);
}

uint64_t re::DynamicArray<float>::operator=(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  unint64_t v5;

  if ((uint64_t *)a1 != a2)
  {
    v4 = *a2;
    if (*(_QWORD *)a1)
    {
      if (v4)
        re::DynamicArray<float>::copy((void **)a1, (uint64_t)a2);
      else
        *(_QWORD *)(a1 + 16) = 0;
      ++*(_DWORD *)(a1 + 24);
    }
    else if (v4)
    {
      v5 = a2[2];
      *(_QWORD *)a1 = v4;
      re::DynamicArray<int>::setCapacity((_QWORD *)a1, v5);
      ++*(_DWORD *)(a1 + 24);
      re::DynamicArray<float>::copy((void **)a1, (uint64_t)a2);
    }
  }
  return a1;
}

void **re::DynamicArray<float>::copy(void **result, uint64_t a2)
{
  void **v3;
  unint64_t v4;
  void *v5;

  v3 = result;
  v4 = *(_QWORD *)(a2 + 16);
  if (v4 >= (unint64_t)result[2])
  {
    re::DynamicArray<int>::setCapacity(result, *(_QWORD *)(a2 + 16));
    v5 = v3[2];
    if (v5)
    {
      memmove(v3[4], *(const void **)(a2 + 32), 4 * (_QWORD)v5);
      v5 = v3[2];
    }
    result = (void **)memcpy((char *)v3[4] + 4 * (_QWORD)v5, (const void *)(*(_QWORD *)(a2 + 32) + 4 * (_QWORD)v5), 4 * v4 - 4 * (_QWORD)v5);
  }
  else if (v4)
  {
    result = (void **)memmove(result[4], *(const void **)(a2 + 32), 4 * v4);
  }
  v3[2] = (void *)v4;
  return result;
}

uint64_t `anonymous namespace'::evaluateCubicBlossom(float32x4_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  float32x4_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  float v8;
  float32x4_t v9;
  float32x4_t *v10;
  float v11;
  float32x4_t v12;
  float32x4_t v14;
  _OWORD v15[3];
  uint64_t v16;

  v3 = 0;
  v16 = *MEMORY[0x24BDAC8D0];
  v14 = *a1;
  v15[0] = a1[1];
  v4 = a1[3];
  v15[1] = a1[2];
  v15[2] = v4;
  v5 = a2 + 12;
  v6 = 3;
  do
  {
    v7 = 0;
    v8 = *(float *)(a3 + 4 * v3);
    v9 = v14;
    v10 = (float32x4_t *)v15;
    do
    {
      v11 = (float)(v8 - *(float *)(a2 + 4 * v7)) / (float)(*(float *)(v5 + 4 * v7) - *(float *)(a2 + 4 * v7));
      v12 = vmulq_n_f32(v9, 1.0 - v11);
      ++v7;
      v9 = *v10;
      v10[-1] = vaddq_f32(vmulq_n_f32(*v10, v11), v12);
      ++v10;
    }
    while (v6 != v7);
    ++v3;
    --v6;
    a2 += 4;
  }
  while (v3 != 3);
  return v14.i64[0];
}

uint64_t re::Spline<re::Vector3<float>>::~Spline(uint64_t a1)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;

  *(_QWORD *)a1 = off_24ED23CF0;
  v3 = (_QWORD *)(a1 + 88);
  v2 = *(_QWORD *)(a1 + 88);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 120))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *(_QWORD *)(a1 + 120) = 0;
    v3[1] = 0;
    v3[2] = 0;
    *v3 = 0;
    ++*(_DWORD *)(a1 + 112);
  }
  v4 = *(_QWORD *)(a1 + 48);
  if (v4)
  {
    if (*(_QWORD *)(a1 + 80))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *(_QWORD *)(a1 + 80) = 0;
    *(_QWORD *)(a1 + 56) = 0;
    *(_QWORD *)(a1 + 64) = 0;
    *(_QWORD *)(a1 + 48) = 0;
    ++*(_DWORD *)(a1 + 72);
  }
  v5 = *(_QWORD *)(a1 + 8);
  if (v5)
  {
    if (*(_QWORD *)(a1 + 40))
      (*(void (**)(uint64_t))(*(_QWORD *)v5 + 40))(v5);
    *(_QWORD *)(a1 + 40) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)(a1 + 24) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    ++*(_DWORD *)(a1 + 32);
  }
  return a1;
}

void re::EvaluationDependencyMap::init(_QWORD *a1@<X0>, uint64_t a2@<X1>, re::EvaluationTree *a3@<X2>, uint64_t a4@<X3>, int a5@<W4>, uint64_t a6@<X8>)
{
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t *v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t i;
  _QWORD *v30;
  uint64_t v31;
  _QWORD *v32;
  _QWORD *v33;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  unint64_t *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  _QWORD *v42;
  unint64_t *v43;
  _QWORD *v44;
  unint64_t v45;
  uint64_t v46;
  _QWORD *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  unint64_t *v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t j;
  _QWORD *v57;
  uint64_t v58;
  uint64_t k;
  _QWORD *v60;
  uint64_t v61;
  unint64_t v64;
  unsigned __int8 v65[8];
  __int128 v66;
  uint64_t v67;
  __int128 v68;
  uint64_t v69;
  _OWORD v70[9];
  _OWORD v71[8];
  __int128 v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  _OWORD v76[12];
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  _OWORD v80[12];
  uint64_t v81;
  _OWORD v82[3];
  _OWORD v83[3];
  _OWORD v84[3];
  __int128 v85;
  __int128 v86;
  __int128 v87;
  _OWORD v88[3];
  _OWORD v89[3];
  _OWORD v90[3];
  __int128 v91;
  __int128 v92;
  __int128 v93;
  int v94;
  const char *v95;
  __int16 v96;
  int v97;
  __int16 v98;
  unint64_t v99;
  __int16 v100;
  unint64_t v101;
  __int128 v102;
  __int128 v103;
  __int128 v104;
  __int128 v105;
  __int128 v106;
  uint64_t v107;

  v107 = *MEMORY[0x24BDAC8D0];
  memset(v80, 0, sizeof(v80));
  v78 = 0;
  v77 = 0;
  v79 = 0;
  memset(v76, 0, sizeof(v76));
  v73 = 0;
  v74 = 0;
  v75 = 0;
  v72 = 0u;
  memset(v71, 0, sizeof(v71));
  memset(v70, 0, sizeof(v70));
  re::EvaluationTree::resolveAliasRegisters(a3, a2, a4, v80, &v77, v76, &v73, v70);
  v65[0] = 1;
  v93 = 0u;
  v92 = 0u;
  v91 = 0u;
  memset(v90, 0, sizeof(v90));
  memset(v89, 0, sizeof(v89));
  memset(v88, 0, sizeof(v88));
  v87 = 0u;
  v86 = 0u;
  v85 = 0u;
  memset(v84, 0, sizeof(v84));
  memset(v83, 0, sizeof(v83));
  memset(v82, 0, sizeof(v82));
  v9 = *((_QWORD *)a3 + 210);
  re::FixedArray<BOOL>::init<>(a1, a2, v9);
  re::FixedArray<BOOL>::init<>(v88, a2, v9);
  re::FixedArray<unsigned long>::init<>((uint64_t *)v82, a2, v9);
  v10 = *((_QWORD *)a3 + 215);
  re::FixedArray<BOOL>::init<>(a1 + 3, a2, v10);
  re::FixedArray<BOOL>::init<>((_QWORD *)&v88[1] + 1, a2, v10);
  re::FixedArray<unsigned long>::init<>((uint64_t *)&v82[1] + 1, a2, v10);
  v11 = *((_QWORD *)a3 + 220);
  re::FixedArray<BOOL>::init<>(a1 + 6, a2, v11);
  re::FixedArray<BOOL>::init<>(v89, a2, v11);
  re::FixedArray<unsigned long>::init<>((uint64_t *)v83, a2, v11);
  v12 = *((_QWORD *)a3 + 225);
  re::FixedArray<BOOL>::init<>(a1 + 9, a2, v12);
  re::FixedArray<BOOL>::init<>((_QWORD *)&v89[1] + 1, a2, v12);
  re::FixedArray<unsigned long>::init<>((uint64_t *)&v83[1] + 1, a2, v12);
  v13 = *((_QWORD *)a3 + 230);
  re::FixedArray<BOOL>::init<>(a1 + 12, a2, v13);
  re::FixedArray<BOOL>::init<>(v90, a2, v13);
  re::FixedArray<unsigned long>::init<>((uint64_t *)v84, a2, v13);
  v14 = *((_QWORD *)a3 + 235);
  re::FixedArray<BOOL>::init<>(a1 + 15, a2, v14);
  re::FixedArray<BOOL>::init<>((_QWORD *)&v90[1] + 1, a2, v14);
  re::FixedArray<unsigned long>::init<>((uint64_t *)&v84[1] + 1, a2, v14);
  v15 = *((_QWORD *)a3 + 240);
  re::FixedArray<BOOL>::init<>(a1 + 18, a2, v15);
  re::FixedArray<BOOL>::init<>(&v91, a2, v15);
  re::FixedArray<unsigned long>::init<>((uint64_t *)&v85, a2, v15);
  v16 = *((_QWORD *)a3 + 245);
  re::FixedArray<BOOL>::init<>(a1 + 21, a2, v16);
  re::FixedArray<BOOL>::init<>((_QWORD *)&v92 + 1, a2, v16);
  re::FixedArray<unsigned long>::init<>((uint64_t *)&v86 + 1, a2, v16);
  v64 = 0;
  if (!v65[0])
  {
    *(_BYTE *)a6 = 0;
    *(_OWORD *)(a6 + 8) = v66;
    *(_QWORD *)(a6 + 24) = v67;
    *(_QWORD *)(a6 + 48) = v69;
    *(_OWORD *)(a6 + 32) = v68;
    goto LABEL_46;
  }
  v18 = *((_QWORD *)&v72 + 1);
  if (*((_QWORD *)&v72 + 1))
  {
    v19 = 0;
    v20 = 0;
    while (1)
    {
      v21 = *((_QWORD *)&v72 + 1);
      if (*((_QWORD *)&v72 + 1) <= v20)
        break;
      v22 = v72;
      if (!v65[0])
        goto LABEL_45;
      v23 = v22 + v19;
      if (!v65[0])
        goto LABEL_45;
      if (!v65[0])
        goto LABEL_45;
      ++v20;
      v19 += 24;
      if (v18 == v20)
        goto LABEL_9;
    }
LABEL_74:
    re::internal::assertLog((re::internal *)6, v17, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v20, v21);
    _os_crash();
    __break(1u);
    goto LABEL_75;
  }
LABEL_9:
  if (a5)
  {
    v24 = *((_QWORD *)a3 + 255);
    if (v24)
    {
      v25 = (unint64_t *)*((_QWORD *)a3 + 257);
      v26 = 8 * v24;
      while (1)
      {
        if (!v65[0])
          break;
        ++v25;
        v26 -= 8;
        if (!v26)
          goto LABEL_14;
      }
LABEL_45:
      *(_BYTE *)a6 = 0;
      *(_OWORD *)(a6 + 8) = v66;
      *(_QWORD *)(a6 + 24) = v67;
      *(_QWORD *)(a6 + 48) = v69;
      *(_OWORD *)(a6 + 32) = v68;
LABEL_46:
      v69 = 0;
      v67 = 0;
      v68 = 0uLL;
      goto LABEL_47;
    }
  }
LABEL_14:
  v20 = v64;
  a1[48] = a2;
  a1[49] = v20;
  if (v20)
  {
    if (v20 >> 60)
      goto LABEL_76;
    v27 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 16 * v20, 8);
    a1[50] = v27;
    if (!v27)
    {
LABEL_77:
      re::internal::assertLog((re::internal *)4, v17, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
      _os_crash();
      __break(1u);
    }
    v28 = v20 - 1;
    if (v20 != 1)
    {
      do
      {
        *(_BYTE *)v27 = -1;
        *(_QWORD *)(v27 + 8) = -1;
        v27 += 16;
        --v28;
      }
      while (v28);
    }
    *(_BYTE *)v27 = -1;
    *(_QWORD *)(v27 + 8) = -1;
  }
  for (i = 0; i != 24; i += 3)
  {
    v20 = *(_QWORD *)((char *)v82 + i * 8 + 8);
    v30 = &a1[i];
    v30[24] = a2;
    v30[25] = v20;
    if (v20)
    {
      if (v20 >> 60)
        goto LABEL_72;
      v31 = 16 * v20;
      v32 = (_QWORD *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 16 * v20, 8);
      a1[i + 26] = v32;
      if (!v32)
        goto LABEL_73;
      v33 = v32;
      if (v20 != 1)
      {
        bzero(v32, v31 - 16);
        v33 = (_QWORD *)((char *)v33 + v31 - 16);
      }
      *v33 = 0;
      v33[1] = 0;
    }
  }
  v34 = 0;
  v35 = 0;
  do
  {
    v36 = (char *)v82 + 24 * v34;
    v39 = *((_QWORD *)v36 + 1);
    v37 = (unint64_t *)(v36 + 8);
    v38 = v39;
    if (v39)
    {
      v40 = 0;
      v41 = 0;
      v42 = &a1[3 * v34];
      v43 = v42 + 25;
      v44 = v42 + 26;
      while (1)
      {
        v45 = *v37;
        if (*v37 <= v41)
          break;
        v45 = *v43;
        if (*v43 <= v41)
          goto LABEL_71;
        v46 = *(_QWORD *)(*((_QWORD *)&v82[1] + 3 * v34) + 8 * v41);
        v47 = (_QWORD *)(*v44 + v40);
        *v47 = a1[50] + 16 * v35;
        v47[1] = v46;
        v35 += v46;
        ++v41;
        v40 += 16;
        if (v38 == v41)
          goto LABEL_34;
      }
      v81 = 0;
      v105 = 0u;
      v106 = 0u;
      v103 = 0u;
      v104 = 0u;
      v102 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v94 = 136315906;
      v95 = "operator[]";
      v96 = 1024;
      v97 = 468;
      v98 = 2048;
      v99 = v41;
      v100 = 2048;
      v101 = v45;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_71:
      v81 = 0;
      v105 = 0u;
      v106 = 0u;
      v103 = 0u;
      v104 = 0u;
      v102 = 0u;
      v20 = MEMORY[0x24BDACB70];
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v94 = 136315906;
      v95 = "operator[]";
      v96 = 1024;
      v97 = 468;
      v98 = 2048;
      v99 = v41;
      v100 = 2048;
      v101 = v45;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_72:
      re::internal::assertLog((re::internal *)6, v17, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 16, v20);
      _os_crash();
      __break(1u);
LABEL_73:
      re::internal::assertLog((re::internal *)4, v17, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
      _os_crash();
      __break(1u);
      goto LABEL_74;
    }
LABEL_34:
    ++v34;
  }
  while (v34 != 8);
  if (v18)
  {
    v49 = 0;
    v20 = 0;
    while (1)
    {
      v50 = *((_QWORD *)&v72 + 1);
      if (*((_QWORD *)&v72 + 1) <= v20)
        break;
      v51 = v72 + v49;
      ++v20;
      v49 += 24;
      if (v18 == v20)
        goto LABEL_39;
    }
LABEL_75:
    re::internal::assertLog((re::internal *)6, v48, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v20, v50);
    _os_crash();
    __break(1u);
LABEL_76:
    re::internal::assertLog((re::internal *)6, v17, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 16, v20);
    _os_crash();
    __break(1u);
    goto LABEL_77;
  }
LABEL_39:
  if ((a5 & 1) != 0)
  {
    v52 = *((_QWORD *)a3 + 255);
    if (v52)
    {
      v53 = (unint64_t *)*((_QWORD *)a3 + 257);
      v54 = 8 * v52;
      do
      {
        v55 = *v53++;
        v54 -= 8;
      }
      while (v54);
    }
  }
  *(_BYTE *)a6 = 1;
LABEL_47:
  for (j = 0; j != -192; j -= 24)
  {
    v57 = (_QWORD *)((char *)v82 + j);
    v58 = *(_QWORD *)((char *)&v86 + j + 8);
    if (v58)
    {
      if (v57[22])
      {
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v58 + 40))(v58, *(_QWORD *)((char *)&v87 + j + 8));
        v57[22] = 0;
        v57[23] = 0;
      }
      v57[21] = 0;
    }
  }
  for (k = 0; k != -192; k -= 24)
  {
    v60 = (_QWORD *)((char *)v88 + k);
    v61 = *(_QWORD *)((char *)&v92 + k + 8);
    if (v61)
    {
      if (v60[22])
      {
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v61 + 40))(v61, *(_QWORD *)((char *)&v93 + k + 8));
        v60[22] = 0;
        v60[23] = 0;
      }
      v60[21] = 0;
    }
  }
  if (!v65[0] && v67 && (v68 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v67 + 40))();
  if (v73 && v74)
    (*(void (**)(void))(*(_QWORD *)v73 + 40))();
  re::FixedRegisterTable::~FixedRegisterTable((re::FixedRegisterTable *)v76);
  if (v77 && v78)
    (*(void (**)(void))(*(_QWORD *)v77 + 40))();
  re::FixedRegisterTable::~FixedRegisterTable((re::FixedRegisterTable *)v80);
}

void re::`anonymous namespace'::countRegisterDependenciesForType<int>(uint64_t a1, re::EvaluationTree *a2, char a3, _QWORD *a4, uint64_t a5, uint64_t a6, _QWORD *a7, unsigned __int8 *a8)
{
  unint64_t v8;
  unint64_t v17;
  unint64_t v18;
  BOOL v19;

  v8 = a4[1];
  if (v8)
  {
    v17 = 0;
    while (1)
    {
      v18 = a4[1];
      if (v18 <= v17)
        break;
      if (*a8)
        v19 = v17 >= v8;
      else
        v19 = 1;
      if (v19)
        return;
    }
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v17, v18);
    _os_crash();
    __break(1u);
  }
}

uint64_t re::`anonymous namespace'::countRegisterDependenciesForType<unsigned int>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, _BYTE *a8)
{
  unint64_t v8;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  BOOL v19;

  v8 = *(_QWORD *)(a4 + 24);
  if (v8)
  {
    v16 = result;
    v17 = 0;
    while (1)
    {
      v18 = *(_QWORD *)(a4 + 24);
      if (v18 <= v17)
        break;
      if (*a8)
        v19 = v17 >= v8;
      else
        v19 = 1;
      if (v19)
        return result;
    }
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v17, v18);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::`anonymous namespace'::countRegisterDependenciesForType<float>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, _BYTE *a8)
{
  unint64_t v8;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  BOOL v19;

  v8 = *(_QWORD *)(a4 + 40);
  if (v8)
  {
    v16 = result;
    v17 = 0;
    while (1)
    {
      v18 = *(_QWORD *)(a4 + 40);
      if (v18 <= v17)
        break;
      if (*a8)
        v19 = v17 >= v8;
      else
        v19 = 1;
      if (v19)
        return result;
    }
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v17, v18);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::`anonymous namespace'::countRegisterDependenciesForType<re::Matrix3x3<float>>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, _BYTE *a8)
{
  unint64_t v8;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  BOOL v19;

  v8 = *(_QWORD *)(a4 + 56);
  if (v8)
  {
    v16 = result;
    v17 = 0;
    while (1)
    {
      v18 = *(_QWORD *)(a4 + 56);
      if (v18 <= v17)
        break;
      if (*a8)
        v19 = v17 >= v8;
      else
        v19 = 1;
      if (v19)
        return result;
    }
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v17, v18);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::`anonymous namespace'::countRegisterDependenciesForType<re::Matrix4x4<float>>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, _BYTE *a8)
{
  unint64_t v8;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  BOOL v19;

  v8 = *(_QWORD *)(a4 + 72);
  if (v8)
  {
    v16 = result;
    v17 = 0;
    while (1)
    {
      v18 = *(_QWORD *)(a4 + 72);
      if (v18 <= v17)
        break;
      if (*a8)
        v19 = v17 >= v8;
      else
        v19 = 1;
      if (v19)
        return result;
    }
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v17, v18);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::`anonymous namespace'::countRegisterDependenciesForType<re::Quaternion<float>>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, _BYTE *a8)
{
  unint64_t v8;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  BOOL v19;

  v8 = *(_QWORD *)(a4 + 88);
  if (v8)
  {
    v16 = result;
    v17 = 0;
    while (1)
    {
      v18 = *(_QWORD *)(a4 + 88);
      if (v18 <= v17)
        break;
      if (*a8)
        v19 = v17 >= v8;
      else
        v19 = 1;
      if (v19)
        return result;
    }
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v17, v18);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::`anonymous namespace'::countRegisterDependenciesForType<re::Vector2<float>>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, _BYTE *a8)
{
  unint64_t v8;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  BOOL v19;

  v8 = *(_QWORD *)(a4 + 104);
  if (v8)
  {
    v16 = result;
    v17 = 0;
    while (1)
    {
      v18 = *(_QWORD *)(a4 + 104);
      if (v18 <= v17)
        break;
      if (*a8)
        v19 = v17 >= v8;
      else
        v19 = 1;
      if (v19)
        return result;
    }
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v17, v18);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::`anonymous namespace'::countRegisterDependenciesForType<re::Vector3<float>>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, _BYTE *a8)
{
  unint64_t v8;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  BOOL v19;

  v8 = *(_QWORD *)(a4 + 120);
  if (v8)
  {
    v16 = result;
    v17 = 0;
    while (1)
    {
      v18 = *(_QWORD *)(a4 + 120);
      if (v18 <= v17)
        break;
      if (*a8)
        v19 = v17 >= v8;
      else
        v19 = 1;
      if (v19)
        return result;
    }
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v17, v18);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

void re::`anonymous namespace'::countRegisterDependencies(uint64_t a1, re::EvaluationTree *a2, char a3, unsigned int a4, unint64_t a5, uint64_t a6, uint64_t a7, _QWORD *a8, unsigned __int8 *a9)
{
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  int v24;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  _QWORD *CallbackData;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char v35;
  uint64_t v36;
  uint64_t v37;
  _QWORD *v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  _QWORD *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  int v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  _QWORD *v57;
  unint64_t *v58;
  uint64_t v60;
  char **v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  _QWORD v65[5];
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  _BYTE v77[40];
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  __int128 v89;
  _QWORD v90[4];
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  _BYTE v102[192];
  __int128 v103;
  __int128 v104;
  int v105;
  const char *v106;
  __int16 v107;
  int v108;
  __int16 v109;
  unint64_t v110;
  __int16 v111;
  unint64_t v112;
  uint64_t v113;

  v113 = *MEMORY[0x24BDAC8D0];
  if ((a3 & 1) != 0)
  {
    ++*a8;
    v15 = *(_QWORD *)(a7 + 24 * a4 + 8);
    if (v15 <= a5)
      goto LABEL_55;
    v16 = *(_QWORD *)(a7 + 24 * a4 + 16);
    ++*(_QWORD *)(v16 + 8 * a5);
  }
  v17 = a6 + 24 * a4;
  v19 = *(_QWORD *)(v17 + 8);
  v18 = (unint64_t *)(v17 + 8);
  v15 = v19;
  if (v19 <= a5)
    goto LABEL_54;
  v20 = a6 + 24 * a4;
  v23 = *(_QWORD *)(v20 + 16);
  v22 = (_QWORD *)(v20 + 16);
  v21 = v23;
  v24 = *(unsigned __int8 *)(v23 + a5);
  if (v24 != 2)
  {
    if (v24 == 1)
    {
      *(_QWORD *)v77 = a1;
      memset(&v77[8], 0, 24);
      re::DynamicString::setCapacity(v77, 0x80uLL);
      re::DynamicString::appendf((re::DynamicString *)v77, "A circular dependency has been detected with register type %u, register id %zu.", a4, a5);
      LOBYTE(v89) = 0;
      *((_QWORD *)&v89 + 1) = 4000;
      v90[0] = &re::AnimationErrorCategory(void)::instance;
      *(_OWORD *)&v90[1] = *(_OWORD *)v77;
      v90[3] = *(_QWORD *)&v77[16];
      *(_QWORD *)&v91 = *(_QWORD *)&v77[24];
      re::Result<re::Unit,re::DetailedError>::operator=((uint64_t)a9, (uint64_t)&v89);
      if (!(_BYTE)v89 && v90[1] && (v90[2] & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v90[1] + 40))();
    }
    else
    {
      v57 = v22;
      v58 = v18;
      *(_BYTE *)(v21 + a5) = 1;
      re::EvaluationTree::getRegister((uint64_t)v65, a2, a4, a5);
      v61 = &(&re::kEvaluationCommandDescriptions)[2 * LODWORD(v65[0])];
      v60 = *((unsigned __int8 *)v61 + 9);
      if (*((_BYTE *)v61 + 9))
      {
        v26 = 0;
        while (1)
        {
          v27 = *((unsigned __int8 *)v61 + v26 + 10);
          v28 = v65[v26 + 1];
          v62 = v26;
          if ((_DWORD)v27 == 253)
          {
            v36 = re::BucketArray<re::EvaluationBranchGroupData,8ul>::operator[]((uint64_t)a2 + 1608, v28);
            v64 = *(_QWORD *)(v36 + 40);
            if (!v64)
              goto LABEL_48;
            v37 = v36;
            v31 = 0;
            while (1)
            {
              v38 = (_QWORD *)re::BucketArray<re::EvaluationBranchData,8ul>::operator[](v37, v31);
              v39 = v38[5];
              if (v39 == -1)
                goto LABEL_33;
              v40 = v39 - 0x7FFFFFFFFFFFFFFFLL;
              if (v39 - 0x7FFFFFFFFFFFFFFFLL < 0)
                goto LABEL_32;
              v41 = v37;
              v32 = *((_QWORD *)a2 + 88);
              do
              {
                if (v32 <= v40)
                {
                  *(_QWORD *)&v66 = 0;
                  v91 = 0u;
                  v92 = 0u;
                  memset(v90, 0, sizeof(v90));
                  v89 = 0u;
                  os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
                  *(_DWORD *)v77 = 136315906;
                  *(_QWORD *)&v77[4] = "operator[]";
                  *(_WORD *)&v77[12] = 1024;
                  *(_DWORD *)&v77[14] = 797;
                  *(_WORD *)&v77[18] = 2048;
                  *(_QWORD *)&v77[20] = v40;
                  *(_WORD *)&v77[28] = 2048;
                  *(_QWORD *)&v77[30] = v32;
                  _os_log_send_and_compose_impl();
                  _os_crash_msg();
                  __break(1u);
                  goto LABEL_53;
                }
                v39 = *(_QWORD *)(*((_QWORD *)a2 + 90) + 8 * v40);
                v40 = v39 - 0x7FFFFFFFFFFFFFFFLL;
              }
              while (v39 - 0x7FFFFFFFFFFFFFFFLL >= 0);
              v37 = v41;
LABEL_32:
              if (!*a9)
                return;
LABEL_33:
              v42 = (_QWORD *)*v38;
              v43 = *(_QWORD *)(*v38 + 1304);
              *(_QWORD *)v77 = *(_QWORD *)(*v38 + 1320);
              *(_QWORD *)&v77[8] = v43;
              v44 = v42[168];
              *(_QWORD *)&v77[16] = v42[170];
              *(_QWORD *)&v77[24] = v44;
              v45 = v42[173];
              *(_QWORD *)&v77[32] = v42[175];
              v78 = v45;
              v46 = v42[178];
              v79 = v42[180];
              v80 = v46;
              v47 = v42[183];
              v81 = v42[185];
              v82 = v47;
              v48 = v42[188];
              v83 = v42[190];
              v84 = v48;
              v49 = v42[193];
              v85 = v42[195];
              v86 = v49;
              v50 = v42[200];
              v51 = v42[198];
              v87 = v50;
              v88 = v51;
              v98 = 0u;
              v99 = 0u;
              v96 = 0u;
              v97 = 0u;
              v94 = 0u;
              v95 = 0u;
              v92 = 0u;
              v93 = 0u;
              v91 = 0u;
              v89 = 0u;
              memset(v90, 0, sizeof(v90));
              re::EvaluationTree::resolveAliasRegisters((uint64_t)a2, a1, (uint64_t *)v77, &v89);
              *(_QWORD *)&v66 = v90[0];
              *((_QWORD *)&v66 + 1) = *((_QWORD *)&v89 + 1);
              *(_QWORD *)&v67 = v90[3];
              *((_QWORD *)&v67 + 1) = v90[2];
              *(_QWORD *)&v68 = v92;
              *((_QWORD *)&v68 + 1) = *((_QWORD *)&v91 + 1);
              *(_QWORD *)&v69 = *((_QWORD *)&v93 + 1);
              *((_QWORD *)&v69 + 1) = v93;
              *(_QWORD *)&v70 = v95;
              *((_QWORD *)&v70 + 1) = *((_QWORD *)&v94 + 1);
              v71 = *((_QWORD *)&v96 + 1);
              v72 = v96;
              v73 = v98;
              v74 = *((_QWORD *)&v97 + 1);
              v75 = *((_QWORD *)&v99 + 1);
              v76 = v99;
              v52 = *a9;
              re::FixedRegisterTable::~FixedRegisterTable((re::FixedRegisterTable *)&v89);
              if (!v52)
                return;
              if (++v31 == v64)
                goto LABEL_48;
            }
          }
          if ((_DWORD)v27 != 254)
            break;
          v103 = 0u;
          v104 = 0u;
          memset(v102, 0, sizeof(v102));
          v100 = 0u;
          v101 = 0u;
          v98 = 0u;
          v99 = 0u;
          v96 = 0u;
          v97 = 0u;
          v94 = 0u;
          v95 = 0u;
          v92 = 0u;
          v93 = 0u;
          v91 = 0u;
          v89 = 0u;
          memset(v90, 0, sizeof(v90));
          CallbackData = (_QWORD *)re::EvaluationTree::getCallbackData(a2, v28);
          re::EvaluationTree::resolveAliasRegisters(a2, a1, CallbackData, &v89);
          *(_QWORD *)v77 = v90[1];
          *(_QWORD *)&v77[8] = v90[0];
          *(_QWORD *)&v77[16] = v91;
          *(_QWORD *)&v77[24] = v90[3];
          *(_QWORD *)&v77[32] = *((_QWORD *)&v92 + 1);
          v78 = v92;
          v79 = v94;
          v80 = *((_QWORD *)&v93 + 1);
          v81 = *((_QWORD *)&v95 + 1);
          v82 = v95;
          v83 = v97;
          v84 = *((_QWORD *)&v96 + 1);
          v85 = *((_QWORD *)&v98 + 1);
          v86 = v98;
          v87 = v100;
          v88 = *((_QWORD *)&v99 + 1);
          if (*a9)
          {
            v63 = v101;
            if ((_QWORD)v101)
            {
              v30 = 0;
              v31 = 0;
              while (1)
              {
                v32 = v101;
                if ((unint64_t)v101 <= v31)
                  break;
                v33 = *((_QWORD *)&v101 + 1);
                if (!*a9)
                  goto LABEL_38;
                v34 = v33 + v30;
                if (!*a9)
                  goto LABEL_38;
                if (!*a9)
                  goto LABEL_38;
                ++v31;
                v30 += 24;
                if (v63 == v31)
                  goto LABEL_23;
              }
LABEL_53:
              v65[4] = 0;
              v69 = 0u;
              v70 = 0u;
              v67 = 0u;
              v68 = 0u;
              v66 = 0u;
              v15 = MEMORY[0x24BDACB70];
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              v105 = 136315906;
              v106 = "operator[]";
              v107 = 1024;
              v108 = 468;
              v109 = 2048;
              v110 = v31;
              v111 = 2048;
              v112 = v32;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_54:
              *(_QWORD *)&v66 = 0;
              v91 = 0u;
              v92 = 0u;
              memset(v90, 0, sizeof(v90));
              v89 = 0u;
              v54 = a5;
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              *(_DWORD *)v77 = 136315906;
              *(_QWORD *)&v77[4] = "operator[]";
              *(_WORD *)&v77[12] = 1024;
              *(_DWORD *)&v77[14] = 468;
              *(_WORD *)&v77[18] = 2048;
              *(_QWORD *)&v77[20] = v54;
              *(_WORD *)&v77[28] = 2048;
              *(_QWORD *)&v77[30] = v15;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_55:
              *(_QWORD *)&v66 = 0;
              v91 = 0u;
              v92 = 0u;
              memset(v90, 0, sizeof(v90));
              v89 = 0u;
              v55 = a5;
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              *(_DWORD *)v77 = 136315906;
              *(_QWORD *)&v77[4] = "operator[]";
              *(_WORD *)&v77[12] = 1024;
              *(_DWORD *)&v77[14] = 468;
              *(_WORD *)&v77[18] = 2048;
              *(_QWORD *)&v77[20] = v55;
              *(_WORD *)&v77[28] = 2048;
              *(_QWORD *)&v77[30] = v15;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_56:
              *(_QWORD *)&v66 = 0;
              v91 = 0u;
              v92 = 0u;
              memset(v90, 0, sizeof(v90));
              v89 = 0u;
              v56 = v53;
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              *(_DWORD *)v77 = 136315906;
              *(_QWORD *)&v77[4] = "operator[]";
              *(_WORD *)&v77[12] = 1024;
              *(_DWORD *)&v77[14] = 468;
              *(_WORD *)&v77[18] = 2048;
              *(_QWORD *)&v77[20] = v56;
              *(_WORD *)&v77[28] = 2048;
              *(_QWORD *)&v77[30] = v15;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
            }
LABEL_23:
            v35 = 1;
          }
          else
          {
LABEL_38:
            v35 = 0;
          }
          if ((_QWORD)v103)
          {
            if (*((_QWORD *)&v103 + 1))
            {
              (*(void (**)(void))(*(_QWORD *)v103 + 40))();
              *((_QWORD *)&v103 + 1) = 0;
              *(_QWORD *)&v104 = 0;
            }
            *(_QWORD *)&v103 = 0;
          }
          re::FixedRegisterTable::~FixedRegisterTable((re::FixedRegisterTable *)v102);
          if (*((_QWORD *)&v100 + 1))
          {
            if ((_QWORD)v101)
            {
              (*(void (**)(void))(**((_QWORD **)&v100 + 1) + 40))();
              v101 = 0uLL;
            }
            *((_QWORD *)&v100 + 1) = 0;
          }
          re::FixedRegisterTable::~FixedRegisterTable((re::FixedRegisterTable *)((char *)&v89 + 8));
          if ((v35 & 1) == 0)
            return;
LABEL_48:
          v26 = v62 + 1;
          if (v62 + 1 == v60)
            goto LABEL_49;
        }
        if (*a9)
          goto LABEL_48;
      }
      else
      {
LABEL_49:
        v53 = a5;
        v15 = *v58;
        if (*v58 <= a5)
          goto LABEL_56;
        *(_BYTE *)(*v57 + a5) = 2;
      }
    }
  }
}

void re::`anonymous namespace'::storeRegisterDependenciesForType<int>(re::EvaluationTree *a1, uint64_t a2, uint64_t a3, _QWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  unint64_t v15;
  unint64_t v16;

  v7 = a4[1];
  if (v7)
  {
    v15 = 0;
    while (1)
    {
      v16 = a4[1];
      if (v16 <= v15)
        break;
      if (v7 == v15)
        return;
    }
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v15, v16);
    _os_crash();
    __break(1u);
  }
}

uint64_t re::`anonymous namespace'::storeRegisterDependenciesForType<unsigned int>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;

  v7 = *(_QWORD *)(a4 + 24);
  if (v7)
  {
    v14 = result;
    v15 = 0;
    while (1)
    {
      v16 = *(_QWORD *)(a4 + 24);
      if (v16 <= v15)
        break;
      if (v7 == v15)
        return result;
    }
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v15, v16);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::`anonymous namespace'::storeRegisterDependenciesForType<float>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;

  v7 = *(_QWORD *)(a4 + 40);
  if (v7)
  {
    v14 = result;
    v15 = 0;
    while (1)
    {
      v16 = *(_QWORD *)(a4 + 40);
      if (v16 <= v15)
        break;
      if (v7 == v15)
        return result;
    }
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v15, v16);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::`anonymous namespace'::storeRegisterDependenciesForType<re::Matrix3x3<float>>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;

  v7 = *(_QWORD *)(a4 + 56);
  if (v7)
  {
    v14 = result;
    v15 = 0;
    while (1)
    {
      v16 = *(_QWORD *)(a4 + 56);
      if (v16 <= v15)
        break;
      if (v7 == v15)
        return result;
    }
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v15, v16);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::`anonymous namespace'::storeRegisterDependenciesForType<re::Matrix4x4<float>>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;

  v7 = *(_QWORD *)(a4 + 72);
  if (v7)
  {
    v14 = result;
    v15 = 0;
    while (1)
    {
      v16 = *(_QWORD *)(a4 + 72);
      if (v16 <= v15)
        break;
      if (v7 == v15)
        return result;
    }
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v15, v16);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::`anonymous namespace'::storeRegisterDependenciesForType<re::Quaternion<float>>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;

  v7 = *(_QWORD *)(a4 + 88);
  if (v7)
  {
    v14 = result;
    v15 = 0;
    while (1)
    {
      v16 = *(_QWORD *)(a4 + 88);
      if (v16 <= v15)
        break;
      if (v7 == v15)
        return result;
    }
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v15, v16);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::`anonymous namespace'::storeRegisterDependenciesForType<re::Vector2<float>>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;

  v7 = *(_QWORD *)(a4 + 104);
  if (v7)
  {
    v14 = result;
    v15 = 0;
    while (1)
    {
      v16 = *(_QWORD *)(a4 + 104);
      if (v16 <= v15)
        break;
      if (v7 == v15)
        return result;
    }
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v15, v16);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::`anonymous namespace'::storeRegisterDependenciesForType<re::Vector3<float>>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;

  v7 = *(_QWORD *)(a4 + 120);
  if (v7)
  {
    v14 = result;
    v15 = 0;
    while (1)
    {
      v16 = *(_QWORD *)(a4 + 120);
      if (v16 <= v15)
        break;
      if (v7 == v15)
        return result;
    }
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v15, v16);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

void re::`anonymous namespace'::storeRegisterDependencies(re::EvaluationTree *a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  _QWORD *CallbackData;
  _QWORD *v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t i;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  _QWORD *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  char **v46;
  uint64_t v47;
  uint64_t v48;
  unsigned int v49[8];
  _QWORD v50[2];
  char v51;
  uint64_t v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  _BYTE v64[40];
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  _OWORD v90[12];
  __int128 v91;
  __int128 v92;
  int v93;
  const char *v94;
  __int16 v95;
  int v96;
  __int16 v97;
  _QWORD *v98;
  __int16 v99;
  unint64_t v100;
  uint64_t v101;

  v11 = a5;
  v101 = *MEMORY[0x24BDAC8D0];
  v51 = 0;
  v50[0] = &off_24ED42648;
  v50[1] = "Scratch Pad";
  if ((_DWORD)a2 != 255)
  {
    v14 = *(_QWORD **)(a7 + 24 * a4 + 8);
    if ((unint64_t)v14 <= a5)
    {
LABEL_43:
      *(_QWORD *)&v53 = 0;
      v79 = 0u;
      v80 = 0u;
      v77 = 0u;
      v78 = 0u;
      v76 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v64 = 136315906;
      *(_QWORD *)&v64[4] = "operator[]";
      *(_WORD *)&v64[12] = 1024;
      *(_DWORD *)&v64[14] = 468;
      *(_WORD *)&v64[18] = 2048;
      *(_QWORD *)&v64[20] = v11;
      *(_WORD *)&v64[28] = 2048;
      *(_QWORD *)&v64[30] = v14;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_44;
    }
    v14 = *(_QWORD **)(a8 + 24 * a4 + 8);
    if ((unint64_t)v14 <= a5)
    {
LABEL_44:
      *(_QWORD *)&v53 = 0;
      v79 = 0u;
      v80 = 0u;
      v77 = 0u;
      v78 = 0u;
      v76 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v64 = 136315906;
      *(_QWORD *)&v64[4] = "operator[]";
      *(_WORD *)&v64[12] = 1024;
      *(_DWORD *)&v64[14] = 468;
      *(_WORD *)&v64[18] = 2048;
      *(_QWORD *)&v64[20] = v11;
      *(_WORD *)&v64[28] = 2048;
      *(_QWORD *)&v64[30] = v14;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_45:
      re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v17, v18);
      _os_crash();
      __break(1u);
    }
    v15 = *(_QWORD *)(a7 + 24 * a4 + 16);
    v16 = *(_QWORD *)(a8 + 24 * a4 + 16);
    v17 = *(_QWORD *)(v15 + 8 * a5) - 1;
    *(_QWORD *)(v15 + 8 * a5) = v17;
    v18 = *(_QWORD *)(v16 + 16 * a5 + 8);
    if (v18 <= v17)
      goto LABEL_45;
    v19 = *(_QWORD *)(v16 + 16 * a5) + 16 * v17;
    *(_BYTE *)v19 = a2;
    *(_QWORD *)(v19 + 8) = a3;
  }
  v14 = *(_QWORD **)(a6 + 24 * a4 + 8);
  if ((unint64_t)v14 <= a5)
  {
LABEL_42:
    *(_QWORD *)&v53 = 0;
    v79 = 0u;
    v80 = 0u;
    v77 = 0u;
    v78 = 0u;
    v76 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v64 = 136315906;
    *(_QWORD *)&v64[4] = "operator[]";
    *(_WORD *)&v64[12] = 1024;
    *(_DWORD *)&v64[14] = 468;
    *(_WORD *)&v64[18] = 2048;
    *(_QWORD *)&v64[20] = v11;
    *(_WORD *)&v64[28] = 2048;
    *(_QWORD *)&v64[30] = v14;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_43;
  }
  v20 = *(_QWORD *)(a6 + 24 * a4 + 16);
  if (!*(_BYTE *)(v20 + a5))
  {
    *(_BYTE *)(v20 + a5) = 1;
    re::EvaluationTree::getRegister((uint64_t)v49, a1, a4, a5);
    v46 = &(&re::kEvaluationCommandDescriptions)[2 * v49[0]];
    v45 = *((unsigned __int8 *)v46 + 9);
    if (*((_BYTE *)v46 + 9))
    {
      v21 = 0;
      while (1)
      {
        v22 = *((unsigned __int8 *)v46 + v21 + 10);
        v23 = *(_QWORD *)&v49[2 * v21 + 2];
        v47 = v21;
        if ((_DWORD)v22 != 253)
          break;
        v29 = re::BucketArray<re::EvaluationBranchGroupData,8ul>::operator[]((uint64_t)a1 + 1608, v23);
        v48 = *(_QWORD *)(v29 + 40);
        if (!v48)
          goto LABEL_38;
        v30 = v29;
        for (i = 0; i != v48; ++i)
        {
          v14 = (_QWORD *)re::BucketArray<re::EvaluationBranchData,8ul>::operator[](v30, i);
          v32 = v14[5];
          if (v32 == -1)
            goto LABEL_35;
          v33 = v32 - 0x7FFFFFFFFFFFFFFFLL;
          if (v32 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_34;
          v34 = v30;
          v27 = *((_QWORD *)a1 + 88);
          do
          {
            if (v27 <= v33)
            {
              *(_QWORD *)&v53 = 0;
              v79 = 0u;
              v80 = 0u;
              v77 = 0u;
              v78 = 0u;
              v76 = 0u;
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              *(_DWORD *)v64 = 136315906;
              *(_QWORD *)&v64[4] = "operator[]";
              *(_WORD *)&v64[12] = 1024;
              *(_DWORD *)&v64[14] = 797;
              *(_WORD *)&v64[18] = 2048;
              *(_QWORD *)&v64[20] = v33;
              *(_WORD *)&v64[28] = 2048;
              *(_QWORD *)&v64[30] = v27;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
              goto LABEL_41;
            }
            v32 = *(_QWORD *)(*((_QWORD *)a1 + 90) + 8 * v33);
            v33 = v32 - 0x7FFFFFFFFFFFFFFFLL;
          }
          while (v32 - 0x7FFFFFFFFFFFFFFFLL >= 0);
          v30 = v34;
LABEL_34:
LABEL_35:
          v35 = (_QWORD *)*v14;
          v36 = *(_QWORD *)(*v14 + 1304);
          *(_QWORD *)v64 = *(_QWORD *)(*v14 + 1320);
          *(_QWORD *)&v64[8] = v36;
          v37 = v35[168];
          *(_QWORD *)&v64[16] = v35[170];
          *(_QWORD *)&v64[24] = v37;
          v38 = v35[173];
          *(_QWORD *)&v64[32] = v35[175];
          v65 = v38;
          v39 = v35[178];
          v66 = v35[180];
          v67 = v39;
          v40 = v35[183];
          v68 = v35[185];
          v69 = v40;
          v41 = v35[188];
          v70 = v35[190];
          v71 = v41;
          v42 = v35[193];
          v72 = v35[195];
          v73 = v42;
          v43 = v35[200];
          v44 = v35[198];
          v74 = v43;
          v75 = v44;
          v86 = 0u;
          v87 = 0u;
          v84 = 0u;
          v85 = 0u;
          v82 = 0u;
          v83 = 0u;
          v80 = 0u;
          v81 = 0u;
          v78 = 0u;
          v79 = 0u;
          v76 = 0u;
          v77 = 0u;
          re::EvaluationTree::resolveAliasRegisters((uint64_t)a1, (uint64_t)v50, (uint64_t *)v64, &v76);
          *(_QWORD *)&v53 = v77;
          *((_QWORD *)&v53 + 1) = *((_QWORD *)&v76 + 1);
          *(_QWORD *)&v54 = *((_QWORD *)&v78 + 1);
          *((_QWORD *)&v54 + 1) = v78;
          *(_QWORD *)&v55 = v80;
          *((_QWORD *)&v55 + 1) = *((_QWORD *)&v79 + 1);
          *(_QWORD *)&v56 = *((_QWORD *)&v81 + 1);
          *((_QWORD *)&v56 + 1) = v81;
          *(_QWORD *)&v57 = v83;
          *((_QWORD *)&v57 + 1) = *((_QWORD *)&v82 + 1);
          v58 = *((_QWORD *)&v84 + 1);
          v59 = v84;
          v60 = v86;
          v61 = *((_QWORD *)&v85 + 1);
          v62 = *((_QWORD *)&v87 + 1);
          v63 = v87;
          re::FixedRegisterTable::~FixedRegisterTable((re::FixedRegisterTable *)&v76);
        }
LABEL_38:
        v21 = v47 + 1;
        if (v47 + 1 == v45)
          goto LABEL_8;
      }
      if ((_DWORD)v22 != 254)
      {
        goto LABEL_38;
      }
      v91 = 0u;
      v92 = 0u;
      memset(v90, 0, sizeof(v90));
      v88 = 0u;
      v89 = 0u;
      v86 = 0u;
      v87 = 0u;
      v84 = 0u;
      v85 = 0u;
      v82 = 0u;
      v83 = 0u;
      v80 = 0u;
      v81 = 0u;
      v78 = 0u;
      v79 = 0u;
      v76 = 0u;
      v77 = 0u;
      CallbackData = (_QWORD *)re::EvaluationTree::getCallbackData(a1, v23);
      re::EvaluationTree::resolveAliasRegisters(a1, (uint64_t)v50, CallbackData, &v76);
      *(_QWORD *)v64 = *((_QWORD *)&v77 + 1);
      *(_QWORD *)&v64[8] = v77;
      *(_QWORD *)&v64[16] = v79;
      *(_QWORD *)&v64[24] = *((_QWORD *)&v78 + 1);
      *(_QWORD *)&v64[32] = *((_QWORD *)&v80 + 1);
      v65 = v80;
      v66 = v82;
      v67 = *((_QWORD *)&v81 + 1);
      v68 = *((_QWORD *)&v83 + 1);
      v69 = v83;
      v70 = v85;
      v71 = *((_QWORD *)&v84 + 1);
      v72 = *((_QWORD *)&v86 + 1);
      v73 = v86;
      v74 = v88;
      v75 = *((_QWORD *)&v87 + 1);
      v25 = (_QWORD *)v89;
      if (!(_QWORD)v89)
      {
LABEL_17:
        if ((_QWORD)v91)
        {
          if (*((_QWORD *)&v91 + 1))
          {
            (*(void (**)(void))(*(_QWORD *)v91 + 40))();
            *((_QWORD *)&v91 + 1) = 0;
            *(_QWORD *)&v92 = 0;
          }
          *(_QWORD *)&v91 = 0;
        }
        re::FixedRegisterTable::~FixedRegisterTable((re::FixedRegisterTable *)v90);
        if (*((_QWORD *)&v88 + 1))
        {
          if ((_QWORD)v89)
          {
            (*(void (**)(void))(**((_QWORD **)&v88 + 1) + 40))();
            v89 = 0uLL;
          }
          *((_QWORD *)&v88 + 1) = 0;
        }
        re::FixedRegisterTable::~FixedRegisterTable((re::FixedRegisterTable *)((char *)&v76 + 8));
        goto LABEL_38;
      }
      v26 = 0;
      v14 = 0;
      while (1)
      {
        v27 = v89;
        if ((unint64_t)v89 <= (unint64_t)v14)
          break;
        v28 = *((_QWORD *)&v89 + 1) + v26;
        v14 = (_QWORD *)((char *)v14 + 1);
        v26 += 24;
        if (v25 == v14)
          goto LABEL_17;
      }
LABEL_41:
      v52 = 0;
      v56 = 0u;
      v57 = 0u;
      v54 = 0u;
      v55 = 0u;
      v53 = 0u;
      v11 = MEMORY[0x24BDACB70];
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v93 = 136315906;
      v94 = "operator[]";
      v95 = 1024;
      v96 = 468;
      v97 = 2048;
      v98 = v14;
      v99 = 2048;
      v100 = v27;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_42;
    }
  }
LABEL_8:
  re::Allocator::~Allocator((re::Allocator *)v50);
}

uint64_t re::Result<re::Unit,re::DetailedError>::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _OWORD *v8;

  if (*(_BYTE *)a1)
  {
    if (!*(_BYTE *)a2)
    {
      *(_BYTE *)a1 = 0;
      *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
      *(_OWORD *)(a1 + 40) = 0u;
      *(_OWORD *)(a1 + 24) = 0u;
      *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
      v3 = *(_QWORD *)(a2 + 32);
      *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
      *(_QWORD *)(a2 + 24) = 0;
      v4 = *(_QWORD *)(a2 + 40);
      *(_QWORD *)(a2 + 48) = 0;
      v6 = *(_QWORD *)(a1 + 32);
      v5 = *(_QWORD *)(a1 + 40);
      *(_QWORD *)(a1 + 32) = v3;
      *(_QWORD *)(a1 + 40) = v4;
      *(_QWORD *)(a2 + 32) = v6;
      *(_QWORD *)(a2 + 40) = v5;
    }
  }
  else if (*(_BYTE *)a2)
  {
    v8 = (_OWORD *)(a1 + 24);
    v7 = *(_QWORD *)(a1 + 24);
    if (v7)
    {
      if ((*(_BYTE *)(a1 + 32) & 1) != 0)
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v7 + 40))(v7, *(_QWORD *)(a1 + 40));
      *v8 = 0u;
      *(_OWORD *)(a1 + 40) = 0u;
    }
    *(_BYTE *)a1 = 1;
  }
  else
  {
    *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
    re::DynamicString::operator=((re::DynamicString *)(a1 + 24), (re::DynamicString *)(a2 + 24));
  }
  return a1;
}

_QWORD *re::EvaluationTree::getRegister(uint64_t a1, _QWORD *a2, unsigned __int8 a3, uint64_t a4)
{
  _QWORD *result;

  *(_DWORD *)a1 = -1;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  switch(a3)
  {
    case 0u:
      result = re::EvaluationTree::getRegister<int>(a2, a4, (_OWORD *)a1);
      break;
    case 1u:
      result = re::EvaluationTree::getRegister<unsigned int>(a2, a4, (_OWORD *)a1);
      break;
    case 2u:
      result = re::EvaluationTree::getRegister<float>(a2, a4, (_OWORD *)a1);
      break;
    case 3u:
      result = re::EvaluationTree::getRegister<re::Matrix3x3<float>>(a2, a4, (_OWORD *)a1);
      break;
    case 4u:
      result = re::EvaluationTree::getRegister<re::Matrix4x4<float>>(a2, a4, (_OWORD *)a1);
      break;
    case 5u:
      result = re::EvaluationTree::getRegister<re::Quaternion<float>>(a2, a4, (_OWORD *)a1);
      break;
    case 6u:
      result = re::EvaluationTree::getRegister<re::Vector2<float>>(a2, a4, (_OWORD *)a1);
      break;
    case 7u:
      result = re::EvaluationTree::getRegister<re::Vector3<float>>(a2, a4, (_OWORD *)a1);
      break;
    default:
      re::internal::assertLog((re::internal *)5, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Invalid Register Type: %u", "!\"Unreachable code\"", "getRegister", 885, a3);
      _os_crash();
      __break(1u);
      JUMPOUT(0x2250DE57CLL);
  }
  return result;
}

_QWORD *re::EvaluationTree::getRegister<int>(_QWORD *result, uint64_t a2, _OWORD *a3)
{
  unint64_t v3;
  unint64_t v4;
  _OWORD *v5;
  __int128 v6;
  char **v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;

  v3 = a2;
  v4 = a2 - 0x7FFFFFFFFFFFFFFFLL;
  if (a2 - 0x7FFFFFFFFFFFFFFFLL >= 0)
  {
    while (result[83] > v4)
    {
      v3 = *(_QWORD *)(result[85] + 8 * v4);
      v4 = v3 - 0x7FFFFFFFFFFFFFFFLL;
      if ((uint64_t)(v3 - 0x7FFFFFFFFFFFFFFFLL) < 0)
        goto LABEL_4;
    }
    goto LABEL_51;
  }
LABEL_4:
  if (result[210] <= v3)
  {
LABEL_52:
    v14 = 0;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    LODWORD(v15) = 136315906;
    *(_QWORD *)((char *)&v15 + 4) = "operator[]";
    WORD6(v15) = 1024;
    HIWORD(v15) = 797;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_53:
    re::internal::assertLog((re::internal *)5, a2, "assertion failure: '%s' (%s:line %i) Invalid Register Type: %u", "!\"Unreachable code\"", "getRegister", 866, v11, v14, v15);
    _os_crash();
    __break(1u);
  }
  v5 = (_OWORD *)(result[212] + 32 * v3);
  v6 = v5[1];
  *a3 = *v5;
  a3[1] = v6;
  v7 = &(&re::kEvaluationCommandDescriptions)[2 * *(unsigned int *)a3];
  v8 = *((unsigned __int8 *)v7 + 9);
  if (!*((_BYTE *)v7 + 9))
    return result;
  v9 = 0;
  do
  {
    v10 = *((_QWORD *)v5 + v9 + 1) - 0x7FFFFFFFFFFFFFFFLL;
    if ((v10 & 0x8000000000000000) != 0)
      goto LABEL_41;
    v11 = *((unsigned __int8 *)v7 + v9 + 10);
    switch(*((_BYTE *)v7 + v9 + 10))
    {
      case 0:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[83] > v10)
        {
          v13 = *(_QWORD *)(result[85] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_44;
      case 1:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[88] > v10)
        {
          v13 = *(_QWORD *)(result[90] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
LABEL_44:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_45;
      case 2:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[93] > v10)
        {
          v13 = *(_QWORD *)(result[95] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
LABEL_45:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_46;
      case 3:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[98] > v10)
        {
          v13 = *(_QWORD *)(result[100] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
LABEL_46:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_47;
      case 4:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[103] > v10)
        {
          v13 = *(_QWORD *)(result[105] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
LABEL_47:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_48;
      case 5:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[108] > v10)
        {
          v13 = *(_QWORD *)(result[110] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
LABEL_48:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_49;
      case 6:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[113] > v10)
        {
          v13 = *(_QWORD *)(result[115] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
LABEL_49:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_50;
      case 7:
        v12 = (_QWORD *)a3 + v9 + 1;
        break;
      default:
        goto LABEL_53;
    }
    do
    {
      if (result[118] <= v10)
      {
LABEL_50:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_51:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_52;
      }
      v13 = *(_QWORD *)(result[120] + 8 * v10);
      v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
    }
    while (v13 - 0x7FFFFFFFFFFFFFFFLL >= 0);
LABEL_40:
    *v12 = v13;
LABEL_41:
    ++v9;
  }
  while (v9 != v8);
  return result;
}

_QWORD *re::EvaluationTree::getRegister<unsigned int>(_QWORD *result, uint64_t a2, _OWORD *a3)
{
  unint64_t v3;
  unint64_t v4;
  _OWORD *v5;
  __int128 v6;
  char **v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;

  v3 = a2;
  v4 = a2 - 0x7FFFFFFFFFFFFFFFLL;
  if (a2 - 0x7FFFFFFFFFFFFFFFLL >= 0)
  {
    while (result[88] > v4)
    {
      v3 = *(_QWORD *)(result[90] + 8 * v4);
      v4 = v3 - 0x7FFFFFFFFFFFFFFFLL;
      if ((uint64_t)(v3 - 0x7FFFFFFFFFFFFFFFLL) < 0)
        goto LABEL_4;
    }
    goto LABEL_51;
  }
LABEL_4:
  if (result[215] <= v3)
  {
LABEL_52:
    v14 = 0;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    LODWORD(v15) = 136315906;
    *(_QWORD *)((char *)&v15 + 4) = "operator[]";
    WORD6(v15) = 1024;
    HIWORD(v15) = 797;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_53:
    re::internal::assertLog((re::internal *)5, a2, "assertion failure: '%s' (%s:line %i) Invalid Register Type: %u", "!\"Unreachable code\"", "getRegister", 866, v11, v14, v15);
    _os_crash();
    __break(1u);
  }
  v5 = (_OWORD *)(result[217] + 32 * v3);
  v6 = v5[1];
  *a3 = *v5;
  a3[1] = v6;
  v7 = &(&re::kEvaluationCommandDescriptions)[2 * *(unsigned int *)a3];
  v8 = *((unsigned __int8 *)v7 + 9);
  if (!*((_BYTE *)v7 + 9))
    return result;
  v9 = 0;
  do
  {
    v10 = *((_QWORD *)v5 + v9 + 1) - 0x7FFFFFFFFFFFFFFFLL;
    if ((v10 & 0x8000000000000000) != 0)
      goto LABEL_41;
    v11 = *((unsigned __int8 *)v7 + v9 + 10);
    switch(*((_BYTE *)v7 + v9 + 10))
    {
      case 0:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[83] > v10)
        {
          v13 = *(_QWORD *)(result[85] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_44;
      case 1:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[88] > v10)
        {
          v13 = *(_QWORD *)(result[90] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
LABEL_44:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_45;
      case 2:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[93] > v10)
        {
          v13 = *(_QWORD *)(result[95] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
LABEL_45:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_46;
      case 3:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[98] > v10)
        {
          v13 = *(_QWORD *)(result[100] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
LABEL_46:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_47;
      case 4:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[103] > v10)
        {
          v13 = *(_QWORD *)(result[105] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
LABEL_47:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_48;
      case 5:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[108] > v10)
        {
          v13 = *(_QWORD *)(result[110] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
LABEL_48:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_49;
      case 6:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[113] > v10)
        {
          v13 = *(_QWORD *)(result[115] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
LABEL_49:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_50;
      case 7:
        v12 = (_QWORD *)a3 + v9 + 1;
        break;
      default:
        goto LABEL_53;
    }
    do
    {
      if (result[118] <= v10)
      {
LABEL_50:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_51:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_52;
      }
      v13 = *(_QWORD *)(result[120] + 8 * v10);
      v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
    }
    while (v13 - 0x7FFFFFFFFFFFFFFFLL >= 0);
LABEL_40:
    *v12 = v13;
LABEL_41:
    ++v9;
  }
  while (v9 != v8);
  return result;
}

_QWORD *re::EvaluationTree::getRegister<float>(_QWORD *result, uint64_t a2, _OWORD *a3)
{
  unint64_t v3;
  unint64_t v4;
  _OWORD *v5;
  __int128 v6;
  char **v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;

  v3 = a2;
  v4 = a2 - 0x7FFFFFFFFFFFFFFFLL;
  if (a2 - 0x7FFFFFFFFFFFFFFFLL >= 0)
  {
    while (result[93] > v4)
    {
      v3 = *(_QWORD *)(result[95] + 8 * v4);
      v4 = v3 - 0x7FFFFFFFFFFFFFFFLL;
      if ((uint64_t)(v3 - 0x7FFFFFFFFFFFFFFFLL) < 0)
        goto LABEL_4;
    }
    goto LABEL_51;
  }
LABEL_4:
  if (result[220] <= v3)
  {
LABEL_52:
    v14 = 0;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    LODWORD(v15) = 136315906;
    *(_QWORD *)((char *)&v15 + 4) = "operator[]";
    WORD6(v15) = 1024;
    HIWORD(v15) = 797;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_53:
    re::internal::assertLog((re::internal *)5, a2, "assertion failure: '%s' (%s:line %i) Invalid Register Type: %u", "!\"Unreachable code\"", "getRegister", 866, v11, v14, v15);
    _os_crash();
    __break(1u);
  }
  v5 = (_OWORD *)(result[222] + 32 * v3);
  v6 = v5[1];
  *a3 = *v5;
  a3[1] = v6;
  v7 = &(&re::kEvaluationCommandDescriptions)[2 * *(unsigned int *)a3];
  v8 = *((unsigned __int8 *)v7 + 9);
  if (!*((_BYTE *)v7 + 9))
    return result;
  v9 = 0;
  do
  {
    v10 = *((_QWORD *)v5 + v9 + 1) - 0x7FFFFFFFFFFFFFFFLL;
    if ((v10 & 0x8000000000000000) != 0)
      goto LABEL_41;
    v11 = *((unsigned __int8 *)v7 + v9 + 10);
    switch(*((_BYTE *)v7 + v9 + 10))
    {
      case 0:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[83] > v10)
        {
          v13 = *(_QWORD *)(result[85] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_44;
      case 1:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[88] > v10)
        {
          v13 = *(_QWORD *)(result[90] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
LABEL_44:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_45;
      case 2:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[93] > v10)
        {
          v13 = *(_QWORD *)(result[95] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
LABEL_45:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_46;
      case 3:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[98] > v10)
        {
          v13 = *(_QWORD *)(result[100] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
LABEL_46:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_47;
      case 4:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[103] > v10)
        {
          v13 = *(_QWORD *)(result[105] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
LABEL_47:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_48;
      case 5:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[108] > v10)
        {
          v13 = *(_QWORD *)(result[110] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
LABEL_48:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_49;
      case 6:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[113] > v10)
        {
          v13 = *(_QWORD *)(result[115] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
LABEL_49:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_50;
      case 7:
        v12 = (_QWORD *)a3 + v9 + 1;
        break;
      default:
        goto LABEL_53;
    }
    do
    {
      if (result[118] <= v10)
      {
LABEL_50:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_51:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_52;
      }
      v13 = *(_QWORD *)(result[120] + 8 * v10);
      v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
    }
    while (v13 - 0x7FFFFFFFFFFFFFFFLL >= 0);
LABEL_40:
    *v12 = v13;
LABEL_41:
    ++v9;
  }
  while (v9 != v8);
  return result;
}

_QWORD *re::EvaluationTree::getRegister<re::Matrix3x3<float>>(_QWORD *result, uint64_t a2, _OWORD *a3)
{
  unint64_t v3;
  unint64_t v4;
  _OWORD *v5;
  __int128 v6;
  char **v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;

  v3 = a2;
  v4 = a2 - 0x7FFFFFFFFFFFFFFFLL;
  if (a2 - 0x7FFFFFFFFFFFFFFFLL >= 0)
  {
    while (result[98] > v4)
    {
      v3 = *(_QWORD *)(result[100] + 8 * v4);
      v4 = v3 - 0x7FFFFFFFFFFFFFFFLL;
      if ((uint64_t)(v3 - 0x7FFFFFFFFFFFFFFFLL) < 0)
        goto LABEL_4;
    }
    goto LABEL_51;
  }
LABEL_4:
  if (result[225] <= v3)
  {
LABEL_52:
    v14 = 0;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    LODWORD(v15) = 136315906;
    *(_QWORD *)((char *)&v15 + 4) = "operator[]";
    WORD6(v15) = 1024;
    HIWORD(v15) = 797;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_53:
    re::internal::assertLog((re::internal *)5, a2, "assertion failure: '%s' (%s:line %i) Invalid Register Type: %u", "!\"Unreachable code\"", "getRegister", 866, v11, v14, v15);
    _os_crash();
    __break(1u);
  }
  v5 = (_OWORD *)(result[227] + 32 * v3);
  v6 = v5[1];
  *a3 = *v5;
  a3[1] = v6;
  v7 = &(&re::kEvaluationCommandDescriptions)[2 * *(unsigned int *)a3];
  v8 = *((unsigned __int8 *)v7 + 9);
  if (!*((_BYTE *)v7 + 9))
    return result;
  v9 = 0;
  do
  {
    v10 = *((_QWORD *)v5 + v9 + 1) - 0x7FFFFFFFFFFFFFFFLL;
    if ((v10 & 0x8000000000000000) != 0)
      goto LABEL_41;
    v11 = *((unsigned __int8 *)v7 + v9 + 10);
    switch(*((_BYTE *)v7 + v9 + 10))
    {
      case 0:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[83] > v10)
        {
          v13 = *(_QWORD *)(result[85] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_44;
      case 1:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[88] > v10)
        {
          v13 = *(_QWORD *)(result[90] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
LABEL_44:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_45;
      case 2:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[93] > v10)
        {
          v13 = *(_QWORD *)(result[95] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
LABEL_45:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_46;
      case 3:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[98] > v10)
        {
          v13 = *(_QWORD *)(result[100] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
LABEL_46:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_47;
      case 4:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[103] > v10)
        {
          v13 = *(_QWORD *)(result[105] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
LABEL_47:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_48;
      case 5:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[108] > v10)
        {
          v13 = *(_QWORD *)(result[110] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
LABEL_48:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_49;
      case 6:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[113] > v10)
        {
          v13 = *(_QWORD *)(result[115] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
LABEL_49:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_50;
      case 7:
        v12 = (_QWORD *)a3 + v9 + 1;
        break;
      default:
        goto LABEL_53;
    }
    do
    {
      if (result[118] <= v10)
      {
LABEL_50:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_51:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_52;
      }
      v13 = *(_QWORD *)(result[120] + 8 * v10);
      v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
    }
    while (v13 - 0x7FFFFFFFFFFFFFFFLL >= 0);
LABEL_40:
    *v12 = v13;
LABEL_41:
    ++v9;
  }
  while (v9 != v8);
  return result;
}

_QWORD *re::EvaluationTree::getRegister<re::Matrix4x4<float>>(_QWORD *result, uint64_t a2, _OWORD *a3)
{
  unint64_t v3;
  unint64_t v4;
  _OWORD *v5;
  __int128 v6;
  char **v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;

  v3 = a2;
  v4 = a2 - 0x7FFFFFFFFFFFFFFFLL;
  if (a2 - 0x7FFFFFFFFFFFFFFFLL >= 0)
  {
    while (result[103] > v4)
    {
      v3 = *(_QWORD *)(result[105] + 8 * v4);
      v4 = v3 - 0x7FFFFFFFFFFFFFFFLL;
      if ((uint64_t)(v3 - 0x7FFFFFFFFFFFFFFFLL) < 0)
        goto LABEL_4;
    }
    goto LABEL_51;
  }
LABEL_4:
  if (result[230] <= v3)
  {
LABEL_52:
    v14 = 0;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    LODWORD(v15) = 136315906;
    *(_QWORD *)((char *)&v15 + 4) = "operator[]";
    WORD6(v15) = 1024;
    HIWORD(v15) = 797;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_53:
    re::internal::assertLog((re::internal *)5, a2, "assertion failure: '%s' (%s:line %i) Invalid Register Type: %u", "!\"Unreachable code\"", "getRegister", 866, v11, v14, v15);
    _os_crash();
    __break(1u);
  }
  v5 = (_OWORD *)(result[232] + 32 * v3);
  v6 = v5[1];
  *a3 = *v5;
  a3[1] = v6;
  v7 = &(&re::kEvaluationCommandDescriptions)[2 * *(unsigned int *)a3];
  v8 = *((unsigned __int8 *)v7 + 9);
  if (!*((_BYTE *)v7 + 9))
    return result;
  v9 = 0;
  do
  {
    v10 = *((_QWORD *)v5 + v9 + 1) - 0x7FFFFFFFFFFFFFFFLL;
    if ((v10 & 0x8000000000000000) != 0)
      goto LABEL_41;
    v11 = *((unsigned __int8 *)v7 + v9 + 10);
    switch(*((_BYTE *)v7 + v9 + 10))
    {
      case 0:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[83] > v10)
        {
          v13 = *(_QWORD *)(result[85] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_44;
      case 1:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[88] > v10)
        {
          v13 = *(_QWORD *)(result[90] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
LABEL_44:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_45;
      case 2:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[93] > v10)
        {
          v13 = *(_QWORD *)(result[95] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
LABEL_45:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_46;
      case 3:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[98] > v10)
        {
          v13 = *(_QWORD *)(result[100] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
LABEL_46:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_47;
      case 4:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[103] > v10)
        {
          v13 = *(_QWORD *)(result[105] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
LABEL_47:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_48;
      case 5:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[108] > v10)
        {
          v13 = *(_QWORD *)(result[110] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
LABEL_48:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_49;
      case 6:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[113] > v10)
        {
          v13 = *(_QWORD *)(result[115] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
LABEL_49:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_50;
      case 7:
        v12 = (_QWORD *)a3 + v9 + 1;
        break;
      default:
        goto LABEL_53;
    }
    do
    {
      if (result[118] <= v10)
      {
LABEL_50:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_51:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_52;
      }
      v13 = *(_QWORD *)(result[120] + 8 * v10);
      v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
    }
    while (v13 - 0x7FFFFFFFFFFFFFFFLL >= 0);
LABEL_40:
    *v12 = v13;
LABEL_41:
    ++v9;
  }
  while (v9 != v8);
  return result;
}

_QWORD *re::EvaluationTree::getRegister<re::Quaternion<float>>(_QWORD *result, uint64_t a2, _OWORD *a3)
{
  unint64_t v3;
  unint64_t v4;
  _OWORD *v5;
  __int128 v6;
  char **v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;

  v3 = a2;
  v4 = a2 - 0x7FFFFFFFFFFFFFFFLL;
  if (a2 - 0x7FFFFFFFFFFFFFFFLL >= 0)
  {
    while (result[108] > v4)
    {
      v3 = *(_QWORD *)(result[110] + 8 * v4);
      v4 = v3 - 0x7FFFFFFFFFFFFFFFLL;
      if ((uint64_t)(v3 - 0x7FFFFFFFFFFFFFFFLL) < 0)
        goto LABEL_4;
    }
    goto LABEL_51;
  }
LABEL_4:
  if (result[235] <= v3)
  {
LABEL_52:
    v14 = 0;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    LODWORD(v15) = 136315906;
    *(_QWORD *)((char *)&v15 + 4) = "operator[]";
    WORD6(v15) = 1024;
    HIWORD(v15) = 797;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_53:
    re::internal::assertLog((re::internal *)5, a2, "assertion failure: '%s' (%s:line %i) Invalid Register Type: %u", "!\"Unreachable code\"", "getRegister", 866, v11, v14, v15);
    _os_crash();
    __break(1u);
  }
  v5 = (_OWORD *)(result[237] + 32 * v3);
  v6 = v5[1];
  *a3 = *v5;
  a3[1] = v6;
  v7 = &(&re::kEvaluationCommandDescriptions)[2 * *(unsigned int *)a3];
  v8 = *((unsigned __int8 *)v7 + 9);
  if (!*((_BYTE *)v7 + 9))
    return result;
  v9 = 0;
  do
  {
    v10 = *((_QWORD *)v5 + v9 + 1) - 0x7FFFFFFFFFFFFFFFLL;
    if ((v10 & 0x8000000000000000) != 0)
      goto LABEL_41;
    v11 = *((unsigned __int8 *)v7 + v9 + 10);
    switch(*((_BYTE *)v7 + v9 + 10))
    {
      case 0:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[83] > v10)
        {
          v13 = *(_QWORD *)(result[85] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_44;
      case 1:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[88] > v10)
        {
          v13 = *(_QWORD *)(result[90] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
LABEL_44:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_45;
      case 2:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[93] > v10)
        {
          v13 = *(_QWORD *)(result[95] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
LABEL_45:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_46;
      case 3:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[98] > v10)
        {
          v13 = *(_QWORD *)(result[100] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
LABEL_46:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_47;
      case 4:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[103] > v10)
        {
          v13 = *(_QWORD *)(result[105] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
LABEL_47:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_48;
      case 5:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[108] > v10)
        {
          v13 = *(_QWORD *)(result[110] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
LABEL_48:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_49;
      case 6:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[113] > v10)
        {
          v13 = *(_QWORD *)(result[115] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
LABEL_49:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_50;
      case 7:
        v12 = (_QWORD *)a3 + v9 + 1;
        break;
      default:
        goto LABEL_53;
    }
    do
    {
      if (result[118] <= v10)
      {
LABEL_50:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_51:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_52;
      }
      v13 = *(_QWORD *)(result[120] + 8 * v10);
      v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
    }
    while (v13 - 0x7FFFFFFFFFFFFFFFLL >= 0);
LABEL_40:
    *v12 = v13;
LABEL_41:
    ++v9;
  }
  while (v9 != v8);
  return result;
}

_QWORD *re::EvaluationTree::getRegister<re::Vector2<float>>(_QWORD *result, uint64_t a2, _OWORD *a3)
{
  unint64_t v3;
  unint64_t v4;
  _OWORD *v5;
  __int128 v6;
  char **v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;

  v3 = a2;
  v4 = a2 - 0x7FFFFFFFFFFFFFFFLL;
  if (a2 - 0x7FFFFFFFFFFFFFFFLL >= 0)
  {
    while (result[113] > v4)
    {
      v3 = *(_QWORD *)(result[115] + 8 * v4);
      v4 = v3 - 0x7FFFFFFFFFFFFFFFLL;
      if ((uint64_t)(v3 - 0x7FFFFFFFFFFFFFFFLL) < 0)
        goto LABEL_4;
    }
    goto LABEL_51;
  }
LABEL_4:
  if (result[240] <= v3)
  {
LABEL_52:
    v14 = 0;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    LODWORD(v15) = 136315906;
    *(_QWORD *)((char *)&v15 + 4) = "operator[]";
    WORD6(v15) = 1024;
    HIWORD(v15) = 797;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_53:
    re::internal::assertLog((re::internal *)5, a2, "assertion failure: '%s' (%s:line %i) Invalid Register Type: %u", "!\"Unreachable code\"", "getRegister", 866, v11, v14, v15);
    _os_crash();
    __break(1u);
  }
  v5 = (_OWORD *)(result[242] + 32 * v3);
  v6 = v5[1];
  *a3 = *v5;
  a3[1] = v6;
  v7 = &(&re::kEvaluationCommandDescriptions)[2 * *(unsigned int *)a3];
  v8 = *((unsigned __int8 *)v7 + 9);
  if (!*((_BYTE *)v7 + 9))
    return result;
  v9 = 0;
  do
  {
    v10 = *((_QWORD *)v5 + v9 + 1) - 0x7FFFFFFFFFFFFFFFLL;
    if ((v10 & 0x8000000000000000) != 0)
      goto LABEL_41;
    v11 = *((unsigned __int8 *)v7 + v9 + 10);
    switch(*((_BYTE *)v7 + v9 + 10))
    {
      case 0:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[83] > v10)
        {
          v13 = *(_QWORD *)(result[85] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_44;
      case 1:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[88] > v10)
        {
          v13 = *(_QWORD *)(result[90] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
LABEL_44:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_45;
      case 2:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[93] > v10)
        {
          v13 = *(_QWORD *)(result[95] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
LABEL_45:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_46;
      case 3:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[98] > v10)
        {
          v13 = *(_QWORD *)(result[100] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
LABEL_46:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_47;
      case 4:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[103] > v10)
        {
          v13 = *(_QWORD *)(result[105] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
LABEL_47:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_48;
      case 5:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[108] > v10)
        {
          v13 = *(_QWORD *)(result[110] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
LABEL_48:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_49;
      case 6:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[113] > v10)
        {
          v13 = *(_QWORD *)(result[115] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
LABEL_49:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_50;
      case 7:
        v12 = (_QWORD *)a3 + v9 + 1;
        break;
      default:
        goto LABEL_53;
    }
    do
    {
      if (result[118] <= v10)
      {
LABEL_50:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_51:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_52;
      }
      v13 = *(_QWORD *)(result[120] + 8 * v10);
      v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
    }
    while (v13 - 0x7FFFFFFFFFFFFFFFLL >= 0);
LABEL_40:
    *v12 = v13;
LABEL_41:
    ++v9;
  }
  while (v9 != v8);
  return result;
}

_QWORD *re::EvaluationTree::getRegister<re::Vector3<float>>(_QWORD *result, uint64_t a2, _OWORD *a3)
{
  unint64_t v3;
  unint64_t v4;
  _OWORD *v5;
  __int128 v6;
  char **v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;

  v3 = a2;
  v4 = a2 - 0x7FFFFFFFFFFFFFFFLL;
  if (a2 - 0x7FFFFFFFFFFFFFFFLL >= 0)
  {
    while (result[118] > v4)
    {
      v3 = *(_QWORD *)(result[120] + 8 * v4);
      v4 = v3 - 0x7FFFFFFFFFFFFFFFLL;
      if ((uint64_t)(v3 - 0x7FFFFFFFFFFFFFFFLL) < 0)
        goto LABEL_4;
    }
    goto LABEL_51;
  }
LABEL_4:
  if (result[245] <= v3)
  {
LABEL_52:
    v14 = 0;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    LODWORD(v15) = 136315906;
    *(_QWORD *)((char *)&v15 + 4) = "operator[]";
    WORD6(v15) = 1024;
    HIWORD(v15) = 797;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_53:
    re::internal::assertLog((re::internal *)5, a2, "assertion failure: '%s' (%s:line %i) Invalid Register Type: %u", "!\"Unreachable code\"", "getRegister", 866, v11, v14, v15);
    _os_crash();
    __break(1u);
  }
  v5 = (_OWORD *)(result[247] + 32 * v3);
  v6 = v5[1];
  *a3 = *v5;
  a3[1] = v6;
  v7 = &(&re::kEvaluationCommandDescriptions)[2 * *(unsigned int *)a3];
  v8 = *((unsigned __int8 *)v7 + 9);
  if (!*((_BYTE *)v7 + 9))
    return result;
  v9 = 0;
  do
  {
    v10 = *((_QWORD *)v5 + v9 + 1) - 0x7FFFFFFFFFFFFFFFLL;
    if ((v10 & 0x8000000000000000) != 0)
      goto LABEL_41;
    v11 = *((unsigned __int8 *)v7 + v9 + 10);
    switch(*((_BYTE *)v7 + v9 + 10))
    {
      case 0:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[83] > v10)
        {
          v13 = *(_QWORD *)(result[85] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_44;
      case 1:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[88] > v10)
        {
          v13 = *(_QWORD *)(result[90] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
LABEL_44:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_45;
      case 2:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[93] > v10)
        {
          v13 = *(_QWORD *)(result[95] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
LABEL_45:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_46;
      case 3:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[98] > v10)
        {
          v13 = *(_QWORD *)(result[100] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
LABEL_46:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_47;
      case 4:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[103] > v10)
        {
          v13 = *(_QWORD *)(result[105] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
LABEL_47:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_48;
      case 5:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[108] > v10)
        {
          v13 = *(_QWORD *)(result[110] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
LABEL_48:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_49;
      case 6:
        v12 = (_QWORD *)a3 + v9 + 1;
        while (result[113] > v10)
        {
          v13 = *(_QWORD *)(result[115] + 8 * v10);
          v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
          if (v13 - 0x7FFFFFFFFFFFFFFFLL < 0)
            goto LABEL_40;
        }
LABEL_49:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_50;
      case 7:
        v12 = (_QWORD *)a3 + v9 + 1;
        break;
      default:
        goto LABEL_53;
    }
    do
    {
      if (result[118] <= v10)
      {
LABEL_50:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_51:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_52;
      }
      v13 = *(_QWORD *)(result[120] + 8 * v10);
      v10 = v13 - 0x7FFFFFFFFFFFFFFFLL;
    }
    while (v13 - 0x7FFFFFFFFFFFFFFFLL >= 0);
LABEL_40:
    *v12 = v13;
LABEL_41:
    ++v9;
  }
  while (v9 != v8);
  return result;
}

void re::FixedArray<BOOL>::init<>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  _BYTE *v5;
  uint64_t v6;
  _BYTE *v7;
  size_t v8;

  *a1 = a2;
  a1[1] = a3;
  if (a3)
  {
    v5 = (_BYTE *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, a3, 1);
    a1[2] = v5;
    if (v5)
    {
      v7 = v5;
      v8 = a3 - 1;
      if (v8)
      {
        bzero(v5, v8);
        v7 += v8;
      }
      *v7 = 0;
    }
    else
    {
      re::internal::assertLog((re::internal *)4, v6, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
      _os_crash();
      __break(1u);
    }
  }
}

uint64_t re::FullBodyIKSolver::FullBodyIKSolver(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  _anonymous_namespace_ *v11;
  _anonymous_namespace_ *v12;
  _anonymous_namespace_ *v13;
  _QWORD v15[3];
  _QWORD *v16;
  uint64_t v17;
  _QWORD v18[5];

  v18[4] = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = &str_110;
  *(_QWORD *)(a1 + 16) = 0;
  v6 = (uint64_t *)(a1 + 16);
  v7 = (_QWORD *)(a1 + 24);
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  v8 = CoreIKGenericSolverCreate();
  v15[0] = &off_24ED24280;
  v16 = v15;
  v17 = 0;
  v18[3] = v18;
  v18[0] = &off_24ED24280;
  std::unique_ptr<re::RigHierarchy,std::function<void ()(re::RigHierarchy*)>>::reset[abi:nn180100](v6, v8);
  std::__function::__value_func<void ()(re::RigHierarchy *)>::operator=[abi:nn180100](v7, (uint64_t)v18);
  std::unique_ptr<re::RigHierarchy,std::function<void ()(re::RigHierarchy*)>>::~unique_ptr[abi:nn180100](&v17);
  v9 = v16;
  if (v16 == v15)
  {
    v10 = 4;
    v9 = v15;
    goto LABEL_5;
  }
  if (v16)
  {
    v10 = 5;
LABEL_5:
    (*(void (**)(void))(*v9 + 8 * v10))();
  }
  re::StringID::operator=((unint64_t *)a1, a3);
  v11 = (_anonymous_namespace_ *)MEMORY[0x2276916F0](a2);
  v12 = (_anonymous_namespace_ *)MEMORY[0x227691324](a2);
  return a1;
}

__n128 re::FullBodyIKSolver::copyPoseToInternal(re::FullBodyIKSolver *this, const re::RigDataValue *a2)
{
  uint64_t v2;
  uint64_t v5;
  unint64_t i;
  unint64_t v7;
  unint64_t v8;
  __n128 result;
  uint64_t v10;
  __int128 v11;
  __n128 v12;
  __int128 v13;
  uint64_t v14;
  int v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  unint64_t v20;
  __int16 v21;
  unint64_t v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  v2 = *((_QWORD *)a2 + 32);
  if (v2)
  {
    v5 = 0;
    for (i = 0; i != v2; ++i)
    {
      *(_QWORD *)&v11 = 0x3F8000003F800000;
      *((_QWORD *)&v11 + 1) = 1065353216;
      v12.n128_u64[0] = 0;
      v12.n128_u64[1] = 0x3F80000000000000;
      v13 = 0uLL;
      v7 = re::RigDataValue::attributeValue(a2, i);
      re::RigDataValue::getRuntimeValue<re::GenericSRT<float>>(v7, &v11);
      v8 = *((_QWORD *)this + 14);
      if (v8 <= i)
      {
        v14 = 0;
        v26 = 0u;
        v27 = 0u;
        v24 = 0u;
        v25 = 0u;
        v23 = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        v15 = 136315906;
        v16 = "operator[]";
        v17 = 1024;
        v18 = 468;
        v19 = 2048;
        v20 = i;
        v21 = 2048;
        v22 = v8;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      result = v12;
      v10 = *((_QWORD *)this + 15) + v5;
      *(_OWORD *)v10 = v13;
      *(__n128 *)(v10 + 16) = result;
      v5 += 32;
    }
  }
  return result;
}

_OWORD *re::FullBodyIKSolver::copyInternalToPose(_OWORD *this, re::RigDataValue *a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  unint64_t i;
  __int128 *v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  unint64_t v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v2 = *((_QWORD *)a2 + 32);
  if (v2)
  {
    v4 = (uint64_t)this;
    v5 = 0;
    for (i = 0; i != v2; ++i)
    {
      if (*(_QWORD *)(v4 + 112) <= i)
      {
        v15 = 0u;
        v16 = 0u;
        v13 = 0u;
        v14 = 0u;
        v12 = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      v7 = (__int128 *)(*(_QWORD *)(v4 + 120) + v5);
      v9 = *((_QWORD *)v7 + 2);
      v8 = *((_QWORD *)v7 + 3);
      v10 = *v7;
      *(_QWORD *)&v12 = 0x3F8000003F800000;
      *((_QWORD *)&v12 + 1) = 1065353216;
      *(_QWORD *)&v13 = v9;
      *((_QWORD *)&v13 + 1) = v8;
      v14 = v10;
      v11 = re::RigDataValue::attributeValue(a2, i);
      this = re::RigDataValue::setRuntimeValue<re::GenericSRT<float>>(v11, &v12);
      v5 += 32;
    }
  }
  return this;
}

BOOL re::FullBodyIKSolver::solve(re::FullBodyIKSolver *a1, const re::RigDataValue *a2, re::RigDataValue *a3)
{
  int v6;
  uint64_t v7;
  unint64_t i;
  unint64_t v9;
  unint64_t v10;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  re::FullBodyIKSolver::copyPoseToInternal(a1, a2);
  re::FullBodyIKSolver::applyTaskTargets((uint64_t)a1);
  v6 = CoreIKGenericSolverSolve();
  if (v6 == 1)
  {
    v7 = *((_QWORD *)a2 + 32);
    if (v7)
    {
      for (i = 0; i != v7; ++i)
      {
        *(_QWORD *)&v12 = 0x3F8000003F800000;
        *((_QWORD *)&v12 + 1) = 1065353216;
        v13 = 0;
        v14 = 0x3F80000000000000;
        v15 = 0;
        v16 = 0;
        v9 = re::RigDataValue::attributeValue(a2, i);
        re::RigDataValue::getRuntimeValue<re::GenericSRT<float>>(v9, &v12);
        v10 = re::RigDataValue::attributeValue(a3, i);
        re::RigDataValue::setRuntimeValue<re::GenericSRT<float>>(v10, &v12);
      }
    }
  }
  else
  {
    re::FullBodyIKSolver::copyInternalToPose(a1, a3);
  }
  return v6 != 1;
}

uint64_t re::FullBodyIKSolver::applyTaskTargets(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;

  if (*(_QWORD *)(this + 64))
  {
    v1 = this;
    v2 = 0;
    v3 = 0;
    v4 = *(_QWORD *)(this + 16);
    do
    {
      MEMORY[0x22769154C](v4, v3);
      if (CoreIKGenericConstraintHasLookAtEnabled())
      {
        if (*(_QWORD *)(v1 + 88) <= v3)
        {
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        CoreIKGenericConstraintSetLookAtTarget();
      }
      CoreIKGenericConstraintSetTargetTranslation();
      this = CoreIKGenericConstraintSetTargetOrientation();
      ++v3;
      v2 += 48;
    }
    while (v3 < *(_QWORD *)(v1 + 64));
  }
  return this;
}

uint64_t re::FullBodyIKSolver::taskName(re::FullBodyIKSolver *this)
{
  uint64_t v1;

  v1 = MEMORY[0x22769154C](*((_QWORD *)this + 2));
  MEMORY[0x227691474](v1);
  return CoreIKConstraintGetName();
}

uint64_t re::FullBodyIKSolver::taskTargetName(re::FullBodyIKSolver *this)
{
  uint64_t v1;

  v1 = MEMORY[0x22769154C](*((_QWORD *)this + 2));
  MEMORY[0x227691474](v1);
  return CoreIKConstraintGetBoneName();
}

void re::FullBodyIKSolver::taskPositionEnabled(re::FullBodyIKSolver *this)
{
  uint64_t v1;

  v1 = MEMORY[0x22769154C](*((_QWORD *)this + 2));
  MEMORY[0x227691474](v1);
  JUMPOUT(0x227691630);
}

void re::FullBodyIKSolver::taskRotationEnabled(re::FullBodyIKSolver *this)
{
  uint64_t v1;

  v1 = MEMORY[0x22769154C](*((_QWORD *)this + 2));
  MEMORY[0x227691474](v1);
  JUMPOUT(0x227691618);
}

__n128 re::FullBodyIKSolver::taskLookAtTarget(re::FullBodyIKSolver *this, unint64_t a2)
{
  if (*((_QWORD *)this + 11) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(__n128 *)(*((_QWORD *)this + 12) + 16 * a2);
}

uint64_t re::FullBodyIKSolver::setTaskLookAtTarget(uint64_t result, unint64_t a2, __n128 a3)
{
  if (*(_QWORD *)(result + 88) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  *(__n128 *)(*(_QWORD *)(result + 96) + 16 * a2) = a3;
  return result;
}

uint64_t re::FullBodyIKSolver::setTaskTargetPosition(uint64_t result, unint64_t a2, __n128 a3)
{
  if (*(_QWORD *)(result + 64) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  *(__n128 *)(*(_QWORD *)(result + 72) + 48 * a2 + 32) = a3;
  return result;
}

__n128 re::FullBodyIKSolver::taskTargetRotation(re::FullBodyIKSolver *this, unint64_t a2)
{
  if (*((_QWORD *)this + 8) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(__n128 *)(*((_QWORD *)this + 9) + 48 * a2 + 16);
}

uint64_t re::FullBodyIKSolver::setTaskTargetRotation(uint64_t this, unint64_t a2, simd_quatf a3)
{
  if (*(_QWORD *)(this + 64) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  *(simd_quatf *)(*(_QWORD *)(this + 72) + 48 * a2 + 16) = a3;
  return this;
}

uint64_t re::FullBodyIKSolver::setTaskTargetParameters(uint64_t a1, unint64_t a2, __n128 a3, double a4, __n128 a5)
{
  simd_quatf v7;

  re::FullBodyIKSolver::setTaskTargetPosition(a1, a2, a3);
  MEMORY[0x22769154C](*(_QWORD *)(a1 + 16), a2);
  CoreIKGenericConstraintSetTranslationTargetBlendWeight();
  v7 = (simd_quatf)a5;
  re::FullBodyIKSolver::setTaskTargetRotation(a1, a2, v7);
  MEMORY[0x22769154C](*(_QWORD *)(a1 + 16), a2);
  return CoreIKGenericConstraintSetOrientationTargetBlendWeight();
}

uint64_t *re::allocInfo_FullBodyIKSolver(re *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&qword_2540FA258);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_2540FA258))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FA260, 0);
    *(uint64_t *)((char *)&qword_2540FA270 + 6) = 0;
    qword_2540FA270 = 0;
    qword_2540FA280 = 0;
    qword_2540FA288 = 0xFFFFFFFFLL;
    qword_2540FA260 = (uint64_t)&off_24ED7DAA8;
    qword_2540FA290 = (uint64_t)"FullBodyIKSolver";
    dword_2540FA298 = 0;
    unk_2540FA2A0 = 0u;
    unk_2540FA2B0 = 0u;
    unk_2540FA2C0 = 0u;
    qword_2540FA2D0 = 0;
    __cxa_guard_release(&qword_2540FA258);
  }
  return &qword_2540FA260;
}

void re::initInfo_FullBodyIKSolver(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  const re::IntrospectionBase *v7;
  void *v8;
  uint64_t v9;
  __int128 v10;
  _QWORD v11[2];
  __int128 v12;

  v11[0] = 0xE798B206CD368F8CLL;
  v11[1] = "FullBodyIKSolver";
  re::StringID::destroyString((re::StringID *)v11);
  *((_OWORD *)this + 2) = v12;
  v4 = atomic_load((unsigned __int8 *)&qword_2540FA250);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_2540FA250);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      v8 = re::IntrospectionInfo<re::StringID>::get(1, v7);
      v9 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
      *(_DWORD *)v9 = 1;
      *(_QWORD *)(v9 + 8) = "m_name";
      *(_QWORD *)(v9 + 16) = v8;
      *(_QWORD *)(v9 + 24) = 0;
      *(_QWORD *)(v9 + 32) = 1;
      *(_DWORD *)(v9 + 40) = 0;
      *(_QWORD *)(v9 + 48) = 0;
      *(_QWORD *)(v9 + 56) = 0;
      *(_DWORD *)(v9 + 64) = 0;
      _MergedGlobals_20 = v9;
      __cxa_guard_release(&qword_2540FA250);
    }
  }
  *((_QWORD *)this + 2) = 0x8000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 1;
  *((_QWORD *)this + 8) = &_MergedGlobals_20;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::FullBodyIKSolver>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::FullBodyIKSolver>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::FullBodyIKSolver>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::FullBodyIKSolver>;
  re::IntrospectionRegistry::add(this, v3);
  v10 = v12;
}

double re::internal::defaultConstruct<re::FullBodyIKSolver>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double result;

  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = &str_110;
  *(_QWORD *)(a3 + 16) = 0;
  result = 0.0;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 80) = 0u;
  *(_OWORD *)(a3 + 96) = 0u;
  *(_OWORD *)(a3 + 112) = 0u;
  return result;
}

void re::internal::defaultDestruct<re::FullBodyIKSolver>(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = a3[13];
  if (v4)
  {
    v5 = a3 + 14;
    if (a3[14])
    {
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v4 + 40))(v4, a3[15]);
      *v5 = 0;
      a3[15] = 0;
    }
    a3[13] = 0;
  }
  v6 = a3[10];
  if (v6)
  {
    if (a3[11])
    {
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v6 + 40))(v6, a3[12]);
      a3[11] = 0;
      a3[12] = 0;
    }
    a3[10] = 0;
  }
  v7 = a3[7];
  if (v7)
  {
    if (a3[8])
    {
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v7 + 40))(v7, a3[9]);
      a3[8] = 0;
      a3[9] = 0;
    }
    a3[7] = 0;
  }
  std::unique_ptr<re::RigHierarchy,std::function<void ()(re::RigHierarchy*)>>::~unique_ptr[abi:nn180100](a3 + 2);
  re::StringID::destroyString((re::StringID *)a3);
}

double re::internal::defaultConstructV2<re::FullBodyIKSolver>(uint64_t a1)
{
  double result;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = &str_110;
  *(_QWORD *)(a1 + 16) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  return result;
}

void re::internal::defaultDestructV2<re::FullBodyIKSolver>(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = a1[13];
  if (v2)
  {
    if (a1[14])
    {
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[15]);
      a1[14] = 0;
      a1[15] = 0;
    }
    a1[13] = 0;
  }
  v3 = a1[10];
  if (v3)
  {
    if (a1[11])
    {
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v3 + 40))(v3, a1[12]);
      a1[11] = 0;
      a1[12] = 0;
    }
    a1[10] = 0;
  }
  v4 = a1[7];
  if (v4)
  {
    if (a1[8])
    {
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v4 + 40))(v4, a1[9]);
      a1[8] = 0;
      a1[9] = 0;
    }
    a1[7] = 0;
  }
  std::unique_ptr<re::RigHierarchy,std::function<void ()(re::RigHierarchy*)>>::~unique_ptr[abi:nn180100](a1 + 2);
  re::StringID::destroyString((re::StringID *)a1);
}

uint64_t re::introspect_FullBodyIKSolver(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"FullBodyIKSolver", (uint64_t (*)(re::internal *))re::allocInfo_FullBodyIKSolver, (re::IntrospectionBase *(*)(void))re::initInfo_FullBodyIKSolver, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::FullBodyIKSolver>, this);
}

void std::__function::__func<re::FullBodyIKSolver::FullBodyIKSolver(CoreIKRig *,re::StringID const&)::$_0,std::allocator<re::FullBodyIKSolver::FullBodyIKSolver(CoreIKRig *,re::StringID const&)::$_0>,void ()(CoreIKGenericSolver *)>::~__func()
{
  JUMPOUT(0x2276933B8);
}

_QWORD *std::__function::__func<re::FullBodyIKSolver::FullBodyIKSolver(CoreIKRig *,re::StringID const&)::$_0,std::allocator<re::FullBodyIKSolver::FullBodyIKSolver(CoreIKRig *,re::StringID const&)::$_0>,void ()(CoreIKGenericSolver *)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_24ED24280;
  return result;
}

void std::__function::__func<re::FullBodyIKSolver::FullBodyIKSolver(CoreIKRig *,re::StringID const&)::$_0,std::allocator<re::FullBodyIKSolver::FullBodyIKSolver(CoreIKRig *,re::StringID const&)::$_0>,void ()(CoreIKGenericSolver *)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24ED24280;
}

uint64_t std::__function::__func<re::FullBodyIKSolver::FullBodyIKSolver(CoreIKRig *,re::StringID const&)::$_0,std::allocator<re::FullBodyIKSolver::FullBodyIKSolver(CoreIKRig *,re::StringID const&)::$_0>,void ()(CoreIKGenericSolver *)>::operator()()
{
  return CoreIKGenericSolverDestroy();
}

uint64_t std::__function::__func<re::FullBodyIKSolver::FullBodyIKSolver(CoreIKRig *,re::StringID const&)::$_0,std::allocator<re::FullBodyIKSolver::FullBodyIKSolver(CoreIKRig *,re::StringID const&)::$_0>,void ()(CoreIKGenericSolver *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::FullBodyIKSolver::FullBodyIKSolver(CoreIKRig *,re::StringID const&)::$_0,std::allocator<re::FullBodyIKSolver::FullBodyIKSolver(CoreIKRig *,re::StringID const&)::$_0>,void ()(CoreIKGenericSolver *)>::target_type()
{
}

void re::FixedArray<re::FullBodyIKSolver::CorePose>::init<>(uint64_t *a1, uint64_t a2, unint64_t a3)
{
  uint64_t v5;
  _OWORD *v6;
  uint64_t v7;
  _OWORD *v8;

  *a1 = a2;
  a1[1] = a3;
  if (!a3)
    return;
  if (a3 >> 59)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 32, a3);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  v5 = 32 * a3;
  v6 = (_OWORD *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 32 * a3, 16);
  a1[2] = (uint64_t)v6;
  if (!v6)
  {
LABEL_9:
    re::internal::assertLog((re::internal *)4, v7, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    _os_crash();
    __break(1u);
    return;
  }
  v8 = v6;
  if (a3 != 1)
  {
    bzero(v6, v5 - 32);
    v8 = (_OWORD *)((char *)v8 + v5 - 32);
  }
  *v8 = 0u;
  v8[1] = 0u;
}

void _ZN2re10FixedArrayIDv3_fE4initIJEEEvPNS_9AllocatorEmDpOT_(uint64_t *a1, uint64_t a2, unint64_t a3)
{
  uint64_t v5;
  _OWORD *v6;
  uint64_t v7;
  _OWORD *v8;

  *a1 = a2;
  a1[1] = a3;
  if (!a3)
    return;
  if (a3 >> 60)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 16, a3);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  v5 = 16 * a3;
  v6 = (_OWORD *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 16 * a3, 16);
  a1[2] = (uint64_t)v6;
  if (!v6)
  {
LABEL_9:
    re::internal::assertLog((re::internal *)4, v7, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    _os_crash();
    __break(1u);
    return;
  }
  v8 = v6;
  if (a3 != 1)
  {
    bzero(v6, v5 - 16);
    v8 = (_OWORD *)((char *)v8 + v5 - 16);
  }
  *v8 = 0u;
}

BOOL re::TimelineClip::childCount(re::TimelineClip *this)
{
  return *((_QWORD *)this + 9) != 0;
}

uint64_t re::TimelineClip::child(re::TimelineClip *this)
{
  return *((_QWORD *)this + 9);
}

double re::TimelineClip::totalDuration(re::TimelineClip *this)
{
  uint64_t v2;
  double v3;
  double v4;
  double v5;

  v2 = *((_QWORD *)this + 9);
  if (v2)
  {
    if (*((_BYTE *)this + 80))
      v3 = *((double *)this + 11);
    else
      v3 = 0.0;
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    if (*((_BYTE *)this + 96))
      v5 = *((double *)this + 13);
    v4 = v5 - v3;
  }
  else
  {
    v4 = 0.0;
  }
  if (*((_BYTE *)this + 136))
    v4 = *((double *)this + 18);
  return *((double *)this + 16) + v4 / *((float *)this + 38);
}

float re::TimelineClip::timelineDesc@<S0>(re::TimelineClip *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  double v5;
  float v6;
  double v7;
  double v8;
  char v9;
  float v10;
  float v11;
  float v12;
  float result;
  float v14;

  v4 = *((_QWORD *)this + 9);
  if (v4)
  {
    if (*((_BYTE *)this + 80))
      v5 = *((double *)this + 11);
    else
      v5 = 0.0;
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    if (*((_BYTE *)this + 96))
      v7 = *((double *)this + 13);
    v6 = v7 - v5;
  }
  else
  {
    v6 = 0.0;
    v5 = 0.0;
    v7 = 0.0;
  }
  if (!*((_BYTE *)this + 136) || (v8 = *((double *)this + 18), v8 == 0.0))
  {
    v9 = *((_BYTE *)this + 156);
    if (v9)
      v6 = INFINITY;
  }
  else
  {
    v6 = v8;
    v9 = *((_BYTE *)this + 156);
  }
  v10 = *((double *)this + 16);
  *(float *)a2 = v10;
  *(float *)(a2 + 4) = v6;
  v11 = *((float *)this + 38);
  if (*((_BYTE *)this + 120))
    v11 = -v11;
  v12 = v5;
  *(float *)(a2 + 8) = v11;
  *(float *)(a2 + 12) = v12;
  result = v7;
  v14 = *((double *)this + 14);
  *(float *)(a2 + 16) = result;
  *(float *)(a2 + 20) = v14;
  *(_BYTE *)(a2 + 24) = v9;
  *(_BYTE *)(a2 + 25) = *((_BYTE *)this + 16);
  return result;
}

void re::TimelineClip::~TimelineClip(re::TimelineClip *this)
{
  uint64_t v2;
  _OWORD *v3;

  *(_QWORD *)this = off_24ED1F350;
  v3 = (_OWORD *)((char *)this + 40);
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    if ((*((_BYTE *)this + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *((_QWORD *)this + 7));
    *v3 = 0u;
    v3[1] = 0u;
  }
  re::StringID::destroyString((re::TimelineClip *)((char *)this + 24));
}

{
  uint64_t v2;
  _OWORD *v3;

  *(_QWORD *)this = off_24ED1F350;
  v3 = (_OWORD *)((char *)this + 40);
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    if ((*((_BYTE *)this + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *((_QWORD *)this + 7));
    *v3 = 0u;
    v3[1] = 0u;
  }
  re::StringID::destroyString((re::TimelineClip *)((char *)this + 24));
  JUMPOUT(0x2276933B8);
}

ArcSharedObject *re::BlendShapeWeightsDefinition::BlendShapeWeightsDefinition(ArcSharedObject *a1, uint64_t a2, const StringID **a3)
{
  uint64_t v6;
  _anonymous_namespace_ *v7;
  const StringID *v8;
  const StringID *v9;
  uint64_t v10;
  unint64_t v11;
  _QWORD v13[2];

  ArcSharedObject::ArcSharedObject(a1, 0);
  *(_QWORD *)(v6 + 16) = a2;
  *(_QWORD *)v6 = &off_24ED24398;
  *(_OWORD *)(v6 + 40) = 0u;
  *(_OWORD *)(v6 + 56) = 0u;
  *(_OWORD *)(v6 + 24) = 0u;
  v7 = (_anonymous_namespace_ *)(v6 + 24);
  *(_OWORD *)(v6 + 68) = 0u;
  *(_QWORD *)(v6 + 84) = 0x7FFFFFFFLL;
  *(_QWORD *)(v6 + 96) = 0;
  re::FixedArray<re::StringID>::init<>((_QWORD *)(v6 + 24), a2, (unint64_t)a3[1]);
  re::FixedArray<re::StringID>::operator=(v7, (uint64_t)a3);
  v8 = a3[1];
  if (v8)
  {
    v9 = *a3;
    v10 = 16 * (_QWORD)v8;
    do
    {
      re::StringID::StringID((re::StringID *)v13, v9);
      v11 = 0x94D049BB133111EBLL
          * ((0xBF58476D1CE4E5B9 * ((v13[0] >> 31) ^ (v13[0] >> 1))) ^ ((0xBF58476D1CE4E5B9
                                                                         * ((v13[0] >> 31) ^ (v13[0] >> 1))) >> 27));
      *((_QWORD *)a1 + 12) ^= (*((_QWORD *)a1 + 12) << 6)
                            + (*((_QWORD *)a1 + 12) >> 2)
                            - 0x61C8864680B583E9
                            + (v11 ^ (v11 >> 31));
      re::StringID::destroyString((re::StringID *)v13);
      ++v9;
      v10 -= 16;
    }
    while (v10);
  }
  re::BlendShapeWeightsDefinition::buildWeightNameMap(a1);
  return a1;
}

void re::BlendShapeWeightsDefinition::buildWeightNameMap(re::BlendShapeWeightsDefinition *this)
{
  char *v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t i;
  char *v6;
  const char *v7;
  StringID v8;
  unint64_t v9;

  v2 = (char *)this + 48;
  re::HashTable<re::StringID,unsigned long,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init((uint64_t)this + 48, *((_QWORD *)this + 3), 2 * *((_DWORD *)this + 8));
  *(_QWORD *)&v8.var0 = 0;
  if (*((_QWORD *)this + 4))
  {
    v3 = 0;
    do
    {
      re::HashTable<re::StringID,unsigned long,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::add((uint64_t)v2, (StringID *)(*((_QWORD *)this + 5) + 16 * v3), &v8);
      v3 = *(_QWORD *)&v8.var0 + 1;
      *(_QWORD *)&v8.var0 = v3;
      v4 = *((_QWORD *)this + 4);
    }
    while (v3 < v4);
    v9 = 0;
    if (v4)
    {
      for (i = 0; i < v4; v9 = i)
      {
        v6 = strrchr(*(char **)(*((_QWORD *)this + 5) + 16 * i + 8), 47);
        if (v6)
        {
          v7 = v6 + 1;
          *(_QWORD *)&v8.var0 = 0;
          v8.var1 = (char *)&str_110;
          re::HashTable<re::StringID,unsigned long,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::add((uint64_t)v2, &v8, &v9);
          re::StringID::destroyString((re::StringID *)&v8);
          i = v9;
          v4 = *((_QWORD *)this + 4);
        }
        ++i;
      }
    }
  }
}

void re::BlendShapeWeights::init(uint64_t *a1, uint64_t *a2)
{
  re::SharedPtr<re::SkeletalPoseJointDefinition>::reset(a1 + 3, *a2);
}

void re::BlendShapeWeights::deinit(re::BlendShapeWeights *this)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)this;
  if (v2)
  {
    if (*((_QWORD *)this + 1))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *((_QWORD *)this + 2));
      *((_QWORD *)this + 1) = 0;
      *((_QWORD *)this + 2) = 0;
    }
    *(_QWORD *)this = 0;
  }
  v3 = *((_QWORD *)this + 3);
  if (v3)
  {

    *((_QWORD *)this + 3) = 0;
  }
}

void re::BlendShapeWeights::reset(uint64_t *a1, uint64_t *a2)
{
  _anonymous_namespace_ *v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t *v6;
  uint64_t v7;

  re::SharedPtr<re::SkeletalPoseJointDefinition>::reset(a1 + 3, *a2);
  v5 = a1 + 1;
  v4 = a1[1];
  if (v4 != *(_QWORD *)(a1[3] + 32))
  {
    v6 = (uint64_t *)*a1;
    if (*a1)
    {
      v7 = *a1;
      if (v4)
      {
LABEL_4:
        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v7 + 40))(v7, a1[2]);
        *v5 = 0;
        a1[2] = 0;
      }
    }
    else
    {
      v7 = *a1;
      if (!*a1)
      {
        goto LABEL_6;
      }
      if (*v5)
        goto LABEL_4;
    }
    *a1 = 0;
LABEL_6:
    re::FixedArray<int>::init<>(a1, (uint64_t)v6, *(_QWORD *)(a1[3] + 32));
  }
}

uint64_t *re::allocInfo_BlendShapeWeights(re *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&_MergedGlobals_21);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&_MergedGlobals_21))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FA2F0, 0);
    *(uint64_t *)((char *)&qword_2540FA300 + 6) = 0;
    qword_2540FA300 = 0;
    qword_2540FA310 = 0;
    qword_2540FA318 = 0xFFFFFFFFLL;
    qword_2540FA2F0 = (uint64_t)&off_24ED7DAA8;
    qword_2540FA320 = (uint64_t)"BlendShapeWeights";
    dword_2540FA328 = 0;
    unk_2540FA330 = 0u;
    unk_2540FA340 = 0u;
    unk_2540FA350 = 0u;
    qword_2540FA360 = 0;
    __cxa_guard_release(&_MergedGlobals_21);
  }
  return &qword_2540FA2F0;
}

void re::initInfo_BlendShapeWeights(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  const re::IntrospectionBase *v7;
  uint64_t *v8;
  uint64_t v9;
  __int128 v10;
  _QWORD v11[2];
  __int128 v12;

  v11[0] = 0x3826001B6619E1D6;
  v11[1] = "BlendShapeWeights";
  re::StringID::destroyString((re::StringID *)v11);
  *((_OWORD *)this + 2) = v12;
  v4 = atomic_load((unsigned __int8 *)&qword_2540FA2E8);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_2540FA2E8);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      v8 = re::IntrospectionInfo<re::FixedArray<float>>::get(1, v7);
      v9 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
      *(_DWORD *)v9 = 1;
      *(_QWORD *)(v9 + 8) = "weights";
      *(_QWORD *)(v9 + 16) = v8;
      *(_QWORD *)(v9 + 24) = 0;
      *(_QWORD *)(v9 + 32) = 1;
      *(_DWORD *)(v9 + 40) = 0;
      *(_QWORD *)(v9 + 48) = 0;
      *(_QWORD *)(v9 + 56) = 0;
      *(_DWORD *)(v9 + 64) = 0;
      qword_2540FA2E0 = v9;
      __cxa_guard_release(&qword_2540FA2E8);
    }
  }
  *((_QWORD *)this + 2) = 0x2000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 1;
  *((_QWORD *)this + 8) = &qword_2540FA2E0;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::BlendShapeWeights>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::BlendShapeWeights>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::BlendShapeWeights>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::BlendShapeWeights>;
  re::IntrospectionRegistry::add(this, v3);
  v10 = v12;
}

uint64_t *re::IntrospectionInfo<re::FixedArray<float>>::get(int a1, const re::IntrospectionBase *a2)
{
  unsigned __int8 v3;
  int v4;
  re *v5;
  std::__shared_mutex_base *v6;
  re *v7;
  std::__shared_mutex_base *v8;
  uint64_t v10;
  int v11;
  re::IntrospectionRegistry *v12;
  const re::IntrospectionBase *v13;
  const char *v14;
  __int128 v15;
  __int128 v16;
  const char *v17;
  uint64_t v18[2];

  if ((v3 & 1) == 0
  {
    re::IntrospectionFixedArrayBase::IntrospectionFixedArrayBase((re::IntrospectionFixedArrayBase *)&re::IntrospectionInfo<re::FixedArray<float>>::get(BOOL)::info);
    re::IntrospectionInfo<re::FixedArray<float>>::get(BOOL)::info = (uint64_t)&off_24ED243E0;
  }
  if (a1)
  {
    if (re::IntrospectionInfo<re::FixedArray<float>>::get(BOOL)::isInitialized)
      return &re::IntrospectionInfo<re::FixedArray<float>>::get(BOOL)::info;
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v16);
    v4 = re::IntrospectionInfo<re::FixedArray<float>>::get(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v16);
    if (v4)
      return &re::IntrospectionInfo<re::FixedArray<float>>::get(BOOL)::info;
    v6 = re::introspectionSharedMutex(v5);
    std::__shared_mutex_base::lock(v6);
  }
  v7 = (re *)re::introspect_float((re *)1, a2);
  if (re::IntrospectionInfo<re::FixedArray<float>>::get(BOOL)::isInitialized)
  {
    if ((a1 & 1) == 0)
    {
LABEL_9:
      v8 = re::introspectionSharedMutex(v7);
      std::__shared_mutex_base::unlock(v8);
    }
  }
  else
  {
    v10 = (uint64_t)v7;
    re::IntrospectionInfo<re::FixedArray<float>>::get(BOOL)::isInitialized = 1;
    v11 = *((_DWORD *)v7 + 6);
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&re::IntrospectionInfo<re::FixedArray<float>>::get(BOOL)::info, 0);
    qword_2557FF580 = 0x1800000004;
    dword_2557FF588 = v11;
    word_2557FF58C = 0;
    *(_QWORD *)&xmmword_2557FF590 = 0;
    *((_QWORD *)&xmmword_2557FF590 + 1) = 0xFFFFFFFFLL;
    qword_2557FF5A0 = v10;
    unk_2557FF5A8 = 0;
    re::IntrospectionInfo<re::FixedArray<float>>::get(BOOL)::info = (uint64_t)&off_24ED243E0;
    re::IntrospectionRegistry::add(v12, v13);
    re::getPrettyTypeName((re *)&re::IntrospectionInfo<re::FixedArray<float>>::get(BOOL)::info, (const re::IntrospectionBase *)&v16);
    if ((BYTE8(v16) & 1) != 0)
      v14 = v17;
    else
      v14 = (char *)&v16 + 9;
    if ((_QWORD)v16 && (BYTE8(v16) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v16 + 40))();
    v16 = *(_OWORD *)(v10 + 32);
    xmmword_2557FF590 = v15;
    re::StringID::destroyString((re::StringID *)v18);
    if ((a1 & 1) == 0)
      goto LABEL_9;
  }
  return &re::IntrospectionInfo<re::FixedArray<float>>::get(BOOL)::info;
}

double re::internal::defaultConstruct<re::BlendShapeWeights>(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  double result;

  result = 0.0;
  *a3 = 0u;
  a3[1] = 0u;
  return result;
}

void re::internal::defaultDestruct<re::BlendShapeWeights>(int a1, int a2, re::BlendShapeWeights *this)
{
  re::BlendShapeWeights::~BlendShapeWeights(this);
}

double re::internal::defaultConstructV2<re::BlendShapeWeights>(_OWORD *a1)
{
  double result;

  result = 0.0;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t re::introspect_BlendShapeWeights(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"BlendShapeWeights", (uint64_t (*)(re::internal *))re::allocInfo_BlendShapeWeights, (re::IntrospectionBase *(*)(void))re::initInfo_BlendShapeWeights, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::BlendShapeWeights>, this);
}

uint64_t *re::AnimationValueTraits<re::BlendShapeWeights>::copy(uint64_t *result, uint64_t *a2)
{
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;

  v3 = result;
  v4 = result[3];
  v5 = *(_QWORD *)(v4 + 32);
  v6 = a2[3];
  if (v5 == *(_QWORD *)(v6 + 32) && *(_QWORD *)(v4 + 96) == *(_QWORD *)(v6 + 96))
    return re::FixedArray<float>::operator=(a2, (uint64_t)result);
  if (v5)
  {
    v7 = 0;
    v8 = 0;
    while (1)
    {
      v9 = v3[3];
      if (*(_QWORD *)(v9 + 32) <= v8)
        break;
      result = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(a2[3] + 48, (_QWORD *)(*(_QWORD *)(v9 + 40) + v7));
      if (result)
      {
        if (v3[1] <= v8)
          goto LABEL_14;
        if (a2[1] <= (unint64_t)*result)
          goto LABEL_15;
        *(_DWORD *)(a2[2] + 4 * *result) = *(_DWORD *)(v3[2] + 4 * v8);
      }
      ++v8;
      v7 += 16;
      if (v5 == v8)
        return result;
    }
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_14:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_15:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return result;
}

float re::AnimationValueTraits<re::BlendShapeWeights>::combine(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  unint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t *v16;
  float result;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  unint64_t *v22;
  unint64_t *v23;
  uint64_t v24;
  unint64_t *v25;
  _QWORD *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  const char *v35;
  __int16 v36;
  int v37;
  __int16 v38;
  _QWORD *v39;
  __int16 v40;
  _QWORD *v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  uint64_t v47;

  v7 = a2;
  v8 = a1;
  v47 = *MEMORY[0x24BDAC8D0];
  v9 = a1[3];
  v10 = *(_QWORD **)(v9 + 32);
  v11 = a2[3];
  if (v10 != *(_QWORD **)(v11 + 32) || *(_QWORD *)(v9 + 96) != *(_QWORD *)(v11 + 96))
  {
    v18 = *(_QWORD *)(v7[3] + 32);
    v31 = 0;
    v32 = 0;
    v30 = 0;
    v15 = *(_QWORD *)(v8[3] + 32);
    if (v15)
    {
      v4 = 0;
      v19 = 0;
      while (1)
      {
        v20 = v8[3];
        v13 = *(_QWORD *)(v20 + 32);
        if (v13 <= v19)
          break;
        v21 = (_QWORD *)((char *)v4 + *(_QWORD *)(v20 + 40));
        v22 = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(a3[3] + 48, v21);
        if (v22)
        {
          v3 = *v22;
          v23 = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v7[3] + 48, v21);
          if (v23)
          {
            v13 = v8[1];
            if (v13 <= v19)
              goto LABEL_51;
            v13 = *v23;
            v5 = (_QWORD *)v7[1];
            if ((unint64_t)v5 <= *v23)
              goto LABEL_52;
            v5 = (_QWORD *)a3[1];
            if ((unint64_t)v5 <= v3)
              goto LABEL_53;
            result = *(float *)(v8[2] + 4 * v19) + *(float *)(v7[2] + 4 * v13);
            *(float *)(a3[2] + 4 * v3) = result;
            v3 = v31;
            if (v31 <= v13)
              goto LABEL_54;
            *(_BYTE *)(v32 + v13) = 1;
          }
          else
          {
            v13 = v8[1];
            if (v13 <= v19)
              goto LABEL_56;
            v13 = a3[1];
            if (v13 <= v3)
              goto LABEL_57;
            result = *(float *)(v8[2] + 4 * v19);
            *(float *)(a3[2] + 4 * v3) = result;
          }
        }
        ++v19;
        v4 += 2;
        if (v15 == v19)
          goto LABEL_28;
      }
      v33 = 0;
      v45 = 0u;
      v46 = 0u;
      v43 = 0u;
      v44 = 0u;
      v42 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v34 = 136315906;
      v35 = "operator[]";
      v36 = 1024;
      v37 = 476;
      v38 = 2048;
      v39 = (_QWORD *)v19;
      v40 = 2048;
      v41 = (_QWORD *)v13;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    else
    {
LABEL_28:
      v13 = *(_QWORD *)(v7[3] + 32);
      if (!v13)
      {
LABEL_38:
        if (v30)
        {
          if (v31)
            (*(void (**)(void))(*(_QWORD *)v30 + 40))();
        }
        return result;
      }
      v19 = 0;
      v8 = 0;
      while (1)
      {
        v3 = v31;
        if (v31 <= (unint64_t)v8)
          break;
        if (!*((_BYTE *)v8 + v32))
        {
          v24 = v7[3];
          v3 = *(_QWORD *)(v24 + 32);
          if (v3 <= (unint64_t)v8)
            goto LABEL_55;
          v25 = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(a3[3] + 48, (_QWORD *)(*(_QWORD *)(v24 + 40) + v19));
          if (v25)
          {
            v3 = v7[1];
            if (v3 <= v13)
              goto LABEL_58;
            v3 = *v25;
            v15 = a3[1];
            if (v15 <= *v25)
              goto LABEL_59;
            result = *(float *)(v7[2] + 4 * v13);
            *(float *)(a3[2] + 4 * v3) = result;
          }
        }
        v8 = (_QWORD *)((char *)v8 + 1);
        v19 += 16;
        if ((_QWORD *)v13 == v8)
          goto LABEL_38;
      }
    }
    v33 = 0;
    v45 = 0u;
    v46 = 0u;
    v43 = 0u;
    v44 = 0u;
    v42 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v34 = 136315906;
    v35 = "operator[]";
    v36 = 1024;
    v37 = 468;
    v38 = 2048;
    v39 = v8;
    v40 = 2048;
    v41 = (_QWORD *)v3;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_51:
    v33 = 0;
    v45 = 0u;
    v46 = 0u;
    v43 = 0u;
    v44 = 0u;
    v42 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v34 = 136315906;
    v35 = "operator[]";
    v36 = 1024;
    v37 = 476;
    v38 = 2048;
    v39 = (_QWORD *)v19;
    v40 = 2048;
    v41 = (_QWORD *)v13;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_52:
    v33 = 0;
    v45 = 0u;
    v46 = 0u;
    v43 = 0u;
    v44 = 0u;
    v42 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v34 = 136315906;
    v35 = "operator[]";
    v36 = 1024;
    v37 = 476;
    v38 = 2048;
    v39 = (_QWORD *)v13;
    v40 = 2048;
    v41 = v5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_53:
    v33 = 0;
    v45 = 0u;
    v46 = 0u;
    v43 = 0u;
    v44 = 0u;
    v42 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v34 = 136315906;
    v35 = "operator[]";
    v36 = 1024;
    v37 = 468;
    v38 = 2048;
    v39 = (_QWORD *)v3;
    v40 = 2048;
    v41 = v5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_54:
    v33 = 0;
    v45 = 0u;
    v46 = 0u;
    v43 = 0u;
    v44 = 0u;
    v42 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v34 = 136315906;
    v35 = "operator[]";
    v36 = 1024;
    v37 = 468;
    v38 = 2048;
    v39 = (_QWORD *)v13;
    v40 = 2048;
    v41 = (_QWORD *)v3;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_55:
    v33 = 0;
    v45 = 0u;
    v46 = 0u;
    v43 = 0u;
    v44 = 0u;
    v42 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v34 = 136315906;
    v35 = "operator[]";
    v36 = 1024;
    v37 = 476;
    v38 = 2048;
    v39 = v8;
    v40 = 2048;
    v41 = (_QWORD *)v3;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_56:
    v33 = 0;
    v45 = 0u;
    v46 = 0u;
    v43 = 0u;
    v44 = 0u;
    v42 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v34 = 136315906;
    v35 = "operator[]";
    v36 = 1024;
    v37 = 476;
    v38 = 2048;
    v39 = (_QWORD *)v19;
    v40 = 2048;
    v41 = (_QWORD *)v13;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_57:
    v33 = 0;
    v45 = 0u;
    v46 = 0u;
    v43 = 0u;
    v44 = 0u;
    v42 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v34 = 136315906;
    v35 = "operator[]";
    v36 = 1024;
    v37 = 468;
    v38 = 2048;
    v39 = (_QWORD *)v3;
    v40 = 2048;
    v41 = (_QWORD *)v13;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_58:
    v33 = 0;
    v45 = 0u;
    v46 = 0u;
    v43 = 0u;
    v44 = 0u;
    v42 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v34 = 136315906;
    v35 = "operator[]";
    v36 = 1024;
    v37 = 476;
    v38 = 2048;
    v39 = (_QWORD *)v13;
    v40 = 2048;
    v41 = (_QWORD *)v3;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_59:
    v33 = 0;
    v45 = 0u;
    v46 = 0u;
    v43 = 0u;
    v44 = 0u;
    v42 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v34 = 136315906;
    v35 = "operator[]";
    v36 = 1024;
    v37 = 468;
    v38 = 2048;
    v39 = (_QWORD *)v3;
    v40 = 2048;
    v41 = (_QWORD *)v15;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_60;
  }
  if (v9 == a3[3])
  {
    if (v10)
    {
      v26 = 0;
      v13 = a1[1];
      v27 = a1[2];
      v8 = (_QWORD *)a2[1];
      v28 = a2[2];
      v7 = (_QWORD *)a3[1];
      v29 = a3[2];
      while ((_QWORD *)v13 != v26)
      {
        if (v8 == v26)
          goto LABEL_65;
        if (v7 == v26)
          goto LABEL_66;
        result = *(float *)(v27 + 4 * (_QWORD)v26) + *(float *)(v28 + 4 * (_QWORD)v26);
        *(float *)(v29 + 4 * (_QWORD)v26) = result;
        v26 = (_QWORD *)((char *)v26 + 1);
        if (v10 == v26)
          return result;
      }
LABEL_64:
      v30 = 0;
      v45 = 0u;
      v46 = 0u;
      v43 = 0u;
      v44 = 0u;
      v42 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v34 = 136315906;
      v35 = "operator[]";
      v36 = 1024;
      v37 = 476;
      v38 = 2048;
      v39 = (_QWORD *)v13;
      v40 = 2048;
      v41 = (_QWORD *)v13;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_65:
      v30 = 0;
      v45 = 0u;
      v46 = 0u;
      v43 = 0u;
      v44 = 0u;
      v42 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v34 = 136315906;
      v35 = "operator[]";
      v36 = 1024;
      v37 = 476;
      v38 = 2048;
      v39 = v8;
      v40 = 2048;
      v41 = v8;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_66:
      v30 = 0;
      v45 = 0u;
      v46 = 0u;
      v43 = 0u;
      v44 = 0u;
      v42 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v34 = 136315906;
      v35 = "operator[]";
      v36 = 1024;
      v37 = 468;
      v38 = 2048;
      v39 = v7;
      v40 = 2048;
      v41 = v7;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
  else if (v10)
  {
    v12 = 0;
    v13 = 0;
    while (1)
    {
      v14 = v8[3];
      v15 = *(_QWORD *)(v14 + 32);
      if (v15 <= v13)
        break;
      v16 = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(a3[3] + 48, (_QWORD *)(*(_QWORD *)(v14 + 40) + v12));
      if (v16)
      {
        v15 = v8[1];
        if (v15 <= v13)
          goto LABEL_61;
        v15 = v7[1];
        if (v15 <= v13)
          goto LABEL_62;
        v15 = *v16;
        v4 = (_QWORD *)a3[1];
        if ((unint64_t)v4 <= *v16)
          goto LABEL_63;
        result = *(float *)(v8[2] + 4 * v13) + *(float *)(v7[2] + 4 * v13);
        *(float *)(a3[2] + 4 * v15) = result;
      }
      ++v13;
      v12 += 16;
      if (v10 == (_QWORD *)v13)
        return result;
    }
LABEL_60:
    v30 = 0;
    v45 = 0u;
    v46 = 0u;
    v43 = 0u;
    v44 = 0u;
    v42 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v34 = 136315906;
    v35 = "operator[]";
    v36 = 1024;
    v37 = 476;
    v38 = 2048;
    v39 = (_QWORD *)v13;
    v40 = 2048;
    v41 = (_QWORD *)v15;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_61:
    v30 = 0;
    v45 = 0u;
    v46 = 0u;
    v43 = 0u;
    v44 = 0u;
    v42 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v34 = 136315906;
    v35 = "operator[]";
    v36 = 1024;
    v37 = 476;
    v38 = 2048;
    v39 = (_QWORD *)v13;
    v40 = 2048;
    v41 = (_QWORD *)v15;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_62:
    v30 = 0;
    v45 = 0u;
    v46 = 0u;
    v43 = 0u;
    v44 = 0u;
    v42 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v34 = 136315906;
    v35 = "operator[]";
    v36 = 1024;
    v37 = 476;
    v38 = 2048;
    v39 = (_QWORD *)v13;
    v40 = 2048;
    v41 = (_QWORD *)v15;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_63:
    v30 = 0;
    v45 = 0u;
    v46 = 0u;
    v43 = 0u;
    v44 = 0u;
    v42 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v34 = 136315906;
    v35 = "operator[]";
    v36 = 1024;
    v37 = 468;
    v38 = 2048;
    v39 = (_QWORD *)v15;
    v40 = 2048;
    v41 = v4;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_64;
  }
  return result;
}

_QWORD *re::AnimationValueTraits<re::BlendShapeWeights>::invert(_QWORD *result, _QWORD *a2)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;

  v3 = result;
  v4 = result[3];
  v5 = *(_QWORD *)(v4 + 32);
  v6 = a2[3];
  if (v5 == *(_QWORD *)(v6 + 32) && *(_QWORD *)(v4 + 96) == *(_QWORD *)(v6 + 96))
  {
    if (v5)
    {
      v7 = 0;
      v9 = result[1];
      v8 = result[2];
      v11 = a2[1];
      v10 = a2[2];
      while (v9 != v7)
      {
        if (v11 == v7)
          goto LABEL_22;
        *(float *)(v10 + 4 * v7) = -*(float *)(v8 + 4 * v7);
        if (v5 == ++v7)
          return result;
      }
      goto LABEL_21;
    }
  }
  else if (v5)
  {
    v12 = 0;
    v13 = 0;
    while (1)
    {
      v14 = v3[3];
      if (*(_QWORD *)(v14 + 32) <= v13)
        break;
      result = (_QWORD *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(a2[3] + 48, (_QWORD *)(*(_QWORD *)(v14 + 40) + v12));
      if (result)
      {
        if (v3[1] <= v13)
          goto LABEL_19;
        if (a2[1] <= *result)
          goto LABEL_20;
        *(float *)(a2[2] + 4 * *result) = -*(float *)(v3[2] + 4 * v13);
      }
      ++v13;
      v12 += 16;
      if (v5 == v13)
        return result;
    }
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_19:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_20:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_21:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_22:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return result;
}

_anonymous_namespace_ *re::AnimationValueTraits<re::BlendShapeWeights>::interpolate(_anonymous_namespace_ *result, _QWORD *a2, _QWORD *a3, float a4)
{
  unint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v9;
  unint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  float v20;
  uint64_t v21;
  _QWORD *v22;
  unint64_t *v23;
  unint64_t *v24;
  uint64_t v25;
  unint64_t *v26;
  _QWORD *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  float v31;
  _anonymous_namespace_ *v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  const char *v37;
  __int16 v38;
  int v39;
  __int16 v40;
  _QWORD *v41;
  __int16 v42;
  _QWORD *v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  uint64_t v49;

  v9 = a2;
  v10 = (unint64_t)result;
  v49 = *MEMORY[0x24BDAC8D0];
  v11 = *((_QWORD *)result + 3);
  v12 = *(_QWORD **)(v11 + 32);
  v13 = a2[3];
  if (v12 != *(_QWORD **)(v13 + 32) || *(_QWORD *)(v11 + 96) != *(_QWORD *)(v13 + 96))
  {
    v18 = *(_QWORD *)(v9[3] + 32);
    v33 = 0;
    v34 = 0;
    v32 = 0;
    v17 = *(_QWORD *)(*(_QWORD *)(v10 + 24) + 32);
    if (v17)
    {
      v5 = 0;
      v19 = 0;
      v20 = 1.0 - a4;
      while (1)
      {
        v21 = *(_QWORD *)(v10 + 24);
        v15 = *(_QWORD *)(v21 + 32);
        if (v15 <= v19)
          break;
        v22 = (_QWORD *)((char *)v5 + *(_QWORD *)(v21 + 40));
        v23 = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(a3[3] + 48, v22);
        if (v23)
        {
          v4 = *v23;
          v24 = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v9[3] + 48, v22);
          if (v24)
          {
            v15 = *(_QWORD *)(v10 + 8);
            if (v15 <= v19)
              goto LABEL_51;
            v15 = *v24;
            v6 = (_QWORD *)v9[1];
            if ((unint64_t)v6 <= *v24)
              goto LABEL_52;
            v6 = (_QWORD *)a3[1];
            if ((unint64_t)v6 <= v4)
              goto LABEL_53;
            *(float *)(a3[2] + 4 * v4) = (float)(*(float *)(v9[2] + 4 * v15) * a4)
                                       + (float)(*(float *)(*(_QWORD *)(v10 + 16) + 4 * v19) * v20);
            v4 = v33;
            if (v33 <= v15)
              goto LABEL_54;
            *(_BYTE *)(v34 + v15) = 1;
          }
          else
          {
            v15 = *(_QWORD *)(v10 + 8);
            if (v15 <= v19)
              goto LABEL_56;
            v15 = a3[1];
            if (v15 <= v4)
              goto LABEL_57;
            *(float *)(a3[2] + 4 * v4) = (float)(a4 * 0.0) + (float)(*(float *)(*(_QWORD *)(v10 + 16) + 4 * v19) * v20);
          }
        }
        ++v19;
        v5 += 2;
        if (v17 == v19)
          goto LABEL_28;
      }
      v35 = 0;
      v47 = 0u;
      v48 = 0u;
      v45 = 0u;
      v46 = 0u;
      v44 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v36 = 136315906;
      v37 = "operator[]";
      v38 = 1024;
      v39 = 476;
      v40 = 2048;
      v41 = (_QWORD *)v19;
      v42 = 2048;
      v43 = (_QWORD *)v15;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    else
    {
LABEL_28:
      v15 = *(_QWORD *)(v9[3] + 32);
      if (!v15)
      {
LABEL_38:
        result = v32;
        if (v32)
        {
          if (v33)
            return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v32 + 40))();
        }
        return result;
      }
      v19 = 0;
      v10 = 0;
      while (1)
      {
        v4 = v33;
        if (v33 <= v10)
          break;
        if (!*(_BYTE *)(v34 + v10))
        {
          v25 = v9[3];
          v4 = *(_QWORD *)(v25 + 32);
          if (v4 <= v10)
            goto LABEL_55;
          v26 = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(a3[3] + 48, (_QWORD *)(*(_QWORD *)(v25 + 40) + v19));
          if (v26)
          {
            v4 = v9[1];
            if (v4 <= v10)
              goto LABEL_58;
            v4 = *v26;
            v17 = a3[1];
            if (v17 <= *v26)
              goto LABEL_59;
            *(float *)(a3[2] + 4 * v4) = (float)(*(float *)(v9[2] + 4 * v10) * a4) + (float)((float)(1.0 - a4) * 0.0);
          }
        }
        ++v10;
        v19 += 16;
        if (v15 == v10)
          goto LABEL_38;
      }
    }
    v35 = 0;
    v47 = 0u;
    v48 = 0u;
    v45 = 0u;
    v46 = 0u;
    v44 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v36 = 136315906;
    v37 = "operator[]";
    v38 = 1024;
    v39 = 468;
    v40 = 2048;
    v41 = (_QWORD *)v10;
    v42 = 2048;
    v43 = (_QWORD *)v4;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_51:
    v35 = 0;
    v47 = 0u;
    v48 = 0u;
    v45 = 0u;
    v46 = 0u;
    v44 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v36 = 136315906;
    v37 = "operator[]";
    v38 = 1024;
    v39 = 476;
    v40 = 2048;
    v41 = (_QWORD *)v19;
    v42 = 2048;
    v43 = (_QWORD *)v15;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_52:
    v35 = 0;
    v47 = 0u;
    v48 = 0u;
    v45 = 0u;
    v46 = 0u;
    v44 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v36 = 136315906;
    v37 = "operator[]";
    v38 = 1024;
    v39 = 476;
    v40 = 2048;
    v41 = (_QWORD *)v15;
    v42 = 2048;
    v43 = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_53:
    v35 = 0;
    v47 = 0u;
    v48 = 0u;
    v45 = 0u;
    v46 = 0u;
    v44 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v36 = 136315906;
    v37 = "operator[]";
    v38 = 1024;
    v39 = 468;
    v40 = 2048;
    v41 = (_QWORD *)v4;
    v42 = 2048;
    v43 = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_54:
    v35 = 0;
    v47 = 0u;
    v48 = 0u;
    v45 = 0u;
    v46 = 0u;
    v44 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v36 = 136315906;
    v37 = "operator[]";
    v38 = 1024;
    v39 = 468;
    v40 = 2048;
    v41 = (_QWORD *)v15;
    v42 = 2048;
    v43 = (_QWORD *)v4;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_55:
    v35 = 0;
    v47 = 0u;
    v48 = 0u;
    v45 = 0u;
    v46 = 0u;
    v44 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v36 = 136315906;
    v37 = "operator[]";
    v38 = 1024;
    v39 = 476;
    v40 = 2048;
    v41 = (_QWORD *)v10;
    v42 = 2048;
    v43 = (_QWORD *)v4;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_56:
    v35 = 0;
    v47 = 0u;
    v48 = 0u;
    v45 = 0u;
    v46 = 0u;
    v44 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v36 = 136315906;
    v37 = "operator[]";
    v38 = 1024;
    v39 = 476;
    v40 = 2048;
    v41 = (_QWORD *)v19;
    v42 = 2048;
    v43 = (_QWORD *)v15;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_57:
    v35 = 0;
    v47 = 0u;
    v48 = 0u;
    v45 = 0u;
    v46 = 0u;
    v44 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v36 = 136315906;
    v37 = "operator[]";
    v38 = 1024;
    v39 = 468;
    v40 = 2048;
    v41 = (_QWORD *)v4;
    v42 = 2048;
    v43 = (_QWORD *)v15;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_58:
    v35 = 0;
    v47 = 0u;
    v48 = 0u;
    v45 = 0u;
    v46 = 0u;
    v44 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v36 = 136315906;
    v37 = "operator[]";
    v38 = 1024;
    v39 = 476;
    v40 = 2048;
    v41 = (_QWORD *)v10;
    v42 = 2048;
    v43 = (_QWORD *)v4;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_59:
    v35 = 0;
    v47 = 0u;
    v48 = 0u;
    v45 = 0u;
    v46 = 0u;
    v44 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v36 = 136315906;
    v37 = "operator[]";
    v38 = 1024;
    v39 = 468;
    v40 = 2048;
    v41 = (_QWORD *)v4;
    v42 = 2048;
    v43 = (_QWORD *)v17;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_60;
  }
  if (v11 == a3[3])
  {
    if (v12)
    {
      v27 = 0;
      v15 = *((_QWORD *)result + 1);
      v28 = *((_QWORD *)result + 2);
      v10 = a2[1];
      v29 = a2[2];
      v9 = (_QWORD *)a3[1];
      v30 = a3[2];
      v31 = 1.0 - a4;
      while ((_QWORD *)v15 != v27)
      {
        if ((_QWORD *)v10 == v27)
          goto LABEL_65;
        if (v9 == v27)
          goto LABEL_66;
        *(float *)(v30 + 4 * (_QWORD)v27) = (float)(*(float *)(v29 + 4 * (_QWORD)v27) * a4)
                                            + (float)(*(float *)(v28 + 4 * (_QWORD)v27) * v31);
        v27 = (_QWORD *)((char *)v27 + 1);
        if (v12 == v27)
          return result;
      }
LABEL_64:
      v32 = 0;
      v47 = 0u;
      v48 = 0u;
      v45 = 0u;
      v46 = 0u;
      v44 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v36 = 136315906;
      v37 = "operator[]";
      v38 = 1024;
      v39 = 476;
      v40 = 2048;
      v41 = (_QWORD *)v15;
      v42 = 2048;
      v43 = (_QWORD *)v15;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_65:
      v32 = 0;
      v47 = 0u;
      v48 = 0u;
      v45 = 0u;
      v46 = 0u;
      v44 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v36 = 136315906;
      v37 = "operator[]";
      v38 = 1024;
      v39 = 476;
      v40 = 2048;
      v41 = (_QWORD *)v10;
      v42 = 2048;
      v43 = (_QWORD *)v10;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_66:
      v32 = 0;
      v47 = 0u;
      v48 = 0u;
      v45 = 0u;
      v46 = 0u;
      v44 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v36 = 136315906;
      v37 = "operator[]";
      v38 = 1024;
      v39 = 468;
      v40 = 2048;
      v41 = v9;
      v42 = 2048;
      v43 = v9;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
  else if (v12)
  {
    v14 = 0;
    v15 = 0;
    while (1)
    {
      v16 = *(_QWORD *)(v10 + 24);
      v17 = *(_QWORD *)(v16 + 32);
      if (v17 <= v15)
        break;
      result = (_anonymous_namespace_ *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(a3[3] + 48, (_QWORD *)(*(_QWORD *)(v16 + 40) + v14));
      if (result)
      {
        v17 = *(_QWORD *)(v10 + 8);
        if (v17 <= v15)
          goto LABEL_61;
        v17 = v9[1];
        if (v17 <= v15)
          goto LABEL_62;
        v17 = *(_QWORD *)result;
        v5 = (_QWORD *)a3[1];
        if ((unint64_t)v5 <= *(_QWORD *)result)
          goto LABEL_63;
        *(float *)(a3[2] + 4 * v17) = (float)(*(float *)(v9[2] + 4 * v15) * a4)
                                    + (float)(*(float *)(*(_QWORD *)(v10 + 16) + 4 * v15) * (float)(1.0 - a4));
      }
      ++v15;
      v14 += 16;
      if (v12 == (_QWORD *)v15)
        return result;
    }
LABEL_60:
    v32 = 0;
    v47 = 0u;
    v48 = 0u;
    v45 = 0u;
    v46 = 0u;
    v44 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v36 = 136315906;
    v37 = "operator[]";
    v38 = 1024;
    v39 = 476;
    v40 = 2048;
    v41 = (_QWORD *)v15;
    v42 = 2048;
    v43 = (_QWORD *)v17;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_61:
    v32 = 0;
    v47 = 0u;
    v48 = 0u;
    v45 = 0u;
    v46 = 0u;
    v44 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v36 = 136315906;
    v37 = "operator[]";
    v38 = 1024;
    v39 = 476;
    v40 = 2048;
    v41 = (_QWORD *)v15;
    v42 = 2048;
    v43 = (_QWORD *)v17;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_62:
    v32 = 0;
    v47 = 0u;
    v48 = 0u;
    v45 = 0u;
    v46 = 0u;
    v44 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v36 = 136315906;
    v37 = "operator[]";
    v38 = 1024;
    v39 = 476;
    v40 = 2048;
    v41 = (_QWORD *)v15;
    v42 = 2048;
    v43 = (_QWORD *)v17;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_63:
    v32 = 0;
    v47 = 0u;
    v48 = 0u;
    v45 = 0u;
    v46 = 0u;
    v44 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v36 = 136315906;
    v37 = "operator[]";
    v38 = 1024;
    v39 = 468;
    v40 = 2048;
    v41 = (_QWORD *)v17;
    v42 = 2048;
    v43 = v5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_64;
  }
  return result;
}

void re::BlendShapeWeightsDefinition::~BlendShapeWeightsDefinition(re::BlendShapeWeightsDefinition *this)
{
  _QWORD *v2;

  *(_QWORD *)this = &off_24ED24398;
  v2 = (_QWORD *)((char *)this + 24);
  re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 6);
  re::FixedArray<re::StringID>::deinit(v2);
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  _QWORD *v2;

  *(_QWORD *)this = &off_24ED24398;
  v2 = (_QWORD *)((char *)this + 24);
  re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 6);
  re::FixedArray<re::StringID>::deinit(v2);
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

uint64_t re::SharedObject::allocator(re::SharedObject *this)
{
  return *((_QWORD *)this + 2);
}

void re::TypeBuilderHelper::registerFixedArray<float>(re::TypeRegistry *a1@<X0>, uint64_t *a2@<X1>, __int128 *a3@<X2>, re::TypeRegistry **a4@<X8>)
{
  _anonymous_namespace_ *v8;
  re::TypeRegistry *v9;
  uint64_t v10;
  __int128 v11;
  _BYTE v12[488];

  v8 = (_anonymous_namespace_ *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a1 + 200, a2);
  if (a1 && v8)
  {
    v9 = *(re::TypeRegistry **)v8;
    *a4 = a1;
    a4[1] = v9;
  }
  else
  {
    v11 = *a3;
    re::TypeBuilder::beginListType((uint64_t)v12, a2, 1, 0x18uLL, 8uLL, &v11);
    re::TypeBuilder::setConstructor((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerFixedArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
    re::TypeBuilder::setDestructor((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerFixedArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
    re::TypeBuilder::setListUsesContiguousStorage((uint64_t)v12, 1);
    re::TypeBuilder::setListAccessors((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerFixedArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerFixedArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
    re::TypeBuilder::setListIndexer((uint64_t)v12, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerFixedArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
    re::TypeBuilder::setListIterator((uint64_t)v12, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerFixedArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerFixedArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerFixedArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
    re::TypeBuilder::commitTo((re::TypeBuilder *)v12, a1, a4);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v12, v10);
  }
}

_QWORD *re::IntrospectionFixedArray<float>::~IntrospectionFixedArray(_QWORD *a1)
{
  *a1 = &off_24ED20258;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionFixedArray<float>::~IntrospectionFixedArray(_QWORD *a1)
{
  *a1 = &off_24ED20258;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x2276933B8);
}

void re::IntrospectionFixedArray<float>::construct(uint64_t a1, _QWORD *a2)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
}

uint64_t re::IntrospectionFixedArray<float>::destroy(uint64_t a1, uint64_t *a2)
{
  uint64_t result;
  _QWORD *v4;

  result = *a2;
  if (*a2)
  {
    v4 = a2 + 1;
    if (a2[1])
    {
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, a2[2]);
      *v4 = 0;
      v4[1] = 0;
    }
    *a2 = 0;
  }
  return result;
}

void re::IntrospectionFixedArray<float>::init(uint64_t a1, uint64_t *a2, re *a3, int a4, unint64_t a5)
{
  uint64_t v10;
  unint64_t v11;

  re::FixedArray<int>::init<>(a2, (uint64_t)a3, a5);
  if (a5)
  {
    v10 = 0;
    v11 = 0;
    do
    {
      if (a2[1] <= v11)
      {
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      re::introspectionInitElement(a3, a4, *(re::Allocator **)(a1 + 48), (re::IntrospectionBase *)(a2[2] + v10));
      ++v11;
      v10 += 4;
    }
    while (a5 != v11);
  }
}

uint64_t re::IntrospectionFixedArray<float>::deinit(uint64_t a1, uint64_t *a2)
{
  uint64_t result;
  _QWORD *v4;

  result = *a2;
  if (*a2)
  {
    v4 = a2 + 1;
    if (a2[1])
    {
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, a2[2]);
      *v4 = 0;
      v4[1] = 0;
    }
    *a2 = 0;
  }
  return result;
}

uint64_t re::IntrospectionFixedArray<float>::size(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 8);
}

BOOL re::IntrospectionFixedArray<float>::isInitialized(uint64_t a1, _QWORD *a2)
{
  return *a2 != 0;
}

uint64_t re::IntrospectionFixedArray<float>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(_QWORD *)(a2 + 8) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 16) + 4 * a3;
}

{
  if (*(_QWORD *)(a2 + 8) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 16) + 4 * a3;
}

_QWORD *re::TypeBuilderHelper::registerFixedArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(_QWORD *result, uint64_t a2, uint64_t a3)
{
  result[1] = 0;
  result[2] = 0;
  *result = a3;
  return result;
}

uint64_t re::TypeBuilderHelper::registerFixedArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke(uint64_t *a1)
{
  uint64_t result;

  result = *a1;
  if (result)
  {
    if (a1[1])
    {
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, a1[2]);
      a1[1] = 0;
      a1[2] = 0;
    }
    *a1 = 0;
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerFixedArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

void re::TypeBuilderHelper::registerFixedArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t *a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  uint64_t v8;
  _anonymous_namespace_ *v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  _BYTE v13[32];
  _BYTE v14[8];
  uint64_t v15;

  v8 = *a1;
  if (v8)
  {
    if (a1[1])
    {
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v8 + 40))(v8, a1[2]);
      a1[1] = 0;
      a1[2] = 0;
    }
    *a1 = 0;
  }
  re::FixedArray<int>::init<>(a1, (uint64_t)a3, a4);
  {
    re::TypeRegistry::typeInfo(*(_QWORD **)a2, *(_QWORD *)(*(_QWORD *)(a2 + 16) + 72), v14);
    re::TypeInfo::TypeInfo((uint64_t)v13, (uint64_t)&v15);
    v10 = a1[1];
    if (v10)
    {
      v11 = (char *)a1[2];
      v12 = 4 * v10;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v13, v11, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v13, (void **)v11, a3, 0);
        v11 += 4;
        v12 -= 4;
      }
      while (v12);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerFixedArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(_QWORD *)(a1 + 8) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a1 + 16) + 4 * a2;
}

uint64_t re::TypeBuilderHelper::registerFixedArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 16, 8);
  *(_QWORD *)result = a1;
  *(_DWORD *)(result + 8) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerFixedArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1)
{
  int v1;
  uint64_t v2;
  unint64_t v3;

  v1 = a1[2];
  v2 = *(_QWORD *)a1;
  v3 = *(_QWORD *)(*(_QWORD *)a1 + 8);
  if (v1 < (int)v3)
    a1[2] = ++v1;
  if (v3 <= v1)
    return 0;
  else
    return *(_QWORD *)(v2 + 16) + 4 * v1;
}

uint64_t re::TypeBuilderHelper::registerFixedArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 40))(a2, result);
  return result;
}

uint64_t re::internal::retargetingSolverCallback(uint64_t a1, uint64_t a2, re::RigDataValue *a3, unint64_t a4, uint64_t a5, uint64_t a6, re::RigDataValue *a7, uint64_t a8, uint64_t a9)
{
  re::RigDataValue *v11;
  int v12;
  uint64_t result;

  if (!a4)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_19;
  }
  if (a4 == 1)
  {
LABEL_19:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    _os_crash();
    __break(1u);
    goto LABEL_20;
  }
  if (a4 <= 2)
  {
LABEL_20:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, a4);
    _os_crash();
    __break(1u);
    goto LABEL_21;
  }
  if (!a8)
  {
LABEL_21:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, 0, 0);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v11 = (re::RigDataValue *)((char *)a3 + 288);
  if (re::internal::enableSignposts(0, 0))
    kdebug_trace();
  re::internal::transferPose(v11, a9 + 40);
  re::internal::transferPose(a3, a9 + 16);
  if (re::internal::enableSignposts(0, 0))
    kdebug_trace();
  if (re::internal::enableSignposts(0, 0))
    kdebug_trace();
  v12 = CoreIKSolve();
  if (re::internal::enableSignposts(0, 0))
  {
    CoreIKSolverGetConstraintCount();
    kdebug_trace();
  }
  if (re::internal::enableSignposts(0, 0))
    kdebug_trace();
  re::internal::updateOutputBasedOnSolveResult(v12, (uint64_t)a3, (_OWORD *)(a9 + 16), a7);
  result = re::internal::enableSignposts(0, 0);
  if ((_DWORD)result)
    return kdebug_trace();
  return result;
}

uint64_t re::internal::retargetingSolverCompile(re::Allocator **a1, _QWORD *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  _anonymous_namespace_ *v6;
  const re::RigDataValue *v7;
  _anonymous_namespace_ *v8;
  const char *v9;
  size_t v10;
  uint64_t v11;
  uint64_t v12;
  re::Allocator *v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v18;
  _OWORD v19[2];
  int v20;
  _OWORD v21[2];
  int v22;
  uint64_t v23;
  StringID v24;
  re::Allocator *v25;
  char **p_var1;
  _BYTE v27[288];
  _BYTE v28[288];
  _BYTE v29[288];
  uint64_t v30;

  v30 = *MEMORY[0x24BDAC8D0];
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_8;
  }
  if (a3 == 1)
  {
LABEL_8:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  if (a3 <= 2)
  {
LABEL_9:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2);
    _os_crash();
    __break(1u);
    goto LABEL_10;
  }
  if (a3 == 3)
  {
LABEL_10:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 3, 3);
    _os_crash();
    __break(1u);
LABEL_11:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
  }
  if (!a5)
    goto LABEL_11;
  v6 = *(_anonymous_namespace_ **)(a2[1] + 184);
  v7 = (const re::RigDataValue *)a2[3];
  v8 = *(_anonymous_namespace_ **)(a2[2] + 184);
  v18 = *a4;
  v9 = *(const char **)(*a2 + 232);
  v10 = strlen(v9);
  v11 = MEMORY[0x22769136C](v9, v10);
  re::internal::makePoseFromRig(a1, v6, v11, (uint64_t)v29);
  re::internal::makeSourcePose(a1, v8, v11, (uint64_t)v28);
  v12 = MEMORY[0x2276916F0](v11);
  re::internal::makePose(a1, v12, (uint64_t)v27);
  v23 = 0;
  memset(v19, 0, sizeof(v19));
  v20 = 0;
  memset(v21, 0, sizeof(v21));
  v22 = 0;
  v13 = *a1;
  re::RigGraphCallbackBuilder::init((re::RigGraphCallbackBuilder *)v19, *a1);
  *(_QWORD *)&v24.var0 = 0x10643527A253C4;
  v24.var1 = "TargetPose";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v19, &v24, (const re::RigDataValue *)v29);
  re::StringID::destroyString((re::StringID *)&v24);
  *(_QWORD *)&v24.var0 = 0x104A00692196D8;
  v24.var1 = "SourcePose";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v19, &v24, (const re::RigDataValue *)v28);
  re::StringID::destroyString((re::StringID *)&v24);
  *(_QWORD *)&v24.var0 = 0xF3F1BA25D000CB3ALL;
  v24.var1 = "SolverToComponentTransform";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v19, &v24, v7);
  re::StringID::destroyString((re::StringID *)&v24);
  *(_QWORD *)&v24.var0 = 0xDC3EE39E3142978ELL;
  v24.var1 = "SolvedTargetPose";
  re::RigGraphCallbackBuilder::addOutputParam((re::RigGraphCallbackBuilder *)v19, &v24, (re::RigDataValue *)v27);
  re::StringID::destroyString((re::StringID *)&v24);
  v14 = (*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(_QWORD *)v13 + 32))(v13, 64, 8);
  *(_QWORD *)v14 = MEMORY[0x227691378](v11);
  *(_QWORD *)(v14 + 8) = v13;
  *(_OWORD *)(v14 + 32) = 0u;
  *(_OWORD *)(v14 + 48) = 0u;
  *(_OWORD *)(v14 + 16) = 0u;
  v15 = MEMORY[0x2276916F0](v11);
  re::FixedArray<CoreIKTransform>::init<>((uint64_t *)(v14 + 16), (uint64_t)v13, v15);
  v16 = MEMORY[0x2276916D8](v11);
  re::FixedArray<CoreIKTransform>::init<>((uint64_t *)(v14 + 40), (uint64_t)v13, v16);
  *(_QWORD *)&v24.var0 = v14;
  v24.var1 = (char *)&off_24ED24558;
  p_var1 = &v24.var1;
  v25 = v13;
  re::RigGraphCallbackBuilder::buildCallbackData((unint64_t *)v19, (uint64_t)a1, (uint64_t)re::internal::retargetingSolverCallback, (uint64_t *)&v24);
  re::internal::bindCallbackOutputToNodeOutputPose(v6, (re::RigDataValue *)v27, v11, (uint64_t)a1, v18);
  MEMORY[0x2276913A8](v11);
  std::unique_ptr<re::RigHierarchy,std::function<void ()(re::RigHierarchy*)>>::~unique_ptr[abi:nn180100]((uint64_t *)&v24);
  re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)v21 + 8);
  re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)v19 + 8);
  re::RigDataValue::~RigDataValue((re::RigDataValue *)v27);
  re::RigDataValue::~RigDataValue((re::RigDataValue *)v28);
  re::RigDataValue::~RigDataValue((re::RigDataValue *)v29);
  return 1;
}

uint64_t re::internal::arvinoToArvinoRetargetNodeCallback(int a1, uint64_t a2, unint64_t a3, unint64_t a4, int a5, int a6, re::RigDataValue *a7, uint64_t a8, re::internal::AutoRetargetRigGraphNode *a9)
{
  uint64_t result;

  if (!a4)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_11;
  }
  if (a4 == 1)
  {
LABEL_11:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (a4 <= 2)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, a4);
    _os_crash();
    __break(1u);
    goto LABEL_13;
  }
  if (a4 == 3)
  {
LABEL_13:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 3, 3);
    _os_crash();
    __break(1u);
    goto LABEL_14;
  }
  if (a4 <= 4)
  {
LABEL_14:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 4, 4);
    _os_crash();
    __break(1u);
    goto LABEL_15;
  }
  if (!a8)
  {
LABEL_15:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, 0, 0);
    result = _os_crash();
    __break(1u);
    return result;
  }
  result = re::internal::AutoRetargetRigGraphNode::initialize(a9, (const re::RigDataValue *)(a3 + 576), (const re::RigDataValue *)(a3 + 864), (const re::RigDataValue *)(a3 + 1152), (const re::RigDataValue *)(a3 + 1152));
  if ((_DWORD)result)
    return re::internal::AutoRetargetRigGraphNode::solveAndUpdate(a9, a3, (const re::RigDataValue *)(a3 + 288), a7);
  return result;
}

uint64_t re::internal::arvinoToArvinoRetargetNodeCompile(re::Allocator **a1, _QWORD *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t *v6;
  re::RigHierarchy *v7;
  const re::RigDataValue *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  re::Allocator *v12;
  re::internal::AutoRetargetRigGraphNode *v13;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  __int128 v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _OWORD v35[2];
  int v36;
  _BYTE v37[32];
  int v38;
  uint64_t v39;
  __int128 v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44[5];
  uint64_t v45[5];
  uint64_t v46[5];
  uint64_t v47[5];
  uint64_t v48[5];
  uint64_t v49[5];
  __int128 v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54[5];
  uint64_t v55[5];
  uint64_t v56[5];
  uint64_t v57[5];
  uint64_t v58[5];
  uint64_t v59[5];
  StringID v60;
  re::Allocator *v61;
  char **p_var1;
  _BYTE v63[288];
  _BYTE v64[288];
  _BYTE v65[288];
  _BYTE v66[288];
  _BYTE v67[296];
  uint64_t v68;

  v68 = *MEMORY[0x24BDAC8D0];
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_7;
  }
  if (a3 == 1)
  {
LABEL_7:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    _os_crash();
    __break(1u);
    goto LABEL_8;
  }
  if (a3 <= 2)
  {
LABEL_8:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2);
    _os_crash();
    __break(1u);
LABEL_9:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
  }
  if (!a5)
    goto LABEL_9;
  v6 = *(uint64_t **)(*a2 + 184);
  v7 = *(re::RigHierarchy **)(a2[1] + 184);
  v8 = (const re::RigDataValue *)a2[2];
  v9 = *a4;
  re::internal::makePoseFromRigHierarchy(a1, (re::RigHierarchy *)v6, (uint64_t)v67);
  re::RigHierarchy::getBindPoseHierarchy((re::RigHierarchy *)v6, v10, (uint64_t)&v50);
  re::internal::makePoseFromRigHierarchy(a1, (re::RigHierarchy *)&v50, (uint64_t)v66);
  re::internal::makePoseFromRigHierarchy(a1, v7, (uint64_t)v65);
  re::RigHierarchy::getBindPoseHierarchy(v7, v11, (uint64_t)&v40);
  re::internal::makePoseFromRigHierarchy(a1, (re::RigHierarchy *)&v40, (uint64_t)v64);
  re::internal::makePose(a1, v6[27], (uint64_t)v63);
  v39 = 0;
  memset(v35, 0, sizeof(v35));
  memset(v37, 0, sizeof(v37));
  v36 = 0;
  v38 = 0;
  v12 = *a1;
  re::RigGraphCallbackBuilder::init((re::RigGraphCallbackBuilder *)v35, *a1);
  *(_QWORD *)&v60.var0 = 0x10643527A253C4;
  v60.var1 = "TargetPose";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v35, &v60, (const re::RigDataValue *)v67);
  re::StringID::destroyString((re::StringID *)&v60);
  *(_QWORD *)&v60.var0 = 0x104A00692196D8;
  v60.var1 = "SourcePose";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v35, &v60, (const re::RigDataValue *)v65);
  re::StringID::destroyString((re::StringID *)&v60);
  *(_QWORD *)&v60.var0 = 0xFC2B6F833ABE967ELL;
  v60.var1 = "TargetBindPose";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v35, &v60, (const re::RigDataValue *)v66);
  re::StringID::destroyString((re::StringID *)&v60);
  *(_QWORD *)&v60.var0 = 0x8AE112C755FE2F92;
  v60.var1 = "SourceBindPose";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v35, &v60, (const re::RigDataValue *)v64);
  re::StringID::destroyString((re::StringID *)&v60);
  *(_QWORD *)&v60.var0 = 0xB88303615935B0FCLL;
  v60.var1 = "ModelToWorldTransform";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v35, &v60, v8);
  re::StringID::destroyString((re::StringID *)&v60);
  *(_QWORD *)&v60.var0 = 0xDC3EE39E3142978ELL;
  v60.var1 = "SolvedTargetPose";
  re::RigGraphCallbackBuilder::addOutputParam((re::RigGraphCallbackBuilder *)v35, &v60, (re::RigDataValue *)v63);
  re::StringID::destroyString((re::StringID *)&v60);
  v25 = v50;
  v26 = v51;
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::HashTable((uint64_t)&v27, (uint64_t)&v52);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::HashTable((uint64_t)&v28, (uint64_t)&v53);
  re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::DynamicArray((uint64_t)&v29, v54);
  re::DynamicArray<re::DynamicArray<re::RigDataValue>>::DynamicArray((uint64_t)&v30, v55);
  re::DynamicArray<re::StringID>::DynamicArray((uint64_t)&v31, v56);
  re::DynamicArray<unsigned long>::DynamicArray((uint64_t)&v32, v57);
  re::DynamicArray<re::RigHierarchyJointTransform>::DynamicArray((uint64_t)&v33, v58);
  re::DynamicArray<unsigned long>::DynamicArray((uint64_t)&v34, v59);
  v15 = v40;
  v16 = v41;
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::HashTable((uint64_t)&v17, (uint64_t)&v42);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::HashTable((uint64_t)&v18, (uint64_t)&v43);
  re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::DynamicArray((uint64_t)&v19, v44);
  re::DynamicArray<re::DynamicArray<re::RigDataValue>>::DynamicArray((uint64_t)&v20, v45);
  re::DynamicArray<re::StringID>::DynamicArray((uint64_t)&v21, v46);
  re::DynamicArray<unsigned long>::DynamicArray((uint64_t)&v22, v47);
  re::DynamicArray<re::RigHierarchyJointTransform>::DynamicArray((uint64_t)&v23, v48);
  re::DynamicArray<unsigned long>::DynamicArray((uint64_t)&v24, v49);
  v13 = (re::internal::AutoRetargetRigGraphNode *)(*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(_QWORD *)v12 + 32))(v12, 144, 8);
  *(_QWORD *)&v60.var0 = re::internal::AutoRetargetRigGraphNode::AutoRetargetRigGraphNode(v13, v12, (const re::RigHierarchy *)&v25, (const re::RigHierarchy *)&v15);
  v60.var1 = (char *)&off_24ED245D8;
  p_var1 = &v60.var1;
  v61 = v12;
  re::RigHierarchy::~RigHierarchy((re::RigHierarchy *)&v15);
  re::RigHierarchy::~RigHierarchy((re::RigHierarchy *)&v25);
  re::RigGraphCallbackBuilder::buildCallbackData((unint64_t *)v35, (uint64_t)a1, (uint64_t)re::internal::arvinoToArvinoRetargetNodeCallback, (uint64_t *)&v60);
  re::internal::bindCallbackOutputToNodeOutputPose((re::RigHierarchy *)v6, (re::RigDataValue *)v63, v9, (uint64_t)a1);
  std::unique_ptr<re::RigHierarchy,std::function<void ()(re::RigHierarchy*)>>::~unique_ptr[abi:nn180100]((uint64_t *)&v60);
  re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)&v37[8]);
  re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)v35 + 8);
  re::RigDataValue::~RigDataValue((re::RigDataValue *)v63);
  re::RigDataValue::~RigDataValue((re::RigDataValue *)v64);
  re::RigHierarchy::~RigHierarchy((re::RigHierarchy *)&v40);
  re::RigDataValue::~RigDataValue((re::RigDataValue *)v65);
  re::RigDataValue::~RigDataValue((re::RigDataValue *)v66);
  re::RigHierarchy::~RigHierarchy((re::RigHierarchy *)&v50);
  re::RigDataValue::~RigDataValue((re::RigDataValue *)v67);
  return 1;
}

uint64_t re::internal::bipedToBipedAutoRetargetNodeCallback(int a1, uint64_t a2, unint64_t a3, unint64_t a4, int a5, int a6, re::RigDataValue *a7, uint64_t a8, re::internal::AutoRetargetRigGraphNode *a9)
{
  uint64_t result;

  if (!a4)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (a4 == 1)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    _os_crash();
    __break(1u);
    goto LABEL_13;
  }
  if (a4 <= 2)
  {
LABEL_13:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, a4);
    _os_crash();
    __break(1u);
    goto LABEL_14;
  }
  if (a4 == 3)
  {
LABEL_14:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 3, 3);
    _os_crash();
    __break(1u);
    goto LABEL_15;
  }
  if (a4 <= 4)
  {
LABEL_15:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 4, 4);
    _os_crash();
    __break(1u);
    goto LABEL_16;
  }
  if (a4 == 5)
  {
LABEL_16:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 5, 5);
    _os_crash();
    __break(1u);
    goto LABEL_17;
  }
  if (!a8)
  {
LABEL_17:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, 0, 0);
    result = _os_crash();
    __break(1u);
    return result;
  }
  result = re::internal::AutoRetargetRigGraphNode::initialize(a9, (const re::RigDataValue *)(a3 + 576), (const re::RigDataValue *)(a3 + 864), (const re::RigDataValue *)(a3 + 1152), (const re::RigDataValue *)(a3 + 1440));
  if ((_DWORD)result)
    return re::internal::AutoRetargetRigGraphNode::solveAndUpdate(a9, a3, (const re::RigDataValue *)(a3 + 288), a7);
  return result;
}

uint64_t re::internal::bipedToBipedAutoRetargetNodeCompile(re::Allocator **a1, _QWORD *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t *v6;
  re::RigHierarchy *v7;
  const re::RigDataValue *v8;
  const re::RigDataValue *v9;
  uint64_t v10;
  uint64_t v11;
  re::Allocator *v12;
  re::internal::AutoRetargetRigGraphNode *v13;
  uint64_t v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  __int128 v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  _OWORD v36[2];
  int v37;
  _BYTE v38[32];
  int v39;
  uint64_t v40;
  __int128 v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45[5];
  uint64_t v46[5];
  uint64_t v47[5];
  uint64_t v48[5];
  uint64_t v49[5];
  uint64_t v50[5];
  __int128 v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55[5];
  uint64_t v56[5];
  uint64_t v57[5];
  uint64_t v58[5];
  uint64_t v59[5];
  uint64_t v60[5];
  StringID v61;
  re::Allocator *v62;
  char **p_var1;
  _BYTE v64[288];
  _BYTE v65[288];
  _BYTE v66[288];
  _BYTE v67[288];
  _BYTE v68[296];
  uint64_t v69;

  v69 = *MEMORY[0x24BDAC8D0];
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_8;
  }
  if (a3 == 1)
  {
LABEL_8:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  if (a3 <= 2)
  {
LABEL_9:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2);
    _os_crash();
    __break(1u);
    goto LABEL_10;
  }
  if (a3 == 3)
  {
LABEL_10:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 3, 3);
    _os_crash();
    __break(1u);
LABEL_11:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
  }
  if (!a5)
    goto LABEL_11;
  v6 = *(uint64_t **)(*a2 + 184);
  v7 = *(re::RigHierarchy **)(a2[1] + 184);
  v9 = (const re::RigDataValue *)a2[2];
  v8 = (const re::RigDataValue *)a2[3];
  v15 = *a4;
  re::internal::makePoseFromRigHierarchy(a1, (re::RigHierarchy *)v6, (uint64_t)v68);
  re::RigHierarchy::getBindPoseHierarchy((re::RigHierarchy *)v6, v10, (uint64_t)&v51);
  re::internal::makePoseFromRigHierarchy(a1, (re::RigHierarchy *)&v51, (uint64_t)v67);
  re::internal::makePoseFromRigHierarchy(a1, v7, (uint64_t)v66);
  re::RigHierarchy::getBindPoseHierarchy(v7, v11, (uint64_t)&v41);
  re::internal::makePoseFromRigHierarchy(a1, (re::RigHierarchy *)&v41, (uint64_t)v65);
  re::internal::makePose(a1, v6[27], (uint64_t)v64);
  v40 = 0;
  memset(v36, 0, sizeof(v36));
  memset(v38, 0, sizeof(v38));
  v37 = 0;
  v39 = 0;
  v12 = *a1;
  re::RigGraphCallbackBuilder::init((re::RigGraphCallbackBuilder *)v36, *a1);
  *(_QWORD *)&v61.var0 = 0x10643527A253C4;
  v61.var1 = "TargetPose";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v36, &v61, (const re::RigDataValue *)v68);
  re::StringID::destroyString((re::StringID *)&v61);
  *(_QWORD *)&v61.var0 = 0x104A00692196D8;
  v61.var1 = "SourcePose";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v36, &v61, (const re::RigDataValue *)v66);
  re::StringID::destroyString((re::StringID *)&v61);
  *(_QWORD *)&v61.var0 = 0xFC2B6F833ABE967ELL;
  v61.var1 = "TargetBindPose";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v36, &v61, (const re::RigDataValue *)v67);
  re::StringID::destroyString((re::StringID *)&v61);
  *(_QWORD *)&v61.var0 = 0x8AE112C755FE2F92;
  v61.var1 = "SourceBindPose";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v36, &v61, (const re::RigDataValue *)v65);
  re::StringID::destroyString((re::StringID *)&v61);
  *(_QWORD *)&v61.var0 = 0xE3E7F62755B346DALL;
  v61.var1 = "TargetModelToWorldTransform";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v36, &v61, v9);
  re::StringID::destroyString((re::StringID *)&v61);
  *(_QWORD *)&v61.var0 = 0x8128E1FAEBA80E46;
  v61.var1 = "SourceModelToWorldTransform";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v36, &v61, v8);
  re::StringID::destroyString((re::StringID *)&v61);
  *(_QWORD *)&v61.var0 = 0xDC3EE39E3142978ELL;
  v61.var1 = "SolvedTargetPose";
  re::RigGraphCallbackBuilder::addOutputParam((re::RigGraphCallbackBuilder *)v36, &v61, (re::RigDataValue *)v64);
  re::StringID::destroyString((re::StringID *)&v61);
  v26 = v51;
  v27 = v52;
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::HashTable((uint64_t)&v28, (uint64_t)&v53);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::HashTable((uint64_t)&v29, (uint64_t)&v54);
  re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::DynamicArray((uint64_t)&v30, v55);
  re::DynamicArray<re::DynamicArray<re::RigDataValue>>::DynamicArray((uint64_t)&v31, v56);
  re::DynamicArray<re::StringID>::DynamicArray((uint64_t)&v32, v57);
  re::DynamicArray<unsigned long>::DynamicArray((uint64_t)&v33, v58);
  re::DynamicArray<re::RigHierarchyJointTransform>::DynamicArray((uint64_t)&v34, v59);
  re::DynamicArray<unsigned long>::DynamicArray((uint64_t)&v35, v60);
  v16 = v41;
  v17 = v42;
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::HashTable((uint64_t)&v18, (uint64_t)&v43);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::HashTable((uint64_t)&v19, (uint64_t)&v44);
  re::DynamicArray<re::Pair<re::DynamicString,re::RigDataTypeClass,true>>::DynamicArray((uint64_t)&v20, v45);
  re::DynamicArray<re::DynamicArray<re::RigDataValue>>::DynamicArray((uint64_t)&v21, v46);
  re::DynamicArray<re::StringID>::DynamicArray((uint64_t)&v22, v47);
  re::DynamicArray<unsigned long>::DynamicArray((uint64_t)&v23, v48);
  re::DynamicArray<re::RigHierarchyJointTransform>::DynamicArray((uint64_t)&v24, v49);
  re::DynamicArray<unsigned long>::DynamicArray((uint64_t)&v25, v50);
  v13 = (re::internal::AutoRetargetRigGraphNode *)(*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(_QWORD *)v12 + 32))(v12, 144, 8);
  *(_QWORD *)&v61.var0 = re::internal::AutoRetargetRigGraphNode::AutoRetargetRigGraphNode(v13, v12, (const re::RigHierarchy *)&v26, (const re::RigHierarchy *)&v16);
  v61.var1 = (char *)&off_24ED245D8;
  p_var1 = &v61.var1;
  v62 = v12;
  re::RigHierarchy::~RigHierarchy((re::RigHierarchy *)&v16);
  re::RigHierarchy::~RigHierarchy((re::RigHierarchy *)&v26);
  re::RigGraphCallbackBuilder::buildCallbackData((unint64_t *)v36, (uint64_t)a1, (uint64_t)re::internal::bipedToBipedAutoRetargetNodeCallback, (uint64_t *)&v61);
  re::internal::bindCallbackOutputToNodeOutputPose((re::RigHierarchy *)v6, (re::RigDataValue *)v64, v15, (uint64_t)a1);
  std::unique_ptr<re::RigHierarchy,std::function<void ()(re::RigHierarchy*)>>::~unique_ptr[abi:nn180100]((uint64_t *)&v61);
  re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)&v38[8]);
  re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)v36 + 8);
  re::RigDataValue::~RigDataValue((re::RigDataValue *)v64);
  re::RigDataValue::~RigDataValue((re::RigDataValue *)v65);
  re::RigHierarchy::~RigHierarchy((re::RigHierarchy *)&v41);
  re::RigDataValue::~RigDataValue((re::RigDataValue *)v66);
  re::RigDataValue::~RigDataValue((re::RigDataValue *)v67);
  re::RigHierarchy::~RigHierarchy((re::RigHierarchy *)&v51);
  re::RigDataValue::~RigDataValue((re::RigDataValue *)v68);
  return 1;
}

void re::internal::registerRetargetingSolverNode(re::internal *this, re::RigEnvironment *a2)
{
  uint64_t v3[2];
  unint64_t v4[2];
  _OWORD v5[3];
  uint64_t v6;
  _OWORD v7[5];
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v6 = 0;
  v4[0] = 0;
  memset(v5, 0, sizeof(v5));
  v4[1] = (unint64_t)&str_110;
  v3[0] = 0;
  v3[1] = (uint64_t)&str_110;
  v7[2] = xmmword_24ED24488;
  v7[3] = *(_OWORD *)&off_24ED24498;
  v7[4] = xmmword_24ED244A8;
  v7[0] = constinit_6;
  v7[1] = *(_OWORD *)&off_24ED24478;
  re::RigGraphOperatorDefinition::init(v4, (uint64_t *)this, v3, 4uLL, 1uLL, (unint64_t)re::internal::retargetingSolverCompile, (const char **)v7);
  re::StringID::destroyString((re::StringID *)v3);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v5[1] + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(v5);
  re::StringID::destroyString((re::StringID *)v4);
}

void re::internal::registerArvinoToArvinoRetargetNode(re::internal *this, re::RigEnvironment *a2)
{
  uint64_t v3[2];
  unint64_t v4[2];
  _OWORD v5[3];
  uint64_t v6;
  _OWORD v7[4];
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v6 = 0;
  v4[0] = 0;
  memset(v5, 0, sizeof(v5));
  v4[1] = (unint64_t)&str_110;
  v3[0] = 0;
  v3[1] = (uint64_t)&str_110;
  v7[0] = constinit_20_0;
  v7[1] = *(_OWORD *)&off_24ED244C8;
  v7[2] = xmmword_24ED244D8;
  v7[3] = *(_OWORD *)&off_24ED244E8;
  re::RigGraphOperatorDefinition::init(v4, (uint64_t *)this, v3, 3uLL, 1uLL, (unint64_t)re::internal::arvinoToArvinoRetargetNodeCompile, (const char **)v7);
  re::StringID::destroyString((re::StringID *)v3);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v5[1] + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(v5);
  re::StringID::destroyString((re::StringID *)v4);
}

void re::internal::registerBipedToBipedRetargetNode(re::internal *this, re::RigEnvironment *a2)
{
  uint64_t v3[2];
  unint64_t v4[2];
  _OWORD v5[3];
  uint64_t v6;
  _OWORD v7[5];
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v6 = 0;
  v4[0] = 0;
  memset(v5, 0, sizeof(v5));
  v4[1] = (unint64_t)&str_110;
  v3[0] = 0;
  v3[1] = (uint64_t)&str_110;
  v7[2] = xmmword_24ED24518;
  v7[3] = *(_OWORD *)&off_24ED24528;
  v7[4] = xmmword_24ED24538;
  v7[0] = constinit_24;
  v7[1] = *(_OWORD *)&off_24ED24508;
  re::RigGraphOperatorDefinition::init(v4, (uint64_t *)this, v3, 4uLL, 1uLL, (unint64_t)re::internal::bipedToBipedAutoRetargetNodeCompile, (const char **)v7);
  re::StringID::destroyString((re::StringID *)v3);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v5[1] + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(v5);
  re::StringID::destroyString((re::StringID *)v4);
}

void _ZNSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_33CoreIKRetargetingSolverNodeHelperENS2_9AllocatorEJP9CoreIKRigEEEDaPT0_DpT1_EUlPvE_NS_9allocatorISF_EEFvSE_EED0Ev()
{
  JUMPOUT(0x2276933B8);
}

_QWORD *_ZNKSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_33CoreIKRetargetingSolverNodeHelperENS2_9AllocatorEJP9CoreIKRigEEEDaPT0_DpT1_EUlPvE_NS_9allocatorISF_EEFvSE_EE7__cloneEv(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24ED24558;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_33CoreIKRetargetingSolverNodeHelperENS2_9AllocatorEJP9CoreIKRigEEEDaPT0_DpT1_EUlPvE_NS_9allocatorISF_EEFvSE_EE7__cloneEPNS0_6__baseISI_EE(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24ED24558;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_33CoreIKRetargetingSolverNodeHelperENS2_9AllocatorEJP9CoreIKRigEEEDaPT0_DpT1_EUlPvE_NS_9allocatorISF_EEFvSE_EEclEOSE_(uint64_t result, _QWORD *a2)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = (_QWORD *)*a2;
  if (*a2)
  {
    v3 = *(_QWORD *)(result + 8);
    MEMORY[0x2276913B4](*v2);
    v4 = v2[5];
    if (v4)
    {
      if (v2[6])
      {
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, v2[7]);
        v2[6] = 0;
        v2[7] = 0;
      }
      v2[5] = 0;
    }
    v5 = v2[2];
    if (v5)
    {
      if (v2[3])
      {
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v5 + 40))(v5, v2[4]);
        v2[3] = 0;
        v2[4] = 0;
      }
      v2[2] = 0;
    }
    return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v3 + 40))(v3, v2);
  }
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_33CoreIKRetargetingSolverNodeHelperENS2_9AllocatorEJP9CoreIKRigEEEDaPT0_DpT1_EUlPvE_NS_9allocatorISF_EEFvSE_EE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:nn180100](a2, (uint64_t)&_ZTIZN2re8internal14makeNodeUniqueINS0_33CoreIKRetargetingSolverNodeHelperENS_9AllocatorEJP9CoreIKRigEEEDaPT0_DpT1_EUlPvE_))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *_ZNKSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_33CoreIKRetargetingSolverNodeHelperENS2_9AllocatorEJP9CoreIKRigEEEDaPT0_DpT1_EUlPvE_NS_9allocatorISF_EEFvSE_EE11target_typeEv()
{
  return &_ZTIZN2re8internal14makeNodeUniqueINS0_33CoreIKRetargetingSolverNodeHelperENS_9AllocatorEJP9CoreIKRigEEEDaPT0_DpT1_EUlPvE_;
}

void _ZNSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_24AutoRetargetRigGraphNodeENS2_9AllocatorEJNS2_12RigHierarchyES7_EEEDaPT0_DpT1_EUlPvE_NS_9allocatorISE_EEFvSD_EED0Ev()
{
  JUMPOUT(0x2276933B8);
}

_QWORD *_ZNKSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_24AutoRetargetRigGraphNodeENS2_9AllocatorEJNS2_12RigHierarchyES7_EEEDaPT0_DpT1_EUlPvE_NS_9allocatorISE_EEFvSD_EE7__cloneEv(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24ED245D8;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_24AutoRetargetRigGraphNodeENS2_9AllocatorEJNS2_12RigHierarchyES7_EEEDaPT0_DpT1_EUlPvE_NS_9allocatorISE_EEFvSD_EE7__cloneEPNS0_6__baseISH_EE(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24ED245D8;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_24AutoRetargetRigGraphNodeENS2_9AllocatorEJNS2_12RigHierarchyES7_EEEDaPT0_DpT1_EUlPvE_NS_9allocatorISE_EEFvSD_EEclEOSD_(uint64_t result, _QWORD **a2)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v2 = *a2;
  if (*a2)
  {
    v3 = *(_QWORD *)(result + 8);
    if (*v2)
      MEMORY[0x2276913B4]();
    v4 = v2[13];
    if (v4)
    {
      if (v2[14])
      {
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, v2[15]);
        v2[14] = 0;
        v2[15] = 0;
      }
      v2[13] = 0;
    }
    v5 = v2[10];
    if (v5)
    {
      if (v2[11])
      {
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v5 + 40))(v5, v2[12]);
        v2[11] = 0;
        v2[12] = 0;
      }
      v2[10] = 0;
    }
    v6 = v2[7];
    if (v6)
    {
      if (v2[8])
      {
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v6 + 40))(v6, v2[9]);
        v2[8] = 0;
        v2[9] = 0;
      }
      v2[7] = 0;
    }
    re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(v2 + 4);
    re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(v2 + 1);
    return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v3 + 40))(v3, v2);
  }
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_24AutoRetargetRigGraphNodeENS2_9AllocatorEJNS2_12RigHierarchyES7_EEEDaPT0_DpT1_EUlPvE_NS_9allocatorISE_EEFvSD_EE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:nn180100](a2, (uint64_t)&_ZTIZN2re8internal14makeNodeUniqueINS0_24AutoRetargetRigGraphNodeENS_9AllocatorEJNS_12RigHierarchyES4_EEEDaPT0_DpT1_EUlPvE_))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *_ZNKSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_24AutoRetargetRigGraphNodeENS2_9AllocatorEJNS2_12RigHierarchyES7_EEEDaPT0_DpT1_EUlPvE_NS_9allocatorISE_EEFvSD_EE11target_typeEv()
{
  return &_ZTIZN2re8internal14makeNodeUniqueINS0_24AutoRetargetRigGraphNodeENS_9AllocatorEJNS_12RigHierarchyES4_EEEDaPT0_DpT1_EUlPvE_;
}

void re::introspect_AnimationHandoffType(re *this, const re::IntrospectionBase *a2)
{
  unsigned __int8 v2;
  unsigned __int8 v3;
  uint64_t *v4;
  uint64_t v5;
  unsigned int *v6;
  _anonymous_namespace_ *v7;
  unint64_t v8;
  unint64_t i;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  char v13;
  unsigned __int8 *v14;
  int v15;
  uint64_t v16;
  unint64_t j;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  char v21;
  unsigned __int8 *v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  re *v26;
  uint64_t *v27;
  re *v28;
  uint64_t *v29;
  re *v30;
  uint64_t *v31;
  re *v32;
  uint64_t *v33;
  re *v34;
  uint64_t *v35;
  re *v36;
  uint64_t *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  const char *v41;
  StringID v42;
  _QWORD v43[2];
  _QWORD v44[61];

  v2 = atomic_load((unsigned __int8 *)&qword_2540FA370);
  if ((v2 & 1) == 0)
  {
    v26 = (re *)__cxa_guard_acquire(&qword_2540FA370);
    if ((_DWORD)v26)
    {
      v27 = re::introspectionAllocator(v26);
      v28 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v27 + 32))(v27, 24, 8);
      *(_DWORD *)v28 = 1;
      *((_QWORD *)v28 + 1) = 0;
      *((_QWORD *)v28 + 2) = "SnapshotAndReplace";
      qword_2540FA3A8 = (uint64_t)v28;
      v29 = re::introspectionAllocator(v28);
      v30 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v29 + 32))(v29, 24, 8);
      *(_DWORD *)v30 = 1;
      *((_QWORD *)v30 + 1) = 1;
      *((_QWORD *)v30 + 2) = "Replace";
      qword_2540FA3B0 = (uint64_t)v30;
      v31 = re::introspectionAllocator(v30);
      v32 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v31 + 32))(v31, 24, 8);
      *(_DWORD *)v32 = 1;
      *((_QWORD *)v32 + 1) = 2;
      *((_QWORD *)v32 + 2) = "Compose";
      qword_2540FA3B8 = (uint64_t)v32;
      v33 = re::introspectionAllocator(v32);
      v34 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v33 + 32))(v33, 24, 8);
      *(_DWORD *)v34 = 1;
      *((_QWORD *)v34 + 1) = 3;
      *((_QWORD *)v34 + 2) = "Stop";
      qword_2540FA3C0 = (uint64_t)v34;
      v35 = re::introspectionAllocator(v34);
      v36 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v35 + 32))(v35, 24, 8);
      *(_DWORD *)v36 = 1;
      *((_QWORD *)v36 + 1) = 4;
      *((_QWORD *)v36 + 2) = "UpdateBaseAndCompose";
      qword_2540FA3C8 = (uint64_t)v36;
      v37 = re::introspectionAllocator(v36);
      v38 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v37 + 32))(v37, 24, 8);
      *(_DWORD *)v38 = 1;
      *(_QWORD *)(v38 + 8) = 5;
      *(_QWORD *)(v38 + 16) = "ComposeAndUpdateBase";
      qword_2540FA3D0 = v38;
      __cxa_guard_release(&qword_2540FA370);
    }
  }
  v3 = atomic_load((unsigned __int8 *)&qword_2540FA378);
  if ((v3 & 1) == 0 && __cxa_guard_acquire(&qword_2540FA378))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_2540FA3D8, "AnimationHandoffType", 4, 4, 1, 1);
    qword_2540FA3D8 = (uint64_t)&off_24ED7D9E8;
    qword_2540FA418 = (uint64_t)&re::introspect_AnimationHandoffType(BOOL)::enumTable;
    dword_2540FA3E8 = 9;
    __cxa_guard_release(&qword_2540FA378);
  }
  if ((_MergedGlobals_22 & 1) == 0)
  {
    _MergedGlobals_22 = 1;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_2540FA3D8, a2);
    v40 = 0x8FFDC97622DE77ECLL;
    v41 = "AnimationHandoffType";
    v44[0] = 208862;
    v44[1] = "int";
    v4 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v44);
    if (v4)
    {
      v5 = *v4;
      re::StringID::destroyString((re::StringID *)v44);
      v6 = (unsigned int *)qword_2540FA418;
      v43[1] = v5;
      re::TypeBuilder::beginEnumType((uint64_t)v44, &v40, 1, 1, (uint64_t)v43);
      v8 = *v6;
      if ((_DWORD)v8)
      {
        for (i = 0; i < v8; ++i)
        {
          v10 = *(_QWORD *)(*((_QWORD *)v6 + 1) + 8 * i);
          if (*(_DWORD *)v10 == 1)
          {
            v11 = *(char **)(v10 + 16);
            if (v11)
            {
              v12 = *v11;
              if (*v11)
              {
                v13 = v11[1];
                if (v13)
                {
                  v14 = (unsigned __int8 *)(v11 + 2);
                  do
                  {
                    v12 = 31 * v12 + v13;
                    v15 = *v14++;
                    v13 = v15;
                  }
                  while (v15);
                }
              }
            }
            else
            {
              v12 = 0;
            }
            v16 = *(_QWORD *)(v10 + 8);
            *(_QWORD *)&v42.var0 = 2 * v12;
            v42.var1 = v11;
            re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v44, v16, &v42);
            re::StringID::destroyString((re::StringID *)&v42);
            v8 = *v6;
          }
        }
        if (v8)
        {
          for (j = 0; j < v8; ++j)
          {
            v18 = *(_QWORD *)(*((_QWORD *)v6 + 1) + 8 * j);
            if (*(_DWORD *)v18 == 2)
            {
              v19 = *(char **)(v18 + 16);
              if (v19)
              {
                v20 = *v19;
                if (*v19)
                {
                  v21 = v19[1];
                  if (v21)
                  {
                    v22 = (unsigned __int8 *)(v19 + 2);
                    do
                    {
                      v20 = 31 * v20 + v21;
                      v23 = *v22++;
                      v21 = v23;
                    }
                    while (v23);
                  }
                }
              }
              else
              {
                v20 = 0;
              }
              v24 = *(_QWORD *)(v18 + 8);
              *(_QWORD *)&v42.var0 = 2 * v20;
              v42.var1 = v19;
              re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v44, v24, &v42);
              re::StringID::destroyString((re::StringID *)&v42);
              v8 = *v6;
            }
          }
        }
      }
      re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v44, v25);
      xmmword_2540FA3F8 = (__int128)v42;
      re::StringID::destroyString((re::StringID *)&v40);
    }
    else
    {
      re::StringID::destroyString((re::StringID *)v44);
      re::internal::assertLog((re::internal *)5, v39, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "AnimationHandoffType", v40, v41);
      _os_crash();
      __break(1u);
    }
  }
}

uint64_t *re::allocInfo_AnimationHandoffDesc(re *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&qword_2540FA380);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_2540FA380))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FA420, 0);
    *(uint64_t *)((char *)&qword_2540FA430 + 6) = 0;
    qword_2540FA430 = 0;
    qword_2540FA440 = 0;
    qword_2540FA448 = 0xFFFFFFFFLL;
    qword_2540FA420 = (uint64_t)&off_24ED7DAA8;
    qword_2540FA450 = (uint64_t)"AnimationHandoffDesc";
    dword_2540FA458 = 0;
    xmmword_2540FA460 = 0u;
    unk_2540FA470 = 0u;
    xmmword_2540FA480 = 0u;
    qword_2540FA490 = 0;
    __cxa_guard_release(&qword_2540FA380);
  }
  return &qword_2540FA420;
}

void re::initInfo_AnimationHandoffDesc(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  const re::IntrospectionBase *v7;
  void *v8;
  uint64_t v9;
  uint64_t *v10;
  const re::IntrospectionBase *v11;
  uint64_t v12;
  uint64_t *v13;
  const re::IntrospectionBase *v14;
  void *v15;
  uint64_t v16;
  __int128 v17;
  _QWORD v18[2];
  __int128 v19;

  v18[0] = 0x8FFDC97622CF569ALL;
  v18[1] = "AnimationHandoffDesc";
  re::StringID::destroyString((re::StringID *)v18);
  *((_OWORD *)this + 2) = v19;
  v4 = atomic_load((unsigned __int8 *)&qword_2540FA388);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_2540FA388);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      v8 = re::introspect_float((re *)1, v7);
      v9 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
      *(_DWORD *)v9 = 1;
      *(_QWORD *)(v9 + 8) = "fadeDuration";
      *(_QWORD *)(v9 + 16) = v8;
      *(_QWORD *)(v9 + 24) = 0;
      *(_QWORD *)(v9 + 32) = 0x400000001;
      *(_DWORD *)(v9 + 40) = 0;
      *(_QWORD *)(v9 + 48) = 0;
      *(_QWORD *)(v9 + 56) = 0;
      *(_DWORD *)(v9 + 64) = 0;
      qword_2540FA390 = v9;
      v10 = re::introspectionAllocator((re *)v9);
      re::introspect_AnimationHandoffType((re *)v10, v11);
      v12 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v10 + 32))(v10, 72, 8);
      *(_DWORD *)v12 = 1;
      *(_QWORD *)(v12 + 8) = "type";
      *(_QWORD *)(v12 + 16) = &qword_2540FA3D8;
      *(_QWORD *)(v12 + 24) = 0;
      *(_QWORD *)(v12 + 32) = 2;
      *(_DWORD *)(v12 + 40) = 0;
      *(_QWORD *)(v12 + 48) = 0;
      *(_QWORD *)(v12 + 56) = 0;
      *(_DWORD *)(v12 + 64) = 0;
      qword_2540FA398 = v12;
      v13 = re::introspectionAllocator((re *)v12);
      v15 = re::introspect_BOOL((re *)1, v14);
      v16 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v13 + 32))(v13, 72, 8);
      *(_DWORD *)v16 = 1;
      *(_QWORD *)(v16 + 8) = "layerOnly";
      *(_QWORD *)(v16 + 16) = v15;
      *(_QWORD *)(v16 + 24) = 0;
      *(_QWORD *)(v16 + 32) = 0x800000003;
      *(_DWORD *)(v16 + 40) = 0;
      *(_QWORD *)(v16 + 48) = 0;
      *(_QWORD *)(v16 + 56) = 0;
      *(_DWORD *)(v16 + 64) = 0;
      qword_2540FA3A0 = v16;
      __cxa_guard_release(&qword_2540FA388);
    }
  }
  *((_QWORD *)this + 2) = 0x1800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 3;
  *((_QWORD *)this + 8) = &qword_2540FA390;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::AnimationHandoffDesc>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::AnimationHandoffDesc>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::AnimationHandoffDesc>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::AnimationHandoffDesc>;
  re::IntrospectionRegistry::add(this, v3);
  v17 = v19;
}

void re::internal::defaultConstruct<re::AnimationHandoffDesc>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_BYTE *)(a3 + 8) = 0;
  *(_QWORD *)a3 = 0;
  *(_DWORD *)(a3 + 12) = 0x80000000;
  *(_QWORD *)(a3 + 16) = "";
}

uint64_t re::internal::defaultConstructV2<re::AnimationHandoffDesc>(uint64_t result)
{
  *(_BYTE *)(result + 8) = 0;
  *(_QWORD *)result = 0;
  *(_DWORD *)(result + 12) = 0x80000000;
  *(_QWORD *)(result + 16) = "";
  return result;
}

uint64_t re::introspect_AnimationHandoffDesc(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"AnimationHandoffDesc", (uint64_t (*)(re::internal *))re::allocInfo_AnimationHandoffDesc, (re::IntrospectionBase *(*)(void))re::initInfo_AnimationHandoffDesc, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::AnimationHandoffDesc>, this);
}

void re::TimelineGroup::timelineDesc(re::TimelineGroup *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  double v7;
  uint64_t v8;
  double v9;
  float v10;

  v4 = *((_QWORD *)this + 10);
  if (v4)
  {
    v5 = (uint64_t *)*((_QWORD *)this + 11);
    v6 = 8 * v4;
    v7 = 0.0;
    do
    {
      v8 = *v5++;
      v9 = (*(double (**)(uint64_t))(*(_QWORD *)v8 + 40))(v8);
      if (v7 < v9)
        v7 = v9;
      v6 -= 8;
    }
    while (v6);
    v10 = v7;
  }
  else
  {
    v10 = 0.0;
  }
  *(_DWORD *)a2 = 0;
  *(float *)(a2 + 4) = v10;
  *(_QWORD *)(a2 + 8) = 1065353216;
  *(float *)(a2 + 16) = v10;
  *(_DWORD *)(a2 + 20) = 0;
  *(_BYTE *)(a2 + 24) = 0;
  *(_BYTE *)(a2 + 25) = *((_BYTE *)this + 16);
}

double re::TimelineGroup::totalDuration(re::TimelineGroup *this)
{
  uint64_t v1;
  uint64_t *v2;
  uint64_t v3;
  double v4;
  uint64_t v5;
  double v6;

  v1 = *((_QWORD *)this + 10);
  if (!v1)
    return 0.0;
  v2 = (uint64_t *)*((_QWORD *)this + 11);
  v3 = 8 * v1;
  v4 = 0.0;
  do
  {
    v5 = *v2++;
    v6 = (*(double (**)(uint64_t))(*(_QWORD *)v5 + 40))(v5);
    if (v4 < v6)
      v4 = v6;
    v3 -= 8;
  }
  while (v3);
  return v4;
}

void re::TimelineGroup::~TimelineGroup(re::TimelineGroup *this)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *((_QWORD *)this + 9);
  if (v2)
  {
    if (*((_QWORD *)this + 10))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *((_QWORD *)this + 11));
      *((_QWORD *)this + 10) = 0;
      *((_QWORD *)this + 11) = 0;
    }
    *((_QWORD *)this + 9) = 0;
  }
  *(_QWORD *)this = off_24ED1F350;
  v3 = *((_QWORD *)this + 5);
  if (v3)
  {
    if ((*((_BYTE *)this + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *((_QWORD *)this + 7));
    *(_OWORD *)((char *)this + 40) = 0u;
    *(_OWORD *)((char *)this + 56) = 0u;
  }
  re::StringID::destroyString((re::TimelineGroup *)((char *)this + 24));
}

{
  uint64_t v2;
  uint64_t v3;

  v2 = *((_QWORD *)this + 9);
  if (v2)
  {
    if (*((_QWORD *)this + 10))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *((_QWORD *)this + 11));
      *((_QWORD *)this + 10) = 0;
      *((_QWORD *)this + 11) = 0;
    }
    *((_QWORD *)this + 9) = 0;
  }
  *(_QWORD *)this = off_24ED1F350;
  v3 = *((_QWORD *)this + 5);
  if (v3)
  {
    if ((*((_BYTE *)this + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *((_QWORD *)this + 7));
    *(_OWORD *)((char *)this + 40) = 0u;
    *(_OWORD *)((char *)this + 56) = 0u;
  }
  re::StringID::destroyString((re::TimelineGroup *)((char *)this + 24));
  JUMPOUT(0x2276933B8);
}

uint64_t re::TimelineGroup::childCount(re::TimelineGroup *this)
{
  return *((_QWORD *)this + 10);
}

uint64_t re::TimelineGroup::child(re::TimelineGroup *this, unint64_t a2)
{
  if (*((_QWORD *)this + 10) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(*((_QWORD *)this + 11) + 8 * a2);
}

uint64_t re::internal::CoreIKFootPlacementSolverNodeHelper::CoreIKFootPlacementSolverNodeHelper(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8;
  float32x4_t v9;
  float32x4_t v10;

  *(_QWORD *)a1 = CoreIKFootPlacementSolverCreate();
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_DWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 64) = a4;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 84) = 0xFFFFFFFF00000001;
  *(_OWORD *)(a1 + 124) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 140) = 0u;
  *(_OWORD *)(a1 + 108) = 0u;
  *(_OWORD *)(a1 + 92) = 0u;
  *(_DWORD *)(a1 + 128) = 1;
  *(_QWORD *)(a1 + 144) = 0;
  *(_QWORD *)(a1 + 152) = 0;
  *(_QWORD *)(a1 + 136) = 0;
  *(_DWORD *)(a1 + 160) = 0;
  *(_QWORD *)(a1 + 176) = a2;
  *(_QWORD *)(a1 + 192) = 0;
  *(_QWORD *)(a1 + 200) = 0;
  *(_QWORD *)(a1 + 184) = 0;
  *(_BYTE *)(a1 + 208) = 1;
  v8 = MEMORY[0x2276916F0](a3);
  re::FixedArray<CoreIKTransform>::init<>((uint64_t *)(a1 + 184), a2, v8);
  CoreIKFootPlacementSolverGetGenericSolver();
  CoreIKGenericSolverGetTargetRestPose();
  v10 = vmulq_f32(v9, v9);
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = xmmword_2260E5F50;
  *(float *)(a1 + 48) = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v10, 2), vaddq_f32(v10, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v10.f32, 1))).f32[0])* 4.0;
  return a1;
}

uint64_t re::internal::CoreIKFootPlacementSolverNodeHelper::updateLookAtTasks(re::internal::CoreIKFootPlacementSolverNodeHelper *this, const re::RigDataValue *a2)
{
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  unint64_t i;
  re::RigDataValue *v7;
  __int128 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  result = CoreIKFootPlacementSolverGetGenericSolver();
  v4 = *((_QWORD *)a2 + 32);
  if (v4)
  {
    v5 = result;
    for (i = 0; i != v4; ++i)
    {
      v7 = (re::RigDataValue *)re::RigDataValue::attributeValue(a2, i);
      re::internal::getRuntimeValue<re::internal::IKLookAtTaskSettings>(v7, (uint64_t)&v8);
      MEMORY[0x22769154C](v5, v9);
      result = CoreIKGenericConstraintSetLookAtParameters();
    }
  }
  return result;
}

uint64_t re::internal::CoreIKFootPlacementSolverNodeHelper::updateRayCastTasks(float32x4_t *a1, re::RigDataValue *a2, float32x4_t *a3)
{
  uint64_t result;
  uint64_t v7;
  unint64_t v8;
  uint64_t i;
  uint64_t v10;
  re::internal *v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  int32x4_t v16;
  float32x4_t v17;
  int32x4_t v18;
  __n128 v19;
  __n128 v20;
  float v21;
  float32x4_t v22;
  _QWORD v23[4];
  int32x4_t v24;
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  result = CoreIKFootPlacementSolverGetConstraintCount();
  if (result)
  {
    v7 = result;
    v8 = 0;
    for (i = 0; i != v7; ++i)
    {
      v10 = MEMORY[0x227691444](a1->i64[0], i);
      result = CoreIKFootPlacementConstraintIsRayTracing();
      if ((_DWORD)result)
      {
        v21 = a1[3].f32[0] * 0.5;
        v22 = a1[2];
        v11 = (re::internal *)re::RigDataValue::attributeValue(a2, v8);
        re::internal::getSRTFromRDV(v11, v23);
        v12 = a3[1];
        v13 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v12, (int32x4_t)v12), (int8x16_t)v12, 0xCuLL);
        v14 = vnegq_f32(v12);
        v15 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v24, v24), (int8x16_t)v24, 0xCuLL), v14), (float32x4_t)v24, v13);
        v16 = (int32x4_t)vaddq_f32(v15, v15);
        v17 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v16, v16), (int8x16_t)v16, 0xCuLL);
        v18 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v17, (int32x4_t)v17), (int8x16_t)v17, 0xCuLL), v14), v17, v13);
        a1[1] = vsubq_f32(vaddq_f32(a3[2], vmulq_f32(*a3, vaddq_f32(vaddq_f32((float32x4_t)v24, vmulq_laneq_f32(v17, v12, 3)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v18, v18), (int8x16_t)v18, 0xCuLL)))), vmulq_n_f32(v22, v21));
        re::internal::RayCaster::cast((float32x4_t *)a1[4].i64, (uint64_t)&a1[1], (uint64_t)v23);
        if (LOBYTE(v23[0]))
        {
          CoreIKFootPlacementConstraintSetRayTraceParameters();
          v19.n128_u32[0] = 1.0;
          v20.n128_u32[0] = 1.0;
        }
        else
        {
          v19.n128_u32[0] = 0;
          v20.n128_u32[0] = 0;
        }
        result = MEMORY[0x227691414](v10, v19, v20);
        ++v8;
      }
    }
  }
  return result;
}

uint64_t re::internal::CoreIKFootPlacementSolverNodeHelper::solveAndUpdate(re::internal::CoreIKFootPlacementSolverNodeHelper *this, const re::RigDataValue *a2, re::RigDataValue *a3)
{
  int v6;
  uint64_t result;

  CoreIKFootPlacementSolverGetGenericSolver();
  if (re::internal::enableSignposts(0, 0))
    kdebug_trace();
  v6 = CoreIKGenericSolverSolve();
  if (re::internal::enableSignposts(0, 0))
  {
    CoreIKFootPlacementSolverGetGenericSolver();
    CoreIKGenericSolverGetConstraintCount();
    CoreIKFootPlacementSolverGetGenericSolver();
    CoreIKGenericSolverGetJointCount();
    kdebug_trace();
  }
  if (re::internal::enableSignposts(0, 0))
    kdebug_trace();
  re::internal::updateOutputBasedOnSolveResult(v6, (uint64_t)a2, (re::internal::CoreIKFootPlacementSolverNodeHelper *)((char *)this + 184), a3);
  result = re::internal::enableSignposts(0, 0);
  if ((_DWORD)result)
    return kdebug_trace();
  return result;
}

uint64_t re::internal::footPlacementSolverCallback(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, re::RigDataValue *a7, uint64_t a8, float32x4_t *a9)
{
  unint64_t v9;
  uint64_t v13;
  uint64_t v14;
  float32x4_t v16;
  float32x4_t v17;
  int32x4_t v18;
  float32x4_t v20;
  float32x4_t v26;
  int32x4_t v27;
  float32x4_t v28;
  int32x4_t v29;
  uint64_t v31;
  uint64_t result;
  float32x4_t v33[3];
  float32x4_t v34;
  int32x4_t v35;
  int32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;

  if (!a4)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_14;
  }
  v9 = a4;
  if (a4 == 1)
  {
LABEL_14:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    _os_crash();
    __break(1u);
    goto LABEL_15;
  }
  if (a4 <= 2)
  {
LABEL_15:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, v9);
    _os_crash();
    __break(1u);
    goto LABEL_16;
  }
  re::internal::getSRTFromRDV((re::internal *)(a3 + 576), &v37);
  if (v9 == 3)
  {
LABEL_16:
    re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 3, 3);
    _os_crash();
    __break(1u);
    goto LABEL_17;
  }
  re::internal::getSRTFromRDV((re::internal *)(a3 + 864), &v34);
  if (v9 <= 4)
  {
LABEL_17:
    re::internal::assertLog((re::internal *)6, v14, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 4, 4);
    _os_crash();
    __break(1u);
    goto LABEL_18;
  }
  if (v9 == 5)
  {
LABEL_18:
    re::internal::assertLog((re::internal *)6, v14, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 5, 5);
    _os_crash();
    __break(1u);
    goto LABEL_19;
  }
  if (!a8)
  {
LABEL_19:
    re::internal::assertLog((re::internal *)6, v14, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, 0, 0);
    result = _os_crash();
    __break(1u);
    return result;
  }
  if (re::internal::enableSignposts(0, 0))
    kdebug_trace();
  _Q2 = (int32x4_t)v38;
  v16 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(_Q2, _Q2), (int8x16_t)_Q2, 0xCuLL);
  v17 = vnegq_f32(v38);
  v18 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v35, v35), (int8x16_t)v35, 0xCuLL), v17), (float32x4_t)v35, v16);
  _S7 = v35.i32[3];
  v20 = vmlaq_laneq_f32(vmlaq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v18, v18), (int8x16_t)v18, 0xCuLL), (float32x4_t)v35, v38, 3), v38, (float32x4_t)v35, 3);
  __asm { FMLA            S3, S7, V2.S[3] }
  v26 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v36, v36), (int8x16_t)v36, 0xCuLL), v17), (float32x4_t)v36, v16);
  v27 = (int32x4_t)vaddq_f32(v26, v26);
  v28 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v27, v27), (int8x16_t)v27, 0xCuLL);
  v29 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v28, (int32x4_t)v28), (int8x16_t)v28, 0xCuLL), v17), v28, v16);
  v20.i32[3] = _S3;
  v33[0] = vmulq_f32(v37, v34);
  v33[1] = v20;
  v33[2] = vaddq_f32(v39, vmulq_f32(v37, vaddq_f32(vaddq_f32((float32x4_t)v36, vmulq_laneq_f32(v28, v38, 3)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v29, v29), (int8x16_t)v29, 0xCuLL))));
  __asm { FMOV            V5.4S, #-1.0 }
  CoreIKFootPlacementSolverGetGenericSolver();
  CoreIKGenericSolverSetWorldToSolverTransform();
  re::RigDataValue::getRuntimeValue<float>(a3 + 1440, v31);
  CoreIKFootPlacementSolverSetBodyControllerParameters();
  re::internal::CoreIKFootPlacementSolverNodeHelper::updateRayCastTasks(a9, (re::RigDataValue *)(a3 + 288), v33);
  re::internal::CoreIKFootPlacementSolverNodeHelper::updateLookAtTasks((re::internal::CoreIKFootPlacementSolverNodeHelper *)a9->i64[0], (const re::RigDataValue *)(a3 + 1152));
  re::internal::transferPose((re::RigDataValue *)a3, (uint64_t)&a9[11].i64[1]);
  if (re::internal::enableSignposts(0, 0))
    kdebug_trace();
  return re::internal::CoreIKFootPlacementSolverNodeHelper::solveAndUpdate((re::internal::CoreIKFootPlacementSolverNodeHelper *)a9, (const re::RigDataValue *)a3, a7);
}

uint64_t re::internal::footPlacementSolverCompile(re::Allocator **a1, _QWORD *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v10;
  _anonymous_namespace_ *v11;
  const re::RigDataValue *v12;
  const re::RigDataValue *v13;
  uint64_t v14;
  uint64_t v15;
  size_t v16;
  uint64_t v17;
  uint64_t v18;
  re::Allocator *v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  StringID v24;
  _OWORD v25[2];
  int v26;
  _OWORD v27[2];
  int v28;
  uint64_t v29;
  _BYTE v30[288];
  _BYTE v31[296];
  uint64_t *v32;
  _QWORD v33[4];
  _BYTE v34[288];
  const char *v35[36];
  _QWORD v36[38];

  v36[37] = *MEMORY[0x24BDAC8D0];
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_10;
  }
  if (a3 == 1)
  {
LABEL_10:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    _os_crash();
    __break(1u);
    goto LABEL_11;
  }
  if (a3 <= 2)
  {
LABEL_11:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (a3 == 3)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 3, 3);
    _os_crash();
    __break(1u);
    goto LABEL_13;
  }
  v10 = a2[1];
  v11 = *(_anonymous_namespace_ **)(*a2 + 184);
  v12 = (const re::RigDataValue *)a2[2];
  v13 = (const re::RigDataValue *)a2[3];
  v35[0] = (const char *)0x51C691EF1C9C00D8;
  v35[1] = "IKLookAtTaskSettings[0]";
  re::internal::makeRigDataValue(a1, v35, (uint64_t)v36);
  re::StringID::destroyString((re::StringID *)v35);
  if (a3 == 5)
    re::RigDataValue::operator=(v36, a2[4]);
  if (!a5)
  {
LABEL_13:
    re::internal::assertLog((re::internal *)6, v14, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
  }
  v15 = *a4;
  v16 = strlen(*(const char **)(v10 + 232));
  v17 = MEMORY[0x22769136C](*(_QWORD *)(v10 + 232), v16);
  re::internal::makePoseFromRig(a1, v11, v17, (uint64_t)v35);
  v18 = MEMORY[0x2276916F0](v17);
  re::internal::makePose(a1, v18, (uint64_t)v34);
  v19 = *a1;
  v20 = *((_QWORD *)a1[2] + 7);
  v21 = (*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(_QWORD *)*a1 + 32))(*a1, 224, 16);
  v32 = (uint64_t *)re::internal::CoreIKFootPlacementSolverNodeHelper::CoreIKFootPlacementSolverNodeHelper(v21, (uint64_t)v19, v17, v20);
  v33[0] = &off_24ED24820;
  v33[3] = v33;
  v33[1] = v19;
  re::internal::makeModelSpacePoseForRayTracingJoints(a1, v11, *v32, (uint64_t)v31);
  v22 = re::RigHierarchy::jointName(v11, 0);
  re::internal::makeModelSpaceJointPoseRDV(a1, v11, *(const char **)(v22 + 8), (re::RigDataValue *)v30);
  v29 = 0;
  memset(v25, 0, sizeof(v25));
  v26 = 0;
  memset(v27, 0, sizeof(v27));
  v28 = 0;
  re::RigGraphCallbackBuilder::init((re::RigGraphCallbackBuilder *)v25, v19);
  *(_QWORD *)&v24.var0 = 0x76F1BA5D1EB6;
  v24.var1 = "InputPose";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v25, &v24, (const re::RigDataValue *)v35);
  re::StringID::destroyString((re::StringID *)&v24);
  *(_QWORD *)&v24.var0 = 0x10988E7944E83FE6;
  v24.var1 = "ModelSpaceRayCastTransforms";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v25, &v24, (const re::RigDataValue *)v31);
  re::StringID::destroyString((re::StringID *)&v24);
  *(_QWORD *)&v24.var0 = 0x1F85042B1B4E4034;
  v24.var1 = "WorldTransform";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v25, &v24, v13);
  re::StringID::destroyString((re::StringID *)&v24);
  *(_QWORD *)&v24.var0 = 0xF5F802EF32C90F2;
  v24.var1 = "SolverTransform";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v25, &v24, (const re::RigDataValue *)v30);
  re::StringID::destroyString((re::StringID *)&v24);
  *(_QWORD *)&v24.var0 = 0x1D028121B777EB8;
  v24.var1 = "LookAtTasks";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v25, &v24, (const re::RigDataValue *)v36);
  re::StringID::destroyString((re::StringID *)&v24);
  *(_QWORD *)&v24.var0 = 0x4DF90C13235A0886;
  v24.var1 = "HipOffsetMultiplier";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v25, &v24, v12);
  re::StringID::destroyString((re::StringID *)&v24);
  *(_QWORD *)&v24.var0 = 0x10498EC9357CACLL;
  v24.var1 = "SolvedPose";
  re::RigGraphCallbackBuilder::addOutputParam((re::RigGraphCallbackBuilder *)v25, &v24, (re::RigDataValue *)v34);
  re::StringID::destroyString((re::StringID *)&v24);
  re::RigGraphCallbackBuilder::buildCallbackData((unint64_t *)v25, (uint64_t)a1, (uint64_t)re::internal::footPlacementSolverCallback, (uint64_t *)&v32);
  re::internal::bindCallbackOutputToNodeOutputPose(v11, (re::RigDataValue *)v34, v17, (uint64_t)a1, v15);
  MEMORY[0x2276913A8](v17);
  re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)v27 + 8);
  re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)v25 + 8);
  re::RigDataValue::~RigDataValue((re::RigDataValue *)v30);
  re::RigDataValue::~RigDataValue((re::RigDataValue *)v31);
  std::unique_ptr<re::RigHierarchy,std::function<void ()(re::RigHierarchy*)>>::~unique_ptr[abi:nn180100]((uint64_t *)&v32);
  re::RigDataValue::~RigDataValue((re::RigDataValue *)v34);
  re::RigDataValue::~RigDataValue((re::RigDataValue *)v35);
  re::RigDataValue::~RigDataValue((re::RigDataValue *)v36);
  return 1;
}

uint64_t re::internal::footPlacementDebugSolverCallback(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, re::RigDataValue *a7, uint64_t a8, float32x4_t *a9)
{
  uint64_t v13;
  uint64_t v14;
  float32x4_t v16;
  float32x4_t v17;
  int32x4_t v18;
  float32x4_t v20;
  float32x4_t v26;
  int32x4_t v27;
  float32x4_t v28;
  int32x4_t v29;
  uint64_t v31;
  uint64_t v32;
  uint64_t GenericSolver;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t result;
  float32x4_t v40[3];
  float32x4_t v41;
  int32x4_t v42;
  int32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;

  if (re::internal::enableSignposts(0, 0))
    kdebug_trace();
  if (a4 <= 3)
  {
    re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 3, a4);
    _os_crash();
    __break(1u);
    goto LABEL_14;
  }
  re::internal::getSRTFromRDV((re::internal *)(a3 + 864), &v44);
  if (a4 == 4)
  {
LABEL_14:
    re::internal::assertLog((re::internal *)6, v14, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 4, 4);
    _os_crash();
    __break(1u);
    goto LABEL_15;
  }
  re::internal::getSRTFromRDV((re::internal *)(a3 + 1152), &v41);
  _Q2 = (int32x4_t)v45;
  v16 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(_Q2, _Q2), (int8x16_t)_Q2, 0xCuLL);
  v17 = vnegq_f32(v45);
  v18 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v42, v42), (int8x16_t)v42, 0xCuLL), v17), (float32x4_t)v42, v16);
  _S7 = v42.i32[3];
  v20 = vmlaq_laneq_f32(vmlaq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v18, v18), (int8x16_t)v18, 0xCuLL), (float32x4_t)v42, v45, 3), v45, (float32x4_t)v42, 3);
  __asm { FMLA            S3, S7, V2.S[3] }
  v26 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v43, v43), (int8x16_t)v43, 0xCuLL), v17), (float32x4_t)v43, v16);
  v27 = (int32x4_t)vaddq_f32(v26, v26);
  v28 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v27, v27), (int8x16_t)v27, 0xCuLL);
  v29 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v28, (int32x4_t)v28), (int8x16_t)v28, 0xCuLL), v17), v28, v16);
  v20.i32[3] = _S3;
  v40[0] = vmulq_f32(v44, v41);
  v40[1] = v20;
  v40[2] = vaddq_f32(v46, vmulq_f32(v44, vaddq_f32(vaddq_f32((float32x4_t)v43, vmulq_laneq_f32(v28, v45, 3)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v29, v29), (int8x16_t)v29, 0xCuLL))));
  __asm { FMOV            V5.4S, #-1.0 }
  CoreIKFootPlacementSolverGetGenericSolver();
  CoreIKGenericSolverSetWorldToSolverTransform();
  re::RigDataValue::getRuntimeValue<float>(a3 + 576, v31);
  CoreIKFootPlacementSolverSetBodyControllerParameters();
  re::internal::CoreIKFootPlacementSolverNodeHelper::updateRayCastTasks(a9, (re::RigDataValue *)(a3 + 288), v40);
  if (a4 <= 5)
  {
LABEL_15:
    re::internal::assertLog((re::internal *)6, v32, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 5, 5);
    _os_crash();
    __break(1u);
    goto LABEL_16;
  }
  re::internal::CoreIKFootPlacementSolverNodeHelper::updateLookAtTasks((re::internal::CoreIKFootPlacementSolverNodeHelper *)a9->i64[0], (const re::RigDataValue *)(a3 + 1440));
  GenericSolver = CoreIKFootPlacementSolverGetGenericSolver();
  if (a4 == 6)
  {
LABEL_16:
    re::internal::assertLog((re::internal *)6, v34, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 6, 6);
    _os_crash();
    __break(1u);
    goto LABEL_17;
  }
  v35 = GenericSolver;
  re::internal::GameRigSettingsUpdateHelper::updateRigJointSettings((re::RigDataValue *)(a3 + 1728));
  if (a4 <= 7)
  {
LABEL_17:
    re::internal::assertLog((re::internal *)6, v36, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 7, 7);
    _os_crash();
    __break(1u);
    goto LABEL_18;
  }
  re::internal::GameRigSettingsUpdateHelper::updateRigTaskSettings((re::RigDataValue *)(a3 + 2016), v35);
  if (a4 == 8)
  {
LABEL_18:
    re::internal::assertLog((re::internal *)6, v37, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 8, 8);
    _os_crash();
    __break(1u);
    goto LABEL_19;
  }
  re::internal::GameRigSettingsUpdateHelper::updateRigSolverSettings((re::RigDataValue *)(a3 + 2304), v35);
  re::internal::transferPose((re::RigDataValue *)a3, (uint64_t)&a9[11].i64[1]);
  if (re::internal::enableSignposts(0, 0))
    kdebug_trace();
  if (a8)
    return re::internal::CoreIKFootPlacementSolverNodeHelper::solveAndUpdate((re::internal::CoreIKFootPlacementSolverNodeHelper *)a9, (const re::RigDataValue *)a3, a7);
LABEL_19:
  re::internal::assertLog((re::internal *)6, v38, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, 0, 0);
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::internal::footPlacementSolverDebugCompile(re::Allocator **a1, uint64_t a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  _anonymous_namespace_ *v10;
  const char *v11;
  size_t v12;
  uint64_t v13;
  uint64_t v14;
  re::Allocator *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  StringID v27;
  _OWORD v28[2];
  int v29;
  _OWORD v30[2];
  int v31;
  uint64_t v32;
  _BYTE v33[288];
  _BYTE v34[296];
  uint64_t *v35;
  _QWORD v36[4];
  _BYTE v37[288];
  _BYTE v38[296];
  uint64_t v39;

  v39 = *MEMORY[0x24BDAC8D0];
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_14;
  }
  if (a3 == 1)
  {
LABEL_14:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    _os_crash();
    __break(1u);
    goto LABEL_15;
  }
  v10 = *(_anonymous_namespace_ **)(*(_QWORD *)a2 + 184);
  v11 = *(const char **)(*(_QWORD *)(a2 + 8) + 232);
  v12 = strlen(v11);
  v13 = MEMORY[0x22769136C](v11, v12);
  re::internal::makePoseFromRig(a1, v10, v13, (uint64_t)v38);
  v14 = MEMORY[0x2276916F0](v13);
  re::internal::makePose(a1, v14, (uint64_t)v37);
  v15 = *a1;
  v16 = *((_QWORD *)a1[2] + 7);
  v17 = (*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(_QWORD *)*a1 + 32))(*a1, 224, 16);
  v35 = (uint64_t *)re::internal::CoreIKFootPlacementSolverNodeHelper::CoreIKFootPlacementSolverNodeHelper(v17, (uint64_t)v15, v13, v16);
  v36[0] = &off_24ED24820;
  v36[3] = v36;
  v36[1] = v15;
  re::internal::makeModelSpacePoseForRayTracingJoints(a1, v10, *v35, (uint64_t)v34);
  v18 = re::RigHierarchy::jointName(v10, 0);
  re::internal::makeModelSpaceJointPoseRDV(a1, v10, *(const char **)(v18 + 8), (re::RigDataValue *)v33);
  v32 = 0;
  memset(v28, 0, sizeof(v28));
  v29 = 0;
  memset(v30, 0, sizeof(v30));
  v31 = 0;
  re::RigGraphCallbackBuilder::init((re::RigGraphCallbackBuilder *)v28, v15);
  *(_QWORD *)&v27.var0 = 0x76F1BA5D1EB6;
  v27.var1 = "InputPose";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v28, &v27, (const re::RigDataValue *)v38);
  re::StringID::destroyString((re::StringID *)&v27);
  *(_QWORD *)&v27.var0 = 0x10988E7944E83FE6;
  v27.var1 = "ModelSpaceRayCastTransforms";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v28, &v27, (const re::RigDataValue *)v34);
  re::StringID::destroyString((re::StringID *)&v27);
  *(_QWORD *)&v27.var0 = 0x4DF90C13235A0886;
  v27.var1 = "HipOffsetMultiplier";
  if (a3 <= 2)
  {
LABEL_15:
    re::internal::assertLog((re::internal *)6, v19, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 2, 2, *(_QWORD *)&v27.var0, v27.var1);
    _os_crash();
    __break(1u);
    goto LABEL_16;
  }
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v28, &v27, *(const re::RigDataValue **)(a2 + 16));
  re::StringID::destroyString((re::StringID *)&v27);
  *(_QWORD *)&v27.var0 = 0x1F85042B1B4E4034;
  v27.var1 = "WorldTransform";
  if (a3 == 3)
  {
LABEL_16:
    re::internal::assertLog((re::internal *)6, v20, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 3, 3, *(_QWORD *)&v27.var0, v27.var1);
    _os_crash();
    __break(1u);
    goto LABEL_17;
  }
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v28, &v27, *(const re::RigDataValue **)(a2 + 24));
  re::StringID::destroyString((re::StringID *)&v27);
  *(_QWORD *)&v27.var0 = 0xF5F802EF32C90F2;
  v27.var1 = "SolverTransform";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v28, &v27, (const re::RigDataValue *)v33);
  re::StringID::destroyString((re::StringID *)&v27);
  *(_QWORD *)&v27.var0 = 0x80FA33623D02F274;
  v27.var1 = "LookAtTaskSettings";
  if (a3 <= 4)
  {
LABEL_17:
    re::internal::assertLog((re::internal *)6, v21, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 4, 4, *(_QWORD *)&v27.var0, v27.var1);
    _os_crash();
    __break(1u);
    goto LABEL_18;
  }
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v28, &v27, *(const re::RigDataValue **)(a2 + 32));
  re::StringID::destroyString((re::StringID *)&v27);
  *(_QWORD *)&v27.var0 = 0x608B8AAFAB2B677ALL;
  v27.var1 = "RigJointSettings";
  if (a3 == 5)
  {
LABEL_18:
    re::internal::assertLog((re::internal *)6, v22, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 5, 5, *(_QWORD *)&v27.var0, v27.var1);
    _os_crash();
    __break(1u);
    goto LABEL_19;
  }
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v28, &v27, *(const re::RigDataValue **)(a2 + 40));
  re::StringID::destroyString((re::StringID *)&v27);
  *(_QWORD *)&v27.var0 = 0x963E12F0C5BD5BB0;
  v27.var1 = "RigTaskSettings";
  if (a3 <= 6)
  {
LABEL_19:
    re::internal::assertLog((re::internal *)6, v23, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 6, 6, *(_QWORD *)&v27.var0, v27.var1);
    _os_crash();
    __break(1u);
    goto LABEL_20;
  }
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v28, &v27, *(const re::RigDataValue **)(a2 + 48));
  re::StringID::destroyString((re::StringID *)&v27);
  *(_QWORD *)&v27.var0 = 0x86B1473B92D2CCCCLL;
  v27.var1 = "RigSolverSettings";
  if (a3 == 7)
  {
LABEL_20:
    re::internal::assertLog((re::internal *)6, v24, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 7, 7, *(_QWORD *)&v27.var0, v27.var1);
    _os_crash();
    __break(1u);
LABEL_21:
    re::internal::assertLog((re::internal *)6, v25, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
  }
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v28, &v27, *(const re::RigDataValue **)(a2 + 56));
  re::StringID::destroyString((re::StringID *)&v27);
  *(_QWORD *)&v27.var0 = 0x10498EC9357CACLL;
  v27.var1 = "SolvedPose";
  re::RigGraphCallbackBuilder::addOutputParam((re::RigGraphCallbackBuilder *)v28, &v27, (re::RigDataValue *)v37);
  re::StringID::destroyString((re::StringID *)&v27);
  re::RigGraphCallbackBuilder::buildCallbackData((unint64_t *)v28, (uint64_t)a1, (uint64_t)re::internal::footPlacementDebugSolverCallback, (uint64_t *)&v35);
  if (!a5)
    goto LABEL_21;
  re::internal::bindCallbackOutputToNodeOutputPose(v10, (re::RigDataValue *)v37, v13, (uint64_t)a1, *a4);
  if (v13)
    MEMORY[0x2276913A8](v13);
  re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)v30 + 8);
  re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)v28 + 8);
  re::RigDataValue::~RigDataValue((re::RigDataValue *)v33);
  re::RigDataValue::~RigDataValue((re::RigDataValue *)v34);
  std::unique_ptr<re::RigHierarchy,std::function<void ()(re::RigHierarchy*)>>::~unique_ptr[abi:nn180100]((uint64_t *)&v35);
  re::RigDataValue::~RigDataValue((re::RigDataValue *)v37);
  re::RigDataValue::~RigDataValue((re::RigDataValue *)v38);
  return 1;
}

void re::internal::registerFootPlacementSolverNoLookAtNode(re::internal *this, re::RigEnvironment *a2)
{
  uint64_t v3[2];
  unint64_t v4[2];
  _OWORD v5[3];
  uint64_t v6;
  _OWORD v7[5];
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v6 = 0;
  v4[0] = 0;
  memset(v5, 0, sizeof(v5));
  v4[1] = (unint64_t)&str_110;
  v3[0] = 0;
  v3[1] = (uint64_t)&str_110;
  v7[2] = xmmword_24ED246F0;
  v7[3] = *(_OWORD *)&off_24ED24700;
  v7[4] = xmmword_24ED24710;
  v7[0] = constinit_7;
  v7[1] = *(_OWORD *)&off_24ED246E0;
  re::RigGraphOperatorDefinition::init(v4, (uint64_t *)this, v3, 4uLL, 1uLL, (unint64_t)re::internal::footPlacementSolverCompile, (const char **)v7);
  re::StringID::destroyString((re::StringID *)v3);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v5[1] + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(v5);
  re::StringID::destroyString((re::StringID *)v4);
}

void re::internal::registerFootPlacementSolverNode(re::internal *this, re::RigEnvironment *a2)
{
  uint64_t v3[2];
  unint64_t v4[2];
  _OWORD v5[3];
  uint64_t v6;
  _OWORD v7[6];
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v6 = 0;
  v4[0] = 0;
  memset(v5, 0, sizeof(v5));
  v4[1] = (unint64_t)&str_110;
  v3[0] = 0;
  v3[1] = (uint64_t)&str_110;
  v7[2] = xmmword_24ED24740;
  v7[3] = *(_OWORD *)&off_24ED24750;
  v7[4] = xmmword_24ED24760;
  v7[5] = *(_OWORD *)&off_24ED24770;
  v7[0] = constinit_25;
  v7[1] = *(_OWORD *)&off_24ED24730;
  re::RigGraphOperatorDefinition::init(v4, (uint64_t *)this, v3, 5uLL, 1uLL, (unint64_t)re::internal::footPlacementSolverCompile, (const char **)v7);
  re::StringID::destroyString((re::StringID *)v3);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v5[1] + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(v5);
  re::StringID::destroyString((re::StringID *)v4);
}

void re::internal::registerFootPlacementSolverDebugNode(re::internal *this, re::RigEnvironment *a2)
{
  uint64_t v3[2];
  unint64_t v4[2];
  _OWORD v5[3];
  uint64_t v6;
  _OWORD v7[9];
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v6 = 0;
  v4[0] = 0;
  memset(v5, 0, sizeof(v5));
  v4[1] = (unint64_t)&str_110;
  v3[0] = 0;
  v3[1] = (uint64_t)&str_110;
  v7[6] = xmmword_24ED247E0;
  v7[7] = *(_OWORD *)&off_24ED247F0;
  v7[8] = xmmword_24ED24800;
  v7[2] = xmmword_24ED247A0;
  v7[3] = *(_OWORD *)&off_24ED247B0;
  v7[4] = xmmword_24ED247C0;
  v7[5] = *(_OWORD *)&off_24ED247D0;
  v7[0] = constinit_33;
  v7[1] = *(_OWORD *)&off_24ED24790;
  re::RigGraphOperatorDefinition::init(v4, (uint64_t *)this, v3, 8uLL, 1uLL, (unint64_t)re::internal::footPlacementSolverDebugCompile, (const char **)v7);
  re::StringID::destroyString((re::StringID *)v3);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v5[1] + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(v5);
  re::StringID::destroyString((re::StringID *)v4);
}

void _ZNSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_35CoreIKFootPlacementSolverNodeHelperENS2_9AllocatorEJP9CoreIKRigNS_17reference_wrapperIKNS2_14CollisionWorldEEEEEEDaPT0_DpT1_EUlPvE_NS_9allocatorISJ_EEFvSI_EED0Ev()
{
  JUMPOUT(0x2276933B8);
}

_QWORD *_ZNKSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_35CoreIKFootPlacementSolverNodeHelperENS2_9AllocatorEJP9CoreIKRigNS_17reference_wrapperIKNS2_14CollisionWorldEEEEEEDaPT0_DpT1_EUlPvE_NS_9allocatorISJ_EEFvSI_EE7__cloneEv(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24ED24820;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_35CoreIKFootPlacementSolverNodeHelperENS2_9AllocatorEJP9CoreIKRigNS_17reference_wrapperIKNS2_14CollisionWorldEEEEEEDaPT0_DpT1_EUlPvE_NS_9allocatorISJ_EEFvSI_EE7__cloneEPNS0_6__baseISM_EE(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24ED24820;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_35CoreIKFootPlacementSolverNodeHelperENS2_9AllocatorEJP9CoreIKRigNS_17reference_wrapperIKNS2_14CollisionWorldEEEEEEDaPT0_DpT1_EUlPvE_NS_9allocatorISJ_EEFvSI_EEclEOSI_(uint64_t result, _QWORD *a2)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;

  v2 = (_QWORD *)*a2;
  if (*a2)
  {
    v3 = *(_QWORD *)(result + 8);
    CoreIKFootPlacementSolverDestroy();
    v4 = v2[23];
    if (v4)
    {
      if (v2[24])
      {
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, v2[25]);
        v2[24] = 0;
        v2[25] = 0;
      }
      v2[23] = 0;
    }
    re::BucketArray<re::CollisionCastHit,10ul>::deinit((uint64_t)(v2 + 14));
    re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)(v2 + 14));
    return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v3 + 40))(v3, v2);
  }
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_35CoreIKFootPlacementSolverNodeHelperENS2_9AllocatorEJP9CoreIKRigNS_17reference_wrapperIKNS2_14CollisionWorldEEEEEEDaPT0_DpT1_EUlPvE_NS_9allocatorISJ_EEFvSI_EE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:nn180100](a2, (uint64_t)&_ZTIZN2re8internal14makeNodeUniqueINS0_35CoreIKFootPlacementSolverNodeHelperENS_9AllocatorEJP9CoreIKRigNSt3__117reference_wrapperIKNS_14CollisionWorldEEEEEEDaPT0_DpT1_EUlPvE_))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *_ZNKSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_35CoreIKFootPlacementSolverNodeHelperENS2_9AllocatorEJP9CoreIKRigNS_17reference_wrapperIKNS2_14CollisionWorldEEEEEEDaPT0_DpT1_EUlPvE_NS_9allocatorISJ_EEFvSI_EE11target_typeEv()
{
  return &_ZTIZN2re8internal14makeNodeUniqueINS0_35CoreIKFootPlacementSolverNodeHelperENS_9AllocatorEJP9CoreIKRigNSt3__117reference_wrapperIKNS_14CollisionWorldEEEEEEDaPT0_DpT1_EUlPvE_;
}

uint64_t re::internal::feetSlidingSolverCallback(uint64_t a1, uint64_t a2, re::RigDataValue *a3, uint64_t a4, uint64_t a5, uint64_t a6, re::RigDataValue *a7, uint64_t a8, uint64_t a9)
{
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t result;

  if (re::internal::enableSignposts(0, 0))
    kdebug_trace();
  if (!a4)
  {
    re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_17:
    re::internal::assertLog((re::internal *)6, v14, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, 0, 0);
    result = _os_crash();
    __break(1u);
    return result;
  }
  re::internal::transferPose(a3, a9 + 16);
  if (re::internal::enableSignposts(0, 0))
    kdebug_trace();
  if (!a8)
    goto LABEL_17;
  if (re::internal::enableSignposts(0, 0))
    kdebug_trace();
  v15 = MEMORY[0x227691300](*(_QWORD *)a9, *(_QWORD *)(a9 + 32), *(_QWORD *)(a9 + 24));
  if (re::internal::enableSignposts(0, 0))
    kdebug_trace();
  if (re::internal::enableSignposts(0, 0))
    kdebug_trace();
  re::internal::updateOutputBasedOnSolveResult(v15, (uint64_t)a3, (_OWORD *)(a9 + 16), a7);
  result = re::internal::enableSignposts(0, 0);
  if ((_DWORD)result)
    return kdebug_trace();
  return result;
}

uint64_t re::internal::feetSlidingSolverCompile(re::Allocator **a1, _QWORD *a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  size_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  unint64_t v13;
  _anonymous_namespace_ *v14;
  uint64_t v15;
  StringID v17;
  _OWORD v18[2];
  int v19;
  _OWORD v20[2];
  int v21;
  uint64_t v22;
  _BYTE v23[288];
  _BYTE v24[288];
  uint64_t *v25;
  _QWORD v26[5];

  v26[4] = *MEMORY[0x24BDAC8D0];
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_6;
  }
  if (a3 == 1)
  {
LABEL_6:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 1, 1);
    _os_crash();
    __break(1u);
LABEL_7:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
  }
  if (!a5)
    goto LABEL_7;
  v6 = a2[1];
  v7 = *a4;
  v8 = *(const char **)(*a2 + 232);
  v9 = strlen(v8);
  v10 = MEMORY[0x22769136C](v8, v9);
  v11 = (uint64_t)*a1;
  v12 = (uint64_t *)(*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(_QWORD *)*a1 + 32))(*a1, 40, 8);
  *v12 = CoreIKCreateACPSlidingSolverFromRig();
  v12[1] = v11;
  v12[3] = 0;
  v12[4] = 0;
  v12[2] = 0;
  v13 = MEMORY[0x2276916F0](v10);
  re::FixedArray<CoreIKTransform>::init<>(v12 + 2, v11, v13);
  v25 = v12;
  v26[0] = &off_24ED248D0;
  v26[3] = v26;
  v26[1] = v11;
  v14 = *(_anonymous_namespace_ **)(v6 + 184);
  re::internal::makePoseFromRig(a1, v14, v10, (uint64_t)v24);
  v15 = MEMORY[0x2276916F0](v10);
  re::internal::makePose(a1, v15, (uint64_t)v23);
  v22 = 0;
  memset(v18, 0, sizeof(v18));
  v19 = 0;
  memset(v20, 0, sizeof(v20));
  v21 = 0;
  re::RigGraphCallbackBuilder::init((re::RigGraphCallbackBuilder *)v18, *a1);
  *(_QWORD *)&v17.var0 = 0x10643527A253C4;
  v17.var1 = "TargetPose";
  re::RigGraphCallbackBuilder::addInputParam((re::RigGraphCallbackBuilder *)v18, &v17, (const re::RigDataValue *)v24);
  re::StringID::destroyString((re::StringID *)&v17);
  *(_QWORD *)&v17.var0 = 0x10498EC9357CACLL;
  v17.var1 = "SolvedPose";
  re::RigGraphCallbackBuilder::addOutputParam((re::RigGraphCallbackBuilder *)v18, &v17, (re::RigDataValue *)v23);
  re::StringID::destroyString((re::StringID *)&v17);
  re::RigGraphCallbackBuilder::buildCallbackData((unint64_t *)v18, (uint64_t)a1, (uint64_t)re::internal::feetSlidingSolverCallback, (uint64_t *)&v25);
  re::internal::bindCallbackOutputToNodeOutputPose(v14, (re::RigDataValue *)v23, v10, (uint64_t)a1, v7);
  MEMORY[0x2276913A8](v10);
  re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)v20 + 8);
  re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)v18 + 8);
  re::RigDataValue::~RigDataValue((re::RigDataValue *)v23);
  re::RigDataValue::~RigDataValue((re::RigDataValue *)v24);
  std::unique_ptr<re::RigHierarchy,std::function<void ()(re::RigHierarchy*)>>::~unique_ptr[abi:nn180100]((uint64_t *)&v25);
  return 1;
}

void re::internal::registerFeetSlidingSolverNode(re::internal *this, re::RigEnvironment *a2)
{
  uint64_t v3[2];
  unint64_t v4[2];
  _OWORD v5[3];
  uint64_t v6;
  _OWORD v7[3];
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v6 = 0;
  v4[0] = 0;
  memset(v5, 0, sizeof(v5));
  v4[1] = (unint64_t)&str_110;
  v3[0] = 0;
  v3[1] = (uint64_t)&str_110;
  v7[0] = constinit_8;
  v7[1] = *(_OWORD *)&off_24ED248A0;
  v7[2] = xmmword_24ED248B0;
  re::RigGraphOperatorDefinition::init(v4, (uint64_t *)this, v3, 2uLL, 1uLL, (unint64_t)re::internal::feetSlidingSolverCompile, (const char **)v7);
  re::StringID::destroyString((re::StringID *)v3);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit((_QWORD *)&v5[1] + 1);
  re::FixedArray<re::RigGraphOperatorParameterDefinition>::deinit(v5);
  re::StringID::destroyString((re::StringID *)v4);
}

void _ZNSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_32CoreIKACPSlidingSolverNodeHelperENS2_9AllocatorEJP9CoreIKRigEEEDaPT0_DpT1_EUlPvE_NS_9allocatorISF_EEFvSE_EED0Ev()
{
  JUMPOUT(0x2276933B8);
}

_QWORD *_ZNKSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_32CoreIKACPSlidingSolverNodeHelperENS2_9AllocatorEJP9CoreIKRigEEEDaPT0_DpT1_EUlPvE_NS_9allocatorISF_EEFvSE_EE7__cloneEv(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24ED248D0;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_32CoreIKACPSlidingSolverNodeHelperENS2_9AllocatorEJP9CoreIKRigEEEDaPT0_DpT1_EUlPvE_NS_9allocatorISF_EEFvSE_EE7__cloneEPNS0_6__baseISI_EE(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24ED248D0;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_32CoreIKACPSlidingSolverNodeHelperENS2_9AllocatorEJP9CoreIKRigEEEDaPT0_DpT1_EUlPvE_NS_9allocatorISF_EEFvSE_EEclEOSE_(uint64_t result, _QWORD *a2)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;

  v2 = (_QWORD *)*a2;
  if (*a2)
  {
    v3 = *(_QWORD *)(result + 8);
    CoreIKDestroyACPSlidingSolver();
    v4 = v2[2];
    if (v4)
    {
      if (v2[3])
      {
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, v2[4]);
        v2[3] = 0;
        v2[4] = 0;
      }
      v2[2] = 0;
    }
    return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v3 + 40))(v3, v2);
  }
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_32CoreIKACPSlidingSolverNodeHelperENS2_9AllocatorEJP9CoreIKRigEEEDaPT0_DpT1_EUlPvE_NS_9allocatorISF_EEFvSE_EE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:nn180100](a2, (uint64_t)&_ZTIZN2re8internal14makeNodeUniqueINS0_32CoreIKACPSlidingSolverNodeHelperENS_9AllocatorEJP9CoreIKRigEEEDaPT0_DpT1_EUlPvE_))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *_ZNKSt3__110__function6__funcIZN2re8internal14makeNodeUniqueINS3_32CoreIKACPSlidingSolverNodeHelperENS2_9AllocatorEJP9CoreIKRigEEEDaPT0_DpT1_EUlPvE_NS_9allocatorISF_EEFvSE_EE11target_typeEv()
{
  return &_ZTIZN2re8internal14makeNodeUniqueINS0_32CoreIKACPSlidingSolverNodeHelperENS_9AllocatorEJP9CoreIKRigEEEDaPT0_DpT1_EUlPvE_;
}

uint64_t re::AnimationController::indexOf(uint64_t this, const re::Timeline *a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  char v10;

  v3 = this;
  if (*(_QWORD *)a2
    && (this = re::DataArray<re::internal::TimelineTree>::tryGet(*(_QWORD *)a2 + (*((uint64_t *)a2 + 1) >> 56 << 6) + 72, *((_QWORD *)a2 + 1))) != 0)
  {
    if (a3)
    {
      v6 = *(_QWORD *)(this + 128);
      v5 = *(_QWORD *)(this + 136);
      if (v6)
      {
        v7 = 8 * v6;
        v8 = *(_QWORD **)(this + 136);
        while (*v8 != a3)
        {
          ++v8;
          v7 -= 8;
          if (!v7)
          {
            v8 = (_QWORD *)(v5 + 8 * v6);
            break;
          }
        }
      }
      else
      {
        v8 = *(_QWORD **)(this + 136);
      }
      v9 = ((uint64_t)v8 - v5) >> 3;
      if (v9 == v6)
      {
        v10 = 0;
      }
      else
      {
        *(_QWORD *)(v3 + 8) = v9;
        v10 = 1;
      }
      *(_BYTE *)v3 = v10;
    }
    else
    {
      *(_BYTE *)v3 = 1;
      *(_QWORD *)(v3 + 8) = 0;
    }
  }
  else
  {
    *(_BYTE *)v3 = 0;
  }
  return this;
}

void re::AnimationController::pause(re::AnimationController *this)
{
  re::internal::TimelineTree *v1;

  if (*(_QWORD *)this)
  {
    v1 = (re::internal::TimelineTree *)re::DataArray<re::internal::TimelineTree>::tryGet(*(_QWORD *)this + (*((uint64_t *)this + 1) >> 56 << 6) + 72, *((_QWORD *)this + 1));
    if (v1)
      re::internal::TimelineTree::setPaused(v1, 1);
  }
}

void re::AnimationController::resume(re::AnimationController *this)
{
  re::internal::TimelineTree *v1;

  if (*(_QWORD *)this)
  {
    v1 = (re::internal::TimelineTree *)re::DataArray<re::internal::TimelineTree>::tryGet(*(_QWORD *)this + (*((uint64_t *)this + 1) >> 56 << 6) + 72, *((_QWORD *)this + 1));
    if (v1)
      re::internal::TimelineTree::setPaused(v1, 0);
  }
}

double re::AnimationController::stop(re::AnimationController *this, double result)
{
  float v2;
  uint64_t v4;
  re::internal::TimelineTree *v5;
  re::AnimationManager *v6;
  int v7;
  char v8;
  char v9;
  int v10;
  float v11;

  if (*(_QWORD *)this)
  {
    v2 = *(float *)&result;
    v4 = re::DataArray<re::internal::TimelineTree>::tryGet(*(_QWORD *)this + (*((uint64_t *)this + 1) >> 56 << 6) + 72, *((_QWORD *)this + 1));
    if (v4)
    {
      v5 = (re::internal::TimelineTree *)v4;
      v6 = *(re::AnimationManager **)this;
      if (v2 <= 0.0)
      {
        return re::AnimationManager::remove(v6, v5, 1);
      }
      else
      {
        v7 = 3;
        v8 = 0;
        v9 = 1;
        v10 = 0;
        v11 = v2;
        re::AnimationManager::addFadeOutHandoffBehavior(v6, (uint64_t)v5, (uint64_t)&v7);
      }
    }
  }
  return result;
}

void re::AnimationController::updateAndApply(re::AnimationController *this)
{
  re::internal::TimelineTree *v2;

  if (*(_QWORD *)this)
  {
    v2 = (re::internal::TimelineTree *)re::DataArray<re::internal::TimelineTree>::tryGet(*(_QWORD *)this + (*((uint64_t *)this + 1) >> 56 << 6) + 72, *((_QWORD *)this + 1));
    if (v2)
      re::AnimationManager::updateAndApplyAnimations(*(re::AnimationManager **)this, v2);
  }
}

uint64_t re::AnimationController::isPaused(re::AnimationController *this)
{
  uint64_t result;
  uint64_t v2;

  if (!*(_QWORD *)this)
    return 0;
  result = re::DataArray<re::internal::TimelineTree>::tryGet(*(_QWORD *)this + (*((uint64_t *)this + 1) >> 56 << 6) + 72, *((_QWORD *)this + 1));
  if (result)
  {
    do
    {
      v2 = result;
      result = *(_QWORD *)(result + 200);
    }
    while (result);
    return *(unsigned __int8 *)(v2 + 185) == 1;
  }
  return result;
}

_QWORD *re::AnimationController::setParentClockOrTimebase(_QWORD *this, void *a2)
{
  _QWORD *v3;
  void *v4;

  if (*this)
  {
    v3 = this;
    this = (_QWORD *)re::DataArray<re::internal::TimelineTree>::tryGet(*this + ((uint64_t)this[1] >> 56 << 6) + 72, this[1]);
    if (this)
    {
      if (a2)
        v4 = a2;
      else
        v4 = *(void **)(*v3 + 64);
      return (_QWORD *)re::internal::TimelineTree::setParentClockOrTimebase((uint64_t)this, v4);
    }
  }
  return this;
}

uint64_t re::internal::TimelineTree::setParentClockOrTimebase(uint64_t this, void *cf)
{
  uint64_t v3;
  CFTypeID v4;
  CFTypeID TypeID;
  OpaqueCMTimebase *v6;

  if (!*(_QWORD *)(this + 200))
  {
    v3 = this;
    v4 = CFGetTypeID(cf);
    TypeID = CMClockGetTypeID();
    v6 = *(OpaqueCMTimebase **)(v3 + 192);
    if (v4 == TypeID)
      return CMTimebaseSetSourceClock(v6, (CMClockRef)cf);
    else
      return CMTimebaseSetSourceTimebase(v6, (CMTimebaseRef)cf);
  }
  return this;
}

_QWORD *re::AnimationController::timebase@<X0>(_QWORD *this@<X0>, uint64_t a2@<X8>)
{
  _QWORD *v3;

  if (*this
    && (this = (_QWORD *)re::DataArray<re::internal::TimelineTree>::tryGet(*this + ((uint64_t)this[1] >> 56 << 6) + 72, this[1])) != 0)
  {
    do
    {
      v3 = this;
      this = (_QWORD *)this[25];
    }
    while (this);
    *(_BYTE *)a2 = 1;
    *(_QWORD *)(a2 + 8) = v3[24];
  }
  else
  {
    *(_BYTE *)a2 = 0;
  }
  return this;
}

float re::AnimationController::speed(re::AnimationController *this)
{
  uint64_t v1;
  uint64_t v2;

  if (!*(_QWORD *)this)
    return NAN;
  v1 = re::DataArray<re::internal::TimelineTree>::tryGet(*(_QWORD *)this + (*((uint64_t *)this + 1) >> 56 << 6) + 72, *((_QWORD *)this + 1));
  if (!v1)
    return NAN;
  do
  {
    v2 = v1;
    v1 = *(_QWORD *)(v1 + 200);
  }
  while (v1);
  return *(float *)(v2 + 188);
}

uint64_t re::AnimationController::setSpeed(uint64_t this, float a2)
{
  if (*(_QWORD *)this)
  {
    this = re::DataArray<re::internal::TimelineTree>::tryGet(*(_QWORD *)this + (*(uint64_t *)(this + 8) >> 56 << 6) + 72, *(_QWORD *)(this + 8));
    if (this)
    {
      if (!*(_QWORD *)(this + 200))
      {
        *(float *)(this + 188) = a2;
        if (!*(_BYTE *)(this + 185))
          return CMTimebaseSetRate(*(CMTimebaseRef *)(this + 192), a2);
      }
    }
  }
  return this;
}

uint64_t re::AnimationController::timeline(re::AnimationController *this)
{
  uint64_t result;

  if (!*(_QWORD *)this)
    return 0;
  result = re::DataArray<re::internal::TimelineTree>::tryGet(*(_QWORD *)this + (*((uint64_t *)this + 1) >> 56 << 6) + 72, *((_QWORD *)this + 1));
  if (result)
  {
    if (!*(_QWORD *)(result + 128))
    {
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    return **(_QWORD **)(result + 136);
  }
  return result;
}

uint64_t re::AnimationController::clock@<X0>(re::AnimationController *this@<X0>, const re::Timeline *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t result;
  int v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  _BYTE v13[8];
  unint64_t v14;
  uint64_t v15;
  int v16;
  const char *v17;
  __int16 v18;
  int v19;
  __int16 v20;
  unint64_t v21;
  __int16 v22;
  unint64_t v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  result = re::AnimationController::indexOf((uint64_t)v13, this, (uint64_t)a2);
  if (v13[0])
  {
    if (*(_QWORD *)this)
      result = re::DataArray<re::internal::TimelineTree>::tryGet(*(_QWORD *)this + (*((uint64_t *)this + 1) >> 56 << 6) + 72, *((_QWORD *)this + 1));
    else
      result = 0;
    v7 = v14;
    v8 = *(_QWORD *)(result + 56);
    if (v8 <= v14)
    {
      v15 = 0;
      v27 = 0u;
      v28 = 0u;
      v25 = 0u;
      v26 = 0u;
      v24 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v16 = 136315906;
      v17 = "operator[]";
      v18 = 1024;
      v19 = 468;
      v20 = 2048;
      v21 = v7;
      v22 = 2048;
      v23 = v8;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    v9 = *(_QWORD *)(result + 64);
    v10 = v9 + 72 * v14;
    *(_OWORD *)a3 = *(_OWORD *)v10;
    LODWORD(v10) = *(unsigned __int8 *)(v10 + 16);
    *(_BYTE *)(a3 + 16) = v10;
    if ((_DWORD)v10)
      *(_QWORD *)(a3 + 24) = *(_QWORD *)(v9 + 72 * v7 + 24);
    v11 = v9 + 72 * v7;
    v12 = *(_OWORD *)(v11 + 48);
    *(_OWORD *)(a3 + 32) = *(_OWORD *)(v11 + 32);
    *(_OWORD *)(a3 + 48) = v12;
    v6 = *(_DWORD *)(v11 + 64);
  }
  else
  {
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)(a3 + 48) = 0u;
    *(_QWORD *)(a3 + 64) = 0;
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_BYTE *)a3 = 1;
    *(_DWORD *)(a3 + 60) = 0;
    *(_QWORD *)(a3 + 36) = 0;
    *(_QWORD *)(a3 + 44) = 0;
    *(_QWORD *)(a3 + 49) = 0;
    v6 = 2;
  }
  *(_DWORD *)(a3 + 64) = v6;
  return result;
}

void re::AnimationController::time(re::AnimationController *this@<X0>, uint64_t a2@<X8>)
{
  re::internal::TimelineTree *v3;
  Float64 v4;

  if (*(_QWORD *)this
    && (v3 = (re::internal::TimelineTree *)re::DataArray<re::internal::TimelineTree>::tryGet(*(_QWORD *)this + (*((uint64_t *)this + 1) >> 56 << 6) + 72, *((_QWORD *)this + 1))) != 0)
  {
    v4 = re::internal::TimelineTree::currentTime(v3);
    *(_BYTE *)a2 = 1;
    *(Float64 *)(a2 + 8) = v4;
  }
  else
  {
    *(_BYTE *)a2 = 0;
  }
}

_QWORD *re::AnimationController::setTime(_QWORD *this, double a2)
{
  if (*this)
  {
    this = (_QWORD *)re::DataArray<re::internal::TimelineTree>::tryGet(*this + ((uint64_t)this[1] >> 56 << 6) + 72, this[1]);
    if (this)
      return (_QWORD *)re::internal::TimelineTree::setCurrentTime((uint64_t)this, a2);
  }
  return this;
}

uint64_t re::internal::TimelineTree::setCurrentTime(uint64_t this, double a2)
{
  OpaqueCMTimebase *v2;
  CMTime time;

  if (!*(_QWORD *)(this + 200))
  {
    v2 = *(OpaqueCMTimebase **)(this + 192);
    CMTimeMake(&time, (unint64_t)(a2 * 18000.0 + 0.5), 18000);
    return CMTimebaseSetTime(v2, &time);
  }
  return this;
}

float re::AnimationController::blendFactor(re::AnimationController *this, const re::Timeline *a2)
{
  uint64_t v3;
  unint64_t v5;
  unint64_t v6;
  unsigned __int8 *v7;
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  int v10;
  _BYTE v11[8];
  unint64_t v12;
  uint64_t v13;
  int v14;
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  unint64_t v19;
  __int16 v20;
  unint64_t v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  re::AnimationController::indexOf((uint64_t)v11, this, (uint64_t)a2);
  if (!v11[0])
    return NAN;
  if (*(_QWORD *)this)
    v3 = re::DataArray<re::internal::TimelineTree>::tryGet(*(_QWORD *)this + (*((uint64_t *)this + 1) >> 56 << 6) + 72, *((_QWORD *)this + 1));
  else
    v3 = 0;
  v5 = v12;
  v6 = *(_QWORD *)(v3 + 80);
  if (v6 <= v12)
  {
    v13 = 0;
    v25 = 0u;
    v26 = 0u;
    v23 = 0u;
    v24 = 0u;
    v22 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v14 = 136315906;
    v15 = "operator[]";
    v16 = 1024;
    v17 = 468;
    v18 = 2048;
    v19 = v5;
    v20 = 2048;
    v21 = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  v7 = (unsigned __int8 *)(*(_QWORD *)(v3 + 88) + 12 * v12);
  v8 = v7 + 8;
  v10 = *v7;
  v9 = v7 + 4;
  if (v10)
    v9 = v8;
  return *(float *)v9;
}

uint64_t re::AnimationController::setBlendFactor(re::AnimationController *this, float a2, const re::Timeline *a3)
{
  uint64_t result;
  unint64_t v6;
  unint64_t v7;
  _BYTE v8[8];
  unint64_t v9;
  uint64_t v10;
  int v11;
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  unint64_t v16;
  __int16 v17;
  unint64_t v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  result = re::AnimationController::indexOf((uint64_t)v8, this, (uint64_t)a3);
  if (v8[0])
  {
    if (*(_QWORD *)this)
      result = re::DataArray<re::internal::TimelineTree>::tryGet(*(_QWORD *)this + (*((uint64_t *)this + 1) >> 56 << 6) + 72, *((_QWORD *)this + 1));
    else
      result = 0;
    v6 = v9;
    v7 = *(_QWORD *)(result + 80);
    if (v7 <= v9)
    {
      v10 = 0;
      v22 = 0u;
      v23 = 0u;
      v20 = 0u;
      v21 = 0u;
      v19 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v11 = 136315906;
      v12 = "operator[]";
      v13 = 1024;
      v14 = 468;
      v15 = 2048;
      v16 = v6;
      v17 = 2048;
      v18 = v7;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    *(float *)(*(_QWORD *)(result + 88) + 12 * v9 + 4) = a2;
  }
  return result;
}

uint64_t re::AnimationController::userData(re::AnimationController *this)
{
  uint64_t result;

  if (!*(_QWORD *)this)
    return 0;
  result = re::DataArray<re::internal::TimelineTree>::tryGet(*(_QWORD *)this + (*((uint64_t *)this + 1) >> 56 << 6) + 72, *((_QWORD *)this + 1));
  if (result)
    return *(_QWORD *)(result + 168);
  return result;
}

_BYTE *re::RigDataTypeClass::rigDataTypeParser@<X0>(unint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  char *v6;
  size_t v7;
  size_t v8;
  char *v9;
  size_t v10;
  const char *v11;
  size_t v12;
  char *v13;
  unint64_t v14;
  char *v15;
  uint64_t v16;
  char *v17;
  size_t v18;
  char *v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  char *v24;
  char *v25;
  char *v26;
  char *v27;
  char *v28;
  unint64_t v29;
  char *v30;
  uint64_t v31;
  char *v32;
  size_t v33;
  char *v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  unint64_t v39;
  char *v40;
  uint64_t v41;
  char *v42;
  size_t v43;
  char *v44;
  char *v45;
  char *v46;
  char *v47;
  char *v48;
  char *v49;
  char *v50;
  size_t v51;
  char *v52;
  size_t v53;
  char *v54;
  unint64_t v55;
  char *v56;
  uint64_t v57;
  const char *v58;
  size_t v59;
  unint64_t v60;
  uint64_t v61;
  char *v62;
  char *v63;
  char *var1;
  unint64_t v65;
  uint64_t *v66;
  uint64_t v67;
  unint64_t v68;
  char **v69;
  char *v70;
  char *v71;
  uint64_t v72;
  uint64_t v73;
  unint64_t v74;
  char *v75;
  uint64_t v76;
  char *v77;
  size_t v78;
  char *v79;
  char *v80;
  char *v81;
  uint64_t v82;
  __int128 v83;
  uint64_t v84;
  uint64_t v85;
  _anonymous_namespace_ *v87;
  const char *v88;
  char *v89;
  char *v90;
  uint64_t v91;
  unint64_t v92;
  unint64_t v93;
  uint64_t v94;
  uint64_t v95;
  _anonymous_namespace_ *v96;
  _anonymous_namespace_ *v97;
  uint64_t v98;
  uint64_t v99;
  _anonymous_namespace_ *v100;
  const char *v101;
  _anonymous_namespace_ *v102;
  _anonymous_namespace_ *v103;
  uint64_t *v104;
  uint64_t v105;
  size_t v106;
  const char *v107;
  const char *v108;
  size_t v109;
  _anonymous_namespace_ *v110;
  unint64_t i;
  uint64_t v112;
  char *v113;
  uint64_t *v114;
  uint64_t *v115;
  uint64_t *v116;
  char *v117;
  uint64_t *v118;
  re::StringID *v119;
  const char *v120;
  char *v121;
  StringID v122;
  StringID v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t *v126;
  uint64_t v127;
  int v128;
  uint64_t v129;
  _BYTE v130[40];
  uint64_t v131;
  int v132;
  uint64_t v133;
  _BYTE v134[18];
  __int16 v135;
  unint64_t v136;
  __int16 v137;
  char *v138;
  StringID v139;
  unsigned __int128 v140;
  __int128 v141;
  __int128 v142;
  __int128 v143;
  uint64_t v144;

  v144 = *MEMORY[0x24BDAC8D0];
  v6 = re::RigDataParser::parseAlphaNumeric((uint64_t *)a2);
  v8 = v7;
  if (strncmp(v6, "struct", v7))
    goto LABEL_3;
  if (aStruct_0[v8])
    goto LABEL_3;
  v24 = (char *)(*(_QWORD *)a2 + *(_QWORD *)(a2 + 8) - (_QWORD)&v6[v8]);
  *(_QWORD *)&v139.var0 = &v6[v8];
  v139.var1 = v24;
  v25 = re::RigDataParser::parseAlphaNumeric((uint64_t *)&v139);
  if (!v26)
    goto LABEL_3;
  v27 = v25;
  v28 = v26;
  v29 = *(_QWORD *)a2 + *(_QWORD *)(a2 + 8);
  *(_QWORD *)&v139.var0 = &v26[(_QWORD)v25];
  v139.var1 = (char *)(v29 - (unint64_t)&v26[(_QWORD)v25]);
  v30 = re::RigDataParser::parseWhitespace((uint64_t *)&v139);
  v32 = &v30[v31];
  v33 = (unint64_t)&v30[v31] < v29;
  if (strncmp(&v30[v31], "{", v33) || asc_22622D872[v33])
  {
LABEL_3:
    *(_BYTE *)&v139.var0 = 0;
    goto LABEL_4;
  }
  v34 = &v32[v33];
  *(_QWORD *)&v122.var0 = v27;
  v122.var1 = v28;
  *(_QWORD *)&v123.var0 = 0;
  v123.var1 = 0;
  v35 = 1;
  LODWORD(v124) = 1;
  v126 = 0;
  v127 = 0;
  v125 = 0;
  v128 = 0;
  v36 = *(_QWORD *)a2;
  v37 = *(_QWORD *)(a2 + 8);
  v38 = *(_QWORD *)a2 + v37;
  if ((unint64_t)&v32[v33] >= v38)
  {
    v116 = 0;
    v121 = 0;
    v39 = 0;
  }
  else
  {
    v121 = 0;
    v116 = 0;
    v39 = 0;
    while (1)
    {
      *(_QWORD *)&v139.var0 = v34;
      v139.var1 = (char *)(v38 - (_QWORD)v34);
      v40 = re::RigDataParser::parseWhitespace((uint64_t *)&v139);
      v42 = &v40[v41];
      v43 = (unint64_t)&v40[v41] < v38;
      if (!strncmp(&v40[v41], "}", v43) && !asc_22622D9C1[v43])
        break;
      v44 = (char *)(*(_QWORD *)a2 + *(_QWORD *)(a2 + 8) - (_QWORD)v34);
      *(_QWORD *)&v139.var0 = v34;
      v139.var1 = v44;
      v45 = re::RigDataParser::parseTypeName((uint64_t *)&v139);
      if (!v46)
        goto LABEL_55;
      v47 = v45;
      v48 = v46;
      v49 = (char *)(*(_QWORD *)a2 + *(_QWORD *)(a2 + 8) - (unint64_t)&v46[(_QWORD)v45]);
      *(_QWORD *)&v139.var0 = &v46[(_QWORD)v45];
      v139.var1 = v49;
      v50 = re::RigDataParser::parseAlphaNumeric((uint64_t *)&v139);
      if (!v51)
        goto LABEL_55;
      v52 = v50;
      v53 = v51;
      v117 = v48;
      v119 = (re::StringID *)v47;
      v54 = &v50[v51];
      v55 = *(_QWORD *)a2 + *(_QWORD *)(a2 + 8);
      *(_QWORD *)&v139.var0 = &v50[v51];
      v139.var1 = (char *)(v55 - (_QWORD)&v50[v51]);
      v56 = re::RigDataParser::parseWhitespace((uint64_t *)&v139);
      v58 = &v56[v57];
      v59 = (unint64_t)v58 < v55;
      v120 = v58;
      if (strncmp(v58, ";", v59) || asc_226231DD6[v59])
      {
LABEL_55:
        *(_BYTE *)&v139.var0 = 0;
        goto LABEL_76;
      }
      if (v39)
      {
        v60 = 0;
        while (1)
        {
          v61 = re::BucketArray<re::RigDataTypeStructBuilder::RigDataTypeStructMember,8ul>::operator[]((uint64_t)&v123, v60);
          if (*(_QWORD *)(v61 + 8) == v53 && !memcmp(*(const void **)v61, v52, v53))
            break;
          if (v39 == ++v60)
            goto LABEL_29;
        }
      }
      else
      {
LABEL_29:
        v62 = (char *)memchr(v52, 46, v53);
        if (v62)
          v63 = v62;
        else
          v63 = v54;
        if (v63 - v52 == v53)
        {
          var1 = v121;
          if (v39 + 1 > 8 * (uint64_t)v121)
          {
            re::BucketArray<re::RigDataTypeStructBuilder::RigDataTypeStructMember,8ul>::setBucketsCapacity(&v123, (v39 + 8) >> 3);
            var1 = v123.var1;
          }
          v65 = v39 >> 3;
          v121 = var1;
          if ((unint64_t)var1 <= v39 >> 3)
            goto LABEL_94;
          v35 = v124;
          v66 = &v125;
          v116 = v126;
          if ((v124 & 1) == 0)
            v66 = v126;
          v67 = v66[v65];
          v68 = v39 & 7;
          v39 = ++v127;
          ++v128;
          v69 = (char **)(v67 + 32 * v68);
          *v69 = v52;
          v69[1] = (char *)v53;
          v69[2] = (char *)v119;
          v69[3] = v117;
        }
      }
      v34 = (char *)&v120[v59];
      v36 = *(_QWORD *)a2;
      v37 = *(_QWORD *)(a2 + 8);
      v38 = *(_QWORD *)a2 + v37;
      if ((unint64_t)v34 >= v38)
        goto LABEL_53;
    }
    v34 = &v42[v43];
    v36 = *(_QWORD *)a2;
    v37 = *(_QWORD *)(a2 + 8);
  }
LABEL_53:
  v89 = (char *)(v36 + v37);
  *(_QWORD *)&v139.var0 = v34;
  v139.var1 = (char *)(v36 + v37 - (_QWORD)v34);
  v90 = re::RigDataParser::parseWhitespace((uint64_t *)&v139);
  if (&v90[v91] == v89)
  {
    *(_QWORD *)&v139.var0 = 0;
    v139.var1 = (char *)&str_110;
    v130[0] = 13;
    re::StringID::StringID((re::StringID *)&v130[8], &v139);
    v133 = 0;
    *(_QWORD *)&v130[32] = 0;
    v131 = 0;
    *(_QWORD *)&v130[24] = 0;
    v132 = 0;
    re::StringID::destroyString((re::StringID *)&v139);
    v103 = (_anonymous_namespace_ *)re::DynamicArray<re::RigDataTypeClass::RigDataTypeAttribute>::setCapacity(&v130[24], v39);
    ++v132;
    if (v39)
    {
      v65 = 0;
      v104 = &v125;
      if ((v35 & 1) == 0)
        v104 = v116;
      v118 = v104;
      while ((unint64_t)v121 > v65 >> 3)
      {
        v105 = v118[v65 >> 3] + 32 * (v65 & 7);
        v107 = *(const char **)v105;
        v106 = *(_QWORD *)(v105 + 8);
        *(_QWORD *)&v139.var0 = 0;
        v139.var1 = (char *)&str_110;
        v108 = *(const char **)(v105 + 16);
        v109 = *(_QWORD *)(v105 + 24);
        *(_QWORD *)&v140 = 0;
        *((_QWORD *)&v140 + 1) = &str_110;
        re::DynamicArray<re::RigDataTypeClass::RigDataTypeAttribute>::add((_anonymous_namespace_ *)&v130[24], (uint64_t *)&v139);
        re::StringID::destroyString((re::StringID *)&v140);
        re::StringID::destroyString((re::StringID *)&v139);
        if (v39 == ++v65)
          goto LABEL_75;
      }
      v129 = 0;
      v142 = 0u;
      v143 = 0u;
      v140 = 0u;
      v141 = 0u;
      v139 = (StringID)0;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v134 = 136315906;
      *(_QWORD *)&v134[4] = "operator[]";
      *(_WORD *)&v134[12] = 1024;
      *(_DWORD *)&v134[14] = 866;
      v135 = 2048;
      v136 = v65 >> 3;
      v137 = 2048;
      v138 = v121;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_94:
      *(_QWORD *)v134 = 0;
      v142 = 0u;
      v143 = 0u;
      v140 = 0u;
      v141 = 0u;
      v139 = (StringID)0;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v130 = 136315906;
      *(_QWORD *)&v130[4] = "operator[]";
      *(_WORD *)&v130[12] = 1024;
      *(_DWORD *)&v130[14] = 858;
      *(_WORD *)&v130[18] = 2048;
      *(_QWORD *)&v130[20] = v65;
      *(_WORD *)&v130[28] = 2048;
      *(_QWORD *)&v130[30] = v121;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
LABEL_75:
    *(_BYTE *)&v139.var0 = 1;
    LOBYTE(v139.var1) = v130[0];
    re::StringID::StringID((re::StringID *)&v140, (const StringID *)&v130[8]);
    re::DynamicArray<re::RigDataTypeClass::RigDataTypeAttribute>::DynamicArray((uint64_t)&v141, (uint64_t *)&v130[24]);
    re::DynamicArray<re::RigDataTypeClass::RigDataTypeAttribute>::deinit((uint64_t)&v130[24]);
    re::StringID::destroyString((re::StringID *)&v130[8]);
  }
  else
  {
    *(_BYTE *)&v139.var0 = 0;
  }
LABEL_76:
  if (v39)
  {
    for (i = 0; i != v39; ++i)
      re::BucketArray<re::RigDataTypeStructBuilder::RigDataTypeStructMember,8ul>::operator[]((uint64_t)&v123, i);
  }
  v112 = *(_QWORD *)&v123.var0;
  if (v121)
  {
    v113 = v121 - 1;
    v114 = v116;
    do
    {
      if ((v35 & 1) != 0)
        v115 = &v125;
      else
        v115 = v116;
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v112 + 40))(v112, v115[(_QWORD)v113]);
      v35 += 2;
      LODWORD(v124) = v35;
      --v113;
    }
    while (v113 != (char *)-1);
    v123.var1 = 0;
  }
  else
  {
    v114 = v116;
    if (!*(_QWORD *)&v123.var0)
      goto LABEL_89;
  }
  if ((v35 & 1) == 0)
    (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v112 + 40))(v112, v114);
LABEL_89:
  if (v139.var0)
  {
    *(_BYTE *)&v122.var0 = v139.var1;
    re::StringID::StringID((re::StringID *)&v122.var1, (const StringID *)&v140);
    re::DynamicArray<re::RigDataTypeClass::RigDataTypeAttribute>::DynamicArray((uint64_t)&v123.var1, (uint64_t *)&v141);
    *(_BYTE *)a3 = 1;
    *(_BYTE *)(a3 + 8) = v122.var0;
    re::StringID::StringID((re::StringID *)(a3 + 16), (const StringID *)&v122.var1);
    re::DynamicArray<re::RigDataTypeClass::RigDataTypeAttribute>::DynamicArray(a3 + 32, (uint64_t *)&v123.var1);
    re::DynamicArray<re::RigDataTypeClass::RigDataTypeAttribute>::deinit((uint64_t)&v123.var1);
    re::StringID::destroyString((re::StringID *)&v122.var1);
    return re::Optional<re::RigDataTypeClass>::~Optional(&v139);
  }
LABEL_4:
  v9 = re::RigDataParser::parseAlphaNumeric((uint64_t *)a2);
  if (!v10)
    goto LABEL_44;
  v11 = v9;
  v12 = v10;
  v13 = &v9[v10];
  v14 = *(_QWORD *)a2 + *(_QWORD *)(a2 + 8);
  *(_QWORD *)&v122.var0 = &v9[v10];
  v122.var1 = (char *)(v14 - (_QWORD)&v9[v10]);
  v15 = re::RigDataParser::parseWhitespace((uint64_t *)&v122);
  v17 = &v15[v16];
  v18 = (unint64_t)&v15[v16] < v14;
  if (strncmp(&v15[v16], "[", v18) || asc_22622DA93[v18])
  {
    v19 = (char *)(*(_QWORD *)a2 + *(_QWORD *)(a2 + 8));
    *(_QWORD *)&v122.var0 = v13;
    v122.var1 = (char *)(v19 - v13);
    v20 = re::RigDataParser::parseWhitespace((uint64_t *)&v122);
    if (&v20[v21] == v19)
    {
      v22 = 1;
      while (1)
      {
        v23 = *re::RigDataTypeDescriptions::rigDataTypeDescription(v22, v21);
        if (!strncmp(v11, v23, v12) && !v23[v12])
          break;
        if (++v22 == 14)
          goto LABEL_44;
      }
      v87 = (_anonymous_namespace_ *)re::RigDataTypeDescriptions::rigDataTypeDescription(v22, v21);
      v88 = *(const char **)v87;
      *(_QWORD *)&v122.var0 = 0;
      v122.var1 = (char *)&str_110;
      v130[0] = v22;
      goto LABEL_49;
    }
LABEL_44:
    *(_BYTE *)&v122.var0 = 0;
    goto LABEL_45;
  }
  v70 = (char *)(*(_QWORD *)a2 + *(_QWORD *)(a2 + 8) - (_QWORD)&v17[v18]);
  *(_QWORD *)&v122.var0 = &v17[v18];
  v122.var1 = v70;
  v71 = re::RigDataParser::parseNumeric((uint64_t *)&v122);
  v73 = v72;
  v74 = *(_QWORD *)a2 + *(_QWORD *)(a2 + 8);
  *(_QWORD *)&v122.var0 = &v71[v72];
  v122.var1 = (char *)(v74 - (_QWORD)&v71[v72]);
  v75 = re::RigDataParser::parseWhitespace((uint64_t *)&v122);
  v77 = &v75[v76];
  v78 = (unint64_t)&v75[v76] < v74;
  if (strncmp(&v75[v76], "]", v78))
    goto LABEL_44;
  if (asc_22622DA95[v78])
    goto LABEL_44;
  v79 = &v77[v78];
  v80 = (char *)(*(_QWORD *)a2 + *(_QWORD *)(a2 + 8));
  *(_QWORD *)&v122.var0 = v79;
  v122.var1 = (char *)(v80 - v79);
  v81 = re::RigDataParser::parseWhitespace((uint64_t *)&v122);
  if (&v81[v82] != v80)
    goto LABEL_44;
  if (!v73)
  {
    *(_QWORD *)&v122.var0 = 0;
    v122.var1 = (char *)&str_110;
    v130[0] = 12;
LABEL_49:
    re::StringID::StringID((re::StringID *)&v130[8], &v122);
    v133 = 0;
    *(_QWORD *)&v130[32] = 0;
    v131 = 0;
    *(_QWORD *)&v130[24] = 0;
    v132 = 0;
    re::StringID::destroyString((re::StringID *)&v122);
    *(_BYTE *)&v122.var0 = 1;
    LOBYTE(v122.var1) = v130[0];
    goto LABEL_50;
  }
  v92 = 0;
  do
  {
    v93 = v92;
    v95 = *v71++;
    v94 = v95;
    v92 = v95 + 10 * v92 - 48;
    --v73;
  }
  while (v73);
  *(_QWORD *)&v122.var0 = 0;
  v122.var1 = (char *)&str_110;
  v130[0] = 11;
  re::StringID::StringID((re::StringID *)&v130[8], &v122);
  v133 = 0;
  *(_QWORD *)&v130[32] = 0;
  v131 = 0;
  *(_QWORD *)&v130[24] = 0;
  v132 = 0;
  re::StringID::destroyString((re::StringID *)&v122);
  v97 = (_anonymous_namespace_ *)re::DynamicArray<re::RigDataTypeClass::RigDataTypeAttribute>::setCapacity(&v130[24], v92);
  ++v132;
  v122.var1 = 0;
  *(_QWORD *)&v123.var0 = 0;
  v123.var1 = 0;
  re::DynamicString::setCapacity(&v122, 0);
  if (v92)
  {
    v98 = 0;
    v99 = v94 + 10 * v93 - 48;
    do
    {
      v100 = (_anonymous_namespace_ *)re::DynamicString::assignf((re::DynamicString *)&v122, "value[%zu]", v98);
      if (((uint64_t)v122.var1 & 1) != 0)
        v101 = *(const char **)&v123.var0;
      else
        v101 = (char *)&v122.var1 + 1;
      *(_QWORD *)v134 = 0;
      *(_QWORD *)&v134[8] = &str_110;
      re::StringID::StringID((re::StringID *)&v134[16], (const StringID *)&v130[8]);
      re::DynamicArray<re::RigDataTypeClass::RigDataTypeAttribute>::add((_anonymous_namespace_ *)&v130[24], (uint64_t *)v134);
      re::StringID::destroyString((re::StringID *)&v134[16]);
      re::StringID::destroyString((re::StringID *)v134);
      ++v98;
    }
    while (v99 != v98);
  }
  if (*(_QWORD *)&v122.var0 && ((uint64_t)v122.var1 & 1) != 0)
    (*(void (**)(void))(**(_QWORD **)&v122.var0 + 40))();
  *(_BYTE *)&v122.var0 = 1;
  LOBYTE(v122.var1) = v130[0];
LABEL_50:
  re::StringID::StringID((re::StringID *)&v123, (const StringID *)&v130[8]);
  re::DynamicArray<re::RigDataTypeClass::RigDataTypeAttribute>::DynamicArray((uint64_t)&v124, (uint64_t *)&v130[24]);
  re::DynamicArray<re::RigDataTypeClass::RigDataTypeAttribute>::deinit((uint64_t)&v130[24]);
  re::StringID::destroyString((re::StringID *)&v130[8]);
  if (v122.var0)
  {
    v130[0] = v122.var1;
    re::StringID::StringID((re::StringID *)&v130[8], &v123);
    re::DynamicArray<re::RigDataTypeClass::RigDataTypeAttribute>::DynamicArray((uint64_t)&v130[24], &v124);
    *(_BYTE *)a3 = 1;
    *(_BYTE *)(a3 + 8) = v130[0];
    re::StringID::StringID((re::StringID *)(a3 + 16), (const StringID *)&v130[8]);
    re::DynamicArray<re::RigDataTypeClass::RigDataTypeAttribute>::DynamicArray(a3 + 32, (uint64_t *)&v130[24]);
    re::DynamicArray<re::RigDataTypeClass::RigDataTypeAttribute>::deinit((uint64_t)&v130[24]);
    re::StringID::destroyString((re::StringID *)&v130[8]);
    goto LABEL_46;
  }
LABEL_45:
  *(_QWORD *)&v130[16] = 0;
  *(_QWORD *)&v130[24] = 0;
  *(_OWORD *)v130 = a1;
  re::DynamicString::setCapacity(v130, 0x40uLL);
  re::DynamicString::append((re::DynamicString *)v130, "Unknown rig data type: ", 0x17uLL);
  re::DynamicString::append((re::DynamicString *)v130, *(const char **)a2, *(_QWORD *)(a2 + 8));
  v83 = *(_OWORD *)v130;
  v84 = *(_QWORD *)&v130[16];
  v85 = *(_QWORD *)&v130[24];
  *(_BYTE *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 5000;
  *(_QWORD *)(a3 + 16) = &re::AnimationErrorCategory(void)::instance;
  *(_OWORD *)(a3 + 24) = v83;
  *(_QWORD *)(a3 + 40) = v84;
  *(_QWORD *)(a3 + 48) = v85;
LABEL_46:
  re::Optional<re::RigDataTypeClass>::~Optional(&v122);
  return re::Optional<re::RigDataTypeClass>::~Optional(&v139);
}

void re::RigDataTypeClass::attributeType(uint64_t a1@<X0>, re::RigEnvironment *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  size_t v8;
  void *v9;
  size_t v10;
  size_t v11;
  size_t v12;
  size_t v13;
  StringID *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  size_t v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  __int128 v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  char *v29;
  uint64_t v30;
  _BYTE v31[24];
  __int128 v32;
  uint64_t v33;
  uint64_t v34;
  __int128 v35;
  char *v36;
  uint64_t v37;
  __int128 v38;

  v9 = *(void **)a3;
  v8 = *(_QWORD *)(a3 + 8);
  v10 = *(_QWORD *)a3 + v8;
  v11 = (size_t)memchr(*(void **)a3, 46, v8);
  if (v11)
    v12 = v11;
  else
    v12 = v10;
  v13 = v12 - (_QWORD)v9;
  if (v12 - (_QWORD)v9 == v8)
  {
    v38 = *(_OWORD *)a3;
  }
  else
  {
    *(_QWORD *)&v38 = v9;
    *((_QWORD *)&v38 + 1) = v12 - (_QWORD)v9;
  }
  if (*(_BYTE *)a1 == 12)
  {
    re::RigDataParser::extractArrayIndex((uint64_t *)&v38, (uint64_t)v31);
    if (!v31[0])
    {
      *(_OWORD *)(a4 + 8) = *(_OWORD *)&v31[8];
      v25 = v32;
      v26 = v33;
      v27 = v34;
      *(_BYTE *)a4 = 0;
      *(_OWORD *)(a4 + 24) = v25;
      *(_QWORD *)(a4 + 40) = v26;
      *(_QWORD *)(a4 + 48) = v27;
      return;
    }
    v14 = (StringID *)(a1 + 8);
    goto LABEL_10;
  }
  v16 = *(_QWORD *)(a1 + 40);
  if (v16)
  {
    v14 = (StringID *)(*(_QWORD *)(a1 + 56) + 16);
    v17 = 32 * v16;
    while (1)
    {
      v11 = strlen(v14[-1].var1);
      if (*((_QWORD *)&v38 + 1) == v11)
      {
        v11 = memcmp((const void *)v38, v14[-1].var1, *((size_t *)&v38 + 1));
        if (!(_DWORD)v11)
          break;
      }
      v14 += 2;
      v17 -= 32;
      if (!v17)
        goto LABEL_17;
    }
LABEL_10:
    if (v13 == v8)
    {
      re::StringID::StringID((re::StringID *)v31, v14);
      *(_BYTE *)a4 = 1;
      v15 = *(_QWORD *)&v31[8];
      *(_QWORD *)(a4 + 8) = *(_QWORD *)v31;
      *(_QWORD *)(a4 + 16) = v15;
      *(_QWORD *)v31 = 0;
      *(_QWORD *)&v31[8] = &str_110;
      re::StringID::destroyString((re::StringID *)v31);
    }
    else
    {
      re::RigEnvironment::lookupRigDataType(a2, (const char **)v14, v31);
      if (v31[0])
      {
        *(_QWORD *)&v35 = re::Slice<char>::range((_QWORD *)a3, v13 + 1, *(_QWORD *)(a3 + 8));
        *((_QWORD *)&v35 + 1) = v24;
        re::RigDataTypeClass::attributeType(&v31[8], a2, &v35);
      }
      else
      {
        re::DynamicString::format((re::DynamicString *)"Unknown child attribute type: %s", (re::DynamicString *)&v35, v14->var1);
        v28 = v35;
        v29 = v36;
        v30 = v37;
        *(_BYTE *)a4 = 0;
        *(_QWORD *)(a4 + 8) = 5000;
        *(_QWORD *)(a4 + 16) = &re::AnimationErrorCategory(void)::instance;
        *(_OWORD *)(a4 + 24) = v28;
        *(_QWORD *)(a4 + 40) = v29;
        *(_QWORD *)(a4 + 48) = v30;
      }
      re::Optional<re::RigDataTypeClass>::~Optional(v31);
    }
    return;
  }
LABEL_17:
  v36 = 0;
  v37 = 0;
  v18 = *(_QWORD *)(a3 + 8);
  if (v18)
    v19 = v18 + 1;
  else
    v19 = 0;
  *((_QWORD *)&v35 + 1) = 0;
  re::DynamicString::setCapacity(&v35, v19);
  re::DynamicString::operator=((re::DynamicString *)&v35, a3);
  if ((BYTE8(v35) & 1) != 0)
    v20 = v36;
  else
    v20 = (char *)&v35 + 9;
  re::DynamicString::format((re::DynamicString *)"Attribute name could not be resolved: %s", (re::DynamicString *)v31, v20);
  v21 = *(_OWORD *)v31;
  v22 = *(_QWORD *)&v31[16];
  v23 = v32;
  *(_BYTE *)a4 = 0;
  *(_QWORD *)(a4 + 8) = 5003;
  *(_QWORD *)(a4 + 16) = &re::AnimationErrorCategory(void)::instance;
  *(_OWORD *)(a4 + 24) = v21;
  *(_QWORD *)(a4 + 40) = v22;
  *(_QWORD *)(a4 + 48) = v23;
  if ((_QWORD)v35 && (BYTE8(v35) & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v35 + 40))();
}

uint64_t re::Slice<char>::range(_QWORD *a1, unint64_t a2, unint64_t a3)
{
  unint64_t v3;
  uint64_t result;

  v3 = a1[1];
  if (v3 < a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. fromInclusive = %zu, size = %zu", "fromInclusive <= size()", "range", 241, a2, v3);
    _os_crash();
    __break(1u);
  }
  else if (v3 >= a3)
  {
    return *a1 + a2;
  }
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. toExclusive = %zu, size = %zu", "toExclusive <= size()", "range", 242, a2, v3);
  result = _os_crash();
  __break(1u);
  return result;
}

BOOL re::RigDataTypeClass::operator==(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v2;
  int v3;

  v2 = *a1;
  v3 = *a2;
  if (v2 == 12)
  {
    if (v3 == 12)
      return re::StringID::operator==((_QWORD *)a1 + 1, (_QWORD *)a2 + 1);
  }
  else if (v2 == v3)
  {
    return re::DynamicArray<re::RigDataTypeClass::RigDataTypeAttribute>::operator==((uint64_t)(a1 + 24), (uint64_t)(a2 + 24));
  }
  return 0;
}

BOOL re::DynamicArray<re::RigDataTypeClass::RigDataTypeAttribute>::operator==(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _BOOL8 result;
  _QWORD *v7;
  _QWORD *v8;

  v2 = *(_QWORD *)(a1 + 16);
  if (v2 != *(_QWORD *)(a2 + 16))
    return 0;
  if (!v2)
    return 1;
  v3 = *(_QWORD **)(a1 + 32);
  v4 = &v3[4 * v2];
  v5 = *(_QWORD **)(a2 + 32);
  while (1)
  {
    result = re::StringID::operator==(v3, v5);
    if (!result)
      break;
    v7 = v3 + 2;
    v8 = v5 + 2;
    result = re::StringID::operator==(v7, v8);
    if (!result)
      break;
    v3 = v7 + 2;
    v5 = v8 + 2;
    if (v3 == v4)
      return 1;
  }
  return result;
}

_anonymous_namespace_ *re::DynamicArray<re::RigDataTypeClass::RigDataTypeAttribute>::add(_anonymous_namespace_ *result, uint64_t *a2)
{
  _anonymous_namespace_ *v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  BOOL v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t *v11;
  uint64_t v12;
  uint64_t v13;

  v3 = result;
  v4 = *((_QWORD *)result + 1);
  v5 = *((_QWORD *)result + 2);
  if (v5 >= v4)
  {
    v6 = v5 + 1;
    if (v4 < v5 + 1)
    {
      if (*(_QWORD *)result)
      {
        v7 = 2 * v4;
        v8 = v4 == 0;
        v9 = 8;
        if (!v8)
          v9 = v7;
        if (v9 <= v6)
          v10 = v6;
        else
          v10 = v9;
        result = (_anonymous_namespace_ *)re::DynamicArray<re::RigDataTypeClass::RigDataTypeAttribute>::setCapacity(result, v10);
      }
      else
      {
        result = (_anonymous_namespace_ *)re::DynamicArray<re::RigDataTypeClass::RigDataTypeAttribute>::setCapacity(v3, v6);
        ++*((_DWORD *)v3 + 6);
      }
    }
    v5 = *((_QWORD *)v3 + 2);
  }
  v11 = (unint64_t *)(*((_QWORD *)v3 + 4) + 32 * v5);
  v12 = *a2;
  *v11 = *v11 & 0xFFFFFFFFFFFFFFFELL | *a2 & 1;
  *v11 = *a2 & 0xFFFFFFFFFFFFFFFELL | v12 & 1;
  v11[1] = a2[1];
  *a2 = 0;
  a2[1] = (uint64_t)&str_110;
  v13 = a2[2];
  v11[2] = v11[2] & 0xFFFFFFFFFFFFFFFELL | v13 & 1;
  v11[2] = a2[2] & 0xFFFFFFFFFFFFFFFELL | v13 & 1;
  v11[3] = a2[3];
  a2[2] = 0;
  a2[3] = (uint64_t)&str_110;
  ++*((_QWORD *)v3 + 2);
  ++*((_DWORD *)v3 + 6);
  return result;
}

uint64_t re::BucketArray<re::RigDataTypeStructBuilder::RigDataTypeStructMember,8ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1011, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(_QWORD *)(a1 + 8) <= a2 >> 3)
    goto LABEL_8;
  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
    v3 = a1 + 24;
  else
    v3 = *(_QWORD *)(a1 + 32);
  return *(_QWORD *)(v3 + 8 * (a2 >> 3)) + 32 * (a2 & 7);
}

_QWORD *re::BucketArray<re::RigDataTypeStructBuilder::RigDataTypeStructMember,8ul>::setBucketsCapacity(_QWORD *result, unint64_t a2)
{
  _QWORD *v3;
  unint64_t v4;
  unint64_t *v5;
  _QWORD *v6;
  unint64_t v7;
  int v8;
  unint64_t v9;
  unint64_t v10;
  BOOL v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  _QWORD *v15;
  unint64_t v16;

  v3 = result;
  if (*result)
  {
    if (result[5] < 8 * a2)
    {
      while (1)
      {
        v4 = v3[1];
        if (v4 <= a2)
          break;
        result = (_QWORD *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        v5 = v3 + 3;
        do
        {
          result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(*(_QWORD *)*v3 + 32))(*v3, 256, 0);
          v6 = result;
          if (*v3)
          {
            v7 = v3[1];
            v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              v9 = *v5;
              v11 = v7 >= *v5;
              v10 = v7 + 1;
              v11 = !v11 || v9 >= v10;
              if (v11)
                goto LABEL_22;
              v12 = 2 * v9;
              goto LABEL_18;
            }
            v10 = v7 + 1;
            if (v10 >= 3)
            {
              v12 = 4;
LABEL_18:
              if (v12 <= v10)
                v14 = v10;
              else
                v14 = v12;
              result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v14);
              v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            v13 = v3[1] + 1;
            result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v13);
            v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + 4) = v8;
          }
LABEL_22:
          v15 = v3 + 3;
          if ((v8 & 1) == 0)
            v15 = (_QWORD *)v3[4];
          v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
    re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, a2);
    *((_DWORD *)v3 + 4) += 2;
    v3[5] = 0;
    result = (_QWORD *)re::BucketArray<re::RigDataTypeStructBuilder::RigDataTypeStructMember,8ul>::setBucketsCapacity(v3, a2);
    ++*((_DWORD *)v3 + 12);
  }
  return result;
}

char *re::RigDataParser::parseWhitespace(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t v7;

  v1 = *a1;
  v2 = a1[1];
  if (v2)
  {
    v4 = -v1;
    v5 = MEMORY[0x24BDAC740];
    while (1)
    {
      v6 = *(char *)v1;
      if ((v6 & 0x80000000) != 0)
      {
        if (!__maskrune(v6, 0x4000uLL))
          return (char *)*a1;
      }
      else if ((*(_DWORD *)(v5 + 4 * v6 + 60) & 0x4000) == 0)
      {
        return (char *)*a1;
      }
      ++v1;
      --v4;
      if (!--v2)
      {
        v1 = *a1;
        v7 = a1[1];
        return (char *)(v1 + v7);
      }
    }
  }
  v7 = 0;
  return (char *)(v1 + v7);
}

char *re::RigDataParser::parseAlphaNumeric(uint64_t *a1)
{
  char *v2;
  uint64_t v3;
  char *result;
  unint64_t v5;
  char *v6;
  int v7;

  v2 = re::RigDataParser::parseWhitespace(a1);
  result = &v2[v3];
  v5 = *a1 + a1[1];
  if ((unint64_t)result < v5)
  {
    v6 = result;
    do
    {
      v7 = *v6;
      if ((v7 - 48) >= 0xA && (v7 & 0xFFFFFFDF) - 65 > 0x19)
        break;
      ++v6;
    }
    while ((unint64_t)v6 < v5);
  }
  return result;
}

char *re::RigDataParser::parseNumeric(uint64_t *a1)
{
  char *v2;
  uint64_t v3;
  char *result;
  unint64_t v5;
  char *v6;

  v2 = re::RigDataParser::parseWhitespace(a1);
  result = &v2[v3];
  v5 = *a1 + a1[1];
  if ((unint64_t)result < v5)
  {
    v6 = result;
    do
    {
      if (*v6 - 48 > 9)
        break;
      ++v6;
    }
    while ((unint64_t)v6 < v5);
  }
  return result;
}

char *re::RigDataParser::parseFloat(uint64_t *a1)
{
  char *v2;
  uint64_t v3;
  char *result;
  char *v5;
  unint64_t v6;
  int v7;
  unsigned __int8 *v8;
  unsigned __int8 *v9;

  v2 = re::RigDataParser::parseWhitespace(a1);
  result = &v2[v3];
  v5 = result + 1;
  if (*result != 45)
    v5 = result;
  v6 = *a1 + a1[1];
  if ((unint64_t)v5 >= v6)
  {
LABEL_7:
    v7 = *v5;
  }
  else
  {
    while (1)
    {
      v7 = *v5;
      if ((v7 - 48) > 9)
        break;
      if ((unint64_t)++v5 >= v6)
      {
        v5 = (char *)(*a1 + a1[1]);
        goto LABEL_7;
      }
    }
  }
  if (v7 == 46)
  {
    v8 = (unsigned __int8 *)(v5 + 1);
    do
    {
      v9 = v8;
      if ((unint64_t)v8 >= v6)
        break;
      ++v8;
    }
    while (*v9 - 48 < 0xA);
  }
  return result;
}

char *re::RigDataParser::parseTypeName(uint64_t *a1)
{
  uint64_t v2;
  char *v3;
  uint64_t v4;
  char *v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  char *v9;
  size_t v10;
  size_t v11;
  char *v12;
  unint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  char *v18;
  size_t v19;

  v2 = a1[1];
  v18 = (char *)*a1;
  v19 = v2;
  v3 = re::RigDataParser::parseAlphaNumeric((uint64_t *)&v18);
  v5 = v3;
  if (v4)
  {
    v6 = *a1 + a1[1];
    v18 = &v3[v4];
    v19 = v6 - (_QWORD)&v3[v4];
    v7 = re::RigDataParser::parseWhitespace((uint64_t *)&v18);
    v9 = &v7[v8];
    v10 = (unint64_t)&v7[v8] < v6;
    if (!strncmp(&v7[v8], "[", v10) && !str_8[v10])
    {
      v11 = *a1 + a1[1] - (_QWORD)&v9[v10];
      v18 = &v9[v10];
      v19 = v11;
      v12 = re::RigDataParser::parseNumeric((uint64_t *)&v18);
      v13 = *a1 + a1[1];
      v18 = &v12[v14];
      v19 = v13 - (_QWORD)&v12[v14];
      v15 = re::RigDataParser::parseWhitespace((uint64_t *)&v18);
      strncmp(&v15[v16], "]", (unint64_t)&v15[v16] < v13);
    }
  }
  return v5;
}

char *re::RigDataParser::extractArrayIndex@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  char *v4;
  size_t v5;
  size_t v6;
  _anonymous_namespace_ *v7;
  uint64_t v8;
  size_t v9;
  char *v10;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  char *result;
  char *v15;
  unint64_t v16;
  char *v17;
  uint64_t v18;
  char *v19;
  size_t v20;
  _anonymous_namespace_ *v21;
  uint64_t v22;
  size_t v23;
  char *v24;
  size_t v25;
  char *v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  unint64_t v30;
  char *v31;
  uint64_t v32;
  char *v33;
  size_t v34;
  _anonymous_namespace_ *v35;
  uint64_t v36;
  size_t v37;
  char *v38;
  uint64_t v39;
  size_t v40;
  char *v41;
  char *v42;
  char *v43;
  uint64_t v44;
  uint64_t v45;
  size_t v46;
  char *v47;
  uint64_t *v48;
  uint64_t v49;
  char *v50;
  uint64_t v51;
  __int128 v52;
  uint64_t v53;
  uint64_t v54;

  v4 = re::RigDataParser::parseAlphaNumeric(a1);
  v6 = v5;
  v7 = (_anonymous_namespace_ *)strncmp(v4, "value", v5);
  if ((_DWORD)v7 || aValue[v6])
  {
    v50 = 0;
    v51 = 0;
    v8 = a1[1];
    if (v8)
      v9 = v8 + 1;
    else
      v9 = 0;
    v49 = 0;
    re::DynamicString::setCapacity(&v48, v9);
    re::DynamicString::operator=((re::DynamicString *)&v48, (uint64_t)a1);
    if ((v49 & 1) != 0)
      v10 = v50;
    else
      v10 = (char *)&v49 + 1;
    re::DynamicString::format((re::DynamicString *)"Unknown child attribute (expected array value): %s", (re::DynamicString *)&v52, v10);
  }
  else
  {
    v15 = &v4[v6];
    v16 = *a1 + a1[1];
    *(_QWORD *)&v52 = v15;
    *((_QWORD *)&v52 + 1) = v16 - (_QWORD)v15;
    v17 = re::RigDataParser::parseWhitespace((uint64_t *)&v52);
    v19 = &v17[v18];
    v20 = (unint64_t)&v17[v18] < v16;
    v21 = (_anonymous_namespace_ *)strncmp(&v17[v18], "[", v20);
    if ((_DWORD)v21 || str_8[v20])
    {
      v50 = 0;
      v51 = 0;
      v22 = a1[1];
      if (v22)
        v23 = v22 + 1;
      else
        v23 = 0;
      v49 = 0;
      re::DynamicString::setCapacity(&v48, v23);
      re::DynamicString::operator=((re::DynamicString *)&v48, (uint64_t)a1);
      if ((v49 & 1) != 0)
        v24 = v50;
      else
        v24 = (char *)&v49 + 1;
      re::DynamicString::format((re::DynamicString *)"Unknown child attribute (expected array subscript): %s", (re::DynamicString *)&v52, v24);
    }
    else
    {
      v25 = *a1 + a1[1] - (_QWORD)&v19[v20];
      *(_QWORD *)&v52 = &v19[v20];
      *((_QWORD *)&v52 + 1) = v25;
      v26 = re::RigDataParser::parseNumeric((uint64_t *)&v52);
      if (v27)
      {
        v28 = v26;
        v29 = v27;
        v30 = *a1 + a1[1];
        *(_QWORD *)&v52 = &v26[v27];
        *((_QWORD *)&v52 + 1) = v30 - (_QWORD)&v26[v27];
        v31 = re::RigDataParser::parseWhitespace((uint64_t *)&v52);
        v33 = &v31[v32];
        v34 = (unint64_t)&v31[v32] < v30;
        v35 = (_anonymous_namespace_ *)strncmp(&v31[v32], "]", v34);
        if ((_DWORD)v35 || str_1_9[v34])
        {
          v50 = 0;
          v51 = 0;
          v36 = a1[1];
          if (v36)
            v37 = v36 + 1;
          else
            v37 = 0;
          v49 = 0;
          re::DynamicString::setCapacity(&v48, v37);
          re::DynamicString::operator=((re::DynamicString *)&v48, (uint64_t)a1);
          if ((v49 & 1) != 0)
            v38 = v50;
          else
            v38 = (char *)&v49 + 1;
          re::DynamicString::format((re::DynamicString *)"Unknown child attribute (expected array subscript end): %s", (re::DynamicString *)&v52, v38);
        }
        else
        {
          v42 = &v33[v34];
          v43 = (char *)(*a1 + a1[1]);
          *(_QWORD *)&v52 = v42;
          *((_QWORD *)&v52 + 1) = v43 - v42;
          result = re::RigDataParser::parseWhitespace((uint64_t *)&v52);
          if (&result[v44] == v43)
          {
            *(_BYTE *)a2 = 1;
            *(_QWORD *)(a2 + 8) = v28;
            *(_QWORD *)(a2 + 16) = v29;
            return result;
          }
          v50 = 0;
          v51 = 0;
          v45 = a1[1];
          if (v45)
            v46 = v45 + 1;
          else
            v46 = 0;
          v49 = 0;
          re::DynamicString::setCapacity(&v48, v46);
          re::DynamicString::operator=((re::DynamicString *)&v48, (uint64_t)a1);
          if ((v49 & 1) != 0)
            v47 = v50;
          else
            v47 = (char *)&v49 + 1;
          re::DynamicString::format((re::DynamicString *)"Unknown child attribute (expected only array value): %s", (re::DynamicString *)&v52, v47);
        }
      }
      else
      {
        v50 = 0;
        v51 = 0;
        v39 = a1[1];
        if (v39)
          v40 = v39 + 1;
        else
          v40 = 0;
        v49 = 0;
        re::DynamicString::setCapacity(&v48, v40);
        re::DynamicString::operator=((re::DynamicString *)&v48, (uint64_t)a1);
        if ((v49 & 1) != 0)
          v41 = v50;
        else
          v41 = (char *)&v49 + 1;
        re::DynamicString::format((re::DynamicString *)"Unknown child attribute (expected array index): %s", (re::DynamicString *)&v52, v41);
      }
    }
  }
  v11 = v52;
  v12 = v53;
  v13 = v54;
  *(_BYTE *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 5007;
  *(_QWORD *)(a2 + 16) = &re::AnimationErrorCategory(void)::instance;
  *(_OWORD *)(a2 + 24) = v11;
  *(_QWORD *)(a2 + 40) = v12;
  *(_QWORD *)(a2 + 48) = v13;
  result = (char *)v48;
  if (v48)
  {
    if ((v49 & 1) != 0)
      return (char *)(*(uint64_t (**)(void))(*v48 + 40))();
  }
  return result;
}

float re::RigDataParser::stringToFloat(unsigned __int8 **a1)
{
  uint64_t v1;
  unsigned __int8 *v2;
  int v3;
  unsigned __int8 *v4;
  float result;
  char *v6;
  char *v7;
  unsigned __int8 *v8;
  int v9;
  float v10;
  uint64_t v11;

  v1 = (uint64_t)*a1;
  v2 = a1[1];
  v3 = **a1;
  v4 = (unsigned __int8 *)(v3 == 45);
  result = 0.0;
  if (v2 != v4)
  {
    v6 = (char *)&v2[v1];
    v7 = (char *)&v4[v1];
    v8 = &v2[~(unint64_t)v4];
    while (1)
    {
      v9 = *v7;
      if (v9 == 46)
        break;
      result = (float)(result * 10.0) + (float)(v9 - 48);
      ++v7;
      --v8;
      if (v7 == v6)
        goto LABEL_9;
    }
    if (v7 + 1 != v6)
    {
      v10 = 1.0;
      v11 = 1;
      do
      {
        v10 = v10 * 0.1;
        result = result + (float)((float)(v7[v11++] - 48) * v10);
        --v8;
      }
      while (v8);
    }
  }
LABEL_9:
  if (v3 == 45)
    return -result;
  return result;
}

uint64_t *re::FixedArray<float>::operator=(uint64_t *result, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  BOOL v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (result != a2)
  {
    v2 = *result;
    v3 = *a2;
    if (*result)
      v4 = v2 == v3;
    else
      v4 = 1;
    if (v4)
    {
      *result = v3;
      *a2 = v2;
      v5 = result[1];
      v6 = result[2];
      v7 = a2[2];
      result[1] = a2[1];
      result[2] = v7;
      a2[1] = v5;
      a2[2] = v6;
    }
    else
    {
      re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) ", "!isInitialized() || m_allocator == other.m_allocator", "operator=", 296);
      result = (uint64_t *)_os_crash();
      __break(1u);
    }
  }
  return result;
}

double re::KeyframeAnimation<float>::totalDuration(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 88);
  if (v1)
    return *(float *)(*(_QWORD *)(a1 + 96) + 4 * v1 - 4);
  else
    return 0.0;
}

uint64_t re::KeyframeAnimation<float>::evaluateCore(uint64_t result, uint64_t a2, uint64_t a3, float *a4, uint64_t a5, float *a6)
{
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  float v10;
  float *v11;
  float v12;
  float *v13;
  unint64_t v14;
  unint64_t v15;
  float *v16;
  float *v17;
  float v18;
  unint64_t v19;
  unint64_t v20;
  float v21;
  float v22;
  float v23;

  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_36;
  }
  v6 = *(_QWORD *)(result + 88);
  v7 = *(_QWORD *)(result + 112);
  if (v6 >= v7)
    v8 = *(_QWORD *)(result + 112);
  else
    v8 = *(_QWORD *)(result + 88);
  v9 = v8 - 1;
  if (v8 == 1)
  {
    if (v7)
      goto LABEL_29;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    result = _os_crash_msg();
    __break(1u);
LABEL_10:
    if (v6)
    {
      if (v6 > v9)
      {
        v11 = *(float **)(result + 96);
        v12 = *(double *)(a2 + 24);
        if (*v11 < v12)
        {
          if (v11[v9] > v12)
          {
            v13 = *(float **)(result + 96);
            v14 = v6;
            do
            {
              v15 = v14 >> 1;
              v16 = &v13[v14 >> 1];
              v18 = *v16;
              v17 = v16 + 1;
              v14 += ~(v14 >> 1);
              if (v18 < v12)
                v13 = v17;
              else
                v14 = v15;
            }
            while (v14);
            v19 = v13 - v11;
            if (!*(_BYTE *)(result + 73) || v19 == v8)
            {
              if (v7 > v19)
              {
                v10 = *(float *)(*(_QWORD *)(result + 120) + 4 * v19);
                goto LABEL_30;
              }
LABEL_44:
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
            }
            v20 = v19 - 1;
            if (v6 > v19 - 1)
            {
              if (v6 > v19)
              {
                v21 = v11[v20];
                v22 = v11[v19] - v21;
                v23 = 0.0;
                if (v22 > 0.0)
                  v23 = (float)(v12 - v21) / v22;
                if (v7 > v20)
                {
                  if (v7 > v19)
                  {
                    v10 = (float)(v23 * *(float *)(*(_QWORD *)(result + 120) + 4 * v19))
                        + (float)(*(float *)(*(_QWORD *)(result + 120) + 4 * v20) * (float)(1.0 - v23));
                    goto LABEL_30;
                  }
                  goto LABEL_43;
                }
LABEL_42:
                os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
LABEL_43:
                os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
                goto LABEL_44;
              }
LABEL_41:
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
              goto LABEL_42;
            }
LABEL_40:
            os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
            goto LABEL_41;
          }
          if (v7 > v9)
          {
            v10 = *(float *)(*(_QWORD *)(result + 120) + 4 * v9);
            goto LABEL_30;
          }
LABEL_39:
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
          goto LABEL_40;
        }
        if (v7)
        {
LABEL_29:
          v10 = **(float **)(result + 120);
          goto LABEL_30;
        }
LABEL_38:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_39;
      }
LABEL_37:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_38;
    }
LABEL_36:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_37;
  }
  if (v8)
    goto LABEL_10;
  v10 = *a4;
LABEL_30:
  *a6 = v10;
  return result;
}

double re::KeyframeAnimation<double>::totalDuration(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 88);
  if (v1)
    return *(float *)(*(_QWORD *)(a1 + 96) + 4 * v1 - 4);
  else
    return 0.0;
}

uint64_t re::KeyframeAnimation<double>::evaluateCore(uint64_t result, uint64_t a2, uint64_t a3, double *a4, uint64_t a5, double *a6)
{
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  double v10;
  float *v11;
  float v12;
  float *v13;
  unint64_t v14;
  unint64_t v15;
  float *v16;
  float *v17;
  float v18;
  unint64_t v19;
  unint64_t v20;
  float v21;
  float v22;
  float v23;

  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_36;
  }
  v6 = *(_QWORD *)(result + 88);
  v7 = *(_QWORD *)(result + 112);
  if (v6 >= v7)
    v8 = *(_QWORD *)(result + 112);
  else
    v8 = *(_QWORD *)(result + 88);
  v9 = v8 - 1;
  if (v8 == 1)
  {
    if (v7)
      goto LABEL_29;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    result = _os_crash_msg();
    __break(1u);
LABEL_10:
    if (v6)
    {
      if (v6 > v9)
      {
        v11 = *(float **)(result + 96);
        v12 = *(double *)(a2 + 24);
        if (*v11 < v12)
        {
          if (v11[v9] > v12)
          {
            v13 = *(float **)(result + 96);
            v14 = v6;
            do
            {
              v15 = v14 >> 1;
              v16 = &v13[v14 >> 1];
              v18 = *v16;
              v17 = v16 + 1;
              v14 += ~(v14 >> 1);
              if (v18 < v12)
                v13 = v17;
              else
                v14 = v15;
            }
            while (v14);
            v19 = v13 - v11;
            if (!*(_BYTE *)(result + 73) || v19 == v8)
            {
              if (v7 > v19)
              {
                v10 = *(double *)(*(_QWORD *)(result + 120) + 8 * v19);
                goto LABEL_30;
              }
LABEL_44:
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
            }
            v20 = v19 - 1;
            if (v6 > v19 - 1)
            {
              if (v6 > v19)
              {
                v21 = v11[v20];
                v22 = v11[v19] - v21;
                v23 = 0.0;
                if (v22 > 0.0)
                  v23 = (float)(v12 - v21) / v22;
                if (v7 > v20)
                {
                  if (v7 > v19)
                  {
                    v10 = *(double *)(*(_QWORD *)(result + 120) + 8 * v19) * v23
                        + *(double *)(*(_QWORD *)(result + 120) + 8 * v20) * (float)(1.0 - v23);
                    goto LABEL_30;
                  }
                  goto LABEL_43;
                }
LABEL_42:
                os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
LABEL_43:
                os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
                goto LABEL_44;
              }
LABEL_41:
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
              goto LABEL_42;
            }
LABEL_40:
            os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
            goto LABEL_41;
          }
          if (v7 > v9)
          {
            v10 = *(double *)(*(_QWORD *)(result + 120) + 8 * v9);
            goto LABEL_30;
          }
LABEL_39:
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
          goto LABEL_40;
        }
        if (v7)
        {
LABEL_29:
          v10 = **(double **)(result + 120);
          goto LABEL_30;
        }
LABEL_38:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_39;
      }
LABEL_37:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_38;
    }
LABEL_36:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_37;
  }
  if (v8)
    goto LABEL_10;
  v10 = *a4;
LABEL_30:
  *a6 = v10;
  return result;
}

double re::KeyframeAnimation<re::Vector2<float>>::totalDuration(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 88);
  if (v1)
    return *(float *)(*(_QWORD *)(a1 + 96) + 4 * v1 - 4);
  else
    return 0.0;
}

uint64_t re::KeyframeAnimation<re::Vector2<float>>::evaluateCore(uint64_t result, uint64_t a2, uint64_t a3, float32x2_t *a4, uint64_t a5, float32x2_t *a6)
{
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  float32x2_t v10;
  float *v11;
  float v12;
  float *v13;
  unint64_t v14;
  unint64_t v15;
  float *v16;
  float *v17;
  float v18;
  unint64_t v19;
  unint64_t v20;
  float v21;
  float v22;
  float v23;

  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_37;
  }
  v6 = *(_QWORD *)(result + 88);
  v7 = *(_QWORD *)(result + 112);
  if (v6 >= v7)
    v8 = *(_QWORD *)(result + 112);
  else
    v8 = *(_QWORD *)(result + 88);
  v9 = v8 - 1;
  if (v8 == 1)
  {
    if (v7)
      goto LABEL_29;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    result = _os_crash_msg();
    __break(1u);
LABEL_10:
    if (v6)
    {
      if (v6 > v9)
      {
        v11 = *(float **)(result + 96);
        v12 = *(double *)(a2 + 24);
        if (*v11 < v12)
        {
          if (v11[v9] > v12)
          {
            v13 = *(float **)(result + 96);
            v14 = v6;
            do
            {
              v15 = v14 >> 1;
              v16 = &v13[v14 >> 1];
              v18 = *v16;
              v17 = v16 + 1;
              v14 += ~(v14 >> 1);
              if (v18 < v12)
                v13 = v17;
              else
                v14 = v15;
            }
            while (v14);
            v19 = v13 - v11;
            if (!*(_BYTE *)(result + 73) || v19 == v8)
            {
              if (v7 > v19)
              {
                v10 = *(float32x2_t *)(*(_QWORD *)(result + 120) + 8 * v19);
                goto LABEL_30;
              }
LABEL_45:
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
            }
            v20 = v19 - 1;
            if (v6 > v19 - 1)
            {
              if (v6 > v19)
              {
                v21 = v11[v20];
                v22 = v11[v19] - v21;
                v23 = 0.0;
                if (v22 > 0.0)
                  v23 = (float)(v12 - v21) / v22;
                if (v7 > v20)
                {
                  if (v7 > v19)
                  {
                    *a6 = vadd_f32(vmul_n_f32(*(float32x2_t *)(*(_QWORD *)(result + 120) + 8 * v20), 1.0 - v23), vmul_n_f32(*(float32x2_t *)(*(_QWORD *)(result + 120) + 8 * v19), v23));
                    return result;
                  }
                  goto LABEL_44;
                }
LABEL_43:
                os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
LABEL_44:
                os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
                goto LABEL_45;
              }
LABEL_42:
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
              goto LABEL_43;
            }
LABEL_41:
            os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
            goto LABEL_42;
          }
          if (v7 > v9)
          {
            v10 = *(float32x2_t *)(*(_QWORD *)(result + 120) + 8 * v9);
            goto LABEL_30;
          }
LABEL_40:
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
          goto LABEL_41;
        }
        if (v7)
        {
LABEL_29:
          v10 = **(float32x2_t **)(result + 120);
          goto LABEL_30;
        }
LABEL_39:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_40;
      }
LABEL_38:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_39;
    }
LABEL_37:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_38;
  }
  if (v8)
    goto LABEL_10;
  v10 = *a4;
LABEL_30:
  *a6 = v10;
  return result;
}

double re::KeyframeAnimation<re::Vector3<float>>::totalDuration(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 88);
  if (v1)
    return *(float *)(*(_QWORD *)(a1 + 96) + 4 * v1 - 4);
  else
    return 0.0;
}

uint64_t re::KeyframeAnimation<re::Vector3<float>>::evaluateCore(uint64_t result, uint64_t a2, uint64_t a3, float32x4_t *a4, uint64_t a5, float32x4_t *a6)
{
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  float32x4_t v10;
  float *v11;
  float v12;
  float *v13;
  unint64_t v14;
  unint64_t v15;
  float *v16;
  float *v17;
  float v18;
  unint64_t v19;
  unint64_t v20;
  float v21;
  float v22;
  float v23;

  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_37;
  }
  v6 = *(_QWORD *)(result + 88);
  v7 = *(_QWORD *)(result + 112);
  if (v6 >= v7)
    v8 = *(_QWORD *)(result + 112);
  else
    v8 = *(_QWORD *)(result + 88);
  v9 = v8 - 1;
  if (v8 == 1)
  {
    if (v7)
      goto LABEL_29;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    result = _os_crash_msg();
    __break(1u);
LABEL_10:
    if (v6)
    {
      if (v6 > v9)
      {
        v11 = *(float **)(result + 96);
        v12 = *(double *)(a2 + 24);
        if (*v11 < v12)
        {
          if (v11[v9] > v12)
          {
            v13 = *(float **)(result + 96);
            v14 = v6;
            do
            {
              v15 = v14 >> 1;
              v16 = &v13[v14 >> 1];
              v18 = *v16;
              v17 = v16 + 1;
              v14 += ~(v14 >> 1);
              if (v18 < v12)
                v13 = v17;
              else
                v14 = v15;
            }
            while (v14);
            v19 = v13 - v11;
            if (!*(_BYTE *)(result + 73) || v19 == v8)
            {
              if (v7 > v19)
              {
                v10 = *(float32x4_t *)(*(_QWORD *)(result + 120) + 16 * v19);
                goto LABEL_30;
              }
              goto LABEL_44;
            }
            v20 = v19 - 1;
            if (v6 > v19 - 1)
            {
              if (v6 > v19)
              {
                v21 = v11[v20];
                v22 = v11[v19] - v21;
                v23 = 0.0;
                if (v22 > 0.0)
                  v23 = (float)(v12 - v21) / v22;
                if (v7 > v20)
                {
                  if (v7 > v19)
                  {
                    *a6 = vmlaq_n_f32(vmulq_n_f32(*(float32x4_t *)(*(_QWORD *)(result + 120) + 16 * v19), v23), *(float32x4_t *)(*(_QWORD *)(result + 120) + 16 * v20), 1.0 - v23);
                    return result;
                  }
LABEL_45:
                  os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
                  _os_log_send_and_compose_impl();
                  _os_crash_msg();
                  __break(1u);
                }
                goto LABEL_43;
              }
LABEL_42:
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_43:
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_44:
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
              goto LABEL_45;
            }
LABEL_41:
            os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
            goto LABEL_42;
          }
          if (v7 > v9)
          {
            v10 = *(float32x4_t *)(*(_QWORD *)(result + 120) + 16 * v9);
            goto LABEL_30;
          }
LABEL_40:
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
          goto LABEL_41;
        }
        if (v7)
        {
LABEL_29:
          v10 = *(float32x4_t *)*(_QWORD *)(result + 120);
          goto LABEL_30;
        }
LABEL_39:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_40;
      }
LABEL_38:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_39;
    }
LABEL_37:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_38;
  }
  if (v8)
    goto LABEL_10;
  v10 = *a4;
LABEL_30:
  *a6 = v10;
  return result;
}

double re::KeyframeAnimation<re::Vector4<float>>::totalDuration(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 88);
  if (v1)
    return *(float *)(*(_QWORD *)(a1 + 96) + 4 * v1 - 4);
  else
    return 0.0;
}

uint64_t re::KeyframeAnimation<re::Vector4<float>>::evaluateCore(uint64_t result, uint64_t a2, uint64_t a3, float32x4_t *a4, uint64_t a5, float32x4_t *a6)
{
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  float32x4_t v10;
  float *v11;
  float v12;
  float *v13;
  unint64_t v14;
  unint64_t v15;
  float *v16;
  float *v17;
  float v18;
  unint64_t v19;
  unint64_t v20;
  float v21;
  float v22;
  float v23;

  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_36;
  }
  v6 = *(_QWORD *)(result + 88);
  v7 = *(_QWORD *)(result + 112);
  if (v6 >= v7)
    v8 = *(_QWORD *)(result + 112);
  else
    v8 = *(_QWORD *)(result + 88);
  v9 = v8 - 1;
  if (v8 == 1)
  {
    if (v7)
      goto LABEL_29;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    result = _os_crash_msg();
    __break(1u);
LABEL_10:
    if (v6)
    {
      if (v6 > v9)
      {
        v11 = *(float **)(result + 96);
        v12 = *(double *)(a2 + 24);
        if (*v11 < v12)
        {
          if (v11[v9] > v12)
          {
            v13 = *(float **)(result + 96);
            v14 = v6;
            do
            {
              v15 = v14 >> 1;
              v16 = &v13[v14 >> 1];
              v18 = *v16;
              v17 = v16 + 1;
              v14 += ~(v14 >> 1);
              if (v18 < v12)
                v13 = v17;
              else
                v14 = v15;
            }
            while (v14);
            v19 = v13 - v11;
            if (!*(_BYTE *)(result + 73) || v19 == v8)
            {
              if (v7 > v19)
              {
                v10 = *(float32x4_t *)(*(_QWORD *)(result + 120) + 16 * v19);
                goto LABEL_30;
              }
              goto LABEL_42;
            }
            v20 = v19 - 1;
            if (v6 > v19 - 1)
            {
              if (v6 > v19)
              {
                v21 = v11[v20];
                v22 = v11[v19] - v21;
                v23 = 0.0;
                if (v22 > 0.0)
                  v23 = (float)(v12 - v21) / v22;
                if (v7 > v20)
                {
                  if (v7 > v19)
                  {
                    v10 = vaddq_f32(vmulq_n_f32(*(float32x4_t *)(*(_QWORD *)(result + 120) + 16 * v20), 1.0 - v23), vmulq_n_f32(*(float32x4_t *)(*(_QWORD *)(result + 120) + 16 * v19), v23));
                    goto LABEL_30;
                  }
LABEL_44:
                  os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
                  _os_log_send_and_compose_impl();
                  _os_crash_msg();
                  __break(1u);
                }
LABEL_43:
                os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
                goto LABEL_44;
              }
              goto LABEL_41;
            }
LABEL_40:
            os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_41:
            os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_42:
            os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
            goto LABEL_43;
          }
          if (v7 > v9)
          {
            v10 = *(float32x4_t *)(*(_QWORD *)(result + 120) + 16 * v9);
            goto LABEL_30;
          }
LABEL_39:
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
          goto LABEL_40;
        }
        if (v7)
        {
LABEL_29:
          v10 = *(float32x4_t *)*(_QWORD *)(result + 120);
          goto LABEL_30;
        }
LABEL_38:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_39;
      }
LABEL_37:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_38;
    }
LABEL_36:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_37;
  }
  if (v8)
    goto LABEL_10;
  v10 = *a4;
LABEL_30:
  *a6 = v10;
  return result;
}

double re::KeyframeAnimation<re::Quaternion<float>>::totalDuration(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 88);
  if (v1)
    return *(float *)(*(_QWORD *)(a1 + 96) + 4 * v1 - 4);
  else
    return 0.0;
}

void re::KeyframeAnimation<re::Quaternion<float>>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4, uint64_t a5, uint64_t *a6)
{
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  __int128 v10;
  float *v11;
  float v12;
  float *v13;
  unint64_t v14;
  unint64_t v15;
  float *v16;
  float *v17;
  float v18;
  unint64_t v19;
  unint64_t v20;
  float v21;
  float v22;
  float v23;

  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_36;
  }
  v6 = *(_QWORD *)(a1 + 88);
  v7 = *(_QWORD *)(a1 + 112);
  if (v6 >= v7)
    v8 = *(_QWORD *)(a1 + 112);
  else
    v8 = *(_QWORD *)(a1 + 88);
  v9 = v8 - 1;
  if (v8 == 1)
  {
    if (v7)
      goto LABEL_29;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    a1 = _os_crash_msg();
    __break(1u);
LABEL_10:
    if (v6)
    {
      if (v6 > v9)
      {
        v11 = *(float **)(a1 + 96);
        v12 = *(double *)(a2 + 24);
        if (*v11 < v12)
        {
          if (v11[v9] > v12)
          {
            v13 = *(float **)(a1 + 96);
            v14 = v6;
            do
            {
              v15 = v14 >> 1;
              v16 = &v13[v14 >> 1];
              v18 = *v16;
              v17 = v16 + 1;
              v14 += ~(v14 >> 1);
              if (v18 < v12)
                v13 = v17;
              else
                v14 = v15;
            }
            while (v14);
            v19 = v13 - v11;
            if (!*(_BYTE *)(a1 + 73) || v19 == v8)
            {
              if (v7 > v19)
              {
                v10 = *(_OWORD *)(*(_QWORD *)(a1 + 120) + 16 * v19);
                goto LABEL_30;
              }
LABEL_44:
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
            }
            v20 = v19 - 1;
            if (v6 > v19 - 1)
            {
              if (v6 > v19)
              {
                v21 = v11[v20];
                v22 = v11[v19] - v21;
                v23 = 0.0;
                if (v22 > 0.0)
                  v23 = (float)(v12 - v21) / v22;
                if (v7 > v20)
                {
                  if (v7 > v19)
                  {
                    re::AnimationValueTraits<re::Quaternion<float>>::interpolate((float32x4_t *)(*(_QWORD *)(a1 + 120) + 16 * v20), (float32x4_t *)(*(_QWORD *)(a1 + 120) + 16 * v19), a6, v23);
                    return;
                  }
                  goto LABEL_43;
                }
LABEL_42:
                os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
LABEL_43:
                os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
                goto LABEL_44;
              }
LABEL_41:
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
              goto LABEL_42;
            }
LABEL_40:
            os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
            goto LABEL_41;
          }
          if (v7 > v9)
          {
            v10 = *(_OWORD *)(*(_QWORD *)(a1 + 120) + 16 * v9);
            goto LABEL_30;
          }
LABEL_39:
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
          goto LABEL_40;
        }
        if (v7)
        {
LABEL_29:
          v10 = *(_OWORD *)*(_QWORD *)(a1 + 120);
          goto LABEL_30;
        }
LABEL_38:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_39;
      }
LABEL_37:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_38;
    }
LABEL_36:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_37;
  }
  if (v8)
    goto LABEL_10;
  v10 = *a4;
LABEL_30:
  *(_OWORD *)a6 = v10;
}

double re::KeyframeAnimation<re::GenericSRT<float>>::totalDuration(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 88);
  if (v1)
    return *(float *)(*(_QWORD *)(a1 + 96) + 4 * v1 - 4);
  else
    return 0.0;
}

void re::KeyframeAnimation<re::GenericSRT<float>>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4, uint64_t a5, uint64_t a6)
{
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  float *v14;
  float v15;
  float *v16;
  unint64_t v17;
  unint64_t v18;
  float *v19;
  float *v20;
  float v21;
  unint64_t v22;
  unint64_t v23;
  float v24;
  float v25;
  float v26;
  __int128 v27;
  __int128 *v28;
  float32x4_t v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
    goto LABEL_38;
  }
  v7 = *(_QWORD *)(a1 + 88);
  v8 = *(_QWORD *)(a1 + 112);
  if (v7 >= v8)
    v9 = *(_QWORD *)(a1 + 112);
  else
    v9 = *(_QWORD *)(a1 + 88);
  v10 = v9 - 1;
  if (v9 == 1)
  {
    if (v8)
      goto LABEL_29;
    v32 = 0u;
    v33 = 0u;
    v30 = 0u;
    v31 = 0u;
    v29 = 0u;
    a6 = MEMORY[0x24BDACB70];
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    a1 = _os_crash_msg();
    __break(1u);
LABEL_10:
    if (v7)
    {
      if (v7 > v10)
      {
        v14 = *(float **)(a1 + 96);
        v15 = *(double *)(a2 + 24);
        if (*v14 < v15)
        {
          if (v14[v10] > v15)
          {
            v16 = *(float **)(a1 + 96);
            v17 = v7;
            do
            {
              v18 = v17 >> 1;
              v19 = &v16[v17 >> 1];
              v21 = *v19;
              v20 = v19 + 1;
              v17 += ~(v17 >> 1);
              if (v21 < v15)
                v16 = v20;
              else
                v17 = v18;
            }
            while (v17);
            v22 = v16 - v14;
            if (*(_BYTE *)(a1 + 73) && v22 != v9)
            {
              v23 = v22 - 1;
              if (v7 > v22 - 1)
              {
                if (v7 > v22)
                {
                  v24 = v14[v23];
                  v25 = v14[v22] - v24;
                  v26 = 0.0;
                  if (v25 > 0.0)
                    v26 = (float)(v15 - v24) / v25;
                  if (v8 > v23)
                  {
                    if (v8 > v22)
                    {
                      re::lerp<float>((float32x4_t *)(*(_QWORD *)(a1 + 120) + 48 * v23), (float32x4_t *)(*(_QWORD *)(a1 + 120) + 48 * v22), &v29, v26);
                      v27 = v30;
                      *(float32x4_t *)a6 = v29;
                      *(_OWORD *)(a6 + 16) = v27;
                      *(_OWORD *)(a6 + 32) = v31;
                      return;
                    }
LABEL_46:
                    v32 = 0u;
                    v33 = 0u;
                    v30 = 0u;
                    v31 = 0u;
                    v29 = 0u;
                    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
                    _os_log_send_and_compose_impl();
                    _os_crash_msg();
                    __break(1u);
                  }
LABEL_45:
                  v32 = 0u;
                  v33 = 0u;
                  v30 = 0u;
                  v31 = 0u;
                  v29 = 0u;
                  os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
                  _os_log_send_and_compose_impl();
                  _os_crash_msg();
                  __break(1u);
                  goto LABEL_46;
                }
                goto LABEL_43;
              }
LABEL_42:
              v32 = 0u;
              v33 = 0u;
              v30 = 0u;
              v31 = 0u;
              v29 = 0u;
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_43:
              v32 = 0u;
              v33 = 0u;
              v30 = 0u;
              v31 = 0u;
              v29 = 0u;
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
              goto LABEL_44;
            }
            if (v8 <= v22)
            {
LABEL_44:
              v32 = 0u;
              v33 = 0u;
              v30 = 0u;
              v31 = 0u;
              v29 = 0u;
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
              goto LABEL_45;
            }
            v28 = (__int128 *)(*(_QWORD *)(a1 + 120) + 48 * v22);
LABEL_30:
            v11 = *v28;
            v12 = v28[1];
            v13 = v28[2];
            goto LABEL_31;
          }
          if (v8 > v10)
          {
            v28 = (__int128 *)(*(_QWORD *)(a1 + 120) + 48 * v10);
            goto LABEL_30;
          }
LABEL_41:
          v32 = 0u;
          v33 = 0u;
          v30 = 0u;
          v31 = 0u;
          v29 = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
          goto LABEL_42;
        }
        if (v8)
        {
LABEL_29:
          v28 = *(__int128 **)(a1 + 120);
          goto LABEL_30;
        }
LABEL_40:
        v32 = 0u;
        v33 = 0u;
        v30 = 0u;
        v31 = 0u;
        v29 = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_41;
      }
LABEL_39:
      v32 = 0u;
      v33 = 0u;
      v30 = 0u;
      v31 = 0u;
      v29 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_40;
    }
LABEL_38:
    v32 = 0u;
    v33 = 0u;
    v30 = 0u;
    v31 = 0u;
    v29 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_39;
  }
  if (v9)
    goto LABEL_10;
  v11 = *a4;
  v12 = a4[1];
  v13 = a4[2];
LABEL_31:
  *(_OWORD *)(a6 + 16) = v12;
  *(_OWORD *)(a6 + 32) = v13;
  *(_OWORD *)a6 = v11;
}

double re::KeyframeAnimation<re::SkeletalPose>::totalDuration(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 88);
  if (v1)
    return *(float *)(*(_QWORD *)(a1 + 96) + 4 * v1 - 4);
  else
    return 0.0;
}

void re::KeyframeAnimation<re::SkeletalPose>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4, int a5, _QWORD *a6)
{
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  float *v11;
  float v12;
  float *v13;
  unint64_t v14;
  unint64_t v15;
  float *v16;
  float *v17;
  float v18;
  unint64_t v19;
  unint64_t v20;
  float v21;
  float v22;
  float v23;

  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_36:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_37;
  }
  v6 = *(_QWORD *)(a1 + 88);
  v7 = *(_QWORD *)(a1 + 112);
  if (v6 >= v7)
    v8 = *(_QWORD *)(a1 + 112);
  else
    v8 = *(_QWORD *)(a1 + 88);
  v9 = v8 - 1;
  if (v8 == 1)
  {
    if (v7)
    {
LABEL_29:
      a4 = *(_QWORD **)(a1 + 120);
      goto LABEL_30;
    }
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    a1 = _os_crash_msg();
    __break(1u);
  }
  else if (!v8)
  {
    goto LABEL_30;
  }
  if (!v6)
    goto LABEL_36;
  if (v6 <= v9)
  {
LABEL_37:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_38;
  }
  v11 = *(float **)(a1 + 96);
  v12 = *(double *)(a2 + 24);
  if (*v11 >= v12)
  {
    if (v7)
      goto LABEL_29;
LABEL_38:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_39;
  }
  if (v11[v9] <= v12)
  {
    if (v7 > v9)
    {
      a4 = (_QWORD *)(*(_QWORD *)(a1 + 120) + 88 * v9);
      goto LABEL_30;
    }
LABEL_39:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_40;
  }
  v13 = *(float **)(a1 + 96);
  v14 = v6;
  do
  {
    v15 = v14 >> 1;
    v16 = &v13[v14 >> 1];
    v18 = *v16;
    v17 = v16 + 1;
    v14 += ~(v14 >> 1);
    if (v18 < v12)
      v13 = v17;
    else
      v14 = v15;
  }
  while (v14);
  v19 = v13 - v11;
  if (*(_BYTE *)(a1 + 73) && v19 != v8)
  {
    v20 = v19 - 1;
    if (v6 > v19 - 1)
    {
      if (v6 > v19)
      {
        v21 = v11[v20];
        v22 = v11[v19] - v21;
        v23 = 0.0;
        if (v22 > 0.0)
          v23 = (float)(v12 - v21) / v22;
        if (v7 > v20)
        {
          if (v7 > v19)
          {
            re::AnimationValueTraits<re::SkeletalPose>::interpolate((_QWORD *)(*(_QWORD *)(a1 + 120) + 88 * v20), (_QWORD *)(*(_QWORD *)(a1 + 120) + 88 * v19), a6, v23);
            return;
          }
          goto LABEL_43;
        }
LABEL_42:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_43:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_44:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
LABEL_41:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_42;
    }
LABEL_40:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_41;
  }
  if (v7 <= v19)
    goto LABEL_44;
  a4 = (_QWORD *)(*(_QWORD *)(a1 + 120) + 88 * v19);
LABEL_30:
  re::AnimationValueTraits<re::SkeletalPose>::copy(a4, a6);
}

double re::KeyframeAnimation<re::BlendShapeWeights>::totalDuration(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 88);
  if (v1)
    return *(float *)(*(_QWORD *)(a1 + 96) + 4 * v1 - 4);
  else
    return 0.0;
}

uint64_t *re::KeyframeAnimation<re::BlendShapeWeights>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, int a5, uint64_t *a6)
{
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  float *v11;
  float v12;
  float *v13;
  unint64_t v14;
  unint64_t v15;
  float *v16;
  float *v17;
  float v18;
  unint64_t v19;
  unint64_t v20;
  float v21;
  float v22;
  float v23;

  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_36:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_37;
  }
  v6 = *(_QWORD *)(a1 + 88);
  v7 = *(_QWORD *)(a1 + 112);
  if (v6 >= v7)
    v8 = *(_QWORD *)(a1 + 112);
  else
    v8 = *(_QWORD *)(a1 + 88);
  v9 = v8 - 1;
  if (v8 == 1)
  {
    if (v7)
    {
LABEL_29:
      a4 = *(uint64_t **)(a1 + 120);
      return re::AnimationValueTraits<re::BlendShapeWeights>::copy(a4, a6);
    }
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    a1 = _os_crash_msg();
    __break(1u);
  }
  else if (!v8)
  {
    return re::AnimationValueTraits<re::BlendShapeWeights>::copy(a4, a6);
  }
  if (!v6)
    goto LABEL_36;
  if (v6 <= v9)
  {
LABEL_37:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_38;
  }
  v11 = *(float **)(a1 + 96);
  v12 = *(double *)(a2 + 24);
  if (*v11 >= v12)
  {
    if (v7)
      goto LABEL_29;
LABEL_38:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_39;
  }
  if (v11[v9] <= v12)
  {
    if (v7 > v9)
    {
      a4 = (uint64_t *)(*(_QWORD *)(a1 + 120) + 32 * v9);
      return re::AnimationValueTraits<re::BlendShapeWeights>::copy(a4, a6);
    }
LABEL_39:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_40;
  }
  v13 = *(float **)(a1 + 96);
  v14 = v6;
  do
  {
    v15 = v14 >> 1;
    v16 = &v13[v14 >> 1];
    v18 = *v16;
    v17 = v16 + 1;
    v14 += ~(v14 >> 1);
    if (v18 < v12)
      v13 = v17;
    else
      v14 = v15;
  }
  while (v14);
  v19 = v13 - v11;
  if (*(_BYTE *)(a1 + 73) && v19 != v8)
  {
    v20 = v19 - 1;
    if (v6 > v19 - 1)
    {
      if (v6 > v19)
      {
        v21 = v11[v20];
        v22 = v11[v19] - v21;
        v23 = 0.0;
        if (v22 > 0.0)
          v23 = (float)(v12 - v21) / v22;
        if (v7 > v20)
        {
          if (v7 > v19)
            return (uint64_t *)re::AnimationValueTraits<re::BlendShapeWeights>::interpolate((_anonymous_namespace_ *)(*(_QWORD *)(a1 + 120) + 32 * v20), (_QWORD *)(*(_QWORD *)(a1 + 120) + 32 * v19), a6, v23);
          goto LABEL_43;
        }
LABEL_42:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_43:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_44:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
LABEL_41:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_42;
    }
LABEL_40:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_41;
  }
  if (v7 <= v19)
    goto LABEL_44;
  a4 = (uint64_t *)(*(_QWORD *)(a1 + 120) + 32 * v19);
  return re::AnimationValueTraits<re::BlendShapeWeights>::copy(a4, a6);
}

uint64_t re::KeyframeAnimation<float>::~KeyframeAnimation(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)a1 = off_24ED24950;
  v2 = *(_QWORD *)(a1 + 104);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 112))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 120));
      *(_QWORD *)(a1 + 112) = 0;
      *(_QWORD *)(a1 + 120) = 0;
    }
    *(_QWORD *)(a1 + 104) = 0;
  }
  v3 = *(_QWORD *)(a1 + 80);
  if (v3)
  {
    if (*(_QWORD *)(a1 + 88))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 96));
      *(_QWORD *)(a1 + 88) = 0;
      *(_QWORD *)(a1 + 96) = 0;
    }
    *(_QWORD *)(a1 + 80) = 0;
  }
  *(_QWORD *)a1 = off_24ED1F350;
  v4 = *(_QWORD *)(a1 + 40);
  if (v4)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, *(_QWORD *)(a1 + 56));
    *(_OWORD *)(a1 + 40) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  return a1;
}

void re::KeyframeAnimation<float>::~KeyframeAnimation(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)a1 = off_24ED24950;
  v2 = *(_QWORD *)(a1 + 104);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 112))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 120));
      *(_QWORD *)(a1 + 112) = 0;
      *(_QWORD *)(a1 + 120) = 0;
    }
    *(_QWORD *)(a1 + 104) = 0;
  }
  v3 = *(_QWORD *)(a1 + 80);
  if (v3)
  {
    if (*(_QWORD *)(a1 + 88))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 96));
      *(_QWORD *)(a1 + 88) = 0;
      *(_QWORD *)(a1 + 96) = 0;
    }
    *(_QWORD *)(a1 + 80) = 0;
  }
  *(_QWORD *)a1 = off_24ED1F350;
  v4 = *(_QWORD *)(a1 + 40);
  if (v4)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, *(_QWORD *)(a1 + 56));
    *(_OWORD *)(a1 + 40) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  JUMPOUT(0x2276933B8);
}

uint64_t re::KeyframeAnimation<double>::~KeyframeAnimation(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)a1 = off_24ED249D8;
  v2 = *(_QWORD *)(a1 + 104);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 112))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 120));
      *(_QWORD *)(a1 + 112) = 0;
      *(_QWORD *)(a1 + 120) = 0;
    }
    *(_QWORD *)(a1 + 104) = 0;
  }
  v3 = *(_QWORD *)(a1 + 80);
  if (v3)
  {
    if (*(_QWORD *)(a1 + 88))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 96));
      *(_QWORD *)(a1 + 88) = 0;
      *(_QWORD *)(a1 + 96) = 0;
    }
    *(_QWORD *)(a1 + 80) = 0;
  }
  *(_QWORD *)a1 = off_24ED1F350;
  v4 = *(_QWORD *)(a1 + 40);
  if (v4)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, *(_QWORD *)(a1 + 56));
    *(_OWORD *)(a1 + 40) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  return a1;
}

void re::KeyframeAnimation<double>::~KeyframeAnimation(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)a1 = off_24ED249D8;
  v2 = *(_QWORD *)(a1 + 104);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 112))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 120));
      *(_QWORD *)(a1 + 112) = 0;
      *(_QWORD *)(a1 + 120) = 0;
    }
    *(_QWORD *)(a1 + 104) = 0;
  }
  v3 = *(_QWORD *)(a1 + 80);
  if (v3)
  {
    if (*(_QWORD *)(a1 + 88))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 96));
      *(_QWORD *)(a1 + 88) = 0;
      *(_QWORD *)(a1 + 96) = 0;
    }
    *(_QWORD *)(a1 + 80) = 0;
  }
  *(_QWORD *)a1 = off_24ED1F350;
  v4 = *(_QWORD *)(a1 + 40);
  if (v4)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, *(_QWORD *)(a1 + 56));
    *(_OWORD *)(a1 + 40) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  JUMPOUT(0x2276933B8);
}

uint64_t re::KeyframeAnimation<re::Vector2<float>>::~KeyframeAnimation(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)a1 = off_24ED24A60;
  v2 = *(_QWORD *)(a1 + 104);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 112))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 120));
      *(_QWORD *)(a1 + 112) = 0;
      *(_QWORD *)(a1 + 120) = 0;
    }
    *(_QWORD *)(a1 + 104) = 0;
  }
  v3 = *(_QWORD *)(a1 + 80);
  if (v3)
  {
    if (*(_QWORD *)(a1 + 88))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 96));
      *(_QWORD *)(a1 + 88) = 0;
      *(_QWORD *)(a1 + 96) = 0;
    }
    *(_QWORD *)(a1 + 80) = 0;
  }
  *(_QWORD *)a1 = off_24ED1F350;
  v4 = *(_QWORD *)(a1 + 40);
  if (v4)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, *(_QWORD *)(a1 + 56));
    *(_OWORD *)(a1 + 40) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  return a1;
}

void re::KeyframeAnimation<re::Vector2<float>>::~KeyframeAnimation(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)a1 = off_24ED24A60;
  v2 = *(_QWORD *)(a1 + 104);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 112))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 120));
      *(_QWORD *)(a1 + 112) = 0;
      *(_QWORD *)(a1 + 120) = 0;
    }
    *(_QWORD *)(a1 + 104) = 0;
  }
  v3 = *(_QWORD *)(a1 + 80);
  if (v3)
  {
    if (*(_QWORD *)(a1 + 88))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 96));
      *(_QWORD *)(a1 + 88) = 0;
      *(_QWORD *)(a1 + 96) = 0;
    }
    *(_QWORD *)(a1 + 80) = 0;
  }
  *(_QWORD *)a1 = off_24ED1F350;
  v4 = *(_QWORD *)(a1 + 40);
  if (v4)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, *(_QWORD *)(a1 + 56));
    *(_OWORD *)(a1 + 40) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  JUMPOUT(0x2276933B8);
}

uint64_t re::KeyframeAnimation<re::Vector3<float>>::~KeyframeAnimation(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)a1 = off_24ED24AE8;
  v2 = *(_QWORD *)(a1 + 104);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 112))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 120));
      *(_QWORD *)(a1 + 112) = 0;
      *(_QWORD *)(a1 + 120) = 0;
    }
    *(_QWORD *)(a1 + 104) = 0;
  }
  v3 = *(_QWORD *)(a1 + 80);
  if (v3)
  {
    if (*(_QWORD *)(a1 + 88))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 96));
      *(_QWORD *)(a1 + 88) = 0;
      *(_QWORD *)(a1 + 96) = 0;
    }
    *(_QWORD *)(a1 + 80) = 0;
  }
  *(_QWORD *)a1 = off_24ED1F350;
  v4 = *(_QWORD *)(a1 + 40);
  if (v4)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, *(_QWORD *)(a1 + 56));
    *(_OWORD *)(a1 + 40) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  return a1;
}

void re::KeyframeAnimation<re::Vector3<float>>::~KeyframeAnimation(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)a1 = off_24ED24AE8;
  v2 = *(_QWORD *)(a1 + 104);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 112))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 120));
      *(_QWORD *)(a1 + 112) = 0;
      *(_QWORD *)(a1 + 120) = 0;
    }
    *(_QWORD *)(a1 + 104) = 0;
  }
  v3 = *(_QWORD *)(a1 + 80);
  if (v3)
  {
    if (*(_QWORD *)(a1 + 88))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 96));
      *(_QWORD *)(a1 + 88) = 0;
      *(_QWORD *)(a1 + 96) = 0;
    }
    *(_QWORD *)(a1 + 80) = 0;
  }
  *(_QWORD *)a1 = off_24ED1F350;
  v4 = *(_QWORD *)(a1 + 40);
  if (v4)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, *(_QWORD *)(a1 + 56));
    *(_OWORD *)(a1 + 40) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  JUMPOUT(0x2276933B8);
}

uint64_t re::KeyframeAnimation<re::Vector4<float>>::~KeyframeAnimation(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)a1 = off_24ED24B70;
  v2 = *(_QWORD *)(a1 + 104);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 112))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 120));
      *(_QWORD *)(a1 + 112) = 0;
      *(_QWORD *)(a1 + 120) = 0;
    }
    *(_QWORD *)(a1 + 104) = 0;
  }
  v3 = *(_QWORD *)(a1 + 80);
  if (v3)
  {
    if (*(_QWORD *)(a1 + 88))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 96));
      *(_QWORD *)(a1 + 88) = 0;
      *(_QWORD *)(a1 + 96) = 0;
    }
    *(_QWORD *)(a1 + 80) = 0;
  }
  *(_QWORD *)a1 = off_24ED1F350;
  v4 = *(_QWORD *)(a1 + 40);
  if (v4)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, *(_QWORD *)(a1 + 56));
    *(_OWORD *)(a1 + 40) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  return a1;
}

void re::KeyframeAnimation<re::Vector4<float>>::~KeyframeAnimation(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)a1 = off_24ED24B70;
  v2 = *(_QWORD *)(a1 + 104);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 112))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 120));
      *(_QWORD *)(a1 + 112) = 0;
      *(_QWORD *)(a1 + 120) = 0;
    }
    *(_QWORD *)(a1 + 104) = 0;
  }
  v3 = *(_QWORD *)(a1 + 80);
  if (v3)
  {
    if (*(_QWORD *)(a1 + 88))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 96));
      *(_QWORD *)(a1 + 88) = 0;
      *(_QWORD *)(a1 + 96) = 0;
    }
    *(_QWORD *)(a1 + 80) = 0;
  }
  *(_QWORD *)a1 = off_24ED1F350;
  v4 = *(_QWORD *)(a1 + 40);
  if (v4)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, *(_QWORD *)(a1 + 56));
    *(_OWORD *)(a1 + 40) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  JUMPOUT(0x2276933B8);
}

uint64_t re::KeyframeAnimation<re::Quaternion<float>>::~KeyframeAnimation(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)a1 = off_24ED24BF8;
  v2 = *(_QWORD *)(a1 + 104);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 112))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 120));
      *(_QWORD *)(a1 + 112) = 0;
      *(_QWORD *)(a1 + 120) = 0;
    }
    *(_QWORD *)(a1 + 104) = 0;
  }
  v3 = *(_QWORD *)(a1 + 80);
  if (v3)
  {
    if (*(_QWORD *)(a1 + 88))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 96));
      *(_QWORD *)(a1 + 88) = 0;
      *(_QWORD *)(a1 + 96) = 0;
    }
    *(_QWORD *)(a1 + 80) = 0;
  }
  *(_QWORD *)a1 = off_24ED1F350;
  v4 = *(_QWORD *)(a1 + 40);
  if (v4)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, *(_QWORD *)(a1 + 56));
    *(_OWORD *)(a1 + 40) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  return a1;
}

void re::KeyframeAnimation<re::Quaternion<float>>::~KeyframeAnimation(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)a1 = off_24ED24BF8;
  v2 = *(_QWORD *)(a1 + 104);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 112))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 120));
      *(_QWORD *)(a1 + 112) = 0;
      *(_QWORD *)(a1 + 120) = 0;
    }
    *(_QWORD *)(a1 + 104) = 0;
  }
  v3 = *(_QWORD *)(a1 + 80);
  if (v3)
  {
    if (*(_QWORD *)(a1 + 88))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 96));
      *(_QWORD *)(a1 + 88) = 0;
      *(_QWORD *)(a1 + 96) = 0;
    }
    *(_QWORD *)(a1 + 80) = 0;
  }
  *(_QWORD *)a1 = off_24ED1F350;
  v4 = *(_QWORD *)(a1 + 40);
  if (v4)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, *(_QWORD *)(a1 + 56));
    *(_OWORD *)(a1 + 40) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  JUMPOUT(0x2276933B8);
}

uint64_t re::KeyframeAnimation<re::GenericSRT<float>>::~KeyframeAnimation(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)a1 = off_24ED24C80;
  v2 = *(_QWORD *)(a1 + 104);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 112))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 120));
      *(_QWORD *)(a1 + 112) = 0;
      *(_QWORD *)(a1 + 120) = 0;
    }
    *(_QWORD *)(a1 + 104) = 0;
  }
  v3 = *(_QWORD *)(a1 + 80);
  if (v3)
  {
    if (*(_QWORD *)(a1 + 88))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 96));
      *(_QWORD *)(a1 + 88) = 0;
      *(_QWORD *)(a1 + 96) = 0;
    }
    *(_QWORD *)(a1 + 80) = 0;
  }
  *(_QWORD *)a1 = off_24ED1F350;
  v4 = *(_QWORD *)(a1 + 40);
  if (v4)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, *(_QWORD *)(a1 + 56));
    *(_OWORD *)(a1 + 40) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  return a1;
}

void re::KeyframeAnimation<re::GenericSRT<float>>::~KeyframeAnimation(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)a1 = off_24ED24C80;
  v2 = *(_QWORD *)(a1 + 104);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 112))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 120));
      *(_QWORD *)(a1 + 112) = 0;
      *(_QWORD *)(a1 + 120) = 0;
    }
    *(_QWORD *)(a1 + 104) = 0;
  }
  v3 = *(_QWORD *)(a1 + 80);
  if (v3)
  {
    if (*(_QWORD *)(a1 + 88))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 96));
      *(_QWORD *)(a1 + 88) = 0;
      *(_QWORD *)(a1 + 96) = 0;
    }
    *(_QWORD *)(a1 + 80) = 0;
  }
  *(_QWORD *)a1 = off_24ED1F350;
  v4 = *(_QWORD *)(a1 + 40);
  if (v4)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, *(_QWORD *)(a1 + 56));
    *(_OWORD *)(a1 + 40) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  JUMPOUT(0x2276933B8);
}

uint64_t re::KeyframeAnimation<re::SkeletalPose>::~KeyframeAnimation(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)a1 = off_24ED24D08;
  re::FixedArray<re::SkeletalPose>::deinit((_QWORD *)(a1 + 104));
  v2 = *(_QWORD *)(a1 + 80);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 88))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 96));
      *(_QWORD *)(a1 + 88) = 0;
      *(_QWORD *)(a1 + 96) = 0;
    }
    *(_QWORD *)(a1 + 80) = 0;
  }
  *(_QWORD *)a1 = off_24ED1F350;
  v3 = *(_QWORD *)(a1 + 40);
  if (v3)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 56));
    *(_OWORD *)(a1 + 40) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  return a1;
}

void re::KeyframeAnimation<re::SkeletalPose>::~KeyframeAnimation(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)a1 = off_24ED24D08;
  re::FixedArray<re::SkeletalPose>::deinit((_QWORD *)(a1 + 104));
  v2 = *(_QWORD *)(a1 + 80);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 88))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 96));
      *(_QWORD *)(a1 + 88) = 0;
      *(_QWORD *)(a1 + 96) = 0;
    }
    *(_QWORD *)(a1 + 80) = 0;
  }
  *(_QWORD *)a1 = off_24ED1F350;
  v3 = *(_QWORD *)(a1 + 40);
  if (v3)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 56));
    *(_OWORD *)(a1 + 40) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  JUMPOUT(0x2276933B8);
}

uint64_t re::KeyframeAnimation<re::BlendShapeWeights>::~KeyframeAnimation(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)a1 = off_24ED24D90;
  re::FixedArray<re::BlendShapeWeights>::deinit((_QWORD *)(a1 + 104));
  v2 = *(_QWORD *)(a1 + 80);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 88))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 96));
      *(_QWORD *)(a1 + 88) = 0;
      *(_QWORD *)(a1 + 96) = 0;
    }
    *(_QWORD *)(a1 + 80) = 0;
  }
  *(_QWORD *)a1 = off_24ED1F350;
  v3 = *(_QWORD *)(a1 + 40);
  if (v3)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 56));
    *(_OWORD *)(a1 + 40) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  return a1;
}

void re::KeyframeAnimation<re::BlendShapeWeights>::~KeyframeAnimation(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)a1 = off_24ED24D90;
  re::FixedArray<re::BlendShapeWeights>::deinit((_QWORD *)(a1 + 104));
  v2 = *(_QWORD *)(a1 + 80);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 88))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 96));
      *(_QWORD *)(a1 + 88) = 0;
      *(_QWORD *)(a1 + 96) = 0;
    }
    *(_QWORD *)(a1 + 80) = 0;
  }
  *(_QWORD *)a1 = off_24ED1F350;
  v3 = *(_QWORD *)(a1 + 40);
  if (v3)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 56));
    *(_OWORD *)(a1 + 40) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  JUMPOUT(0x2276933B8);
}

BOOL re::TimelineEventData::addParameterDescription(_QWORD *a1, StringID *a2, int a3)
{
  uint64_t v6;
  re *v7;
  NSObject *v8;
  _BOOL8 result;
  char *var1;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint8_t buf[24];
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  v6 = (uint64_t)(a1 + 17);
  v7 = (re *)re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)(a1 + 17), a2);
  if (v7 && *((_QWORD *)v7 + 1))
  {
    v8 = *re::animationLogObjects(v7);
    result = os_log_type_enabled(v8, OS_LOG_TYPE_ERROR);
    if (result)
    {
      var1 = a2->var1;
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = var1;
      _os_log_error_impl(&dword_224FE9000, v8, OS_LOG_TYPE_ERROR, "Event parameter named %s was already declared.", buf, 0xCu);
      return 0;
    }
  }
  else
  {
    switch(a3)
    {
      case 1:
        *(_QWORD *)buf = a1[23];
        *(_QWORD *)&buf[8] = 1;
        re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::add(v6, a2, buf);
        if (a1[26])
        {
          re::internal::assertLog((re::internal *)4, v11, "assertion failure: '%s' (%s:line %i) Can not define additional parameters after adding events.", "parameters.isEmpty()", "addParameter", 30);
          _os_crash();
          __break(1u);
LABEL_21:
          re::internal::assertLog((re::internal *)4, v12, "assertion failure: '%s' (%s:line %i) Can not define additional parameters after adding events.", "parameters.isEmpty()", "addParameter", 30);
          _os_crash();
          __break(1u);
LABEL_22:
          re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Can not define additional parameters after adding events.", "parameters.isEmpty()", "addParameter", 30);
          _os_crash();
          __break(1u);
LABEL_23:
          re::internal::assertLog((re::internal *)4, v14, "assertion failure: '%s' (%s:line %i) Can not define additional parameters after adding events.", "parameters.isEmpty()", "addParameter", 30);
          _os_crash();
          __break(1u);
LABEL_24:
          re::internal::assertLog((re::internal *)4, v15, "assertion failure: '%s' (%s:line %i) Can not define additional parameters after adding events.", "parameters.isEmpty()", "addParameter", 30);
          _os_crash();
          __break(1u);
LABEL_25:
          re::internal::assertLog((re::internal *)4, v16, "assertion failure: '%s' (%s:line %i) Can not define additional parameters after adding events.", "parameters.isEmpty()", "addParameter", 30);
          _os_crash();
          __break(1u);
        }
        ++a1[23];
        break;
      case 2:
        *(_QWORD *)buf = a1[29];
        *(_QWORD *)&buf[8] = 2;
        re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::add(v6, a2, buf);
        if (a1[32])
          goto LABEL_21;
        ++a1[29];
        break;
      case 3:
        *(_QWORD *)buf = a1[35];
        *(_QWORD *)&buf[8] = 3;
        re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::add(v6, a2, buf);
        if (a1[38])
          goto LABEL_22;
        ++a1[35];
        break;
      case 4:
        *(_QWORD *)buf = a1[41];
        *(_QWORD *)&buf[8] = 4;
        re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::add(v6, a2, buf);
        if (a1[44])
          goto LABEL_23;
        ++a1[41];
        break;
      case 5:
        *(_QWORD *)buf = a1[47];
        *(_QWORD *)&buf[8] = 5;
        re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::add(v6, a2, buf);
        if (a1[50])
          goto LABEL_24;
        ++a1[47];
        break;
      case 6:
        *(_QWORD *)buf = a1[53];
        *(_QWORD *)&buf[8] = 6;
        re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::add(v6, a2, buf);
        if (a1[56])
          goto LABEL_25;
        ++a1[53];
        break;
      default:
        return 1;
    }
    return 1;
  }
  return result;
}

uint64_t re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::add(uint64_t a1, StringID *a2, _OWORD *a3)
{
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t result;

  v6 = 0xBF58476D1CE4E5B9 * ((*(_QWORD *)&a2->var0 >> 31) ^ (*(_QWORD *)&a2->var0 >> 1));
  v7 = (0x94D049BB133111EBLL * (v6 ^ (v6 >> 27))) ^ ((0x94D049BB133111EBLL * (v6 ^ (v6 >> 27))) >> 31);
  if (!*(_QWORD *)a1)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  v8 = v7 % *(unsigned int *)(a1 + 24);
  v9 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v8);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
LABEL_8:
    result = re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addAsCopy(a1, v8, v7, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    return result;
  }
  v10 = *(_QWORD *)(a1 + 16);
  while (1)
  {
    result = re::StringID::operator==((_QWORD *)(v10 + 40 * v9 + 8), a2);
    if ((result & 1) != 0)
      return result;
    v9 = *(_DWORD *)(v10 + 40 * v9) & 0x7FFFFFFF;
    if (v9 == 0x7FFFFFFF)
      goto LABEL_8;
  }
}

void re::TimelineEventData::addEvent(re::TimelineEventData *this, uint64_t a2)
{
  unint64_t v2;
  re::TimelineEventData *v4;
  unint64_t v5;
  unint64_t i;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _DWORD *v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  unint64_t j;
  unint64_t v37;
  uint64_t v38;
  re::TimelineEventData **v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t *v46;
  uint64_t v47;
  uint64_t *v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  unint64_t v52;
  uint64_t v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  uint64_t v58;
  _QWORD *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  void **v63;
  uint64_t v64;
  void **v65;
  void *v66;
  void *v67;
  void *v68;
  re::TimelineEventData *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  _BYTE v73[18];
  __int16 v74;
  unint64_t v75;
  __int16 v76;
  unint64_t v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  uint64_t v83;

  v4 = this;
  v83 = *MEMORY[0x24BDAC8D0];
  v5 = *((_QWORD *)this + 23);
  if (v5)
  {
    for (i = 0; i < v5; ++i)
    {
      LODWORD(v78) = 0;
      this = (re::TimelineEventData *)re::DynamicArray<float>::insert((_QWORD *)v4 + 24, i + v5 * a2, &v78);
      v5 = *((_QWORD *)v4 + 23);
    }
  }
  v7 = *((_QWORD *)v4 + 29);
  if (v7)
  {
    v8 = 0;
    v9 = *((_QWORD *)v4 + 32);
    while (1)
    {
      v10 = v8 + v7 * a2;
      v11 = v9 + 1;
      if (v9 + 1 <= v10)
        break;
      if (v9 >= *((_QWORD *)v4 + 31))
      {
        this = (re::TimelineEventData *)re::DynamicArray<float>::growCapacity((_QWORD *)v4 + 30, v9 + 1);
        v9 = *((_QWORD *)v4 + 32);
      }
      v12 = *((_QWORD *)v4 + 34);
      v13 = (_DWORD *)(v12 + 4 * v9);
      if (v9 > v10)
      {
        *v13 = *(v13 - 1);
        v14 = v12 + 4 * v10;
        if (v13 - 1 != (_DWORD *)v14)
        {
          this = (re::TimelineEventData *)memmove((void *)(v14 + 4), (const void *)v14, (size_t)v13 - v14 - 4);
          v12 = *((_QWORD *)v4 + 34);
          v9 = *((_QWORD *)v4 + 32);
        }
        v13 = (_DWORD *)(v12 + 4 * v10);
      }
      *v13 = 0;
      *((_QWORD *)v4 + 32) = ++v9;
      ++*((_DWORD *)v4 + 66);
      ++v8;
      v7 = *((_QWORD *)v4 + 29);
      if (v8 >= v7)
        goto LABEL_14;
    }
    v69 = 0;
    v81 = 0u;
    v82 = 0u;
    v79 = 0u;
    v80 = 0u;
    v78 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v73 = 136315906;
    *(_QWORD *)&v73[4] = "insert";
    *(_WORD *)&v73[12] = 1024;
    *(_DWORD *)&v73[14] = 887;
    v74 = 2048;
    v75 = v8 + a2 * v7;
    v76 = 2048;
    v77 = v11;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_77;
  }
LABEL_14:
  v15 = *((_QWORD *)v4 + 35);
  if (v15)
  {
    v8 = 0;
    v7 = (unint64_t)&str_110;
    while (1)
    {
      v2 = v15 * a2;
      v10 = v15 * a2 + v8;
      v16 = *((_QWORD *)v4 + 38);
      v11 = v16 + 1;
      if (v16 + 1 <= v10)
        break;
      if (v16 >= *((_QWORD *)v4 + 37))
      {
        re::DynamicArray<re::StringID>::growCapacity((_QWORD *)v4 + 36, v16 + 1);
        v16 = *((_QWORD *)v4 + 38);
      }
      v17 = (_QWORD *)(*((_QWORD *)v4 + 40) + 16 * v16);
      if (v16 <= v10)
      {
        *v17 = 0;
        v17[1] = &str_110;
        *(_QWORD *)v73 = 0;
        *(_QWORD *)&v73[8] = &str_110;
      }
      else
      {
        v18 = *(v17 - 1);
        *v17 = *(v17 - 2);
        v17[1] = v18;
        *(v17 - 2) = 0;
        *(v17 - 1) = &str_110;
        v19 = *((_QWORD *)v4 + 40);
        v20 = *((_QWORD *)v4 + 38);
        v21 = (uint64_t *)(v19 + 16 * v20 - 16);
        if (v21 != (uint64_t *)(v19 + 16 * v10))
        {
          v22 = 16 * (v8 + v2) - 16 * v20 + 16;
          v2 = v19 + 16 * v20 - 16;
          do
          {
            v23 = *(_QWORD *)(v2 - 16);
            v2 -= 16;
            v24 = *(v21 - 1);
            v25 = *v21;
            *(v21 - 1) = (uint64_t)&str_110;
            *(_QWORD *)v2 = 0;
            v26 = v21[1];
            v21[1] = v24;
            *(_QWORD *)&v78 = v23 & 0xFFFFFFFFFFFFFFFELL | v25 & 1;
            *((_QWORD *)&v78 + 1) = v26;
            *v21 = v23;
            re::StringID::destroyString((re::StringID *)&v78);
            v21 = (uint64_t *)v2;
            v22 += 16;
          }
          while (v22);
          v19 = *((_QWORD *)v4 + 40);
        }
        v27 = (_QWORD *)(v19 + 16 * v10);
        *(_QWORD *)v73 = 0;
        *(_QWORD *)&v73[8] = &str_110;
        v28 = v27[1];
        v29 = *v27 & 1;
        v27[1] = &str_110;
        *(_QWORD *)&v78 = v29;
        *((_QWORD *)&v78 + 1) = v28;
        *v27 = 0;
        re::StringID::destroyString((re::StringID *)&v78);
      }
      ++*((_QWORD *)v4 + 38);
      ++*((_DWORD *)v4 + 78);
      re::StringID::destroyString((re::StringID *)v73);
      ++v8;
      v15 = *((_QWORD *)v4 + 35);
      if (v8 >= v15)
        goto LABEL_27;
    }
LABEL_77:
    v69 = 0;
    v81 = 0u;
    v82 = 0u;
    v79 = 0u;
    v80 = 0u;
    v78 = 0u;
    a2 = MEMORY[0x24BDACB70];
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v73 = 136315906;
    *(_QWORD *)&v73[4] = "insert";
    *(_WORD *)&v73[12] = 1024;
    *(_DWORD *)&v73[14] = 887;
    v74 = 2048;
    v75 = v10;
    v76 = 2048;
    v77 = v11;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_78:
    v69 = 0;
    v81 = 0u;
    v82 = 0u;
    v79 = 0u;
    v80 = 0u;
    v78 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v73 = 136315906;
    *(_QWORD *)&v73[4] = "insert";
    *(_WORD *)&v73[12] = 1024;
    *(_DWORD *)&v73[14] = 887;
    v74 = 2048;
    v75 = v8 + a2 * v7;
    v76 = 2048;
    v77 = v11;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_79:
    v72 = 0;
    v81 = 0u;
    v82 = 0u;
    v79 = 0u;
    v80 = 0u;
    v78 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v73 = 136315906;
    *(_QWORD *)&v73[4] = "insert";
    *(_WORD *)&v73[12] = 1024;
    *(_DWORD *)&v73[14] = 887;
    v74 = 2048;
    v75 = v10;
    v76 = 2048;
    v77 = v11;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_80;
  }
LABEL_27:
  v7 = *((_QWORD *)v4 + 41);
  if (v7)
  {
    v8 = 0;
    v30 = *((_QWORD *)v4 + 44);
    do
    {
      v10 = v8 + v7 * a2;
      v11 = v30 + 1;
      if (v30 + 1 <= v10)
        goto LABEL_78;
      if (v30 >= *((_QWORD *)v4 + 43))
      {
        this = (re::TimelineEventData *)re::DynamicArray<re::Vector4<float>>::growCapacity((_QWORD *)v4 + 42, v30 + 1);
        v30 = *((_QWORD *)v4 + 44);
      }
      v31 = *((_QWORD *)v4 + 46) + 16 * v30;
      if (v30 > v10)
      {
        *(_OWORD *)v31 = *(_OWORD *)(v31 - 16);
        v32 = *((_QWORD *)v4 + 46);
        v33 = v32 + 16 * v10;
        v34 = v32 + 16 * *((_QWORD *)v4 + 44) - 16;
        if (v34 != v33)
        {
          this = (re::TimelineEventData *)memmove((void *)(v33 + 16), (const void *)v33, v34 - v33);
          v32 = *((_QWORD *)v4 + 46);
        }
        v31 = v32 + 16 * v10;
      }
      *(_QWORD *)v31 = 0;
      *(_QWORD *)(v31 + 8) = 0;
      v30 = *((_QWORD *)v4 + 44) + 1;
      *((_QWORD *)v4 + 44) = v30;
      ++*((_DWORD *)v4 + 90);
      ++v8;
      v7 = *((_QWORD *)v4 + 41);
    }
    while (v8 < v7);
  }
  v35 = *((_QWORD *)v4 + 47);
  if (v35)
  {
    for (j = 0; j < v35; ++j)
    {
      v2 = v35 * a2;
      v10 = v35 * a2 + j;
      v69 = 0;
      v70 = 0;
      v71 = 0;
      v37 = *((_QWORD *)v4 + 50);
      v11 = v37 + 1;
      if (v37 + 1 <= v10)
        goto LABEL_79;
      if (v37 >= *((_QWORD *)v4 + 49))
      {
        re::DynamicArray<re::FixedArray<unsigned char>>::growCapacity((_QWORD *)v4 + 48, v37 + 1);
        v37 = *((_QWORD *)v4 + 50);
      }
      v38 = *((_QWORD *)v4 + 52);
      v39 = (re::TimelineEventData **)(v38 + 24 * v37);
      if (v37 <= v10)
      {
        v49 = v38 + 24 * v37;
        *v39 = 0;
        v39[1] = 0;
        v39[2] = 0;
        *v39 = v69;
        v69 = 0;
        *(_QWORD *)(v49 + 8) = v70;
        v70 = 0;
        v50 = *(_QWORD *)(v49 + 16);
        *(_QWORD *)(v49 + 16) = v71;
        v71 = v50;
      }
      else
      {
        v40 = v38 + 24 * v37;
        v39[1] = 0;
        v39[2] = 0;
        v41 = *(_QWORD *)(v40 - 16);
        *v39 = *(re::TimelineEventData **)(v40 - 24);
        *(_QWORD *)(v40 - 24) = 0;
        *(_QWORD *)(v40 - 16) = 0;
        v42 = *(_QWORD *)(v40 + 16);
        v43 = *(_QWORD *)(v40 - 8);
        *(_QWORD *)(v40 + 8) = v41;
        *(_QWORD *)(v40 + 16) = v43;
        *(_QWORD *)(v40 - 8) = v42;
        v44 = *((_QWORD *)v4 + 52);
        v45 = *((_QWORD *)v4 + 50);
        v46 = (uint64_t *)(v44 + 24 * v45 - 24);
        if (v46 != (uint64_t *)(v44 + 24 * v10))
        {
          v47 = -24 * v45 + 24 * (j + v2) + 24;
          do
          {
            v48 = v46 - 3;
            re::FixedArray<float>::operator=(v46, v46 - 3);
            v46 = v48;
            v47 += 24;
          }
          while (v47);
          v44 = *((_QWORD *)v4 + 52);
        }
        re::FixedArray<float>::operator=((uint64_t *)(v44 + 24 * v10), (uint64_t *)&v69);
      }
      ++*((_QWORD *)v4 + 50);
      ++*((_DWORD *)v4 + 102);
      this = v69;
      if (v69 && v70)
        this = (re::TimelineEventData *)(*(uint64_t (**)(void))(*(_QWORD *)v69 + 40))();
      v35 = *((_QWORD *)v4 + 47);
    }
  }
  v51 = *((_QWORD *)v4 + 53);
  if (v51)
  {
    v52 = 0;
    while (1)
    {
      v53 = v51 * a2;
      v2 = v51 * a2 + v52;
      v54 = *((_QWORD *)v4 + 56);
      v11 = v54 + 1;
      if (v54 + 1 <= v2)
        break;
      v55 = *((_QWORD *)v4 + 55);
      if (v54 >= v55)
      {
        if (v55 < v11)
        {
          if (*((_QWORD *)v4 + 54))
          {
            v56 = 2 * v55;
            if (!v55)
              v56 = 8;
            if (v56 <= v11)
              v57 = v11;
            else
              v57 = v56;
            this = (re::TimelineEventData *)re::DynamicArray<re::ObjCObject>::setCapacity((_QWORD *)v4 + 54, v57);
          }
          else
          {
            this = (re::TimelineEventData *)re::DynamicArray<re::ObjCObject>::setCapacity((_QWORD *)v4 + 54, v11);
            ++*((_DWORD *)v4 + 114);
          }
        }
        v54 = *((_QWORD *)v4 + 56);
      }
      v58 = *((_QWORD *)v4 + 58);
      if (v54 <= v2)
      {
        *(_QWORD *)(v58 + 8 * v54) = 0;
      }
      else
      {
        v59 = (_QWORD *)(v58 + 8 * v54);
        v60 = *(v59 - 1);
        *(v59 - 1) = 0;
        *v59 = v60;
        v61 = *((_QWORD *)v4 + 58);
        v62 = *((_QWORD *)v4 + 56);
        v63 = (void **)(v61 + 8 * v62 - 8);
        if (v63 != (void **)(v61 + 8 * v2))
        {
          v64 = 8 * (v52 + v53) - 8 * v62 + 8;
          v65 = (void **)(v61 + 8 * v62 - 8);
          do
          {
            v66 = *--v65;
            *v65 = 0;
            v67 = *v63;
            *v63 = v66;

            v63 = v65;
            v64 += 8;
          }
          while (v64);
          v61 = *((_QWORD *)v4 + 58);
        }
        v68 = *(void **)(v61 + 8 * v2);
        *(_QWORD *)(v61 + 8 * v2) = 0;

        v54 = *((_QWORD *)v4 + 56);
      }
      *((_QWORD *)v4 + 56) = v54 + 1;
      ++*((_DWORD *)v4 + 114);
      ++v52;
      v51 = *((_QWORD *)v4 + 53);
      if (v52 >= v51)
        return;
    }
LABEL_80:
    v69 = 0;
    v81 = 0u;
    v82 = 0u;
    v79 = 0u;
    v80 = 0u;
    v78 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v73 = 136315906;
    *(_QWORD *)&v73[4] = "insert";
    *(_WORD *)&v73[12] = 1024;
    *(_DWORD *)&v73[14] = 887;
    v74 = 2048;
    v75 = v2;
    v76 = 2048;
    v77 = v11;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
}

void re::EventTimeline::setEventData(re::EventTimeline *this, const re::TimelineEventData *a2, re::Allocator *a3)
{
  ArcSharedObject *v6;
  _QWORD *v7;
  uint64_t v8;

  v6 = (ArcSharedObject *)(*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(_QWORD *)a3 + 32))(a3, 584, 8);
  ArcSharedObject::ArcSharedObject(v6, 0);
  v7[2] = a3;
  *v7 = &off_24ED24F90;
  re::TimelineEventData::TimelineEventData((re::TimelineEventData *)(v7 + 3), a2);
  v8 = *((_QWORD *)this + 10);
  *((_QWORD *)this + 10) = v6;
  if (v8)

}

void re::TimelineEventData::addEvent(re::TimelineEventData *this@<X0>, double a2@<D0>, double a3@<D1>, uint64_t a4@<X1>, uint64_t a5@<X8>)
{
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  double v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  float v16;
  float v17;
  float v18;
  unint64_t v19;
  float v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  if (a3 < 0.0)
  {
    *(_BYTE *)a5 = 0;
    return;
  }
  if (a3 == 0.0)
  {
    v7 = *((_QWORD *)this + 14);
    if (!v7)
    {
LABEL_24:
      v8 = 0;
      goto LABEL_25;
    }
    v8 = 0;
    v9 = *((_QWORD *)this + 16);
    while (*(float *)(v9 + 4 * v8) < a2)
    {
      if (v7 == ++v8)
      {
        v8 = *((_QWORD *)this + 14);
        break;
      }
    }
    if (!v8)
      goto LABEL_25;
    if (v7 <= v8 - 1)
    {
      v24 = 0u;
      v25 = 0u;
      v22 = 0u;
      v23 = 0u;
      v21 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_30;
    }
    if (*(float *)(v9 + 4 * (v8 - 1)) < a2)
    {
LABEL_25:
      v18 = a2;
      *(float *)&v21 = v18;
      re::DynamicArray<float>::insert((_QWORD *)this + 12, v8, &v21);
      re::TimelineEventData::addEvent(this, *((_QWORD *)this + 4) + v8);
      v19 = *((_QWORD *)this + 4) + v8;
      *(_BYTE *)a5 = 1;
      *(_QWORD *)(a5 + 8) = v19;
      return;
    }
    re::internal::assertLog((re::internal *)5, a4, "assertion failure: '%s' (%s:line %i) Can not add skip only, fence event at time %f. It overlaps with an existing fence event.", "false", "addEvent", 127, *(_QWORD *)&a2);
    _os_crash();
    __break(1u);
  }
  v10 = a3;
  v11 = *((_QWORD *)this + 4);
  if (!v11)
  {
    v14 = (_QWORD *)((char *)this + 16);
LABEL_27:
    v12 = 0;
    v17 = a2;
    goto LABEL_28;
  }
  v12 = 0;
  v13 = *((_QWORD *)this + 6);
  while (*(float *)(v13 + 4 * v12) < a2)
  {
    if (v11 == ++v12)
    {
      v12 = *((_QWORD *)this + 4);
      break;
    }
  }
  v14 = (_QWORD *)((char *)this + 16);
  if (!v12)
    goto LABEL_27;
  v15 = v12 - 1;
  if (v11 <= v12 - 1)
  {
LABEL_30:
    v24 = 0u;
    v25 = 0u;
    v22 = 0u;
    v23 = 0u;
    v21 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_31:
    v24 = 0u;
    v25 = 0u;
    v22 = 0u;
    v23 = 0u;
    v21 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*((_QWORD *)this + 9) <= v15)
    goto LABEL_31;
  v16 = *(float *)(v13 + 4 * v15) + *(float *)(*((_QWORD *)this + 11) + 4 * v15);
  v17 = a2;
  if (v16 > v17 && vabds_f32(v16, v17) >= (float)((float)((float)(fabsf(v17) + fabsf(v16)) + 1.0) * 0.00001))
  {
    re::internal::assertLog((re::internal *)6, a4, "assertion failure: '%s' (%s:line %i) Can not add event inteval at time %f with duration %f. It overlaps with an existing event.", "false", "addEvent", 143, *(_QWORD *)&a2, *(_QWORD *)&v10);
    _os_crash();
    __break(1u);
    goto LABEL_24;
  }
LABEL_28:
  *(float *)&v21 = v17;
  re::DynamicArray<float>::insert(v14, v12, &v21);
  v20 = v10;
  *(float *)&v21 = v20;
  re::DynamicArray<float>::insert((_QWORD *)this + 7, v12, &v21);
  re::TimelineEventData::addEvent(this, v12);
  *(_BYTE *)a5 = 1;
  *(_QWORD *)(a5 + 8) = v12;
}

_QWORD *re::DynamicArray<float>::insert(_QWORD *this, unint64_t a2, _DWORD *a3)
{
  unint64_t v4;
  _QWORD *v6;
  uint64_t v7;
  _DWORD *v8;
  uint64_t v9;

  v4 = this[2];
  if (v4 + 1 <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  v6 = this;
  if (v4 >= this[1])
  {
    this = re::DynamicArray<float>::growCapacity(this, v4 + 1);
    v4 = v6[2];
  }
  v7 = v6[4];
  v8 = (_DWORD *)(v7 + 4 * v4);
  if (v4 <= a2)
  {
    *v8 = *a3;
  }
  else
  {
    *v8 = *(v8 - 1);
    v9 = v7 + 4 * a2;
    if (v8 - 1 != (_DWORD *)v9)
    {
      this = memmove((void *)(v9 + 4), (const void *)v9, (size_t)v8 - v9 - 4);
      v7 = v6[4];
      v4 = v6[2];
    }
    *(_DWORD *)(v7 + 4 * a2) = *a3;
  }
  v6[2] = v4 + 1;
  ++*((_DWORD *)v6 + 6);
  return this;
}

double re::TimelineEventData::totalDuration(re::TimelineEventData *this)
{
  uint64_t v1;
  float v2;
  uint64_t v3;
  uint64_t v4;

  v1 = *((_QWORD *)this + 4);
  if (v1)
    v2 = *(float *)(*((_QWORD *)this + 6) + 4 * v1 - 4)
       + *(float *)(*((_QWORD *)this + 11) + 4 * *((_QWORD *)this + 9) - 4);
  else
    v2 = 0.0;
  v3 = *((_QWORD *)this + 14);
  if (v3)
  {
    v4 = *((_QWORD *)this + 16) + 4 * v3;
    if (v2 < *(float *)(v4 - 4))
      return *(float *)(v4 - 4);
  }
  return v2;
}

uint64_t re::TimelineEventData::parameterName(re::TimelineEventData *this, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  int *v4;
  int v5;
  uint64_t v7;
  int v8;
  int v9;
  unsigned int v10;

  if (*((unsigned int *)this + 41) <= a2)
    return 0;
  v2 = *((unsigned int *)this + 42);
  if ((_DWORD)v2)
  {
    v3 = 0;
    v4 = (int *)*((_QWORD *)this + 19);
    while (1)
    {
      v5 = *v4;
      v4 += 10;
      if (v5 < 0)
        break;
      if (v2 == ++v3)
      {
        LODWORD(v3) = *((_DWORD *)this + 42);
        break;
      }
    }
  }
  else
  {
    LODWORD(v3) = 0;
  }
  if ((_DWORD)v2 == (_DWORD)v3)
    return 0;
  if (a2)
  {
    v7 = 0;
    while (1)
    {
      ++v7;
      v8 = v2 <= (int)v3 + 1 ? v3 + 1 : *((_DWORD *)this + 42);
      v9 = v3;
      while (1)
      {
        v10 = v9 + 1;
        if (v8 - 1 == v9)
          break;
        ++v9;
        LODWORD(v3) = v10;
        if ((*(_DWORD *)(*((_QWORD *)this + 19) + 40 * v10) & 0x80000000) != 0)
          goto LABEL_20;
      }
      LODWORD(v3) = v8;
LABEL_20:
      if ((_DWORD)v2 == (_DWORD)v3)
        return 0;
      if (v7 == a2)
        return *(_QWORD *)(*((_QWORD *)this + 19) + 40 * v10 + 16);
    }
  }
  v10 = v3;
  return *(_QWORD *)(*((_QWORD *)this + 19) + 40 * v10 + 16);
}

uint64_t re::EventTimeline::createInstance(re::EventTimeline *this, re::Allocator *a2, const re::BindNode *a3, const re::internal::TimelineTree *a4, uint64_t a5)
{
  uint64_t v5;
  unint64_t *v9;
  re::DynamicString *v10;
  uint64_t (**v11)();

  switch(*(_BYTE *)(*((_QWORD *)this + 10) + 496))
  {
    case 0xFF:
    case 0:
    case 8:
      v5 = (*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 184, 8);
      *(_QWORD *)v5 = off_24ED1F350;
      *(_QWORD *)(v5 + 8) = 49;
      *(_BYTE *)(v5 + 16) = 0;
      *(_QWORD *)(v5 + 24) = 0;
      v9 = (unint64_t *)(v5 + 24);
      *(_QWORD *)(v5 + 32) = &str_110;
      v10 = (re::DynamicString *)(v5 + 40);
      *(_BYTE *)(v5 + 72) = 0;
      v11 = off_24ED24FD8;
      goto LABEL_10;
    case 1:
      v5 = (*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 184, 8);
      *(_QWORD *)v5 = off_24ED1F350;
      *(_QWORD *)(v5 + 8) = 49;
      *(_BYTE *)(v5 + 16) = 0;
      *(_QWORD *)(v5 + 24) = 0;
      v9 = (unint64_t *)(v5 + 24);
      *(_QWORD *)(v5 + 32) = &str_110;
      v10 = (re::DynamicString *)(v5 + 40);
      *(_BYTE *)(v5 + 72) = 0;
      v11 = off_24ED25118;
      goto LABEL_10;
    case 2:
      v5 = (*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 184, 8);
      *(_QWORD *)v5 = off_24ED1F350;
      *(_QWORD *)(v5 + 8) = 49;
      *(_BYTE *)(v5 + 16) = 0;
      *(_QWORD *)(v5 + 24) = 0;
      v9 = (unint64_t *)(v5 + 24);
      *(_QWORD *)(v5 + 32) = &str_110;
      v10 = (re::DynamicString *)(v5 + 40);
      *(_BYTE *)(v5 + 72) = 0;
      v11 = off_24ED251B8;
      goto LABEL_10;
    case 3:
      v5 = (*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 184, 8);
      *(_QWORD *)v5 = off_24ED1F350;
      *(_QWORD *)(v5 + 8) = 49;
      *(_BYTE *)(v5 + 16) = 0;
      *(_QWORD *)(v5 + 24) = 0;
      v9 = (unint64_t *)(v5 + 24);
      *(_QWORD *)(v5 + 32) = &str_110;
      v10 = (re::DynamicString *)(v5 + 40);
      *(_BYTE *)(v5 + 72) = 0;
      v11 = off_24ED25258;
      goto LABEL_10;
    case 4:
      v5 = (*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 184, 8);
      *(_QWORD *)v5 = off_24ED1F350;
      *(_QWORD *)(v5 + 8) = 49;
      *(_BYTE *)(v5 + 16) = 0;
      *(_QWORD *)(v5 + 24) = 0;
      v9 = (unint64_t *)(v5 + 24);
      *(_QWORD *)(v5 + 32) = &str_110;
      v10 = (re::DynamicString *)(v5 + 40);
      *(_BYTE *)(v5 + 72) = 0;
      v11 = off_24ED252F8;
      goto LABEL_10;
    case 5:
      v5 = (*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 184, 8);
      *(_QWORD *)v5 = off_24ED1F350;
      *(_QWORD *)(v5 + 8) = 49;
      *(_BYTE *)(v5 + 16) = 0;
      *(_QWORD *)(v5 + 24) = 0;
      v9 = (unint64_t *)(v5 + 24);
      *(_QWORD *)(v5 + 32) = &str_110;
      v10 = (re::DynamicString *)(v5 + 40);
      *(_BYTE *)(v5 + 72) = 0;
      v11 = off_24ED25398;
      goto LABEL_10;
    case 6:
      v5 = (*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 184, 8);
      *(_QWORD *)v5 = off_24ED1F350;
      *(_QWORD *)(v5 + 8) = 49;
      *(_BYTE *)(v5 + 16) = 0;
      *(_QWORD *)(v5 + 24) = 0;
      v9 = (unint64_t *)(v5 + 24);
      *(_QWORD *)(v5 + 32) = &str_110;
      v10 = (re::DynamicString *)(v5 + 40);
      *(_BYTE *)(v5 + 72) = 0;
      v11 = off_24ED25078;
      goto LABEL_10;
    case 7:
      v5 = (*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 184, 8);
      *(_QWORD *)v5 = off_24ED1F350;
      *(_QWORD *)(v5 + 8) = 49;
      *(_BYTE *)(v5 + 16) = 0;
      *(_QWORD *)(v5 + 24) = 0;
      v9 = (unint64_t *)(v5 + 24);
      *(_QWORD *)(v5 + 32) = &str_110;
      v10 = (re::DynamicString *)(v5 + 40);
      *(_BYTE *)(v5 + 72) = 0;
      v11 = off_24ED25438;
LABEL_10:
      *(_QWORD *)v5 = v11;
      *(_BYTE *)(v5 + 80) = 0;
      *(_QWORD *)(v5 + 96) = 0;
      *(_BYTE *)(v5 + 104) = 0;
      *(_BYTE *)(v5 + 120) = 0;
      *(_QWORD *)(v5 + 128) = a4;
      *(_QWORD *)(v5 + 136) = this;
      *(_QWORD *)(v5 + 144) = a5;
      *(_BYTE *)(v5 + 152) = 0;
      *(_BYTE *)(v5 + 168) = 0;
      re::DynamicString::operator=(v10, (re::EventTimeline *)((char *)this + 40));
      *(_BYTE *)(v5 + 72) = *((_BYTE *)this + 72);
      *(_DWORD *)(v5 + 12) = *((_DWORD *)this + 3);
      *(_BYTE *)(v5 + 16) = *((_BYTE *)this + 16);
      re::StringID::operator=(v9, (uint64_t *)this + 3);
      break;
    default:
      return v5;
  }
  return v5;
}

uint64_t re::TypedEventTimelineInstance<float>::initAnimationState(uint64_t a1, uint64_t a2, __int128 *a3, unint64_t a4, double *a5, char a6)
{
  __int128 v11;
  __int128 v12;
  __int128 v13;
  float v14;
  _QWORD *v15;
  unint64_t v16;
  BOOL v17;
  unint64_t v18;
  _QWORD *v19;
  float v20;
  unint64_t v21;
  unint64_t v22;
  float v23;
  char v24;
  double v25;
  float v26;
  uint64_t result;

  if (a3)
  {
    v11 = *a3;
    v12 = a3[1];
    v13 = a3[2];
    *(_OWORD *)(a2 + 41) = *(__int128 *)((char *)a3 + 41);
    *(_OWORD *)(a2 + 16) = v12;
    *(_OWORD *)(a2 + 32) = v13;
    *(_OWORD *)a2 = v11;
  }
  v14 = re::TypedEventTimelineInstance<float>::rootAnimationTime(*(_QWORD *)(a1 + 128)) - *(double *)(a1 + 96);
  *(float *)(a2 + 4) = v14;
  v15 = *(_QWORD **)(*(_QWORD *)(a1 + 136) + 80);
  v16 = v15[7];
  v17 = a4 >= v16;
  v18 = a4 - v16;
  if (!v17)
  {
    v19 = v15 + 9;
    v18 = a4;
LABEL_7:
    v20 = *(float *)(*v19 + 4 * v18);
    goto LABEL_9;
  }
  if (v18 < v15[17])
  {
    v19 = v15 + 19;
    goto LABEL_7;
  }
  v20 = NAN;
LABEL_9:
  v21 = v15[12];
  v17 = a4 >= v21;
  v22 = a4 - v21;
  if (v17)
  {
    if (v22 >= v15[17])
      v23 = NAN;
    else
      v23 = 0.0;
  }
  else
  {
    v23 = *(float *)(v15[14] + 4 * a4);
  }
  v24 = *(_BYTE *)a5;
  if (*(_BYTE *)a5)
  {
    v25 = (a5[1] - v20) / v23;
    if (v25 > 1.0)
      v25 = 1.0;
    if (v25 < 0.0)
      v25 = 0.0;
    v26 = v25;
  }
  else
  {
    v26 = -1.0;
  }
  *(float *)(a2 + 8) = v26;
  *(_BYTE *)(a2 + 1) = 0;
  *(_BYTE *)(a2 + 2) = v24;
  result = re::TypedEventTimelineInstance<float>::compositionChain(a1);
  if (result)
    *(_QWORD *)(a2 + 40) = result + 8;
  *(_BYTE *)(a2 + 56) = a6;
  *(float *)(a2 + 48) = v20;
  *(float *)(a2 + 52) = v23;
  return result;
}

double re::TypedEventTimelineInstance<float>::rootAnimationTime(uint64_t a1)
{
  if (!*(_QWORD *)(a1 + 56))
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(double *)(*(_QWORD *)(a1 + 64) + 8);
}

void re::TypedEventTimelineInstance<float>::raiseSkippedEvents(uint64_t a1, uint64_t a2, __int128 *a3, double a4, double a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v9;
  unint64_t v10;
  unint64_t i;
  int v12;
  unint64_t v13;
  int v14;
  unint64_t v15;
  uint64_t v16;
  float v17;
  float v18;
  float v19;
  float v20;
  unint64_t v21;
  char *v22;
  _QWORD *v23;
  char *v24;
  void *v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  float v29;
  float v30;
  float v31;
  float v32;
  unint64_t v33;
  char *WeakRetained;
  _QWORD *v35;
  char *v36;
  void *v37;
  double v38[2];
  double v39[2];
  _QWORD v40[6];
  double v41;
  double v42;
  __int128 *v43;
  uint64_t v44;
  int v45;
  const char *v46;
  __int16 v47;
  _QWORD v48[6];
  _BYTE v49[12];
  __int16 v50;
  int v51;
  __int16 v52;
  uint64_t v53;
  __int16 v54;
  uint64_t v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  uint64_t v61;

  v61 = *MEMORY[0x24BDAC8D0];
  v43 = a3;
  if (a4 != a5 && vabdd_f64(a4, a5) >= (fabs(a4) + fabs(a5) + 1.0) * 1.0e-12)
  {
    v9 = *(_QWORD *)(*(_QWORD *)(a1 + 136) + 80);
    v40[0] = v9 + 24;
    v40[1] = &v42;
    v40[2] = &v41;
    v40[3] = a1;
    v40[4] = &v43;
    v40[5] = a2;
    if (a5 <= a4)
    {
      if (a5 < a4 && *(_BYTE *)(v9 + 536))
      {
        v41 = a4;
        v42 = a5;
        if ((int)*(_QWORD *)(v9 + 56) >= 1)
        {
          v13 = *(_QWORD *)(v9 + 56) + 1;
          do
          {
            re::TypedEventTimelineInstance<float>::raiseSkippedEvents(double,double,re::AnimationClock,re::CompositionChainStateBase const*)const::$_0::operator()((uint64_t)v40, (v13 - 2), 1, *(_QWORD *)(v9 + 56) - 1 == (_DWORD)v13 - 2);
            --v13;
          }
          while (v13 > 1);
        }
        v14 = *(unsigned __int8 *)(a1 + 168);
        if (*(_BYTE *)(a1 + 168))
        {
          v5 = *(_QWORD *)(a1 + 176);
          *(_BYTE *)(a1 + 168) = 0;
        }
        if (*(_BYTE *)(a1 + 152))
          *(_BYTE *)(a1 + 152) = 0;
        if ((int)*(_QWORD *)(v9 + 136) >= 1)
        {
          v26 = *(_QWORD *)(v9 + 136) + 1;
          while (1)
          {
            v27 = (v26 - 2);
            v28 = *(_QWORD *)(v9 + 136);
            if (v28 <= v27)
            {
              *(_QWORD *)v49 = 0;
              v59 = 0u;
              v60 = 0u;
              v57 = 0u;
              v58 = 0u;
              v56 = 0u;
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              v45 = 136315906;
              v46 = "operator[]";
              v47 = 1024;
              LODWORD(v48[0]) = 797;
              WORD2(v48[0]) = 2048;
              *(_QWORD *)((char *)v48 + 6) = (v26 - 2);
              HIWORD(v48[1]) = 2048;
              v48[2] = v28;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_67:
              v44 = 0;
              v59 = 0u;
              v60 = 0u;
              v57 = 0u;
              v58 = 0u;
              v56 = 0u;
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              *(_DWORD *)v49 = 136315906;
              *(_QWORD *)&v49[4] = "operator[]";
              v50 = 1024;
              v51 = 476;
              v52 = 2048;
              v53 = 0;
              v54 = 2048;
              v55 = 0;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_68:
              v44 = 0;
              v59 = 0u;
              v60 = 0u;
              v57 = 0u;
              v58 = 0u;
              v56 = 0u;
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              *(_DWORD *)v49 = 136315906;
              *(_QWORD *)&v49[4] = "operator[]";
              v50 = 1024;
              v51 = 476;
              v52 = 2048;
              v53 = 0;
              v54 = 2048;
              v55 = 0;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
            }
            v29 = *(float *)(*(_QWORD *)(v9 + 152) + 4 * v27);
            v30 = v42;
            if (v29 <= v30)
              break;
            v31 = fabsf(v29);
            if (vabds_f32(v29, v30) < (float)((float)((float)(v31 + fabsf(v30)) + 1.0) * 0.00001))
              break;
            if (v42 < v29)
            {
              if (v41 > v29
                || v14
                && v5 == v27
                && ((v32 = v41, v29 == v32)
                 || vabds_f32(v29, v32) < (float)((float)((float)(v31 + fabsf(v32)) + 1.0) * 0.00001)))
              {
                LOWORD(v45) = 255;
                BYTE2(v45) = 0;
                v46 = 0;
                memset((char *)v48 + 2, 0, 41);
                v33 = *(_QWORD *)(v9 + 56) + v27;
                LOBYTE(v38[0]) = 0;
                re::TypedEventTimelineInstance<float>::initAnimationState(a1, (uint64_t)&v45, v43, v33, v38, 1);
                WeakRetained = (char *)objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 128) + 176));
                v35 = *(_QWORD **)(a1 + 128);
                if (!v35[7])
                  goto LABEL_68;
                if (WeakRetained)
                  v36 = WeakRetained - 8;
                else
                  v36 = 0;
                v37 = v36 + 8;
                (*(void (**)(char *, uint64_t, _QWORD, uint64_t, _QWORD, unint64_t, uint64_t, int *, double))(*(_QWORD *)v36 + 40))(v36, 10, v35[21], a2, *(_QWORD *)(a1 + 136), v33, a1, &v45, *(double *)(v35[8] + 8));

              }
            }
            if ((unint64_t)--v26 <= 1)
              return;
          }
          if (v29 == v30 || vabds_f32(v29, v30) < (float)((float)((float)(fabsf(v29) + fabsf(v30)) + 1.0) * 0.00001))
          {
            if (!*(_BYTE *)(a1 + 168))
              *(_BYTE *)(a1 + 168) = 1;
            *(_QWORD *)(a1 + 176) = v27;
          }
        }
      }
    }
    else
    {
      v41 = a5;
      v42 = a4;
      v10 = *(_QWORD *)(v9 + 56);
      if (v10)
      {
        for (i = 0; i < v10; ++i)
        {
          re::TypedEventTimelineInstance<float>::raiseSkippedEvents(double,double,re::AnimationClock,re::CompositionChainStateBase const*)const::$_0::operator()((uint64_t)v40, i, 0, i == v10 - 1);
          v10 = *(_QWORD *)(v9 + 56);
        }
      }
      v12 = *(unsigned __int8 *)(a1 + 152);
      if (*(_BYTE *)(a1 + 152))
      {
        v6 = *(_QWORD *)(a1 + 160);
        *(_BYTE *)(a1 + 152) = 0;
      }
      if (*(_BYTE *)(a1 + 168))
        *(_BYTE *)(a1 + 168) = 0;
      v15 = *(_QWORD *)(v9 + 136);
      if (v15)
      {
        v16 = 0;
        while (1)
        {
          v17 = *(float *)(*(_QWORD *)(v9 + 152) + 4 * v16);
          v18 = v41;
          if (v17 >= v18)
            break;
          v19 = fabsf(v17);
          if (vabds_f32(v17, v18) < (float)((float)((float)(v19 + fabsf(v18)) + 1.0) * 0.00001))
            break;
          if (v41 > v17)
          {
            if (v42 < v17
              || v12
              && v6 == v16
              && ((v20 = v42, v17 == v20)
               || vabds_f32(v17, v20) < (float)((float)((float)(v19 + fabsf(v20)) + 1.0) * 0.00001)))
            {
              LOWORD(v45) = 255;
              BYTE2(v45) = 0;
              v46 = 0;
              memset((char *)v48 + 2, 0, 41);
              v21 = v16 + *(_QWORD *)(v9 + 56);
              LOBYTE(v39[0]) = 0;
              re::TypedEventTimelineInstance<float>::initAnimationState(a1, (uint64_t)&v45, v43, v21, v39, 0);
              v22 = (char *)objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 128) + 176));
              v23 = *(_QWORD **)(a1 + 128);
              if (!v23[7])
                goto LABEL_67;
              if (v22)
                v24 = v22 - 8;
              else
                v24 = 0;
              v25 = v24 + 8;
              (*(void (**)(char *, uint64_t, _QWORD, uint64_t, _QWORD, unint64_t, uint64_t, int *, double))(*(_QWORD *)v24 + 40))(v24, 10, v23[21], a2, *(_QWORD *)(a1 + 136), v21, a1, &v45, *(double *)(v23[8] + 8));

              v15 = *(_QWORD *)(v9 + 136);
            }
          }
          if (++v16 >= v15)
            return;
        }
        if (v17 == v18 || vabds_f32(v17, v18) < (float)((float)((float)(fabsf(v17) + fabsf(v18)) + 1.0) * 0.00001))
        {
          if (!*(_BYTE *)(a1 + 152))
            *(_BYTE *)(a1 + 152) = 1;
          *(_QWORD *)(a1 + 160) = v16;
        }
      }
    }
  }
}

void re::TypedEventTimelineInstance<float>::raiseSkippedEvents(double,double,re::AnimationClock,re::CompositionChainStateBase const*)const::$_0::operator()(uint64_t a1, unint64_t a2, char a3, int a4)
{
  _QWORD *v5;
  unint64_t v6;
  float v8;
  uint64_t v10;
  float v11;
  float v12;
  __int128 *v13;
  char *WeakRetained;
  _QWORD *v15;
  uint64_t v16;
  char *v17;
  void *v18;
  double v19[3];
  int v20;
  const char *v21;
  __int16 v22;
  _QWORD v23[6];
  _BYTE v24[12];
  __int16 v25;
  int v26;
  __int16 v27;
  uint64_t v28;
  __int16 v29;
  uint64_t v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  uint64_t v36;

  v36 = *MEMORY[0x24BDAC8D0];
  v5 = *(_QWORD **)a1;
  v6 = *(_QWORD *)(*(_QWORD *)a1 + 32);
  if (v6 <= a2)
  {
    *(_QWORD *)v24 = 0;
    v34 = 0u;
    v35 = 0u;
    v32 = 0u;
    v33 = 0u;
    v31 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v20 = 136315906;
    v21 = "operator[]";
    v22 = 1024;
    LODWORD(v23[0]) = 797;
    WORD2(v23[0]) = 2048;
    *(_QWORD *)((char *)v23 + 6) = a2;
    HIWORD(v23[1]) = 2048;
    v23[2] = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_16:
    *(_QWORD *)v24 = 0;
    v34 = 0u;
    v35 = 0u;
    v32 = 0u;
    v33 = 0u;
    v31 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v20 = 136315906;
    v21 = "operator[]";
    v22 = 1024;
    LODWORD(v23[0]) = 797;
    WORD2(v23[0]) = 2048;
    *(_QWORD *)((char *)v23 + 6) = a2;
    HIWORD(v23[1]) = 2048;
    v23[2] = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_17;
  }
  v8 = *(float *)(v5[6] + 4 * a2);
  if (**(double **)(a1 + 8) >= v8)
    return;
  v6 = v5[9];
  if (v6 <= a2)
    goto LABEL_16;
  v10 = *(_QWORD *)(a1 + 24);
  v11 = v8 + *(float *)(v5[11] + 4 * a2);
  if (a4)
  {
    if (**(double **)(a1 + 16) <= v11)
      return;
  }
  else
  {
    v12 = **(double **)(a1 + 16);
    if (v11 > v12 && vabds_f32(v11, v12) >= (float)((float)((float)(fabsf(v11) + fabsf(v12)) + 1.0) * 0.00001))
      return;
  }
  LOWORD(v20) = 255;
  BYTE2(v20) = 0;
  v21 = 0;
  memset((char *)v23 + 2, 0, 41);
  v13 = **(__int128 ***)(a1 + 32);
  LOBYTE(v19[0]) = 0;
  re::TypedEventTimelineInstance<float>::initAnimationState(v10, (uint64_t)&v20, v13, a2, v19, a3);
  WeakRetained = (char *)objc_loadWeakRetained((id *)(*(_QWORD *)(v10 + 128) + 176));
  v15 = *(_QWORD **)(v10 + 128);
  if (!v15[7])
  {
LABEL_17:
    v19[2] = 0.0;
    v34 = 0u;
    v35 = 0u;
    v32 = 0u;
    v33 = 0u;
    v31 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v24 = 136315906;
    *(_QWORD *)&v24[4] = "operator[]";
    v25 = 1024;
    v26 = 476;
    v27 = 2048;
    v28 = 0;
    v29 = 2048;
    v30 = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  v16 = *(_QWORD *)(a1 + 40);
  if (WeakRetained)
    v17 = WeakRetained - 8;
  else
    v17 = 0;
  v18 = v17 + 8;
  (*(void (**)(char *, uint64_t, _QWORD, uint64_t, _QWORD, unint64_t, uint64_t, int *, double))(*(_QWORD *)v17 + 40))(v17, 10, v15[21], v16, *(_QWORD *)(v10 + 136), a2, v10, &v20, *(double *)(v15[8] + 8));

}

void re::TypedEventTimelineInstance<float>::timelineRemoved(uint64_t a1)
{
  uint64_t v2;
  unint64_t v3;
  char *WeakRetained;
  _QWORD *v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  char *v13;
  _QWORD *v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  double v20[2];
  __int16 v21;
  char v22;
  int v23;
  int v24;
  __int128 v25;
  _QWORD v26[4];
  uint64_t v27;
  int v28;
  const char *v29;
  __int16 v30;
  int v31;
  __int16 v32;
  unint64_t v33;
  __int16 v34;
  unint64_t v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  uint64_t v41;

  v41 = *MEMORY[0x24BDAC8D0];
  v21 = 255;
  v22 = 0;
  v23 = 0;
  v24 = 0;
  v25 = 0u;
  memset(v26, 0, 25);
  v2 = re::TypedEventTimelineInstance<float>::compositionChain(a1);
  if (v2)
    v26[1] = v2 + 8;
  if (*(_BYTE *)(a1 + 80))
  {
    v3 = *(_QWORD *)(a1 + 88);
    LOBYTE(v20[0]) = 0;
    re::TypedEventTimelineInstance<float>::initAnimationState(a1, (uint64_t)&v21, 0, v3, v20, 0);
    WeakRetained = (char *)objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 128) + 176));
    v5 = *(_QWORD **)(a1 + 128);
    v6 = *(_QWORD *)(a1 + 144);
    v7 = v5[7];
    if (v7 <= v6)
      goto LABEL_16;
    v8 = v5[21];
    if (WeakRetained)
      v9 = WeakRetained - 8;
    else
      v9 = 0;
    v10 = v5[8];
    v11 = v10 + 72 * v6;
    v12 = v9 + 8;
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, __int16 *, double))(*(_QWORD *)v9 + 40))(v9, 7, v8, v11, *(_QWORD *)(a1 + 136), *(_QWORD *)(a1 + 88), a1, &v21, *(double *)(v10 + 8));

    if (*(_BYTE *)(a1 + 80))
      *(_BYTE *)(a1 + 80) = 0;
  }
  v13 = (char *)objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 128) + 176));
  v14 = *(_QWORD **)(a1 + 128);
  v6 = *(_QWORD *)(a1 + 144);
  v7 = v14[7];
  if (v7 <= v6)
  {
    v27 = 0;
    v39 = 0u;
    v40 = 0u;
    v37 = 0u;
    v38 = 0u;
    v36 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v28 = 136315906;
    v29 = "operator[]";
    v30 = 1024;
    v31 = 476;
    v32 = 2048;
    v33 = v6;
    v34 = 2048;
    v35 = v7;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_16:
    v27 = 0;
    v39 = 0u;
    v40 = 0u;
    v37 = 0u;
    v38 = 0u;
    v36 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v28 = 136315906;
    v29 = "operator[]";
    v30 = 1024;
    v31 = 476;
    v32 = 2048;
    v33 = v6;
    v34 = 2048;
    v35 = v7;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  v15 = v14[21];
  if (v13)
    v16 = v13 - 8;
  else
    v16 = 0;
  v17 = v14[8];
  v18 = v17 + 72 * v6;
  v19 = v16 + 8;
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, __int16 *, double))(*(_QWORD *)v16 + 40))(v16, 11, v15, v18, *(_QWORD *)(a1 + 136), -1, a1, &v21, *(double *)(v17 + 8));

}

void re::TypedEventTimelineInstance<float>::processEvents(uint64_t a1, __int128 *a2, __int128 *a3)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  float v6;
  double v7;
  double v8;
  uint64_t v12;
  uint64_t v13;
  double v14;
  _QWORD *v15;
  unint64_t v16;
  double v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  __n128 v22;
  _QWORD *v23;
  unint64_t v24;
  uint64_t v25;
  unint64_t v26;
  char *WeakRetained;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  double v31;
  char v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  __int128 *v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  float v43;
  uint64_t v44;
  float *v45;
  unint64_t v46;
  unint64_t v47;
  float *v48;
  float *v49;
  float v50;
  uint64_t v51;
  float v52;
  float v53;
  char v54;
  int v55;
  int v56;
  unint64_t v57;
  char *v58;
  char *v59;
  uint64_t v60;
  uint64_t v61;
  double v62;
  char v63;
  char v64;
  char *v65;
  char *v66;
  uint64_t v67;
  uint64_t v68;
  double v69;
  char *v70;
  char *v71;
  uint64_t v72;
  uint64_t v73;
  double v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  double v78[2];
  double v79[2];
  double v80[2];
  __int128 v81;
  uint64_t v83;
  __int128 v84;
  __int128 v85;
  int v86;
  __int128 v87;
  uint64_t v89;
  __int128 v90;
  __int128 v91;
  int v92;
  __int128 v93;
  uint64_t v95;
  __int128 v96;
  __int128 v97;
  int v98;
  double v99[2];
  char v100[8];
  double v101;
  char v102[8];
  double v103;
  int v104;
  _QWORD v105[2];
  uint64_t v106;
  int v107;
  uint64_t v108;
  uint64_t v109;
  __int128 v110;
  __int128 v111;
  _OWORD v112[2];
  __int128 v113;
  _BYTE v114[28];
  __int16 v115;
  unint64_t v116;
  __int128 v117;
  __int128 v118;
  _OWORD v119[3];
  uint64_t v120;

  v12 = (uint64_t)&v110;
  v120 = *MEMORY[0x24BDAC8D0];
  if (!*((_BYTE *)a2 + 16))
  {
    if (*(_BYTE *)(a1 + 80))
    {
      LOWORD(v110) = 255;
      BYTE2(v110) = 0;
      *(_QWORD *)((char *)&v110 + 4) = 0;
      v111 = 0u;
      memset(v112, 0, 25);
      v26 = *(_QWORD *)(a1 + 88);
      LOBYTE(v99[0]) = 0;
      re::TypedEventTimelineInstance<float>::initAnimationState(a1, (uint64_t)&v110, a3, v26, v99, 0);
      WeakRetained = (char *)objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 128) + 176));
      v28 = WeakRetained ? (uint64_t)(WeakRetained - 8) : 0;
      v29 = *(_QWORD *)(a1 + 128);
      v30 = *(_QWORD *)(v29 + 168);
      v31 = re::TypedEventTimelineInstance<float>::rootAnimationTime(v29);
      (*(void (**)(uint64_t, uint64_t, uint64_t, __int128 *, _QWORD, _QWORD, uint64_t, __int128 *, double))(*(_QWORD *)v28 + 40))(v28, 7, v30, a2, *(_QWORD *)(a1 + 136), *(_QWORD *)(a1 + 88), a1, &v110, v31);

      if (*(_BYTE *)(a1 + 80))
        goto LABEL_94;
    }
    goto LABEL_114;
  }
  v13 = *(_QWORD *)(*(_QWORD *)(a1 + 136) + 80);
  v14 = *((double *)a2 + 3);
  if (!*(_BYTE *)(a1 + 104))
  {
    v32 = *((float *)a2 + 9) < 0.0;
    goto LABEL_59;
  }
  v15 = *(_QWORD **)(a1 + 128);
  v3 = *(_QWORD *)(a1 + 144);
  v16 = v15[7];
  if (v16 <= v3)
    goto LABEL_119;
  v16 = v15[4];
  if (v16 <= v3)
  {
LABEL_120:
    v105[0] = 0;
    v113 = 0u;
    v111 = 0u;
    memset(v112, 0, sizeof(v112));
    v110 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    LODWORD(v117) = 136315906;
    *(_QWORD *)(v12 + 180) = "operator[]";
    WORD6(v117) = 1024;
    *(_DWORD *)(v12 + 190) = 476;
    WORD1(v118) = 2048;
    *(_QWORD *)(v12 + 196) = v3;
    WORD6(v118) = 2048;
    *(_QWORD *)(v12 + 206) = v16;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_121:
    v109 = 0;
    v118 = 0u;
    memset(v119, 0, sizeof(v119));
    v117 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v114 = 136315906;
    *(_QWORD *)(v12 + 132) = "operator[]";
    *(_WORD *)&v114[12] = 1024;
    *(_DWORD *)(v12 + 142) = 476;
    *(_WORD *)&v114[18] = 2048;
    *(_QWORD *)(v12 + 148) = v16;
    v115 = 2048;
    *(_QWORD *)(v12 + 158) = v3;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_122;
  }
  v17 = *(double *)(a1 + 112);
  v18 = v15[8];
  v19 = *(unsigned __int8 *)(v18 + 72 * v3 + 56);
  if (*(_DWORD *)(v18 + 72 * v3 + 48) != *(_DWORD *)(v18 + 72 * v3 + 52))
  {
    v33 = v15[5] + 28 * v3;
    v8 = *(float *)(v33 + 12);
    v7 = *(float *)(v33 + 16);
    goto LABEL_44;
  }
  re::StackScratchAllocator::StackScratchAllocator((re::StackScratchAllocator *)&v110);
  v108 = 0;
  v105[1] = 0;
  v106 = 0;
  v107 = 0;
  v105[0] = &v110;
  re::DynamicArray<int>::setCapacity(v105, 0);
  ++v107;
  LODWORD(v117) = *(_QWORD *)(a1 + 144);
  re::DynamicArray<int>::add(v105, &v117);
  v20 = *(_QWORD *)(a1 + 128);
  do
  {
    v21 = v20;
    v20 = *(_QWORD *)(v20 + 200);
  }
  while (v20);
  v22.n128_f64[0] = CMTimebaseGetRate(*(CMTimebaseRef *)(v21 + 192));
  v23 = *(_QWORD **)(a1 + 128);
  v16 = *(_QWORD *)(a1 + 144);
  v3 = v23[1];
  if (v3 <= v16)
    goto LABEL_121;
  v3 = *(unsigned int *)(v23[2] + 4 * v16);
  v104 = v3;
  if ((v3 & 0x80000000) != 0)
  {
    v3 = 0;
    goto LABEL_40;
  }
  v77 = v13;
  v6 = v22.n128_f64[0];
  v16 = 72;
  while (1)
  {
    v24 = v23[7];
    if (v24 <= v3)
    {
      v109 = 0;
      v118 = 0u;
      memset(v119, 0, sizeof(v119));
      v117 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v114 = 136315906;
      *(_QWORD *)&v114[4] = "operator[]";
      *(_WORD *)&v114[12] = 1024;
      *(_DWORD *)&v114[14] = 476;
      *(_WORD *)&v114[18] = 2048;
      *(_QWORD *)&v114[20] = v3;
      v115 = 2048;
      v116 = v24;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_116:
      v109 = 0;
      v118 = 0u;
      memset(v119, 0, sizeof(v119));
      v117 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v114 = 136315906;
      *(_QWORD *)&v114[4] = "operator[]";
      *(_WORD *)&v114[12] = 1024;
      *(_DWORD *)&v114[14] = 476;
      *(_WORD *)&v114[18] = 2048;
      *(_QWORD *)&v114[20] = v3;
      v115 = 2048;
      v116 = v24;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_117:
      v109 = 0;
      v118 = 0u;
      memset(v119, 0, sizeof(v119));
      v117 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v114 = 136315906;
      *(_QWORD *)&v114[4] = "operator[]";
      *(_WORD *)&v114[12] = 1024;
      *(_DWORD *)&v114[14] = 476;
      *(_WORD *)&v114[18] = 2048;
      *(_QWORD *)&v114[20] = v3;
      v115 = 2048;
      v116 = v24;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_118:
      v109 = 0;
      v118 = 0u;
      memset(v119, 0, sizeof(v119));
      v117 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v114 = 136315906;
      *(_QWORD *)&v114[4] = "operator[]";
      *(_WORD *)&v114[12] = 1024;
      *(_DWORD *)&v114[14] = 476;
      *(_WORD *)&v114[18] = 2048;
      *(_QWORD *)&v114[20] = v4;
      v115 = 2048;
      v116 = v5;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_119:
      v105[0] = 0;
      v113 = 0u;
      v111 = 0u;
      memset(v112, 0, sizeof(v112));
      v110 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      LODWORD(v117) = 136315906;
      *(_QWORD *)(v12 + 180) = "operator[]";
      WORD6(v117) = 1024;
      *(_DWORD *)(v12 + 190) = 476;
      WORD1(v118) = 2048;
      *(_QWORD *)(v12 + 196) = v3;
      WORD6(v118) = 2048;
      *(_QWORD *)(v12 + 206) = v16;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_120;
    }
    v24 = v23[4];
    if (v24 <= v3)
      goto LABEL_116;
    v25 = v23[8] + 72 * v3;
    v19 ^= *(unsigned __int8 *)(v25 + 56);
    if (*(_DWORD *)(v25 + 48) != *(_DWORD *)(v25 + 52))
      break;
    re::DynamicArray<int>::add(v105, &v104);
    v23 = *(_QWORD **)(a1 + 128);
    v3 = v104;
    v24 = v23[1];
    if (v24 <= v104)
      goto LABEL_117;
    v3 = *(unsigned int *)(v23[2] + 4 * v104);
    v104 = v3;
    if ((v3 & 0x80000000) != 0)
    {
      v3 = 0;
      goto LABEL_39;
    }
  }
  v34 = v23[5] + 28 * v3;
  v22.n128_u32[0] = *(_DWORD *)(v34 + 12);
  v8 = v22.n128_f32[0];
  v7 = *(float *)(v34 + 16);
  v35 = v106;
  v3 = 1;
  if (v106)
  {
    v16 = 1;
    v12 = 1;
    do
    {
      v36 = v35 - 1;
      v4 = *(int *)(v108 + 4 * v36);
      v37 = *(_QWORD *)(a1 + 128);
      v5 = *(_QWORD *)(v37 + 32);
      if (v5 <= v4)
        goto LABEL_118;
      v38 = (__int128 *)(*(_QWORD *)(v37 + 40) + 28 * (int)v4);
      v39 = *v38;
      *(_OWORD *)&v114[12] = *(__int128 *)((char *)v38 + 12);
      *(_OWORD *)v114 = v39;
      v114[25] = 3;
      v106 = v36;
      ++v107;
      LOBYTE(v117) = 1;
      *((_QWORD *)&v117 + 1) = 0;
      LOBYTE(v118) = 0;
      LOBYTE(v119[0]) = 0;
      *(_QWORD *)((char *)&v119[1] + 12) = 0x200000000;
      *(_QWORD *)((char *)v119 + 4) = 0;
      *(_QWORD *)((char *)v119 + 12) = 0;
      *(_QWORD *)((char *)&v119[1] + 1) = 0;
      v102[0] = v16;
      if (!(_DWORD)v16)
        goto LABEL_124;
      v103 = v8;
      re::AnimationClock::update((char *)&v117, (uint64_t)v102, (uint64_t)v114, v6);
      v100[0] = v12;
      if (!(_DWORD)v12)
        goto LABEL_125;
      if ((_BYTE)v118)
      {
        v8 = *((double *)&v118 + 1);
        v16 = v16;
      }
      else
      {
        v16 = 0;
      }
      v101 = v7;
      re::AnimationClock::update((char *)&v117, (uint64_t)v100, (uint64_t)v114, v6);
      v22.n128_u64[0] = *((_QWORD *)&v118 + 1);
      if ((_BYTE)v118)
      {
        v7 = *((double *)&v118 + 1);
        v12 = v12;
      }
      else
      {
        v12 = 0;
      }
      v35 = v106;
    }
    while (v106);
    v3 = 1;
    v12 = (uint64_t)&v110;
  }
LABEL_39:
  v13 = v77;
LABEL_40:
  if (v105[0] && v108)
    (*(void (**)(__n128))(*(_QWORD *)v105[0] + 40))(v22);
  re::StackScratchAllocator::~StackScratchAllocator((re::StackScratchAllocator *)&v110);
  if ((_DWORD)v3)
  {
LABEL_44:
    if (v19)
    {
      v87 = *a2;
      if (*((_BYTE *)a2 + 16))
        v89 = *((_QWORD *)a2 + 3);
      v40 = a2[3];
      v90 = a2[2];
      v91 = v40;
      v92 = *((_DWORD *)a2 + 16);
      re::TypedEventTimelineInstance<float>::raiseSkippedEvents(a1, (uint64_t)&v87, a3, v17, v8 + -0.00100000005);
      v17 = v7 + 0.00100000005;
    }
    else
    {
      v93 = *a2;
      if (*((_BYTE *)a2 + 16))
        v95 = *((_QWORD *)a2 + 3);
      v41 = a2[3];
      v96 = a2[2];
      v97 = v41;
      v98 = *((_DWORD *)a2 + 16);
      re::TypedEventTimelineInstance<float>::raiseSkippedEvents(a1, (uint64_t)&v93, a3, v17, v7 + 0.00100000005);
      v17 = v8 + -0.00100000005;
    }
  }
  v81 = *a2;
  if (*((_BYTE *)a2 + 16))
    v83 = *((_QWORD *)a2 + 3);
  v42 = a2[3];
  v84 = a2[2];
  v85 = v42;
  v86 = *((_DWORD *)a2 + 16);
  re::TypedEventTimelineInstance<float>::raiseSkippedEvents(a1, (uint64_t)&v81, a3, v17, v14);
  if (*((float *)a2 + 9) >= 0.0)
  {
    if (!*(_BYTE *)(a1 + 104))
    {
      v32 = 0;
      goto LABEL_59;
    }
    v32 = v14 < *(double *)(a1 + 112);
  }
  else
  {
    v32 = 1;
    if (!*(_BYTE *)(a1 + 104))
LABEL_59:
      *(_BYTE *)(a1 + 104) = 1;
  }
  *(double *)(a1 + 112) = v14;
  if (*(_BYTE *)(v13 + 536) || (v32 & 1) == 0)
  {
    v43 = v14;
    v44 = *(_QWORD *)(v13 + 72);
    v16 = *(_QWORD *)(v13 + 56);
    if (v16)
    {
      v45 = *(float **)(v13 + 72);
      v46 = *(_QWORD *)(v13 + 56);
      do
      {
        v47 = v46 >> 1;
        v48 = &v45[v46 >> 1];
        v50 = *v48;
        v49 = v48 + 1;
        v46 += ~(v46 >> 1);
        if (v43 + 0.00416666667 > v50)
          v45 = v49;
        else
          v46 = v47;
      }
      while (v46);
    }
    else
    {
      v45 = *(float **)(v13 + 72);
    }
    v51 = (uint64_t)v45 - v44;
    if (v51)
    {
      v3 = (v51 >> 2) - 1;
      if (v16 > v3)
      {
        v16 = *(_QWORD *)(v13 + 96);
        if (v16 > v3)
        {
          v52 = *(float *)(v44 + 4 * v3) + *(float *)(*(_QWORD *)(v13 + 112) + 4 * v3);
          if (v52 <= v43 || vabds_f32(v43, v52) < (float)((float)((float)(fabsf(v43) + fabsf(v52)) + 1.0) * 0.00001))
            goto LABEL_75;
          v54 = 0;
LABEL_78:
          v55 = 1;
          goto LABEL_79;
        }
LABEL_123:
        v105[0] = 0;
        v113 = 0u;
        v111 = 0u;
        memset(v112, 0, sizeof(v112));
        v110 = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        LODWORD(v117) = 136315906;
        *(_QWORD *)(v12 + 180) = "operator[]";
        WORD6(v117) = 1024;
        *(_DWORD *)(v12 + 190) = 797;
        WORD1(v118) = 2048;
        *(_QWORD *)(v12 + 196) = v3;
        WORD6(v118) = 2048;
        *(_QWORD *)(v12 + 206) = v16;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_124:
        re::AnimationClock::update((char *)&v117, (uint64_t)v102, (uint64_t)v114, v6);
        re::internal::assertLog((re::internal *)4, v75, "assertion failure: '%s' (%s:line %i) ", "loopStart.hasValue()", "didLoop", 466);
        _os_crash();
        __break(1u);
LABEL_125:
        re::AnimationClock::update((char *)&v117, (uint64_t)v100, (uint64_t)v114, v6);
        re::internal::assertLog((re::internal *)4, v76, "assertion failure: '%s' (%s:line %i) ", "loopEnd.hasValue()", "didLoop", 469);
        _os_crash();
        __break(1u);
      }
LABEL_122:
      v105[0] = 0;
      v113 = 0u;
      v111 = 0u;
      memset(v112, 0, sizeof(v112));
      v110 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      LODWORD(v117) = 136315906;
      *(_QWORD *)(v12 + 180) = "operator[]";
      WORD6(v117) = 1024;
      *(_DWORD *)(v12 + 190) = 797;
      WORD1(v118) = 2048;
      *(_QWORD *)(v12 + 196) = v3;
      WORD6(v118) = 2048;
      *(_QWORD *)(v12 + 206) = v16;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_123;
    }
LABEL_75:
    v53 = re::TimelineEventData::totalDuration((re::TimelineEventData *)(v13 + 24));
    if (v53 == v43 || vabds_f32(v53, v43) < (float)((float)((float)(fabsf(v43) + fabsf(v53)) + 1.0) * 0.00001))
    {
      v54 = 0;
      v3 = *(_QWORD *)(v13 + 56) - 1;
      goto LABEL_78;
    }
    v55 = 0;
    v54 = 1;
LABEL_79:
    LOWORD(v110) = 255;
    BYTE2(v110) = 0;
    *(_QWORD *)((char *)&v110 + 4) = 0;
    v111 = 0u;
    memset(v112, 0, 25);
    v56 = *(unsigned __int8 *)(a1 + 80);
    if ((v54 & 1) == 0 && *(_BYTE *)(a1 + 80))
    {
      v57 = *(_QWORD *)(a1 + 88);
      if (v3 == v57)
      {
LABEL_110:
        LOBYTE(v78[0]) = 1;
        v78[1] = v14;
        re::TypedEventTimelineInstance<float>::initAnimationState(a1, (uint64_t)&v110, a3, v3, v78, v32);
        v70 = (char *)objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 128) + 176));
        if (v70)
          v71 = v70 - 8;
        else
          v71 = 0;
        v72 = *(_QWORD *)(a1 + 128);
        v73 = *(_QWORD *)(v72 + 168);
        v74 = re::TypedEventTimelineInstance<float>::rootAnimationTime(v72);
        (*(void (**)(char *, uint64_t, uint64_t, __int128 *, _QWORD, _QWORD, uint64_t, __int128 *, double))(*(_QWORD *)v71 + 40))(v71, 6, v73, a2, *(_QWORD *)(a1 + 136), *(_QWORD *)(a1 + 88), a1, &v110, v74);

        goto LABEL_114;
      }
LABEL_86:
      LOBYTE(v80[0]) = 1;
      v80[1] = v14;
      re::TypedEventTimelineInstance<float>::initAnimationState(a1, (uint64_t)&v110, a3, v57, v80, v32);
      v58 = (char *)objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 128) + 176));
      if (v58)
        v59 = v58 - 8;
      else
        v59 = 0;
      v60 = *(_QWORD *)(a1 + 128);
      v61 = *(_QWORD *)(v60 + 168);
      v62 = re::TypedEventTimelineInstance<float>::rootAnimationTime(v60);
      (*(void (**)(char *, uint64_t, uint64_t, __int128 *, _QWORD, _QWORD, uint64_t, __int128 *, double))(*(_QWORD *)v59 + 40))(v59, 7, v61, a2, *(_QWORD *)(a1 + 136), *(_QWORD *)(a1 + 88), a1, &v110, v62);

      v56 = *(unsigned __int8 *)(a1 + 80);
      goto LABEL_90;
    }
    if (v56 | v55)
    {
      if (*(_BYTE *)(a1 + 80))
      {
        v57 = *(_QWORD *)(a1 + 88);
        goto LABEL_86;
      }
LABEL_90:
      if (!(v56 | v55))
        goto LABEL_114;
      v63 = v54 ^ 1;
      if (!v56)
        v63 = 1;
      if ((v63 & 1) == 0)
      {
LABEL_94:
        *(_BYTE *)(a1 + 80) = 0;
        goto LABEL_114;
      }
      if (v56)
        v64 = 1;
      else
        v64 = v54;
      if ((v64 & 1) != 0)
      {
        *(_QWORD *)(a1 + 88) = v3;
        if ((v54 & 1) != 0)
          goto LABEL_108;
      }
      else
      {
        *(_BYTE *)(a1 + 80) = 1;
        *(_QWORD *)(a1 + 88) = v3;
      }
      LOBYTE(v79[0]) = 1;
      v79[1] = v14;
      re::TypedEventTimelineInstance<float>::initAnimationState(a1, (uint64_t)&v110, a3, v3, v79, v32);
      v65 = (char *)objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 128) + 176));
      if (v65)
        v66 = v65 - 8;
      else
        v66 = 0;
      v67 = *(_QWORD *)(a1 + 128);
      v68 = *(_QWORD *)(v67 + 168);
      v69 = re::TypedEventTimelineInstance<float>::rootAnimationTime(v67);
      (*(void (**)(char *, uint64_t, uint64_t, __int128 *, _QWORD, unint64_t, uint64_t, __int128 *, double))(*(_QWORD *)v66 + 40))(v66, 5, v68, a2, *(_QWORD *)(a1 + 136), v3, a1, &v110, v69);

      v56 = *(unsigned __int8 *)(a1 + 80);
    }
LABEL_108:
    if (v56)
    {
      v3 = *(_QWORD *)(a1 + 88);
      goto LABEL_110;
    }
  }
LABEL_114:
  *(double *)(a1 + 96) = re::TypedEventTimelineInstance<float>::rootAnimationTime(*(_QWORD *)(a1 + 128));
}

void re::EventTimeline::~EventTimeline(re::EventTimeline *this)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = off_24ED24EF0;
  v2 = *((_QWORD *)this + 10);
  if (v2)
  {

    *((_QWORD *)this + 10) = 0;
  }
  *(_QWORD *)this = off_24ED1F350;
  v3 = *((_QWORD *)this + 5);
  if (v3)
  {
    if ((*((_BYTE *)this + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *((_QWORD *)this + 7));
    *(_OWORD *)((char *)this + 40) = 0u;
    *(_OWORD *)((char *)this + 56) = 0u;
  }
  re::StringID::destroyString((re::EventTimeline *)((char *)this + 24));
}

{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = off_24ED24EF0;
  v2 = *((_QWORD *)this + 10);
  if (v2)
  {

    *((_QWORD *)this + 10) = 0;
  }
  *(_QWORD *)this = off_24ED1F350;
  v3 = *((_QWORD *)this + 5);
  if (v3)
  {
    if ((*((_BYTE *)this + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *((_QWORD *)this + 7));
    *(_OWORD *)((char *)this + 40) = 0u;
    *(_OWORD *)((char *)this + 56) = 0u;
  }
  re::StringID::destroyString((re::EventTimeline *)((char *)this + 24));
  JUMPOUT(0x2276933B8);
}

double re::EventTimeline::totalDuration(re::EventTimeline *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 10);
  if (v1)
    return re::TimelineEventData::totalDuration((re::TimelineEventData *)(v1 + 24));
  else
    return 0.0;
}

void re::EventTimeline::evaluateCore(uint64_t a1, uint64_t a2)
{
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Requires EventTimelineInstance", "!\"Unreachable code\"", "evaluateCore", 366);
  _os_crash();
  __break(1u);
}

uint64_t re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(uint64_t a1, _QWORD *a2)
{
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if (!*(_QWORD *)a1)
    return 0;
  v3 = 0xBF58476D1CE4E5B9 * ((*a2 >> 31) ^ (*a2 >> 1));
  v4 = *(unsigned int *)(*(_QWORD *)(a1 + 8)
                       + 4
                       * (((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) ^ ((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) >> 31))
                        % *(unsigned int *)(a1 + 24)));
  if ((_DWORD)v4 == 0x7FFFFFFF)
    return 0;
  v5 = *(_QWORD *)(a1 + 16);
  while (!re::StringID::operator==((_QWORD *)(v5 + 40 * v4 + 8), a2))
  {
    v4 = *(_DWORD *)(v5 + 40 * v4) & 0x7FFFFFFF;
    if (v4 == 0x7FFFFFFF)
      return 0;
  }
  return v5 + 40 * v4 + 24;
}

void re::SharedEventData::~SharedEventData(re::SharedEventData *this)
{
  *(_QWORD *)this = &off_24ED24F90;
  re::TimelineEventData::~TimelineEventData((re::SharedEventData *)((char *)this + 24));
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  *(_QWORD *)this = &off_24ED24F90;
  re::TimelineEventData::~TimelineEventData((re::SharedEventData *)((char *)this + 24));
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

re::TimelineEventData *re::TimelineEventData::TimelineEventData(re::TimelineEventData *this, const re::TimelineEventData *a2)
{
  re::StringID *v4;

  v4 = re::StringID::StringID(this, (const StringID *)a2);
  re::DynamicArray<float>::DynamicArray((uint64_t)v4 + 16, (uint64_t *)a2 + 2);
  re::DynamicArray<float>::DynamicArray((uint64_t)this + 56, (uint64_t *)a2 + 7);
  re::DynamicArray<float>::DynamicArray((uint64_t)this + 96, (uint64_t *)a2 + 12);
  re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::HashTable((uint64_t)this + 136, (uint64_t)a2 + 136);
  *((_QWORD *)this + 23) = *((_QWORD *)a2 + 23);
  re::DynamicArray<float>::DynamicArray((uint64_t)this + 192, (uint64_t *)a2 + 24);
  *((_QWORD *)this + 29) = *((_QWORD *)a2 + 29);
  re::DynamicArray<float>::DynamicArray((uint64_t)this + 240, (uint64_t *)a2 + 30);
  *((_QWORD *)this + 35) = *((_QWORD *)a2 + 35);
  re::DynamicArray<re::StringID>::DynamicArray((uint64_t)this + 288, (uint64_t *)a2 + 36);
  *((_QWORD *)this + 41) = *((_QWORD *)a2 + 41);
  re::DynamicArray<re::Vector4<float>>::DynamicArray((uint64_t)this + 336, (uint64_t *)a2 + 42);
  *((_QWORD *)this + 47) = *((_QWORD *)a2 + 47);
  re::DynamicArray<re::FixedArray<unsigned char>>::DynamicArray((uint64_t)this + 384, (uint64_t *)a2 + 48);
  *((_QWORD *)this + 53) = *((_QWORD *)a2 + 53);
  re::DynamicArray<re::ObjCObject>::DynamicArray((uint64_t)this + 432, (uint64_t *)a2 + 54);
  *((_BYTE *)this + 472) = *((_BYTE *)a2 + 472);
  re::FixedArray<unsigned char>::FixedArray((_QWORD *)this + 60, (uint64_t *)a2 + 60);
  *((_QWORD *)this + 63) = *((id *)a2 + 63);
  *((_BYTE *)this + 512) = *((_BYTE *)a2 + 512);
  re::DynamicArray<char const*>::DynamicArray((uint64_t)this + 520, (uint64_t *)a2 + 65);
  return this;
}

uint64_t re::DynamicArray<float>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  unint64_t v5;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  v3 = *a2;
  if (*a2)
  {
    v5 = a2[2];
    *(_QWORD *)a1 = v3;
    re::DynamicArray<int>::setCapacity((_QWORD *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<float>::copy((void **)a1, (uint64_t)a2);
  }
  return a1;
}

uint64_t re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::HashTable(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  signed int v5;

  *(_DWORD *)(a1 + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_QWORD *)(a1 + 36) = 0x7FFFFFFFLL;
  v4 = *(_QWORD *)a2;
  if (v4)
  {
    if (*(_DWORD *)(a2 + 28) <= 3u)
      v5 = 3;
    else
      v5 = *(_DWORD *)(a2 + 28);
    re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init(a1, v4, v5);
    re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::copy(a1, a2);
  }
  return a1;
}

void re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 40 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &unk_2260EB7B0, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

void re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::copy(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t i;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;

  re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::clear(a1);
  v4 = *(_DWORD *)(a2 + 28);
  if (*(_DWORD *)(a1 + 24) < v4)
    re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::setCapacity(a1, v4);
  v5 = *(unsigned int *)(a2 + 32);
  if ((_DWORD)v5)
  {
    v6 = 0;
    for (i = 0; i < v5; ++i)
    {
      v8 = *(_QWORD *)(a2 + 16);
      if ((*(_DWORD *)(v8 + v6) & 0x80000000) != 0)
      {
        v9 = 0xBF58476D1CE4E5B9 * ((*(_QWORD *)(v8 + v6 + 8) >> 31) ^ (*(_QWORD *)(v8 + v6 + 8) >> 1));
        v10 = (0x94D049BB133111EBLL * (v9 ^ (v9 >> 27))) ^ ((0x94D049BB133111EBLL * (v9 ^ (v9 >> 27))) >> 31);
        re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addAsCopy(a1, v10 % *(unsigned int *)(a1 + 24), v10, (StringID *)(v8 + v6 + 8), (_OWORD *)(v8 + v6 + 24));
        v5 = *(unsigned int *)(a2 + 32);
      }
      v6 += 40;
    }
  }
}

void re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::clear(uint64_t a1)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t i;
  uint64_t v6;
  int v7;
  int v8;

  if (*(_DWORD *)(a1 + 28))
  {
    v2 = *(unsigned int *)(a1 + 24);
    if ((_DWORD)v2)
      memset_pattern16(*(void **)(a1 + 8), &unk_2260EB7B0, 4 * v2);
    v3 = *(unsigned int *)(a1 + 32);
    if ((_DWORD)v3)
    {
      v4 = 0;
      for (i = 0; i < v3; ++i)
      {
        v6 = *(_QWORD *)(a1 + 16);
        v7 = *(_DWORD *)(v6 + v4);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + v4) = v7 & 0x7FFFFFFF;
          re::StringID::destroyString((re::StringID *)(v6 + v4 + 8));
          v3 = *(unsigned int *)(a1 + 32);
        }
        v4 += 40;
      }
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    v8 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v8;
  }
}

void re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  unsigned int v7;
  __int128 v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  signed int v14;
  _BYTE v15[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v15, 0, 36);
      *(_QWORD *)&v15[36] = 0x7FFFFFFFLL;
      re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init((uint64_t)v15, v4, a2);
      v5 = *(_OWORD *)v15;
      *(_OWORD *)v15 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      v6 = *(_QWORD *)&v15[16];
      *(_QWORD *)&v15[16] = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 16) = v6;
      v8 = *(_OWORD *)&v15[24];
      *(_OWORD *)&v15[24] = *(_OWORD *)(a1 + 24);
      v7 = *(_DWORD *)&v15[32];
      *(_OWORD *)(a1 + 24) = v8;
      v9 = v7;
      if (v7)
      {
        v10 = 0;
        v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(_QWORD *)&v15[16] + v10) & 0x80000000) != 0)
          {
            v12 = 0xBF58476D1CE4E5B9
                * ((*(_QWORD *)(*(_QWORD *)&v15[16] + v10 + 8) >> 31) ^ (*(_QWORD *)(*(_QWORD *)&v15[16] + v10 + 8) >> 1));
            v13 = (0x94D049BB133111EBLL * (v12 ^ (v12 >> 27))) ^ ((0x94D049BB133111EBLL * (v12 ^ (v12 >> 27))) >> 31);
            re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addAsCopy(a1, v13 % *(unsigned int *)(a1 + 24), v13, (StringID *)(*(_QWORD *)&v15[16] + v10 + 8));
            v9 = *(_DWORD *)&v15[32];
          }
          ++v11;
          v10 += 40;
        }
        while (v11 < v9);
      }
      re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)v15);
    }
  }
  else
  {
    if (a2)
      v14 = a2;
    else
      v14 = 3;
  }
}

uint64_t re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, StringID *a4, _OWORD *a5)
{
  uint64_t v9;
  int v10;
  uint64_t v12;
  int v13;
  uint64_t v14;

  v9 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
    v9 = *(unsigned int *)(a1 + 32);
    v10 = v9;
    if ((_DWORD)v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 40 * v9);
  }
  else
  {
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 40 * v9);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  v14 = 40 * v9;
  *(_DWORD *)(v12 + v14) = v13 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + v14) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 40 * v9) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  re::StringID::StringID((re::StringID *)(*(_QWORD *)(a1 + 16) + 40 * v9 + 8), a4);
  *(_OWORD *)(*(_QWORD *)(a1 + 16) + 40 * v9 + 24) = *a5;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

double re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit(uint64_t *a1)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t i;
  uint64_t v6;
  int v7;
  double result;

  v2 = *a1;
  if (v2)
  {
    v3 = *((unsigned int *)a1 + 8);
    if ((_DWORD)v3)
    {
      v4 = 0;
      for (i = 0; i < v3; ++i)
      {
        v6 = a1[2];
        v7 = *(_DWORD *)(v6 + v4);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + v4) = v7 & 0x7FFFFFFF;
          re::StringID::destroyString((re::StringID *)(v6 + v4 + 8));
          v3 = *((unsigned int *)a1 + 8);
        }
        v4 += 40;
      }
      v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

uint64_t re::DynamicArray<re::Vector4<float>>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  unint64_t v5;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  v3 = *a2;
  if (*a2)
  {
    v5 = a2[2];
    *(_QWORD *)a1 = v3;
    re::DynamicArray<re::Vector4<float>>::setCapacity((_QWORD *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::Vector4<float>>::copy((void **)a1, (uint64_t)a2);
  }
  return a1;
}

void **re::DynamicArray<re::Vector4<float>>::copy(void **result, uint64_t a2)
{
  void **v3;
  unint64_t v4;
  void *v5;

  v3 = result;
  v4 = *(_QWORD *)(a2 + 16);
  if (v4 >= (unint64_t)result[2])
  {
    re::DynamicArray<re::Vector4<float>>::setCapacity(result, *(_QWORD *)(a2 + 16));
    v5 = v3[2];
    if (v5)
    {
      memmove(v3[4], *(const void **)(a2 + 32), 16 * (_QWORD)v5);
      v5 = v3[2];
    }
    result = (void **)memcpy((char *)v3[4] + 16 * (_QWORD)v5, (const void *)(*(_QWORD *)(a2 + 32) + 16 * (_QWORD)v5), 16 * v4 - 16 * (_QWORD)v5);
  }
  else if (v4)
  {
    result = (void **)memmove(result[4], *(const void **)(a2 + 32), 16 * v4);
  }
  v3[2] = (void *)v4;
  return result;
}

uint64_t re::DynamicArray<re::FixedArray<unsigned char>>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  unint64_t v5;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  v3 = *a2;
  if (*a2)
  {
    v5 = a2[2];
    *(_QWORD *)a1 = v3;
    re::DynamicArray<re::EvaluationSkeletalPoseInputHandle>::setCapacity((_QWORD *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::FixedArray<unsigned char>>::copy(a1, (uint64_t)a2);
  }
  return a1;
}

uint64_t *re::DynamicArray<re::FixedArray<unsigned char>>::copy(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t *result;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  _QWORD *v13;

  v4 = *(_QWORD *)(a2 + 16);
  if (v4 >= *(_QWORD *)(a1 + 16))
  {
    re::DynamicArray<re::EvaluationSkeletalPoseInputHandle>::setCapacity((_QWORD *)a1, *(_QWORD *)(a2 + 16));
    result = std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::FixedArray<unsigned char> *,re::FixedArray<unsigned char> *,re::FixedArray<unsigned char> *,0>(*(uint64_t **)(a2 + 32), (uint64_t *)(*(_QWORD *)(a2 + 32) + 24 * *(_QWORD *)(a1 + 16)), *(uint64_t **)(a1 + 32));
    v9 = *(_QWORD *)(a1 + 16);
    if (v9 != v4)
    {
      v10 = 3 * v9;
      v11 = (uint64_t *)(*(_QWORD *)(a2 + 32) + 8 * v10);
      result = (uint64_t *)(*(_QWORD *)(a1 + 32) + 8 * v10);
      v12 = 24 * v4 - 8 * v10;
      do
      {
        v13 = re::FixedArray<unsigned char>::FixedArray(result, v11);
        v11 += 3;
        result = v13 + 3;
        v12 -= 24;
      }
      while (v12);
    }
  }
  else
  {
    result = std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::FixedArray<unsigned char> *,re::FixedArray<unsigned char> *,re::FixedArray<unsigned char> *,0>(*(uint64_t **)(a2 + 32), (uint64_t *)(*(_QWORD *)(a2 + 32) + 24 * v4), *(uint64_t **)(a1 + 32));
    v6 = *(_QWORD *)(a1 + 16);
    if (v4 != v6)
    {
      v7 = 24 * v6 - 24 * v4;
      v8 = (_QWORD *)(*(_QWORD *)(a1 + 32) + 24 * v4 + 8);
      do
      {
        result = (uint64_t *)*(v8 - 1);
        if (result)
        {
          if (*v8)
          {
            result = (uint64_t *)(*(uint64_t (**)(uint64_t *, _QWORD))(*result + 40))(result, v8[1]);
            *v8 = 0;
            v8[1] = 0;
          }
          *(v8 - 1) = 0;
        }
        v8 += 3;
        v7 -= 24;
      }
      while (v7);
    }
  }
  *(_QWORD *)(a1 + 16) = v4;
  return result;
}

uint64_t *std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::FixedArray<unsigned char> *,re::FixedArray<unsigned char> *,re::FixedArray<unsigned char> *,0>(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t *v4;

  v4 = a1;
  if (a1 != a2)
  {
    do
    {
      re::FixedArray<unsigned char>::operator=(a3, v4);
      v4 += 3;
      a3 += 3;
    }
    while (v4 != a2);
    return a2;
  }
  return v4;
}

uint64_t *re::FixedArray<unsigned char>::operator=(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4;

  if (a1 != a2)
  {
    v4 = *a2;
    if (*a1)
    {
      if (!v4)
        return a1;
      goto LABEL_7;
    }
    if (v4)
    {
      re::FixedArray<BOOL>::init<>(a1, v4, a2[1]);
LABEL_7:
      re::FixedArray<unsigned char>::copy(a1, (uint64_t)a2);
    }
  }
  return a1;
}

void *re::FixedArray<unsigned char>::copy(void *result, uint64_t a2)
{
  size_t v2;

  v2 = *((_QWORD *)result + 1);
  if (v2 == *(_QWORD *)(a2 + 8))
  {
    if (v2)
      return memmove(*((void **)result + 2), *(const void **)(a2 + 16), v2);
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Cannot copy from a FixedArray of a different size", "m_size == other.m_size", "copy", 388);
    result = (void *)_os_crash();
    __break(1u);
  }
  return result;
}

{
  size_t v2;

  v2 = *((_QWORD *)result + 1);
  if (v2 == *(_QWORD *)(a2 + 8))
  {
    if (v2)
      return memmove(*((void **)result + 2), *(const void **)a2, v2);
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Cannot copy from a Slice of a different size", "m_size == other.size()", "copy", 378);
    result = (void *)_os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::DynamicArray<re::ObjCObject>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  unint64_t v5;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  v3 = *a2;
  if (*a2)
  {
    v5 = a2[2];
    *(_QWORD *)a1 = v3;
    re::DynamicArray<re::ObjCObject>::setCapacity((_QWORD *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::ObjCObject>::copy((_QWORD *)a1, (uint64_t)a2);
  }
  return a1;
}

void re::DynamicArray<re::ObjCObject>::copy(_QWORD *a1, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  id *v6;
  id *v7;
  uint64_t v8;
  id *v9;
  void **v10;
  uint64_t v11;
  void *v12;
  id *v13;
  uint64_t v14;
  id *v15;
  uint64_t v16;
  id *v17;
  void **v18;
  id *v19;
  uint64_t v20;
  void *v21;

  v4 = *(_QWORD *)(a2 + 16);
  v5 = a1[2];
  if (v4 >= v5)
  {
    re::DynamicArray<re::ObjCObject>::setCapacity(a1, *(_QWORD *)(a2 + 16));
    v13 = *(id **)(a2 + 32);
    v14 = a1[2];
    v15 = (id *)a1[4];
    if (v14)
    {
      v16 = 8 * v14;
      do
      {
        v17 = re::ObjCObject::operator=(v15, v13++);
        v15 = v17 + 1;
        v16 -= 8;
      }
      while (v16);
      v15 = (id *)a1[4];
      v14 = a1[2];
      v13 = *(id **)(a2 + 32);
    }
    if (v14 != v4)
    {
      v18 = &v13[v14];
      v19 = &v15[v14];
      v20 = 8 * v4 - 8 * v14;
      do
      {
        v21 = *v18++;
        *v19++ = v21;
        v20 -= 8;
      }
      while (v20);
    }
  }
  else
  {
    v6 = (id *)a1[4];
    if (v4)
    {
      v7 = *(id **)(a2 + 32);
      v8 = 8 * v4;
      do
      {
        v9 = re::ObjCObject::operator=(v6, v7++);
        v6 = v9 + 1;
        v8 -= 8;
      }
      while (v8);
      v6 = (id *)a1[4];
      v5 = a1[2];
    }
    if (v4 != v5)
    {
      v10 = &v6[v4];
      v11 = 8 * v5 - 8 * v4;
      do
      {
        v12 = *v10++;

        v11 -= 8;
      }
      while (v11);
    }
  }
  a1[2] = v4;
}

_QWORD *re::DynamicArray<re::ObjCObject>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  void **v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  void *v12;
  void *v13;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::ObjCObject>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (a2 >> 61)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 8, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          v2 = 8 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 8 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_16;
            goto LABEL_11;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = (void **)v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = 8 * v9;
        v11 = v7;
        do
        {
          v12 = *v8;
          *v8 = 0;
          *v11++ = v12;
          v13 = *v8++;

          v10 -= 8;
        }
        while (v10);
        v8 = (void **)v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, void **))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

_QWORD *re::FixedArray<unsigned char>::FixedArray(_QWORD *a1, uint64_t *a2)
{
  uint64_t v4;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v4 = *a2;
  if (v4)
  {
    re::FixedArray<BOOL>::init<>(a1, v4, a2[1]);
    re::FixedArray<unsigned char>::copy(a1, (uint64_t)a2);
  }
  return a1;
}

uint64_t re::DynamicArray<char const*>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  unint64_t v5;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  v3 = *a2;
  if (*a2)
  {
    v5 = a2[2];
    *(_QWORD *)a1 = v3;
    re::DynamicArray<float *>::setCapacity((_QWORD *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<char const*>::copy((void **)a1, (uint64_t)a2);
  }
  return a1;
}

void **re::DynamicArray<char const*>::copy(void **result, uint64_t a2)
{
  void **v3;
  unint64_t v4;
  void *v5;

  v3 = result;
  v4 = *(_QWORD *)(a2 + 16);
  if (v4 >= (unint64_t)result[2])
  {
    re::DynamicArray<float *>::setCapacity(result, *(_QWORD *)(a2 + 16));
    v5 = v3[2];
    if (v5)
    {
      memmove(v3[4], *(const void **)(a2 + 32), 8 * (_QWORD)v5);
      v5 = v3[2];
    }
    result = (void **)memcpy((char *)v3[4] + 8 * (_QWORD)v5, (const void *)(*(_QWORD *)(a2 + 32) + 8 * (_QWORD)v5), 8 * v4 - 8 * (_QWORD)v5);
  }
  else if (v4)
  {
    result = (void **)memmove(result[4], *(const void **)(a2 + 32), 8 * v4);
  }
  v3[2] = (void *)v4;
  return result;
}

void re::TimelineEventData::~TimelineEventData(re::TimelineEventData *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __n128 v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v2 = *((_QWORD *)this + 65);
  if (v2)
  {
    if (*((_QWORD *)this + 69))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *((_QWORD *)this + 69) = 0;
    *((_QWORD *)this + 66) = 0;
    *((_QWORD *)this + 67) = 0;
    *((_QWORD *)this + 65) = 0;
    ++*((_DWORD *)this + 136);
  }

  v3 = *((_QWORD *)this + 60);
  if (v3)
  {
    if (*((_QWORD *)this + 61))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *((_QWORD *)this + 62));
      *((_QWORD *)this + 61) = 0;
      *((_QWORD *)this + 62) = 0;
    }
    *((_QWORD *)this + 60) = 0;
  }
  re::DynamicArray<re::ObjCObject>::deinit((uint64_t)this + 432);
  re::DynamicArray<re::EvaluationSkeletalPoseInputHandle>::deinit((uint64_t)this + 384);
  v4 = *((_QWORD *)this + 42);
  if (v4)
  {
    if (*((_QWORD *)this + 46))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *((_QWORD *)this + 46) = 0;
    *((_QWORD *)this + 43) = 0;
    *((_QWORD *)this + 44) = 0;
    *((_QWORD *)this + 42) = 0;
    ++*((_DWORD *)this + 90);
  }
  re::DynamicArray<re::StringID>::deinit((uint64_t)this + 288);
  v5 = *((_QWORD *)this + 30);
  if (v5)
  {
    if (*((_QWORD *)this + 34))
      (*(void (**)(uint64_t))(*(_QWORD *)v5 + 40))(v5);
    *((_QWORD *)this + 34) = 0;
    *((_QWORD *)this + 31) = 0;
    *((_QWORD *)this + 32) = 0;
    *((_QWORD *)this + 30) = 0;
    ++*((_DWORD *)this + 66);
  }
  v6 = *((_QWORD *)this + 24);
  if (v6)
  {
    if (*((_QWORD *)this + 28))
      (*(void (**)(uint64_t))(*(_QWORD *)v6 + 40))(v6);
    *((_QWORD *)this + 28) = 0;
    *((_QWORD *)this + 25) = 0;
    *((_QWORD *)this + 26) = 0;
    *((_QWORD *)this + 24) = 0;
    ++*((_DWORD *)this + 54);
  }
  v7.n128_f64[0] = re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 17);
  v8 = *((_QWORD *)this + 12);
  if (v8)
  {
    if (*((_QWORD *)this + 16))
      (*(void (**)(uint64_t, double))(*(_QWORD *)v8 + 40))(v8, v7.n128_f64[0]);
    *((_QWORD *)this + 16) = 0;
    *((_QWORD *)this + 13) = 0;
    *((_QWORD *)this + 14) = 0;
    *((_QWORD *)this + 12) = 0;
    ++*((_DWORD *)this + 30);
  }
  v9 = *((_QWORD *)this + 7);
  if (v9)
  {
    if (*((_QWORD *)this + 11))
      (*(void (**)(uint64_t, __n128))(*(_QWORD *)v9 + 40))(v9, v7);
    *((_QWORD *)this + 11) = 0;
    *((_QWORD *)this + 8) = 0;
    *((_QWORD *)this + 9) = 0;
    *((_QWORD *)this + 7) = 0;
    ++*((_DWORD *)this + 20);
  }
  v10 = *((_QWORD *)this + 2);
  if (v10)
  {
    if (*((_QWORD *)this + 6))
      (*(void (**)(uint64_t, __n128))(*(_QWORD *)v10 + 40))(v10, v7);
    *((_QWORD *)this + 6) = 0;
    *((_QWORD *)this + 3) = 0;
    *((_QWORD *)this + 4) = 0;
    *((_QWORD *)this + 2) = 0;
    ++*((_DWORD *)this + 10);
  }
  re::StringID::destroyString(this);
}

uint64_t re::DynamicArray<re::ObjCObject>::deinit(uint64_t a1)
{
  uint64_t result;
  void **v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(void ***)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 8 * v4;
        do
        {
          v6 = *v3++;

          v5 -= 8;
        }
        while (v5);
        result = *(_QWORD *)a1;
        v3 = *(void ***)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, void **))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

_QWORD *re::DynamicArray<re::FixedArray<unsigned char>>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<re::EvaluationSkeletalPoseInputHandle>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::EvaluationSkeletalPoseInputHandle>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

uint64_t re::TypedEventTimelineInstance<float>::~TypedEventTimelineInstance(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;

  *(_QWORD *)a1 = off_24ED1F350;
  v3 = (_OWORD *)(a1 + 40);
  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 56));
    *v3 = 0u;
    v3[1] = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  return a1;
}

void re::TypedEventTimelineInstance<float>::~TypedEventTimelineInstance(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;

  *(_QWORD *)a1 = off_24ED1F350;
  v3 = (_OWORD *)(a1 + 40);
  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 56));
    *v3 = 0u;
    v3[1] = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  JUMPOUT(0x2276933B8);
}

uint64_t re::TypedEventTimelineInstance<float>::totalDuration(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 136) + 40))(*(_QWORD *)(a1 + 136));
}

uint64_t re::TypedEventTimelineInstance<float>::isInstanced()
{
  return 1;
}

void re::TypedEventTimelineInstance<float>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _DWORD *a6)
{
  id WeakRetained;
  uint64_t v13;
  void *v14;
  int v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  int v23;
  __int128 v24;
  uint64_t v25;
  uint64_t v26;
  _DWORD **v27;
  uint64_t v28;
  uint64_t v29;
  char v30;
  _DWORD *v31;
  int v32;
  char v33;

  WeakRetained = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 128) + 176));
  if (WeakRetained)
  {
    v14 = WeakRetained;
    v15 = *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 80) + 496);
    if (v15 != 255)
    {
      v31 = a6;
      v32 = 0;
      v33 = 1;
      *(_WORD *)((char *)&v24 + 1) = 0;
      *(_QWORD *)((char *)&v24 + 4) = 0;
      v28 = 0;
      v29 = 0;
      v30 = 0;
      LOBYTE(v24) = v15;
      v25 = a4;
      v26 = a5;
      v27 = &v31;
      if (!a3)
      {
        re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
        _os_crash();
        __break(1u);
        return;
      }
      v18 = *(_OWORD *)a2;
      if (*(_BYTE *)(a2 + 16))
        v20 = *(_QWORD *)(a2 + 24);
      v16 = *(_OWORD *)(a2 + 32);
      v17 = *(_OWORD *)(a2 + 48);
      v23 = *(_DWORD *)(a2 + 64);
      v21 = v16;
      v22 = v17;
      re::TypedEventTimelineInstance<float>::processEvents(a1, &v18, &v24);
      if (!v32 && *(_BYTE *)(a1 + 72) && *(_BYTE *)(a2 + 16))
      {
        if (v33)
          *v31 = 0;
      }
    }

  }
}

uint64_t re::TypedEventTimelineInstance<re::GenericSRT<float>>::~TypedEventTimelineInstance(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;

  *(_QWORD *)a1 = off_24ED1F350;
  v3 = (_OWORD *)(a1 + 40);
  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 56));
    *v3 = 0u;
    v3[1] = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  return a1;
}

void re::TypedEventTimelineInstance<re::GenericSRT<float>>::~TypedEventTimelineInstance(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;

  *(_QWORD *)a1 = off_24ED1F350;
  v3 = (_OWORD *)(a1 + 40);
  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 56));
    *v3 = 0u;
    v3[1] = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  JUMPOUT(0x2276933B8);
}

uint64_t re::TypedEventTimelineInstance<re::GenericSRT<float>>::totalDuration(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 136) + 40))(*(_QWORD *)(a1 + 136));
}

uint64_t re::TypedEventTimelineInstance<re::GenericSRT<float>>::isInstanced()
{
  return 1;
}

void re::TypedEventTimelineInstance<re::GenericSRT<float>>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _QWORD *a6)
{
  id WeakRetained;
  uint64_t v13;
  void *v14;
  int v15;
  __int128 v16;
  __int128 v17;
  _QWORD *v18;
  __int128 v19;
  uint64_t v21;
  __int128 v22;
  __int128 v23;
  int v24;
  __int128 v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD **v28;
  uint64_t v29;
  uint64_t v30;
  char v31;
  _QWORD *v32;
  int v33;
  char v34;

  WeakRetained = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 128) + 176));
  if (WeakRetained)
  {
    v14 = WeakRetained;
    v15 = *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 80) + 496);
    if (v15 != 255)
    {
      v32 = a6;
      v33 = 0;
      v34 = 1;
      *(_WORD *)((char *)&v25 + 1) = 0;
      *(_QWORD *)((char *)&v25 + 4) = 0;
      v29 = 0;
      v30 = 0;
      v31 = 0;
      LOBYTE(v25) = v15;
      v26 = a4;
      v27 = a5;
      v28 = &v32;
      if (!a3)
      {
        re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
        _os_crash();
        __break(1u);
        return;
      }
      v19 = *(_OWORD *)a2;
      if (*(_BYTE *)(a2 + 16))
        v21 = *(_QWORD *)(a2 + 24);
      v16 = *(_OWORD *)(a2 + 32);
      v17 = *(_OWORD *)(a2 + 48);
      v24 = *(_DWORD *)(a2 + 64);
      v22 = v16;
      v23 = v17;
      re::TypedEventTimelineInstance<float>::processEvents(a1, &v19, &v25);
      if (!v33 && *(_BYTE *)(a1 + 72) && *(_BYTE *)(a2 + 16))
      {
        if (v34)
        {
          v18 = v32;
          *v32 = 0x3F8000003F800000;
          v18[1] = 1065353216;
          v18[2] = 0;
          v18[3] = 0x3F80000000000000;
          v18[4] = 0;
          v18[5] = 0;
        }
      }
    }

  }
}

uint64_t re::TypedEventTimelineInstance<double>::~TypedEventTimelineInstance(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;

  *(_QWORD *)a1 = off_24ED1F350;
  v3 = (_OWORD *)(a1 + 40);
  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 56));
    *v3 = 0u;
    v3[1] = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  return a1;
}

void re::TypedEventTimelineInstance<double>::~TypedEventTimelineInstance(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;

  *(_QWORD *)a1 = off_24ED1F350;
  v3 = (_OWORD *)(a1 + 40);
  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 56));
    *v3 = 0u;
    v3[1] = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  JUMPOUT(0x2276933B8);
}

uint64_t re::TypedEventTimelineInstance<double>::totalDuration(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 136) + 40))(*(_QWORD *)(a1 + 136));
}

uint64_t re::TypedEventTimelineInstance<double>::isInstanced()
{
  return 1;
}

void re::TypedEventTimelineInstance<double>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _QWORD *a6)
{
  id WeakRetained;
  uint64_t v13;
  void *v14;
  int v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  int v23;
  __int128 v24;
  uint64_t v25;
  uint64_t v26;
  _QWORD **v27;
  uint64_t v28;
  uint64_t v29;
  char v30;
  _QWORD *v31;
  int v32;
  char v33;

  WeakRetained = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 128) + 176));
  if (WeakRetained)
  {
    v14 = WeakRetained;
    v15 = *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 80) + 496);
    if (v15 != 255)
    {
      v31 = a6;
      v32 = 0;
      v33 = 1;
      *(_WORD *)((char *)&v24 + 1) = 0;
      *(_QWORD *)((char *)&v24 + 4) = 0;
      v28 = 0;
      v29 = 0;
      v30 = 0;
      LOBYTE(v24) = v15;
      v25 = a4;
      v26 = a5;
      v27 = &v31;
      if (!a3)
      {
        re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
        _os_crash();
        __break(1u);
        return;
      }
      v18 = *(_OWORD *)a2;
      if (*(_BYTE *)(a2 + 16))
        v20 = *(_QWORD *)(a2 + 24);
      v16 = *(_OWORD *)(a2 + 32);
      v17 = *(_OWORD *)(a2 + 48);
      v23 = *(_DWORD *)(a2 + 64);
      v21 = v16;
      v22 = v17;
      re::TypedEventTimelineInstance<float>::processEvents(a1, &v18, &v24);
      if (!v32 && *(_BYTE *)(a1 + 72) && *(_BYTE *)(a2 + 16))
      {
        if (v33)
          *v31 = 0;
      }
    }

  }
}

uint64_t re::TypedEventTimelineInstance<re::Vector2<float>>::~TypedEventTimelineInstance(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;

  *(_QWORD *)a1 = off_24ED1F350;
  v3 = (_OWORD *)(a1 + 40);
  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 56));
    *v3 = 0u;
    v3[1] = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  return a1;
}

void re::TypedEventTimelineInstance<re::Vector2<float>>::~TypedEventTimelineInstance(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;

  *(_QWORD *)a1 = off_24ED1F350;
  v3 = (_OWORD *)(a1 + 40);
  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 56));
    *v3 = 0u;
    v3[1] = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  JUMPOUT(0x2276933B8);
}

uint64_t re::TypedEventTimelineInstance<re::Vector2<float>>::totalDuration(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 136) + 40))(*(_QWORD *)(a1 + 136));
}

uint64_t re::TypedEventTimelineInstance<re::Vector2<float>>::isInstanced()
{
  return 1;
}

void re::TypedEventTimelineInstance<re::Vector2<float>>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _QWORD *a6)
{
  id WeakRetained;
  uint64_t v13;
  void *v14;
  int v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  int v23;
  __int128 v24;
  uint64_t v25;
  uint64_t v26;
  _QWORD **v27;
  uint64_t v28;
  uint64_t v29;
  char v30;
  _QWORD *v31;
  int v32;
  char v33;

  WeakRetained = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 128) + 176));
  if (WeakRetained)
  {
    v14 = WeakRetained;
    v15 = *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 80) + 496);
    if (v15 != 255)
    {
      v31 = a6;
      v32 = 0;
      v33 = 1;
      *(_WORD *)((char *)&v24 + 1) = 0;
      *(_QWORD *)((char *)&v24 + 4) = 0;
      v28 = 0;
      v29 = 0;
      v30 = 0;
      LOBYTE(v24) = v15;
      v25 = a4;
      v26 = a5;
      v27 = &v31;
      if (!a3)
      {
        re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
        _os_crash();
        __break(1u);
        return;
      }
      v18 = *(_OWORD *)a2;
      if (*(_BYTE *)(a2 + 16))
        v20 = *(_QWORD *)(a2 + 24);
      v16 = *(_OWORD *)(a2 + 32);
      v17 = *(_OWORD *)(a2 + 48);
      v23 = *(_DWORD *)(a2 + 64);
      v21 = v16;
      v22 = v17;
      re::TypedEventTimelineInstance<float>::processEvents(a1, &v18, &v24);
      if (!v32 && *(_BYTE *)(a1 + 72) && *(_BYTE *)(a2 + 16))
      {
        if (v33)
          *v31 = 0;
      }
    }

  }
}

uint64_t re::TypedEventTimelineInstance<re::Vector3<float>>::~TypedEventTimelineInstance(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;

  *(_QWORD *)a1 = off_24ED1F350;
  v3 = (_OWORD *)(a1 + 40);
  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 56));
    *v3 = 0u;
    v3[1] = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  return a1;
}

void re::TypedEventTimelineInstance<re::Vector3<float>>::~TypedEventTimelineInstance(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;

  *(_QWORD *)a1 = off_24ED1F350;
  v3 = (_OWORD *)(a1 + 40);
  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 56));
    *v3 = 0u;
    v3[1] = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  JUMPOUT(0x2276933B8);
}

uint64_t re::TypedEventTimelineInstance<re::Vector3<float>>::totalDuration(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 136) + 40))(*(_QWORD *)(a1 + 136));
}

uint64_t re::TypedEventTimelineInstance<re::Vector3<float>>::isInstanced()
{
  return 1;
}

void re::TypedEventTimelineInstance<re::Vector3<float>>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _OWORD *a6)
{
  id WeakRetained;
  uint64_t v13;
  void *v14;
  int v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  int v23;
  __int128 v24;
  uint64_t v25;
  uint64_t v26;
  _OWORD **v27;
  uint64_t v28;
  uint64_t v29;
  char v30;
  _OWORD *v31;
  int v32;
  char v33;

  WeakRetained = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 128) + 176));
  if (WeakRetained)
  {
    v14 = WeakRetained;
    v15 = *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 80) + 496);
    if (v15 != 255)
    {
      v31 = a6;
      v32 = 0;
      v33 = 1;
      *(_WORD *)((char *)&v24 + 1) = 0;
      *(_QWORD *)((char *)&v24 + 4) = 0;
      v28 = 0;
      v29 = 0;
      v30 = 0;
      LOBYTE(v24) = v15;
      v25 = a4;
      v26 = a5;
      v27 = &v31;
      if (!a3)
      {
        re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
        _os_crash();
        __break(1u);
        return;
      }
      v18 = *(_OWORD *)a2;
      if (*(_BYTE *)(a2 + 16))
        v20 = *(_QWORD *)(a2 + 24);
      v16 = *(_OWORD *)(a2 + 32);
      v17 = *(_OWORD *)(a2 + 48);
      v23 = *(_DWORD *)(a2 + 64);
      v21 = v16;
      v22 = v17;
      re::TypedEventTimelineInstance<float>::processEvents(a1, &v18, &v24);
      if (!v32 && *(_BYTE *)(a1 + 72) && *(_BYTE *)(a2 + 16))
      {
        if (v33)
          *v31 = 0u;
      }
    }

  }
}

uint64_t re::TypedEventTimelineInstance<re::Vector4<float>>::~TypedEventTimelineInstance(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;

  *(_QWORD *)a1 = off_24ED1F350;
  v3 = (_OWORD *)(a1 + 40);
  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 56));
    *v3 = 0u;
    v3[1] = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  return a1;
}

void re::TypedEventTimelineInstance<re::Vector4<float>>::~TypedEventTimelineInstance(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;

  *(_QWORD *)a1 = off_24ED1F350;
  v3 = (_OWORD *)(a1 + 40);
  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 56));
    *v3 = 0u;
    v3[1] = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  JUMPOUT(0x2276933B8);
}

uint64_t re::TypedEventTimelineInstance<re::Vector4<float>>::totalDuration(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 136) + 40))(*(_QWORD *)(a1 + 136));
}

uint64_t re::TypedEventTimelineInstance<re::Vector4<float>>::isInstanced()
{
  return 1;
}

void re::TypedEventTimelineInstance<re::Vector4<float>>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _QWORD *a6)
{
  id WeakRetained;
  uint64_t v13;
  void *v14;
  int v15;
  __int128 v16;
  __int128 v17;
  _QWORD *v18;
  __int128 v19;
  uint64_t v21;
  __int128 v22;
  __int128 v23;
  int v24;
  __int128 v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD **v28;
  uint64_t v29;
  uint64_t v30;
  char v31;
  _QWORD *v32;
  int v33;
  char v34;

  WeakRetained = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 128) + 176));
  if (WeakRetained)
  {
    v14 = WeakRetained;
    v15 = *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 80) + 496);
    if (v15 != 255)
    {
      v32 = a6;
      v33 = 0;
      v34 = 1;
      *(_WORD *)((char *)&v25 + 1) = 0;
      *(_QWORD *)((char *)&v25 + 4) = 0;
      v29 = 0;
      v30 = 0;
      v31 = 0;
      LOBYTE(v25) = v15;
      v26 = a4;
      v27 = a5;
      v28 = &v32;
      if (!a3)
      {
        re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
        _os_crash();
        __break(1u);
        return;
      }
      v19 = *(_OWORD *)a2;
      if (*(_BYTE *)(a2 + 16))
        v21 = *(_QWORD *)(a2 + 24);
      v16 = *(_OWORD *)(a2 + 32);
      v17 = *(_OWORD *)(a2 + 48);
      v24 = *(_DWORD *)(a2 + 64);
      v22 = v16;
      v23 = v17;
      re::TypedEventTimelineInstance<float>::processEvents(a1, &v19, &v25);
      if (!v33 && *(_BYTE *)(a1 + 72) && *(_BYTE *)(a2 + 16))
      {
        if (v34)
        {
          v18 = v32;
          *v32 = 0;
          v18[1] = 0;
        }
      }
    }

  }
}

uint64_t re::TypedEventTimelineInstance<re::Quaternion<float>>::~TypedEventTimelineInstance(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;

  *(_QWORD *)a1 = off_24ED1F350;
  v3 = (_OWORD *)(a1 + 40);
  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 56));
    *v3 = 0u;
    v3[1] = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  return a1;
}

void re::TypedEventTimelineInstance<re::Quaternion<float>>::~TypedEventTimelineInstance(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;

  *(_QWORD *)a1 = off_24ED1F350;
  v3 = (_OWORD *)(a1 + 40);
  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 56));
    *v3 = 0u;
    v3[1] = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  JUMPOUT(0x2276933B8);
}

uint64_t re::TypedEventTimelineInstance<re::Quaternion<float>>::totalDuration(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 136) + 40))(*(_QWORD *)(a1 + 136));
}

uint64_t re::TypedEventTimelineInstance<re::Quaternion<float>>::isInstanced()
{
  return 1;
}

void re::TypedEventTimelineInstance<re::Quaternion<float>>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _QWORD *a6)
{
  id WeakRetained;
  uint64_t v13;
  void *v14;
  int v15;
  __int128 v16;
  __int128 v17;
  _QWORD *v18;
  __int128 v19;
  uint64_t v21;
  __int128 v22;
  __int128 v23;
  int v24;
  __int128 v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD **v28;
  uint64_t v29;
  uint64_t v30;
  char v31;
  _QWORD *v32;
  int v33;
  char v34;

  WeakRetained = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 128) + 176));
  if (WeakRetained)
  {
    v14 = WeakRetained;
    v15 = *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 80) + 496);
    if (v15 != 255)
    {
      v32 = a6;
      v33 = 0;
      v34 = 1;
      *(_WORD *)((char *)&v25 + 1) = 0;
      *(_QWORD *)((char *)&v25 + 4) = 0;
      v29 = 0;
      v30 = 0;
      v31 = 0;
      LOBYTE(v25) = v15;
      v26 = a4;
      v27 = a5;
      v28 = &v32;
      if (!a3)
      {
        re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
        _os_crash();
        __break(1u);
        return;
      }
      v19 = *(_OWORD *)a2;
      if (*(_BYTE *)(a2 + 16))
        v21 = *(_QWORD *)(a2 + 24);
      v16 = *(_OWORD *)(a2 + 32);
      v17 = *(_OWORD *)(a2 + 48);
      v24 = *(_DWORD *)(a2 + 64);
      v22 = v16;
      v23 = v17;
      re::TypedEventTimelineInstance<float>::processEvents(a1, &v19, &v25);
      if (!v33 && *(_BYTE *)(a1 + 72) && *(_BYTE *)(a2 + 16))
      {
        if (v34)
        {
          v18 = v32;
          *v32 = 0;
          v18[1] = 0x3F80000000000000;
        }
      }
    }

  }
}

uint64_t re::TypedEventTimelineInstance<re::SkeletalPose>::~TypedEventTimelineInstance(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;

  *(_QWORD *)a1 = off_24ED1F350;
  v3 = (_OWORD *)(a1 + 40);
  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 56));
    *v3 = 0u;
    v3[1] = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  return a1;
}

void re::TypedEventTimelineInstance<re::SkeletalPose>::~TypedEventTimelineInstance(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;

  *(_QWORD *)a1 = off_24ED1F350;
  v3 = (_OWORD *)(a1 + 40);
  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 56));
    *v3 = 0u;
    v3[1] = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  JUMPOUT(0x2276933B8);
}

uint64_t re::TypedEventTimelineInstance<re::SkeletalPose>::totalDuration(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 136) + 40))(*(_QWORD *)(a1 + 136));
}

uint64_t re::TypedEventTimelineInstance<re::SkeletalPose>::isInstanced()
{
  return 1;
}

void re::TypedEventTimelineInstance<re::SkeletalPose>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  id WeakRetained;
  uint64_t v13;
  void *v14;
  int v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  __int128 v21;
  uint64_t v23;
  __int128 v24;
  __int128 v25;
  int v26;
  __int128 v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t *v30;
  uint64_t v31;
  uint64_t v32;
  char v33;
  uint64_t v34;
  int v35;
  char v36;

  WeakRetained = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 128) + 176));
  if (WeakRetained)
  {
    v14 = WeakRetained;
    v15 = *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 80) + 496);
    if (v15 != 255)
    {
      v34 = a6;
      v35 = 0;
      v36 = 1;
      *(_WORD *)((char *)&v27 + 1) = 0;
      *(_QWORD *)((char *)&v27 + 4) = 0;
      v31 = 0;
      v32 = 0;
      v33 = 0;
      LOBYTE(v27) = v15;
      v28 = a4;
      v29 = a5;
      v30 = &v34;
      if (!a3)
      {
        re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
        _os_crash();
        __break(1u);
        return;
      }
      v21 = *(_OWORD *)a2;
      if (*(_BYTE *)(a2 + 16))
        v23 = *(_QWORD *)(a2 + 24);
      v16 = *(_OWORD *)(a2 + 32);
      v17 = *(_OWORD *)(a2 + 48);
      v26 = *(_DWORD *)(a2 + 64);
      v24 = v16;
      v25 = v17;
      re::TypedEventTimelineInstance<float>::processEvents(a1, &v21, &v27);
      if (!v35)
      {
        if (*(_BYTE *)(a1 + 72))
        {
          if (*(_BYTE *)(a2 + 16))
          {
            if (v36)
            {
              v18 = *(_QWORD *)(v34 + 24);
              if (v18)
              {
                v19 = *(_QWORD **)(v34 + 32);
                v20 = &v19[6 * v18];
                do
                {
                  *v19 = 0x3F8000003F800000;
                  v19[1] = 1065353216;
                  v19[2] = 0;
                  v19[3] = 0x3F80000000000000;
                  v19[4] = 0;
                  v19[5] = 0;
                  v19 += 6;
                }
                while (v19 != v20);
              }
            }
          }
        }
      }
    }

  }
}

_QWORD *re::RigGraphCompilation::init(re::RigGraphCompilation *this, re::Allocator *a2)
{
  re::RigGraphCompilation *v3;
  _QWORD *result;

  v3 = this;
  re::BucketArray<std::unique_ptr<void,std::function<void ()(void *)>>,64ul>::init((uint64_t)this, (uint64_t)a2, 1uLL);
  *((_QWORD *)v3 + 7) = a2;
  re::DynamicArray<re::RigDataValue>::setCapacity((_QWORD *)v3 + 7, 0);
  *((_QWORD *)v3 + 12) = a2;
  v3 = (re::RigGraphCompilation *)((char *)v3 + 96);
  ++*((_DWORD *)v3 - 4);
  result = re::DynamicArray<re::RigDataValue>::setCapacity(v3, 0);
  ++*((_DWORD *)v3 + 6);
  return result;
}

uint64_t re::BucketArray<std::unique_ptr<void,std::function<void ()(void *)>>,64ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t result;

  *(_QWORD *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((_QWORD *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(_QWORD *)(a1 + 40) = 0;
  result = re::BucketArray<std::unique_ptr<void,std::function<void ()(void *)>>,64ul>::setBucketsCapacity(a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

uint64_t re::RigGraphCompilation::setRuntimeContext(uint64_t result, re::EvaluationContext *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v3 = result;
  v4 = *(_QWORD *)(result + 72);
  if (v4)
  {
    v5 = *(_QWORD *)(result + 88);
    v6 = 288 * v4;
    do
    {
      result = re::RigDataValue::setRuntimeContext(v5, a2);
      v5 += 288;
      v6 -= 288;
    }
    while (v6);
  }
  v7 = *(_QWORD *)(v3 + 112);
  if (v7)
  {
    v8 = *(_QWORD *)(v3 + 128);
    v9 = 288 * v7;
    do
    {
      result = re::RigDataValue::setRuntimeContext(v8, a2);
      v8 += 288;
      v9 -= 288;
    }
    while (v9);
  }
  return result;
}

uint64_t re::RigGraphCompilation::setInputOutputValues(_QWORD *a1, re::EvaluationContextManager *a2, _QWORD **a3, _QWORD **a4)
{
  uint64_t v7;
  re::RigDataValue *v8;
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  re::DynamicArray<re::RigDataValue>::operator=((uint64_t)(a1 + 7), a3);
  v7 = a1[9];
  if (v7)
  {
    v8 = (re::RigDataValue *)a1[11];
    v9 = 288 * v7;
    do
    {
      if (*((_BYTE *)v8 + 32) != 10)
        re::RigDataValue::resolveRuntimeInputValues(v8, a2);
      v8 = (re::RigDataValue *)((char *)v8 + 288);
      v9 -= 288;
    }
    while (v9);
  }
  result = re::DynamicArray<re::RigDataValue>::operator=((uint64_t)(a1 + 12), a4);
  v11 = a1[14];
  if (v11)
  {
    v12 = a1[16];
    v13 = 288 * v11;
    do
    {
      if (*(_BYTE *)(v12 + 32) != 10)
        result = (uint64_t)re::RigDataValue::resolveRuntimeOutputValues((_QWORD *)v12, a2);
      v12 += 288;
      v13 -= 288;
    }
    while (v13);
  }
  return result;
}

uint64_t re::DynamicArray<re::RigDataValue>::operator=(uint64_t a1, _QWORD **a2)
{
  unint64_t v4;

  v4 = (unint64_t)a2[1];
  if (*(_QWORD *)a1)
  {
    if (v4)
    {
      re::DynamicArray<re::RigDataValue>::copy((_QWORD *)a1, 0, *a2, v4);
      re::DynamicArray<re::RigDataValue>::resize(a1, (unint64_t)a2[1]);
    }
    else
    {
      re::DynamicArray<re::RigDataValue>::clear((re::RigDataValue *)a1);
    }
  }
  else if (v4)
  {
    re::DynamicArray<re::RigDataValue>::setCapacity((_QWORD *)a1, v4);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::RigDataValue>::copy((_QWORD *)a1, 0, *a2, (uint64_t)a2[1]);
  }
  return a1;
}

uint64_t *re::BucketArray<std::unique_ptr<void,std::function<void ()(void *)>>,64ul>::setBucketsCapacity(uint64_t *result, unint64_t a2)
{
  uint64_t *v3;
  unint64_t v4;
  uint64_t v5;

  v3 = result;
  if (*result)
  {
    if (result[5] < a2 << 6)
    {
      while (1)
      {
        v4 = v3[1];
        if (v4 <= a2)
          break;
        result = (uint64_t *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      while (v4 < a2)
      {
        v5 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)*v3 + 32))(*v3, 2560, 0);
        result = (uint64_t *)re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::add((uint64_t)v3, &v5);
        v4 = v3[1];
      }
    }
  }
  else
  {
  }
  return result;
}

_anonymous_namespace_ *re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::add(uint64_t a1, _QWORD *a2)
{
  _anonymous_namespace_ *result;
  uint64_t v5;
  uint64_t v6;

  result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::ensureCapacity((_anonymous_namespace_ *)a1);
  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
    v5 = a1 + 24;
  else
    v5 = *(_QWORD *)(a1 + 32);
  v6 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(v5 + 8 * v6) = *a2;
  *(_QWORD *)(a1 + 8) = v6 + 1;
  *(_DWORD *)(a1 + 16) += 2;
  return result;
}

_anonymous_namespace_ *re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::ensureCapacity(_anonymous_namespace_ *result)
{
  _anonymous_namespace_ *v1;
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;

  v1 = result;
  if (!*(_QWORD *)result)
  {
    v7 = *((_QWORD *)v1 + 1) + 1;
    result = (_anonymous_namespace_ *)re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v1, v7);
    *((_DWORD *)v1 + 4) += 2;
    return result;
  }
  v2 = *((_QWORD *)result + 1);
  if ((*((_BYTE *)result + 16) & 1) != 0)
  {
    v4 = v2 + 1;
    if (v4 < 3)
      return result;
    v6 = 4;
    goto LABEL_12;
  }
  v3 = *((_QWORD *)result + 3);
  v5 = v2 >= v3;
  v4 = v2 + 1;
  v5 = !v5 || v3 >= v4;
  if (!v5)
  {
    v6 = 2 * v3;
LABEL_12:
    if (v6 <= v4)
      v8 = v4;
    else
      v8 = v6;
    return (_anonymous_namespace_ *)re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(result, v8);
  }
  return result;
}

_QWORD *re::DynamicArray<re::RigDataValue>::copy(_QWORD *this, unint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v10;
  const re::RigDataValue *v11;
  uint64_t v12;
  re::RigDataValue *v13;
  uint64_t v14;
  __int128 v15;

  if (!a4)
    return this;
  v6 = this;
  v7 = this[2];
  if (v7 + 1 <= a2)
  {
    v14 = 0;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    LODWORD(v15) = 136315906;
    *(_QWORD *)((char *)&v15 + 4) = "copy";
    WORD6(v15) = 1024;
    HIWORD(v15) = 643;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)7, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::copy(). size = %zu, pos = %zu, count = %zu", "!overflow", "copy", 647, v7, a2, v4, v14, v15);
    _os_crash();
    __break(1u);
  }
  v4 = a4;
  v8 = a2 + a4;
  if (__CFADD__(a2, a4))
    goto LABEL_13;
  if (v7 >= v8)
  {
    this = std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::RigDataValue const*,re::RigDataValue const*,re::RigDataValue*,0>(a3, &a3[36 * a4], (_QWORD *)(this[4] + 288 * a2));
  }
  else
  {
    re::DynamicArray<re::RigDataValue>::growCapacity(this, a2 + a4);
    v10 = v6[2];
    v11 = (const re::RigDataValue *)&a3[36 * (v10 - a2)];
    this = std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::RigDataValue const*,re::RigDataValue const*,re::RigDataValue*,0>(a3, v11, (_QWORD *)(v6[4] + 288 * a2));
    if (v10 - a2 != v4)
    {
      this = (_QWORD *)(v6[4] + 288 * v6[2]);
      v12 = 288 * a2 + 288 * v4 - 288 * v10;
      do
      {
        v13 = re::RigDataValue::RigDataValue((re::RigDataValue *)this, v11);
        v11 = (const re::RigDataValue *)((char *)v11 + 288);
        this = (_QWORD *)((char *)v13 + 288);
        v12 -= 288;
      }
      while (v12);
    }
    v6[2] = v8;
  }
  ++*((_DWORD *)v6 + 6);
  return this;
}

_QWORD *std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::RigDataValue const*,re::RigDataValue const*,re::RigDataValue*,0>(_QWORD *result, _QWORD *a2, _QWORD *a3)
{
  uint64_t v5;

  if (result != a2)
  {
    v5 = (uint64_t)result;
    do
    {
      result = re::RigDataValue::operator=(a3, v5);
      v5 += 288;
      a3 += 36;
    }
    while ((_QWORD *)v5 != a2);
  }
  return result;
}

uint64_t re::BucketArray<std::unique_ptr<void,std::function<void ()(void *)>>,64ul>::addUninitialized(uint64_t a1)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = *(_QWORD *)(a1 + 40);
  v3 = *(_QWORD *)(a1 + 8);
  if (v2 + 1 > v3 << 6)
  {
    re::BucketArray<std::unique_ptr<void,std::function<void ()(void *)>>,64ul>::setBucketsCapacity((uint64_t *)a1, (v2 + 64) >> 6);
    v3 = *(_QWORD *)(a1 + 8);
  }
  if (v3 <= v2 >> 6)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
    v4 = a1 + 24;
  else
    v4 = *(_QWORD *)(a1 + 32);
  v5 = *(_QWORD *)(v4 + 8 * (v2 >> 6));
  ++*(_QWORD *)(a1 + 40);
  ++*(_DWORD *)(a1 + 48);
  return v5 + 40 * (v2 & 0x3F);
}

_QWORD *std::unique_ptr<void,std::function<void ()(void *)>>::unique_ptr[abi:nn180100](_QWORD *a1, uint64_t *a2)
{
  uint64_t v3;
  _QWORD *v4;
  uint64_t *v5;

  v3 = *a2;
  *a2 = 0;
  *a1 = v3;
  v4 = a1 + 1;
  v5 = (uint64_t *)a2[4];
  if (v5)
  {
    if (v5 == a2 + 1)
    {
      a1[4] = v4;
      (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)a2[4] + 24))(a2[4], v4);
    }
    else
    {
      a1[4] = v5;
      a2[4] = 0;
    }
  }
  else
  {
    a1[4] = 0;
  }
  return a1;
}

double re::FromToByAnimation<float>::totalDuration(uint64_t a1)
{
  return *(double *)(a1 + 80);
}

uint64_t re::FromToByAnimation<float>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, float *a4, float *a5, float *a6, __n128 a7)
{
  double v11;
  float v12;
  uint64_t result;
  int v14;
  float *v15;
  float v16;
  float *v17;
  float v18;

  if (a3)
  {
    v11 = *(double *)(a1 + 80);
    a7.n128_u32[0] = 1.0;
    v12 = 1.0;
    if (fabs(v11) >= 1.0e-12)
      v12 = *(double *)(a2 + 24) / v11;
    if (v12 <= 1.0)
      a7.n128_f32[0] = v12;
    if (a7.n128_f32[0] < 0.0)
      a7.n128_f32[0] = 0.0;
    result = *(_QWORD *)(a1 + 112);
    if (result)
      result = (*(uint64_t (**)(uint64_t, __n128))(*(_QWORD *)result + 16))(result, a7);
    v18 = 0.0;
    v14 = *(unsigned __int8 *)(a1 + 88);
    if (*(_BYTE *)(a1 + 88))
    {
      v15 = (float *)(a1 + 92);
    }
    else
    {
      v15 = a4;
      if (*(_BYTE *)(a1 + 96))
      {
        v15 = a4;
        if (*(_BYTE *)(a1 + 104))
        {
          v18 = *(float *)(a1 + 100) - *(float *)(a1 + 108);
          v15 = &v18;
        }
      }
    }
    if (a7.n128_f32[0] == 0.0)
    {
      v16 = *v15;
    }
    else
    {
      if (*(_BYTE *)(a1 + 96))
      {
        v17 = (float *)(a1 + 100);
      }
      else if (*(_BYTE *)(a1 + 104))
      {
        v18 = *v15 + *(float *)(a1 + 108);
        v17 = &v18;
      }
      else if (v14)
      {
        v17 = a4;
      }
      else
      {
        v17 = a5;
      }
      if (a7.n128_f32[0] == 1.0)
        v16 = *v17;
      else
        v16 = (float)(a7.n128_f32[0] * *v17) + (float)(*v15 * (float)(1.0 - a7.n128_f32[0]));
    }
    *a6 = v16;
  }
  else
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

double re::FromToByAnimation<double>::totalDuration(uint64_t a1)
{
  return *(double *)(a1 + 80);
}

uint64_t re::FromToByAnimation<double>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, double *a4, double *a5, double *a6, __n128 a7)
{
  double v11;
  float v12;
  uint64_t result;
  int v14;
  double *v15;
  double v16;
  double *v17;
  double v18;

  if (a3)
  {
    v11 = *(double *)(a1 + 80);
    a7.n128_u32[0] = 1.0;
    v12 = 1.0;
    if (fabs(v11) >= 1.0e-12)
      v12 = *(double *)(a2 + 24) / v11;
    if (v12 <= 1.0)
      a7.n128_f32[0] = v12;
    if (a7.n128_f32[0] < 0.0)
      a7.n128_f32[0] = 0.0;
    result = *(_QWORD *)(a1 + 136);
    if (result)
      result = (*(uint64_t (**)(uint64_t, __n128))(*(_QWORD *)result + 16))(result, a7);
    v18 = 0.0;
    v14 = *(unsigned __int8 *)(a1 + 88);
    if (*(_BYTE *)(a1 + 88))
    {
      v15 = (double *)(a1 + 96);
    }
    else
    {
      v15 = a4;
      if (*(_BYTE *)(a1 + 104))
      {
        v15 = a4;
        if (*(_BYTE *)(a1 + 120))
        {
          v18 = *(double *)(a1 + 112) - *(double *)(a1 + 128);
          v15 = &v18;
        }
      }
    }
    if (a7.n128_f32[0] == 0.0)
    {
      v16 = *v15;
    }
    else
    {
      if (*(_BYTE *)(a1 + 104))
      {
        v17 = (double *)(a1 + 112);
      }
      else if (*(_BYTE *)(a1 + 120))
      {
        v18 = *v15 + *(double *)(a1 + 128);
        v17 = &v18;
      }
      else if (v14)
      {
        v17 = a4;
      }
      else
      {
        v17 = a5;
      }
      if (a7.n128_f32[0] == 1.0)
        v16 = *v17;
      else
        v16 = *v17 * a7.n128_f32[0] + *v15 * (float)(1.0 - a7.n128_f32[0]);
    }
    *a6 = v16;
  }
  else
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

double re::FromToByAnimation<re::Vector2<float>>::totalDuration(uint64_t a1)
{
  return *(double *)(a1 + 80);
}

uint64_t re::FromToByAnimation<re::Vector2<float>>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, float32x2_t *a4, float32x2_t *a5, float32x2_t *a6, __n128 a7)
{
  double v11;
  float v12;
  uint64_t result;
  int v14;
  float32x2_t *v15;
  float32x2_t v16;
  float32x2_t *v17;
  float32x2_t v18;

  if (a3)
  {
    v11 = *(double *)(a1 + 80);
    a7.n128_u32[0] = 1.0;
    v12 = 1.0;
    if (fabs(v11) >= 1.0e-12)
      v12 = *(double *)(a2 + 24) / v11;
    if (v12 <= 1.0)
      a7.n128_f32[0] = v12;
    if (a7.n128_f32[0] < 0.0)
      a7.n128_f32[0] = 0.0;
    result = *(_QWORD *)(a1 + 136);
    if (result)
      result = (*(uint64_t (**)(uint64_t, __n128))(*(_QWORD *)result + 16))(result, a7);
    v18 = 0;
    v14 = *(unsigned __int8 *)(a1 + 88);
    if (*(_BYTE *)(a1 + 88))
    {
      v15 = (float32x2_t *)(a1 + 96);
    }
    else
    {
      v15 = a4;
      if (*(_BYTE *)(a1 + 104))
      {
        v15 = a4;
        if (*(_BYTE *)(a1 + 120))
        {
          v18 = vsub_f32(*(float32x2_t *)(a1 + 112), *(float32x2_t *)(a1 + 128));
          v15 = &v18;
        }
      }
    }
    if (a7.n128_f32[0] == 0.0)
    {
      v16 = *v15;
    }
    else
    {
      if (*(_BYTE *)(a1 + 104))
      {
        v17 = (float32x2_t *)(a1 + 112);
      }
      else if (*(_BYTE *)(a1 + 120))
      {
        v18 = vadd_f32(*v15, *(float32x2_t *)(a1 + 128));
        v17 = &v18;
      }
      else if (v14)
      {
        v17 = a4;
      }
      else
      {
        v17 = a5;
      }
      if (a7.n128_f32[0] != 1.0)
      {
        *a6 = vadd_f32(vmul_n_f32(*v15, 1.0 - a7.n128_f32[0]), vmul_n_f32(*v17, a7.n128_f32[0]));
        return result;
      }
      v16 = *v17;
    }
    *a6 = v16;
  }
  else
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

double re::FromToByAnimation<re::Vector3<float>>::totalDuration(uint64_t a1)
{
  return *(double *)(a1 + 80);
}

uint64_t re::FromToByAnimation<re::Vector3<float>>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, float32x4_t *a4, float32x4_t *a5, float32x4_t *a6, __n128 a7)
{
  double v11;
  float v12;
  uint64_t result;
  int v14;
  float32x4_t *v15;
  float32x4_t v16;
  float32x4_t *v17;
  float32x4_t v18;

  if (a3)
  {
    v11 = *(double *)(a1 + 80);
    a7.n128_u32[0] = 1.0;
    v12 = 1.0;
    if (fabs(v11) >= 1.0e-12)
      v12 = *(double *)(a2 + 24) / v11;
    if (v12 <= 1.0)
      a7.n128_f32[0] = v12;
    if (a7.n128_f32[0] < 0.0)
      a7.n128_f32[0] = 0.0;
    result = *(_QWORD *)(a1 + 192);
    if (result)
      result = (*(uint64_t (**)(uint64_t, __n128))(*(_QWORD *)result + 16))(result, a7);
    v18 = 0u;
    v14 = *(unsigned __int8 *)(a1 + 96);
    if (*(_BYTE *)(a1 + 96))
    {
      v15 = (float32x4_t *)(a1 + 112);
    }
    else
    {
      v15 = a4;
      if (*(_BYTE *)(a1 + 128))
      {
        v15 = a4;
        if (*(_BYTE *)(a1 + 160))
        {
          v18 = vsubq_f32(*(float32x4_t *)(a1 + 144), *(float32x4_t *)(a1 + 176));
          v15 = &v18;
        }
      }
    }
    if (a7.n128_f32[0] == 0.0)
    {
      v16 = *v15;
    }
    else
    {
      if (*(_BYTE *)(a1 + 128))
      {
        v17 = (float32x4_t *)(a1 + 144);
      }
      else if (*(_BYTE *)(a1 + 160))
      {
        v18 = vaddq_f32(*v15, *(float32x4_t *)(a1 + 176));
        v17 = &v18;
      }
      else if (v14)
      {
        v17 = a4;
      }
      else
      {
        v17 = a5;
      }
      if (a7.n128_f32[0] == 1.0)
        v16 = *v17;
      else
        v16 = vmlaq_n_f32(vmulq_n_f32(*v17, a7.n128_f32[0]), *v15, 1.0 - a7.n128_f32[0]);
    }
    *a6 = v16;
  }
  else
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

double re::FromToByAnimation<re::Vector4<float>>::totalDuration(uint64_t a1)
{
  return *(double *)(a1 + 80);
}

uint64_t re::FromToByAnimation<re::Vector4<float>>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, float32x4_t *a4, float32x4_t *a5, float32x4_t *a6, __n128 a7)
{
  double v11;
  float v12;
  uint64_t result;
  int v14;
  float32x4_t *v15;
  float32x4_t v16;
  float32x4_t *v17;
  float32x4_t v18;

  if (a3)
  {
    v11 = *(double *)(a1 + 80);
    a7.n128_u32[0] = 1.0;
    v12 = 1.0;
    if (fabs(v11) >= 1.0e-12)
      v12 = *(double *)(a2 + 24) / v11;
    if (v12 <= 1.0)
      a7.n128_f32[0] = v12;
    if (a7.n128_f32[0] < 0.0)
      a7.n128_f32[0] = 0.0;
    result = *(_QWORD *)(a1 + 192);
    if (result)
      result = (*(uint64_t (**)(uint64_t, __n128))(*(_QWORD *)result + 16))(result, a7);
    v18 = 0uLL;
    v14 = *(unsigned __int8 *)(a1 + 96);
    if (*(_BYTE *)(a1 + 96))
    {
      v15 = (float32x4_t *)(a1 + 112);
    }
    else
    {
      v15 = a4;
      if (*(_BYTE *)(a1 + 128))
      {
        v15 = a4;
        if (*(_BYTE *)(a1 + 160))
        {
          v18 = vsubq_f32(*(float32x4_t *)(a1 + 144), *(float32x4_t *)(a1 + 176));
          v15 = &v18;
        }
      }
    }
    if (a7.n128_f32[0] == 0.0)
    {
      v16 = *v15;
    }
    else
    {
      if (*(_BYTE *)(a1 + 128))
      {
        v17 = (float32x4_t *)(a1 + 144);
      }
      else if (*(_BYTE *)(a1 + 160))
      {
        v18 = vaddq_f32(*v15, *(float32x4_t *)(a1 + 176));
        v17 = &v18;
      }
      else if (v14)
      {
        v17 = a4;
      }
      else
      {
        v17 = a5;
      }
      if (a7.n128_f32[0] == 1.0)
        v16 = *v17;
      else
        v16 = vaddq_f32(vmulq_n_f32(*v15, 1.0 - a7.n128_f32[0]), vmulq_n_f32(*v17, a7.n128_f32[0]));
    }
    *a6 = v16;
  }
  else
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

double re::FromToByAnimation<re::Quaternion<float>>::totalDuration(uint64_t a1)
{
  return *(double *)(a1 + 80);
}

void re::FromToByAnimation<re::Quaternion<float>>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, int32x4_t *a4, float32x4_t *a5, uint64_t *a6, __n128 a7)
{
  double v11;
  float v12;
  uint64_t v13;
  int v14;
  int32x4_t *v15;
  float32x4_t v16;
  float32x4_t v19;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t *v27;
  float32x4_t v30;
  float32x4_t v31;
  __int128 v33;

  if (a3)
  {
    v11 = *(double *)(a1 + 80);
    a7.n128_u32[0] = 1.0;
    v12 = 1.0;
    if (fabs(v11) >= 1.0e-12)
      v12 = *(double *)(a2 + 24) / v11;
    if (v12 <= 1.0)
      a7.n128_f32[0] = v12;
    if (a7.n128_f32[0] < 0.0)
      a7.n128_f32[0] = 0.0;
    v13 = *(_QWORD *)(a1 + 192);
    if (v13)
      (*(void (**)(uint64_t, __n128))(*(_QWORD *)v13 + 16))(v13, a7);
    v33 = xmmword_2260E5D70;
    v14 = *(unsigned __int8 *)(a1 + 96);
    if (*(_BYTE *)(a1 + 96))
    {
      v15 = (int32x4_t *)(a1 + 112);
    }
    else
    {
      v15 = a4;
      if (*(_BYTE *)(a1 + 128))
      {
        v15 = a4;
        if (*(_BYTE *)(a1 + 160))
        {
          v33 = *(_OWORD *)(a1 + 176);
          _V1.S[3] = HIDWORD(v33);
          _Q2 = (int32x4_t)vnegq_f32((float32x4_t)v33);
          v19 = *(float32x4_t *)(a1 + 144);
          _Q5 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v19, (int32x4_t)v19), (int8x16_t)v19, 0xCuLL), (float32x4_t)v33), v19, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(_Q2, _Q2), (int8x16_t)_Q2, 0xCuLL));
          v21 = vmlaq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(_Q5, _Q5), (int8x16_t)_Q5, 0xCuLL), v19, (float32x4_t)v33, 3);
          _Q5.i32[0] = v19.i32[3];
          v22 = vmlsq_laneq_f32(v21, (float32x4_t)v33, v19, 3);
          __asm { FMLA            S2, S5, V1.S[3] }
          v22.i32[3] = _Q2.i32[0];
          v33 = (__int128)v22;
          v15 = (int32x4_t *)&v33;
        }
      }
    }
    if (a7.n128_f32[0] == 0.0)
    {
      v16 = *(float32x4_t *)v15;
    }
    else
    {
      if (*(_BYTE *)(a1 + 128))
      {
        v27 = (float32x4_t *)(a1 + 144);
      }
      else if (*(_BYTE *)(a1 + 160))
      {
        _Q1 = *(float32x4_t *)(a1 + 176);
        _Q4 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(*v15, *v15), *(int8x16_t *)v15, 0xCuLL), vnegq_f32(_Q1)), *(float32x4_t *)v15, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q1, (int32x4_t)_Q1), (int8x16_t)_Q1, 0xCuLL));
        v30 = vmlaq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(_Q4, _Q4), (int8x16_t)_Q4, 0xCuLL), *(float32x4_t *)v15, _Q1, 3);
        _Q4.i32[0] = HIDWORD(*(unsigned __int128 *)v15);
        v31 = vmlaq_laneq_f32(v30, _Q1, *(float32x4_t *)v15, 3);
        __asm { FMLA            S2, S4, V1.S[3] }
        v31.i32[3] = _S2;
        v33 = (__int128)v31;
        v27 = (float32x4_t *)&v33;
      }
      else if (v14)
      {
        v27 = (float32x4_t *)a4;
      }
      else
      {
        v27 = a5;
      }
      if (a7.n128_f32[0] != 1.0)
      {
        re::AnimationValueTraits<re::Quaternion<float>>::interpolate((float32x4_t *)v15, v27, a6, a7.n128_f32[0]);
        return;
      }
      v16 = *v27;
    }
    *(float32x4_t *)a6 = v16;
  }
  else
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
  }
}

double re::FromToByAnimation<re::GenericSRT<float>>::totalDuration(uint64_t a1)
{
  return *(double *)(a1 + 80);
}

void re::FromToByAnimation<re::GenericSRT<float>>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, float32x4_t *a4, float32x4_t *a5, float32x4_t *a6)
{
  double v10;
  float v11;
  float v12;
  float v13;
  uint64_t v14;
  float32x4_t *v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v26;
  int32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  int32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  int32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  int32x4_t v36;
  float32x4_t v37;
  float32x4_t v38[3];

  if (a3)
  {
    v10 = *(double *)(a1 + 80);
    v11 = 1.0;
    v12 = 1.0;
    if (fabs(v10) >= 1.0e-12)
      v12 = *(double *)(a2 + 24) / v10;
    if (v12 <= 1.0)
      v11 = v12;
    if (v11 >= 0.0)
      v13 = v11;
    else
      v13 = 0.0;
    v14 = *(_QWORD *)(a1 + 288);
    if (v14)
      v13 = (*(float (**)(uint64_t, float))(*(_QWORD *)v14 + 16))(v14, v13);
    v35.i64[0] = 0x3F8000003F800000;
    v35.i64[1] = 1065353216;
    v36.i64[0] = 0;
    v36.i64[1] = 0x3F80000000000000;
    v37 = 0uLL;
    if (*(_BYTE *)(a1 + 96))
    {
      v15 = (float32x4_t *)(a1 + 112);
    }
    else
    {
      v15 = a4;
      if (*(_BYTE *)(a1 + 160))
      {
        v15 = a4;
        if (*(_BYTE *)(a1 + 224))
        {
          v19 = *(float32x4_t *)(a1 + 256);
          v20 = *(float32x4_t *)(a1 + 272);
          __asm { FMOV            V3.4S, #1.0 }
          v26 = vdivq_f32(_Q3, *(float32x4_t *)(a1 + 240));
          v27 = (int32x4_t)vnegq_f32(v19);
          v28 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v27, v27), (int8x16_t)v27, 0xCuLL);
          v27.i32[3] = v19.i32[3];
          v29 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v20, (int32x4_t)v20), (int8x16_t)v20, 0xCuLL), v19), v20, v28);
          v30 = (int32x4_t)vaddq_f32(v29, v29);
          v31 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v30, v30), (int8x16_t)v30, 0xCuLL);
          v32 = vaddq_f32(v20, vmulq_laneq_f32(v31, v19, 3));
          v33 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v31, (int32x4_t)v31), (int8x16_t)v31, 0xCuLL), v19), v31, v28);
          v35 = v26;
          v36 = v27;
          v37 = vmulq_f32(vaddq_f32(v32, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v33, v33), (int8x16_t)v33, 0xCuLL)), vnegq_f32(v26));
          v15 = &v35;
          re::AnimationValueTraits<re::GenericSRT<float>>::combine((float32x4_t *)(a1 + 176), &v35, &v35);
        }
      }
    }
    if (v13 == 0.0)
    {
      v16 = *v15;
      v17 = v15[1];
      v18 = v15[2];
LABEL_26:
      a6[1] = v17;
      a6[2] = v18;
      *a6 = v16;
      return;
    }
    if (*(_BYTE *)(a1 + 160))
    {
      a5 = (float32x4_t *)(a1 + 176);
    }
    else if (*(_BYTE *)(a1 + 224))
    {
      a5 = &v35;
      re::AnimationValueTraits<re::GenericSRT<float>>::combine(v15, (float32x4_t *)(a1 + 240), &v35);
    }
    else if (*(_BYTE *)(a1 + 96))
    {
      a5 = a4;
    }
    if (v13 == 1.0)
    {
      v16 = *a5;
      v17 = a5[1];
      v18 = a5[2];
      goto LABEL_26;
    }
    re::lerp<float>(v15, a5, v38, v13);
    v34 = v38[1];
    *a6 = v38[0];
    a6[1] = v34;
    a6[2] = v38[2];
  }
  else
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
  }
}

double re::FromToByAnimation<re::SkeletalPose>::totalDuration(uint64_t a1)
{
  return *(double *)(a1 + 80);
}

void re::FromToByAnimation<re::SkeletalPose>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5, _QWORD *a6)
{
  double v10;
  float v11;
  float v12;
  float v13;
  uint64_t v14;
  int v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t v18[2];
  __int128 v19;
  __int128 v20;
  __int128 v21;
  int v22;
  uint64_t v23;
  uint64_t v24;

  if (a3)
  {
    v10 = *(double *)(a1 + 80);
    v11 = 1.0;
    v12 = 1.0;
    if (fabs(v10) >= 1.0e-12)
      v12 = *(double *)(a2 + 24) / v10;
    if (v12 <= 1.0)
      v11 = v12;
    if (v11 >= 0.0)
      v13 = v11;
    else
      v13 = 0.0;
    v14 = *(_QWORD *)(a1 + 376);
    if (v14)
      v13 = (*(float (**)(uint64_t, float))(*(_QWORD *)v14 + 16))(v14, v13);
    v18[0] = 0;
    v18[1] = (uint64_t)&str_110;
    v19 = 0u;
    v20 = 0u;
    v21 = 0u;
    v22 = 0;
    v23 = 0;
    v24 = 0;
    if (*(_BYTE *)(a1 + 88))
    {
      v15 = 0;
      v16 = (uint64_t *)(a1 + 96);
    }
    else if (*(_BYTE *)(a1 + 184) && *(_BYTE *)(a1 + 280))
    {
      v16 = v18;
      re::SkeletalPose::init(v18, a4 + 10);
      re::AnimationValueTraits<re::SkeletalPose>::invert((_QWORD *)(a1 + 288), v18);
      re::AnimationValueTraits<re::SkeletalPose>::combine((_QWORD *)(a1 + 192), v18, v18);
      v15 = 1;
    }
    else
    {
      v15 = 0;
      v16 = a4;
    }
    if (v13 == 0.0)
    {
      re::AnimationValueTraits<re::SkeletalPose>::copy(v16, a6);
LABEL_28:
      re::SkeletalPose::~SkeletalPose((re::SkeletalPose *)v18);
      return;
    }
    if (*(_BYTE *)(a1 + 184))
    {
      a4 = (uint64_t *)(a1 + 192);
    }
    else if (*(_BYTE *)(a1 + 280))
    {
      v17 = a4 + 10;
      a4 = v18;
      re::SkeletalPose::init(v18, v17);
      re::AnimationValueTraits<re::SkeletalPose>::combine(v16, (_QWORD *)(a1 + 288), v18);
      v15 = 1;
    }
    else if (!*(_BYTE *)(a1 + 88))
    {
      a4 = a5;
    }
    if (v13 == 1.0)
    {
      re::AnimationValueTraits<re::SkeletalPose>::copy(a4, a6);
      if (!v15)
        goto LABEL_28;
    }
    else
    {
      re::AnimationValueTraits<re::SkeletalPose>::interpolate(v16, a4, a6, v13);
      if (!v15)
        goto LABEL_28;
    }
    re::SkeletalPose::deinit((re::SkeletalPose *)v18);
    goto LABEL_28;
  }
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
  _os_crash();
  __break(1u);
}

double re::FromToByAnimation<re::BlendShapeWeights>::totalDuration(uint64_t a1)
{
  return *(double *)(a1 + 80);
}

void re::FromToByAnimation<re::BlendShapeWeights>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5, uint64_t *a6)
{
  double v10;
  float v11;
  float v12;
  float v13;
  uint64_t v14;
  int v15;
  uint64_t *v16;
  uint64_t *v17;
  _OWORD v18[2];

  if (a3)
  {
    v10 = *(double *)(a1 + 80);
    v11 = 1.0;
    v12 = 1.0;
    if (fabs(v10) >= 1.0e-12)
      v12 = *(double *)(a2 + 24) / v10;
    if (v12 <= 1.0)
      v11 = v12;
    if (v11 >= 0.0)
      v13 = v11;
    else
      v13 = 0.0;
    v14 = *(_QWORD *)(a1 + 208);
    if (v14)
      v13 = (*(float (**)(uint64_t, float))(*(_QWORD *)v14 + 16))(v14, v13);
    memset(v18, 0, sizeof(v18));
    if (*(_BYTE *)(a1 + 88))
    {
      v15 = 0;
      v16 = (uint64_t *)(a1 + 96);
    }
    else if (*(_BYTE *)(a1 + 128) && *(_BYTE *)(a1 + 168))
    {
      v16 = (uint64_t *)v18;
      re::BlendShapeWeights::init((uint64_t *)v18, a4 + 3);
      re::AnimationValueTraits<re::BlendShapeWeights>::invert((_QWORD *)(a1 + 176), v18);
      re::AnimationValueTraits<re::BlendShapeWeights>::combine((_QWORD *)(a1 + 136), v18, v18);
      v15 = 1;
    }
    else
    {
      v15 = 0;
      v16 = a4;
    }
    if (v13 == 0.0)
    {
      re::AnimationValueTraits<re::BlendShapeWeights>::copy(v16, a6);
LABEL_28:
      re::BlendShapeWeights::~BlendShapeWeights((re::BlendShapeWeights *)v18);
      return;
    }
    if (*(_BYTE *)(a1 + 128))
    {
      a4 = (uint64_t *)(a1 + 136);
    }
    else if (*(_BYTE *)(a1 + 168))
    {
      v17 = a4 + 3;
      a4 = (uint64_t *)v18;
      re::BlendShapeWeights::init((uint64_t *)v18, v17);
      re::AnimationValueTraits<re::BlendShapeWeights>::combine(v16, (_QWORD *)(a1 + 176), v18);
      v15 = 1;
    }
    else if (!*(_BYTE *)(a1 + 88))
    {
      a4 = a5;
    }
    if (v13 == 1.0)
    {
      re::AnimationValueTraits<re::BlendShapeWeights>::copy(a4, a6);
      if (!v15)
        goto LABEL_28;
    }
    else
    {
      re::AnimationValueTraits<re::BlendShapeWeights>::interpolate((_anonymous_namespace_ *)v16, a4, a6, v13);
      if (!v15)
        goto LABEL_28;
    }
    re::BlendShapeWeights::deinit((re::BlendShapeWeights *)v18);
    goto LABEL_28;
  }
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
  _os_crash();
  __break(1u);
}

uint64_t re::FromToByAnimation<re::SkeletalPose>::~FromToByAnimation(uint64_t a1)
{
  uint64_t v2;

  *(_QWORD *)a1 = off_24ED254D8;
  if (*(_BYTE *)(a1 + 280))
    re::SkeletalPose::~SkeletalPose((re::SkeletalPose *)(a1 + 288));
  if (*(_BYTE *)(a1 + 184))
    re::SkeletalPose::~SkeletalPose((re::SkeletalPose *)(a1 + 192));
  if (*(_BYTE *)(a1 + 88))
    re::SkeletalPose::~SkeletalPose((re::SkeletalPose *)(a1 + 96));
  *(_QWORD *)a1 = off_24ED1F350;
  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 56));
    *(_OWORD *)(a1 + 40) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  return a1;
}

void re::FromToByAnimation<re::SkeletalPose>::~FromToByAnimation(uint64_t a1)
{
  uint64_t v2;

  *(_QWORD *)a1 = off_24ED254D8;
  if (*(_BYTE *)(a1 + 280))
    re::SkeletalPose::~SkeletalPose((re::SkeletalPose *)(a1 + 288));
  if (*(_BYTE *)(a1 + 184))
    re::SkeletalPose::~SkeletalPose((re::SkeletalPose *)(a1 + 192));
  if (*(_BYTE *)(a1 + 88))
    re::SkeletalPose::~SkeletalPose((re::SkeletalPose *)(a1 + 96));
  *(_QWORD *)a1 = off_24ED1F350;
  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 56));
    *(_OWORD *)(a1 + 40) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  JUMPOUT(0x2276933B8);
}

uint64_t re::FromToByAnimation<re::BlendShapeWeights>::~FromToByAnimation(uint64_t a1)
{
  uint64_t v2;

  *(_QWORD *)a1 = off_24ED25560;
  if (*(_BYTE *)(a1 + 168))
    re::BlendShapeWeights::~BlendShapeWeights((re::BlendShapeWeights *)(a1 + 176));
  if (*(_BYTE *)(a1 + 128))
    re::BlendShapeWeights::~BlendShapeWeights((re::BlendShapeWeights *)(a1 + 136));
  if (*(_BYTE *)(a1 + 88))
    re::BlendShapeWeights::~BlendShapeWeights((re::BlendShapeWeights *)(a1 + 96));
  *(_QWORD *)a1 = off_24ED1F350;
  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 56));
    *(_OWORD *)(a1 + 40) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  return a1;
}

void re::FromToByAnimation<re::BlendShapeWeights>::~FromToByAnimation(uint64_t a1)
{
  uint64_t v2;

  *(_QWORD *)a1 = off_24ED25560;
  if (*(_BYTE *)(a1 + 168))
    re::BlendShapeWeights::~BlendShapeWeights((re::BlendShapeWeights *)(a1 + 176));
  if (*(_BYTE *)(a1 + 128))
    re::BlendShapeWeights::~BlendShapeWeights((re::BlendShapeWeights *)(a1 + 136));
  if (*(_BYTE *)(a1 + 88))
    re::BlendShapeWeights::~BlendShapeWeights((re::BlendShapeWeights *)(a1 + 96));
  *(_QWORD *)a1 = off_24ED1F350;
  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 56));
    *(_OWORD *)(a1 + 40) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  JUMPOUT(0x2276933B8);
}

uint64_t re::AnimationHelper::makeAdditiveForOptionalValueReferences<float>(re *a1, uint64_t a2, uint64_t a3, unint64_t a4, double a5)
{
  uint64_t result;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unsigned __int8 *v10;
  unsigned __int8 *v11;
  int v12;
  uint64_t v14;
  unint64_t v15;
  float v16;
  BOOL v17;
  BOOL v18;
  NSObject *v19;
  const char *v20;
  uint8_t *v21;
  unint64_t v22;
  unint64_t v23;
  unsigned __int8 *v24;
  unsigned __int8 *v25;
  int v26;
  BOOL v28;
  BOOL v29;
  uint8_t buf[2];
  __int16 v31;

  if (*((_QWORD *)a1 + 1) != a4)
  {
    v19 = *re::animationLogObjects(a1);
    result = os_log_type_enabled(v19, OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    v31 = 0;
    v20 = "Cannot make additive values, output values expected to match input values size.";
    v21 = (uint8_t *)&v31;
    goto LABEL_33;
  }
  if (!*(_QWORD *)(a2 + 8))
  {
    v19 = *re::animationLogObjects(a1);
    result = os_log_type_enabled(v19, OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    *(_WORD *)buf = 0;
    v20 = "Cannot make additive values, base values array size must not be zero.";
    v21 = buf;
LABEL_33:
    _os_log_error_impl(&dword_224FE9000, v19, OS_LOG_TYPE_ERROR, v20, v21, 2u);
    return 0;
  }
  result = 1;
  if (a4)
  {
    v7 = 0;
    v8 = *(_QWORD *)a1;
    LODWORD(a5) = 0;
    v9 = a4;
    do
    {
      if (a4 == v7)
      {
        re::internal::assertLog((re::internal *)6, a2, a5, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, a4, a4);
        _os_crash();
        __break(1u);
LABEL_63:
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v7, v9);
        _os_crash();
        __break(1u);
LABEL_64:
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v7, v15);
        _os_crash();
        __break(1u);
        goto LABEL_65;
      }
      v10 = *(unsigned __int8 **)(v8 + 8 * v7);
      v11 = *(unsigned __int8 **)(a3 + 8 * v7);
      v12 = *v11;
      if ((*v10 != 0) != (*v11 != 0) && (v12 | *v10) != 0)
      {
        if (*v10)
          v17 = 1;
        else
          v17 = v12 == 0;
        if (v17)
        {
          if (*v10)
            v18 = v12 == 0;
          else
            v18 = 0;
          if (v18)
          {
            *v11 = 1;
            *((_DWORD *)v11 + 1) = *((_DWORD *)v10 + 1);
          }
          else
          {
            *((_DWORD *)v11 + 1) = *((_DWORD *)v10 + 1);
            v9 = *((_QWORD *)a1 + 1);
          }
        }
        else
        {
          *v11 = 0;
        }
      }
      if (v9 <= v7)
        goto LABEL_63;
      v8 = *(_QWORD *)a1;
      v14 = *(_QWORD *)(*(_QWORD *)a1 + 8 * v7);
      v15 = *(_QWORD *)(a2 + 8);
      if (*(_BYTE *)v14)
      {
        if (v15 <= v7)
          goto LABEL_64;
        v16 = **(float **)(*(_QWORD *)a2 + 8 * v7);
        *(float *)&a5 = -v16;
        *(float *)(*(_QWORD *)(a3 + 8 * v7) + 4) = *(float *)(v14 + 4) - v16;
        v15 = *(_QWORD *)(a2 + 8);
      }
      ++v7;
    }
    while (v9 > v7 && v15 > v7);
    result = 1;
    if (v9 <= v7)
      return result;
    v22 = v7;
    if (a4 <= v7)
      v23 = v7;
    else
      v23 = a4;
    if (a4 <= v7)
      v7 = v7;
    else
      v7 = a4;
    while (v7 != v22)
    {
      v24 = *(unsigned __int8 **)(v8 + 8 * v22);
      v25 = *(unsigned __int8 **)(a3 + 8 * v22);
      v26 = *v25;
      a2 = *v25 != 0;
      if ((*v24 != 0) != (_DWORD)a2 && (v26 | *v24) != 0)
      {
        if (*v24)
          v28 = 1;
        else
          v28 = v26 == 0;
        if (v28)
        {
          if (*v24)
            v29 = v26 == 0;
          else
            v29 = 0;
          if (v29)
          {
            *v25 = 1;
            *((_DWORD *)v25 + 1) = *((_DWORD *)v24 + 1);
          }
          else
          {
            *((_DWORD *)v25 + 1) = *((_DWORD *)v24 + 1);
            v9 = *((_QWORD *)a1 + 1);
          }
        }
        else
        {
          *v25 = 0;
        }
      }
      if (v9 <= v22)
        goto LABEL_66;
      v8 = *(_QWORD *)a1;
      *(float *)(*(_QWORD *)(a3 + 8 * v22) + 4) = *(float *)&a5
                                                  + *(float *)(*(_QWORD *)(*(_QWORD *)a1 + 8 * v22) + 4);
      if (v9 <= ++v22)
        return 1;
    }
LABEL_65:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v23, a4);
    _os_crash();
    __break(1u);
LABEL_66:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v22, v9);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::AnimationHelper::makeAdditiveForOptionalValueReferences<double>(re *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t result;
  unint64_t v6;
  uint64_t v7;
  double v8;
  unint64_t v9;
  unsigned __int8 *v10;
  unsigned __int8 *v11;
  int v12;
  uint64_t v14;
  unint64_t v15;
  double v16;
  BOOL v17;
  BOOL v18;
  NSObject *v19;
  const char *v20;
  uint8_t *v21;
  unint64_t v22;
  unint64_t v23;
  unsigned __int8 *v24;
  unsigned __int8 *v25;
  int v26;
  BOOL v28;
  BOOL v29;
  uint8_t buf[2];
  __int16 v31;

  if (*((_QWORD *)a1 + 1) != a4)
  {
    v19 = *re::animationLogObjects(a1);
    result = os_log_type_enabled(v19, OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    v31 = 0;
    v20 = "Cannot make additive values, output values expected to match input values size.";
    v21 = (uint8_t *)&v31;
    goto LABEL_33;
  }
  if (!*(_QWORD *)(a2 + 8))
  {
    v19 = *re::animationLogObjects(a1);
    result = os_log_type_enabled(v19, OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    *(_WORD *)buf = 0;
    v20 = "Cannot make additive values, base values array size must not be zero.";
    v21 = buf;
LABEL_33:
    _os_log_error_impl(&dword_224FE9000, v19, OS_LOG_TYPE_ERROR, v20, v21, 2u);
    return 0;
  }
  result = 1;
  if (a4)
  {
    v6 = 0;
    v7 = *(_QWORD *)a1;
    v8 = 0.0;
    v9 = a4;
    do
    {
      if (a4 == v6)
      {
        re::internal::assertLog((re::internal *)6, a2, v8, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, a4, a4);
        _os_crash();
        __break(1u);
LABEL_63:
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v6, v9);
        _os_crash();
        __break(1u);
LABEL_64:
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v6, v15);
        _os_crash();
        __break(1u);
        goto LABEL_65;
      }
      v10 = *(unsigned __int8 **)(v7 + 8 * v6);
      v11 = *(unsigned __int8 **)(a3 + 8 * v6);
      v12 = *v11;
      if ((*v10 != 0) != (*v11 != 0) && (v12 | *v10) != 0)
      {
        if (*v10)
          v17 = 1;
        else
          v17 = v12 == 0;
        if (v17)
        {
          if (*v10)
            v18 = v12 == 0;
          else
            v18 = 0;
          if (v18)
          {
            *v11 = 1;
            *((_QWORD *)v11 + 1) = *((_QWORD *)v10 + 1);
          }
          else
          {
            *((_QWORD *)v11 + 1) = *((_QWORD *)v10 + 1);
            v9 = *((_QWORD *)a1 + 1);
          }
        }
        else
        {
          *v11 = 0;
        }
      }
      if (v9 <= v6)
        goto LABEL_63;
      v7 = *(_QWORD *)a1;
      v14 = *(_QWORD *)(*(_QWORD *)a1 + 8 * v6);
      v15 = *(_QWORD *)(a2 + 8);
      if (*(_BYTE *)v14)
      {
        if (v15 <= v6)
          goto LABEL_64;
        v16 = **(double **)(*(_QWORD *)a2 + 8 * v6);
        v8 = -v16;
        *(double *)(*(_QWORD *)(a3 + 8 * v6) + 8) = *(double *)(v14 + 8) - v16;
        v15 = *(_QWORD *)(a2 + 8);
      }
      ++v6;
    }
    while (v9 > v6 && v15 > v6);
    result = 1;
    if (v9 <= v6)
      return result;
    v22 = v6;
    if (a4 <= v6)
      v23 = v6;
    else
      v23 = a4;
    if (a4 <= v6)
      v6 = v6;
    else
      v6 = a4;
    while (v6 != v22)
    {
      v24 = *(unsigned __int8 **)(v7 + 8 * v22);
      v25 = *(unsigned __int8 **)(a3 + 8 * v22);
      v26 = *v25;
      a2 = *v25 != 0;
      if ((*v24 != 0) != (_DWORD)a2 && (v26 | *v24) != 0)
      {
        if (*v24)
          v28 = 1;
        else
          v28 = v26 == 0;
        if (v28)
        {
          if (*v24)
            v29 = v26 == 0;
          else
            v29 = 0;
          if (v29)
          {
            *v25 = 1;
            *((_QWORD *)v25 + 1) = *((_QWORD *)v24 + 1);
          }
          else
          {
            *((_QWORD *)v25 + 1) = *((_QWORD *)v24 + 1);
            v9 = *((_QWORD *)a1 + 1);
          }
        }
        else
        {
          *v25 = 0;
        }
      }
      if (v9 <= v22)
        goto LABEL_66;
      v7 = *(_QWORD *)a1;
      *(double *)(*(_QWORD *)(a3 + 8 * v22) + 8) = v8 + *(double *)(*(_QWORD *)(*(_QWORD *)a1 + 8 * v22) + 8);
      if (v9 <= ++v22)
        return 1;
    }
LABEL_65:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v23, a4);
    _os_crash();
    __break(1u);
LABEL_66:
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v22, v9);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::AnimationHelper::makeAdditiveForOptionalValueReferences<re::Vector2<float>>(re *a1, _QWORD *a2, uint64_t a3, unint64_t a4)
{
  uint64_t result;
  unint64_t v6;
  float32x2_t v7;
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  int v10;
  unint64_t v12;
  float32x2_t *v13;
  unint64_t v14;
  float32x2_t v15;
  BOOL v16;
  BOOL v17;
  NSObject *v18;
  const char *v19;
  uint8_t *v20;
  unint64_t v21;
  unint64_t v22;
  unsigned __int8 *v23;
  unsigned __int8 *v24;
  int v25;
  unint64_t v27;
  BOOL v28;
  BOOL v29;
  uint8_t buf[2];
  __int16 v31;

  if (*((_QWORD *)a1 + 1) != a4)
  {
    v18 = *re::animationLogObjects(a1);
    result = os_log_type_enabled(v18, OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    v31 = 0;
    v19 = "Cannot make additive values, output values expected to match input values size.";
    v20 = (uint8_t *)&v31;
    goto LABEL_34;
  }
  if (!a2[1])
  {
    v18 = *re::animationLogObjects(a1);
    result = os_log_type_enabled(v18, OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    *(_WORD *)buf = 0;
    v19 = "Cannot make additive values, base values array size must not be zero.";
    v20 = buf;
LABEL_34:
    _os_log_error_impl(&dword_224FE9000, v18, OS_LOG_TYPE_ERROR, v19, v20, 2u);
    return 0;
  }
  result = 1;
  if (a4)
  {
    v6 = 0;
    v7 = 0;
    do
    {
      if (a4 == v6)
      {
        re::internal::assertLog((re::internal *)6, (uint64_t)a2, *(double *)&v7, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, a4, a4);
        _os_crash();
        __break(1u);
LABEL_65:
        re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v6, v12);
        _os_crash();
        __break(1u);
LABEL_66:
        re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v6, v14);
        _os_crash();
        __break(1u);
        goto LABEL_67;
      }
      v8 = *(unsigned __int8 **)(*(_QWORD *)a1 + 8 * v6);
      v9 = *(unsigned __int8 **)(a3 + 8 * v6);
      v10 = *v9;
      if ((*v8 != 0) != (*v9 != 0) && (v10 | *v8) != 0)
      {
        if (*v8)
          v16 = 1;
        else
          v16 = v10 == 0;
        if (v16)
        {
          if (*v8)
            v17 = v10 == 0;
          else
            v17 = 0;
          if (v17)
            *v9 = 1;
          *((_QWORD *)v9 + 1) = *((_QWORD *)v8 + 1);
        }
        else
        {
          *v9 = 0;
        }
      }
      v12 = *((_QWORD *)a1 + 1);
      if (v12 <= v6)
        goto LABEL_65;
      v13 = *(float32x2_t **)(*(_QWORD *)a1 + 8 * v6);
      v14 = a2[1];
      if (v13->i8[0])
      {
        if (v14 <= v6)
          goto LABEL_66;
        v15 = **(float32x2_t **)(*a2 + 8 * v6);
        v7 = vneg_f32(v15);
        *(float32x2_t *)(*(_QWORD *)(a3 + 8 * v6) + 8) = vsub_f32(v13[1], v15);
        v12 = *((_QWORD *)a1 + 1);
        v14 = a2[1];
      }
      ++v6;
    }
    while (v12 > v6 && v14 > v6);
    result = 1;
    if (v12 <= v6)
      return result;
    v21 = v6;
    if (a4 <= v6)
      v22 = v6;
    else
      v22 = a4;
    if (a4 <= v6)
      v6 = v6;
    else
      v6 = a4;
    while (v6 != v21)
    {
      v23 = *(unsigned __int8 **)(*(_QWORD *)a1 + 8 * v21);
      v24 = *(unsigned __int8 **)(a3 + 8 * v21);
      v25 = *v24;
      if ((*v23 != 0) != (*v24 != 0) && (v25 | *v23) != 0)
      {
        if (*v23)
          v28 = 1;
        else
          v28 = v25 == 0;
        if (v28)
        {
          if (*v23)
            v29 = v25 == 0;
          else
            v29 = 0;
          if (v29)
            *v24 = 1;
          *((_QWORD *)v24 + 1) = *((_QWORD *)v23 + 1);
        }
        else
        {
          *v24 = 0;
        }
      }
      v27 = *((_QWORD *)a1 + 1);
      if (v27 <= v21)
        goto LABEL_68;
      *(float32x2_t *)(*(_QWORD *)(a3 + 8 * v21) + 8) = vadd_f32(v7, *(float32x2_t *)(*(_QWORD *)(*(_QWORD *)a1 + 8 * v21) + 8));
      if (*((_QWORD *)a1 + 1) <= ++v21)
        return 1;
    }
LABEL_67:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v22, a4);
    _os_crash();
    __break(1u);
LABEL_68:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v21, v27);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::AnimationHelper::makeAdditiveForOptionalValueReferences<re::Vector3<float>>(re *a1, _QWORD *a2, uint64_t a3, unint64_t a4)
{
  uint64_t result;
  unint64_t v6;
  float32x4_t v7;
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  int v10;
  unint64_t v12;
  float32x4_t *v13;
  unint64_t v14;
  float32x4_t v15;
  BOOL v16;
  BOOL v17;
  NSObject *v18;
  const char *v19;
  uint8_t *v20;
  unint64_t v21;
  unint64_t v22;
  unsigned __int8 *v23;
  unsigned __int8 *v24;
  int v25;
  unint64_t v27;
  BOOL v28;
  BOOL v29;
  uint8_t buf[2];
  __int16 v31;

  if (*((_QWORD *)a1 + 1) != a4)
  {
    v18 = *re::animationLogObjects(a1);
    result = os_log_type_enabled(v18, OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    v31 = 0;
    v19 = "Cannot make additive values, output values expected to match input values size.";
    v20 = (uint8_t *)&v31;
    goto LABEL_34;
  }
  if (!a2[1])
  {
    v18 = *re::animationLogObjects(a1);
    result = os_log_type_enabled(v18, OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    *(_WORD *)buf = 0;
    v19 = "Cannot make additive values, base values array size must not be zero.";
    v20 = buf;
LABEL_34:
    _os_log_error_impl(&dword_224FE9000, v18, OS_LOG_TYPE_ERROR, v19, v20, 2u);
    return 0;
  }
  result = 1;
  if (a4)
  {
    v6 = 0;
    v7 = 0uLL;
    do
    {
      if (a4 == v6)
      {
        re::internal::assertLog((re::internal *)6, (uint64_t)a2, *(double *)v7.i64, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, a4, a4);
        _os_crash();
        __break(1u);
LABEL_65:
        re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v6, v12);
        _os_crash();
        __break(1u);
LABEL_66:
        re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v6, v14);
        _os_crash();
        __break(1u);
        goto LABEL_67;
      }
      v8 = *(unsigned __int8 **)(*(_QWORD *)a1 + 8 * v6);
      v9 = *(unsigned __int8 **)(a3 + 8 * v6);
      v10 = *v9;
      if ((*v8 != 0) != (*v9 != 0) && (v10 | *v8) != 0)
      {
        if (*v8)
          v16 = 1;
        else
          v16 = v10 == 0;
        if (v16)
        {
          if (*v8)
            v17 = v10 == 0;
          else
            v17 = 0;
          if (v17)
            *v9 = 1;
          *((_OWORD *)v9 + 1) = *((_OWORD *)v8 + 1);
        }
        else
        {
          *v9 = 0;
        }
      }
      v12 = *((_QWORD *)a1 + 1);
      if (v12 <= v6)
        goto LABEL_65;
      v13 = *(float32x4_t **)(*(_QWORD *)a1 + 8 * v6);
      v14 = a2[1];
      if (v13->i8[0])
      {
        if (v14 <= v6)
          goto LABEL_66;
        v15 = *(float32x4_t *)*(_QWORD *)(*a2 + 8 * v6);
        v7 = vnegq_f32(v15);
        *(float32x4_t *)(*(_QWORD *)(a3 + 8 * v6) + 16) = vsubq_f32(v13[1], v15);
        v12 = *((_QWORD *)a1 + 1);
        v14 = a2[1];
      }
      ++v6;
    }
    while (v12 > v6 && v14 > v6);
    result = 1;
    if (v12 <= v6)
      return result;
    v21 = v6;
    if (a4 <= v6)
      v22 = v6;
    else
      v22 = a4;
    if (a4 <= v6)
      v6 = v6;
    else
      v6 = a4;
    while (v6 != v21)
    {
      v23 = *(unsigned __int8 **)(*(_QWORD *)a1 + 8 * v21);
      v24 = *(unsigned __int8 **)(a3 + 8 * v21);
      v25 = *v24;
      if ((*v23 != 0) != (*v24 != 0) && (v25 | *v23) != 0)
      {
        if (*v23)
          v28 = 1;
        else
          v28 = v25 == 0;
        if (v28)
        {
          if (*v23)
            v29 = v25 == 0;
          else
            v29 = 0;
          if (v29)
            *v24 = 1;
          *((_OWORD *)v24 + 1) = *((_OWORD *)v23 + 1);
        }
        else
        {
          *v24 = 0;
        }
      }
      v27 = *((_QWORD *)a1 + 1);
      if (v27 <= v21)
        goto LABEL_68;
      *(float32x4_t *)(*(_QWORD *)(a3 + 8 * v21) + 16) = vaddq_f32(v7, *(float32x4_t *)(*(_QWORD *)(*(_QWORD *)a1 + 8 * v21) + 16));
      if (*((_QWORD *)a1 + 1) <= ++v21)
        return 1;
    }
LABEL_67:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v22, a4);
    _os_crash();
    __break(1u);
LABEL_68:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v21, v27);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::AnimationHelper::makeAdditiveForOptionalValueReferences<re::Quaternion<float>>(re *a1, _QWORD *a2, uint64_t a3, unint64_t a4)
{
  uint64_t result;
  unint64_t v6;
  float32x4_t v7;
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  int v10;
  unint64_t v12;
  float32x4_t *v13;
  unint64_t v14;
  float32x4_t v16;
  float32x4_t v19;
  BOOL v23;
  BOOL v24;
  NSObject *v25;
  const char *v26;
  uint8_t *v27;
  unint64_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v32;
  unint64_t v33;
  unsigned __int8 *v34;
  unsigned __int8 *v35;
  int v36;
  unint64_t v38;
  int8x16_t v40;
  float32x4_t v41;
  BOOL v43;
  BOOL v44;
  uint8_t buf[2];
  __int16 v46;

  if (*((_QWORD *)a1 + 1) != a4)
  {
    v25 = *re::animationLogObjects(a1);
    result = os_log_type_enabled(v25, OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    v46 = 0;
    v26 = "Cannot make additive values, output values expected to match input values size.";
    v27 = (uint8_t *)&v46;
    goto LABEL_34;
  }
  if (!a2[1])
  {
    v25 = *re::animationLogObjects(a1);
    result = os_log_type_enabled(v25, OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    *(_WORD *)buf = 0;
    v26 = "Cannot make additive values, base values array size must not be zero.";
    v27 = buf;
LABEL_34:
    _os_log_error_impl(&dword_224FE9000, v25, OS_LOG_TYPE_ERROR, v26, v27, 2u);
    return 0;
  }
  result = 1;
  if (a4)
  {
    v6 = 0;
    v7 = (float32x4_t)xmmword_2260E5D70;
    do
    {
      if (a4 == v6)
      {
        re::internal::assertLog((re::internal *)6, (uint64_t)a2, *(double *)v7.i64, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, a4, a4);
        _os_crash();
        __break(1u);
LABEL_65:
        re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v6, v12);
        _os_crash();
        __break(1u);
LABEL_66:
        re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v6, v14);
        _os_crash();
        __break(1u);
        goto LABEL_67;
      }
      v8 = *(unsigned __int8 **)(*(_QWORD *)a1 + 8 * v6);
      v9 = *(unsigned __int8 **)(a3 + 8 * v6);
      v10 = *v9;
      if ((*v8 != 0) != (*v9 != 0) && (v10 | *v8) != 0)
      {
        if (*v8)
          v23 = 1;
        else
          v23 = v10 == 0;
        if (v23)
        {
          if (*v8)
            v24 = v10 == 0;
          else
            v24 = 0;
          if (v24)
            *v9 = 1;
          *((_OWORD *)v9 + 1) = *((_OWORD *)v8 + 1);
        }
        else
        {
          *v9 = 0;
        }
      }
      v12 = *((_QWORD *)a1 + 1);
      if (v12 <= v6)
        goto LABEL_65;
      v13 = *(float32x4_t **)(*(_QWORD *)a1 + 8 * v6);
      v14 = a2[1];
      if (v13->i8[0])
      {
        if (v14 <= v6)
          goto LABEL_66;
        _Q1 = *(float32x4_t *)*(_QWORD *)(*a2 + 8 * v6);
        v7 = vnegq_f32(_Q1);
        v16 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v7, (int32x4_t)v7), (int8x16_t)v7, 0xCuLL);
        v7.i32[3] = _Q1.i32[3];
        _Q3 = v13[1];
        _Q4 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q3, (int32x4_t)_Q3), (int8x16_t)_Q3, 0xCuLL), _Q1), _Q3, v16);
        v19 = vmlsq_laneq_f32(vmlaq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q4, (int32x4_t)_Q4), _Q4, 0xCuLL), _Q3, _Q1, 3), _Q1, _Q3, 3);
        _Q3.i32[0] = _Q3.i32[3];
        __asm { FMLA            S4, S3, V1.S[3] }
        v19.i32[3] = _Q4.i32[0];
        *(float32x4_t *)(*(_QWORD *)(a3 + 8 * v6) + 16) = v19;
        v12 = *((_QWORD *)a1 + 1);
        v14 = a2[1];
      }
      ++v6;
    }
    while (v12 > v6 && v14 > v6);
    result = 1;
    if (v12 <= v6)
      return result;
    v28 = v6;
    v29 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v7, (int32x4_t)v7), (int8x16_t)v7, 0xCuLL);
    v30 = vnegq_f32(v7);
    _S3 = v7.i32[3];
    v32 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 3);
    if (a4 <= v6)
      v33 = v6;
    else
      v33 = a4;
    if (a4 <= v6)
      v6 = v6;
    else
      v6 = a4;
    while (v6 != v28)
    {
      v34 = *(unsigned __int8 **)(*(_QWORD *)a1 + 8 * v28);
      v35 = *(unsigned __int8 **)(a3 + 8 * v28);
      v36 = *v35;
      if ((*v34 != 0) != (*v35 != 0) && (v36 | *v34) != 0)
      {
        if (*v34)
          v43 = 1;
        else
          v43 = v36 == 0;
        if (v43)
        {
          if (*v34)
            v44 = v36 == 0;
          else
            v44 = 0;
          if (v44)
            *v35 = 1;
          *((_OWORD *)v35 + 1) = *((_OWORD *)v34 + 1);
        }
        else
        {
          *v35 = 0;
        }
      }
      v38 = *((_QWORD *)a1 + 1);
      if (v38 <= v28)
        goto LABEL_68;
      _Q5 = *(float32x4_t *)(*(_QWORD *)(*(_QWORD *)a1 + 8 * v28) + 16);
      v40 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q5, (int32x4_t)_Q5), (int8x16_t)_Q5, 0xCuLL), v30), _Q5, v29);
      v41 = vmlaq_laneq_f32(vmlaq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v40, (int32x4_t)v40), v40, 0xCuLL), _Q5, v32), v7, _Q5, 3);
      __asm { FMLA            S7, S3, V5.S[3] }
      v41.i32[3] = _S7;
      *(float32x4_t *)(*(_QWORD *)(a3 + 8 * v28++) + 16) = v41;
      if (*((_QWORD *)a1 + 1) <= v28)
        return 1;
    }
LABEL_67:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v33, a4);
    _os_crash();
    __break(1u);
LABEL_68:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v28, v38);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::AnimationHelper::makeAdditiveForOptionalValueReferences<re::GenericSRT<float>>(re *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4;
  unint64_t v8;
  uint64_t v13;
  unsigned __int8 *v14;
  unsigned __int8 *v15;
  int v16;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  float32x4_t *v21;
  float32x4_t v22;
  float32x4_t v23;
  int8x16_t v24;
  float32x4_t v25;
  float32x4_t v26;
  int8x16_t v27;
  float32x4_t v28;
  float32x4_t v29;
  int8x16_t v30;
  BOOL v31;
  BOOL v32;
  __int128 v33;
  __int128 v34;
  NSObject *v35;
  uint64_t result;
  const char *v37;
  unsigned __int8 *v38;
  unsigned __int8 *v39;
  int v40;
  unint64_t v42;
  BOOL v43;
  BOOL v44;
  __int128 v45;
  __int128 v46;
  float32x4_t v47;
  uint8_t buf[16];
  int8x16_t v49;
  float32x4_t v50;

  if (*((_QWORD *)a1 + 1) != a4)
  {
    v35 = *re::animationLogObjects(a1);
    result = os_log_type_enabled(v35, OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    *(_WORD *)buf = 0;
    v37 = "Cannot make additive values, output values expected to match input values size.";
    goto LABEL_34;
  }
  v4 = a2;
  if (!*(_QWORD *)(a2 + 8))
  {
    v35 = *re::animationLogObjects(a1);
    result = os_log_type_enabled(v35, OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    *(_WORD *)buf = 0;
    v37 = "Cannot make additive values, base values array size must not be zero.";
LABEL_34:
    _os_log_error_impl(&dword_224FE9000, v35, OS_LOG_TYPE_ERROR, v37, buf, 2u);
    return 0;
  }
  *(_QWORD *)buf = 0x3F8000003F800000;
  *(_QWORD *)&buf[8] = 1065353216;
  v49.i64[0] = 0;
  v49.i64[1] = 0x3F80000000000000;
  v50 = 0uLL;
  if (!a4)
    return 1;
  v8 = 0;
  __asm { FMOV            V0.4S, #1.0 }
  v47 = _Q0;
  v13 = 1;
  do
  {
    if (a4 == v8)
    {
      re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, a4, a4);
      _os_crash();
      __break(1u);
LABEL_66:
      re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v8, v18);
      _os_crash();
      __break(1u);
LABEL_67:
      re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v8, v20);
      _os_crash();
      __break(1u);
      goto LABEL_68;
    }
    v14 = *(unsigned __int8 **)(*(_QWORD *)a1 + 8 * v8);
    v15 = *(unsigned __int8 **)(a3 + 8 * v8);
    v16 = *v15;
    if ((*v14 != 0) != (*v15 != 0) && (v16 | *v14) != 0)
    {
      if (*v14)
        v31 = 1;
      else
        v31 = v16 == 0;
      if (v31)
      {
        if (*v14)
          v32 = v16 == 0;
        else
          v32 = 0;
        if (v32)
          *v15 = 1;
        v33 = *((_OWORD *)v14 + 1);
        v34 = *((_OWORD *)v14 + 3);
        *((_OWORD *)v15 + 2) = *((_OWORD *)v14 + 2);
        *((_OWORD *)v15 + 3) = v34;
        *((_OWORD *)v15 + 1) = v33;
      }
      else
      {
        *v15 = 0;
      }
    }
    v18 = *((_QWORD *)a1 + 1);
    if (v18 <= v8)
      goto LABEL_66;
    v19 = *(_QWORD *)a1;
    v20 = *(_QWORD *)(v4 + 8);
    if (**(_BYTE **)(*(_QWORD *)a1 + 8 * v8))
    {
      if (v20 <= v8)
        goto LABEL_67;
      v21 = *(float32x4_t **)(*(_QWORD *)v4 + 8 * v8);
      v22 = v21[1];
      v23 = v21[2];
      v24 = (int8x16_t)vnegq_f32(v22);
      v25 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v24, (int32x4_t)v24), v24, 0xCuLL);
      v24.i32[3] = v22.i32[3];
      v26 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v23, (int32x4_t)v23), (int8x16_t)v23, 0xCuLL), v22), v23, v25);
      v27 = (int8x16_t)vaddq_f32(v26, v26);
      v28 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v27, (int32x4_t)v27), v27, 0xCuLL);
      v29 = vaddq_f32(v23, vmulq_laneq_f32(v28, v22, 3));
      v30 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v28, (int32x4_t)v28), (int8x16_t)v28, 0xCuLL), v22), v28, v25);
      *(float32x4_t *)buf = vdivq_f32(v47, *v21);
      v49 = v24;
      v50 = vmulq_f32(vaddq_f32(v29, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v30, (int32x4_t)v30), v30, 0xCuLL)), vnegq_f32(*(float32x4_t *)buf));
      re::AnimationValueTraits<re::GenericSRT<float>>::combine((float32x4_t *)(*(_QWORD *)(v19 + 8 * v8) + 16), (float32x4_t *)buf, (float32x4_t *)(*(_QWORD *)(a3 + 8 * v8) + 16));
      v18 = *((_QWORD *)a1 + 1);
      v20 = *(_QWORD *)(v4 + 8);
    }
    ++v8;
  }
  while (v18 > v8 && v20 > v8);
  if (v18 <= v8)
    return 1;
  v4 = v8;
  if (a4 <= v8)
    v13 = v8;
  else
    v13 = a4;
  if (a4 <= v8)
    v8 = v8;
  else
    v8 = a4;
  while (v8 != v4)
  {
    v38 = *(unsigned __int8 **)(*(_QWORD *)a1 + 8 * v4);
    v39 = *(unsigned __int8 **)(a3 + 8 * v4);
    v40 = *v39;
    if ((*v38 != 0) != (*v39 != 0) && (v40 | *v38) != 0)
    {
      if (*v38)
        v43 = 1;
      else
        v43 = v40 == 0;
      if (v43)
      {
        if (*v38)
          v44 = v40 == 0;
        else
          v44 = 0;
        if (v44)
          *v39 = 1;
        v45 = *((_OWORD *)v38 + 1);
        v46 = *((_OWORD *)v38 + 3);
        *((_OWORD *)v39 + 2) = *((_OWORD *)v38 + 2);
        *((_OWORD *)v39 + 3) = v46;
        *((_OWORD *)v39 + 1) = v45;
      }
      else
      {
        *v39 = 0;
      }
    }
    v42 = *((_QWORD *)a1 + 1);
    if (v42 <= v4)
      goto LABEL_69;
    re::AnimationValueTraits<re::GenericSRT<float>>::combine((float32x4_t *)(*(_QWORD *)(*(_QWORD *)a1 + 8 * v4) + 16), (float32x4_t *)buf, (float32x4_t *)(*(_QWORD *)(a3 + 8 * v4) + 16));
    if (*((_QWORD *)a1 + 1) <= ++v4)
      return 1;
  }
LABEL_68:
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v13, a4);
  _os_crash();
  __break(1u);
LABEL_69:
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v4, v42);
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::AnimationHelper::makeAdditiveForOptionalValueReferences<re::SkeletalPose>(re *a1, _QWORD *a2, uint64_t a3, _QWORD *a4)
{
  _QWORD *v4;
  uint64_t *v8;
  unint64_t v9;
  unint64_t v10;
  unsigned __int8 *v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t *v15;
  unsigned __int8 *v16;
  uint64_t result;
  NSObject *v18;
  const char *v19;
  uint8_t buf[8];
  void *v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  int v25;
  uint64_t v26;
  uint64_t v27;

  if (*((_QWORD **)a1 + 1) != a4)
  {
    v18 = *re::animationLogObjects(a1);
    result = os_log_type_enabled(v18, OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    *(_WORD *)buf = 0;
    v19 = "Cannot make additive values, output values expected to match input values size.";
    goto LABEL_32;
  }
  v4 = a2;
  if (!a2[1])
  {
    v18 = *re::animationLogObjects(a1);
    result = os_log_type_enabled(v18, OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    *(_WORD *)buf = 0;
    v19 = "Cannot make additive values, base values array size must not be zero.";
LABEL_32:
    _os_log_error_impl(&dword_224FE9000, v18, OS_LOG_TYPE_ERROR, v19, buf, 2u);
    return 0;
  }
  *(_QWORD *)buf = 0;
  v21 = &str_110;
  v22 = 0u;
  v23 = 0u;
  v24 = 0u;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  re::SkeletalPose::init((uint64_t *)buf, (uint64_t *)(*(_QWORD *)*a2 + 80));
  v9 = 0;
  v10 = *((_QWORD *)a1 + 1);
  if (v10 && v4[1])
  {
    v9 = 0;
    while (a4 != (_QWORD *)v9)
    {
      v8 = *(uint64_t **)(*(_QWORD *)a1 + 8 * v9);
      v11 = *(unsigned __int8 **)(a3 + 8 * v9);
      if ((*(_BYTE *)v8 != 0) != (*v11 != 0))
      {
        re::Optional<re::SkeletalPose>::operator=(v11, v8);
        v10 = *((_QWORD *)a1 + 1);
      }
      if (v10 <= v9)
        goto LABEL_34;
      v12 = v4[1];
      if (**(_BYTE **)(*(_QWORD *)a1 + 8 * v9))
      {
        if (v12 <= v9)
          goto LABEL_37;
        re::AnimationValueTraits<re::SkeletalPose>::invert(*(_QWORD **)(*v4 + 8 * v9), buf);
        v14 = *((_QWORD *)a1 + 1);
        if (v14 <= v9)
          goto LABEL_38;
        re::AnimationValueTraits<re::SkeletalPose>::combine((_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 8 * v9) + 8), buf, (_QWORD *)(*(_QWORD *)(a3 + 8 * v9) + 8));
        v10 = *((_QWORD *)a1 + 1);
        v12 = v4[1];
      }
      if (v10 <= ++v9 || v12 <= v9)
      {
        v9 = v9;
        goto LABEL_17;
      }
    }
    re::internal::assertLog((re::internal *)6, (uint64_t)v8, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, a4, a4);
    _os_crash();
    __break(1u);
LABEL_34:
    re::internal::assertLog((re::internal *)6, (uint64_t)v8, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v9, v10);
    _os_crash();
    __break(1u);
  }
  else
  {
LABEL_17:
    if (v10 <= v9)
    {
LABEL_26:
      re::SkeletalPose::deinit((re::SkeletalPose *)buf);
      re::SkeletalPose::~SkeletalPose((re::SkeletalPose *)buf);
      return 1;
    }
    if ((unint64_t)a4 <= v9)
      v4 = (_QWORD *)v9;
    else
      v4 = a4;
    while (v4 != (_QWORD *)v9)
    {
      v15 = *(uint64_t **)(*(_QWORD *)a1 + 8 * v9);
      v16 = *(unsigned __int8 **)(a3 + 8 * v9);
      if ((*(_BYTE *)v15 != 0) != (*v16 != 0))
      {
        re::Optional<re::SkeletalPose>::operator=(v16, v15);
        v10 = *((_QWORD *)a1 + 1);
      }
      if (v10 <= v9)
        goto LABEL_36;
      re::AnimationValueTraits<re::SkeletalPose>::combine((_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 8 * v9) + 8), buf, (_QWORD *)(*(_QWORD *)(a3 + 8 * v9) + 8));
      ++v9;
      v10 = *((_QWORD *)a1 + 1);
      if (v10 <= v9)
        goto LABEL_26;
    }
  }
  re::internal::assertLog((re::internal *)6, (uint64_t)v8, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v4, a4);
  _os_crash();
  __break(1u);
LABEL_36:
  re::internal::assertLog((re::internal *)6, (uint64_t)v15, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v9, v10);
  _os_crash();
  __break(1u);
LABEL_37:
  re::internal::assertLog((re::internal *)6, (uint64_t)v8, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v9, v12);
  _os_crash();
  __break(1u);
LABEL_38:
  re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v9, v14);
  result = _os_crash();
  __break(1u);
  return result;
}

re::OrbitAnimation *re::OrbitAnimation::OrbitAnimation(re::OrbitAnimation *this)
{
  re::DynamicString *v2;

  *(_QWORD *)this = off_24ED1F350;
  *((_QWORD *)this + 1) = 37;
  *((_BYTE *)this + 16) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = &str_110;
  v2 = (re::OrbitAnimation *)((char *)this + 40);
  *((_BYTE *)this + 72) = 0;
  *(_QWORD *)this = off_24ED256C0;
  __asm { FMOV            V0.2S, #1.0 }
  *(_QWORD *)((char *)this + 76) = _D0;
  *((_WORD *)this + 42) = 1;
  *((_OWORD *)this + 6) = xmmword_2260E5F20;
  *((_DWORD *)this + 28) = 0;
  *((_QWORD *)this + 16) = 0x3F8000003F800000;
  *((_QWORD *)this + 17) = 1065353216;
  *((_QWORD *)this + 18) = 0;
  *((_QWORD *)this + 19) = 0x3F80000000000000;
  *((_OWORD *)this + 10) = 0u;
  *((_QWORD *)this + 22) = 0x3F8000003F800000;
  *((_QWORD *)this + 23) = 1065353216;
  *((_QWORD *)this + 24) = 0;
  *((_QWORD *)this + 25) = 0x3F80000000000000;
  *((_OWORD *)this + 13) = 0u;
  return this;
}

float32x4_t re::OrbitAnimation::computeOrbitTransform(float32x4_t *a1, uint64_t a2, float a3)
{
  float v5;
  float v6;
  float32x4_t v7;
  float32x4_t v8;
  float v9;
  float v10;
  float32x2_t v11;
  float32x2_t v12;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v17;
  float32x4_t v23;
  float32x4_t v24;
  int32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  int32x4_t v28;
  float32x4_t v29;
  int32x4_t v30;
  float32x4_t v31;
  int32x4_t v32;
  float32x4_t v33;
  float32x4_t v35;
  int32x4_t v36;
  float32x4_t v38;
  int32x4_t v39;
  float32x4_t v40;
  float32x4_t v42;
  float32x4_t v43;
  int32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  int8x16_t v47;
  float32x4_t v48;
  int32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  int32x4_t v52;
  float32x4_t v53;
  float32x4_t v55;
  float32x4_t v56;
  int32x4_t v57;
  float32x4_t v59;
  float32x4_t v60;
  int32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  int32x4_t v64;
  float32x4_t result;
  float32x4_t v66;

  v5 = a1[7].f32[0] + (float)((float)(a3 * 6.2832) * a1[5].f32[0]);
  v6 = -v5;
  if (!a1[5].i8[4])
    v6 = v5;
  v7 = a1[6];
  v8 = vmulq_f32(v7, v7);
  LODWORD(v9) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v8, 2), vaddq_f32(v8, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.f32, 1))).u32[0];
  if (fabsf(v9) >= 1.0e-10)
  {
    v10 = v9;
    v11 = vrsqrte_f32((float32x2_t)LODWORD(v9));
    v12 = vmul_f32(v11, vrsqrts_f32((float32x2_t)LODWORD(v10), vmul_f32(v11, v11)));
    v7 = vmulq_n_f32(v7, vmul_f32(v12, vrsqrts_f32((float32x2_t)LODWORD(v10), vmul_f32(v12, v12))).f32[0]);
  }
  v66 = v7;
  _KR00_8 = __sincosf_stret(v6 * 0.5);
  *(float32x2_t *)v14.f32 = vmul_n_f32(*(float32x2_t *)v66.f32, _KR00_8.__sinval);
  v14.i32[2] = vmuls_lane_f32(_KR00_8.__sinval, v66, 2);
  v15 = v14;
  v15.i32[3] = LODWORD(_KR00_8.__cosval);
  if (a1[4].i8[8])
  {
    _Q3 = a1[12];
    v17 = a1[13];
    __asm { FMOV            V5.4S, #1.0 }
    v23 = a1[10];
    v24 = vdivq_f32(_Q5, a1[11]);
    v25 = (int32x4_t)vnegq_f32(_Q3);
    v26 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v25, v25), (int8x16_t)v25, 0xCuLL);
    v27 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v17, (int32x4_t)v17), (int8x16_t)v17, 0xCuLL), _Q3), v17, v26);
    v28 = (int32x4_t)vaddq_f32(v27, v27);
    v29 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v28, v28), (int8x16_t)v28, 0xCuLL);
    v30 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v29, (int32x4_t)v29), (int8x16_t)v29, 0xCuLL), _Q3), v29, v26);
    v31 = vaddq_f32(vaddq_f32(v17, vmulq_laneq_f32(v29, _Q3, 3)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v30, v30), (int8x16_t)v30, 0xCuLL));
    v32 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v14, (int32x4_t)v14), (int8x16_t)v14, 0xCuLL), _Q3), v14, v26);
    v33 = vmlsq_laneq_f32(vmlaq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v32, v32), (int8x16_t)v32, 0xCuLL), v14, _Q3, 3), _Q3, v15, 3);
    __asm { FMLA            S2, S1, V3.S[3] }
    v35 = vmlaq_f32(vmulq_f32(_Q3, (float32x4_t)0), (float32x4_t)0, v26);
    v36 = (int32x4_t)vaddq_f32(v35, v35);
    _Q1 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v36, v36), (int8x16_t)v36, 0xCuLL);
    v38 = vaddq_f32(vmulq_laneq_f32(_Q1, _Q3, 3), (float32x4_t)0);
    v39 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q1, (int32x4_t)_Q1), (int8x16_t)_Q1, 0xCuLL), _Q3), _Q1, v26);
    v40 = vaddq_f32(v38, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v39, v39), (int8x16_t)v39, 0xCuLL));
    _Q6 = a1[9];
    v42 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v33, (int32x4_t)v33), (int8x16_t)v33, 0xCuLL);
    v43 = vnegq_f32(v33);
    v44 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q6, (int32x4_t)_Q6), (int8x16_t)_Q6, 0xCuLL), v43), _Q6, v42);
    v47 = (int8x16_t)vmlaq_laneq_f32(vmlaq_n_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v44, v44), (int8x16_t)v44, 0xCuLL), _Q6, _S2), v33, _Q6, 3);
    v45 = vsubq_f32(vmulq_f32(v24, v40), vmulq_f32(v24, v31));
    v46 = vmulq_f32(a1[8], v24);
    __asm { FMLA            S1, S2, V6.S[3] }
    v47.i32[3] = _Q1.i32[0];
    v48 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v23, (int32x4_t)v23), (int8x16_t)v23, 0xCuLL), v43), v23, v42);
    v49 = (int32x4_t)vaddq_f32(v48, v48);
    v50 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v49, v49), (int8x16_t)v49, 0xCuLL);
    v51 = vaddq_f32(v23, vmulq_n_f32(v50, _S2));
    v52 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v50, (int32x4_t)v50), (int8x16_t)v50, 0xCuLL), v43), v50, v42);
    v53 = vmulq_f32(v24, vaddq_f32(v51, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v52, v52), (int8x16_t)v52, 0xCuLL)));
    _Q5 = (float32x4_t)xmmword_2260E5D70;
  }
  else
  {
    v46 = a1[8];
    _Q5 = a1[9];
    v55 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v14, (int32x4_t)v14), (int8x16_t)v14, 0xCuLL);
    v56 = vnegq_f32(v14);
    v57 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q5, (int32x4_t)_Q5), (int8x16_t)_Q5, 0xCuLL), v56), _Q5, v55);
    v47 = (int8x16_t)vmlaq_laneq_f32(vmlaq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v57, v57), (int8x16_t)v57, 0xCuLL), _Q5, v15, 3), v14, _Q5, 3);
    __asm { FMLA            S2, S1, V5.S[3] }
    v47.i32[3] = _S2;
    v59 = a1[10];
    v60 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v59, (int32x4_t)v59), (int8x16_t)v59, 0xCuLL), v56), v59, v55);
    v61 = (int32x4_t)vaddq_f32(v60, v60);
    v62 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v61, v61), (int8x16_t)v61, 0xCuLL);
    v63 = vaddq_f32(v59, vmulq_laneq_f32(v62, v15, 3));
    v64 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v62, (int32x4_t)v62), (int8x16_t)v62, 0xCuLL), v56), v62, v55);
    v51 = (float32x4_t)vuzp1q_s32(v64, v64);
    v45 = vaddq_f32(v63, (float32x4_t)vextq_s8((int8x16_t)v51, (int8x16_t)v64, 0xCuLL));
    v53 = 0uLL;
  }
  v51.i32[0] = 0;
  result = vaddq_f32(v53, v45);
  v53.i8[0] = a1[5].i8[5];
  *(float32x4_t *)a2 = v46;
  *(int8x16_t *)(a2 + 16) = vbslq_s8(vdupq_lane_s8((int8x8_t)*(_OWORD *)&vceqq_s8((int8x16_t)v53, (int8x16_t)v51), 0), (int8x16_t)_Q5, v47);
  *(float32x4_t *)(a2 + 32) = result;
  return result;
}

void re::OrbitAnimation::evaluateCore(float32x4_t *a1, uint64_t a2, uint64_t a3, int a4, int a5, uint64_t a6)
{
  float v6;

  if (a3)
  {
    v6 = *(double *)(a2 + 24) / a1[4].f32[3];
    re::OrbitAnimation::computeOrbitTransform(a1, a6, v6);
  }
  else
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
  }
}

void re::OrbitAnimation::~OrbitAnimation(re::OrbitAnimation *this)
{
  uint64_t v2;
  _OWORD *v3;

  *(_QWORD *)this = off_24ED1F350;
  v3 = (_OWORD *)((char *)this + 40);
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    if ((*((_BYTE *)this + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *((_QWORD *)this + 7));
    *v3 = 0u;
    v3[1] = 0u;
  }
  re::StringID::destroyString((re::OrbitAnimation *)((char *)this + 24));
}

{
  uint64_t v2;
  _OWORD *v3;

  *(_QWORD *)this = off_24ED1F350;
  v3 = (_OWORD *)((char *)this + 40);
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    if ((*((_BYTE *)this + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *((_QWORD *)this + 7));
    *v3 = 0u;
    v3[1] = 0u;
  }
  re::StringID::destroyString((re::OrbitAnimation *)((char *)this + 24));
  JUMPOUT(0x2276933B8);
}

double re::OrbitAnimation::totalDuration(re::OrbitAnimation *this)
{
  return *((float *)this + 19);
}

uint64_t re::EvaluationOutputHandle<re::Matrix4x4<float>>::bindEvaluationOutput<re::Matrix4x4<float>>(_QWORD *a1, const re::IntrospectionBase *a2, char a3)
{
  unsigned __int8 v5;
  _QWORD *v6;
  uint64_t v7;
  const re::IntrospectionBase *v9;
  int v10;
  uint64_t v11;
  uint64_t v12[5];
  uint64_t v13;
  _BYTE v14[40];

  if ((v5 & 1) == 0)
  {
    v9 = a2;
    a2 = v9;
    if (v10)
    {
      re::introspect<re::Matrix4x4<float>>(void)::info = (_UNKNOWN *)re::introspect_Matrix4x4F(0);
      a2 = v9;
    }
  }
  re::makeBindPoint((re *)re::introspect<re::Matrix4x4<float>>(void)::info, a2, (uint64_t)&v11);
  v6 = (_QWORD *)*a1;
  v13 = v11;
  re::DynamicArray<re::BindPoint::BindPointData>::DynamicArray((uint64_t)v14, v12);
  v7 = re::EvaluationContextManager::bindOutputHandle<re::Matrix4x4<float>>(v6, (uint64_t)a1, &v13, a3);
  re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)v14);
  re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)v14);
  re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)v12);
  re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)v12);
  return v7;
}

void re::FixedArray<re::EvaluationOutputHandle<re::GenericSRT<float>>>::init<>(uint64_t *a1, uint64_t a2, unint64_t a3)
{
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;

  *a1 = a2;
  a1[1] = a3;
  if (!a3)
    return;
  if (a3 >> 60)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 16, a3);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  v5 = 16 * a3;
  v6 = (_QWORD *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 16 * a3, 8);
  a1[2] = (uint64_t)v6;
  if (!v6)
  {
LABEL_9:
    re::internal::assertLog((re::internal *)4, v7, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    _os_crash();
    __break(1u);
    return;
  }
  v8 = v6;
  if (a3 != 1)
  {
    bzero(v6, v5 - 16);
    v8 = (_QWORD *)((char *)v8 + v5 - 16);
  }
  *v8 = 0;
  v8[1] = 0;
}

void *re::RigEvaluation::init@<X0>(re::RigEvaluation *this@<X0>, re::Allocator *a2@<X1>, const re::RigDefinition *a3@<X2>, uint64_t a4@<X8>)
{
  void *result;
  _BYTE v9[8];
  __int128 v10;
  uint64_t v11;
  char v12;

  re::RigEvaluation::initRigDefinitionData(this, a2, a3, (uint64_t)v9);
  if (v9[0])
  {
    *(_QWORD *)this = a2;
    re::RigDefinition::operator=((uint64_t)this + 8, (uint64_t)a3);
    re::HashTable<re::StringID,BOOL (*)(re::MutableSlice<re::Matrix4x4<float>>,re::Slice<unsigned int>,re::Slice<unsigned long>,re::Slice<unsigned long>,re::Slice<re::Vector3<float>>,void *),re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init((uint64_t)this + 1224, (uint64_t)a2, 3);
    *((_QWORD *)this + 186) = a2;
    result = re::DynamicArray<re::internal::RigIKCall>::setCapacity((_QWORD *)this + 186, 0);
    ++*((_DWORD *)this + 378);
    *(_BYTE *)a4 = 1;
  }
  else
  {
    *(_BYTE *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v10;
    result = re::DynamicString::DynamicString((re::DynamicString *)(a4 + 24), (const re::DynamicString *)&v11);
  }
  if (!v9[0])
  {
    result = (void *)v11;
    if (v11)
    {
      if ((v12 & 1) != 0)
        return (void *)(*(uint64_t (**)(void))(*(_QWORD *)v11 + 40))();
    }
  }
  return result;
}

uint64_t re::RigEvaluation::initRigDefinitionData@<X0>(re::RigEvaluation *this@<X0>, re::Allocator *a2@<X1>, const re::RigDefinition *a3@<X2>, uint64_t a4@<X8>)
{
  char *v4;
  unint64_t *v5;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  char *v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  unint64_t v21;
  char **v22;
  unint64_t v23;
  char *v24;
  char *v25;
  char *v26;
  _QWORD *v27;
  _QWORD *v28;
  uint64_t v29;
  unint64_t *v30;
  _QWORD *v31;
  __int128 *v32;
  char *v33;
  unint64_t v34;
  char **v35;
  unint64_t v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  _QWORD *v46;
  unint64_t v47;
  unint64_t v48;
  unint64_t v49;
  uint64_t v50;
  uint64_t v51;
  char *v52;
  uint64_t v53;
  unint64_t v54;
  char **v55;
  char *v56;
  __int128 *v57;
  unint64_t v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t v63;
  uint64_t v64;
  unint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  char *v70;
  uint64_t v71;
  unint64_t v72;
  uint64_t *v73;
  char *v74;
  unint64_t v75;
  unint64_t v76;
  unint64_t v77;
  unint64_t v78;
  unint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  unint64_t v83;
  unint64_t v84;
  _QWORD *v85;
  uint64_t v86;
  const char *v87;
  char **v88;
  char *v89;
  size_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  char *v94;
  size_t v95;
  unint64_t v96;
  unint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  unint64_t v101;
  unint64_t v102;
  char *v103;
  const char *v104;
  size_t v105;
  unint64_t v106;
  unint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t result;
  __int128 v112;
  __int128 v113;
  uint64_t v114;
  _QWORD *v115;
  unint64_t v116;
  unint64_t *v117;
  unint64_t v118;
  unint64_t v119;
  re::Allocator *v120;
  uint64_t v121;
  unint64_t v122;
  uint64_t v123;
  unint64_t v124;
  __int128 v125;
  uint64_t v126;
  char v127[8];
  __int128 v128;
  uint64_t v129;
  char v130;
  uint64_t v131;
  __int128 v132;
  __int128 v133;
  __int128 v134;
  _QWORD v135[4];
  _BYTE v136[40];
  __int128 v137;
  _BYTE v138[18];
  __int16 v139;
  unint64_t v140;
  __int16 v141;
  char *v142;
  _QWORD v143[6];
  __int128 v144;
  __int128 v145;
  uint64_t v146;

  v5 = (unint64_t *)a3;
  v146 = *MEMORY[0x24BDAC8D0];
  re::validateRigDefinitionData(a2, a3, a3, (uint64_t)v127);
  if (!v127[0])
  {
    *(_BYTE *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v128;
    result = (uint64_t)re::DynamicString::DynamicString((re::DynamicString *)(a4 + 24), (const re::DynamicString *)&v129);
    goto LABEL_140;
  }
  re::FixedArray<re::FixedArray<float>>::init<>((uint64_t *)this + 168, (uint64_t)a2, v5[95]);
  re::FixedArray<re::FixedArray<float>>::init<>((uint64_t *)this + 171, (uint64_t)a2, v5[95]);
  re::FixedArray<re::TwoBoneIKOptions>::init<>((uint64_t *)this + 174, (uint64_t)a2, v5[95]);
  re::FixedArray<re::FABRIKOptions>::init<>((_QWORD *)this + 177, (uint64_t)a2, v5[100]);
  re::FixedArray<re::SplineIKOptions>::init<>((uint64_t)this + 1440, (uint64_t)a2, v5[105]);
  re::FixedArray<re::internal::RigIKCall>::init<>((uint64_t *)this + 165, (uint64_t)a2, v5[125]);
  v10 = v5[125];
  v120 = a2;
  *((_QWORD *)this + 183) = a2;
  *((_QWORD *)this + 184) = v10;
  v114 = a4;
  v117 = v5;
  if (v10)
  {
    if (v10 >> 60)
      goto LABEL_175;
    v11 = (*(uint64_t (**)(re::Allocator *, unint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 16 * v10, 8);
    *((_QWORD *)this + 185) = v11;
    if (!v11)
    {
LABEL_176:
      re::internal::assertLog((re::internal *)4, v12, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
      _os_crash();
      __break(1u);
LABEL_177:
      re::internal::assertLog((re::internal *)5, v12, "assertion failure: '%s' (%s:line %i) Unexpected Rig IK Handle Type: %u.", "!\"Unreachable code\"", "initRigDefinitionData", 1748, v18);
      _os_crash();
      __break(1u);
    }
    v13 = v10 - 1;
    if (v10 != 1)
    {
      do
      {
        *(_BYTE *)v11 = 0;
        *(_QWORD *)(v11 + 8) = -1;
        v11 += 16;
        --v13;
      }
      while (v13);
    }
    *(_BYTE *)v11 = 0;
    *(_QWORD *)(v11 + 8) = -1;
    if (v5[125])
    {
      v14 = 0;
      v15 = (unint64_t)&v132 + 8;
      v16 = v136;
      do
      {
        v17 = v5[127];
        v18 = *(unsigned __int8 *)(v17 + 16 * v14);
        switch((_DWORD)v18)
        {
          case 3:
            v54 = v17 + 16 * v14;
            v56 = *(char **)(v54 + 8);
            v55 = (char **)(v54 + 8);
            v15 = (unint64_t)v56;
            v24 = (char *)v5[105];
            if (v24 <= v56)
              goto LABEL_153;
            v57 = (__int128 *)*((_QWORD *)this + 181);
            if ((unint64_t)v57 <= v15)
              goto LABEL_155;
            v58 = v5[107];
            v59 = v58 + 240 * v15;
            v60 = *((_QWORD *)this + 182) + 80 * v15;
            *(float *)v60 = *(float *)v59 * *(float *)v59;
            v61 = *(_QWORD *)(v59 + 120);
            v62 = *(_QWORD *)(v59 + 104);
            *(_QWORD *)(v60 + 8) = v61;
            *(_QWORD *)(v60 + 16) = v62;
            v33 = *v55;
            v4 = (char *)*((_QWORD *)this + 181);
            if (v4 <= *v55)
              goto LABEL_157;
            v63 = v58 + 240 * v15;
            v64 = *((_QWORD *)this + 182);
            *(_DWORD *)(v64 + 80 * (_QWORD)v33 + 64) = *(_DWORD *)(v63 + 224);
            v65 = *(_QWORD *)(v63 + 64);
            if (*(_QWORD *)(v63 + 160) != -1)
            {
              ++v65;
              v66 = v64 + 80 * (_QWORD)v33;
              *(_BYTE *)(v66 + 24) = 1;
              *(_OWORD *)(v66 + 32) = *(_OWORD *)(v58 + 240 * v15 + 176);
            }
            v119 = v58;
            if (*(_QWORD *)(v58 + 240 * v15 + 168) != -1)
            {
              v33 = *v55;
              v4 = (char *)*((_QWORD *)this + 181);
              if (v4 <= *v55)
                goto LABEL_174;
              ++v65;
              v67 = *((_QWORD *)this + 182) + 80 * (_QWORD)v33;
              *(_BYTE *)(v67 + 25) = 1;
              *(_OWORD *)(v67 + 48) = *(_OWORD *)(v58 + 240 * v15 + 192);
            }
            *(_QWORD *)&v132 = re::solverSplineIK;
            v4 = (char *)&v132 + 8;
            v133 = 0uLL;
            *((_QWORD *)&v132 + 1) = 0;
            re::FixedArray<unsigned long>::init<>((uint64_t *)&v132 + 1, (uint64_t)v120, 1uLL);
            v134 = 0uLL;
            v135[0] = 0;
            re::FixedArray<unsigned long>::init<>((uint64_t *)&v134, (uint64_t)v120, 1uLL);
            memset(&v135[1], 0, 24);
            *(_QWORD *)v136 = v65;
            memset(&v136[8], 0, 32);
            re::FixedArray<re::Vector3<float>>::init<>((uint64_t *)&v136[16], (uint64_t)v120, v65);
            *(_QWORD *)&v137 = 0;
            *((_QWORD *)&v137 + 1) = v14;
            v33 = (char *)*((_QWORD *)this + 166);
            if ((unint64_t)v33 <= v14)
              goto LABEL_160;
            v68 = *((_QWORD *)this + 167) + 136 * v14;
            *(_QWORD *)v68 = v132;
            re::FixedArray<unsigned long>::operator=((uint64_t *)(v68 + 8), (uint64_t *)&v132 + 1);
            re::FixedArray<unsigned long>::operator=((uint64_t *)(v68 + 32), (uint64_t *)&v134);
            re::FixedArray<unsigned long>::operator=((uint64_t *)(v68 + 56), &v135[1]);
            *(_OWORD *)(v68 + 80) = *(_OWORD *)v136;
            re::FixedArray<float>::operator=((uint64_t *)(v68 + 96), (uint64_t *)&v136[16]);
            *(_OWORD *)(v68 + 120) = v137;
            if (*(_QWORD *)&v136[16])
            {
              if (*(_QWORD *)&v136[24])
              {
                (*(void (**)(void))(**(_QWORD **)&v136[16] + 40))();
                *(_QWORD *)&v136[24] = 0;
                *(_QWORD *)&v136[32] = 0;
              }
              *(_QWORD *)&v136[16] = 0;
            }
            v16 = v136;
            if (v135[1])
            {
              if (v135[2])
              {
                (*(void (**)(void))(*(_QWORD *)v135[1] + 40))();
                v135[2] = 0;
                v135[3] = 0;
              }
              v135[1] = 0;
            }
            if ((_QWORD)v134)
            {
              if (*((_QWORD *)&v134 + 1))
              {
                (*(void (**)(void))(*(_QWORD *)v134 + 40))();
                *((_QWORD *)&v134 + 1) = 0;
                v135[0] = 0;
              }
              *(_QWORD *)&v134 = 0;
            }
            if (*((_QWORD *)&v132 + 1) && (_QWORD)v133)
              (*(void (**)(void))(**((_QWORD **)&v132 + 1) + 40))();
            v33 = (char *)*((_QWORD *)this + 166);
            if ((unint64_t)v33 <= v14)
              goto LABEL_161;
            v69 = *((_QWORD *)this + 167);
            if (!*(_QWORD *)(v69 + 136 * v14 + 16))
              goto LABEL_162;
            **(_QWORD **)(v69 + 136 * v14 + 24) = *(_QWORD *)(v119 + 240 * v15 + 128);
            v33 = (char *)*((_QWORD *)this + 166);
            if ((unint64_t)v33 <= v14)
              goto LABEL_163;
            if (!*(_QWORD *)(v69 + 136 * v14 + 40))
              goto LABEL_164;
            **(_QWORD **)(v69 + 136 * v14 + 48) = *(_QWORD *)(v119 + 240 * v15 + 136);
            v33 = (char *)*((_QWORD *)this + 184);
            if ((unint64_t)v33 <= v14)
              goto LABEL_165;
            v70 = *v55;
            v71 = *((_QWORD *)this + 185) + 16 * v14;
            *(_BYTE *)v71 = 3;
            *(_QWORD *)(v71 + 8) = v70;
            v15 = (unint64_t)&v132 + 8;
            v5 = v117;
            break;
          case 2:
            v72 = v17 + 16 * v14;
            v74 = *(char **)(v72 + 8);
            v73 = (uint64_t *)(v72 + 8);
            v33 = v74;
            v4 = (char *)v5[100];
            if (v4 <= v74)
              goto LABEL_154;
            v4 = (char *)*((_QWORD *)this + 178);
            if (v4 <= v33)
              goto LABEL_156;
            v75 = v5[102] + ((_QWORD)v33 << 7);
            v76 = *(_QWORD *)(v75 + 96);
            *(_DWORD *)(*((_QWORD *)this + 179) + 8 * (_QWORD)v33) = *(_DWORD *)(v75 + 120);
            *(_QWORD *)&v132 = re::solverFABRIK;
            v125 = 0uLL;
            v77 = *(_QWORD *)(v75 + 16);
            *(_QWORD *)&v125 = *(_QWORD *)(v75 + 32);
            *((_QWORD *)&v125 + 1) = v77;
            v133 = 0uLL;
            *((_QWORD *)&v132 + 1) = 0;
            re::FixedArray<unsigned long>::init<>((uint64_t *)&v132 + 1, (uint64_t)v120, v77);
            re::FixedArray<unsigned long>::copy((char *)&v132 + 8, (uint64_t)&v125);
            v123 = 0;
            v124 = 0;
            v78 = *(_QWORD *)(v75 + 56);
            v123 = *(_QWORD *)(v75 + 72);
            v124 = v78;
            v135[0] = 0;
            v134 = 0uLL;
            re::FixedArray<unsigned long>::init<>((uint64_t *)&v134, (uint64_t)v120, v78);
            re::FixedArray<unsigned long>::copy(&v134, (uint64_t)&v123);
            v121 = 0;
            v122 = 0;
            v79 = *(_QWORD *)(v75 + 96);
            v121 = *(_QWORD *)(v75 + 112);
            v122 = v79;
            memset(&v135[1], 0, 24);
            re::FixedArray<unsigned long>::init<>(&v135[1], (uint64_t)v120, v79);
            re::FixedArray<unsigned long>::copy(&v135[1], (uint64_t)&v121);
            memset(v136, 0, sizeof(v136));
            v4 = &v136[16];
            re::FixedArray<re::Vector3<float>>::init<>((uint64_t *)&v136[16], (uint64_t)v120, v76);
            v137 = 0uLL;
            v33 = (char *)*((_QWORD *)this + 166);
            if ((unint64_t)v33 <= v14)
              goto LABEL_158;
            v80 = *((_QWORD *)this + 167) + 136 * v14;
            *(_QWORD *)v80 = v132;
            re::FixedArray<unsigned long>::operator=((uint64_t *)(v80 + 8), (uint64_t *)&v132 + 1);
            re::FixedArray<unsigned long>::operator=((uint64_t *)(v80 + 32), (uint64_t *)&v134);
            re::FixedArray<unsigned long>::operator=((uint64_t *)(v80 + 56), &v135[1]);
            *(_OWORD *)(v80 + 80) = *(_OWORD *)v136;
            re::FixedArray<float>::operator=((uint64_t *)(v80 + 96), (uint64_t *)&v136[16]);
            *(_OWORD *)(v80 + 120) = v137;
            v5 = v117;
            if (*(_QWORD *)&v136[16])
            {
              if (*(_QWORD *)&v136[24])
              {
                (*(void (**)(void))(**(_QWORD **)&v136[16] + 40))();
                *(_QWORD *)&v136[24] = 0;
                *(_QWORD *)&v136[32] = 0;
              }
              *(_QWORD *)&v136[16] = 0;
            }
            if (v135[1])
            {
              if (v135[2])
              {
                (*(void (**)(void))(*(_QWORD *)v135[1] + 40))();
                v135[2] = 0;
                v135[3] = 0;
              }
              v135[1] = 0;
            }
            if ((_QWORD)v134)
            {
              if (*((_QWORD *)&v134 + 1))
              {
                (*(void (**)(void))(*(_QWORD *)v134 + 40))();
                *((_QWORD *)&v134 + 1) = 0;
                v135[0] = 0;
              }
              *(_QWORD *)&v134 = 0;
            }
            if (*((_QWORD *)&v132 + 1) && (_QWORD)v133)
              (*(void (**)(void))(**((_QWORD **)&v132 + 1) + 40))();
            v33 = (char *)*((_QWORD *)this + 184);
            if ((unint64_t)v33 <= v14)
              goto LABEL_159;
            v81 = *v73;
            v82 = *((_QWORD *)this + 185) + 16 * v14;
            *(_BYTE *)v82 = 2;
            *(_QWORD *)(v82 + 8) = v81;
            break;
          case 1:
            v19 = v5;
            v20 = v17 + 16 * v14;
            v23 = *(_QWORD *)(v20 + 8);
            v22 = (char **)(v20 + 8);
            v21 = v23;
            v24 = (char *)v19[95];
            if ((unint64_t)v24 <= v23)
              goto LABEL_152;
            v118 = v19[97];
            v115 = (_QWORD *)(v118 + 240 * v21);
            v26 = (char *)(v115 + 12);
            v25 = (char *)v115[12];
            v125 = 0uLL;
            v126 = 0;
            v116 = 2 * (_QWORD)v25;
            re::FixedArray<unsigned long>::init<>((uint64_t *)&v125, (uint64_t)v120, 2 * (_QWORD)v25);
            if (v25)
            {
              v4 = 0;
              v15 = 0;
              v27 = (_QWORD *)(v118 + 240 * v21);
              v28 = v27 + 14;
              v29 = v126;
              v30 = v27 + 17;
              v31 = v27 + 19;
              while (1)
              {
                v16 = *(char **)v26;
                if (*(_QWORD *)v26 <= v15)
                  break;
                v16 = (char *)*((_QWORD *)&v125 + 1);
                if (*((_QWORD *)&v125 + 1) <= (unint64_t)v4)
                  goto LABEL_146;
                *(_QWORD *)(v29 + 8 * (_QWORD)v4) = *(_QWORD *)(*v28 + 8 * v15);
                v16 = (char *)*v30;
                if (*v30 <= v15)
                  goto LABEL_147;
                v32 = (__int128 *)(v4 + 1);
                v16 = (char *)*((_QWORD *)&v125 + 1);
                if (*((_QWORD *)&v125 + 1) <= (unint64_t)(v4 + 1))
                  goto LABEL_148;
                *(_QWORD *)(v29 + 8 * (_QWORD)v4 + 8) = *(_QWORD *)(*v31 + 8 * v15++);
                v4 += 2;
                if (v25 == (char *)v15)
                  goto LABEL_20;
              }
              *(_QWORD *)v138 = 0;
              memset(v135, 0, sizeof(v135));
              v133 = 0u;
              v134 = 0u;
              v132 = 0u;
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              LODWORD(v143[0]) = 136315906;
              *(_QWORD *)((char *)v143 + 4) = "operator[]";
              WORD2(v143[1]) = 1024;
              *(_DWORD *)((char *)&v143[1] + 6) = 797;
              WORD1(v143[2]) = 2048;
              *(_QWORD *)((char *)&v143[2] + 4) = v15;
              WORD2(v143[3]) = 2048;
              *(_QWORD *)((char *)&v143[3] + 6) = v16;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_146:
              *(_QWORD *)v138 = 0;
              memset(v135, 0, sizeof(v135));
              v133 = 0u;
              v134 = 0u;
              v132 = 0u;
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              LODWORD(v143[0]) = 136315906;
              *(_QWORD *)((char *)v143 + 4) = "operator[]";
              WORD2(v143[1]) = 1024;
              *(_DWORD *)((char *)&v143[1] + 6) = 468;
              WORD1(v143[2]) = 2048;
              *(_QWORD *)((char *)&v143[2] + 4) = v4;
              WORD2(v143[3]) = 2048;
              *(_QWORD *)((char *)&v143[3] + 6) = v16;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_147:
              *(_QWORD *)v138 = 0;
              v32 = &v132;
              memset(v135, 0, sizeof(v135));
              v133 = 0u;
              v134 = 0u;
              v132 = 0u;
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              LODWORD(v143[0]) = 136315906;
              *(_QWORD *)((char *)v143 + 4) = "operator[]";
              WORD2(v143[1]) = 1024;
              *(_DWORD *)((char *)&v143[1] + 6) = 797;
              WORD1(v143[2]) = 2048;
              *(_QWORD *)((char *)&v143[2] + 4) = v15;
              WORD2(v143[3]) = 2048;
              *(_QWORD *)((char *)&v143[3] + 6) = v16;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_148:
              *(_QWORD *)v138 = 0;
              v33 = (char *)&v132;
              memset(v135, 0, sizeof(v135));
              v133 = 0u;
              v134 = 0u;
              v132 = 0u;
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              LODWORD(v143[0]) = 136315906;
              *(_QWORD *)((char *)v143 + 4) = "operator[]";
              WORD2(v143[1]) = 1024;
              *(_DWORD *)((char *)&v143[1] + 6) = 468;
              WORD1(v143[2]) = 2048;
              *(_QWORD *)((char *)&v143[2] + 4) = v32;
              WORD2(v143[3]) = 2048;
              *(_QWORD *)((char *)&v143[3] + 6) = v16;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_149:
              *(_QWORD *)v138 = 0;
              memset(v135, 0, sizeof(v135));
              v133 = 0u;
              v134 = 0u;
              v132 = 0u;
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              LODWORD(v143[0]) = 136315906;
              *(_QWORD *)((char *)v143 + 4) = "operator[]";
              WORD2(v143[1]) = 1024;
              *(_DWORD *)((char *)&v143[1] + 6) = 797;
              WORD1(v143[2]) = 2048;
              *(_QWORD *)((char *)&v143[2] + 4) = v4;
              WORD2(v143[3]) = 2048;
              *(_QWORD *)((char *)&v143[3] + 6) = v4;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_150:
              *(_QWORD *)v138 = 0;
              memset(v135, 0, sizeof(v135));
              v133 = 0u;
              v134 = 0u;
              v132 = 0u;
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              LODWORD(v143[0]) = 136315906;
              *(_QWORD *)((char *)v143 + 4) = "operator[]";
              WORD2(v143[1]) = 1024;
              *(_DWORD *)((char *)&v143[1] + 6) = 468;
              WORD1(v143[2]) = 2048;
              *(_QWORD *)((char *)&v143[2] + 4) = v33;
              WORD2(v143[3]) = 2048;
              *(_QWORD *)((char *)&v143[3] + 6) = v16;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_151:
              *(_QWORD *)v138 = 0;
              v24 = (char *)&v132;
              memset(v135, 0, sizeof(v135));
              v133 = 0u;
              v134 = 0u;
              v132 = 0u;
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              LODWORD(v143[0]) = 136315906;
              *(_QWORD *)((char *)v143 + 4) = "operator[]";
              WORD2(v143[1]) = 1024;
              *(_DWORD *)((char *)&v143[1] + 6) = 468;
              WORD1(v143[2]) = 2048;
              *(_QWORD *)((char *)&v143[2] + 4) = v26;
              WORD2(v143[3]) = 2048;
              *(_QWORD *)((char *)&v143[3] + 6) = v16;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_152:
              *(_QWORD *)v138 = 0;
              memset(v135, 0, sizeof(v135));
              v133 = 0u;
              v134 = 0u;
              v132 = 0u;
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              LODWORD(v143[0]) = 136315906;
              *(_QWORD *)((char *)v143 + 4) = "operator[]";
              WORD2(v143[1]) = 1024;
              *(_DWORD *)((char *)&v143[1] + 6) = 797;
              WORD1(v143[2]) = 2048;
              *(_QWORD *)((char *)&v143[2] + 4) = v21;
              WORD2(v143[3]) = 2048;
              *(_QWORD *)((char *)&v143[3] + 6) = v24;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_153:
              *(_QWORD *)v138 = 0;
              v33 = (char *)&v132;
              memset(v135, 0, sizeof(v135));
              v133 = 0u;
              v134 = 0u;
              v132 = 0u;
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              LODWORD(v143[0]) = 136315906;
              *(_QWORD *)((char *)v143 + 4) = "operator[]";
              WORD2(v143[1]) = 1024;
              *(_DWORD *)((char *)&v143[1] + 6) = 797;
              WORD1(v143[2]) = 2048;
              *(_QWORD *)((char *)&v143[2] + 4) = v15;
              WORD2(v143[3]) = 2048;
              *(_QWORD *)((char *)&v143[3] + 6) = v24;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_154:
              *(_QWORD *)v138 = 0;
              v57 = &v132;
              memset(v135, 0, sizeof(v135));
              v133 = 0u;
              v134 = 0u;
              v132 = 0u;
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              LODWORD(v143[0]) = 136315906;
              *(_QWORD *)((char *)v143 + 4) = "operator[]";
              WORD2(v143[1]) = 1024;
              *(_DWORD *)((char *)&v143[1] + 6) = 797;
              WORD1(v143[2]) = 2048;
              *(_QWORD *)((char *)&v143[2] + 4) = v33;
              WORD2(v143[3]) = 2048;
              *(_QWORD *)((char *)&v143[3] + 6) = v4;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_155:
              *(_QWORD *)v138 = 0;
              v33 = (char *)&v132;
              memset(v135, 0, sizeof(v135));
              v133 = 0u;
              v134 = 0u;
              v132 = 0u;
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              LODWORD(v143[0]) = 136315906;
              *(_QWORD *)((char *)v143 + 4) = "operator[]";
              WORD2(v143[1]) = 1024;
              *(_DWORD *)((char *)&v143[1] + 6) = 468;
              WORD1(v143[2]) = 2048;
              *(_QWORD *)((char *)&v143[2] + 4) = v15;
              WORD2(v143[3]) = 2048;
              *(_QWORD *)((char *)&v143[3] + 6) = v57;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_156:
              *(_QWORD *)v138 = 0;
              memset(v135, 0, sizeof(v135));
              v133 = 0u;
              v134 = 0u;
              v132 = 0u;
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              LODWORD(v143[0]) = 136315906;
              *(_QWORD *)((char *)v143 + 4) = "operator[]";
              WORD2(v143[1]) = 1024;
              *(_DWORD *)((char *)&v143[1] + 6) = 468;
              WORD1(v143[2]) = 2048;
              *(_QWORD *)((char *)&v143[2] + 4) = v33;
              WORD2(v143[3]) = 2048;
              *(_QWORD *)((char *)&v143[3] + 6) = v4;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_157:
              *(_QWORD *)v138 = 0;
              memset(v135, 0, sizeof(v135));
              v133 = 0u;
              v134 = 0u;
              v132 = 0u;
              v14 = MEMORY[0x24BDACB70];
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              LODWORD(v143[0]) = 136315906;
              *(_QWORD *)((char *)v143 + 4) = "operator[]";
              WORD2(v143[1]) = 1024;
              *(_DWORD *)((char *)&v143[1] + 6) = 468;
              WORD1(v143[2]) = 2048;
              *(_QWORD *)((char *)&v143[2] + 4) = v33;
              WORD2(v143[3]) = 2048;
              *(_QWORD *)((char *)&v143[3] + 6) = v4;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_158:
              v131 = 0;
              v144 = 0u;
              v145 = 0u;
              memset(v143, 0, sizeof(v143));
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              *(_DWORD *)v138 = 136315906;
              *(_QWORD *)&v138[4] = "operator[]";
              *(_WORD *)&v138[12] = 1024;
              *(_DWORD *)&v138[14] = 468;
              v139 = 2048;
              v140 = v14;
              v141 = 2048;
              v142 = v33;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_159:
              *(_QWORD *)v138 = 0;
              memset(v135, 0, sizeof(v135));
              v133 = 0u;
              v134 = 0u;
              v132 = 0u;
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              LODWORD(v143[0]) = 136315906;
              *(_QWORD *)((char *)v143 + 4) = "operator[]";
              WORD2(v143[1]) = 1024;
              *(_DWORD *)((char *)&v143[1] + 6) = 468;
              WORD1(v143[2]) = 2048;
              *(_QWORD *)((char *)&v143[2] + 4) = v14;
              WORD2(v143[3]) = 2048;
              *(_QWORD *)((char *)&v143[3] + 6) = v33;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_160:
              *(_QWORD *)&v125 = 0;
              v144 = 0u;
              v145 = 0u;
              memset(v143, 0, sizeof(v143));
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              *(_DWORD *)v138 = 136315906;
              *(_QWORD *)&v138[4] = "operator[]";
              *(_WORD *)&v138[12] = 1024;
              *(_DWORD *)&v138[14] = 468;
              v139 = 2048;
              v140 = v14;
              v141 = 2048;
              v142 = v33;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_161:
              *(_QWORD *)v138 = 0;
              memset(v135, 0, sizeof(v135));
              v133 = 0u;
              v134 = 0u;
              v132 = 0u;
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              LODWORD(v143[0]) = 136315906;
              *(_QWORD *)((char *)v143 + 4) = "operator[]";
              WORD2(v143[1]) = 1024;
              *(_DWORD *)((char *)&v143[1] + 6) = 468;
              WORD1(v143[2]) = 2048;
              *(_QWORD *)((char *)&v143[2] + 4) = v14;
              WORD2(v143[3]) = 2048;
              *(_QWORD *)((char *)&v143[3] + 6) = v33;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_162:
              *(_QWORD *)v138 = 0;
              memset(v135, 0, sizeof(v135));
              v133 = 0u;
              v134 = 0u;
              v132 = 0u;
              v14 = MEMORY[0x24BDACB70];
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              LODWORD(v143[0]) = 136315906;
              *(_QWORD *)((char *)v143 + 4) = "operator[]";
              WORD2(v143[1]) = 1024;
              *(_DWORD *)((char *)&v143[1] + 6) = 468;
              WORD1(v143[2]) = 2048;
              *(_QWORD *)((char *)&v143[2] + 4) = 0;
              WORD2(v143[3]) = 2048;
              *(_QWORD *)((char *)&v143[3] + 6) = 0;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_163:
              *(_QWORD *)v138 = 0;
              memset(v135, 0, sizeof(v135));
              v133 = 0u;
              v134 = 0u;
              v132 = 0u;
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              LODWORD(v143[0]) = 136315906;
              *(_QWORD *)((char *)v143 + 4) = "operator[]";
              WORD2(v143[1]) = 1024;
              *(_DWORD *)((char *)&v143[1] + 6) = 468;
              WORD1(v143[2]) = 2048;
              *(_QWORD *)((char *)&v143[2] + 4) = v14;
              WORD2(v143[3]) = 2048;
              *(_QWORD *)((char *)&v143[3] + 6) = v33;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_164:
              *(_QWORD *)v138 = 0;
              memset(v135, 0, sizeof(v135));
              v133 = 0u;
              v134 = 0u;
              v132 = 0u;
              v14 = MEMORY[0x24BDACB70];
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              LODWORD(v143[0]) = 136315906;
              *(_QWORD *)((char *)v143 + 4) = "operator[]";
              WORD2(v143[1]) = 1024;
              *(_DWORD *)((char *)&v143[1] + 6) = 468;
              WORD1(v143[2]) = 2048;
              *(_QWORD *)((char *)&v143[2] + 4) = 0;
              WORD2(v143[3]) = 2048;
              *(_QWORD *)((char *)&v143[3] + 6) = 0;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_165:
              *(_QWORD *)v138 = 0;
              memset(v135, 0, sizeof(v135));
              v133 = 0u;
              v134 = 0u;
              v132 = 0u;
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              LODWORD(v143[0]) = 136315906;
              *(_QWORD *)((char *)v143 + 4) = "operator[]";
              WORD2(v143[1]) = 1024;
              *(_DWORD *)((char *)&v143[1] + 6) = 468;
              WORD1(v143[2]) = 2048;
              *(_QWORD *)((char *)&v143[2] + 4) = v14;
              WORD2(v143[3]) = 2048;
              *(_QWORD *)((char *)&v143[3] + 6) = v33;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_166:
              *(_QWORD *)v138 = 0;
              memset(v135, 0, sizeof(v135));
              v133 = 0u;
              v134 = 0u;
              v132 = 0u;
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              LODWORD(v143[0]) = 136315906;
              *(_QWORD *)((char *)v143 + 4) = "operator[]";
              WORD2(v143[1]) = 1024;
              *(_DWORD *)((char *)&v143[1] + 6) = 468;
              WORD1(v143[2]) = 2048;
              *(_QWORD *)((char *)&v143[2] + 4) = v33;
              WORD2(v143[3]) = 2048;
              *(_QWORD *)((char *)&v143[3] + 6) = v4;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_167:
              v123 = 0;
              memset(v135, 0, sizeof(v135));
              v133 = 0u;
              v134 = 0u;
              v132 = 0u;
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              LODWORD(v143[0]) = 136315906;
              *(_QWORD *)((char *)v143 + 4) = "operator[]";
              WORD2(v143[1]) = 1024;
              *(_DWORD *)((char *)&v143[1] + 6) = 468;
              WORD1(v143[2]) = 2048;
              *(_QWORD *)((char *)&v143[2] + 4) = v33;
              WORD2(v143[3]) = 2048;
              *(_QWORD *)((char *)&v143[3] + 6) = v4;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_168:
              *(_QWORD *)v138 = 0;
              memset(v135, 0, sizeof(v135));
              v133 = 0u;
              v134 = 0u;
              v132 = 0u;
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              LODWORD(v143[0]) = 136315906;
              *(_QWORD *)((char *)v143 + 4) = "operator[]";
              WORD2(v143[1]) = 1024;
              *(_DWORD *)((char *)&v143[1] + 6) = 468;
              WORD1(v143[2]) = 2048;
              *(_QWORD *)((char *)&v143[2] + 4) = v4;
              WORD2(v143[3]) = 2048;
              *(_QWORD *)((char *)&v143[3] + 6) = v33;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_169:
              *(_QWORD *)v138 = 0;
              memset(v135, 0, sizeof(v135));
              v133 = 0u;
              v134 = 0u;
              v132 = 0u;
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              LODWORD(v143[0]) = 136315906;
              *(_QWORD *)((char *)v143 + 4) = "operator[]";
              WORD2(v143[1]) = 1024;
              *(_DWORD *)((char *)&v143[1] + 6) = 468;
              WORD1(v143[2]) = 2048;
              *(_QWORD *)((char *)&v143[2] + 4) = v4;
              WORD2(v143[3]) = 2048;
              *(_QWORD *)((char *)&v143[3] + 6) = v33;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_170:
              *(_QWORD *)v138 = 0;
              memset(v135, 0, sizeof(v135));
              v133 = 0u;
              v134 = 0u;
              v132 = 0u;
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              LODWORD(v143[0]) = 136315906;
              *(_QWORD *)((char *)v143 + 4) = "operator[]";
              WORD2(v143[1]) = 1024;
              *(_DWORD *)((char *)&v143[1] + 6) = 468;
              WORD1(v143[2]) = 2048;
              *(_QWORD *)((char *)&v143[2] + 4) = v4;
              WORD2(v143[3]) = 2048;
              *(_QWORD *)((char *)&v143[3] + 6) = v33;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_171:
              *(_QWORD *)v138 = 0;
              memset(v135, 0, sizeof(v135));
              v133 = 0u;
              v134 = 0u;
              v132 = 0u;
              v14 = MEMORY[0x24BDACB70];
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              LODWORD(v143[0]) = 136315906;
              *(_QWORD *)((char *)v143 + 4) = "operator[]";
              WORD2(v143[1]) = 1024;
              *(_DWORD *)((char *)&v143[1] + 6) = 468;
              WORD1(v143[2]) = 2048;
              *(_QWORD *)((char *)&v143[2] + 4) = v4;
              WORD2(v143[3]) = 2048;
              *(_QWORD *)((char *)&v143[3] + 6) = v33;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_172:
              v131 = 0;
              v144 = 0u;
              v145 = 0u;
              memset(v143, 0, sizeof(v143));
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              *(_DWORD *)v138 = 136315906;
              *(_QWORD *)&v138[4] = "operator[]";
              *(_WORD *)&v138[12] = 1024;
              *(_DWORD *)&v138[14] = 468;
              v139 = 2048;
              v140 = v14;
              v141 = 2048;
              v142 = v33;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_173:
              *(_QWORD *)v138 = 0;
              memset(v135, 0, sizeof(v135));
              v133 = 0u;
              v134 = 0u;
              v132 = 0u;
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              LODWORD(v143[0]) = 136315906;
              *(_QWORD *)((char *)v143 + 4) = "operator[]";
              WORD2(v143[1]) = 1024;
              *(_DWORD *)((char *)&v143[1] + 6) = 468;
              WORD1(v143[2]) = 2048;
              *(_QWORD *)((char *)&v143[2] + 4) = v14;
              WORD2(v143[3]) = 2048;
              *(_QWORD *)((char *)&v143[3] + 6) = v33;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_174:
              *(_QWORD *)v138 = 0;
              memset(v135, 0, sizeof(v135));
              v133 = 0u;
              v134 = 0u;
              v132 = 0u;
              v10 = MEMORY[0x24BDACB70];
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              LODWORD(v143[0]) = 136315906;
              *(_QWORD *)((char *)v143 + 4) = "operator[]";
              WORD2(v143[1]) = 1024;
              *(_DWORD *)((char *)&v143[1] + 6) = 468;
              WORD1(v143[2]) = 2048;
              *(_QWORD *)((char *)&v143[2] + 4) = v33;
              WORD2(v143[3]) = 2048;
              *(_QWORD *)((char *)&v143[3] + 6) = v4;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_175:
              re::internal::assertLog((re::internal *)6, v9, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 16, v10);
              _os_crash();
              __break(1u);
              goto LABEL_176;
            }
LABEL_20:
            v33 = *v22;
            v4 = (char *)*((_QWORD *)this + 169);
            if (v4 <= *v22)
              goto LABEL_166;
            v34 = v118 + 240 * v21;
            v36 = *(_QWORD *)(v34 + 176);
            v35 = (char **)(v34 + 176);
            v15 = v36;
            re::FixedArray<int>::init<>((uint64_t *)(*((_QWORD *)this + 170) + 24 * (_QWORD)v33), (uint64_t)v120, v36);
            if (v36)
            {
              v26 = 0;
              v4 = *v35;
              while (v4 != v26)
              {
                v33 = *v22;
                v16 = (char *)*((_QWORD *)this + 169);
                if (v16 <= *v22)
                  goto LABEL_150;
                v37 = *((_QWORD *)this + 170);
                v16 = *(char **)(v37 + 24 * (_QWORD)v33 + 8);
                if (v16 <= v26)
                  goto LABEL_151;
                *(float *)(*(_QWORD *)(v37 + 24 * (_QWORD)v33 + 16) + 4 * (_QWORD)v26) = *(float *)(*(_QWORD *)(v118 + 240 * v21 + 192) + 4 * (_QWORD)v26)
                                                                                           * 0.017453;
                if ((char *)v15 == ++v26)
                  goto LABEL_27;
              }
              goto LABEL_149;
            }
LABEL_27:
            v38 = v118 + 240 * v21;
            *(_QWORD *)v138 = 0;
            *(_QWORD *)&v138[8] = 0;
            v39 = *(_QWORD *)(v38 + 232);
            v40 = *(_QWORD *)(v38 + 216);
            *(_QWORD *)v138 = v39;
            *(_QWORD *)&v138[8] = v40;
            v33 = *v22;
            v4 = (char *)*((_QWORD *)this + 172);
            if (v4 <= *v22)
              goto LABEL_167;
            re::FixedArray<int>::operator=((_anonymous_namespace_ *)(*((_QWORD *)this + 173) + 24 * (_QWORD)v33), (uint64_t)v138);
            v4 = *v22;
            v33 = (char *)*((_QWORD *)this + 169);
            if (v33 <= *v22)
              goto LABEL_168;
            v33 = (char *)*((_QWORD *)this + 175);
            if (v33 <= v4)
              goto LABEL_169;
            v41 = *((_QWORD *)this + 170) + 24 * (_QWORD)v4;
            v42 = *(_QWORD *)(v41 + 8);
            v43 = *((_QWORD *)this + 176) + 32 * (_QWORD)v4;
            *(_QWORD *)(v43 + 16) = *(_QWORD *)(v41 + 16);
            *(_QWORD *)(v43 + 24) = v42;
            v4 = *v22;
            v33 = (char *)*((_QWORD *)this + 172);
            if (v33 <= *v22)
              goto LABEL_170;
            v33 = (char *)*((_QWORD *)this + 175);
            if (v33 <= v4)
              goto LABEL_171;
            v44 = *((_QWORD *)this + 173) + 24 * (_QWORD)v4;
            v45 = *(_QWORD *)(v44 + 8);
            v46 = (_QWORD *)(*((_QWORD *)this + 176) + 32 * (_QWORD)v4);
            *v46 = *(_QWORD *)(v44 + 16);
            v46[1] = v45;
            *(_QWORD *)&v132 = re::solverTwoBoneIK;
            v123 = 0;
            v124 = 0;
            v47 = v115[2];
            v123 = v115[4];
            v124 = v47;
            v15 = (unint64_t)&v132 + 8;
            v133 = 0uLL;
            *((_QWORD *)&v132 + 1) = 0;
            re::FixedArray<unsigned long>::init<>((uint64_t *)&v132 + 1, (uint64_t)v120, v47);
            re::FixedArray<unsigned long>::copy((char *)&v132 + 8, (uint64_t)&v123);
            v48 = v118 + 240 * v21;
            v121 = 0;
            v122 = 0;
            v49 = *(_QWORD *)(v48 + 56);
            v121 = *(_QWORD *)(v48 + 72);
            v122 = v49;
            v135[0] = 0;
            v134 = 0uLL;
            re::FixedArray<unsigned long>::init<>((uint64_t *)&v134, (uint64_t)v120, v49);
            re::FixedArray<unsigned long>::copy(&v134, (uint64_t)&v121);
            *(_OWORD *)&v135[1] = v125;
            v50 = v126;
            v126 = 0;
            v125 = 0uLL;
            v135[3] = v50;
            v16 = v136;
            memset(v136, 0, sizeof(v136));
            v4 = &v136[16];
            re::FixedArray<re::Vector3<float>>::init<>((uint64_t *)&v136[16], (uint64_t)v120, v116);
            v137 = 0uLL;
            v33 = (char *)*((_QWORD *)this + 166);
            if ((unint64_t)v33 <= v14)
              goto LABEL_172;
            v51 = *((_QWORD *)this + 167) + 136 * v14;
            *(_QWORD *)v51 = v132;
            re::FixedArray<unsigned long>::operator=((uint64_t *)(v51 + 8), (uint64_t *)&v132 + 1);
            re::FixedArray<unsigned long>::operator=((uint64_t *)(v51 + 32), (uint64_t *)&v134);
            re::FixedArray<unsigned long>::operator=((uint64_t *)(v51 + 56), &v135[1]);
            *(_OWORD *)(v51 + 80) = *(_OWORD *)v136;
            re::FixedArray<float>::operator=((uint64_t *)(v51 + 96), (uint64_t *)&v136[16]);
            *(_OWORD *)(v51 + 120) = v137;
            if (*(_QWORD *)&v136[16])
            {
              if (*(_QWORD *)&v136[24])
              {
                (*(void (**)(void))(**(_QWORD **)&v136[16] + 40))();
                *(_QWORD *)&v136[24] = 0;
                *(_QWORD *)&v136[32] = 0;
              }
              *(_QWORD *)&v136[16] = 0;
            }
            if (v135[1])
            {
              if (v135[2])
              {
                (*(void (**)(void))(*(_QWORD *)v135[1] + 40))();
                v135[2] = 0;
                v135[3] = 0;
              }
              v135[1] = 0;
            }
            if ((_QWORD)v134)
            {
              if (*((_QWORD *)&v134 + 1))
              {
                (*(void (**)(void))(*(_QWORD *)v134 + 40))();
                *((_QWORD *)&v134 + 1) = 0;
                v135[0] = 0;
              }
              *(_QWORD *)&v134 = 0;
            }
            if (*((_QWORD *)&v132 + 1) && (_QWORD)v133)
              (*(void (**)(void))(**((_QWORD **)&v132 + 1) + 40))();
            v33 = (char *)*((_QWORD *)this + 184);
            if ((unint64_t)v33 <= v14)
              goto LABEL_173;
            v52 = *v22;
            v53 = *((_QWORD *)this + 185) + 16 * v14;
            *(_BYTE *)v53 = 1;
            *(_QWORD *)(v53 + 8) = v52;
            if ((_QWORD)v125 && *((_QWORD *)&v125 + 1))
              (*(void (**)(void))(*(_QWORD *)v125 + 40))();
            v5 = v117;
            break;
          default:
            goto LABEL_177;
        }
        ++v14;
      }
      while (v14 < v5[125]);
    }
  }
  v83 = v5[130];
  if ((_DWORD)v83)
  {
    re::HashTable<re::StringID,BOOL (*)(re::MutableSlice<re::Matrix4x4<float>>,re::Slice<unsigned int>,re::Slice<unsigned long>,re::Slice<unsigned long>,re::Slice<re::Vector3<float>>,void *),re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init((uint64_t)this + 1176, (uint64_t)v120, 4 * v83);
    v83 = v5[130];
  }
  v143[0] = 0;
  if (!v83)
  {
    v101 = 0;
    goto LABEL_139;
  }
  v84 = 0;
  v85 = (_QWORD *)((char *)this + 1176);
  while (1)
  {
    v86 = v5[132] + 56 * v84;
    v89 = *(char **)(v86 + 8);
    v88 = (char **)(v86 + 8);
    v87 = v89;
    v90 = re::RigEvaluation::HashString::operator()((int)&v132, v89);
    if (*v85)
    {
      v91 = *(unsigned int *)(*((_QWORD *)this + 148) + 4 * (v90 % *((unsigned int *)this + 300)));
      if ((_DWORD)v91 != 0x7FFFFFFF)
        break;
    }
LABEL_113:
    v94 = *v88;
    *(_QWORD *)&v132 = v94;
    v95 = re::RigEvaluation::HashString::operator()((int)v138, v94);
    v96 = v95;
    if (*v85)
    {
      v97 = v95 % *((unsigned int *)this + 300);
      v98 = *(unsigned int *)(*((_QWORD *)this + 148) + 4 * v97);
      if ((_DWORD)v98 != 0x7FFFFFFF)
      {
        v99 = *((_QWORD *)this + 149);
        do
        {
          v100 = v99 + 32 * v98;
          if (!strcmp(*(const char **)(v100 + 16), v94))
            goto LABEL_121;
          v98 = *(_DWORD *)(v100 + 8) & 0x7FFFFFFF;
        }
        while (v98 != 0x7FFFFFFF);
      }
    }
    else
    {
      LODWORD(v97) = 0;
    }
    re::HashTable<char const*,unsigned long,re::RigEvaluation::HashString,re::RigEvaluation::EqualString,true,false>::addEmplace<unsigned long &>((uint64_t)this + 1176, v97, v96, &v132, v143);
    ++*((_DWORD *)this + 304);
LABEL_121:
    v143[0] = ++v84;
    v5 = v117;
    v101 = v117[130];
    if (v84 >= v101)
    {
      *(_QWORD *)&v132 = 0;
      if (v101)
      {
        v102 = 0;
        while (1)
        {
          v103 = strrchr(*(char **)(v5[132] + 56 * v102 + 8), 47);
          if (v103)
            break;
LABEL_134:
          *(_QWORD *)&v132 = ++v102;
          if (v102 >= v101)
            goto LABEL_139;
        }
        v104 = v103 + 1;
        v143[0] = v103 + 1;
        v105 = re::RigEvaluation::HashString::operator()((int)v138, v103 + 1);
        v106 = v105;
        if (*v85)
        {
          v107 = v105 % *((unsigned int *)this + 300);
          v108 = *(unsigned int *)(*((_QWORD *)this + 148) + 4 * v107);
          if ((_DWORD)v108 != 0x7FFFFFFF)
          {
            v109 = *((_QWORD *)this + 149);
            do
            {
              v110 = v109 + 32 * v108;
              if (!strcmp(*(const char **)(v110 + 16), v104))
                goto LABEL_133;
              v108 = *(_DWORD *)(v110 + 8) & 0x7FFFFFFF;
            }
            while (v108 != 0x7FFFFFFF);
          }
        }
        else
        {
          LODWORD(v107) = 0;
        }
        re::HashTable<char const*,unsigned long,re::RigEvaluation::HashString,re::RigEvaluation::EqualString,true,false>::addEmplace<unsigned long &>((uint64_t)this + 1176, v107, v106, v143, &v132);
        ++*((_DWORD *)this + 304);
LABEL_133:
        v5 = v117;
        v101 = v117[130];
        goto LABEL_134;
      }
LABEL_139:
      re::FixedArray<re::EvaluationSRT>::init<>((_QWORD *)this + 159, (uint64_t)v120, v101);
      re::FixedArray<re::EvaluationRegisterId<int>>::init<>((_QWORD *)this + 162, (uint64_t)v120, v5[130]);
      result = (uint64_t)re::FixedArray<unsigned long>::init<unsigned long const&>((_QWORD *)this + 144, (uint64_t)v120, v5[130], &re::RigPose::kInvalidIndex);
      *(_BYTE *)v114 = 1;
      goto LABEL_140;
    }
  }
  v92 = *((_QWORD *)this + 149);
  while (1)
  {
    v93 = v92 + 32 * v91;
    if (!strcmp(*(const char **)(v93 + 16), v87))
      break;
    v91 = *(_DWORD *)(v93 + 8) & 0x7FFFFFFF;
    if (v91 == 0x7FFFFFFF)
      goto LABEL_113;
  }
  result = re::DynamicString::format(v120, (re::Allocator *)"Rig contains multiple nodes named '%s'", (re::DynamicString *)&v132, *v88);
  v112 = v132;
  v113 = v133;
  *(_BYTE *)v114 = 0;
  *(_QWORD *)(v114 + 8) = 3000;
  *(_QWORD *)(v114 + 16) = &re::AnimationErrorCategory(void)::instance;
  *(_OWORD *)(v114 + 24) = v112;
  *(_OWORD *)(v114 + 40) = v113;
LABEL_140:
  if (!v127[0])
  {
    result = v129;
    if (v129)
    {
      if ((v130 & 1) != 0)
        return (*(uint64_t (**)(void))(*(_QWORD *)v129 + 40))();
    }
  }
  return result;
}

uint64_t re::RigDefinition::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  unint64_t v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  re::RigTwoBoneIKHandles *v36;
  unint64_t v37;
  uint64_t v38;
  _QWORD *v39;
  unint64_t v40;
  uint64_t v41;
  _QWORD *v42;
  unint64_t v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  _QWORD *v53;
  unint64_t v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t v59;

  v4 = re::DynamicArray<re::RigComponentConstraint>::operator=(a1, (uint64_t *)a2);
  re::DynamicArray<re::RigComponentConstraint>::operator=(v4 + 40, (uint64_t *)(a2 + 40));
  if (a1 != a2)
  {
    v5 = *(_QWORD *)(a2 + 80);
    if (*(_QWORD *)(a1 + 80))
    {
      v6 = (_QWORD *)(a1 + 80);
      if (v5)
      {
        re::DynamicArray<re::RigBasicConstraint>::copy(v6, a2 + 80);
        ++*(_DWORD *)(a1 + 104);
      }
      else
      {
        re::DynamicArray<re::RigBasicConstraint>::clear(v6);
      }
    }
    else if (v5)
    {
      v7 = *(_QWORD *)(a2 + 96);
      *(_QWORD *)(a1 + 80) = v5;
      re::DynamicArray<re::RigBasicConstraint>::setCapacity((_QWORD *)(a1 + 80), v7);
      ++*(_DWORD *)(a1 + 104);
      re::DynamicArray<re::RigBasicConstraint>::copy((_QWORD *)(a1 + 80), a2 + 80);
    }
    v8 = *(_QWORD *)(a2 + 120);
    if (*(_QWORD *)(a1 + 120))
    {
      v9 = (_QWORD *)(a1 + 120);
      if (v8)
      {
        re::DynamicArray<re::RigAimConstraint>::copy(v9, a2 + 120);
        ++*(_DWORD *)(a1 + 144);
      }
      else
      {
        re::DynamicArray<re::RigAimConstraint>::clear(v9);
      }
    }
    else if (v8)
    {
      v10 = *(_QWORD *)(a2 + 136);
      *(_QWORD *)(a1 + 120) = v8;
      re::DynamicArray<re::RigAimConstraint>::setCapacity((_QWORD *)(a1 + 120), v10);
      ++*(_DWORD *)(a1 + 144);
      re::DynamicArray<re::RigAimConstraint>::copy((_QWORD *)(a1 + 120), a2 + 120);
    }
    v11 = *(_QWORD *)(a2 + 160);
    if (*(_QWORD *)(a1 + 160))
    {
      if (v11)
        re::DynamicArray<re::RigNodeChannel>::copy((void **)(a1 + 160), a2 + 160);
      else
        *(_QWORD *)(a1 + 176) = 0;
      ++*(_DWORD *)(a1 + 184);
    }
    else if (v11)
    {
      v12 = *(_QWORD *)(a2 + 176);
      *(_QWORD *)(a1 + 160) = v11;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity((_QWORD *)(a1 + 160), v12);
      ++*(_DWORD *)(a1 + 184);
      re::DynamicArray<re::RigNodeChannel>::copy((void **)(a1 + 160), a2 + 160);
    }
  }
  re::DynamicArray<float>::operator=(a1 + 200, (uint64_t *)(a2 + 200));
  re::DynamicArray<float>::operator=(a1 + 240, (uint64_t *)(a2 + 240));
  re::DynamicArray<float>::operator=(a1 + 280, (uint64_t *)(a2 + 280));
  if (a1 != a2)
  {
    v13 = *(_QWORD *)(a2 + 320);
    if (*(_QWORD *)(a1 + 320))
    {
      if (v13)
        re::DynamicArray<re::Matrix3x3<float>>::copy((void **)(a1 + 320), a2 + 320);
      else
        *(_QWORD *)(a1 + 336) = 0;
      ++*(_DWORD *)(a1 + 344);
    }
    else if (v13)
    {
      v14 = *(_QWORD *)(a2 + 336);
      *(_QWORD *)(a1 + 320) = v13;
      re::DynamicArray<re::Matrix3x3<float>>::setCapacity((_QWORD *)(a1 + 320), v14);
      ++*(_DWORD *)(a1 + 344);
      re::DynamicArray<re::Matrix3x3<float>>::copy((void **)(a1 + 320), a2 + 320);
    }
    v15 = *(_QWORD *)(a2 + 360);
    if (*(_QWORD *)(a1 + 360))
    {
      if (v15)
        re::DynamicArray<re::Matrix4x4<float>>::copy((void **)(a1 + 360), a2 + 360);
      else
        *(_QWORD *)(a1 + 376) = 0;
      ++*(_DWORD *)(a1 + 384);
    }
    else if (v15)
    {
      v16 = *(_QWORD *)(a2 + 376);
      *(_QWORD *)(a1 + 360) = v15;
      re::DynamicArray<re::Matrix4x4<float>>::setCapacity((_QWORD *)(a1 + 360), v16);
      ++*(_DWORD *)(a1 + 384);
      re::DynamicArray<re::Matrix4x4<float>>::copy((void **)(a1 + 360), a2 + 360);
    }
    v17 = *(_QWORD *)(a2 + 400);
    if (*(_QWORD *)(a1 + 400))
    {
      if (v17)
        re::DynamicArray<re::Quaternion<float>>::copy((void **)(a1 + 400), a2 + 400);
      else
        *(_QWORD *)(a1 + 416) = 0;
      ++*(_DWORD *)(a1 + 424);
    }
    else if (v17)
    {
      v18 = *(_QWORD *)(a2 + 416);
      *(_QWORD *)(a1 + 400) = v17;
      re::DynamicArray<re::Quaternion<float>>::setCapacity((_QWORD *)(a1 + 400), v18);
      ++*(_DWORD *)(a1 + 424);
      re::DynamicArray<re::Quaternion<float>>::copy((void **)(a1 + 400), a2 + 400);
    }
    v19 = *(_QWORD *)(a2 + 440);
    if (*(_QWORD *)(a1 + 440))
    {
      if (v19)
        re::DynamicArray<unsigned long>::copy((void **)(a1 + 440), a2 + 440);
      else
        *(_QWORD *)(a1 + 456) = 0;
      ++*(_DWORD *)(a1 + 464);
    }
    else if (v19)
    {
      v20 = *(_QWORD *)(a2 + 456);
      *(_QWORD *)(a1 + 440) = v19;
      re::DynamicArray<re::EvaluationRegisterId<int>>::setCapacity((_QWORD *)(a1 + 440), v20);
      ++*(_DWORD *)(a1 + 464);
      re::DynamicArray<unsigned long>::copy((void **)(a1 + 440), a2 + 440);
    }
  }
  re::DynamicArray<re::Vector3<float>>::operator=(a1 + 480, (uint64_t *)(a2 + 480));
  if (a1 == a2)
  {
    v22 = *(_OWORD *)(a2 + 560);
    v23 = *(_OWORD *)(a2 + 576);
    v24 = *(_OWORD *)(a2 + 608);
    *(_OWORD *)(a1 + 592) = *(_OWORD *)(a2 + 592);
    *(_OWORD *)(a1 + 608) = v24;
    *(_OWORD *)(a1 + 560) = v22;
    *(_OWORD *)(a1 + 576) = v23;
  }
  else
  {
    v21 = *(_QWORD *)(a2 + 520);
    if (*(_QWORD *)(a1 + 520))
    {
      if (v21)
        re::DynamicArray<re::RigNodeChannel>::copy((void **)(a1 + 520), a2 + 520);
      else
        *(_QWORD *)(a1 + 536) = 0;
      ++*(_DWORD *)(a1 + 544);
    }
    else if (v21)
    {
      v25 = *(_QWORD *)(a2 + 536);
      *(_QWORD *)(a1 + 520) = v21;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity((_QWORD *)(a1 + 520), v25);
      ++*(_DWORD *)(a1 + 544);
      re::DynamicArray<re::RigNodeChannel>::copy((void **)(a1 + 520), a2 + 520);
    }
    v26 = *(_OWORD *)(a2 + 560);
    v27 = *(_OWORD *)(a2 + 576);
    v28 = *(_OWORD *)(a2 + 608);
    *(_OWORD *)(a1 + 592) = *(_OWORD *)(a2 + 592);
    *(_OWORD *)(a1 + 608) = v28;
    *(_OWORD *)(a1 + 560) = v26;
    *(_OWORD *)(a1 + 576) = v27;
    v29 = *(_QWORD *)(a2 + 624);
    if (*(_QWORD *)(a1 + 624))
    {
      if (v29)
        re::DynamicArray<re::RigNodeChannel>::copy((void **)(a1 + 624), a2 + 624);
      else
        *(_QWORD *)(a1 + 640) = 0;
      ++*(_DWORD *)(a1 + 648);
    }
    else if (v29)
    {
      v30 = *(_QWORD *)(a2 + 640);
      *(_QWORD *)(a1 + 624) = v29;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity((_QWORD *)(a1 + 624), v30);
      ++*(_DWORD *)(a1 + 648);
      re::DynamicArray<re::RigNodeChannel>::copy((void **)(a1 + 624), a2 + 624);
    }
    v31 = *(_QWORD *)(a2 + 664);
    if (*(_QWORD *)(a1 + 664))
    {
      if (v31)
        re::DynamicArray<re::RigNodeChannel>::copy((void **)(a1 + 664), a2 + 664);
      else
        *(_QWORD *)(a1 + 680) = 0;
      ++*(_DWORD *)(a1 + 688);
    }
    else if (v31)
    {
      v32 = *(_QWORD *)(a2 + 680);
      *(_QWORD *)(a1 + 664) = v31;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity((_QWORD *)(a1 + 664), v32);
      ++*(_DWORD *)(a1 + 688);
      re::DynamicArray<re::RigNodeChannel>::copy((void **)(a1 + 664), a2 + 664);
    }
    v33 = *(_QWORD *)(a2 + 704);
    if (*(_QWORD *)(a1 + 704))
    {
      if (v33)
        re::DynamicArray<re::RigExpression>::copy((void **)(a1 + 704), a2 + 704);
      else
        *(_QWORD *)(a1 + 720) = 0;
      ++*(_DWORD *)(a1 + 728);
    }
    else if (v33)
    {
      v34 = *(_QWORD *)(a2 + 720);
      *(_QWORD *)(a1 + 704) = v33;
      re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity((_QWORD *)(a1 + 704), v34);
      ++*(_DWORD *)(a1 + 728);
      re::DynamicArray<re::RigExpression>::copy((void **)(a1 + 704), a2 + 704);
    }
    v35 = *(_QWORD *)(a2 + 744);
    if (*(_QWORD *)(a1 + 744))
    {
      v36 = (re::RigTwoBoneIKHandles *)(a1 + 744);
      if (v35)
      {
        re::DynamicArray<re::RigTwoBoneIKHandles>::copy(v36, a2 + 744);
        ++*(_DWORD *)(a1 + 768);
      }
      else
      {
        re::DynamicArray<re::RigTwoBoneIKHandles>::clear(v36);
      }
    }
    else if (v35)
    {
      v37 = *(_QWORD *)(a2 + 760);
      *(_QWORD *)(a1 + 744) = v35;
      re::DynamicArray<re::RigTwoBoneIKHandles>::setCapacity((_QWORD *)(a1 + 744), v37);
      ++*(_DWORD *)(a1 + 768);
      re::DynamicArray<re::RigTwoBoneIKHandles>::copy((_QWORD *)(a1 + 744), a2 + 744);
    }
    v38 = *(_QWORD *)(a2 + 784);
    if (*(_QWORD *)(a1 + 784))
    {
      v39 = (_QWORD *)(a1 + 784);
      if (v38)
      {
        re::DynamicArray<re::RigSingleChainIKHandles>::copy(v39, a2 + 784);
        ++*(_DWORD *)(a1 + 808);
      }
      else
      {
        re::DynamicArray<re::RigSingleChainIKHandles>::clear(v39);
      }
    }
    else if (v38)
    {
      v40 = *(_QWORD *)(a2 + 800);
      *(_QWORD *)(a1 + 784) = v38;
      re::DynamicArray<re::RigSingleChainIKHandles>::setCapacity((_QWORD *)(a1 + 784), v40);
      ++*(_DWORD *)(a1 + 808);
      re::DynamicArray<re::RigSingleChainIKHandles>::copy((_QWORD *)(a1 + 784), a2 + 784);
    }
    v41 = *(_QWORD *)(a2 + 824);
    if (*(_QWORD *)(a1 + 824))
    {
      v42 = (_QWORD *)(a1 + 824);
      if (v41)
      {
        re::DynamicArray<re::RigSplineIKHandle>::copy(v42, a2 + 824);
        ++*(_DWORD *)(a1 + 848);
      }
      else
      {
        re::DynamicArray<re::RigSplineIKHandle>::clear(v42);
      }
    }
    else if (v41)
    {
      v43 = *(_QWORD *)(a2 + 840);
      *(_QWORD *)(a1 + 824) = v41;
      re::DynamicArray<re::RigSplineIKHandle>::setCapacity((_QWORD *)(a1 + 824), v43);
      ++*(_DWORD *)(a1 + 848);
      re::DynamicArray<re::RigSplineIKHandle>::copy((_QWORD *)(a1 + 824), a2 + 824);
    }
    v44 = *(_QWORD *)(a2 + 864);
    if (*(_QWORD *)(a1 + 864))
    {
      if (v44)
        re::DynamicArray<re::RigTransform>::copy((void **)(a1 + 864), a2 + 864);
      else
        *(_QWORD *)(a1 + 880) = 0;
      ++*(_DWORD *)(a1 + 888);
    }
    else if (v44)
    {
      v45 = *(_QWORD *)(a2 + 880);
      *(_QWORD *)(a1 + 864) = v44;
      re::DynamicArray<re::RigTransform>::setCapacity((_QWORD *)(a1 + 864), v45);
      ++*(_DWORD *)(a1 + 888);
      re::DynamicArray<re::RigTransform>::copy((void **)(a1 + 864), a2 + 864);
    }
    v46 = *(_QWORD *)(a2 + 904);
    if (*(_QWORD *)(a1 + 904))
    {
      if (v46)
        re::DynamicArray<re::RigJoint>::copy((void **)(a1 + 904), a2 + 904);
      else
        *(_QWORD *)(a1 + 920) = 0;
      ++*(_DWORD *)(a1 + 928);
    }
    else if (v46)
    {
      v47 = *(_QWORD *)(a2 + 920);
      *(_QWORD *)(a1 + 904) = v46;
      re::DynamicArray<re::RigJoint>::setCapacity((_QWORD *)(a1 + 904), v47);
      ++*(_DWORD *)(a1 + 928);
      re::DynamicArray<re::RigJoint>::copy((void **)(a1 + 904), a2 + 904);
    }
    v48 = *(_QWORD *)(a2 + 944);
    if (*(_QWORD *)(a1 + 944))
    {
      if (v48)
        re::DynamicArray<re::RigNodeChannel>::copy((void **)(a1 + 944), a2 + 944);
      else
        *(_QWORD *)(a1 + 960) = 0;
      ++*(_DWORD *)(a1 + 968);
    }
    else if (v48)
    {
      v49 = *(_QWORD *)(a2 + 960);
      *(_QWORD *)(a1 + 944) = v48;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity((_QWORD *)(a1 + 944), v49);
      ++*(_DWORD *)(a1 + 968);
      re::DynamicArray<re::RigNodeChannel>::copy((void **)(a1 + 944), a2 + 944);
    }
    v50 = *(_QWORD *)(a2 + 984);
    if (*(_QWORD *)(a1 + 984))
    {
      if (v50)
        re::DynamicArray<re::RigNodeChannel>::copy((void **)(a1 + 984), a2 + 984);
      else
        *(_QWORD *)(a1 + 1000) = 0;
      ++*(_DWORD *)(a1 + 1008);
    }
    else if (v50)
    {
      v51 = *(_QWORD *)(a2 + 1000);
      *(_QWORD *)(a1 + 984) = v50;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity((_QWORD *)(a1 + 984), v51);
      ++*(_DWORD *)(a1 + 1008);
      re::DynamicArray<re::RigNodeChannel>::copy((void **)(a1 + 984), a2 + 984);
    }
    v52 = *(_QWORD *)(a2 + 1024);
    if (*(_QWORD *)(a1 + 1024))
    {
      v53 = (_QWORD *)(a1 + 1024);
      if (v52)
      {
        re::DynamicArray<re::RigNode>::copy(v53, a2 + 1024);
        ++*(_DWORD *)(a1 + 1048);
      }
      else
      {
        re::DynamicArray<re::RigNode>::clear((uint64_t)v53);
      }
    }
    else if (v52)
    {
      v54 = *(_QWORD *)(a2 + 1040);
      *(_QWORD *)(a1 + 1024) = v52;
      re::DynamicArray<re::RigNode>::setCapacity((_QWORD *)(a1 + 1024), v54);
      ++*(_DWORD *)(a1 + 1048);
      re::DynamicArray<re::RigNode>::copy((_QWORD *)(a1 + 1024), a2 + 1024);
    }
    v55 = *(_QWORD *)(a2 + 1064);
    if (*(_QWORD *)(a1 + 1064))
    {
      if (v55)
        re::DynamicArray<re::RigExpression>::copy((void **)(a1 + 1064), a2 + 1064);
      else
        *(_QWORD *)(a1 + 1080) = 0;
      ++*(_DWORD *)(a1 + 1088);
    }
    else if (v55)
    {
      v56 = *(_QWORD *)(a2 + 1080);
      *(_QWORD *)(a1 + 1064) = v55;
      re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity((_QWORD *)(a1 + 1064), v56);
      ++*(_DWORD *)(a1 + 1088);
      re::DynamicArray<re::RigExpression>::copy((void **)(a1 + 1064), a2 + 1064);
    }
    v57 = *(_QWORD *)(a2 + 1104);
    if (*(_QWORD *)(a1 + 1104))
    {
      v58 = a1 + 1104;
      if (v57)
      {
        re::DynamicArray<re::RigPose>::copy(v58, a2 + 1104);
        ++*(_DWORD *)(a1 + 1128);
      }
      else
      {
        re::DynamicArray<re::RigPose>::clear(v58);
      }
    }
    else if (v57)
    {
      v59 = *(_QWORD *)(a2 + 1120);
      *(_QWORD *)(a1 + 1104) = v57;
      re::DynamicArray<re::RigPose>::setCapacity((_QWORD *)(a1 + 1104), v59);
      ++*(_DWORD *)(a1 + 1128);
      re::DynamicArray<re::RigPose>::copy(a1 + 1104, a2 + 1104);
    }
  }
  return a1;
}

void re::HashTable<re::StringID,BOOL (*)(re::MutableSlice<re::Matrix4x4<float>>,re::Slice<unsigned int>,re::Slice<unsigned long>,re::Slice<unsigned long>,re::Slice<re::Vector3<float>>,void *),re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 32 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &memset_pattern_255, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

void *re::RigEvaluation::init@<X0>(uint64_t a1@<X0>, re::Allocator *a2@<X1>, const re::RigDefinition *a3@<X2>, uint64_t a4@<X8>)
{
  void *result;
  _BYTE v9[8];
  __int128 v10;
  void *v11;
  char v12;

  re::RigEvaluation::initRigDefinitionData((re::RigEvaluation *)a1, a2, a3, (uint64_t)v9);
  if (v9[0])
  {
    *(_QWORD *)a1 = a2;
    result = re::RigDefinition::operator=((_OWORD *)(a1 + 8), a3);
    *(_BYTE *)a4 = 1;
  }
  else
  {
    *(_BYTE *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v10;
    result = re::DynamicString::DynamicString((re::DynamicString *)(a4 + 24), (const re::DynamicString *)&v11);
  }
  if (!v9[0])
  {
    result = v11;
    if (v11)
    {
      if ((v12 & 1) != 0)
        return (void *)(*(uint64_t (**)(void))(*(_QWORD *)v11 + 40))();
    }
  }
  return result;
}

_OWORD *re::RigDefinition::operator=(_OWORD *a1, _OWORD *a2)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;

  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)a1, (uint64_t)a2);
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)a1 + 40, (uint64_t)a2 + 40);
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)(a1 + 5), (uint64_t)(a2 + 5));
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)a1 + 120, (uint64_t)a2 + 120);
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)(a1 + 10), (uint64_t)(a2 + 10));
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)a1 + 200, (uint64_t)a2 + 200);
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)(a1 + 15), (uint64_t)(a2 + 15));
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)a1 + 280, (uint64_t)a2 + 280);
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)(a1 + 20), (uint64_t)(a2 + 20));
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)a1 + 360, (uint64_t)a2 + 360);
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)(a1 + 25), (uint64_t)(a2 + 25));
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)a1 + 440, (uint64_t)a2 + 440);
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)(a1 + 30), (uint64_t)(a2 + 30));
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)a1 + 520, (uint64_t)a2 + 520);
  v4 = a2[38];
  v6 = a2[35];
  v5 = a2[36];
  a1[37] = a2[37];
  a1[38] = v4;
  a1[35] = v6;
  a1[36] = v5;
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)(a1 + 39), (uint64_t)(a2 + 39));
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)a1 + 664, (uint64_t)a2 + 664);
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)(a1 + 44), (uint64_t)(a2 + 44));
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)a1 + 744, (uint64_t)a2 + 744);
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)(a1 + 49), (uint64_t)(a2 + 49));
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)a1 + 824, (uint64_t)a2 + 824);
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)(a1 + 54), (uint64_t)(a2 + 54));
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)a1 + 904, (uint64_t)a2 + 904);
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)(a1 + 59), (uint64_t)(a2 + 59));
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)a1 + 984, (uint64_t)a2 + 984);
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)(a1 + 64), (uint64_t)(a2 + 64));
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)a1 + 1064, (uint64_t)a2 + 1064);
  re::DynamicArray<re::RigComponentConstraint>::operator=((uint64_t)(a1 + 69), (uint64_t)(a2 + 69));
  return a1;
}

uint64_t re::HashTable<char const*,unsigned long,re::RigEvaluation::HashString,re::RigEvaluation::EqualString,true,false>::tryGet(uint64_t a1, char **a2)
{
  size_t v4;
  uint64_t v5;
  uint64_t v6;
  const char *v7;
  uint64_t v8;
  char v10;

  v4 = re::RigEvaluation::HashString::operator()((int)&v10, *a2);
  if (!*(_QWORD *)a1)
    return 0;
  v5 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * (v4 % *(unsigned int *)(a1 + 24)));
  if ((_DWORD)v5 == 0x7FFFFFFF)
    return 0;
  v6 = *(_QWORD *)(a1 + 16);
  v7 = *a2;
  while (1)
  {
    v8 = v6 + 32 * v5;
    if (!strcmp(*(const char **)(v8 + 16), v7))
      break;
    v5 = *(_DWORD *)(v8 + 8) & 0x7FFFFFFF;
    if (v5 == 0x7FFFFFFF)
      return 0;
  }
  return v8 + 24;
}

uint64_t re::RigDefinition::deinit(re::RigDefinition *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this);
  re::DynamicArray<re::RigComponentConstraint>::deinit((uint64_t)this + 40);
  re::DynamicArray<re::RigBasicConstraint>::deinit((uint64_t)this + 80);
  re::DynamicArray<re::RigAimConstraint>::deinit((uint64_t)this + 120);
  v2 = *((_QWORD *)this + 20);
  if (v2)
  {
    if (*((_QWORD *)this + 24))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *((_QWORD *)this + 24) = 0;
    *((_QWORD *)this + 21) = 0;
    *((_QWORD *)this + 22) = 0;
    *((_QWORD *)this + 20) = 0;
    ++*((_DWORD *)this + 46);
  }
  re::DynamicRegisterIdTable::deinit((re::RigDefinition *)((char *)this + 200));
  v3 = *((_QWORD *)this + 65);
  if (v3)
  {
    if (*((_QWORD *)this + 69))
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
    *((_QWORD *)this + 69) = 0;
    *((_QWORD *)this + 66) = 0;
    *((_QWORD *)this + 67) = 0;
    *((_QWORD *)this + 65) = 0;
    ++*((_DWORD *)this + 136);
  }
  *((_OWORD *)this + 37) = 0u;
  *((_OWORD *)this + 38) = 0u;
  *((_OWORD *)this + 35) = 0u;
  *((_OWORD *)this + 36) = 0u;
  v4 = *((_QWORD *)this + 78);
  if (v4)
  {
    if (*((_QWORD *)this + 82))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *((_QWORD *)this + 82) = 0;
    *((_QWORD *)this + 79) = 0;
    *((_QWORD *)this + 80) = 0;
    *((_QWORD *)this + 78) = 0;
    ++*((_DWORD *)this + 162);
  }
  v5 = *((_QWORD *)this + 83);
  if (v5)
  {
    if (*((_QWORD *)this + 87))
      (*(void (**)(uint64_t))(*(_QWORD *)v5 + 40))(v5);
    *((_QWORD *)this + 87) = 0;
    *((_QWORD *)this + 84) = 0;
    *((_QWORD *)this + 85) = 0;
    *((_QWORD *)this + 83) = 0;
    ++*((_DWORD *)this + 172);
  }
  v6 = *((_QWORD *)this + 88);
  if (v6)
  {
    if (*((_QWORD *)this + 92))
      (*(void (**)(uint64_t))(*(_QWORD *)v6 + 40))(v6);
    *((_QWORD *)this + 92) = 0;
    *((_QWORD *)this + 89) = 0;
    *((_QWORD *)this + 90) = 0;
    *((_QWORD *)this + 88) = 0;
    ++*((_DWORD *)this + 182);
  }
  re::DynamicArray<re::RigTwoBoneIKHandles>::deinit((uint64_t)this + 744);
  re::DynamicArray<re::RigSingleChainIKHandles>::deinit((uint64_t)this + 784);
  v7 = *((_QWORD *)this + 108);
  if (v7)
  {
    if (*((_QWORD *)this + 112))
      (*(void (**)(uint64_t))(*(_QWORD *)v7 + 40))(v7);
    *((_QWORD *)this + 112) = 0;
    *((_QWORD *)this + 109) = 0;
    *((_QWORD *)this + 110) = 0;
    *((_QWORD *)this + 108) = 0;
    ++*((_DWORD *)this + 222);
  }
  v8 = *((_QWORD *)this + 113);
  if (v8)
  {
    if (*((_QWORD *)this + 117))
      (*(void (**)(uint64_t))(*(_QWORD *)v8 + 40))(v8);
    *((_QWORD *)this + 117) = 0;
    *((_QWORD *)this + 114) = 0;
    *((_QWORD *)this + 115) = 0;
    *((_QWORD *)this + 113) = 0;
    ++*((_DWORD *)this + 232);
  }
  v9 = *((_QWORD *)this + 118);
  if (v9)
  {
    if (*((_QWORD *)this + 122))
      (*(void (**)(uint64_t))(*(_QWORD *)v9 + 40))(v9);
    *((_QWORD *)this + 122) = 0;
    *((_QWORD *)this + 119) = 0;
    *((_QWORD *)this + 120) = 0;
    *((_QWORD *)this + 118) = 0;
    ++*((_DWORD *)this + 242);
  }
  v10 = *((_QWORD *)this + 123);
  if (v10)
  {
    if (*((_QWORD *)this + 127))
      (*(void (**)(uint64_t))(*(_QWORD *)v10 + 40))(v10);
    *((_QWORD *)this + 127) = 0;
    *((_QWORD *)this + 124) = 0;
    *((_QWORD *)this + 125) = 0;
    *((_QWORD *)this + 123) = 0;
    ++*((_DWORD *)this + 252);
  }
  re::DynamicArray<re::RigNode>::deinit((uint64_t)this + 1024);
  v11 = *((_QWORD *)this + 133);
  if (v11)
  {
    if (*((_QWORD *)this + 137))
      (*(void (**)(uint64_t))(*(_QWORD *)v11 + 40))(v11);
    *((_QWORD *)this + 137) = 0;
    *((_QWORD *)this + 134) = 0;
    *((_QWORD *)this + 135) = 0;
    *((_QWORD *)this + 133) = 0;
    ++*((_DWORD *)this + 272);
  }
  return re::DynamicArray<re::RigPose>::deinit((uint64_t)this + 1104);
}

_QWORD *re::FixedArray<re::internal::RigIKCall>::deinit(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  if (*result)
  {
    v1 = result;
    v3 = result + 1;
    v2 = result[1];
    if (v2)
    {
      v4 = 136 * v2;
      v5 = (_QWORD *)(result[2] + 56);
      do
      {
        v6 = v5[5];
        if (v6)
        {
          if (v5[6])
          {
            (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v6 + 40))(v6, v5[7]);
            v5[6] = 0;
            v5[7] = 0;
          }
          v5[5] = 0;
        }
        if (*v5)
        {
          if (v5[1])
          {
            (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*v5 + 40))(*v5, v5[2]);
            v5[1] = 0;
            v5[2] = 0;
          }
          *v5 = 0;
        }
        v7 = *(v5 - 3);
        if (v7)
        {
          if (*(v5 - 2))
          {
            (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v7 + 40))(v7, *(v5 - 1));
            *(v5 - 2) = 0;
            *(v5 - 1) = 0;
          }
          *(v5 - 3) = 0;
        }
        v8 = *(v5 - 6);
        if (v8)
        {
          if (*(v5 - 5))
          {
            (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v8 + 40))(v8, *(v5 - 4));
            *(v5 - 5) = 0;
            *(v5 - 4) = 0;
          }
          *(v5 - 6) = 0;
        }
        v5 += 17;
        v4 -= 136;
      }
      while (v4);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v1 + 40))(*v1, v1[2]);
      *v3 = 0;
      v3[1] = 0;
    }
    *v1 = 0;
  }
  return result;
}

uint64_t re::DynamicArray<re::internal::RigIKCall>::deinit(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 136 * v4;
        v6 = (_QWORD *)(v3 + 56);
        do
        {
          v7 = v6[5];
          if (v7)
          {
            if (v6[6])
            {
              (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v7 + 40))(v7, v6[7]);
              v6[6] = 0;
              v6[7] = 0;
            }
            v6[5] = 0;
          }
          if (*v6)
          {
            if (v6[1])
            {
              (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*v6 + 40))(*v6, v6[2]);
              v6[1] = 0;
              v6[2] = 0;
            }
            *v6 = 0;
          }
          v8 = *(v6 - 3);
          if (v8)
          {
            if (*(v6 - 2))
            {
              (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v8 + 40))(v8, *(v6 - 1));
              *(v6 - 2) = 0;
              *(v6 - 1) = 0;
            }
            *(v6 - 3) = 0;
          }
          v9 = *(v6 - 6);
          if (v9)
          {
            if (*(v6 - 5))
            {
              (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v9 + 40))(v9, *(v6 - 4));
              *(v6 - 5) = 0;
              *(v6 - 4) = 0;
            }
            *(v6 - 6) = 0;
          }
          v6 += 17;
          v5 -= 136;
        }
        while (v5);
        result = *(_QWORD *)a1;
        v3 = *(_QWORD *)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

_QWORD *re::RigEvaluation::reset(re::RigEvaluation *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *((_QWORD *)this + 160);
  if (v2 >= 1)
    memset(*((void **)this + 161), 255, 24 * (24 * v2 / 0x18uLL - ((unint64_t)(24 * v2) > 0x17)) + 24);
  v3 = *((_QWORD *)this + 163);
  if (v3 >= 1)
    memset(*((void **)this + 164), 255, 8 * (v3 - ((v3 & 0x1FFFFFFFFFFFFFFFLL) != 0)) + 8);
  v4 = *((_QWORD *)this + 145);
  if (v4 >= 1)
    memset(*((void **)this + 146), 255, 8 * (v4 - ((v4 & 0x1FFFFFFFFFFFFFFFLL) != 0)) + 8);
  return re::DynamicArray<re::internal::RigIKCall>::clear((_QWORD *)this + 186);
}

_QWORD *re::DynamicArray<re::internal::RigIKCall>::clear(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;

  v1 = result;
  v2 = result[2];
  result[2] = 0;
  if (v2)
  {
    v3 = 136 * v2;
    v4 = (_QWORD *)(result[4] + 56);
    do
    {
      v5 = v4[5];
      if (v5)
      {
        if (v4[6])
        {
          (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v5 + 40))(v5, v4[7]);
          v4[6] = 0;
          v4[7] = 0;
        }
        v4[5] = 0;
      }
      if (*v4)
      {
        if (v4[1])
        {
          (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*v4 + 40))(*v4, v4[2]);
          v4[1] = 0;
          v4[2] = 0;
        }
        *v4 = 0;
      }
      v6 = *(v4 - 3);
      if (v6)
      {
        if (*(v4 - 2))
        {
          (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v6 + 40))(v6, *(v4 - 1));
          *(v4 - 2) = 0;
          *(v4 - 1) = 0;
        }
        *(v4 - 3) = 0;
      }
      result = (_QWORD *)*(v4 - 6);
      if (result)
      {
        if (*(v4 - 5))
        {
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, _QWORD))(*result + 40))(result, *(v4 - 4));
          *(v4 - 5) = 0;
          *(v4 - 4) = 0;
        }
        *(v4 - 6) = 0;
      }
      v4 += 17;
      v3 -= 136;
    }
    while (v3);
  }
  ++*((_DWORD *)v1 + 6);
  return result;
}

BOOL re::RigEvaluation::bindLocalSpaceJointInput(uint64_t a1, char *a2, __int128 *a3)
{
  unint64_t *v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  __int128 v9;
  char *v11[2];
  int v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  unint64_t v17;
  __int16 v18;
  unint64_t v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  v11[0] = a2;
  v5 = (unint64_t *)re::HashTable<char const*,unsigned long,re::RigEvaluation::HashString,re::RigEvaluation::EqualString,true,false>::tryGet(a1 + 1176, v11);
  if (v5)
  {
    v6 = *v5;
    v7 = *(_QWORD *)(a1 + 1280);
    if (v7 <= *v5)
    {
      v11[1] = 0;
      v23 = 0u;
      v24 = 0u;
      v21 = 0u;
      v22 = 0u;
      v20 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v12 = 136315906;
      v13 = "operator[]";
      v14 = 1024;
      v15 = 468;
      v16 = 2048;
      v17 = v6;
      v18 = 2048;
      v19 = v7;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    v8 = *(_QWORD *)(a1 + 1288) + 24 * v6;
    v9 = *a3;
    *(_QWORD *)(v8 + 16) = *((_QWORD *)a3 + 2);
    *(_OWORD *)v8 = v9;
  }
  return v5 != 0;
}

BOOL re::RigEvaluation::bindModelSpaceJointInput(uint64_t a1, char *a2, uint64_t a3)
{
  unint64_t *v5;
  unint64_t v6;
  unint64_t v7;
  char *v9[2];
  int v10;
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  unint64_t v15;
  __int16 v16;
  unint64_t v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  v9[0] = a2;
  v5 = (unint64_t *)re::HashTable<char const*,unsigned long,re::RigEvaluation::HashString,re::RigEvaluation::EqualString,true,false>::tryGet(a1 + 1176, v9);
  if (v5)
  {
    v6 = *v5;
    v7 = *(_QWORD *)(a1 + 1304);
    if (v7 <= *v5)
    {
      v9[1] = 0;
      v21 = 0u;
      v22 = 0u;
      v19 = 0u;
      v20 = 0u;
      v18 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v10 = 136315906;
      v11 = "operator[]";
      v12 = 1024;
      v13 = 468;
      v14 = 2048;
      v15 = v6;
      v16 = 2048;
      v17 = v7;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    *(_QWORD *)(*(_QWORD *)(a1 + 1312) + 8 * v6) = a3;
  }
  return v5 != 0;
}

BOOL re::RigEvaluation::setDefaultPose(re::RigEvaluation *this, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t *v8;
  uint64_t v9;
  unint64_t v10;
  _QWORD *v11;
  unint64_t v12;
  unint64_t v13;

  v4 = *((_QWORD *)this + 146);
  v5 = *((_QWORD *)this + 145);
  if (v5 >= 1)
    memset(*((void **)this + 146), 255, 8 * (v5 - ((v5 & 0x1FFFFFFFFFFFFFFFLL) != 0)) + 8);
  v6 = *((_QWORD *)this + 141);
  if (v6 > a2)
  {
    v7 = *((_QWORD *)this + 143) + 32 * a2;
    v9 = *(_QWORD *)(v7 + 16);
    v8 = (unint64_t *)(v7 + 16);
    if (v9)
    {
      v10 = 0;
      v11 = (_QWORD *)(*((_QWORD *)this + 143) + 32 * a2 + 24);
      do
      {
        v12 = v10 + *v11;
        if (*((_QWORD *)this + 136) <= v12)
        {
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_11:
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        v13 = *(_QWORD *)(*((_QWORD *)this + 138) + 24 * v12 + 16);
        if (*((_QWORD *)this + 145) <= v13)
          goto LABEL_11;
        *(_QWORD *)(v4 + 8 * v13) = v12;
        ++v10;
      }
      while (v10 < *v8);
    }
  }
  return v6 > a2;
}

void re::RigEvaluation::constructEvaluationCommands(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD v15[2];
  char v16;
  uint64_t v17;
  int v18;
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  uint64_t v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  uint64_t v31;

  v31 = *MEMORY[0x24BDAC8D0];
  v16 = 0;
  v15[0] = &off_24ED42648;
  v15[1] = "Scratch Pad";
  v12 = 0;
  v13 = 0;
  v14 = 0;
  re::FixedArray<char const*>::init<>(&v12, (uint64_t)v15, a3);
  if (a3)
  {
    v8 = 0;
    v9 = v13;
    v10 = (uint64_t *)(a2 + 8);
    do
    {
      if (v9 == v8)
      {
        v17 = 0;
        v29 = 0u;
        v30 = 0u;
        v28 = 0u;
        v26 = 0u;
        v27 = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        v18 = 136315906;
        v19 = "operator[]";
        v20 = 1024;
        v21 = 468;
        v22 = 2048;
        v23 = v9;
        v24 = 2048;
        v25 = v9;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      v11 = *v10;
      v10 += 2;
      *(_QWORD *)(v14 + 8 * v8++) = v11;
    }
    while (a3 != v8);
  }
  else
  {
    v9 = v13;
  }
  ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t))re::RigEvaluation::constructEvaluationCommands)(a1, v14, v9, a4);
  if (v12 && v13)
    (*(void (**)(void))(*(_QWORD *)v12 + 40))();
  re::Allocator::~Allocator((re::Allocator *)v15);
}

void re::FixedArray<re::internal::RigIKCall>::init<>(uint64_t *a1, uint64_t a2, unint64_t a3)
{
  uint64_t v5;
  char *v6;
  uint64_t v7;
  char *v8;

  *a1 = a2;
  a1[1] = a3;
  if (!a3)
    return;
  if (a3 >= 0x1E1E1E1E1E1E1E2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 136, a3);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  v5 = 136 * a3;
  v6 = (char *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 136 * a3, 8);
  a1[2] = (uint64_t)v6;
  if (!v6)
  {
LABEL_9:
    re::internal::assertLog((re::internal *)4, v7, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    _os_crash();
    __break(1u);
    return;
  }
  v8 = v6;
  if (a3 != 1)
  {
    bzero(v6, v5 - 136);
    v8 += v5 - 136;
  }
  *((_QWORD *)v8 + 16) = 0;
  *((_OWORD *)v8 + 6) = 0u;
  *((_OWORD *)v8 + 7) = 0u;
  *((_OWORD *)v8 + 4) = 0u;
  *((_OWORD *)v8 + 5) = 0u;
  *((_OWORD *)v8 + 2) = 0u;
  *((_OWORD *)v8 + 3) = 0u;
  *(_OWORD *)v8 = 0u;
  *((_OWORD *)v8 + 1) = 0u;
}

uint64_t *re::`anonymous namespace'::rigIKCallbackFunction(re::_anonymous_namespace_ *this, re::EvaluationContext *a2, void *a3)
{
  uint64_t *result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  unint64_t *v14;
  _QWORD *v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  _QWORD *v22;
  _QWORD *v23;
  unint64_t *v24;
  _QWORD *v25;
  unint64_t v26;
  _QWORD *v27;

  result = re::FixedArray<re::Matrix4x4<float>>::operator=((uint64_t *)this + 39, (uint64_t)this + 96);
  if (*((_QWORD *)a2 + 1))
  {
    v6 = 0;
    while (1)
    {
      v7 = *((_QWORD *)a2 + 2);
      v8 = v7 + 136 * v6;
      v9 = *(_QWORD *)(v8 + 80);
      if (v9)
        break;
      v17 = v7 + 136 * v6;
      v20 = *(_QWORD *)(v17 + 64);
      v18 = (unint64_t *)(v17 + 64);
      v19 = v20;
      if (v20)
      {
        v21 = 0;
        v22 = (_QWORD *)(v7 + 136 * v6);
        v23 = v22 + 9;
        v24 = v22 + 13;
        v25 = v22 + 14;
        while (*v18 > v21)
        {
          v26 = *(_QWORD *)(*v23 + 8 * v21);
          if (*((_QWORD *)this + 40) <= v26)
            goto LABEL_20;
          if (*v24 <= v21)
            goto LABEL_21;
          *(_OWORD *)(*v25 + 16 * v21++) = *(_OWORD *)(*((_QWORD *)this + 41) + (v26 << 6) + 48);
          if (v19 == v21)
            goto LABEL_15;
        }
LABEL_19:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_20:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_21:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
LABEL_15:
      v27 = (_QWORD *)(v7 + 136 * v6);
      result = (uint64_t *)(*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))v8)(*((_QWORD *)this + 41), *((_QWORD *)this + 40), *((_QWORD *)a2 + 5), *((_QWORD *)a2 + 4), v27[3], v27[2], v27[6], v27[5], v27[14], v27[13], v27[15]);
      if ((unint64_t)++v6 >= *((_QWORD *)a2 + 1))
        return result;
    }
    v10 = 0;
    v11 = 0;
    v12 = (_QWORD *)(v7 + 136 * v6);
    v13 = v12 + 11;
    v14 = v12 + 13;
    v15 = v12 + 14;
    while (1)
    {
      v16 = v11 + *v13;
      if (*((_QWORD *)this + 22) <= v16)
        break;
      if (*v14 <= v11)
        goto LABEL_18;
      *(_OWORD *)(*v15 + v10) = *(_OWORD *)(*((_QWORD *)this + 23) + 16 * v16);
      ++v11;
      v10 += 16;
      if (v9 == v11)
        goto LABEL_15;
    }
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_18:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_19;
  }
  return result;
}

uint64_t re::`anonymous namespace'::calculateWeightedConstraint<re::EvaluationRegisterId<re::Vector3<float>>>(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t (*a6)(_QWORD *, _QWORD, uint64_t, uint64_t, uint64_t), uint64_t a7)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v10;
  uint64_t v13;
  float v14;
  uint64_t v16;
  float v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  float v22;
  uint64_t v23;
  __int128 *v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  float v28;
  uint64_t v29;
  float v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _QWORD *v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t v38;
  _QWORD *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  _anonymous_namespace_ *v44;
  uint64_t v47;
  float v48;
  uint64_t v49;
  _BYTE v50[18];
  __int16 v51;
  uint64_t v52;
  __int16 v53;
  uint64_t v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  uint64_t v60;

  v7 = a7;
  v8 = a5;
  v10 = a3;
  v60 = *MEMORY[0x24BDAC8D0];
  v13 = *(_QWORD *)(a4 + 16);
  if (v13 != 2)
  {
    if (v13 == 1)
    {
      if (!*(_QWORD *)(a5 + 16))
        return a6(a1, **(_QWORD **)(a4 + 32), a2, a3, a7);
      v14 = **(float **)(a5 + 32);
      if (v14 == 1.0 || vabds_f32(1.0, v14) < (float)((float)((float)(fabsf(v14) + 1.0) + 1.0) * 0.00001))
        return a6(a1, **(_QWORD **)(a4 + 32), a2, a3, a7);
    }
LABEL_14:
    *(_QWORD *)v50 = 0;
    *(_QWORD *)&v50[8] = 0;
    LODWORD(v55) = 7;
    v56 = 0uLL;
    *((_QWORD *)&v55 + 1) = 0;
    v44 = (_anonymous_namespace_ *)(a1 + 243);
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(a1 + 243), (uint64_t)&v55);
    *(_QWORD *)&v55 = a1[245] - 1;
    v23 = a4;
    v24 = &v55;
    re::DynamicArray<unsigned long>::add(a1 + 36, &v55);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(a1 + 76), (__n128 *)v50);
    v25 = *(_QWORD *)(a1[40] + 8 * a1[38] - 8);
    v26 = *(_QWORD *)(v23 + 16);
    if (v26)
    {
      v42 = *(_QWORD *)(a1[40] + 8 * a1[38] - 8);
      v43 = a2;
      v27 = 0;
      v41 = *(_QWORD *)(v23 + 16);
      v40 = (uint64_t)(a1 + 208);
      v28 = 1.0 / (float)v26;
      while (1)
      {
        v19 = *(_QWORD *)(v23 + 16);
        if (v19 <= v27)
          break;
        v29 = a6(a1, *(_QWORD *)(*(_QWORD *)(v23 + 32) + 8 * v27), v43, v10, v7);
        v48 = 0.0;
        v24 = *(__int128 **)(v8 + 16);
        v30 = v28;
        if (v24)
        {
          if ((unint64_t)v24 <= v27)
            goto LABEL_27;
          v30 = *(float *)(*(_QWORD *)(v8 + 32) + 4 * v27);
        }
        v48 = v30;
        LODWORD(v55) = 2;
        v56 = 0uLL;
        *((_QWORD *)&v55 + 1) = 0;
        v47 = v29;
        re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(a1 + 218), (uint64_t)&v55);
        *(_QWORD *)&v55 = a1[220] - 1;
        re::DynamicArray<unsigned long>::add(a1 + 11, &v55);
        re::DynamicArray<float>::add((_anonymous_namespace_ *)(a1 + 51), &v48);
        v31 = v8;
        v32 = v10;
        v33 = v7;
        v34 = *(_QWORD *)(a1[15] + 8 * a1[13] - 8);
        LODWORD(v55) = 11;
        v56 = 0uLL;
        *((_QWORD *)&v55 + 1) = 0;
        re::DynamicArray<re::EvaluationRegister>::add(v44, (uint64_t)&v55);
        v24 = (__int128 *)(a1[245] - 1);
        v35 = (_QWORD *)re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v40, (unint64_t)v24);
        v35[1] = v42;
        v35[2] = v47;
        v35[3] = v34;
        v7 = v33;
        v10 = v32;
        v8 = v31;
        LODWORD(v55) = 8;
        v56 = 0uLL;
        *((_QWORD *)&v55 + 1) = 0;
        re::DynamicArray<re::EvaluationRegister>::add(v44, (uint64_t)&v55);
        v36 = a1[245] - 1;
        v37 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v40, v36);
        *(_QWORD *)(v37 + 8) = v25;
        *(_QWORD *)(v37 + 16) = v24;
        ++v27;
        v25 = v36;
        if (v41 == v27)
          return v36;
      }
      v49 = 0;
      v58 = 0u;
      v59 = 0u;
      v56 = 0u;
      v57 = 0u;
      v55 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v50 = 136315906;
      *(_QWORD *)&v50[4] = "operator[]";
      *(_WORD *)&v50[12] = 1024;
      *(_DWORD *)&v50[14] = 797;
      v51 = 2048;
      v52 = v27;
      v53 = 2048;
      v54 = v19;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_27:
      v49 = 0;
      v58 = 0u;
      v59 = 0u;
      v56 = 0u;
      v57 = 0u;
      v55 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v50 = 136315906;
      *(_QWORD *)&v50[4] = "operator[]";
      *(_WORD *)&v50[12] = 1024;
      *(_DWORD *)&v50[14] = 797;
      v51 = 2048;
      v52 = v27;
      v53 = 2048;
      v54 = (uint64_t)v24;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_28;
    }
    return *(_QWORD *)(a1[40] + 8 * a1[38] - 8);
  }
  v16 = *(_QWORD *)(a5 + 16);
  if (v16)
  {
    if (v16 == 1)
      goto LABEL_29;
    v17 = **(float **)(a5 + 32) + *(float *)(*(_QWORD *)(a5 + 32) + 4);
    if (v17 != 1.0 && vabds_f32(1.0, v17) >= (float)((float)((float)(fabsf(v17) + 1.0) + 1.0) * 0.00001))
      goto LABEL_14;
  }
  v18 = a6(a1, **(_QWORD **)(a4 + 32), a2, a3, a7);
  v19 = *(_QWORD *)(a4 + 16);
  if (v19 <= 1)
  {
LABEL_28:
    v49 = 0;
    v58 = 0u;
    v59 = 0u;
    v56 = 0u;
    v57 = 0u;
    v55 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v50 = 136315906;
    *(_QWORD *)&v50[4] = "operator[]";
    *(_WORD *)&v50[12] = 1024;
    *(_DWORD *)&v50[14] = 797;
    v51 = 2048;
    v52 = 1;
    v53 = 2048;
    v54 = v19;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_29:
    v49 = 0;
    v58 = 0u;
    v59 = 0u;
    v56 = 0u;
    v57 = 0u;
    v55 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v50 = 136315906;
    *(_QWORD *)&v50[4] = "operator[]";
    *(_WORD *)&v50[12] = 1024;
    *(_DWORD *)&v50[14] = 797;
    v51 = 2048;
    v52 = 1;
    v53 = 2048;
    v54 = 1;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  v20 = v18;
  v21 = a6(a1, *(_QWORD *)(*(_QWORD *)(a4 + 32) + 8), a2, v10, v7);
  if (*(_QWORD *)(v8 + 16))
    v22 = **(float **)(v8 + 32);
  else
    v22 = 0.5;
  *(float *)v50 = v22;
  LODWORD(v55) = 2;
  v56 = 0uLL;
  *((_QWORD *)&v55 + 1) = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(a1 + 218), (uint64_t)&v55);
  *(_QWORD *)&v55 = a1[220] - 1;
  re::DynamicArray<unsigned long>::add(a1 + 11, &v55);
  re::DynamicArray<float>::add((_anonymous_namespace_ *)(a1 + 51), (float *)v50);
  v38 = *(_QWORD *)(a1[15] + 8 * a1[13] - 8);
  LODWORD(v55) = 11;
  v56 = 0uLL;
  *((_QWORD *)&v55 + 1) = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(a1 + 243), (uint64_t)&v55);
  v36 = a1[245] - 1;
  v39 = (_QWORD *)re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>((uint64_t)(a1 + 208), v36);
  v39[1] = v20;
  v39[2] = v21;
  v39[3] = v38;
  return v36;
}

unint64_t re::`anonymous namespace'::calculatePointConstraint(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  _anonymous_namespace_ *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  if (*(_QWORD *)(a3 + 8) <= a2)
  {
    v19 = 0u;
    v20 = 0u;
    v17 = 0u;
    v18 = 0u;
    v16 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_5:
    v19 = 0u;
    v20 = 0u;
    v17 = 0u;
    v18 = 0u;
    v16 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  v7 = *(_QWORD *)(*(_QWORD *)(a3 + 16) + 8 * a2);
  v8 = a1 + 1664;
  v9 = (_anonymous_namespace_ *)(a1 + 1944);
  LODWORD(v16) = 37;
  v17 = 0uLL;
  *((_QWORD *)&v16 + 1) = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(a1 + 1944), (uint64_t)&v16);
  v10 = *(_QWORD *)(a1 + 1960) - 1;
  *(_QWORD *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v8, v10) + 8) = v7;
  if (*(_QWORD *)(a4 + 8) <= a2)
    goto LABEL_5;
  v11 = *(_QWORD *)(*(_QWORD *)(a4 + 16) + 8 * a2);
  LODWORD(v16) = 37;
  v17 = 0uLL;
  *((_QWORD *)&v16 + 1) = 0;
  re::DynamicArray<re::EvaluationRegister>::add(v9, (uint64_t)&v16);
  v12 = *(_QWORD *)(a1 + 1960) - 1;
  *(_QWORD *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v8, v12) + 8) = v11;
  LODWORD(v16) = 31;
  v17 = 0uLL;
  *((_QWORD *)&v16 + 1) = 0;
  re::DynamicArray<re::EvaluationRegister>::add(v9, (uint64_t)&v16);
  v13 = *(_QWORD *)(a1 + 1960) - 1;
  v14 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v8, v13);
  *(_QWORD *)(v14 + 8) = v12;
  *(_QWORD *)(v14 + 16) = v10;
  return v13;
}

unint64_t re::`anonymous namespace'::extractConstrainedComponents(_QWORD *a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4, __n128 a5)
{
  int32x2_t v8;
  float v14;
  _QWORD *v15;
  _anonymous_namespace_ *v16;
  uint64_t v17;
  _anonymous_namespace_ *v18;
  uint64_t v19;
  unint64_t v20;
  _QWORD *v21;
  __n128 v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  v8.i32[0] = *a2;
  v8.i32[1] = a2[1];
  __asm { FMOV            V1.2S, #1.0 }
  a5.n128_u64[0] = (unint64_t)vbic_s8(_D1, (int8x8_t)vceqz_s32(v8));
  v14 = 1.0;
  if (!a2[2])
    v14 = 0.0;
  a5.n128_f32[2] = v14;
  v23 = a5;
  LODWORD(v24) = 7;
  v26 = 0;
  v27 = 0;
  v15 = a1 + 36;
  v16 = (_anonymous_namespace_ *)(a1 + 76);
  v17 = (uint64_t)(a1 + 208);
  v18 = (_anonymous_namespace_ *)(a1 + 243);
  v25 = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(a1 + 243), (uint64_t)&v24);
  v24 = a1[245] - 1;
  re::DynamicArray<unsigned long>::add(v15, &v24);
  re::DynamicArray<re::Vector3<float>>::add(v16, &v23);
  v19 = *(_QWORD *)(a1[40] + 8 * a1[38] - 8);
  LODWORD(v24) = 10;
  v26 = 0;
  v27 = 0;
  v25 = 0;
  re::DynamicArray<re::EvaluationRegister>::add(v18, (uint64_t)&v24);
  v20 = a1[245] - 1;
  v21 = (_QWORD *)re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v17, v20);
  v21[1] = a3;
  v21[2] = a4;
  v21[3] = v19;
  return v20;
}

unint64_t re::`anonymous namespace'::calculateOrientConstraint(_QWORD *a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t Rotation;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  if (a3 <= a2)
  {
    v18 = 0u;
    v19 = 0u;
    v16 = 0u;
    v17 = 0u;
    v15 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_5:
    v18 = 0u;
    v19 = 0u;
    v16 = 0u;
    v17 = 0u;
    v15 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  Rotation = re::EvaluationTree::extractRotation(a1, *(_QWORD *)(a4 + 8 * a2));
  if (*(_QWORD *)(a5 + 8) <= a2)
    goto LABEL_5;
  v9 = Rotation;
  v10 = re::EvaluationTree::extractRotation(a1, *(_QWORD *)(*(_QWORD *)(a5 + 16) + 8 * a2));
  LODWORD(v15) = 21;
  v16 = 0uLL;
  *((_QWORD *)&v15 + 1) = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(a1 + 233), (uint64_t)&v15);
  v11 = a1[235] - 1;
  *(_QWORD *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Quaternion<float>>((uint64_t)(a1 + 208), v11) + 8) = v9;
  LODWORD(v15) = 24;
  v16 = 0uLL;
  *((_QWORD *)&v15 + 1) = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(a1 + 233), (uint64_t)&v15);
  v12 = a1[235] - 1;
  v13 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Quaternion<float>>((uint64_t)(a1 + 208), v12);
  *(_QWORD *)(v13 + 8) = v10;
  *(_QWORD *)(v13 + 16) = v11;
  return v12;
}

uint64_t re::`anonymous namespace'::rigNodeRotationOrder(_QWORD *a1, char a2, unint64_t a3)
{
  unsigned __int8 *v3;

  if (a2 != 1)
  {
    if (a1[115] > a3)
    {
      v3 = (unsigned __int8 *)(a1[117] + 96 * a3 + 80);
      return *v3;
    }
LABEL_8:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (a1[110] <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_8;
  }
  v3 = (unsigned __int8 *)(a1[112] + (a3 << 6) + 48);
  return *v3;
}

uint64_t re::`anonymous namespace'::calculateParentConstraintSRT(unint64_t *a1, _QWORD *a2, unint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6, uint64_t a7)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _anonymous_namespace_ *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t result;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  if (a4 <= a3)
  {
    v21 = 0u;
    v22 = 0u;
    v19 = 0u;
    v20 = 0u;
    v18 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_5:
    v21 = 0u;
    v22 = 0u;
    v19 = 0u;
    v20 = 0u;
    v18 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (a6 <= a3)
    goto LABEL_5;
  v9 = *(_QWORD *)(a5 + 8 * a3);
  v10 = *(_QWORD *)(a7 + 8 * a3);
  v11 = (uint64_t)(a2 + 208);
  v12 = (_anonymous_namespace_ *)(a2 + 228);
  LODWORD(v18) = 20;
  v19 = 0uLL;
  *((_QWORD *)&v18 + 1) = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(a2 + 228), (uint64_t)&v18);
  v13 = a2[230] - 1;
  *(_QWORD *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix4x4<float>>(v11, v13) + 8) = v9;
  LODWORD(v18) = 28;
  v19 = 0uLL;
  *((_QWORD *)&v18 + 1) = 0;
  re::DynamicArray<re::EvaluationRegister>::add(v12, (uint64_t)&v18);
  v14 = a2[230] - 1;
  v15 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Matrix4x4<float>>(v11, v14);
  *(_QWORD *)(v15 + 8) = v10;
  *(_QWORD *)(v15 + 16) = v13;
  *a1 = re::EvaluationTree::extractScale(a2, v14);
  a1[1] = re::EvaluationTree::extractRotation(a2, v14);
  LODWORD(v18) = 37;
  v19 = 0uLL;
  *((_QWORD *)&v18 + 1) = 0;
  re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(a2 + 243), (uint64_t)&v18);
  v16 = a2[245] - 1;
  result = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v11, v16);
  *(_QWORD *)(result + 8) = v14;
  a1[2] = v16;
  return result;
}

uint64_t re::`anonymous namespace'::calculateAimForwardDirection(_QWORD *a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  unint64_t v5;
  int v7;
  unint64_t v9;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t result;
  _BYTE v24[18];
  __int16 v25;
  unint64_t v26;
  __int16 v27;
  unint64_t v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  v7 = *(unsigned __int8 *)(a5[1] + 3);
  if (v7 == 2)
  {
    *(_QWORD *)v24 = 0;
    *(_QWORD *)&v24[8] = 1065353216;
    LODWORD(v29) = 7;
    v30 = 0uLL;
    *((_QWORD *)&v29 + 1) = 0;
    re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(a1 + 243), (uint64_t)&v29);
    *(_QWORD *)&v29 = a1[245] - 1;
    re::DynamicArray<unsigned long>::add(a1 + 36, &v29);
    re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(a1 + 76), (__n128 *)v24);
    return *(_QWORD *)(a1[40] + 8 * a1[38] - 8);
  }
  if (v7 == 1)
  {
    v5 = *(_QWORD *)(a4 + 8);
    if (v5 > a2)
    {
      v18 = *(_QWORD *)(*(_QWORD *)(a4 + 16) + 8 * a2);
      *(_QWORD *)v24 = 0;
      *(_QWORD *)&v24[8] = 1065353216;
      v19 = (uint64_t)(a1 + 208);
      LODWORD(v29) = 7;
      v30 = 0uLL;
      *((_QWORD *)&v29 + 1) = 0;
      re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(a1 + 243), (uint64_t)&v29);
      *(_QWORD *)&v29 = a1[245] - 1;
      re::DynamicArray<unsigned long>::add(a1 + 36, &v29);
      re::DynamicArray<re::Vector3<float>>::add((_anonymous_namespace_ *)(a1 + 76), (__n128 *)v24);
      v20 = *(_QWORD *)(a1[40] + 8 * a1[38] - 8);
      LODWORD(v29) = 42;
      v30 = 0uLL;
      *((_QWORD *)&v29 + 1) = 0;
      re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(a1 + 243), (uint64_t)&v29);
      v21 = a1[245] - 1;
      v22 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>((uint64_t)(a1 + 208), v21);
      *(_QWORD *)(v22 + 8) = v18;
      *(_QWORD *)(v22 + 16) = v20;
      LODWORD(v29) = 29;
      v30 = 0uLL;
      *((_QWORD *)&v29 + 1) = 0;
      re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(a1 + 243), (uint64_t)&v29);
      v17 = a1[245] - 1;
      *(_QWORD *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v19, v17) + 8) = v21;
      return v17;
    }
    goto LABEL_11;
  }
  if (!*(_BYTE *)(a5[1] + 3))
  {
    v9 = *(_QWORD *)(a4 + 8);
    if (v9 > a2)
    {
      v11 = *(_QWORD *)(*(_QWORD *)(a4 + 16) + 8 * a2);
      v12 = (uint64_t)(a1 + 208);
      LODWORD(v29) = 37;
      v30 = 0uLL;
      *((_QWORD *)&v29 + 1) = 0;
      re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(a1 + 243), (uint64_t)&v29);
      v13 = a1[245] - 1;
      *(_QWORD *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>((uint64_t)(a1 + 208), v13)
                + 8) = v11;
      v14 = *a5;
      LODWORD(v29) = 31;
      v30 = 0uLL;
      *((_QWORD *)&v29 + 1) = 0;
      re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(a1 + 243), (uint64_t)&v29);
      v15 = a1[245] - 1;
      v16 = re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>((uint64_t)(a1 + 208), v15);
      *(_QWORD *)(v16 + 8) = v13;
      *(_QWORD *)(v16 + 16) = v14;
      LODWORD(v29) = 29;
      v30 = 0uLL;
      *((_QWORD *)&v29 + 1) = 0;
      re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(a1 + 243), (uint64_t)&v29);
      v17 = a1[245] - 1;
      *(_QWORD *)(re::DynamicEvaluationRegisterTable::evaluationRegister<re::Vector3<float>>(v12, v17) + 8) = v15;
      return v17;
    }
    v32 = 0u;
    v33 = 0u;
    v30 = 0u;
    v31 = 0u;
    v29 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v24 = 136315906;
    *(_QWORD *)&v24[4] = "operator[]";
    *(_WORD *)&v24[12] = 1024;
    *(_DWORD *)&v24[14] = 476;
    v25 = 2048;
    v26 = a2;
    v27 = 2048;
    v28 = v9;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_11:
    v32 = 0u;
    v33 = 0u;
    v30 = 0u;
    v31 = 0u;
    v29 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v24 = 136315906;
    *(_QWORD *)&v24[4] = "operator[]";
    *(_WORD *)&v24[12] = 1024;
    *(_DWORD *)&v24[14] = 476;
    v25 = 2048;
    v26 = a2;
    v27 = 2048;
    v28 = v5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Unexpected aim constraint forward axis type.", "!\"Unreachable code\"", "calculateAimForwardDirection", 233);
  result = _os_crash();
  __break(1u);
  return result;
}

void re::FixedArray<re::FixedArray<float>>::init<>(uint64_t *a1, uint64_t a2, unint64_t a3)
{
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;

  *a1 = a2;
  a1[1] = a3;
  if (!a3)
    return;
  if (a3 >= 0xAAAAAAAAAAAAAABLL)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 24, a3);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  v5 = 24 * a3;
  v6 = (_QWORD *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 24 * a3, 8);
  a1[2] = (uint64_t)v6;
  if (!v6)
  {
LABEL_9:
    re::internal::assertLog((re::internal *)4, v7, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    _os_crash();
    __break(1u);
    return;
  }
  v8 = v6;
  if (a3 != 1)
  {
    bzero(v6, v5 - 24);
    v8 = (_QWORD *)((char *)v8 + v5 - 24);
  }
  *v8 = 0;
  v8[1] = 0;
  v8[2] = 0;
}

void re::FixedArray<re::TwoBoneIKOptions>::init<>(uint64_t *a1, uint64_t a2, unint64_t a3)
{
  uint64_t v5;
  _OWORD *v6;
  uint64_t v7;
  _OWORD *v8;

  *a1 = a2;
  a1[1] = a3;
  if (!a3)
    return;
  if (a3 >> 59)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 32, a3);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  v5 = 32 * a3;
  v6 = (_OWORD *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 32 * a3, 8);
  a1[2] = (uint64_t)v6;
  if (!v6)
  {
LABEL_9:
    re::internal::assertLog((re::internal *)4, v7, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    _os_crash();
    __break(1u);
    return;
  }
  v8 = v6;
  if (a3 != 1)
  {
    bzero(v6, v5 - 32);
    v8 = (_OWORD *)((char *)v8 + v5 - 32);
  }
  *v8 = 0u;
  v8[1] = 0u;
}

_QWORD *re::FixedArray<re::FABRIKOptions>::init<>(_QWORD *result, uint64_t a2, unint64_t a3)
{
  _QWORD *v4;
  uint64_t v5;
  unint64_t v6;

  *result = a2;
  result[1] = a3;
  if (!a3)
    return result;
  if (a3 >> 61)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 8, a3);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  v4 = result;
  result = (_QWORD *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 8 * a3, 4);
  v4[2] = result;
  if (!result)
  {
LABEL_9:
    re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    result = (_QWORD *)_os_crash();
    __break(1u);
    return result;
  }
  v6 = a3 - 1;
  if (a3 != 1)
  {
    do
    {
      *result++ = 0x203DCCCCCDLL;
      --v6;
    }
    while (v6);
  }
  *result = 0x203DCCCCCDLL;
  return result;
}

uint64_t re::FixedArray<re::SplineIKOptions>::init<>(uint64_t result, uint64_t a2, unint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;

  *(_QWORD *)result = a2;
  *(_QWORD *)(result + 8) = a3;
  if (!a3)
    return result;
  if (a3 >= 0x333333333333334)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 80, a3);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  v4 = result;
  result = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 80 * a3, 16);
  *(_QWORD *)(v4 + 16) = result;
  if (!result)
  {
LABEL_9:
    re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v6 = a3 - 1;
  if (a3 != 1)
  {
    do
    {
      *(_DWORD *)result = 1008981770;
      *(_QWORD *)(result + 8) = 0;
      *(_QWORD *)(result + 16) = 0;
      *(_WORD *)(result + 24) = 0;
      *(_OWORD *)(result + 32) = 0uLL;
      *(_OWORD *)(result + 48) = 0uLL;
      *(_DWORD *)(result + 64) = 0;
      result += 80;
      --v6;
    }
    while (v6);
  }
  *(_DWORD *)result = 1008981770;
  *(_QWORD *)(result + 8) = 0;
  *(_QWORD *)(result + 16) = 0;
  *(_WORD *)(result + 24) = 0;
  *(_OWORD *)(result + 32) = 0u;
  *(_OWORD *)(result + 48) = 0u;
  *(_DWORD *)(result + 64) = 0;
  return result;
}

uint64_t re::DynamicArray<re::RigComponentConstraint>::operator=(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  unint64_t v5;

  if ((uint64_t *)a1 != a2)
  {
    v4 = *a2;
    if (*(_QWORD *)a1)
    {
      if (v4)
      {
        re::DynamicArray<re::RigComponentConstraint>::copy((_QWORD *)a1, (uint64_t)a2);
        ++*(_DWORD *)(a1 + 24);
      }
      else
      {
        re::DynamicArray<re::RigComponentConstraint>::clear((_QWORD *)a1);
      }
    }
    else if (v4)
    {
      v5 = a2[2];
      *(_QWORD *)a1 = v4;
      re::DynamicArray<re::RigComponentConstraint>::setCapacity((_QWORD *)a1, v5);
      ++*(_DWORD *)(a1 + 24);
      re::DynamicArray<re::RigComponentConstraint>::copy((_QWORD *)a1, (uint64_t)a2);
    }
  }
  return a1;
}

uint64_t re::DynamicArray<re::RigComponentConstraint>::copy(_QWORD *a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  __int16 v16;

  v4 = *(_QWORD *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<re::RigComponentConstraint>::setCapacity(a1, *(_QWORD *)(a2 + 16));
    result = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::RigComponentConstraint *,re::RigComponentConstraint *,re::RigComponentConstraint *>(*(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 32) + 88 * a1[2], a1[4]);
    v10 = a1[2];
    if (v10 != v4)
    {
      v11 = *(_QWORD *)(a2 + 32);
      v12 = a1[4];
      v13 = 88 * v10;
      v14 = 88 * v4;
      do
      {
        v15 = v12 + v13;
        v16 = *(_WORD *)(v11 + v13);
        *(_BYTE *)(v15 + 2) = *(_BYTE *)(v11 + v13 + 2);
        *(_WORD *)v15 = v16;
        re::DynamicArray<unsigned long>::DynamicArray(v12 + v13 + 8, (uint64_t *)(v11 + v13 + 8));
        result = re::DynamicArray<float>::DynamicArray(v12 + v13 + 48, (uint64_t *)(v11 + v13 + 48));
        v14 -= 88;
        v11 += 88;
        v12 += 88;
      }
      while (v13 != v14);
    }
  }
  else
  {
    result = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::RigComponentConstraint *,re::RigComponentConstraint *,re::RigComponentConstraint *>(*(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 32) + 88 * v4, a1[4]);
    v6 = a1[2];
    if (v4 != v6)
    {
      v7 = -88 * v4 + 88 * v6;
      v8 = 88 * v4 + a1[4] + 40;
      do
      {
        v9 = *(_QWORD *)(v8 + 8);
        if (v9)
        {
          if (*(_QWORD *)(v8 + 40))
            (*(void (**)(uint64_t))(*(_QWORD *)v9 + 40))(v9);
          *(_QWORD *)(v8 + 40) = 0;
          *(_QWORD *)(v8 + 16) = 0;
          *(_QWORD *)(v8 + 24) = 0;
          *(_QWORD *)(v8 + 8) = 0;
          ++*(_DWORD *)(v8 + 32);
        }
        result = *(_QWORD *)(v8 - 32);
        if (result)
        {
          if (*(_QWORD *)v8)
            result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
          *(_QWORD *)v8 = 0;
          *(_QWORD *)(v8 - 24) = 0;
          *(_QWORD *)(v8 - 16) = 0;
          *(_QWORD *)(v8 - 32) = 0;
          ++*(_DWORD *)(v8 - 8);
        }
        v8 += 88;
        v7 -= 88;
      }
      while (v7);
    }
  }
  a1[2] = v4;
  return result;
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::RigComponentConstraint *,re::RigComponentConstraint *,re::RigComponentConstraint *>(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  __int16 v6;

  if (result != a2)
  {
    v5 = result;
    do
    {
      v6 = *(_WORD *)v5;
      *(_BYTE *)(a3 + 2) = *(_BYTE *)(v5 + 2);
      *(_WORD *)a3 = v6;
      re::DynamicArray<unsigned long>::operator=(a3 + 8, (uint64_t *)(v5 + 8));
      result = re::DynamicArray<float>::operator=(a3 + 48, (uint64_t *)(v5 + 48));
      v5 += 88;
      a3 += 88;
    }
    while (v5 != a2);
  }
  return result;
}

uint64_t re::DynamicArray<re::RigBasicConstraint>::copy(_QWORD *a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;

  v4 = *(_QWORD *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<re::RigBasicConstraint>::setCapacity(a1, *(_QWORD *)(a2 + 16));
    result = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::RigBasicConstraint *,re::RigBasicConstraint *,re::RigBasicConstraint *>(*(_QWORD *)(a2 + 32), (uint64_t *)(*(_QWORD *)(a2 + 32) + 80 * a1[2]), a1[4]);
    v10 = a1[2];
    if (v10 != v4)
    {
      v11 = 5 * v10;
      v12 = (uint64_t *)(*(_QWORD *)(a2 + 32) + 16 * v11);
      v13 = a1[4] + 16 * v11;
      v14 = 80 * v4 - 16 * v11;
      do
      {
        re::DynamicArray<unsigned long>::DynamicArray(v13, v12);
        result = re::DynamicArray<float>::DynamicArray(v13 + 40, v12 + 5);
        v12 += 10;
        v13 += 80;
        v14 -= 80;
      }
      while (v14);
    }
  }
  else
  {
    result = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::RigBasicConstraint *,re::RigBasicConstraint *,re::RigBasicConstraint *>(*(_QWORD *)(a2 + 32), (uint64_t *)(*(_QWORD *)(a2 + 32) + 80 * v4), a1[4]);
    v6 = a1[2];
    if (v4 != v6)
    {
      v7 = 80 * v6 - 80 * v4;
      v8 = (_QWORD *)(a1[4] + 80 * v4 + 40);
      do
      {
        v9 = v8 - 5;
        if (*v8)
        {
          if (v8[4])
            (*(void (**)(_QWORD))(*(_QWORD *)*v8 + 40))(*v8);
          v8[4] = 0;
          v8[1] = 0;
          v8[2] = 0;
          *v8 = 0;
          ++*((_DWORD *)v8 + 6);
        }
        result = *v9;
        if (*v9)
        {
          if (*(v8 - 1))
            result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
          *(v8 - 1) = 0;
          *(v8 - 4) = 0;
          *(v8 - 3) = 0;
          *v9 = 0;
          ++*((_DWORD *)v8 - 4);
        }
        v8 += 10;
        v7 -= 80;
      }
      while (v7);
    }
  }
  a1[2] = v4;
  return result;
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::RigBasicConstraint *,re::RigBasicConstraint *,re::RigBasicConstraint *>(uint64_t result, uint64_t *a2, uint64_t a3)
{
  uint64_t *v5;

  if ((uint64_t *)result != a2)
  {
    v5 = (uint64_t *)result;
    do
    {
      re::DynamicArray<unsigned long>::operator=(a3, v5);
      result = re::DynamicArray<float>::operator=(a3 + 40, v5 + 5);
      v5 += 10;
      a3 += 80;
    }
    while (v5 != a2);
  }
  return result;
}

uint64_t re::DynamicArray<re::RigAimConstraint>::copy(_QWORD *a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;
  __int128 v18;

  v4 = *(_QWORD *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<re::RigAimConstraint>::setCapacity(a1, *(_QWORD *)(a2 + 16));
    result = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::RigAimConstraint *,re::RigAimConstraint *,re::RigAimConstraint *>(*(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 32) + 144 * a1[2], a1[4]);
    v10 = a1[2];
    if (v10 != v4)
    {
      v11 = *(_QWORD *)(a2 + 32);
      v12 = v11 + 144 * v4;
      v13 = a1[4];
      v14 = 144 * v10;
      do
      {
        v15 = v11 + v14;
        v16 = v13 + v14;
        v17 = *(_OWORD *)(v11 + v14);
        v18 = *(_OWORD *)(v11 + v14 + 32);
        *(_OWORD *)(v16 + 16) = *(_OWORD *)(v11 + v14 + 16);
        *(_OWORD *)(v16 + 32) = v18;
        *(_OWORD *)v16 = v17;
        re::DynamicArray<unsigned long>::DynamicArray(v13 + v14 + 48, (uint64_t *)(v11 + v14 + 48));
        result = re::DynamicArray<float>::DynamicArray(v13 + v14 + 88, (uint64_t *)(v11 + v14 + 88));
        *(_QWORD *)(v16 + 128) = *(_QWORD *)(v11 + v14 + 128);
        v11 += 144;
        v13 += 144;
      }
      while (v15 + 144 != v12);
    }
  }
  else
  {
    result = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::RigAimConstraint *,re::RigAimConstraint *,re::RigAimConstraint *>(*(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 32) + 144 * v4, a1[4]);
    v6 = a1[2];
    if (v4 != v6)
    {
      v7 = 144 * v6 - 144 * v4;
      v8 = a1[4] + 144 * v4 + 72;
      do
      {
        v9 = *(_QWORD *)(v8 + 16);
        if (v9)
        {
          if (*(_QWORD *)(v8 + 48))
            (*(void (**)(uint64_t))(*(_QWORD *)v9 + 40))(v9);
          *(_QWORD *)(v8 + 48) = 0;
          *(_QWORD *)(v8 + 24) = 0;
          *(_QWORD *)(v8 + 32) = 0;
          *(_QWORD *)(v8 + 16) = 0;
          ++*(_DWORD *)(v8 + 40);
        }
        result = *(_QWORD *)(v8 - 24);
        if (result)
        {
          if (*(_QWORD *)(v8 + 8))
            result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
          *(_QWORD *)(v8 + 8) = 0;
          *(_QWORD *)(v8 - 16) = 0;
          *(_QWORD *)(v8 - 8) = 0;
          *(_QWORD *)(v8 - 24) = 0;
          ++*(_DWORD *)v8;
        }
        v8 += 144;
        v7 -= 144;
      }
      while (v7);
    }
  }
  a1[2] = v4;
  return result;
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::RigAimConstraint *,re::RigAimConstraint *,re::RigAimConstraint *>(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  __int128 v6;
  __int128 v7;

  if (result != a2)
  {
    v5 = result;
    do
    {
      v6 = *(_OWORD *)v5;
      v7 = *(_OWORD *)(v5 + 32);
      *(_OWORD *)(a3 + 16) = *(_OWORD *)(v5 + 16);
      *(_OWORD *)(a3 + 32) = v7;
      *(_OWORD *)a3 = v6;
      re::DynamicArray<unsigned long>::operator=(a3 + 48, (uint64_t *)(v5 + 48));
      result = re::DynamicArray<float>::operator=(a3 + 88, (uint64_t *)(v5 + 88));
      *(_QWORD *)(a3 + 128) = *(_QWORD *)(v5 + 128);
      v5 += 144;
      a3 += 144;
    }
    while (v5 != a2);
  }
  return result;
}

void **re::DynamicArray<re::RigNodeChannel>::copy(void **result, uint64_t a2)
{
  void **v3;
  unint64_t v4;
  void *v5;

  v3 = result;
  v4 = *(_QWORD *)(a2 + 16);
  if (v4 >= (unint64_t)result[2])
  {
    re::DynamicArray<re::RigNodeConstraint>::setCapacity(result, *(_QWORD *)(a2 + 16));
    v5 = v3[2];
    if (v5)
    {
      memmove(v3[4], *(const void **)(a2 + 32), 16 * (_QWORD)v5);
      v5 = v3[2];
    }
    result = (void **)memcpy((char *)v3[4] + 16 * (_QWORD)v5, (const void *)(*(_QWORD *)(a2 + 32) + 16 * (_QWORD)v5), 16 * v4 - 16 * (_QWORD)v5);
  }
  else if (v4)
  {
    result = (void **)memmove(result[4], *(const void **)(a2 + 32), 16 * v4);
  }
  v3[2] = (void *)v4;
  return result;
}

uint64_t re::DynamicArray<re::Vector3<float>>::operator=(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  unint64_t v5;

  if ((uint64_t *)a1 != a2)
  {
    v4 = *a2;
    if (*(_QWORD *)a1)
    {
      if (v4)
        re::DynamicArray<re::Quaternion<float>>::copy((void **)a1, (uint64_t)a2);
      else
        *(_QWORD *)(a1 + 16) = 0;
      ++*(_DWORD *)(a1 + 24);
    }
    else if (v4)
    {
      v5 = a2[2];
      *(_QWORD *)a1 = v4;
      re::DynamicArray<re::Quaternion<float>>::setCapacity((_QWORD *)a1, v5);
      ++*(_DWORD *)(a1 + 24);
      re::DynamicArray<re::Quaternion<float>>::copy((void **)a1, (uint64_t)a2);
    }
  }
  return a1;
}

void **re::DynamicArray<re::Matrix3x3<float>>::copy(void **result, uint64_t a2)
{
  void **v3;
  unint64_t v4;
  void *v5;

  v3 = result;
  v4 = *(_QWORD *)(a2 + 16);
  if (v4 >= (unint64_t)result[2])
  {
    re::DynamicArray<re::Matrix3x3<float>>::setCapacity(result, *(_QWORD *)(a2 + 16));
    v5 = v3[2];
    if (v5)
    {
      memmove(v3[4], *(const void **)(a2 + 32), 48 * (_QWORD)v5);
      v5 = v3[2];
    }
    result = (void **)memcpy((char *)v3[4] + 48 * (_QWORD)v5, (const void *)(*(_QWORD *)(a2 + 32) + 48 * (_QWORD)v5), 48 * v4 - 48 * (_QWORD)v5);
  }
  else if (v4)
  {
    result = (void **)memmove(result[4], *(const void **)(a2 + 32), 48 * v4);
  }
  v3[2] = (void *)v4;
  return result;
}

void **re::DynamicArray<re::Matrix4x4<float>>::copy(void **result, uint64_t a2)
{
  void **v3;
  unint64_t v4;
  void *v5;

  v3 = result;
  v4 = *(_QWORD *)(a2 + 16);
  if (v4 >= (unint64_t)result[2])
  {
    re::DynamicArray<re::Matrix4x4<float>>::setCapacity(result, *(_QWORD *)(a2 + 16));
    v5 = v3[2];
    if (v5)
    {
      memmove(v3[4], *(const void **)(a2 + 32), (_QWORD)v5 << 6);
      v5 = v3[2];
    }
    result = (void **)memcpy((char *)v3[4] + 64 * (_QWORD)v5, (const void *)(*(_QWORD *)(a2 + 32) + ((_QWORD)v5 << 6)), (v4 << 6) - ((_QWORD)v5 << 6));
  }
  else if (v4)
  {
    result = (void **)memmove(result[4], *(const void **)(a2 + 32), v4 << 6);
  }
  v3[2] = (void *)v4;
  return result;
}

void **re::DynamicArray<re::Quaternion<float>>::copy(void **result, uint64_t a2)
{
  void **v3;
  unint64_t v4;
  void *v5;

  v3 = result;
  v4 = *(_QWORD *)(a2 + 16);
  if (v4 >= (unint64_t)result[2])
  {
    re::DynamicArray<re::Quaternion<float>>::setCapacity(result, *(_QWORD *)(a2 + 16));
    v5 = v3[2];
    if (v5)
    {
      memmove(v3[4], *(const void **)(a2 + 32), 16 * (_QWORD)v5);
      v5 = v3[2];
    }
    result = (void **)memcpy((char *)v3[4] + 16 * (_QWORD)v5, (const void *)(*(_QWORD *)(a2 + 32) + 16 * (_QWORD)v5), 16 * v4 - 16 * (_QWORD)v5);
  }
  else if (v4)
  {
    result = (void **)memmove(result[4], *(const void **)(a2 + 32), 16 * v4);
  }
  v3[2] = (void *)v4;
  return result;
}

void **re::DynamicArray<re::RigExpression>::copy(void **result, uint64_t a2)
{
  void **v3;
  unint64_t v4;
  void *v5;

  v3 = result;
  v4 = *(_QWORD *)(a2 + 16);
  if (v4 >= (unint64_t)result[2])
  {
    re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity(result, *(_QWORD *)(a2 + 16));
    v5 = v3[2];
    if (v5)
    {
      memmove(v3[4], *(const void **)(a2 + 32), 24 * (_QWORD)v5);
      v5 = v3[2];
    }
    result = (void **)memcpy((char *)v3[4] + 24 * (_QWORD)v5, (const void *)(*(_QWORD *)(a2 + 32) + 24 * (_QWORD)v5), 24 * v4 - 24 * (_QWORD)v5);
  }
  else if (v4)
  {
    result = (void **)memmove(result[4], *(const void **)(a2 + 32), 24 * v4);
  }
  v3[2] = (void *)v4;
  return result;
}

re::RigTwoBoneIKHandles *re::DynamicArray<re::RigTwoBoneIKHandles>::copy(_QWORD *a1, uint64_t a2)
{
  unint64_t v4;
  re::RigTwoBoneIKHandles *result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v4 = *(_QWORD *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<re::RigTwoBoneIKHandles>::setCapacity(a1, *(_QWORD *)(a2 + 16));
    result = (re::RigTwoBoneIKHandles *)std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::RigTwoBoneIKHandles *,re::RigTwoBoneIKHandles *,re::RigTwoBoneIKHandles *>(*(_QWORD *)(a2 + 32), (uint64_t *)(*(_QWORD *)(a2 + 32) + 240 * a1[2]), a1[4]);
    v9 = a1[2];
    if (v9 != v4)
    {
      v10 = *(_QWORD *)(a2 + 32);
      v11 = a1[4];
      v12 = 240 * v9;
      v13 = 240 * v4;
      do
      {
        re::DynamicArray<unsigned long>::DynamicArray(v11 + v12, (uint64_t *)(v10 + v12));
        re::DynamicArray<unsigned long>::DynamicArray(v11 + v12 + 40, (uint64_t *)(v10 + v12 + 40));
        re::DynamicArray<unsigned long>::DynamicArray(v11 + v12 + 80, (uint64_t *)(v10 + v12 + 80));
        re::DynamicArray<unsigned long>::DynamicArray(v11 + v12 + 120, (uint64_t *)(v10 + v12 + 120));
        re::DynamicArray<float>::DynamicArray(v11 + v12 + 160, (uint64_t *)(v10 + v12 + 160));
        result = (re::RigTwoBoneIKHandles *)re::DynamicArray<float>::DynamicArray(v11 + v12 + 200, (uint64_t *)(v10 + v12 + 200));
        v13 -= 240;
        v10 += 240;
        v11 += 240;
      }
      while (v12 != v13);
    }
  }
  else
  {
    result = (re::RigTwoBoneIKHandles *)std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::RigTwoBoneIKHandles *,re::RigTwoBoneIKHandles *,re::RigTwoBoneIKHandles *>(*(_QWORD *)(a2 + 32), (uint64_t *)(*(_QWORD *)(a2 + 32) + 240 * v4), a1[4]);
    v6 = a1[2];
    if (v4 != v6)
    {
      result = (re::RigTwoBoneIKHandles *)(a1[4] + 240 * v4);
      v7 = -240 * v4 + 240 * v6;
      do
      {
        re::RigTwoBoneIKHandles::~RigTwoBoneIKHandles(result);
        result = (re::RigTwoBoneIKHandles *)(v8 + 240);
        v7 -= 240;
      }
      while (v7);
    }
  }
  a1[2] = v4;
  return result;
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::RigTwoBoneIKHandles *,re::RigTwoBoneIKHandles *,re::RigTwoBoneIKHandles *>(uint64_t result, uint64_t *a2, uint64_t a3)
{
  uint64_t *v5;

  if ((uint64_t *)result != a2)
  {
    v5 = (uint64_t *)result;
    do
    {
      re::DynamicArray<unsigned long>::operator=(a3, v5);
      re::DynamicArray<unsigned long>::operator=(a3 + 40, v5 + 5);
      re::DynamicArray<unsigned long>::operator=(a3 + 80, v5 + 10);
      re::DynamicArray<unsigned long>::operator=(a3 + 120, v5 + 15);
      re::DynamicArray<float>::operator=(a3 + 160, v5 + 20);
      result = re::DynamicArray<float>::operator=(a3 + 200, v5 + 25);
      v5 += 30;
      a3 += 240;
    }
    while (v5 != a2);
  }
  return result;
}

void re::DynamicArray<re::RigSingleChainIKHandles>::copy(_QWORD *a1, uint64_t a2)
{
  unint64_t v4;
  __n128 v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v4 = *(_QWORD *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<re::RigSingleChainIKHandles>::setCapacity(a1, *(_QWORD *)(a2 + 16));
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::RigSingleChainIKHandles *,re::RigSingleChainIKHandles *,re::RigSingleChainIKHandles *>(*(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 32) + (a1[2] << 7), a1[4]);
    v12 = a1[2];
    if (v12 != v4)
    {
      v13 = *(_QWORD *)(a2 + 32);
      v14 = a1[4];
      v15 = v12 << 7;
      v16 = v4 << 7;
      do
      {
        re::DynamicArray<unsigned long>::DynamicArray(v14 + v15, (uint64_t *)(v13 + v15));
        re::DynamicArray<unsigned long>::DynamicArray(v14 + v15 + 40, (uint64_t *)(v13 + v15 + 40));
        re::DynamicArray<unsigned long>::DynamicArray(v14 + v15 + 80, (uint64_t *)(v13 + v15 + 80));
        *(_DWORD *)(v14 + v15 + 120) = *(_DWORD *)(v13 + v15 + 120);
        v16 -= 128;
        v13 += 128;
        v14 += 128;
      }
      while (v15 != v16);
    }
  }
  else
  {
    v5.n128_f32[0] = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::RigSingleChainIKHandles *,re::RigSingleChainIKHandles *,re::RigSingleChainIKHandles *>(*(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 32) + (v4 << 7), a1[4]);
    v6 = a1[2];
    if (v4 != v6)
    {
      v7 = (v6 << 7) - (v4 << 7);
      v8 = a1[4] + (v4 << 7) + 64;
      do
      {
        v9 = *(_QWORD *)(v8 + 16);
        if (v9)
        {
          if (*(_QWORD *)(v8 + 48))
            (*(void (**)(uint64_t, __n128))(*(_QWORD *)v9 + 40))(v9, v5);
          *(_QWORD *)(v8 + 48) = 0;
          *(_QWORD *)(v8 + 24) = 0;
          *(_QWORD *)(v8 + 32) = 0;
          *(_QWORD *)(v8 + 16) = 0;
          ++*(_DWORD *)(v8 + 40);
        }
        v10 = *(_QWORD *)(v8 - 24);
        if (v10)
        {
          if (*(_QWORD *)(v8 + 8))
            (*(void (**)(uint64_t, __n128))(*(_QWORD *)v10 + 40))(v10, v5);
          *(_QWORD *)(v8 + 8) = 0;
          *(_QWORD *)(v8 - 16) = 0;
          *(_QWORD *)(v8 - 8) = 0;
          *(_QWORD *)(v8 - 24) = 0;
          ++*(_DWORD *)v8;
        }
        v11 = *(_QWORD *)(v8 - 64);
        if (v11)
        {
          if (*(_QWORD *)(v8 - 32))
            (*(void (**)(uint64_t, __n128))(*(_QWORD *)v11 + 40))(v11, v5);
          *(_QWORD *)(v8 - 32) = 0;
          *(_QWORD *)(v8 - 56) = 0;
          *(_QWORD *)(v8 - 48) = 0;
          *(_QWORD *)(v8 - 64) = 0;
          ++*(_DWORD *)(v8 - 40);
        }
        v8 += 128;
        v7 -= 128;
      }
      while (v7);
    }
  }
  a1[2] = v4;
}

float std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::RigSingleChainIKHandles *,re::RigSingleChainIKHandles *,re::RigSingleChainIKHandles *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  float result;

  if (a1 != a2)
  {
    v5 = a1;
    do
    {
      re::DynamicArray<unsigned long>::operator=(a3, (uint64_t *)v5);
      re::DynamicArray<unsigned long>::operator=(a3 + 40, (uint64_t *)(v5 + 40));
      re::DynamicArray<unsigned long>::operator=(a3 + 80, (uint64_t *)(v5 + 80));
      result = *(float *)(v5 + 120);
      *(float *)(a3 + 120) = result;
      v5 += 128;
      a3 += 128;
    }
    while (v5 != a2);
  }
  return result;
}

void re::DynamicArray<re::RigSplineIKHandle>::copy(_QWORD *a1, uint64_t a2)
{
  unint64_t v4;
  __n128 v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;

  v4 = *(_QWORD *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<re::RigSplineIKHandle>::setCapacity(a1, *(_QWORD *)(a2 + 16));
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::RigSplineIKHandle *,re::RigSplineIKHandle *,re::RigSplineIKHandle *>(*(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 32) + 240 * a1[2], a1[4]);
    v11 = a1[2];
    if (v11 != v4)
    {
      v12 = *(_QWORD *)(a2 + 32);
      v13 = a1[4];
      v14 = 240 * v11;
      v15 = 240 * v4;
      do
      {
        v16 = v13 + v14;
        v17 = v12 + v14;
        *(_DWORD *)v16 = *(_DWORD *)(v12 + v14);
        *(_QWORD *)(v13 + v14 + 8) = 0;
        *(_QWORD *)(v16 + 16) = 0;
        *(_QWORD *)(v16 + 24) = 0;
        *(_DWORD *)(v16 + 32) = 0;
        v18 = *(_QWORD *)(v12 + v14 + 8);
        *(_QWORD *)(v16 + 40) = 0;
        if (v18)
        {
          v19 = *(_QWORD *)(v17 + 24);
          *(_QWORD *)(v13 + v14 + 8) = v18;
          re::DynamicArray<re::RigSplineIKJoint>::setCapacity((_QWORD *)(v13 + v14 + 8), v19);
          ++*(_DWORD *)(v16 + 32);
          re::DynamicArray<re::RigSplineIKJoint>::copy((void **)(v13 + v14 + 8), v12 + v14 + 8);
        }
        *(_QWORD *)(v16 + 48) = 0;
        v20 = v16 + 48;
        *(_QWORD *)(v20 + 8) = 0;
        *(_QWORD *)(v20 + 16) = 0;
        *(_DWORD *)(v20 + 24) = 0;
        v23 = *(_QWORD *)(v17 + 48);
        v22 = v17 + 48;
        v21 = v23;
        *(_QWORD *)(v20 + 32) = 0;
        if (v23)
        {
          v24 = *(_QWORD *)(v12 + v14 + 64);
          *(_QWORD *)v20 = v21;
          re::DynamicArray<re::RigSplineIKControlPoint>::setCapacity((_QWORD *)v20, v24);
          ++*(_DWORD *)(v13 + v14 + 72);
          re::DynamicArray<re::RigSplineIKControlPoint>::copy(v20, v22);
        }
        v25 = v13 + v14;
        re::DynamicArray<float>::DynamicArray(v13 + v14 + 88, (uint64_t *)(v12 + v14 + 88));
        v26 = *(_OWORD *)(v12 + v14 + 128);
        v27 = *(_OWORD *)(v12 + v14 + 160);
        *(_OWORD *)(v25 + 144) = *(_OWORD *)(v12 + v14 + 144);
        *(_OWORD *)(v25 + 160) = v27;
        *(_OWORD *)(v25 + 128) = v26;
        v28 = *(_OWORD *)(v12 + v14 + 176);
        v29 = *(_OWORD *)(v12 + v14 + 192);
        v30 = *(_OWORD *)(v12 + v14 + 208);
        *(_DWORD *)(v25 + 224) = *(_DWORD *)(v12 + v14 + 224);
        *(_OWORD *)(v25 + 192) = v29;
        *(_OWORD *)(v25 + 208) = v30;
        *(_OWORD *)(v25 + 176) = v28;
        v12 += 240;
        v13 += 240;
        v15 -= 240;
      }
      while (v14 != v15);
    }
  }
  else
  {
    v5 = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::RigSplineIKHandle *,re::RigSplineIKHandle *,re::RigSplineIKHandle *>(*(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 32) + 240 * v4, a1[4]);
    v6 = a1[2];
    if (v4 != v6)
    {
      v7 = -240 * v4 + 240 * v6;
      v8 = (_QWORD *)(240 * v4 + a1[4] + 120);
      do
      {
        v9 = *(v8 - 4);
        if (v9)
        {
          if (*v8)
            (*(void (**)(uint64_t, __n128))(*(_QWORD *)v9 + 40))(v9, v5);
          *v8 = 0;
          *(v8 - 3) = 0;
          *(v8 - 2) = 0;
          *(v8 - 4) = 0;
          ++*((_DWORD *)v8 - 2);
        }
        re::DynamicArray<re::RigSplineIKControlPoint>::deinit((uint64_t)(v8 - 9));
        v10 = *(v8 - 14);
        if (v10)
        {
          if (*(v8 - 10))
            (*(void (**)(uint64_t))(*(_QWORD *)v10 + 40))(v10);
          *(v8 - 10) = 0;
          *(v8 - 13) = 0;
          *(v8 - 12) = 0;
          *(v8 - 14) = 0;
          ++*((_DWORD *)v8 - 22);
        }
        v8 += 30;
        v7 -= 240;
      }
      while (v7);
    }
  }
  a1[2] = v4;
}

__n128 std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::RigSplineIKHandle *,re::RigSplineIKHandle *,re::RigSplineIKHandle *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  __int128 v16;
  __int128 v17;
  __n128 result;
  __int128 v19;
  __int128 v20;

  if (a1 != a2)
  {
    v6 = 0;
    do
    {
      v7 = a1 + v6;
      v8 = a3 + v6;
      *(_DWORD *)(a3 + v6) = *(_DWORD *)(a1 + v6);
      v9 = (_QWORD *)(a3 + v6 + 8);
      if (a3 != a1)
      {
        v10 = *(_QWORD *)(a1 + v6 + 8);
        if (*v9)
        {
          if (v10)
          {
            re::DynamicArray<re::RigSplineIKJoint>::copy((void **)(a3 + v6 + 8), a1 + v6 + 8);
            v11 = a3 + v6;
          }
          else
          {
            v11 = a3 + v6;
            *(_QWORD *)(a3 + v6 + 24) = 0;
          }
          ++*(_DWORD *)(v11 + 32);
        }
        else if (v10)
        {
          v12 = *(_QWORD *)(a1 + v6 + 24);
          *v9 = v10;
          re::DynamicArray<re::RigSplineIKJoint>::setCapacity((_QWORD *)(a3 + v6 + 8), v12);
          ++*(_DWORD *)(a3 + v6 + 32);
          re::DynamicArray<re::RigSplineIKJoint>::copy((void **)(a3 + v6 + 8), a1 + v6 + 8);
        }
        v13 = *(_QWORD *)(a1 + v6 + 48);
        if (*(_QWORD *)(a3 + v6 + 48))
        {
          v14 = (_QWORD *)(a3 + v6 + 48);
          if (v13)
          {
            re::DynamicArray<re::RigSplineIKControlPoint>::copy((uint64_t)v14, a1 + v6 + 48);
            ++*(_DWORD *)(a3 + v6 + 72);
          }
          else
          {
            re::DynamicArray<re::RigSplineIKControlPoint>::clear(v14);
          }
        }
        else if (v13)
        {
          v15 = *(_QWORD *)(a1 + v6 + 64);
          *(_QWORD *)(a3 + v6 + 48) = v13;
          re::DynamicArray<re::RigSplineIKControlPoint>::setCapacity((_QWORD *)(a3 + v6 + 48), v15);
          ++*(_DWORD *)(a3 + v6 + 72);
          re::DynamicArray<re::RigSplineIKControlPoint>::copy(a3 + v6 + 48, a1 + v6 + 48);
        }
      }
      re::DynamicArray<float>::operator=(v8 + 88, (uint64_t *)(v7 + 88));
      v17 = *(_OWORD *)(v7 + 144);
      v16 = *(_OWORD *)(v7 + 160);
      *(_OWORD *)(v8 + 128) = *(_OWORD *)(v7 + 128);
      *(_OWORD *)(v8 + 144) = v17;
      *(_OWORD *)(v8 + 160) = v16;
      v19 = *(_OWORD *)(v7 + 192);
      result = *(__n128 *)(v7 + 208);
      v20 = *(_OWORD *)(v7 + 176);
      *(_DWORD *)(v8 + 224) = *(_DWORD *)(v7 + 224);
      *(_OWORD *)(v8 + 192) = v19;
      *(__n128 *)(v8 + 208) = result;
      *(_OWORD *)(v8 + 176) = v20;
      v6 += 240;
    }
    while (v7 + 240 != a2);
  }
  return result;
}

void **re::DynamicArray<re::RigSplineIKJoint>::copy(void **result, uint64_t a2)
{
  void **v3;
  unint64_t v4;
  void *v5;

  v3 = result;
  v4 = *(_QWORD *)(a2 + 16);
  if (v4 >= (unint64_t)result[2])
  {
    re::DynamicArray<re::RigSplineIKJoint>::setCapacity(result, *(_QWORD *)(a2 + 16));
    v5 = v3[2];
    if (v5)
    {
      memmove(v3[4], *(const void **)(a2 + 32), 80 * (_QWORD)v5);
      v5 = v3[2];
    }
    result = (void **)memcpy((char *)v3[4] + 80 * (_QWORD)v5, (const void *)(*(_QWORD *)(a2 + 32) + 80 * (_QWORD)v5), 80 * v4 - 80 * (_QWORD)v5);
  }
  else if (v4)
  {
    result = (void **)memmove(result[4], *(const void **)(a2 + 32), 80 * v4);
  }
  v3[2] = (void *)v4;
  return result;
}

void re::DynamicArray<re::RigSplineIKControlPoint>::copy(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  __n128 v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v4 = *(_QWORD *)(a2 + 16);
  if (v4 >= *(_QWORD *)(a1 + 16))
  {
    re::DynamicArray<re::RigSplineIKControlPoint>::setCapacity((_QWORD *)a1, *(_QWORD *)(a2 + 16));
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::RigSplineIKControlPoint *,re::RigSplineIKControlPoint *,re::RigSplineIKControlPoint *>(*(__n128 **)(a2 + 32), (__n128 *)(*(_QWORD *)(a2 + 32) + 96 * *(_QWORD *)(a1 + 16)), *(__n128 **)(a1 + 32));
    v10 = *(_QWORD *)(a1 + 16);
    if (v10 != v4)
    {
      v11 = *(_QWORD *)(a2 + 32);
      v12 = *(_QWORD *)(a1 + 32);
      v13 = 96 * v10;
      v14 = 96 * v4;
      do
      {
        re::DynamicArray<unsigned long>::DynamicArray(v12 + v13, (uint64_t *)(v11 + v13));
        re::DynamicArray<float>::DynamicArray(v12 + v13 + 40, (uint64_t *)(v11 + v13 + 40));
        *(_OWORD *)(v12 + v13 + 80) = *(_OWORD *)(v11 + v13 + 80);
        v14 -= 96;
        v11 += 96;
        v12 += 96;
      }
      while (v13 != v14);
    }
  }
  else
  {
    v5 = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::RigSplineIKControlPoint *,re::RigSplineIKControlPoint *,re::RigSplineIKControlPoint *>((__n128 *)*(_QWORD *)(a2 + 32), (__n128 *)(*(_QWORD *)(a2 + 32) + 96 * v4), (__n128 *)*(_QWORD *)(a1 + 32));
    v6 = *(_QWORD *)(a1 + 16);
    if (v4 != v6)
    {
      v7 = 96 * v6 - 96 * v4;
      v8 = (_QWORD *)(*(_QWORD *)(a1 + 32) + 96 * v4 + 40);
      do
      {
        v9 = v8 - 5;
        if (*v8)
        {
          if (v8[4])
            (*(void (**)(_QWORD, __n128))(*(_QWORD *)*v8 + 40))(*v8, v5);
          v8[4] = 0;
          v8[1] = 0;
          v8[2] = 0;
          *v8 = 0;
          ++*((_DWORD *)v8 + 6);
        }
        if (*v9)
        {
          if (*(v8 - 1))
            (*(void (**)(_QWORD, __n128))(*(_QWORD *)*v9 + 40))(*v9, v5);
          *(v8 - 1) = 0;
          *(v8 - 4) = 0;
          *(v8 - 3) = 0;
          *v9 = 0;
          ++*((_DWORD *)v8 - 4);
        }
        v8 += 12;
        v7 -= 96;
      }
      while (v7);
    }
  }
  *(_QWORD *)(a1 + 16) = v4;
}

__n128 std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::RigSplineIKControlPoint *,re::RigSplineIKControlPoint *,re::RigSplineIKControlPoint *>(__n128 *a1, __n128 *a2, __n128 *a3)
{
  __n128 *v5;
  __n128 result;

  if (a1 != a2)
  {
    v5 = a1;
    do
    {
      re::DynamicArray<unsigned long>::operator=((uint64_t)a3, (uint64_t *)v5);
      re::DynamicArray<float>::operator=((uint64_t)&a3[2].n128_i64[1], &v5[2].n128_i64[1]);
      result = v5[5];
      a3[5] = result;
      v5 += 6;
      a3 += 6;
    }
    while (v5 != a2);
  }
  return result;
}

void **re::DynamicArray<re::RigTransform>::copy(void **result, uint64_t a2)
{
  void **v3;
  unint64_t v4;
  void *v5;

  v3 = result;
  v4 = *(_QWORD *)(a2 + 16);
  if (v4 >= (unint64_t)result[2])
  {
    re::DynamicArray<re::RigTransform>::setCapacity(result, *(_QWORD *)(a2 + 16));
    v5 = v3[2];
    if (v5)
    {
      memmove(v3[4], *(const void **)(a2 + 32), ((_QWORD)v5 << 6) - 15);
      v5 = v3[2];
    }
    result = (void **)memcpy((char *)v3[4] + 64 * (_QWORD)v5, (const void *)(*(_QWORD *)(a2 + 32) + ((_QWORD)v5 << 6)), (v4 << 6) - ((_QWORD)v5 << 6));
  }
  else if (v4)
  {
    result = (void **)memmove(result[4], *(const void **)(a2 + 32), (v4 << 6) - 15);
  }
  v3[2] = (void *)v4;
  return result;
}

void **re::DynamicArray<re::RigJoint>::copy(void **result, uint64_t a2)
{
  void **v3;
  unint64_t v4;
  void *v5;

  v3 = result;
  v4 = *(_QWORD *)(a2 + 16);
  if (v4 >= (unint64_t)result[2])
  {
    re::DynamicArray<re::RigJoint>::setCapacity(result, *(_QWORD *)(a2 + 16));
    v5 = v3[2];
    if (v5)
    {
      memmove(v3[4], *(const void **)(a2 + 32), 96 * (_QWORD)v5 - 15);
      v5 = v3[2];
    }
    result = (void **)memcpy((char *)v3[4] + 96 * (_QWORD)v5, (const void *)(*(_QWORD *)(a2 + 32) + 96 * (_QWORD)v5), 96 * v4 - 96 * (_QWORD)v5);
  }
  else if (v4)
  {
    result = (void **)memmove(result[4], *(const void **)(a2 + 32), 96 * v4 - 15);
  }
  v3[2] = (void *)v4;
  return result;
}

void re::DynamicArray<re::RigNode>::copy(_QWORD *a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  re::StringID *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  re::StringID *v11;
  uint64_t v12;
  re::StringID *v13;
  __int128 v14;
  __int128 v15;

  v4 = *(_QWORD *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<re::RigNode>::setCapacity(a1, *(_QWORD *)(a2 + 16));
    std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::RigNode *,re::RigNode *,re::RigNode *,0>(*(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 32) + 56 * a1[2], a1[4]);
    v8 = a1[2];
    if (v8 != v4)
    {
      v9 = 56 * v8;
      v10 = *(_QWORD *)(a2 + 32) + v9;
      v11 = (re::StringID *)(a1[4] + v9);
      v12 = 56 * v4 - v9;
      do
      {
        v13 = re::StringID::StringID(v11, (const StringID *)v10);
        v14 = *(_OWORD *)(v10 + 16);
        v15 = *(_OWORD *)(v10 + 32);
        *((_QWORD *)v13 + 6) = *(_QWORD *)(v10 + 48);
        *((_OWORD *)v13 + 1) = v14;
        *((_OWORD *)v13 + 2) = v15;
        v10 += 56;
        v11 = (re::StringID *)((char *)v13 + 56);
        v12 -= 56;
      }
      while (v12);
    }
  }
  else
  {
    std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::RigNode *,re::RigNode *,re::RigNode *,0>(*(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 32) + 56 * v4, a1[4]);
    v5 = a1[2];
    if (v4 != v5)
    {
      v6 = (re::StringID *)(a1[4] + 56 * v4);
      v7 = -56 * v4 + 56 * v5;
      do
      {
        re::StringID::destroyString(v6);
        v6 = (re::StringID *)((char *)v6 + 56);
        v7 -= 56;
      }
      while (v7);
    }
  }
  a1[2] = v4;
}

__n128 std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::RigNode *,re::RigNode *,re::RigNode *,0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  __n128 result;
  __int128 v7;

  if (a1 != a2)
  {
    v5 = a1;
    do
    {
      re::StringID::operator=((unint64_t *)a3, (uint64_t *)v5);
      result = *(__n128 *)(v5 + 16);
      v7 = *(_OWORD *)(v5 + 32);
      *(_QWORD *)(a3 + 48) = *(_QWORD *)(v5 + 48);
      *(__n128 *)(a3 + 16) = result;
      *(_OWORD *)(a3 + 32) = v7;
      v5 += 56;
      a3 += 56;
    }
    while (v5 != a2);
  }
  return result;
}

void re::DynamicArray<re::RigPose>::copy(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  re::StringID *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  re::StringID *v10;
  uint64_t v11;
  re::StringID *v12;

  v4 = *(_QWORD *)(a2 + 16);
  if (v4 >= *(_QWORD *)(a1 + 16))
  {
    re::DynamicArray<re::RigPose>::setCapacity((_QWORD *)a1, *(_QWORD *)(a2 + 16));
    std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::RigPose *,re::RigPose *,re::RigPose *,0>(*(__n128 **)(a2 + 32), (__n128 *)(*(_QWORD *)(a2 + 32) + 32 * *(_QWORD *)(a1 + 16)), *(__n128 **)(a1 + 32));
    v8 = *(_QWORD *)(a1 + 16);
    if (v8 != v4)
    {
      v9 = *(_QWORD *)(a2 + 32) + 32 * v8;
      v10 = (re::StringID *)(*(_QWORD *)(a1 + 32) + 32 * v8);
      v11 = 32 * v4 - 32 * v8;
      do
      {
        v12 = re::StringID::StringID(v10, (const StringID *)v9);
        *((_OWORD *)v12 + 1) = *(_OWORD *)(v9 + 16);
        v9 += 32;
        v10 = (re::StringID *)((char *)v12 + 32);
        v11 -= 32;
      }
      while (v11);
    }
  }
  else
  {
    std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::RigPose *,re::RigPose *,re::RigPose *,0>(*(__n128 **)(a2 + 32), (__n128 *)(*(_QWORD *)(a2 + 32) + 32 * v4), *(__n128 **)(a1 + 32));
    v5 = *(_QWORD *)(a1 + 16);
    if (v4 != v5)
    {
      v6 = (re::StringID *)(*(_QWORD *)(a1 + 32) + 32 * v4);
      v7 = 32 * v5 - 32 * v4;
      do
      {
        re::StringID::destroyString(v6);
        v6 = (re::StringID *)((char *)v6 + 32);
        v7 -= 32;
      }
      while (v7);
    }
  }
  *(_QWORD *)(a1 + 16) = v4;
}

__n128 std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::RigPose *,re::RigPose *,re::RigPose *,0>(__n128 *a1, __n128 *a2, __n128 *a3)
{
  __n128 *v5;
  __n128 result;

  if (a1 != a2)
  {
    v5 = a1;
    do
    {
      re::StringID::operator=(a3->n128_u64, (uint64_t *)v5);
      result = v5[1];
      a3[1] = result;
      v5 += 2;
      a3 += 2;
    }
    while (v5 != a2);
  }
  return result;
}

uint64_t re::DynamicArray<re::RigComponentConstraint>::operator=(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  BOOL v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (result != a2)
  {
    v2 = *(_QWORD *)result;
    v3 = *(_QWORD *)a2;
    if (*(_QWORD *)result)
      v4 = v3 == 0;
    else
      v4 = 1;
    if (v4 || v2 == v3)
    {
      v6 = *(_QWORD *)(result + 8);
      v7 = *(_QWORD *)(a2 + 8);
      *(_QWORD *)result = v3;
      *(_QWORD *)(result + 8) = v7;
      *(_QWORD *)a2 = v2;
      *(_QWORD *)(a2 + 8) = v6;
      v8 = *(_QWORD *)(result + 16);
      *(_QWORD *)(result + 16) = *(_QWORD *)(a2 + 16);
      *(_QWORD *)(a2 + 16) = v8;
      v9 = *(_QWORD *)(result + 32);
      *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
      *(_QWORD *)(a2 + 32) = v9;
      ++*(_DWORD *)(a2 + 24);
      ++*(_DWORD *)(result + 24);
    }
    else
    {
      re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) ", "!isInitialized() || !other.isInitialized() || m_allocator == other.m_allocator", "operator=", 503);
      result = _os_crash();
      __break(1u);
    }
  }
  return result;
}

_QWORD *re::FixedArray<re::FixedArray<float>>::deinit(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;

  if (*result)
  {
    v1 = result;
    v3 = result + 1;
    v2 = result[1];
    if (v2)
    {
      v4 = 24 * v2;
      v5 = (_QWORD *)(result[2] + 8);
      do
      {
        v6 = *(v5 - 1);
        if (v6)
        {
          if (*v5)
          {
            (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v6 + 40))(v6, v5[1]);
            *v5 = 0;
            v5[1] = 0;
          }
          *(v5 - 1) = 0;
        }
        v5 += 3;
        v4 -= 24;
      }
      while (v4);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v1 + 40))(*v1, v1[2]);
      *v3 = 0;
      v3[1] = 0;
    }
    *v1 = 0;
  }
  return result;
}

uint64_t re::FixedArray<re::FixedArray<float>>::operator=(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t result;

  if (a1 == a2)
    return (uint64_t)a1;
  v4 = *a2;
  if (*a1)
  {
    if (!v4)
      return (uint64_t)a1;
  }
  else
  {
    if (!v4)
      return (uint64_t)a1;
    re::FixedArray<re::FixedArray<float>>::init<>(a1, v4, a2[1]);
  }
  v5 = a2[1];
  if (a1[1] == v5)
  {
    if (v5)
    {
      v6 = a2[2];
      v7 = (uint64_t *)a1[2];
      v8 = 24 * v5;
      do
      {
        re::FixedArray<float>::operator=(v7, v6);
        v6 += 24;
        v7 += 3;
        v8 -= 24;
      }
      while (v8);
    }
    return (uint64_t)a1;
  }
  re::internal::assertLog((re::internal *)4, v4, "assertion failure: '%s' (%s:line %i) Cannot copy from a FixedArray of a different size", "m_size == other.m_size", "copy", 388);
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::FixedArray<re::TwoBoneIKOptions>::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t result;

  if (a1 == a2)
    return a1;
  v4 = *(_QWORD *)a2;
  if (*(_QWORD *)a1)
  {
    if (!v4)
      return a1;
  }
  else
  {
    if (!v4)
      return a1;
    re::FixedArray<re::TwoBoneIKOptions>::init<>((uint64_t *)a1, v4, *(_QWORD *)(a2 + 8));
  }
  v5 = *(_QWORD *)(a2 + 8);
  if (*(_QWORD *)(a1 + 8) == v5)
  {
    if (v5)
      memmove(*(void **)(a1 + 16), *(const void **)(a2 + 16), 32 * v5);
    return a1;
  }
  re::internal::assertLog((re::internal *)4, v4, "assertion failure: '%s' (%s:line %i) Cannot copy from a FixedArray of a different size", "m_size == other.m_size", "copy", 388);
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::FixedArray<re::FABRIKOptions>::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t result;

  if (a1 == a2)
    return a1;
  v4 = *(_QWORD *)a2;
  if (*(_QWORD *)a1)
  {
    if (!v4)
      return a1;
  }
  else
  {
    if (!v4)
      return a1;
    re::FixedArray<re::FABRIKOptions>::init<>((_QWORD *)a1, v4, *(_QWORD *)(a2 + 8));
  }
  v5 = *(_QWORD *)(a2 + 8);
  if (*(_QWORD *)(a1 + 8) == v5)
  {
    if (v5)
      memmove(*(void **)(a1 + 16), *(const void **)(a2 + 16), 8 * v5);
    return a1;
  }
  re::internal::assertLog((re::internal *)4, v4, "assertion failure: '%s' (%s:line %i) Cannot copy from a FixedArray of a different size", "m_size == other.m_size", "copy", 388);
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::FixedArray<re::SplineIKOptions>::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t result;

  if (a1 == a2)
    return a1;
  v4 = *(_QWORD *)a2;
  if (*(_QWORD *)a1)
  {
    if (!v4)
      return a1;
  }
  else
  {
    if (!v4)
      return a1;
    re::FixedArray<re::SplineIKOptions>::init<>(a1, v4, *(_QWORD *)(a2 + 8));
  }
  v5 = *(_QWORD *)(a2 + 8);
  if (*(_QWORD *)(a1 + 8) == v5)
  {
    if (v5)
      memmove(*(void **)(a1 + 16), *(const void **)(a2 + 16), 80 * v5 - 12);
    return a1;
  }
  re::internal::assertLog((re::internal *)4, v4, "assertion failure: '%s' (%s:line %i) Cannot copy from a FixedArray of a different size", "m_size == other.m_size", "copy", 388);
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t *re::FixedArray<unsigned long>::operator=(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;

  if (a1 != (uint64_t *)a2)
  {
    v4 = *(_QWORD *)a2;
    if (*a1)
    {
      if (!v4)
        return a1;
      goto LABEL_7;
    }
    if (v4)
    {
      re::FixedArray<unsigned long>::init<>(a1, v4, *(_QWORD *)(a2 + 8));
LABEL_7:
      re::FixedArray<unsigned long>::copy(a1, a2);
    }
  }
  return a1;
}

uint64_t *re::FixedArray<re::Vector3<float>>::operator=(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;

  if (a1 != (uint64_t *)a2)
  {
    v4 = *(_QWORD *)a2;
    if (*a1)
    {
      if (!v4)
        return a1;
      goto LABEL_7;
    }
    if (v4)
    {
      re::FixedArray<re::Vector3<float>>::init<>(a1, v4, *(_QWORD *)(a2 + 8));
LABEL_7:
      re::FixedArray<re::Vector3<float>>::copy(a1, a2);
    }
  }
  return a1;
}

void *re::FixedArray<re::Vector3<float>>::copy(void *result, uint64_t a2)
{
  uint64_t v2;

  v2 = *((_QWORD *)result + 1);
  if (v2 == *(_QWORD *)(a2 + 8))
  {
    if (v2)
      return memmove(*((void **)result + 2), *(const void **)(a2 + 16), 16 * v2);
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Cannot copy from a FixedArray of a different size", "m_size == other.m_size", "copy", 388);
    result = (void *)_os_crash();
    __break(1u);
  }
  return result;
}

uint64_t *re::FixedArray<re::Matrix4x4<float>>::operator=(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;

  if (a1 != (uint64_t *)a2)
  {
    v4 = *(_QWORD *)a2;
    if (*a1)
    {
      if (!v4)
        return a1;
      goto LABEL_7;
    }
    if (v4)
    {
      re::FixedArray<re::Matrix4x4<float>>::init<>(a1, v4, *(_QWORD *)(a2 + 8));
LABEL_7:
      re::FixedArray<re::Matrix4x4<float>>::copy(a1, a2);
    }
  }
  return a1;
}

uint64_t *re::FixedArray<unsigned long>::operator=(uint64_t *result, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  BOOL v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (result != a2)
  {
    v2 = *result;
    v3 = *a2;
    if (*result)
      v4 = v2 == v3;
    else
      v4 = 1;
    if (v4)
    {
      *result = v3;
      *a2 = v2;
      v5 = result[1];
      v6 = result[2];
      v7 = a2[2];
      result[1] = a2[1];
      result[2] = v7;
      a2[1] = v5;
      a2[2] = v6;
    }
    else
    {
      re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) ", "!isInitialized() || m_allocator == other.m_allocator", "operator=", 296);
      result = (uint64_t *)_os_crash();
      __break(1u);
    }
  }
  return result;
}

uint64_t re::EvaluationContextManager::bindOutputHandle<re::Matrix4x4<float>>(_QWORD *a1, uint64_t a2, _QWORD *a3, char a4)
{
  __objc2_class_ro *v7;
  unsigned __int8 v8;
  __objc2_class_ro **p_info;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  int v15;
  BOOL v16[8];
  __objc2_class_ro *v17;
  _BYTE v18[40];
  char v19;
  _QWORD v20[2];
  int v21;
  const char *v22;
  __int16 v23;
  int v24;
  __int16 v25;
  uint64_t v26;
  __int16 v27;
  unint64_t v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  if (!a3[3])
    return 0;
  v7 = (__objc2_class_ro *)*a3;
  p_info = VideoSpillMapMetalSession.info;
  if ((v8 & 1) == 0)
  {
    *(_QWORD *)v16 = a2;
    p_info = (__objc2_class_ro **)(VideoSpillMapMetalSession + 32);
    a2 = *(_QWORD *)v16;
    if (v15)
    {
      re::introspect<re::Matrix4x4<float>>(void)::info = (_UNKNOWN *)re::introspect_Matrix4x4F(0);
      p_info = (__objc2_class_ro **)(VideoSpillMapMetalSession + 32);
      a2 = *(_QWORD *)v16;
    }
  }
  if (v7 != p_info[187])
    return 0;
  v11 = *(_QWORD *)(a2 + 8);
  v20[0] = v11;
  if (v11 >= a1[248])
  {
    re::DynamicArray<re::EvaluationContextManager::BindPointReference>::resize(a1 + 246, v11 + 1);
  }
  else if (*(_QWORD *)(a1[250] + 56 * v11 + 24))
  {
    return 0;
  }
  re::DynamicArray<unsigned long>::add(a1 + 291, v20);
  v17 = (__objc2_class_ro *)*a3;
  re::DynamicArray<re::BindPoint::BindPointData>::DynamicArray((uint64_t)v18, a3 + 1);
  v19 = a4;
  v12 = v20[0];
  v13 = a1[248];
  if (v13 <= v20[0])
  {
    v20[1] = 0;
    v32 = 0u;
    v33 = 0u;
    v30 = 0u;
    v31 = 0u;
    v29 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v21 = 136315906;
    v22 = "operator[]";
    v23 = 1024;
    v24 = 789;
    v25 = 2048;
    v26 = v12;
    v27 = 2048;
    v28 = v13;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  v14 = a1[250] + 56 * v20[0];
  *(_QWORD *)v14 = v17;
  re::DynamicArray<re::RigDataValue>::operator=(v14 + 8, (uint64_t)v18);
  *(_BYTE *)(v14 + 48) = v19;
  re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)v18);
  re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)v18);
  return 1;
}

_QWORD *re::DynamicArray<re::internal::RigIKCall>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::internal::RigIKCall>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x88uLL))
        {
          v2 = 136 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 136 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_32;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 136, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_32:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = 136 * v9;
        v11 = v8 + 64;
        v12 = v7;
        do
        {
          *v12 = *(_QWORD *)(v11 - 64);
          v12[1] = 0;
          v12[2] = 0;
          v12[3] = 0;
          v14 = (_QWORD *)(v11 - 48);
          v13 = *(_QWORD *)(v11 - 48);
          v12[1] = *(_QWORD *)(v11 - 56);
          *(_QWORD *)(v11 - 56) = 0;
          v12[2] = v13;
          *(_QWORD *)(v11 - 48) = 0;
          v15 = v12[3];
          v12[3] = *(_QWORD *)(v11 - 40);
          *(_QWORD *)(v11 - 40) = v15;
          v12[4] = 0;
          v12[5] = 0;
          v12[6] = 0;
          v17 = (_QWORD *)(v11 - 24);
          v16 = *(_QWORD *)(v11 - 24);
          v12[4] = *(_QWORD *)(v11 - 32);
          *(_QWORD *)(v11 - 32) = 0;
          v12[5] = v16;
          *(_QWORD *)(v11 - 24) = 0;
          v18 = v12[6];
          v12[6] = *(_QWORD *)(v11 - 16);
          *(_QWORD *)(v11 - 16) = v18;
          v12[7] = 0;
          v12[8] = 0;
          v12[9] = 0;
          v12[7] = *(_QWORD *)(v11 - 8);
          *(_QWORD *)(v11 - 8) = 0;
          v19 = v12[9];
          v20 = *(_QWORD *)(v11 + 8);
          v12[8] = *(_QWORD *)v11;
          v12[9] = v20;
          *(_QWORD *)v11 = 0;
          *(_QWORD *)(v11 + 8) = v19;
          *((_OWORD *)v12 + 5) = *(_OWORD *)(v11 + 16);
          v12[13] = 0;
          v12[14] = 0;
          v12[12] = 0;
          v22 = (_QWORD *)(v11 + 40);
          v21 = *(_QWORD *)(v11 + 40);
          v12[12] = *(_QWORD *)(v11 + 32);
          *(_QWORD *)(v11 + 32) = 0;
          v12[13] = v21;
          v23 = v12[14];
          v12[14] = *(_QWORD *)(v11 + 48);
          *(_QWORD *)(v11 + 40) = 0;
          *(_QWORD *)(v11 + 48) = v23;
          *(_OWORD *)(v12 + 15) = *(_OWORD *)(v11 + 56);
          v24 = *(_QWORD *)(v11 + 32);
          if (v24)
          {
            if (*v22)
            {
              (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v24 + 40))(v24, *(_QWORD *)(v11 + 48));
              *v22 = 0;
              *(_QWORD *)(v11 + 48) = 0;
            }
            *(_QWORD *)(v11 + 32) = 0;
          }
          v25 = *(_QWORD *)(v11 - 8);
          if (v25)
          {
            if (*(_QWORD *)v11)
            {
              (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v25 + 40))(v25, *(_QWORD *)(v11 + 8));
              *(_QWORD *)v11 = 0;
              *(_QWORD *)(v11 + 8) = 0;
            }
            *(_QWORD *)(v11 - 8) = 0;
          }
          v26 = *(_QWORD *)(v11 - 32);
          if (v26)
          {
            if (*v17)
            {
              (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v26 + 40))(v26, *(_QWORD *)(v11 - 16));
              *v17 = 0;
              *(_QWORD *)(v11 - 16) = 0;
            }
            *(_QWORD *)(v11 - 32) = 0;
          }
          v27 = *(_QWORD *)(v11 - 56);
          if (v27)
          {
            if (*v14)
            {
              (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v27 + 40))(v27, *(_QWORD *)(v11 - 40));
              *v14 = 0;
              *(_QWORD *)(v11 - 40) = 0;
            }
            *(_QWORD *)(v11 - 56) = 0;
          }
          v11 += 136;
          v12 += 17;
          v10 -= 136;
        }
        while (v10);
        v8 = v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_32;
    }
  }
  return result;
}

size_t re::RigEvaluation::HashString::operator()(int a1, char *__s)
{
  size_t result;
  unint64_t v4[3];

  v4[2] = *MEMORY[0x24BDAC8D0];
  result = strlen(__s);
  if (result)
  {
    MurmurHash3_x64_128((uint64_t)__s, result, 0, v4);
    return (v4[1] + (v4[0] << 6) + (v4[0] >> 2) - 0x61C8864680B583E9) ^ v4[0];
  }
  return result;
}

void re::FixedArray<char const*>::init<>(uint64_t *a1, uint64_t a2, unint64_t a3)
{
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;

  *a1 = a2;
  a1[1] = a3;
  if (!a3)
    return;
  if (a3 >> 61)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 8, a3);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  v5 = 8 * a3;
  v6 = (_QWORD *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 8 * a3, 8);
  a1[2] = (uint64_t)v6;
  if (!v6)
  {
LABEL_9:
    re::internal::assertLog((re::internal *)4, v7, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    _os_crash();
    __break(1u);
    return;
  }
  v8 = v6;
  if (a3 != 1)
  {
    bzero(v6, v5 - 8);
    v8 = (_QWORD *)((char *)v8 + v5 - 8);
  }
  *v8 = 0;
}

void re::convertIntrinsicEulersToQuaternions<float>(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7;
  float *v8;
  float *v9;
  __float2 v10;
  __float2 v11;
  float v12;
  __float2 v13;
  uint64_t v14;
  float *v15;
  float *v16;
  __float2 v17;
  __float2 v18;
  float v19;
  __float2 v20;
  float v21;
  uint64_t v22;
  float *v23;
  float *v24;
  __float2 v25;
  __float2 v26;
  float v27;
  __float2 v28;
  uint64_t v29;
  float *v30;
  float *v31;
  __float2 v32;
  __float2 v33;
  float v34;
  __float2 v35;
  uint64_t v36;
  float *v37;
  float *v38;
  __float2 v39;
  __float2 v40;
  float v41;
  __float2 v42;
  uint64_t v43;
  float *v44;
  float *v45;
  __float2 v46;
  __float2 v47;
  float v48;
  __float2 v49;

  switch(a3)
  {
    case 0:
      if (!a2)
        return;
      v7 = 0;
      v8 = (float *)(a1 + 8);
      v9 = (float *)(a4 + 8);
      while (a5 != v7)
      {
        v10 = __sincosf_stret(*(v8 - 2) * 0.5);
        v11 = __sincosf_stret(*(v8 - 1) * 0.5);
        v12 = *v8;
        v8 += 4;
        v13 = __sincosf_stret(v12 * 0.5);
        *(v9 - 2) = (float)((float)(v10.__cosval * v11.__sinval) * v13.__sinval)
                  + (float)((float)(v10.__sinval * v11.__cosval) * v13.__cosval);
        *(v9 - 1) = (float)((float)(v10.__cosval * v11.__sinval) * v13.__cosval)
                  - (float)((float)(v10.__sinval * v11.__cosval) * v13.__sinval);
        *v9 = (float)((float)(v10.__sinval * v11.__sinval) * v13.__cosval)
            + (float)((float)(v10.__cosval * v11.__cosval) * v13.__sinval);
        v9[1] = (float)((float)(v10.__cosval * v11.__cosval) * v13.__cosval)
              - (float)((float)(v10.__sinval * v11.__sinval) * v13.__sinval);
        v9 += 4;
        if (a2 == ++v7)
          return;
      }
      re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, a5, a5);
      _os_crash();
      __break(1u);
      goto LABEL_33;
    case 1:
      if (!a2)
        return;
      v14 = 0;
      v15 = (float *)(a1 + 8);
      v16 = (float *)(a4 + 8);
      while (a5 != v14)
      {
        v17 = __sincosf_stret(*(v15 - 2) * 0.5);
        v18 = __sincosf_stret(*(v15 - 1) * 0.5);
        v19 = *v15;
        v15 += 4;
        v20 = __sincosf_stret(v19 * 0.5);
        *(v16 - 2) = (float)((float)(v17.__cosval * v18.__sinval) * v20.__sinval)
                   + (float)((float)(v17.__sinval * v18.__cosval) * v20.__cosval);
        *(v16 - 1) = (float)((float)(v17.__sinval * v18.__cosval) * v20.__sinval)
                   + (float)((float)(v17.__cosval * v18.__sinval) * v20.__cosval);
        v21 = -(float)(v17.__sinval * v18.__sinval);
        *v16 = (float)(v20.__cosval * v21) + (float)((float)(v17.__cosval * v18.__cosval) * v20.__sinval);
        v16[1] = (float)(v20.__sinval * v21) + (float)((float)(v17.__cosval * v18.__cosval) * v20.__cosval);
        v16 += 4;
        if (a2 == ++v14)
          return;
      }
LABEL_33:
      re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, a5, a5);
      _os_crash();
      __break(1u);
      goto LABEL_34;
    case 2:
      if (!a2)
        return;
      v22 = 0;
      v23 = (float *)(a1 + 8);
      v24 = (float *)(a4 + 8);
      while (a5 != v22)
      {
        v25 = __sincosf_stret(*(v23 - 2) * 0.5);
        v26 = __sincosf_stret(*(v23 - 1) * 0.5);
        v27 = *v23;
        v23 += 4;
        v28 = __sincosf_stret(v27 * 0.5);
        *(v24 - 2) = (float)((float)(v25.__sinval * v26.__cosval) * v28.__cosval)
                   - (float)((float)(v25.__cosval * v26.__sinval) * v28.__sinval);
        *(v24 - 1) = (float)((float)(v25.__sinval * v26.__cosval) * v28.__sinval)
                   + (float)((float)(v25.__cosval * v26.__sinval) * v28.__cosval);
        *v24 = (float)((float)(v25.__sinval * v26.__sinval) * v28.__cosval)
             + (float)((float)(v25.__cosval * v26.__cosval) * v28.__sinval);
        v24[1] = (float)((float)(v25.__cosval * v26.__cosval) * v28.__cosval)
               - (float)((float)(v25.__sinval * v26.__sinval) * v28.__sinval);
        v24 += 4;
        if (a2 == ++v22)
          return;
      }
LABEL_34:
      re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, a5, a5);
      _os_crash();
      __break(1u);
      goto LABEL_35;
    case 3:
      if (!a2)
        return;
      v29 = 0;
      v30 = (float *)(a1 + 8);
      v31 = (float *)(a4 + 8);
      while (a5 != v29)
      {
        v32 = __sincosf_stret(*(v30 - 2) * 0.5);
        v33 = __sincosf_stret(*(v30 - 1) * 0.5);
        v34 = *v30;
        v30 += 4;
        v35 = __sincosf_stret(v34 * 0.5);
        *(v31 - 2) = (float)((float)(v32.__sinval * v33.__cosval) * v35.__cosval)
                   - (float)((float)(v32.__cosval * v33.__sinval) * v35.__sinval);
        *(v31 - 1) = (float)((float)(v32.__cosval * v33.__sinval) * v35.__cosval)
                   - (float)((float)(v32.__sinval * v33.__cosval) * v35.__sinval);
        *v31 = (float)((float)(v32.__sinval * v33.__sinval) * v35.__cosval)
             + (float)((float)(v32.__cosval * v33.__cosval) * v35.__sinval);
        v31[1] = (float)((float)(v32.__sinval * v33.__sinval) * v35.__sinval)
               + (float)((float)(v32.__cosval * v33.__cosval) * v35.__cosval);
        v31 += 4;
        if (a2 == ++v29)
          return;
      }
LABEL_35:
      re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, a5, a5);
      _os_crash();
      __break(1u);
      goto LABEL_36;
    case 4:
      if (!a2)
        return;
      v36 = 0;
      v37 = (float *)(a1 + 8);
      v38 = (float *)(a4 + 8);
      while (a5 != v36)
      {
        v39 = __sincosf_stret(*(v37 - 2) * 0.5);
        v40 = __sincosf_stret(*(v37 - 1) * 0.5);
        v41 = *v37;
        v37 += 4;
        v42 = __sincosf_stret(v41 * 0.5);
        *(v38 - 2) = (float)((float)(v39.__cosval * v40.__sinval) * v42.__sinval)
                   + (float)((float)(v39.__sinval * v40.__cosval) * v42.__cosval);
        *(v38 - 1) = (float)((float)(v39.__cosval * v40.__sinval) * v42.__cosval)
                   - (float)((float)(v39.__sinval * v40.__cosval) * v42.__sinval);
        *v38 = (float)((float)(v39.__cosval * v40.__cosval) * v42.__sinval)
             - (float)((float)(v39.__sinval * v40.__sinval) * v42.__cosval);
        v38[1] = (float)((float)(v39.__sinval * v40.__sinval) * v42.__sinval)
               + (float)((float)(v39.__cosval * v40.__cosval) * v42.__cosval);
        v38 += 4;
        if (a2 == ++v36)
          return;
      }
LABEL_36:
      re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, a5, a5);
      _os_crash();
      __break(1u);
      goto LABEL_37;
    case 5:
      if (!a2)
        return;
      v43 = 0;
      v44 = (float *)(a1 + 8);
      v45 = (float *)(a4 + 8);
      do
      {
        if (a5 == v43)
        {
LABEL_37:
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, a5, a5);
          _os_crash();
          __break(1u);
LABEL_38:
          re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Unknown rotation order", "!\"Unreachable code\"", "convertIntrinsicEulersToQuaternions", 554);
          _os_crash();
          __break(1u);
          JUMPOUT(0x225118244);
        }
        v46 = __sincosf_stret(*(v44 - 2) * 0.5);
        v47 = __sincosf_stret(*(v44 - 1) * 0.5);
        v48 = *v44;
        v44 += 4;
        v49 = __sincosf_stret(v48 * 0.5);
        *(v45 - 2) = (float)((float)(v46.__sinval * v47.__cosval) * v49.__cosval)
                   - (float)((float)(v46.__cosval * v47.__sinval) * v49.__sinval);
        *(v45 - 1) = (float)((float)(v46.__sinval * v47.__cosval) * v49.__sinval)
                   + (float)((float)(v46.__cosval * v47.__sinval) * v49.__cosval);
        *v45 = (float)((float)(v46.__cosval * v47.__cosval) * v49.__sinval)
             - (float)((float)(v46.__sinval * v47.__sinval) * v49.__cosval);
        v45[1] = (float)((float)(v46.__sinval * v47.__sinval) * v49.__sinval)
               + (float)((float)(v46.__cosval * v47.__cosval) * v49.__cosval);
        v45 += 4;
        ++v43;
      }
      while (a2 != v43);
      return;
    default:
      goto LABEL_38;
  }
}

void std::__function::__func<re::RigEvaluation::constructEvaluationCommands(re::Slice<char const*>,re::EvaluationTree *)::$_0,std::allocator<re::RigEvaluation::constructEvaluationCommands(re::Slice<char const*>,re::EvaluationTree *)::$_0>,void ()(re::internal::RigIKCallbackData *)>::~__func()
{
  JUMPOUT(0x2276933B8);
}

_QWORD *std::__function::__func<re::RigEvaluation::constructEvaluationCommands(re::Slice<char const*>,re::EvaluationTree *)::$_0,std::allocator<re::RigEvaluation::constructEvaluationCommands(re::Slice<char const*>,re::EvaluationTree *)::$_0>,void ()(re::internal::RigIKCallbackData *)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24ED25C40;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<re::RigEvaluation::constructEvaluationCommands(re::Slice<char const*>,re::EvaluationTree *)::$_0,std::allocator<re::RigEvaluation::constructEvaluationCommands(re::Slice<char const*>,re::EvaluationTree *)::$_0>,void ()(re::internal::RigIKCallbackData *)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24ED25C40;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<re::RigEvaluation::constructEvaluationCommands(re::Slice<char const*>,re::EvaluationTree *)::$_0,std::allocator<re::RigEvaluation::constructEvaluationCommands(re::Slice<char const*>,re::EvaluationTree *)::$_0>,void ()(re::internal::RigIKCallbackData *)>::operator()(uint64_t result, _QWORD **a2)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v2 = *a2;
  if (*a2)
  {
    v3 = *(_QWORD *)(result + 8);
    v4 = v2[18];
    if (v4)
    {
      if (v2[19])
      {
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, v2[20]);
        v2[19] = 0;
        v2[20] = 0;
      }
      v2[18] = 0;
    }
    v5 = v2[15];
    if (v5)
    {
      if (v2[16])
      {
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v5 + 40))(v5, v2[17]);
        v2[16] = 0;
        v2[17] = 0;
      }
      v2[15] = 0;
    }
    v6 = v2[12];
    if (v6)
    {
      if (v2[13])
      {
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v6 + 40))(v6, v2[14]);
        v2[13] = 0;
        v2[14] = 0;
      }
      v2[12] = 0;
    }
    re::FixedArray<re::FixedArray<float>>::deinit(v2 + 9);
    re::FixedArray<re::FixedArray<float>>::deinit(v2 + 6);
    v7 = v2[3];
    if (v7)
    {
      if (v2[4])
      {
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v7 + 40))(v7, v2[5]);
        v2[4] = 0;
        v2[5] = 0;
      }
      v2[3] = 0;
    }
    re::FixedArray<re::internal::RigIKCall>::deinit(v2);
    return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v3 + 40))(v3, v2);
  }
  return result;
}

uint64_t std::__function::__func<re::RigEvaluation::constructEvaluationCommands(re::Slice<char const*>,re::EvaluationTree *)::$_0,std::allocator<re::RigEvaluation::constructEvaluationCommands(re::Slice<char const*>,re::EvaluationTree *)::$_0>,void ()(re::internal::RigIKCallbackData *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::RigEvaluation::constructEvaluationCommands(re::Slice<char const*>,re::EvaluationTree *)::$_0,std::allocator<re::RigEvaluation::constructEvaluationCommands(re::Slice<char const*>,re::EvaluationTree *)::$_0>,void ()(re::internal::RigIKCallbackData *)>::target_type()
{
}

_QWORD *re::types::Ok<re::EvaluationRigState>::Ok(_QWORD *a1, uint64_t *a2)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v4 = std::unique_ptr<void,std::function<void ()(void *)>>::unique_ptr[abi:nn180100](a1, a2);
  v4[5] = 0;
  v4[6] = 0;
  v4[7] = 0;
  v5 = a2[6];
  v4[5] = a2[5];
  v4[6] = v5;
  a2[5] = 0;
  a2[6] = 0;
  v6 = v4[7];
  v4[7] = a2[7];
  a2[7] = v6;
  v4[8] = 0;
  v4[9] = 0;
  v4[10] = 0;
  v7 = a2[9];
  v4[8] = a2[8];
  v4[9] = v7;
  a2[8] = 0;
  a2[9] = 0;
  v8 = v4[10];
  v4[10] = a2[10];
  a2[10] = v8;
  re::RigGraphCompilation::RigGraphCompilation((uint64_t)(v4 + 11), (uint64_t)(a2 + 11));
  return a1;
}

uint64_t re::Result<re::EvaluationRigState,re::DetailedError>::Result(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  *(_BYTE *)a1 = 1;
  std::unique_ptr<void,std::function<void ()(void *)>>::unique_ptr[abi:nn180100]((_QWORD *)(a1 + 8), a2);
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  v4 = a2[6];
  *(_QWORD *)(a1 + 48) = a2[5];
  *(_QWORD *)(a1 + 56) = v4;
  a2[5] = 0;
  a2[6] = 0;
  v5 = *(_QWORD *)(a1 + 64);
  *(_QWORD *)(a1 + 64) = a2[7];
  a2[7] = v5;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  v6 = a2[9];
  *(_QWORD *)(a1 + 72) = a2[8];
  *(_QWORD *)(a1 + 80) = v6;
  a2[8] = 0;
  a2[9] = 0;
  v7 = *(_QWORD *)(a1 + 88);
  *(_QWORD *)(a1 + 88) = a2[10];
  a2[10] = v7;
  re::RigGraphCompilation::RigGraphCompilation(a1 + 96, (uint64_t)(a2 + 11));
  return a1;
}

void re::HashTable<char const*,unsigned long,re::RigEvaluation::HashString,re::RigEvaluation::EqualString,true,false>::addEmplace<unsigned long &>(uint64_t a1, unsigned int a2, unint64_t a3, _QWORD *a4, _QWORD *a5)
{
  uint64_t v9;
  int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;

  v9 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
    v9 = *(unsigned int *)(a1 + 32);
    v10 = v9;
    if ((_DWORD)v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<char const*,unsigned long,re::RigEvaluation::HashString,re::RigEvaluation::EqualString,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 32 * v9 + 8);
  }
  else
  {
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 32 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v11 + 32 * v9 + 8) = v12 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9) = a3;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 16) = *a4;
  v13 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 24) = *a5;
  *(_DWORD *)(v13 + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
}

void re::HashTable<char const*,unsigned long,re::RigEvaluation::HashString,re::RigEvaluation::EqualString,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  __int128 v7;
  unsigned int v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  int v12;
  uint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  signed int v22;
  _BYTE v23[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v23, 0, 36);
      *(_QWORD *)&v23[36] = 0x7FFFFFFFLL;
      re::HashTable<re::StringID,BOOL (*)(re::MutableSlice<re::Matrix4x4<float>>,re::Slice<unsigned int>,re::Slice<unsigned long>,re::Slice<unsigned long>,re::Slice<re::Vector3<float>>,void *),re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init((uint64_t)v23, v4, a2);
      v5 = *(_OWORD *)a1;
      *(_QWORD *)a1 = *(_QWORD *)v23;
      v6 = *(_QWORD *)(a1 + 16);
      v7 = *(_OWORD *)&v23[8];
      *(_OWORD *)v23 = v5;
      *(_QWORD *)&v23[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      v9 = *(_OWORD *)&v23[24];
      *(_OWORD *)&v23[24] = *(_OWORD *)(a1 + 24);
      v8 = *(_DWORD *)&v23[32];
      *(_OWORD *)(a1 + 24) = v9;
      v10 = v8;
      if (v8)
      {
        v11 = 0;
        v12 = DWORD1(v9);
        v13 = v7;
        v14 = (_QWORD *)(v6 + 16);
        do
        {
          if ((*(_DWORD *)(v14 - 1) & 0x80000000) != 0)
          {
            v15 = *(v14 - 2);
            v16 = *(unsigned int *)(a1 + 24);
            v17 = v15 % v16;
            v18 = *(unsigned int *)(a1 + 36);
            if ((_DWORD)v18 == 0x7FFFFFFF)
            {
              v18 = *(unsigned int *)(a1 + 32);
              v19 = v18;
              if ((_DWORD)v18 == (_DWORD)v16)
              {
                re::HashTable<char const*,unsigned long,re::RigEvaluation::HashString,re::RigEvaluation::EqualString,true,false>::setCapacity(a1, (2 * v12));
                v17 = v15 % *(unsigned int *)(a1 + 24);
                v19 = *(_DWORD *)(a1 + 32);
                v13 = *(_QWORD *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v19 + 1;
              v20 = *(_QWORD *)(a1 + 16);
              v21 = *(_DWORD *)(v20 + 32 * v18 + 8);
            }
            else
            {
              v20 = *(_QWORD *)(a1 + 16);
              v21 = *(_DWORD *)(v20 + 32 * v18 + 8);
              *(_DWORD *)(a1 + 36) = v21 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v20 + 32 * v18 + 8) = v21 | 0x80000000;
            *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v18 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v18 + 8) & 0x80000000 | *(_DWORD *)(v13 + 4 * v17);
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v18) = v15;
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v18 + 16) = *v14;
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v18 + 24) = v14[1];
            v13 = *(_QWORD *)(a1 + 8);
            *(_DWORD *)(v13 + 4 * v17) = v18;
            v12 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v12;
          }
          ++v11;
          v14 += 4;
        }
        while (v11 < v10);
      }
      re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)v23);
    }
  }
  else
  {
    if (a2)
      v22 = a2;
    else
      v22 = 3;
  }
}

double re::makeSkeletalPoseJointBindNode@<D0>(re *this@<X0>, const re::BindPoint *a2@<X1>, uint64_t a3@<X8>)
{
  __objc2_class_ro *v6;
  unsigned __int8 v7;
  __objc2_class_ro **p_info;
  uint64_t v9;
  unsigned __int8 v10;
  double v11;
  uint64_t v12;
  _QWORD *v13;
  double result;
  int v15;
  _OWORD v16[2];
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  if (!*((_QWORD *)this + 3))
    goto LABEL_7;
  v6 = *(__objc2_class_ro **)this;
  p_info = VideoSpillMapMetalSession.info;
  if ((v7 & 1) == 0)
  {
    p_info = (__objc2_class_ro **)(VideoSpillMapMetalSession + 32);
    if (v15)
    {
      re::introspect<re::SkeletalPose>(void)::info = re::internal::getOrCreateInfo((re::internal *)"SkeletalPose", (uint64_t (*)(re::internal *))re::allocInfo_SkeletalPose, (re::IntrospectionBase *(*)(void))re::initInfo_SkeletalPose, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::SkeletalPose>, 0);
      p_info = (__objc2_class_ro **)(VideoSpillMapMetalSession + 32);
    }
  }
  if (v6 == p_info[37] && (v9 = re::BindPoint::valueUntyped(this), *(_QWORD *)(v9 + 24) > (unint64_t)a2))
  {
    if ((v10 & 1) == 0)
    {
      if ((_DWORD)v9)
      {
        re::introspect<re::GenericSRT<float>>(void)::info = re::introspect_SRT(0);
      }
    }
    *(_QWORD *)a3 = re::introspect<re::GenericSRT<float>>(void)::info;
    *(_QWORD *)(a3 + 40) = 0;
    *(_QWORD *)(a3 + 16) = 0;
    *(_QWORD *)(a3 + 24) = 0;
    *(_DWORD *)(a3 + 32) = 0;
    *(_QWORD *)(a3 + 8) = 0;
    memset(v16, 0, sizeof(v16));
    re::DynamicArray<re::BindPoint::BindPointData>::add((_anonymous_namespace_ *)(a3 + 8), v16);
    v11 = re::BindPoint::BindPointData::deinit((re::BindPoint::BindPointData *)v16);
    v12 = *(_QWORD *)(a3 + 40) + 32 * *(_QWORD *)(a3 + 24);
    *(_QWORD *)(v12 - 32) = 0;
                                                      + 32))(v11);
    *v13 = &off_24ED25D18;
    v13[1] = *(_QWORD *)this;
    re::DynamicArray<re::BindPoint::BindPointData>::DynamicArray((uint64_t)(v13 + 2), (uint64_t *)this + 1);
    v13[7] = a2;
    *(_QWORD *)(v12 - 16) = v13;
  }
  else
  {
LABEL_7:
    *(_QWORD *)(a3 + 40) = 0;
    result = 0.0;
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_DWORD *)(a3 + 32) = 0;
  }
  return result;
}

__n128 re::EvaluationSkeletalPoseInputHandle::set(re::EvaluationSkeletalPoseInputHandle *this, const re::SkeletalPose *a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __n128 result;
  __int128 v11;

  if (*((_QWORD *)this + 1))
  {
    v2 = 0;
    v3 = 0;
    v4 = 0;
    do
    {
      if (*((_QWORD *)a2 + 3) <= v4)
      {
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_8:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      v5 = (_QWORD *)(*((_QWORD *)this + 2) + v3);
      v6 = *v5;
      v7 = v5[1];
      if (*(_QWORD *)(*v5 + 2736) <= v7)
        goto LABEL_8;
      v8 = *((_QWORD *)a2 + 4) + v2;
      v9 = *(_QWORD *)(v6 + 2744) + 48 * v7;
      result = *(__n128 *)v8;
      v11 = *(_OWORD *)(v8 + 32);
      *(_OWORD *)(v9 + 16) = *(_OWORD *)(v8 + 16);
      *(_OWORD *)(v9 + 32) = v11;
      *(__n128 *)v9 = result;
      ++v4;
      v3 += 16;
      v2 += 48;
    }
    while (v4 < *((_QWORD *)this + 1));
  }
  return result;
}

__n128 re::EvaluationSkeletalPoseOutputHandle::get(re::EvaluationSkeletalPoseOutputHandle *this, re::SkeletalPose *a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __n128 result;
  __int128 v11;

  if (*((_QWORD *)this + 1))
  {
    v2 = 0;
    v3 = 0;
    v4 = 0;
    do
    {
      if (*((_QWORD *)a2 + 3) <= v4)
      {
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_8:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      v5 = (_QWORD *)(*((_QWORD *)this + 2) + v3);
      v6 = *v5;
      v7 = v5[1];
      if (*(_QWORD *)(*v5 + 2952) <= v7)
        goto LABEL_8;
      v8 = *((_QWORD *)a2 + 4) + v2;
      v9 = *(_QWORD *)(v6 + 2960) + 48 * v7;
      result = *(__n128 *)v9;
      v11 = *(_OWORD *)(v9 + 32);
      *(_OWORD *)(v8 + 16) = *(_OWORD *)(v9 + 16);
      *(_OWORD *)(v8 + 32) = v11;
      *(__n128 *)v8 = result;
      ++v4;
      v3 += 16;
      v2 += 48;
    }
    while (v4 < *((_QWORD *)this + 1));
  }
  return result;
}

uint64_t *re::SkeletalPoseJointDefinition::SkeletalPoseJointDefinition(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v8;
  unint64_t *v9;
  unint64_t *v10;
  _anonymous_namespace_ *v11;

  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(_QWORD *)(v8 + 16) = a2;
  *(_QWORD *)v8 = &off_24ED25CD0;
  *(_QWORD *)(v8 + 24) = 0;
  v9 = (unint64_t *)(v8 + 24);
  *(_QWORD *)(v8 + 32) = &str_110;
  *(_OWORD *)(v8 + 40) = 0u;
  v10 = (unint64_t *)(v8 + 40);
  *(_OWORD *)(v8 + 56) = 0u;
  *(_OWORD *)(v8 + 72) = 0u;
  *(_OWORD *)(v8 + 88) = 0u;
  *(_OWORD *)(v8 + 104) = 0u;
  *(_OWORD *)(v8 + 120) = 0u;
  *(_OWORD *)(v8 + 136) = 0u;
  *(_OWORD *)(v8 + 152) = 0u;
  *(_DWORD *)(v8 + 168) = 0;
  *(_QWORD *)(v8 + 172) = 0x7FFFFFFFLL;
  *(_OWORD *)(v8 + 200) = 0u;
  *(_OWORD *)(v8 + 216) = 0u;
  *(_OWORD *)(v8 + 228) = 0u;
  *(_OWORD *)(v8 + 184) = 0u;
  v11 = (_anonymous_namespace_ *)(v8 + 184);
  *(_QWORD *)(v8 + 244) = 0x7FFFFFFFLL;
  re::FixedArray<re::StringID>::init<>((_QWORD *)(v8 + 184), a2, *(_QWORD *)(a3 + 8));
  re::FixedArray<re::StringID>::operator=(v11, a3);
  re::SkeletalPoseJointDefinition::buildJointNameMap((re::SkeletalPoseJointDefinition *)a1);
  if (a4 && a4[2])
  {
    re::StringID::operator=(v9, a4);
    re::FixedArray<re::StringID>::operator=(v10, (uint64_t)(a4 + 2));
    re::FixedArray<unsigned int>::operator=(a1 + 8, (uint64_t)(a4 + 5));
    re::FixedArray<re::GenericSRT<float>>::operator=(a1 + 11, (uint64_t)(a4 + 8));
    re::FixedArray<re::Matrix4x4<float>>::operator=(a1 + 14, (uint64_t)(a4 + 11));
    re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::operator=((uint64_t)(a1 + 17), (uint64_t)(a4 + 14));
  }
  return a1;
}

uint64_t re::SkeletalPoseJointDefinition::SkeletalPoseJointDefinition(uint64_t a1, _QWORD *a2, const StringID *a3)
{
  uint64_t v6;
  uint64_t v7;

  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(_QWORD *)a1 = &off_24ED25CD0;
  re::StringID::StringID((re::StringID *)(a1 + 24), a3);
  re::FixedArray<re::StringID>::FixedArray((unint64_t *)(a1 + 40), (uint64_t)&a3[1]);
  re::FixedArray<unsigned int>::FixedArray((uint64_t *)(a1 + 64), (uint64_t)&a3[2].var1);
  re::FixedArray<re::GenericSRT<float>>::FixedArray((_QWORD *)(a1 + 88), (uint64_t)&a3[4]);
  re::FixedArray<re::Matrix4x4<float>>::FixedArray((uint64_t *)(a1 + 112), (uint64_t)&a3[5].var1);
  re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::HashTable(a1 + 136, (uint64_t)&a3[7]);
  *(_QWORD *)(a1 + 184) = 0;
  *(_QWORD *)(a1 + 192) = 0;
  *(_QWORD *)(a1 + 200) = 0;
  v6 = a2[1];
  *(_QWORD *)(a1 + 184) = *a2;
  *(_QWORD *)(a1 + 192) = v6;
  *a2 = 0;
  a2[1] = 0;
  v7 = *(_QWORD *)(a1 + 200);
  *(_QWORD *)(a1 + 200) = a2[2];
  a2[2] = v7;
  *(_DWORD *)(a1 + 240) = 0;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_QWORD *)(a1 + 244) = 0x7FFFFFFFLL;
  re::SkeletalPoseJointDefinition::buildJointNameMap((re::SkeletalPoseJointDefinition *)a1);
  return a1;
}

void re::SkeletalPoseJointDefinition::buildJointNameMap(re::SkeletalPoseJointDefinition *this)
{
  char *v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t i;
  char *v6;
  const char *v7;
  StringID v8;
  unint64_t v9;

  v2 = (char *)this + 208;
  re::HashTable<re::StringID,unsigned long,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init((uint64_t)this + 208, *((_QWORD *)this + 23), 2 * *((_DWORD *)this + 48));
  *(_QWORD *)&v8.var0 = 0;
  if (*((_QWORD *)this + 24))
  {
    v3 = 0;
    do
    {
      re::HashTable<re::StringID,unsigned long,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::add((uint64_t)v2, (StringID *)(*((_QWORD *)this + 25) + 16 * v3), &v8);
      v3 = *(_QWORD *)&v8.var0 + 1;
      *(_QWORD *)&v8.var0 = v3;
      v4 = *((_QWORD *)this + 24);
    }
    while (v3 < v4);
    v9 = 0;
    if (v4)
    {
      for (i = 0; i < v4; v9 = i)
      {
        v6 = strrchr(*(char **)(*((_QWORD *)this + 25) + 16 * i + 8), 47);
        if (v6)
        {
          v7 = v6 + 1;
          *(_QWORD *)&v8.var0 = 0;
          v8.var1 = (char *)&str_110;
          re::HashTable<re::StringID,unsigned long,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::add((uint64_t)v2, &v8, &v9);
          re::StringID::destroyString((re::StringID *)&v8);
          i = v9;
          v4 = *((_QWORD *)this + 24);
        }
        ++i;
      }
    }
  }
}

void re::EvaluationSkeletalPose::createInputHandle(re::EvaluationSkeletalPose *this@<X0>, re::EvaluationContextManager *a2@<X1>, _QWORD *a3@<X8>)
{
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t *i;
  __n128 *v16;
  uint64_t v17;
  _QWORD v18[8];
  int v19;
  const char *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  unint64_t v24;
  __int16 v25;
  unint64_t v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  a3[2] = 0;
  v6 = *((_QWORD *)this + 1);
  a3[1] = v6;
  if (v6)
  {
    if (v6 >> 60)
    {
LABEL_14:
      re::internal::assertLog((re::internal *)6, v7, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 16, v6);
      _os_crash();
      __break(1u);
LABEL_15:
      re::internal::assertLog((re::internal *)4, v10, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
      _os_crash();
      __break(1u);
    }
    v8 = 2 * v6;
    a3[2] = v9;
    if (!v9)
      goto LABEL_15;
    v11 = v9;
    v12 = v9;
    if (v6 != 1)
    {
      bzero(v9, v8 * 8 - 16);
      v12 = &v11[v8 - 2];
    }
    *v12 = 0;
    v12[1] = 0;
  }
  else
  {
    v11 = 0;
  }
  if (*((_QWORD *)this + 1))
  {
    v13 = 0;
    v14 = 0;
    for (i = v11 + 1; ; i += 2)
    {
      v16 = (__n128 *)(*((_QWORD *)this + 2) + v13);
      v18[0] = 0x3F8000003F800000;
      v18[1] = 1065353216;
      v18[2] = 0;
      v18[3] = 0x3F80000000000000;
      v18[4] = 0;
      v18[5] = 0;
      re::DynamicArray<re::EvaluationSRT>::add((re::EvaluationContextManager *)((char *)a2 + 328), v16);
      re::DynamicArray<re::Matrix3x3<float>>::add((re::EvaluationContextManager *)((char *)a2 + 688), (uint64_t)v18);
      if (v6 == v14)
        break;
      v17 = *((_QWORD *)a2 + 43) - 1;
      *(i - 1) = (uint64_t)a2;
      *i = v17;
      ++v14;
      v13 += 24;
      if (v14 >= *((_QWORD *)this + 1))
        return;
    }
    v18[7] = 0;
    v30 = 0u;
    v31 = 0u;
    v28 = 0u;
    v29 = 0u;
    v27 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v19 = 136315906;
    v20 = "operator[]";
    v21 = 1024;
    v22 = 468;
    v23 = 2048;
    v24 = v6;
    v25 = 2048;
    v26 = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_14;
  }
}

void re::EvaluationSkeletalPose::createOutputHandle(re::EvaluationSkeletalPose *this@<X0>, re::EvaluationContextManager *a2@<X1>, uint64_t *a3@<X8>)
{
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  _QWORD *v11;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  v6 = *((_QWORD *)this + 1);
  if (*((_QWORD *)this + 1))
  {
    v7 = 0;
    v8 = 0;
    v9 = 0;
    do
    {
      re::DynamicArray<re::EvaluationSRT>::add((re::EvaluationContextManager *)((char *)a2 + 1768), (__n128 *)(*((_QWORD *)this + 2) + v7));
      if (a3[1] <= v9)
      {
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      v10 = *((_QWORD *)a2 + 223) - 1;
      v11 = (_QWORD *)(a3[2] + v8);
      *v11 = a2;
      v11[1] = v10;
      ++v9;
      v8 += 16;
      v7 += 24;
    }
    while (v9 < *((_QWORD *)this + 1));
  }
}

uint64_t re::SkeletalPose::SkeletalPose(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = &str_110;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_DWORD *)(a1 + 64) = 0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  re::FixedArray<re::GenericSRT<float>>::init<>((_QWORD *)(a1 + 16), a2, *(_QWORD *)(*a3 + 192));
  re::SharedPtr<re::SkeletalPoseJointDefinition>::reset((uint64_t *)(a1 + 80), *a3);
  return a1;
}

void re::SkeletalPose::init(uint64_t *a1, uint64_t *a2)
{
  re::SharedPtr<re::SkeletalPoseJointDefinition>::reset(a1 + 10, *a2);
}

void re::SkeletalPose::deinit(re::SkeletalPose *this)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *((_QWORD *)this + 2);
  if (v2)
  {
    if (*((_QWORD *)this + 3))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *((_QWORD *)this + 4));
      *((_QWORD *)this + 3) = 0;
      *((_QWORD *)this + 4) = 0;
    }
    *((_QWORD *)this + 2) = 0;
  }
  v3 = *((_QWORD *)this + 10);
  if (v3)
  {

    *((_QWORD *)this + 10) = 0;
  }
}

void re::SkeletalPose::reset(uint64_t *a1, uint64_t *a2)
{
  _QWORD *v3;
  _anonymous_namespace_ *v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t *v7;
  uint64_t *v8;
  uint64_t v9;

  v3 = a1 + 10;
  re::SharedPtr<re::SkeletalPoseJointDefinition>::reset(a1 + 10, *a2);
  v6 = a1 + 3;
  v5 = a1[3];
  if (v5 != *(_QWORD *)(a1[10] + 192))
  {
    v7 = a1 + 2;
    v8 = (uint64_t *)a1[2];
    if (v8)
    {
      v9 = a1[2];
      if (v5)
      {
LABEL_4:
        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v9 + 40))(v9, a1[4]);
        *v6 = 0;
        a1[4] = 0;
      }
    }
    else
    {
      v9 = *v7;
      if (!*v7)
      {
        goto LABEL_6;
      }
      if (*v6)
        goto LABEL_4;
    }
    *v7 = 0;
LABEL_6:
    re::FixedArray<re::GenericSRT<float>>::init<>(a1 + 2, (uint64_t)v8, *(_QWORD *)(*v3 + 192));
  }
}

uint64_t *re::allocInfo_SkeletalPose(re *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&_MergedGlobals_23);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&_MergedGlobals_23))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FA4C0, 0);
    *(uint64_t *)((char *)&qword_2540FA4D0 + 6) = 0;
    qword_2540FA4D0 = 0;
    qword_2540FA4E0 = 0;
    qword_2540FA4E8 = 0xFFFFFFFFLL;
    qword_2540FA4C0 = (uint64_t)&off_24ED7DAA8;
    qword_2540FA4F0 = (uint64_t)"SkeletalPose";
    dword_2540FA4F8 = 0;
    unk_2540FA500 = 0u;
    unk_2540FA510 = 0u;
    unk_2540FA520 = 0u;
    qword_2540FA530 = 0;
    __cxa_guard_release(&_MergedGlobals_23);
  }
  return &qword_2540FA4C0;
}

void re::initInfo_SkeletalPose(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t *v9;
  const re::IntrospectionBase *v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t *v13;
  const re::IntrospectionBase *v14;
  void *v15;
  uint64_t v16;
  __int128 v17;
  _QWORD v18[2];
  __int128 v19;

  v18[0] = 0x3D0B75488F9EC5D4;
  v18[1] = "SkeletalPose";
  re::StringID::destroyString((re::StringID *)v18);
  *((_OWORD *)this + 2) = v19;
  v4 = atomic_load((unsigned __int8 *)&qword_2540FA4A0);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_2540FA4A0);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      v7 = re::IntrospectionInfo<re::FixedArray<re::GenericSRT<float>>>::get(1);
      v8 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
      *(_DWORD *)v8 = 1;
      *(_QWORD *)(v8 + 8) = "jointTransforms";
      *(_QWORD *)(v8 + 16) = v7;
      *(_QWORD *)(v8 + 24) = 0;
      *(_QWORD *)(v8 + 32) = 0x1000000001;
      *(_DWORD *)(v8 + 40) = 0;
      *(_QWORD *)(v8 + 48) = 0;
      *(_QWORD *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_2540FA4A8 = v8;
      v9 = re::introspectionAllocator((re *)v8);
      v11 = re::IntrospectionInfo<re::DynamicArray<BOOL>>::get(1, v10);
      v12 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v9 + 32))(v9, 72, 8);
      *(_DWORD *)v12 = 1;
      *(_QWORD *)(v12 + 8) = "poseMask";
      *(_QWORD *)(v12 + 16) = v11;
      *(_QWORD *)(v12 + 24) = 0;
      *(_QWORD *)(v12 + 32) = 0x2800000002;
      *(_DWORD *)(v12 + 40) = 0;
      *(_QWORD *)(v12 + 48) = 0;
      *(_QWORD *)(v12 + 56) = 0;
      *(_DWORD *)(v12 + 64) = 0;
      qword_2540FA4B0 = v12;
      v13 = re::introspectionAllocator((re *)v12);
      v15 = re::IntrospectionInfo<re::StringID>::get(1, v14);
      v16 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v13 + 32))(v13, 72, 8);
      *(_DWORD *)v16 = 1;
      *(_QWORD *)(v16 + 8) = "name";
      *(_QWORD *)(v16 + 16) = v15;
      *(_QWORD *)(v16 + 24) = 0;
      *(_QWORD *)(v16 + 32) = 3;
      *(_DWORD *)(v16 + 40) = 0;
      *(_QWORD *)(v16 + 48) = 0;
      *(_QWORD *)(v16 + 56) = 0;
      *(_DWORD *)(v16 + 64) = 0;
      qword_2540FA4B8 = v16;
      __cxa_guard_release(&qword_2540FA4A0);
    }
  }
  *((_QWORD *)this + 2) = 0x5800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 3;
  *((_QWORD *)this + 8) = &qword_2540FA4A8;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::SkeletalPose>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::SkeletalPose>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::SkeletalPose>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::SkeletalPose>;
  re::IntrospectionRegistry::add(this, v3);
  v17 = v19;
}

uint64_t *re::IntrospectionInfo<re::DynamicArray<BOOL>>::get(int a1, const re::IntrospectionBase *a2)
{
  unsigned __int8 v3;
  int v4;
  re *v5;
  std::__shared_mutex_base *v6;
  re *v7;
  std::__shared_mutex_base *v8;
  uint64_t v10;
  int v11;
  re::IntrospectionRegistry *v12;
  const re::IntrospectionBase *v13;
  const char *v14;
  __int128 v15;
  __int128 v16;
  const char *v17;
  uint64_t v18[2];

  if ((v3 & 1) == 0
  {
    re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&re::IntrospectionInfo<re::DynamicArray<BOOL>>::get(BOOL)::info);
    re::IntrospectionInfo<re::DynamicArray<BOOL>>::get(BOOL)::info = (uint64_t)&off_24ED25DE8;
  }
  if (a1)
  {
    if (re::IntrospectionInfo<re::DynamicArray<BOOL>>::get(BOOL)::isInitialized)
      return &re::IntrospectionInfo<re::DynamicArray<BOOL>>::get(BOOL)::info;
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v16);
    v4 = re::IntrospectionInfo<re::DynamicArray<BOOL>>::get(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v16);
    if (v4)
      return &re::IntrospectionInfo<re::DynamicArray<BOOL>>::get(BOOL)::info;
    v6 = re::introspectionSharedMutex(v5);
    std::__shared_mutex_base::lock(v6);
  }
  v7 = (re *)re::introspect_BOOL((re *)1, a2);
  if (re::IntrospectionInfo<re::DynamicArray<BOOL>>::get(BOOL)::isInitialized)
  {
    if ((a1 & 1) == 0)
    {
LABEL_9:
      v8 = re::introspectionSharedMutex(v7);
      std::__shared_mutex_base::unlock(v8);
    }
  }
  else
  {
    v10 = (uint64_t)v7;
    re::IntrospectionInfo<re::DynamicArray<BOOL>>::get(BOOL)::isInitialized = 1;
    v11 = *((_DWORD *)v7 + 6);
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&re::IntrospectionInfo<re::DynamicArray<BOOL>>::get(BOOL)::info, 0);
    qword_2557FF600 = 0x2800000003;
    dword_2557FF608 = v11;
    word_2557FF60C = 0;
    *(_QWORD *)&xmmword_2557FF610 = 0;
    *((_QWORD *)&xmmword_2557FF610 + 1) = 0xFFFFFFFFLL;
    qword_2557FF620 = v10;
    unk_2557FF628 = 0;
    re::IntrospectionInfo<re::DynamicArray<BOOL>>::get(BOOL)::info = (uint64_t)&off_24ED25DE8;
    re::IntrospectionRegistry::add(v12, v13);
    re::getPrettyTypeName((re *)&re::IntrospectionInfo<re::DynamicArray<BOOL>>::get(BOOL)::info, (const re::IntrospectionBase *)&v16);
    if ((BYTE8(v16) & 1) != 0)
      v14 = v17;
    else
      v14 = (char *)&v16 + 9;
    if ((_QWORD)v16 && (BYTE8(v16) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v16 + 40))();
    v16 = *(_OWORD *)(v10 + 32);
    xmmword_2557FF610 = v15;
    re::StringID::destroyString((re::StringID *)v18);
    if ((a1 & 1) == 0)
      goto LABEL_9;
  }
  return &re::IntrospectionInfo<re::DynamicArray<BOOL>>::get(BOOL)::info;
}

double re::internal::defaultConstruct<re::SkeletalPose>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double result;

  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = &str_110;
  result = 0.0;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_DWORD *)(a3 + 64) = 0;
  *(_QWORD *)(a3 + 72) = 0;
  *(_QWORD *)(a3 + 80) = 0;
  return result;
}

void re::internal::defaultDestruct<re::SkeletalPose>(int a1, int a2, re::SkeletalPose *this)
{
  re::SkeletalPose::~SkeletalPose(this);
}

double re::internal::defaultConstructV2<re::SkeletalPose>(uint64_t a1)
{
  double result;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = &str_110;
  result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_DWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  return result;
}

uint64_t re::introspect_SkeletalPose(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"SkeletalPose", (uint64_t (*)(re::internal *))re::allocInfo_SkeletalPose, (re::IntrospectionBase *(*)(void))re::initInfo_SkeletalPose, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::SkeletalPose>, this);
}

_QWORD *re::AnimationValueTraits<re::SkeletalPose>::copy(_QWORD *result, _QWORD *a2)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  __int128 *v10;
  _OWORD *v11;
  __int128 v12;
  __int128 v13;

  v3 = result;
  v4 = result[10];
  if (v4 == a2[10])
    return re::FixedArray<re::GenericSRT<float>>::operator=(a2 + 2, (uint64_t)(result + 2));
  v5 = *(_QWORD *)(v4 + 192);
  if (v5)
  {
    v6 = 0;
    v7 = 0;
    v8 = 0;
    while (1)
    {
      v9 = v3[10];
      if (*(_QWORD *)(v9 + 192) <= v8)
        break;
      result = (_QWORD *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(a2[10] + 208, (_QWORD *)(*(_QWORD *)(v9 + 200) + v6));
      if (result)
      {
        if (v3[3] <= v8)
          goto LABEL_13;
        if (a2[3] <= *result)
          goto LABEL_14;
        v10 = (__int128 *)(v3[4] + v7);
        v11 = (_OWORD *)(a2[4] + 48 * *result);
        v12 = *v10;
        v13 = v10[2];
        v11[1] = v10[1];
        v11[2] = v13;
        *v11 = v12;
      }
      ++v8;
      v7 += 48;
      v6 += 16;
      if (v5 == v8)
        return result;
    }
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_13:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_14:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return result;
}

void re::AnimationValueTraits<re::SkeletalPose>::combine(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  unint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  unint64_t v15;
  _QWORD *v16;
  unint64_t *v17;
  unint64_t *v18;
  __int128 *v19;
  _OWORD *v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;
  unint64_t *v24;
  __int128 *v25;
  _OWORD *v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  const char *v38;
  __int16 v39;
  int v40;
  __int16 v41;
  _QWORD *v42;
  __int16 v43;
  unint64_t v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  uint64_t v50;

  v8 = a1;
  v50 = *MEMORY[0x24BDAC8D0];
  v9 = a1[10];
  if (v9 == a2[10])
  {
    v13 = *(_QWORD **)(v9 + 192);
    if (v9 == a3[10])
    {
      if (v13)
      {
        v32 = 0;
        v15 = 0;
        while (1)
        {
          v12 = v8[3];
          if (v12 <= v15)
            break;
          v12 = a2[3];
          if (v12 <= v15)
            goto LABEL_63;
          v12 = a3[3];
          if (v12 <= v15)
            goto LABEL_64;
          re::AnimationValueTraits<re::GenericSRT<float>>::combine((float32x4_t *)(v8[4] + v32), (float32x4_t *)(a2[4] + v32), (float32x4_t *)(a3[4] + v32));
          ++v15;
          v32 += 48;
          if (v13 == (_QWORD *)v15)
            return;
        }
LABEL_62:
        v33 = 0;
        v48 = 0u;
        v49 = 0u;
        v46 = 0u;
        v47 = 0u;
        v45 = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        v37 = 136315906;
        v38 = "operator[]";
        v39 = 1024;
        v40 = 476;
        v41 = 2048;
        v42 = (_QWORD *)v15;
        v43 = 2048;
        v44 = v12;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_63:
        v33 = 0;
        v48 = 0u;
        v49 = 0u;
        v46 = 0u;
        v47 = 0u;
        v45 = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        v37 = 136315906;
        v38 = "operator[]";
        v39 = 1024;
        v40 = 476;
        v41 = 2048;
        v42 = (_QWORD *)v15;
        v43 = 2048;
        v44 = v12;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_64:
        v33 = 0;
        v48 = 0u;
        v49 = 0u;
        v46 = 0u;
        v47 = 0u;
        v45 = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        v37 = 136315906;
        v38 = "operator[]";
        v39 = 1024;
        v40 = 468;
        v41 = 2048;
        v42 = (_QWORD *)v15;
        v43 = 2048;
        v44 = v12;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
    }
    else if (v13)
    {
      v29 = 0;
      v12 = 0;
      v15 = 0;
      v3 = 48;
      while (1)
      {
        v30 = v8[10];
        v4 = *(_QWORD *)(v30 + 192);
        if (v4 <= v15)
          goto LABEL_53;
        v31 = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(a3[10] + 208, (_QWORD *)(*(_QWORD *)(v30 + 200) + v29));
        if (v31)
        {
          v4 = v8[3];
          if (v4 <= v15)
            goto LABEL_55;
          v4 = a2[3];
          if (v4 <= v15)
            goto LABEL_56;
          v4 = *v31;
          v5 = a3[3];
          if (v5 <= *v31)
            goto LABEL_57;
          re::AnimationValueTraits<re::GenericSRT<float>>::combine((float32x4_t *)(v8[4] + v12), (float32x4_t *)(a2[4] + v12), (float32x4_t *)(a3[4] + 48 * v4));
        }
        ++v15;
        v12 += 48;
        v29 += 16;
        if (v13 == (_QWORD *)v15)
          return;
      }
    }
  }
  else
  {
    v10 = *(_QWORD *)(a2[10] + 192);
    v34 = 0;
    v35 = 0;
    v33 = 0;
    v11 = *(_QWORD **)(v8[10] + 192);
    if (v11)
    {
      v12 = 0;
      v3 = 0;
      v13 = 0;
      v5 = 48;
      while (1)
      {
        v14 = v8[10];
        v15 = *(_QWORD *)(v14 + 192);
        if (v15 <= (unint64_t)v13)
          break;
        v16 = (_QWORD *)(*(_QWORD *)(v14 + 200) + v12);
        v17 = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(a3[10] + 208, v16);
        if (v17)
        {
          v4 = *v17;
          v18 = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(a2[10] + 208, v16);
          if (v18)
          {
            v15 = v8[3];
            if (v15 <= (unint64_t)v13)
              goto LABEL_49;
            v15 = *v18;
            v5 = a2[3];
            if (v5 <= *v18)
              goto LABEL_50;
            v5 = a3[3];
            if (v5 <= v4)
              goto LABEL_51;
            v5 = 48;
            re::AnimationValueTraits<re::GenericSRT<float>>::combine((float32x4_t *)(v8[4] + v3), (float32x4_t *)(a2[4] + 48 * v15), (float32x4_t *)(a3[4] + 48 * v4));
            v4 = v34;
            if (v34 <= v15)
              goto LABEL_52;
            *(_BYTE *)(v35 + v15) = 1;
          }
          else
          {
            v15 = v8[3];
            if (v15 <= (unint64_t)v13)
              goto LABEL_58;
            v15 = a3[3];
            if (v15 <= v4)
              goto LABEL_59;
            v19 = (__int128 *)(v8[4] + v3);
            v20 = (_OWORD *)(a3[4] + 48 * v4);
            v21 = *v19;
            v22 = v19[2];
            v20[1] = v19[1];
            v20[2] = v22;
            *v20 = v21;
          }
        }
        v13 = (_QWORD *)((char *)v13 + 1);
        v3 += 48;
        v12 += 16;
        if (v11 == v13)
          goto LABEL_16;
      }
      v36 = 0;
      v48 = 0u;
      v49 = 0u;
      v46 = 0u;
      v47 = 0u;
      v45 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v37 = 136315906;
      v38 = "operator[]";
      v39 = 1024;
      v40 = 476;
      v41 = 2048;
      v42 = v13;
      v43 = 2048;
      v44 = v15;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_48;
    }
LABEL_16:
    v15 = *(_QWORD *)(a2[10] + 192);
    if (v15)
    {
      v13 = 0;
      v8 = 0;
      while (1)
      {
        v12 = v34;
        if (v34 <= (unint64_t)v8)
          break;
        if (!*((_BYTE *)v8 + v35))
        {
          v23 = a2[10];
          v12 = *(_QWORD *)(v23 + 192);
          if (v12 <= (unint64_t)v8)
            goto LABEL_54;
          v24 = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(a3[10] + 208, (_QWORD *)((char *)v13 + *(_QWORD *)(v23 + 200)));
          if (v24)
          {
            v12 = a2[3];
            if (v12 <= v15)
              goto LABEL_60;
            v12 = *v24;
            v3 = a3[3];
            if (v3 <= *v24)
              goto LABEL_61;
            v25 = (__int128 *)(a2[4] + 48 * v15);
            v26 = (_OWORD *)(a3[4] + 48 * v12);
            v27 = *v25;
            v28 = v25[2];
            v26[1] = v25[1];
            v26[2] = v28;
            *v26 = v27;
          }
        }
        v8 = (_QWORD *)((char *)v8 + 1);
        v13 += 2;
        if ((_QWORD *)v15 == v8)
          goto LABEL_26;
      }
LABEL_48:
      v36 = 0;
      v48 = 0u;
      v49 = 0u;
      v46 = 0u;
      v47 = 0u;
      v45 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v37 = 136315906;
      v38 = "operator[]";
      v39 = 1024;
      v40 = 468;
      v41 = 2048;
      v42 = v8;
      v43 = 2048;
      v44 = v12;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_49:
      v36 = 0;
      v48 = 0u;
      v49 = 0u;
      v46 = 0u;
      v47 = 0u;
      v45 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v37 = 136315906;
      v38 = "operator[]";
      v39 = 1024;
      v40 = 476;
      v41 = 2048;
      v42 = v13;
      v43 = 2048;
      v44 = v15;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_50:
      v36 = 0;
      v48 = 0u;
      v49 = 0u;
      v46 = 0u;
      v47 = 0u;
      v45 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v37 = 136315906;
      v38 = "operator[]";
      v39 = 1024;
      v40 = 476;
      v41 = 2048;
      v42 = (_QWORD *)v15;
      v43 = 2048;
      v44 = v5;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_51:
      v36 = 0;
      v48 = 0u;
      v49 = 0u;
      v46 = 0u;
      v47 = 0u;
      v45 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v37 = 136315906;
      v38 = "operator[]";
      v39 = 1024;
      v40 = 468;
      v41 = 2048;
      v42 = (_QWORD *)v4;
      v43 = 2048;
      v44 = v5;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_52:
      v36 = 0;
      v48 = 0u;
      v49 = 0u;
      v46 = 0u;
      v47 = 0u;
      v45 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v37 = 136315906;
      v38 = "operator[]";
      v39 = 1024;
      v40 = 468;
      v41 = 2048;
      v42 = (_QWORD *)v15;
      v43 = 2048;
      v44 = v4;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_53:
      v33 = 0;
      v48 = 0u;
      v49 = 0u;
      v46 = 0u;
      v47 = 0u;
      v45 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v37 = 136315906;
      v38 = "operator[]";
      v39 = 1024;
      v40 = 476;
      v41 = 2048;
      v42 = (_QWORD *)v15;
      v43 = 2048;
      v44 = v4;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_54:
      v36 = 0;
      v48 = 0u;
      v49 = 0u;
      v46 = 0u;
      v47 = 0u;
      v45 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v37 = 136315906;
      v38 = "operator[]";
      v39 = 1024;
      v40 = 476;
      v41 = 2048;
      v42 = v8;
      v43 = 2048;
      v44 = v12;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_55:
      v33 = 0;
      v48 = 0u;
      v49 = 0u;
      v46 = 0u;
      v47 = 0u;
      v45 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v37 = 136315906;
      v38 = "operator[]";
      v39 = 1024;
      v40 = 476;
      v41 = 2048;
      v42 = (_QWORD *)v15;
      v43 = 2048;
      v44 = v4;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_56:
      v33 = 0;
      v48 = 0u;
      v49 = 0u;
      v46 = 0u;
      v47 = 0u;
      v45 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v37 = 136315906;
      v38 = "operator[]";
      v39 = 1024;
      v40 = 476;
      v41 = 2048;
      v42 = (_QWORD *)v15;
      v43 = 2048;
      v44 = v4;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_57:
      v33 = 0;
      v48 = 0u;
      v49 = 0u;
      v46 = 0u;
      v47 = 0u;
      v45 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v37 = 136315906;
      v38 = "operator[]";
      v39 = 1024;
      v40 = 468;
      v41 = 2048;
      v42 = (_QWORD *)v4;
      v43 = 2048;
      v44 = v5;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_58:
      v36 = 0;
      v48 = 0u;
      v49 = 0u;
      v46 = 0u;
      v47 = 0u;
      v45 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v37 = 136315906;
      v38 = "operator[]";
      v39 = 1024;
      v40 = 476;
      v41 = 2048;
      v42 = v13;
      v43 = 2048;
      v44 = v15;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_59:
      v36 = 0;
      v48 = 0u;
      v49 = 0u;
      v46 = 0u;
      v47 = 0u;
      v45 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v37 = 136315906;
      v38 = "operator[]";
      v39 = 1024;
      v40 = 468;
      v41 = 2048;
      v42 = (_QWORD *)v4;
      v43 = 2048;
      v44 = v15;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_60:
      v36 = 0;
      v48 = 0u;
      v49 = 0u;
      v46 = 0u;
      v47 = 0u;
      v45 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v37 = 136315906;
      v38 = "operator[]";
      v39 = 1024;
      v40 = 476;
      v41 = 2048;
      v42 = (_QWORD *)v15;
      v43 = 2048;
      v44 = v12;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_61:
      v36 = 0;
      v48 = 0u;
      v49 = 0u;
      v46 = 0u;
      v47 = 0u;
      v45 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v37 = 136315906;
      v38 = "operator[]";
      v39 = 1024;
      v40 = 468;
      v41 = 2048;
      v42 = (_QWORD *)v12;
      v43 = 2048;
      v44 = v3;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_62;
    }
LABEL_26:
    if (v33)
    {
      if (v34)
        (*(void (**)(void))(*(_QWORD *)v33 + 40))();
    }
  }
}

_QWORD *re::AnimationValueTraits<re::SkeletalPose>::invert(_QWORD *result, _QWORD *a2)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v14;
  float32x4_t *v15;
  uint64_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  int32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  int32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  int32x4_t v26;
  uint64_t v27;
  unint64_t v28;
  float32x4_t *v30;
  uint64_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  int32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  int32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  int32x4_t v41;
  float32x4_t v42;

  v3 = result;
  v4 = result[10];
  v5 = *(_QWORD *)(v4 + 192);
  if (v4 == a2[10])
  {
    if (v5)
    {
      v27 = 0;
      v28 = 0;
      __asm { FMOV            V0.4S, #1.0 }
      while (result[3] > v28)
      {
        if (a2[3] <= v28)
          goto LABEL_21;
        v30 = (float32x4_t *)(result[4] + v27);
        v31 = a2[4] + v27;
        v32 = v30[1];
        v33 = v30[2];
        v34 = vdivq_f32(_Q0, *v30);
        v35 = (int32x4_t)vnegq_f32(v32);
        v36 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v35, v35), (int8x16_t)v35, 0xCuLL);
        v35.i32[3] = v32.i32[3];
        v37 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v33, (int32x4_t)v33), (int8x16_t)v33, 0xCuLL), v32), v33, v36);
        v38 = (int32x4_t)vaddq_f32(v37, v37);
        v39 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v38, v38), (int8x16_t)v38, 0xCuLL);
        v40 = vaddq_f32(v33, vmulq_laneq_f32(v39, v32, 3));
        v41 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v39, (int32x4_t)v39), (int8x16_t)v39, 0xCuLL), v32), v39, v36);
        *(float32x4_t *)v31 = v34;
        *(int32x4_t *)(v31 + 16) = v35;
        *(float32x4_t *)(v31 + 32) = vmulq_f32(vaddq_f32(v40, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v41, v41), (int8x16_t)v41, 0xCuLL)), vnegq_f32(v34));
        ++v28;
        v27 += 48;
        if (v5 == v28)
          return result;
      }
LABEL_20:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_21:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
  else if (v5)
  {
    v6 = 0;
    v7 = 0;
    v8 = 0;
    __asm { FMOV            V0.4S, #1.0 }
    v42 = _Q0;
    while (1)
    {
      v14 = v3[10];
      if (*(_QWORD *)(v14 + 192) <= v8)
        break;
      result = (_QWORD *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(a2[10] + 208, (_QWORD *)(*(_QWORD *)(v14 + 200) + v6));
      if (result)
      {
        if (v3[3] <= v8)
          goto LABEL_18;
        if (a2[3] <= *result)
          goto LABEL_19;
        v15 = (float32x4_t *)(v3[4] + v7);
        v16 = a2[4] + 48 * *result;
        v17 = v15[1];
        v18 = v15[2];
        v19 = vdivq_f32(v42, *v15);
        v20 = (int32x4_t)vnegq_f32(v17);
        v21 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v20, v20), (int8x16_t)v20, 0xCuLL);
        v20.i32[3] = v17.i32[3];
        v22 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v18, (int32x4_t)v18), (int8x16_t)v18, 0xCuLL), v17), v18, v21);
        v23 = (int32x4_t)vaddq_f32(v22, v22);
        v24 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v23, v23), (int8x16_t)v23, 0xCuLL);
        v25 = vaddq_f32(v18, vmulq_laneq_f32(v24, v17, 3));
        v26 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v24, (int32x4_t)v24), (int8x16_t)v24, 0xCuLL), v17), v24, v21);
        *(float32x4_t *)v16 = v19;
        *(int32x4_t *)(v16 + 16) = v20;
        *(float32x4_t *)(v16 + 32) = vmulq_f32(vaddq_f32(v25, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v26, v26), (int8x16_t)v26, 0xCuLL)), vnegq_f32(v19));
      }
      ++v8;
      v7 += 48;
      v6 += 16;
      if (v5 == v8)
        return result;
    }
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_18:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_19:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_20;
  }
  return result;
}

void re::AnimationValueTraits<re::SkeletalPose>::interpolate(_QWORD *a1, _QWORD *a2, _QWORD *a3, float a4)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  _QWORD *v18;
  unint64_t *v19;
  unint64_t *v20;
  float32x4_t *v21;
  float32x4_t v22;
  float32x4_t v23;
  uint64_t v24;
  float32x4_t *v25;
  float32x4_t v26;
  float32x4_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t *v30;
  float32x4_t *v31;
  float32x4_t v32;
  float32x4_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t *v36;
  float32x4_t *v37;
  float32x4_t v38;
  float32x4_t v39;
  uint64_t v40;
  float32x4_t *v41;
  float32x4_t v42;
  float32x4_t v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t v46;
  uint64_t v47;
  _BYTE v48[40];
  uint64_t v49;
  _BYTE v50[12];
  __int16 v51;
  int v52;
  __int16 v53;
  _QWORD *v54;
  __int16 v55;
  unint64_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  __int128 v60;
  __int128 v61;
  uint64_t v62;

  v10 = a1;
  v62 = *MEMORY[0x24BDAC8D0];
  v11 = a1[10];
  if (v11 == a2[10])
  {
    v15 = *(_QWORD *)(v11 + 192);
    if (v11 == a3[10])
    {
      if (v15)
      {
        v40 = 0;
        v17 = 0;
        while (1)
        {
          v14 = v10[3];
          if (v14 <= v17)
            break;
          v14 = a2[3];
          if (v14 <= v17)
            goto LABEL_63;
          v14 = a3[3];
          if (v14 <= v17)
            goto LABEL_64;
          v41 = (float32x4_t *)(a3[4] + v40);
          re::lerp<float>((float32x4_t *)(v10[4] + v40), (float32x4_t *)(a2[4] + v40), &v57, a4);
          v42 = v57;
          v43 = v59;
          v41[1] = v58;
          v41[2] = v43;
          *v41 = v42;
          ++v17;
          v40 += 48;
          if (v15 == v17)
            return;
        }
LABEL_62:
        *(_QWORD *)v50 = 0;
        v60 = 0u;
        v61 = 0u;
        v58 = 0u;
        v59 = 0u;
        v57 = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        *(_DWORD *)v48 = 136315906;
        *(_QWORD *)&v48[4] = "operator[]";
        *(_WORD *)&v48[12] = 1024;
        *(_DWORD *)&v48[14] = 476;
        *(_WORD *)&v48[18] = 2048;
        *(_QWORD *)&v48[20] = v17;
        *(_WORD *)&v48[28] = 2048;
        *(_QWORD *)&v48[30] = v14;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_63:
        *(_QWORD *)v50 = 0;
        v60 = 0u;
        v61 = 0u;
        v58 = 0u;
        v59 = 0u;
        v57 = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        *(_DWORD *)v48 = 136315906;
        *(_QWORD *)&v48[4] = "operator[]";
        *(_WORD *)&v48[12] = 1024;
        *(_DWORD *)&v48[14] = 476;
        *(_WORD *)&v48[18] = 2048;
        *(_QWORD *)&v48[20] = v17;
        *(_WORD *)&v48[28] = 2048;
        *(_QWORD *)&v48[30] = v14;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_64:
        *(_QWORD *)v50 = 0;
        v60 = 0u;
        v61 = 0u;
        v58 = 0u;
        v59 = 0u;
        v57 = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        *(_DWORD *)v48 = 136315906;
        *(_QWORD *)&v48[4] = "operator[]";
        *(_WORD *)&v48[12] = 1024;
        *(_DWORD *)&v48[14] = 468;
        *(_WORD *)&v48[18] = 2048;
        *(_QWORD *)&v48[20] = v17;
        *(_WORD *)&v48[28] = 2048;
        *(_QWORD *)&v48[30] = v14;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
    }
    else if (v15)
    {
      v34 = 0;
      v14 = 0;
      v17 = 0;
      v4 = 48;
      while (1)
      {
        v35 = v10[10];
        v5 = *(_QWORD *)(v35 + 192);
        if (v5 <= v17)
          goto LABEL_53;
        v36 = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(a3[10] + 208, (_QWORD *)(*(_QWORD *)(v35 + 200) + v34));
        if (v36)
        {
          v5 = v10[3];
          if (v5 <= v17)
            goto LABEL_55;
          v5 = a2[3];
          if (v5 <= v17)
            goto LABEL_56;
          v5 = *v36;
          v6 = a3[3];
          if (v6 <= *v36)
            goto LABEL_57;
          v37 = (float32x4_t *)(a3[4] + 48 * v5);
          re::lerp<float>((float32x4_t *)(v10[4] + v14), (float32x4_t *)(a2[4] + v14), &v57, a4);
          v38 = v57;
          v39 = v59;
          v37[1] = v58;
          v37[2] = v39;
          *v37 = v38;
        }
        ++v17;
        v14 += 48;
        v34 += 16;
        if (v15 == v17)
          return;
      }
    }
  }
  else
  {
    v12 = *(_QWORD *)(a2[10] + 192);
    v45 = 0;
    v46 = 0;
    v44 = 0;
    v13 = *(_QWORD *)(v10[10] + 192);
    if (v13)
    {
      v14 = 0;
      v4 = 0;
      v15 = 0;
      v6 = 48;
      while (1)
      {
        v16 = v10[10];
        v17 = *(_QWORD *)(v16 + 192);
        if (v17 <= v15)
          break;
        v18 = (_QWORD *)(*(_QWORD *)(v16 + 200) + v14);
        v19 = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(a3[10] + 208, v18);
        if (v19)
        {
          v5 = *v19;
          v20 = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(a2[10] + 208, v18);
          if (v20)
          {
            v17 = v10[3];
            if (v17 <= v15)
              goto LABEL_49;
            v17 = *v20;
            v6 = a2[3];
            if (v6 <= *v20)
              goto LABEL_50;
            v6 = a3[3];
            if (v6 <= v5)
              goto LABEL_51;
            v6 = 48;
            v21 = (float32x4_t *)(a3[4] + 48 * v5);
            re::lerp<float>((float32x4_t *)(v10[4] + v4), (float32x4_t *)(a2[4] + 48 * v17), &v57, a4);
            v22 = v57;
            v23 = v59;
            v21[1] = v58;
            v21[2] = v23;
            *v21 = v22;
            v5 = v45;
            if (v45 <= v17)
              goto LABEL_52;
            *(_BYTE *)(v46 + v17) = 1;
          }
          else
          {
            v17 = v10[3];
            if (v17 <= v15)
              goto LABEL_58;
            v24 = v10[4];
            *(_QWORD *)&v48[8] = 1065353216;
            *(_QWORD *)&v48[16] = 0;
            *(_QWORD *)v48 = 0x3F8000003F800000;
            *(_QWORD *)&v48[24] = 0x3F80000000000000;
            *(_QWORD *)&v48[32] = 0;
            v49 = 0;
            v17 = a3[3];
            if (v17 <= v5)
              goto LABEL_59;
            v25 = (float32x4_t *)(a3[4] + 48 * v5);
            re::lerp<float>((float32x4_t *)(v24 + v4), (float32x4_t *)v48, &v57, a4);
            v26 = v57;
            v27 = v59;
            v25[1] = v58;
            v25[2] = v27;
            *v25 = v26;
          }
        }
        ++v15;
        v4 += 48;
        v14 += 16;
        if (v13 == v15)
          goto LABEL_16;
      }
      *(_QWORD *)v50 = 0;
      v60 = 0u;
      v61 = 0u;
      v58 = 0u;
      v59 = 0u;
      v57 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v48 = 136315906;
      *(_QWORD *)&v48[4] = "operator[]";
      *(_WORD *)&v48[12] = 1024;
      *(_DWORD *)&v48[14] = 476;
      *(_WORD *)&v48[18] = 2048;
      *(_QWORD *)&v48[20] = v15;
      *(_WORD *)&v48[28] = 2048;
      *(_QWORD *)&v48[30] = v17;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_48;
    }
LABEL_16:
    v17 = *(_QWORD *)(a2[10] + 192);
    if (v17)
    {
      v15 = 0;
      v28 = 0;
      v10 = 0;
      v5 = 0x3F80000000000000;
      v6 = 48;
      while (1)
      {
        v14 = v45;
        if (v45 <= (unint64_t)v10)
          break;
        if (!*((_BYTE *)v10 + v46))
        {
          v29 = a2[10];
          v14 = *(_QWORD *)(v29 + 192);
          if (v14 <= (unint64_t)v10)
            goto LABEL_54;
          v30 = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(a3[10] + 208, (_QWORD *)(*(_QWORD *)(v29 + 200) + v15));
          if (v30)
          {
            v14 = *v30;
            *(_QWORD *)&v48[8] = 1065353216;
            *(_QWORD *)&v48[16] = 0;
            *(_QWORD *)v48 = 0x3F8000003F800000;
            *(_QWORD *)&v48[24] = 0x3F80000000000000;
            *(_QWORD *)&v48[32] = 0;
            v49 = 0;
            v4 = a2[3];
            if (v4 <= (unint64_t)v10)
              goto LABEL_60;
            v4 = a3[3];
            if (v4 <= v14)
              goto LABEL_61;
            v31 = (float32x4_t *)(a3[4] + 48 * v14);
            re::lerp<float>((float32x4_t *)v48, (float32x4_t *)(a2[4] + v28), &v57, a4);
            v32 = v57;
            v33 = v59;
            v31[1] = v58;
            v31[2] = v33;
            *v31 = v32;
          }
        }
        v10 = (_QWORD *)((char *)v10 + 1);
        v28 += 48;
        v15 += 16;
        if ((_QWORD *)v17 == v10)
          goto LABEL_26;
      }
LABEL_48:
      *(_QWORD *)v50 = 0;
      v60 = 0u;
      v61 = 0u;
      v58 = 0u;
      v59 = 0u;
      v57 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v48 = 136315906;
      *(_QWORD *)&v48[4] = "operator[]";
      *(_WORD *)&v48[12] = 1024;
      *(_DWORD *)&v48[14] = 468;
      *(_WORD *)&v48[18] = 2048;
      *(_QWORD *)&v48[20] = v10;
      *(_WORD *)&v48[28] = 2048;
      *(_QWORD *)&v48[30] = v14;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_49:
      *(_QWORD *)v50 = 0;
      v60 = 0u;
      v61 = 0u;
      v58 = 0u;
      v59 = 0u;
      v57 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v48 = 136315906;
      *(_QWORD *)&v48[4] = "operator[]";
      *(_WORD *)&v48[12] = 1024;
      *(_DWORD *)&v48[14] = 476;
      *(_WORD *)&v48[18] = 2048;
      *(_QWORD *)&v48[20] = v15;
      *(_WORD *)&v48[28] = 2048;
      *(_QWORD *)&v48[30] = v17;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_50:
      *(_QWORD *)v50 = 0;
      v60 = 0u;
      v61 = 0u;
      v58 = 0u;
      v59 = 0u;
      v57 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v48 = 136315906;
      *(_QWORD *)&v48[4] = "operator[]";
      *(_WORD *)&v48[12] = 1024;
      *(_DWORD *)&v48[14] = 476;
      *(_WORD *)&v48[18] = 2048;
      *(_QWORD *)&v48[20] = v17;
      *(_WORD *)&v48[28] = 2048;
      *(_QWORD *)&v48[30] = v6;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_51:
      *(_QWORD *)v50 = 0;
      v60 = 0u;
      v61 = 0u;
      v58 = 0u;
      v59 = 0u;
      v57 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v48 = 136315906;
      *(_QWORD *)&v48[4] = "operator[]";
      *(_WORD *)&v48[12] = 1024;
      *(_DWORD *)&v48[14] = 468;
      *(_WORD *)&v48[18] = 2048;
      *(_QWORD *)&v48[20] = v5;
      *(_WORD *)&v48[28] = 2048;
      *(_QWORD *)&v48[30] = v6;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_52:
      *(_QWORD *)v50 = 0;
      v60 = 0u;
      v61 = 0u;
      v58 = 0u;
      v59 = 0u;
      v57 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v48 = 136315906;
      *(_QWORD *)&v48[4] = "operator[]";
      *(_WORD *)&v48[12] = 1024;
      *(_DWORD *)&v48[14] = 468;
      *(_WORD *)&v48[18] = 2048;
      *(_QWORD *)&v48[20] = v17;
      *(_WORD *)&v48[28] = 2048;
      *(_QWORD *)&v48[30] = v5;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_53:
      *(_QWORD *)v50 = 0;
      v60 = 0u;
      v61 = 0u;
      v58 = 0u;
      v59 = 0u;
      v57 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v48 = 136315906;
      *(_QWORD *)&v48[4] = "operator[]";
      *(_WORD *)&v48[12] = 1024;
      *(_DWORD *)&v48[14] = 476;
      *(_WORD *)&v48[18] = 2048;
      *(_QWORD *)&v48[20] = v17;
      *(_WORD *)&v48[28] = 2048;
      *(_QWORD *)&v48[30] = v5;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_54:
      *(_QWORD *)v50 = 0;
      v60 = 0u;
      v61 = 0u;
      v58 = 0u;
      v59 = 0u;
      v57 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v48 = 136315906;
      *(_QWORD *)&v48[4] = "operator[]";
      *(_WORD *)&v48[12] = 1024;
      *(_DWORD *)&v48[14] = 476;
      *(_WORD *)&v48[18] = 2048;
      *(_QWORD *)&v48[20] = v10;
      *(_WORD *)&v48[28] = 2048;
      *(_QWORD *)&v48[30] = v14;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_55:
      *(_QWORD *)v50 = 0;
      v60 = 0u;
      v61 = 0u;
      v58 = 0u;
      v59 = 0u;
      v57 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v48 = 136315906;
      *(_QWORD *)&v48[4] = "operator[]";
      *(_WORD *)&v48[12] = 1024;
      *(_DWORD *)&v48[14] = 476;
      *(_WORD *)&v48[18] = 2048;
      *(_QWORD *)&v48[20] = v17;
      *(_WORD *)&v48[28] = 2048;
      *(_QWORD *)&v48[30] = v5;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_56:
      *(_QWORD *)v50 = 0;
      v60 = 0u;
      v61 = 0u;
      v58 = 0u;
      v59 = 0u;
      v57 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v48 = 136315906;
      *(_QWORD *)&v48[4] = "operator[]";
      *(_WORD *)&v48[12] = 1024;
      *(_DWORD *)&v48[14] = 476;
      *(_WORD *)&v48[18] = 2048;
      *(_QWORD *)&v48[20] = v17;
      *(_WORD *)&v48[28] = 2048;
      *(_QWORD *)&v48[30] = v5;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_57:
      *(_QWORD *)v50 = 0;
      v60 = 0u;
      v61 = 0u;
      v58 = 0u;
      v59 = 0u;
      v57 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v48 = 136315906;
      *(_QWORD *)&v48[4] = "operator[]";
      *(_WORD *)&v48[12] = 1024;
      *(_DWORD *)&v48[14] = 468;
      *(_WORD *)&v48[18] = 2048;
      *(_QWORD *)&v48[20] = v5;
      *(_WORD *)&v48[28] = 2048;
      *(_QWORD *)&v48[30] = v6;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_58:
      *(_QWORD *)v50 = 0;
      v60 = 0u;
      v61 = 0u;
      v58 = 0u;
      v59 = 0u;
      v57 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v48 = 136315906;
      *(_QWORD *)&v48[4] = "operator[]";
      *(_WORD *)&v48[12] = 1024;
      *(_DWORD *)&v48[14] = 476;
      *(_WORD *)&v48[18] = 2048;
      *(_QWORD *)&v48[20] = v15;
      *(_WORD *)&v48[28] = 2048;
      *(_QWORD *)&v48[30] = v17;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_59:
      v47 = 0;
      v60 = 0u;
      v61 = 0u;
      v58 = 0u;
      v59 = 0u;
      v57 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v50 = 136315906;
      *(_QWORD *)&v50[4] = "operator[]";
      v51 = 1024;
      v52 = 468;
      v53 = 2048;
      v54 = (_QWORD *)v5;
      v55 = 2048;
      v56 = v17;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_60:
      v47 = 0;
      v60 = 0u;
      v61 = 0u;
      v58 = 0u;
      v59 = 0u;
      v57 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v50 = 136315906;
      *(_QWORD *)&v50[4] = "operator[]";
      v51 = 1024;
      v52 = 476;
      v53 = 2048;
      v54 = v10;
      v55 = 2048;
      v56 = v4;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_61:
      v47 = 0;
      v60 = 0u;
      v61 = 0u;
      v58 = 0u;
      v59 = 0u;
      v57 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v50 = 136315906;
      *(_QWORD *)&v50[4] = "operator[]";
      v51 = 1024;
      v52 = 468;
      v53 = 2048;
      v54 = (_QWORD *)v14;
      v55 = 2048;
      v56 = v4;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_62;
    }
LABEL_26:
    if (v44)
    {
      if (v45)
        (*(void (**)(void))(*(_QWORD *)v44 + 40))();
    }
  }
}

uint64_t re::FixedArray<re::GenericSRT<float>>::slice(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v4;
  uint64_t v6;
  __int128 v7;

  v4 = *(_QWORD *)(a1 + 8);
  if (v4 + 1 <= a2)
  {
    v6 = 0;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    LODWORD(v7) = 136315906;
    *(_QWORD *)((char *)&v7 + 4) = "slice";
    WORD6(v7) = 1024;
    HIWORD(v7) = 502;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_6;
  }
  if (__CFADD__(a2, a3))
  {
LABEL_6:
    re::internal::assertLog((re::internal *)7, a2, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::slice(size_t,size_t). index, %zu, count = %zu, array size = %zu", "!overflow", "slice", 508, a2, a3, v4, v6, v7);
    _os_crash();
    __break(1u);
LABEL_7:
    re::internal::assertLog((re::internal *)7, a2, "assertion failure: '%s' (%s:line %i) Invalid count. index = %zu, count = %zu, array size = %zu", "endIndexExclusive <= m_size", "slice", 512, a2, a3, v4);
    _os_crash();
    __break(1u);
  }
  if (a2 + a3 > v4)
    goto LABEL_7;
  return *(_QWORD *)(a1 + 16) + 48 * a2;
}

void re::SkeletalPoseJointDefinition::~SkeletalPoseJointDefinition(re::SkeletalPoseJointDefinition *this)
{
  re::Skeleton *v2;

  *(_QWORD *)this = &off_24ED25CD0;
  v2 = (re::SkeletalPoseJointDefinition *)((char *)this + 24);
  re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 26);
  re::FixedArray<re::StringID>::deinit((_QWORD *)this + 23);
  re::Skeleton::~Skeleton(v2);
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  re::Skeleton *v2;

  *(_QWORD *)this = &off_24ED25CD0;
  v2 = (re::SkeletalPoseJointDefinition *)((char *)this + 24);
  re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 26);
  re::FixedArray<re::StringID>::deinit((_QWORD *)this + 23);
  re::Skeleton::~Skeleton(v2);
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

unint64_t *re::FixedArray<re::StringID>::FixedArray(unint64_t *a1, uint64_t a2)
{
  uint64_t v4;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v4 = *(_QWORD *)a2;
  if (v4)
  {
    re::FixedArray<re::StringID>::init<>(a1, v4, *(_QWORD *)(a2 + 8));
    re::FixedArray<re::StringID>::copy(a1, a2);
  }
  return a1;
}

unint64_t *re::FixedArray<re::StringID>::copy(unint64_t *result, uint64_t a2)
{
  unint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  unint64_t *v5;

  v2 = result[1];
  if (v2 == *(_QWORD *)(a2 + 8))
  {
    if (v2)
    {
      v3 = *(uint64_t **)(a2 + 16);
      result = (unint64_t *)result[2];
      v4 = 16 * v2;
      do
      {
        v5 = re::StringID::operator=(result, v3);
        v3 += 2;
        result = v5 + 2;
        v4 -= 16;
      }
      while (v4);
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Cannot copy from a FixedArray of a different size", "m_size == other.m_size", "copy", 388);
    result = (unint64_t *)_os_crash();
    __break(1u);
  }
  return result;
}

uint64_t *re::FixedArray<unsigned int>::FixedArray(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v4 = *(_QWORD *)a2;
  if (v4)
  {
    re::FixedArray<int>::init<>(a1, v4, *(_QWORD *)(a2 + 8));
    re::FixedArray<unsigned int>::copy(a1, a2);
  }
  return a1;
}

void *re::FixedArray<unsigned int>::copy(void *result, uint64_t a2)
{
  uint64_t v2;

  v2 = *((_QWORD *)result + 1);
  if (v2 == *(_QWORD *)(a2 + 8))
  {
    if (v2)
      return memmove(*((void **)result + 2), *(const void **)(a2 + 16), 4 * v2);
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Cannot copy from a FixedArray of a different size", "m_size == other.m_size", "copy", 388);
    result = (void *)_os_crash();
    __break(1u);
  }
  return result;
}

uint64_t *re::FixedArray<re::Matrix4x4<float>>::FixedArray(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v4 = *(_QWORD *)a2;
  if (v4)
  {
    re::FixedArray<re::Matrix4x4<float>>::init<>(a1, v4, *(_QWORD *)(a2 + 8));
    re::FixedArray<re::Matrix4x4<float>>::copy(a1, a2);
  }
  return a1;
}

uint64_t re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::HashTable(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  signed int v5;

  *(_DWORD *)(a1 + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_QWORD *)(a1 + 36) = 0x7FFFFFFFLL;
  v4 = *(_QWORD *)a2;
  if (v4)
  {
    if (*(_DWORD *)(a2 + 28) <= 3u)
      v5 = 3;
    else
      v5 = *(_DWORD *)(a2 + 28);
    re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init(a1, v4, v5);
    re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::copy(a1, a2);
  }
  return a1;
}

void re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::copy(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t i;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;

  re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::clear(a1);
  v4 = *(_DWORD *)(a2 + 28);
  if (*(_DWORD *)(a1 + 24) < v4)
    re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::setCapacity(a1, v4);
  v5 = *(unsigned int *)(a2 + 32);
  if ((_DWORD)v5)
  {
    v6 = 0;
    for (i = 0; i < v5; ++i)
    {
      v8 = *(_QWORD *)(a2 + 16);
      if ((*(_DWORD *)(v8 + v6) & 0x80000000) != 0)
      {
        v9 = 0xBF58476D1CE4E5B9 * ((*(_QWORD *)(v8 + v6 + 8) >> 31) ^ (*(_QWORD *)(v8 + v6 + 8) >> 1));
        v10 = (0x94D049BB133111EBLL * (v9 ^ (v9 >> 27))) ^ ((0x94D049BB133111EBLL * (v9 ^ (v9 >> 27))) >> 31);
        re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addEmplace<unsigned int &>(a1, v10 % *(unsigned int *)(a1 + 24), v10, (StringID *)(v8 + v6 + 8), (_DWORD *)(v8 + v6 + 24));
        v5 = *(unsigned int *)(a2 + 32);
      }
      v6 += 32;
    }
  }
}

unint64_t *re::FixedArray<re::StringID>::operator=(unint64_t *a1, uint64_t a2)
{
  uint64_t v4;

  if (a1 != (unint64_t *)a2)
  {
    v4 = *(_QWORD *)a2;
    if (*a1)
    {
      if (!v4)
        return a1;
      goto LABEL_7;
    }
    if (v4)
    {
      re::FixedArray<re::StringID>::init<>(a1, v4, *(_QWORD *)(a2 + 8));
LABEL_7:
      re::FixedArray<re::StringID>::copy(a1, a2);
    }
  }
  return a1;
}

uint64_t *re::FixedArray<unsigned int>::operator=(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;

  if (a1 != (uint64_t *)a2)
  {
    v4 = *(_QWORD *)a2;
    if (*a1)
    {
      if (!v4)
        return a1;
      goto LABEL_7;
    }
    if (v4)
    {
      re::FixedArray<int>::init<>(a1, v4, *(_QWORD *)(a2 + 8));
LABEL_7:
      re::FixedArray<unsigned int>::copy(a1, a2);
    }
  }
  return a1;
}

uint64_t re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  signed int v5;

  if (a1 != a2)
  {
    v4 = *(_QWORD *)a2;
    if (*(_QWORD *)a1)
    {
      if (v4)
      {
        re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::copy(a1, a2);
        ++*(_DWORD *)(a1 + 40);
      }
      else
      {
        re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::clear(a1);
      }
    }
    else if (v4)
    {
      if (*(_DWORD *)(a2 + 28) <= 3u)
        v5 = 3;
      else
        v5 = *(_DWORD *)(a2 + 28);
      re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init(a1, v4, v5);
      re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::copy(a1, a2);
    }
  }
  return a1;
}

void re::`anonymous namespace'::SkeletalPoseJointBindPointImpl::~SkeletalPoseJointBindPointImpl(re::_anonymous_namespace_::SkeletalPoseJointBindPointImpl *this)
{
  char *v1;

  v1 = (char *)this + 16;
  re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)this + 16);
  re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)v1);
}

{
  char *v1;

  v1 = (char *)this + 16;
  re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)this + 16);
  re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)v1);
  JUMPOUT(0x2276933B8);
}

const char *re::internal::BindPointImpl<re::`anonymous namespace'::SkeletalPoseJointBindPointImpl>::implTypeInfo()
{
  return "@";
}

uint64_t re::internal::BindPointImpl<re::`anonymous namespace'::SkeletalPoseJointBindPointImpl>::copyInto(_QWORD *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t result;

  v4 = a1[1];
  *a2 = &off_24ED25D18;
  a2[1] = v4;
  result = re::DynamicArray<re::BindPoint::BindPointData>::DynamicArray((uint64_t)(a2 + 2), a1 + 2);
  a2[7] = a1[7];
  return result;
}

uint64_t re::internal::BindPointImpl<re::`anonymous namespace'::SkeletalPoseJointBindPointImpl>::moveInto(_QWORD *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t result;

  v4 = a1[1];
  *a2 = &off_24ED25D18;
  a2[1] = v4;
  result = re::DynamicArray<re::BindPoint::BindPointData>::DynamicArray((uint64_t)(a2 + 2), a1 + 2);
  a2[7] = a1[7];
  return result;
}

BOOL re::internal::BindPointImpl<re::`anonymous namespace'::SkeletalPoseJointBindPointImpl>::equals(uint64_t a1, _QWORD *a2)
{
  _BOOL8 result;

  if ((char *)(*(uint64_t (**)(_QWORD *))(*a2 + 16))(a2) != "@")
    return 0;
  result = re::BindPoint::operator==((re::BindPoint *)(a1 + 8), (re::BindPoint *)(a2 + 1));
  if (result)
    return *(_QWORD *)(a1 + 56) == a2[7];
  return result;
}

uint64_t re::`anonymous namespace'::SkeletalPoseJointBindPointImpl::hash(_QWORD *a1)
{
  unint64_t v2;

  if (a1[4])
    v2 = re::BindPoint::baseValueUntyped((re::BindPoint *)(a1 + 1));
  else
    v2 = 0;
  return (a1[7] + (v2 << 6) + (v2 >> 2) - 0x61C8864680B583E9) ^ v2;
}

uint64_t re::`anonymous namespace'::SkeletalPoseJointBindPointImpl::isWeak(uint64_t a1)
{
  return re::BindPoint::isWeak((re::BindPoint *)(a1 + 8));
}

uint64_t re::`anonymous namespace'::SkeletalPoseJointBindPointImpl::isAlive(uint64_t a1)
{
  return re::BindPoint::isAlive((re::BindPoint *)(a1 + 8));
}

uint64_t re::`anonymous namespace'::SkeletalPoseJointBindPointImpl::baseValueUntyped(uint64_t a1)
{
  uint64_t result;
  unint64_t v3;

  result = re::BindPoint::baseValueUntyped((re::BindPoint *)(a1 + 8));
  if (result)
  {
    v3 = *(_QWORD *)(a1 + 56);
    if (*(_QWORD *)(result + 24) <= v3)
    {
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    return *(_QWORD *)(result + 32) + 48 * v3;
  }
  return result;
}

uint64_t re::`anonymous namespace'::SkeletalPoseJointBindPointImpl::supportsOverrideValue(uint64_t a1)
{
  return re::BindPoint::supportsOverrideValue((re::BindPoint *)(a1 + 8));
}

uint64_t re::`anonymous namespace'::SkeletalPoseJointBindPointImpl::isOverridden(uint64_t a1)
{
  return re::BindPoint::isOverridden((re::BindPoint *)(a1 + 8));
}

uint64_t re::`anonymous namespace'::SkeletalPoseJointBindPointImpl::setIsOverridden(uint64_t a1, int a2, int a3, int a4, uint64_t a5)
{
  return re::BindPoint::setIsOverridden(a1 + 8, a5);
}

uint64_t re::`anonymous namespace'::SkeletalPoseJointBindPointImpl::overrideValueUntyped(uint64_t a1)
{
  uint64_t result;
  unint64_t v3;

  result = re::BindPoint::overrideValueUntyped((re::BindPoint *)(a1 + 8));
  if (result)
  {
    v3 = *(_QWORD *)(a1 + 56);
    if (*(_QWORD *)(result + 24) <= v3)
    {
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    return *(_QWORD *)(result + 32) + 48 * v3;
  }
  return result;
}

uint64_t re::`anonymous namespace'::SkeletalPoseJointBindPointImpl::boundOwner()
{
  return 0;
}

void re::TypeBuilderHelper::registerDynamicArray<BOOL>(re::TypeRegistry *a1@<X0>, uint64_t *a2@<X1>, __int128 *a3@<X2>, re::TypeRegistry **a4@<X8>)
{
  _anonymous_namespace_ *v8;
  re::TypeRegistry *v9;
  uint64_t v10;
  __int128 v11;
  _BYTE v12[488];

  v8 = (_anonymous_namespace_ *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a1 + 200, a2);
  if (a1 && v8)
  {
    v9 = *(re::TypeRegistry **)v8;
    *a4 = a1;
    a4[1] = v9;
  }
  else
  {
    v11 = *a3;
    re::TypeBuilder::beginListType((uint64_t)v12, a2, 1, 0x28uLL, 8uLL, &v11);
    re::TypeBuilder::setConstructor((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<BOOL>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
    re::TypeBuilder::setDestructor((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<BOOL>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
    re::TypeBuilder::setListUsesContiguousStorage((uint64_t)v12, 1);
    re::TypeBuilder::setListAccessors((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<BOOL>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<BOOL>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
    re::TypeBuilder::setListIndexer((uint64_t)v12, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<BOOL>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
    re::TypeBuilder::setListIterator((uint64_t)v12, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<BOOL>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<BOOL>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<BOOL>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
    re::TypeBuilder::commitTo((re::TypeBuilder *)v12, a1, a4);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v12, v10);
  }
}

_QWORD *re::IntrospectionDynamicArray<BOOL>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<BOOL>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x2276933B8);
}

void re::IntrospectionDynamicArray<BOOL>::construct(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<BOOL>::destroy(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = *(_QWORD *)a2;
  if (*(_QWORD *)a2)
  {
    if (*(_QWORD *)(a2 + 32))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a2 + 32) = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_QWORD *)a2 = 0;
    ++*(_DWORD *)(a2 + 24);
  }
  return result;
}

_QWORD *re::IntrospectionDynamicArray<BOOL>::init(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  _QWORD *result;

  if (*a2)
  {
    if (a2[4])
      (*(void (**)(_QWORD))(*(_QWORD *)*a2 + 40))(*a2);
    a2[4] = 0;
    a2[1] = 0;
    a2[2] = 0;
    ++*((_DWORD *)a2 + 6);
  }
  *a2 = a3;
  result = re::DynamicArray<BOOL>::setCapacity(a2, 0);
  ++*((_DWORD *)a2 + 6);
  return result;
}

void re::IntrospectionDynamicArray<BOOL>::resize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  unint64_t v10;
  unint64_t i;

  if (!*(_QWORD *)a4)
  {
    *(_QWORD *)a4 = a2;
    re::DynamicArray<BOOL>::setCapacity((_QWORD *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  v10 = *(_QWORD *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
      re::DynamicArray<BOOL>::resize(a4, a5);
  }
  else
  {
    re::DynamicArray<BOOL>::setCapacity((_QWORD *)a4, a5);
    for (i = a5 - *(_QWORD *)(a4 + 16); i; --i)
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, a3, a4);
  }
}

re::IntrospectionBase *re::IntrospectionDynamicArray<BOOL>::addElement(uint64_t a1, re *a2, int a3, _anonymous_namespace_ *this)
{
  re::IntrospectionBase *v8;
  char v10;

  v10 = 0;
  re::DynamicArray<BOOL>::add(this, &v10);
  v8 = (re::IntrospectionBase *)(*((_QWORD *)this + 2) + *((_QWORD *)this + 4) - 1);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v8);
  return v8;
}

uint64_t re::IntrospectionDynamicArray<BOOL>::size(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 16);
}

unint64_t re::IntrospectionDynamicArray<BOOL>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + a3;
}

{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + a3;
}

void re::DynamicArray<BOOL>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v4;

  v4 = *(_QWORD *)(a1 + 16);
  if (v4 >= a2)
  {
    if (v4 <= a2)
      return;
  }
  else
  {
    if (*(_QWORD *)(a1 + 8) < a2)
    {
      re::DynamicArray<BOOL>::setCapacity((_QWORD *)a1, a2);
      v4 = *(_QWORD *)(a1 + 16);
    }
    if (v4 < a2 && (uint64_t)(a2 - v4) >= 1)
      bzero((void *)(*(_QWORD *)(a1 + 32) + v4), a2 - v4);
  }
  *(_QWORD *)(a1 + 16) = a2;
  ++*(_DWORD *)(a1 + 24);
}

_QWORD *re::DynamicArray<BOOL>::add(_QWORD *this, _BYTE *a2)
{
  _QWORD *v3;
  unint64_t v4;

  v3 = this;
  v4 = this[2];
  if (v4 >= this[1])
  {
    this = re::DynamicArray<BOOL>::growCapacity(this, v4 + 1);
    v4 = v3[2];
  }
  *(_BYTE *)(v3[4] + v4) = *a2;
  v3[2] = v4 + 1;
  ++*((_DWORD *)v3 + 6);
  return this;
}

_QWORD *re::DynamicArray<BOOL>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<BOOL>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<BOOL>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

_QWORD *re::TypeBuilderHelper::registerDynamicArray<BOOL>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)a1 = a3;
  result = re::DynamicArray<BOOL>::setCapacity((_QWORD *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<BOOL>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)a1;
  if (result)
  {
    if (*(_QWORD *)(a1 + 32))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<BOOL>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<BOOL>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  char v4;

  re::TypeBuilderHelper::registerDynamicArray<BOOL>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::operator()((uint64_t)&v4, a1, a2, a3, a4);
}

void re::TypeBuilderHelper::registerDynamicArray<BOOL>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::operator()(uint64_t a1, uint64_t a2, uint64_t a3, re::Allocator *a4, unint64_t a5)
{
  uint64_t v9;
  _anonymous_namespace_ *v10;
  uint64_t v11;
  void **v12;
  _BYTE v13[32];
  _BYTE v14[8];
  uint64_t v15;

  v9 = *(_QWORD *)a2;
  if (*(re::Allocator **)a2 == a4)
  {
    *(_QWORD *)(a2 + 16) = 0;
  }
  else
  {
    if (v9)
    {
      if (*(_QWORD *)(a2 + 32))
        (*(void (**)(uint64_t))(*(_QWORD *)v9 + 40))(v9);
      *(_QWORD *)(a2 + 32) = 0;
      *(_QWORD *)(a2 + 8) = 0;
      *(_QWORD *)(a2 + 16) = 0;
      ++*(_DWORD *)(a2 + 24);
    }
    *(_QWORD *)a2 = a4;
    re::DynamicArray<BOOL>::setCapacity((_QWORD *)a2, a5);
  }
  ++*(_DWORD *)(a2 + 24);
  re::DynamicArray<BOOL>::resize(a2, a5);
  {
    re::TypeRegistry::typeInfo(*(_QWORD **)a3, *(_QWORD *)(*(_QWORD *)(a3 + 16) + 72), v14);
    re::TypeInfo::TypeInfo((uint64_t)v13, (uint64_t)&v15);
    v11 = *(_QWORD *)(a2 + 16);
    if (v11)
    {
      v12 = *(void ***)(a2 + 32);
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v13, v12, a4, 0);
        re::TypeInfo::construct((re::TypeInfo *)v13, v12, a4, 0);
        v12 = (void **)((char *)v12 + 1);
        --v11;
      }
      while (v11);
    }
  }
}

unint64_t re::TypeBuilderHelper::registerDynamicArray<BOOL>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(_QWORD *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a1 + 32) + a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<BOOL>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 16, 8);
  *(_QWORD *)result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<BOOL>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unint64_t v4;
  uint64_t result;

  v2 = *(_QWORD *)a1;
  if (a1[2] == *(_DWORD *)(*(_QWORD *)a1 + 24))
  {
    v3 = a1[3];
    v4 = *(_QWORD *)(v2 + 16);
    if (v3 < (int)v4)
      a1[3] = ++v3;
    if (v4 <= v3)
      return 0;
    else
      return *(_QWORD *)(v2 + 32) + v3;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<BOOL>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 40))(a2, result);
  return result;
}

_QWORD *re::FixedArray<re::GenericSRT<float>>::copy(_QWORD *result, uint64_t a2, const void *a3, uint64_t a4)
{
  if (__CFADD__(a2, a4))
  {
    re::internal::assertLog((re::internal *)7, a2, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::copy(). size = %zu, pos = %zu, count = %zu", "!overflow", "copy", 362, result[1], a2, a4);
    _os_crash();
    __break(1u);
    goto LABEL_7;
  }
  if ((unint64_t)(a2 + a4) > result[1])
  {
LABEL_7:
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Too much data to copy.", "requiredSize <= m_size", "copy", 363);
    result = (_QWORD *)_os_crash();
    __break(1u);
    return result;
  }
  if (a4)
    return memmove((void *)(result[2] + 48 * a2), a3, 48 * a4);
  return result;
}

void re::registerIKinemaAnimNodes(re *this, re::RigEnvironment *a2)
{
  uint64_t v3;
  unint64_t v4;
  size_t v5;
  re::RigEnvironment *v6;
  re::RigEnvironment *v7;
  re::RigEnvironment *v8;
  re::RigEnvironment *v9;
  re::RigEnvironment *v10;
  re::RigEnvironment *v11;
  re::RigEnvironment *v12;
  re::RigEnvironment *v13;
  re::RigEnvironment *v14;
  re::RigEnvironment *v15;
  re::RigEnvironment *v16;
  re::RigEnvironment *v17;
  re::RigEnvironment *v18;
  re::RigEnvironment *v19;
  re::RigEnvironment *v20;
  re::RigEnvironment *v21;
  re::RigEnvironment *v22;
  re::RigEnvironment *v23;
  re::RigEnvironment *v24;
  re::RigEnvironment *v25;
  const char *v26[2];
  _QWORD v27[3];
  uint64_t v28;
  char v29;
  _BYTE v30[8];
  uint64_t v31;
  StringID v32;

  v3 = 0;
  v4 = *(_QWORD *)this;
  do
  {
    v5 = strlen(re::registerIKinemaAnimNodes(re::RigEnvironment *)::kCustomStructs[v3]);
    v27[0] = re::registerIKinemaAnimNodes(re::RigEnvironment *)::kCustomStructs[v3];
    v27[1] = v5;
    re::RigDataTypeClass::rigDataTypeParser(v4, (uint64_t)v27, (uint64_t)v30);
    re::StringID::StringID((re::StringID *)v26, &v32);
    re::RigEnvironment::insertRigDataType(this, v26, (const re::RigDataTypeClass *)&v31, (uint64_t)v27);
    re::StringID::destroyString((re::StringID *)v26);
    if (!LOBYTE(v27[0]) && v28 && (v29 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v28 + 40))();
    re::Result<re::RigDataTypeClass,re::DetailedError>::~Result((uint64_t)v30);
    ++v3;
  }
  while (v3 != 6);
  re::internal::registerMakeIKTask(this, v6);
  re::internal::registerMakeIKLookAtTask(this, v7);
  re::internal::registerMakeIKPenetrationCorrectionTask(this, v8);
  re::internal::registerMakeIKRigJointSettings(this, v9);
  re::internal::registerMakeIKRigTaskSettings(this, v10);
  re::internal::registerMakeIKRigSolverSettings(this, v11);
  re::internal::registerGenericSolverNode(this, v12);
  re::internal::registerGenericSolverNoLookAtNode(this, v13);
  re::internal::registerGenericSolverWithRigSettingsDebug(this, v14);
  re::internal::registerIKParametersComponentNode(this, v15);
  re::internal::registerFootPlacementSolverNoLookAtNode(this, v16);
  re::internal::registerFootPlacementSolverNode(this, v17);
  re::internal::registerFootPlacementSolverDebugNode(this, v18);
  re::internal::registerRetargetingSolverNode(this, v19);
  re::internal::registerPenetrationCorrectionSolverNode(this, v20);
  re::internal::registerArvinoToArvinoRetargetNode(this, v21);
  re::internal::registerBipedToBipedRetargetNode(this, v22);
  re::internal::registerFeetSlidingSolverNode(this, v23);
  re::internal::registerFilterSolverNode(this, v24);
  re::internal::registerFloorLevelSolverNode(this, v25);
}

BOOL re::AnimationClip<float>::childCount(uint64_t a1)
{
  return *(_QWORD *)(a1 + 80) != 0;
}

uint64_t re::AnimationClip<float>::child(uint64_t a1)
{
  return *(_QWORD *)(a1 + 80);
}

double re::AnimationClip<float>::totalDuration(uint64_t a1)
{
  uint64_t v2;
  double v3;
  double v4;
  double v5;

  v2 = *(_QWORD *)(a1 + 80);
  if (v2)
  {
    if (*(_BYTE *)(a1 + 88))
      v3 = *(double *)(a1 + 96);
    else
      v3 = 0.0;
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    if (*(_BYTE *)(a1 + 104))
      v5 = *(double *)(a1 + 112);
    v4 = v5 - v3;
  }
  else
  {
    v4 = 0.0;
  }
  if (*(_BYTE *)(a1 + 144))
    v4 = *(double *)(a1 + 152);
  return *(double *)(a1 + 136) + v4 / fabsf(*(float *)(a1 + 160));
}

uint64_t re::AnimationClip<float>::timelineDesc@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  double v5;
  float v6;
  double v7;
  double v8;
  char v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  uint64_t result;

  v4 = *(_QWORD *)(a1 + 80);
  if (v4)
  {
    if (*(_BYTE *)(a1 + 88))
      v5 = *(double *)(a1 + 96);
    else
      v5 = 0.0;
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    if (*(_BYTE *)(a1 + 104))
      v7 = *(double *)(a1 + 112);
    v6 = v7 - v5;
  }
  else
  {
    v6 = 0.0;
    v5 = 0.0;
    v7 = 0.0;
  }
  if (!*(_BYTE *)(a1 + 144) || (v8 = *(double *)(a1 + 152), v8 == 0.0))
  {
    v9 = *(_BYTE *)(a1 + 164);
    if (v9)
      v6 = INFINITY;
  }
  else
  {
    v6 = v8;
    v9 = *(_BYTE *)(a1 + 164);
  }
  v10 = *(double *)(a1 + 136);
  *(float *)a2 = v10;
  *(float *)(a2 + 4) = v6;
  v11 = *(float *)(a1 + 160);
  if (*(_BYTE *)(a1 + 128))
    v11 = -v11;
  v12 = v5;
  *(float *)(a2 + 8) = v11;
  *(float *)(a2 + 12) = v12;
  v13 = v7;
  v14 = *(double *)(a1 + 120);
  *(float *)(a2 + 16) = v13;
  *(float *)(a2 + 20) = v14;
  *(_BYTE *)(a2 + 24) = v9;
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
  *(_BYTE *)(a2 + 25) = result;
  return result;
}

uint64_t re::AnimationClip<float>::createInstance(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v8 = a1;
  if ((*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1) == 1)
  {
    v9 = a5 + 1;
    if (*(_QWORD *)(a4 + 128) <= v9)
    {
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_8;
    }
    v10 = *(_QWORD *)(*(_QWORD *)(a4 + 136) + 8 * v9);
    if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v10 + 88))(v10))
    {
      v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 168, 8);
      v12 = re::AnimationClip<float>::AnimationClip(v11, v8);
      if (*(_QWORD *)(a4 + 128) > v9)
      {
        *(_QWORD *)(v12 + 80) = *(_QWORD *)(*(_QWORD *)(a4 + 136) + 8 * v9);
        *(_BYTE *)(v12 + 165) = 1;
        return v12;
      }
LABEL_8:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
  return v8;
}

uint64_t re::AnimationClip<float>::isInstanced(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 165);
}

uint64_t re::AnimationClip<float>::derivedFillMode(uint64_t a1)
{
  char v1;
  uint64_t v3;

  v1 = *(_BYTE *)(a1 + 16);
  if (v1)
    return v1;
  v3 = *(_QWORD *)(a1 + 80);
  if (!v3)
    return 0;
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 56))(v3);
}

uint64_t re::AnimationClip<float>::evaluateCore(uint64_t result, uint64_t a2, unint64_t a3, float *a4, uint64_t a5, float *a6)
{
  uint64_t v8;
  uint64_t *v9;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  float v17;
  uint64_t v18;
  char *v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  char v23[8];
  uint64_t v24;
  char v25;
  uint64_t v26;
  char v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  char v31;
  uint64_t v32;
  _BYTE v33[4];
  int v34;
  uint64_t v35;
  char v36;
  uint64_t v37;
  char v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  char v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;

  v45 = a2;
  v46 = a3;
  if (a3)
  {
    v8 = result;
    v9 = *(uint64_t **)(result + 80);
    if (!v9)
    {
      v17 = *a4;
LABEL_23:
      *a6 = v17;
      return result;
    }
    if (*(_BYTE *)(result + 164) != 2 || !vcvtms_s32_f32(*(float *)(a2 + 60)))
    {
      v15 = re::Slice<re::AnimationClock>::range(&v45, 1uLL, a3);
      return (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, float *, uint64_t, float *))(*v9 + 96))(v9, v15, v16, a4, a5, a6);
    }
    v44 = 0;
    if (v33[0] && v34 == 1)
    {
      v13 = *(_QWORD *)(v8 + 80);
      if (v13)
      {
        if (*(_BYTE *)(v8 + 88))
          v14 = *(_QWORD *)(v8 + 96);
        else
          v14 = 0;
        (*(void (**)(uint64_t))(*(_QWORD *)v13 + 40))(v13);
        if (*(_BYTE *)(v8 + 104))
          v18 = *(_QWORD *)(v8 + 112);
      }
      else
      {
        v18 = 0;
        v14 = 0;
      }
      v35 = 0;
      v38 = 0;
      v40 = 0;
      v41 = 0;
      v42 = 0;
      v33[0] = 3;
      v36 = 1;
      v37 = v14;
      v43 = 0x200000000;
      v39 = 1065353216;
      v24 = 0;
      v27 = 0;
      v29 = 0;
      v30 = 0;
      v31 = 0;
      v23[0] = 3;
      v25 = 1;
      v26 = v18;
      v32 = 0x200000000;
      v28 = 1065353216;
      if (*(_BYTE *)(v8 + 128))
        v19 = (char *)&v44;
      else
        v19 = (char *)&v44 + 4;
      if (*(_BYTE *)(v8 + 128))
        v20 = (char *)&v44 + 4;
      else
        v20 = (char *)&v44;
      (*(void (**)(uint64_t *, _BYTE *, uint64_t, float *, uint64_t, char *))(*v9 + 96))(v9, v33, 1, a4, a5, v19);
      (*(void (**)(uint64_t *, char *, uint64_t, float *, uint64_t, char *))(*v9 + 96))(v9, v23, 1, a4, a5, v20);
      *((float *)&v44 + 1) = (float)(*(float *)&v44 - *((float *)&v44 + 1)) * (float)(int)floorf(*(float *)(a2 + 60));
      v21 = re::Slice<re::AnimationClock>::range(&v45, 1uLL, v46);
      result = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, float *, uint64_t, float *))(*v9 + 96))(v9, v21, v22, a4, a5, a6);
      v17 = *a6 + *((float *)&v44 + 1);
      goto LABEL_23;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
  }
  re::internal::assertLog((re::internal *)4, v12, "assertion failure: '%s' (%s:line %i) Not yet implemented. Cycle-offset computation currently does not yet support nested animations.", "internal::countTimelines(*source) == 1", "evaluateCore", 299);
  result = _os_crash();
  __break(1u);
  return result;
}

BOOL re::AnimationClip<double>::childCount(uint64_t a1)
{
  return *(_QWORD *)(a1 + 80) != 0;
}

uint64_t re::AnimationClip<double>::child(uint64_t a1)
{
  return *(_QWORD *)(a1 + 80);
}

double re::AnimationClip<double>::totalDuration(uint64_t a1)
{
  uint64_t v2;
  double v3;
  double v4;
  double v5;

  v2 = *(_QWORD *)(a1 + 80);
  if (v2)
  {
    if (*(_BYTE *)(a1 + 88))
      v3 = *(double *)(a1 + 96);
    else
      v3 = 0.0;
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    if (*(_BYTE *)(a1 + 104))
      v5 = *(double *)(a1 + 112);
    v4 = v5 - v3;
  }
  else
  {
    v4 = 0.0;
  }
  if (*(_BYTE *)(a1 + 144))
    v4 = *(double *)(a1 + 152);
  return *(double *)(a1 + 136) + v4 / fabsf(*(float *)(a1 + 160));
}

uint64_t re::AnimationClip<double>::timelineDesc@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  double v5;
  float v6;
  double v7;
  double v8;
  char v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  uint64_t result;

  v4 = *(_QWORD *)(a1 + 80);
  if (v4)
  {
    if (*(_BYTE *)(a1 + 88))
      v5 = *(double *)(a1 + 96);
    else
      v5 = 0.0;
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    if (*(_BYTE *)(a1 + 104))
      v7 = *(double *)(a1 + 112);
    v6 = v7 - v5;
  }
  else
  {
    v6 = 0.0;
    v5 = 0.0;
    v7 = 0.0;
  }
  if (!*(_BYTE *)(a1 + 144) || (v8 = *(double *)(a1 + 152), v8 == 0.0))
  {
    v9 = *(_BYTE *)(a1 + 164);
    if (v9)
      v6 = INFINITY;
  }
  else
  {
    v6 = v8;
    v9 = *(_BYTE *)(a1 + 164);
  }
  v10 = *(double *)(a1 + 136);
  *(float *)a2 = v10;
  *(float *)(a2 + 4) = v6;
  v11 = *(float *)(a1 + 160);
  if (*(_BYTE *)(a1 + 128))
    v11 = -v11;
  v12 = v5;
  *(float *)(a2 + 8) = v11;
  *(float *)(a2 + 12) = v12;
  v13 = v7;
  v14 = *(double *)(a1 + 120);
  *(float *)(a2 + 16) = v13;
  *(float *)(a2 + 20) = v14;
  *(_BYTE *)(a2 + 24) = v9;
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
  *(_BYTE *)(a2 + 25) = result;
  return result;
}

uint64_t re::AnimationClip<double>::createInstance(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v8 = a1;
  if ((*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1) == 1)
  {
    v9 = a5 + 1;
    if (*(_QWORD *)(a4 + 128) <= v9)
    {
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_8;
    }
    v10 = *(_QWORD *)(*(_QWORD *)(a4 + 136) + 8 * v9);
    if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v10 + 88))(v10))
    {
      v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 168, 8);
      v12 = re::AnimationClip<double>::AnimationClip(v11, v8);
      if (*(_QWORD *)(a4 + 128) > v9)
      {
        *(_QWORD *)(v12 + 80) = *(_QWORD *)(*(_QWORD *)(a4 + 136) + 8 * v9);
        *(_BYTE *)(v12 + 165) = 1;
        return v12;
      }
LABEL_8:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
  return v8;
}

uint64_t re::AnimationClip<double>::isInstanced(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 165);
}

uint64_t re::AnimationClip<double>::derivedFillMode(uint64_t a1)
{
  char v1;
  uint64_t v3;

  v1 = *(_BYTE *)(a1 + 16);
  if (v1)
    return v1;
  v3 = *(_QWORD *)(a1 + 80);
  if (!v3)
    return 0;
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 56))(v3);
}

uint64_t re::AnimationClip<double>::evaluateCore(uint64_t result, uint64_t a2, unint64_t a3, double *a4, uint64_t a5, double *a6)
{
  uint64_t v8;
  uint64_t *v9;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  double v17;
  uint64_t v18;
  double *v19;
  double *v20;
  uint64_t v21;
  uint64_t v22;
  char v23[8];
  uint64_t v24;
  char v25;
  uint64_t v26;
  char v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  char v31;
  uint64_t v32;
  _BYTE v33[4];
  int v34;
  uint64_t v35;
  char v36;
  uint64_t v37;
  char v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  char v42;
  uint64_t v43;
  double v44;
  double v45;
  uint64_t v46;
  unint64_t v47;

  v46 = a2;
  v47 = a3;
  if (a3)
  {
    v8 = result;
    v9 = *(uint64_t **)(result + 80);
    if (!v9)
    {
      v17 = *a4;
LABEL_23:
      *a6 = v17;
      return result;
    }
    if (*(_BYTE *)(result + 164) != 2 || !vcvtms_s32_f32(*(float *)(a2 + 60)))
    {
      v15 = re::Slice<re::AnimationClock>::range(&v46, 1uLL, a3);
      return (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, double *, uint64_t, double *))(*v9 + 96))(v9, v15, v16, a4, a5, a6);
    }
    v44 = 0.0;
    v45 = 0.0;
    if (v33[0] && v34 == 1)
    {
      v13 = *(_QWORD *)(v8 + 80);
      if (v13)
      {
        if (*(_BYTE *)(v8 + 88))
          v14 = *(_QWORD *)(v8 + 96);
        else
          v14 = 0;
        (*(void (**)(uint64_t))(*(_QWORD *)v13 + 40))(v13);
        if (*(_BYTE *)(v8 + 104))
          v18 = *(_QWORD *)(v8 + 112);
      }
      else
      {
        v18 = 0;
        v14 = 0;
      }
      v35 = 0;
      v38 = 0;
      v40 = 0;
      v41 = 0;
      v42 = 0;
      v33[0] = 3;
      v36 = 1;
      v37 = v14;
      v43 = 0x200000000;
      v39 = 1065353216;
      v24 = 0;
      v27 = 0;
      v29 = 0;
      v30 = 0;
      v31 = 0;
      v23[0] = 3;
      v25 = 1;
      v26 = v18;
      v32 = 0x200000000;
      v28 = 1065353216;
      if (*(_BYTE *)(v8 + 128))
        v19 = &v44;
      else
        v19 = &v45;
      if (*(_BYTE *)(v8 + 128))
        v20 = &v45;
      else
        v20 = &v44;
      (*(void (**)(uint64_t *, _BYTE *, uint64_t, double *, uint64_t, double *))(*v9 + 96))(v9, v33, 1, a4, a5, v19);
      (*(void (**)(uint64_t *, char *, uint64_t, double *, uint64_t, double *))(*v9 + 96))(v9, v23, 1, a4, a5, v20);
      v45 = (v44 - v45) * (double)(int)vcvtms_s32_f32(*(float *)(a2 + 60));
      v21 = re::Slice<re::AnimationClock>::range(&v46, 1uLL, v47);
      result = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, double *, uint64_t, double *))(*v9 + 96))(v9, v21, v22, a4, a5, a6);
      v17 = *a6 + v45;
      goto LABEL_23;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
  }
  re::internal::assertLog((re::internal *)4, v12, "assertion failure: '%s' (%s:line %i) Not yet implemented. Cycle-offset computation currently does not yet support nested animations.", "internal::countTimelines(*source) == 1", "evaluateCore", 299);
  result = _os_crash();
  __break(1u);
  return result;
}

BOOL re::AnimationClip<re::Vector2<float>>::childCount(uint64_t a1)
{
  return *(_QWORD *)(a1 + 80) != 0;
}

uint64_t re::AnimationClip<re::Vector2<float>>::child(uint64_t a1)
{
  return *(_QWORD *)(a1 + 80);
}

double re::AnimationClip<re::Vector2<float>>::totalDuration(uint64_t a1)
{
  uint64_t v2;
  double v3;
  double v4;
  double v5;

  v2 = *(_QWORD *)(a1 + 80);
  if (v2)
  {
    if (*(_BYTE *)(a1 + 88))
      v3 = *(double *)(a1 + 96);
    else
      v3 = 0.0;
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    if (*(_BYTE *)(a1 + 104))
      v5 = *(double *)(a1 + 112);
    v4 = v5 - v3;
  }
  else
  {
    v4 = 0.0;
  }
  if (*(_BYTE *)(a1 + 144))
    v4 = *(double *)(a1 + 152);
  return *(double *)(a1 + 136) + v4 / fabsf(*(float *)(a1 + 160));
}

uint64_t re::AnimationClip<re::Vector2<float>>::timelineDesc@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  double v5;
  float v6;
  double v7;
  double v8;
  char v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  uint64_t result;

  v4 = *(_QWORD *)(a1 + 80);
  if (v4)
  {
    if (*(_BYTE *)(a1 + 88))
      v5 = *(double *)(a1 + 96);
    else
      v5 = 0.0;
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    if (*(_BYTE *)(a1 + 104))
      v7 = *(double *)(a1 + 112);
    v6 = v7 - v5;
  }
  else
  {
    v6 = 0.0;
    v5 = 0.0;
    v7 = 0.0;
  }
  if (!*(_BYTE *)(a1 + 144) || (v8 = *(double *)(a1 + 152), v8 == 0.0))
  {
    v9 = *(_BYTE *)(a1 + 164);
    if (v9)
      v6 = INFINITY;
  }
  else
  {
    v6 = v8;
    v9 = *(_BYTE *)(a1 + 164);
  }
  v10 = *(double *)(a1 + 136);
  *(float *)a2 = v10;
  *(float *)(a2 + 4) = v6;
  v11 = *(float *)(a1 + 160);
  if (*(_BYTE *)(a1 + 128))
    v11 = -v11;
  v12 = v5;
  *(float *)(a2 + 8) = v11;
  *(float *)(a2 + 12) = v12;
  v13 = v7;
  v14 = *(double *)(a1 + 120);
  *(float *)(a2 + 16) = v13;
  *(float *)(a2 + 20) = v14;
  *(_BYTE *)(a2 + 24) = v9;
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
  *(_BYTE *)(a2 + 25) = result;
  return result;
}

uint64_t re::AnimationClip<re::Vector2<float>>::createInstance(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v8 = a1;
  if ((*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1) == 1)
  {
    v9 = a5 + 1;
    if (*(_QWORD *)(a4 + 128) <= v9)
    {
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_8;
    }
    v10 = *(_QWORD *)(*(_QWORD *)(a4 + 136) + 8 * v9);
    if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v10 + 88))(v10))
    {
      v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 168, 8);
      v12 = re::AnimationClip<re::Vector2<float>>::AnimationClip(v11, v8);
      if (*(_QWORD *)(a4 + 128) > v9)
      {
        *(_QWORD *)(v12 + 80) = *(_QWORD *)(*(_QWORD *)(a4 + 136) + 8 * v9);
        *(_BYTE *)(v12 + 165) = 1;
        return v12;
      }
LABEL_8:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
  return v8;
}

uint64_t re::AnimationClip<re::Vector2<float>>::isInstanced(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 165);
}

uint64_t re::AnimationClip<re::Vector2<float>>::derivedFillMode(uint64_t a1)
{
  char v1;
  uint64_t v3;

  v1 = *(_BYTE *)(a1 + 16);
  if (v1)
    return v1;
  v3 = *(_QWORD *)(a1 + 80);
  if (!v3)
    return 0;
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 56))(v3);
}

uint64_t re::AnimationClip<re::Vector2<float>>::evaluateCore(uint64_t result, uint64_t a2, unint64_t a3, float32x2_t *a4, uint64_t a5, float32x2_t *a6)
{
  uint64_t v8;
  uint64_t *v9;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  float32x2_t *v18;
  float32x2_t *v19;
  uint64_t v20;
  uint64_t v21;
  char v22[8];
  uint64_t v23;
  char v24;
  uint64_t v25;
  char v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  char v30;
  uint64_t v31;
  _BYTE v32[4];
  int v33;
  uint64_t v34;
  char v35;
  uint64_t v36;
  char v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  char v41;
  uint64_t v42;
  float32x2_t v43;
  float32x2_t v44;
  uint64_t v45;
  unint64_t v46;

  v45 = a2;
  v46 = a3;
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_24:
    re::internal::assertLog((re::internal *)4, v12, "assertion failure: '%s' (%s:line %i) Not yet implemented. Cycle-offset computation currently does not yet support nested animations.", "internal::countTimelines(*source) == 1", "evaluateCore", 299);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v8 = result;
  v9 = *(uint64_t **)(result + 80);
  if (!v9)
  {
    *a6 = *a4;
    return result;
  }
  if (*(_BYTE *)(result + 164) != 2 || !vcvtms_s32_f32(*(float *)(a2 + 60)))
  {
    v15 = re::Slice<re::AnimationClock>::range(&v45, 1uLL, a3);
    return (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, float32x2_t *, uint64_t, float32x2_t *))(*v9 + 96))(v9, v15, v16, a4, a5, a6);
  }
  v43 = 0;
  v44 = 0;
  if (!v32[0] || v33 != 1)
    goto LABEL_24;
  v13 = *(_QWORD *)(v8 + 80);
  if (v13)
  {
    if (*(_BYTE *)(v8 + 88))
      v14 = *(_QWORD *)(v8 + 96);
    else
      v14 = 0;
    (*(void (**)(uint64_t))(*(_QWORD *)v13 + 40))(v13);
    if (*(_BYTE *)(v8 + 104))
      v17 = *(_QWORD *)(v8 + 112);
  }
  else
  {
    v17 = 0;
    v14 = 0;
  }
  v34 = 0;
  v37 = 0;
  v39 = 0;
  v40 = 0;
  v41 = 0;
  v32[0] = 3;
  v35 = 1;
  v36 = v14;
  v42 = 0x200000000;
  v38 = 1065353216;
  v23 = 0;
  v26 = 0;
  v28 = 0;
  v29 = 0;
  v30 = 0;
  v22[0] = 3;
  v24 = 1;
  v25 = v17;
  v31 = 0x200000000;
  v27 = 1065353216;
  if (*(_BYTE *)(v8 + 128))
    v18 = &v43;
  else
    v18 = &v44;
  if (*(_BYTE *)(v8 + 128))
    v19 = &v44;
  else
    v19 = &v43;
  (*(void (**)(uint64_t *, _BYTE *, uint64_t, float32x2_t *, uint64_t, float32x2_t *))(*v9 + 96))(v9, v32, 1, a4, a5, v18);
  (*(void (**)(uint64_t *, char *, uint64_t, float32x2_t *, uint64_t, float32x2_t *))(*v9 + 96))(v9, v22, 1, a4, a5, v19);
  v44 = vmul_n_f32(vsub_f32(v43, v44), (float)(int)floorf(*(float *)(a2 + 60)));
  v20 = re::Slice<re::AnimationClock>::range(&v45, 1uLL, v46);
  result = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, float32x2_t *, uint64_t, float32x2_t *))(*v9 + 96))(v9, v20, v21, a4, a5, a6);
  *a6 = vadd_f32(*a6, v44);
  return result;
}

BOOL re::AnimationClip<re::Vector3<float>>::childCount(uint64_t a1)
{
  return *(_QWORD *)(a1 + 80) != 0;
}

uint64_t re::AnimationClip<re::Vector3<float>>::child(uint64_t a1)
{
  return *(_QWORD *)(a1 + 80);
}

double re::AnimationClip<re::Vector3<float>>::totalDuration(uint64_t a1)
{
  uint64_t v2;
  double v3;
  double v4;
  double v5;

  v2 = *(_QWORD *)(a1 + 80);
  if (v2)
  {
    if (*(_BYTE *)(a1 + 88))
      v3 = *(double *)(a1 + 96);
    else
      v3 = 0.0;
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    if (*(_BYTE *)(a1 + 104))
      v5 = *(double *)(a1 + 112);
    v4 = v5 - v3;
  }
  else
  {
    v4 = 0.0;
  }
  if (*(_BYTE *)(a1 + 144))
    v4 = *(double *)(a1 + 152);
  return *(double *)(a1 + 136) + v4 / fabsf(*(float *)(a1 + 160));
}

uint64_t re::AnimationClip<re::Vector3<float>>::timelineDesc@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  double v5;
  float v6;
  double v7;
  double v8;
  char v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  uint64_t result;

  v4 = *(_QWORD *)(a1 + 80);
  if (v4)
  {
    if (*(_BYTE *)(a1 + 88))
      v5 = *(double *)(a1 + 96);
    else
      v5 = 0.0;
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    if (*(_BYTE *)(a1 + 104))
      v7 = *(double *)(a1 + 112);
    v6 = v7 - v5;
  }
  else
  {
    v6 = 0.0;
    v5 = 0.0;
    v7 = 0.0;
  }
  if (!*(_BYTE *)(a1 + 144) || (v8 = *(double *)(a1 + 152), v8 == 0.0))
  {
    v9 = *(_BYTE *)(a1 + 164);
    if (v9)
      v6 = INFINITY;
  }
  else
  {
    v6 = v8;
    v9 = *(_BYTE *)(a1 + 164);
  }
  v10 = *(double *)(a1 + 136);
  *(float *)a2 = v10;
  *(float *)(a2 + 4) = v6;
  v11 = *(float *)(a1 + 160);
  if (*(_BYTE *)(a1 + 128))
    v11 = -v11;
  v12 = v5;
  *(float *)(a2 + 8) = v11;
  *(float *)(a2 + 12) = v12;
  v13 = v7;
  v14 = *(double *)(a1 + 120);
  *(float *)(a2 + 16) = v13;
  *(float *)(a2 + 20) = v14;
  *(_BYTE *)(a2 + 24) = v9;
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
  *(_BYTE *)(a2 + 25) = result;
  return result;
}

uint64_t re::AnimationClip<re::Vector3<float>>::createInstance(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v8 = a1;
  if ((*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1) == 1)
  {
    v9 = a5 + 1;
    if (*(_QWORD *)(a4 + 128) <= v9)
    {
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_8;
    }
    v10 = *(_QWORD *)(*(_QWORD *)(a4 + 136) + 8 * v9);
    if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v10 + 88))(v10))
    {
      v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 168, 8);
      v12 = re::AnimationClip<re::Vector3<float>>::AnimationClip(v11, v8);
      if (*(_QWORD *)(a4 + 128) > v9)
      {
        *(_QWORD *)(v12 + 80) = *(_QWORD *)(*(_QWORD *)(a4 + 136) + 8 * v9);
        *(_BYTE *)(v12 + 165) = 1;
        return v12;
      }
LABEL_8:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
  return v8;
}

uint64_t re::AnimationClip<re::Vector3<float>>::isInstanced(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 165);
}

uint64_t re::AnimationClip<re::Vector3<float>>::derivedFillMode(uint64_t a1)
{
  char v1;
  uint64_t v3;

  v1 = *(_BYTE *)(a1 + 16);
  if (v1)
    return v1;
  v3 = *(_QWORD *)(a1 + 80);
  if (!v3)
    return 0;
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 56))(v3);
}

uint64_t re::AnimationClip<re::Vector3<float>>::evaluateCore(uint64_t result, uint64_t a2, unint64_t a3, float32x4_t *a4, uint64_t a5, float32x4_t *a6)
{
  uint64_t v8;
  uint64_t *v9;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  float32x4_t v17;
  uint64_t v18;
  float32x4_t *v19;
  float32x4_t *v20;
  uint64_t v21;
  uint64_t v22;
  char v23[8];
  uint64_t v24;
  char v25;
  uint64_t v26;
  char v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  char v31;
  uint64_t v32;
  _BYTE v33[4];
  int v34;
  uint64_t v35;
  char v36;
  uint64_t v37;
  char v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  char v42;
  uint64_t v43;
  float32x4_t v44;
  float32x4_t v45;
  uint64_t v46;
  unint64_t v47;

  v46 = a2;
  v47 = a3;
  if (a3)
  {
    v8 = result;
    v9 = *(uint64_t **)(result + 80);
    if (!v9)
    {
      v17 = *a4;
LABEL_23:
      *a6 = v17;
      return result;
    }
    if (*(_BYTE *)(result + 164) != 2 || !vcvtms_s32_f32(*(float *)(a2 + 60)))
    {
      v15 = re::Slice<re::AnimationClock>::range(&v46, 1uLL, a3);
      return (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, float32x4_t *, uint64_t, float32x4_t *))(*v9 + 96))(v9, v15, v16, a4, a5, a6);
    }
    v44 = 0u;
    v45 = 0u;
    if (v33[0] && v34 == 1)
    {
      v13 = *(_QWORD *)(v8 + 80);
      if (v13)
      {
        if (*(_BYTE *)(v8 + 88))
          v14 = *(_QWORD *)(v8 + 96);
        else
          v14 = 0;
        (*(void (**)(uint64_t))(*(_QWORD *)v13 + 40))(v13);
        if (*(_BYTE *)(v8 + 104))
          v18 = *(_QWORD *)(v8 + 112);
      }
      else
      {
        v18 = 0;
        v14 = 0;
      }
      v35 = 0;
      v38 = 0;
      v40 = 0;
      v41 = 0;
      v42 = 0;
      v33[0] = 3;
      v36 = 1;
      v37 = v14;
      v43 = 0x200000000;
      v39 = 1065353216;
      v24 = 0;
      v27 = 0;
      v29 = 0;
      v30 = 0;
      v31 = 0;
      v23[0] = 3;
      v25 = 1;
      v26 = v18;
      v32 = 0x200000000;
      v28 = 1065353216;
      if (*(_BYTE *)(v8 + 128))
        v19 = &v44;
      else
        v19 = &v45;
      if (*(_BYTE *)(v8 + 128))
        v20 = &v45;
      else
        v20 = &v44;
      (*(void (**)(uint64_t *, _BYTE *, uint64_t, float32x4_t *, uint64_t, float32x4_t *))(*v9 + 96))(v9, v33, 1, a4, a5, v19);
      (*(void (**)(uint64_t *, char *, uint64_t, float32x4_t *, uint64_t, float32x4_t *))(*v9 + 96))(v9, v23, 1, a4, a5, v20);
      v45 = vmulq_n_f32(vsubq_f32(v44, v45), (float)(int)floorf(*(float *)(a2 + 60)));
      v21 = re::Slice<re::AnimationClock>::range(&v46, 1uLL, v47);
      result = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, float32x4_t *, uint64_t, float32x4_t *))(*v9 + 96))(v9, v21, v22, a4, a5, a6);
      v17 = vaddq_f32(*a6, v45);
      goto LABEL_23;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
  }
  re::internal::assertLog((re::internal *)4, v12, "assertion failure: '%s' (%s:line %i) Not yet implemented. Cycle-offset computation currently does not yet support nested animations.", "internal::countTimelines(*source) == 1", "evaluateCore", 299);
  result = _os_crash();
  __break(1u);
  return result;
}

BOOL re::AnimationClip<re::Vector4<float>>::childCount(uint64_t a1)
{
  return *(_QWORD *)(a1 + 80) != 0;
}

uint64_t re::AnimationClip<re::Vector4<float>>::child(uint64_t a1)
{
  return *(_QWORD *)(a1 + 80);
}

double re::AnimationClip<re::Vector4<float>>::totalDuration(uint64_t a1)
{
  uint64_t v2;
  double v3;
  double v4;
  double v5;

  v2 = *(_QWORD *)(a1 + 80);
  if (v2)
  {
    if (*(_BYTE *)(a1 + 88))
      v3 = *(double *)(a1 + 96);
    else
      v3 = 0.0;
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    if (*(_BYTE *)(a1 + 104))
      v5 = *(double *)(a1 + 112);
    v4 = v5 - v3;
  }
  else
  {
    v4 = 0.0;
  }
  if (*(_BYTE *)(a1 + 144))
    v4 = *(double *)(a1 + 152);
  return *(double *)(a1 + 136) + v4 / fabsf(*(float *)(a1 + 160));
}

uint64_t re::AnimationClip<re::Vector4<float>>::timelineDesc@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  double v5;
  float v6;
  double v7;
  double v8;
  char v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  uint64_t result;

  v4 = *(_QWORD *)(a1 + 80);
  if (v4)
  {
    if (*(_BYTE *)(a1 + 88))
      v5 = *(double *)(a1 + 96);
    else
      v5 = 0.0;
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    if (*(_BYTE *)(a1 + 104))
      v7 = *(double *)(a1 + 112);
    v6 = v7 - v5;
  }
  else
  {
    v6 = 0.0;
    v5 = 0.0;
    v7 = 0.0;
  }
  if (!*(_BYTE *)(a1 + 144) || (v8 = *(double *)(a1 + 152), v8 == 0.0))
  {
    v9 = *(_BYTE *)(a1 + 164);
    if (v9)
      v6 = INFINITY;
  }
  else
  {
    v6 = v8;
    v9 = *(_BYTE *)(a1 + 164);
  }
  v10 = *(double *)(a1 + 136);
  *(float *)a2 = v10;
  *(float *)(a2 + 4) = v6;
  v11 = *(float *)(a1 + 160);
  if (*(_BYTE *)(a1 + 128))
    v11 = -v11;
  v12 = v5;
  *(float *)(a2 + 8) = v11;
  *(float *)(a2 + 12) = v12;
  v13 = v7;
  v14 = *(double *)(a1 + 120);
  *(float *)(a2 + 16) = v13;
  *(float *)(a2 + 20) = v14;
  *(_BYTE *)(a2 + 24) = v9;
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
  *(_BYTE *)(a2 + 25) = result;
  return result;
}

uint64_t re::AnimationClip<re::Vector4<float>>::createInstance(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v8 = a1;
  if ((*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1) == 1)
  {
    v9 = a5 + 1;
    if (*(_QWORD *)(a4 + 128) <= v9)
    {
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_8;
    }
    v10 = *(_QWORD *)(*(_QWORD *)(a4 + 136) + 8 * v9);
    if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v10 + 88))(v10))
    {
      v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 168, 8);
      v12 = re::AnimationClip<re::Vector4<float>>::AnimationClip(v11, v8);
      if (*(_QWORD *)(a4 + 128) > v9)
      {
        *(_QWORD *)(v12 + 80) = *(_QWORD *)(*(_QWORD *)(a4 + 136) + 8 * v9);
        *(_BYTE *)(v12 + 165) = 1;
        return v12;
      }
LABEL_8:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
  return v8;
}

uint64_t re::AnimationClip<re::Vector4<float>>::isInstanced(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 165);
}

uint64_t re::AnimationClip<re::Vector4<float>>::derivedFillMode(uint64_t a1)
{
  char v1;
  uint64_t v3;

  v1 = *(_BYTE *)(a1 + 16);
  if (v1)
    return v1;
  v3 = *(_QWORD *)(a1 + 80);
  if (!v3)
    return 0;
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 56))(v3);
}

uint64_t re::AnimationClip<re::Vector4<float>>::evaluateCore(uint64_t result, uint64_t a2, unint64_t a3, float32x4_t *a4, uint64_t a5, float32x4_t *a6)
{
  uint64_t v8;
  uint64_t *v9;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  float32x4_t v17;
  uint64_t v18;
  float32x4_t *v19;
  float32x4_t *v20;
  uint64_t v21;
  uint64_t v22;
  char v23[8];
  uint64_t v24;
  char v25;
  uint64_t v26;
  char v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  char v31;
  uint64_t v32;
  _BYTE v33[4];
  int v34;
  uint64_t v35;
  char v36;
  uint64_t v37;
  char v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  char v42;
  uint64_t v43;
  float32x4_t v44;
  float32x4_t v45;
  uint64_t v46;
  unint64_t v47;

  v46 = a2;
  v47 = a3;
  if (a3)
  {
    v8 = result;
    v9 = *(uint64_t **)(result + 80);
    if (!v9)
    {
      v17 = *a4;
LABEL_23:
      *a6 = v17;
      return result;
    }
    if (*(_BYTE *)(result + 164) != 2 || !vcvtms_s32_f32(*(float *)(a2 + 60)))
    {
      v15 = re::Slice<re::AnimationClock>::range(&v46, 1uLL, a3);
      return (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, float32x4_t *, uint64_t, float32x4_t *))(*v9 + 96))(v9, v15, v16, a4, a5, a6);
    }
    v44 = 0u;
    v45 = 0u;
    if (v33[0] && v34 == 1)
    {
      v13 = *(_QWORD *)(v8 + 80);
      if (v13)
      {
        if (*(_BYTE *)(v8 + 88))
          v14 = *(_QWORD *)(v8 + 96);
        else
          v14 = 0;
        (*(void (**)(uint64_t))(*(_QWORD *)v13 + 40))(v13);
        if (*(_BYTE *)(v8 + 104))
          v18 = *(_QWORD *)(v8 + 112);
      }
      else
      {
        v18 = 0;
        v14 = 0;
      }
      v35 = 0;
      v38 = 0;
      v40 = 0;
      v41 = 0;
      v42 = 0;
      v33[0] = 3;
      v36 = 1;
      v37 = v14;
      v43 = 0x200000000;
      v39 = 1065353216;
      v24 = 0;
      v27 = 0;
      v29 = 0;
      v30 = 0;
      v31 = 0;
      v23[0] = 3;
      v25 = 1;
      v26 = v18;
      v32 = 0x200000000;
      v28 = 1065353216;
      if (*(_BYTE *)(v8 + 128))
        v19 = &v44;
      else
        v19 = &v45;
      if (*(_BYTE *)(v8 + 128))
        v20 = &v45;
      else
        v20 = &v44;
      (*(void (**)(uint64_t *, _BYTE *, uint64_t, float32x4_t *, uint64_t, float32x4_t *))(*v9 + 96))(v9, v33, 1, a4, a5, v19);
      (*(void (**)(uint64_t *, char *, uint64_t, float32x4_t *, uint64_t, float32x4_t *))(*v9 + 96))(v9, v23, 1, a4, a5, v20);
      v45 = vmulq_n_f32(vsubq_f32(v44, v45), (float)(int)floorf(*(float *)(a2 + 60)));
      v21 = re::Slice<re::AnimationClock>::range(&v46, 1uLL, v47);
      result = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, float32x4_t *, uint64_t, float32x4_t *))(*v9 + 96))(v9, v21, v22, a4, a5, a6);
      v17 = vaddq_f32(*a6, v45);
      goto LABEL_23;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
  }
  re::internal::assertLog((re::internal *)4, v12, "assertion failure: '%s' (%s:line %i) Not yet implemented. Cycle-offset computation currently does not yet support nested animations.", "internal::countTimelines(*source) == 1", "evaluateCore", 299);
  result = _os_crash();
  __break(1u);
  return result;
}

BOOL re::AnimationClip<re::Quaternion<float>>::childCount(uint64_t a1)
{
  return *(_QWORD *)(a1 + 80) != 0;
}

uint64_t re::AnimationClip<re::Quaternion<float>>::child(uint64_t a1)
{
  return *(_QWORD *)(a1 + 80);
}

double re::AnimationClip<re::Quaternion<float>>::totalDuration(uint64_t a1)
{
  uint64_t v2;
  double v3;
  double v4;
  double v5;

  v2 = *(_QWORD *)(a1 + 80);
  if (v2)
  {
    if (*(_BYTE *)(a1 + 88))
      v3 = *(double *)(a1 + 96);
    else
      v3 = 0.0;
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    if (*(_BYTE *)(a1 + 104))
      v5 = *(double *)(a1 + 112);
    v4 = v5 - v3;
  }
  else
  {
    v4 = 0.0;
  }
  if (*(_BYTE *)(a1 + 144))
    v4 = *(double *)(a1 + 152);
  return *(double *)(a1 + 136) + v4 / fabsf(*(float *)(a1 + 160));
}

uint64_t re::AnimationClip<re::Quaternion<float>>::timelineDesc@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  double v5;
  float v6;
  double v7;
  double v8;
  char v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  uint64_t result;

  v4 = *(_QWORD *)(a1 + 80);
  if (v4)
  {
    if (*(_BYTE *)(a1 + 88))
      v5 = *(double *)(a1 + 96);
    else
      v5 = 0.0;
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    if (*(_BYTE *)(a1 + 104))
      v7 = *(double *)(a1 + 112);
    v6 = v7 - v5;
  }
  else
  {
    v6 = 0.0;
    v5 = 0.0;
    v7 = 0.0;
  }
  if (!*(_BYTE *)(a1 + 144) || (v8 = *(double *)(a1 + 152), v8 == 0.0))
  {
    v9 = *(_BYTE *)(a1 + 164);
    if (v9)
      v6 = INFINITY;
  }
  else
  {
    v6 = v8;
    v9 = *(_BYTE *)(a1 + 164);
  }
  v10 = *(double *)(a1 + 136);
  *(float *)a2 = v10;
  *(float *)(a2 + 4) = v6;
  v11 = *(float *)(a1 + 160);
  if (*(_BYTE *)(a1 + 128))
    v11 = -v11;
  v12 = v5;
  *(float *)(a2 + 8) = v11;
  *(float *)(a2 + 12) = v12;
  v13 = v7;
  v14 = *(double *)(a1 + 120);
  *(float *)(a2 + 16) = v13;
  *(float *)(a2 + 20) = v14;
  *(_BYTE *)(a2 + 24) = v9;
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
  *(_BYTE *)(a2 + 25) = result;
  return result;
}

uint64_t re::AnimationClip<re::Quaternion<float>>::createInstance(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v8 = a1;
  if ((*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1) == 1)
  {
    v9 = a5 + 1;
    if (*(_QWORD *)(a4 + 128) <= v9)
    {
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_8;
    }
    v10 = *(_QWORD *)(*(_QWORD *)(a4 + 136) + 8 * v9);
    if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v10 + 88))(v10))
    {
      v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 168, 8);
      v12 = re::AnimationClip<re::Quaternion<float>>::AnimationClip(v11, v8);
      if (*(_QWORD *)(a4 + 128) > v9)
      {
        *(_QWORD *)(v12 + 80) = *(_QWORD *)(*(_QWORD *)(a4 + 136) + 8 * v9);
        *(_BYTE *)(v12 + 165) = 1;
        return v12;
      }
LABEL_8:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
  return v8;
}

uint64_t re::AnimationClip<re::Quaternion<float>>::isInstanced(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 165);
}

uint64_t re::AnimationClip<re::Quaternion<float>>::derivedFillMode(uint64_t a1)
{
  char v1;
  uint64_t v3;

  v1 = *(_BYTE *)(a1 + 16);
  if (v1)
    return v1;
  v3 = *(_QWORD *)(a1 + 80);
  if (!v3)
    return 0;
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 56))(v3);
}

uint64_t re::AnimationClip<re::Quaternion<float>>::evaluateCore(uint64_t result, uint64_t a2, unint64_t a3, int32x4_t *a4, uint64_t a5, int32x4_t *a6)
{
  uint64_t v8;
  uint64_t *v9;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  __int128 *v18;
  __int128 *v19;
  int32x4_t v21;
  float32x4_t v23;
  float32x4_t v24;
  uint64_t v30;
  uint64_t v31;
  float32x4_t v34;
  float32x4_t v35;
  char v37[8];
  uint64_t v38;
  char v39;
  uint64_t v40;
  char v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  char v45;
  uint64_t v46;
  _BYTE v47[4];
  int v48;
  uint64_t v49;
  char v50;
  uint64_t v51;
  char v52;
  int v53;
  uint64_t v54;
  uint64_t v55;
  char v56;
  uint64_t v57;
  __int128 v58;
  __int128 v59;
  uint64_t v60;
  unint64_t v61;

  v60 = a2;
  v61 = a3;
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_24:
    re::internal::assertLog((re::internal *)4, v12, "assertion failure: '%s' (%s:line %i) Not yet implemented. Cycle-offset computation currently does not yet support nested animations.", "internal::countTimelines(*source) == 1", "evaluateCore", 299);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v8 = result;
  v9 = *(uint64_t **)(result + 80);
  if (!v9)
  {
    *a6 = *a4;
    return result;
  }
  if (*(_BYTE *)(result + 164) != 2 || !vcvtms_s32_f32(*(float *)(a2 + 60)))
  {
    v15 = re::Slice<re::AnimationClock>::range(&v60, 1uLL, a3);
    return (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, int32x4_t *, uint64_t, int32x4_t *))(*v9 + 96))(v9, v15, v16, a4, a5, a6);
  }
  v58 = xmmword_2260E5D70;
  v59 = xmmword_2260E5D70;
  if (!v47[0] || v48 != 1)
    goto LABEL_24;
  v13 = *(_QWORD *)(v8 + 80);
  if (v13)
  {
    if (*(_BYTE *)(v8 + 88))
      v14 = *(_QWORD *)(v8 + 96);
    else
      v14 = 0;
    (*(void (**)(uint64_t))(*(_QWORD *)v13 + 40))(v13);
    if (*(_BYTE *)(v8 + 104))
      v17 = *(_QWORD *)(v8 + 112);
  }
  else
  {
    v17 = 0;
    v14 = 0;
  }
  v49 = 0;
  v52 = 0;
  v54 = 0;
  v55 = 0;
  v56 = 0;
  v47[0] = 3;
  v50 = 1;
  v51 = v14;
  v57 = 0x200000000;
  v53 = 1065353216;
  v38 = 0;
  v41 = 0;
  v43 = 0;
  v44 = 0;
  v45 = 0;
  v37[0] = 3;
  v39 = 1;
  v40 = v17;
  v46 = 0x200000000;
  v42 = 1065353216;
  if (*(_BYTE *)(v8 + 128))
    v18 = &v58;
  else
    v18 = &v59;
  if (*(_BYTE *)(v8 + 128))
    v19 = &v59;
  else
    v19 = &v58;
  (*(void (**)(uint64_t *, _BYTE *, uint64_t, int32x4_t *, uint64_t, __int128 *))(*v9 + 96))(v9, v47, 1, a4, a5, v18);
  (*(void (**)(uint64_t *, char *, uint64_t, int32x4_t *, uint64_t, __int128 *))(*v9 + 96))(v9, v37, 1, a4, a5, v19);
  _Q2 = (int32x4_t)v58;
  v21 = (int32x4_t)vnegq_f32((float32x4_t)v59);
  _Q4 = (int32x4_t)vmlsq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v21, v21), (int8x16_t)v21, 0xCuLL), vnegq_f32((float32x4_t)v58)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(_Q2, _Q2), (int8x16_t)v58, 0xCuLL), (float32x4_t)v59);
  v23 = vmlsq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(_Q4, _Q4), (int8x16_t)_Q4, 0xCuLL), (float32x4_t)v59, (float32x4_t)v58, 3);
  _Q4.i32[0] = HIDWORD(v59);
  v24 = vmlaq_laneq_f32(v23, (float32x4_t)v58, (float32x4_t)v59, 3);
  __asm { FMLA            S0, S4, V2.S[3] }
  v24.i32[3] = _S0;
  v59 = (__int128)v24;
  re::AnimationValueTraits<re::Quaternion<float>>::repeat((float32x4_t *)&v59, vcvtms_s32_f32(*(float *)(a2 + 60)), (unint64_t *)&v59);
  v30 = re::Slice<re::AnimationClock>::range(&v60, 1uLL, v61);
  result = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, int32x4_t *, uint64_t, int32x4_t *))(*v9 + 96))(v9, v30, v31, a4, a5, a6);
  _Q0 = (int32x4_t)v59;
  _Q3 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(*a6, *a6), *(int8x16_t *)a6, 0xCuLL), vnegq_f32((float32x4_t)v59)), *(float32x4_t *)a6, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(_Q0, _Q0), (int8x16_t)v59, 0xCuLL));
  v34 = vmlaq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(_Q3, _Q3), (int8x16_t)_Q3, 0xCuLL), *(float32x4_t *)a6, (float32x4_t)v59, 3);
  _Q3.i32[0] = HIDWORD(*(unsigned __int128 *)a6);
  v35 = vmlaq_laneq_f32(v34, (float32x4_t)v59, *(float32x4_t *)a6, 3);
  __asm { FMLA            S1, S3, V0.S[3] }
  v35.i32[3] = _S1;
  *a6 = (int32x4_t)v35;
  return result;
}

void re::AnimationValueTraits<re::Quaternion<float>>::repeat(float32x4_t *a1, int a2, unint64_t *a3)
{
  float v4;
  float v5;
  float v6;
  float32x4_t v7;
  float32x4_t v8;
  float v9;
  float32x4_t v10;
  float v11;
  float v12;
  float32x4_t v13;
  float32x4_t v14;
  float v15;
  float32x2_t v16;
  float v17;
  float v18;
  float32x4_t v19;
  float v20;
  float v21;
  float32x2_t v22;

  v4 = (float)a2;
  v5 = a1->f32[3];
  v6 = fabsf(v5);
  if (v6 > 1.0 && fabsf(v6 + -1.0) >= (float)((float)((float)(v6 + 1.0) + 1.0) * 0.00001))
  {
    v10 = (float32x4_t)vdupq_n_s32(0x7FC00000u);
  }
  else
  {
    v7 = *a1;
    v8 = vmulq_f32(v7, v7);
    v9 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v8, 2), vaddq_f32(v8, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.f32, 1))).f32[0]);
    if (fabsf(v9) >= 0.00001)
    {
      v19 = *a1;
      v21 = (float)a2;
      v11 = atanf(v9 / v5);
      v4 = v21;
      v12 = v11 / v9;
      *(float32x2_t *)v10.f32 = vmul_n_f32(*(float32x2_t *)v19.f32, v11 / v9);
      v10.i64[1] = COERCE_UNSIGNED_INT(vmuls_lane_f32(v12, v19, 2));
    }
    else
    {
      v7.i32[3] = 0;
      v10 = v7;
    }
  }
  v13 = vmulq_n_f32(v10, v4);
  v14 = vmulq_f32(v13, v13);
  v15 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 2), vaddq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 1))).f32[0]);
  v16.i32[1] = v13.i32[1];
  v16.i32[0] = vextq_s8((int8x16_t)v13, (int8x16_t)v13, 8uLL).u32[0];
  v20 = v13.f32[0];
  v22 = v16;
  if (v15 > 0.00001)
  {
    v17 = sinf(v15) / v15;
    v20 = v20 * v17;
    v22 = vmul_n_f32(v22, v17);
  }
  v18 = cosf(v15);
  *a3 = LODWORD(v20) | ((unint64_t)v22.u32[1] << 32);
  a3[1] = v22.u32[0] | ((unint64_t)LODWORD(v18) << 32);
}

BOOL re::AnimationClip<re::GenericSRT<float>>::childCount(uint64_t a1)
{
  return *(_QWORD *)(a1 + 80) != 0;
}

uint64_t re::AnimationClip<re::GenericSRT<float>>::child(uint64_t a1)
{
  return *(_QWORD *)(a1 + 80);
}

double re::AnimationClip<re::GenericSRT<float>>::totalDuration(uint64_t a1)
{
  uint64_t v2;
  double v3;
  double v4;
  double v5;

  v2 = *(_QWORD *)(a1 + 80);
  if (v2)
  {
    if (*(_BYTE *)(a1 + 88))
      v3 = *(double *)(a1 + 96);
    else
      v3 = 0.0;
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    if (*(_BYTE *)(a1 + 104))
      v5 = *(double *)(a1 + 112);
    v4 = v5 - v3;
  }
  else
  {
    v4 = 0.0;
  }
  if (*(_BYTE *)(a1 + 144))
    v4 = *(double *)(a1 + 152);
  return *(double *)(a1 + 136) + v4 / fabsf(*(float *)(a1 + 160));
}

uint64_t re::AnimationClip<re::GenericSRT<float>>::timelineDesc@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  double v5;
  float v6;
  double v7;
  double v8;
  char v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  uint64_t result;

  v4 = *(_QWORD *)(a1 + 80);
  if (v4)
  {
    if (*(_BYTE *)(a1 + 88))
      v5 = *(double *)(a1 + 96);
    else
      v5 = 0.0;
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    if (*(_BYTE *)(a1 + 104))
      v7 = *(double *)(a1 + 112);
    v6 = v7 - v5;
  }
  else
  {
    v6 = 0.0;
    v5 = 0.0;
    v7 = 0.0;
  }
  if (!*(_BYTE *)(a1 + 144) || (v8 = *(double *)(a1 + 152), v8 == 0.0))
  {
    v9 = *(_BYTE *)(a1 + 164);
    if (v9)
      v6 = INFINITY;
  }
  else
  {
    v6 = v8;
    v9 = *(_BYTE *)(a1 + 164);
  }
  v10 = *(double *)(a1 + 136);
  *(float *)a2 = v10;
  *(float *)(a2 + 4) = v6;
  v11 = *(float *)(a1 + 160);
  if (*(_BYTE *)(a1 + 128))
    v11 = -v11;
  v12 = v5;
  *(float *)(a2 + 8) = v11;
  *(float *)(a2 + 12) = v12;
  v13 = v7;
  v14 = *(double *)(a1 + 120);
  *(float *)(a2 + 16) = v13;
  *(float *)(a2 + 20) = v14;
  *(_BYTE *)(a2 + 24) = v9;
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
  *(_BYTE *)(a2 + 25) = result;
  return result;
}

uint64_t re::AnimationClip<re::GenericSRT<float>>::createInstance(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v8 = a1;
  if ((*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1) == 1)
  {
    v9 = a5 + 1;
    if (*(_QWORD *)(a4 + 128) <= v9)
    {
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_8;
    }
    v10 = *(_QWORD *)(*(_QWORD *)(a4 + 136) + 8 * v9);
    if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v10 + 88))(v10))
    {
      v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 168, 8);
      v12 = re::AnimationClip<re::GenericSRT<float>>::AnimationClip(v11, v8);
      if (*(_QWORD *)(a4 + 128) > v9)
      {
        *(_QWORD *)(v12 + 80) = *(_QWORD *)(*(_QWORD *)(a4 + 136) + 8 * v9);
        *(_BYTE *)(v12 + 165) = 1;
        return v12;
      }
LABEL_8:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
  return v8;
}

uint64_t re::AnimationClip<re::GenericSRT<float>>::isInstanced(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 165);
}

uint64_t re::AnimationClip<re::GenericSRT<float>>::derivedFillMode(uint64_t a1)
{
  char v1;
  uint64_t v3;

  v1 = *(_BYTE *)(a1 + 16);
  if (v1)
    return v1;
  v3 = *(_QWORD *)(a1 + 80);
  if (!v3)
    return 0;
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 56))(v3);
}

void re::AnimationClip<re::GenericSRT<float>>::evaluateCore(uint64_t a1, uint64_t a2, unint64_t a3, __int128 *a4, uint64_t a5, uint64_t a6)
{
  uint64_t *v9;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;
  __int128 v18;
  uint64_t v19;
  float32x4_t *v20;
  float32x4_t *v21;
  float32x4_t v27;
  int32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  int32x4_t v31;
  float32x4_t v32;
  int32x4_t v34;
  float32x4_t v35;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  int32x4_t v40;
  float32x4_t v41;
  float32x4_t v43;
  int32x4_t v44;
  float32x4_t v45;
  int32x4_t v46;
  uint64_t v47;
  uint64_t v48;
  char v49[8];
  uint64_t v50;
  char v51;
  uint64_t v52;
  char v53;
  int v54;
  uint64_t v55;
  uint64_t v56;
  char v57;
  uint64_t v58;
  _BYTE v59[4];
  int v60;
  uint64_t v61;
  char v62;
  uint64_t v63;
  char v64;
  int v65;
  uint64_t v66;
  uint64_t v67;
  char v68;
  uint64_t v69;
  float32x4_t v70;
  int8x16_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  uint64_t v76;
  unint64_t v77;

  v76 = a2;
  v77 = a3;
  if (!a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    _os_crash();
    __break(1u);
LABEL_24:
    re::internal::assertLog((re::internal *)4, v12, "assertion failure: '%s' (%s:line %i) Not yet implemented. Cycle-offset computation currently does not yet support nested animations.", "internal::countTimelines(*source) == 1", "evaluateCore", 299);
    _os_crash();
    __break(1u);
    return;
  }
  v9 = *(uint64_t **)(a1 + 80);
  if (!v9)
  {
    v17 = *a4;
    v18 = a4[2];
    *(_OWORD *)(a6 + 16) = a4[1];
    *(_OWORD *)(a6 + 32) = v18;
    *(_OWORD *)a6 = v17;
    return;
  }
  if (*(_BYTE *)(a1 + 164) != 2 || !vcvtms_s32_f32(*(float *)(a2 + 60)))
  {
    v15 = re::Slice<re::AnimationClock>::range(&v76, 1uLL, a3);
    (*(void (**)(uint64_t *, uint64_t, uint64_t, __int128 *, uint64_t, uint64_t))(*v9 + 96))(v9, v15, v16, a4, a5, a6);
    return;
  }
  v73.i64[0] = 0x3F8000003F800000;
  v73.i64[1] = 1065353216;
  v74.i64[0] = 0;
  v74.i64[1] = 0x3F80000000000000;
  v75 = 0uLL;
  v70.i64[0] = 0x3F8000003F800000;
  v70.i64[1] = 1065353216;
  v71.i64[0] = 0;
  v71.i64[1] = 0x3F80000000000000;
  v72 = 0uLL;
  if (!v59[0] || v60 != 1)
    goto LABEL_24;
  v13 = *(_QWORD *)(a1 + 80);
  if (v13)
  {
    if (*(_BYTE *)(a1 + 88))
      v14 = *(_QWORD *)(a1 + 96);
    else
      v14 = 0;
    (*(void (**)(uint64_t))(*(_QWORD *)v13 + 40))(v13);
    if (*(_BYTE *)(a1 + 104))
      v19 = *(_QWORD *)(a1 + 112);
  }
  else
  {
    v19 = 0;
    v14 = 0;
  }
  v61 = 0;
  v64 = 0;
  v66 = 0;
  v67 = 0;
  v68 = 0;
  v59[0] = 3;
  v62 = 1;
  v63 = v14;
  v69 = 0x200000000;
  v65 = 1065353216;
  v50 = 0;
  v53 = 0;
  v55 = 0;
  v56 = 0;
  v57 = 0;
  v49[0] = 3;
  v51 = 1;
  v52 = v19;
  v58 = 0x200000000;
  v54 = 1065353216;
  if (*(_BYTE *)(a1 + 128))
    v20 = &v70;
  else
    v20 = &v73;
  if (*(_BYTE *)(a1 + 128))
    v21 = &v73;
  else
    v21 = &v70;
  (*(void (**)(uint64_t *, _BYTE *, uint64_t, __int128 *, uint64_t, float32x4_t *))(*v9 + 96))(v9, v59, 1, a4, a5, v20);
  (*(void (**)(uint64_t *, char *, uint64_t, __int128 *, uint64_t, float32x4_t *))(*v9 + 96))(v9, v49, 1, a4, a5, v21);
  __asm { FMOV            V3.4S, #1.0 }
  v27 = vdivq_f32(_Q3, v73);
  v28 = (int32x4_t)vnegq_f32(v74);
  v29 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v28, v28), (int8x16_t)v28, 0xCuLL);
  v30 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v75, (int32x4_t)v75), (int8x16_t)v75, 0xCuLL), v74), v75, v29);
  v31 = (int32x4_t)vaddq_f32(v30, v30);
  v32 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v31, v31), (int8x16_t)v31, 0xCuLL);
  _S7 = v74.i32[3];
  v34 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v32, (int32x4_t)v32), (int8x16_t)v32, 0xCuLL), v74), v32, v29);
  v35 = vmulq_f32(vaddq_f32(vaddq_f32(v75, vmulq_laneq_f32(v32, v74, 3)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v34, v34), (int8x16_t)v34, 0xCuLL)), vnegq_f32(v27));
  _Q6 = (int32x4_t)v71;
  v37 = vmulq_f32(v27, v70);
  v38 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(_Q6, _Q6), v71, 0xCuLL);
  v39 = vnegq_f32((float32x4_t)v71);
  v40 = (int32x4_t)vmlsq_f32(vmulq_f32(v29, v39), v38, v74);
  v41 = vmlaq_laneq_f32(vmlsq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v40, v40), (int8x16_t)v40, 0xCuLL), v74, (float32x4_t)v71, 3), (float32x4_t)v71, v74, 3);
  __asm { FMLA            S1, S7, V6.S[3] }
  v41.i32[3] = _S1;
  v43 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v35, (int32x4_t)v35), (int8x16_t)v35, 0xCuLL), v39), v35, v38);
  v44 = (int32x4_t)vaddq_f32(v43, v43);
  v45 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v44, v44), (int8x16_t)v44, 0xCuLL);
  v46 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v45, (int32x4_t)v45), (int8x16_t)v45, 0xCuLL), v39), v45, v38);
  v73 = v37;
  v74 = v41;
  v75 = vaddq_f32(v72, vmulq_f32(v70, vaddq_f32(vaddq_f32(v35, vmulq_laneq_f32(v45, (float32x4_t)v71, 3)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v46, v46), (int8x16_t)v46, 0xCuLL))));
  v37.i32[0] = *(_DWORD *)(a2 + 60);
  re::AnimationValueTraits<re::GenericSRT<float>>::repeat(&v73, vcvtms_s32_f32(v37.f32[0]), &v73, v37);
  v47 = re::Slice<re::AnimationClock>::range(&v76, 1uLL, v77);
  (*(void (**)(uint64_t *, uint64_t, uint64_t, __int128 *, uint64_t, uint64_t))(*v9 + 96))(v9, v47, v48, a4, a5, a6);
  re::AnimationValueTraits<re::GenericSRT<float>>::combine((float32x4_t *)a6, &v73, (float32x4_t *)a6);
}

float32x4_t re::AnimationValueTraits<re::GenericSRT<float>>::repeat(float32x4_t *a1, unsigned int a2, float32x4_t *a3, float32x4_t result)
{
  float32x4_t v4;
  float32x4_t v5;
  float32x4_t v6;
  float32x4_t v7;
  float32x4_t v8;
  int32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  int32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  int32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  int32x4_t v29;
  float32x4_t v30;
  int32x4_t v31;
  float32x4_t v32;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v37;
  float32x4_t v38;
  int32x4_t v39;
  float32x4_t v42;
  float32x4_t v44;
  int32x4_t v45;
  float32x4_t v46;
  float32x4_t v48;
  int32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  int32x4_t v52;
  float32x4_t v53;
  int32x4_t v54;
  float32x4_t v55;
  BOOL v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  int32x4_t v60;
  float32x4_t v61;
  float32x4_t v64;
  int32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  int32x4_t v68;

  if (a2)
  {
    if ((a2 & 0x80000000) != 0)
    {
      v7 = a1[1];
      v8 = a1[2];
      __asm { FMOV            V3.4S, #1.0 }
      v6 = vdivq_f32(_Q3, *a1);
      v14 = (int32x4_t)vnegq_f32(v7);
      v15 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v14, v14), (int8x16_t)v14, 0xCuLL);
      v14.i32[3] = v7.i32[3];
      v16 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v8, (int32x4_t)v8), (int8x16_t)v8, 0xCuLL), v7), v8, v15);
      v17 = (int32x4_t)vaddq_f32(v16, v16);
      v18 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v17, v17), (int8x16_t)v17, 0xCuLL);
      v19 = vaddq_f32(v8, vmulq_laneq_f32(v18, v7, 3));
      v20 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v18, (int32x4_t)v18), (int8x16_t)v18, 0xCuLL), v7), v18, v15);
      a3[1] = (float32x4_t)v14;
      a3[2] = vmulq_f32(vaddq_f32(v19, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v20, v20), (int8x16_t)v20, 0xCuLL)), vnegq_f32(v6));
      a2 = -a2;
    }
    else
    {
      v4 = a1[2];
      v5 = *a1;
      a3[1] = a1[1];
      a3[2] = v4;
      *a3 = v5;
      v6 = *a3;
    }
    if (a2 <= 1)
    {
      v22 = (float32x4_t)xmmword_2260E5D70;
      v21 = (float32x4_t)xmmword_2260EDC60;
      _Q2 = a3[1];
      v23 = a3[2];
      v25 = 0uLL;
    }
    else
    {
      v21 = (float32x4_t)xmmword_2260EDC60;
      v22 = (float32x4_t)xmmword_2260E5D70;
      _Q2 = a3[1];
      v23 = a3[2];
      v25 = 0uLL;
      do
      {
        if ((a2 & 1) != 0)
        {
          v21 = vmulq_f32(v21, v6);
          v37 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q2, (int32x4_t)_Q2), (int8x16_t)_Q2, 0xCuLL);
          v38 = vnegq_f32(_Q2);
          v39 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v22, (int32x4_t)v22), (int8x16_t)v22, 0xCuLL), v38), v22, v37);
          _S17 = _Q2.i32[3];
          _S18 = v22.i32[3];
          v42 = vmlaq_laneq_f32(vmlaq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v39, v39), (int8x16_t)v39, 0xCuLL), v22, _Q2, 3), _Q2, v22, 3);
          __asm { FMLA            S5, S18, V2.S[3] }
          v42.i32[3] = _S5;
          v44 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v25, (int32x4_t)v25), (int8x16_t)v25, 0xCuLL), v38), v25, v37);
          v45 = (int32x4_t)vaddq_f32(v44, v44);
          v46 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v45, v45), (int8x16_t)v45, 0xCuLL);
          _Q18 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v46, (int32x4_t)v46), (int8x16_t)v46, 0xCuLL), v38), v46, v37);
          v48 = vmulq_f32(v6, vaddq_f32(vaddq_f32(v25, vmulq_laneq_f32(v46, _Q2, 3)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(_Q18, _Q18), (int8x16_t)_Q18, 0xCuLL)));
          v49 = (int32x4_t)vmlaq_f32(vmulq_f32(v37, v38), _Q2, v37);
          v50 = vmlaq_laneq_f32(vmlaq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v49, v49), (int8x16_t)v49, 0xCuLL), _Q2, _Q2, 3), _Q2, _Q2, 3);
          __asm { FMLA            S18, S17, V2.S[3] }
          v50.i32[3] = _Q18.i32[0];
          v25 = vaddq_f32(v23, v48);
          v51 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v23, (int32x4_t)v23), (int8x16_t)v23, 0xCuLL), v38), v23, v37);
          v52 = (int32x4_t)vaddq_f32(v51, v51);
          v53 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v52, v52), (int8x16_t)v52, 0xCuLL);
          v54 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v53, (int32x4_t)v53), (int8x16_t)v53, 0xCuLL), v38), v53, v37);
          v55 = vmulq_f32(v6, vaddq_f32(vaddq_f32(v23, vmulq_laneq_f32(v53, _Q2, 3)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v54, v54), (int8x16_t)v54, 0xCuLL)));
          v6 = vmulq_f32(v6, v6);
          v23 = vaddq_f32(v23, v55);
          --a2;
          _Q2 = v50;
          v22 = v42;
        }
        else
        {
          v26 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q2, (int32x4_t)_Q2), (int8x16_t)_Q2, 0xCuLL);
          v27 = vnegq_f32(_Q2);
          v28 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v23, (int32x4_t)v23), (int8x16_t)v23, 0xCuLL), v27), v23, v26);
          v29 = (int32x4_t)vaddq_f32(v28, v28);
          v30 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v29, v29), (int8x16_t)v29, 0xCuLL);
          v31 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v30, (int32x4_t)v30), (int8x16_t)v30, 0xCuLL), v27), v30, v26);
          v32 = vmulq_f32(v6, vaddq_f32(vaddq_f32(v23, vmulq_laneq_f32(v30, _Q2, 3)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v31, v31), (int8x16_t)v31, 0xCuLL)));
          v6 = vmulq_f32(v6, v6);
          _Q7 = (int32x4_t)vmlaq_f32(vmulq_f32(v26, v27), _Q2, v26);
          v34 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(_Q7, _Q7), (int8x16_t)_Q7, 0xCuLL);
          _Q7.i32[0] = _Q2.i32[3];
          v35 = vmlaq_laneq_f32(vmlaq_laneq_f32(v34, _Q2, _Q2, 3), _Q2, _Q2, 3);
          __asm { FMLA            S17, S7, V2.S[3] }
          v35.i32[3] = _S17;
          v23 = vaddq_f32(v23, v32);
          _Q2 = v35;
        }
        v56 = a2 > 3;
        a2 >>= 1;
      }
      while (v56);
    }
    v57 = vmulq_f32(v6, v21);
    v58 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q2, (int32x4_t)_Q2), (int8x16_t)_Q2, 0xCuLL);
    v59 = vnegq_f32(_Q2);
    v60 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v22, (int32x4_t)v22), (int8x16_t)v22, 0xCuLL), v59), v22, v58);
    v61 = vmlaq_laneq_f32(vmlaq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v60, v60), (int8x16_t)v60, 0xCuLL), v22, _Q2, 3), _Q2, v22, 3);
    _S5 = v22.i32[3];
    __asm { FMLA            S17, S5, V2.S[3] }
    v61.i32[3] = _S17;
    v64 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v25, (int32x4_t)v25), (int8x16_t)v25, 0xCuLL), v59), v25, v58);
    v65 = (int32x4_t)vaddq_f32(v64, v64);
    v66 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v65, v65), (int8x16_t)v65, 0xCuLL);
    v67 = vaddq_f32(v25, vmulq_laneq_f32(v66, _Q2, 3));
    v68 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v66, (int32x4_t)v66), (int8x16_t)v66, 0xCuLL), v59), v66, v58);
    result = vaddq_f32(v23, vmulq_f32(v6, vaddq_f32(v67, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v68, v68), (int8x16_t)v68, 0xCuLL))));
    *a3 = v57;
    a3[1] = v61;
    a3[2] = result;
  }
  else
  {
    a3->i64[0] = 0x3F8000003F800000;
    a3->i64[1] = 1065353216;
    a3[1].i64[0] = 0;
    a3[1].i64[1] = 0x3F80000000000000;
    a3[2].i64[0] = 0;
    a3[2].i64[1] = 0;
  }
  return result;
}

BOOL re::AnimationClip<re::SkeletalPose>::childCount(uint64_t a1)
{
  return *(_QWORD *)(a1 + 80) != 0;
}

uint64_t re::AnimationClip<re::SkeletalPose>::child(uint64_t a1)
{
  return *(_QWORD *)(a1 + 80);
}

double re::AnimationClip<re::SkeletalPose>::totalDuration(uint64_t a1)
{
  uint64_t v2;
  double v3;
  double v4;
  double v5;

  v2 = *(_QWORD *)(a1 + 80);
  if (v2)
  {
    if (*(_BYTE *)(a1 + 88))
      v3 = *(double *)(a1 + 96);
    else
      v3 = 0.0;
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    if (*(_BYTE *)(a1 + 104))
      v5 = *(double *)(a1 + 112);
    v4 = v5 - v3;
  }
  else
  {
    v4 = 0.0;
  }
  if (*(_BYTE *)(a1 + 144))
    v4 = *(double *)(a1 + 152);
  return *(double *)(a1 + 136) + v4 / fabsf(*(float *)(a1 + 160));
}

uint64_t re::AnimationClip<re::SkeletalPose>::timelineDesc@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  double v5;
  float v6;
  double v7;
  double v8;
  char v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  uint64_t result;

  v4 = *(_QWORD *)(a1 + 80);
  if (v4)
  {
    if (*(_BYTE *)(a1 + 88))
      v5 = *(double *)(a1 + 96);
    else
      v5 = 0.0;
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    if (*(_BYTE *)(a1 + 104))
      v7 = *(double *)(a1 + 112);
    v6 = v7 - v5;
  }
  else
  {
    v6 = 0.0;
    v5 = 0.0;
    v7 = 0.0;
  }
  if (!*(_BYTE *)(a1 + 144) || (v8 = *(double *)(a1 + 152), v8 == 0.0))
  {
    v9 = *(_BYTE *)(a1 + 164);
    if (v9)
      v6 = INFINITY;
  }
  else
  {
    v6 = v8;
    v9 = *(_BYTE *)(a1 + 164);
  }
  v10 = *(double *)(a1 + 136);
  *(float *)a2 = v10;
  *(float *)(a2 + 4) = v6;
  v11 = *(float *)(a1 + 160);
  if (*(_BYTE *)(a1 + 128))
    v11 = -v11;
  v12 = v5;
  *(float *)(a2 + 8) = v11;
  *(float *)(a2 + 12) = v12;
  v13 = v7;
  v14 = *(double *)(a1 + 120);
  *(float *)(a2 + 16) = v13;
  *(float *)(a2 + 20) = v14;
  *(_BYTE *)(a2 + 24) = v9;
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
  *(_BYTE *)(a2 + 25) = result;
  return result;
}

uint64_t re::AnimationClip<re::SkeletalPose>::createInstance(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v8 = a1;
  if ((*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1) == 1)
  {
    v9 = a5 + 1;
    if (*(_QWORD *)(a4 + 128) <= v9)
    {
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_8;
    }
    v10 = *(_QWORD *)(*(_QWORD *)(a4 + 136) + 8 * v9);
    if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v10 + 88))(v10))
    {
      v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 168, 8);
      v12 = re::AnimationClip<re::SkeletalPose>::AnimationClip(v11, v8);
      if (*(_QWORD *)(a4 + 128) > v9)
      {
        *(_QWORD *)(v12 + 80) = *(_QWORD *)(*(_QWORD *)(a4 + 136) + 8 * v9);
        *(_BYTE *)(v12 + 165) = 1;
        return v12;
      }
LABEL_8:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
  return v8;
}

uint64_t re::AnimationClip<re::SkeletalPose>::isInstanced(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 165);
}

uint64_t re::AnimationClip<re::SkeletalPose>::derivedFillMode(uint64_t a1)
{
  char v1;
  uint64_t v3;

  v1 = *(_BYTE *)(a1 + 16);
  if (v1)
    return v1;
  v3 = *(_QWORD *)(a1 + 80);
  if (!v3)
    return 0;
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 56))(v3);
}

_QWORD *re::AnimationClip<re::SkeletalPose>::evaluateCore(uint64_t a1, uint64_t a2, unint64_t a3, _QWORD *a4, uint64_t a5, _QWORD *a6)
{
  uint64_t v6;
  _QWORD *v7;
  uint64_t *v8;
  uint64_t v10;
  uint64_t v11;
  _QWORD *result;
  uint64_t v13;
  __n128 v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  char v21[8];
  uint64_t v22;
  char v23;
  unint64_t v24;
  char v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  char v29;
  uint64_t v30;
  _BYTE v31[4];
  int v32;
  uint64_t v33;
  char v34;
  uint64_t v35;
  char v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  char v40;
  uint64_t v41;
  uint64_t v42[2];
  __int128 v43;
  __int128 v44;
  __int128 v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49[2];
  __int128 v50;
  __int128 v51;
  __int128 v52;
  int v53;
  uint64_t v54;
  uint64_t v55;
  _QWORD v56[2];

  v56[0] = a2;
  v56[1] = a3;
  if (a3)
  {
    v7 = a4;
    v8 = *(uint64_t **)(a1 + 80);
    if (!v8)
      return re::AnimationValueTraits<re::SkeletalPose>::copy(a4, a6);
    v6 = a5;
    if (*(_BYTE *)(a1 + 164) != 2 || !vcvtms_s32_f32(*(float *)(a2 + 60)))
    {
      v10 = re::Slice<re::AnimationClock>::range(v56, 1uLL, a3);
      return (_QWORD *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, _QWORD *, uint64_t, _QWORD *))(*v8 + 96))(v8, v10, v11, v7, v6, a6);
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    a1 = _os_crash();
    __break(1u);
  }
  v20 = a1;
  v49[0] = 0;
  v49[1] = (uint64_t)&str_110;
  v50 = 0u;
  v51 = 0u;
  v52 = 0u;
  v53 = 0;
  v54 = 0;
  v55 = 0;
  v42[0] = 0;
  v42[1] = (uint64_t)&str_110;
  v43 = 0u;
  v44 = 0u;
  v45 = 0u;
  v46 = 0;
  v47 = 0;
  v48 = 0;
  re::SkeletalPose::init(v49, v7 + 10);
  re::SkeletalPose::init(v42, v7 + 10);
  if (v31[0] && v32 == 1)
  {
    v15 = *(_QWORD *)(v20 + 80);
    v14.n128_u64[0] = 0;
    v16 = 0;
    if (v15)
    {
      if (*(_BYTE *)(v20 + 88))
        v16 = *(_QWORD *)(v20 + 96);
      (*(void (**)(uint64_t, __n128))(*(_QWORD *)v15 + 40))(v15, v14);
      if (*(_BYTE *)(v20 + 104))
        v14.n128_u64[0] = *(_QWORD *)(v20 + 112);
    }
    v33 = 0;
    v36 = 0;
    v38 = 0;
    v39 = 0;
    v40 = 0;
    v31[0] = 3;
    v34 = 1;
    v35 = v16;
    v41 = 0x200000000;
    v37 = 1065353216;
    v22 = 0;
    v25 = 0;
    v27 = 0;
    v28 = 0;
    v29 = 0;
    v21[0] = 3;
    v23 = 1;
    v24 = v14.n128_u64[0];
    v30 = 0x200000000;
    v26 = 1065353216;
    if (*(_BYTE *)(v20 + 128))
      v17 = v42;
    else
      v17 = v49;
    if (*(_BYTE *)(v20 + 128))
      v18 = v49;
    else
      v18 = v42;
    (*(void (**)(uint64_t *, _BYTE *, uint64_t, _QWORD *, uint64_t, uint64_t *))(*v8 + 96))(v8, v31, 1, v7, v6, v17);
    (*(void (**)(uint64_t *, char *, uint64_t, _QWORD *, uint64_t, uint64_t *))(*v8 + 96))(v8, v21, 1, v7, v6, v18);
    re::AnimationValueTraits<re::SkeletalPose>::invert(v49, v49);
    re::AnimationValueTraits<re::SkeletalPose>::combine(v49, v42, v49);
    re::internal::assertLog((re::internal *)4, v19, "assertion failure: '%s' (%s:line %i) Not yet implemented.", "!\"Unreachable code\"", "repeat", 304);
    _os_crash();
    __break(1u);
  }
  re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Not yet implemented. Cycle-offset computation currently does not yet support nested animations.", "internal::countTimelines(*source) == 1", "evaluateCore", 299);
  result = (_QWORD *)_os_crash();
  __break(1u);
  return result;
}

uint64_t re::AnimationClip<float>::~AnimationClip(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;

  *(_QWORD *)a1 = off_24ED1F350;
  v3 = (_OWORD *)(a1 + 40);
  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 56));
    *v3 = 0u;
    v3[1] = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  return a1;
}

void re::AnimationClip<float>::~AnimationClip(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;

  *(_QWORD *)a1 = off_24ED1F350;
  v3 = (_OWORD *)(a1 + 40);
  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 56));
    *v3 = 0u;
    v3[1] = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  JUMPOUT(0x2276933B8);
}

uint64_t re::AnimationClip<double>::~AnimationClip(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;

  *(_QWORD *)a1 = off_24ED1F350;
  v3 = (_OWORD *)(a1 + 40);
  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 56));
    *v3 = 0u;
    v3[1] = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  return a1;
}

void re::AnimationClip<double>::~AnimationClip(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;

  *(_QWORD *)a1 = off_24ED1F350;
  v3 = (_OWORD *)(a1 + 40);
  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 56));
    *v3 = 0u;
    v3[1] = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  JUMPOUT(0x2276933B8);
}

uint64_t re::AnimationClip<re::Vector2<float>>::~AnimationClip(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;

  *(_QWORD *)a1 = off_24ED1F350;
  v3 = (_OWORD *)(a1 + 40);
  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 56));
    *v3 = 0u;
    v3[1] = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  return a1;
}

void re::AnimationClip<re::Vector2<float>>::~AnimationClip(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;

  *(_QWORD *)a1 = off_24ED1F350;
  v3 = (_OWORD *)(a1 + 40);
  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 56));
    *v3 = 0u;
    v3[1] = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  JUMPOUT(0x2276933B8);
}

uint64_t re::AnimationClip<re::Vector3<float>>::~AnimationClip(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;

  *(_QWORD *)a1 = off_24ED1F350;
  v3 = (_OWORD *)(a1 + 40);
  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 56));
    *v3 = 0u;
    v3[1] = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  return a1;
}

void re::AnimationClip<re::Vector3<float>>::~AnimationClip(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;

  *(_QWORD *)a1 = off_24ED1F350;
  v3 = (_OWORD *)(a1 + 40);
  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 56));
    *v3 = 0u;
    v3[1] = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  JUMPOUT(0x2276933B8);
}

uint64_t re::AnimationClip<re::Vector4<float>>::~AnimationClip(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;

  *(_QWORD *)a1 = off_24ED1F350;
  v3 = (_OWORD *)(a1 + 40);
  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 56));
    *v3 = 0u;
    v3[1] = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  return a1;
}

void re::AnimationClip<re::Vector4<float>>::~AnimationClip(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;

  *(_QWORD *)a1 = off_24ED1F350;
  v3 = (_OWORD *)(a1 + 40);
  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 56));
    *v3 = 0u;
    v3[1] = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  JUMPOUT(0x2276933B8);
}

uint64_t re::AnimationClip<re::Quaternion<float>>::~AnimationClip(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;

  *(_QWORD *)a1 = off_24ED1F350;
  v3 = (_OWORD *)(a1 + 40);
  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 56));
    *v3 = 0u;
    v3[1] = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  return a1;
}

void re::AnimationClip<re::Quaternion<float>>::~AnimationClip(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;

  *(_QWORD *)a1 = off_24ED1F350;
  v3 = (_OWORD *)(a1 + 40);
  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 56));
    *v3 = 0u;
    v3[1] = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  JUMPOUT(0x2276933B8);
}

uint64_t re::AnimationClip<re::GenericSRT<float>>::~AnimationClip(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;

  *(_QWORD *)a1 = off_24ED1F350;
  v3 = (_OWORD *)(a1 + 40);
  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 56));
    *v3 = 0u;
    v3[1] = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  return a1;
}

void re::AnimationClip<re::GenericSRT<float>>::~AnimationClip(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;

  *(_QWORD *)a1 = off_24ED1F350;
  v3 = (_OWORD *)(a1 + 40);
  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 56));
    *v3 = 0u;
    v3[1] = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  JUMPOUT(0x2276933B8);
}

uint64_t re::AnimationClip<re::SkeletalPose>::~AnimationClip(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;

  *(_QWORD *)a1 = off_24ED1F350;
  v3 = (_OWORD *)(a1 + 40);
  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 56));
    *v3 = 0u;
    v3[1] = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  return a1;
}

void re::AnimationClip<re::SkeletalPose>::~AnimationClip(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;

  *(_QWORD *)a1 = off_24ED1F350;
  v3 = (_OWORD *)(a1 + 40);
  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 56));
    *v3 = 0u;
    v3[1] = 0u;
  }
  re::StringID::destroyString((re::StringID *)(a1 + 24));
  JUMPOUT(0x2276933B8);
}

uint64_t re::AnimationClip<float>::AnimationClip(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  int v6;
  __int128 v7;
  int v8;
  int v9;

  *(_QWORD *)a1 = off_24ED1F350;
  v4 = *(_QWORD *)(a2 + 8);
  *(_BYTE *)(a1 + 16) = *(_BYTE *)(a2 + 16);
  *(_QWORD *)(a1 + 8) = v4;
  re::StringID::StringID((re::StringID *)(a1 + 24), (const StringID *)(a2 + 24));
  re::DynamicString::DynamicString((re::DynamicString *)(a1 + 40), (const re::DynamicString *)(a2 + 40));
  *(_BYTE *)(a1 + 72) = *(_BYTE *)(a2 + 72);
  *(_QWORD *)a1 = off_24ED25EB0;
  *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
  v5 = *(unsigned __int8 *)(a2 + 88);
  *(_BYTE *)(a1 + 88) = v5;
  if (v5)
    *(_QWORD *)(a1 + 96) = *(_QWORD *)(a2 + 96);
  v6 = *(unsigned __int8 *)(a2 + 104);
  *(_BYTE *)(a1 + 104) = v6;
  if (v6)
    *(_QWORD *)(a1 + 112) = *(_QWORD *)(a2 + 112);
  v7 = *(_OWORD *)(a2 + 120);
  *(_QWORD *)(a1 + 136) = *(_QWORD *)(a2 + 136);
  *(_OWORD *)(a1 + 120) = v7;
  v8 = *(unsigned __int8 *)(a2 + 144);
  *(_BYTE *)(a1 + 144) = v8;
  if (v8)
    *(_QWORD *)(a1 + 152) = *(_QWORD *)(a2 + 152);
  v9 = *(_DWORD *)(a2 + 160);
  *(_WORD *)(a1 + 164) = *(_WORD *)(a2 + 164);
  *(_DWORD *)(a1 + 160) = v9;
  return a1;
}

uint64_t re::AnimationClip<double>::AnimationClip(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  int v6;
  __int128 v7;
  int v8;
  int v9;

  *(_QWORD *)a1 = off_24ED1F350;
  v4 = *(_QWORD *)(a2 + 8);
  *(_BYTE *)(a1 + 16) = *(_BYTE *)(a2 + 16);
  *(_QWORD *)(a1 + 8) = v4;
  re::StringID::StringID((re::StringID *)(a1 + 24), (const StringID *)(a2 + 24));
  re::DynamicString::DynamicString((re::DynamicString *)(a1 + 40), (const re::DynamicString *)(a2 + 40));
  *(_BYTE *)(a1 + 72) = *(_BYTE *)(a2 + 72);
  *(_QWORD *)a1 = off_24ED25F38;
  *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
  v5 = *(unsigned __int8 *)(a2 + 88);
  *(_BYTE *)(a1 + 88) = v5;
  if (v5)
    *(_QWORD *)(a1 + 96) = *(_QWORD *)(a2 + 96);
  v6 = *(unsigned __int8 *)(a2 + 104);
  *(_BYTE *)(a1 + 104) = v6;
  if (v6)
    *(_QWORD *)(a1 + 112) = *(_QWORD *)(a2 + 112);
  v7 = *(_OWORD *)(a2 + 120);
  *(_QWORD *)(a1 + 136) = *(_QWORD *)(a2 + 136);
  *(_OWORD *)(a1 + 120) = v7;
  v8 = *(unsigned __int8 *)(a2 + 144);
  *(_BYTE *)(a1 + 144) = v8;
  if (v8)
    *(_QWORD *)(a1 + 152) = *(_QWORD *)(a2 + 152);
  v9 = *(_DWORD *)(a2 + 160);
  *(_WORD *)(a1 + 164) = *(_WORD *)(a2 + 164);
  *(_DWORD *)(a1 + 160) = v9;
  return a1;
}

uint64_t re::AnimationClip<re::Vector2<float>>::AnimationClip(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  int v6;
  __int128 v7;
  int v8;
  int v9;

  *(_QWORD *)a1 = off_24ED1F350;
  v4 = *(_QWORD *)(a2 + 8);
  *(_BYTE *)(a1 + 16) = *(_BYTE *)(a2 + 16);
  *(_QWORD *)(a1 + 8) = v4;
  re::StringID::StringID((re::StringID *)(a1 + 24), (const StringID *)(a2 + 24));
  re::DynamicString::DynamicString((re::DynamicString *)(a1 + 40), (const re::DynamicString *)(a2 + 40));
  *(_BYTE *)(a1 + 72) = *(_BYTE *)(a2 + 72);
  *(_QWORD *)a1 = off_24ED25FC0;
  *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
  v5 = *(unsigned __int8 *)(a2 + 88);
  *(_BYTE *)(a1 + 88) = v5;
  if (v5)
    *(_QWORD *)(a1 + 96) = *(_QWORD *)(a2 + 96);
  v6 = *(unsigned __int8 *)(a2 + 104);
  *(_BYTE *)(a1 + 104) = v6;
  if (v6)
    *(_QWORD *)(a1 + 112) = *(_QWORD *)(a2 + 112);
  v7 = *(_OWORD *)(a2 + 120);
  *(_QWORD *)(a1 + 136) = *(_QWORD *)(a2 + 136);
  *(_OWORD *)(a1 + 120) = v7;
  v8 = *(unsigned __int8 *)(a2 + 144);
  *(_BYTE *)(a1 + 144) = v8;
  if (v8)
    *(_QWORD *)(a1 + 152) = *(_QWORD *)(a2 + 152);
  v9 = *(_DWORD *)(a2 + 160);
  *(_WORD *)(a1 + 164) = *(_WORD *)(a2 + 164);
  *(_DWORD *)(a1 + 160) = v9;
  return a1;
}

uint64_t re::AnimationClip<re::Vector3<float>>::AnimationClip(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  int v6;
  __int128 v7;
  int v8;
  int v9;

  *(_QWORD *)a1 = off_24ED1F350;
  v4 = *(_QWORD *)(a2 + 8);
  *(_BYTE *)(a1 + 16) = *(_BYTE *)(a2 + 16);
  *(_QWORD *)(a1 + 8) = v4;
  re::StringID::StringID((re::StringID *)(a1 + 24), (const StringID *)(a2 + 24));
  re::DynamicString::DynamicString((re::DynamicString *)(a1 + 40), (const re::DynamicString *)(a2 + 40));
  *(_BYTE *)(a1 + 72) = *(_BYTE *)(a2 + 72);
  *(_QWORD *)a1 = off_24ED26048;
  *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
  v5 = *(unsigned __int8 *)(a2 + 88);
  *(_BYTE *)(a1 + 88) = v5;
  if (v5)
    *(_QWORD *)(a1 + 96) = *(_QWORD *)(a2 + 96);
  v6 = *(unsigned __int8 *)(a2 + 104);
  *(_BYTE *)(a1 + 104) = v6;
  if (v6)
    *(_QWORD *)(a1 + 112) = *(_QWORD *)(a2 + 112);
  v7 = *(_OWORD *)(a2 + 120);
  *(_QWORD *)(a1 + 136) = *(_QWORD *)(a2 + 136);
  *(_OWORD *)(a1 + 120) = v7;
  v8 = *(unsigned __int8 *)(a2 + 144);
  *(_BYTE *)(a1 + 144) = v8;
  if (v8)
    *(_QWORD *)(a1 + 152) = *(_QWORD *)(a2 + 152);
  v9 = *(_DWORD *)(a2 + 160);
  *(_WORD *)(a1 + 164) = *(_WORD *)(a2 + 164);
  *(_DWORD *)(a1 + 160) = v9;
  return a1;
}

uint64_t re::AnimationClip<re::Vector4<float>>::AnimationClip(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  int v6;
  __int128 v7;
  int v8;
  int v9;

  *(_QWORD *)a1 = off_24ED1F350;
  v4 = *(_QWORD *)(a2 + 8);
  *(_BYTE *)(a1 + 16) = *(_BYTE *)(a2 + 16);
  *(_QWORD *)(a1 + 8) = v4;
  re::StringID::StringID((re::StringID *)(a1 + 24), (const StringID *)(a2 + 24));
  re::DynamicString::DynamicString((re::DynamicString *)(a1 + 40), (const re::DynamicString *)(a2 + 40));
  *(_BYTE *)(a1 + 72) = *(_BYTE *)(a2 + 72);
  *(_QWORD *)a1 = off_24ED260D0;
  *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
  v5 = *(unsigned __int8 *)(a2 + 88);
  *(_BYTE *)(a1 + 88) = v5;
  if (v5)
    *(_QWORD *)(a1 + 96) = *(_QWORD *)(a2 + 96);
  v6 = *(unsigned __int8 *)(a2 + 104);
  *(_BYTE *)(a1 + 104) = v6;
  if (v6)
    *(_QWORD *)(a1 + 112) = *(_QWORD *)(a2 + 112);
  v7 = *(_OWORD *)(a2 + 120);
  *(_QWORD *)(a1 + 136) = *(_QWORD *)(a2 + 136);
  *(_OWORD *)(a1 + 120) = v7;
  v8 = *(unsigned __int8 *)(a2 + 144);
  *(_BYTE *)(a1 + 144) = v8;
  if (v8)
    *(_QWORD *)(a1 + 152) = *(_QWORD *)(a2 + 152);
  v9 = *(_DWORD *)(a2 + 160);
  *(_WORD *)(a1 + 164) = *(_WORD *)(a2 + 164);
  *(_DWORD *)(a1 + 160) = v9;
  return a1;
}

uint64_t re::AnimationClip<re::Quaternion<float>>::AnimationClip(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  int v6;
  __int128 v7;
  int v8;
  int v9;

  *(_QWORD *)a1 = off_24ED1F350;
  v4 = *(_QWORD *)(a2 + 8);
  *(_BYTE *)(a1 + 16) = *(_BYTE *)(a2 + 16);
  *(_QWORD *)(a1 + 8) = v4;
  re::StringID::StringID((re::StringID *)(a1 + 24), (const StringID *)(a2 + 24));
  re::DynamicString::DynamicString((re::DynamicString *)(a1 + 40), (const re::DynamicString *)(a2 + 40));
  *(_BYTE *)(a1 + 72) = *(_BYTE *)(a2 + 72);
  *(_QWORD *)a1 = off_24ED26158;
  *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
  v5 = *(unsigned __int8 *)(a2 + 88);
  *(_BYTE *)(a1 + 88) = v5;
  if (v5)
    *(_QWORD *)(a1 + 96) = *(_QWORD *)(a2 + 96);
  v6 = *(unsigned __int8 *)(a2 + 104);
  *(_BYTE *)(a1 + 104) = v6;
  if (v6)
    *(_QWORD *)(a1 + 112) = *(_QWORD *)(a2 + 112);
  v7 = *(_OWORD *)(a2 + 120);
  *(_QWORD *)(a1 + 136) = *(_QWORD *)(a2 + 136);
  *(_OWORD *)(a1 + 120) = v7;
  v8 = *(unsigned __int8 *)(a2 + 144);
  *(_BYTE *)(a1 + 144) = v8;
  if (v8)
    *(_QWORD *)(a1 + 152) = *(_QWORD *)(a2 + 152);
  v9 = *(_DWORD *)(a2 + 160);
  *(_WORD *)(a1 + 164) = *(_WORD *)(a2 + 164);
  *(_DWORD *)(a1 + 160) = v9;
  return a1;
}

uint64_t re::AnimationClip<re::GenericSRT<float>>::AnimationClip(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  int v6;
  __int128 v7;
  int v8;
  int v9;

  *(_QWORD *)a1 = off_24ED1F350;
  v4 = *(_QWORD *)(a2 + 8);
  *(_BYTE *)(a1 + 16) = *(_BYTE *)(a2 + 16);
  *(_QWORD *)(a1 + 8) = v4;
  re::StringID::StringID((re::StringID *)(a1 + 24), (const StringID *)(a2 + 24));
  re::DynamicString::DynamicString((re::DynamicString *)(a1 + 40), (const re::DynamicString *)(a2 + 40));
  *(_BYTE *)(a1 + 72) = *(_BYTE *)(a2 + 72);
  *(_QWORD *)a1 = off_24ED261E0;
  *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
  v5 = *(unsigned __int8 *)(a2 + 88);
  *(_BYTE *)(a1 + 88) = v5;
  if (v5)
    *(_QWORD *)(a1 + 96) = *(_QWORD *)(a2 + 96);
  v6 = *(unsigned __int8 *)(a2 + 104);
  *(_BYTE *)(a1 + 104) = v6;
  if (v6)
    *(_QWORD *)(a1 + 112) = *(_QWORD *)(a2 + 112);
  v7 = *(_OWORD *)(a2 + 120);
  *(_QWORD *)(a1 + 136) = *(_QWORD *)(a2 + 136);
  *(_OWORD *)(a1 + 120) = v7;
  v8 = *(unsigned __int8 *)(a2 + 144);
  *(_BYTE *)(a1 + 144) = v8;
  if (v8)
    *(_QWORD *)(a1 + 152) = *(_QWORD *)(a2 + 152);
  v9 = *(_DWORD *)(a2 + 160);
  *(_WORD *)(a1 + 164) = *(_WORD *)(a2 + 164);
  *(_DWORD *)(a1 + 160) = v9;
  return a1;
}

uint64_t re::AnimationClip<re::SkeletalPose>::AnimationClip(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  int v6;
  __int128 v7;
  int v8;
  int v9;

  *(_QWORD *)a1 = off_24ED1F350;
  v4 = *(_QWORD *)(a2 + 8);
  *(_BYTE *)(a1 + 16) = *(_BYTE *)(a2 + 16);
  *(_QWORD *)(a1 + 8) = v4;
  re::StringID::StringID((re::StringID *)(a1 + 24), (const StringID *)(a2 + 24));
  re::DynamicString::DynamicString((re::DynamicString *)(a1 + 40), (const re::DynamicString *)(a2 + 40));
  *(_BYTE *)(a1 + 72) = *(_BYTE *)(a2 + 72);
  *(_QWORD *)a1 = off_24ED26268;
  *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
  v5 = *(unsigned __int8 *)(a2 + 88);
  *(_BYTE *)(a1 + 88) = v5;
  if (v5)
    *(_QWORD *)(a1 + 96) = *(_QWORD *)(a2 + 96);
  v6 = *(unsigned __int8 *)(a2 + 104);
  *(_BYTE *)(a1 + 104) = v6;
  if (v6)
    *(_QWORD *)(a1 + 112) = *(_QWORD *)(a2 + 112);
  v7 = *(_OWORD *)(a2 + 120);
  *(_QWORD *)(a1 + 136) = *(_QWORD *)(a2 + 136);
  *(_OWORD *)(a1 + 120) = v7;
  v8 = *(unsigned __int8 *)(a2 + 144);
  *(_BYTE *)(a1 + 144) = v8;
  if (v8)
    *(_QWORD *)(a1 + 152) = *(_QWORD *)(a2 + 152);
  v9 = *(_DWORD *)(a2 + 160);
  *(_WORD *)(a1 + 164) = *(_WORD *)(a2 + 164);
  *(_DWORD *)(a1 + 160) = v9;
  return a1;
}

uint64_t *re::allocInfo_AudioAnimationState(re *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&_MergedGlobals_24);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&_MergedGlobals_24))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FA578, 0);
    *(uint64_t *)((char *)&qword_2540FA588 + 6) = 0;
    qword_2540FA588 = 0;
    qword_2540FA598 = 0;
    qword_2540FA5A0 = 0xFFFFFFFFLL;
    qword_2540FA578 = (uint64_t)&off_24ED7DAA8;
    qword_2540FA5A8 = (uint64_t)"AudioAnimationState";
    dword_2540FA5B0 = 0;
    xmmword_2540FA5B8 = 0u;
    unk_2540FA5C8 = 0u;
    xmmword_2540FA5D8 = 0u;
    qword_2540FA5E8 = 0;
    __cxa_guard_release(&_MergedGlobals_24);
  }
  return &qword_2540FA578;
}

void re::initInfo_AudioAnimationState(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  const re::IntrospectionBase *v7;
  void *v8;
  uint64_t v9;
  uint64_t *v10;
  const re::IntrospectionBase *v11;
  void *v12;
  uint64_t v13;
  uint64_t *v14;
  const re::IntrospectionBase *v15;
  void *v16;
  uint64_t v17;
  uint64_t *v18;
  const re::IntrospectionBase *v19;
  void *v20;
  uint64_t v21;
  __int128 v22;
  _QWORD v23[2];
  __int128 v24;

  v23[0] = 0x2D5905E6F33A1986;
  v23[1] = "AudioAnimationState";
  re::StringID::destroyString((re::StringID *)v23);
  *((_OWORD *)this + 2) = v24;
  v4 = atomic_load((unsigned __int8 *)&qword_2540FA540);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_2540FA540);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      v8 = re::introspect_float((re *)1, v7);
      v9 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
      *(_DWORD *)v9 = 1;
      *(_QWORD *)(v9 + 8) = "speed";
      *(_QWORD *)(v9 + 16) = v8;
      *(_QWORD *)(v9 + 24) = 0;
      *(_QWORD *)(v9 + 32) = 0x800000001;
      *(_DWORD *)(v9 + 40) = 0;
      *(_QWORD *)(v9 + 48) = 0;
      *(_QWORD *)(v9 + 56) = 0;
      *(_DWORD *)(v9 + 64) = 0;
      qword_2540FA558 = v9;
      v10 = re::introspectionAllocator((re *)v9);
      v12 = re::introspect_double((re *)1, v11);
      v13 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v10 + 32))(v10, 72, 8);
      *(_DWORD *)v13 = 1;
      *(_QWORD *)(v13 + 8) = "time";
      *(_QWORD *)(v13 + 16) = v12;
      *(_QWORD *)(v13 + 24) = 0;
      *(_QWORD *)(v13 + 32) = 2;
      *(_DWORD *)(v13 + 40) = 0;
      *(_QWORD *)(v13 + 48) = 0;
      *(_QWORD *)(v13 + 56) = 0;
      *(_DWORD *)(v13 + 64) = 0;
      qword_2540FA560 = v13;
      v14 = re::introspectionAllocator((re *)v13);
      v16 = re::introspect_BOOL((re *)1, v15);
      v17 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v14 + 32))(v14, 72, 8);
      *(_DWORD *)v17 = 1;
      *(_QWORD *)(v17 + 8) = "prepared";
      *(_QWORD *)(v17 + 16) = v16;
      *(_QWORD *)(v17 + 24) = 0;
      *(_QWORD *)(v17 + 32) = 0xC00000003;
      *(_DWORD *)(v17 + 40) = 0;
      *(_QWORD *)(v17 + 48) = 0;
      *(_QWORD *)(v17 + 56) = 0;
      *(_DWORD *)(v17 + 64) = 0;
      qword_2540FA568 = v17;
      v18 = re::introspectionAllocator((re *)v17);
      v20 = re::introspect_size_t((re *)1, v19);
      v21 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v18 + 32))(v18, 72, 8);
      *(_DWORD *)v21 = 1;
      *(_QWORD *)(v21 + 8) = "animationCounter";
      *(_QWORD *)(v21 + 16) = v20;
      *(_QWORD *)(v21 + 24) = 0;
      *(_QWORD *)(v21 + 32) = 0x1000000004;
      *(_DWORD *)(v21 + 40) = 0;
      *(_QWORD *)(v21 + 48) = 0;
      *(_QWORD *)(v21 + 56) = 0;
      *(_DWORD *)(v21 + 64) = 0;
      qword_2540FA570 = v21;
      __cxa_guard_release(&qword_2540FA540);
    }
  }
  *((_QWORD *)this + 2) = 0x1800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 4;
  *((_QWORD *)this + 8) = &qword_2540FA558;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::AudioAnimationState>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::AudioAnimationState>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::AudioAnimationState>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::AudioAnimationState>;
  re::IntrospectionRegistry::add(this, v3);
  v22 = v24;
}

void re::internal::defaultConstruct<re::AudioAnimationState>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)a3 = 0;
  *(_DWORD *)(a3 + 8) = 0;
  *(_BYTE *)(a3 + 12) = 0;
  *(_QWORD *)(a3 + 16) = 0;
}

uint64_t re::internal::defaultConstructV2<re::AudioAnimationState>(uint64_t result)
{
  *(_QWORD *)result = 0;
  *(_DWORD *)(result + 8) = 0;
  *(_BYTE *)(result + 12) = 0;
  *(_QWORD *)(result + 16) = 0;
  return result;
}

uint64_t re::introspect_AudioAnimationState(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"AudioAnimationState", (uint64_t (*)(re::internal *))re::allocInfo_AudioAnimationState, (re::IntrospectionBase *(*)(void))re::initInfo_AudioAnimationState, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::AudioAnimationState>, this);
}

uint64_t re::AudioAnimationTimeline::evaluateCore(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  float v6;
  double v7;
  uint64_t v8;
  double v9;
  BOOL v10;
  BOOL v11;

  if (a3)
  {
    v6 = *(double *)(a2 + 24);
    v7 = v6;
    if (*(double *)(result + 80) <= v7)
    {
      v9 = *(double *)(result + 88);
      v10 = v9 == v7;
      v11 = v9 < v7;
      if (v9 <= v7)
        v7 = 0.0;
      *(double *)a6 = v7;
      *(_DWORD *)(a6 + 8) = *(_DWORD *)(a2 + 36);
      if (v11 || v10)
        v8 = 0;
      else
        v8 = *(_QWORD *)(a2 + 40);
    }
    else
    {
      v8 = 0;
      *(_QWORD *)a6 = 0;
      *(_DWORD *)(a6 + 8) = *(_DWORD *)(a2 + 36);
    }
    *(_QWORD *)(a6 + 16) = v8;
  }
  else
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

double re::AudioAnimationTimeline::totalDuration(re::AudioAnimationTimeline *this)
{
  return *((double *)this + 11) - *((double *)this + 10);
}

float re::AudioAnimationTimeline::timelineDesc@<S0>(re::AudioAnimationTimeline *this@<X0>, uint64_t a2@<X8>)
{
  double v2;
  double v3;
  float v4;
  float result;

  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 8) = 1065353216;
  *(_DWORD *)(a2 + 20) = 0;
  *(_WORD *)(a2 + 24) = 0;
  v3 = *((double *)this + 10);
  v2 = *((double *)this + 11);
  v4 = v2 - v3;
  *(float *)(a2 + 4) = v4;
  *(float *)&v3 = v3;
  result = v2;
  *(_DWORD *)(a2 + 12) = LODWORD(v3);
  *(float *)(a2 + 16) = result;
  return result;
}

double re::AudioAnimationTimeline::makeCompositionChain(re::AudioAnimationTimeline *this, Allocator *a2)
{
  uint64_t v2;
  double result;

  v2 = (*((uint64_t (**)(Allocator *, uint64_t, uint64_t))a2->var0 + 4))(a2, 176, 8);
  result = 0.0;
  *(_OWORD *)(v2 + 40) = 0u;
  *(_OWORD *)(v2 + 88) = 0u;
  *(_OWORD *)(v2 + 104) = 0u;
  *(_OWORD *)(v2 + 136) = 0u;
  *(_OWORD *)(v2 + 152) = 0u;
  *(_OWORD *)(v2 + 72) = 0u;
  *(_OWORD *)(v2 + 56) = 0u;
  *(_OWORD *)(v2 + 120) = 0u;
  *(_QWORD *)(v2 + 168) = 0;
  *(_OWORD *)(v2 + 8) = 0u;
  *(_OWORD *)(v2 + 24) = 0u;
  *(_DWORD *)(v2 + 40) = 0;
  *(_QWORD *)(v2 + 88) = 0;
  *(_QWORD *)(v2 + 96) = 0;
  *(_BYTE *)(v2 + 104) = 0;
  *(_QWORD *)(v2 + 144) = 0;
  *(_BYTE *)(v2 + 156) = 0;
  *(_DWORD *)(v2 + 80) = 0;
  *(_OWORD *)(v2 + 48) = 0u;
  *(_OWORD *)(v2 + 64) = 0u;
  *(_QWORD *)v2 = &off_24ED26480;
  return result;
}

uint64_t re::internal::AudioAnimationTimelineCompositionChain::prepare(uint64_t this)
{
  *(_BYTE *)(this + 168) = 1;
  return this;
}

uint64_t re::internal::AudioAnimationTimelineCompositionChain::update(re::internal::AudioAnimationTimelineCompositionChain *this)
{
  uint64_t result;

  result = re::internal::AnimationCompositionChain<re::AudioAnimationState>::update((uint64_t)this);
  *((_BYTE *)this + 156) = *((_BYTE *)this + 168);
  return result;
}

uint64_t re::internal::AnimationCompositionChain<re::AudioAnimationState>::update(uint64_t result)
{
  unint64_t v1;
  unint64_t v2;
  re::BindPoint *v3;
  unint64_t v4;
  uint64_t v5;
  re::BindPoint *v6;
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  int v10;
  double v11;
  float v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  re::BindPoint *v16;
  BOOL v17;
  float v18;
  _QWORD *v19;
  unint64_t v20;
  unint64_t v21;
  int v22;
  int v23;
  _BYTE *v24;
  float v25;
  float v26;
  __int128 *v27;
  BOOL v28;
  float v29;
  double v30;
  float v31;
  __int128 *v32;
  BOOL v33;
  float v34;
  int v35;
  double v36;
  float v37;
  int v38;
  BOOL v39;
  float v40;
  __int128 v41;
  float v42;
  int v43;
  int v44;
  float v45;
  int v46;
  float v47;
  double v48;
  float v49;
  float v50;
  char v51;
  BOOL v52;
  float v53;
  uint64_t v54;
  __int128 v55;
  re::BindPoint *v56;
  uint64_t *v57;
  int v58;
  char v59;
  int v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t *v63;
  int v64;
  char v65;
  __int128 v66;
  __int128 v67;
  uint64_t v68;
  int v69;
  char v70;
  uint64_t v71;
  char v72;
  uint64_t v73;
  int v74;
  const char *v75;
  __int16 v76;
  int v77;
  __int16 v78;
  unint64_t v79;
  __int16 v80;
  re::BindPoint *v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  uint64_t v87;

  v87 = *MEMORY[0x24BDAC8D0];
  v62 = *(_QWORD *)(result + 72);
  if (!v62)
    return result;
  v5 = result;
  v6 = (re::BindPoint *)(result + 8);
  result = re::BindPoint::isAlive((re::BindPoint *)(result + 8));
  if (!(_DWORD)result)
    return result;
  result = re::BindPoint::supportsOverrideValue(v6);
  v68 = 0;
  v69 = 0;
  v70 = 0;
  v71 = 0;
  v72 = 0;
  v58 = result;
  if ((_DWORD)result)
  {
    result = re::BindPoint::baseValueUntyped(v6);
    v57 = (uint64_t *)result;
  }
  else
  {
    v72 = 1;
    v71 = 0;
    v57 = &v68;
  }
  if (*(_BYTE *)(v5 + 112))
  {
    *(_OWORD *)(v5 + 144) = *(_OWORD *)(v5 + 120);
    *(_QWORD *)(v5 + 160) = *(_QWORD *)(v5 + 136);
  }
  else
  {
    v8 = *(_OWORD *)v57;
    *(_QWORD *)(v5 + 160) = v57[2];
    *(_OWORD *)(v5 + 144) = v8;
  }
  v9 = 0uLL;
  v66 = 0u;
  v67 = 0u;
  if (!*(_QWORD *)(v5 + 72))
    goto LABEL_88;
  v56 = v6;
  v4 = 0;
  LOBYTE(v60) = 0;
  v10 = 0;
  v6 = (re::BindPoint *)*(unsigned int *)(*(_QWORD *)(v5 + 88) + 16);
  v61 = v5 + 144;
  v63 = v57;
  v64 = 0;
  v65 = 0;
  v11 = 0.0;
  v12 = 0.0;
  v13 = 24;
  v59 = v58;
  while (1)
  {
    v1 = *(_QWORD *)(v5 + 72);
    if (v1 <= v4)
    {
      v73 = 0;
      v85 = 0u;
      v86 = 0u;
      v83 = 0u;
      v84 = 0u;
      v82 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v74 = 136315906;
      v75 = "operator[]";
      v76 = 1024;
      v77 = 789;
      v78 = 2048;
      v79 = v4;
      v80 = 2048;
      v81 = (re::BindPoint *)v1;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_82:
      v73 = 0;
      v85 = 0u;
      v86 = 0u;
      v83 = 0u;
      v84 = 0u;
      v82 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v74 = 136315906;
      v75 = "operator[]";
      v76 = 1024;
      v77 = 476;
      v78 = 2048;
      v79 = v2;
      v80 = 2048;
      v81 = (re::BindPoint *)v1;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_83:
      re::internal::assertLog((re::internal *)6, v7, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
      _os_crash();
      __break(1u);
LABEL_84:
      v73 = 0;
      v85 = 0u;
      v86 = 0u;
      v83 = 0u;
      v84 = 0u;
      v82 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v74 = 136315906;
      v75 = "operator[]";
      v76 = 1024;
      v77 = 476;
      v78 = 2048;
      v79 = v2;
      v80 = 2048;
      v81 = (re::BindPoint *)v1;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_85:
      v73 = 0;
      v85 = 0u;
      v86 = 0u;
      v83 = 0u;
      v84 = 0u;
      v82 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v74 = 136315906;
      v75 = "operator[]";
      v76 = 1024;
      v77 = 476;
      v78 = 2048;
      v79 = v2;
      v80 = 2048;
      v81 = (re::BindPoint *)v13;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_86;
    }
    v14 = *(_QWORD *)(v5 + 88);
    v15 = v14 + 24 * v4;
    v16 = (re::BindPoint *)*(unsigned int *)(v15 + 16);
    if ((_DWORD)v6 != (_DWORD)v16 && v10)
    {
      v10 = 0;
      v17 = (v60 | *(unsigned __int8 *)(v5 + 156)) != 0;
      v18 = v12 + *(float *)(v5 + 152);
      *(double *)(v5 + 144) = (v11 + *(double *)(v5 + 144)) * 0.5;
      *(float *)(v5 + 152) = v18 * 0.5;
      *(_BYTE *)(v5 + 156) = v17;
      *(_QWORD *)(v5 + 160) = 0;
    }
    v6 = v16;
    v19 = *(_QWORD **)v15;
    v2 = *(int *)(v15 + 8);
    v1 = *(_QWORD *)(*(_QWORD *)v15 + 56);
    v20 = v2 + 1;
    if (v1 <= v2 + 1)
      v21 = v2 + 1;
    else
      v21 = *(_QWORD *)(*(_QWORD *)v15 + 56);
    do
    {
      if (v21 == v20)
        goto LABEL_22;
      v3 = (re::BindPoint *)v19[1];
      if ((unint64_t)v3 <= v20)
      {
        v73 = 0;
        v85 = 0u;
        v86 = 0u;
        v83 = 0u;
        v84 = 0u;
        v82 = 0u;
        v5 = MEMORY[0x24BDACB70];
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        v74 = 136315906;
        v75 = "operator[]";
        v76 = 1024;
        v77 = 476;
        v78 = 2048;
        v79 = v20;
        v80 = 2048;
        v81 = v3;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_76;
      }
      v22 = *(_DWORD *)(v19[2] + 4 * v20++);
    }
    while (v22 >= (int)v2);
    LODWORD(v21) = v20 - 1;
LABEL_22:
    if (v1 <= v2)
      goto LABEL_82;
    v23 = v21 - v2;
    if (!v23)
      goto LABEL_83;
    v1 = v19[16];
    if (v1 <= v2)
      goto LABEL_84;
    v1 = v19[8];
    v24 = (_BYTE *)(v1 + 72 * (int)v2);
    v3 = *(re::BindPoint **)(v19[17] + 8 * v2);
    if (!v24[16])
      goto LABEL_42;
    v13 = v19[13];
    if (v13 <= v2)
      goto LABEL_85;
    v25 = *(float *)(v19[14] + 4 * v2);
    v26 = fabsf(v25);
    v13 = 24;
    if (v26 < 0.00001)
      goto LABEL_71;
    if (v25 != 1.0 && fabsf(v25 + -1.0) >= (float)((float)((float)(v26 + 1.0) + 1.0) * 0.00001))
    {
      if (!BYTE8(v67))
        BYTE8(v67) = 1;
      v32 = (__int128 *)(v5 + 144);
      if (v10)
      {
        v33 = (v60 | *(unsigned __int8 *)(v5 + 156)) != 0;
        v34 = v12 + *(float *)(v5 + 152);
        *(double *)&v66 = (v11 + *(double *)(v5 + 144)) * 0.5;
        *((float *)&v66 + 2) = v34 * 0.5;
        BYTE12(v66) = v33;
        *(_QWORD *)&v67 = 0;
        v32 = &v66;
      }
      v35 = v64;
      result = (*(uint64_t (**)(re::BindPoint *, _BYTE *, _QWORD, __int128 *, uint64_t **, __int128 *))(*(_QWORD *)v3 + 96))(v3, v24, v23, v32, &v63, &v66);
      if (v64 != v35)
        return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 32))(v5);
      if (*((_BYTE *)v3 + 72))
      {
        v1 = *(_QWORD *)(v5 + 72);
        if (v1 <= v4)
          goto LABEL_90;
        if ((*(_BYTE *)(*(_QWORD *)(v5 + 88) + 24 * v4 + 20) & 4) != 0)
        {
          v36 = *(double *)(v5 + 144);
          v42 = *(float *)(v5 + 152);
          v43 = *(unsigned __int8 *)(v5 + 156);
          *(double *)&v66 = (*(double *)&v66 + v36) * 0.5;
          *((float *)&v66 + 2) = (float)(*((float *)&v66 + 2) + v42) * 0.5;
          BYTE12(v66) = (BYTE12(v66) | v43) != 0;
          *(_QWORD *)&v67 = 0;
          v38 = (v60 | v43) != 0;
          v37 = (float)(v12 + v42) * 0.5;
          if (v10)
          {
            v36 = (v11 + v36) * 0.5;
          }
          else
          {
            v38 = v43;
            v37 = v42;
          }
        }
        else
        {
          v36 = *(double *)(v5 + 144);
          v37 = *(float *)(v5 + 152);
          v38 = *(unsigned __int8 *)(v5 + 156);
          if (v10)
          {
            v38 = (v60 | v38) != 0;
            v37 = (float)(v12 + v37) * 0.5;
            v36 = (v11 + v36) * 0.5;
          }
          *(double *)&v66 = (v36 + *(double *)&v66) * 0.5;
          *((float *)&v66 + 2) = (float)(v37 + *((float *)&v66 + 2)) * 0.5;
          BYTE12(v66) = (BYTE12(v66) | v38) != 0;
          *(_QWORD *)&v67 = 0;
        }
      }
      else
      {
        v36 = *(double *)(v5 + 144);
        v37 = *(float *)(v5 + 152);
        v38 = *(unsigned __int8 *)(v5 + 156);
        if (v10)
        {
          v38 = (v60 | v38) != 0;
          v37 = (float)(v12 + v37) * 0.5;
          v36 = (v11 + v36) * 0.5;
        }
      }
      v10 = 0;
      v44 = v38 | BYTE12(v66);
      v45 = (float)(v25 * *((float *)&v66 + 2)) + (float)(v37 * (float)(1.0 - v25));
      *(double *)(v5 + 144) = *(double *)&v66 * v25 + v36 * (float)(1.0 - v25);
      *(float *)(v5 + 152) = v45;
      *(_BYTE *)(v5 + 156) = v44 != 0;
      *(_QWORD *)(v5 + 160) = 0;
      goto LABEL_71;
    }
    *(_BYTE *)(v14 + 24 * v4 + 20) &= ~4u;
    if (*((_BYTE *)v3 + 72))
      break;
    v65 = 1;
LABEL_42:
    result = (*(uint64_t (**)(re::BindPoint *, unint64_t, _QWORD, uint64_t, uint64_t **, uint64_t))(*(_QWORD *)v3 + 96))(v3, v1 + 72 * (int)v2, v23, v61, &v63, v61);
LABEL_71:
    if (++v4 == v62)
    {
      if (v10)
      {
        v46 = v60 | *(unsigned __int8 *)(v5 + 156);
        v47 = (float)(v12 + *(float *)(v5 + 152)) * 0.5;
        *(double *)(v5 + 144) = (v11 + *(double *)(v5 + 144)) * 0.5;
        *(float *)(v5 + 152) = v47;
        *(_BYTE *)(v5 + 156) = v46 != 0;
        *(_QWORD *)(v5 + 160) = 0;
      }
      return result;
    }
  }
  if (!BYTE8(v67))
    BYTE8(v67) = 1;
  v27 = (__int128 *)(v5 + 144);
  if (v10)
  {
    v28 = (v60 | *(unsigned __int8 *)(v5 + 156)) != 0;
    v29 = v12 + *(float *)(v5 + 152);
    *(double *)&v66 = (v11 + *(double *)(v5 + 144)) * 0.5;
    *((float *)&v66 + 2) = v29 * 0.5;
    BYTE12(v66) = v28;
    *(_QWORD *)&v67 = 0;
    v27 = &v66;
  }
  result = (*(uint64_t (**)(re::BindPoint *, unint64_t, _QWORD, __int128 *, uint64_t **, __int128 *))(*(_QWORD *)v3 + 96))(v3, v1 + 72 * (int)v2, v23, v27, &v63, &v66);
  if (!v58)
  {
LABEL_39:
    v30 = *(double *)&v66;
    v31 = *((float *)&v66 + 2);
    if (v10)
    {
      v60 = (BYTE12(v66) | v60) != 0;
      v31 = (float)(v12 + *((float *)&v66 + 2)) * 0.5;
      v30 = (v11 + *(double *)&v66) * 0.5;
    }
    else
    {
      v60 = BYTE12(v66);
    }
    if ((v59 & 1) != 0)
    {
      v1 = *(_QWORD *)(v5 + 72);
      if (v1 <= v4)
        goto LABEL_87;
      v59 = 0;
      v10 = 1;
      if ((*(_BYTE *)(*(_QWORD *)(v5 + 88) + 24 * v4 + 20) & 2) != 0 && *v24 == 5)
      {
        v39 = (v60 | *(unsigned __int8 *)(v5 + 156)) != 0;
        v40 = (float)(v31 + *(float *)(v5 + 152)) * 0.5;
        *(double *)(v5 + 144) = (v30 + *(double *)(v5 + 144)) * 0.5;
        *(float *)(v5 + 152) = v40;
        *(_BYTE *)(v5 + 156) = v39;
        *(_QWORD *)(v5 + 160) = 0;
        result = re::BindPoint::baseValueUntyped(v56);
        if (result)
        {
          v41 = *(_OWORD *)v61;
          *(_QWORD *)(result + 16) = *(_QWORD *)(v5 + 160);
          *(_OWORD *)result = v41;
          result = re::BindPoint::markAsWritten((uint64_t)v56);
        }
        v1 = *(_QWORD *)(v5 + 72);
        if (v1 <= v4)
          goto LABEL_89;
        v10 = 0;
        *(_BYTE *)(*(_QWORD *)(v5 + 88) + 24 * v4 + 20) &= ~2u;
        v59 = 1;
        *v24 = 1;
      }
    }
    else
    {
      v59 = 0;
      v10 = 1;
    }
    v11 = v30;
    v12 = v31;
    goto LABEL_71;
  }
  v3 = *(re::BindPoint **)(v5 + 72);
  if ((unint64_t)v3 <= v4)
  {
LABEL_86:
    v73 = 0;
    v85 = 0u;
    v86 = 0u;
    v83 = 0u;
    v84 = 0u;
    v82 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v74 = 136315906;
    v75 = "operator[]";
    v76 = 1024;
    v77 = 789;
    v78 = 2048;
    v79 = v4;
    v80 = 2048;
    v81 = v3;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_87:
    v73 = 0;
    v85 = 0u;
    v86 = 0u;
    v83 = 0u;
    v84 = 0u;
    v82 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v74 = 136315906;
    v75 = "operator[]";
    v76 = 1024;
    v77 = 789;
    v78 = 2048;
    v79 = v4;
    v80 = 2048;
    v81 = (re::BindPoint *)v1;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_88:
    v63 = 0;
    v85 = v9;
    v86 = v9;
    v83 = v9;
    v84 = v9;
    v82 = v9;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v74 = 136315906;
    v75 = "operator[]";
    v76 = 1024;
    v77 = 789;
    v78 = 2048;
    v79 = 0;
    v80 = 2048;
    v81 = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_89:
    v73 = 0;
    v85 = 0u;
    v86 = 0u;
    v83 = 0u;
    v84 = 0u;
    v82 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v74 = 136315906;
    v75 = "operator[]";
    v76 = 1024;
    v77 = 789;
    v78 = 2048;
    v79 = v4;
    v80 = 2048;
    v81 = (re::BindPoint *)v1;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_90:
    v73 = 0;
    v85 = 0u;
    v86 = 0u;
    v83 = 0u;
    v84 = 0u;
    v82 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v74 = 136315906;
    v75 = "operator[]";
    v76 = 1024;
    v77 = 789;
    v78 = 2048;
    v79 = v4;
    v80 = 2048;
    v81 = (re::BindPoint *)v1;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_91:
    v73 = 0;
    v85 = 0u;
    v86 = 0u;
    v83 = 0u;
    v84 = 0u;
    v82 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v74 = 136315906;
    v75 = "operator[]";
    v76 = 1024;
    v77 = 789;
    v78 = 2048;
    v79 = v4;
    v80 = 2048;
    v81 = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if ((*(_BYTE *)(*(_QWORD *)(v5 + 88) + 24 * v4 + 20) & 1) == 0 || !*(_BYTE *)(v1 + 72 * (int)v2 + 32))
    goto LABEL_39;
LABEL_76:
  v48 = *(double *)&v66;
  v49 = *((float *)&v66 + 2);
  v50 = -*((float *)&v66 + 2);
  v51 = BYTE12(v66);
  *(double *)(v5 + 144) = -*(double *)&v66;
  *(float *)(v5 + 152) = v50;
  *(_BYTE *)(v5 + 156) = v51;
  *(_QWORD *)(v5 + 160) = 0;
  v52 = (v51 | *((_BYTE *)v57 + 12)) != 0;
  v53 = (float)(*((float *)v57 + 2) - v49) * 0.5;
  *(double *)(v5 + 144) = (*(double *)v57 - v48) * 0.5;
  *(float *)(v5 + 152) = v53;
  *(_BYTE *)(v5 + 156) = v52;
  *(_QWORD *)(v5 + 160) = 0;
  v54 = re::BindPoint::baseValueUntyped(v56);
  if (v54)
  {
    v55 = *(_OWORD *)v61;
    *(_QWORD *)(v54 + 16) = *(_QWORD *)(v61 + 16);
    *(_OWORD *)v54 = v55;
    re::BindPoint::markAsWritten((uint64_t)v56);
  }
  v6 = *(re::BindPoint **)(v5 + 72);
  if ((unint64_t)v6 <= v4)
    goto LABEL_91;
  *(_BYTE *)(*(_QWORD *)(v5 + 88) + 24 * v4 + 20) &= ~1u;
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 32))(v5);
}

uint64_t re::internal::AudioAnimationTimelineCompositionChain::cleanup(re::internal::AudioAnimationTimelineCompositionChain *this)
{
  *((_BYTE *)this + 168) = 0;
  *((_QWORD *)this + 18) = 0;
  *((_DWORD *)this + 38) = 0;
  *((_BYTE *)this + 156) = 0;
  *((_QWORD *)this + 20) = 0;
  return (*(uint64_t (**)(re::internal::AudioAnimationTimelineCompositionChain *))(*(_QWORD *)this + 40))(this);
}

void re::AudioAnimationTimeline::~AudioAnimationTimeline(re::AudioAnimationTimeline *this)
{
  uint64_t v2;
  _OWORD *v3;

  *(_QWORD *)this = off_24ED1F350;
  v3 = (_OWORD *)((char *)this + 40);
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    if ((*((_BYTE *)this + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *((_QWORD *)this + 7));
    *v3 = 0u;
    v3[1] = 0u;
  }
  re::StringID::destroyString((re::AudioAnimationTimeline *)((char *)this + 24));
}

{
  uint64_t v2;
  _OWORD *v3;

  *(_QWORD *)this = off_24ED1F350;
  v3 = (_OWORD *)((char *)this + 40);
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    if ((*((_BYTE *)this + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *((_QWORD *)this + 7));
    *v3 = 0u;
    v3[1] = 0u;
  }
  re::StringID::destroyString((re::AudioAnimationTimeline *)((char *)this + 24));
  JUMPOUT(0x2276933B8);
}

uint64_t re::Animation<re::AudioAnimationState>::animationValueType()
{
  unsigned __int8 v0;

  v0 = atomic_load((unsigned __int8 *)&qword_2540FA550);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_2540FA550))
  {
    qword_2540FA548 = re::internal::getOrCreateInfo((re::internal *)"AudioAnimationState", (uint64_t (*)(re::internal *))re::allocInfo_AudioAnimationState, (re::IntrospectionBase *(*)(void))re::initInfo_AudioAnimationState, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::AudioAnimationState>, 0);
    __cxa_guard_release(&qword_2540FA550);
  }
  return qword_2540FA548;
}

uint64_t re::AudioAnimationTimeline::isValidBindPoint()
{
  return 1;
}

_DWORD *re::AnimationImpl<re::AudioAnimationState>::evaluate(_DWORD *result, _BYTE *a2, uint64_t a3, __int128 *a4, uint64_t a5, uint64_t a6)
{
  BOOL v6;
  __int128 v7;

  if (a3)
  {
    if (a2[16])
      v6 = *a2 == 2;
    else
      v6 = 1;
    if (!v6)
      return (_DWORD *)(*(uint64_t (**)(_DWORD *))(*(_QWORD *)result + 104))(result);
    v7 = *a4;
    *(_QWORD *)(a6 + 16) = *((_QWORD *)a4 + 2);
    *(_OWORD *)a6 = v7;
    if (result[2] == 49)
      return (_DWORD *)(*(uint64_t (**)(_DWORD *))(*(_QWORD *)result + 104))(result);
  }
  else
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
    result = (_DWORD *)_os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::AnimationImpl<re::AudioAnimationState>::evaluateCore(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _QWORD *a5)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)a1 + 112))(a1, a2, a3, a4, *a5);
}

void re::internal::AudioAnimationTimelineCompositionChain::~AudioAnimationTimelineCompositionChain(re::internal::AudioAnimationTimelineCompositionChain *this)
{
  *(_QWORD *)this = &off_24ED26508;
  re::internal::AnimationCompositionChain<re::AudioAnimationState>::deinit((uint64_t)this);
  re::internal::AnimationCompositionChainBase::~AnimationCompositionChainBase(this);
}

{
  *(_QWORD *)this = &off_24ED26508;
  re::internal::AnimationCompositionChain<re::AudioAnimationState>::deinit((uint64_t)this);
  re::internal::AnimationCompositionChainBase::~AnimationCompositionChainBase(this);
  JUMPOUT(0x2276933B8);
}

uint64_t re::internal::AnimationCompositionChain<re::AudioAnimationState>::init(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  _anonymous_namespace_ *v4;

  v3 = a1;
  *(_QWORD *)(a1 + 8) = *a2;
  v4 = (_anonymous_namespace_ *)re::DynamicArray<re::BindPoint::BindPointData>::operator=(a1 + 16, a2 + 1);
  v3 += 56;
  re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity((_QWORD *)v3, 0);
  ++*(_DWORD *)(v3 + 24);
  return re::BindPoint::baseValueUntyped((re::BindPoint *)a2);
}

uint64_t re::internal::AnimationCompositionChain<re::AudioAnimationState>::deinit(uint64_t a1)
{
  uint64_t result;
  _QWORD *v3;

  v3 = (_QWORD *)(a1 + 56);
  result = *(_QWORD *)(a1 + 56);
  if (result)
  {
    if (*(_BYTE *)(a1 + 112))
      *(_BYTE *)(a1 + 112) = 0;
    if (*(_QWORD *)(a1 + 88))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a1 + 88) = 0;
    v3[1] = 0;
    v3[2] = 0;
    *v3 = 0;
    ++*(_DWORD *)(a1 + 80);
  }
  return result;
}

uint64_t re::internal::AnimationCompositionChain<re::AudioAnimationState>::apply(uint64_t a1)
{
  re::BindPoint *v2;
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  __int128 v6;

  v2 = (re::BindPoint *)(a1 + 8);
  result = re::BindPoint::isAlive((re::BindPoint *)(a1 + 8));
  if ((_DWORD)result)
  {
    if (*(_QWORD *)(a1 + 72))
    {
      return re::BindPoint::setValue<re::AudioAnimationState>((uint64_t)v2, (__int128 *)(a1 + 144));
    }
    else
    {
      if (*(_BYTE *)(a1 + 104) && re::BindPoint::isOverridden(v2))
      {
        v4 = re::BindPoint::overrideValueUntyped(v2);
        v5 = re::BindPoint::baseValueUntyped(v2);
        if (v5)
        {
          v6 = *(_OWORD *)v4;
          *(_QWORD *)(v5 + 16) = *(_QWORD *)(v4 + 16);
          *(_OWORD *)v5 = v6;
          re::BindPoint::markAsWritten((uint64_t)v2);
        }
      }
      return re::BindPoint::setIsOverridden((uint64_t)v2, 0);
    }
  }
  return result;
}

uint64_t re::internal::AnimationCompositionChain<re::AudioAnimationState>::takeSnapshot(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;

  v1 = result;
  if (*(_QWORD *)(result + 72))
  {
    if (!*(_BYTE *)(result + 112))
      *(_BYTE *)(result + 112) = 1;
    *(_OWORD *)(result + 120) = *(_OWORD *)(result + 144);
    v2 = *(_QWORD *)(result + 160);
    goto LABEL_14;
  }
  if (re::BindPoint::supportsOverrideValue((re::BindPoint *)(result + 8)))
  {
    if (!*(_BYTE *)(v1 + 112))
    {
      *(_BYTE *)(v1 + 112) = 1;
      *(_QWORD *)(v1 + 120) = 0;
      *(_DWORD *)(v1 + 128) = 0;
      *(_BYTE *)(v1 + 132) = 0;
      *(_QWORD *)(v1 + 136) = 0;
    }
    result = re::BindPoint::baseValueUntyped((re::BindPoint *)(v1 + 8));
LABEL_13:
    v2 = *(_QWORD *)(result + 16);
    *(_OWORD *)(v1 + 120) = *(_OWORD *)result;
LABEL_14:
    *(_QWORD *)(v1 + 136) = v2;
    return result;
  }
  result = re::BindPoint::isAlive((re::BindPoint *)(v1 + 8));
  if ((_DWORD)result)
  {
    if (!*(_BYTE *)(v1 + 112))
    {
      *(_BYTE *)(v1 + 112) = 1;
      *(_QWORD *)(v1 + 120) = 0;
      *(_DWORD *)(v1 + 128) = 0;
      *(_BYTE *)(v1 + 132) = 0;
      *(_QWORD *)(v1 + 136) = 0;
    }
    result = re::BindPoint::valueUntyped((re::BindPoint *)(v1 + 8));
    goto LABEL_13;
  }
  if (*(_BYTE *)(v1 + 112))
    *(_BYTE *)(v1 + 112) = 0;
  return result;
}

void re::internal::AnimationCompositionChain<re::AudioAnimationState>::~AnimationCompositionChain(re::internal::AnimationCompositionChainBase *a1)
{
  *(_QWORD *)a1 = &off_24ED26508;
  re::internal::AnimationCompositionChain<re::AudioAnimationState>::deinit((uint64_t)a1);
  re::internal::AnimationCompositionChainBase::~AnimationCompositionChainBase(a1);
}

{
  *(_QWORD *)a1 = &off_24ED26508;
  re::internal::AnimationCompositionChain<re::AudioAnimationState>::deinit((uint64_t)a1);
  re::internal::AnimationCompositionChainBase::~AnimationCompositionChainBase(a1);
  JUMPOUT(0x2276933B8);
}

uint64_t re::BindPoint::setValue<re::AudioAnimationState>(uint64_t result, __int128 *a2)
{
  uint64_t v2;
  re::BindPoint *v4;
  unint64_t v5;
  _QWORD *v6;
  size_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;
  __int128 v16;
  _QWORD v17[2];
  int v18;
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  uint64_t v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  uint64_t v31;

  v31 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(result + 24);
  if (v2)
  {
    v4 = (re::BindPoint *)result;
    MEMORY[0x24BDAC7A8](result);
    v6 = (_QWORD *)((char *)v17 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0));
    if (v5 >= 0x200)
      v7 = 512;
    else
      v7 = v5;
    bzero((char *)v17 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0), v7);
    v8 = 0;
    v9 = 0;
    v10 = *((_QWORD *)v4 + 3);
    do
    {
      if (v10 == v9)
      {
        v17[1] = 0;
        v29 = 0u;
        v30 = 0u;
        v27 = 0u;
        v28 = 0u;
        v26 = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        v18 = 136315906;
        v19 = "operator[]";
        v20 = 1024;
        v21 = 797;
        v22 = 2048;
        v23 = v10;
        v24 = 2048;
        v25 = v10;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      v11 = (_QWORD *)(*((_QWORD *)v4 + 5) + v8);
      if (!*v11)
        v11 = (_QWORD *)v11[2];
      v6[v9++] = v11;
      v8 += 32;
    }
    while (v2 != v9);
    v12 = v2 - 1;
    v13 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD *, uint64_t))(*(_QWORD *)*v6 + 120))(*v6, 0, v6 + 1, v12);
    if (v13)
    {
      v14 = v13;
      result = re::BindPoint::isOverridden(v4);
      if (!(_DWORD)result
        || *(double *)v14 != *(double *)a2
        || *(float *)(v14 + 8) != *((float *)a2 + 2)
        || *(unsigned __int8 *)(v14 + 12) != *((unsigned __int8 *)a2 + 12))
      {
        v15 = *a2;
        *(_QWORD *)(v14 + 16) = *((_QWORD *)a2 + 2);
        *(_OWORD *)v14 = v15;
        re::BindPoint::setIsOverridden((uint64_t)v4, 1);
        return re::BindPoint::markAsWritten((uint64_t)v4);
      }
    }
    else
    {
      result = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD *, uint64_t))(*(_QWORD *)*v6 + 88))(*v6, 0, v6 + 1, v12);
      if (result
        && (*(double *)result != *(double *)a2
         || *(float *)(result + 8) != *((float *)a2 + 2)
         || *(unsigned __int8 *)(result + 12) != *((unsigned __int8 *)a2 + 12)))
      {
        v16 = *a2;
        *(_QWORD *)(result + 16) = *((_QWORD *)a2 + 2);
        *(_OWORD *)result = v16;
        return re::BindPoint::markAsWritten((uint64_t)v4);
      }
    }
  }
  return result;
}

uint64_t *re::allocInfo_AnimationService(re *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&_MergedGlobals_25);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&_MergedGlobals_25))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FA5F8, 0);
    *(uint64_t *)((char *)&qword_2540FA608 + 6) = 0;
    qword_2540FA608 = 0;
    qword_2540FA618 = 0;
    qword_2540FA620 = 0xFFFFFFFFLL;
    qword_2540FA5F8 = (uint64_t)&off_24ED7DAA8;
    qword_2540FA628 = (uint64_t)"AnimationService";
    dword_2540FA630 = 0;
    unk_2540FA638 = 0u;
    unk_2540FA648 = 0u;
    unk_2540FA658 = 0u;
    qword_2540FA668 = 0;
    __cxa_guard_release(&_MergedGlobals_25);
  }
  return &qword_2540FA5F8;
}

void re::initInfo_AnimationService(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  __int128 v4;
  _QWORD v5[2];
  __int128 v6;

  v5[0] = 0x1D19303ADC189562;
  v5[1] = "AnimationService";
  re::StringID::destroyString((re::StringID *)v5);
  *((_OWORD *)this + 2) = v6;
  *((_QWORD *)this + 2) = 0x800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 8) = &re::initInfo_AnimationService(re::IntrospectionBase *)::structureAttributes;
  re::IntrospectionRegistry::add(this, v3);
  v4 = v6;
}

uint64_t re::introspect_AnimationService(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"AnimationService", (uint64_t (*)(re::internal *))re::allocInfo_AnimationService, (re::IntrospectionBase *(*)(void))re::initInfo_AnimationService, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::AnimationService>, this);
}

re::StringID *re::internal::defaultConstruct<re::BlendParameterInputNode>(uint64_t a1, uint64_t a2, re::StringID *a3)
{
  re::StringID *result;

  result = re::StringID::invalid(a3);
  *((_DWORD *)a3 + 4) = -1;
  return result;
}

void re::internal::defaultDestruct<re::BlendParameterInputNode>(int a1, int a2, re::StringID *this)
{
  re::StringID::destroyString(this);
}

re::StringID *re::internal::defaultConstructV2<re::BlendParameterInputNode>(re::StringID *a1)
{
  re::StringID *result;

  result = re::StringID::invalid(a1);
  *((_DWORD *)a1 + 4) = -1;
  return result;
}

re::StringID *re::internal::defaultConstruct<re::BlendValueInputNode>(uint64_t a1, uint64_t a2, re::StringID *a3)
{
  re::StringID *result;

  result = re::StringID::invalid(a3);
  *((_DWORD *)a3 + 4) = 0;
  return result;
}

void re::internal::defaultDestruct<re::BlendValueInputNode>(int a1, int a2, re::StringID *this)
{
  re::StringID::destroyString(this);
}

re::StringID *re::internal::defaultConstructV2<re::BlendValueInputNode>(re::StringID *a1)
{
  re::StringID *result;

  result = re::StringID::invalid(a1);
  *((_DWORD *)a1 + 4) = 0;
  return result;
}

void re::introspect_BlendType(re *this, const re::IntrospectionBase *a2)
{
  unsigned __int8 v2;
  unsigned __int8 v3;
  uint64_t *v4;
  uint64_t v5;
  unsigned int *v6;
  _anonymous_namespace_ *v7;
  unint64_t v8;
  unint64_t i;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  char v13;
  unsigned __int8 *v14;
  int v15;
  uint64_t v16;
  unint64_t j;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  char v21;
  unsigned __int8 *v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  re *v26;
  uint64_t *v27;
  re *v28;
  uint64_t *v29;
  re *v30;
  uint64_t *v31;
  re *v32;
  uint64_t *v33;
  re *v34;
  uint64_t *v35;
  re *v36;
  uint64_t *v37;
  re *v38;
  uint64_t *v39;
  re *v40;
  uint64_t *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  const char *v45;
  StringID v46;
  _QWORD v47[2];
  _QWORD v48[61];

  v2 = atomic_load((unsigned __int8 *)&qword_2540FA6A8);
  if ((v2 & 1) == 0)
  {
    v26 = (re *)__cxa_guard_acquire(&qword_2540FA6A8);
    if ((_DWORD)v26)
    {
      v27 = re::introspectionAllocator(v26);
      v28 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v27 + 32))(v27, 24, 8);
      *(_DWORD *)v28 = 1;
      *((_QWORD *)v28 + 1) = 0;
      *((_QWORD *)v28 + 2) = "Unknown";
      qword_2540FA738 = (uint64_t)v28;
      v29 = re::introspectionAllocator(v28);
      v30 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v29 + 32))(v29, 24, 8);
      *(_DWORD *)v30 = 1;
      *((_QWORD *)v30 + 1) = 1;
      *((_QWORD *)v30 + 2) = "Invert";
      qword_2540FA740 = (uint64_t)v30;
      v31 = re::introspectionAllocator(v30);
      v32 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v31 + 32))(v31, 24, 8);
      *(_DWORD *)v32 = 1;
      *((_QWORD *)v32 + 1) = 2;
      *((_QWORD *)v32 + 2) = "Identity";
      qword_2540FA748 = (uint64_t)v32;
      v33 = re::introspectionAllocator(v32);
      v34 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v33 + 32))(v33, 24, 8);
      *(_DWORD *)v34 = 1;
      *((_QWORD *)v34 + 1) = 3;
      *((_QWORD *)v34 + 2) = "Repeat";
      qword_2540FA750 = (uint64_t)v34;
      v35 = re::introspectionAllocator(v34);
      v36 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v35 + 32))(v35, 24, 8);
      *(_DWORD *)v36 = 1;
      *((_QWORD *)v36 + 1) = 4;
      *((_QWORD *)v36 + 2) = "Interpolate";
      qword_2540FA758 = (uint64_t)v36;
      v37 = re::introspectionAllocator(v36);
      v38 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v37 + 32))(v37, 24, 8);
      *(_DWORD *)v38 = 1;
      *((_QWORD *)v38 + 1) = 5;
      *((_QWORD *)v38 + 2) = "AdditiveBlend";
      qword_2540FA760 = (uint64_t)v38;
      v39 = re::introspectionAllocator(v38);
      v40 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v39 + 32))(v39, 24, 8);
      *(_DWORD *)v40 = 1;
      *((_QWORD *)v40 + 1) = 6;
      *((_QWORD *)v40 + 2) = "WeightedAdditiveBlend";
      qword_2540FA768 = (uint64_t)v40;
      v41 = re::introspectionAllocator(v40);
      v42 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v41 + 32))(v41, 24, 8);
      *(_DWORD *)v42 = 1;
      *(_QWORD *)(v42 + 8) = 7;
      *(_QWORD *)(v42 + 16) = "BlendTypeCount";
      qword_2540FA770 = v42;
      __cxa_guard_release(&qword_2540FA6A8);
    }
  }
  v3 = atomic_load((unsigned __int8 *)&qword_2540FA6B0);
  if ((v3 & 1) == 0 && __cxa_guard_acquire(&qword_2540FA6B0))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_2540FA838, "BlendType", 1, 1, 1, 1);
    qword_2540FA838 = (uint64_t)&off_24ED7D9E8;
    qword_2540FA878 = (uint64_t)&re::introspect_BlendType(BOOL)::enumTable;
    dword_2540FA848 = 9;
    __cxa_guard_release(&qword_2540FA6B0);
  }
  if ((_MergedGlobals_26 & 1) == 0)
  {
    _MergedGlobals_26 = 1;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_2540FA838, a2);
    v44 = 0x6BF759AE6616;
    v45 = "BlendType";
    v48[0] = 0x31CD534126;
    v48[1] = "uint8_t";
    v4 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v48);
    if (v4)
    {
      v5 = *v4;
      re::StringID::destroyString((re::StringID *)v48);
      v6 = (unsigned int *)qword_2540FA878;
      v47[1] = v5;
      re::TypeBuilder::beginEnumType((uint64_t)v48, &v44, 1, 1, (uint64_t)v47);
      v8 = *v6;
      if ((_DWORD)v8)
      {
        for (i = 0; i < v8; ++i)
        {
          v10 = *(_QWORD *)(*((_QWORD *)v6 + 1) + 8 * i);
          if (*(_DWORD *)v10 == 1)
          {
            v11 = *(char **)(v10 + 16);
            if (v11)
            {
              v12 = *v11;
              if (*v11)
              {
                v13 = v11[1];
                if (v13)
                {
                  v14 = (unsigned __int8 *)(v11 + 2);
                  do
                  {
                    v12 = 31 * v12 + v13;
                    v15 = *v14++;
                    v13 = v15;
                  }
                  while (v15);
                }
              }
            }
            else
            {
              v12 = 0;
            }
            v16 = *(_QWORD *)(v10 + 8);
            *(_QWORD *)&v46.var0 = 2 * v12;
            v46.var1 = v11;
            re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v48, v16, &v46);
            re::StringID::destroyString((re::StringID *)&v46);
            v8 = *v6;
          }
        }
        if (v8)
        {
          for (j = 0; j < v8; ++j)
          {
            v18 = *(_QWORD *)(*((_QWORD *)v6 + 1) + 8 * j);
            if (*(_DWORD *)v18 == 2)
            {
              v19 = *(char **)(v18 + 16);
              if (v19)
              {
                v20 = *v19;
                if (*v19)
                {
                  v21 = v19[1];
                  if (v21)
                  {
                    v22 = (unsigned __int8 *)(v19 + 2);
                    do
                    {
                      v20 = 31 * v20 + v21;
                      v23 = *v22++;
                      v21 = v23;
                    }
                    while (v23);
                  }
                }
              }
              else
              {
                v20 = 0;
              }
              v24 = *(_QWORD *)(v18 + 8);
              *(_QWORD *)&v46.var0 = 2 * v20;
              v46.var1 = v19;
              re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v48, v24, &v46);
              re::StringID::destroyString((re::StringID *)&v46);
              v8 = *v6;
            }
          }
        }
      }
      re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v48, v25);
      xmmword_2540FA858 = (__int128)v46;
      re::StringID::destroyString((re::StringID *)&v44);
    }
    else
    {
      re::StringID::destroyString((re::StringID *)v48);
      re::internal::assertLog((re::internal *)5, v43, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "BlendType", v44, v45);
      _os_crash();
      __break(1u);
    }
  }
}

void re::internal::defaultConstruct<re::BlendNode>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_BYTE *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_DWORD *)(a3 + 4) = 0;
}

uint64_t re::internal::defaultConstructV2<re::BlendNode>(uint64_t result)
{
  *(_BYTE *)result = 0;
  *(_QWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 4) = 0;
  return result;
}

uint64_t *re::allocInfo_BlendTreeDefinition(re *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  v1 = atomic_load((unsigned __int8 *)&qword_2540FA6D0);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_2540FA6D0))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FAA38, 0);
    *(_QWORD *)(v3 + 22) = 0;
    qword_2540FAA48 = 0;
    qword_2540FAA58 = 0;
    qword_2540FAA60 = 0xFFFFFFFFLL;
    qword_2540FAA38 = (uint64_t)&off_24ED7DAA8;
    qword_2540FAA68 = (uint64_t)"BlendTreeDefinition";
    dword_2540FAA70 = 0;
    *(_OWORD *)(v3 + 64) = 0u;
    *(_OWORD *)(v3 + 80) = 0u;
    *(_OWORD *)(v3 + 96) = 0u;
    qword_2540FAAA8 = 0;
    __cxa_guard_release(&qword_2540FA6D0);
  }
  return &qword_2540FAA38;
}

void re::initInfo_BlendTreeDefinition(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  const re::IntrospectionBase *v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t *v12;
  const re::IntrospectionBase *v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t *v18;
  const re::IntrospectionBase *v19;
  void *v20;
  uint64_t v21;
  uint64_t *v22;
  const re::IntrospectionBase *v23;
  void *v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t *v28;
  const re::IntrospectionBase *v29;
  uint64_t *v30;
  uint64_t v31;
  uint64_t *v32;
  const re::IntrospectionBase *v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t *v36;
  uint64_t v37;
  __int128 v38;
  _QWORD v39[2];
  __int128 v40;

  v39[0] = 0x498A493E4355D444;
  v39[1] = "BlendTreeDefinition";
  re::StringID::destroyString((re::StringID *)v39);
  *((_OWORD *)this + 2) = v40;
  v4 = atomic_load((unsigned __int8 *)&qword_2540FA6D8);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_2540FA6D8);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      v8 = re::IntrospectionInfo<re::DynamicArray<unsigned int>>::get(1, v7);
      v9 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
      *(_DWORD *)v9 = 1;
      *(_QWORD *)(v9 + 8) = "defaultUInt32s";
      *(_QWORD *)(v9 + 16) = v8;
      *(_QWORD *)(v9 + 24) = 0;
      *(_QWORD *)(v9 + 32) = 1;
      *(_DWORD *)(v9 + 40) = 0;
      *(_QWORD *)(v9 + 48) = 0;
      *(_QWORD *)(v9 + 56) = 0;
      *(_DWORD *)(v9 + 64) = 0;
      qword_2540FA880 = v9;
      v10 = re::introspectionAllocator((re *)v9);
      re::IntrospectionInfo<re::DynamicArray<re::BlendParameterInputNode>>::get();
      v11 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v10 + 32))(v10, 72, 8);
      *(_DWORD *)v11 = 1;
      *(_QWORD *)(v11 + 8) = "parameterInputUInt32Nodes";
      *(_QWORD *)(v11 + 16) = &qword_2540FA778;
      *(_QWORD *)(v11 + 24) = 0;
      *(_QWORD *)(v11 + 32) = 0x2800000002;
      *(_DWORD *)(v11 + 40) = 0;
      *(_QWORD *)(v11 + 48) = 0;
      *(_QWORD *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_2540FA888 = v11;
      v12 = re::introspectionAllocator((re *)v11);
      v14 = re::IntrospectionInfo<re::DynamicArray<float>>::get(1, v13);
      v15 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v12 + 32))(v12, 72, 8);
      *(_DWORD *)v15 = 1;
      *(_QWORD *)(v15 + 8) = "defaultFloats";
      *(_QWORD *)(v15 + 16) = v14;
      *(_QWORD *)(v15 + 24) = 0;
      *(_QWORD *)(v15 + 32) = 0x5000000003;
      *(_DWORD *)(v15 + 40) = 0;
      *(_QWORD *)(v15 + 48) = 0;
      *(_QWORD *)(v15 + 56) = 0;
      *(_DWORD *)(v15 + 64) = 0;
      qword_2540FA890 = v15;
      v16 = re::introspectionAllocator((re *)v15);
      re::IntrospectionInfo<re::DynamicArray<re::BlendParameterInputNode>>::get();
      v17 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v16 + 32))(v16, 72, 8);
      *(_DWORD *)v17 = 1;
      *(_QWORD *)(v17 + 8) = "parameterInputFloatNodes";
      *(_QWORD *)(v17 + 16) = &qword_2540FA778;
      *(_QWORD *)(v17 + 24) = 0;
      *(_QWORD *)(v17 + 32) = 0x7800000004;
      *(_DWORD *)(v17 + 40) = 0;
      *(_QWORD *)(v17 + 48) = 0;
      *(_QWORD *)(v17 + 56) = 0;
      *(_DWORD *)(v17 + 64) = 0;
      qword_2540FA898 = v17;
      v18 = re::introspectionAllocator((re *)v17);
      v20 = re::introspect_uint32_t((re *)1, v19);
      v21 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v18 + 32))(v18, 72, 8);
      *(_DWORD *)v21 = 1;
      *(_QWORD *)(v21 + 8) = "blendValueCount";
      *(_QWORD *)(v21 + 16) = v20;
      *(_QWORD *)(v21 + 24) = 0;
      *(_QWORD *)(v21 + 32) = 0xA000000005;
      *(_DWORD *)(v21 + 40) = 0;
      *(_QWORD *)(v21 + 48) = 0;
      *(_QWORD *)(v21 + 56) = 0;
      *(_DWORD *)(v21 + 64) = 0;
      qword_2540FA8A0 = v21;
      v22 = re::introspectionAllocator((re *)v21);
      v24 = re::introspect_uint32_t((re *)1, v23);
      v25 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v22 + 32))(v22, 72, 8);
      *(_DWORD *)v25 = 1;
      *(_QWORD *)(v25 + 8) = "blendOutputIndex";
      *(_QWORD *)(v25 + 16) = v24;
      *(_QWORD *)(v25 + 24) = 0;
      *(_QWORD *)(v25 + 32) = 0xA400000006;
      *(_DWORD *)(v25 + 40) = 0;
      *(_QWORD *)(v25 + 48) = 0;
      *(_QWORD *)(v25 + 56) = 0;
      *(_DWORD *)(v25 + 64) = 0;
      qword_2540FA8A8 = v25;
      v26 = re::introspectionAllocator((re *)v25);
      re::IntrospectionInfo<re::DynamicArray<re::BlendValueInputNode>>::get();
      v27 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v26 + 32))(v26, 72, 8);
      *(_DWORD *)v27 = 1;
      *(_QWORD *)(v27 + 8) = "blendValueInputNodes";
      *(_QWORD *)(v27 + 16) = &qword_2540FA7B8;
      *(_QWORD *)(v27 + 24) = 0;
      *(_QWORD *)(v27 + 32) = 0xA800000007;
      *(_DWORD *)(v27 + 40) = 0;
      *(_QWORD *)(v27 + 48) = 0;
      *(_QWORD *)(v27 + 56) = 0;
      *(_DWORD *)(v27 + 64) = 0;
      qword_2540FA8B0 = v27;
      v28 = re::introspectionAllocator((re *)v27);
      v30 = re::IntrospectionInfo<re::DynamicArray<unsigned int>>::get(1, v29);
      v31 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v28 + 32))(v28, 72, 8);
      *(_DWORD *)v31 = 1;
      *(_QWORD *)(v31 + 8) = "blendNodeParameters";
      *(_QWORD *)(v31 + 16) = v30;
      *(_QWORD *)(v31 + 24) = 0;
      *(_QWORD *)(v31 + 32) = 0xD000000008;
      *(_DWORD *)(v31 + 40) = 0;
      *(_QWORD *)(v31 + 48) = 0;
      *(_QWORD *)(v31 + 56) = 0;
      *(_DWORD *)(v31 + 64) = 0;
      qword_2540FA8B8 = v31;
      v32 = re::introspectionAllocator((re *)v31);
      v34 = re::IntrospectionInfo<re::DynamicArray<unsigned int>>::get(1, v33);
      v35 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v32 + 32))(v32, 72, 8);
      *(_DWORD *)v35 = 1;
      *(_QWORD *)(v35 + 8) = "blendNodeOptions";
      *(_QWORD *)(v35 + 16) = v34;
      *(_QWORD *)(v35 + 24) = 0;
      *(_QWORD *)(v35 + 32) = 0xF800000009;
      *(_DWORD *)(v35 + 40) = 0;
      *(_QWORD *)(v35 + 48) = 0;
      *(_QWORD *)(v35 + 56) = 0;
      *(_DWORD *)(v35 + 64) = 0;
      qword_2540FA8C0 = v35;
      v36 = re::introspectionAllocator((re *)v35);
      re::IntrospectionInfo<re::DynamicArray<re::BlendNode>>::get();
      v37 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v36 + 32))(v36, 72, 8);
      *(_DWORD *)v37 = 1;
      *(_QWORD *)(v37 + 8) = "blendNodes";
      *(_QWORD *)(v37 + 16) = &qword_2540FA7F8;
      *(_QWORD *)(v37 + 24) = 0;
      *(_QWORD *)(v37 + 32) = 0x1200000000ALL;
      *(_DWORD *)(v37 + 40) = 0;
      *(_QWORD *)(v37 + 48) = 0;
      *(_QWORD *)(v37 + 56) = 0;
      *(_DWORD *)(v37 + 64) = 0;
      qword_2540FA8C8 = v37;
      __cxa_guard_release(&qword_2540FA6D8);
    }
  }
  *((_QWORD *)this + 2) = 0x14800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 10;
  *((_QWORD *)this + 8) = &qword_2540FA880;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::BlendTreeDefinition>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::BlendTreeDefinition>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::BlendTreeDefinition>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::BlendTreeDefinition>;
  re::IntrospectionRegistry::add(this, v3);
  v38 = v40;
}

uint64_t *re::IntrospectionInfo<re::DynamicArray<unsigned int>>::get(int a1, const re::IntrospectionBase *a2)
{
  unsigned __int8 v3;
  int v4;
  re *v5;
  std::__shared_mutex_base *v6;
  re *v7;
  std::__shared_mutex_base *v8;
  uint64_t v10;
  int v11;
  re::IntrospectionRegistry *v12;
  const re::IntrospectionBase *v13;
  const char *v14;
  __int128 v15;
  __int128 v16;
  const char *v17;
  uint64_t v18[2];

  if ((v3 & 1) == 0
  {
    re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&re::IntrospectionInfo<re::DynamicArray<unsigned int>>::get(BOOL)::info);
    re::IntrospectionInfo<re::DynamicArray<unsigned int>>::get(BOOL)::info = (uint64_t)&off_24ED26560;
  }
  if (a1)
  {
    if (re::IntrospectionInfo<re::DynamicArray<unsigned int>>::get(BOOL)::isInitialized)
      return &re::IntrospectionInfo<re::DynamicArray<unsigned int>>::get(BOOL)::info;
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v16);
    v4 = re::IntrospectionInfo<re::DynamicArray<unsigned int>>::get(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v16);
    if (v4)
      return &re::IntrospectionInfo<re::DynamicArray<unsigned int>>::get(BOOL)::info;
    v6 = re::introspectionSharedMutex(v5);
    std::__shared_mutex_base::lock(v6);
  }
  v7 = (re *)re::introspect_uint32_t((re *)1, a2);
  if (re::IntrospectionInfo<re::DynamicArray<unsigned int>>::get(BOOL)::isInitialized)
  {
    if ((a1 & 1) == 0)
    {
LABEL_9:
      v8 = re::introspectionSharedMutex(v7);
      std::__shared_mutex_base::unlock(v8);
    }
  }
  else
  {
    v10 = (uint64_t)v7;
    re::IntrospectionInfo<re::DynamicArray<unsigned int>>::get(BOOL)::isInitialized = 1;
    v11 = *((_DWORD *)v7 + 6);
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&re::IntrospectionInfo<re::DynamicArray<unsigned int>>::get(BOOL)::info, 0);
    qword_2557FF678 = 0x2800000003;
    dword_2557FF680 = v11;
    word_2557FF684 = 0;
    *(_QWORD *)&xmmword_2557FF688 = 0;
    *((_QWORD *)&xmmword_2557FF688 + 1) = 0xFFFFFFFFLL;
    qword_2557FF698 = v10;
    unk_2557FF6A0 = 0;
    re::IntrospectionInfo<re::DynamicArray<unsigned int>>::get(BOOL)::info = (uint64_t)&off_24ED26560;
    re::IntrospectionRegistry::add(v12, v13);
    re::getPrettyTypeName((re *)&re::IntrospectionInfo<re::DynamicArray<unsigned int>>::get(BOOL)::info, (const re::IntrospectionBase *)&v16);
    if ((BYTE8(v16) & 1) != 0)
      v14 = v17;
    else
      v14 = (char *)&v16 + 9;
    if ((_QWORD)v16 && (BYTE8(v16) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v16 + 40))();
    v16 = *(_OWORD *)(v10 + 32);
    xmmword_2557FF688 = v15;
    re::StringID::destroyString((re::StringID *)v18);
    if ((a1 & 1) == 0)
      goto LABEL_9;
  }
  return &re::IntrospectionInfo<re::DynamicArray<unsigned int>>::get(BOOL)::info;
}

void re::IntrospectionInfo<re::DynamicArray<re::BlendParameterInputNode>>::get()
{
  unsigned __int8 v0;
  uint64_t *v1;
  unsigned __int8 v2;
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  int v5;
  re::IntrospectionRegistry *v6;
  const re::IntrospectionBase *v7;
  const char *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  re *v13;
  uint64_t *v14;
  const re::IntrospectionBase *v15;
  void *v16;
  uint64_t v17;
  uint64_t *v18;
  const re::IntrospectionBase *v19;
  void *v20;
  uint64_t v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24[2];
  __int128 v25;
  const char *v26;
  __int128 v27;

  v0 = atomic_load((unsigned __int8 *)&qword_2540FA6E0);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_2540FA6E0))
  {
    re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_2540FA778);
    qword_2540FA778 = (uint64_t)&off_24ED265F8;
    __cxa_guard_release(&qword_2540FA6E0);
  }
  if ((byte_2540FA671 & 1) == 0)
  {
    v1 = (uint64_t *)qword_2540FA688;
    if (qword_2540FA688)
      goto LABEL_7;
    v2 = atomic_load((unsigned __int8 *)&qword_2540FA678);
    if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_2540FA678))
    {
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FA8D0, 0);
      *(_QWORD *)(v12 + 22) = 0;
      qword_2540FA8E0 = 0;
      *(_QWORD *)&xmmword_2540FA8F0 = 0;
      *((_QWORD *)&xmmword_2540FA8F0 + 1) = 0xFFFFFFFFLL;
      qword_2540FA8D0 = (uint64_t)&off_24ED7DAA8;
      qword_2540FA900 = (uint64_t)"BlendParameterInputNode";
      dword_2540FA908 = 0;
      xmmword_2540FA910 = 0u;
      *(_OWORD *)&qword_2540FA920 = 0u;
      xmmword_2540FA930 = 0u;
      qword_2540FA940 = 0;
      __cxa_guard_release(&qword_2540FA678);
    }
    qword_2540FA688 = (uint64_t)&qword_2540FA8D0;
    *(_QWORD *)&v27 = 0xA1A56AFCB4DA42A8;
    *((_QWORD *)&v27 + 1) = "BlendParameterInputNode";
    re::StringID::destroyString((re::StringID *)&v27);
    xmmword_2540FA8F0 = v25;
    v4 = atomic_load((unsigned __int8 *)&qword_2540FA680);
    if ((v4 & 1) == 0)
    {
      v13 = (re *)__cxa_guard_acquire(&qword_2540FA680);
      if ((_DWORD)v13)
      {
        v14 = re::introspectionAllocator(v13);
        v16 = re::IntrospectionInfo<re::StringID>::get(1, v15);
        v17 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v14 + 32))(v14, 72, 8);
        *(_DWORD *)v17 = 1;
        *(_QWORD *)(v17 + 8) = "name";
        *(_QWORD *)(v17 + 16) = v16;
        *(_QWORD *)(v17 + 24) = 0;
        *(_QWORD *)(v17 + 32) = 1;
        *(_DWORD *)(v17 + 40) = 0;
        *(_QWORD *)(v17 + 48) = 0;
        *(_QWORD *)(v17 + 56) = 0;
        *(_DWORD *)(v17 + 64) = 0;
        qword_2540FA6F8 = v17;
        v18 = re::introspectionAllocator((re *)v17);
        v20 = re::introspect_uint32_t((re *)1, v19);
        v21 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v18 + 32))(v18, 72, 8);
        *(_DWORD *)v21 = 1;
        *(_QWORD *)(v21 + 8) = "defaultValueIndex";
        *(_QWORD *)(v21 + 16) = v20;
        *(_QWORD *)(v21 + 24) = 0;
        *(_QWORD *)(v21 + 32) = 0x1000000002;
        *(_DWORD *)(v21 + 40) = 0;
        *(_QWORD *)(v21 + 48) = 0;
        *(_QWORD *)(v21 + 56) = 0;
        *(_DWORD *)(v21 + 64) = 0;
        qword_2540FA700 = v21;
        __cxa_guard_release(&qword_2540FA680);
      }
    }
    qword_2540FA8E0 = 0x1800000008;
    v1 = &qword_2540FA8D0;
    dword_2540FA8E8 = 8;
    word_2540FA8EC = 0;
    dword_2540FA908 = 2;
    *(_QWORD *)&xmmword_2540FA910 = &qword_2540FA6F8;
    *((_QWORD *)&xmmword_2540FA910 + 1) = re::internal::defaultConstruct<re::BlendParameterInputNode>;
    qword_2540FA920 = (uint64_t)re::internal::defaultDestruct<re::BlendParameterInputNode>;
    *(_QWORD *)&xmmword_2540FA930 = 0;
    qword_2540FA928 = 0;
    *((_QWORD *)&xmmword_2540FA930 + 1) = re::internal::defaultConstructV2<re::BlendParameterInputNode>;
    qword_2540FA940 = (uint64_t)re::internal::defaultDestructV2<re::BlendParameterInputNode>;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_2540FA8D0, v3);
    v27 = v25;
    if ((byte_2540FA671 & 1) == 0)
    {
LABEL_7:
      byte_2540FA671 = 1;
      v5 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FA778, 0);
      qword_2540FA788 = 0x2800000003;
      dword_2540FA790 = v5;
      word_2540FA794 = 0;
      *(_QWORD *)&xmmword_2540FA798 = 0;
      *((_QWORD *)&xmmword_2540FA798 + 1) = 0xFFFFFFFFLL;
      qword_2540FA7A8 = (uint64_t)v1;
      unk_2540FA7B0 = 0;
      qword_2540FA778 = (uint64_t)&off_24ED265F8;
      re::IntrospectionRegistry::add(v6, v7);
      re::getPrettyTypeName((re *)&qword_2540FA778, (const re::IntrospectionBase *)&v25);
      if ((BYTE8(v25) & 1) != 0)
        v8 = v26;
      else
        v8 = (char *)&v25 + 9;
      if ((_QWORD)v25 && (BYTE8(v25) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v25 + 40))();
      v23 = *((_OWORD *)v1 + 2);
      v9 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v24);
      if (v9)
      {
        v10 = *v9;
        *((_QWORD *)&v22 + 1) = v10;
      }
      else
      {
        v27 = v23;
        re::TypeBuilder::beginListType((uint64_t)&v25, v24, 1, 0x28uLL, 8uLL, &v27);
        re::TypeBuilder::setConstructor((uint64_t)&v25, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::BlendParameterInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v25, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::BlendParameterInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v25, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v25, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::BlendParameterInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::BlendParameterInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v25, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::BlendParameterInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v25, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::BlendParameterInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::BlendParameterInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::BlendParameterInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v25, v11);
      }
      xmmword_2540FA798 = v22;
      re::StringID::destroyString((re::StringID *)v24);
    }
  }
}

void re::IntrospectionInfo<re::DynamicArray<re::BlendValueInputNode>>::get()
{
  unsigned __int8 v0;
  uint64_t *v1;
  unsigned __int8 v2;
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  int v5;
  re::IntrospectionRegistry *v6;
  const re::IntrospectionBase *v7;
  const char *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  re *v13;
  uint64_t *v14;
  const re::IntrospectionBase *v15;
  void *v16;
  uint64_t v17;
  uint64_t *v18;
  const re::IntrospectionBase *v19;
  void *v20;
  uint64_t v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24[2];
  __int128 v25;
  const char *v26;
  __int128 v27;

  v0 = atomic_load((unsigned __int8 *)&qword_2540FA6E8);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_2540FA6E8))
  {
    re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_2540FA7B8);
    qword_2540FA7B8 = (uint64_t)&off_24ED26690;
    __cxa_guard_release(&qword_2540FA6E8);
  }
  if ((byte_2540FA672 & 1) == 0)
  {
    v1 = (uint64_t *)qword_2540FA6A0;
    if (qword_2540FA6A0)
      goto LABEL_7;
    v2 = atomic_load((unsigned __int8 *)&qword_2540FA690);
    if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_2540FA690))
    {
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FA948, 0);
      *(_QWORD *)(v12 + 22) = 0;
      qword_2540FA958 = 0;
      *(_QWORD *)&xmmword_2540FA968 = 0;
      *((_QWORD *)&xmmword_2540FA968 + 1) = 0xFFFFFFFFLL;
      qword_2540FA948 = (uint64_t)&off_24ED7DAA8;
      qword_2540FA978 = (uint64_t)"BlendValueInputNode";
      dword_2540FA980 = 0;
      *(_OWORD *)(v12 + 64) = 0u;
      *(_OWORD *)(v12 + 80) = 0u;
      *(_OWORD *)(v12 + 96) = 0u;
      qword_2540FA9B8 = 0;
      __cxa_guard_release(&qword_2540FA690);
    }
    qword_2540FA6A0 = (uint64_t)&qword_2540FA948;
    *(_QWORD *)&v27 = 0x26A7E5732D4BEA18;
    *((_QWORD *)&v27 + 1) = "BlendValueInputNode";
    re::StringID::destroyString((re::StringID *)&v27);
    xmmword_2540FA968 = v25;
    v4 = atomic_load((unsigned __int8 *)&qword_2540FA698);
    if ((v4 & 1) == 0)
    {
      v13 = (re *)__cxa_guard_acquire(&qword_2540FA698);
      if ((_DWORD)v13)
      {
        v14 = re::introspectionAllocator(v13);
        v16 = re::IntrospectionInfo<re::StringID>::get(1, v15);
        v17 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v14 + 32))(v14, 72, 8);
        *(_DWORD *)v17 = 1;
        *(_QWORD *)(v17 + 8) = "name";
        *(_QWORD *)(v17 + 16) = v16;
        *(_QWORD *)(v17 + 24) = 0;
        *(_QWORD *)(v17 + 32) = 1;
        *(_DWORD *)(v17 + 40) = 0;
        *(_QWORD *)(v17 + 48) = 0;
        *(_QWORD *)(v17 + 56) = 0;
        *(_DWORD *)(v17 + 64) = 0;
        qword_2540FA708 = v17;
        v18 = re::introspectionAllocator((re *)v17);
        v20 = re::introspect_uint32_t((re *)1, v19);
        v21 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v18 + 32))(v18, 72, 8);
        *(_DWORD *)v21 = 1;
        *(_QWORD *)(v21 + 8) = "blendValueIndex";
        *(_QWORD *)(v21 + 16) = v20;
        *(_QWORD *)(v21 + 24) = 0;
        *(_QWORD *)(v21 + 32) = 0x1000000002;
        *(_DWORD *)(v21 + 40) = 0;
        *(_QWORD *)(v21 + 48) = 0;
        *(_QWORD *)(v21 + 56) = 0;
        *(_DWORD *)(v21 + 64) = 0;
        qword_2540FA710 = v21;
        __cxa_guard_release(&qword_2540FA698);
      }
    }
    qword_2540FA958 = 0x1800000008;
    v1 = &qword_2540FA948;
    dword_2540FA960 = 8;
    word_2540FA964 = 0;
    dword_2540FA980 = 2;
    qword_2540FA988 = (uint64_t)&qword_2540FA708;
    qword_2540FA990 = (uint64_t)re::internal::defaultConstruct<re::BlendValueInputNode>;
    qword_2540FA998 = (uint64_t)re::internal::defaultDestruct<re::BlendValueInputNode>;
    qword_2540FA9A8 = 0;
    qword_2540FA9A0 = 0;
    qword_2540FA9B0 = (uint64_t)re::internal::defaultConstructV2<re::BlendValueInputNode>;
    qword_2540FA9B8 = (uint64_t)re::internal::defaultDestructV2<re::BlendValueInputNode>;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_2540FA948, v3);
    v27 = v25;
    if ((byte_2540FA672 & 1) == 0)
    {
LABEL_7:
      byte_2540FA672 = 1;
      v5 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FA7B8, 0);
      qword_2540FA7C8 = 0x2800000003;
      dword_2540FA7D0 = v5;
      word_2540FA7D4 = 0;
      *(_QWORD *)&xmmword_2540FA7D8 = 0;
      *((_QWORD *)&xmmword_2540FA7D8 + 1) = 0xFFFFFFFFLL;
      qword_2540FA7E8 = (uint64_t)v1;
      unk_2540FA7F0 = 0;
      qword_2540FA7B8 = (uint64_t)&off_24ED26690;
      re::IntrospectionRegistry::add(v6, v7);
      re::getPrettyTypeName((re *)&qword_2540FA7B8, (const re::IntrospectionBase *)&v25);
      if ((BYTE8(v25) & 1) != 0)
        v8 = v26;
      else
        v8 = (char *)&v25 + 9;
      if ((_QWORD)v25 && (BYTE8(v25) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v25 + 40))();
      v23 = *((_OWORD *)v1 + 2);
      v9 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v24);
      if (v9)
      {
        v10 = *v9;
        *((_QWORD *)&v22 + 1) = v10;
      }
      else
      {
        v27 = v23;
        re::TypeBuilder::beginListType((uint64_t)&v25, v24, 1, 0x28uLL, 8uLL, &v27);
        re::TypeBuilder::setConstructor((uint64_t)&v25, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::BlendValueInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v25, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::BlendValueInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v25, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v25, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::BlendValueInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::BlendValueInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v25, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::BlendValueInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v25, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::BlendValueInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::BlendValueInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::BlendValueInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v25, v11);
      }
      xmmword_2540FA7D8 = v22;
      re::StringID::destroyString((re::StringID *)v24);
    }
  }
}

void re::IntrospectionInfo<re::DynamicArray<re::BlendNode>>::get()
{
  unsigned __int8 v0;
  uint64_t *v1;
  unsigned __int8 v2;
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  int v5;
  re::IntrospectionRegistry *v6;
  const re::IntrospectionBase *v7;
  const char *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  re *v13;
  uint64_t *v14;
  const re::IntrospectionBase *v15;
  uint64_t v16;
  uint64_t *v17;
  const re::IntrospectionBase *v18;
  void *v19;
  uint64_t v20;
  uint64_t *v21;
  const re::IntrospectionBase *v22;
  void *v23;
  uint64_t v24;
  uint64_t *v25;
  const re::IntrospectionBase *v26;
  void *v27;
  uint64_t v28;
  __int128 v29;
  __int128 v30;
  uint64_t v31[2];
  __int128 v32;
  const char *v33;
  __int128 v34;

  v0 = atomic_load((unsigned __int8 *)&qword_2540FA6F0);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_2540FA6F0))
  {
    re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&qword_2540FA7F8);
    qword_2540FA7F8 = (uint64_t)&off_24ED26728;
    __cxa_guard_release(&qword_2540FA6F0);
  }
  if ((byte_2540FA673 & 1) == 0)
  {
    v1 = (uint64_t *)qword_2540FA6C8;
    if (qword_2540FA6C8)
      goto LABEL_7;
    v2 = atomic_load((unsigned __int8 *)&qword_2540FA6B8);
    if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_2540FA6B8))
    {
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FA9C0, 0);
      *(_QWORD *)(v12 + 22) = 0;
      qword_2540FA9D0 = 0;
      *(_QWORD *)&xmmword_2540FA9E0 = 0;
      *((_QWORD *)&xmmword_2540FA9E0 + 1) = 0xFFFFFFFFLL;
      qword_2540FA9C0 = (uint64_t)&off_24ED7DAA8;
      qword_2540FA9F0 = (uint64_t)"BlendNode";
      dword_2540FA9F8 = 0;
      xmmword_2540FAA00 = 0u;
      *(_OWORD *)&qword_2540FAA10 = 0u;
      xmmword_2540FAA20 = 0u;
      qword_2540FAA30 = 0;
      __cxa_guard_release(&qword_2540FA6B8);
    }
    qword_2540FA6C8 = (uint64_t)&qword_2540FA9C0;
    *(_QWORD *)&v34 = 0x6BF759A8A3A6;
    *((_QWORD *)&v34 + 1) = "BlendNode";
    re::StringID::destroyString((re::StringID *)&v34);
    xmmword_2540FA9E0 = v32;
    v4 = atomic_load((unsigned __int8 *)&qword_2540FA6C0);
    if ((v4 & 1) == 0)
    {
      v13 = (re *)__cxa_guard_acquire(&qword_2540FA6C0);
      if ((_DWORD)v13)
      {
        v14 = re::introspectionAllocator(v13);
        re::introspect_BlendType((re *)v14, v15);
        v16 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v14 + 32))(v14, 72, 8);
        *(_DWORD *)v16 = 1;
        *(_QWORD *)(v16 + 8) = "blendType";
        *(_QWORD *)(v16 + 16) = &qword_2540FA838;
        *(_QWORD *)(v16 + 24) = 0;
        *(_QWORD *)(v16 + 32) = 1;
        *(_DWORD *)(v16 + 40) = 0;
        *(_QWORD *)(v16 + 48) = 0;
        *(_QWORD *)(v16 + 56) = 0;
        *(_DWORD *)(v16 + 64) = 0;
        qword_2540FA718 = v16;
        v17 = re::introspectionAllocator((re *)v16);
        v19 = re::introspect_uint32_t((re *)1, v18);
        v20 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v17 + 32))(v17, 72, 8);
        *(_DWORD *)v20 = 1;
        *(_QWORD *)(v20 + 8) = "blendNodeParameterIndexStart";
        *(_QWORD *)(v20 + 16) = v19;
        *(_QWORD *)(v20 + 24) = 0;
        *(_QWORD *)(v20 + 32) = 0x400000002;
        *(_DWORD *)(v20 + 40) = 0;
        *(_QWORD *)(v20 + 48) = 0;
        *(_QWORD *)(v20 + 56) = 0;
        *(_DWORD *)(v20 + 64) = 0;
        qword_2540FA720 = v20;
        v21 = re::introspectionAllocator((re *)v20);
        v23 = re::introspect_uint32_t((re *)1, v22);
        v24 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v21 + 32))(v21, 72, 8);
        *(_DWORD *)v24 = 1;
        *(_QWORD *)(v24 + 8) = "blendNodeOptionIndexStart";
        *(_QWORD *)(v24 + 16) = v23;
        *(_QWORD *)(v24 + 24) = 0;
        *(_QWORD *)(v24 + 32) = 0x800000003;
        *(_DWORD *)(v24 + 40) = 0;
        *(_QWORD *)(v24 + 48) = 0;
        *(_QWORD *)(v24 + 56) = 0;
        *(_DWORD *)(v24 + 64) = 0;
        qword_2540FA728 = v24;
        v25 = re::introspectionAllocator((re *)v24);
        v27 = re::introspect_uint32_t((re *)1, v26);
        v28 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v25 + 32))(v25, 72, 8);
        *(_DWORD *)v28 = 1;
        *(_QWORD *)(v28 + 8) = "outputBlendValueIndex";
        *(_QWORD *)(v28 + 16) = v27;
        *(_QWORD *)(v28 + 24) = 0;
        *(_QWORD *)(v28 + 32) = 0xC00000004;
        *(_DWORD *)(v28 + 40) = 0;
        *(_QWORD *)(v28 + 48) = 0;
        *(_QWORD *)(v28 + 56) = 0;
        *(_DWORD *)(v28 + 64) = 0;
        qword_2540FA730 = v28;
        __cxa_guard_release(&qword_2540FA6C0);
      }
    }
    qword_2540FA9D0 = 0x1000000008;
    v1 = &qword_2540FA9C0;
    dword_2540FA9D8 = 4;
    word_2540FA9DC = 1;
    dword_2540FA9F8 = 4;
    *(_QWORD *)&xmmword_2540FAA00 = &qword_2540FA718;
    *((_QWORD *)&xmmword_2540FAA00 + 1) = re::internal::defaultConstruct<re::BlendNode>;
    qword_2540FAA10 = (uint64_t)re::internal::defaultDestruct<re::BlendNode>;
    *(_QWORD *)&xmmword_2540FAA20 = 0;
    qword_2540FAA18 = 0;
    *((_QWORD *)&xmmword_2540FAA20 + 1) = re::internal::defaultConstructV2<re::BlendNode>;
    qword_2540FAA30 = (uint64_t)re::internal::defaultDestructV2<re::BlendNode>;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_2540FA9C0, v3);
    v34 = v32;
    if ((byte_2540FA673 & 1) == 0)
    {
LABEL_7:
      byte_2540FA673 = 1;
      v5 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FA7F8, 0);
      qword_2540FA808 = 0x2800000003;
      dword_2540FA810 = v5;
      word_2540FA814 = 0;
      *(_QWORD *)&xmmword_2540FA818 = 0;
      *((_QWORD *)&xmmword_2540FA818 + 1) = 0xFFFFFFFFLL;
      qword_2540FA828 = (uint64_t)v1;
      unk_2540FA830 = 0;
      qword_2540FA7F8 = (uint64_t)&off_24ED26728;
      re::IntrospectionRegistry::add(v6, v7);
      re::getPrettyTypeName((re *)&qword_2540FA7F8, (const re::IntrospectionBase *)&v32);
      if ((BYTE8(v32) & 1) != 0)
        v8 = v33;
      else
        v8 = (char *)&v32 + 9;
      if ((_QWORD)v32 && (BYTE8(v32) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v32 + 40))();
      v30 = *((_OWORD *)v1 + 2);
      v9 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v31);
      if (v9)
      {
        v10 = *v9;
        *((_QWORD *)&v29 + 1) = v10;
      }
      else
      {
        v34 = v30;
        re::TypeBuilder::beginListType((uint64_t)&v32, v31, 1, 0x28uLL, 8uLL, &v34);
        re::TypeBuilder::setConstructor((uint64_t)&v32, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::BlendNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v32, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::BlendNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v32, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v32, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::BlendNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::BlendNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v32, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::BlendNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v32, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::BlendNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::BlendNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::BlendNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v32, v11);
      }
      xmmword_2540FA818 = v29;
      re::StringID::destroyString((re::StringID *)v31);
    }
  }
}

double re::internal::defaultConstruct<re::BlendTreeDefinition>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double result;

  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_DWORD *)(a3 + 24) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  *(_QWORD *)(a3 + 320) = 0;
  result = 0.0;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_DWORD *)(a3 + 64) = 0;
  *(_OWORD *)(a3 + 72) = 0u;
  *(_OWORD *)(a3 + 88) = 0u;
  *(_DWORD *)(a3 + 104) = 0;
  *(_OWORD *)(a3 + 112) = 0u;
  *(_OWORD *)(a3 + 128) = 0u;
  *(_DWORD *)(a3 + 144) = 0;
  *(_OWORD *)(a3 + 152) = 0u;
  *(_OWORD *)(a3 + 168) = 0u;
  *(_OWORD *)(a3 + 180) = 0u;
  *(_DWORD *)(a3 + 232) = 0;
  *(_OWORD *)(a3 + 216) = 0u;
  *(_OWORD *)(a3 + 200) = 0u;
  *(_DWORD *)(a3 + 272) = 0;
  *(_OWORD *)(a3 + 240) = 0u;
  *(_OWORD *)(a3 + 256) = 0u;
  *(_OWORD *)(a3 + 280) = 0u;
  *(_OWORD *)(a3 + 296) = 0u;
  *(_DWORD *)(a3 + 312) = 0;
  return result;
}

void re::internal::defaultDestruct<re::BlendTreeDefinition>(int a1, int a2, re::BlendTreeDefinition *this)
{
  re::BlendTreeDefinition::~BlendTreeDefinition(this);
}

double re::internal::defaultConstructV2<re::BlendTreeDefinition>(uint64_t a1)
{
  double result;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 320) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_DWORD *)(a1 + 64) = 0;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_DWORD *)(a1 + 104) = 0;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_DWORD *)(a1 + 144) = 0;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 180) = 0u;
  *(_DWORD *)(a1 + 232) = 0;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_DWORD *)(a1 + 272) = 0;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 280) = 0u;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_DWORD *)(a1 + 312) = 0;
  return result;
}

uint64_t re::introspect_BlendTreeDefinition(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"BlendTreeDefinition", (uint64_t (*)(re::internal *))re::allocInfo_BlendTreeDefinition, (re::IntrospectionBase *(*)(void))re::initInfo_BlendTreeDefinition, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::BlendTreeDefinition>, this);
}

void re::TypeBuilderHelper::registerDynamicArray<unsigned int>(re::TypeRegistry *a1@<X0>, uint64_t *a2@<X1>, __int128 *a3@<X2>, re::TypeRegistry **a4@<X8>)
{
  _anonymous_namespace_ *v8;
  re::TypeRegistry *v9;
  uint64_t v10;
  __int128 v11;
  _BYTE v12[488];

  v8 = (_anonymous_namespace_ *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a1 + 200, a2);
  if (a1 && v8)
  {
    v9 = *(re::TypeRegistry **)v8;
    *a4 = a1;
    a4[1] = v9;
  }
  else
  {
    v11 = *a3;
    re::TypeBuilder::beginListType((uint64_t)v12, a2, 1, 0x28uLL, 8uLL, &v11);
    re::TypeBuilder::setConstructor((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<unsigned int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
    re::TypeBuilder::setDestructor((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<unsigned int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
    re::TypeBuilder::setListUsesContiguousStorage((uint64_t)v12, 1);
    re::TypeBuilder::setListAccessors((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<unsigned int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<unsigned int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
    re::TypeBuilder::setListIndexer((uint64_t)v12, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<unsigned int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
    re::TypeBuilder::setListIterator((uint64_t)v12, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<unsigned int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<unsigned int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<unsigned int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
    re::TypeBuilder::commitTo((re::TypeBuilder *)v12, a1, a4);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v12, v10);
  }
}

_QWORD *re::IntrospectionDynamicArray<unsigned int>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<unsigned int>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x2276933B8);
}

void re::IntrospectionDynamicArray<unsigned int>::construct(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<unsigned int>::destroy(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = *(_QWORD *)a2;
  if (*(_QWORD *)a2)
  {
    if (*(_QWORD *)(a2 + 32))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a2 + 32) = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_QWORD *)a2 = 0;
    ++*(_DWORD *)(a2 + 24);
  }
  return result;
}

_QWORD *re::IntrospectionDynamicArray<unsigned int>::init(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  _QWORD *result;

  if (*a2)
  {
    if (a2[4])
      (*(void (**)(_QWORD))(*(_QWORD *)*a2 + 40))(*a2);
    a2[4] = 0;
    a2[1] = 0;
    a2[2] = 0;
    ++*((_DWORD *)a2 + 6);
  }
  *a2 = a3;
  result = re::DynamicArray<int>::setCapacity(a2, 0);
  ++*((_DWORD *)a2 + 6);
  return result;
}

void re::IntrospectionDynamicArray<unsigned int>::resize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  unint64_t v10;
  unint64_t i;

  if (!*(_QWORD *)a4)
  {
    *(_QWORD *)a4 = a2;
    re::DynamicArray<int>::setCapacity((_QWORD *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  v10 = *(_QWORD *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
      re::DynamicArray<float>::resize(a4, a5);
  }
  else
  {
    re::DynamicArray<int>::setCapacity((_QWORD *)a4, a5);
    for (i = a5 - *(_QWORD *)(a4 + 16); i; --i)
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, a3, a4);
  }
}

re::IntrospectionBase *re::IntrospectionDynamicArray<unsigned int>::addElement(uint64_t a1, re *a2, int a3, _anonymous_namespace_ *this)
{
  re::IntrospectionBase *v8;
  int v10;

  v10 = 0;
  re::DynamicArray<int>::add(this, &v10);
  v8 = (re::IntrospectionBase *)(*((_QWORD *)this + 4) + 4 * *((_QWORD *)this + 2) - 4);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v8);
  return v8;
}

uint64_t re::IntrospectionDynamicArray<unsigned int>::size(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<unsigned int>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 4 * a3;
}

{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 4 * a3;
}

_QWORD *re::TypeBuilderHelper::registerDynamicArray<unsigned int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)a1 = a3;
  result = re::DynamicArray<int>::setCapacity((_QWORD *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<unsigned int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)a1;
  if (result)
  {
    if (*(_QWORD *)(a1 + 32))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<unsigned int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<unsigned int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  char v4;

  re::TypeBuilderHelper::registerDynamicArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::operator()((uint64_t)&v4, a1, a2, a3, a4);
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<unsigned int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(_QWORD *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a1 + 32) + 4 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<unsigned int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 16, 8);
  *(_QWORD *)result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<unsigned int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unint64_t v4;
  uint64_t result;

  v2 = *(_QWORD *)a1;
  if (a1[2] == *(_DWORD *)(*(_QWORD *)a1 + 24))
  {
    v3 = a1[3];
    v4 = *(_QWORD *)(v2 + 16);
    if (v3 < (int)v4)
      a1[3] = ++v3;
    if (v4 <= v3)
      return 0;
    else
      return *(_QWORD *)(v2 + 32) + 4 * v3;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<unsigned int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 40))(a2, result);
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::BlendParameterInputNode>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::BlendParameterInputNode>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x2276933B8);
}

void re::IntrospectionDynamicArray<re::BlendParameterInputNode>::construct(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::BlendParameterInputNode>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit(a2);
}

_QWORD *re::IntrospectionDynamicArray<re::BlendParameterInputNode>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit(a2);
  *(_QWORD *)a2 = a3;
  result = re::DynamicArray<re::BlendParameterInputNode>::setCapacity((_QWORD *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

void re::IntrospectionDynamicArray<re::BlendParameterInputNode>::resize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  unint64_t v10;
  unint64_t i;

  if (!*(_QWORD *)a4)
  {
    *(_QWORD *)a4 = a2;
    re::DynamicArray<re::BlendParameterInputNode>::setCapacity((_QWORD *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  v10 = *(_QWORD *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
      re::DynamicArray<re::BlendParameterInputNode>::resize(a4, a5);
  }
  else
  {
    re::DynamicArray<re::BlendParameterInputNode>::setCapacity((_QWORD *)a4, a5);
    for (i = a5 - *(_QWORD *)(a4 + 16); i; --i)
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, a3, a4);
  }
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::BlendParameterInputNode>::addElement(uint64_t a1, re *a2, int a3, uint64_t a4)
{
  _anonymous_namespace_ *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  BOOL v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  char v17;
  re::IntrospectionBase *v18;
  uint64_t v20;
  void *v21;
  uint64_t v22;

  v20 = 0;
  v21 = 0;
  v22 = 0;
  v8 = re::StringID::invalid((re::StringID *)&v20);
  LODWORD(v22) = -1;
  v9 = *(_QWORD *)(a4 + 8);
  v10 = *(_QWORD *)(a4 + 16);
  if (v10 >= v9)
  {
    v11 = v10 + 1;
    if (v9 < v10 + 1)
    {
      if (*(_QWORD *)a4)
      {
        v12 = 2 * v9;
        v13 = v9 == 0;
        v14 = 8;
        if (!v13)
          v14 = v12;
        if (v14 <= v11)
          v15 = v11;
        else
          v15 = v14;
        re::DynamicArray<re::BlendParameterInputNode>::setCapacity((_QWORD *)a4, v15);
      }
      else
      {
        re::DynamicArray<re::BlendParameterInputNode>::setCapacity((_QWORD *)a4, v11);
        ++*(_DWORD *)(a4 + 24);
      }
    }
    v10 = *(_QWORD *)(a4 + 16);
  }
  v16 = *(_QWORD *)(a4 + 32) + 24 * v10;
  v17 = v20;
  *(_QWORD *)v16 = *(_QWORD *)v16 & 0xFFFFFFFFFFFFFFFELL | v20 & 1;
  *(_QWORD *)v16 = v20 & 0xFFFFFFFFFFFFFFFELL | v17 & 1;
  *(_QWORD *)(v16 + 8) = v21;
  v20 = 0;
  v21 = &str_110;
  *(_DWORD *)(v16 + 16) = v22;
  ++*(_QWORD *)(a4 + 16);
  ++*(_DWORD *)(a4 + 24);
  re::StringID::destroyString((re::StringID *)&v20);
  v18 = (re::IntrospectionBase *)(*(_QWORD *)(a4 + 32) + 24 * *(_QWORD *)(a4 + 16) - 24);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v18);
  return v18;
}

uint64_t re::IntrospectionDynamicArray<re::BlendParameterInputNode>::size(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::BlendParameterInputNode>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 24 * a3;
}

{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 24 * a3;
}

_QWORD *re::DynamicArray<re::BlendParameterInputNode>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  unint64_t *v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t *v10;
  unint64_t *v11;
  uint64_t v12;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::BlendParameterInputNode>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x18uLL))
        {
          v2 = 24 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 24 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_16;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 24, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = (uint64_t *)v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = &v8[3 * v9];
        v11 = v7;
        do
        {
          v12 = *v8;
          *v11 = *v11 & 0xFFFFFFFFFFFFFFFELL | *v8 & 1;
          *v11 = *v8 & 0xFFFFFFFFFFFFFFFELL | v12 & 1;
          v11[1] = v8[1];
          *v8 = 0;
          v8[1] = (uint64_t)&str_110;
          *((_DWORD *)v11 + 4) = *((_DWORD *)v8 + 4);
          re::StringID::destroyString((re::StringID *)v8);
          v8 += 3;
          v11 += 3;
        }
        while (v8 != v10);
        v8 = (uint64_t *)v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t *))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

void re::DynamicArray<re::BlendParameterInputNode>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  re::StringID *v7;
  uint64_t v8;
  unint64_t v9;

  v4 = *(_QWORD *)(a1 + 16);
  if (v4 >= a2)
  {
    if (v4 <= a2)
      return;
    v8 = 24 * a2;
    v9 = a2;
    do
    {
      re::StringID::destroyString((re::StringID *)(*(_QWORD *)(a1 + 32) + v8));
      ++v9;
      v8 += 24;
    }
    while (v9 < *(_QWORD *)(a1 + 16));
  }
  else
  {
    if (*(_QWORD *)(a1 + 8) < a2)
    {
      re::DynamicArray<re::BlendParameterInputNode>::setCapacity((_QWORD *)a1, a2);
      v4 = *(_QWORD *)(a1 + 16);
    }
    v5 = a2 - v4;
    if (a2 > v4)
    {
      v6 = 24 * v4;
      do
      {
        v7 = (re::StringID *)(*(_QWORD *)(a1 + 32) + v6);
        re::StringID::invalid(v7);
        *((_DWORD *)v7 + 4) = -1;
        v6 += 24;
        --v5;
      }
      while (v5);
    }
  }
  *(_QWORD *)(a1 + 16) = a2;
  ++*(_DWORD *)(a1 + 24);
}

_QWORD *re::TypeBuilderHelper::registerDynamicArray<re::BlendParameterInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)a1 = a3;
  result = re::DynamicArray<re::BlendParameterInputNode>::setCapacity((_QWORD *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BlendParameterInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::BlendParameterInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  uint64_t v8;
  re::StringID *v9;
  uint64_t v10;
  _anonymous_namespace_ *v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  _BYTE v15[32];
  _BYTE v16[8];
  uint64_t v17;

  if (*(re::Allocator **)a1 == a3)
  {
    v8 = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = 0;
    if (v8)
    {
      v9 = *(re::StringID **)(a1 + 32);
      v10 = 24 * v8;
      do
      {
        re::StringID::destroyString(v9);
        v9 = (re::StringID *)((char *)v9 + 24);
        v10 -= 24;
      }
      while (v10);
    }
  }
  else
  {
    re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit(a1);
    *(_QWORD *)a1 = a3;
    re::DynamicArray<re::BlendParameterInputNode>::setCapacity((_QWORD *)a1, a4);
  }
  ++*(_DWORD *)(a1 + 24);
  re::DynamicArray<re::BlendParameterInputNode>::resize(a1, a4);
  {
    re::TypeRegistry::typeInfo(*(_QWORD **)a2, *(_QWORD *)(*(_QWORD *)(a2 + 16) + 72), v16);
    re::TypeInfo::TypeInfo((uint64_t)v15, (uint64_t)&v17);
    v12 = *(_QWORD *)(a1 + 16);
    if (v12)
    {
      v13 = *(char **)(a1 + 32);
      v14 = 24 * v12;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v15, v13, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v15, (void **)v13, a3, 0);
        v13 += 24;
        v14 -= 24;
      }
      while (v14);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BlendParameterInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(_QWORD *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a1 + 32) + 24 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BlendParameterInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 16, 8);
  *(_QWORD *)result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BlendParameterInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unint64_t v4;
  uint64_t result;

  v2 = *(_QWORD *)a1;
  if (a1[2] == *(_DWORD *)(*(_QWORD *)a1 + 24))
  {
    v3 = a1[3];
    v4 = *(_QWORD *)(v2 + 16);
    if (v3 < (int)v4)
      a1[3] = ++v3;
    if (v4 <= v3)
      return 0;
    else
      return *(_QWORD *)(v2 + 32) + 24 * v3;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BlendParameterInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 40))(a2, result);
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::BlendValueInputNode>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::BlendValueInputNode>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x2276933B8);
}

void re::IntrospectionDynamicArray<re::BlendValueInputNode>::construct(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::BlendValueInputNode>::destroy(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit(a2);
}

_QWORD *re::IntrospectionDynamicArray<re::BlendValueInputNode>::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit(a2);
  *(_QWORD *)a2 = a3;
  result = re::DynamicArray<re::BlendParameterInputNode>::setCapacity((_QWORD *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

void re::IntrospectionDynamicArray<re::BlendValueInputNode>::resize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  unint64_t v10;
  unint64_t i;

  if (!*(_QWORD *)a4)
  {
    *(_QWORD *)a4 = a2;
    re::DynamicArray<re::BlendParameterInputNode>::setCapacity((_QWORD *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  v10 = *(_QWORD *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
      re::DynamicArray<re::BlendValueInputNode>::resize(a4, a5);
  }
  else
  {
    re::DynamicArray<re::BlendParameterInputNode>::setCapacity((_QWORD *)a4, a5);
    for (i = a5 - *(_QWORD *)(a4 + 16); i; --i)
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, a3, a4);
  }
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::BlendValueInputNode>::addElement(uint64_t a1, re *a2, int a3, uint64_t a4)
{
  _anonymous_namespace_ *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  BOOL v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  char v17;
  re::IntrospectionBase *v18;
  uint64_t v20;
  void *v21;
  uint64_t v22;

  v20 = 0;
  v21 = 0;
  v22 = 0;
  v8 = re::StringID::invalid((re::StringID *)&v20);
  LODWORD(v22) = 0;
  v9 = *(_QWORD *)(a4 + 8);
  v10 = *(_QWORD *)(a4 + 16);
  if (v10 >= v9)
  {
    v11 = v10 + 1;
    if (v9 < v10 + 1)
    {
      if (*(_QWORD *)a4)
      {
        v12 = 2 * v9;
        v13 = v9 == 0;
        v14 = 8;
        if (!v13)
          v14 = v12;
        if (v14 <= v11)
          v15 = v11;
        else
          v15 = v14;
        re::DynamicArray<re::BlendParameterInputNode>::setCapacity((_QWORD *)a4, v15);
      }
      else
      {
        re::DynamicArray<re::BlendParameterInputNode>::setCapacity((_QWORD *)a4, v11);
        ++*(_DWORD *)(a4 + 24);
      }
    }
    v10 = *(_QWORD *)(a4 + 16);
  }
  v16 = *(_QWORD *)(a4 + 32) + 24 * v10;
  v17 = v20;
  *(_QWORD *)v16 = *(_QWORD *)v16 & 0xFFFFFFFFFFFFFFFELL | v20 & 1;
  *(_QWORD *)v16 = v20 & 0xFFFFFFFFFFFFFFFELL | v17 & 1;
  *(_QWORD *)(v16 + 8) = v21;
  v20 = 0;
  v21 = &str_110;
  *(_DWORD *)(v16 + 16) = v22;
  ++*(_QWORD *)(a4 + 16);
  ++*(_DWORD *)(a4 + 24);
  re::StringID::destroyString((re::StringID *)&v20);
  v18 = (re::IntrospectionBase *)(*(_QWORD *)(a4 + 32) + 24 * *(_QWORD *)(a4 + 16) - 24);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v18);
  return v18;
}

uint64_t re::IntrospectionDynamicArray<re::BlendValueInputNode>::size(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::BlendValueInputNode>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 24 * a3;
}

{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 24 * a3;
}

void re::DynamicArray<re::BlendValueInputNode>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  re::StringID *v7;
  uint64_t v8;
  unint64_t v9;

  v4 = *(_QWORD *)(a1 + 16);
  if (v4 >= a2)
  {
    if (v4 <= a2)
      return;
    v8 = 24 * a2;
    v9 = a2;
    do
    {
      re::StringID::destroyString((re::StringID *)(*(_QWORD *)(a1 + 32) + v8));
      ++v9;
      v8 += 24;
    }
    while (v9 < *(_QWORD *)(a1 + 16));
  }
  else
  {
    if (*(_QWORD *)(a1 + 8) < a2)
    {
      re::DynamicArray<re::BlendParameterInputNode>::setCapacity((_QWORD *)a1, a2);
      v4 = *(_QWORD *)(a1 + 16);
    }
    v5 = a2 - v4;
    if (a2 > v4)
    {
      v6 = 24 * v4;
      do
      {
        v7 = (re::StringID *)(*(_QWORD *)(a1 + 32) + v6);
        re::StringID::invalid(v7);
        *((_DWORD *)v7 + 4) = 0;
        v6 += 24;
        --v5;
      }
      while (v5);
    }
  }
  *(_QWORD *)(a1 + 16) = a2;
  ++*(_DWORD *)(a1 + 24);
}

_QWORD *re::TypeBuilderHelper::registerDynamicArray<re::BlendValueInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)a1 = a3;
  result = re::DynamicArray<re::BlendParameterInputNode>::setCapacity((_QWORD *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BlendValueInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::BlendValueInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  uint64_t v8;
  re::StringID *v9;
  uint64_t v10;
  _anonymous_namespace_ *v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  _BYTE v15[32];
  _BYTE v16[8];
  uint64_t v17;

  if (*(re::Allocator **)a1 == a3)
  {
    v8 = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = 0;
    if (v8)
    {
      v9 = *(re::StringID **)(a1 + 32);
      v10 = 24 * v8;
      do
      {
        re::StringID::destroyString(v9);
        v9 = (re::StringID *)((char *)v9 + 24);
        v10 -= 24;
      }
      while (v10);
    }
  }
  else
  {
    re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit(a1);
    *(_QWORD *)a1 = a3;
    re::DynamicArray<re::BlendParameterInputNode>::setCapacity((_QWORD *)a1, a4);
  }
  ++*(_DWORD *)(a1 + 24);
  re::DynamicArray<re::BlendValueInputNode>::resize(a1, a4);
  {
    re::TypeRegistry::typeInfo(*(_QWORD **)a2, *(_QWORD *)(*(_QWORD *)(a2 + 16) + 72), v16);
    re::TypeInfo::TypeInfo((uint64_t)v15, (uint64_t)&v17);
    v12 = *(_QWORD *)(a1 + 16);
    if (v12)
    {
      v13 = *(char **)(a1 + 32);
      v14 = 24 * v12;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v15, v13, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v15, (void **)v13, a3, 0);
        v13 += 24;
        v14 -= 24;
      }
      while (v14);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BlendValueInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(_QWORD *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a1 + 32) + 24 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BlendValueInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 16, 8);
  *(_QWORD *)result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BlendValueInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unint64_t v4;
  uint64_t result;

  v2 = *(_QWORD *)a1;
  if (a1[2] == *(_DWORD *)(*(_QWORD *)a1 + 24))
  {
    v3 = a1[3];
    v4 = *(_QWORD *)(v2 + 16);
    if (v3 < (int)v4)
      a1[3] = ++v3;
    if (v4 <= v3)
      return 0;
    else
      return *(_QWORD *)(v2 + 32) + 24 * v3;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BlendValueInputNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 40))(a2, result);
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::BlendNode>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::BlendNode>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x2276933B8);
}

void re::IntrospectionDynamicArray<re::BlendNode>::construct(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::BlendNode>::destroy(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = *(_QWORD *)a2;
  if (*(_QWORD *)a2)
  {
    if (*(_QWORD *)(a2 + 32))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a2 + 32) = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_QWORD *)a2 = 0;
    ++*(_DWORD *)(a2 + 24);
  }
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::BlendNode>::init(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  _QWORD *result;

  if (*a2)
  {
    if (a2[4])
      (*(void (**)(_QWORD))(*(_QWORD *)*a2 + 40))(*a2);
    a2[4] = 0;
    a2[1] = 0;
    a2[2] = 0;
    ++*((_DWORD *)a2 + 6);
  }
  *a2 = a3;
  result = re::DynamicArray<re::BlendNode>::setCapacity(a2, 0);
  ++*((_DWORD *)a2 + 6);
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::BlendNode>::resize(_QWORD *result, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  _QWORD *v9;
  unint64_t v10;
  unint64_t i;

  v9 = result;
  if (!*(_QWORD *)a4)
  {
    *(_QWORD *)a4 = a2;
    result = re::DynamicArray<re::BlendNode>::setCapacity((_QWORD *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  v10 = *(_QWORD *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
      return re::DynamicArray<re::BlendNode>::resize((_QWORD *)a4, a5);
  }
  else
  {
    result = re::DynamicArray<re::BlendNode>::setCapacity((_QWORD *)a4, a5);
    for (i = a5 - *(_QWORD *)(a4 + 16); i; --i)
      result = (_QWORD *)(*(uint64_t (**)(_QWORD *, uint64_t, uint64_t, uint64_t))(*v9 + 80))(v9, a2, a3, a4);
  }
  return result;
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::BlendNode>::addElement(re::Allocator **a1, re *a2, int a3, uint64_t a4)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  BOOL v12;
  unint64_t v13;
  unint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  re::IntrospectionBase *v17;

  v8 = *(_QWORD *)(a4 + 8);
  v9 = *(_QWORD *)(a4 + 16);
  if (v9 >= v8)
  {
    v10 = v9 + 1;
    if (v8 < v9 + 1)
    {
      if (*(_QWORD *)a4)
      {
        v11 = 2 * v8;
        v12 = v8 == 0;
        v13 = 8;
        if (!v12)
          v13 = v11;
        if (v13 <= v10)
          v14 = v10;
        else
          v14 = v13;
        re::DynamicArray<re::BlendNode>::setCapacity((_QWORD *)a4, v14);
      }
      else
      {
        re::DynamicArray<re::BlendNode>::setCapacity((_QWORD *)a4, v10);
        ++*(_DWORD *)(a4 + 24);
      }
    }
    v9 = *(_QWORD *)(a4 + 16);
  }
  v15 = (_QWORD *)(*(_QWORD *)(a4 + 32) + 16 * v9);
  *v15 = 0;
  v15[1] = 0;
  v16 = *(_QWORD *)(a4 + 16);
  *(_QWORD *)(a4 + 16) = v16 + 1;
  ++*(_DWORD *)(a4 + 24);
  v17 = (re::IntrospectionBase *)(*(_QWORD *)(a4 + 32) + 16 * v16);
  re::introspectionInitElement(a2, a3, a1[6], v17);
  return v17;
}

uint64_t re::IntrospectionDynamicArray<re::BlendNode>::size(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::BlendNode>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 16 * a3;
}

{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 16 * a3;
}

_QWORD *re::DynamicArray<re::BlendNode>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  void *v7;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (*v5)
      {
        if (!a2)
        {
          v7 = 0;
          if (!v3)
            goto LABEL_9;
          goto LABEL_8;
        }
        if (a2 >> 60)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 16, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          v2 = 16 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 16 * a2, 4);
          if (result)
          {
            v7 = result;
            if (!v5[1])
            {
LABEL_9:
              v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            memcpy(v7, (const void *)v5[4], 16 * v5[2]);
            result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
      }
      else
      {
        result = (_QWORD *)re::DynamicArray<re::BlendNode>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

_QWORD *re::DynamicArray<re::BlendNode>::resize(_QWORD *result, unint64_t a2)
{
  _QWORD *v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;

  v3 = result;
  v4 = result[2];
  if (v4 >= a2)
  {
    if (v4 <= a2)
      return result;
  }
  else
  {
    if (result[1] < a2)
    {
      result = re::DynamicArray<re::BlendNode>::setCapacity(result, a2);
      v4 = v3[2];
    }
    if (v4 < a2)
    {
      v5 = v3[4];
      v6 = v5 + 16 * v4;
      v7 = v5 + 16 * a2 - v6;
      if (v7 >= 1)
      {
        v8 = ((unint64_t)v7 >> 4) + 1;
        do
        {
          *(_BYTE *)v6 = 0;
          *(_QWORD *)(v6 + 8) = 0;
          *(_DWORD *)(v6 + 4) = 0;
          --v8;
          v6 += 16;
        }
        while (v8 > 1);
      }
    }
  }
  v3[2] = a2;
  ++*((_DWORD *)v3 + 6);
  return result;
}

_QWORD *re::TypeBuilderHelper::registerDynamicArray<re::BlendNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)a1 = a3;
  result = re::DynamicArray<re::BlendNode>::setCapacity((_QWORD *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BlendNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)a1;
  if (result)
  {
    if (*(_QWORD *)(a1 + 32))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BlendNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::BlendNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  re::Allocator *v8;
  _anonymous_namespace_ *v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  _BYTE v13[32];
  _BYTE v14[8];
  uint64_t v15;

  v8 = *(re::Allocator **)a1;
  if (v8 == a3)
  {
    *(_QWORD *)(a1 + 16) = 0;
  }
  else
  {
    if (v8)
    {
      if (*(_QWORD *)(a1 + 32))
        (*(void (**)(re::Allocator *))(*(_QWORD *)v8 + 40))(v8);
      *(_QWORD *)(a1 + 32) = 0;
      *(_QWORD *)(a1 + 8) = 0;
      *(_QWORD *)(a1 + 16) = 0;
      ++*(_DWORD *)(a1 + 24);
    }
    *(_QWORD *)a1 = a3;
    re::DynamicArray<re::BlendNode>::setCapacity((_QWORD *)a1, a4);
  }
  ++*(_DWORD *)(a1 + 24);
  v9 = (_anonymous_namespace_ *)re::DynamicArray<re::BlendNode>::resize((_QWORD *)a1, a4);
  {
    re::TypeRegistry::typeInfo(*(_QWORD **)a2, *(_QWORD *)(*(_QWORD *)(a2 + 16) + 72), v14);
    re::TypeInfo::TypeInfo((uint64_t)v13, (uint64_t)&v15);
    v10 = *(_QWORD *)(a1 + 16);
    if (v10)
    {
      v11 = *(char **)(a1 + 32);
      v12 = 16 * v10;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v13, v11, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v13, (void **)v11, a3, 0);
        v11 += 16;
        v12 -= 16;
      }
      while (v12);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BlendNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(_QWORD *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a1 + 32) + 16 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BlendNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 16, 8);
  *(_QWORD *)result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BlendNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unint64_t v4;
  uint64_t result;

  v2 = *(_QWORD *)a1;
  if (a1[2] == *(_DWORD *)(*(_QWORD *)a1 + 24))
  {
    v3 = a1[3];
    v4 = *(_QWORD *)(v2 + 16);
    if (v3 < (int)v4)
      a1[3] = ++v3;
    if (v4 <= v3)
      return 0;
    else
      return *(_QWORD *)(v2 + 32) + 16 * v3;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::BlendNode>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 40))(a2, result);
  return result;
}

void re::BlendTreeDefinition::~BlendTreeDefinition(re::BlendTreeDefinition *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = *((_QWORD *)this + 36);
  if (v2)
  {
    if (*((_QWORD *)this + 40))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *((_QWORD *)this + 40) = 0;
    *((_QWORD *)this + 37) = 0;
    *((_QWORD *)this + 38) = 0;
    *((_QWORD *)this + 36) = 0;
    ++*((_DWORD *)this + 78);
  }
  v3 = *((_QWORD *)this + 31);
  if (v3)
  {
    if (*((_QWORD *)this + 35))
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
    *((_QWORD *)this + 35) = 0;
    *((_QWORD *)this + 32) = 0;
    *((_QWORD *)this + 33) = 0;
    *((_QWORD *)this + 31) = 0;
    ++*((_DWORD *)this + 68);
  }
  v4 = *((_QWORD *)this + 26);
  if (v4)
  {
    if (*((_QWORD *)this + 30))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *((_QWORD *)this + 30) = 0;
    *((_QWORD *)this + 27) = 0;
    *((_QWORD *)this + 28) = 0;
    *((_QWORD *)this + 26) = 0;
    ++*((_DWORD *)this + 58);
  }
  re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)this + 168);
  re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)this + 120);
  v5 = *((_QWORD *)this + 10);
  if (v5)
  {
    if (*((_QWORD *)this + 14))
      (*(void (**)(uint64_t))(*(_QWORD *)v5 + 40))(v5);
    *((_QWORD *)this + 14) = 0;
    *((_QWORD *)this + 11) = 0;
    *((_QWORD *)this + 12) = 0;
    *((_QWORD *)this + 10) = 0;
    ++*((_DWORD *)this + 26);
  }
  re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)this + 40);
  if (*(_QWORD *)this)
  {
    if (*((_QWORD *)this + 4))
      (*(void (**)(_QWORD))(**(_QWORD **)this + 40))(*(_QWORD *)this);
    *((_QWORD *)this + 4) = 0;
    *((_QWORD *)this + 1) = 0;
    *((_QWORD *)this + 2) = 0;
    *(_QWORD *)this = 0;
    ++*((_DWORD *)this + 6);
  }
}

uint64_t *re::IntrospectionInfo<re::FixedArray<int>>::get(int a1, const re::IntrospectionBase *a2)
{
  unsigned __int8 v3;
  int v4;
  re *v5;
  std::__shared_mutex_base *v6;
  re *v7;
  std::__shared_mutex_base *v8;
  uint64_t v10;
  int v11;
  re::IntrospectionRegistry *v12;
  const re::IntrospectionBase *v13;
  const char *v14;
  __int128 v15;
  __int128 v16;
  const char *v17;
  uint64_t v18[2];

  if ((v3 & 1) == 0
  {
    re::IntrospectionFixedArrayBase::IntrospectionFixedArrayBase((re::IntrospectionFixedArrayBase *)&re::IntrospectionInfo<re::FixedArray<int>>::get(BOOL)::info);
    re::IntrospectionInfo<re::FixedArray<int>>::get(BOOL)::info = (uint64_t)&off_24ED267C0;
  }
  if (a1)
  {
    if (re::IntrospectionInfo<re::FixedArray<int>>::get(BOOL)::isInitialized)
      return &re::IntrospectionInfo<re::FixedArray<int>>::get(BOOL)::info;
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v16);
    v4 = re::IntrospectionInfo<re::FixedArray<int>>::get(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v16);
    if (v4)
      return &re::IntrospectionInfo<re::FixedArray<int>>::get(BOOL)::info;
    v6 = re::introspectionSharedMutex(v5);
    std::__shared_mutex_base::lock(v6);
  }
  v7 = (re *)re::introspect_int((re *)1, a2);
  if (re::IntrospectionInfo<re::FixedArray<int>>::get(BOOL)::isInitialized)
  {
    if ((a1 & 1) == 0)
    {
LABEL_9:
      v8 = re::introspectionSharedMutex(v7);
      std::__shared_mutex_base::unlock(v8);
    }
  }
  else
  {
    v10 = (uint64_t)v7;
    re::IntrospectionInfo<re::FixedArray<int>>::get(BOOL)::isInitialized = 1;
    v11 = *((_DWORD *)v7 + 6);
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&re::IntrospectionInfo<re::FixedArray<int>>::get(BOOL)::info, 0);
    qword_2557FF6F0 = 0x1800000004;
    dword_2557FF6F8 = v11;
    word_2557FF6FC = 0;
    *(_QWORD *)&xmmword_2557FF700 = 0;
    *((_QWORD *)&xmmword_2557FF700 + 1) = 0xFFFFFFFFLL;
    qword_2557FF710 = v10;
    unk_2557FF718 = 0;
    re::IntrospectionInfo<re::FixedArray<int>>::get(BOOL)::info = (uint64_t)&off_24ED267C0;
    re::IntrospectionRegistry::add(v12, v13);
    re::getPrettyTypeName((re *)&re::IntrospectionInfo<re::FixedArray<int>>::get(BOOL)::info, (const re::IntrospectionBase *)&v16);
    if ((BYTE8(v16) & 1) != 0)
      v14 = v17;
    else
      v14 = (char *)&v16 + 9;
    if ((_QWORD)v16 && (BYTE8(v16) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v16 + 40))();
    v16 = *(_OWORD *)(v10 + 32);
    xmmword_2557FF700 = v15;
    re::StringID::destroyString((re::StringID *)v18);
    if ((a1 & 1) == 0)
      goto LABEL_9;
  }
  return &re::IntrospectionInfo<re::FixedArray<int>>::get(BOOL)::info;
}

uint64_t *re::IntrospectionInfo<re::FixedArray<re::Vector3<float>>>::get(int a1)
{
  unsigned __int8 v2;
  int v3;
  re *v4;
  std::__shared_mutex_base *v5;
  re *v6;
  std::__shared_mutex_base *v7;
  uint64_t v9;
  int v10;
  re::IntrospectionRegistry *v11;
  const re::IntrospectionBase *v12;
  const char *v13;
  __int128 v14;
  __int128 v15;
  const char *v16;
  uint64_t v17[2];

  if ((v2 & 1) == 0
  {
    re::IntrospectionFixedArrayBase::IntrospectionFixedArrayBase((re::IntrospectionFixedArrayBase *)&re::IntrospectionInfo<re::FixedArray<re::Vector3<float>>>::get(BOOL)::info);
    re::IntrospectionInfo<re::FixedArray<re::Vector3<float>>>::get(BOOL)::info = (uint64_t)&off_24ED26858;
  }
  if (a1)
  {
    if (re::IntrospectionInfo<re::FixedArray<re::Vector3<float>>>::get(BOOL)::isInitialized)
      return &re::IntrospectionInfo<re::FixedArray<re::Vector3<float>>>::get(BOOL)::info;
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v15);
    v3 = re::IntrospectionInfo<re::FixedArray<re::Vector3<float>>>::get(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v15);
    if (v3)
      return &re::IntrospectionInfo<re::FixedArray<re::Vector3<float>>>::get(BOOL)::info;
    v5 = re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(v5);
  }
  v6 = (re *)re::introspect_Vector3F((re::IntrospectionBase **)1);
  if (re::IntrospectionInfo<re::FixedArray<re::Vector3<float>>>::get(BOOL)::isInitialized)
  {
    if ((a1 & 1) == 0)
    {
LABEL_9:
      v7 = re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(v7);
    }
  }
  else
  {
    v9 = (uint64_t)v6;
    re::IntrospectionInfo<re::FixedArray<re::Vector3<float>>>::get(BOOL)::isInitialized = 1;
    v10 = *((_DWORD *)v6 + 6);
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&re::IntrospectionInfo<re::FixedArray<re::Vector3<float>>>::get(BOOL)::info, 0);
    qword_2557FF740 = 0x1800000004;
    dword_2557FF748 = v10;
    word_2557FF74C = 0;
    *(_QWORD *)&xmmword_2557FF750 = 0;
    *((_QWORD *)&xmmword_2557FF750 + 1) = 0xFFFFFFFFLL;
    qword_2557FF760 = v9;
    unk_2557FF768 = 0;
    re::IntrospectionInfo<re::FixedArray<re::Vector3<float>>>::get(BOOL)::info = (uint64_t)&off_24ED26858;
    re::IntrospectionRegistry::add(v11, v12);
    re::getPrettyTypeName((re *)&re::IntrospectionInfo<re::FixedArray<re::Vector3<float>>>::get(BOOL)::info, (const re::IntrospectionBase *)&v15);
    if ((BYTE8(v15) & 1) != 0)
      v13 = v16;
    else
      v13 = (char *)&v15 + 9;
    if ((_QWORD)v15 && (BYTE8(v15) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v15 + 40))();
    v15 = *(_OWORD *)(v9 + 32);
    xmmword_2557FF750 = v14;
    re::StringID::destroyString((re::StringID *)v17);
    if ((a1 & 1) == 0)
      goto LABEL_9;
  }
  return &re::IntrospectionInfo<re::FixedArray<re::Vector3<float>>>::get(BOOL)::info;
}

uint64_t *re::allocInfo_DynamicRegisterTable(re *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  v1 = atomic_load((unsigned __int8 *)&qword_2540FAAB8);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_2540FAAB8))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FAC58, 0);
    *(_QWORD *)(v3 + 22) = 0;
    qword_2540FAC68 = 0;
    qword_2540FAC78 = 0;
    qword_2540FAC80 = 0xFFFFFFFFLL;
    qword_2540FAC58 = (uint64_t)&off_24ED7DAA8;
    qword_2540FAC88 = (uint64_t)"DynamicRegisterTable";
    dword_2540FAC90 = 0;
    xmmword_2540FAC98 = 0u;
    unk_2540FACA8 = 0u;
    xmmword_2540FACB8 = 0u;
    qword_2540FACC8 = 0;
    __cxa_guard_release(&qword_2540FAAB8);
  }
  return &qword_2540FAC58;
}

void re::initInfo_DynamicRegisterTable(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  const re::IntrospectionBase *v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t *v10;
  const re::IntrospectionBase *v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t *v14;
  const re::IntrospectionBase *v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t *v27;
  uint64_t v28;
  uint64_t *v29;
  uint64_t *v30;
  uint64_t v31;
  __int128 v32;
  _QWORD v33[2];
  __int128 v34;

  v33[0] = 0x52D273DBBD26DA18;
  v33[1] = "DynamicRegisterTable";
  re::StringID::destroyString((re::StringID *)v33);
  *((_OWORD *)this + 2) = v34;
  v4 = atomic_load((unsigned __int8 *)&qword_2540FAAC0);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_2540FAAC0);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      v8 = re::IntrospectionInfo<re::DynamicArray<int>>::get(1, v7);
      v9 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
      *(_DWORD *)v9 = 1;
      *(_QWORD *)(v9 + 8) = "registerInt32s";
      *(_QWORD *)(v9 + 16) = v8;
      *(_QWORD *)(v9 + 24) = 0;
      *(_QWORD *)(v9 + 32) = 1;
      *(_DWORD *)(v9 + 40) = 0;
      *(_QWORD *)(v9 + 48) = 0;
      *(_QWORD *)(v9 + 56) = 0;
      *(_DWORD *)(v9 + 64) = 0;
      qword_2540FAAF0 = v9;
      v10 = re::introspectionAllocator((re *)v9);
      v12 = re::IntrospectionInfo<re::DynamicArray<unsigned int>>::get(1, v11);
      v13 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v10 + 32))(v10, 72, 8);
      *(_DWORD *)v13 = 1;
      *(_QWORD *)(v13 + 8) = "registerUInt32s";
      *(_QWORD *)(v13 + 16) = v12;
      *(_QWORD *)(v13 + 24) = 0;
      *(_QWORD *)(v13 + 32) = 0x2800000002;
      *(_DWORD *)(v13 + 40) = 0;
      *(_QWORD *)(v13 + 48) = 0;
      *(_QWORD *)(v13 + 56) = 0;
      *(_DWORD *)(v13 + 64) = 0;
      qword_2540FAAF8 = v13;
      v14 = re::introspectionAllocator((re *)v13);
      v16 = re::IntrospectionInfo<re::DynamicArray<float>>::get(1, v15);
      v17 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v14 + 32))(v14, 72, 8);
      *(_DWORD *)v17 = 1;
      *(_QWORD *)(v17 + 8) = "registerFloats";
      *(_QWORD *)(v17 + 16) = v16;
      *(_QWORD *)(v17 + 24) = 0;
      *(_QWORD *)(v17 + 32) = 0x5000000003;
      *(_DWORD *)(v17 + 40) = 0;
      *(_QWORD *)(v17 + 48) = 0;
      *(_QWORD *)(v17 + 56) = 0;
      *(_DWORD *)(v17 + 64) = 0;
      qword_2540FAB00 = v17;
      v18 = re::introspectionAllocator((re *)v17);
      re::IntrospectionInfo<re::DynamicArray<re::Matrix3x3<float>>>::get();
      v19 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v18 + 32))(v18, 72, 8);
      *(_DWORD *)v19 = 1;
      *(_QWORD *)(v19 + 8) = "registerMatrix3x3s";
      *(_QWORD *)(v19 + 16) = qword_2540FAB30;
      *(_QWORD *)(v19 + 24) = 0;
      *(_QWORD *)(v19 + 32) = 0x7800000004;
      *(_DWORD *)(v19 + 40) = 0;
      *(_QWORD *)(v19 + 48) = 0;
      *(_QWORD *)(v19 + 56) = 0;
      *(_DWORD *)(v19 + 64) = 0;
      qword_2540FAB08 = v19;
      v20 = re::introspectionAllocator((re *)v19);
      v21 = re::IntrospectionInfo<re::DynamicArray<re::Matrix4x4<float>>>::get(1);
      v22 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v20 + 32))(v20, 72, 8);
      *(_DWORD *)v22 = 1;
      *(_QWORD *)(v22 + 8) = "registerMatrix4x4s";
      *(_QWORD *)(v22 + 16) = v21;
      *(_QWORD *)(v22 + 24) = 0;
      *(_QWORD *)(v22 + 32) = 0xA000000005;
      *(_DWORD *)(v22 + 40) = 0;
      *(_QWORD *)(v22 + 48) = 0;
      *(_QWORD *)(v22 + 56) = 0;
      *(_DWORD *)(v22 + 64) = 0;
      qword_2540FAB10 = v22;
      v23 = re::introspectionAllocator((re *)v22);
      v24 = re::IntrospectionInfo<re::DynamicArray<re::Quaternion<float>>>::get(1);
      v25 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v23 + 32))(v23, 72, 8);
      *(_DWORD *)v25 = 1;
      *(_QWORD *)(v25 + 8) = "registerQuaternions";
      *(_QWORD *)(v25 + 16) = v24;
      *(_QWORD *)(v25 + 24) = 0;
      *(_QWORD *)(v25 + 32) = 0xC800000006;
      *(_DWORD *)(v25 + 40) = 0;
      *(_QWORD *)(v25 + 48) = 0;
      *(_QWORD *)(v25 + 56) = 0;
      *(_DWORD *)(v25 + 64) = 0;
      qword_2540FAB18 = v25;
      v26 = re::introspectionAllocator((re *)v25);
      v27 = re::IntrospectionInfo<re::DynamicArray<re::Vector2<float>>>::get(1);
      v28 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v26 + 32))(v26, 72, 8);
      *(_DWORD *)v28 = 1;
      *(_QWORD *)(v28 + 8) = "registerVector2s";
      *(_QWORD *)(v28 + 16) = v27;
      *(_QWORD *)(v28 + 24) = 0;
      *(_QWORD *)(v28 + 32) = 0xF000000007;
      *(_DWORD *)(v28 + 40) = 0;
      *(_QWORD *)(v28 + 48) = 0;
      *(_QWORD *)(v28 + 56) = 0;
      *(_DWORD *)(v28 + 64) = 0;
      qword_2540FAB20 = v28;
      v29 = re::introspectionAllocator((re *)v28);
      v30 = re::IntrospectionInfo<re::DynamicArray<re::Vector3<float>>>::get(1);
      v31 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v29 + 32))(v29, 72, 8);
      *(_DWORD *)v31 = 1;
      *(_QWORD *)(v31 + 8) = "registerVector3s";
      *(_QWORD *)(v31 + 16) = v30;
      *(_QWORD *)(v31 + 24) = 0;
      *(_QWORD *)(v31 + 32) = 0x11800000008;
      *(_DWORD *)(v31 + 40) = 0;
      *(_QWORD *)(v31 + 48) = 0;
      *(_QWORD *)(v31 + 56) = 0;
      *(_DWORD *)(v31 + 64) = 0;
      qword_2540FAB28 = v31;
      __cxa_guard_release(&qword_2540FAAC0);
    }
  }
  *((_QWORD *)this + 2) = 0x14000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 8;
  *((_QWORD *)this + 8) = &qword_2540FAAF0;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::DynamicRegisterTable>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::DynamicRegisterTable>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::DynamicRegisterTable>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::DynamicRegisterTable>;
  re::IntrospectionRegistry::add(this, v3);
  v32 = v34;
}

uint64_t *re::IntrospectionInfo<re::DynamicArray<int>>::get(int a1, const re::IntrospectionBase *a2)
{
  unsigned __int8 v3;
  int v4;
  re *v5;
  std::__shared_mutex_base *v6;
  re *v7;
  std::__shared_mutex_base *v8;
  uint64_t v10;
  int v11;
  re::IntrospectionRegistry *v12;
  const re::IntrospectionBase *v13;
  const char *v14;
  __int128 v15;
  __int128 v16;
  const char *v17;
  uint64_t v18[2];

  if ((v3 & 1) == 0
  {
    re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&re::IntrospectionInfo<re::DynamicArray<int>>::get(BOOL)::info);
    re::IntrospectionInfo<re::DynamicArray<int>>::get(BOOL)::info = (uint64_t)&off_24ED268F0;
  }
  if (a1)
  {
    if (re::IntrospectionInfo<re::DynamicArray<int>>::get(BOOL)::isInitialized)
      return &re::IntrospectionInfo<re::DynamicArray<int>>::get(BOOL)::info;
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v16);
    v4 = re::IntrospectionInfo<re::DynamicArray<int>>::get(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v16);
    if (v4)
      return &re::IntrospectionInfo<re::DynamicArray<int>>::get(BOOL)::info;
    v6 = re::introspectionSharedMutex(v5);
    std::__shared_mutex_base::lock(v6);
  }
  v7 = (re *)re::introspect_int((re *)1, a2);
  if (re::IntrospectionInfo<re::DynamicArray<int>>::get(BOOL)::isInitialized)
  {
    if ((a1 & 1) == 0)
    {
LABEL_9:
      v8 = re::introspectionSharedMutex(v7);
      std::__shared_mutex_base::unlock(v8);
    }
  }
  else
  {
    v10 = (uint64_t)v7;
    re::IntrospectionInfo<re::DynamicArray<int>>::get(BOOL)::isInitialized = 1;
    v11 = *((_DWORD *)v7 + 6);
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&re::IntrospectionInfo<re::DynamicArray<int>>::get(BOOL)::info, 0);
    qword_2557FF790 = 0x2800000003;
    dword_2557FF798 = v11;
    word_2557FF79C = 0;
    *(_QWORD *)&xmmword_2557FF7A0 = 0;
    *((_QWORD *)&xmmword_2557FF7A0 + 1) = 0xFFFFFFFFLL;
    qword_2557FF7B0 = v10;
    unk_2557FF7B8 = 0;
    re::IntrospectionInfo<re::DynamicArray<int>>::get(BOOL)::info = (uint64_t)&off_24ED268F0;
    re::IntrospectionRegistry::add(v12, v13);
    re::getPrettyTypeName((re *)&re::IntrospectionInfo<re::DynamicArray<int>>::get(BOOL)::info, (const re::IntrospectionBase *)&v16);
    if ((BYTE8(v16) & 1) != 0)
      v14 = v17;
    else
      v14 = (char *)&v16 + 9;
    if ((_QWORD)v16 && (BYTE8(v16) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v16 + 40))();
    v16 = *(_OWORD *)(v10 + 32);
    xmmword_2557FF7A0 = v15;
    re::StringID::destroyString((re::StringID *)v18);
    if ((a1 & 1) == 0)
      goto LABEL_9;
  }
  return &re::IntrospectionInfo<re::DynamicArray<int>>::get(BOOL)::info;
}

void re::IntrospectionInfo<re::DynamicArray<re::Matrix3x3<float>>>::get()
{
  unsigned __int8 v0;
  uint64_t v1;
  uint64_t v2;
  int v3;
  re::IntrospectionRegistry *v4;
  const re::IntrospectionBase *v5;
  const char *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  uint64_t v12[2];
  __int128 v13;
  uint64_t v14;
  char v15;
  _BYTE v16[479];

  v0 = atomic_load((unsigned __int8 *)&qword_2540FAAE8);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_2540FAAE8))
  {
    re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)qword_2540FAB30);
    qword_2540FAB30[0] = (uint64_t)&off_24ED26988;
    __cxa_guard_release(&qword_2540FAAE8);
  }
  if ((byte_2540FAAB2 & 1) == 0)
  {
    v1 = re::introspect_Matrix3x3F((re::IntrospectionBase **)1);
    if ((byte_2540FAAB2 & 1) == 0)
    {
      v2 = v1;
      byte_2540FAAB2 = 1;
      v3 = *(_DWORD *)(v1 + 24);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)qword_2540FAB30, 0);
      unk_2540FAB40 = 0x2800000003;
      unk_2540FAB48 = v3;
      word_2540FAB4C = 0;
      *(_QWORD *)&xmmword_2540FAB50 = 0;
      *((_QWORD *)&xmmword_2540FAB50 + 1) = 0xFFFFFFFFLL;
      unk_2540FAB60 = v2;
      unk_2540FAB68 = 0;
      qword_2540FAB30[0] = (uint64_t)&off_24ED26988;
      re::IntrospectionRegistry::add(v4, v5);
      re::getPrettyTypeName((re *)qword_2540FAB30, (const re::IntrospectionBase *)&v14);
      if ((v15 & 1) != 0)
        v6 = *(const char **)&v16[7];
      else
        v6 = v16;
      if (v14 && (v15 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v14 + 40))();
      v11 = *(_OWORD *)(v2 + 32);
      v7 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v12);
      if (v7)
      {
        v8 = *v7;
        *((_QWORD *)&v10 + 1) = v8;
      }
      else
      {
        v13 = v11;
        re::TypeBuilder::beginListType((uint64_t)&v14, v12, 1, 0x28uLL, 8uLL, &v13);
        re::TypeBuilder::setConstructor((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::Matrix3x3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::Matrix3x3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setListUsesContiguousStorage((uint64_t)&v14, 1);
        re::TypeBuilder::setListAccessors((uint64_t)&v14, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::Matrix3x3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::Matrix3x3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIndexer((uint64_t)&v14, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::Matrix3x3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
        re::TypeBuilder::setListIterator((uint64_t)&v14, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::Matrix3x3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::Matrix3x3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::Matrix3x3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v14, v9);
      }
      xmmword_2540FAB50 = v10;
      re::StringID::destroyString((re::StringID *)v12);
    }
  }
}

uint64_t *re::IntrospectionInfo<re::DynamicArray<re::Matrix4x4<float>>>::get(int a1)
{
  unsigned __int8 v2;
  int v3;
  re *v4;
  std::__shared_mutex_base *v5;
  re *v6;
  std::__shared_mutex_base *v7;
  uint64_t v9;
  int v10;
  re::IntrospectionRegistry *v11;
  const re::IntrospectionBase *v12;
  const char *v13;
  __int128 v14;
  __int128 v15;
  const char *v16;
  uint64_t v17[2];

  if ((v2 & 1) == 0
  {
    re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&re::IntrospectionInfo<re::DynamicArray<re::Matrix4x4<float>>>::get(BOOL)::info);
    re::IntrospectionInfo<re::DynamicArray<re::Matrix4x4<float>>>::get(BOOL)::info = (uint64_t)&off_24ED26A20;
  }
  if (a1)
  {
    if (re::IntrospectionInfo<re::DynamicArray<re::Matrix4x4<float>>>::get(BOOL)::isInitialized)
      return &re::IntrospectionInfo<re::DynamicArray<re::Matrix4x4<float>>>::get(BOOL)::info;
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v15);
    v3 = re::IntrospectionInfo<re::DynamicArray<re::Matrix4x4<float>>>::get(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v15);
    if (v3)
      return &re::IntrospectionInfo<re::DynamicArray<re::Matrix4x4<float>>>::get(BOOL)::info;
    v5 = re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(v5);
  }
  v6 = (re *)re::introspect_Matrix4x4F((re::IntrospectionBase **)1);
  if (re::IntrospectionInfo<re::DynamicArray<re::Matrix4x4<float>>>::get(BOOL)::isInitialized)
  {
    if ((a1 & 1) == 0)
    {
LABEL_9:
      v7 = re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(v7);
    }
  }
  else
  {
    v9 = (uint64_t)v6;
    re::IntrospectionInfo<re::DynamicArray<re::Matrix4x4<float>>>::get(BOOL)::isInitialized = 1;
    v10 = *((_DWORD *)v6 + 6);
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&re::IntrospectionInfo<re::DynamicArray<re::Matrix4x4<float>>>::get(BOOL)::info, 0);
    qword_2557FF7E0 = 0x2800000003;
    dword_2557FF7E8 = v10;
    word_2557FF7EC = 0;
    *(_QWORD *)&xmmword_2557FF7F0 = 0;
    *((_QWORD *)&xmmword_2557FF7F0 + 1) = 0xFFFFFFFFLL;
    qword_2557FF800 = v9;
    unk_2557FF808 = 0;
    re::IntrospectionInfo<re::DynamicArray<re::Matrix4x4<float>>>::get(BOOL)::info = (uint64_t)&off_24ED26A20;
    re::IntrospectionRegistry::add(v11, v12);
    re::getPrettyTypeName((re *)&re::IntrospectionInfo<re::DynamicArray<re::Matrix4x4<float>>>::get(BOOL)::info, (const re::IntrospectionBase *)&v15);
    if ((BYTE8(v15) & 1) != 0)
      v13 = v16;
    else
      v13 = (char *)&v15 + 9;
    if ((_QWORD)v15 && (BYTE8(v15) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v15 + 40))();
    v15 = *(_OWORD *)(v9 + 32);
    xmmword_2557FF7F0 = v14;
    re::StringID::destroyString((re::StringID *)v17);
    if ((a1 & 1) == 0)
      goto LABEL_9;
  }
  return &re::IntrospectionInfo<re::DynamicArray<re::Matrix4x4<float>>>::get(BOOL)::info;
}

uint64_t *re::IntrospectionInfo<re::DynamicArray<re::Quaternion<float>>>::get(int a1)
{
  unsigned __int8 v2;
  int v3;
  re *v4;
  std::__shared_mutex_base *v5;
  re *v6;
  std::__shared_mutex_base *v7;
  uint64_t v9;
  int v10;
  re::IntrospectionRegistry *v11;
  const re::IntrospectionBase *v12;
  const char *v13;
  __int128 v14;
  __int128 v15;
  const char *v16;
  uint64_t v17[2];

  if ((v2 & 1) == 0
  {
    re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&re::IntrospectionInfo<re::DynamicArray<re::Quaternion<float>>>::get(BOOL)::info);
    re::IntrospectionInfo<re::DynamicArray<re::Quaternion<float>>>::get(BOOL)::info = (uint64_t)&off_24ED26AB8;
  }
  if (a1)
  {
    if (re::IntrospectionInfo<re::DynamicArray<re::Quaternion<float>>>::get(BOOL)::isInitialized)
      return &re::IntrospectionInfo<re::DynamicArray<re::Quaternion<float>>>::get(BOOL)::info;
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v15);
    v3 = re::IntrospectionInfo<re::DynamicArray<re::Quaternion<float>>>::get(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v15);
    if (v3)
      return &re::IntrospectionInfo<re::DynamicArray<re::Quaternion<float>>>::get(BOOL)::info;
    v5 = re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(v5);
  }
  v6 = (re *)re::introspect_QuaternionF((re::IntrospectionBase **)1);
  if (re::IntrospectionInfo<re::DynamicArray<re::Quaternion<float>>>::get(BOOL)::isInitialized)
  {
    if ((a1 & 1) == 0)
    {
LABEL_9:
      v7 = re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(v7);
    }
  }
  else
  {
    v9 = (uint64_t)v6;
    re::IntrospectionInfo<re::DynamicArray<re::Quaternion<float>>>::get(BOOL)::isInitialized = 1;
    v10 = *((_DWORD *)v6 + 6);
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&re::IntrospectionInfo<re::DynamicArray<re::Quaternion<float>>>::get(BOOL)::info, 0);
    qword_2557FF830 = 0x2800000003;
    dword_2557FF838 = v10;
    word_2557FF83C = 0;
    *(_QWORD *)&xmmword_2557FF840 = 0;
    *((_QWORD *)&xmmword_2557FF840 + 1) = 0xFFFFFFFFLL;
    qword_2557FF850 = v9;
    unk_2557FF858 = 0;
    re::IntrospectionInfo<re::DynamicArray<re::Quaternion<float>>>::get(BOOL)::info = (uint64_t)&off_24ED26AB8;
    re::IntrospectionRegistry::add(v11, v12);
    re::getPrettyTypeName((re *)&re::IntrospectionInfo<re::DynamicArray<re::Quaternion<float>>>::get(BOOL)::info, (const re::IntrospectionBase *)&v15);
    if ((BYTE8(v15) & 1) != 0)
      v13 = v16;
    else
      v13 = (char *)&v15 + 9;
    if ((_QWORD)v15 && (BYTE8(v15) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v15 + 40))();
    v15 = *(_OWORD *)(v9 + 32);
    xmmword_2557FF840 = v14;
    re::StringID::destroyString((re::StringID *)v17);
    if ((a1 & 1) == 0)
      goto LABEL_9;
  }
  return &re::IntrospectionInfo<re::DynamicArray<re::Quaternion<float>>>::get(BOOL)::info;
}

uint64_t *re::IntrospectionInfo<re::DynamicArray<re::Vector2<float>>>::get(int a1)
{
  unsigned __int8 v2;
  int v3;
  re *v4;
  std::__shared_mutex_base *v5;
  re *v6;
  std::__shared_mutex_base *v7;
  uint64_t v9;
  int v10;
  re::IntrospectionRegistry *v11;
  const re::IntrospectionBase *v12;
  const char *v13;
  __int128 v14;
  __int128 v15;
  const char *v16;
  uint64_t v17[2];

  if ((v2 & 1) == 0
  {
    re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&re::IntrospectionInfo<re::DynamicArray<re::Vector2<float>>>::get(BOOL)::info);
    re::IntrospectionInfo<re::DynamicArray<re::Vector2<float>>>::get(BOOL)::info = (uint64_t)&off_24ED26B50;
  }
  if (a1)
  {
    if (re::IntrospectionInfo<re::DynamicArray<re::Vector2<float>>>::get(BOOL)::isInitialized)
      return &re::IntrospectionInfo<re::DynamicArray<re::Vector2<float>>>::get(BOOL)::info;
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v15);
    v3 = re::IntrospectionInfo<re::DynamicArray<re::Vector2<float>>>::get(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v15);
    if (v3)
      return &re::IntrospectionInfo<re::DynamicArray<re::Vector2<float>>>::get(BOOL)::info;
    v5 = re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(v5);
  }
  v6 = (re *)re::introspect_Vector2F((re::IntrospectionBase **)1);
  if (re::IntrospectionInfo<re::DynamicArray<re::Vector2<float>>>::get(BOOL)::isInitialized)
  {
    if ((a1 & 1) == 0)
    {
LABEL_9:
      v7 = re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(v7);
    }
  }
  else
  {
    v9 = (uint64_t)v6;
    re::IntrospectionInfo<re::DynamicArray<re::Vector2<float>>>::get(BOOL)::isInitialized = 1;
    v10 = *((_DWORD *)v6 + 6);
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&re::IntrospectionInfo<re::DynamicArray<re::Vector2<float>>>::get(BOOL)::info, 0);
    qword_2557FF880 = 0x2800000003;
    dword_2557FF888 = v10;
    word_2557FF88C = 0;
    *(_QWORD *)&xmmword_2557FF890 = 0;
    *((_QWORD *)&xmmword_2557FF890 + 1) = 0xFFFFFFFFLL;
    qword_2557FF8A0 = v9;
    unk_2557FF8A8 = 0;
    re::IntrospectionInfo<re::DynamicArray<re::Vector2<float>>>::get(BOOL)::info = (uint64_t)&off_24ED26B50;
    re::IntrospectionRegistry::add(v11, v12);
    re::getPrettyTypeName((re *)&re::IntrospectionInfo<re::DynamicArray<re::Vector2<float>>>::get(BOOL)::info, (const re::IntrospectionBase *)&v15);
    if ((BYTE8(v15) & 1) != 0)
      v13 = v16;
    else
      v13 = (char *)&v15 + 9;
    if ((_QWORD)v15 && (BYTE8(v15) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v15 + 40))();
    v15 = *(_OWORD *)(v9 + 32);
    xmmword_2557FF890 = v14;
    re::StringID::destroyString((re::StringID *)v17);
    if ((a1 & 1) == 0)
      goto LABEL_9;
  }
  return &re::IntrospectionInfo<re::DynamicArray<re::Vector2<float>>>::get(BOOL)::info;
}

uint64_t *re::IntrospectionInfo<re::DynamicArray<re::Vector3<float>>>::get(int a1)
{
  unsigned __int8 v2;
  int v3;
  re *v4;
  std::__shared_mutex_base *v5;
  re *v6;
  std::__shared_mutex_base *v7;
  uint64_t v9;
  int v10;
  re::IntrospectionRegistry *v11;
  const re::IntrospectionBase *v12;
  const char *v13;
  __int128 v14;
  __int128 v15;
  const char *v16;
  uint64_t v17[2];

  if ((v2 & 1) == 0
  {
    re::IntrospectionDynamicArrayBase::IntrospectionDynamicArrayBase((re::IntrospectionDynamicArrayBase *)&re::IntrospectionInfo<re::DynamicArray<re::Vector3<float>>>::get(BOOL)::info);
    re::IntrospectionInfo<re::DynamicArray<re::Vector3<float>>>::get(BOOL)::info = (uint64_t)&off_24ED26BE8;
  }
  if (a1)
  {
    if (re::IntrospectionInfo<re::DynamicArray<re::Vector3<float>>>::get(BOOL)::isInitialized)
      return &re::IntrospectionInfo<re::DynamicArray<re::Vector3<float>>>::get(BOOL)::info;
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v15);
    v3 = re::IntrospectionInfo<re::DynamicArray<re::Vector3<float>>>::get(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v15);
    if (v3)
      return &re::IntrospectionInfo<re::DynamicArray<re::Vector3<float>>>::get(BOOL)::info;
    v5 = re::introspectionSharedMutex(v4);
    std::__shared_mutex_base::lock(v5);
  }
  v6 = (re *)re::introspect_Vector3F((re::IntrospectionBase **)1);
  if (re::IntrospectionInfo<re::DynamicArray<re::Vector3<float>>>::get(BOOL)::isInitialized)
  {
    if ((a1 & 1) == 0)
    {
LABEL_9:
      v7 = re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(v7);
    }
  }
  else
  {
    v9 = (uint64_t)v6;
    re::IntrospectionInfo<re::DynamicArray<re::Vector3<float>>>::get(BOOL)::isInitialized = 1;
    v10 = *((_DWORD *)v6 + 6);
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&re::IntrospectionInfo<re::DynamicArray<re::Vector3<float>>>::get(BOOL)::info, 0);
    qword_2557FF8D0 = 0x2800000003;
    dword_2557FF8D8 = v10;
    word_2557FF8DC = 0;
    *(_QWORD *)&xmmword_2557FF8E0 = 0;
    *((_QWORD *)&xmmword_2557FF8E0 + 1) = 0xFFFFFFFFLL;
    qword_2557FF8F0 = v9;
    unk_2557FF8F8 = 0;
    re::IntrospectionInfo<re::DynamicArray<re::Vector3<float>>>::get(BOOL)::info = (uint64_t)&off_24ED26BE8;
    re::IntrospectionRegistry::add(v11, v12);
    re::getPrettyTypeName((re *)&re::IntrospectionInfo<re::DynamicArray<re::Vector3<float>>>::get(BOOL)::info, (const re::IntrospectionBase *)&v15);
    if ((BYTE8(v15) & 1) != 0)
      v13 = v16;
    else
      v13 = (char *)&v15 + 9;
    if ((_QWORD)v15 && (BYTE8(v15) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v15 + 40))();
    v15 = *(_OWORD *)(v9 + 32);
    xmmword_2557FF8E0 = v14;
    re::StringID::destroyString((re::StringID *)v17);
    if ((a1 & 1) == 0)
      goto LABEL_9;
  }
  return &re::IntrospectionInfo<re::DynamicArray<re::Vector3<float>>>::get(BOOL)::info;
}

double re::internal::defaultConstruct<re::DynamicRegisterTable>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double result;

  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_DWORD *)(a3 + 24) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  *(_QWORD *)(a3 + 312) = 0;
  result = 0.0;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_DWORD *)(a3 + 64) = 0;
  *(_OWORD *)(a3 + 72) = 0u;
  *(_OWORD *)(a3 + 88) = 0u;
  *(_DWORD *)(a3 + 104) = 0;
  *(_OWORD *)(a3 + 112) = 0u;
  *(_OWORD *)(a3 + 128) = 0u;
  *(_DWORD *)(a3 + 144) = 0;
  *(_OWORD *)(a3 + 152) = 0u;
  *(_OWORD *)(a3 + 168) = 0u;
  *(_DWORD *)(a3 + 184) = 0;
  *(_DWORD *)(a3 + 224) = 0;
  *(_OWORD *)(a3 + 192) = 0u;
  *(_OWORD *)(a3 + 208) = 0u;
  *(_DWORD *)(a3 + 264) = 0;
  *(_OWORD *)(a3 + 248) = 0u;
  *(_OWORD *)(a3 + 232) = 0u;
  *(_DWORD *)(a3 + 304) = 0;
  *(_OWORD *)(a3 + 272) = 0u;
  *(_OWORD *)(a3 + 288) = 0u;
  return result;
}

void re::internal::defaultDestruct<re::DynamicRegisterTable>(int a1, int a2, re::DynamicRegisterIdTable *this)
{
  re::DynamicRegisterIdTable::~DynamicRegisterIdTable(this);
}

double re::internal::defaultConstructV2<re::DynamicRegisterTable>(uint64_t a1)
{
  double result;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 312) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_DWORD *)(a1 + 64) = 0;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_DWORD *)(a1 + 104) = 0;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_DWORD *)(a1 + 144) = 0;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_DWORD *)(a1 + 184) = 0;
  *(_DWORD *)(a1 + 224) = 0;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_DWORD *)(a1 + 264) = 0;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_DWORD *)(a1 + 304) = 0;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  return result;
}

uint64_t re::introspect_DynamicRegisterTable(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"DynamicRegisterTable", (uint64_t (*)(re::internal *))re::allocInfo_DynamicRegisterTable, (re::IntrospectionBase *(*)(void))re::initInfo_DynamicRegisterTable, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::DynamicRegisterTable>, this);
}

uint64_t *re::introspect_EvaluationRegisterType(re *this, const re::IntrospectionBase *a2)
{
  int v2;
  unsigned __int8 v3;
  unsigned __int8 v4;
  char v5;
  re *v6;
  std::__shared_mutex_base *v7;
  re *v8;
  uint64_t *v9;
  uint64_t v10;
  unsigned int *v11;
  _anonymous_namespace_ *v12;
  unint64_t v13;
  unint64_t i;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  char v18;
  unsigned __int8 *v19;
  int v20;
  uint64_t v21;
  unint64_t j;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  char v26;
  unsigned __int8 *v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  std::__shared_mutex_base *v31;
  uint64_t *result;
  re *v33;
  uint64_t *v34;
  re *v35;
  uint64_t *v36;
  re *v37;
  uint64_t *v38;
  re *v39;
  uint64_t *v40;
  re *v41;
  uint64_t *v42;
  re *v43;
  uint64_t *v44;
  re *v45;
  uint64_t *v46;
  re *v47;
  uint64_t *v48;
  re *v49;
  uint64_t *v50;
  re *v51;
  uint64_t *v52;
  re *v53;
  uint64_t *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  const char *v58;
  StringID v59;
  _QWORD v60[2];
  _QWORD v61[61];

  v2 = (int)this;
  v3 = atomic_load((unsigned __int8 *)&qword_2540FAAC8);
  if ((v3 & 1) == 0)
  {
    v33 = (re *)__cxa_guard_acquire(&qword_2540FAAC8);
    if ((_DWORD)v33)
    {
      v34 = re::introspectionAllocator(v33);
      v35 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v34 + 32))(v34, 24, 8);
      *(_DWORD *)v35 = 1;
      *((_QWORD *)v35 + 1) = 0;
      *((_QWORD *)v35 + 2) = "EvaluationRegisterTypeInt32";
      qword_2540FAC00 = (uint64_t)v35;
      v36 = re::introspectionAllocator(v35);
      v37 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v36 + 32))(v36, 24, 8);
      *(_DWORD *)v37 = 1;
      *((_QWORD *)v37 + 1) = 1;
      *((_QWORD *)v37 + 2) = "EvaluationRegisterTypeUInt32";
      qword_2540FAC08 = (uint64_t)v37;
      v38 = re::introspectionAllocator(v37);
      v39 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v38 + 32))(v38, 24, 8);
      *(_DWORD *)v39 = 1;
      *((_QWORD *)v39 + 1) = 2;
      *((_QWORD *)v39 + 2) = "EvaluationRegisterTypeFloat";
      qword_2540FAC10 = (uint64_t)v39;
      v40 = re::introspectionAllocator(v39);
      v41 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v40 + 32))(v40, 24, 8);
      *(_DWORD *)v41 = 1;
      *((_QWORD *)v41 + 1) = 3;
      *((_QWORD *)v41 + 2) = "EvaluationRegisterTypeMatrix3x3";
      qword_2540FAC18 = (uint64_t)v41;
      v42 = re::introspectionAllocator(v41);
      v43 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v42 + 32))(v42, 24, 8);
      *(_DWORD *)v43 = 1;
      *((_QWORD *)v43 + 1) = 4;
      *((_QWORD *)v43 + 2) = "EvaluationRegisterTypeMatrix4x4";
      qword_2540FAC20 = (uint64_t)v43;
      v44 = re::introspectionAllocator(v43);
      v45 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v44 + 32))(v44, 24, 8);
      *(_DWORD *)v45 = 1;
      *((_QWORD *)v45 + 1) = 5;
      *((_QWORD *)v45 + 2) = "EvaluationRegisterTypeQuaternion";
      qword_2540FAC28 = (uint64_t)v45;
      v46 = re::introspectionAllocator(v45);
      v47 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v46 + 32))(v46, 24, 8);
      *(_DWORD *)v47 = 1;
      *((_QWORD *)v47 + 1) = 6;
      *((_QWORD *)v47 + 2) = "EvaluationRegisterTypeVector2";
      qword_2540FAC30 = (uint64_t)v47;
      v48 = re::introspectionAllocator(v47);
      v49 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v48 + 32))(v48, 24, 8);
      *(_DWORD *)v49 = 1;
      *((_QWORD *)v49 + 1) = 7;
      *((_QWORD *)v49 + 2) = "EvaluationRegisterTypeVector3";
      qword_2540FAC38 = (uint64_t)v49;
      v50 = re::introspectionAllocator(v49);
      v51 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v50 + 32))(v50, 24, 8);
      *(_DWORD *)v51 = 1;
      *((_QWORD *)v51 + 1) = 8;
      *((_QWORD *)v51 + 2) = "EvaluationRegisterTypeCount";
      qword_2540FAC40 = (uint64_t)v51;
      v52 = re::introspectionAllocator(v51);
      v53 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v52 + 32))(v52, 24, 8);
      *(_DWORD *)v53 = 1;
      *((_QWORD *)v53 + 1) = 255;
      *((_QWORD *)v53 + 2) = "EvaluationRegisterTypeUnknown";
      qword_2540FAC48 = (uint64_t)v53;
      v54 = re::introspectionAllocator(v53);
      v55 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v54 + 32))(v54, 24, 8);
      *(_DWORD *)v55 = 1;
      *(_QWORD *)(v55 + 8) = 254;
      *(_QWORD *)(v55 + 16) = "EvaluationRegisterTypeCallback";
      qword_2540FAC50 = v55;
      __cxa_guard_release(&qword_2540FAAC8);
    }
  }
  v4 = atomic_load((unsigned __int8 *)&qword_2540FAAD0);
  if ((v4 & 1) == 0 && __cxa_guard_acquire(&qword_2540FAAD0))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_2540FAB70, "EvaluationRegisterType", 1, 1, 1, 1);
    qword_2540FAB70 = (uint64_t)&off_24ED7D9E8;
    qword_2540FABB0 = (uint64_t)&re::introspect_EvaluationRegisterType(BOOL)::enumTable;
    dword_2540FAB80 = 9;
    __cxa_guard_release(&qword_2540FAAD0);
  }
  if (v2)
  {
    if ((_MergedGlobals_27 & 1) != 0)
      return &qword_2540FAB70;
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)v61);
    v5 = _MergedGlobals_27;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)v61);
    if ((v5 & 1) != 0)
      return &qword_2540FAB70;
    v7 = re::introspectionSharedMutex(v6);
    std::__shared_mutex_base::lock(v7);
    if ((_MergedGlobals_27 & 1) != 0)
    {
LABEL_34:
      v31 = re::introspectionSharedMutex(v8);
      std::__shared_mutex_base::unlock(v31);
      return &qword_2540FAB70;
    }
  }
  _MergedGlobals_27 = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_2540FAB70, a2);
  v57 = 0x79BBFE2840B26BF2;
  v58 = "EvaluationRegisterType";
  v61[0] = 0x31CD534126;
  v61[1] = "uint8_t";
  v9 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v61);
  if (v9)
  {
    v10 = *v9;
    re::StringID::destroyString((re::StringID *)v61);
    v11 = (unsigned int *)qword_2540FABB0;
    v60[1] = v10;
    re::TypeBuilder::beginEnumType((uint64_t)v61, &v57, 1, 1, (uint64_t)v60);
    v13 = *v11;
    if ((_DWORD)v13)
    {
      for (i = 0; i < v13; ++i)
      {
        v15 = *(_QWORD *)(*((_QWORD *)v11 + 1) + 8 * i);
        if (*(_DWORD *)v15 == 1)
        {
          v16 = *(char **)(v15 + 16);
          if (v16)
          {
            v17 = *v16;
            if (*v16)
            {
              v18 = v16[1];
              if (v18)
              {
                v19 = (unsigned __int8 *)(v16 + 2);
                do
                {
                  v17 = 31 * v17 + v18;
                  v20 = *v19++;
                  v18 = v20;
                }
                while (v20);
              }
            }
          }
          else
          {
            v17 = 0;
          }
          v21 = *(_QWORD *)(v15 + 8);
          *(_QWORD *)&v59.var0 = 2 * v17;
          v59.var1 = v16;
          re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v61, v21, &v59);
          re::StringID::destroyString((re::StringID *)&v59);
          v13 = *v11;
        }
      }
      if (v13)
      {
        for (j = 0; j < v13; ++j)
        {
          v23 = *(_QWORD *)(*((_QWORD *)v11 + 1) + 8 * j);
          if (*(_DWORD *)v23 == 2)
          {
            v24 = *(char **)(v23 + 16);
            if (v24)
            {
              v25 = *v24;
              if (*v24)
              {
                v26 = v24[1];
                if (v26)
                {
                  v27 = (unsigned __int8 *)(v24 + 2);
                  do
                  {
                    v25 = 31 * v25 + v26;
                    v28 = *v27++;
                    v26 = v28;
                  }
                  while (v28);
                }
              }
            }
            else
            {
              v25 = 0;
            }
            v29 = *(_QWORD *)(v23 + 8);
            *(_QWORD *)&v59.var0 = 2 * v25;
            v59.var1 = v24;
            re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v61, v29, &v59);
            re::StringID::destroyString((re::StringID *)&v59);
            v13 = *v11;
          }
        }
      }
    }
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v61, v30);
    xmmword_2540FAB90 = (__int128)v59;
    re::StringID::destroyString((re::StringID *)&v57);
    if ((v2 & 1) != 0)
      return &qword_2540FAB70;
    goto LABEL_34;
  }
  re::StringID::destroyString((re::StringID *)v61);
  re::internal::assertLog((re::internal *)5, v56, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "EvaluationRegisterType", v57, v58);
  result = (uint64_t *)_os_crash();
  __break(1u);
  return result;
}

uint64_t *re::introspect_EvaluationCommand(re *this, const re::IntrospectionBase *a2)
{
  int v2;
  unsigned __int8 v3;
  unsigned __int8 v4;
  char v5;
  re *v6;
  std::__shared_mutex_base *v7;
  re *v8;
  uint64_t *v9;
  uint64_t v10;
  unsigned int *v11;
  _anonymous_namespace_ *v12;
  unint64_t v13;
  unint64_t i;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  char v18;
  unsigned __int8 *v19;
  int v20;
  uint64_t v21;
  unint64_t j;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  char v26;
  unsigned __int8 *v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  std::__shared_mutex_base *v31;
  uint64_t *result;
  re *v33;
  uint64_t *v34;
  re *v35;
  uint64_t *v36;
  re *v37;
  uint64_t *v38;
  re *v39;
  uint64_t *v40;
  re *v41;
  uint64_t *v42;
  re *v43;
  uint64_t *v44;
  re *v45;
  uint64_t *v46;
  re *v47;
  uint64_t *v48;
  re *v49;
  uint64_t *v50;
  re *v51;
  uint64_t *v52;
  re *v53;
  uint64_t *v54;
  re *v55;
  uint64_t *v56;
  re *v57;
  uint64_t *v58;
  re *v59;
  uint64_t *v60;
  re *v61;
  uint64_t *v62;
  re *v63;
  uint64_t *v64;
  re *v65;
  uint64_t *v66;
  re *v67;
  uint64_t *v68;
  re *v69;
  uint64_t *v70;
  re *v71;
  uint64_t *v72;
  re *v73;
  uint64_t *v74;
  re *v75;
  uint64_t *v76;
  re *v77;
  uint64_t *v78;
  re *v79;
  uint64_t *v80;
  re *v81;
  uint64_t *v82;
  re *v83;
  uint64_t *v84;
  re *v85;
  uint64_t *v86;
  re *v87;
  uint64_t *v88;
  re *v89;
  uint64_t *v90;
  re *v91;
  uint64_t *v92;
  re *v93;
  uint64_t *v94;
  re *v95;
  uint64_t *v96;
  re *v97;
  uint64_t *v98;
  re *v99;
  uint64_t *v100;
  re *v101;
  uint64_t *v102;
  re *v103;
  uint64_t *v104;
  re *v105;
  uint64_t *v106;
  re *v107;
  uint64_t *v108;
  re *v109;
  uint64_t *v110;
  re *v111;
  uint64_t *v112;
  re *v113;
  uint64_t *v114;
  re *v115;
  uint64_t *v116;
  re *v117;
  uint64_t *v118;
  re *v119;
  uint64_t *v120;
  re *v121;
  uint64_t *v122;
  re *v123;
  uint64_t *v124;
  re *v125;
  uint64_t *v126;
  re *v127;
  uint64_t *v128;
  re *v129;
  uint64_t *v130;
  re *v131;
  uint64_t *v132;
  re *v133;
  uint64_t *v134;
  re *v135;
  uint64_t *v136;
  re *v137;
  uint64_t *v138;
  re *v139;
  uint64_t *v140;
  re *v141;
  uint64_t *v142;
  re *v143;
  uint64_t *v144;
  re *v145;
  uint64_t *v146;
  re *v147;
  uint64_t *v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  const char *v152;
  StringID v153;
  _QWORD v154[2];
  _QWORD v155[61];

  v2 = (int)this;
  v3 = atomic_load((unsigned __int8 *)&qword_2540FAAD8);
  if ((v3 & 1) == 0)
  {
    v33 = (re *)__cxa_guard_acquire(&qword_2540FAAD8);
    if ((_DWORD)v33)
    {
      v34 = re::introspectionAllocator(v33);
      v35 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v34 + 32))(v34, 24, 8);
      *(_DWORD *)v35 = 1;
      *((_QWORD *)v35 + 1) = 8;
      *((_QWORD *)v35 + 2) = "AddVector3";
      qword_2540FACD0 = (uint64_t)v35;
      v36 = re::introspectionAllocator(v35);
      v37 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v36 + 32))(v36, 24, 8);
      *(_DWORD *)v37 = 1;
      *((_QWORD *)v37 + 1) = 9;
      *((_QWORD *)v37 + 2) = "AddVector2";
      qword_2540FACD8 = (uint64_t)v37;
      v38 = re::introspectionAllocator(v37);
      v39 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v38 + 32))(v38, 24, 8);
      *(_DWORD *)v39 = 1;
      *((_QWORD *)v39 + 1) = 10;
      *((_QWORD *)v39 + 2) = "ComponentLerpVector3";
      qword_2540FACE0 = (uint64_t)v39;
      v40 = re::introspectionAllocator(v39);
      v41 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v40 + 32))(v40, 24, 8);
      *(_DWORD *)v41 = 1;
      *((_QWORD *)v41 + 1) = 11;
      *((_QWORD *)v41 + 2) = "LerpVector3";
      qword_2540FACE8 = (uint64_t)v41;
      v42 = re::introspectionAllocator(v41);
      v43 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v42 + 32))(v42, 24, 8);
      *(_DWORD *)v43 = 1;
      *((_QWORD *)v43 + 1) = 12;
      *((_QWORD *)v43 + 2) = "SlerpQuaternion";
      qword_2540FACF0 = (uint64_t)v43;
      v44 = re::introspectionAllocator(v43);
      v45 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v44 + 32))(v44, 24, 8);
      *(_DWORD *)v45 = 1;
      *((_QWORD *)v45 + 1) = 13;
      *((_QWORD *)v45 + 2) = "ConvertIntrinsicEulerToQuaternion";
      qword_2540FACF8 = (uint64_t)v45;
      v46 = re::introspectionAllocator(v45);
      v47 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v46 + 32))(v46, 24, 8);
      *(_DWORD *)v47 = 1;
      *((_QWORD *)v47 + 1) = 14;
      *((_QWORD *)v47 + 2) = "ConvertQuaternionToIntrinsicEuler";
      qword_2540FAD00 = (uint64_t)v47;
      v48 = re::introspectionAllocator(v47);
      v49 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v48 + 32))(v48, 24, 8);
      *(_DWORD *)v49 = 1;
      *((_QWORD *)v49 + 1) = 15;
      *((_QWORD *)v49 + 2) = "CrossVector3";
      qword_2540FAD08 = (uint64_t)v49;
      v50 = re::introspectionAllocator(v49);
      v51 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v50 + 32))(v50, 24, 8);
      *(_DWORD *)v51 = 1;
      *((_QWORD *)v51 + 1) = 16;
      *((_QWORD *)v51 + 2) = "DivideQuaternion";
      qword_2540FAD10 = (uint64_t)v51;
      v52 = re::introspectionAllocator(v51);
      v53 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v52 + 32))(v52, 24, 8);
      *(_DWORD *)v53 = 1;
      *((_QWORD *)v53 + 1) = 18;
      *((_QWORD *)v53 + 2) = "ConjugateQuaternion";
      qword_2540FAD18 = (uint64_t)v53;
      v54 = re::introspectionAllocator(v53);
      v55 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v54 + 32))(v54, 24, 8);
      *(_DWORD *)v55 = 1;
      *((_QWORD *)v55 + 1) = 19;
      *((_QWORD *)v55 + 2) = "InvertMatrix3x3";
      qword_2540FAD20 = (uint64_t)v55;
      v56 = re::introspectionAllocator(v55);
      v57 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v56 + 32))(v56, 24, 8);
      *(_DWORD *)v57 = 1;
      *((_QWORD *)v57 + 1) = 20;
      *((_QWORD *)v57 + 2) = "InvertMatrix4x4";
      qword_2540FAD28 = (uint64_t)v57;
      v58 = re::introspectionAllocator(v57);
      v59 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v58 + 32))(v58, 24, 8);
      *(_DWORD *)v59 = 1;
      *((_QWORD *)v59 + 1) = 21;
      *((_QWORD *)v59 + 2) = "InvertQuaternion";
      qword_2540FAD30 = (uint64_t)v59;
      v60 = re::introspectionAllocator(v59);
      v61 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v60 + 32))(v60, 24, 8);
      *(_DWORD *)v61 = 1;
      *((_QWORD *)v61 + 1) = 22;
      *((_QWORD *)v61 + 2) = "DotVector3";
      qword_2540FAD38 = (uint64_t)v61;
      v62 = re::introspectionAllocator(v61);
      v63 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v62 + 32))(v62, 24, 8);
      *(_DWORD *)v63 = 1;
      *((_QWORD *)v63 + 1) = 23;
      *((_QWORD *)v63 + 2) = "DotVector2";
      qword_2540FAD40 = (uint64_t)v63;
      v64 = re::introspectionAllocator(v63);
      v65 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v64 + 32))(v64, 24, 8);
      *(_DWORD *)v65 = 1;
      *((_QWORD *)v65 + 1) = 24;
      *((_QWORD *)v65 + 2) = "MultiplyQuaternion";
      qword_2540FAD48 = (uint64_t)v65;
      v66 = re::introspectionAllocator(v65);
      v67 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v66 + 32))(v66, 24, 8);
      *(_DWORD *)v67 = 1;
      *((_QWORD *)v67 + 1) = 25;
      *((_QWORD *)v67 + 2) = "MultiplyVector3";
      qword_2540FAD50 = (uint64_t)v67;
      v68 = re::introspectionAllocator(v67);
      v69 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v68 + 32))(v68, 24, 8);
      *(_DWORD *)v69 = 1;
      *((_QWORD *)v69 + 1) = 27;
      *((_QWORD *)v69 + 2) = "MultiplyMatrix3x3";
      qword_2540FAD58 = (uint64_t)v69;
      v70 = re::introspectionAllocator(v69);
      v71 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v70 + 32))(v70, 24, 8);
      *(_DWORD *)v71 = 1;
      *((_QWORD *)v71 + 1) = 28;
      *((_QWORD *)v71 + 2) = "MultiplyMatrix4x4";
      qword_2540FAD60 = (uint64_t)v71;
      v72 = re::introspectionAllocator(v71);
      v73 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v72 + 32))(v72, 24, 8);
      *(_DWORD *)v73 = 1;
      *((_QWORD *)v73 + 1) = 29;
      *((_QWORD *)v73 + 2) = "NormalizeVector3";
      qword_2540FAD68 = (uint64_t)v73;
      v74 = re::introspectionAllocator(v73);
      v75 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v74 + 32))(v74, 24, 8);
      *(_DWORD *)v75 = 1;
      *((_QWORD *)v75 + 1) = 30;
      *((_QWORD *)v75 + 2) = "RotateQuaternionVector3";
      qword_2540FAD70 = (uint64_t)v75;
      v76 = re::introspectionAllocator(v75);
      v77 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v76 + 32))(v76, 24, 8);
      *(_DWORD *)v77 = 1;
      *((_QWORD *)v77 + 1) = 31;
      *((_QWORD *)v77 + 2) = "SubtractVector3";
      qword_2540FAD78 = (uint64_t)v77;
      v78 = re::introspectionAllocator(v77);
      v79 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v78 + 32))(v78, 24, 8);
      *(_DWORD *)v79 = 1;
      *((_QWORD *)v79 + 1) = 32;
      *((_QWORD *)v79 + 2) = "SubtractVector2";
      qword_2540FAD80 = (uint64_t)v79;
      v80 = re::introspectionAllocator(v79);
      v81 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v80 + 32))(v80, 24, 8);
      *(_DWORD *)v81 = 1;
      *((_QWORD *)v81 + 1) = 33;
      *((_QWORD *)v81 + 2) = "TransposeMatrix3x3";
      qword_2540FAD88 = (uint64_t)v81;
      v82 = re::introspectionAllocator(v81);
      v83 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v82 + 32))(v82, 24, 8);
      *(_DWORD *)v83 = 1;
      *((_QWORD *)v83 + 1) = 34;
      *((_QWORD *)v83 + 2) = "ExtractMinorMatrix4x4";
      qword_2540FAD90 = (uint64_t)v83;
      v84 = re::introspectionAllocator(v83);
      v85 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v84 + 32))(v84, 24, 8);
      *(_DWORD *)v85 = 1;
      *((_QWORD *)v85 + 1) = 35;
      *((_QWORD *)v85 + 2) = "ExtractRotationMatrix3x3";
      qword_2540FAD98 = (uint64_t)v85;
      v86 = re::introspectionAllocator(v85);
      v87 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v86 + 32))(v86, 24, 8);
      *(_DWORD *)v87 = 1;
      *((_QWORD *)v87 + 1) = 36;
      *((_QWORD *)v87 + 2) = "ExtractScaleMatrix3x3";
      qword_2540FADA0 = (uint64_t)v87;
      v88 = re::introspectionAllocator(v87);
      v89 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v88 + 32))(v88, 24, 8);
      *(_DWORD *)v89 = 1;
      *((_QWORD *)v89 + 1) = 37;
      *((_QWORD *)v89 + 2) = "ExtractTranslationMatrix4x4";
      qword_2540FADA8 = (uint64_t)v89;
      v90 = re::introspectionAllocator(v89);
      v91 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v90 + 32))(v90, 24, 8);
      *(_DWORD *)v91 = 1;
      *((_QWORD *)v91 + 1) = 38;
      *((_QWORD *)v91 + 2) = "MakeColumnsMatrix3x3";
      qword_2540FADB0 = (uint64_t)v91;
      v92 = re::introspectionAllocator(v91);
      v93 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v92 + 32))(v92, 24, 8);
      *(_DWORD *)v93 = 1;
      *((_QWORD *)v93 + 1) = 39;
      *((_QWORD *)v93 + 2) = "MakeScaleRotationMatrix3x3";
      qword_2540FADB8 = (uint64_t)v93;
      v94 = re::introspectionAllocator(v93);
      v95 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v94 + 32))(v94, 24, 8);
      *(_DWORD *)v95 = 1;
      *((_QWORD *)v95 + 1) = 40;
      *((_QWORD *)v95 + 2) = "MakeMinorTranslationMatrix4x4";
      qword_2540FADC0 = (uint64_t)v95;
      v96 = re::introspectionAllocator(v95);
      v97 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v96 + 32))(v96, 24, 8);
      *(_DWORD *)v97 = 1;
      *((_QWORD *)v97 + 1) = 41;
      *((_QWORD *)v97 + 2) = "TransformDirectionMatrix3x3Vector3";
      qword_2540FADC8 = (uint64_t)v97;
      v98 = re::introspectionAllocator(v97);
      v99 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v98 + 32))(v98, 24, 8);
      *(_DWORD *)v99 = 1;
      *((_QWORD *)v99 + 1) = 42;
      *((_QWORD *)v99 + 2) = "TransformDirectionMatrix4x4Vector3";
      qword_2540FADD0 = (uint64_t)v99;
      v100 = re::introspectionAllocator(v99);
      v101 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v100 + 32))(v100, 24, 8);
      *(_DWORD *)v101 = 1;
      *((_QWORD *)v101 + 1) = 43;
      *((_QWORD *)v101 + 2) = "TransformPositionMatrix4x4Vector3";
      qword_2540FADD8 = (uint64_t)v101;
      v102 = re::introspectionAllocator(v101);
      v103 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v102 + 32))(v102, 24, 8);
      *(_DWORD *)v103 = 1;
      *((_QWORD *)v103 + 1) = 44;
      *((_QWORD *)v103 + 2) = "DotQuaternion";
      qword_2540FADE0 = (uint64_t)v103;
      v104 = re::introspectionAllocator(v103);
      v105 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v104 + 32))(v104, 24, 8);
      *(_DWORD *)v105 = 1;
      *((_QWORD *)v105 + 1) = 45;
      *((_QWORD *)v105 + 2) = "MakeAxisAngleQuaternion";
      qword_2540FADE8 = (uint64_t)v105;
      v106 = re::introspectionAllocator(v105);
      v107 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v106 + 32))(v106, 24, 8);
      *(_DWORD *)v107 = 1;
      *((_QWORD *)v107 + 1) = 46;
      *((_QWORD *)v107 + 2) = "MakeVector3FloatQuaternion";
      qword_2540FADF0 = (uint64_t)v107;
      v108 = re::introspectionAllocator(v107);
      v109 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v108 + 32))(v108, 24, 8);
      *(_DWORD *)v109 = 1;
      *((_QWORD *)v109 + 1) = 47;
      *((_QWORD *)v109 + 2) = "MakeVector3";
      qword_2540FADF8 = (uint64_t)v109;
      v110 = re::introspectionAllocator(v109);
      v111 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v110 + 32))(v110, 24, 8);
      *(_DWORD *)v111 = 1;
      *((_QWORD *)v111 + 1) = 48;
      *((_QWORD *)v111 + 2) = "MakeVector2";
      qword_2540FAE00 = (uint64_t)v111;
      v112 = re::introspectionAllocator(v111);
      v113 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v112 + 32))(v112, 24, 8);
      *(_DWORD *)v113 = 1;
      *((_QWORD *)v113 + 1) = 49;
      *((_QWORD *)v113 + 2) = "AddFloat";
      qword_2540FAE08 = (uint64_t)v113;
      v114 = re::introspectionAllocator(v113);
      v115 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v114 + 32))(v114, 24, 8);
      *(_DWORD *)v115 = 1;
      *((_QWORD *)v115 + 1) = 50;
      *((_QWORD *)v115 + 2) = "SubtractFloat";
      qword_2540FAE10 = (uint64_t)v115;
      v116 = re::introspectionAllocator(v115);
      v117 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v116 + 32))(v116, 24, 8);
      *(_DWORD *)v117 = 1;
      *((_QWORD *)v117 + 1) = 51;
      *((_QWORD *)v117 + 2) = "MultiplyFloat";
      qword_2540FAE18 = (uint64_t)v117;
      v118 = re::introspectionAllocator(v117);
      v119 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v118 + 32))(v118, 24, 8);
      *(_DWORD *)v119 = 1;
      *((_QWORD *)v119 + 1) = 52;
      *((_QWORD *)v119 + 2) = "DivideFloat";
      qword_2540FAE20 = (uint64_t)v119;
      v120 = re::introspectionAllocator(v119);
      v121 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v120 + 32))(v120, 24, 8);
      *(_DWORD *)v121 = 1;
      *((_QWORD *)v121 + 1) = 53;
      *((_QWORD *)v121 + 2) = "SinFloat";
      qword_2540FAE28 = (uint64_t)v121;
      v122 = re::introspectionAllocator(v121);
      v123 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v122 + 32))(v122, 24, 8);
      *(_DWORD *)v123 = 1;
      *((_QWORD *)v123 + 1) = 54;
      *((_QWORD *)v123 + 2) = "CosFloat";
      qword_2540FAE30 = (uint64_t)v123;
      v124 = re::introspectionAllocator(v123);
      v125 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v124 + 32))(v124, 24, 8);
      *(_DWORD *)v125 = 1;
      *((_QWORD *)v125 + 1) = 55;
      *((_QWORD *)v125 + 2) = "TanFloat";
      qword_2540FAE38 = (uint64_t)v125;
      v126 = re::introspectionAllocator(v125);
      v127 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v126 + 32))(v126, 24, 8);
      *(_DWORD *)v127 = 1;
      *((_QWORD *)v127 + 1) = 56;
      *((_QWORD *)v127 + 2) = "AsinFloat";
      qword_2540FAE40 = (uint64_t)v127;
      v128 = re::introspectionAllocator(v127);
      v129 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v128 + 32))(v128, 24, 8);
      *(_DWORD *)v129 = 1;
      *((_QWORD *)v129 + 1) = 57;
      *((_QWORD *)v129 + 2) = "AcosFloat";
      qword_2540FAE48 = (uint64_t)v129;
      v130 = re::introspectionAllocator(v129);
      v131 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v130 + 32))(v130, 24, 8);
      *(_DWORD *)v131 = 1;
      *((_QWORD *)v131 + 1) = 58;
      *((_QWORD *)v131 + 2) = "AtanFloat";
      qword_2540FAE50 = (uint64_t)v131;
      v132 = re::introspectionAllocator(v131);
      v133 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v132 + 32))(v132, 24, 8);
      *(_DWORD *)v133 = 1;
      *((_QWORD *)v133 + 1) = 59;
      *((_QWORD *)v133 + 2) = "Atan2Float";
      qword_2540FAE58 = (uint64_t)v133;
      v134 = re::introspectionAllocator(v133);
      v135 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v134 + 32))(v134, 24, 8);
      *(_DWORD *)v135 = 1;
      *((_QWORD *)v135 + 1) = 60;
      *((_QWORD *)v135 + 2) = "SelectFloat";
      qword_2540FAE60 = (uint64_t)v135;
      v136 = re::introspectionAllocator(v135);
      v137 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v136 + 32))(v136, 24, 8);
      *(_DWORD *)v137 = 1;
      *((_QWORD *)v137 + 1) = 61;
      *((_QWORD *)v137 + 2) = "GreaterFloat";
      qword_2540FAE68 = (uint64_t)v137;
      v138 = re::introspectionAllocator(v137);
      v139 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v138 + 32))(v138, 24, 8);
      *(_DWORD *)v139 = 1;
      *((_QWORD *)v139 + 1) = 62;
      *((_QWORD *)v139 + 2) = "GreaterEqualFloat";
      qword_2540FAE70 = (uint64_t)v139;
      v140 = re::introspectionAllocator(v139);
      v141 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v140 + 32))(v140, 24, 8);
      *(_DWORD *)v141 = 1;
      *((_QWORD *)v141 + 1) = 63;
      *((_QWORD *)v141 + 2) = "LessFloat";
      qword_2540FAE78 = (uint64_t)v141;
      v142 = re::introspectionAllocator(v141);
      v143 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v142 + 32))(v142, 24, 8);
      *(_DWORD *)v143 = 1;
      *((_QWORD *)v143 + 1) = 64;
      *((_QWORD *)v143 + 2) = "LessEqualFloat";
      qword_2540FAE80 = (uint64_t)v143;
      v144 = re::introspectionAllocator(v143);
      v145 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v144 + 32))(v144, 24, 8);
      *(_DWORD *)v145 = 1;
      *((_QWORD *)v145 + 1) = 65;
      *((_QWORD *)v145 + 2) = "Int32IsEqual";
      qword_2540FAE88 = (uint64_t)v145;
      v146 = re::introspectionAllocator(v145);
      v147 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v146 + 32))(v146, 24, 8);
      *(_DWORD *)v147 = 1;
      *((_QWORD *)v147 + 1) = 66;
      *((_QWORD *)v147 + 2) = "UInt32IsEqual";
      qword_2540FAE90 = (uint64_t)v147;
      v148 = re::introspectionAllocator(v147);
      v149 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v148 + 32))(v148, 24, 8);
      *(_DWORD *)v149 = 1;
      *(_QWORD *)(v149 + 8) = 67;
      *(_QWORD *)(v149 + 16) = "FloatAlmostEqual";
      qword_2540FAE98 = v149;
      __cxa_guard_release(&qword_2540FAAD8);
    }
  }
  v4 = atomic_load((unsigned __int8 *)&qword_2540FAAE0);
  if ((v4 & 1) == 0 && __cxa_guard_acquire(&qword_2540FAAE0))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_2540FABB8, "EvaluationCommand", 4, 4, 1, 1);
    qword_2540FABB8 = (uint64_t)&off_24ED7D9E8;
    qword_2540FABF8 = (uint64_t)&re::introspect_EvaluationCommand(BOOL)::enumTable;
    dword_2540FABC8 = 9;
    __cxa_guard_release(&qword_2540FAAE0);
  }
  if (v2)
  {
    if ((byte_2540FAAB1 & 1) != 0)
      return &qword_2540FABB8;
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)v155);
    v5 = byte_2540FAAB1;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)v155);
    if ((v5 & 1) != 0)
      return &qword_2540FABB8;
    v7 = re::introspectionSharedMutex(v6);
    std::__shared_mutex_base::lock(v7);
    if ((byte_2540FAAB1 & 1) != 0)
    {
LABEL_34:
      v31 = re::introspectionSharedMutex(v8);
      std::__shared_mutex_base::unlock(v31);
      return &qword_2540FABB8;
    }
  }
  byte_2540FAAB1 = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_2540FABB8, a2);
  v151 = 0x59C43F7855EEA89ELL;
  v152 = "EvaluationCommand";
  v155[0] = 0x607DD0F01DCLL;
  v155[1] = "uint32_t";
  v9 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v155);
  if (v9)
  {
    v10 = *v9;
    re::StringID::destroyString((re::StringID *)v155);
    v11 = (unsigned int *)qword_2540FABF8;
    v154[1] = v10;
    re::TypeBuilder::beginEnumType((uint64_t)v155, &v151, 1, 1, (uint64_t)v154);
    v13 = *v11;
    if ((_DWORD)v13)
    {
      for (i = 0; i < v13; ++i)
      {
        v15 = *(_QWORD *)(*((_QWORD *)v11 + 1) + 8 * i);
        if (*(_DWORD *)v15 == 1)
        {
          v16 = *(char **)(v15 + 16);
          if (v16)
          {
            v17 = *v16;
            if (*v16)
            {
              v18 = v16[1];
              if (v18)
              {
                v19 = (unsigned __int8 *)(v16 + 2);
                do
                {
                  v17 = 31 * v17 + v18;
                  v20 = *v19++;
                  v18 = v20;
                }
                while (v20);
              }
            }
          }
          else
          {
            v17 = 0;
          }
          v21 = *(_QWORD *)(v15 + 8);
          *(_QWORD *)&v153.var0 = 2 * v17;
          v153.var1 = v16;
          re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v155, v21, &v153);
          re::StringID::destroyString((re::StringID *)&v153);
          v13 = *v11;
        }
      }
      if (v13)
      {
        for (j = 0; j < v13; ++j)
        {
          v23 = *(_QWORD *)(*((_QWORD *)v11 + 1) + 8 * j);
          if (*(_DWORD *)v23 == 2)
          {
            v24 = *(char **)(v23 + 16);
            if (v24)
            {
              v25 = *v24;
              if (*v24)
              {
                v26 = v24[1];
                if (v26)
                {
                  v27 = (unsigned __int8 *)(v24 + 2);
                  do
                  {
                    v25 = 31 * v25 + v26;
                    v28 = *v27++;
                    v26 = v28;
                  }
                  while (v28);
                }
              }
            }
            else
            {
              v25 = 0;
            }
            v29 = *(_QWORD *)(v23 + 8);
            *(_QWORD *)&v153.var0 = 2 * v25;
            v153.var1 = v24;
            re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v155, v29, &v153);
            re::StringID::destroyString((re::StringID *)&v153);
            v13 = *v11;
          }
        }
      }
    }
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v155, v30);
    xmmword_2540FABD8 = (__int128)v153;
    re::StringID::destroyString((re::StringID *)&v151);
    if ((v2 & 1) != 0)
      return &qword_2540FABB8;
    goto LABEL_34;
  }
  re::StringID::destroyString((re::StringID *)v155);
  re::internal::assertLog((re::internal *)5, v150, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "EvaluationCommand", v151, v152);
  result = (uint64_t *)_os_crash();
  __break(1u);
  return result;
}

void re::TypeBuilderHelper::registerFixedArray<int>(re::TypeRegistry *a1@<X0>, uint64_t *a2@<X1>, __int128 *a3@<X2>, re::TypeRegistry **a4@<X8>)
{
  _anonymous_namespace_ *v8;
  re::TypeRegistry *v9;
  uint64_t v10;
  __int128 v11;
  _BYTE v12[488];

  v8 = (_anonymous_namespace_ *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a1 + 200, a2);
  if (a1 && v8)
  {
    v9 = *(re::TypeRegistry **)v8;
    *a4 = a1;
    a4[1] = v9;
  }
  else
  {
    v11 = *a3;
    re::TypeBuilder::beginListType((uint64_t)v12, a2, 1, 0x18uLL, 8uLL, &v11);
    re::TypeBuilder::setConstructor((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerFixedArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
    re::TypeBuilder::setDestructor((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerFixedArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
    re::TypeBuilder::setListUsesContiguousStorage((uint64_t)v12, 1);
    re::TypeBuilder::setListAccessors((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerFixedArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerFixedArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
    re::TypeBuilder::setListIndexer((uint64_t)v12, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerFixedArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
    re::TypeBuilder::setListIterator((uint64_t)v12, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerFixedArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerFixedArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerFixedArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
    re::TypeBuilder::commitTo((re::TypeBuilder *)v12, a1, a4);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v12, v10);
  }
}

_QWORD *re::IntrospectionFixedArray<int>::~IntrospectionFixedArray(_QWORD *a1)
{
  *a1 = &off_24ED20258;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionFixedArray<int>::~IntrospectionFixedArray(_QWORD *a1)
{
  *a1 = &off_24ED20258;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x2276933B8);
}

void re::IntrospectionFixedArray<int>::construct(uint64_t a1, _QWORD *a2)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
}

uint64_t re::IntrospectionFixedArray<int>::destroy(uint64_t a1, uint64_t *a2)
{
  uint64_t result;
  _QWORD *v4;

  result = *a2;
  if (*a2)
  {
    v4 = a2 + 1;
    if (a2[1])
    {
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, a2[2]);
      *v4 = 0;
      v4[1] = 0;
    }
    *a2 = 0;
  }
  return result;
}

void re::IntrospectionFixedArray<int>::init(uint64_t a1, uint64_t *a2, re *a3, int a4, unint64_t a5)
{
  uint64_t v10;
  unint64_t v11;

  re::FixedArray<int>::init<>(a2, (uint64_t)a3, a5);
  if (a5)
  {
    v10 = 0;
    v11 = 0;
    do
    {
      if (a2[1] <= v11)
      {
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      re::introspectionInitElement(a3, a4, *(re::Allocator **)(a1 + 48), (re::IntrospectionBase *)(a2[2] + v10));
      ++v11;
      v10 += 4;
    }
    while (a5 != v11);
  }
}

uint64_t re::IntrospectionFixedArray<int>::deinit(uint64_t a1, uint64_t *a2)
{
  uint64_t result;
  _QWORD *v4;

  result = *a2;
  if (*a2)
  {
    v4 = a2 + 1;
    if (a2[1])
    {
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, a2[2]);
      *v4 = 0;
      v4[1] = 0;
    }
    *a2 = 0;
  }
  return result;
}

uint64_t re::IntrospectionFixedArray<int>::size(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 8);
}

BOOL re::IntrospectionFixedArray<int>::isInitialized(uint64_t a1, _QWORD *a2)
{
  return *a2 != 0;
}

uint64_t re::IntrospectionFixedArray<int>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(_QWORD *)(a2 + 8) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 16) + 4 * a3;
}

{
  if (*(_QWORD *)(a2 + 8) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 16) + 4 * a3;
}

_QWORD *re::TypeBuilderHelper::registerFixedArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(_QWORD *result, uint64_t a2, uint64_t a3)
{
  result[1] = 0;
  result[2] = 0;
  *result = a3;
  return result;
}

uint64_t re::TypeBuilderHelper::registerFixedArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke(uint64_t *a1)
{
  uint64_t result;

  result = *a1;
  if (result)
  {
    if (a1[1])
    {
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, a1[2]);
      a1[1] = 0;
      a1[2] = 0;
    }
    *a1 = 0;
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerFixedArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

void re::TypeBuilderHelper::registerFixedArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t *a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  uint64_t v8;
  _anonymous_namespace_ *v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  _BYTE v13[32];
  _BYTE v14[8];
  uint64_t v15;

  v8 = *a1;
  if (v8)
  {
    if (a1[1])
    {
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v8 + 40))(v8, a1[2]);
      a1[1] = 0;
      a1[2] = 0;
    }
    *a1 = 0;
  }
  re::FixedArray<int>::init<>(a1, (uint64_t)a3, a4);
  {
    re::TypeRegistry::typeInfo(*(_QWORD **)a2, *(_QWORD *)(*(_QWORD *)(a2 + 16) + 72), v14);
    re::TypeInfo::TypeInfo((uint64_t)v13, (uint64_t)&v15);
    v10 = a1[1];
    if (v10)
    {
      v11 = (char *)a1[2];
      v12 = 4 * v10;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v13, v11, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v13, (void **)v11, a3, 0);
        v11 += 4;
        v12 -= 4;
      }
      while (v12);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerFixedArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(_QWORD *)(a1 + 8) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a1 + 16) + 4 * a2;
}

uint64_t re::TypeBuilderHelper::registerFixedArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 16, 8);
  *(_QWORD *)result = a1;
  *(_DWORD *)(result + 8) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerFixedArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1)
{
  int v1;
  uint64_t v2;
  unint64_t v3;

  v1 = a1[2];
  v2 = *(_QWORD *)a1;
  v3 = *(_QWORD *)(*(_QWORD *)a1 + 8);
  if (v1 < (int)v3)
    a1[2] = ++v1;
  if (v3 <= v1)
    return 0;
  else
    return *(_QWORD *)(v2 + 16) + 4 * v1;
}

uint64_t re::TypeBuilderHelper::registerFixedArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 40))(a2, result);
  return result;
}

void re::TypeBuilderHelper::registerFixedArray<re::Vector3<float>>(re::TypeRegistry *a1@<X0>, uint64_t *a2@<X1>, __int128 *a3@<X2>, re::TypeRegistry **a4@<X8>)
{
  _anonymous_namespace_ *v8;
  re::TypeRegistry *v9;
  uint64_t v10;
  __int128 v11;
  _BYTE v12[488];

  v8 = (_anonymous_namespace_ *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a1 + 200, a2);
  if (a1 && v8)
  {
    v9 = *(re::TypeRegistry **)v8;
    *a4 = a1;
    a4[1] = v9;
  }
  else
  {
    v11 = *a3;
    re::TypeBuilder::beginListType((uint64_t)v12, a2, 1, 0x18uLL, 8uLL, &v11);
    re::TypeBuilder::setConstructor((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerFixedArray<re::Vector3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
    re::TypeBuilder::setDestructor((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerFixedArray<re::Vector3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
    re::TypeBuilder::setListUsesContiguousStorage((uint64_t)v12, 1);
    re::TypeBuilder::setListAccessors((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerFixedArray<re::Vector3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerFixedArray<re::Vector3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
    re::TypeBuilder::setListIndexer((uint64_t)v12, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerFixedArray<re::Vector3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
    re::TypeBuilder::setListIterator((uint64_t)v12, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerFixedArray<re::Vector3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerFixedArray<re::Vector3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerFixedArray<re::Vector3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
    re::TypeBuilder::commitTo((re::TypeBuilder *)v12, a1, a4);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v12, v10);
  }
}

_QWORD *re::IntrospectionFixedArray<re::Vector3<float>>::~IntrospectionFixedArray(_QWORD *a1)
{
  *a1 = &off_24ED20258;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionFixedArray<re::Vector3<float>>::~IntrospectionFixedArray(_QWORD *a1)
{
  *a1 = &off_24ED20258;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x2276933B8);
}

void re::IntrospectionFixedArray<re::Vector3<float>>::construct(uint64_t a1, _QWORD *a2)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
}

uint64_t re::IntrospectionFixedArray<re::Vector3<float>>::destroy(uint64_t a1, uint64_t *a2)
{
  uint64_t result;
  _QWORD *v4;

  result = *a2;
  if (*a2)
  {
    v4 = a2 + 1;
    if (a2[1])
    {
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, a2[2]);
      *v4 = 0;
      v4[1] = 0;
    }
    *a2 = 0;
  }
  return result;
}

void re::IntrospectionFixedArray<re::Vector3<float>>::init(uint64_t a1, uint64_t *a2, re *a3, int a4, unint64_t a5)
{
  uint64_t v10;
  unint64_t v11;

  re::FixedArray<re::Vector3<float>>::init<>(a2, (uint64_t)a3, a5);
  if (a5)
  {
    v10 = 0;
    v11 = 0;
    do
    {
      if (a2[1] <= v11)
      {
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      re::introspectionInitElement(a3, a4, *(re::Allocator **)(a1 + 48), (re::IntrospectionBase *)(a2[2] + v10));
      ++v11;
      v10 += 16;
    }
    while (a5 != v11);
  }
}

uint64_t re::IntrospectionFixedArray<re::Vector3<float>>::deinit(uint64_t a1, uint64_t *a2)
{
  uint64_t result;
  _QWORD *v4;

  result = *a2;
  if (*a2)
  {
    v4 = a2 + 1;
    if (a2[1])
    {
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, a2[2]);
      *v4 = 0;
      v4[1] = 0;
    }
    *a2 = 0;
  }
  return result;
}

uint64_t re::IntrospectionFixedArray<re::Vector3<float>>::size(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 8);
}

BOOL re::IntrospectionFixedArray<re::Vector3<float>>::isInitialized(uint64_t a1, _QWORD *a2)
{
  return *a2 != 0;
}

uint64_t re::IntrospectionFixedArray<re::Vector3<float>>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(_QWORD *)(a2 + 8) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 16) + 16 * a3;
}

{
  if (*(_QWORD *)(a2 + 8) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 16) + 16 * a3;
}

_QWORD *re::TypeBuilderHelper::registerFixedArray<re::Vector3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(_QWORD *result, uint64_t a2, uint64_t a3)
{
  result[1] = 0;
  result[2] = 0;
  *result = a3;
  return result;
}

uint64_t re::TypeBuilderHelper::registerFixedArray<re::Vector3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke(uint64_t *a1)
{
  uint64_t result;

  result = *a1;
  if (result)
  {
    if (a1[1])
    {
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, a1[2]);
      a1[1] = 0;
      a1[2] = 0;
    }
    *a1 = 0;
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerFixedArray<re::Vector3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

void re::TypeBuilderHelper::registerFixedArray<re::Vector3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t *a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  uint64_t v8;
  _anonymous_namespace_ *v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  _BYTE v13[32];
  _BYTE v14[8];
  uint64_t v15;

  v8 = *a1;
  if (v8)
  {
    if (a1[1])
    {
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v8 + 40))(v8, a1[2]);
      a1[1] = 0;
      a1[2] = 0;
    }
    *a1 = 0;
  }
  re::FixedArray<re::Vector3<float>>::init<>(a1, (uint64_t)a3, a4);
  {
    re::TypeRegistry::typeInfo(*(_QWORD **)a2, *(_QWORD *)(*(_QWORD *)(a2 + 16) + 72), v14);
    re::TypeInfo::TypeInfo((uint64_t)v13, (uint64_t)&v15);
    v10 = a1[1];
    if (v10)
    {
      v11 = (char *)a1[2];
      v12 = 16 * v10;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v13, v11, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v13, (void **)v11, a3, 0);
        v11 += 16;
        v12 -= 16;
      }
      while (v12);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerFixedArray<re::Vector3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(_QWORD *)(a1 + 8) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a1 + 16) + 16 * a2;
}

uint64_t re::TypeBuilderHelper::registerFixedArray<re::Vector3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 16, 8);
  *(_QWORD *)result = a1;
  *(_DWORD *)(result + 8) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerFixedArray<re::Vector3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1)
{
  int v1;
  uint64_t v2;
  unint64_t v3;

  v1 = a1[2];
  v2 = *(_QWORD *)a1;
  v3 = *(_QWORD *)(*(_QWORD *)a1 + 8);
  if (v1 < (int)v3)
    a1[2] = ++v1;
  if (v3 <= v1)
    return 0;
  else
    return *(_QWORD *)(v2 + 16) + 16 * v1;
}

uint64_t re::TypeBuilderHelper::registerFixedArray<re::Vector3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 40))(a2, result);
  return result;
}

void re::TypeBuilderHelper::registerDynamicArray<int>(re::TypeRegistry *a1@<X0>, uint64_t *a2@<X1>, __int128 *a3@<X2>, re::TypeRegistry **a4@<X8>)
{
  _anonymous_namespace_ *v8;
  re::TypeRegistry *v9;
  uint64_t v10;
  __int128 v11;
  _BYTE v12[488];

  v8 = (_anonymous_namespace_ *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a1 + 200, a2);
  if (a1 && v8)
  {
    v9 = *(re::TypeRegistry **)v8;
    *a4 = a1;
    a4[1] = v9;
  }
  else
  {
    v11 = *a3;
    re::TypeBuilder::beginListType((uint64_t)v12, a2, 1, 0x28uLL, 8uLL, &v11);
    re::TypeBuilder::setConstructor((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
    re::TypeBuilder::setDestructor((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
    re::TypeBuilder::setListUsesContiguousStorage((uint64_t)v12, 1);
    re::TypeBuilder::setListAccessors((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
    re::TypeBuilder::setListIndexer((uint64_t)v12, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
    re::TypeBuilder::setListIterator((uint64_t)v12, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
    re::TypeBuilder::commitTo((re::TypeBuilder *)v12, a1, a4);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v12, v10);
  }
}

_QWORD *re::IntrospectionDynamicArray<int>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<int>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x2276933B8);
}

void re::IntrospectionDynamicArray<int>::construct(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<int>::destroy(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = *(_QWORD *)a2;
  if (*(_QWORD *)a2)
  {
    if (*(_QWORD *)(a2 + 32))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a2 + 32) = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_QWORD *)a2 = 0;
    ++*(_DWORD *)(a2 + 24);
  }
  return result;
}

_QWORD *re::IntrospectionDynamicArray<int>::init(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  _QWORD *result;

  if (*a2)
  {
    if (a2[4])
      (*(void (**)(_QWORD))(*(_QWORD *)*a2 + 40))(*a2);
    a2[4] = 0;
    a2[1] = 0;
    a2[2] = 0;
    ++*((_DWORD *)a2 + 6);
  }
  *a2 = a3;
  result = re::DynamicArray<int>::setCapacity(a2, 0);
  ++*((_DWORD *)a2 + 6);
  return result;
}

void re::IntrospectionDynamicArray<int>::resize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  unint64_t v10;
  unint64_t i;

  if (!*(_QWORD *)a4)
  {
    *(_QWORD *)a4 = a2;
    re::DynamicArray<int>::setCapacity((_QWORD *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  v10 = *(_QWORD *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
      re::DynamicArray<float>::resize(a4, a5);
  }
  else
  {
    re::DynamicArray<int>::setCapacity((_QWORD *)a4, a5);
    for (i = a5 - *(_QWORD *)(a4 + 16); i; --i)
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, a3, a4);
  }
}

re::IntrospectionBase *re::IntrospectionDynamicArray<int>::addElement(uint64_t a1, re *a2, int a3, _anonymous_namespace_ *this)
{
  re::IntrospectionBase *v8;
  int v10;

  v10 = 0;
  re::DynamicArray<int>::add(this, &v10);
  v8 = (re::IntrospectionBase *)(*((_QWORD *)this + 4) + 4 * *((_QWORD *)this + 2) - 4);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v8);
  return v8;
}

uint64_t re::IntrospectionDynamicArray<int>::size(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<int>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 4 * a3;
}

{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 4 * a3;
}

_QWORD *re::TypeBuilderHelper::registerDynamicArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)a1 = a3;
  result = re::DynamicArray<int>::setCapacity((_QWORD *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)a1;
  if (result)
  {
    if (*(_QWORD *)(a1 + 32))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  char v4;

  re::TypeBuilderHelper::registerDynamicArray<float>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::operator()((uint64_t)&v4, a1, a2, a3, a4);
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(_QWORD *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a1 + 32) + 4 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 16, 8);
  *(_QWORD *)result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unint64_t v4;
  uint64_t result;

  v2 = *(_QWORD *)a1;
  if (a1[2] == *(_DWORD *)(*(_QWORD *)a1 + 24))
  {
    v3 = a1[3];
    v4 = *(_QWORD *)(v2 + 16);
    if (v3 < (int)v4)
      a1[3] = ++v3;
    if (v4 <= v3)
      return 0;
    else
      return *(_QWORD *)(v2 + 32) + 4 * v3;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 40))(a2, result);
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::Matrix3x3<float>>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionDynamicArray<re::Matrix3x3<float>>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x2276933B8);
}

void re::IntrospectionDynamicArray<re::Matrix3x3<float>>::construct(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
}

uint64_t re::IntrospectionDynamicArray<re::Matrix3x3<float>>::destroy(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = *(_QWORD *)a2;
  if (*(_QWORD *)a2)
  {
    if (*(_QWORD *)(a2 + 32))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a2 + 32) = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_QWORD *)a2 = 0;
    ++*(_DWORD *)(a2 + 24);
  }
  return result;
}

_QWORD *re::IntrospectionDynamicArray<re::Matrix3x3<float>>::init(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  _QWORD *result;

  if (*a2)
  {
    if (a2[4])
      (*(void (**)(_QWORD))(*(_QWORD *)*a2 + 40))(*a2);
    a2[4] = 0;
    a2[1] = 0;
    a2[2] = 0;
    ++*((_DWORD *)a2 + 6);
  }
  *a2 = a3;
  result = re::DynamicArray<re::Matrix3x3<float>>::setCapacity(a2, 0);
  ++*((_DWORD *)a2 + 6);
  return result;
}

void re::IntrospectionDynamicArray<re::Matrix3x3<float>>::resize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  unint64_t v10;
  unint64_t i;

  if (!*(_QWORD *)a4)
  {
    *(_QWORD *)a4 = a2;
    re::DynamicArray<re::Matrix3x3<float>>::setCapacity((_QWORD *)a4, a5);
    ++*(_DWORD *)(a4 + 24);
  }
  v10 = *(_QWORD *)(a4 + 16);
  if (v10 >= a5)
  {
    if (v10 > a5)
      re::DynamicArray<re::Matrix3x3<float>>::resize(a4, a5);
  }
  else
  {
    re::DynamicArray<re::Matrix3x3<float>>::setCapacity((_QWORD *)a4, a5);
    for (i = a5 - *(_QWORD *)(a4 + 16); i; --i)
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, a3, a4);
  }
}

re::IntrospectionBase *re::IntrospectionDynamicArray<re::Matrix3x3<float>>::addElement(uint64_t a1, re *a2, int a3, _anonymous_namespace_ *this)
{
  unint64_t v8;
  _OWORD *v9;
  uint64_t v10;
  re::IntrospectionBase *v11;

  v8 = *((_QWORD *)this + 2);
  if (v8 >= *((_QWORD *)this + 1))
  {
    re::DynamicArray<re::Matrix3x3<float>>::growCapacity(this, v8 + 1);
    v8 = *((_QWORD *)this + 2);
  }
  v9 = (_OWORD *)(*((_QWORD *)this + 4) + 48 * v8);
  v9[1] = 0u;
  v9[2] = 0u;
  *v9 = 0u;
  v10 = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = v10 + 1;
  ++*((_DWORD *)this + 6);
  v11 = (re::IntrospectionBase *)(*((_QWORD *)this + 4) + 48 * v10);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 48), v11);
  return v11;
}

uint64_t re::IntrospectionDynamicArray<re::Matrix3x3<float>>::size(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 16);
}

uint64_t re::IntrospectionDynamicArray<re::Matrix3x3<float>>::elementAt(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 48 * a3;
}

{
  if (*(_QWORD *)(a2 + 16) <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a2 + 32) + 48 * a3;
}

void re::DynamicArray<re::Matrix3x3<float>>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v4;
  void *v5;
  uint64_t v6;

  v4 = *(_QWORD *)(a1 + 16);
  if (v4 >= a2)
  {
    if (v4 <= a2)
      return;
  }
  else
  {
    if (*(_QWORD *)(a1 + 8) < a2)
    {
      re::DynamicArray<re::Matrix3x3<float>>::setCapacity((_QWORD *)a1, a2);
      v4 = *(_QWORD *)(a1 + 16);
    }
    if (v4 < a2)
    {
      v5 = (void *)(*(_QWORD *)(a1 + 32) + 48 * v4);
      v6 = 48 * a2 - 48 * v4;
      if (v6 >= 1)
        bzero(v5, 48 * (v6 / 0x30uLL - ((unint64_t)v6 > 0x2F)) + 48);
    }
  }
  *(_QWORD *)(a1 + 16) = a2;
  ++*(_DWORD *)(a1 + 24);
}

_QWORD *re::TypeBuilderHelper::registerDynamicArray<re::Matrix3x3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)a1 = a3;
  result = re::DynamicArray<re::Matrix3x3<float>>::setCapacity((_QWORD *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::Matrix3x3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)a1;
  if (result)
  {
    if (*(_QWORD *)(a1 + 32))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::Matrix3x3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

void re::TypeBuilderHelper::registerDynamicArray<re::Matrix3x3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke(uint64_t a1, uint64_t a2, re::Allocator *a3, unint64_t a4)
{
  re::Allocator *v8;
  _anonymous_namespace_ *v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  _BYTE v13[32];
  _BYTE v14[8];
  uint64_t v15;

  v8 = *(re::Allocator **)a1;
  if (v8 == a3)
  {
    *(_QWORD *)(a1 + 16) = 0;
  }
  else
  {
    if (v8)
    {
      if (*(_QWORD *)(a1 + 32))
        (*(void (**)(re::Allocator *))(*(_QWORD *)v8 + 40))(v8);
      *(_QWORD *)(a1 + 32) = 0;
      *(_QWORD *)(a1 + 8) = 0;
      *(_QWORD *)(a1 + 16) = 0;
      ++*(_DWORD *)(a1 + 24);
    }
    *(_QWORD *)a1 = a3;
    re::DynamicArray<re::Matrix3x3<float>>::setCapacity((_QWORD *)a1, a4);
  }
  ++*(_DWORD *)(a1 + 24);
  re::DynamicArray<re::Matrix3x3<float>>::resize(a1, a4);
  {
    re::TypeRegistry::typeInfo(*(_QWORD **)a2, *(_QWORD *)(*(_QWORD *)(a2 + 16) + 72), v14);
    re::TypeInfo::TypeInfo((uint64_t)v13, (uint64_t)&v15);
    v10 = *(_QWORD *)(a1 + 16);
    if (v10)
    {
      v11 = *(char **)(a1 + 32);
      v12 = 48 * v10;
      do
      {
        re::TypeInfo::destruct((re::TypeInfo *)v13, v11, a3, 0);
        re::TypeInfo::construct((re::TypeInfo *)v13, (void **)v11, a3, 0);
        v11 += 48;
        v12 -= 48;
      }
      while (v12);
    }
  }
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::Matrix3x3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke(uint64_t a1, unint64_t a2)
{
  if (*(_QWORD *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a1 + 32) + 48 * a2;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::Matrix3x3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 16, 8);
  *(_QWORD *)result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(result + 12) = -1;
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::Matrix3x3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unint64_t v4;
  uint64_t result;

  v2 = *(_QWORD *)a1;
  if (a1[2] == *(_DWORD *)(*(_QWORD *)a1 + 24))
  {
    v3 = a1[3];
    v4 = *(_QWORD *)(v2 + 16);
    if (v3 < (int)v4)
      a1[3] = ++v3;
    if (v4 <= v3)
      return 0;
    else
      return *(_QWORD *)(v2 + 32) + 48 * v3;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) DynamicArray elements may not be added or removed during iteration.", "iter->originalVersion == iter->array->version()", "operator()", 313);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerDynamicArray<re::Matrix3x3<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(uint64_t result, uint64_t a2)
{
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 40))(a2, result);
  return result;
}

void re::TypeBuilderHelper::registerDynamicArray<re::Matrix4x4<float>>(re::TypeRegistry *a1@<X0>, uint64_t *a2@<X1>, __int128 *a3@<X2>, re::TypeRegistry **a4@<X8>)
{
  _anonymous_namespace_ *v8;
  re::TypeRegistry *v9;
  uint64_t v10;
  __int128 v11;
  _BYTE v12[488];

  v8 = (_anonymous_namespace_ *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a1 + 200, a2);
  if (a1 && v8)
  {
    v9 = *(re::TypeRegistry **)v8;
    *a4 = a1;
    a4[1] = v9;
  }
  else
  {
    v11 = *a3;
    re::TypeBuilder::beginListType((uint64_t)v12, a2, 1, 0x28uLL, 8uLL, &v11);
    re::TypeBuilder::setConstructor((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::Matrix4x4<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
    re::TypeBuilder::setDestructor((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::Matrix4x4<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
    re::TypeBuilder::setListUsesContiguousStorage((uint64_t)v12, 1);
    re::TypeBuilder::setListAccessors((uint64_t)v12, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::Matrix4x4<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerDynamicArray<re::Matrix4x4<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,unsigned long)#1}::__invoke);
    re::TypeBuilder::setListIndexer((uint64_t)v12, (void *(*)(void *, unint64_t))re::TypeBuilderHelper::registerDynamicArray<re::Matrix4x4<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,unsigned long)#1}::__invoke);
    re::TypeBuilder::setListIterator((uint64_t)v12, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::Matrix4x4<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerDynamicArray<re::Matrix4x4<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerDynamicArray<re::Matrix4x4<float>>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
    re::TypeBuilder::commitTo((re::TypeBuilder *)v12, a1, a4);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v12, v10);
  }
}

_QWORD *re::IntrospectionDynamicArray<re::Matrix4x4<float>>::~IntrospectionDynamicArray(_QWORD *a1)
{
  *a1 = &off_24ED1FA08;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  return a1;
}

