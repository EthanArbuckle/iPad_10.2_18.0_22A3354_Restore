void sub_225409140(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock((os_unfair_lock_t)&re::audio::throttledLog(os_log_type_t,std::string const&)::logLock);
  _Unwind_Resume(a1);
}

uint64_t re::audio::matrix3x3_to_string(float *a1)
{
  return objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("[%.9g, %.9g, %.9g]\n[%.9g, %.9g, %.9g]\n[%.9g, %.9g, %.9g]\nscale [%.9g, %.9g, %.9g]\n"), *a1, a1[4], a1[8], a1[1], a1[5], a1[9], a1[2], a1[6], a1[10], *a1, a1[5], a1[10]);
}

_QWORD *re::audio::nameForPlaybackState@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a2, off_24ED3DE78[a1]);
}

_QWORD *re::audio::stringFromPose@<X0>(re::audio *this@<X0>, _QWORD *a2@<X8>)
{
  char __str[256];
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  snprintf(__str, 0x100uLL, "<pos=[% 3.2f,% 3.2f,% 3.2f],fwd=[% 3.2f,% 3.2f,% 3.2f],up=[% 3.2f,% 3.2f,% 3.2f]>", *((float *)this + 12), *((float *)this + 13), *((float *)this + 14), *((float *)this + 8), *((float *)this + 9), *((float *)this + 10), *((float *)this + 4), *((float *)this + 5), *((float *)this + 6));
  return std::string::basic_string[abi:ne180100]<0>(a2, __str);
}

_QWORD *re::audio::stringFromMatrix@<X0>(re::audio *this@<X0>, _QWORD *a2@<X8>)
{
  char __str[256];
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  snprintf(__str, 0x100uLL, "<c0=[% 3.2f,% 3.2f,% 3.2f,% 3.2f],c1=[% 3.2f,% 3.2f,% 3.2f,% 3.2f],c2=[% 3.2f,% 3.2f,% 3.2f,% 3.2f],c3=[% 3.2f,% 3.2f,% 3.2f,% 3.2f]>", *(float *)this, *((float *)this + 1), *((float *)this + 2), *((float *)this + 3), *((float *)this + 4), *((float *)this + 5), *((float *)this + 6), *((float *)this + 7), *((float *)this + 8), *((float *)this + 9), *((float *)this + 10), *((float *)this + 11), *((float *)this + 12), *((float *)this + 13), *((float *)this + 14),
    *((float *)this + 15));
  return std::string::basic_string[abi:ne180100]<0>(a2, __str);
}

void re::audio::debugStringFromDeactivatedEntityState(re::audio **this@<X0>, const re::ecs2::Entity *__val@<X1>, std::string *a3@<X8>)
{
  std::string *v5;
  __int128 v6;
  std::string *v7;
  __int128 v8;
  char *v9;
  std::string *p_p;
  std::string::size_type size;
  std::string *v12;
  __int128 v13;
  int v14;
  re::audio *v15;
  int v16;
  const std::string::value_type *v17;
  std::string::size_type v18;
  re::audio *v19;
  int v20;
  re::audio *v21;
  int v22;
  const std::string::value_type *v23;
  std::string::size_type v24;
  std::string *v25;
  __int128 v26;
  std::string *v27;
  __int128 v28;
  char *v29;
  const std::string::value_type *v30;
  std::string::size_type v31;
  std::string *v32;
  __int128 v33;
  std::string *v34;
  std::string::size_type v35;
  std::string *v36;
  __int128 v37;
  std::string *v38;
  __int128 v39;
  char *v40;
  const std::string::value_type *v41;
  std::string::size_type v42;
  std::string *v43;
  __int128 v44;
  std::string *v45;
  std::string::size_type v46;
  std::string v47;
  void *v48;
  std::string::size_type v49;
  unsigned __int8 v50;
  uint64_t v51;
  char v52;
  _BYTE v53[7];
  char *v54;
  void *v55;
  std::string::size_type v56;
  unsigned __int8 v57;
  std::string __p;
  std::string v59;
  std::string v60;
  std::string v61;

  std::to_string(&v59, (unint64_t)__val);
  v5 = std::string::insert(&v59, 0, "Token ");
  v6 = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
  v60.__r_.__value_.__r.__words[2] = v5->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v60.__r_.__value_.__l.__data_ = v6;
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  v7 = std::string::append(&v60, " with ");
  v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
  v61.__r_.__value_.__r.__words[2] = v7->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v61.__r_.__value_.__l.__data_ = v8;
  v7->__r_.__value_.__l.__size_ = 0;
  v7->__r_.__value_.__r.__words[2] = 0;
  v7->__r_.__value_.__r.__words[0] = 0;
  re::ecs2::Entity::debugDescription((re::ecs2::Entity *)this, (re::DynamicString *)&v51);
  if ((v52 & 1) != 0)
    v9 = v54;
  else
    v9 = v53;
  std::string::basic_string[abi:ne180100]<0>(&__p, v9);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  else
    size = __p.__r_.__value_.__l.__size_;
  v12 = std::string::append(&v61, (const std::string::value_type *)p_p, size);
  v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
  a3->__r_.__value_.__r.__words[2] = v12->__r_.__value_.__r.__words[2];
  *(_OWORD *)&a3->__r_.__value_.__l.__data_ = v13;
  v12->__r_.__value_.__l.__size_ = 0;
  v12->__r_.__value_.__r.__words[2] = 0;
  v12->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (v51 && (v52 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v51 + 40))();
  if (SHIBYTE(v61.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v61.__r_.__value_.__l.__data_);
  if (SHIBYTE(v60.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v60.__r_.__value_.__l.__data_);
  if (SHIBYTE(v59.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v59.__r_.__value_.__l.__data_);
  v14 = *((_DWORD *)this + 72);
  if ((v14 & 1) == 0)
  {
    std::string::basic_string[abi:ne180100]<0>(&v47, "");
    if (((_DWORD)this[36] & 0xA) == 8)
    {
      v15 = this[3];
      if (!v15 || (*((_BYTE *)v15 + 288) & 0x80) != 0)
      {
LABEL_29:
        std::string::append(&v47, "No parent with isSelfEnabled = false");
      }
      else
      {
        v16 = 1;
        while ((*((_BYTE *)v15 + 288) & 8) != 0)
        {
          v15 = (re::audio *)*((_QWORD *)v15 + 3);
          if (v15)
          {
            ++v16;
            if ((*((_BYTE *)v15 + 288) & 0x80) == 0)
              continue;
          }
          goto LABEL_29;
        }
        std::to_string(&__p, v16);
        v36 = std::string::insert(&__p, 0, "First parent with isSelfEnabled = false is ");
        v37 = *(_OWORD *)&v36->__r_.__value_.__l.__data_;
        v59.__r_.__value_.__r.__words[2] = v36->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v59.__r_.__value_.__l.__data_ = v37;
        v36->__r_.__value_.__l.__size_ = 0;
        v36->__r_.__value_.__r.__words[2] = 0;
        v36->__r_.__value_.__r.__words[0] = 0;
        v38 = std::string::append(&v59, " levels up with ");
        v39 = *(_OWORD *)&v38->__r_.__value_.__l.__data_;
        v60.__r_.__value_.__r.__words[2] = v38->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v60.__r_.__value_.__l.__data_ = v39;
        v38->__r_.__value_.__l.__size_ = 0;
        v38->__r_.__value_.__r.__words[2] = 0;
        v38->__r_.__value_.__r.__words[0] = 0;
        re::ecs2::Entity::debugDescription(v15, (re::DynamicString *)&v51);
        if ((v52 & 1) != 0)
          v40 = v54;
        else
          v40 = v53;
        std::string::basic_string[abi:ne180100]<0>(&v55, v40);
        if ((v57 & 0x80u) == 0)
          v41 = (const std::string::value_type *)&v55;
        else
          v41 = (const std::string::value_type *)v55;
        if ((v57 & 0x80u) == 0)
          v42 = v57;
        else
          v42 = v56;
        v43 = std::string::append(&v60, v41, v42);
        v44 = *(_OWORD *)&v43->__r_.__value_.__l.__data_;
        v61.__r_.__value_.__r.__words[2] = v43->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v61.__r_.__value_.__l.__data_ = v44;
        v43->__r_.__value_.__l.__size_ = 0;
        v43->__r_.__value_.__r.__words[2] = 0;
        v43->__r_.__value_.__r.__words[0] = 0;
        if ((v61.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v45 = &v61;
        else
          v45 = (std::string *)v61.__r_.__value_.__r.__words[0];
        if ((v61.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v46 = HIBYTE(v61.__r_.__value_.__r.__words[2]);
        else
          v46 = v61.__r_.__value_.__l.__size_;
        std::string::append(&v47, (const std::string::value_type *)v45, v46);
        if (SHIBYTE(v61.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v61.__r_.__value_.__l.__data_);
        if ((char)v57 < 0)
          operator delete(v55);
        if (v51 && (v52 & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v51 + 40))();
        if (SHIBYTE(v60.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v60.__r_.__value_.__l.__data_);
        if (SHIBYTE(v59.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v59.__r_.__value_.__l.__data_);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
    std::operator+<char>();
    if ((v50 & 0x80u) == 0)
      v17 = (const std::string::value_type *)&v48;
    else
      v17 = (const std::string::value_type *)v48;
    if ((v50 & 0x80u) == 0)
      v18 = v50;
    else
      v18 = v49;
    std::string::append(a3, v17, v18);
    if ((char)v50 < 0)
      operator delete(v48);
    if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v47.__r_.__value_.__l.__data_);
    v14 = *((_DWORD *)this + 72);
  }
  if ((v14 & 0xA) == 8)
  {
    std::string::basic_string[abi:ne180100]<0>(&v47, "");
    if (((_BYTE)this[36] & 1) == 0)
    {
      v19 = this[3];
      if (v19)
      {
        v20 = 0;
        do
        {
          v21 = v19;
          v22 = *((_DWORD *)v19 + 72);
          if ((v22 & 0x80) != 0)
            break;
          if ((v22 & 1) != 0)
          {
            std::to_string(&__p, v20);
            v25 = std::string::insert(&__p, 0, "Last parent with isActive = false is ");
            v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
            v59.__r_.__value_.__r.__words[2] = v25->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v59.__r_.__value_.__l.__data_ = v26;
            v25->__r_.__value_.__l.__size_ = 0;
            v25->__r_.__value_.__r.__words[2] = 0;
            v25->__r_.__value_.__r.__words[0] = 0;
            v27 = std::string::append(&v59, " levels up with ");
            v28 = *(_OWORD *)&v27->__r_.__value_.__l.__data_;
            v60.__r_.__value_.__r.__words[2] = v27->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v60.__r_.__value_.__l.__data_ = v28;
            v27->__r_.__value_.__l.__size_ = 0;
            v27->__r_.__value_.__r.__words[2] = 0;
            v27->__r_.__value_.__r.__words[0] = 0;
            re::ecs2::Entity::debugDescription((re::ecs2::Entity *)this, (re::DynamicString *)&v51);
            if ((v52 & 1) != 0)
              v29 = v54;
            else
              v29 = v53;
            std::string::basic_string[abi:ne180100]<0>(&v55, v29);
            if ((v57 & 0x80u) == 0)
              v30 = (const std::string::value_type *)&v55;
            else
              v30 = (const std::string::value_type *)v55;
            if ((v57 & 0x80u) == 0)
              v31 = v57;
            else
              v31 = v56;
            v32 = std::string::append(&v60, v30, v31);
            v33 = *(_OWORD *)&v32->__r_.__value_.__l.__data_;
            v61.__r_.__value_.__r.__words[2] = v32->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v61.__r_.__value_.__l.__data_ = v33;
            v32->__r_.__value_.__l.__size_ = 0;
            v32->__r_.__value_.__r.__words[2] = 0;
            v32->__r_.__value_.__r.__words[0] = 0;
            if ((v61.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v34 = &v61;
            else
              v34 = (std::string *)v61.__r_.__value_.__r.__words[0];
            if ((v61.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v35 = HIBYTE(v61.__r_.__value_.__r.__words[2]);
            else
              v35 = v61.__r_.__value_.__l.__size_;
            std::string::append(&v47, (const std::string::value_type *)v34, v35);
            if (SHIBYTE(v61.__r_.__value_.__r.__words[2]) < 0)
              operator delete(v61.__r_.__value_.__l.__data_);
            if ((char)v57 < 0)
              operator delete(v55);
            if (v51 && (v52 & 1) != 0)
              (*(void (**)(void))(*(_QWORD *)v51 + 40))();
            if (SHIBYTE(v60.__r_.__value_.__r.__words[2]) < 0)
              operator delete(v60.__r_.__value_.__l.__data_);
            if (SHIBYTE(v59.__r_.__value_.__r.__words[2]) < 0)
              operator delete(v59.__r_.__value_.__l.__data_);
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
              operator delete(__p.__r_.__value_.__l.__data_);
            goto LABEL_49;
          }
          ++v20;
          v19 = (re::audio *)*((_QWORD *)v21 + 3);
          this = (re::audio **)v21;
        }
        while (v19);
      }
      std::string::append(&v47, "No parent with isActive = true");
    }
LABEL_49:
    std::operator+<char>();
    if ((v50 & 0x80u) == 0)
      v23 = (const std::string::value_type *)&v48;
    else
      v23 = (const std::string::value_type *)v48;
    if ((v50 & 0x80u) == 0)
      v24 = v50;
    else
      v24 = v49;
    std::string::append(a3, v23, v24);
    if ((char)v50 < 0)
      operator delete(v48);
    if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v47.__r_.__value_.__l.__data_);
  }
}

void sub_225409934(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42)
{
  uint64_t v42;
  uint64_t v43;

  if (*(char *)(v43 - 57) < 0)
    operator delete(*(void **)(v43 - 80));
  if (a30 < 0)
    operator delete(__p);
  if (a21 && (a22 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)a21 + 40))();
  if (*(char *)(v43 - 89) < 0)
    operator delete(*(void **)(v43 - 112));
  if (a42 < 0)
    operator delete(a37);
  if (a36 < 0)
    operator delete(a31);
  if (a14 < 0)
    operator delete(a9);
  if (*(char *)(v42 + 23) < 0)
    operator delete(*(void **)v42);
  _Unwind_Resume(exception_object);
}

__n128 re::audio::cleanUpTransformForPHASE@<Q0>(float32x4_t *a1@<X0>, double *a2@<X4>, double *a3@<X5>, double *a4@<X6>, uint64_t a5@<X8>)
{
  float32x4_t v6;
  float32x4_t v7;
  float32x4_t v8;
  float32x4_t v9;
  float32x4_t v10;
  int32x2_t v11;
  float32x4_t v12;
  int32x2_t v13;
  float32x4_t v14;
  float32x4_t v15;
  __n128 result;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  int8x8_t v21;
  uint64_t v22;
  int32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  __int128 v30;
  __int128 v31;
  re *v32;
  uint64_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  NSObject *v37;
  float32x4_t v38;
  float32x4_t v39;
  void *v40;
  float32x4_t v41;
  __int32 v42;
  __int32 v43;
  float32x4_t v44;
  __int128 v45;
  int32x4_t v46;
  int32x4_t v47;
  int32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  __n128 v52;
  float32x4_t v53;
  float32x4_t v54;
  int32x4_t v55;
  int32x4_t v56;
  int32x4_t v57;
  uint8_t buf[16];
  float32x4_t v59;
  float32x4_t v60;
  uint64_t v61;

  v61 = *MEMORY[0x24BDAC8D0];
  v7 = *a1;
  v6 = a1[1];
  v9 = a1[2];
  v8 = a1[3];
  v10 = vmulq_f32(v7, v7);
  v11 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v10, 2), vaddq_f32(v10, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v10.f32, 1))).u64[0];
  *(float *)v11.i32 = sqrtf(*(float *)v11.i32);
  if (*(float *)v11.i32 == 0.0
    || (v12 = vmulq_f32(v6, v6),
        v13 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 2), vaddq_f32(v12, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 1))).u64[0], *(float *)v13.i32 = sqrtf(*(float *)v13.i32), *(float *)v13.i32 == 0.0)|| (v14 = vmulq_f32(v9, v9), v15 = vaddq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 1)), v15.f32[0] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 2), v15).f32[0]), v15.f32[0] == 0.0))
  {
    result.n128_u64[0] = 1065353216;
    result.n128_u32[2] = 0;
    result.n128_u32[3] = HIDWORD(*(unsigned __int128 *)a1);
    *(_QWORD *)&v30 = 0x3F80000000000000;
    DWORD2(v30) = 0;
    HIDWORD(v30) = HIDWORD(*(_OWORD *)&a1[1]);
    *(_QWORD *)&v31 = 0;
    *((_QWORD *)&v31 + 1) = __PAIR64__(v9.u32[3], 1.0);
    *(__n128 *)a5 = result;
    *(_OWORD *)(a5 + 16) = v30;
    *(_OWORD *)(a5 + 32) = v31;
LABEL_18:
    *(float32x4_t *)(a5 + 48) = v8;
    return result;
  }
  result = (__n128)vdivq_f32(v7, (float32x4_t)vdupq_lane_s32(v11, 0));
  v18 = vdivq_f32(v6, (float32x4_t)vdupq_lane_s32(v13, 0));
  v52 = result;
  v53 = v18;
  v19 = vdivq_f32(v9, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v15.f32, 0));
  v20 = vmulq_f32((float32x4_t)result, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v19, (int8x16_t)v19, 0xCuLL), (int8x16_t)v19, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v18, (int32x4_t)v18), (int8x16_t)v18, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v19, (int32x4_t)v19), (int8x16_t)v19, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v18, (int8x16_t)v18, 0xCuLL), (int8x16_t)v18, 8uLL)));
  v54 = v19;
  if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v20, 2), vaddq_f32(v20, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v20.f32, 1))).f32[0] < 0.0)
  {
    v18 = vnegq_f32(v18);
    v53 = v18;
  }
  v21 = (int8x8_t)vextq_s8((int8x16_t)v18, (int8x16_t)v18, 4uLL).u64[0];
  v22 = 0;
  v23 = vzip1q_s32((int32x4_t)result, (int32x4_t)v19);
  v55 = vzip1q_s32(v23, (int32x4_t)v18);
  v56 = vzip2q_s32(v23, vdupq_lane_s32(*(int32x2_t *)v18.f32, 1));
  v57 = vzip1q_s32(vzip2q_s32((int32x4_t)result, (int32x4_t)v19), vdupq_laneq_s32((int32x4_t)v18, 2));
  do
  {
    *(float32x4_t *)&buf[v22] = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)result, COERCE_FLOAT(*(_OWORD *)((char *)&v55 + v22))), v18, *(float32x2_t *)&v55.i8[v22], 1), v19, *(float32x4_t *)((char *)&v55 + v22), 2);
    v22 += 16;
  }
  while (v22 != 48);
  v24 = *(float32x4_t *)buf;
  v24.i32[0] = 0;
  v25 = vmulq_f32(v24, v24);
  if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v25, 2), vaddq_f32(v25, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v25.f32, 1))).f32[0]) < 1.0e-10)
  {
    v26 = v59;
    v26.i32[1] = 0;
    v27 = vmulq_f32(v26, v26);
    if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v27, 2), vaddq_f32(v27, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v27.f32, 1))).f32[0]) < 1.0e-10)
    {
      v28 = v60;
      v28.i32[2] = 0;
      v29 = vmulq_f32(v28, v28);
      if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v29, 2), vaddq_f32(v29, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v29.f32, 1))).f32[0]) < 1.0e-10)
      {
        v19.i32[3] = result.n128_i32[2];
LABEL_17:
        result.n128_u64[1] = __PAIR64__(vextq_s8(*(int8x16_t *)&v7, *(int8x16_t *)&v7, 8uLL).u32[1], v19.u32[3]);
        v6.i64[0] = __PAIR64__(v21.u32[0], v18.u32[0]);
        v6.i32[2] = v21.i32[1];
        v19.i32[3] = v9.i32[3];
        *(__n128 *)a5 = result;
        *(float32x4_t *)(a5 + 16) = v6;
        *(float32x4_t *)(a5 + 32) = v19;
        goto LABEL_18;
      }
    }
  }
  v41 = v7;
  v42 = v6.i32[3];
  v43 = v9.i32[3];
  v44 = v8;
  v50 = 0u;
  v51 = 0u;
  v48 = 0u;
  v49 = 0u;
  v46 = 0u;
  v47 = 0u;
  v45 = 0u;
  re::computeSVD3x3((float32x2_t *)&v52, &v49, &v45, &v46, a2, a3, a4);
  if ((v32 & 1) != 0)
  {
    v33 = 0;
    v34 = v49;
    v35 = v50;
    v36 = v51;
    v55 = v46;
    v56 = v47;
    v57 = v48;
    do
    {
      *(float32x4_t *)&buf[v33] = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v34, COERCE_FLOAT(*(_OWORD *)((char *)&v55 + v33))), v35, *(float32x2_t *)&v55.i8[v33], 1), v36, *(float32x4_t *)((char *)&v55 + v33), 2);
      v33 += 16;
    }
    while (v33 != 48);
    result.n128_u64[0] = *(_QWORD *)buf;
    v18 = v59;
    v19 = v60;
    v19.i32[3] = *(_DWORD *)&buf[8];
    v21 = vext_s8(*(int8x8_t *)v59.f32, (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v18, (int8x16_t)v18, 8uLL), 4uLL);
    v9.i32[3] = v43;
    v8 = v44;
    v7 = v41;
    v6.i32[3] = v42;
    goto LABEL_17;
  }
  v37 = (id)*re::audioLogObjects(v32);
  if (os_log_type_enabled(v37, OS_LOG_TYPE_FAULT))
  {
    re::audio::matrix3x3_to_string((float *)&v52);
    v40 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 138412290;
    *(_QWORD *)&buf[4] = v40;
    _os_log_fault_impl(&dword_224FE9000, v37, OS_LOG_TYPE_FAULT, "cleanUpTransformForPHASE() Invalid transformation submatrix:\n%@", buf, 0xCu);

  }
  v38 = a1[1];
  *(float32x4_t *)a5 = *a1;
  *(float32x4_t *)(a5 + 16) = v38;
  result = (__n128)a1[2];
  v39 = a1[3];
  *(__n128 *)(a5 + 32) = result;
  *(float32x4_t *)(a5 + 48) = v39;
  return result;
}

void sub_225409E64(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t re::audio::layoutTagFromFormat(re::audio *this, AVAudioFormat *a2)
{
  re::audio *v2;
  void *v3;
  void *v4;
  uint64_t v5;
  re *v6;
  int v7;
  NSObject *v8;
  uint8_t v10[16];

  v2 = this;
  -[re::audio channelLayout](v2, "channelLayout");
  v3 = (void *)objc_claimAutoreleasedReturnValue();

  if (v3)
  {
    -[re::audio channelLayout](v2, "channelLayout");
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    v5 = objc_msgSend(v4, "layoutTag");

  }
  else
  {
    v6 = (re *)-[re::audio channelCount](v2, "channelCount");
    v7 = (int)v6;
    if (v6 >= 3)
    {
      v8 = *re::audioLogObjects(v6);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)v10 = 0;
        _os_log_error_impl(&dword_224FE9000, v8, OS_LOG_TYPE_ERROR, "AudioFileAsset layout tag was not set, but audio has >2 channels. Folding audio to mono!", v10, 2u);
      }
      v5 = v7 | 0x930000u;
    }
    else
    {
      v5 = dword_2260FFF70[(int)v6];
    }
  }

  return v5;
}

void sub_225409F58(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

CFBundleRef REAudioCopyTestDataBundle(void)
{
  void *v0;
  void *v1;
  id v2;
  void (**v3)(void *, const __CFString *);
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  id v9;
  uint64_t v10;
  uint64_t v11;
  const __CFAllocator *v12;
  uint64_t v13;
  const __CFURL *v14;
  CFBundleRef v15;
  id v17;
  void *v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  uint8_t v23[12];
  uint32_t bufsize;
  _QWORD aBlock[4];
  id v26;
  id v27;
  char v28[128];
  char buf[1024];
  uint64_t v30;

  v30 = *MEMORY[0x24BDAC8D0];
  objc_msgSend(MEMORY[0x24BDBCEB8], "array");
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x24BDD1760], "processInfo");
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "environment");
  v1 = (void *)objc_claimAutoreleasedReturnValue();

  aBlock[0] = MEMORY[0x24BDAC760];
  aBlock[1] = 3221225472;
  aBlock[2] = ___Z25REAudioCopyTestDataBundlev_block_invoke;
  aBlock[3] = &unk_24ED3DCE8;
  v17 = v1;
  v26 = v17;
  v2 = v18;
  v27 = v2;
  v3 = (void (**)(void *, const __CFString *))_Block_copy(aBlock);
  v3[2](v3, CFSTR("__XCODE_BUILT_PRODUCTS_DIR_PATHS"));
  v3[2](v3, CFSTR("DYLD_FRAMEWORK_PATH"));
  bufsize = 1023;
  if (_NSGetExecutablePath(buf, &bufsize))
  {
    if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v23 = 0;
      _os_log_error_impl(&dword_224FE9000, MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR, "Failed to get current executable path", v23, 2u);
    }
  }
  else
  {
    buf[bufsize] = 0;
    v4 = (void *)MEMORY[0x24BDBCF48];
    objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", buf);
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v4, "fileURLWithPath:", v5);
    v6 = (void *)objc_claimAutoreleasedReturnValue();

    objc_msgSend(v6, "URLByDeletingLastPathComponent");
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v2, "addObject:", v7);

  }
  objc_msgSend(MEMORY[0x24BDBCF48], "fileURLWithPath:", CFSTR("/AppleInternal/Library/Bundles"));
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "addObject:", v8);

  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  v9 = v2;
  v10 = objc_msgSend(v9, "countByEnumeratingWithState:objects:count:", &v19, v28, 16);
  if (v10)
  {
    v11 = *(_QWORD *)v20;
    v12 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
    while (2)
    {
      v13 = 0;
      do
      {
        if (*(_QWORD *)v20 != v11)
          objc_enumerationMutation(v9);
        objc_msgSend(*(id *)(*((_QWORD *)&v19 + 1) + 8 * v13), "URLByAppendingPathComponent:", CFSTR("REAudioTestData.bundle"));
        v14 = (const __CFURL *)objc_claimAutoreleasedReturnValue();
        v15 = CFBundleCreate(v12, v14);

        if (v15)
        {

          goto LABEL_17;
        }
        ++v13;
      }
      while (v10 != v13);
      v10 = objc_msgSend(v9, "countByEnumeratingWithState:objects:count:", &v19, v28, 16);
      if (v10)
        continue;
      break;
    }
  }

  if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)v23 = 0;
    _os_log_error_impl(&dword_224FE9000, MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR, "Failed to load REAudioTestData.bundle", v23, 2u);
  }
  v15 = 0;
LABEL_17:

  return v15;
}

void sub_22540A2BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _Unwind_Exception *exception_object, void *a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,void *a28)
{
  void *v28;
  void *v29;
  void *v30;

  _Unwind_Resume(a1);
}

void ___Z25REAudioCopyTestDataBundlev_block_invoke(uint64_t a1, uint64_t a2)
{
  void *v3;
  void *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  void *v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  _BYTE v15[128];
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  objc_msgSend(*(id *)(a1 + 32), "objectForKey:", a2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v4 = v3;
  if (v3)
  {
    v13 = 0u;
    v14 = 0u;
    v11 = 0u;
    v12 = 0u;
    objc_msgSend(v3, "componentsSeparatedByString:", CFSTR(":"), 0);
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    v6 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v11, v15, 16);
    if (v6)
    {
      v7 = *(_QWORD *)v12;
      do
      {
        v8 = 0;
        do
        {
          if (*(_QWORD *)v12 != v7)
            objc_enumerationMutation(v5);
          v9 = *(void **)(a1 + 40);
          objc_msgSend(MEMORY[0x24BDBCF48], "fileURLWithPath:", *(_QWORD *)(*((_QWORD *)&v11 + 1) + 8 * v8));
          v10 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v9, "addObject:", v10);

          ++v8;
        }
        while (v6 != v8);
        v6 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v11, v15, 16);
      }
      while (v6);
    }

  }
}

void sub_22540A4AC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

CFBundleRef REAudioCopyTestDataBundleNextTo(CFURLRef url)
{
  const __CFAllocator *v1;
  const __CFURL *PathComponent;
  const __CFURL *v3;
  CFBundleRef v4;
  int v6;
  const __CFURL *v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v1 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  PathComponent = CFURLCreateCopyDeletingLastPathComponent((CFAllocatorRef)*MEMORY[0x24BDBD240], url);
  v3 = CFURLCreateCopyAppendingPathComponent(v1, PathComponent, CFSTR("REAudioTestData.bundle"), 1u);
  v4 = CFBundleCreate(v1, v3);
  if (!v4 && os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
  {
    v6 = 138412290;
    v7 = v3;
    _os_log_error_impl(&dword_224FE9000, MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR, "Failed to load REAudioTestData.bundle from %@", (uint8_t *)&v6, 0xCu);
  }
  CFRelease(v3);
  CFRelease(PathComponent);
  return v4;
}

uint64_t REAudioShouldRedactSensitiveInfoFromLogs(void)
{
  if (qword_254105850 != -1)
    dispatch_once(&qword_254105850, &__block_literal_global_59);
  return _MergedGlobals_119;
}

void ___Z40REAudioShouldRedactSensitiveInfoFromLogsv_block_invoke()
{
  __SecTask *v0;
  __SecTask *v1;
  void *v2;
  char v3;
  CFTypeRef v4;
  id v5;
  NSObject *v6;
  CFTypeRef cf[2];

  cf[1] = *(CFTypeRef *)MEMORY[0x24BDAC8D0];
  v0 = SecTaskCreateFromSelf(0);
  if (v0)
  {
    v1 = v0;
    cf[0] = 0;
    v2 = (void *)SecTaskCopyValueForEntitlement(v0, CFSTR("com.apple.re.should-redact-sensitive-info-from-logs"), (CFErrorRef *)cf);
    v3 = 0;
    v4 = cf[0];
    if (v2 && !cf[0])
    {
      v5 = v2;
      if ((objc_opt_respondsToSelector() & 1) != 0)
        v3 = objc_msgSend(v5, "BOOLValue");
      else
        v3 = 0;

      v4 = cf[0];
    }
    if (v4)
      CFRelease(v4);
    if (v2)
      CFRelease(v2);
    CFRelease(v1);
  }
  else
  {
    v3 = 0;
  }
  _MergedGlobals_119 = v3;
  v6 = *re::audioLogObjects(v0);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(cf[0]) = 67109120;
    HIDWORD(cf[0]) = _MergedGlobals_119;
    _os_log_impl(&dword_224FE9000, v6, OS_LOG_TYPE_DEFAULT, "Entitlement shouldRedactSensitiveInfoFromLogs set %d.", (uint8_t *)cf, 8u);
  }
}

void sub_22540A764(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t REAudioEnableAudioEngineRunnableAutomationSupport(void)
{
  if (qword_254105858 != -1)
    dispatch_once(&qword_254105858, &__block_literal_global_62);
  return byte_254105849;
}

void ___Z49REAudioEnableAudioEngineRunnableAutomationSupportv_block_invoke()
{
  void *v0;
  void *v1;
  uint64_t v2;
  NSObject *v3;
  _DWORD v4[2];
  uint64_t v5;

  v5 = *MEMORY[0x24BDAC8D0];
  objc_msgSend(MEMORY[0x24BDBCF50], "standardUserDefaults");
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "objectForKey:", CFSTR("com.apple.re.enableAudioEngineRunnableAutomation"));
  v1 = (void *)objc_claimAutoreleasedReturnValue();

  if (v1)
  {
    v2 = objc_opt_respondsToSelector();
    if ((v2 & 1) != 0)
    {
      v2 = objc_msgSend(v1, "BOOLValue");
      byte_254105849 = v2;
    }
  }
  v3 = *re::audioLogObjects((re *)v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4[0] = 67109120;
    v4[1] = byte_254105849;
    _os_log_impl(&dword_224FE9000, v3, OS_LOG_TYPE_DEFAULT, "[RE] [Sleep/Wake] User Defaults set enableAudioEngineRunnableAutomationSupport=%d", (uint8_t *)v4, 8u);
  }

}

void sub_22540A8B4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t REAudioShouldConfigureTuningForSTSLabels(void)
{
  if (REAudioShouldConfigureTuningForSTSLabels(void)::onceToken != -1)
    dispatch_once(&REAudioShouldConfigureTuningForSTSLabels(void)::onceToken, &__block_literal_global_66);
  return g_shouldConfigureTuningForSTSLabels;
}

void ___Z40REAudioShouldConfigureTuningForSTSLabelsv_block_invoke()
{
  void *v0;
  void *v1;
  uint64_t v2;
  NSObject *v3;
  _DWORD v4[2];
  uint64_t v5;

  v5 = *MEMORY[0x24BDAC8D0];
  objc_msgSend(MEMORY[0x24BDBCF50], "standardUserDefaults");
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "objectForKey:", CFSTR("com.apple.re.shouldConfigureTuningForSTSLabels"));
  v1 = (void *)objc_claimAutoreleasedReturnValue();

  if (v1)
  {
    v2 = objc_opt_respondsToSelector();
    if ((v2 & 1) != 0)
    {
      v2 = objc_msgSend(v1, "BOOLValue");
      g_shouldConfigureTuningForSTSLabels = v2;
    }
  }
  v3 = *re::audioLogObjects((re *)v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4[0] = 67109120;
    v4[1] = g_shouldConfigureTuningForSTSLabels;
    _os_log_impl(&dword_224FE9000, v3, OS_LOG_TYPE_DEFAULT, "REAudioShouldConfigureTuningForSTSLabels=%d", (uint8_t *)v4, 8u);
  }

}

void sub_22540AA0C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t REAudioEngineShutdownTimerLength(void)
{
  if (REAudioEngineShutdownTimerLength(void)::onceToken != -1)
    dispatch_once(&REAudioEngineShutdownTimerLength(void)::onceToken, &__block_literal_global_69);
  return REAudioEngineShutdownTimerLength(void)::audioEngineShutdownTimerLengthFrames;
}

void ___Z32REAudioEngineShutdownTimerLengthv_block_invoke()
{
  void *v0;
  void *v1;
  uint64_t v2;
  NSObject *v3;
  int v4;
  uint64_t v5;
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  objc_msgSend(MEMORY[0x24BDBCF50], "standardUserDefaults");
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "objectForKey:", CFSTR("com.apple.re.audioEngineShutdownTimerLengthFrames"));
  v1 = (void *)objc_claimAutoreleasedReturnValue();

  v2 = objc_opt_respondsToSelector();
  if ((v2 & 1) != 0)
  {
    v2 = objc_msgSend(v1, "intValue");
    REAudioEngineShutdownTimerLength(void)::audioEngineShutdownTimerLengthFrames = (int)v2;
  }
  v3 = *re::audioLogObjects((re *)v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = 134217984;
    v5 = REAudioEngineShutdownTimerLength(void)::audioEngineShutdownTimerLengthFrames;
    _os_log_impl(&dword_224FE9000, v3, OS_LOG_TYPE_DEFAULT, "audioEngineShutdownTimerLengthFrames=%llu", (uint8_t *)&v4, 0xCu);
  }

}

void sub_22540AB64(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  v2 = v1;

  _Unwind_Resume(a1);
}

void REAudioComputePHASEMixGroupID(unint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, std::string *a4@<X8>)
{
  std::string *v7;
  __int128 v8;
  std::string *p_p;
  std::string::size_type size;
  std::string *v11;
  __int128 v12;
  std::string *v13;
  __int128 v14;
  int v15;
  const std::string::value_type *v16;
  std::string::size_type v17;
  std::string *v18;
  std::string __p;
  std::string v20;
  std::string v21;
  std::string v22;
  std::string v23;

  std::to_string(&v20, a1);
  v7 = std::string::append(&v20, "-");
  v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
  v21.__r_.__value_.__r.__words[2] = v7->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v21.__r_.__value_.__l.__data_ = v8;
  v7->__r_.__value_.__l.__size_ = 0;
  v7->__r_.__value_.__r.__words[2] = 0;
  v7->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&__p, a2);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  else
    size = __p.__r_.__value_.__l.__size_;
  v11 = std::string::append(&v21, (const std::string::value_type *)p_p, size);
  v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
  v22.__r_.__value_.__r.__words[2] = v11->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v22.__r_.__value_.__l.__data_ = v12;
  v11->__r_.__value_.__l.__size_ = 0;
  v11->__r_.__value_.__r.__words[2] = 0;
  v11->__r_.__value_.__r.__words[0] = 0;
  v13 = std::string::append(&v22, "-");
  v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
  v23.__r_.__value_.__r.__words[2] = v13->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v23.__r_.__value_.__l.__data_ = v14;
  v13->__r_.__value_.__l.__size_ = 0;
  v13->__r_.__value_.__r.__words[2] = 0;
  v13->__r_.__value_.__r.__words[0] = 0;
  v15 = *(char *)(a3 + 23);
  if (v15 >= 0)
    v16 = (const std::string::value_type *)a3;
  else
    v16 = *(const std::string::value_type **)a3;
  if (v15 >= 0)
    v17 = *(unsigned __int8 *)(a3 + 23);
  else
    v17 = *(_QWORD *)(a3 + 8);
  v18 = std::string::append(&v23, v16, v17);
  *a4 = *v18;
  v18->__r_.__value_.__l.__size_ = 0;
  v18->__r_.__value_.__r.__words[2] = 0;
  v18->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v23.__r_.__value_.__l.__data_);
  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v22.__r_.__value_.__l.__data_);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v21.__r_.__value_.__l.__data_);
  if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v20.__r_.__value_.__l.__data_);
}

void sub_22540ACE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  uint64_t v33;

  if (*(char *)(v33 - 41) < 0)
    operator delete(*(void **)(v33 - 64));
  if (a33 < 0)
    operator delete(__p);
  if (a14 < 0)
    operator delete(a9);
  if (a26 < 0)
    operator delete(a21);
  if (a20 < 0)
    operator delete(a15);
  _Unwind_Resume(exception_object);
}

unint64_t re::audio::pcmBufferSize(re::audio *this, AVAudioPCMBuffer *a2)
{
  re::audio *v2;
  unsigned int v3;
  void *v4;
  unint64_t v5;

  v2 = this;
  v3 = -[re::audio frameCapacity](v2, "frameCapacity");
  -[re::audio format](v2, "format");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v5 = *(unsigned int *)(objc_msgSend(v4, "streamDescription") + 24) * (unint64_t)v3;

  return v5;
}

void sub_22540ADB4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void std::__tree<std::__value_type<double,std::string>,std::__map_value_compare<double,std::__value_type<double,std::string>,std::less<double>,true>,std::allocator<std::__value_type<double,std::string>>>::destroy(uint64_t a1, char *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<double,std::string>,std::__map_value_compare<double,std::__value_type<double,std::string>,std::less<double>,true>,std::allocator<std::__value_type<double,std::string>>>::destroy(a1, *(_QWORD *)a2);
    std::__tree<std::__value_type<double,std::string>,std::__map_value_compare<double,std::__value_type<double,std::string>,std::less<double>,true>,std::allocator<std::__value_type<double,std::string>>>::destroy(a1, *((_QWORD *)a2 + 1));
    if (a2[63] < 0)
      operator delete(*((void **)a2 + 5));
    operator delete(a2);
  }
}

uint64_t *std::__tree<std::__value_type<double,std::string>,std::__map_value_compare<double,std::__value_type<double,std::string>,std::less<double>,true>,std::allocator<std::__value_type<double,std::string>>>::__emplace_unique_key_args<double,std::piecewise_construct_t const&,std::tuple<double const&>,std::tuple<>>(uint64_t **a1, double *a2, uint64_t a3, uint64_t **a4)
{
  uint64_t *v6;
  uint64_t **v7;
  double v8;
  uint64_t **v9;
  double v10;
  uint64_t *v11;

  v7 = a1 + 1;
  v6 = a1[1];
  if (v6)
  {
    v8 = *a2;
    while (1)
    {
      while (1)
      {
        v9 = (uint64_t **)v6;
        v10 = *((double *)v6 + 4);
        if (v8 >= v10)
          break;
        v6 = (uint64_t *)*v6;
        v7 = v9;
        if (!*v9)
          goto LABEL_10;
      }
      if (v10 >= v8)
        break;
      v6 = (uint64_t *)v6[1];
      if (!v6)
      {
        v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    v9 = a1 + 1;
LABEL_10:
    v11 = (uint64_t *)operator new(0x40uLL);
    v11[4] = **a4;
    v11[6] = 0;
    v11[7] = 0;
    v11[5] = 0;
    std::__tree<std::__value_type<double,std::string>,std::__map_value_compare<double,std::__value_type<double,std::string>,std::less<double>,true>,std::allocator<std::__value_type<double,std::string>>>::__insert_node_at(a1, (uint64_t)v9, v7, v11);
    return v11;
  }
  return (uint64_t *)v9;
}

uint64_t *std::__tree<std::__value_type<double,std::string>,std::__map_value_compare<double,std::__value_type<double,std::string>,std::less<double>,true>,std::allocator<std::__value_type<double,std::string>>>::__insert_node_at(uint64_t **a1, uint64_t a2, uint64_t **a3, uint64_t *a4)
{
  uint64_t *v5;
  uint64_t *result;

  *a4 = 0;
  a4[1] = 0;
  a4[2] = a2;
  *a3 = a4;
  v5 = (uint64_t *)**a1;
  if (v5)
  {
    *a1 = v5;
    a4 = *a3;
  }
  result = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], a4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

uint64_t *std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t *v4;
  _BYTE *v5;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t **v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  *((_BYTE *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      v2 = (uint64_t *)a2[2];
      if (*((_BYTE *)v2 + 24))
        return result;
      v3 = (uint64_t *)v2[2];
      v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        v7 = v3[1];
        if (!v7 || (v8 = *(unsigned __int8 *)(v7 + 24), v5 = (_BYTE *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            v9 = (uint64_t **)a2[2];
          }
          else
          {
            v9 = (uint64_t **)v2[1];
            v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              v10[2] = (uint64_t)v2;
              v3 = (uint64_t *)v2[2];
            }
            v9[2] = v3;
            *(_QWORD *)(v2[2] + 8 * (*(_QWORD *)v2[2] != (_QWORD)v2)) = v9;
            *v9 = v2;
            v2[2] = (uint64_t)v9;
            v3 = v9[2];
            v2 = (uint64_t *)*v3;
          }
          *((_BYTE *)v9 + 24) = 1;
          *((_BYTE *)v3 + 24) = 0;
          v13 = v2[1];
          *v3 = v13;
          if (v13)
            *(_QWORD *)(v13 + 16) = v3;
          v2[2] = v3[2];
          *(_QWORD *)(v3[2] + 8 * (*(_QWORD *)v3[2] != (_QWORD)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }
      else if (!v4 || (v6 = *((unsigned __int8 *)v4 + 24), v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          v11 = a2[1];
          *v2 = v11;
          if (v11)
          {
            *(_QWORD *)(v11 + 16) = v2;
            v3 = (uint64_t *)v2[2];
          }
          a2[2] = (uint64_t)v3;
          *(_QWORD *)(v2[2] + 8 * (*(_QWORD *)v2[2] != (_QWORD)v2)) = a2;
          a2[1] = (uint64_t)v2;
          v2[2] = (uint64_t)a2;
          v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((_BYTE *)a2 + 24) = 1;
        *((_BYTE *)v3 + 24) = 0;
        v2 = (uint64_t *)v3[1];
        v12 = *v2;
        v3[1] = *v2;
        if (v12)
          *(_QWORD *)(v12 + 16) = v3;
        v2[2] = v3[2];
        *(_QWORD *)(v3[2] + 8 * (*(_QWORD *)v3[2] != (_QWORD)v3)) = v2;
        *v2 = (uint64_t)v3;
LABEL_27:
        v3[2] = (uint64_t)v2;
        return result;
      }
      *((_BYTE *)v2 + 24) = 1;
      a2 = v3;
      *((_BYTE *)v3 + 24) = v3 == result;
      *v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

void std::__hash_table<std::__hash_value_type<std::string,double>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,double>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,double>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,double>>>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t i;

  if (*(_QWORD *)(a1 + 24))
  {
    std::__hash_table<std::__hash_value_type<std::string,double>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,double>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,double>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,double>>>::__deallocate_node(a1, *(void ***)(a1 + 16));
    *(_QWORD *)(a1 + 16) = 0;
    v2 = *(_QWORD *)(a1 + 8);
    if (v2)
    {
      for (i = 0; i != v2; ++i)
        *(_QWORD *)(*(_QWORD *)a1 + 8 * i) = 0;
    }
    *(_QWORD *)(a1 + 24) = 0;
  }
}

void std::__hash_table<std::__hash_value_type<std::string,double>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,double>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,double>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,double>>>::__deallocate_node(int a1, void **__p)
{
  void **v2;
  void **v3;

  if (__p)
  {
    v2 = __p;
    do
    {
      v3 = (void **)*v2;
      if (*((char *)v2 + 39) < 0)
        operator delete(v2[2]);
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,double>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,double>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,double>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,double>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1, unsigned __int8 *a2, uint64_t a3, __int128 **a4)
{
  unint64_t v4;
  _QWORD *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint8x8_t v12;
  unint64_t v13;
  unsigned __int8 **v14;
  unsigned __int8 *i;
  unint64_t v16;
  float v17;
  float v18;
  _BOOL8 v19;
  unint64_t v20;
  unint64_t v21;
  size_t v22;
  _QWORD *v23;
  unint64_t v24;
  _QWORD v26[3];

  v8 = (_QWORD *)(a1 + 24);
  v9 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  v10 = v9;
  v11 = *(_QWORD *)(a1 + 8);
  if (v11)
  {
    v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    v13 = v12.u32[0];
    if (v12.u32[0] > 1uLL)
    {
      v4 = v9;
      if (v9 >= v11)
        v4 = v9 % v11;
    }
    else
    {
      v4 = (v11 - 1) & v9;
    }
    v14 = *(unsigned __int8 ***)(*(_QWORD *)a1 + 8 * v4);
    if (v14)
    {
      for (i = *v14; i; i = *(unsigned __int8 **)i)
      {
        v16 = *((_QWORD *)i + 1);
        if (v16 == v10)
        {
          if ((std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v13 > 1)
          {
            if (v16 >= v11)
              v16 %= v11;
          }
          else
          {
            v16 &= v11 - 1;
          }
          if (v16 != v4)
            break;
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<std::string,double>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,double>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,double>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,double>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a1, v10, a4, (uint64_t)v26);
  v17 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v18 = *(float *)(a1 + 32);
  if (!v11 || (float)(v18 * (float)v11) < v17)
  {
    v19 = 1;
    if (v11 >= 3)
      v19 = (v11 & (v11 - 1)) != 0;
    v20 = v19 | (2 * v11);
    v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21)
      v22 = v21;
    else
      v22 = v20;
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a1, v22);
    v11 = *(_QWORD *)(a1 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11)
        v4 = v10 % v11;
      else
        v4 = v10;
    }
    else
    {
      v4 = (v11 - 1) & v10;
    }
  }
  v23 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v23)
  {
    *(_QWORD *)v26[0] = *v23;
    *v23 = v26[0];
  }
  else
  {
    *(_QWORD *)v26[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v26[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v4) = a1 + 16;
    if (*(_QWORD *)v26[0])
    {
      v24 = *(_QWORD *)(*(_QWORD *)v26[0] + 8);
      if ((v11 & (v11 - 1)) != 0)
      {
        if (v24 >= v11)
          v24 %= v11;
      }
      else
      {
        v24 &= v11 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v24) = v26[0];
    }
  }
  i = (unsigned __int8 *)v26[0];
  ++*v8;
  return i;
}

void sub_22540B3D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void **__p, uint64_t a13, char a14)
{
  if (__p)
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,double>,void *>>>::operator()[abi:ne180100](a14, __p);
  _Unwind_Resume(exception_object);
}

void std::__hash_table<std::__hash_value_type<std::string,double>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,double>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,double>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,double>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1@<X0>, uint64_t a2@<X1>, __int128 **a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7;
  _QWORD *v8;
  std::string *v9;
  __int128 *v10;
  __int128 v11;

  v7 = a1 + 16;
  v8 = operator new(0x30uLL);
  *(_QWORD *)a4 = v8;
  *(_QWORD *)(a4 + 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  *v8 = 0;
  v8[1] = a2;
  v9 = (std::string *)(v8 + 2);
  v10 = *a3;
  if (*((char *)*a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v9, *(const std::string::value_type **)v10, *((_QWORD *)v10 + 1));
  }
  else
  {
    v11 = *v10;
    v8[4] = *((_QWORD *)v10 + 2);
    *(_OWORD *)&v9->__r_.__value_.__l.__data_ = v11;
  }
  v8[5] = 0;
  *(_BYTE *)(a4 + 16) = 1;
}

void sub_22540B47C(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void **v2;

  *v1 = 0;
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,double>,void *>>>::operator()[abi:ne180100](0, v2);
  _Unwind_Resume(a1);
}

unint64_t std::__string_hash<char>::operator()[abi:ne180100](uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  char v5;

  v2 = *(_QWORD *)(a2 + 8);
  if (*(char *)(a2 + 23) >= 0)
  {
    v3 = *(unsigned __int8 *)(a2 + 23);
  }
  else
  {
    a2 = *(_QWORD *)a2;
    v3 = v2;
  }
  return std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t)&v5, (uint64_t *)a2, v3);
}

uint64_t std::equal_to<std::string>::operator()[abi:ne180100](uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  unsigned __int8 *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  int v12;
  BOOL v14;
  uint64_t result;

  v3 = a3;
  v4 = a2[23];
  if ((v4 & 0x80u) == 0)
    v5 = a2[23];
  else
    v5 = *((_QWORD *)a2 + 1);
  v6 = a3[23];
  v7 = (char)v6;
  if ((v6 & 0x80u) != 0)
    v6 = *((_QWORD *)a3 + 1);
  if (v5 != v6)
    return 0;
  if (v7 < 0)
    v3 = *(unsigned __int8 **)a3;
  if ((v4 & 0x80) != 0)
    return memcmp(*(const void **)a2, v3, *((_QWORD *)a2 + 1)) == 0;
  if (!a2[23])
    return 1;
  v8 = v4 - 1;
  do
  {
    v10 = *a2++;
    v9 = v10;
    v12 = *v3++;
    v11 = v12;
    v14 = v8-- != 0;
    result = v9 == v11;
  }
  while (v9 == v11 && v14);
  return result;
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,double>,void *>>>::operator()[abi:ne180100](char a1, void **__p)
{
  if (a1)
  {
    if (*((char *)__p + 39) < 0)
      operator delete(__p[2]);
  }
  else if (!__p)
  {
    return;
  }
  operator delete(__p);
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,double>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,double>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,double>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,double>>>::find<std::string>(_QWORD *a1, unsigned __int8 *a2)
{
  unint64_t v4;
  int8x8_t v5;
  unint64_t v6;
  uint8x8_t v7;
  unint64_t v8;
  unint64_t v9;
  unsigned __int8 **v10;
  unsigned __int8 *v11;
  uint64_t v12;
  unint64_t v13;

  v4 = std::__string_hash<char>::operator()[abi:ne180100]((uint64_t)(a1 + 3), (uint64_t)a2);
  v5 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v5)
    return 0;
  v6 = v4;
  v7 = (uint8x8_t)vcnt_s8(v5);
  v7.i16[0] = vaddlv_u8(v7);
  v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    v9 = v4;
    if (v4 >= *(_QWORD *)&v5)
      v9 = v4 % *(_QWORD *)&v5;
  }
  else
  {
    v9 = (*(_QWORD *)&v5 - 1) & v4;
  }
  v10 = *(unsigned __int8 ***)(*a1 + 8 * v9);
  if (!v10)
    return 0;
  v11 = *v10;
  if (*v10)
  {
    v12 = (uint64_t)(a1 + 4);
    do
    {
      v13 = *((_QWORD *)v11 + 1);
      if (v13 == v6)
      {
        if ((std::equal_to<std::string>::operator()[abi:ne180100](v12, v11 + 16, a2) & 1) != 0)
          return v11;
      }
      else
      {
        if (v8 > 1)
        {
          if (v13 >= *(_QWORD *)&v5)
            v13 %= *(_QWORD *)&v5;
        }
        else
        {
          v13 &= *(_QWORD *)&v5 - 1;
        }
        if (v13 != v9)
          return 0;
      }
      v11 = *(unsigned __int8 **)v11;
    }
    while (v11);
  }
  return v11;
}

void std::__shared_ptr_emplace<re::AudioManager_PHASE>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24ED3DE38;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<re::AudioManager_PHASE>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24ED3DE38;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2276933B8);
}

void std::__shared_ptr_emplace<re::AudioManager_PHASE>::__on_zero_shared(uint64_t a1)
{
  re::AudioManager_PHASE::~AudioManager_PHASE((re::AudioManager_PHASE *)(a1 + 32));
}

void std::__shared_ptr_emplace<re::AudioSharedSceneManager>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24ED3DD98;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<re::AudioSharedSceneManager>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24ED3DD98;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2276933B8);
}

uint64_t std::__shared_ptr_emplace<re::AudioSharedSceneManager>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 32))(a1 + 32);
}

void std::__shared_ptr_emplace<re::AudioMultiSceneManager>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24ED3DDE8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<re::AudioMultiSceneManager>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24ED3DDE8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2276933B8);
}

uint64_t std::__shared_ptr_emplace<re::AudioMultiSceneManager>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

uint64_t *re::allocInfo_AudioFileAssetConfiguration(re *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&_MergedGlobals_120);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&_MergedGlobals_120))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2541058C0, 0);
    *(uint64_t *)((char *)&qword_2541058D0 + 6) = 0;
    qword_2541058D0 = 0;
    qword_2541058E0 = 0;
    qword_2541058E8 = 0xFFFFFFFFLL;
    qword_2541058C0 = (uint64_t)&off_24ED7DAA8;
    qword_2541058F0 = (uint64_t)"AudioFileAssetConfiguration";
    dword_2541058F8 = 0;
    xmmword_254105900 = 0u;
    unk_254105910 = 0u;
    xmmword_254105920 = 0u;
    qword_254105930 = 0;
    __cxa_guard_release(&_MergedGlobals_120);
  }
  return &qword_2541058C0;
}

void re::initInfo_AudioFileAssetConfiguration(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  const re::IntrospectionBase *v7;
  void *v8;
  uint64_t v9;
  uint64_t *v10;
  const re::IntrospectionBase *v11;
  void *v12;
  uint64_t v13;
  uint64_t *v14;
  const re::IntrospectionBase *v15;
  void *v16;
  uint64_t v17;
  uint64_t *v18;
  const re::IntrospectionBase *v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t *v22;
  const re::IntrospectionBase *v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t *v26;
  const re::IntrospectionBase *v27;
  void *v28;
  uint64_t v29;
  uint64_t *v30;
  const re::IntrospectionBase *v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t *v34;
  const re::IntrospectionBase *v35;
  uint64_t *v36;
  uint64_t v37;
  uint64_t *v38;
  const re::IntrospectionBase *v39;
  uint64_t *v40;
  uint64_t v41;
  uint64_t *v42;
  const re::IntrospectionBase *v43;
  void *v44;
  uint64_t v45;
  __int128 v46;
  _QWORD v47[2];
  __int128 v48;

  v47[0] = 0xC6CB289492F5ABB0;
  v47[1] = "AudioFileAssetConfiguration";
  re::StringID::destroyString((re::StringID *)v47);
  *((_OWORD *)this + 2) = v48;
  v4 = atomic_load((unsigned __int8 *)&qword_254105868);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_254105868);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      v8 = re::introspect_BOOL((re *)1, v7);
      v9 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
      *(_DWORD *)v9 = 1;
      *(_QWORD *)(v9 + 8) = "stream";
      *(_QWORD *)(v9 + 16) = v8;
      *(_QWORD *)(v9 + 24) = 0;
      *(_QWORD *)(v9 + 32) = 1;
      *(_DWORD *)(v9 + 40) = 0;
      *(_QWORD *)(v9 + 48) = 0;
      *(_QWORD *)(v9 + 56) = 0;
      *(_DWORD *)(v9 + 64) = 0;
      qword_254105870 = v9;
      v10 = re::introspectionAllocator((re *)v9);
      v12 = re::introspect_BOOL((re *)1, v11);
      v13 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v10 + 32))(v10, 72, 8);
      *(_DWORD *)v13 = 1;
      *(_QWORD *)(v13 + 8) = "loop";
      *(_QWORD *)(v13 + 16) = v12;
      *(_QWORD *)(v13 + 24) = 0;
      *(_QWORD *)(v13 + 32) = 0x100000002;
      *(_DWORD *)(v13 + 40) = 0;
      *(_QWORD *)(v13 + 48) = 0;
      *(_QWORD *)(v13 + 56) = 0;
      *(_DWORD *)(v13 + 64) = 0;
      qword_254105878 = v13;
      v14 = re::introspectionAllocator((re *)v13);
      v16 = re::introspect_BOOL((re *)1, v15);
      v17 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v14 + 32))(v14, 72, 8);
      *(_DWORD *)v17 = 1;
      *(_QWORD *)(v17 + 8) = "randomizeStartTime";
      *(_QWORD *)(v17 + 16) = v16;
      *(_QWORD *)(v17 + 24) = 0;
      *(_QWORD *)(v17 + 32) = 0x200000003;
      *(_DWORD *)(v17 + 40) = 0;
      *(_QWORD *)(v17 + 48) = 0;
      *(_QWORD *)(v17 + 56) = 0;
      *(_DWORD *)(v17 + 64) = 0;
      qword_254105880 = v17;
      v18 = re::introspectionAllocator((re *)v17);
      v20 = introspect_REAudioNormalizationMode(1, v19);
      v21 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v18 + 32))(v18, 72, 8);
      *(_DWORD *)v21 = 1;
      *(_QWORD *)(v21 + 8) = "normalizationMode";
      *(_QWORD *)(v21 + 16) = v20;
      *(_QWORD *)(v21 + 24) = 0;
      *(_QWORD *)(v21 + 32) = 0x400000004;
      *(_DWORD *)(v21 + 40) = 0;
      *(_QWORD *)(v21 + 48) = 0;
      *(_QWORD *)(v21 + 56) = 0;
      *(_DWORD *)(v21 + 64) = 0;
      qword_254105888 = v21;
      v22 = re::introspectionAllocator((re *)v21);
      v24 = introspect_REAudioCalibrationMode(1, v23);
      v25 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v22 + 32))(v22, 72, 8);
      *(_DWORD *)v25 = 1;
      *(_QWORD *)(v25 + 8) = "calibrationMode";
      *(_QWORD *)(v25 + 16) = v24;
      *(_QWORD *)(v25 + 24) = 0;
      *(_QWORD *)(v25 + 32) = 0x800000005;
      *(_DWORD *)(v25 + 40) = 0;
      *(_QWORD *)(v25 + 48) = 0;
      *(_QWORD *)(v25 + 56) = 0;
      *(_DWORD *)(v25 + 64) = 0;
      qword_254105890 = v25;
      v26 = re::introspectionAllocator((re *)v25);
      v28 = re::introspect_double((re *)1, v27);
      v29 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v26 + 32))(v26, 72, 8);
      *(_DWORD *)v29 = 1;
      *(_QWORD *)(v29 + 8) = "calibrationLevel";
      *(_QWORD *)(v29 + 16) = v28;
      *(_QWORD *)(v29 + 24) = 0;
      *(_QWORD *)(v29 + 32) = 0x1000000006;
      *(_DWORD *)(v29 + 40) = 0;
      *(_QWORD *)(v29 + 48) = 0;
      *(_QWORD *)(v29 + 56) = 0;
      *(_DWORD *)(v29 + 64) = 0;
      qword_254105898 = v29;
      v30 = re::introspectionAllocator((re *)v29);
      v32 = re::IntrospectionInfo<re::Optional<re::DynamicString>>::get(1, v31);
      v33 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v30 + 32))(v30, 72, 8);
      *(_DWORD *)v33 = 1;
      *(_QWORD *)(v33 + 8) = "mixGroupName";
      *(_QWORD *)(v33 + 16) = v32;
      *(_QWORD *)(v33 + 24) = 0;
      *(_QWORD *)(v33 + 32) = 0x2000000007;
      *(_DWORD *)(v33 + 40) = 0;
      *(_QWORD *)(v33 + 48) = 0;
      *(_QWORD *)(v33 + 56) = 0;
      *(_DWORD *)(v33 + 64) = 0;
      qword_2541058A0 = v33;
      v34 = re::introspectionAllocator((re *)v33);
      v36 = re::IntrospectionInfo<re::Optional<unsigned int>>::get(1, v35);
      v37 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v34 + 32))(v34, 72, 8);
      *(_DWORD *)v37 = 1;
      *(_QWORD *)(v37 + 8) = "layoutTag";
      *(_QWORD *)(v37 + 16) = v36;
      *(_QWORD *)(v37 + 24) = 0;
      *(_QWORD *)(v37 + 32) = 0x4800000008;
      *(_DWORD *)(v37 + 40) = 0;
      *(_QWORD *)(v37 + 48) = 0;
      *(_QWORD *)(v37 + 56) = 0;
      *(_DWORD *)(v37 + 64) = 0;
      qword_2541058A8 = v37;
      v38 = re::introspectionAllocator((re *)v37);
      v40 = introspect_REAudioInputMode(1, v39);
      v41 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v38 + 32))(v38, 72, 8);
      *(_DWORD *)v41 = 1;
      *(_QWORD *)(v41 + 8) = "inputMode";
      *(_QWORD *)(v41 + 16) = v40;
      *(_QWORD *)(v41 + 24) = 0;
      *(_QWORD *)(v41 + 32) = 0x5000000009;
      *(_DWORD *)(v41 + 40) = 0;
      *(_QWORD *)(v41 + 48) = 0;
      *(_QWORD *)(v41 + 56) = 0;
      *(_DWORD *)(v41 + 64) = 0;
      qword_2541058B0 = v41;
      v42 = re::introspectionAllocator((re *)v41);
      v44 = re::introspect_double((re *)1, v43);
      v45 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v42 + 32))(v42, 72, 8);
      *(_DWORD *)v45 = 1;
      *(_QWORD *)(v45 + 8) = "targetLUFS";
      *(_QWORD *)(v45 + 16) = v44;
      *(_QWORD *)(v45 + 24) = 0;
      *(_QWORD *)(v45 + 32) = 0x180000000ALL;
      *(_DWORD *)(v45 + 40) = 0;
      *(_QWORD *)(v45 + 48) = 0;
      *(_QWORD *)(v45 + 56) = 0;
      *(_DWORD *)(v45 + 64) = 0;
      qword_2541058B8 = v45;
      __cxa_guard_release(&qword_254105868);
    }
  }
  *((_QWORD *)this + 2) = 0x5800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 10;
  *((_QWORD *)this + 8) = &qword_254105870;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::AudioFileAssetConfiguration>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::AudioFileAssetConfiguration>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::AudioFileAssetConfiguration>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::AudioFileAssetConfiguration>;
  re::IntrospectionRegistry::add(this, v3);
  v46 = v48;
}

void sub_22540BD64(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&qword_254105868);
  _Unwind_Resume(a1);
}

uint64_t *re::IntrospectionInfo<re::Optional<unsigned int>>::get(char a1, const re::IntrospectionBase *a2)
{
  unsigned __int8 v3;
  int v4;
  re *v5;
  std::__shared_mutex_base *v6;
  re *v7;
  std::__shared_mutex_base *v8;
  uint64_t v10;
  int v11;
  re::IntrospectionRegistry *v12;
  const re::IntrospectionBase *v13;
  const char *v14;
  __int128 v15;
  __int128 v16;
  const char *v17;
  uint64_t v18[2];

  if ((v3 & 1) == 0
  {
    re::IntrospectionOptionalBase::IntrospectionOptionalBase((re::IntrospectionOptionalBase *)&re::IntrospectionInfo<re::Optional<unsigned int>>::get(BOOL)::info);
    re::IntrospectionInfo<re::Optional<unsigned int>>::get(BOOL)::info = (uint64_t)&off_24ED3DEF8;
  }
  if ((a1 & 1) != 0)
  {
    if (re::IntrospectionInfo<re::Optional<unsigned int>>::get(BOOL)::isInitialized)
      return &re::IntrospectionInfo<re::Optional<unsigned int>>::get(BOOL)::info;
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v16);
    v4 = re::IntrospectionInfo<re::Optional<unsigned int>>::get(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v16);
    if (v4)
      return &re::IntrospectionInfo<re::Optional<unsigned int>>::get(BOOL)::info;
    v6 = re::introspectionSharedMutex(v5);
    std::__shared_mutex_base::lock(v6);
  }
  v7 = (re *)re::introspect_uint32_t((re *)1, a2);
  if (re::IntrospectionInfo<re::Optional<unsigned int>>::get(BOOL)::isInitialized)
  {
    if ((a1 & 1) == 0)
    {
LABEL_9:
      v8 = re::introspectionSharedMutex(v7);
      std::__shared_mutex_base::unlock(v8);
    }
  }
  else
  {
    v10 = (uint64_t)v7;
    re::IntrospectionInfo<re::Optional<unsigned int>>::get(BOOL)::isInitialized = 1;
    v11 = *((_DWORD *)v7 + 6);
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&re::IntrospectionInfo<re::Optional<unsigned int>>::get(BOOL)::info, 0);
    qword_255801438 = 0x80000000DLL;
    dword_255801440 = v11;
    word_255801444 = 0;
    *(_QWORD *)&xmmword_255801448 = 0;
    *((_QWORD *)&xmmword_255801448 + 1) = 0xFFFFFFFFLL;
    qword_255801458 = v10;
    unk_255801460 = 0;
    re::IntrospectionInfo<re::Optional<unsigned int>>::get(BOOL)::info = (uint64_t)&off_24ED3DEF8;
    re::IntrospectionRegistry::add(v12, v13);
    re::getPrettyTypeName((re *)&re::IntrospectionInfo<re::Optional<unsigned int>>::get(BOOL)::info, (const re::IntrospectionBase *)&v16);
    if ((BYTE8(v16) & 1) != 0)
      v14 = v17;
    else
      v14 = (char *)&v16 + 9;
    if ((_QWORD)v16 && (BYTE8(v16) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v16 + 40))();
    v16 = *(_OWORD *)(v10 + 32);
    xmmword_255801448 = v15;
    re::StringID::destroyString((re::StringID *)v18);
    if ((a1 & 1) == 0)
      goto LABEL_9;
  }
  return &re::IntrospectionInfo<re::Optional<unsigned int>>::get(BOOL)::info;
}

void sub_22540BF70(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double re::internal::defaultConstruct<re::AudioFileAssetConfiguration>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double result;

  *(_WORD *)a3 = 0;
  *(_BYTE *)(a3 + 2) = 0;
  *(_DWORD *)(a3 + 4) = 0;
  *(_DWORD *)(a3 + 8) = 0;
  result = 0.0;
  *(_OWORD *)(a3 + 16) = xmmword_2260FDC00;
  *(_BYTE *)(a3 + 32) = 0;
  *(_BYTE *)(a3 + 72) = 0;
  *(_BYTE *)(a3 + 80) = 0;
  return result;
}

double re::internal::defaultDestruct<re::AudioFileAssetConfiguration>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  _OWORD *v4;
  double result;

  if (*(_BYTE *)(a3 + 32))
  {
    v4 = (_OWORD *)(a3 + 40);
    v3 = *(_QWORD *)(a3 + 40);
    if (v3)
    {
      if ((*(_BYTE *)(a3 + 48) & 1) != 0)
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a3 + 56));
      result = 0.0;
      *v4 = 0u;
      v4[1] = 0u;
    }
  }
  return result;
}

double re::internal::defaultConstructV2<re::AudioFileAssetConfiguration>(uint64_t a1)
{
  double result;

  *(_WORD *)a1 = 0;
  *(_BYTE *)(a1 + 2) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 16) = xmmword_2260FDC00;
  *(_BYTE *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 72) = 0;
  *(_BYTE *)(a1 + 80) = 0;
  return result;
}

double re::internal::defaultDestructV2<re::AudioFileAssetConfiguration>(uint64_t a1)
{
  uint64_t v1;
  _OWORD *v2;
  double result;

  if (*(_BYTE *)(a1 + 32))
  {
    v2 = (_OWORD *)(a1 + 40);
    v1 = *(_QWORD *)(a1 + 40);
    if (v1)
    {
      if ((*(_BYTE *)(a1 + 48) & 1) != 0)
        (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)v1 + 40))(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 56));
      result = 0.0;
      *v2 = 0u;
      v2[1] = 0u;
    }
  }
  return result;
}

uint64_t re::introspect_AudioFileAssetConfiguration(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"AudioFileAssetConfiguration", (uint64_t (*)(re::internal *))re::allocInfo_AudioFileAssetConfiguration, (re::IntrospectionBase *(*)(void))re::initInfo_AudioFileAssetConfiguration, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::AudioFileAssetConfiguration>, this);
}

void re::TypeBuilderHelper::registerOptional<unsigned int>(re::TypeRegistry *a1@<X0>, uint64_t *a2@<X1>, __int128 *a3@<X2>, re::TypeRegistry **a4@<X8>)
{
  _anonymous_namespace_ *v8;
  re::TypeRegistry *v9;
  uint64_t v10;
  __int128 v11;
  _BYTE v12[488];

  v8 = (_anonymous_namespace_ *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a1 + 200, a2);
  if (a1 && v8)
  {
    v9 = *(re::TypeRegistry **)v8;
    *a4 = a1;
    a4[1] = v9;
  }
  else
  {
    v11 = *a3;
    re::TypeBuilder::beginOptionalType((uint64_t)v12, a2, 8uLL, 4uLL, &v11);
    re::TypeBuilder::setOptionalAccessors((uint64_t)v12, (void *(*)(void *))re::TypeBuilderHelper::registerOptional<unsigned int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (void (*)(void *, const void *))re::TypeBuilderHelper::registerOptional<unsigned int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,void const*)#1}::__invoke);
    re::TypeBuilder::commitTo((re::TypeBuilder *)v12, a1, a4);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v12, v10);
  }
}

_QWORD *re::IntrospectionOptional<unsigned int>::~IntrospectionOptional(_QWORD *a1)
{
  *a1 = &off_24ED2DDF8;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionOptional<unsigned int>::~IntrospectionOptional(_QWORD *a1)
{
  *a1 = &off_24ED2DDF8;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x2276933B8);
}

void re::IntrospectionOptional<unsigned int>::construct(uint64_t a1, _BYTE *a2)
{
  *a2 = 0;
}

uint64_t re::IntrospectionOptional<unsigned int>::hasValue(uint64_t a1, unsigned __int8 *a2)
{
  return *a2;
}

void re::IntrospectionOptional<unsigned int>::setHasValue(uint64_t a1, uint64_t a2, int a3)
{
  if (a3)
  {
    if (!*(_BYTE *)a2)
      *(_BYTE *)a2 = 1;
    *(_DWORD *)(a2 + 4) = 0;
  }
  else if (*(_BYTE *)a2)
  {
    *(_BYTE *)a2 = 0;
  }
}

uint64_t re::IntrospectionOptional<unsigned int>::value(uint64_t a1, uint64_t a2)
{
  return a2 + 4;
}

{
  return a2 + 4;
}

unsigned __int8 *re::TypeBuilderHelper::registerOptional<unsigned int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(unsigned __int8 *a1)
{
  unsigned __int8 *result;
  int v2;

  v2 = *a1;
  result = a1 + 4;
  if (!v2)
    return 0;
  return result;
}

uint64_t re::TypeBuilderHelper::registerOptional<unsigned int>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,void const*)#1}::__invoke(uint64_t result, int *a2)
{
  int v2;

  if (a2)
  {
    v2 = *a2;
    if (!*(_BYTE *)result)
      *(_BYTE *)result = 1;
    *(_DWORD *)(result + 4) = v2;
  }
  else if (*(_BYTE *)result)
  {
    *(_BYTE *)result = 0;
  }
  return result;
}

uint64_t *re::audioLogObjects(re *this)
{
  unsigned __int8 v1;

  {
    re::audioLogObjects(void)::logObjects = (uint64_t)os_log_create("com.apple.re", "Audio");
  }
  return &re::audioLogObjects(void)::logObjects;
}

uint64_t re::AudioLogObjects::loggingEnabled(re::AudioLogObjects *this)
{
  unsigned __int8 v1;
  unsigned __int8 *v2;
  int v4;
  const char *v5;
  char v6;
  char v7[2];

  v2 = (unsigned __int8 *)&re::introspect_REStateCommandID(BOOL)::info;
  if ((v1 & 1) == 0)
  {
    v2 = (_BYTE *)&re::introspect_REStateCommandID(BOOL)::info;
    if (v4)
    {
      re::Defaults::BOOLValue((re::Defaults *)"audio.log.enabled", v5, v7);
      v6 = v7[1];
      if (!v7[0])
        v6 = 0;
      re::AudioLogObjects::loggingEnabled(void)::value = v6;
      v2 = (_BYTE *)&re::introspect_REStateCommandID(BOOL)::info;
    }
  }
  return v2[2488];
}

void re::AudioManager_PHASE_StateMachine_SceneRecoveryStep::eventReceived(uint64_t a1, unint64_t a2, char a3)
{
  if (a3)
    std::__tree<unsigned long long>::__erase_unique<unsigned long long>((void **)(a1 + 16), a2);
}

BOOL re::AudioManager_PHASE_StateMachine_SceneRecoveryStep::isCompleted(re::AudioManager_PHASE_StateMachine_SceneRecoveryStep *this)
{
  return *((_QWORD *)this + 4) == 0;
}

void re::AudioManager_PHASE_StateMachine_SceneRecoveryStep::unregisterScene(void **this, unint64_t a2)
{
  std::__tree<unsigned long long>::__erase_unique<unsigned long long>(this + 2, a2);
}

uint64_t *re::AudioManager_PHASE_StateMachine_SceneRecoveryStep::registerScene(uint64_t **this, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return std::__tree<unsigned long long>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>(this + 2, (unint64_t *)&v3, &v3);
}

void re::AudioManager_PHASE_StateMachine_SceneRecoveryStep::stepDescription(re::AudioManager_PHASE_StateMachine_SceneRecoveryStep *this@<X0>, std::string *a2@<X8>)
{
  std::string *v4;
  __int128 v5;
  std::string *p_p;
  std::string::size_type size;
  std::string *v8;
  __int128 v9;
  std::string *v10;
  void *v11;
  std::string *v12;
  __int128 v13;
  std::string *v14;
  std::string __p;
  std::string v16;
  std::string v17;
  std::string v18;

  if (*((_QWORD *)this + 4))
  {
    re::nameForAudioManagerStateMachineEvent(*((_DWORD *)this + 2), &v16);
    v4 = std::string::append(&v16, ": ");
    v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
    v17.__r_.__value_.__r.__words[2] = v4->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v17.__r_.__value_.__l.__data_ = v5;
    v4->__r_.__value_.__l.__size_ = 0;
    v4->__r_.__value_.__r.__words[2] = 0;
    v4->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&__p, *((_QWORD *)this + 4));
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      p_p = &__p;
    else
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    else
      size = __p.__r_.__value_.__l.__size_;
    v8 = std::string::append(&v17, (const std::string::value_type *)p_p, size);
    v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
    v18.__r_.__value_.__r.__words[2] = v8->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v18.__r_.__value_.__l.__data_ = v9;
    v8->__r_.__value_.__l.__size_ = 0;
    v8->__r_.__value_.__r.__words[2] = 0;
    v8->__r_.__value_.__r.__words[0] = 0;
    v10 = std::string::append(&v18, " remaining");
    *a2 = *v10;
    v10->__r_.__value_.__l.__size_ = 0;
    v10->__r_.__value_.__r.__words[2] = 0;
    v10->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v18.__r_.__value_.__l.__data_);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    if (SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v17.__r_.__value_.__l.__data_);
    if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0)
    {
      v11 = (void *)v16.__r_.__value_.__r.__words[0];
LABEL_20:
      operator delete(v11);
    }
  }
  else
  {
    re::nameForAudioManagerStateMachineEvent(*((_DWORD *)this + 2), &v17);
    v12 = std::string::append(&v17, ": ");
    v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
    v18.__r_.__value_.__r.__words[2] = v12->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v18.__r_.__value_.__l.__data_ = v13;
    v12->__r_.__value_.__l.__size_ = 0;
    v12->__r_.__value_.__r.__words[2] = 0;
    v12->__r_.__value_.__r.__words[0] = 0;
    v14 = std::string::append(&v18, "completed");
    *a2 = *v14;
    v14->__r_.__value_.__l.__size_ = 0;
    v14->__r_.__value_.__r.__words[2] = 0;
    v14->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v18.__r_.__value_.__l.__data_);
    if (SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0)
    {
      v11 = (void *)v17.__r_.__value_.__r.__words[0];
      goto LABEL_20;
    }
  }
}

void sub_22540C564(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  uint64_t v26;

  if (*(char *)(v26 - 25) < 0)
    operator delete(*(void **)(v26 - 48));
  if (a26 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void re::AudioManager_PHASE_StateMachine_SceneRecoveryStep::copy(re::AudioManager_PHASE_StateMachine_SceneRecoveryStep *this@<X0>, uint64_t *a2@<X8>)
{
  re::AudioManager_PHASE_StateMachine_SceneRecoveryStep *v2;
  char *v4;
  uint64_t v5;
  uint64_t v6[3];

  v2 = this;
  v4 = (char *)this + 16;
  v5 = operator new();
  LODWORD(v2) = *((_DWORD *)v2 + 2);
  std::set<unsigned long long>::set[abi:ne180100](v6, (uint64_t)v4);
  *(_DWORD *)(v5 + 8) = (_DWORD)v2;
  *(_QWORD *)v5 = &off_24ED3DF78;
  std::set<unsigned long long>::set[abi:ne180100]((uint64_t *)(v5 + 16), (uint64_t)v6);
  std::__tree<unsigned long long>::destroy((uint64_t)v6, (_QWORD *)v6[1]);
  *a2 = v5;
}

void sub_22540C680(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, _QWORD *a11)
{
  uint64_t v11;

  std::__tree<unsigned long long>::destroy((uint64_t)&a10, a11);
  MEMORY[0x2276933B8](v11, 0x10A1C40C3D8C859);
  _Unwind_Resume(a1);
}

void re::AudioManager_PHASE_StateMachine_SceneRecoveryStep::~AudioManager_PHASE_StateMachine_SceneRecoveryStep(re::AudioManager_PHASE_StateMachine_SceneRecoveryStep *this)
{
  *(_QWORD *)this = &off_24ED3DF78;
  std::__tree<unsigned long long>::destroy((uint64_t)this + 16, *((_QWORD **)this + 3));
}

{
  *(_QWORD *)this = &off_24ED3DF78;
  std::__tree<unsigned long long>::destroy((uint64_t)this + 16, *((_QWORD **)this + 3));
  JUMPOUT(0x2276933B8);
}

void std::__tree<unsigned long long>::destroy(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    std::__tree<unsigned long long>::destroy(a1, *a2);
    std::__tree<unsigned long long>::destroy(a1, a2[1]);
    operator delete(a2);
  }
}

uint64_t *std::set<unsigned long long>::set[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  std::set<unsigned long long>::insert[abi:ne180100]<std::__tree_const_iterator<unsigned long long,std::__tree_node<unsigned long long,void *> *,long>>(a1, *(_QWORD **)a2, (_QWORD *)(a2 + 8));
  return a1;
}

void sub_22540C7AC(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__tree<unsigned long long>::destroy(v1, *(_QWORD **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *std::set<unsigned long long>::insert[abi:ne180100]<std::__tree_const_iterator<unsigned long long,std::__tree_node<unsigned long long,void *> *,long>>(uint64_t *result, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v4;
  uint64_t **v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  BOOL v9;

  if (a2 != a3)
  {
    v4 = a2;
    v5 = (uint64_t **)result;
    v6 = result + 1;
    do
    {
      result = std::__tree<unsigned long long>::__emplace_hint_unique_key_args<unsigned long long,unsigned long long const&>(v5, v6, v4 + 4, v4 + 4);
      v7 = (_QWORD *)v4[1];
      if (v7)
      {
        do
        {
          v8 = v7;
          v7 = (_QWORD *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          v8 = (_QWORD *)v4[2];
          v9 = *v8 == (_QWORD)v4;
          v4 = v8;
        }
        while (!v9);
      }
      v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t *std::__tree<unsigned long long>::__emplace_hint_unique_key_args<unsigned long long,unsigned long long const&>(uint64_t **a1, _QWORD *a2, unint64_t *a3, uint64_t *a4)
{
  uint64_t **v6;
  uint64_t *v7;
  uint64_t **v8;
  uint64_t v10;
  uint64_t v11;

  v6 = (uint64_t **)std::__tree<unsigned long long>::__find_equal<unsigned long long>(a1, a2, &v11, &v10, a3);
  v7 = *v6;
  if (!*v6)
  {
    v8 = v6;
    v7 = (uint64_t *)operator new(0x28uLL);
    v7[4] = *a4;
    std::__tree<std::__value_type<double,std::string>,std::__map_value_compare<double,std::__value_type<double,std::string>,std::less<double>,true>,std::allocator<std::__value_type<double,std::string>>>::__insert_node_at(a1, v11, v8, v7);
  }
  return v7;
}

_QWORD *std::__tree<unsigned long long>::__find_equal<unsigned long long>(_QWORD *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, unint64_t *a5)
{
  _QWORD *v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  BOOL v14;
  unint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  unint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  _QWORD *v21;
  unint64_t v22;

  v5 = a1 + 1;
  if (a1 + 1 == a2 || (v6 = *a5, v7 = a2[4], *a5 < v7))
  {
    v8 = *a2;
    if ((_QWORD *)*a1 == a2)
    {
      v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }
      else
      {
        *a3 = a2;
        return a2;
      }
    }
    if (v8)
    {
      v9 = (_QWORD *)*a2;
      do
      {
        v10 = v9;
        v9 = (_QWORD *)v9[1];
      }
      while (v9);
    }
    else
    {
      v13 = a2;
      do
      {
        v10 = (_QWORD *)v13[2];
        v14 = *v10 == (_QWORD)v13;
        v13 = v10;
      }
      while (v14);
    }
    v15 = *a5;
    if (v10[4] < *a5)
      goto LABEL_17;
    v16 = (_QWORD *)*v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          v17 = v16;
          v18 = v16[4];
          if (v15 >= v18)
            break;
          v16 = (_QWORD *)*v17;
          v5 = v17;
          if (!*v17)
            goto LABEL_29;
        }
        if (v18 >= v15)
          break;
        v5 = v17 + 1;
        v16 = (_QWORD *)v17[1];
      }
      while (v16);
    }
    else
    {
      v17 = a1 + 1;
    }
LABEL_29:
    *a3 = v17;
    return v5;
  }
  if (v7 >= v6)
  {
    *a3 = a2;
    *a4 = a2;
    return a4;
  }
  v11 = a2[1];
  if (v11)
  {
    v12 = (_QWORD *)a2[1];
    do
    {
      a4 = v12;
      v12 = (_QWORD *)*v12;
    }
    while (v12);
  }
  else
  {
    v19 = a2;
    do
    {
      a4 = (_QWORD *)v19[2];
      v14 = *a4 == (_QWORD)v19;
      v19 = a4;
    }
    while (!v14);
  }
  if (a4 != v5 && v6 >= a4[4])
  {
    v20 = (_QWORD *)*v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          v21 = v20;
          v22 = v20[4];
          if (v6 >= v22)
            break;
          v20 = (_QWORD *)*v21;
          v5 = v21;
          if (!*v21)
            goto LABEL_48;
        }
        if (v22 >= v6)
          break;
        v5 = v21 + 1;
        v20 = (_QWORD *)v21[1];
      }
      while (v20);
    }
    else
    {
      v21 = a1 + 1;
    }
LABEL_48:
    *a3 = v21;
    return v5;
  }
  if (v11)
  {
    *a3 = a4;
  }
  else
  {
    *a3 = a2;
    return a2 + 1;
  }
  return a4;
}

void std::__tree<unsigned long long>::__erase_unique<unsigned long long>(void **a1, unint64_t a2)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v5;
  _QWORD *v6;
  unint64_t v7;
  BOOL v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  int v16;
  _QWORD *v17;
  _QWORD *v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  _QWORD *v26;
  _QWORD *v27;
  _BYTE *v28;
  uint64_t v29;
  _BYTE *v30;
  uint64_t *v31;
  BOOL v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;

  v3 = a1 + 1;
  v2 = a1[1];
  if (!v2)
    return;
  v5 = a1 + 1;
  v6 = v2;
  do
  {
    v7 = v6[4];
    v8 = v7 >= a2;
    if (v7 >= a2)
      v9 = v6;
    else
      v9 = v6 + 1;
    if (v8)
      v5 = v6;
    v6 = (_QWORD *)*v9;
  }
  while (*v9);
  if (v5 == v3 || v5[4] > a2)
    return;
  v10 = (_QWORD *)v5[1];
  if (v10)
  {
    do
    {
      v11 = v10;
      v10 = (_QWORD *)*v10;
    }
    while (v10);
  }
  else
  {
    v12 = v5;
    do
    {
      v11 = (_QWORD *)v12[2];
      v32 = *v11 == (_QWORD)v12;
      v12 = v11;
    }
    while (!v32);
  }
  if (*a1 == v5)
    *a1 = v11;
  a1[2] = (char *)a1[2] - 1;
  v13 = *v5;
  v14 = v5;
  if (*v5)
  {
    v15 = (_QWORD *)v5[1];
    if (!v15)
    {
      v14 = v5;
      goto LABEL_27;
    }
    do
    {
      v14 = v15;
      v15 = (_QWORD *)*v15;
    }
    while (v15);
  }
  v13 = v14[1];
  if (v13)
  {
LABEL_27:
    v16 = 0;
    *(_QWORD *)(v13 + 16) = v14[2];
    goto LABEL_28;
  }
  v16 = 1;
LABEL_28:
  v17 = (_QWORD *)v14[2];
  v18 = (_QWORD *)*v17;
  if ((_QWORD *)*v17 == v14)
  {
    *v17 = v13;
    if (v14 == v2)
    {
      v18 = 0;
      v2 = (_QWORD *)v13;
    }
    else
    {
      v18 = (_QWORD *)v17[1];
    }
  }
  else
  {
    v17[1] = v13;
  }
  v19 = *((unsigned __int8 *)v14 + 24);
  if (v14 != v5)
  {
    v20 = v5[2];
    v14[2] = v20;
    *(_QWORD *)(v20 + 8 * (*(_QWORD *)v5[2] != (_QWORD)v5)) = v14;
    v22 = *v5;
    v21 = v5[1];
    *(_QWORD *)(v22 + 16) = v14;
    *v14 = v22;
    v14[1] = v21;
    if (v21)
      *(_QWORD *)(v21 + 16) = v14;
    *((_BYTE *)v14 + 24) = *((_BYTE *)v5 + 24);
    if (v2 == v5)
      v2 = v14;
  }
  if (!v19 || !v2)
    goto LABEL_71;
  if (!v16)
  {
    *(_BYTE *)(v13 + 24) = 1;
    goto LABEL_71;
  }
  while (1)
  {
    v23 = v18[2];
    if (*(_QWORD **)v23 != v18)
      break;
    if (!*((_BYTE *)v18 + 24))
    {
      *((_BYTE *)v18 + 24) = 1;
      *(_BYTE *)(v23 + 24) = 0;
      v29 = v18[1];
      *(_QWORD *)v23 = v29;
      if (v29)
        *(_QWORD *)(v29 + 16) = v23;
      v18[2] = *(_QWORD *)(v23 + 16);
      *(_QWORD *)(*(_QWORD *)(v23 + 16) + 8 * (**(_QWORD **)(v23 + 16) != v23)) = v18;
      v18[1] = v23;
      *(_QWORD *)(v23 + 16) = v18;
      if (v2 == (_QWORD *)v23)
        v2 = v18;
      v18 = *(_QWORD **)v23;
    }
    v30 = (_BYTE *)*v18;
    if (*v18 && !v30[24])
      goto LABEL_88;
    v31 = (uint64_t *)v18[1];
    if (v31 && !*((_BYTE *)v31 + 24))
    {
      if (v30 && !v30[24])
      {
LABEL_88:
        v31 = v18;
      }
      else
      {
        *((_BYTE *)v31 + 24) = 1;
        *((_BYTE *)v18 + 24) = 0;
        v37 = *v31;
        v18[1] = *v31;
        if (v37)
          *(_QWORD *)(v37 + 16) = v18;
        v31[2] = v18[2];
        *(_QWORD *)(v18[2] + 8 * (*(_QWORD *)v18[2] != (_QWORD)v18)) = v31;
        *v31 = (uint64_t)v18;
        v18[2] = v31;
        v30 = v18;
      }
      v34 = v31[2];
      *((_BYTE *)v31 + 24) = *(_BYTE *)(v34 + 24);
      *(_BYTE *)(v34 + 24) = 1;
      v30[24] = 1;
      v35 = *(uint64_t **)v34;
      v38 = *(_QWORD *)(*(_QWORD *)v34 + 8);
      *(_QWORD *)v34 = v38;
      if (v38)
        *(_QWORD *)(v38 + 16) = v34;
      v35[2] = *(_QWORD *)(v34 + 16);
      *(_QWORD *)(*(_QWORD *)(v34 + 16) + 8 * (**(_QWORD **)(v34 + 16) != v34)) = v35;
      v35[1] = v34;
      goto LABEL_92;
    }
    *((_BYTE *)v18 + 24) = 0;
    v28 = (_BYTE *)v18[2];
    if (v28[24])
      v32 = v28 == (_BYTE *)v2;
    else
      v32 = 1;
    if (v32)
      goto LABEL_73;
LABEL_69:
    v18 = *(_QWORD **)(*((_QWORD *)v28 + 2) + 8 * (**((_QWORD **)v28 + 2) == (_QWORD)v28));
  }
  if (!*((_BYTE *)v18 + 24))
  {
    *((_BYTE *)v18 + 24) = 1;
    *(_BYTE *)(v23 + 24) = 0;
    v24 = *(uint64_t **)(v23 + 8);
    v25 = *v24;
    *(_QWORD *)(v23 + 8) = *v24;
    if (v25)
      *(_QWORD *)(v25 + 16) = v23;
    v24[2] = *(_QWORD *)(v23 + 16);
    *(_QWORD *)(*(_QWORD *)(v23 + 16) + 8 * (**(_QWORD **)(v23 + 16) != v23)) = v24;
    *v24 = v23;
    *(_QWORD *)(v23 + 16) = v24;
    if (v2 == (_QWORD *)*v18)
      v2 = v18;
    v18 = *(_QWORD **)(*v18 + 8);
  }
  v26 = (_QWORD *)*v18;
  if (!*v18 || *((_BYTE *)v26 + 24))
  {
    v27 = (_QWORD *)v18[1];
    if (v27 && !*((_BYTE *)v27 + 24))
      goto LABEL_79;
    *((_BYTE *)v18 + 24) = 0;
    v28 = (_BYTE *)v18[2];
    if (v28 == (_BYTE *)v2)
    {
      v28 = v2;
LABEL_73:
      v28[24] = 1;
      goto LABEL_71;
    }
    if (!v28[24])
      goto LABEL_73;
    goto LABEL_69;
  }
  v27 = (_QWORD *)v18[1];
  if (v27 && !*((_BYTE *)v27 + 24))
  {
LABEL_79:
    v26 = v18;
  }
  else
  {
    *((_BYTE *)v26 + 24) = 1;
    *((_BYTE *)v18 + 24) = 0;
    v33 = v26[1];
    *v18 = v33;
    if (v33)
      *(_QWORD *)(v33 + 16) = v18;
    v26[2] = v18[2];
    *(_QWORD *)(v18[2] + 8 * (*(_QWORD *)v18[2] != (_QWORD)v18)) = v26;
    v26[1] = v18;
    v18[2] = v26;
    v27 = v18;
  }
  v34 = v26[2];
  *((_BYTE *)v26 + 24) = *(_BYTE *)(v34 + 24);
  *(_BYTE *)(v34 + 24) = 1;
  *((_BYTE *)v27 + 24) = 1;
  v35 = *(uint64_t **)(v34 + 8);
  v36 = *v35;
  *(_QWORD *)(v34 + 8) = *v35;
  if (v36)
    *(_QWORD *)(v36 + 16) = v34;
  v35[2] = *(_QWORD *)(v34 + 16);
  *(_QWORD *)(*(_QWORD *)(v34 + 16) + 8 * (**(_QWORD **)(v34 + 16) != v34)) = v35;
  *v35 = v34;
LABEL_92:
  *(_QWORD *)(v34 + 16) = v35;
LABEL_71:
  operator delete(v5);
}

uint64_t *std::__tree<unsigned long long>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>(uint64_t **a1, unint64_t *a2, uint64_t *a3)
{
  uint64_t *v5;
  uint64_t **v6;
  unint64_t v7;
  uint64_t **v8;
  unint64_t v9;
  uint64_t *v10;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    v7 = *a2;
    while (1)
    {
      while (1)
      {
        v8 = (uint64_t **)v5;
        v9 = v5[4];
        if (v7 >= v9)
          break;
        v5 = *v8;
        v6 = v8;
        if (!*v8)
          goto LABEL_10;
      }
      if (v9 >= v7)
        break;
      v5 = v8[1];
      if (!v5)
      {
        v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    v8 = a1 + 1;
LABEL_10:
    v10 = (uint64_t *)operator new(0x28uLL);
    v10[4] = *a3;
    std::__tree<std::__value_type<double,std::string>,std::__map_value_compare<double,std::__value_type<double,std::string>,std::less<double>,true>,std::allocator<std::__value_type<double,std::string>>>::__insert_node_at(a1, (uint64_t)v8, v6, v10);
    return v10;
  }
  return (uint64_t *)v8;
}

id **re::AudioManager_PHASE::AudioManager_PHASE(id **this)
{
  re::AudioManager *v2;
  uint64_t *v3;
  re::DisplayStateNotificationManager **v4;
  float **v5;
  uint64_t v6;
  uint8_t *v7;
  uint8_t *v8;
  uint8_t **v9;
  uint64_t v10;
  NSObject *v11;
  NSObject *v12;
  dispatch_queue_t v13;
  id *v14;
  NSObject *v15;
  NSObject *v16;
  dispatch_queue_t v17;
  id *v18;
  id v19;
  char *v20;
  std::__shared_weak_count *v21;
  unint64_t *p_shared_owners;
  unint64_t v23;
  uint64_t v24;
  re::AudioManager_PHASE_Async *v25;
  id *v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  unint64_t *v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  re::DisplayStateNotificationManager *v34;
  id *v35;
  unint64_t *v36;
  unint64_t v37;
  std::__shared_weak_count *v38;
  unint64_t *v39;
  unint64_t v40;
  int v41;
  float *v42;
  re::AudioManager_PHASE_StateMachine *v43;
  re *v44;
  NSObject *v45;
  re::AudioManager_PHASE_StateMachine **v47;
  re::AudioManager_PHASE_Async **v48;
  uint8_t buf[8];
  std::__shared_weak_count *v50;
  uint8_t *v51;
  uint64_t v52;

  v52 = *MEMORY[0x24BDAC8D0];
  v2 = re::AudioManager::AudioManager((re::AudioManager *)this);
  *(_QWORD *)v2 = off_24ED3DFE8;
  *((_OWORD *)v2 + 36) = 0u;
  *((_OWORD *)v2 + 37) = 0u;
  v47 = (re::AudioManager_PHASE_StateMachine **)((char *)v2 + 528);
  v48 = (re::AudioManager_PHASE_Async **)((char *)v2 + 520);
  *((_OWORD *)v2 + 31) = 0u;
  *((_OWORD *)v2 + 32) = 0u;
  *((_OWORD *)v2 + 33) = 0u;
  *(_OWORD *)((char *)v2 + 537) = 0u;
  *(_OWORD *)((char *)v2 + 556) = 0u;
  *((_DWORD *)v2 + 152) = 1065353216;
  *(_OWORD *)((char *)v2 + 616) = 0u;
  *(_OWORD *)((char *)v2 + 632) = 0u;
  *((_DWORD *)v2 + 162) = 1065353216;
  *((_BYTE *)v2 + 656) = 0;
  *((_OWORD *)v2 + 42) = xmmword_2260E5D70;
  *((_QWORD *)v2 + 86) = -1;
  *((_BYTE *)v2 + 696) = 1;
  *((_QWORD *)v2 + 88) = -1;
  *((_DWORD *)v2 + 178) = 0;
  v3 = (uint64_t *)((char *)v2 + 720);
  *((_QWORD *)v2 + 90) = 0;
  v4 = (re::DisplayStateNotificationManager **)((char *)v2 + 864);
  v5 = (float **)((char *)v2 + 872);
  *((_QWORD *)v2 + 96) = 0;
  *((_OWORD *)v2 + 47) = 0u;
  *((_QWORD *)v2 + 110) = 0;
  *((_OWORD *)v2 + 54) = 0u;
  v6 = operator new();
  *(_QWORD *)(v6 + 40) = 0;
  *(_OWORD *)v6 = 0u;
  *(_OWORD *)(v6 + 16) = 0u;
  *(_DWORD *)(v6 + 32) = 0;
  std::unique_ptr<re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>>,std::function<void ()(re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>>*)>>::reset[abi:ne180100](v3, v6);
  v7 = (uint8_t *)(this + 91);
  v8 = buf;
  *(_QWORD *)buf = &off_24ED3E7B0;
  v51 = buf;
  if (buf == (uint8_t *)(this + 91))
  {
    v10 = 4;
    goto LABEL_9;
  }
  v9 = (uint8_t **)(this + 94);
  v8 = (uint8_t *)this[94];
  if (v8 == v7)
  {
    v51 = 0;
    v8 = buf;
    (*(void (**)(char *, uint8_t *))(*(_QWORD *)v7 + 24))((char *)this + 728, buf);
    (*(void (**)(uint8_t *))(*(_QWORD *)*v9 + 32))(*v9);
    v51 = buf;
    *(_QWORD *)v7 = &off_24ED3E7B0;
    v10 = 4;
    *v9 = v7;
    goto LABEL_9;
  }
  *(_QWORD *)v7 = &off_24ED3E7B0;
  v51 = v8;
  *v9 = v7;
  if (v8 == buf)
  {
    v10 = 4;
    v8 = buf;
    goto LABEL_9;
  }
  if (v8)
  {
    v10 = 5;
LABEL_9:
    (*(void (**)(uint8_t *))(*(_QWORD *)v8 + 8 * v10))(v8);
  }
  dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  v11 = objc_claimAutoreleasedReturnValue();
  dispatch_queue_attr_make_with_qos_class(v11, QOS_CLASS_USER_INTERACTIVE, 0);
  v12 = objc_claimAutoreleasedReturnValue();

  v13 = dispatch_queue_create("AudioManager_PHASE", v12);
  v14 = this[67];
  this[67] = (id *)&v13->isa;

  dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  v15 = objc_claimAutoreleasedReturnValue();
  dispatch_queue_attr_make_with_qos_class(v15, QOS_CLASS_USER_INITIATED, 0);
  v16 = objc_claimAutoreleasedReturnValue();

  v17 = dispatch_queue_create("AudioManager_PHASE_slow", v16);
  v18 = this[68];
  this[68] = (id *)&v17->isa;

  v19 = *this[39];
  v20 = (char *)operator new(0x40uLL);
  *((_QWORD *)v20 + 1) = 0;
  *((_QWORD *)v20 + 2) = 0;
  *(_QWORD *)v20 = &off_24ED3E840;
  *(_OWORD *)(v20 + 24) = 0u;
  *(_OWORD *)(v20 + 40) = 0u;
  *((_DWORD *)v20 + 14) = 1065353216;
  this[109] = (id *)(v20 + 24);
  v21 = (std::__shared_weak_count *)this[110];
  this[110] = (id *)v20;
  if (v21)
  {
    p_shared_owners = (unint64_t *)&v21->__shared_owners_;
    do
      v23 = __ldaxr(p_shared_owners);
    while (__stlxr(v23 - 1, p_shared_owners));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }
  v24 = operator new();
  v25 = (re::AudioManager_PHASE_Async *)v24;
  v26 = this[67];
  v27 = (std::__shared_weak_count *)this[110];
  *(_QWORD *)buf = this[109];
  v50 = v27;
  if (v27)
  {
    v28 = (unint64_t *)&v27->__shared_owners_;
    do
      v29 = __ldxr(v28);
    while (__stxr(v29 + 1, v28));
  }
  re::AudioManager_PHASE_Async::AudioManager_PHASE_Async(v24, v26, v19, buf);
  if (v27)
  {
    v30 = (unint64_t *)&v27->__shared_owners_;
    do
      v31 = __ldaxr(v30);
    while (__stlxr(v31 - 1, v30));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
    }
  }
  std::unique_ptr<re::AudioManager_PHASE_Async>::reset[abi:ne180100](v48, v25);
  v32 = operator new();
  v34 = (re::DisplayStateNotificationManager *)v32;
  v35 = this[110];
  *(_QWORD *)buf = this[109];
  v50 = (std::__shared_weak_count *)v35;
  if (v35)
  {
    v36 = (unint64_t *)(v35 + 1);
    do
      v37 = __ldxr(v36);
    while (__stxr(v37 + 1, v36));
  }
  re::DisplayStateNotificationManager::DisplayStateNotificationManager(v32, v33, (uint64_t *)buf);
  v38 = v50;
  if (v50)
  {
    v39 = (unint64_t *)&v50->__shared_owners_;
    do
      v40 = __ldaxr(v39);
    while (__stlxr(v40 - 1, v39));
    if (!v40)
    {
      ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
      std::__shared_weak_count::__release_weak(v38);
    }
  }
  std::unique_ptr<re::DisplayStateNotificationManager>::reset[abi:ne180100](v4, v34);
  v41 = REAudioEnableAudioEngineRunnableAutomationSupport();
  v42 = *v5;
  if (v41)
  {
    if (!v42)
      goto LABEL_38;
    re::AudioEngineRunnableManager::addReason(v42, 1);
  }
  else
  {
    if (!v42)
      goto LABEL_38;
    re::AudioEngineRunnableManager::removeReason(v42, 1);
  }
  if (*v5)
    re::AudioEngineRunnableManager::removeReason(*v5, 2);
LABEL_38:
  v43 = (re::AudioManager_PHASE_StateMachine *)operator new();
  re::AudioManager_PHASE_StateMachine::AudioManager_PHASE_StateMachine(v43);
  v44 = std::unique_ptr<re::AudioManager_PHASE_StateMachine>::reset[abi:ne180100](v47, v43);
  v45 = *re::audioLogObjects(v44);
  if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)buf = 0;
    _os_log_debug_impl(&dword_224FE9000, v45, OS_LOG_TYPE_DEBUG, "AudioManager_PHASE created", buf, 2u);
  }

  return this;
}

void sub_22540D428(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

void re::AudioManager_PHASE::~AudioManager_PHASE(re::AudioManager_PHASE *this)
{
  id v2;
  int v3;
  int v4;
  std::__shared_weak_count *v5;

  v2 = **((id **)this + 39);
  objc_msgSend(v2, "cancel");

  v3 = atomic_load((unsigned int *)this + 139);
  if (v3 >= 1)
  {
    do
    {
      re::AudioManager_PHASE::stopEngine(this);
      v4 = atomic_load((unsigned int *)this + 139);
    }
    while (v4 > 0);
  }
  dispatch_sync(*((dispatch_queue_t *)this + 67), &__block_literal_global_5);
  dispatch_sync(*((dispatch_queue_t *)this + 68), &__block_literal_global_8);
  if (re::AudioManagerTelemetryReporter::m_managerQueue)
    dispatch_sync((dispatch_queue_t)re::AudioManagerTelemetryReporter::m_managerQueue, &__block_literal_global_83);
  std::shared_ptr<re::AssetManager>::~shared_ptr[abi:nn180100]((uint64_t)this + 872);
  std::unique_ptr<re::DisplayStateNotificationManager>::reset[abi:ne180100]((re::DisplayStateNotificationManager **)this + 108, 0);
  std::unique_ptr<re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>>,std::function<void ()(re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>>*)>>::~unique_ptr[abi:ne180100]((uint64_t *)this + 90);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned short>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned short>>>::~__hash_table((uint64_t)this + 616);
  std::__hash_table<std::__hash_value_type<std::string,re::AudioManager_PHASE::MixGroupState>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,re::AudioManager_PHASE::MixGroupState>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,re::AudioManager_PHASE::MixGroupState>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,re::AudioManager_PHASE::MixGroupState>>>::~__hash_table((uint64_t)this + 576);

  std::unique_ptr<re::AudioManager_PHASE_StateMachine>::reset[abi:ne180100]((re::AudioManager_PHASE_StateMachine **)this + 66, 0);
  std::unique_ptr<re::AudioManager_PHASE_Async>::reset[abi:ne180100]((re::AudioManager_PHASE_Async **)this + 65, 0);

  v5 = (std::__shared_weak_count *)*((_QWORD *)this + 63);
  if (v5)
    std::__shared_weak_count::__release_weak(v5);
  re::AudioManager::~AudioManager(this);
}

{
  re::AudioManager_PHASE::~AudioManager_PHASE(this);
  JUMPOUT(0x2276933B8);
}

void re::AudioManager_PHASE::stopEngine(re::AudioManager_PHASE *this)
{
  unsigned int *v1;
  int v2;
  NSObject *v3;
  uint8_t v4[16];

  v1 = (unsigned int *)((char *)this + 556);
  do
    v2 = __ldaxr(v1);
  while (__stlxr(v2 - 1, v1));
  if (v2 <= 0)
  {
    v3 = *re::audioLogObjects(this);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v4 = 0;
      _os_log_error_impl(&dword_224FE9000, v3, OS_LOG_TYPE_ERROR, "unbalanced call to AudioManager_PHASE::stopEngine()", v4, 2u);
    }
  }
}

void re::AudioManager_PHASE::addAudioEngineRunnableReason(uint64_t a1, int a2)
{
  float *v2;

  v2 = *(float **)(a1 + 872);
  if (v2)
    re::AudioEngineRunnableManager::addReason(v2, a2);
}

void re::AudioManager_PHASE::removeAudioEngineRunnableReason(uint64_t a1, int a2)
{
  _QWORD *v2;

  v2 = *(_QWORD **)(a1 + 872);
  if (v2)
    re::AudioEngineRunnableManager::removeReason(v2, a2);
}

void re::AudioManager_PHASE::setEngineQueue(uint64_t a1, void *a2)
{
  id v4;
  uint64_t v5;
  void *v6;

  v4 = a2;
  objc_storeStrong((id *)(a1 + 8), a2);
  v5 = *(_QWORD *)(a1 + 520);
  v6 = *(void **)(v5 + 416);
  *(_QWORD *)(v5 + 416) = v4;

}

void re::AudioManager_PHASE::triggerNotification(re::AudioManager *this, int a2)
{
  switch(a2)
  {
    case 0:
      re::AudioManager::configureSTS(this);
      break;
    case 1:
      re::AudioManager_PHASE::configureAndStartEngine(this);
      break;
    case 2:
      re::AudioManager_PHASE::triggerServiceLost(this);
      break;
    case 3:
      re::AudioManager_PHASE::triggerServiceReset(this);
      break;
    default:
      return;
  }
}

uint64_t re::AudioManager_PHASE::handlesPlaybackForFileAndBufferResources(re::AudioManager_PHASE *this)
{
  return 1;
}

void re::AudioManager_PHASE::configureAndStartEngine(re::AudioManager_PHASE *this)
{
  NSObject *v1;
  _QWORD block[5];

  if (*(_QWORD *)(*((_QWORD *)this + 109) + 24))
  {
    v1 = *((_QWORD *)this + 67);
    block[0] = MEMORY[0x24BDAC760];
    block[1] = 3221225472;
    block[2] = ___ZN2re18AudioManager_PHASE23configureAndStartEngineEv_block_invoke;
    block[3] = &__block_descriptor_40_e5_v8__0l;
    block[4] = this;
    dispatch_async(v1, block);
  }
}

void re::AudioManager_PHASE::triggerServiceLost(re::AudioManager_PHASE *this)
{
  re::AudioManagerTelemetryReporter *v2;
  uint64_t Instance;
  _QWORD block[5];

  re::AudioManager_PHASE_StateMachine::handleStateChangeEvent(*((_QWORD *)this + 66), 0, 0, 0);
  Instance = re::AudioManagerTelemetryReporter::getInstance(v2);
  block[0] = MEMORY[0x24BDAC760];
  block[1] = 3221225472;
  block[2] = ___ZN2re29AudioManagerTelemetryReporter23mediaServicesResetEventEv_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = Instance;
  dispatch_async((dispatch_queue_t)re::AudioManagerTelemetryReporter::m_managerQueue, block);
  re::AudioManager_PHASE_Async::notifyPlaybackClientsWithPreparedSoundsThatMediaServicesWereLost(*((_QWORD *)this + 65));
  re::AudioManager::triggerServiceLost(this);
}

void re::AudioManager_PHASE::triggerServiceReset(re::AudioManager_PHASE *this)
{
  re::AudioManager_PHASE_StateMachine::handleStateChangeEvent(*((_QWORD *)this + 66), 1, 0, 0);
  re::AudioManager_PHASE_Async::notifyPlaybackClientsWithPreparedSoundsThatMediaServicesWereReset(*((_QWORD *)this + 65));
  re::AudioManager::triggerServiceReset(this);
}

void re::AudioManager_PHASE::setPlaybackStateChangeHandlerForToken(uint64_t a1, unint64_t a2, void *a3)
{
  re::AudioManager_PHASE_Async::setPlaybackStateChangeHandlerForToken(*(_QWORD *)(a1 + 520), a2, a3);
}

void re::AudioManager_PHASE::playbackStateDidChangeForToken(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  re::AudioManager_PHASE_Async::playbackStateDidChangeForToken(*(os_unfair_lock_s **)(a1 + 520), a2, a3, a4);
}

uint64_t re::AudioManager_PHASE::playbackHostConnectionIdentifier(re::AudioManager_PHASE_Async **this)
{
  return re::AudioManager_PHASE_Async::playbackHostConnectionIdentifier(this[65]);
}

void re::AudioManager_PHASE::joinPlaybackHostingServiceAtEndpoint(uint64_t a1, void *a2)
{
  id v3;
  NSObject *v4;
  id v5;
  _QWORD v6[4];
  id v7;
  uint64_t v8;

  v3 = a2;
  v4 = *(NSObject **)(a1 + 536);
  v6[0] = MEMORY[0x24BDAC760];
  v6[1] = 3221225472;
  v6[2] = ___ZN2re18AudioManager_PHASE36joinPlaybackHostingServiceAtEndpointEPU24objcproto13OS_xpc_object8NSObject_block_invoke;
  v6[3] = &unk_24ED3D378;
  v7 = v3;
  v8 = a1;
  v5 = v3;
  dispatch_async(v4, v6);

}

void ___ZN2re18AudioManager_PHASE36joinPlaybackHostingServiceAtEndpointEPU24objcproto13OS_xpc_object8NSObject_block_invoke(uint64_t a1)
{
  re::AudioManager_PHASE_Async::joinPlaybackHostingServiceAtEndpoint(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 520), *(void **)(a1 + 32));
}

id re::AudioManager_PHASE::copyOrCreateEndpointForPlaybackHostingService(re::AudioManager_PHASE *this)
{
  uint64_t Instance;

  Instance = re::AudioManagerTelemetryReporter::getInstance(this);
  re::AudioManagerTelemetryReporter::initializeTimerWith(Instance, (uint64_t)this, *((void **)this + 1));
  return re::AudioManager_PHASE_Async::copyOrCreateEndpointForPlaybackHostingService(*((re::AudioManager_PHASE_Async **)this
                                                                                     + 65));
}

uint64_t re::AudioManager_PHASE::addPlaybackConnectionDisconnectCallback(uint64_t a1, void *a2)
{
  unint64_t v2;
  uint64_t v3;
  id v4;
  uint64_t v5;
  unint64_t v6;
  void *v7;
  unint64_t v8;
  uint8x8_t v9;
  _QWORD *v10;
  _QWORD *i;
  unint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  float v15;
  float v16;
  _BOOL8 v17;
  unint64_t v18;
  unint64_t v19;
  int8x8_t prime;
  void *v21;
  void *v22;
  uint64_t v23;
  _QWORD *v24;
  unint64_t v25;
  uint8x8_t v26;
  unint64_t v27;
  uint8x8_t v28;
  uint64_t v29;
  _QWORD *v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD *v34;
  unint64_t v35;
  uint64_t v36;
  void *v38;

  v3 = *(_QWORD *)(a1 + 520);
  v4 = a2;
  os_unfair_lock_lock((os_unfair_lock_t)(v3 + 432));
  v5 = *(_QWORD *)(v3 + 480) + 1;
  do
  {
    v6 = v5;
    v5 = 1;
  }
  while (!v6);
  *(_QWORD *)(v3 + 480) = v6;
  v7 = _Block_copy(v4);
  v8 = *(_QWORD *)(v3 + 448);
  if (v8)
  {
    v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      v2 = v6;
      if (v8 <= v6)
        v2 = v6 % v8;
    }
    else
    {
      v2 = (v8 - 1) & v6;
    }
    v10 = *(_QWORD **)(*(_QWORD *)(v3 + 440) + 8 * v2);
    if (v10)
    {
      for (i = (_QWORD *)*v10; i; i = (_QWORD *)*i)
      {
        v12 = i[1];
        if (v12 == v6)
        {
          if (i[2] == v6)
            goto LABEL_76;
        }
        else
        {
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= v8)
              v12 %= v8;
          }
          else
          {
            v12 &= v8 - 1;
          }
          if (v12 != v2)
            break;
        }
      }
    }
  }
  v13 = operator new(0x20uLL);
  v14 = (_QWORD *)(v3 + 456);
  *v13 = 0;
  v13[1] = v6;
  v13[2] = v6;
  v13[3] = v7;
  v15 = (float)(unint64_t)(*(_QWORD *)(v3 + 464) + 1);
  v16 = *(float *)(v3 + 472);
  if (v8 && (float)(v16 * (float)v8) >= v15)
  {
    v6 = v2;
    goto LABEL_66;
  }
  v17 = 1;
  if (v8 >= 3)
    v17 = (v8 & (v8 - 1)) != 0;
  v18 = v17 | (2 * v8);
  v19 = vcvtps_u32_f32(v15 / v16);
  if (v18 <= v19)
    prime = (int8x8_t)v19;
  else
    prime = (int8x8_t)v18;
  if (*(_QWORD *)&prime == 1)
  {
    prime = (int8x8_t)2;
  }
  else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
  {
    prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
    v8 = *(_QWORD *)(v3 + 448);
  }
  if (*(_QWORD *)&prime <= v8)
  {
    if (*(_QWORD *)&prime >= v8)
      goto LABEL_62;
    v27 = vcvtps_u32_f32((float)*(unint64_t *)(v3 + 464) / *(float *)(v3 + 472));
    if (v8 < 3 || (v28 = (uint8x8_t)vcnt_s8((int8x8_t)v8), v28.i16[0] = vaddlv_u8(v28), v28.u32[0] > 1uLL))
    {
      v27 = std::__next_prime(v27);
    }
    else
    {
      v29 = 1 << -(char)__clz(v27 - 1);
      if (v27 >= 2)
        v27 = v29;
    }
    if (*(_QWORD *)&prime <= v27)
      prime = (int8x8_t)v27;
    if (*(_QWORD *)&prime >= v8)
    {
      v8 = *(_QWORD *)(v3 + 448);
      goto LABEL_62;
    }
    if (!*(_QWORD *)&prime)
    {
      v38 = *(void **)(v3 + 440);
      *(_QWORD *)(v3 + 440) = 0;
      if (v38)
        operator delete(v38);
      v8 = 0;
      *(_QWORD *)(v3 + 448) = 0;
      goto LABEL_62;
    }
  }
  if (*(_QWORD *)&prime >> 61)
    std::__throw_bad_array_new_length[abi:ne180100]();
  v21 = operator new(8 * *(_QWORD *)&prime);
  v22 = *(void **)(v3 + 440);
  *(_QWORD *)(v3 + 440) = v21;
  if (v22)
    operator delete(v22);
  v23 = 0;
  *(int8x8_t *)(v3 + 448) = prime;
  do
    *(_QWORD *)(*(_QWORD *)(v3 + 440) + 8 * v23++) = 0;
  while (*(_QWORD *)&prime != v23);
  v24 = (_QWORD *)*v14;
  if (*v14)
  {
    v25 = v24[1];
    v26 = (uint8x8_t)vcnt_s8(prime);
    v26.i16[0] = vaddlv_u8(v26);
    if (v26.u32[0] > 1uLL)
    {
      if (v25 >= *(_QWORD *)&prime)
        v25 %= *(_QWORD *)&prime;
    }
    else
    {
      v25 &= *(_QWORD *)&prime - 1;
    }
    *(_QWORD *)(*(_QWORD *)(v3 + 440) + 8 * v25) = v14;
    v30 = (_QWORD *)*v24;
    if (*v24)
    {
      do
      {
        v31 = v30[1];
        if (v26.u32[0] > 1uLL)
        {
          if (v31 >= *(_QWORD *)&prime)
            v31 %= *(_QWORD *)&prime;
        }
        else
        {
          v31 &= *(_QWORD *)&prime - 1;
        }
        if (v31 != v25)
        {
          v32 = *(_QWORD *)(v3 + 440);
          if (!*(_QWORD *)(v32 + 8 * v31))
          {
            *(_QWORD *)(v32 + 8 * v31) = v24;
            goto LABEL_58;
          }
          *v24 = *v30;
          *v30 = **(_QWORD **)(*(_QWORD *)(v3 + 440) + 8 * v31);
          **(_QWORD **)(*(_QWORD *)(v3 + 440) + 8 * v31) = v30;
          v30 = v24;
        }
        v31 = v25;
LABEL_58:
        v24 = v30;
        v30 = (_QWORD *)*v30;
        v25 = v31;
      }
      while (v30);
    }
  }
  v8 = (unint64_t)prime;
LABEL_62:
  if ((v8 & (v8 - 1)) != 0)
  {
    if (v8 <= v6)
      v6 %= v8;
  }
  else
  {
    v6 &= v8 - 1;
  }
LABEL_66:
  v33 = *(_QWORD *)(v3 + 440);
  v34 = *(_QWORD **)(v33 + 8 * v6);
  if (v34)
  {
    *v13 = *v34;
LABEL_74:
    *v34 = v13;
    goto LABEL_75;
  }
  *v13 = *v14;
  *v14 = v13;
  *(_QWORD *)(v33 + 8 * v6) = v14;
  if (*v13)
  {
    v35 = *(_QWORD *)(*v13 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v35 >= v8)
        v35 %= v8;
    }
    else
    {
      v35 &= v8 - 1;
    }
    v34 = (_QWORD *)(*(_QWORD *)(v3 + 440) + 8 * v35);
    goto LABEL_74;
  }
LABEL_75:
  v7 = 0;
  ++*(_QWORD *)(v3 + 464);
LABEL_76:

  v36 = *(_QWORD *)(v3 + 480);
  os_unfair_lock_unlock((os_unfair_lock_t)(v3 + 432));

  return v36;
}

void sub_22540DDC4(_Unwind_Exception *a1)
{
  void *v1;
  os_unfair_lock_s *v2;
  id *v3;

  operator delete(v3);
  os_unfair_lock_unlock(v2);

  _Unwind_Resume(a1);
}

void re::AudioManager_PHASE::removePlaybackConnectionDisconnectCallback(re::AudioManager_PHASE *this, unint64_t a2)
{
  uint64_t v3;
  int8x8_t v4;
  uint8x8_t v5;
  unint64_t v6;
  uint64_t v7;
  void **v8;
  _QWORD *v9;
  uint64_t v10;
  unint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  _QWORD *v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;

  v3 = *((_QWORD *)this + 65);
  os_unfair_lock_lock((os_unfair_lock_t)(v3 + 432));
  v4 = *(int8x8_t *)(v3 + 448);
  if (!*(_QWORD *)&v4)
    goto LABEL_47;
  v5 = (uint8x8_t)vcnt_s8(v4);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    v6 = a2;
    if (*(_QWORD *)&v4 <= a2)
      v6 = a2 % *(_QWORD *)&v4;
  }
  else
  {
    v6 = (*(_QWORD *)&v4 - 1) & a2;
  }
  v7 = *(_QWORD *)(v3 + 440);
  v8 = *(void ***)(v7 + 8 * v6);
  if (!v8)
    goto LABEL_47;
  v9 = *v8;
  if (!*v8)
    goto LABEL_47;
  v10 = *(_QWORD *)&v4 - 1;
  while (1)
  {
    v11 = v9[1];
    if (v11 == a2)
      break;
    if (v5.u32[0] > 1uLL)
    {
      if (v11 >= *(_QWORD *)&v4)
        v11 %= *(_QWORD *)&v4;
    }
    else
    {
      v11 &= v10;
    }
    if (v11 != v6)
      goto LABEL_47;
LABEL_17:
    v9 = (_QWORD *)*v9;
    if (!v9)
      goto LABEL_47;
  }
  if (v9[2] != a2)
    goto LABEL_17;
  v12 = (_QWORD *)*v9;
  if (v5.u32[0] > 1uLL)
  {
    if (*(_QWORD *)&v4 <= a2)
      a2 %= *(_QWORD *)&v4;
  }
  else
  {
    a2 &= v10;
  }
  v13 = *(_QWORD **)(v7 + 8 * a2);
  do
  {
    v14 = v13;
    v13 = (_QWORD *)*v13;
  }
  while (v13 != v9);
  if (v14 == (_QWORD *)(v3 + 456))
    goto LABEL_36;
  v15 = v14[1];
  if (v5.u32[0] > 1uLL)
  {
    if (v15 >= *(_QWORD *)&v4)
      v15 %= *(_QWORD *)&v4;
  }
  else
  {
    v15 &= v10;
  }
  if (v15 == a2)
  {
LABEL_38:
    if (v12)
    {
      v16 = v12[1];
      goto LABEL_40;
    }
  }
  else
  {
LABEL_36:
    if (!v12)
      goto LABEL_37;
    v16 = v12[1];
    if (v5.u32[0] > 1uLL)
    {
      v17 = v12[1];
      if (v16 >= *(_QWORD *)&v4)
        v17 = v16 % *(_QWORD *)&v4;
    }
    else
    {
      v17 = v16 & v10;
    }
    if (v17 != a2)
    {
LABEL_37:
      *(_QWORD *)(v7 + 8 * a2) = 0;
      v12 = (_QWORD *)*v9;
      goto LABEL_38;
    }
LABEL_40:
    if (v5.u32[0] > 1uLL)
    {
      if (v16 >= *(_QWORD *)&v4)
        v16 %= *(_QWORD *)&v4;
    }
    else
    {
      v16 &= v10;
    }
    if (v16 != a2)
    {
      *(_QWORD *)(*(_QWORD *)(v3 + 440) + 8 * v16) = v14;
      v12 = (_QWORD *)*v9;
    }
  }
  *v14 = v12;
  *v9 = 0;
  --*(_QWORD *)(v3 + 464);

  operator delete(v9);
LABEL_47:
  os_unfair_lock_unlock((os_unfair_lock_t)(v3 + 432));
}

uint64_t re::AudioManager_PHASE::playbackConnectionDidDisconnect(os_unfair_lock_s **this)
{
  return re::AudioManager_PHASE_Async::triggerPlaybackConnectionDisconnectCallbacks(this[65]);
}

uint64_t re::AudioManager_PHASE::setIsHostingSharedSimulation(uint64_t this, char a2)
{
  *(_BYTE *)(this + 552) = a2;
  return this;
}

uint64_t re::AudioManager_PHASE::getIsHostingSharedSimulation(re::AudioManager_PHASE *this)
{
  return *((unsigned __int8 *)this + 552);
}

uint64_t re::AudioManager_PHASE::controlsPlaybackForGeneratorResources(re::AudioManager_PHASE *this)
{
  return 1;
}

void re::AudioManager_PHASE::setExternalSourceControl(re::AudioManager_PHASE *this, char a2)
{
  NSObject *v2;
  _QWORD v3[5];
  char v4;

  *((_BYTE *)this + 272) = a2;
  v2 = *((_QWORD *)this + 67);
  v3[0] = MEMORY[0x24BDAC760];
  v3[1] = 3221225472;
  v3[2] = ___ZN2re18AudioManager_PHASE24setExternalSourceControlEb_block_invoke;
  v3[3] = &__block_descriptor_41_e5_v8__0l;
  v3[4] = this;
  v4 = a2;
  dispatch_async(v2, v3);
}

uint64_t ___ZN2re18AudioManager_PHASE24setExternalSourceControlEb_block_invoke(uint64_t result)
{
  atomic_store(*(_BYTE *)(result + 40), (unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 520) + 408));
  return result;
}

_QWORD *re::AudioManager_PHASE::loadAssetsOnReset(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *result;
  uint64_t v8;
  _QWORD v9[5];
  _BYTE v10[24];
  _BYTE *v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v2 = *(NSObject **)(a1 + 536);
  v9[0] = MEMORY[0x24BDAC760];
  v9[1] = 3321888768;
  v9[2] = ___ZN2re18AudioManager_PHASE17loadAssetsOnResetENSt3__18functionIFNS1_13unordered_mapIyNS1_10shared_ptrINS_18PersistedAssetDataEEENS1_4hashIyEENS1_8equal_toIyEENS1_9allocatorINS1_4pairIKyS6_EEEEEEvEEE_block_invoke;
  v9[3] = &__block_descriptor_72_ea8_40c152_ZTSKNSt3__18functionIFNS_13unordered_mapIyNS_10shared_ptrIN2re18PersistedAssetDataEEENS_4hashIyEENS_8equal_toIyEENS_9allocatorINS_4pairIKyS5_EEEEEEvEEE_e5_v8__0l;
  v9[4] = a1;
  std::__function::__value_func<void ()(void)>::__value_func[abi:nn180100]((uint64_t)v10, a2);
  dispatch_async(v2, v9);
  result = v11;
  if (v11 == v10)
  {
    v8 = 4;
    result = v10;
  }
  else
  {
    if (!v11)
      return result;
    v8 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(_QWORD *, uint64_t, uint64_t, uint64_t, uint64_t))(*result + 8 * v8))(result, v3, v4, v5, v6);
}

void ___ZN2re18AudioManager_PHASE17loadAssetsOnResetENSt3__18functionIFNS1_13unordered_mapIyNS1_10shared_ptrINS_18PersistedAssetDataEEENS1_4hashIyEENS1_8equal_toIyEENS1_9allocatorINS1_4pairIKyS6_EEEEEEvEEE_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD v4[5];

  v2 = *(_QWORD *)(a1 + 64);
  if (!v2)
    std::__throw_bad_function_call[abi:ne180100]();
  v3 = *(_QWORD *)(a1 + 32);
  (*(void (**)(_QWORD *__return_ptr))(*(_QWORD *)v2 + 48))(v4);
  re::AudioManager_PHASE::loadAssetsFromGenerator(v3, (uint64_t)v4);
  std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<re::PersistedAssetData>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<re::PersistedAssetData>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<re::PersistedAssetData>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<re::PersistedAssetData>>>>::~__hash_table((uint64_t)v4);
  re::AudioManager_PHASE_StateMachine::handleStateChangeEvent(*(_QWORD *)(v3 + 528), 3, 0, 0);
}

void sub_22540E1B4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<re::PersistedAssetData>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<re::PersistedAssetData>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<re::PersistedAssetData>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<re::PersistedAssetData>>>>::~__hash_table((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t re::AudioManager_PHASE::loadAssetsFromGenerator(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  pthread_rwlock_t *v6;
  void *v7;
  void *v8;
  _QWORD *v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  void *v14;
  __int128 v15;
  id v16;
  id v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  _OWORD v23[2];
  char v24;
  uint64_t v25;
  char v26;
  uint64_t v27;
  int v29;
  char v30;
  uint64_t v31;
  std::__shared_weak_count *v32;
  id *v33;
  uint64_t v34;

  v4 = *(_QWORD *)(a1 + 520);
  v6 = *(pthread_rwlock_t **)(v4 + 232);
  v5 = v4 + 232;
  v33 = (id *)(v5 + 16);
  v34 = v5;
  pthread_rwlock_rdlock(v6);
  objc_msgSend(*(id *)(v5 + 16), "engine");
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v7, "assetRegistry");
  v8 = (void *)objc_claimAutoreleasedReturnValue();

  v9 = *(_QWORD **)(a2 + 16);
  if (v9)
  {
    do
    {
      v11 = v9[3];
      v10 = (std::__shared_weak_count *)v9[4];
      v31 = v11;
      v32 = v10;
      if (v10)
      {
        p_shared_owners = (unint64_t *)&v10->__shared_owners_;
        do
          v13 = __ldxr(p_shared_owners);
        while (__stxr(v13 + 1, p_shared_owners));
      }
      v14 = _Block_copy(*(const void **)v11);
      v15 = *(_OWORD *)(v11 + 32);
      v23[0] = *(_OWORD *)(v11 + 16);
      v23[1] = v15;
      v24 = *(_BYTE *)(v11 + 48);
      if (v24)
        re::DynamicString::DynamicString((re::DynamicString *)&v25, (const re::DynamicString *)(v11 + 56));
      if (*(_BYTE *)(v11 + 88))
        v29 = *(_DWORD *)(v11 + 92);
      v30 = *(_BYTE *)(v11 + 96);
      v16 = *(id *)(v11 + 8);
      (*((void (**)(void *, void *, id, _OWORD *, _QWORD))v14 + 2))(v14, v8, v16, v23, *(_QWORD *)(*(_QWORD *)(a1 + 520) + 560));

      v17 = *v33;
      objc_msgSend(v17, "addAudioAssetID:configuration:", v9[2], v23);

      if (v24 && v25 && (v26 & 1) != 0)
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v25 + 40))(v25, v27, v18, v19);

      if (v10)
      {
        v20 = (unint64_t *)&v10->__shared_owners_;
        do
          v21 = __ldaxr(v20);
        while (__stlxr(v21 - 1, v20));
        if (!v21)
        {
          ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
          std::__shared_weak_count::__release_weak(v10);
        }
      }
      v9 = (_QWORD *)*v9;
    }
    while (v9);
    v5 = v34;
  }

  return pthread_rwlock_unlock(*(pthread_rwlock_t **)v5);
}

void sub_22540E380(_Unwind_Exception *a1)
{
  void *v1;
  uint64_t v2;

  std::lock_guard<re::ReadWriteLock::Reader>::~lock_guard[abi:ne180100]((pthread_rwlock_t ***)(v2 - 72));
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_40c152_ZTSKNSt3__18functionIFNS_13unordered_mapIyNS_10shared_ptrIN2re18PersistedAssetDataEEENS_4hashIyEENS_8equal_toIyEENS_9allocatorINS_4pairIKyS5_EEEEEEvEEE(uint64_t a1, uint64_t a2)
{
  return std::__function::__value_func<void ()(void)>::__value_func[abi:nn180100](a1 + 40, a2 + 40);
}

_QWORD *__destroy_helper_block_ea8_40c152_ZTSKNSt3__18functionIFNS_13unordered_mapIyNS_10shared_ptrIN2re18PersistedAssetDataEEENS_4hashIyEENS_8equal_toIyEENS_9allocatorINS_4pairIKyS5_EEEEEEvEEE(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 40);
  result = *(_QWORD **)(a1 + 64);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

_QWORD *re::AudioManager_PHASE::loadAssetsOnSceneRegister(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *result;
  uint64_t v8;
  _QWORD v9[5];
  _BYTE v10[24];
  _BYTE *v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v2 = *(NSObject **)(a1 + 536);
  v9[0] = MEMORY[0x24BDAC760];
  v9[1] = 3321888768;
  v9[2] = ___ZN2re18AudioManager_PHASE25loadAssetsOnSceneRegisterENSt3__18functionIFNS1_13unordered_mapIyNS1_10shared_ptrINS_18PersistedAssetDataEEENS1_4hashIyEENS1_8equal_toIyEENS1_9allocatorINS1_4pairIKyS6_EEEEEEvEEE_block_invoke;
  v9[3] = &__block_descriptor_72_ea8_40c152_ZTSKNSt3__18functionIFNS_13unordered_mapIyNS_10shared_ptrIN2re18PersistedAssetDataEEENS_4hashIyEENS_8equal_toIyEENS_9allocatorINS_4pairIKyS5_EEEEEEvEEE_e5_v8__0l;
  v9[4] = a1;
  std::__function::__value_func<void ()(void)>::__value_func[abi:nn180100]((uint64_t)v10, a2);
  dispatch_async(v2, v9);
  result = v11;
  if (v11 == v10)
  {
    v8 = 4;
    result = v10;
  }
  else
  {
    if (!v11)
      return result;
    v8 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(_QWORD *, uint64_t, uint64_t, uint64_t, uint64_t))(*result + 8 * v8))(result, v3, v4, v5, v6);
}

uint64_t ___ZN2re18AudioManager_PHASE25loadAssetsOnSceneRegisterENSt3__18functionIFNS1_13unordered_mapIyNS1_10shared_ptrINS_18PersistedAssetDataEEENS1_4hashIyEENS1_8equal_toIyEENS1_9allocatorINS1_4pairIKyS6_EEEEEEvEEE_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD v5[5];

  v2 = *(_QWORD *)(a1 + 64);
  if (!v2)
    std::__throw_bad_function_call[abi:ne180100]();
  v3 = *(_QWORD *)(a1 + 32);
  (*(void (**)(_QWORD *__return_ptr))(*(_QWORD *)v2 + 48))(v5);
  re::AudioManager_PHASE::loadAssetsFromGenerator(v3, (uint64_t)v5);
  return std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<re::PersistedAssetData>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<re::PersistedAssetData>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<re::PersistedAssetData>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<re::PersistedAssetData>>>>::~__hash_table((uint64_t)v5);
}

void sub_22540E54C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<re::PersistedAssetData>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<re::PersistedAssetData>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<re::PersistedAssetData>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<re::PersistedAssetData>>>>::~__hash_table((uint64_t)va);
  _Unwind_Resume(a1);
}

void re::AudioManager_PHASE::systemFinishedRecovery(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t a4)
{
  if (a2 <= 5)
    re::AudioManager_PHASE_StateMachine::handleStateChangeEvent(*(_QWORD *)(a1 + 528), dword_226100B64[a2], a3, a4);
}

void re::AudioManager_PHASE::registerSceneForSystemRecovery(re *a1, int a2, uint64_t a3)
{
  uint64_t v4;
  NSObject *v5;
  int v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  void (*v10)(uint64_t);
  void *v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  switch(a2)
  {
    case 0:
      v4 = *((_QWORD *)a1 + 66);
      v5 = *(NSObject **)(v4 + 40);
      v8 = MEMORY[0x24BDAC760];
      v9 = 3221225472;
      v10 = ___ZN2re31AudioManager_PHASE_StateMachine28registerRequiredRecoveryStepENS_36AudioManager_PHASE_StateMachineEventEy_block_invoke;
      v11 = &__block_descriptor_52_e5_v8__0l;
      v6 = 6;
      goto LABEL_9;
    case 2:
      v4 = *((_QWORD *)a1 + 66);
      v5 = *(NSObject **)(v4 + 40);
      v8 = MEMORY[0x24BDAC760];
      v9 = 3221225472;
      v10 = ___ZN2re31AudioManager_PHASE_StateMachine28registerRequiredRecoveryStepENS_36AudioManager_PHASE_StateMachineEventEy_block_invoke;
      v11 = &__block_descriptor_52_e5_v8__0l;
      v6 = 5;
      goto LABEL_9;
    case 3:
      v4 = *((_QWORD *)a1 + 66);
      v5 = *(NSObject **)(v4 + 40);
      v8 = MEMORY[0x24BDAC760];
      v9 = 3221225472;
      v10 = ___ZN2re31AudioManager_PHASE_StateMachine28registerRequiredRecoveryStepENS_36AudioManager_PHASE_StateMachineEventEy_block_invoke;
      v11 = &__block_descriptor_52_e5_v8__0l;
      v6 = 7;
      goto LABEL_9;
    case 4:
      v4 = *((_QWORD *)a1 + 66);
      v5 = *(NSObject **)(v4 + 40);
      v8 = MEMORY[0x24BDAC760];
      v9 = 3221225472;
      v10 = ___ZN2re31AudioManager_PHASE_StateMachine28registerRequiredRecoveryStepENS_36AudioManager_PHASE_StateMachineEventEy_block_invoke;
      v11 = &__block_descriptor_52_e5_v8__0l;
      v6 = 8;
      goto LABEL_9;
    case 5:
      v4 = *((_QWORD *)a1 + 66);
      v5 = *(NSObject **)(v4 + 40);
      v8 = MEMORY[0x24BDAC760];
      v9 = 3221225472;
      v10 = ___ZN2re31AudioManager_PHASE_StateMachine28registerRequiredRecoveryStepENS_36AudioManager_PHASE_StateMachineEventEy_block_invoke;
      v11 = &__block_descriptor_52_e5_v8__0l;
      v6 = 9;
LABEL_9:
      v14 = v6;
      v12 = v4;
      v13 = a3;
      dispatch_async(v5, &v8);
      break;
    default:
      v7 = *re::audioLogObjects(a1);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        LODWORD(v8) = 67109120;
        HIDWORD(v8) = a2;
        _os_log_error_impl(&dword_224FE9000, v7, OS_LOG_TYPE_ERROR, "[RE/MediaServices] [EngineState] Invalid system registered for system recovery, system id %d", (uint8_t *)&v8, 8u);
      }
      break;
  }
}

void re::AudioManager_PHASE::unregisterSceneFromSystemRecovery(re *a1, int a2, uint64_t a3)
{
  uint64_t v4;
  NSObject *v5;
  int v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  void (*v10)(uint64_t);
  void *v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  switch(a2)
  {
    case 0:
      v4 = *((_QWORD *)a1 + 66);
      v5 = *(NSObject **)(v4 + 40);
      v8 = MEMORY[0x24BDAC760];
      v9 = 3221225472;
      v10 = ___ZN2re31AudioManager_PHASE_StateMachine30unregisterRequiredRecoveryStepENS_36AudioManager_PHASE_StateMachineEventEy_block_invoke;
      v11 = &__block_descriptor_52_e5_v8__0l;
      v6 = 6;
      goto LABEL_9;
    case 2:
      v4 = *((_QWORD *)a1 + 66);
      v5 = *(NSObject **)(v4 + 40);
      v8 = MEMORY[0x24BDAC760];
      v9 = 3221225472;
      v10 = ___ZN2re31AudioManager_PHASE_StateMachine30unregisterRequiredRecoveryStepENS_36AudioManager_PHASE_StateMachineEventEy_block_invoke;
      v11 = &__block_descriptor_52_e5_v8__0l;
      v6 = 5;
      goto LABEL_9;
    case 3:
      v4 = *((_QWORD *)a1 + 66);
      v5 = *(NSObject **)(v4 + 40);
      v8 = MEMORY[0x24BDAC760];
      v9 = 3221225472;
      v10 = ___ZN2re31AudioManager_PHASE_StateMachine30unregisterRequiredRecoveryStepENS_36AudioManager_PHASE_StateMachineEventEy_block_invoke;
      v11 = &__block_descriptor_52_e5_v8__0l;
      v6 = 7;
      goto LABEL_9;
    case 4:
      v4 = *((_QWORD *)a1 + 66);
      v5 = *(NSObject **)(v4 + 40);
      v8 = MEMORY[0x24BDAC760];
      v9 = 3221225472;
      v10 = ___ZN2re31AudioManager_PHASE_StateMachine30unregisterRequiredRecoveryStepENS_36AudioManager_PHASE_StateMachineEventEy_block_invoke;
      v11 = &__block_descriptor_52_e5_v8__0l;
      v6 = 8;
      goto LABEL_9;
    case 5:
      v4 = *((_QWORD *)a1 + 66);
      v5 = *(NSObject **)(v4 + 40);
      v8 = MEMORY[0x24BDAC760];
      v9 = 3221225472;
      v10 = ___ZN2re31AudioManager_PHASE_StateMachine30unregisterRequiredRecoveryStepENS_36AudioManager_PHASE_StateMachineEventEy_block_invoke;
      v11 = &__block_descriptor_52_e5_v8__0l;
      v6 = 9;
LABEL_9:
      v14 = v6;
      v12 = v4;
      v13 = a3;
      dispatch_async(v5, &v8);
      break;
    default:
      v7 = *re::audioLogObjects(a1);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        LODWORD(v8) = 67109120;
        HIDWORD(v8) = a2;
        _os_log_error_impl(&dword_224FE9000, v7, OS_LOG_TYPE_ERROR, "[RE/MediaServices] [EngineState] Invalid system unregistered from system recovery, system id %d", (uint8_t *)&v8, 8u);
      }
      break;
  }
}

BOOL re::AudioManager_PHASE::isAudioManagerStateReady(re::AudioManager_PHASE *this)
{
  os_unfair_lock_s *v1;

  v1 = (os_unfair_lock_s *)*((_QWORD *)this + 66);
  return !v1 || re::AudioManager_PHASE_StateMachine::getCurrentStateType(v1) == 2;
}

void re::AudioManager_PHASE::clearAllRenderingState(re::AudioManager_PHASE *this)
{
  void *v2;
  NSObject *v3;
  id v4;
  __int128 v5;
  _QWORD block[4];
  __int128 v7;
  id v8;
  re::AudioManager_PHASE *v9;
  __int128 v10;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;

  re::AudioManager::clearAllRenderingState(this);
  v5 = *((_OWORD *)this + 42);
  v12 = *((_OWORD *)this + 43);
  v13 = *((_QWORD *)this + 88);
  re::AudioManager_PHASE_Async::createPhaseContext(*((_QWORD *)this + 65), *((void **)this + 67));
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  atomic_store(0, (unint64_t *)(*((_QWORD *)this + 65) + 424));
  v3 = *((_QWORD *)this + 67);
  block[0] = MEMORY[0x24BDAC760];
  block[1] = 3321888768;
  block[2] = ___ZN2re18AudioManager_PHASE22clearAllRenderingStateEv_block_invoke;
  block[3] = &unk_24ED3E448;
  v8 = v2;
  v9 = this;
  v10 = v12;
  v11 = v13;
  v7 = v5;
  v4 = v2;
  dispatch_async(v3, block);

}

void ___ZN2re18AudioManager_PHASE22clearAllRenderingStateEv_block_invoke(uint64_t a1)
{
  uint64_t v2;
  re *v3;
  NSObject *v4;
  simd_quatf v5;
  uint64_t v6;
  uint64_t i;
  int v8;
  uint8_t v9[16];

  v2 = *(_QWORD *)(a1 + 56);
  re::AudioManager_PHASE_Async::swapPhaseContext(*(re::AudioManager_PHASE_Async **)(v2 + 520), *(REPHASEContext **)(a1 + 48));
  v3 = (re *)objc_claimAutoreleasedReturnValue();
  v4 = *re::audioLogObjects(v3);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v9 = 0;
    _os_log_impl(&dword_224FE9000, v4, OS_LOG_TYPE_DEFAULT, "[RE/MediaServices] Clearing old phase context and resetting state on new context.", v9, 2u);
  }
  -[re stopAllAndReset](v3, "stopAllAndReset");
  re::AudioManager::setSceneReverbPreset((_QWORD *)v2, *(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 64), *(unsigned __int8 *)(a1 + 72));
  re::AudioManager_PHASE_Async::setSceneReverbPreset(*(_QWORD *)(v2 + 520), *(_QWORD *)(a1 + 64));
  v5 = *(simd_quatf *)(a1 + 32);
  re::AudioManager_PHASE_Async::setSpaceBlendTargetPresetOrientation(*(re::AudioManager_PHASE_Async **)(v2 + 520), v5);
  os_unfair_lock_lock((os_unfair_lock_t)(v2 + 568));
  if (*(_QWORD *)(v2 + 600))
  {
    std::__hash_table<std::__hash_value_type<std::string,re::AudioManager_PHASE::MixGroupState>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,re::AudioManager_PHASE::MixGroupState>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,re::AudioManager_PHASE::MixGroupState>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,re::AudioManager_PHASE::MixGroupState>>>::__deallocate_node(v2 + 576, *(_QWORD **)(v2 + 592));
    *(_QWORD *)(v2 + 592) = 0;
    v6 = *(_QWORD *)(v2 + 584);
    if (v6)
    {
      for (i = 0; i != v6; ++i)
        *(_QWORD *)(*(_QWORD *)(v2 + 576) + 8 * i) = 0;
    }
    *(_QWORD *)(v2 + 600) = 0;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 568));
  v8 = atomic_load((unsigned int *)(v2 + 556));
  if (v8 >= 1 && *(_QWORD *)(*(_QWORD *)(v2 + 872) + 24))
    re::AudioManager_PHASE_Async::configureAndStartEngine(*(_QWORD *)(v2 + 520));
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::clear((_QWORD *)(v2 + 616));
  re::AudioManager_PHASE_StateMachine::handleStateChangeEvent(*(_QWORD *)(v2 + 528), 4, 0, 0);

}

void sub_22540EBBC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void re::AudioManager_PHASE::recoverSTS(re::AudioManager_PHASE *this)
{
  NSObject *v1;
  _QWORD block[5];

  v1 = *((_QWORD *)this + 67);
  block[0] = MEMORY[0x24BDAC760];
  block[1] = 3221225472;
  block[2] = ___ZN2re18AudioManager_PHASE10recoverSTSEv_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = this;
  dispatch_async(v1, block);
}

void ___ZN2re18AudioManager_PHASE10recoverSTSEv_block_invoke(uint64_t a1)
{
  uint64_t *v1;

  v1 = *(uint64_t **)(a1 + 32);
  re::AudioManager::configureSTS((re::AudioManager *)v1);
  re::AudioManager_PHASE_StateMachine::handleStateChangeEvent(v1[66], 2, 0, 0);
}

void re::AudioManager_PHASE::startEngine(re::AudioManager_PHASE *this)
{
  unsigned int *v1;
  unsigned int v2;

  v1 = (unsigned int *)((char *)this + 556);
  do
    v2 = __ldaxr(v1);
  while (__stlxr(v2 + 1, v1));
  if (!v2)
    re::AudioManager_PHASE::configureAndStartEngine(this);
}

uint64_t re::AudioManager_PHASE::getStartEngineCount(re::AudioManager_PHASE *this)
{
  return atomic_load((unsigned int *)this + 139);
}

uint64_t re::AudioManager_PHASE::updateEngine(re::AudioManager_PHASE *this)
{
  uint64_t v1;
  pthread_rwlock_t *v2;

  v1 = *((_QWORD *)this + 65);
  v2 = *(pthread_rwlock_t **)(v1 + 232);
  v1 += 232;
  pthread_rwlock_rdlock(v2);
  objc_msgSend(*(id *)(v1 + 16), "update", v1 + 16, v1);
  return pthread_rwlock_unlock(*(pthread_rwlock_t **)v1);
}

void sub_22540ECDC(_Unwind_Exception *a1)
{
  pthread_rwlock_t ***v1;

  std::lock_guard<re::ReadWriteLock::Reader>::~lock_guard[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

id re::AudioManager_PHASE::getAudioEnginePHASE(re::AudioManager_PHASE *this)
{
  NSObject *v1;
  id v2;
  _QWORD v4[6];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t (*v8)(uint64_t, uint64_t);
  void (*v9)(uint64_t);
  id v10;

  v5 = 0;
  v6 = &v5;
  v7 = 0x3032000000;
  v8 = __Block_byref_object_copy__4;
  v9 = __Block_byref_object_dispose__4;
  v10 = 0;
  v1 = *((_QWORD *)this + 67);
  v4[0] = MEMORY[0x24BDAC760];
  v4[1] = 3221225472;
  v4[2] = ___ZNK2re18AudioManager_PHASE19getAudioEnginePHASEEv_block_invoke;
  v4[3] = &unk_24ED3E480;
  v4[4] = &v5;
  v4[5] = this;
  dispatch_sync(v1, v4);
  v2 = (id)v6[5];
  _Block_object_dispose(&v5, 8);

  return v2;
}

uint64_t __Block_byref_object_copy__4(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__4(uint64_t a1)
{

}

void ___ZNK2re18AudioManager_PHASE19getAudioEnginePHASEEv_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  re::AudioManager_PHASE_Async::getAudioEnginePHASE(*(pthread_rwlock_t ***)(*(_QWORD *)(a1 + 40) + 520));
  v2 = objc_claimAutoreleasedReturnValue();
  v3 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v4 = *(void **)(v3 + 40);
  *(_QWORD *)(v3 + 40) = v2;

}

__n128 re::AudioManager_PHASE::getPHASESourceTransformForToken(re::AudioManager_PHASE *this, uint64_t a2)
{
  uint64_t v3;
  pthread_rwlock_t *v4;
  void *v5;
  __int128 v6;
  __int128 v8;

  v3 = *((_QWORD *)this + 65);
  v4 = *(pthread_rwlock_t **)(v3 + 232);
  v3 += 232;
  pthread_rwlock_rdlock(v4);
  objc_msgSend(*(id *)(v3 + 16), "eventFor:", a2);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v5, "sourcePose");
  v8 = v6;

  pthread_rwlock_unlock(*(pthread_rwlock_t **)v3);
  return (__n128)v8;
}

void sub_22540EE68(_Unwind_Exception *a1)
{
  void *v1;
  uint64_t v2;

  std::lock_guard<re::ReadWriteLock::Reader>::~lock_guard[abi:ne180100]((pthread_rwlock_t ***)(v2 - 24));
  _Unwind_Resume(a1);
}

id re::AudioManager_PHASE::getAudioObjectPHASE(re::AudioManager_PHASE *this, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  pthread_rwlock_t *v5;
  void *v6;
  void *v7;
  id v8;

  v3 = *((_QWORD *)this + 65);
  v5 = *(pthread_rwlock_t **)(v3 + 232);
  v4 = v3 + 232;
  pthread_rwlock_rdlock(v5);
  objc_msgSend(*(id *)(v4 + 16), "eventFor:", a2, v4 + 16, v4);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v6, "externalStreamController");
  v7 = (void *)objc_claimAutoreleasedReturnValue();

  if (v7)
    objc_msgSend(v6, "externalStreamController");
  else
    objc_msgSend(v6, "soundEvent");
  v8 = (id)objc_claimAutoreleasedReturnValue();

  pthread_rwlock_unlock(*(pthread_rwlock_t **)v4);
  return v8;
}

void sub_22540EF30(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::lock_guard<re::ReadWriteLock::Reader>::~lock_guard[abi:ne180100]((pthread_rwlock_t ***)va);
  _Unwind_Resume(a1);
}

id re::AudioManager_PHASE::getPHASESourceForEntityID(re::AudioManager_PHASE *this, uint64_t a2)
{
  uint64_t v3;
  pthread_rwlock_t *v4;
  void *v5;

  v3 = *((_QWORD *)this + 65);
  v4 = *(pthread_rwlock_t **)(v3 + 232);
  v3 += 232;
  pthread_rwlock_rdlock(v4);
  objc_msgSend(*(id *)(v3 + 16), "sourceObjectForEntityID:", a2, v3 + 16, v3);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  pthread_rwlock_unlock(*(pthread_rwlock_t **)v3);
  return v5;
}

void sub_22540EFC0(_Unwind_Exception *a1)
{
  pthread_rwlock_t ***v1;

  std::lock_guard<re::ReadWriteLock::Reader>::~lock_guard[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

id re::AudioManager_PHASE::getPHASEGroups(os_unfair_lock_s *this)
{
  id v2;
  os_unfair_lock_s *v3;
  os_unfair_lock_s *i;

  v2 = objc_alloc_init(MEMORY[0x24BDBCEB8]);
  v3 = this + 142;
  os_unfair_lock_lock(this + 142);
  for (i = this + 148; ; objc_msgSend(v2, "addObject:", *(_QWORD *)&i[12]._os_unfair_lock_opaque))
  {
    i = *(os_unfair_lock_s **)&i->_os_unfair_lock_opaque;
    if (!i)
      break;
  }
  os_unfair_lock_unlock(v3);
  return v2;
}

void sub_22540F03C(_Unwind_Exception *a1)
{
  void *v1;
  os_unfair_lock_s *v2;

  os_unfair_lock_unlock(v2);

  _Unwind_Resume(a1);
}

id re::AudioManager_PHASE::createSamplerDefinitionForToken(re::AudioManager_PHASE *this, uint64_t a2)
{
  NSObject *v2;
  id v3;
  _QWORD block[7];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t (*v9)(uint64_t, uint64_t);
  void (*v10)(uint64_t);
  id v11;

  v6 = 0;
  v7 = &v6;
  v8 = 0x3032000000;
  v9 = __Block_byref_object_copy__4;
  v10 = __Block_byref_object_dispose__4;
  v11 = 0;
  v2 = *((_QWORD *)this + 67);
  block[0] = MEMORY[0x24BDAC760];
  block[1] = 3221225472;
  block[2] = ___ZNK2re18AudioManager_PHASE31createSamplerDefinitionForTokenEy_block_invoke;
  block[3] = &unk_24ED3E4A8;
  block[4] = &v6;
  block[5] = this;
  block[6] = a2;
  dispatch_sync(v2, block);
  v3 = (id)v7[5];
  _Block_object_dispose(&v6, 8);

  return v3;
}

void ___ZNK2re18AudioManager_PHASE31createSamplerDefinitionForTokenEy_block_invoke(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  re::AudioManager_PHASE_Async::createSamplerDefinitionForToken(*(pthread_rwlock_t ***)(a1[5] + 520), a1[6]);
  v2 = objc_claimAutoreleasedReturnValue();
  v3 = *(_QWORD *)(a1[4] + 8);
  v4 = *(void **)(v3 + 40);
  *(_QWORD *)(v3 + 40) = v2;

}

uint64_t re::AudioManager_PHASE::playbackStateForToken(re::AudioManager_PHASE *this, uint64_t a2)
{
  uint64_t v3;
  pthread_rwlock_t *v4;
  void *v5;
  uint64_t v6;

  v3 = *((_QWORD *)this + 65);
  v4 = *(pthread_rwlock_t **)(v3 + 232);
  v3 += 232;
  pthread_rwlock_rdlock(v4);
  objc_msgSend(*(id *)(v3 + 16), "eventFor:", a2, v3 + 16, v3);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "state");

  pthread_rwlock_unlock(*(pthread_rwlock_t **)v3);
  return v6;
}

void sub_22540F1B8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  va_list va;

  va_start(va, a2);

  std::lock_guard<re::ReadWriteLock::Reader>::~lock_guard[abi:ne180100]((pthread_rwlock_t ***)va);
  _Unwind_Resume(a1);
}

id re::AudioManager_PHASE::audioSessionForToken(re::AudioManager_PHASE *this, uint64_t a2)
{
  uint64_t v3;
  pthread_rwlock_t *v4;
  void *v5;
  void *v6;

  v3 = *((_QWORD *)this + 65);
  v4 = *(pthread_rwlock_t **)(v3 + 232);
  v3 += 232;
  pthread_rwlock_rdlock(v4);
  objc_msgSend(*(id *)(v3 + 16), "eventFor:", a2, v3 + 16, v3);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v5, "audioSession");
  v6 = (void *)objc_claimAutoreleasedReturnValue();

  pthread_rwlock_unlock(*(pthread_rwlock_t **)v3);
  return v6;
}

void sub_22540F250(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  va_list va;

  va_start(va, a2);

  std::lock_guard<re::ReadWriteLock::Reader>::~lock_guard[abi:ne180100]((pthread_rwlock_t ***)va);
  _Unwind_Resume(a1);
}

BOOL re::AudioManager_PHASE::isReady(re::AudioManager_PHASE *this)
{
  unint64_t v1;

  v1 = atomic_load((unint64_t *)(*((_QWORD *)this + 65) + 424));
  return v1 == 1;
}

_anonymous_namespace_ *re::AudioManager_PHASE::addAcousticMeshEvent(_anonymous_namespace_ *result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char v11;

  v3 = *((_QWORD *)result + 90);
  v4 = *(_QWORD *)(v3 + 16);
  v5 = v4 + 1;
  v6 = *(_QWORD *)(v3 + 8);
  if (v4 + 1 >= v6)
  {
    if (v6 < v5)
    {
      if (*(_QWORD *)v3)
      {
        v7 = 2 * v6;
        if (!v6)
          v7 = 8;
        if (v7 <= v5)
          v8 = v5;
        else
          v8 = v7;
        result = (_anonymous_namespace_ *)re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>>::setCapacity(*((_QWORD **)result + 90), v8);
        v4 = *(_QWORD *)(v3 + 16);
      }
      else
      {
        result = (_anonymous_namespace_ *)re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>>::setCapacity((_QWORD *)v3, v5);
        v4 = 0;
        *(_QWORD *)(v3 + 16) = 0;
        *(_QWORD *)(v3 + 24) = 0;
        *(_DWORD *)(v3 + 32) = 0;
      }
    }
    v6 = *(_QWORD *)(v3 + 8);
  }
  v9 = *(_QWORD *)(v3 + 40) + 48 * ((*(_QWORD *)(v3 + 24) + v4) % v6);
  *(_BYTE *)v9 = 0;
  *(_DWORD *)(v9 + 40) = -1;
  v10 = *(unsigned int *)(a2 + 40);
  if ((_DWORD)v10 != -1)
  {
    result = (_anonymous_namespace_ *)((uint64_t (*)(char *, uint64_t, uint64_t))off_24ED3E898[v10])(&v11, v9, a2);
    *(_DWORD *)(v9 + 40) = v10;
  }
  ++*(_QWORD *)(v3 + 16);
  ++*(_DWORD *)(v3 + 32);
  return result;
}

void sub_22540F3A4(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__variant_detail::__dtor<std::__variant_detail::__traits<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>,(std::__variant_detail::_Trait)1>::~__dtor(v1);
  _Unwind_Resume(a1);
}

void re::AudioManager_PHASE::beforeFrameUpdate(re::AudioManager_PHASE *this)
{
  _BYTE v2[16];

  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v2, 2500, (uint64_t)this);
  re::AudioManager::beforeFrameUpdate(this);
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v2);
}

void re::AudioManager_PHASE::afterFrameUpdate(re::AudioManager_PHASE *this)
{
  uint64_t v2;
  os_unfair_lock_s *v3;
  _QWORD *v4;
  unint64_t v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unsigned __int8 *v25;
  unsigned __int8 v26;
  int v27;
  unint64_t v28;
  NSObject *v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  int v34;
  re *v35;
  uint64_t *v36;
  NSObject *v37;
  uint64_t v38;
  std::__shared_weak_count *v39;
  uint64_t v40;
  _QWORD *v41;
  uint64_t v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  NSObject *v46;
  unint64_t *p_shared_owners;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  std::__shared_weak_count *v51;
  unint64_t *v52;
  unint64_t v53;
  std::__shared_weak_count *v54;
  unint64_t *v55;
  unint64_t v56;
  int v57;
  _QWORD v58[4];
  re::AudioManager_PHASE *v59;
  uint64_t v60;
  uint64_t v61;
  std::__shared_weak_count *v62;
  uint64_t v63;
  std::__shared_weak_count *v64;
  _QWORD block[7];
  uint64_t v66;
  uint64_t *v67;
  uint64_t v68;
  double (*v69)(uint64_t, _QWORD *);
  double (*v70)(uint64_t);
  const char *v71;
  uint64_t v72[4];
  int v73;
  uint64_t v74;
  uint8_t v75[16];
  uint8_t buf[8];
  _BYTE v77[24];
  _BYTE *v78;
  _BYTE v79[24];
  _BYTE *v80;
  uint64_t v81;

  v81 = *MEMORY[0x24BDAC8D0];
  v2 = *((_QWORD *)this + 70) + 1;
  *((_QWORD *)this + 70) = v2;
  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v75, 2502, (uint64_t)this);
  re::AudioManager::afterFrameUpdate(this);
  v66 = 0;
  v67 = &v66;
  v68 = 0x6012000000;
  v69 = __Block_byref_object_copy__12;
  v70 = __Block_byref_object_dispose__13;
  v71 = "";
  v74 = 0;
  memset(v72, 0, sizeof(v72));
  v73 = 0;
  v3 = (os_unfair_lock_s *)(*((_QWORD *)this + 65) + 488);
  os_unfair_lock_lock(v3);
  v4 = (_QWORD *)*((_QWORD *)this + 65);
  v5 = v4[64];
  if (v5)
  {
    v6 = v67;
    v7 = v67 + 6;
    if (v67 + 6 != v4 + 62)
    {
      v8 = *v7;
      v9 = v4[62];
      if (!*v7 || v8 == v9)
      {
        v67[6] = v9;
        v4[62] = v8;
        v12 = v6[7];
        v6[7] = v4[63];
        v4[63] = v12;
        v13 = v6[8];
        v6[8] = v4[64];
        v4[64] = v13;
        v14 = v6[11];
        v6[11] = v4[67];
        v4[67] = v14;
        v15 = v6[9];
        v6[9] = v4[65];
        v4[65] = v15;
      }
      else
      {
        v10 = v67[8];
        if (v9)
        {
          if (v5 >= v10)
          {
            re::Queue<re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>>>::setCapacity(v67 + 6, v4[64]);
            std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<re::Queue<re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>>>::QueueIterator<re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>>,re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>> const&>,re::Queue<re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>>>::QueueIterator<re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>>,re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>> const&>,re::Queue<re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>>>::QueueIterator<re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>>,re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>>&>>(buf, v4 + 62, 0, v4 + 62, v6[8], v7, 0);
            v17 = v6[8];
            for (v6[8] = v5; v17 != v4[64]; ++v17)
            {
              v18 = v6[11] + 48 * ((v17 + v6[9]) % (unint64_t)v6[7]);
              v19 = (unint64_t)(v17 + v4[65]) % v4[63];
              v20 = v4[67];
              v21 = (_QWORD *)(v20 + 48 * v19);
              *(_OWORD *)(v18 + 16) = 0u;
              *(_QWORD *)(v18 + 40) = 0;
              *(_OWORD *)v18 = 0u;
              *(_DWORD *)(v18 + 32) = 0;
              if (*v21)
              {
                v22 = *(_QWORD *)(v20 + 48 * v19 + 16);
                *(_QWORD *)v18 = *v21;
                re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>>::setCapacity((_QWORD *)v18, v22);
                *(_QWORD *)(v18 + 16) = 0;
                *(_QWORD *)(v18 + 24) = 0;
                *(_DWORD *)(v18 + 32) = 0;
                re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>>::copy((_QWORD *)v18, v21);
              }
            }
          }
          else
          {
            std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<re::Queue<re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>>>::QueueIterator<re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>>,re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>> const&>,re::Queue<re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>>>::QueueIterator<re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>>,re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>> const&>,re::Queue<re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>>>::QueueIterator<re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>>,re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>>&>>(buf, v4 + 62, 0, v4 + 62, v4[64], v67 + 6, 0);
            if (v5 != v6[8])
            {
              v11 = v5;
              do
              {
                re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>>::deinit((uint64_t *)(v6[11] + 48 * ((v11 + v6[9]) % v6[7])));
                ++v11;
              }
              while (v11 != v6[8]);
            }
            v6[8] = v5;
          }
          ++*((_DWORD *)v6 + 20);
        }
        else
        {
          if (v10)
          {
            v16 = 0;
            do
            {
              re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>>::deinit((uint64_t *)(v6[11] + 48 * ((v16 + v6[9]) % v6[7])));
              ++v16;
            }
            while (v16 < v6[8]);
          }
          v6[8] = 0;
          ++*((_DWORD *)v6 + 20);
        }
      }
    }
  }
  os_unfair_lock_unlock(v3);
  if (v67[8])
    atomic_store(1u, (unsigned __int8 *)(*((_QWORD *)this + 65) + 544));
  v23 = atomic_load((unint64_t *)(*((_QWORD *)this + 65) + 424));
  if (v23 == 1)
    goto LABEL_76;
  v24 = *((_QWORD *)this + 65);
  v25 = (unsigned __int8 *)(v24 + 544);
  do
    v26 = __ldaxr(v25);
  while (__stlxr(0, v25));
  v27 = v26 & 1;
  v28 = atomic_load((unint64_t *)(v24 + 424));
  if (v28 || v27 != 0)
  {
LABEL_76:
    if (re::AudioManager_PHASE_Async::isListenerCreatedInScene(*((pthread_rwlock_t ***)this + 65))
      && *((_QWORD *)this + 97))
    {
      re::AudioManager_PHASE_Async::applyListenerTransformAndLevel(*((re::AudioManager_PHASE_Async **)this + 65), (const simd_float4x4 *)((char *)this + 784), *((float *)this + 212));
    }
    v30 = *((_QWORD *)this + 67);
    block[0] = MEMORY[0x24BDAC760];
    block[1] = 3221225472;
    block[2] = ___ZN2re18AudioManager_PHASE16afterFrameUpdateEv_block_invoke;
    block[3] = &unk_24ED3E4A8;
    block[5] = this;
    block[6] = v2;
    block[4] = &v66;
    dispatch_async(v30, block);
  }
  v31 = *((_QWORD *)this + 90);
  if (v31)
  {
    v32 = *(_QWORD *)(v31 + 16);
    if (v32)
    {
      v33 = *((_QWORD *)this + 95);
      *((_QWORD *)this + 95) = v32;
      if (v33 < v32)
      {
        ++*((_DWORD *)this + 193);
        *((_DWORD *)this + 192) = 0;
        goto LABEL_73;
      }
      v34 = *((_DWORD *)this + 192);
      *((_DWORD *)this + 192) = v34 + 1;
      if (v34 < 2)
        goto LABEL_73;
      re::audio::getPhase1AcousticMeshEventSignpostData(v31, (uint64_t)buf);
      v35 = (re *)re::audio::emitPhase1AcousticMeshEventSignposts((uint64_t)buf);
      v36 = (uint64_t *)((char *)this + 720);
      v37 = *re::audioLogObjects(v35);
      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
      {
        v57 = *((_DWORD *)this + 193);
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = v57;
        _os_log_debug_impl(&dword_224FE9000, v37, OS_LOG_TYPE_DEBUG, "AudioManager_PHASE::afterFrameUpdate() dispatching mesh data from %d frames to slow PHASE queue", buf, 8u);
      }
      v38 = *v36;
      v63 = v38;
      if (!v38)
      {
        v39 = 0;
        v64 = 0;
        goto LABEL_53;
      }
      v39 = (std::__shared_weak_count *)operator new();
      v40 = *((_QWORD *)this + 90);
      std::__function::__value_func<void ()(re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>> *)>::__value_func[abi:ne180100]((uint64_t)v79, (uint64_t)this + 728);
      v39->__shared_owners_ = 0;
      v39->__shared_weak_owners_ = 0;
      v39->__vftable = (std::__shared_weak_count_vtbl *)&off_24ED3E968;
      *(_QWORD *)buf = v40;
      std::__function::__value_func<void ()(re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>> *)>::__value_func[abi:ne180100]((uint64_t)v77, (uint64_t)v79);
      v39[1].__vftable = *(std::__shared_weak_count_vtbl **)buf;
      std::__function::__value_func<void ()(re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>> *)>::__value_func[abi:ne180100]((uint64_t)&v39[1].__shared_owners_, (uint64_t)v77);
      v41 = v78;
      if (v78 == v77)
      {
        v42 = 4;
        v41 = v77;
      }
      else
      {
        if (!v78)
        {
LABEL_48:
          v64 = v39;
          v43 = v80;
          if (v80 == v79)
          {
            v44 = 4;
            v43 = v79;
            goto LABEL_52;
          }
          if (v80)
          {
            v44 = 5;
LABEL_52:
            (*(void (**)(void))(*v43 + 8 * v44))();
          }
LABEL_53:
          *v36 = 0;
          v45 = operator new();
          *(_QWORD *)(v45 + 40) = 0;
          *(_QWORD *)(v45 + 16) = 0;
          *(_QWORD *)(v45 + 24) = 0;
          *(_QWORD *)(v45 + 8) = 0;
          *(_DWORD *)(v45 + 32) = 0;
          re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>>::setCapacity((_QWORD *)v45, 8uLL);
          *(_QWORD *)(v45 + 16) = 0;
          *(_QWORD *)(v45 + 24) = 0;
          *(_DWORD *)(v45 + 32) = 0;
          std::unique_ptr<re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>>,std::function<void ()(re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>>*)>>::reset[abi:ne180100]((uint64_t *)this + 90, v45);
          v46 = *((_QWORD *)this + 68);
          v58[0] = MEMORY[0x24BDAC760];
          v58[1] = 3321888768;
          v58[2] = ___ZN2re18AudioManager_PHASE16afterFrameUpdateEv_block_invoke_15;
          v58[3] = &__block_descriptor_64_ea8_32c55_ZTSKZN2re18AudioManager_PHASE16afterFrameUpdateEvE3__0_e5_v8__0l;
          if (v39)
          {
            p_shared_owners = (unint64_t *)&v39->__shared_owners_;
            do
              v48 = __ldxr(p_shared_owners);
            while (__stxr(v48 + 1, p_shared_owners));
            v59 = this;
            v60 = v2;
            v61 = v38;
            v62 = v39;
            do
              v49 = __ldxr(p_shared_owners);
            while (__stxr(v49 + 1, p_shared_owners));
            dispatch_async(v46, v58);
            do
              v50 = __ldaxr(p_shared_owners);
            while (__stlxr(v50 - 1, p_shared_owners));
            if (!v50)
            {
              ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
              std::__shared_weak_count::__release_weak(v39);
            }
          }
          else
          {
            v59 = this;
            v60 = v2;
            v61 = v38;
            v62 = 0;
            dispatch_async(v46, v58);
          }
          *((_QWORD *)this + 95) = 0;
          *((_QWORD *)this + 96) = 0;
          v51 = v62;
          if (v62)
          {
            v52 = (unint64_t *)&v62->__shared_owners_;
            do
              v53 = __ldaxr(v52);
            while (__stlxr(v53 - 1, v52));
            if (!v53)
            {
              ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
              std::__shared_weak_count::__release_weak(v51);
            }
          }
          v54 = v64;
          if (v64)
          {
            v55 = (unint64_t *)&v64->__shared_owners_;
            do
              v56 = __ldaxr(v55);
            while (__stlxr(v56 - 1, v55));
            if (!v56)
            {
              ((void (*)(std::__shared_weak_count *))v54->__on_zero_shared)(v54);
              std::__shared_weak_count::__release_weak(v54);
            }
          }
          goto LABEL_73;
        }
        v42 = 5;
      }
      (*(void (**)(void))(*v41 + 8 * v42))();
      goto LABEL_48;
    }
  }
LABEL_73:
  _Block_object_dispose(&v66, 8);
  re::Queue<re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>>>::deinit(v72);
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v75);
}

void sub_22540FB34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  uint64_t *v27;
  uint64_t v28;

  _Block_object_dispose(&a27, 8);
  re::Queue<re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>>>::deinit(v27);
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)(v28 - 224));
  _Unwind_Resume(a1);
}

double __Block_byref_object_copy__12(uint64_t a1, _QWORD *a2)
{
  double result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  *(_QWORD *)(a1 + 88) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_DWORD *)(a1 + 80) = 0;
  v3 = a2[7];
  *(_QWORD *)(a1 + 48) = a2[6];
  *(_QWORD *)(a1 + 56) = v3;
  a2[6] = 0;
  a2[7] = 0;
  v4 = *(_QWORD *)(a1 + 64);
  *(_QWORD *)(a1 + 64) = a2[8];
  a2[8] = v4;
  v5 = *(_QWORD *)(a1 + 88);
  *(_QWORD *)(a1 + 88) = a2[11];
  a2[11] = v5;
  v6 = *(_QWORD *)(a1 + 72);
  *(_QWORD *)(a1 + 72) = a2[9];
  a2[9] = v6;
  return result;
}

double __Block_byref_object_dispose__13(uint64_t a1)
{
  return re::Queue<re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>>>::deinit((uint64_t *)(a1 + 48));
}

void ___ZN2re18AudioManager_PHASE16afterFrameUpdateEv_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  _BYTE v5[16];

  v2 = *(_QWORD *)(a1 + 40);
  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v5, 2520, *(_QWORD *)(v2 + 520));
  v3 = *(_QWORD *)(v2 + 520);
  v4 = atomic_load((unsigned int *)(v2 + 556));
  re::AudioManager_PHASE_Async::afterFrameUpdate(v3, v4, *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 48);
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v5);
}

void sub_22540FC80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)&a9);
  _Unwind_Resume(a1);
}

uint64_t *std::unique_ptr<re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>>,std::function<void ()(re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>>*)>>::reset[abi:ne180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    v4 = v2;
    v3 = result[4];
    if (!v3)
      std::__throw_bad_function_call[abi:ne180100]();
    return (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)v3 + 48))(v3, &v4);
  }
  return result;
}

void ___ZN2re18AudioManager_PHASE16afterFrameUpdateEv_block_invoke_15(uint64_t a1)
{
  uint64_t v2;
  _BYTE v3[16];

  v2 = *(_QWORD *)(a1 + 32);
  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v3, 2541, *(_QWORD *)(v2 + 520));
  re::AudioManager_PHASE_Async::afterFrameSlowMeshEvents(*(_QWORD *)(v2 + 520), *(_QWORD **)(a1 + 48));
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v3);
}

void sub_22540FD34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)&a9);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_32c55_ZTSKZN2re18AudioManager_PHASE16afterFrameUpdateEvE3__0(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  *(_OWORD *)(result + 32) = *(_OWORD *)(a2 + 32);
  v2 = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(result + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 56) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_ea8_32c55_ZTSKZN2re18AudioManager_PHASE16afterFrameUpdateEvE3__0(uint64_t a1)
{
  return std::shared_ptr<re::AssetManager>::~shared_ptr[abi:nn180100](a1 + 48);
}

uint64_t re::AudioManager_PHASE::fadeSourceToGain(pthread_rwlock_t ***this, const re::AudioSourceState *a2, float a3, double a4)
{
  return re::AudioManager_PHASE_Async::fadeSourceToGain(this[65], *((_QWORD *)a2 + 85), a3, a4);
}

float re::AudioManager_PHASE::currentGainForSource(re::AudioManager_PHASE *this, const re::AudioSourceState *a2)
{
  uint64_t v3;
  uint64_t v4;
  pthread_rwlock_t *v5;
  id v6;
  void *v7;
  re *v8;
  NSObject *v9;
  NSObject *v10;
  void *v11;
  float v12;
  float v13;
  _QWORD *v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  NSObject *v22;
  char *v24;
  uint64_t v25;
  uint8_t buf[4];
  char *v27;
  __int16 v28;
  uint64_t v29;
  __int16 v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  __int16 v34;
  const char *v35;
  __int16 v36;
  uint64_t v37;
  uint64_t v38;

  v38 = *MEMORY[0x24BDAC8D0];
  v3 = *((_QWORD *)this + 65);
  v5 = *(pthread_rwlock_t **)(v3 + 232);
  v4 = v3 + 232;
  pthread_rwlock_rdlock(v5);
  v6 = *(id *)(v4 + 16);
  objc_msgSend(v6, "eventFor:", *((_QWORD *)a2 + 85), v4 + 16, v4);
  v7 = (void *)objc_claimAutoreleasedReturnValue();

  if (v7)
  {
    objc_msgSend(v7, "paramForKey:", CFSTR("gain"));
    v9 = objc_claimAutoreleasedReturnValue();
    v10 = v9;
    if (v9)
    {
      -[NSObject value](v9, "value");
      v11 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v11, "floatValue");
      v13 = v12;

    }
    else
    {
      v22 = (id)*re::audioLogObjects(0);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        v24 = (char *)*((_QWORD *)a2 + 85);
        *(_DWORD *)buf = 134217984;
        v27 = v24;
        _os_log_error_impl(&dword_224FE9000, v22, OS_LOG_TYPE_ERROR, "Could not find gain param for token %llu", buf, 0xCu);
      }

      v10 = 0;
      v13 = 0.0;
    }
  }
  else
  {
    v10 = (id)*re::audioLogObjects(v8);
    v13 = 0.0;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      v14 = re::AssetHandle::assetInfo((const re::AudioSourceState *)((char *)a2 + 32));
      if ((v14[17] & 1) != 0)
        v15 = (char *)v14[18];
      else
        v15 = (char *)v14 + 137;
      v16 = *((_QWORD *)a2 + 85);
      v17 = *((_QWORD *)a2 + 56);
      v18 = *((_QWORD *)a2 + 62);
      v19 = *((_QWORD *)a2 + 60);
      if (v19 && (v20 = *(_QWORD *)(v19 + 16)) != 0)
        v21 = *(const char **)(v20 + 280);
      else
        v21 = "";
      v25 = *((_QWORD *)a2 + 93);
      *(_DWORD *)buf = 136316418;
      v27 = v15;
      v28 = 2048;
      v29 = v16;
      v30 = 2048;
      v31 = v17;
      v32 = 2048;
      v33 = v18;
      v34 = 2080;
      v35 = v21;
      v36 = 2048;
      v37 = v25;
      _os_log_error_impl(&dword_224FE9000, v10, OS_LOG_TYPE_ERROR, "AudioManager_PHASE::currentGainForSource(asset='%s', token=%llu, sceneID=%llu, entity(%llu, '%s'), sourceID=%llu) could not find sound event", buf, 0x3Eu);
    }
  }

  pthread_rwlock_unlock(*(pthread_rwlock_t **)v4);
  return v13;
}

void sub_22540FFA8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  va_list va;

  va_start(va, a2);
  v5 = v4;

  std::lock_guard<re::ReadWriteLock::Reader>::~lock_guard[abi:ne180100]((pthread_rwlock_t ***)va);
  _Unwind_Resume(a1);
}

unint64_t *re::AudioManager_PHASE::createListenerInScene(re *a1, unint64_t a2, char a3)
{
  NSObject *v6;
  unint64_t *ListenerInScene;
  NSObject *v8;
  _QWORD v10[7];
  char v11;
  uint8_t buf[4];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v6 = *re::audioLogObjects(a1);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 134217984;
    v13 = a2;
    _os_log_debug_impl(&dword_224FE9000, v6, OS_LOG_TYPE_DEBUG, "AudioManager_PHASE::createListenerInScene(sceneID=%llu)", buf, 0xCu);
  }
  ListenerInScene = re::AudioManager::createListenerInScene((uint64_t)a1, a2);
  v8 = *((_QWORD *)a1 + 67);
  v10[0] = MEMORY[0x24BDAC760];
  v10[1] = 3221225472;
  v10[2] = ___ZN2re18AudioManager_PHASE21createListenerInSceneEy19REAudioListenerType_block_invoke;
  v10[3] = &__block_descriptor_57_e5_v8__0l;
  v10[4] = a1;
  v10[5] = a2;
  v10[6] = ListenerInScene;
  v11 = a3;
  dispatch_async(v8, v10);
  return ListenerInScene;
}

void ___ZN2re18AudioManager_PHASE21createListenerInSceneEy19REAudioListenerType_block_invoke(uint64_t a1)
{
  uint64_t v2;
  _BYTE v3[16];

  v2 = *(_QWORD *)(a1 + 32);
  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v3, 2504, v2);
  re::AudioManager_PHASE_Async::createListenerInScene(*(_QWORD *)(v2 + 520), *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 40), *(_BYTE *)(a1 + 56));
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v3);
}

void sub_22541016C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)&a9);
  _Unwind_Resume(a1);
}

void re::AudioManager_PHASE::removeListenerFromScene(re::AudioManager_PHASE *this, uint64_t a2)
{
  _QWORD *i;
  NSObject *v3;
  _QWORD block[5];

  if (a2)
  {
    for (i = (_QWORD *)*((_QWORD *)this + 4); i; i = (_QWORD *)*i)
    {
      if (i[3] == a2)
        i[3] = 0;
    }
    v3 = *((_QWORD *)this + 67);
    block[0] = MEMORY[0x24BDAC760];
    block[1] = 3221225472;
    block[2] = ___ZN2re18AudioManager_PHASE23removeListenerFromSceneEy_block_invoke;
    block[3] = &__block_descriptor_40_e5_v8__0l;
    block[4] = this;
    dispatch_async(v3, block);
  }
}

uint64_t ___ZN2re18AudioManager_PHASE23removeListenerFromSceneEy_block_invoke(uint64_t a1)
{
  return re::AudioManager_PHASE_Async::removeListenerFromScene(*(re::AudioManager_PHASE_Async **)(*(_QWORD *)(a1 + 32)
                                                                                                + 520));
}

uint64_t re::AudioManager_PHASE::setListenerTransformAndLevel(uint64_t this, uint64_t a2, const simd_float4x4 *a3, float a4, uint64_t a5)
{
  uint64_t v9;
  uint64_t **v10;
  simd_float4 v11;
  simd_float4 v12;
  int v13;
  simd_float4 v14;
  simd_float4 v15;
  simd_float4 v16;
  simd_float4 v17;
  simd_float4 v18;

  v9 = this;
  v10 = (uint64_t **)(this + 32);
  while (1)
  {
    v10 = (uint64_t **)*v10;
    if (!v10)
      break;
    this = objc_msgSend(v10[12], "count");
    if (this)
      goto LABEL_6;
  }
  if (!*(_QWORD *)(v9 + 456))
    goto LABEL_9;
LABEL_6:
  if (*(_BYTE *)(v9 + 56))
  {
    v11 = a3->columns[0];
    v17 = a3->columns[1];
    v12 = a3->columns[2];
    v18 = a3->columns[3];
    v13 = *(unsigned __int8 *)(v9 + 208);
    *(_QWORD *)(v9 + 128) = a5;
    *(_QWORD *)(v9 + 136) = 0;
    *(simd_float4 *)(v9 + 144) = v11;
    *(simd_float4 *)(v9 + 160) = v17;
    *(simd_float4 *)(v9 + 176) = v12;
    *(simd_float4 *)(v9 + 192) = v18;
    if (!v13)
      *(_BYTE *)(v9 + 208) = 1;
  }
LABEL_9:
  *(_QWORD *)(v9 + 776) = a2;
  v14 = a3->columns[0];
  v15 = a3->columns[1];
  v16 = a3->columns[3];
  *(simd_float4 *)(v9 + 816) = a3->columns[2];
  *(simd_float4 *)(v9 + 832) = v16;
  *(simd_float4 *)(v9 + 784) = v14;
  *(simd_float4 *)(v9 + 800) = v15;
  *(float *)(v9 + 848) = a4;
  *(_QWORD *)(v9 + 856) = a5;
  return this;
}

__n128 re::AudioManager_PHASE::getListenerTransform(pthread_rwlock_t ***this)
{
  void *v1;
  void *v2;
  __int128 v3;
  __int128 v5;

  re::AudioManager_PHASE_Async::getListener(this[65]);
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  v2 = v1;
  if (v1)
  {
    objc_msgSend(v1, "transform");
    v5 = v3;
  }
  else
  {
    v5 = *MEMORY[0x24BDAEE00];
  }

  return (__n128)v5;
}

void sub_225410370(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

float re::AudioManager_PHASE::getListenerLevel(pthread_rwlock_t ***this)
{
  void *v1;
  void *v2;
  double v3;
  float v4;

  re::AudioManager_PHASE_Async::getListener(this[65]);
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  v2 = v1;
  if (v1)
  {
    objc_msgSend(v1, "gain");
    v4 = v3;
  }
  else
  {
    v4 = 0.0;
  }

  return v4;
}

void sub_2254103D0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t re::AudioManager_PHASE::createSessionRootInScene(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  void *v8;
  void *v9;
  NSObject *v10;
  NSObject *v11;
  uint64_t v13;
  _QWORD v14[4];
  id v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint8_t __buf[24];
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  if (a2 == -1)
    return 0;
  if ((*(_BYTE *)(a3 + 8) & 1) != 0)
    v6 = *(_QWORD *)(a3 + 16);
  else
    v6 = a3 + 9;
  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", v6);
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  v9 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BDD1880]), "initWithUUIDString:", v8);
  if (v9)
  {
    *(_QWORD *)__buf = 0;
    do
    {
      arc4random_buf(__buf, 8uLL);
      v7 = *(_QWORD *)__buf;
    }
    while (*(_QWORD *)__buf < 0x3E8uLL);
    v10 = *(NSObject **)(a1 + 536);
    v14[0] = MEMORY[0x24BDAC760];
    v14[1] = 3221225472;
    v14[2] = ___ZN2re18AudioManager_PHASE24createSessionRootInSceneEyNS_13DynamicStringE_block_invoke;
    v14[3] = &unk_24ED3E520;
    v16 = a1;
    v17 = a2;
    v18 = *(_QWORD *)__buf;
    v15 = v9;
    dispatch_async(v10, v14);

  }
  else
  {
    v11 = *re::audioLogObjects(0);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      if ((*(_BYTE *)(a3 + 8) & 1) != 0)
        v13 = *(_QWORD *)(a3 + 16);
      else
        v13 = a3 + 9;
      *(_DWORD *)__buf = 136315138;
      *(_QWORD *)&__buf[4] = v13;
      _os_log_error_impl(&dword_224FE9000, v11, OS_LOG_TYPE_ERROR, "invalid UUID string %s", __buf, 0xCu);
    }
    v7 = 0;
  }

  return v7;
}

void sub_225410584(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void ___ZN2re18AudioManager_PHASE24createSessionRootInSceneEyNS_13DynamicStringE_block_invoke(uint64_t a1)
{
  uint64_t v2;
  _BYTE v3[16];

  v2 = *(_QWORD *)(a1 + 40);
  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v3, 2528, v2);
  re::AudioManager_PHASE_Async::createSessionRootInScene(*(pthread_rwlock_t ***)(v2 + 520), *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 48), *(NSUUID **)(a1 + 32));
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v3);
}

void sub_225410600(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)&a9);
  _Unwind_Resume(a1);
}

void re::AudioManager_PHASE::removeSessionRootFromScene(re::AudioManager_PHASE *this, uint64_t a2)
{
  NSObject *v2;
  _QWORD v3[6];

  v2 = *((_QWORD *)this + 67);
  v3[0] = MEMORY[0x24BDAC760];
  v3[1] = 3221225472;
  v3[2] = ___ZN2re18AudioManager_PHASE26removeSessionRootFromSceneEy_block_invoke;
  v3[3] = &__block_descriptor_48_e5_v8__0l;
  v3[4] = this;
  v3[5] = a2;
  dispatch_async(v2, v3);
}

uint64_t re::AudioManager_PHASE::setSessionRootTransform(pthread_rwlock_t ***this, uint64_t a2, const simd_float4x4 *a3)
{
  return re::AudioManager_PHASE_Async::setSessionRootTransform(this[65], a2, a3);
}

void re::AudioManager_PHASE::setSceneReverbPreset(uint64_t a1, unint64_t a2, uint64_t a3, int a4)
{
  NSObject *v7;
  _QWORD block[6];
  char v9;

  re::AudioManager::setSceneReverbPreset((_QWORD *)a1, a2, a3, a4);
  if (*(_QWORD *)(a1 + 688) != a3 || *(unsigned __int8 *)(a1 + 696) != a4)
  {
    *(_QWORD *)(a1 + 688) = a3;
    *(_BYTE *)(a1 + 696) = a4;
    v7 = *(NSObject **)(a1 + 536);
    block[0] = MEMORY[0x24BDAC760];
    block[1] = 3221225472;
    block[2] = ___ZN2re18AudioManager_PHASE20setSceneReverbPresetEyNS_12ReverbPresetEb_block_invoke;
    block[3] = &__block_descriptor_49_e5_v8__0l;
    block[4] = a1;
    block[5] = a3;
    v9 = a4;
    dispatch_async(v7, block);
  }
}

uint64_t ___ZN2re18AudioManager_PHASE20setSceneReverbPresetEyNS_12ReverbPresetEb_block_invoke(uint64_t a1)
{
  return re::AudioManager_PHASE_Async::setSceneReverbPreset(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 520), *(_QWORD *)(a1 + 40));
}

void re::AudioManager_PHASE::setSpaceBlendTargetPresetOrientation(float32x4_t *this, float32x4_t a2)
{
  NSObject *v2;
  _QWORD v3[4];
  float32x4_t v4;
  float32x4_t *v5;

  if ((vminvq_u32((uint32x4_t)vceqq_f32(this[42], a2)) & 0x80000000) == 0)
  {
    v2 = this[33].i64[1];
    v3[0] = MEMORY[0x24BDAC760];
    v3[1] = 3221225472;
    v3[2] = ___ZN2re18AudioManager_PHASE36setSpaceBlendTargetPresetOrientationE10simd_quatf_block_invoke;
    v3[3] = &__block_descriptor_56_e5_v8__0l;
    v5 = this;
    v4 = a2;
    dispatch_async(v2, v3);
  }
}

uint64_t ___ZN2re18AudioManager_PHASE36setSpaceBlendTargetPresetOrientationE10simd_quatf_block_invoke(simd_quatf *a1)
{
  simd_quatf v1;

  v1 = a1[2];
  return re::AudioManager_PHASE_Async::setSpaceBlendTargetPresetOrientation(*(re::AudioManager_PHASE_Async **)(a1[3].vector.i64[0] + 520), v1);
}

uint64_t re::AudioManager_PHASE::loadAudio(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v7;
  int v8;
  _QWORD v9[9];
  _QWORD *v10;

  std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<NSData * {__strong},AVAudioPCMBuffer * {__strong},NSURL * {__strong}>,(std::__variant_detail::_Trait)1>::__copy_constructor((uint64_t)&v7, *a2);
  v9[0] = a2;
  v9[1] = a3;
  v9[2] = a1;
  v9[3] = a2;
  v9[4] = a3;
  v9[5] = a1;
  v9[6] = a2;
  v9[7] = a3;
  v9[8] = a1;
  if (v8 == -1)
    std::__throw_bad_variant_access[abi:ne180100]();
  v10 = v9;
  ((void (*)(_QWORD **, uint64_t *))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8ne180100INS1_9__variant15__value_visitorIN2re8internal10overloadedIJZNKS6_18AudioManager_PHASE9loadAudioENS_10shared_ptrINS6_17AudioAssetPayloadEEENS_8functionIFvNSA_INS6_18PersistedAssetDataEEEEEEE3__0ZNKS9_9loadAudioESC_SH_E3__1ZNKS9_9loadAudioESC_SH_E3__2EEEEEJNS0_6__implIJU8__strongP6NSDataU8__strongP16AVAudioPCMBufferU8__strongP5NSURLEEEEEEDcOT_DpOT0____fmatrix[v8])(&v10, &v7);
  return std::__variant_detail::__dtor<std::__variant_detail::__traits<NSData * {__strong},AVAudioPCMBuffer * {__strong},NSURL * {__strong}>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)&v7);
}

void sub_225410840(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__variant_detail::__dtor<std::__variant_detail::__traits<NSData * {__strong},AVAudioPCMBuffer * {__strong},NSURL * {__strong}>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void re::AudioManager_PHASE::loadExternalStreamController(uint64_t a1, uint64_t a2, __int128 *a3)
{
  __int128 v6;
  int v7;
  NSObject *v8;
  _QWORD block[6];
  __int128 v10;
  __int128 v11;
  char v12;
  _QWORD v13[4];
  char v14;
  int v15;
  char v16;
  __int128 v17;
  __int128 v18;
  char v19;
  uint64_t v20;
  char v21;
  unsigned __int8 v22;
  int v23;
  char v24;

  v6 = a3[1];
  v17 = *a3;
  v18 = v6;
  v19 = *((_BYTE *)a3 + 32);
  if (v19)
    re::DynamicString::DynamicString((re::DynamicString *)&v20, (const re::DynamicString *)((char *)a3 + 40));
  v22 = *((_BYTE *)a3 + 72);
  v7 = v22;
  if (v22)
    v23 = *((_DWORD *)a3 + 19);
  v24 = *((_BYTE *)a3 + 80);
  v8 = *(NSObject **)(a1 + 536);
  block[0] = MEMORY[0x24BDAC760];
  block[1] = 3321888768;
  block[2] = ___ZN2re18AudioManager_PHASE28loadExternalStreamControllerEyRKNS_27AudioFileAssetConfigurationE_block_invoke;
  block[3] = &__block_descriptor_136_ea8_48c38_ZTSN2re27AudioFileAssetConfigurationE_e5_v8__0l;
  block[4] = a1;
  block[5] = a2;
  v10 = v17;
  v11 = v18;
  v12 = v19;
  if (v19)
  {
    re::DynamicString::DynamicString((re::DynamicString *)v13, (const re::DynamicString *)&v20);
    v7 = v22;
  }
  v14 = v7;
  if (v7)
    v15 = v23;
  v16 = v24;
  dispatch_async(v8, block);
  if (v12 && v13[0])
  {
    if ((v13[1] & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v13[0] + 40))();
    memset(v13, 0, sizeof(v13));
  }
  if (v19 && v20 && (v21 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v20 + 40))();
}

uint64_t ___ZN2re18AudioManager_PHASE28loadExternalStreamControllerEyRKNS_27AudioFileAssetConfigurationE_block_invoke(uint64_t a1)
{
  return re::AudioManager_PHASE_Async::loadExternalStreamController(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 520), *(_QWORD *)(a1 + 40), a1 + 48);
}

re::DynamicString *__copy_helper_block_ea8_48c38_ZTSN2re27AudioFileAssetConfigurationE(re::DynamicString *result, uint64_t a2)
{
  re::DynamicString *v3;
  __int128 v4;
  int v5;
  int v6;

  v3 = result;
  v4 = *(_OWORD *)(a2 + 64);
  *((_OWORD *)result + 3) = *(_OWORD *)(a2 + 48);
  *((_OWORD *)result + 4) = v4;
  v5 = *(unsigned __int8 *)(a2 + 80);
  *((_BYTE *)result + 80) = v5;
  if (v5)
    result = re::DynamicString::DynamicString((re::DynamicString *)((char *)result + 88), (const re::DynamicString *)(a2 + 88));
  v6 = *(unsigned __int8 *)(a2 + 120);
  *((_BYTE *)v3 + 120) = v6;
  if (v6)
    *((_DWORD *)v3 + 31) = *(_DWORD *)(a2 + 124);
  *((_BYTE *)v3 + 128) = *(_BYTE *)(a2 + 128);
  return result;
}

double __destroy_helper_block_ea8_48c38_ZTSN2re27AudioFileAssetConfigurationE(uint64_t a1)
{
  uint64_t v1;
  _OWORD *v2;
  double result;

  if (*(_BYTE *)(a1 + 80))
  {
    v2 = (_OWORD *)(a1 + 88);
    v1 = *(_QWORD *)(a1 + 88);
    if (v1)
    {
      if ((*(_BYTE *)(a1 + 96) & 1) != 0)
        (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)v1 + 40))(*(_QWORD *)(a1 + 88), *(_QWORD *)(a1 + 104));
      result = 0.0;
      *v2 = 0u;
      v2[1] = 0u;
    }
  }
  return result;
}

uint64_t re::AudioManager_PHASE::getConfigurationForExternalStreamController(uint64_t a1, uint64_t a2, uint64_t a3)
{
  NSObject *v3;
  uint64_t v4;
  _QWORD v6[8];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  char v10;

  v7 = 0;
  v8 = &v7;
  v9 = 0x2020000000;
  v10 = 0;
  v3 = *(NSObject **)(a1 + 536);
  v6[0] = MEMORY[0x24BDAC760];
  v6[1] = 3221225472;
  v6[2] = ___ZN2re18AudioManager_PHASE43getConfigurationForExternalStreamControllerEyRNS_27AudioFileAssetConfigurationE_block_invoke;
  v6[3] = &unk_24ED3E578;
  v6[4] = &v7;
  v6[5] = a1;
  v6[6] = a2;
  v6[7] = a3;
  dispatch_sync(v3, v6);
  v4 = *((unsigned __int8 *)v8 + 24);
  _Block_object_dispose(&v7, 8);
  return v4;
}

uint64_t ___ZN2re18AudioManager_PHASE43getConfigurationForExternalStreamControllerEyRNS_27AudioFileAssetConfigurationE_block_invoke(_QWORD *a1)
{
  uint64_t result;

  result = re::AudioManager_PHASE_Async::getConfigurationForExternalStreamController(*(_QWORD *)(a1[5] + 520), a1[6], a1[7]);
  *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) = result;
  return result;
}

void re::AudioManager_PHASE::setSpatialSceneClassification(uint64_t a1, char a2)
{
  NSObject *v2;
  _QWORD v3[5];
  char v4;

  v2 = *(NSObject **)(a1 + 536);
  v3[0] = MEMORY[0x24BDAC760];
  v3[1] = 3221225472;
  v3[2] = ___ZN2re18AudioManager_PHASE29setSpatialSceneClassificationENS_30SpatialSceneClassificationTypeE_block_invoke;
  v3[3] = &__block_descriptor_41_e5_v8__0l;
  v3[4] = a1;
  v4 = a2;
  dispatch_async(v2, v3);
}

void ___ZN2re18AudioManager_PHASE29setSpatialSceneClassificationENS_30SpatialSceneClassificationTypeE_block_invoke(uint64_t a1)
{
  re::AudioManager_PHASE_Async::setSpatialSceneClassification(*(unsigned __int8 **)(*(_QWORD *)(a1 + 32) + 520), *(unsigned __int8 *)(a1 + 40));
}

void re::AudioManager_PHASE::setSpatialSceneRoomIdentifier(re::AudioManager_PHASE *this, unsigned __int8 *a2)
{
  void *v3;
  NSObject *v4;
  id v5;
  _QWORD v6[4];
  id v7;
  re::AudioManager_PHASE *v8;

  v3 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BDD1880]), "initWithUUIDBytes:", a2);
  v4 = *((_QWORD *)this + 67);
  v6[0] = MEMORY[0x24BDAC760];
  v6[1] = 3221225472;
  v6[2] = ___ZN2re18AudioManager_PHASE29setSpatialSceneRoomIdentifierEPh_block_invoke;
  v6[3] = &unk_24ED3D378;
  v7 = v3;
  v8 = this;
  v5 = v3;
  dispatch_async(v4, v6);

}

void ___ZN2re18AudioManager_PHASE29setSpatialSceneRoomIdentifierEPh_block_invoke(uint64_t a1)
{
  re::AudioManager_PHASE_Async::setSpatialSceneRoomIdentifier(*(re::AudioManager_PHASE_Async **)(*(_QWORD *)(a1 + 40) + 520), *(NSUUID **)(a1 + 32));
}

uint64_t re::AudioManager_PHASE::getSpatialSceneClassification(re::AudioManager_PHASE_Async **this)
{
  return re::AudioManager_PHASE_Async::getSpatialSceneClassification(this[65]);
}

_QWORD *re::AudioManager_PHASE::updateExternalSpatialSourcePhase(re::AudioManager_PHASE *this, const re::AudioSourceState *a2)
{
  _QWORD *result;
  uint64_t v5;
  uint64_t v6;
  pthread_rwlock_t *v7;
  void *v8;
  NSObject *v9;
  id v10;
  void *v11;
  id v12;
  id v13;
  uint64_t v14;
  void *v15;
  re::audio::REPHASESoundPrepareState *v16;
  uint64_t v17;
  unint64_t v18;
  BOOL isPlaybackHostConnectionIdentifierSensitive;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  const char *v27;
  void *v28;
  uint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  unint64_t *p_shared_owners;
  unint64_t v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  unint64_t v37;
  NSObject *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  const char *v44;
  _QWORD v45[2];
  _QWORD v46[4];
  id v47;
  id v48;
  id v49;
  re::AudioManager_PHASE *v50;
  unint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  unint64_t v55;
  _BYTE buf[22];
  __int16 v57;
  uint64_t v58;
  __int16 v59;
  const char *v60;
  uint64_t v61;

  v61 = *MEMORY[0x24BDAC8D0];
  re::AudioManager_PHASE::updateSourceStateInternal(this, (simd_float4x4 *)a2);
  v55 = *((_QWORD *)a2 + 85);
  result = std::__hash_table<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>>>::find<unsigned long long>((_QWORD *)this + 77, &v55);
  if (!result)
  {
    v5 = *((_QWORD *)this + 65);
    v7 = *(pthread_rwlock_t **)(v5 + 232);
    v6 = v5 + 232;
    v53 = v6 + 16;
    v54 = v6;
    pthread_rwlock_rdlock(v7);
    objc_msgSend(*(id *)(v6 + 16), "eventFor:", v55);
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    if (!v8)
    {
      v9 = (id)*re::audioLogObjects(0);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        v39 = *((_QWORD *)a2 + 85);
        v40 = *((_QWORD *)a2 + 56);
        v41 = *((_QWORD *)a2 + 62);
        v42 = *((_QWORD *)a2 + 60);
        if (v42 && (v43 = *(_QWORD *)(v42 + 16)) != 0)
          v44 = *(const char **)(v43 + 280);
        else
          v44 = "";
        *(_DWORD *)buf = 134218754;
        *(_QWORD *)&buf[4] = v39;
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = v40;
        v57 = 2048;
        v58 = v41;
        v59 = 2080;
        v60 = v44;
        _os_log_debug_impl(&dword_224FE9000, v9, OS_LOG_TYPE_DEBUG, "AudioManager_PHASE::updateExternalSpatialSourcePhase(token=%llu, sceneID=%llu, entity(%llu, '%s'))", buf, 0x2Au);
      }

      v10 = **((id **)this + 39);
      v11 = (void *)*((_QWORD *)this + 1);
      if (v11)
      {
        v12 = v11;
      }
      else
      {
        v12 = (id)MEMORY[0x24BDAC9B8];
        v13 = MEMORY[0x24BDAC9B8];
      }
      v14 = re::AudioSourceState::playbackHostConnectionIdentifier(a2);
      re::AudioSourceSyncState::externalStreamUUID((const re::AudioSourceState *)((char *)a2 + 24));
      v15 = (void *)objc_claimAutoreleasedReturnValue();
      v16 = (re::audio::REPHASESoundPrepareState *)std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>((uint64_t)this + 616, &v55, &v55);
      if (*((_QWORD *)a2 + 62))
      {
        re::audio::REPHASESoundPrepareState::create(v16, buf);
        objc_storeStrong((id *)(*(_QWORD *)buf + 304), v15);
        objc_storeStrong((id *)(*(_QWORD *)buf + 16), *((id *)a2 + 58));
        v17 = *(_QWORD *)buf;
        *(_QWORD *)(*(_QWORD *)buf + 24) = *((_QWORD *)a2 + 85);
        *(_QWORD *)(v17 + 32) = *((_QWORD *)a2 + 56);
        *(_QWORD *)(v17 + 40) = *((_QWORD *)a2 + 62);
        v18 = re::AudioSourceState::playbackHostConnectionIdentifier(a2);
        *(_QWORD *)(*(_QWORD *)buf + 48) = v18;
        isPlaybackHostConnectionIdentifierSensitive = re::AudioManager_PHASE_Async::isPlaybackHostConnectionIdentifierSensitive(*((os_unfair_lock_s **)this + 65), v18);
        v20 = *(_QWORD *)buf;
        *(_BYTE *)(*(_QWORD *)buf + 208) = isPlaybackHostConnectionIdentifierSensitive;
        v21 = *((_OWORD *)a2 + 20);
        v22 = *((_OWORD *)a2 + 21);
        v23 = *((_OWORD *)a2 + 23);
        *(_OWORD *)(v20 + 144) = *((_OWORD *)a2 + 22);
        *(_OWORD *)(v20 + 160) = v23;
        *(_OWORD *)(v20 + 112) = v21;
        *(_OWORD *)(v20 + 128) = v22;
        *(_OWORD *)(v20 + 312) = *(_OWORD *)((char *)a2 + 216);
        *(_DWORD *)(v20 + 184) = *((_DWORD *)a2 + 118);
        *(_BYTE *)(v20 + 100) = *((_BYTE *)a2 + 476);
        *(_BYTE *)(v20 + 103) = *((_BYTE *)a2 + 100);
        *(float *)(v20 + 188) = *((float *)a2 + 20) + *((float *)a2 + 21);
        *(float *)(v20 + 192) = *((float *)a2 + 24) + *((float *)a2 + 22);
        *(_DWORD *)(v20 + 196) = *((_DWORD *)a2 + 16);
        *(float *)(v20 + 200) = *((float *)a2 + 74) * *((float *)a2 + 32);
        *(_DWORD *)(v20 + 204) = *((_DWORD *)a2 + 23);
        *(_QWORD *)(v20 + 56) = 100;
        v24 = MEMORY[0x24BDAC760];
        *(_QWORD *)(v20 + 64) = *((_QWORD *)a2 + 85);
        v46[0] = v24;
        v46[1] = 3221225472;
        v46[2] = ___ZN2re18AudioManager_PHASE32updateExternalSpatialSourcePhaseERKNS_16AudioSourceStateE_block_invoke;
        v46[3] = &unk_24ED3E5A0;
        v50 = this;
        v47 = v12;
        v48 = v10;
        v51 = v55;
        v49 = v15;
        v52 = v14;
        re::audio::REPHASESoundPrepareState::setCompletionHandler(v20, v46);
        v25 = *((_QWORD *)a2 + 60);
        if (v25 && (v26 = *(_QWORD *)(v25 + 16)) != 0)
          v27 = *(const char **)(v26 + 280);
        else
          v27 = "";
        objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", v27);
        v28 = (void *)objc_claimAutoreleasedReturnValue();
        v29 = *((_QWORD *)this + 65);
        v30 = *(std::__shared_weak_count **)&buf[8];
        v45[0] = *(_QWORD *)buf;
        v45[1] = *(_QWORD *)&buf[8];
        if (*(_QWORD *)&buf[8])
        {
          v31 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
          do
            v32 = __ldxr(v31);
          while (__stxr(v32 + 1, v31));
        }
        re::AudioManager_PHASE_Async::prepareSourceAsync(v29, v45, v14, v28, *((void **)this + 67));
        if (v30)
        {
          p_shared_owners = (unint64_t *)&v30->__shared_owners_;
          do
            v34 = __ldaxr(p_shared_owners);
          while (__stlxr(v34 - 1, p_shared_owners));
          if (!v34)
          {
            ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
            std::__shared_weak_count::__release_weak(v30);
          }
        }

        v35 = *(std::__shared_weak_count **)&buf[8];
        if (*(_QWORD *)&buf[8])
        {
          v36 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
          do
            v37 = __ldaxr(v36);
          while (__stlxr(v37 - 1, v36));
          if (!v37)
          {
            ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
            std::__shared_weak_count::__release_weak(v35);
          }
        }
        v6 = v54;
      }
      else
      {
        v38 = *re::audioLogObjects(v16);
        if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          _os_log_error_impl(&dword_224FE9000, v38, OS_LOG_TYPE_ERROR, "updateExternalSpatialSourcePhase failed because sourceState has no entityID", buf, 2u);
        }
      }

    }
    return (_QWORD *)pthread_rwlock_unlock(*(pthread_rwlock_t **)v6);
  }
  return result;
}

void sub_2254110C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  uint64_t v7;
  va_list va;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  id v14;
  id v15;
  id v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  pthread_rwlock_t **v21;
  va_list va1;
  uint64_t v23;
  va_list va2;

  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v7 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, id);
  v15 = va_arg(va1, id);
  v16 = va_arg(va1, id);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  v19 = va_arg(va1, _QWORD);
  v20 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v21 = va_arg(va2, pthread_rwlock_t **);
  v23 = va_arg(va2, _QWORD);
  std::shared_ptr<re::AssetManager>::~shared_ptr[abi:nn180100]((uint64_t)va);

  std::shared_ptr<re::AssetManager>::~shared_ptr[abi:nn180100]((uint64_t)va2);
  std::lock_guard<re::ReadWriteLock::Reader>::~lock_guard[abi:ne180100]((pthread_rwlock_t ***)va1);
  _Unwind_Resume(a1);
}

void re::AudioManager_PHASE::updateSourceStateInternal(re::AudioManager_PHASE *this, simd_float4x4 *a2)
{
  uint64_t v2;
  uint64_t v5;
  os_unfair_lock_s *v6;
  unint64_t v7;
  _BOOL4 isPlaybackHostConnectionIdentifierSensitive;
  NSObject *v9;
  _QWORD block[7];

  v2 = a2[7].columns[0].i64[0];
  if (v2 != -1)
  {
    v5 = a2[10].columns[2].i64[1];
    if (a2[11].columns[2].i64[1] != v5)
      a2[11].columns[2].i64[1] = v5;
    v6 = (os_unfair_lock_s *)*((_QWORD *)this + 65);
    v7 = re::AudioSourceState::playbackHostConnectionIdentifier((re::AudioSourceState *)a2);
    isPlaybackHostConnectionIdentifierSensitive = re::AudioManager_PHASE_Async::isPlaybackHostConnectionIdentifierSensitive(v6, v7);
    re::AudioManager_PHASE_Async::setTransformForEntity(*((re::AudioManager_PHASE_Async **)this + 65), v2, a2[7].columns[3].u64[0], a2[5], a2[6], isPlaybackHostConnectionIdentifierSensitive);
    v9 = *((_QWORD *)this + 67);
    block[0] = MEMORY[0x24BDAC760];
    block[1] = 3221225472;
    block[2] = ___ZN2re18AudioManager_PHASE25updateSourceStateInternalERKNS_16AudioSourceStateE_block_invoke;
    block[3] = &__block_descriptor_56_e5_v8__0l;
    block[4] = this;
    block[5] = v5;
    block[6] = a2;
    dispatch_async(v9, block);
  }
}

id re::AudioSourceSyncState::externalStreamUUID(re::AudioSourceSyncState *this)
{
  uint64_t v1;
  _QWORD v3[3];

  v3[2] = *MEMORY[0x24BDAC8D0];
  v1 = *((_QWORD *)this + 27);
  if (*((_OWORD *)this + 13) == 0)
    return 0;
  v3[0] = *((_QWORD *)this + 26);
  v3[1] = v1;
  return (id)objc_msgSend(objc_alloc(MEMORY[0x24BDD1880]), "initWithUUIDBytes:", v3);
}

void ___ZN2re18AudioManager_PHASE32updateExternalSpatialSourcePhaseERKNS_16AudioSourceStateE_block_invoke(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  NSObject *v5;
  id v6;
  uint64_t v7;
  re *v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD block[4];
  id v17;
  uint64_t v18;
  uint64_t v19;
  uint8_t buf[4];
  uint64_t v21;
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  id v27;
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  v3 = a2;
  v4 = *(_QWORD *)(a1 + 56);
  block[0] = MEMORY[0x24BDAC760];
  block[1] = 3221225472;
  block[2] = ___ZN2re18AudioManager_PHASE32updateExternalSpatialSourcePhaseERKNS_16AudioSourceStateE_block_invoke_2;
  block[3] = &unk_24ED3EAE8;
  v18 = v4;
  v5 = *(NSObject **)(a1 + 32);
  v6 = *(id *)(a1 + 40);
  v7 = *(_QWORD *)(a1 + 64);
  v17 = v6;
  v19 = v7;
  dispatch_async(v5, block);
  v9 = *re::audioLogObjects(v8);
  if (v3)
  {
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v10 = *(_QWORD *)(a1 + 48);
      v11 = *(_QWORD *)(a1 + 64);
      v12 = *(_QWORD *)(a1 + 72);
      *(_DWORD *)buf = 138413058;
      v21 = v10;
      v22 = 2048;
      v23 = v11;
      v24 = 2048;
      v25 = v12;
      v26 = 2112;
      v27 = v3;
      _os_log_error_impl(&dword_224FE9000, v9, OS_LOG_TYPE_ERROR, "Could not prepare external stream UUID %@ for source state token %llu from connection %llu: %@", buf, 0x2Au);
    }
  }
  else if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    v13 = *(_QWORD *)(a1 + 48);
    v14 = *(_QWORD *)(a1 + 64);
    v15 = *(_QWORD *)(a1 + 72);
    *(_DWORD *)buf = 138412802;
    v21 = v13;
    v22 = 2048;
    v23 = v14;
    v24 = 2048;
    v25 = v15;
    _os_log_impl(&dword_224FE9000, v9, OS_LOG_TYPE_DEFAULT, "Prepared and started external stream UUID %@ for source state token %llu from connection %llu", buf, 0x20u);
  }

}

void ___ZN2re18AudioManager_PHASE32updateExternalSpatialSourcePhaseERKNS_16AudioSourceStateE_block_invoke_2(uint64_t a1)
{
  uint64_t v2;
  re *v3;
  NSObject *v4;
  uint8_t v5[16];

  v2 = *(_QWORD *)(a1 + 40);
  v3 = (re *)objc_msgSend(*(id *)(a1 + 32), "isCancelled");
  if ((_DWORD)v3)
  {
    v4 = *re::audioLogObjects(v3);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v5 = 0;
      _os_log_error_impl(&dword_224FE9000, v4, OS_LOG_TYPE_ERROR, "Engine cancelled, preparation completion", v5, 2u);
    }
  }
  else
  {
    std::__hash_table<std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>>>::__erase_unique<unsigned long long>((_QWORD *)(v2 + 616), (unint64_t *)(a1 + 48));
  }
}

void re::AudioManager_PHASE::prepareSource(uint64_t a1, uint64_t a2, __int128 *a3, void *a4)
{
  void (**v7)(id, _QWORD);
  _BOOL8 isSourcePrepared;
  _BOOL4 v9;
  re::AssetHandle *v10;
  NSObject *v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const char *v18;
  re *v19;
  uint64_t v20;
  unsigned int v21;
  NSObject *v22;
  re *v23;
  re *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  _BOOL8 isPlaybackHostConnectionIdentifierSensitive;
  uint64_t v30;
  NSObject *v31;
  unint64_t v32;
  char *v33;
  _QWORD *v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  char *v39;
  _QWORD *v40;
  char *v41;
  NSObject *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  _QWORD *v46;
  const char *v47;
  uint8_t *v48;
  uint64_t v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  OpaqueCMTimebase *v53;
  double EffectiveRate;
  BOOL v55;
  __int128 v56;
  unint64_t v57;
  unint64_t v58;
  char *v59;
  id v60;
  char *v61;
  uint64_t v62;
  uint64_t v63;
  const char *v64;
  re::AudioFileAsset *v65;
  uint64_t v66;
  uint64_t *v67;
  uint64_t *v68;
  uint64_t *v69;
  uint64_t *v70;
  NSObject *v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  void *v76;
  uint64_t v77;
  char *v78;
  uint64_t isCompletelyLoaded;
  uint64_t v80;
  uint32_t v81;
  unint64_t v82;
  re::AudioFileAsset *v83;
  uint64_t v84;
  uint64_t v85;
  const re::AssetHandle *v86;
  const re::AssetHandle *v87;
  re::AssetHandle *v88;
  uint64_t v89;
  uint64_t v90;
  void *v91;
  unint64_t v92;
  unint64_t v93;
  char *v94;
  id v95;
  char *v96;
  uint64_t v97;
  char *v98;
  _QWORD *v99;
  char *v100;
  uint64_t v101;
  unint64_t v102;
  uint64_t v103;
  unint64_t v104;
  char *v105;
  char *v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  unint64_t *v110;
  unint64_t v111;
  NSObject *v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  void *v116;
  re *v117;
  uint64_t v118;
  char *v119;
  uint64_t v120;
  unint64_t *p_shared_owners;
  unint64_t v122;
  _QWORD *v123;
  std::__shared_weak_count *v124;
  unint64_t *v125;
  unint64_t v126;
  void *v127;
  void *v128;
  uint64_t v129;
  unint64_t *v130;
  unint64_t v131;
  uint64_t v132;
  unint64_t *v133;
  unint64_t v134;
  void *v135;
  void *v136;
  void *v137;
  NSObject *v138;
  uint64_t v139;
  unint64_t *v140;
  unint64_t v141;
  _QWORD *v142;
  uint64_t v143;
  _QWORD *v144;
  char *v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  char *v149;
  _QWORD *v150;
  char *v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  char *v155;
  NSObject *v156;
  void *v157;
  re *v158;
  void (**aBlock)(void);
  void *v160;
  re::AudioFileAsset *v161;
  re *v162;
  id v163[9];
  _QWORD v164[2];
  _QWORD v165[2];
  _QWORD v166[2];
  void *__p[2];
  char v168;
  _QWORD v169[2];
  _QWORD v170[4];
  re *v171;
  NSObject *v172;
  void (**v173)(void);
  uint64_t v174;
  uint64_t v175;
  std::__shared_weak_count *v176;
  _BYTE v177[24];
  _BYTE *v178;
  uint64_t v179;
  const __CFString *v180;
  uint8_t v181[4];
  uint8_t *v182;
  __int16 v183;
  uint64_t v184;
  uint8_t buf[24];
  uint64_t v186;
  __int16 v187;
  const char *v188;
  __int16 v189;
  char *v190;
  uint64_t v191;

  v191 = *MEMORY[0x24BDAC8D0];
  v7 = a4;
  isSourcePrepared = re::AudioManager_PHASE::isSourcePrepared((re::AudioManager_PHASE *)a1, (const re::AudioSourceState *)a2);
  v9 = isSourcePrepared;
  v10 = (re::AssetHandle *)(a2 + 32);
  v11 = (id)*re::audioLogObjects((re *)isSourcePrepared);
  v12 = v11;
  if (v9)
  {
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      v13 = *(_QWORD *)(a2 + 680);
      v14 = *(_QWORD *)(a2 + 448);
      v15 = *(_QWORD *)(a2 + 496);
      v16 = *(_QWORD *)(a2 + 480);
      if (v16 && (v17 = *(_QWORD *)(v16 + 16)) != 0)
        v18 = *(const char **)(v17 + 280);
      else
        v18 = "";
      v40 = re::AssetHandle::assetInfo(v10);
      if ((v40[17] & 1) != 0)
        v41 = (char *)v40[18];
      else
        v41 = (char *)v40 + 137;
      *(_DWORD *)buf = 134219010;
      *(_QWORD *)&buf[4] = v13;
      *(_WORD *)&buf[12] = 2048;
      *(_QWORD *)&buf[14] = v14;
      *(_WORD *)&buf[22] = 2048;
      v186 = v15;
      v187 = 2080;
      v188 = v18;
      v189 = 2080;
      v190 = v41;
      _os_log_impl(&dword_224FE9000, v12, OS_LOG_TYPE_DEFAULT, "AudioManager_PHASE::prepareSource(token=%llu, sceneID=%llu, entity(%llu, '%s')), Asset = '%s' redundant prepare calls", buf, 0x34u);
    }

    if (v7)
      v7[2](v7, 0);
    goto LABEL_135;
  }
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
  {
    v43 = *(_QWORD *)(a2 + 680);
    v44 = *(_QWORD *)(a2 + 448);
    v45 = *(_QWORD *)(a2 + 496);
    v46 = re::AssetHandle::assetInfo((re::AssetHandle *)(a2 + 32));
    if ((v46[17] & 1) != 0)
      v47 = (const char *)v46[18];
    else
      v47 = (char *)v46 + 137;
    *(_DWORD *)buf = 134218754;
    *(_QWORD *)&buf[4] = v43;
    *(_WORD *)&buf[12] = 2048;
    *(_QWORD *)&buf[14] = v44;
    *(_WORD *)&buf[22] = 2048;
    v186 = v45;
    v187 = 2080;
    v188 = v47;
    _os_log_debug_impl(&dword_224FE9000, v12, OS_LOG_TYPE_DEBUG, "AudioManager_PHASE::prepareSource(token=%llu, sceneID=%llu, entityID=%llu), Asset = '%s'", buf, 0x2Au);
  }

  v20 = *(_QWORD *)(a2 + 40);
  if (v20)
  {
    v21 = atomic_load((unsigned int *)(v20 + 704));
    if (v21 != 2)
    {
      v22 = (id)*re::audioLogObjects(v19);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        v34 = re::AssetHandle::assetInfo((re::AssetHandle *)(a2 + 32));
        v36 = v34[17];
        v35 = (char *)v34[18];
        v37 = *(_QWORD *)(a2 + 680);
        v38 = re::AudioSourceState::playbackHostConnectionIdentifier((re::AudioSourceState *)a2);
        v39 = (char *)v34 + 137;
        *(_DWORD *)buf = 136315650;
        if ((v36 & 1) != 0)
          v39 = v35;
        *(_QWORD *)&buf[4] = v39;
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = v37;
        *(_WORD *)&buf[22] = 2048;
        v186 = v38;
        _os_log_error_impl(&dword_224FE9000, v22, OS_LOG_TYPE_ERROR, "AudioManager_PHASE::prepareSource cannot prepare asset that is not loaded. Asset='%s', token=%llu, connection=%llu", buf, 0x20u);
      }
      goto LABEL_134;
    }
    re::AudioManager_PHASE::updateSourceStateInternal((re::AudioManager_PHASE *)a1, (simd_float4x4 *)a2);
    v22 = **(id **)(a1 + 312);
    v23 = (re *)*(id *)(a1 + 8);
    v24 = v23;
    if (!*(_QWORD *)(a2 + 496))
    {
      v42 = *re::audioLogObjects(v23);
      if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_224FE9000, v42, OS_LOG_TYPE_ERROR, "AudioManager_PHASE::prepareSource failed because sourceState has no entityID", buf, 2u);
      }
      goto LABEL_133;
    }
    v162 = v23;
    v25 = *(_QWORD *)(a2 + 680);
    re::audio::REPHASESoundPrepareState::create(v23, &v175);
    v26 = v175;
    v170[0] = MEMORY[0x24BDAC760];
    v170[1] = 3221225472;
    v170[2] = ___ZN2re18AudioManager_PHASE13prepareSourceERNS_16AudioSourceStateE6CMTimeU13block_pointerFvP7NSErrorE_block_invoke;
    v170[3] = &unk_24ED3E5F0;
    v174 = v25;
    aBlock = v7;
    v173 = aBlock;
    v158 = v162;
    v171 = v158;
    v156 = v22;
    v172 = v156;
    re::audio::REPHASESoundPrepareState::setCompletionHandler(v26, v170);
    objc_storeStrong((id *)(v175 + 16), *(id *)(a2 + 464));
    v27 = v175;
    *(_QWORD *)(v175 + 24) = *(_QWORD *)(a2 + 680);
    *(_QWORD *)(v27 + 32) = *(_QWORD *)(a2 + 448);
    *(_QWORD *)(v27 + 40) = *(_QWORD *)(a2 + 496);
    v28 = re::AudioSourceState::playbackHostConnectionIdentifier((re::AudioSourceState *)a2);
    *(_QWORD *)(v175 + 48) = v28;
    isPlaybackHostConnectionIdentifierSensitive = re::AudioManager_PHASE_Async::isPlaybackHostConnectionIdentifierSensitive(*(os_unfair_lock_s **)(a1 + 520), v28);
    v30 = v175;
    *(_BYTE *)(v175 + 208) = isPlaybackHostConnectionIdentifierSensitive;
    *(_BYTE *)(v30 + 100) = *(_BYTE *)(a2 + 476);
    *(_DWORD *)(v30 + 204) = *(_DWORD *)(a2 + 92);
    v31 = (id)*re::audioLogObjects((re *)isPlaybackHostConnectionIdentifierSensitive);
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
    {
      v32 = *(char *)(v175 + 100);
      v33 = v32 > 2 ? "UNKNOWN" : off_24ED3EB28[v32];
      std::string::basic_string[abi:ne180100]<0>(buf, v33);
      v48 = (buf[23] & 0x80u) == 0 ? buf : *(uint8_t **)buf;
      *(_DWORD *)v181 = 136315394;
      v182 = v48;
      v183 = 2048;
      v184 = v25;
      _os_log_impl(&dword_224FE9000, v31, OS_LOG_TYPE_DEFAULT, "[RE/PHASE] [Prepare] Spatial Mode=%s for token=%llu in AudioManager_PHASE::prepareSource", v181, 0x16u);
      if ((char)buf[23] < 0)
        operator delete(*(void **)buf);
    }

    v49 = v175;
    *(_OWORD *)(v175 + 312) = *(_OWORD *)(a2 + 216);
    v51 = *(_OWORD *)(a2 + 352);
    v50 = *(_OWORD *)(a2 + 368);
    v52 = *(_OWORD *)(a2 + 336);
    *(_OWORD *)(v49 + 112) = *(_OWORD *)(a2 + 320);
    *(_OWORD *)(v49 + 128) = v52;
    *(_OWORD *)(v49 + 144) = v51;
    *(_OWORD *)(v49 + 160) = v50;
    *(_DWORD *)(v49 + 184) = *(_DWORD *)(a2 + 472);
    v53 = *(OpaqueCMTimebase **)(a2 + 696);
    if (v53)
    {
      EffectiveRate = CMTimebaseGetEffectiveRate(v53);
      v55 = EffectiveRate <= 4.0 && EffectiveRate >= 0.25;
      v49 = v175;
    }
    else
    {
      v55 = 0;
    }
    *(_BYTE *)(v49 + 102) = v55;
    v56 = *a3;
    *(_QWORD *)(v49 + 240) = *((_QWORD *)a3 + 2);
    *(_OWORD *)(v49 + 224) = v56;
    *(_BYTE *)(v49 + 103) = *(_BYTE *)(a2 + 100);
    *(float *)(v49 + 188) = *(float *)(a2 + 80) + *(float *)(a2 + 84);
    *(float *)(v49 + 192) = *(float *)(a2 + 96) + *(float *)(a2 + 88);
    *(_DWORD *)(v49 + 196) = *(_DWORD *)(a2 + 64);
    *(float *)(v49 + 200) = *(float *)(a2 + 296) * *(float *)(a2 + 128);
    if (*(_BYTE *)(a2 + 136))
    {
      os_unfair_lock_lock((os_unfair_lock_t)(a1 + 568));
      v57 = *(_QWORD *)(a2 + 448);
      v58 = re::AudioSourceState::playbackHostConnectionIdentifier((re::AudioSourceState *)a2);
      if ((*(_QWORD *)(a2 + 152) & 1) != 0)
        v59 = *(char **)(a2 + 160);
      else
        v59 = (char *)(a2 + 153);
      std::string::basic_string[abi:ne180100]<0>(buf, v59);
      v60 = *((id *)re::AudioManager_PHASE::mixGroupStateFor((_QWORD *)a1, v57, v58, (uint64_t)buf) + 1);
      if ((char)buf[23] < 0)
        operator delete(*(void **)buf);
      if (v60)
      {
        if ((*(_QWORD *)(a2 + 152) & 1) != 0)
          v61 = *(char **)(a2 + 160);
        else
          v61 = (char *)(a2 + 153);
        std::optional<std::string>::operator=[abi:ne180100]<char const*,void>(v175 + 248, v61);
      }

      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 568));
    }
    v160 = (void *)re::AudioSourceState::playbackHostConnectionIdentifier((re::AudioSourceState *)a2);
    v62 = *(_QWORD *)(a2 + 480);
    if (v62 && (v63 = *(_QWORD *)(v62 + 16)) != 0)
      v64 = *(const char **)(v63 + 280);
    else
      v64 = "";
    objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", v64, v156);
    v65 = (re::AudioFileAsset *)objc_claimAutoreleasedReturnValue();
    v161 = v65;
    v66 = *(_QWORD *)(a2 + 40);
    if (v66)
      v67 = *(uint64_t **)(v66 + 264);
    else
      v67 = 0;
    v68 = re::AudioFileAsset::assetType(v65);
    if (v67 == v68)
    {
      *(_QWORD *)(v175 + 56) = 0;
      v72 = re::AssetHandle::loadedAsset<re::AudioFileAsset>((re::AudioFileAsset *)(a2 + 32));
      v73 = v72;
      if (*(_BYTE *)(v72 + 153))
      {
        v74 = v175;
        *(_QWORD *)(v175 + 64) = *(_QWORD *)(*(_QWORD *)(v72 + 8) + 24);
        *(_DWORD *)(v74 + 96) = *(_DWORD *)(v72 + 96);
        *(_BYTE *)(v74 + 101) = *(_BYTE *)(v72 + 101);
        re::AudioFileAsset::audioFormat((re::AudioFileAsset *)v72);
        v75 = objc_claimAutoreleasedReturnValue();
        v76 = *(void **)(v175 + 104);
        *(_QWORD *)(v175 + 104) = v75;

        v77 = v175;
        *(_DWORD *)(v175 + 212) = *(_DWORD *)(v73 + 108);
        *(_QWORD *)(v77 + 216) = *(_QWORD *)(v73 + 112);
        if (*(_BYTE *)(v73 + 56))
        {
          if ((*(_BYTE *)(v73 + 72) & 1) != 0)
            v78 = *(char **)(v73 + 80);
          else
            v78 = (char *)(v73 + 73);
          std::optional<std::string>::operator=[abi:ne180100]<char const*,void>(v77 + 248, v78);
          v77 = v175;
        }
        v120 = *(_QWORD *)(a1 + 520);
        v169[0] = v77;
        v169[1] = v176;
        if (v176)
        {
          p_shared_owners = (unint64_t *)&v176->__shared_owners_;
          do
            v122 = __ldxr(p_shared_owners);
          while (__stxr(v122 + 1, p_shared_owners));
        }
        re::AudioManager_PHASE_Async::prepareSourceAsync(v120, v169, (uint64_t)v160, v161, *(void **)(a1 + 536));
        v123 = v169;
        goto LABEL_127;
      }
      v112 = (id)*re::audioLogObjects((re *)v72);
      if (os_log_type_enabled(v112, OS_LOG_TYPE_FAULT))
      {
        v150 = re::AssetHandle::assetInfo((re::AssetHandle *)(a2 + 32));
        v152 = v150[17];
        v151 = (char *)v150[18];
        v153 = *(_QWORD *)(a2 + 680);
        v154 = re::AudioSourceState::playbackHostConnectionIdentifier((re::AudioSourceState *)a2);
        v155 = (char *)v150 + 137;
        *(_DWORD *)buf = 136315650;
        if ((v152 & 1) != 0)
          v155 = v151;
        *(_QWORD *)&buf[4] = v155;
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = v153;
        *(_WORD *)&buf[22] = 2048;
        v186 = v154;
        _os_log_fault_impl(&dword_224FE9000, v112, OS_LOG_TYPE_FAULT, "AudioManager_PHASE::prepareSource cannot prepare file asset that hasn't completely loaded. Asset='%s', token=%llu, connection=%llu", buf, 0x20u);
      }
    }
    else
    {
      v69 = re::AudioFileGroupAsset::assetType((re::AudioFileGroupAsset *)v68);
      if (v67 == v69)
      {
        *(_QWORD *)(v175 + 56) = 1;
        isCompletelyLoaded = re::AssetHandle::loadedAsset<re::AudioFileGroupAsset>((re::AudioFileGroupAsset *)(a2 + 32));
        v80 = isCompletelyLoaded;
        if (isCompletelyLoaded)
        {
          isCompletelyLoaded = re::AudioFileGroupAsset::isCompletelyLoaded(isCompletelyLoaded);
          if ((isCompletelyLoaded & 1) != 0)
          {
            *(_QWORD *)(v175 + 64) = *(_QWORD *)(v80 + 48);
            v81 = arc4random_uniform(*(_DWORD *)(v80 + 24));
            v82 = *(_QWORD *)(v80 + 24);
            if (v82 > v81)
            {
              v83 = (re::AudioFileAsset *)re::DynamicArray<re::AssetHandle>::operator[](v80 + 8, v81);
              v84 = re::AssetHandle::loadedAsset<re::AudioFileAsset>(v83);
              if (v84)
              {
                v85 = v175;
                *(_DWORD *)(v175 + 212) = *(_DWORD *)(v84 + 108);
                *(_QWORD *)(v85 + 216) = *(_QWORD *)(v84 + 112);
              }
              v82 = *(_QWORD *)(v80 + 24);
            }
            memset(buf, 0, sizeof(buf));
            if (v82)
            {
              v86 = *(const re::AssetHandle **)(v80 + 40);
              v87 = (const re::AssetHandle *)((char *)v86 + 24 * v82);
              do
              {
                v88 = re::AssetHandle::AssetHandle((re::AssetHandle *)v181, v86);
                v89 = re::AssetHandle::loadedAsset<re::AudioFileAsset>(v88);
                re::AudioFileAsset::audioFormat((re::AudioFileAsset *)v89);
                v90 = objc_claimAutoreleasedReturnValue();
                v91 = *(void **)(v175 + 104);
                *(_QWORD *)(v175 + 104) = v90;

                if (*(_BYTE *)(v89 + 56))
                {
                  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 568));
                  v92 = *(_QWORD *)(a2 + 448);
                  v93 = re::AudioSourceState::playbackHostConnectionIdentifier((re::AudioSourceState *)a2);
                  if ((*(_BYTE *)(v89 + 72) & 1) != 0)
                    v94 = *(char **)(v89 + 80);
                  else
                    v94 = (char *)(v89 + 73);
                  std::string::basic_string[abi:ne180100]<0>(__p, v94);
                  v95 = *((id *)re::AudioManager_PHASE::mixGroupStateFor((_QWORD *)a1, v92, v93, (uint64_t)__p)+ 1);
                  if (v168 < 0)
                    operator delete(__p[0]);
                  if (v95)
                  {
                    if ((*(_BYTE *)(v89 + 72) & 1) != 0)
                      v96 = *(char **)(v89 + 80);
                    else
                      v96 = (char *)(v89 + 73);
                    std::optional<std::string>::operator=[abi:ne180100]<char const*,void>(v175 + 248, v96);
                  }

                  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 568));
                }
                v97 = *(_QWORD *)(*(_QWORD *)(v89 + 8) + 24);
                v98 = *(char **)&buf[8];
                if (*(_QWORD *)&buf[8] >= *(_QWORD *)&buf[16])
                {
                  v100 = *(char **)buf;
                  v101 = (uint64_t)(*(_QWORD *)&buf[8] - *(_QWORD *)buf) >> 3;
                  v102 = v101 + 1;
                  if ((unint64_t)(v101 + 1) >> 61)
                    std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
                  v103 = *(_QWORD *)&buf[16] - *(_QWORD *)buf;
                  if ((uint64_t)(*(_QWORD *)&buf[16] - *(_QWORD *)buf) >> 2 > v102)
                    v102 = v103 >> 2;
                  if ((unint64_t)v103 >= 0x7FFFFFFFFFFFFFF8)
                    v104 = 0x1FFFFFFFFFFFFFFFLL;
                  else
                    v104 = v102;
                  if (v104)
                  {
                    v105 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&buf[16], v104);
                    v100 = *(char **)buf;
                    v98 = *(char **)&buf[8];
                  }
                  else
                  {
                    v105 = 0;
                  }
                  v106 = &v105[8 * v101];
                  *(_QWORD *)v106 = v97;
                  v99 = v106 + 8;
                  while (v98 != v100)
                  {
                    v107 = *((_QWORD *)v98 - 1);
                    v98 -= 8;
                    *((_QWORD *)v106 - 1) = v107;
                    v106 -= 8;
                  }
                  *(_QWORD *)buf = v106;
                  *(_QWORD *)&buf[8] = v99;
                  *(_QWORD *)&buf[16] = &v105[8 * v104];
                  if (v100)
                    operator delete(v100);
                }
                else
                {
                  **(_QWORD **)&buf[8] = v97;
                  v99 = v98 + 8;
                }
                *(_QWORD *)&buf[8] = v99;
                re::AssetHandle::~AssetHandle((re::AssetHandle *)v181);
                v86 = (const re::AssetHandle *)((char *)v86 + 24);
              }
              while (v86 != v87);
            }
            v108 = v175;
            *(_DWORD *)(v175 + 96) = 0;
            if ((uint8_t *)(v108 + 72) != buf)
            {
              std::vector<unsigned long long>::__assign_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>((_QWORD *)(v108 + 72), *(char **)buf, *(char **)&buf[8], (uint64_t)(*(_QWORD *)&buf[8] - *(_QWORD *)buf) >> 3);
              v108 = v175;
            }
            v109 = *(_QWORD *)(a1 + 520);
            v166[0] = v108;
            v166[1] = v176;
            if (v176)
            {
              v110 = (unint64_t *)&v176->__shared_owners_;
              do
                v111 = __ldxr(v110);
              while (__stxr(v111 + 1, v110));
            }
            re::AudioManager_PHASE_Async::prepareSourceAsync(v109, v166, (uint64_t)v160, v161, *(void **)(a1 + 536));
            std::shared_ptr<re::AssetManager>::~shared_ptr[abi:nn180100]((uint64_t)v166);
            if (*(_QWORD *)buf)
            {
              *(_QWORD *)&buf[8] = *(_QWORD *)buf;
              operator delete(*(void **)buf);
            }
            goto LABEL_128;
          }
        }
        v112 = (id)*re::audioLogObjects((re *)isCompletelyLoaded);
        if (os_log_type_enabled(v112, OS_LOG_TYPE_FAULT))
        {
          v144 = re::AssetHandle::assetInfo((re::AssetHandle *)(a2 + 32));
          v146 = v144[17];
          v145 = (char *)v144[18];
          v147 = *(_QWORD *)(a2 + 680);
          v148 = re::AudioSourceState::playbackHostConnectionIdentifier((re::AudioSourceState *)a2);
          v149 = (char *)v144 + 137;
          *(_DWORD *)buf = 136315650;
          if ((v146 & 1) != 0)
            v149 = v145;
          *(_QWORD *)&buf[4] = v149;
          *(_WORD *)&buf[12] = 2048;
          *(_QWORD *)&buf[14] = v147;
          *(_WORD *)&buf[22] = 2048;
          v186 = v148;
          _os_log_fault_impl(&dword_224FE9000, v112, OS_LOG_TYPE_FAULT, "AudioManager_PHASE::prepareSource cannot prepare group asset that is not completelyLoaded. Asset='%s', token=%llu, connection=%llu", buf, 0x20u);
        }
      }
      else
      {
        v70 = re::AudioGeneratorAsset::assetType((re::AudioGeneratorAsset *)v69);
        if (v67 != v70)
        {
          v71 = *re::audioLogObjects((re *)v70);
          if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)buf = 0;
            _os_log_error_impl(&dword_224FE9000, v71, OS_LOG_TYPE_ERROR, "Unsupported Asset type", buf, 2u);
          }
          goto LABEL_128;
        }
        v113 = re::AssetHandle::loadedAsset<re::AudioGeneratorAsset>((re::AudioGeneratorAsset *)(a2 + 32));
        v114 = v175;
        *(_QWORD *)(v175 + 56) = 2;
        *(_DWORD *)(v114 + 184) = *(_DWORD *)v113;
        *(_QWORD *)(v114 + 64) = *(_QWORD *)(a2 + 680);
        re::AudioSourceSyncState::externalStreamUUID((re::AudioSourceSyncState *)(a2 + 24));
        v115 = objc_claimAutoreleasedReturnValue();
        v116 = *(void **)(v175 + 304);
        *(_QWORD *)(v175 + 304) = v115;

        v118 = v175;
        *(_BYTE *)(v175 + 296) = *(_BYTE *)(a1 + 272);
        if (*(_BYTE *)(v113 + 8))
        {
          if ((*(_BYTE *)(v113 + 24) & 1) != 0)
            v119 = *(char **)(v113 + 32);
          else
            v119 = (char *)(v113 + 25);
          v117 = (re *)std::optional<std::string>::operator=[abi:ne180100]<char const*,void>(v118 + 248, v119);
        }
        if (*(_BYTE *)(a2 + 488))
        {
          if (*(_BYTE *)(v113 + 56))
          {
            v127 = _Block_copy(*(const void **)(v113 + 48));
            v128 = *(void **)(v175 + 288);
            *(_QWORD *)(v175 + 288) = v127;

            v129 = *(_QWORD *)(a1 + 520);
            v164[0] = v175;
            v164[1] = v176;
            if (v176)
            {
              v130 = (unint64_t *)&v176->__shared_owners_;
              do
                v131 = __ldxr(v130);
              while (__stxr(v131 + 1, v130));
            }
            re::AudioManager_PHASE_Async::prepareSourceAsync(v129, v164, (uint64_t)v160, v161, *(void **)(a1 + 536));
            v123 = v164;
LABEL_127:
            std::shared_ptr<re::AssetManager>::~shared_ptr[abi:nn180100]((uint64_t)v123);
LABEL_128:

            v124 = v176;
            v24 = v162;
            if (v176)
            {
              v125 = (unint64_t *)&v176->__shared_owners_;
              do
                v126 = __ldaxr(v125);
              while (__stlxr(v126 - 1, v125));
              if (!v126)
              {
                ((void (*)(std::__shared_weak_count *))v124->__on_zero_shared)(v124);
                std::__shared_weak_count::__release_weak(v124);
              }
            }
LABEL_133:

LABEL_134:
            goto LABEL_135;
          }
          v135 = *(void **)(a2 + 456);
          if (v135)
          {
            objc_storeStrong((id *)(v175 + 280), v135);
            goto LABEL_128;
          }
          v138 = (id)*re::audioLogObjects(v117);
          if (os_log_type_enabled(v138, OS_LOG_TYPE_DEFAULT))
          {
            v139 = *(_QWORD *)(a2 + 680);
            *(_DWORD *)buf = 134217984;
            *(_QWORD *)&buf[4] = v139;
            _os_log_impl(&dword_224FE9000, v138, OS_LOG_TYPE_DEFAULT, "[RE/ASSET] [Prepare] AudioGeneratorAsset created with legacy audio unit mode. Instantiating AudioUnit for token: %llu", buf, 0xCu);
          }

          v163[0] = (id)a2;
          v163[1] = v158;
          v163[2] = v157;
          v163[3] = _Block_copy(aBlock);
          v163[4] = (id)v175;
          v163[5] = v176;
          if (v176)
          {
            v140 = (unint64_t *)&v176->__shared_owners_;
            do
              v141 = __ldxr(v140);
            while (__stxr(v141 + 1, v140));
          }
          v163[6] = (id)a1;
          v163[7] = v160;
          v163[8] = v161;
          std::function<void ()(AUAudioUnit *,NSError *)>::function<re::AudioManager_PHASE::prepareSource(re::AudioSourceState &,CMTime,void({block_pointer})(NSError *))::$_0,void>((uint64_t)v177, (uint64_t)v163);
          re::AudioGeneratorAsset::instantiateAudioUnit(v113, (uint64_t)v177);
          v142 = v178;
          if (v178 == v177)
          {
            v143 = 4;
            v142 = v177;
          }
          else
          {
            if (!v178)
            {
LABEL_170:
              re::AudioManager_PHASE::prepareSource(re::AudioSourceState &,CMTime,void({block_pointer})(NSError *))::$_0::~$_0(v163);
              goto LABEL_128;
            }
            v143 = 5;
          }
          (*(void (**)(void))(*v142 + 8 * v143))();
          goto LABEL_170;
        }
        if (*(_BYTE *)(a1 + 272))
        {
          v132 = *(_QWORD *)(a1 + 520);
          v165[0] = v175;
          v165[1] = v176;
          if (v176)
          {
            v133 = (unint64_t *)&v176->__shared_owners_;
            do
              v134 = __ldxr(v133);
            while (__stxr(v134 + 1, v133));
          }
          re::AudioManager_PHASE_Async::prepareSourceAsync(v132, v165, (uint64_t)v160, v161, *(void **)(a1 + 536));
          v123 = v165;
          goto LABEL_127;
        }
        v136 = (void *)MEMORY[0x24BDD1540];
        v179 = *MEMORY[0x24BDD0FC8];
        v180 = CFSTR("audio manager cannot prepare non-local generator asset without external control");
        objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", &v180, &v179, 1);
        v137 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v136, "errorWithDomain:code:userInfo:", CFSTR("com.apple.re.internal"), -110, v137);
        v112 = objc_claimAutoreleasedReturnValue();

        if (aBlock)
          aBlock[2]();
      }
    }

    goto LABEL_128;
  }
LABEL_135:

}

void sub_225412340(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, id a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,char a26,uint64_t a27,char a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35,char a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,void *a42,void *a43,void *a44)
{
  void *v44;
  void *v45;
  _QWORD *v46;
  uint64_t v47;
  _QWORD *v49;
  uint64_t v50;

  v49 = *(_QWORD **)(v47 - 216);
  if (v49 == v46)
  {
    v50 = 4;
    v49 = (_QWORD *)(v47 - 240);
  }
  else
  {
    if (!v49)
      goto LABEL_6;
    v50 = 5;
  }
  (*(void (**)(void))(*v49 + 8 * v50))();
LABEL_6:
  re::AudioManager_PHASE::prepareSource(re::AudioSourceState &,CMTime,void({block_pointer})(NSError *))::$_0::~$_0(&a15);

  std::shared_ptr<re::AssetManager>::~shared_ptr[abi:nn180100](v47 - 256);
  _Unwind_Resume(a1);
}

BOOL re::AudioManager_PHASE::isSourcePrepared(re::AudioManager_PHASE *this, const re::AudioSourceState *a2)
{
  uint64_t v4;
  pthread_rwlock_t *v5;
  id v6;
  void *v7;
  BOOL v9;

  re::AudioGeneratorAsset::assetType(this);
  if (*((_QWORD *)a2 + 5))
  {
    if (*((_QWORD *)a2 + 87))
    {
LABEL_3:
      v4 = *((_QWORD *)this + 65);
      v5 = *(pthread_rwlock_t **)(v4 + 232);
      v4 += 232;
      pthread_rwlock_rdlock(v5);
      v6 = *(id *)(v4 + 16);
      objc_msgSend(v6, "eventFor:", *((_QWORD *)a2 + 85), v4 + 16, v4);
      v7 = (void *)objc_claimAutoreleasedReturnValue();

      pthread_rwlock_unlock(*(pthread_rwlock_t **)v4);
      return v7 != 0;
    }
  }
  else
  {
    if (*((_QWORD *)a2 + 29))
      v9 = 0;
    else
      v9 = *((_QWORD *)a2 + 30) == 0;
    if (!v9 || *((_QWORD *)a2 + 87) != 0)
      goto LABEL_3;
  }
  return 0;
}

void sub_2254125E8(_Unwind_Exception *a1)
{
  pthread_rwlock_t ***v1;
  void *v2;

  std::lock_guard<re::ReadWriteLock::Reader>::~lock_guard[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void ___ZN2re18AudioManager_PHASE13prepareSourceERNS_16AudioSourceStateE6CMTimeU13block_pointerFvP7NSErrorE_block_invoke(uint64_t a1, void *a2)
{
  re *v3;
  NSObject *v4;
  NSObject *v5;
  uint64_t v6;
  _QWORD block[4];
  id v8;
  re *v9;
  id v10;
  uint8_t buf[4];
  uint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v3 = a2;
  v4 = *re::audioLogObjects(v3);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    v6 = *(_QWORD *)(a1 + 56);
    *(_DWORD *)buf = 134217984;
    v12 = v6;
    _os_log_debug_impl(&dword_224FE9000, v4, OS_LOG_TYPE_DEBUG, "Prepare completed for %llu", buf, 0xCu);
  }
  if (*(_QWORD *)(a1 + 48))
  {
    v5 = *(NSObject **)(a1 + 32);
    if (v5)
    {
      block[0] = MEMORY[0x24BDAC760];
      block[1] = 3221225472;
      block[2] = ___ZN2re18AudioManager_PHASE13prepareSourceERNS_16AudioSourceStateE6CMTimeU13block_pointerFvP7NSErrorE_block_invoke_27;
      block[3] = &unk_24ED3E5C8;
      v8 = *(id *)(a1 + 40);
      v10 = *(id *)(a1 + 48);
      v9 = v3;
      dispatch_async(v5, block);

    }
  }

}

void ___ZN2re18AudioManager_PHASE13prepareSourceERNS_16AudioSourceStateE6CMTimeU13block_pointerFvP7NSErrorE_block_invoke_27(uint64_t a1)
{
  re *v2;
  NSObject *v3;
  uint8_t v4[16];

  v2 = (re *)objc_msgSend(*(id *)(a1 + 32), "isCancelled");
  if ((_DWORD)v2)
  {
    v3 = *re::audioLogObjects(v2);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v4 = 0;
      _os_log_error_impl(&dword_224FE9000, v3, OS_LOG_TYPE_ERROR, "Engine cancelled, preparation completion", v4, 2u);
    }
  }
  else
  {
    (*(void (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
  }
}

unsigned __int8 *re::AudioManager_PHASE::mixGroupStateFor(_QWORD *a1, unint64_t a2, unint64_t a3, uint64_t a4)
{
  unint64_t v5;
  int8x8_t v6;
  unint64_t v7;
  uint8x8_t v8;
  unint64_t v9;
  unint64_t v10;
  unsigned __int8 **v11;
  unsigned __int8 *i;
  unint64_t v13;
  id v14;
  std::string *v15;
  void *v16;
  void *v17;
  re *v18;
  NSObject *v19;
  std::string *v20;
  NSObject *v21;
  id v22;
  _QWORD v24[4];
  id v25;
  _QWORD *v26;
  std::string __p;
  std::string v28;
  _BYTE buf[24];
  uint64_t v30;

  v30 = *MEMORY[0x24BDAC8D0];
  REAudioComputePHASEMixGroupID(a2, a3, a4, &v28);
  v5 = std::__string_hash<char>::operator()[abi:ne180100]((uint64_t)(a1 + 75), (uint64_t)&v28);
  v6 = (int8x8_t)a1[73];
  if (v6)
  {
    v7 = v5;
    v8 = (uint8x8_t)vcnt_s8(v6);
    v8.i16[0] = vaddlv_u8(v8);
    v9 = v8.u32[0];
    if (v8.u32[0] > 1uLL)
    {
      v10 = v5;
      if (v5 >= *(_QWORD *)&v6)
        v10 = v5 % *(_QWORD *)&v6;
    }
    else
    {
      v10 = (*(_QWORD *)&v6 - 1) & v5;
    }
    v11 = *(unsigned __int8 ***)(a1[72] + 8 * v10);
    if (v11)
    {
      for (i = *v11; i; i = *(unsigned __int8 **)i)
      {
        v13 = *((_QWORD *)i + 1);
        if (v13 == v7)
        {
          if ((std::equal_to<std::string>::operator()[abi:ne180100]((uint64_t)(a1 + 76), i + 16, (unsigned __int8 *)&v28) & 1) != 0)goto LABEL_30;
        }
        else
        {
          if (v9 > 1)
          {
            if (v13 >= *(_QWORD *)&v6)
              v13 %= *(_QWORD *)&v6;
          }
          else
          {
            v13 &= *(_QWORD *)&v6 - 1;
          }
          if (v13 != v10)
            break;
        }
      }
    }
  }
  v14 = objc_alloc(MEMORY[0x24BDE3278]);
  if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v15 = &v28;
  else
    v15 = (std::string *)v28.__r_.__value_.__r.__words[0];
  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", v15);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  v17 = (void *)objc_msgSend(v14, "initWithIdentifier:", v16);

  *(_QWORD *)buf = &v28;
  i = std::__hash_table<std::__hash_value_type<std::string,re::AudioManager_PHASE::MixGroupState>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,re::AudioManager_PHASE::MixGroupState>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,re::AudioManager_PHASE::MixGroupState>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,re::AudioManager_PHASE::MixGroupState>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a1 + 72), (unsigned __int8 *)&v28, (__int128 **)buf);
  objc_storeStrong((id *)i + 6, v17);
  v19 = *re::audioLogObjects(v18);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
  {
    v20 = &v28;
    if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      v20 = (std::string *)v28.__r_.__value_.__r.__words[0];
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = v20;
    _os_log_impl(&dword_224FE9000, v19, OS_LOG_TYPE_INFO, "[RE/PHASE] [MixGroup] Will register PHASEGroup in the phase queue. PhaseID: %s (sceneID - connectionID - name).", buf, 0xCu);
  }
  v21 = a1[67];
  v24[0] = MEMORY[0x24BDAC760];
  v24[1] = 3321888768;
  v24[2] = ___ZN2re18AudioManager_PHASE16mixGroupStateForEyyRKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE_block_invoke;
  v24[3] = &unk_24ED3E638;
  v26 = a1;
  v22 = v17;
  v25 = v22;
  if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&__p, v28.__r_.__value_.__l.__data_, v28.__r_.__value_.__l.__size_);
  else
    __p = v28;
  dispatch_async(v21, v24);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);

LABEL_30:
  if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v28.__r_.__value_.__l.__data_);
  return i + 40;
}

void sub_225412A98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  void *v23;

  if (a23 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

uint64_t std::optional<std::string>::operator=[abi:ne180100]<char const*,void>(uint64_t a1, char *a2)
{
  if (*(_BYTE *)(a1 + 24))
  {
    MEMORY[0x227692F50](a1);
  }
  else
  {
    std::string::basic_string[abi:ne180100]<0>((_QWORD *)a1, a2);
    *(_BYTE *)(a1 + 24) = 1;
  }
  return a1;
}

uint64_t re::AssetHandle::loadedAsset<re::AudioFileGroupAsset>(re::AudioFileGroupAsset *a1)
{
  uint64_t *v2;

  if (!*((_QWORD *)a1 + 1))
    return 0;
  v2 = re::AudioFileGroupAsset::assetType(a1);
  return re::AssetHandle::assetWithType(a1, (const re::AssetType *)v2, 1);
}

uint64_t re::DynamicArray<re::AssetHandle>::operator[](uint64_t a1, unint64_t a2)
{
  if (*(_QWORD *)(a1 + 16) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a1 + 32) + 24 * a2;
}

uint64_t re::AssetHandle::loadedAsset<re::AudioGeneratorAsset>(re::AudioGeneratorAsset *a1)
{
  uint64_t *v2;

  if (!*((_QWORD *)a1 + 1))
    return 0;
  v2 = re::AudioGeneratorAsset::assetType(a1);
  return re::AssetHandle::assetWithType(a1, (const re::AssetType *)v2, 1);
}

uint64_t std::function<void ()(AUAudioUnit *,NSError *)>::function<re::AudioManager_PHASE::prepareSource(re::AudioSourceState &,CMTime,void({block_pointer})(NSError *))::$_0,void>(uint64_t a1, uint64_t a2)
{
  char *v4;
  __int128 v5;
  __int128 v6;
  uint64_t v7;

  *(_QWORD *)(a1 + 24) = 0;
  v4 = (char *)operator new(0x50uLL);
  *(_QWORD *)v4 = &off_24ED3EA28;
  v5 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(v4 + 8) = *(_OWORD *)a2;
  *(_OWORD *)(v4 + 24) = v5;
  v6 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(v4 + 40) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a2 + 8) = 0u;
  *(_QWORD *)(a2 + 24) = 0;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(v4 + 56) = v6;
  v7 = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(a2 + 64) = 0;
  *((_QWORD *)v4 + 9) = v7;
  *(_QWORD *)(a1 + 24) = v4;
  return a1;
}

id *re::AudioManager_PHASE::prepareSource(re::AudioSourceState &,CMTime,void({block_pointer})(NSError *))::$_0::~$_0(id *a1)
{

  std::shared_ptr<re::AssetManager>::~shared_ptr[abi:nn180100]((uint64_t)(a1 + 4));
  return a1;
}

uint64_t re::AudioManager_PHASE::scheduleSourceState(re::AudioManager_PHASE *this, const re::AudioSourceState *a2, int a3, double a4, uint64_t a5, CMTime *a6)
{
  uint64_t v11;
  uint64_t v12;
  pthread_rwlock_t *v13;
  id v14;
  void *v15;
  re *v16;
  NSObject *v17;
  NSObject *v18;
  OpaqueCMClock *HostTimeClock;
  CMTimeValue v21;
  Float64 Seconds;
  _QWORD *v23;
  CMTimeValue v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  const char *v31;
  uint64_t v32;
  CMTime v33;
  CMTime rhs;
  CMTime lhs;
  CMTime time;
  CMTime v37;
  uint64_t v38;
  uint64_t v39;
  CMTime v40;
  Float64 v41;
  __int16 v42;
  _BYTE v43[18];
  __int16 v44;
  const char *v45;
  __int16 v46;
  uint64_t v47;
  uint64_t v48;

  v48 = *MEMORY[0x24BDAC8D0];
  v11 = *((_QWORD *)this + 65);
  v13 = *(pthread_rwlock_t **)(v11 + 232);
  v12 = v11 + 232;
  v38 = v12 + 16;
  v39 = v12;
  pthread_rwlock_rdlock(v13);
  v14 = *(id *)(v12 + 16);
  objc_msgSend(v14, "eventFor:", *((_QWORD *)a2 + 85));
  v15 = (void *)objc_claimAutoreleasedReturnValue();

  v17 = (id)*re::audioLogObjects(v16);
  v18 = v17;
  if (v15)
  {
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
    {
      v21 = *((_QWORD *)a2 + 85);
      v37 = *a6;
      Seconds = CMTimeGetSeconds(&v37);
      LODWORD(v40.value) = 134219008;
      *(CMTimeValue *)((char *)&v40.value + 4) = v21;
      LOWORD(v40.flags) = 2048;
      *(_QWORD *)((char *)&v40.flags + 2) = a5;
      HIWORD(v40.epoch) = 2048;
      v41 = Seconds;
      v42 = 1024;
      *(_DWORD *)v43 = a3;
      *(_WORD *)&v43[4] = 2048;
      *(double *)&v43[6] = a4;
      _os_log_debug_impl(&dword_224FE9000, v18, OS_LOG_TYPE_DEBUG, "scheduling token %llu at time %llu with offset %0.3f, shouldSeek=%d, rate=%0.2f", (uint8_t *)&v40, 0x30u);
    }

    if (a3)
    {
      if ((a6->flags & 1) != 0)
      {
        time = *a6;
        objc_msgSend(v15, "seekToTime:", CMTimeGetSeconds(&time));
      }
      else
      {
        memset(&v40, 0, sizeof(v40));
        HostTimeClock = CMClockGetHostTimeClock();
        CMClockGetTime(&lhs, HostTimeClock);
        CMClockMakeHostTimeFromSystemUnits(&rhs, a5);
        CMTimeSubtract(&v40, &lhs, &rhs);
        v33 = v40;
        objc_msgSend(v15, "seekToTime:", CMTimeGetSeconds(&v33));
      }
    }
    if (a4 == 0.0)
    {
      objc_msgSend(v15, "pause");
    }
    else
    {
      if (re::internal::enableSignposts(0, 0))
        kdebug_trace();
      objc_msgSend(v15, "resume");
    }
  }
  else
  {
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      v23 = re::AssetHandle::assetInfo((const re::AudioSourceState *)((char *)a2 + 32));
      if ((v23[17] & 1) != 0)
        v24 = v23[18];
      else
        v24 = (CMTimeValue)v23 + 137;
      v25 = *((_QWORD *)a2 + 85);
      v26 = re::AudioSourceState::playbackHostConnectionIdentifier(a2);
      v27 = *((_QWORD *)a2 + 56);
      v28 = *((_QWORD *)a2 + 62);
      v29 = *((_QWORD *)a2 + 60);
      if (v29 && (v30 = *(_QWORD *)(v29 + 16)) != 0)
        v31 = *(const char **)(v30 + 280);
      else
        v31 = "";
      v32 = *((_QWORD *)a2 + 93);
      LODWORD(v40.value) = 136316674;
      *(CMTimeValue *)((char *)&v40.value + 4) = v24;
      LOWORD(v40.flags) = 2048;
      *(_QWORD *)((char *)&v40.flags + 2) = v25;
      HIWORD(v40.epoch) = 2048;
      v41 = *(double *)&v26;
      v42 = 2048;
      *(_QWORD *)v43 = v27;
      *(_WORD *)&v43[8] = 2048;
      *(_QWORD *)&v43[10] = v28;
      v44 = 2080;
      v45 = v31;
      v46 = 2048;
      v47 = v32;
      _os_log_error_impl(&dword_224FE9000, v18, OS_LOG_TYPE_ERROR, "AudioManager_PHASE::scheduleSourceState(asset=\"%s\", token=%llu, connection=%llu, sceneID=%llu, entity(%llu, '%s'), sourceID=%llu) could not find sound event", (uint8_t *)&v40, 0x48u);
    }

  }
  return pthread_rwlock_unlock(*(pthread_rwlock_t **)v12);
}

void sub_22541309C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,pthread_rwlock_t **a28)
{
  void *v28;
  void *v29;

  std::lock_guard<re::ReadWriteLock::Reader>::~lock_guard[abi:ne180100](&a28);
  _Unwind_Resume(a1);
}

uint64_t re::AudioManager_PHASE::isPreparingSoundEvent(re::AudioManager_PHASE *this, const re::AudioSourceState *a2)
{
  uint64_t v3;
  pthread_rwlock_t *v4;
  id v5;
  uint64_t v6;

  v3 = *((_QWORD *)this + 65);
  v4 = *(pthread_rwlock_t **)(v3 + 232);
  v3 += 232;
  pthread_rwlock_rdlock(v4);
  v5 = *(id *)(v3 + 16);
  v6 = objc_msgSend(v5, "eventBeingPrepared:", *((_QWORD *)a2 + 85), v3 + 16, v3);

  pthread_rwlock_unlock(*(pthread_rwlock_t **)v3);
  return v6;
}

void sub_22541316C(_Unwind_Exception *a1)
{
  pthread_rwlock_t ***v1;
  void *v2;

  std::lock_guard<re::ReadWriteLock::Reader>::~lock_guard[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t re::AudioManager_PHASE::prepareMeshAsset(uint64_t a1, void *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  id v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v13[5];
  uint64_t v14[5];
  uint64_t v15[5];

  v9 = a2;
  v10 = *(_QWORD *)(a1 + 520);
  re::DynamicArray<re::AcousticAbsorptionMaterial>::DynamicArray((uint64_t)v15, a3);
  re::DynamicArray<re::AcousticScatteringMaterial>::DynamicArray((uint64_t)v14, a4);
  re::DynamicArray<re::AcousticSoundReductionMaterial>::DynamicArray((uint64_t)v13, a5);
  v11 = re::AudioManager_PHASE_Async::prepareMeshAsset(v10, v9, v15, v14, v13);
  re::DynamicArray<re::AcousticSoundReductionMaterial>::deinit((uint64_t)v13);
  re::DynamicArray<re::AcousticSoundReductionMaterial>::deinit((uint64_t)v14);
  re::DynamicArray<re::AcousticSoundReductionMaterial>::deinit((uint64_t)v15);

  return v11;
}

void sub_22541323C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  uint64_t v4;
  va_list va;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  va_list va1;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  va_list va2;

  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v10 = va_arg(va2, _QWORD);
  v12 = va_arg(va2, _QWORD);
  v13 = va_arg(va2, _QWORD);
  v14 = va_arg(va2, _QWORD);
  v15 = va_arg(va2, _QWORD);
  re::DynamicArray<re::AcousticSoundReductionMaterial>::deinit((uint64_t)va);
  re::DynamicArray<re::AcousticSoundReductionMaterial>::deinit((uint64_t)va1);
  re::DynamicArray<re::AcousticSoundReductionMaterial>::deinit((uint64_t)va2);

  _Unwind_Resume(a1);
}

uint64_t re::AudioManager_PHASE::prepareMeshAsset(uint64_t a1, void *a2, uint64_t a3)
{
  return re::AudioManager_PHASE_Async::prepareMeshAsset(*(_QWORD *)(a1 + 520), a2, a3);
}

void re::AudioManager_PHASE::removeMeshAsset(re::AudioManager_PHASE *this, uint64_t a2)
{
  NSObject *v2;
  _QWORD v3[6];

  v2 = *((_QWORD *)this + 67);
  v3[0] = MEMORY[0x24BDAC760];
  v3[1] = 3221225472;
  v3[2] = ___ZN2re18AudioManager_PHASE15removeMeshAssetEy_block_invoke;
  v3[3] = &__block_descriptor_48_e5_v8__0l;
  v3[4] = this;
  v3[5] = a2;
  dispatch_async(v2, v3);
}

uint64_t ___ZN2re18AudioManager_PHASE15removeMeshAssetEy_block_invoke(uint64_t a1)
{
  return re::AudioManager_PHASE_Async::removeMeshAsset(*(pthread_rwlock_t ***)(*(_QWORD *)(a1 + 32) + 520), *(_QWORD *)(a1 + 40));
}

void re::AudioManager_PHASE::setMeshesForEntity(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, int a5, int a6)
{
  re::AudioManager_PHASE_Async::setMeshesForEntity(*(_QWORD *)(a1 + 520), a2, a3, a4, a5, a6);
}

uint64_t re::AudioManager_PHASE::setTransformForEntity(re::AudioManager_PHASE_Async **this, uint64_t a2, unint64_t a3, simd_float4x4 a4, simd_float4x4 a5, int a6)
{
  return re::AudioManager_PHASE_Async::setTransformForEntity(this[65], a2, a3, a4, a5, a6);
}

void re::AudioManager_PHASE::unloadAsset(re::AudioManager_PHASE *this, uint64_t a2)
{
  NSObject *v2;
  _QWORD v3[6];

  v2 = *((_QWORD *)this + 67);
  v3[0] = MEMORY[0x24BDAC760];
  v3[1] = 3221225472;
  v3[2] = ___ZN2re18AudioManager_PHASE11unloadAssetEy_block_invoke;
  v3[3] = &__block_descriptor_48_e5_v8__0l;
  v3[4] = this;
  v3[5] = a2;
  dispatch_async(v2, v3);
}

uint64_t ___ZN2re18AudioManager_PHASE11unloadAssetEy_block_invoke(uint64_t a1)
{
  return re::AudioManager_PHASE_Async::unloadAsset(*(re::AudioManager_PHASE_Async **)(*(_QWORD *)(a1 + 32) + 520), *(_QWORD *)(a1 + 40));
}

id re::AudioManager_PHASE::getPHASEAssetForIdentifier(re::AudioManager_PHASE *this, uint64_t a2)
{
  NSObject *v2;
  id v3;
  _QWORD block[7];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t (*v9)(uint64_t, uint64_t);
  void (*v10)(uint64_t);
  id v11;

  v6 = 0;
  v7 = &v6;
  v8 = 0x3032000000;
  v9 = __Block_byref_object_copy__4;
  v10 = __Block_byref_object_dispose__4;
  v11 = 0;
  v2 = *((_QWORD *)this + 67);
  block[0] = MEMORY[0x24BDAC760];
  block[1] = 3221225472;
  block[2] = ___ZNK2re18AudioManager_PHASE26getPHASEAssetForIdentifierEy_block_invoke;
  block[3] = &unk_24ED3E4A8;
  block[4] = &v6;
  block[5] = this;
  block[6] = a2;
  dispatch_sync(v2, block);
  v3 = (id)v7[5];
  _Block_object_dispose(&v6, 8);

  return v3;
}

void ___ZNK2re18AudioManager_PHASE26getPHASEAssetForIdentifierEy_block_invoke(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  re::AudioManager_PHASE_Async::getPHASEAssetForIdentifier(*(pthread_rwlock_t ***)(a1[5] + 520), a1[6]);
  v2 = objc_claimAutoreleasedReturnValue();
  v3 = *(_QWORD *)(a1[4] + 8);
  v4 = *(void **)(v3 + 40);
  *(_QWORD *)(v3 + 40) = v2;

}

uint64_t re::AudioManager_PHASE::removeSourceFromSceneIfIncorrectlyConnected(re::AudioManager_PHASE *this, const re::AudioSourceState *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  pthread_rwlock_t *v7;
  id v8;
  int v9;
  re *v10;
  NSObject *v11;
  uint64_t v12;
  uint8_t buf[4];
  uint64_t v15;
  __int16 v16;
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  v4 = re::AudioManager::removeSourceFromSceneIfIncorrectlyConnected(this, a2);
  v5 = *((_QWORD *)this + 65);
  v7 = *(pthread_rwlock_t **)(v5 + 232);
  v6 = v5 + 232;
  pthread_rwlock_rdlock(v7);
  v8 = *(id *)(v6 + 16);
  v9 = objc_msgSend(v8, "doCleanUpSoundEventForToken:ifNotInScene:", *((_QWORD *)a2 + 85), *((_QWORD *)a2 + 56), v6 + 16, v6);

  if (v9)
  {
    v11 = (id)*re::audioLogObjects(v10);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      v12 = *((_QWORD *)a2 + 85);
      *(_DWORD *)buf = 134218240;
      v15 = v12;
      v16 = 2048;
      v17 = re::AudioSourceState::playbackHostConnectionIdentifier(a2);
      _os_log_impl(&dword_224FE9000, v11, OS_LOG_TYPE_DEFAULT, "[RE/PHASE] [Playback] Stopped sound with token: %llu from connection %llu", buf, 0x16u);
    }

    *((_QWORD *)a2 + 93) = 0;
    *((_DWORD *)a2 + 181) = 0;
    v4 = 1;
  }
  pthread_rwlock_unlock(*(pthread_rwlock_t **)v6);
  return v4;
}

void sub_22541356C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  va_list va;

  va_start(va, a2);

  std::lock_guard<re::ReadWriteLock::Reader>::~lock_guard[abi:ne180100]((pthread_rwlock_t ***)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN2re18AudioManager_PHASE25updateSourceStateInternalERKNS_16AudioSourceStateE_block_invoke(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  pthread_rwlock_t *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  uint64_t v9;
  int8x16_t v10;
  int8x16_t v11;
  __int128 v12;
  float v13;
  float v14;
  float v15;
  float v17;
  float v18;
  __int128 v19;
  float32x2_t v20;
  float32x2_t v21;
  float32x2_t v22;
  float32x2_t v23;
  float32x2_t v24;
  float v26;
  float32_t v27;
  float32x2_t v28;
  float32x2_t v29;
  float32x2_t v30;
  float32x2_t v31;
  float32x2_t v32;
  float32x2_t v33;
  float32x2_t v34;
  float32x2_t v35;
  float32x4_t v40;
  float32x2_t v41;
  float32x2_t v42;
  float v43;
  unsigned int v44;
  float32x2_t v45;
  float32x2_t v46;
  float32x2_t v47;
  float32x2_t v48;
  float32x2_t v49;
  float32x2_t v50;
  float32x4_t v51;
  unsigned __int32 v52;
  float32x2_t v53;
  float32x2_t v54;
  void *v55;
  void *v56;
  void *v57;
  float v58;
  float v59;
  void *v60;
  double v61;
  NSObject *v62;
  uint64_t v63;
  float v64;
  float v65;
  float v66;
  float v67;
  void *v68;
  double v69;
  float v70;
  re *v71;
  NSObject *v72;
  double v73;
  uint64_t v74;
  float v75;
  float v76;
  float v77;
  float v78;
  void *v79;
  double v80;
  float v81;
  re *v82;
  NSObject *v83;
  double v84;
  float v85;
  std::__shared_weak_count *v86;
  float v87;
  unint64_t *v88;
  unint64_t v89;
  int v90;
  std::__shared_weak_count *v91;
  unint64_t *p_shared_owners;
  unint64_t v93;
  int v94;
  std::__shared_weak_count *v95;
  unint64_t *v96;
  unint64_t v97;
  int v98;
  std::__shared_weak_count *v99;
  unint64_t *v100;
  unint64_t v101;
  char v102;
  std::__shared_weak_count *v103;
  unint64_t *v104;
  unint64_t v105;
  int v106;
  std::__shared_weak_count *v107;
  unint64_t *v108;
  unint64_t v109;
  void *v111;
  re *v112;
  int v113;
  NSObject *v114;
  uint64_t v115;
  uint64_t v116;
  double v117;
  uint64_t v118;
  uint64_t v119;
  __int128 v120;
  _QWORD v121[4];
  __int128 v122;
  uint64_t v123;
  uint64_t v124;
  _BYTE __p[22];
  char v126;
  uint64_t v127;

  v127 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1[4] + 520);
  v4 = *(pthread_rwlock_t **)(v2 + 232);
  v3 = v2 + 232;
  v123 = v3 + 16;
  v124 = v3;
  pthread_rwlock_rdlock(v4);
  objc_msgSend(*(id *)(v3 + 16), "eventFor:", a1[5]);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = v5;
  if (!v5)
    goto LABEL_72;
  objc_msgSend(v5, "soundEvent");
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  if (v7)
  {

LABEL_5:
    v9 = a1[6];
    v10 = *(int8x16_t *)(v9 + 320);
    v11 = *(int8x16_t *)(v9 + 336);
    v12 = *(_OWORD *)(v9 + 352);
    LODWORD(v13) = HIDWORD(*(_QWORD *)(v9 + 336));
    v14 = COERCE_FLOAT(*(_QWORD *)(v9 + 360));
    v15 = v14 + (float)(*(float *)v10.i32 + v13);
    if (v15 >= 0.0)
    {
      v26 = sqrtf(v15 + 1.0);
      v27 = v26 + v26;
      v28 = vrecpe_f32((float32x2_t)COERCE_UNSIGNED_INT(v26 + v26));
      v29 = vmul_f32(v28, vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT(v26 + v26), v28));
      v29.i32[0] = vmul_f32(v29, vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT(v26 + v26), v29)).u32[0];
      *(float32x2_t *)v40.f32 = vmul_n_f32(vsub_f32((float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v11, v11, 8uLL), *(int32x2_t *)&v12), (float32x2_t)vext_s8(*(int8x8_t *)&v12, (int8x8_t)*(_OWORD *)&vextq_s8(v10, v10, 8uLL), 4uLL)), v29.f32[0]);
      v30.i32[0] = vsub_f32((float32x2_t)*(_OWORD *)&vdupq_lane_s32(*(int32x2_t *)v10.i8, 1), *(float32x2_t *)v11.i8).u32[0];
      v30.f32[1] = v27;
      v29.i32[1] = 0.25;
      v42 = vmul_f32(v30, v29);
    }
    else if (*(float *)v10.i32 < v13 || *(float *)v10.i32 < v14)
    {
      v17 = 1.0 - *(float *)v10.i32;
      if (v13 >= v14)
      {
        v43 = sqrtf(v13 + (float)(v17 - v14));
        *(float *)&v44 = v43 + v43;
        v45 = vrecpe_f32((float32x2_t)v44);
        v46 = vmul_f32(v45, vrecps_f32((float32x2_t)v44, v45));
        v47.i32[0] = vmul_f32(v46, vrecps_f32((float32x2_t)v44, v46)).u32[0];
        v46.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_lane_s32(*(int32x2_t *)v10.i8, 1), *(float32x2_t *)v11.i8).u32[0];
        v46.i32[1] = v44;
        v48 = (float32x2_t)vrev64_s32(*(int32x2_t *)&v12);
        v49.i32[0] = vadd_f32(v48, (float32x2_t)*(_OWORD *)&vextq_s8(v11, v11, 8uLL)).u32[0];
        v49.i32[1] = vsub_f32(v48, (float32x2_t)vdup_laneq_s32(*(int32x4_t *)&v10, 2)).i32[1];
        v42 = vmul_n_f32(v49, v47.f32[0]);
        v47.i32[1] = 0.25;
        *(float32x2_t *)v40.f32 = vmul_f32(v46, v47);
      }
      else
      {
        v18 = sqrtf(v14 + (float)(v17 - v13));
        v19 = *(_OWORD *)(v9 + 320);
        *(float *)&v19 = v18;
        v20 = vadd_f32((float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v10, v10, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v11, v11, 8uLL)), *(float32x2_t *)&v12);
        v21 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)v11.i8, 0);
        v22 = vsub_f32(*(float32x2_t *)v10.i8, v21);
        v21.i32[0] = 2.0;
        v21.i32[0] = vmul_f32(*(float32x2_t *)&v19, v21).u32[0];
        v21.i32[1] = v22.i32[1];
        v23 = vrecpe_f32((float32x2_t)v21.u32[0]);
        v24 = vmul_f32(v23, vrecps_f32((float32x2_t)v21.u32[0], v23));
        v22.i32[0] = vmul_f32(v24, vrecps_f32((float32x2_t)v21.u32[0], v24)).u32[0];
        *(float32x2_t *)v40.f32 = vmul_n_f32(v20, v22.f32[0]);
        __asm { FMOV            V2.2S, #0.25 }
        _D2.i32[1] = v22.i32[0];
        v42 = vmul_f32(v21, _D2);
      }
    }
    else
    {
      v31 = (float32x2_t)__PAIR64__(v10.u32[1], COERCE_UNSIGNED_INT(sqrtf(*(float *)v10.i32 + (float)((float)(1.0 - v13) - v14))));
      v32 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)v11.i8, 0);
      v33 = vadd_f32(*(float32x2_t *)v10.i8, v32);
      v32.i32[0] = 2.0;
      v32.i32[0] = vmul_f32(v31, v32).u32[0];
      v32.i32[1] = v33.i32[1];
      v34 = vrecpe_f32((float32x2_t)v32.u32[0]);
      v35 = vmul_f32(v34, vrecps_f32((float32x2_t)v32.u32[0], v34));
      v31.i32[0] = vmul_f32(v35, vrecps_f32((float32x2_t)v32.u32[0], v35)).u32[0];
      __asm { FMOV            V5.2S, #0.25 }
      _D5.i32[1] = v31.i32[0];
      *(float32x2_t *)v40.f32 = vmul_f32(v32, _D5);
      v41.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(v10, v10, 8uLL), *(float32x2_t *)&v12).u32[0];
      v41.i32[1] = vsub_f32((float32x2_t)vdup_laneq_s32(*(int32x4_t *)&v11, 2), *(float32x2_t *)&v12).i32[1];
      v42 = vmul_n_f32(v41, v31.f32[0]);
    }
    v50 = vadd_f32(vmul_f32(*(float32x2_t *)v40.f32, *(float32x2_t *)v40.f32), vmul_f32(v42, v42));
    if (vaddv_f32(v50) == 0.0)
    {
      v51 = (float32x4_t)xmmword_2260E5D70;
    }
    else
    {
      *(float32x2_t *)&v40.u32[2] = v42;
      v52 = vadd_f32(v50, (float32x2_t)vdup_lane_s32((int32x2_t)v50, 1)).u32[0];
      v53 = vrsqrte_f32((float32x2_t)v52);
      v54 = vmul_f32(v53, vrsqrts_f32((float32x2_t)v52, vmul_f32(v53, v53)));
      v51 = vmulq_n_f32(v40, vmul_f32(v54, vrsqrts_f32((float32x2_t)v52, vmul_f32(v54, v54))).f32[0]);
    }
    objc_msgSend(v6, "soundEvent", *(_OWORD *)&v51);
    v55 = (void *)objc_claimAutoreleasedReturnValue();

    if (v55)
      objc_msgSend(v6, "soundEvent");
    else
      objc_msgSend(v6, "externalStreamController");
    v56 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v56, "mixers");
    v57 = (void *)objc_claimAutoreleasedReturnValue();

    v121[0] = MEMORY[0x24BDAC760];
    v121[1] = 3221225472;
    v121[2] = ___ZN2re18AudioManager_PHASE25updateSourceStateInternalERKNS_16AudioSourceStateE_block_invoke_2;
    v121[3] = &__block_descriptor_48_e15_v32__0_8_16_B24l;
    v122 = v120;
    objc_msgSend(v57, "enumerateKeysAndObjectsUsingBlock:", v121);

    goto LABEL_22;
  }
  objc_msgSend(v6, "externalStreamController");
  v8 = (void *)objc_claimAutoreleasedReturnValue();

  if (v8)
    goto LABEL_5;
LABEL_22:
  v58 = *(float *)(a1[6] + 64);
  objc_msgSend(v6, "cachedPlaybackSpeed");
  if (v58 != v59)
  {
    objc_msgSend(v6, "paramForKey:", CFSTR("rate"));
    v60 = (void *)objc_claimAutoreleasedReturnValue();
    if (v60)
    {
      LODWORD(v61) = *(_DWORD *)(a1[6] + 64);
      v62 = *re::audioLogObjects((re *)objc_msgSend(v6, "setCachedPlaybackSpeed:", v61));
      if (os_log_type_enabled(v62, OS_LOG_TYPE_DEBUG))
      {
        v116 = a1[5];
        v117 = *(float *)(a1[6] + 64);
        *(_DWORD *)__p = 134218240;
        *(double *)&__p[4] = v117;
        *(_WORD *)&__p[12] = 2048;
        *(_QWORD *)&__p[14] = v116;
        _os_log_debug_impl(&dword_224FE9000, v62, OS_LOG_TYPE_DEBUG, "[RE/PHASE] [Playback] Rate=%.2f for token=%llu", __p, 0x16u);
      }
      objc_msgSend(v60, "fadeToValue:duration:", *(float *)(a1[6] + 64), 0.0);
    }
    else
    {
      objc_msgSend(v6, "soundEvent");
      v111 = (void *)objc_claimAutoreleasedReturnValue();

      if (v111)
      {
        std::string::basic_string[abi:ne180100]<0>(__p, "Could not find rate param for token");
        v112 = (re *)re::audio::throttledLog(OS_LOG_TYPE_ERROR, (__int128 *)__p);
        v113 = (int)v112;
        if (v126 < 0)
          operator delete(*(void **)__p);
        if (v113)
        {
          v114 = *re::audioLogObjects(v112);
          if (os_log_type_enabled(v114, OS_LOG_TYPE_ERROR))
          {
            v115 = a1[5];
            *(_DWORD *)__p = 134217984;
            *(_QWORD *)&__p[4] = v115;
            _os_log_error_impl(&dword_224FE9000, v114, OS_LOG_TYPE_ERROR, "Could not find rate param for token %llu", __p, 0xCu);
          }
        }
      }
    }

  }
  v63 = a1[6];
  v64 = *(float *)(v63 + 80);
  v65 = *(float *)(v63 + 84);
  objc_msgSend(v6, "cachedReverbSendLevel");
  v66 = v64 + v65;
  if (v66 != v67)
  {
    objc_msgSend(v6, "paramForKey:", CFSTR("reverbSend"));
    v68 = (void *)objc_claimAutoreleasedReturnValue();
    if (v68)
    {
      *(float *)&v69 = v66;
      objc_msgSend(v6, "setCachedReverbSendLevel:", v69);
      v70 = __exp10f(v66 / 20.0);
      v72 = *re::audioLogObjects(v71);
      v73 = v70;
      if (os_log_type_enabled(v72, OS_LOG_TYPE_DEBUG))
      {
        v118 = a1[5];
        *(_DWORD *)__p = 134218240;
        *(double *)&__p[4] = v73;
        *(_WORD *)&__p[12] = 2048;
        *(_QWORD *)&__p[14] = v118;
        _os_log_debug_impl(&dword_224FE9000, v72, OS_LOG_TYPE_DEBUG, "[RE/PHASE] [Playback] Reverb=%.2f for token=%llu", __p, 0x16u);
      }
      objc_msgSend(v68, "fadeToValue:duration:", v73, 0.0);
    }

  }
  v74 = a1[6];
  v75 = *(float *)(v74 + 96);
  v76 = *(float *)(v74 + 88);
  objc_msgSend(v6, "cachedDirectSendLevel");
  v77 = v75 + v76;
  if (v77 != v78)
  {
    objc_msgSend(v6, "paramForKey:", CFSTR("directSend"));
    v79 = (void *)objc_claimAutoreleasedReturnValue();
    if (v79)
    {
      *(float *)&v80 = v77;
      objc_msgSend(v6, "setCachedDirectSendLevel:", v80);
      v81 = __exp10f(v77 / 20.0);
      v83 = *re::audioLogObjects(v82);
      v84 = v81;
      if (os_log_type_enabled(v83, OS_LOG_TYPE_DEBUG))
      {
        v119 = a1[5];
        *(_DWORD *)__p = 134218240;
        *(double *)&__p[4] = v84;
        *(_WORD *)&__p[12] = 2048;
        *(_QWORD *)&__p[14] = v119;
        _os_log_debug_impl(&dword_224FE9000, v83, OS_LOG_TYPE_DEBUG, "[RE/PHASE] [Playback] Direct=%.2f for token=%llu", __p, 0x16u);
      }
      objc_msgSend(v79, "fadeToValue:duration:", v84, 0.0);
    }

  }
  v85 = *(float *)(a1[6] + 220);
  objc_msgSend(v6, "prepareState");
  v86 = *(std::__shared_weak_count **)&__p[8];
  v87 = *(float *)(*(_QWORD *)__p + 316);
  if (*(_QWORD *)&__p[8])
  {
    v88 = (unint64_t *)(*(_QWORD *)&__p[8] + 8);
    do
      v89 = __ldaxr(v88);
    while (__stlxr(v89 - 1, v88));
    if (!v89)
    {
      ((void (*)(std::__shared_weak_count *))v86->__on_zero_shared)(v86);
      std::__shared_weak_count::__release_weak(v86);
    }
  }
  if (v85 != v87)
  {
    v90 = *(_DWORD *)(a1[6] + 220);
    objc_msgSend(v6, "prepareState");
    v91 = *(std::__shared_weak_count **)&__p[8];
    *(_DWORD *)(*(_QWORD *)__p + 316) = v90;
    if (v91)
    {
      p_shared_owners = (unint64_t *)&v91->__shared_owners_;
      do
        v93 = __ldaxr(p_shared_owners);
      while (__stlxr(v93 - 1, p_shared_owners));
      if (!v93)
      {
        ((void (*)(std::__shared_weak_count *))v91->__on_zero_shared)(v91);
        std::__shared_weak_count::__release_weak(v91);
      }
    }
  }
  v94 = *(_DWORD *)(a1[6] + 224);
  objc_msgSend(v6, "prepareState");
  v95 = *(std::__shared_weak_count **)&__p[8];
  *(_DWORD *)(*(_QWORD *)__p + 320) = v94;
  if (v95)
  {
    v96 = (unint64_t *)&v95->__shared_owners_;
    do
      v97 = __ldaxr(v96);
    while (__stlxr(v97 - 1, v96));
    if (!v97)
    {
      ((void (*)(std::__shared_weak_count *))v95->__on_zero_shared)(v95);
      std::__shared_weak_count::__release_weak(v95);
    }
  }
  v98 = *(_DWORD *)(a1[6] + 228);
  objc_msgSend(v6, "prepareState");
  v99 = *(std::__shared_weak_count **)&__p[8];
  *(_DWORD *)(*(_QWORD *)__p + 324) = v98;
  if (v99)
  {
    v100 = (unint64_t *)&v99->__shared_owners_;
    do
      v101 = __ldaxr(v100);
    while (__stlxr(v101 - 1, v100));
    if (!v101)
    {
      ((void (*)(std::__shared_weak_count *))v99->__on_zero_shared)(v99);
      std::__shared_weak_count::__release_weak(v99);
    }
  }
  v102 = *(_BYTE *)(a1[6] + 100);
  objc_msgSend(v6, "prepareState");
  v103 = *(std::__shared_weak_count **)&__p[8];
  *(_BYTE *)(*(_QWORD *)__p + 103) = v102;
  if (v103)
  {
    v104 = (unint64_t *)&v103->__shared_owners_;
    do
      v105 = __ldaxr(v104);
    while (__stlxr(v105 - 1, v104));
    if (!v105)
    {
      ((void (*)(std::__shared_weak_count *))v103->__on_zero_shared)(v103);
      std::__shared_weak_count::__release_weak(v103);
    }
  }
  v106 = *(_DWORD *)(a1[6] + 92);
  objc_msgSend(v6, "prepareState");
  v107 = *(std::__shared_weak_count **)&__p[8];
  *(_DWORD *)(*(_QWORD *)__p + 204) = v106;
  if (v107)
  {
    v108 = (unint64_t *)&v107->__shared_owners_;
    do
      v109 = __ldaxr(v108);
    while (__stlxr(v109 - 1, v108));
    if (!v109)
    {
      ((void (*)(std::__shared_weak_count *))v107->__on_zero_shared)(v107);
      std::__shared_weak_count::__release_weak(v107);
    }
  }
  v3 = v124;
LABEL_72:

  return pthread_rwlock_unlock(*(pthread_rwlock_t **)v3);
}

void sub_225413E44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  void *v24;
  void *v25;

  if (a24 < 0)
    operator delete(__p);

  std::lock_guard<re::ReadWriteLock::Reader>::~lock_guard[abi:ne180100]((pthread_rwlock_t ***)&a18);
  _Unwind_Resume(a1);
}

void ___ZN2re18AudioManager_PHASE25updateSourceStateInternalERKNS_16AudioSourceStateE_block_invoke_2(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;

  v4 = a3;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    objc_msgSend(v4, "setOrientation:", *(double *)(a1 + 32));

}

void sub_225413F6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

uint64_t ___ZN2re18AudioManager_PHASE23configureAndStartEngineEv_block_invoke(uint64_t a1)
{
  return re::AudioManager_PHASE_Async::configureAndStartEngine(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 520));
}

void re::AudioManager_PHASE::forceAudioOutputType(uint64_t a1, int a2)
{
  NSObject *v2;
  _QWORD v3[5];
  int v4;

  v2 = *(NSObject **)(a1 + 536);
  v3[0] = MEMORY[0x24BDAC760];
  v3[1] = 3221225472;
  v3[2] = ___ZN2re18AudioManager_PHASE20forceAudioOutputTypeE17REAudioOutputType_block_invoke;
  v3[3] = &__block_descriptor_44_e5_v8__0l;
  v3[4] = a1;
  v4 = a2;
  dispatch_async(v2, v3);
}

uint64_t ___ZN2re18AudioManager_PHASE20forceAudioOutputTypeE17REAudioOutputType_block_invoke(uint64_t a1)
{
  return re::AudioManager_PHASE_Async::forceAudioOutputType(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 520), *(_DWORD *)(a1 + 40));
}

uint64_t re::AudioManager_PHASE::currentAudioOutputType(re::AudioManager_PHASE *this)
{
  NSObject *v1;
  uint64_t v2;
  _QWORD v4[6];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  int v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2020000000;
  v8 = 0;
  v1 = *((_QWORD *)this + 67);
  v4[0] = MEMORY[0x24BDAC760];
  v4[1] = 3221225472;
  v4[2] = ___ZN2re18AudioManager_PHASE22currentAudioOutputTypeEv_block_invoke;
  v4[3] = &unk_24ED3E480;
  v4[4] = &v5;
  v4[5] = this;
  dispatch_sync(v1, v4);
  v2 = *((unsigned int *)v6 + 6);
  _Block_object_dispose(&v5, 8);
  return v2;
}

uint64_t ___ZN2re18AudioManager_PHASE22currentAudioOutputTypeEv_block_invoke(uint64_t a1)
{
  uint64_t result;

  result = re::AudioManager_PHASE_Async::currentAudioOutputType(*(pthread_rwlock_t ***)(*(_QWORD *)(a1 + 40) + 520));
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  return result;
}

void re::AudioManager_PHASE::applyCustomHRIR(id *this)
{
  id v2;
  NSObject *v3;
  id v4;
  _QWORD v5[4];
  id v6;
  id *v7;

  v2 = this[37];
  v3 = this[67];
  v5[0] = MEMORY[0x24BDAC760];
  v5[1] = 3221225472;
  v5[2] = ___ZN2re18AudioManager_PHASE15applyCustomHRIREv_block_invoke;
  v5[3] = &unk_24ED3D378;
  v6 = v2;
  v7 = this;
  v4 = v2;
  dispatch_async(v3, v5);

}

void ___ZN2re18AudioManager_PHASE15applyCustomHRIREv_block_invoke(uint64_t a1)
{
  re::AudioManager_PHASE_Async::applyCustomHRIR(*(re::AudioManager_PHASE_Async **)(*(_QWORD *)(a1 + 40) + 520), *(NSURL **)(a1 + 32));
}

BOOL re::AudioManager_PHASE::applyMixGroupState(os_unfair_lock_s *this, unint64_t a2, unint64_t a3, const re::AudioMixGroup *a4, int a5)
{
  os_unfair_lock_s *v10;
  char *v11;
  char *v12;
  unsigned __int8 *v13;
  unsigned __int8 *v14;
  int v15;
  int v16;
  void *v17;
  re *v18;
  NSObject *v19;
  char *v20;
  uint64_t v21;
  NSObject *v22;
  char *v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  void *v27;
  char *v28;
  float v29;
  double v30;
  NSObject *v31;
  uint64_t v32;
  char *v33;
  float v34;
  uint64_t v35;
  void *v36;
  char *v37;
  float v38;
  double v39;
  float v40;
  double v41;
  float v42;
  float v43;
  re *v44;
  NSObject *v45;
  uint64_t v46;
  char *v47;
  float v48;
  uint64_t v49;
  void *v50;
  char *v51;
  re *v52;
  NSObject *v53;
  char *v54;
  uint64_t v55;
  float v56;
  float v57;
  uint64_t v58;
  void *v59;
  char *v60;
  os_unfair_lock_s *v62;
  os_unfair_lock_s *v63;
  _BYTE __p[12];
  __int16 v65;
  _BYTE v66[18];
  __int16 v67;
  uint64_t v68;
  uint64_t v69;

  v69 = *MEMORY[0x24BDAC8D0];
  v10 = this + 142;
  os_unfair_lock_lock(this + 142);
  v11 = (char *)a4 + 9;
  if ((*((_QWORD *)a4 + 1) & 1) != 0)
    v12 = (char *)*((_QWORD *)a4 + 2);
  else
    v12 = (char *)a4 + 9;
  std::string::basic_string[abi:ne180100]<0>(__p, v12);
  v13 = re::AudioManager_PHASE::mixGroupStateFor(this, a2, a3, (uint64_t)__p);
  v14 = v13;
  if ((v66[9] & 0x80000000) != 0)
    operator delete(*(void **)__p);
  v15 = *v14;
  if (*v14)
  {
    v16 = *((unsigned __int8 *)a4 + 88);
    if (v16 != objc_msgSend(*((id *)v14 + 1), "isMuted"))
    {
      v17 = (void *)*((_QWORD *)v14 + 1);
      if (*((_BYTE *)a4 + 88))
        v18 = (re *)objc_msgSend(v17, "mute");
      else
        v18 = (re *)objc_msgSend(v17, "unmute");
      v22 = (id)*re::audioLogObjects(v18);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
      {
        v62 = v10;
        v24 = *((_QWORD *)a4 + 1);
        v23 = (char *)*((_QWORD *)a4 + 2);
        v25 = *((unsigned __int8 *)a4 + 88);
        objc_msgSend(*((id *)v14 + 1), "identifier");
        v26 = objc_claimAutoreleasedReturnValue();
        v27 = (void *)v26;
        if ((v24 & 1) != 0)
          v28 = v23;
        else
          v28 = (char *)a4 + 9;
        *(_DWORD *)__p = 136315650;
        *(_QWORD *)&__p[4] = v28;
        v65 = 1024;
        *(_DWORD *)v66 = v25;
        *(_WORD *)&v66[4] = 2112;
        *(_QWORD *)&v66[6] = v26;
        _os_log_impl(&dword_224FE9000, v22, OS_LOG_TYPE_INFO, "[RE/PHASE] [MixGroup] Name: %s, Set Muted: %d, PhaseID: %@ (sceneID - connectionID - name).", __p, 0x1Cu);

        v10 = v62;
      }

    }
    v29 = *((float *)a4 + 26);
    objc_msgSend(*((id *)v14 + 1), "rate");
    if (vabdd_f64(v29, v30) > 0.00000011920929)
    {
      v31 = (id)*re::audioLogObjects((re *)objc_msgSend(*((id *)v14 + 1), "setRate:", *((float *)a4 + 26)));
      if (os_log_type_enabled(v31, OS_LOG_TYPE_INFO))
      {
        v63 = v10;
        v32 = *((_QWORD *)a4 + 1);
        v33 = (char *)*((_QWORD *)a4 + 2);
        v34 = *((float *)a4 + 26);
        objc_msgSend(*((id *)v14 + 1), "identifier");
        v35 = objc_claimAutoreleasedReturnValue();
        v36 = (void *)v35;
        if ((v32 & 1) != 0)
          v37 = v33;
        else
          v37 = (char *)a4 + 9;
        *(_DWORD *)__p = 136315650;
        *(_QWORD *)&__p[4] = v37;
        v65 = 2048;
        *(double *)v66 = v34;
        *(_WORD *)&v66[8] = 2112;
        *(_QWORD *)&v66[10] = v35;
        _os_log_impl(&dword_224FE9000, v31, OS_LOG_TYPE_INFO, "[RE/PHASE] [MixGroup] Name: %s, Set Speed: %.2f, PhaseID: %@ (sceneID - connectionID - name).", __p, 0x20u);

        v10 = v63;
      }

    }
    v38 = __exp10f(*((float *)a4 + 24) / 20.0);
    objc_msgSend(*((id *)v14 + 1), "gainLowFrequency");
    if (vabdd_f64(v38, v39) > 0.00000011920929)
      objc_msgSend(*((id *)v14 + 1), "setGainLowFrequency:");
    v40 = __exp10f(*((float *)a4 + 23) / 20.0);
    objc_msgSend(*((id *)v14 + 1), "gainHighFrequency");
    if (vabdd_f64(v40, v41) > 0.00000011920929)
      objc_msgSend(*((id *)v14 + 1), "setGainHighFrequency:");
    if (a5)
    {
      v42 = *((float *)a4 + 27);
      if (v42 == 0.0)
      {
        v43 = *((float *)a4 + 28);
      }
      else
      {
        v43 = *((float *)a4 + 28);
        if (*((float *)a4 + 29) == v43)
        {
LABEL_43:
          if (v42 > 0.0)
          {
            v52 = (re *)objc_msgSend(*((id *)v14 + 1), "fadeGain:duration:curveType:", 1668435054, __exp10f(*((float *)a4 + 29) / 20.0), *((float *)a4 + 27));
            v53 = (id)*re::audioLogObjects(v52);
            if (os_log_type_enabled(v53, OS_LOG_TYPE_INFO))
            {
              v55 = *((_QWORD *)a4 + 1);
              v54 = (char *)*((_QWORD *)a4 + 2);
              v56 = *((float *)a4 + 27);
              v57 = *((float *)a4 + 29);
              objc_msgSend(*((id *)v14 + 1), "identifier");
              v58 = objc_claimAutoreleasedReturnValue();
              v59 = (void *)v58;
              *(_DWORD *)__p = 136315906;
              if ((v55 & 1) != 0)
                v60 = v54;
              else
                v60 = v11;
              *(_QWORD *)&__p[4] = v60;
              v65 = 2048;
              *(double *)v66 = v56;
              *(_WORD *)&v66[8] = 2048;
              *(double *)&v66[10] = v57;
              v67 = 2112;
              v68 = v58;
              _os_log_impl(&dword_224FE9000, v53, OS_LOG_TYPE_INFO, "[RE/PHASE] [MixGroup] Name: %s, Set Fade: %.2fs, Gain: %.2fdB, PhaseID: %@ (sceneID - connectionID - name).", __p, 0x2Au);

            }
          }
          goto LABEL_50;
        }
      }
      v44 = (re *)objc_msgSend(*((id *)v14 + 1), "setGain:", __exp10f(v43 / 20.0));
      v45 = (id)*re::audioLogObjects(v44);
      if (os_log_type_enabled(v45, OS_LOG_TYPE_INFO))
      {
        v46 = *((_QWORD *)a4 + 1);
        v47 = (char *)*((_QWORD *)a4 + 2);
        v48 = *((float *)a4 + 28);
        objc_msgSend(*((id *)v14 + 1), "identifier");
        v49 = objc_claimAutoreleasedReturnValue();
        v50 = (void *)v49;
        if ((v46 & 1) != 0)
          v51 = v47;
        else
          v51 = (char *)a4 + 9;
        *(_DWORD *)__p = 136315650;
        *(_QWORD *)&__p[4] = v51;
        v65 = 2048;
        *(double *)v66 = v48;
        *(_WORD *)&v66[8] = 2112;
        *(_QWORD *)&v66[10] = v49;
        _os_log_impl(&dword_224FE9000, v45, OS_LOG_TYPE_INFO, "[RE/PHASE] [MixGroup] Name: %s, Set Gain: %.2fdB, PhaseID: %@ (sceneID - connectionID - name).", __p, 0x20u);

      }
      v42 = *((float *)a4 + 27);
      goto LABEL_43;
    }
  }
  else
  {
    v19 = *re::audioLogObjects((re *)v13);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
    {
      if ((*((_QWORD *)a4 + 1) & 1) != 0)
        v20 = (char *)*((_QWORD *)a4 + 2);
      else
        v20 = (char *)a4 + 9;
      v21 = *((_QWORD *)a4 + 4);
      *(_DWORD *)__p = 136315394;
      *(_QWORD *)&__p[4] = v20;
      v65 = 2048;
      *(_QWORD *)v66 = v21;
      _os_log_impl(&dword_224FE9000, v19, OS_LOG_TYPE_INFO, "[RE/PHASE] [MixGroup] Ignoring changes for mixGroup %s(id=%llu) as it isn't registered with PHASE yet.", __p, 0x16u);
    }
  }
LABEL_50:
  os_unfair_lock_unlock(v10);
  return v15 != 0;
}

void sub_22541466C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_unfair_lock_t lock, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  void *v16;
  os_unfair_lock_s *v17;

  os_unfair_lock_unlock(v17);
  _Unwind_Resume(a1);
}

void re::AudioManager_PHASE_Async::idlePhaseEngine(re::AudioManager_PHASE_Async *this, PHASEEngine *a2)
{
  PHASEEngine *v3;
  pthread_rwlock_t *v4;
  pthread_t v5;
  NSObject *v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  _QWORD v10[3];
  pthread_rwlock_t **v11;
  uint8_t buf[4];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v3 = a2;
  v4 = (pthread_rwlock_t *)*((_QWORD *)this + 29);
  v10[2] = (char *)this + 248;
  v11 = (pthread_rwlock_t **)((char *)this + 232);
  pthread_rwlock_rdlock(v4);
  v5 = pthread_self();
  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v10, 2526, (uint64_t)v5);
  if (*((_BYTE *)this + 340))
  {
    v6 = *re::audioLogObjects((re *)-[PHASEEngine stop](v3, "stop"));
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      v7 = atomic_load((unint64_t *)this + 50);
      *(_DWORD *)buf = 134217984;
      v13 = v7;
      v8 = "AudioManager_PHASE shutdown timer expired after %llu frames, stopping PHASEEngine";
LABEL_6:
      _os_log_impl(&dword_224FE9000, v6, OS_LOG_TYPE_DEFAULT, v8, buf, 0xCu);
    }
  }
  else
  {
    v6 = *re::audioLogObjects((re *)-[PHASEEngine pause](v3, "pause"));
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      v9 = atomic_load((unint64_t *)this + 50);
      *(_DWORD *)buf = 134217984;
      v13 = v9;
      v8 = "AudioManager_PHASE shutdown timer expired after %llu frames, pausing PHASEEngine";
      goto LABEL_6;
    }
  }
  atomic_store(0, (unint64_t *)this + 53);
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v10);
  pthread_rwlock_unlock(*v11);

}

void sub_225414854(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

void ___ZN2re18AudioManager_PHASE16mixGroupStateForEyyRKNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEE_block_invoke(uint64_t a1)
{
  uint64_t v2;
  __int128 *v3;

  v2 = *(_QWORD *)(a1 + 40);
  re::AudioManager_PHASE_Async::registerMixGroup(*(re::AudioManager_PHASE_Async **)(v2 + 520), *(PHASEGroup **)(a1 + 32));
  os_unfair_lock_lock((os_unfair_lock_t)(v2 + 568));
  v3 = (__int128 *)(a1 + 48);
  std::__hash_table<std::__hash_value_type<std::string,re::AudioManager_PHASE::MixGroupState>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,re::AudioManager_PHASE::MixGroupState>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,re::AudioManager_PHASE::MixGroupState>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,re::AudioManager_PHASE::MixGroupState>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v2 + 576, (unsigned __int8 *)(a1 + 48), &v3)[40] = 1;
  os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 568));
}

void sub_225414904(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void __copy_helper_block_ea8_48c66_ZTSNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE(std::string *a1, uint64_t a2)
{
  std::string *v2;
  __int128 v3;

  v2 = a1 + 2;
  if (*(char *)(a2 + 71) < 0)
  {
    std::string::__init_copy_ctor_external(v2, *(const std::string::value_type **)(a2 + 48), *(_QWORD *)(a2 + 56));
  }
  else
  {
    v3 = *(_OWORD *)(a2 + 48);
    v2->__r_.__value_.__r.__words[2] = *(_QWORD *)(a2 + 64);
    *(_OWORD *)&v2->__r_.__value_.__l.__data_ = v3;
  }
}

void __destroy_helper_block_ea8_48c66_ZTSNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE(uint64_t a1)
{
  if (*(char *)(a1 + 71) < 0)
    operator delete(*(void **)(a1 + 48));
}

BOOL re::AudioManager_PHASE::shouldLoadFileAssetsByAbsolutePath(re::AudioManager_PHASE *this)
{
  uint64_t v1;
  os_unfair_lock_s *v2;
  _BOOL8 v3;

  v1 = *((_QWORD *)this + 65);
  v2 = (os_unfair_lock_s *)(v1 + 336);
  os_unfair_lock_lock((os_unfair_lock_t)(v1 + 336));
  v3 = *(_QWORD *)(v1 + 320) != 0;
  os_unfair_lock_unlock(v2);
  return v3;
}

double re::AudioManager_PHASE::getPeerTimestamp(re::AudioManager_PHASE *this)
{
  return 0.0;
}

id re::AudioManager_PHASE::insertPostProcessingEffect(re::AudioManager_PHASE *this, const AudioComponentDescription *a2)
{
  id v3;
  void *v4;
  void *v5;
  AudioComponentDescription v7;

  v3 = objc_alloc(MEMORY[0x24BDB18B8]);
  v7 = *a2;
  v4 = (void *)objc_msgSend(v3, "initWithAudioComponentDescription:", &v7);
  objc_msgSend(v4, "AUAudioUnit");
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  return v5;
}

void sub_225414A10(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id re::AudioService::getEngineQueue(id *this)
{
  return this[1];
}

float re::AudioManager::getSharedVoiceGain(re::AudioManager *this)
{
  return *((float *)this + 69);
}

float re::AudioManager::getSharedReverbSendLevel(re::AudioManager *this)
{
  return *((float *)this + 70);
}

uint64_t re::AudioManager::hasUpdatedSharedAcousticProperties(re::AudioManager *this)
{
  return *((unsigned __int8 *)this + 292);
}

uint64_t re::AudioManager::stsObject(re::AudioManager *this)
{
  return *((_QWORD *)this + 8);
}

uint64_t re::AudioManager_PHASE::setRequiresAudioSessionForPlayback(uint64_t this, unsigned __int8 a2)
{
  atomic_store(a2, (unsigned __int8 *)(this + 656));
  return this;
}

uint64_t re::AudioManager_PHASE::getRequiresAudioSessionForPlayback(re::AudioManager_PHASE *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)this + 656);
  return v1 & 1;
}

void std::__variant_detail::__visitation::__base::__dispatcher<0ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<re::internal::overloaded<re::AudioManager_PHASE::loadAudio(std::shared_ptr<re::AudioAssetPayload>,std::function<void ()(std::shared_ptr<re::PersistedAssetData>)>)::$_0,re::AudioManager_PHASE::loadAudio(std::shared_ptr<re::AudioAssetPayload>,std::function<void ()(std::shared_ptr<re::PersistedAssetData>)>)::$_1,re::AudioManager_PHASE::loadAudio(std::shared_ptr<re::AudioAssetPayload>,std::function<void ()(std::shared_ptr<re::PersistedAssetData>)>)::$_2>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,NSData * {__strong},AVAudioPCMBuffer * {__strong},NSURL * {__strong}> &&>(uint64_t **a1, id *a2)
{
  uint64_t *v2;
  id v3;
  uint64_t v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  id v12;
  NSObject *v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  unint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  unint64_t *v29;
  unint64_t v30;
  unint64_t *v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  void (*v35)(_QWORD *);
  void *v36;
  id v37;
  uint64_t v38;
  uint64_t v39;
  std::__shared_weak_count *v40;
  std::__shared_weak_count *v41;
  std::__shared_weak_count *v42;

  v2 = *a1;
  v3 = *a2;
  v4 = v2[2];
  v6 = *(_QWORD *)*v2;
  v5 = *(std::__shared_weak_count **)(*v2 + 8);
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }
  v9 = v2[1];
  v10 = (std::__shared_weak_count *)operator new(0x38uLL);
  v10->__shared_owners_ = 0;
  v11 = (unint64_t *)&v10->__shared_owners_;
  v10->__shared_weak_owners_ = 0;
  v10->__vftable = (std::__shared_weak_count_vtbl *)&off_24ED3E710;
  std::__function::__value_func<void ()(std::shared_ptr<re::PersistedAssetData>)>::__value_func[abi:ne180100]((uint64_t)&v10[1], v9);
  v12 = *(id *)(v6 + 128);

  v13 = *(NSObject **)(v4 + 536);
  if (v12)
  {
    v33 = MEMORY[0x24BDAC760];
    v34 = 3321888768;
    v35 = ___ZZNK2re18AudioManager_PHASE9loadAudioENSt3__110shared_ptrINS_17AudioAssetPayloadEEENS1_8functionIFvNS2_INS_18PersistedAssetDataEEEEEEENK3__0clEP6NSData_block_invoke;
    v36 = &unk_24ED3E6D0;
    v38 = v4;
    v37 = v3;
    v39 = v6;
    v40 = v5;
    if (v5)
    {
      v14 = (unint64_t *)&v5->__shared_owners_;
      do
        v15 = __ldxr(v14);
      while (__stxr(v15 + 1, v14));
    }
    v41 = v10 + 1;
    v42 = v10;
    do
      v16 = __ldxr(v11);
    while (__stxr(v16 + 1, v11));
    dispatch_async(v13, &v33);
    v17 = v42;
    if (v42)
    {
      v18 = (unint64_t *)&v42->__shared_owners_;
      do
        v19 = __ldaxr(v18);
      while (__stlxr(v19 - 1, v18));
      if (!v19)
      {
        ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
        std::__shared_weak_count::__release_weak(v17);
      }
    }
    v20 = v40;
    if (v40)
    {
      v21 = (unint64_t *)&v40->__shared_owners_;
      do
        v22 = __ldaxr(v21);
      while (__stlxr(v22 - 1, v21));
      goto LABEL_32;
    }
  }
  else
  {
    v33 = MEMORY[0x24BDAC760];
    v34 = 3321888768;
    v35 = ___ZZNK2re18AudioManager_PHASE9loadAudioENSt3__110shared_ptrINS_17AudioAssetPayloadEEENS1_8functionIFvNS2_INS_18PersistedAssetDataEEEEEEENK3__0clEP6NSData_block_invoke_48;
    v36 = &unk_24ED3E6D0;
    v38 = v4;
    v37 = v3;
    v39 = v6;
    v40 = v5;
    if (v5)
    {
      v23 = (unint64_t *)&v5->__shared_owners_;
      do
        v24 = __ldxr(v23);
      while (__stxr(v24 + 1, v23));
    }
    v41 = v10 + 1;
    v42 = v10;
    do
      v25 = __ldxr(v11);
    while (__stxr(v25 + 1, v11));
    dispatch_sync(v13, &v33);
    v26 = v42;
    if (v42)
    {
      v27 = (unint64_t *)&v42->__shared_owners_;
      do
        v28 = __ldaxr(v27);
      while (__stlxr(v28 - 1, v27));
      if (!v28)
      {
        ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
        std::__shared_weak_count::__release_weak(v26);
      }
    }
    v20 = v40;
    if (v40)
    {
      v29 = (unint64_t *)&v40->__shared_owners_;
      do
        v22 = __ldaxr(v29);
      while (__stlxr(v22 - 1, v29));
LABEL_32:
      if (!v22)
      {
        ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
        std::__shared_weak_count::__release_weak(v20);
      }
    }
  }

  do
    v30 = __ldaxr(v11);
  while (__stlxr(v30 - 1, v11));
  if (!v30)
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  if (v5)
  {
    v31 = (unint64_t *)&v5->__shared_owners_;
    do
      v32 = __ldaxr(v31);
    while (__stlxr(v32 - 1, v31));
    if (!v32)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }

}

void sub_225414D48(_Unwind_Exception *a1)
{
  void *v1;
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v5;

  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }

  _Unwind_Resume(a1);
}

void std::__variant_detail::__visitation::__base::__dispatcher<1ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<re::internal::overloaded<re::AudioManager_PHASE::loadAudio(std::shared_ptr<re::AudioAssetPayload>,std::function<void ()(std::shared_ptr<re::PersistedAssetData>)>)::$_0,re::AudioManager_PHASE::loadAudio(std::shared_ptr<re::AudioAssetPayload>,std::function<void ()(std::shared_ptr<re::PersistedAssetData>)>)::$_1,re::AudioManager_PHASE::loadAudio(std::shared_ptr<re::AudioAssetPayload>,std::function<void ()(std::shared_ptr<re::PersistedAssetData>)>)::$_2>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,NSData * {__strong},AVAudioPCMBuffer * {__strong},NSURL * {__strong}> &&>(_QWORD *a1, id *a2)
{
  _QWORD *v2;
  id v3;
  uint64_t v4;
  uint64_t *v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  NSObject *v13;
  id v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t *v25;
  unint64_t v26;
  _QWORD v27[4];
  id v28;
  uint64_t v29;
  uint64_t v30;
  std::__shared_weak_count *v31;
  std::__shared_weak_count *v32;
  std::__shared_weak_count *v33;

  v2 = (_QWORD *)*a1;
  v3 = *a2;
  v4 = v2[5];
  v5 = (uint64_t *)v2[3];
  v7 = *v5;
  v6 = (std::__shared_weak_count *)v5[1];
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  v10 = v2[4];
  v11 = (std::__shared_weak_count *)operator new(0x38uLL);
  v11->__shared_owners_ = 0;
  v12 = (unint64_t *)&v11->__shared_owners_;
  v11->__shared_weak_owners_ = 0;
  v11->__vftable = (std::__shared_weak_count_vtbl *)&off_24ED3E710;
  std::__function::__value_func<void ()(std::shared_ptr<re::PersistedAssetData>)>::__value_func[abi:ne180100]((uint64_t)&v11[1], v10);
  v13 = *(NSObject **)(v4 + 536);
  v27[0] = MEMORY[0x24BDAC760];
  v27[1] = 3321888768;
  v27[2] = ___ZZNK2re18AudioManager_PHASE9loadAudioENSt3__110shared_ptrINS_17AudioAssetPayloadEEENS1_8functionIFvNS2_INS_18PersistedAssetDataEEEEEEENK3__1clEP16AVAudioPCMBuffer_block_invoke;
  v27[3] = &unk_24ED3E6D0;
  v29 = v4;
  v14 = v3;
  v28 = v14;
  v30 = v7;
  v31 = v6;
  if (v6)
  {
    v15 = (unint64_t *)&v6->__shared_owners_;
    do
      v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }
  v32 = v11 + 1;
  v33 = v11;
  do
    v17 = __ldxr(v12);
  while (__stxr(v17 + 1, v12));
  dispatch_async(v13, v27);
  v18 = v33;
  if (v33)
  {
    v19 = (unint64_t *)&v33->__shared_owners_;
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
  v21 = v31;
  if (v31)
  {
    v22 = (unint64_t *)&v31->__shared_owners_;
    do
      v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }

  do
    v24 = __ldaxr(v12);
  while (__stlxr(v24 - 1, v12));
  if (!v24)
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  if (v6)
  {
    v25 = (unint64_t *)&v6->__shared_owners_;
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

}

void sub_225414F88(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;
  void *v2;
  unint64_t *p_shared_owners;
  unint64_t v5;

  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }

  _Unwind_Resume(a1);
}

void std::__variant_detail::__visitation::__base::__dispatcher<2ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<re::internal::overloaded<re::AudioManager_PHASE::loadAudio(std::shared_ptr<re::AudioAssetPayload>,std::function<void ()(std::shared_ptr<re::PersistedAssetData>)>)::$_0,re::AudioManager_PHASE::loadAudio(std::shared_ptr<re::AudioAssetPayload>,std::function<void ()(std::shared_ptr<re::PersistedAssetData>)>)::$_1,re::AudioManager_PHASE::loadAudio(std::shared_ptr<re::AudioAssetPayload>,std::function<void ()(std::shared_ptr<re::PersistedAssetData>)>)::$_2>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,NSData * {__strong},AVAudioPCMBuffer * {__strong},NSURL * {__strong}> &&>(_QWORD *a1, id *a2)
{
  _QWORD *v2;
  id v3;
  uint64_t v4;
  uint64_t *v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  NSObject *v13;
  id v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t *v25;
  unint64_t v26;
  _QWORD v27[4];
  id v28;
  uint64_t v29;
  uint64_t v30;
  std::__shared_weak_count *v31;
  std::__shared_weak_count *v32;
  std::__shared_weak_count *v33;

  v2 = (_QWORD *)*a1;
  v3 = *a2;
  v4 = v2[8];
  v5 = (uint64_t *)v2[6];
  v7 = *v5;
  v6 = (std::__shared_weak_count *)v5[1];
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  v10 = v2[7];
  v11 = (std::__shared_weak_count *)operator new(0x38uLL);
  v11->__shared_owners_ = 0;
  v12 = (unint64_t *)&v11->__shared_owners_;
  v11->__shared_weak_owners_ = 0;
  v11->__vftable = (std::__shared_weak_count_vtbl *)&off_24ED3E710;
  std::__function::__value_func<void ()(std::shared_ptr<re::PersistedAssetData>)>::__value_func[abi:ne180100]((uint64_t)&v11[1], v10);
  v13 = *(NSObject **)(v4 + 536);
  v27[0] = MEMORY[0x24BDAC760];
  v27[1] = 3321888768;
  v27[2] = ___ZZNK2re18AudioManager_PHASE9loadAudioENSt3__110shared_ptrINS_17AudioAssetPayloadEEENS1_8functionIFvNS2_INS_18PersistedAssetDataEEEEEEENK3__2clEP5NSURL_block_invoke;
  v27[3] = &unk_24ED3E6D0;
  v29 = v4;
  v14 = v3;
  v28 = v14;
  v30 = v7;
  v31 = v6;
  if (v6)
  {
    v15 = (unint64_t *)&v6->__shared_owners_;
    do
      v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }
  v32 = v11 + 1;
  v33 = v11;
  do
    v17 = __ldxr(v12);
  while (__stxr(v17 + 1, v12));
  dispatch_async(v13, v27);
  v18 = v33;
  if (v33)
  {
    v19 = (unint64_t *)&v33->__shared_owners_;
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
  v21 = v31;
  if (v31)
  {
    v22 = (unint64_t *)&v31->__shared_owners_;
    do
      v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }

  do
    v24 = __ldaxr(v12);
  while (__stlxr(v24 - 1, v12));
  if (!v24)
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  if (v6)
  {
    v25 = (unint64_t *)&v6->__shared_owners_;
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

}

void sub_2254151C8(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;
  void *v2;
  unint64_t *p_shared_owners;
  unint64_t v5;

  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }

  _Unwind_Resume(a1);
}

void ___ZZNK2re18AudioManager_PHASE9loadAudioENSt3__110shared_ptrINS_17AudioAssetPayloadEEENS1_8functionIFvNS2_INS_18PersistedAssetDataEEEEEEENK3__0clEP6NSData_block_invoke(_QWORD *a1)
{
  void *v2;
  uint64_t v3;
  id v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  std::__shared_weak_count *v16;
  uint64_t v17;
  std::__shared_weak_count *v18;

  v2 = (void *)a1[4];
  v3 = *(_QWORD *)(a1[5] + 520);
  v4 = *(id *)(a1[6] + 128);
  re::AudioManager_PHASE_Async::loadBuffer(v3, v2, v4, a1[6] + 16, *(_DWORD *)(a1[6] + 104), *(_QWORD *)(a1[6] + 112), &v17);

  v5 = a1[8];
  v15 = v17;
  v16 = v18;
  if (v18)
  {
    p_shared_owners = (unint64_t *)&v18->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  v8 = *(_QWORD *)(v5 + 24);
  if (!v8)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v8 + 48))(v8, &v15);
  v9 = v16;
  if (v16)
  {
    v10 = (unint64_t *)&v16->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  v12 = v18;
  if (v18)
  {
    v13 = (unint64_t *)&v18->__shared_owners_;
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
}

void sub_22541532C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

_QWORD *__copy_helper_block_ea8_48c50_ZTSNSt3__110shared_ptrIN2re17AudioAssetPayloadEEE64c76_ZTSNSt3__110shared_ptrINS_8functionIFvNS0_IN2re18PersistedAssetDataEEEEEEEE(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  v2 = a2[7];
  result[6] = a2[6];
  result[7] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v5 = a2[9];
  result[8] = a2[8];
  result[9] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  return result;
}

void __destroy_helper_block_ea8_48c50_ZTSNSt3__110shared_ptrIN2re17AudioAssetPayloadEEE64c76_ZTSNSt3__110shared_ptrINS_8functionIFvNS0_IN2re18PersistedAssetDataEEEEEEEE(uint64_t a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;

  v2 = *(std::__shared_weak_count **)(a1 + 72);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  v5 = *(std::__shared_weak_count **)(a1 + 56);
  if (v5)
  {
    v6 = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 - 1, v6));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
}

void ___ZZNK2re18AudioManager_PHASE9loadAudioENSt3__110shared_ptrINS_17AudioAssetPayloadEEENS1_8functionIFvNS2_INS_18PersistedAssetDataEEEEEEENK3__0clEP6NSData_block_invoke_48(_QWORD *a1)
{
  void *v2;
  uint64_t v3;
  id v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  std::__shared_weak_count *v16;
  uint64_t v17;
  std::__shared_weak_count *v18;

  v2 = (void *)a1[4];
  v3 = *(_QWORD *)(a1[5] + 520);
  v4 = *(id *)(a1[6] + 120);
  re::AudioManager_PHASE_Async::loadFileData(v3, v2, v4, (unsigned __int8 *)(a1[6] + 16), *(_DWORD *)(a1[6] + 104), *(_QWORD *)(a1[6] + 112), &v17);

  v5 = a1[8];
  v15 = v17;
  v16 = v18;
  if (v18)
  {
    p_shared_owners = (unint64_t *)&v18->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  v8 = *(_QWORD *)(v5 + 24);
  if (!v8)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v8 + 48))(v8, &v15);
  v9 = v16;
  if (v16)
  {
    v10 = (unint64_t *)&v16->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  v12 = v18;
  if (v18)
  {
    v13 = (unint64_t *)&v18->__shared_owners_;
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
}

void sub_22541554C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<std::function<void ()(std::shared_ptr<re::PersistedAssetData>)>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24ED3E710;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<std::function<void ()(std::shared_ptr<re::PersistedAssetData>)>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24ED3E710;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2276933B8);
}

_QWORD *std::__shared_ptr_emplace<std::function<void ()(std::shared_ptr<re::PersistedAssetData>)>>::__on_zero_shared(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 24);
  result = *(_QWORD **)(a1 + 48);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

uint64_t std::__function::__value_func<void ()(std::shared_ptr<re::PersistedAssetData>)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;

  v3 = (_QWORD *)(a2 + 24);
  v4 = *(_QWORD *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(_QWORD *)(a1 + 24) = a1;
      (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(_QWORD *)(a1 + 24) = v4;
  }
  else
  {
    v3 = (_QWORD *)(a1 + 24);
  }
  *v3 = 0;
  return a1;
}

void ___ZZNK2re18AudioManager_PHASE9loadAudioENSt3__110shared_ptrINS_17AudioAssetPayloadEEENS1_8functionIFvNS2_INS_18PersistedAssetDataEEEEEEENK3__1clEP16AVAudioPCMBuffer_block_invoke(uint64_t a1)
{
  uint64_t v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  uint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  uint64_t v14;
  std::__shared_weak_count *v15;

  re::AudioManager_PHASE_Async::loadBuffer(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 520), *(void **)(a1 + 32), *(_QWORD *)(a1 + 48) + 16, *(_DWORD *)(*(_QWORD *)(a1 + 48) + 104), *(_QWORD *)(*(_QWORD *)(a1 + 48) + 112), &v14);
  v2 = *(_QWORD *)(a1 + 64);
  v12 = v14;
  v13 = v15;
  if (v15)
  {
    p_shared_owners = (unint64_t *)&v15->__shared_owners_;
    do
      v4 = __ldxr(p_shared_owners);
    while (__stxr(v4 + 1, p_shared_owners));
  }
  v5 = *(_QWORD *)(v2 + 24);
  if (!v5)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v5 + 48))(v5, &v12);
  v6 = v13;
  if (v13)
  {
    v7 = (unint64_t *)&v13->__shared_owners_;
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  v9 = v15;
  if (v15)
  {
    v10 = (unint64_t *)&v15->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
}

void sub_225415748(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<re::AssetManager>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  std::shared_ptr<re::AssetManager>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void ___ZZNK2re18AudioManager_PHASE9loadAudioENSt3__110shared_ptrINS_17AudioAssetPayloadEEENS1_8functionIFvNS2_INS_18PersistedAssetDataEEEEEEENK3__2clEP5NSURL_block_invoke(_QWORD *a1)
{
  void *v2;
  uint64_t v3;
  id v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  std::__shared_weak_count *v16;
  uint64_t v17;
  std::__shared_weak_count *v18;

  v2 = (void *)a1[4];
  v3 = *(_QWORD *)(a1[5] + 520);
  v4 = *(id *)(a1[6] + 120);
  re::AudioManager_PHASE_Async::loadFile(v3, v2, v4, (unsigned __int8 *)(a1[6] + 16), *(_DWORD *)(a1[6] + 104), *(_QWORD *)(a1[6] + 112), &v17);

  v5 = a1[8];
  v15 = v17;
  v16 = v18;
  if (v18)
  {
    p_shared_owners = (unint64_t *)&v18->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  v8 = *(_QWORD *)(v5 + 24);
  if (!v8)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v8 + 48))(v8, &v15);
  v9 = v16;
  if (v16)
  {
    v10 = (unint64_t *)&v16->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  v12 = v18;
  if (v18)
  {
    v13 = (unint64_t *)&v18->__shared_owners_;
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
}

void sub_225415884(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t std::__variant_detail::__dtor<std::__variant_detail::__traits<NSData * {__strong},AVAudioPCMBuffer * {__strong},NSURL * {__strong}>,(std::__variant_detail::_Trait)1>::~__dtor(uint64_t a1)
{
  uint64_t v2;
  char v4;

  v2 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v2 != -1)
    ((void (*)(char *, uint64_t))__const__ZNSt3__116__variant_detail12__visitation6__base11__visit_altB8ne180100IZNS0_6__dtorINS0_8__traitsIJU8__strongP6NSDataU8__strongP16AVAudioPCMBufferU8__strongP5NSURLEEELNS0_6_TraitE1EE9__destroyB8ne180100EvEUlRT_E_JRSH_EEEDcOSI_DpOT0____fmatrix[v2])(&v4, a1);
  *(_DWORD *)(a1 + 8) = -1;
  return a1;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0EEE10__dispatchB8ne180100IOZNS0_6__dtorINS0_8__traitsIJU8__strongP6NSDataU8__strongP16AVAudioPCMBufferU8__strongP5NSURLEEELNS0_6_TraitE1EE9__destroyB8ne180100EvEUlRT_E_JRNS0_6__baseILSI_1EJSA_SD_SG_EEEEEEDcSK_DpT0_(uint64_t a1, id *a2)
{

}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1EEE10__dispatchB8ne180100IOZNS0_6__dtorINS0_8__traitsIJU8__strongP6NSDataU8__strongP16AVAudioPCMBufferU8__strongP5NSURLEEELNS0_6_TraitE1EE9__destroyB8ne180100EvEUlRT_E_JRNS0_6__baseILSI_1EJSA_SD_SG_EEEEEEDcSK_DpT0_(uint64_t a1, id *a2)
{

}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2EEE10__dispatchB8ne180100IOZNS0_6__dtorINS0_8__traitsIJU8__strongP6NSDataU8__strongP16AVAudioPCMBufferU8__strongP5NSURLEEELNS0_6_TraitE1EE9__destroyB8ne180100EvEUlRT_E_JRNS0_6__baseILSI_1EJSA_SD_SG_EEEEEEDcSK_DpT0_(uint64_t a1, id *a2)
{

}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 61)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(8 * a2);
}

re::AudioManager_PHASE_Async *std::unique_ptr<re::AudioManager_PHASE_Async>::reset[abi:ne180100](re::AudioManager_PHASE_Async **a1, re::AudioManager_PHASE_Async *a2)
{
  re::AudioManager_PHASE_Async *result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    re::AudioManager_PHASE_Async::~AudioManager_PHASE_Async(result);
    JUMPOUT(0x2276933B8);
  }
  return result;
}

re::AudioManager_PHASE_StateMachine *std::unique_ptr<re::AudioManager_PHASE_StateMachine>::reset[abi:ne180100](re::AudioManager_PHASE_StateMachine **a1, re::AudioManager_PHASE_StateMachine *a2)
{
  re::AudioManager_PHASE_StateMachine *result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    re::AudioManager_PHASE_StateMachine::~AudioManager_PHASE_StateMachine(result);
    JUMPOUT(0x2276933B8);
  }
  return result;
}

uint64_t std::__hash_table<std::__hash_value_type<std::string,re::AudioManager_PHASE::MixGroupState>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,re::AudioManager_PHASE::MixGroupState>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,re::AudioManager_PHASE::MixGroupState>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,re::AudioManager_PHASE::MixGroupState>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<std::string,re::AudioManager_PHASE::MixGroupState>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,re::AudioManager_PHASE::MixGroupState>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,re::AudioManager_PHASE::MixGroupState>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,re::AudioManager_PHASE::MixGroupState>>>::__deallocate_node(a1, *(_QWORD **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::__hash_value_type<std::string,re::AudioManager_PHASE::MixGroupState>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,re::AudioManager_PHASE::MixGroupState>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,re::AudioManager_PHASE::MixGroupState>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,re::AudioManager_PHASE::MixGroupState>>>::__deallocate_node(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;

  if (a2)
  {
    v2 = a2;
    do
    {
      v3 = (_QWORD *)*v2;
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,re::AudioManager_PHASE::MixGroupState>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<std::string const,re::AudioManager_PHASE::MixGroupState>,0>(uint64_t a1)
{

  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

uint64_t *std::unique_ptr<re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>>,std::function<void ()(re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>>*)>>::~unique_ptr[abi:ne180100](uint64_t *a1)
{
  uint64_t *v2;
  uint64_t v3;

  std::unique_ptr<re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>>,std::function<void ()(re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>>*)>>::reset[abi:ne180100](a1, 0);
  v2 = (uint64_t *)a1[4];
  if (v2 == a1 + 1)
  {
    v3 = 4;
    v2 = a1 + 1;
    goto LABEL_5;
  }
  if (v2)
  {
    v3 = 5;
LABEL_5:
    (*(void (**)(void))(*v2 + 8 * v3))();
  }
  return a1;
}

re::DisplayStateNotificationManager *std::unique_ptr<re::DisplayStateNotificationManager>::reset[abi:ne180100](re::DisplayStateNotificationManager **a1, re::DisplayStateNotificationManager *a2)
{
  re::DisplayStateNotificationManager *result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    re::DisplayStateNotificationManager::~DisplayStateNotificationManager(result);
    JUMPOUT(0x2276933B8);
  }
  return result;
}

_QWORD *std::default_delete<re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>>>::operator()[abi:ne180100](_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (v2)
    {
      v3 = v1[5];
      if (v3)
      {
        if (v1[2])
        {
          v4 = 0;
          do
          {
            std::__variant_detail::__dtor<std::__variant_detail::__traits<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>,(std::__variant_detail::_Trait)1>::~__dtor(v1[5] + 48 * ((unint64_t)(v4 + v1[3]) % v1[1]));
            ++v4;
          }
          while (v4 != v1[2]);
          v2 = *v1;
          v3 = v1[5];
        }
        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, v3);
      }
      v1[5] = 0;
      *(_OWORD *)v1 = 0u;
      *((_OWORD *)v1 + 1) = 0u;
      *((_DWORD *)v1 + 8) = 0;
    }
    JUMPOUT(0x2276933B8);
  }
  return result;
}

uint64_t std::__variant_detail::__dtor<std::__variant_detail::__traits<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>,(std::__variant_detail::_Trait)1>::~__dtor(uint64_t a1)
{
  uint64_t v2;
  char v4;

  v2 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v2 != -1)
    ((void (*)(char *, uint64_t))off_24ED3E768[v2])(&v4, a1);
  *(_DWORD *)(a1 + 40) = -1;
  return a1;
}

uint64_t *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0EEE10__dispatchB8ne180100IOZNS0_6__dtorINS0_8__traitsIJN2re12DynamicArrayINS8_5audio23AcousticMeshRemovalDataEEENS9_INS_7variantIJNSA_16AcousticMeshDataENSA_21AcousticARKitMeshDataEEEEEENS9_INSD_IJNSA_22AcousticMeshUpdateDataENSA_27AcousticARKitMeshUpdateDataEEEEEEEEELNS0_6_TraitE1EE9__destroyB8ne180100EvEUlRT_E_JRNS0_6__baseILSN_1EJSC_SH_SL_EEEEEEDcSP_DpT0_(uint64_t a1, uint64_t *a2)
{
  return re::DynamicArray<re::audio::AcousticMeshRemovalData>::~DynamicArray(a2);
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1EEE10__dispatchB8ne180100IOZNS0_6__dtorINS0_8__traitsIJN2re12DynamicArrayINS8_5audio23AcousticMeshRemovalDataEEENS9_INS_7variantIJNSA_16AcousticMeshDataENSA_21AcousticARKitMeshDataEEEEEENS9_INSD_IJNSA_22AcousticMeshUpdateDataENSA_27AcousticARKitMeshUpdateDataEEEEEEEEELNS0_6_TraitE1EE9__destroyB8ne180100EvEUlRT_E_JRNS0_6__baseILSN_1EJSC_SH_SL_EEEEEEDcSP_DpT0_(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>::deinit(a2);
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2EEE10__dispatchB8ne180100IOZNS0_6__dtorINS0_8__traitsIJN2re12DynamicArrayINS8_5audio23AcousticMeshRemovalDataEEENS9_INS_7variantIJNSA_16AcousticMeshDataENSA_21AcousticARKitMeshDataEEEEEENS9_INSD_IJNSA_22AcousticMeshUpdateDataENSA_27AcousticARKitMeshUpdateDataEEEEEEEEELNS0_6_TraitE1EE9__destroyB8ne180100EvEUlRT_E_JRNS0_6__baseILSN_1EJSC_SH_SL_EEEEEEDcSP_DpT0_(uint64_t a1, uint64_t a2)
{
  return re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>::deinit(a2);
}

uint64_t re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>::deinit(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 160 * v4;
        do
        {
          std::__variant_detail::__dtor<std::__variant_detail::__traits<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>,(std::__variant_detail::_Trait)1>::~__dtor(v3);
          v3 += 160;
          v5 -= 160;
        }
        while (v5);
        result = *(_QWORD *)a1;
        v3 = *(_QWORD *)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>::deinit(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 168 * v4;
        do
        {
          std::__variant_detail::__dtor<std::__variant_detail::__traits<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>,(std::__variant_detail::_Trait)1>::~__dtor(v3);
          v3 += 168;
          v5 -= 168;
        }
        while (v5);
        result = *(_QWORD *)a1;
        v3 = *(_QWORD *)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t std::__variant_detail::__dtor<std::__variant_detail::__traits<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>,(std::__variant_detail::_Trait)1>::~__dtor(uint64_t a1)
{
  uint64_t v2;
  char v4;

  v2 = *(unsigned int *)(a1 + 160);
  if ((_DWORD)v2 != -1)
    ((void (*)(char *, uint64_t))off_24ED3E790[v2])(&v4, a1);
  *(_DWORD *)(a1 + 160) = -1;
  return a1;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0EEE10__dispatchB8ne180100IOZNS0_6__dtorINS0_8__traitsIJN2re5audio22AcousticMeshUpdateDataENS9_27AcousticARKitMeshUpdateDataEEEELNS0_6_TraitE1EE9__destroyB8ne180100EvEUlRT_E_JRNS0_6__baseILSD_1EJSA_SB_EEEEEEDcSF_DpT0_(uint64_t a1, uint64_t a2)
{
  re::DynamicArray<re::AcousticSoundReductionMaterial>::deinit(a2 + 120);
  re::DynamicArray<re::AcousticSoundReductionMaterial>::deinit(a2 + 80);
  re::DynamicArray<re::AcousticSoundReductionMaterial>::deinit(a2 + 40);

}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1EEE10__dispatchB8ne180100IOZNS0_6__dtorINS0_8__traitsIJN2re5audio22AcousticMeshUpdateDataENS9_27AcousticARKitMeshUpdateDataEEEELNS0_6_TraitE1EE9__destroyB8ne180100EvEUlRT_E_JRNS0_6__baseILSD_1EJSA_SB_EEEEEEDcSF_DpT0_(uint64_t a1, uint64_t a2)
{

}

void std::__function::__func<std::default_delete<re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>>>,std::allocator<std::default_delete<re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>>>>,void ()(re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>>*)>::~__func()
{
  JUMPOUT(0x2276933B8);
}

_QWORD *std::__function::__func<std::default_delete<re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>>>,std::allocator<std::default_delete<re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>>>>,void ()(re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>>*)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_24ED3E7B0;
  return result;
}

void std::__function::__func<std::default_delete<re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>>>,std::allocator<std::default_delete<re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>>>>,void ()(re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>>*)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24ED3E7B0;
}

_QWORD *std::__function::__func<std::default_delete<re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>>>,std::allocator<std::default_delete<re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>>>>,void ()(re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>>*)>::operator()(uint64_t a1, _QWORD **a2)
{
  return std::default_delete<re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>>>::operator()[abi:ne180100](*a2);
}

uint64_t std::__function::__func<std::default_delete<re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>>>,std::allocator<std::default_delete<re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>>>>,void ()(re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>>*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<std::default_delete<re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>>>,std::allocator<std::default_delete<re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>>>>,void ()(re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>>*)>::target_type()
{
}

void std::__shared_ptr_emplace<re::AudioEngineRunnableManager>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24ED3E840;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<re::AudioEngineRunnableManager>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24ED3E840;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2276933B8);
}

uint64_t std::__shared_ptr_emplace<re::AudioEngineRunnableManager>::__on_zero_shared(uint64_t a1)
{
  return std::__hash_table<std::__hash_value_type<unsigned long long,unsigned short>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned short>>>::~__hash_table(a1 + 24);
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<re::PersistedAssetData>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<re::PersistedAssetData>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<re::PersistedAssetData>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<re::PersistedAssetData>>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<re::PersistedAssetData>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<re::PersistedAssetData>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<re::PersistedAssetData>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<re::PersistedAssetData>>>>::__deallocate_node(a1, *(_QWORD **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<re::PersistedAssetData>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<re::PersistedAssetData>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<re::PersistedAssetData>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<re::PersistedAssetData>>>>::__deallocate_node(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;

  if (a2)
  {
    v2 = a2;
    do
    {
      v3 = (_QWORD *)*v2;
      std::shared_ptr<re::AssetManager>::~shared_ptr[abi:nn180100]((uint64_t)(v2 + 3));
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

_QWORD *re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  char v14;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    v6 = result + 2;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>>::setCapacity(v5, a2);
        *v6 = 0;
        v6[1] = 0;
        *((_DWORD *)v6 + 4) = 0;
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x30uLL))
        {
          v2 = 48 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 48 * a2, 8);
          if (result)
          {
            v8 = result;
            if (!v5[1])
              goto LABEL_20;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in Queue<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 440, 48, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v7, "assertion failure: '%s' (%s:line %i) Queue<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 444, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v8 = 0;
      if (!v3)
      {
LABEL_20:
        v5[5] = v8;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      if (v5[2])
      {
        v9 = 0;
        v10 = v5[3];
        do
        {
          v11 = v5[5] + 48 * ((unint64_t)(v9 + v5[3]) % v5[1]);
          v12 = &v8[6 * v10];
          *(_BYTE *)v12 = 0;
          *((_DWORD *)v12 + 10) = -1;
          v13 = *(unsigned int *)(v11 + 40);
          if ((_DWORD)v13 != -1)
          {
            ((void (*)(char *, _QWORD *, uint64_t))off_24ED3E880[v13])(&v14, &v8[6 * v10], v11);
            *((_DWORD *)v12 + 10) = v13;
          }
          std::__variant_detail::__dtor<std::__variant_detail::__traits<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>,(std::__variant_detail::_Trait)1>::~__dtor(v11);
          if (v10 + 1 < a2)
            ++v10;
          else
            v10 = 0;
          ++v9;
        }
        while (v9 != *v6);
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v5 + 40))(*v5, v5[5]);
      goto LABEL_20;
    }
  }
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN2re12DynamicArrayINS8_5audio23AcousticMeshRemovalDataEEENS9_INS_7variantIJNSA_16AcousticMeshDataENSA_21AcousticARKitMeshDataEEEEEENS9_INSD_IJNSA_22AcousticMeshUpdateDataENSA_27AcousticARKitMeshUpdateDataEEEEEEEEEE19__generic_constructB8ne180100INS0_18__move_constructorISM_LNS0_6_TraitE1EEEEEvRSN_OT_EUlRST_OT0_E_JRNS0_6__baseILSQ_1EJSC_SH_SL_EEEOS11_EEEDcST_DpT0_(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
  v3 = *(_QWORD *)(a3 + 8);
  *(_QWORD *)a2 = *(_QWORD *)a3;
  *(_QWORD *)(a2 + 8) = v3;
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  v4 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = *(_QWORD *)(a3 + 16);
  *(_QWORD *)(a3 + 16) = v4;
  v5 = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 32) = *(_QWORD *)(a3 + 32);
  *(_QWORD *)(a3 + 32) = v5;
  ++*(_DWORD *)(a3 + 24);
  ++*(_DWORD *)(a2 + 24);
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN2re12DynamicArrayINS8_5audio23AcousticMeshRemovalDataEEENS9_INS_7variantIJNSA_16AcousticMeshDataENSA_21AcousticARKitMeshDataEEEEEENS9_INSD_IJNSA_22AcousticMeshUpdateDataENSA_27AcousticARKitMeshUpdateDataEEEEEEEEEE19__generic_constructB8ne180100INS0_18__move_constructorISM_LNS0_6_TraitE1EEEEEvRSN_OT_EUlRST_OT0_E_JRNS0_6__baseILSQ_1EJSC_SH_SL_EEEOS11_EEEDcST_DpT0_(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
  v3 = *(_QWORD *)(a3 + 8);
  *(_QWORD *)a2 = *(_QWORD *)a3;
  *(_QWORD *)(a2 + 8) = v3;
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  v4 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = *(_QWORD *)(a3 + 16);
  *(_QWORD *)(a3 + 16) = v4;
  v5 = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 32) = *(_QWORD *)(a3 + 32);
  *(_QWORD *)(a3 + 32) = v5;
  ++*(_DWORD *)(a3 + 24);
  ++*(_DWORD *)(a2 + 24);
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN2re12DynamicArrayINS8_5audio23AcousticMeshRemovalDataEEENS9_INS_7variantIJNSA_16AcousticMeshDataENSA_21AcousticARKitMeshDataEEEEEENS9_INSD_IJNSA_22AcousticMeshUpdateDataENSA_27AcousticARKitMeshUpdateDataEEEEEEEEEE19__generic_constructB8ne180100INS0_18__move_constructorISM_LNS0_6_TraitE1EEEEEvRSN_OT_EUlRST_OT0_E_JRNS0_6__baseILSQ_1EJSC_SH_SL_EEEOS11_EEEDcST_DpT0_(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
  v3 = *(_QWORD *)(a3 + 8);
  *(_QWORD *)a2 = *(_QWORD *)a3;
  *(_QWORD *)(a2 + 8) = v3;
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  v4 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = *(_QWORD *)(a3 + 16);
  *(_QWORD *)(a3 + 16) = v4;
  v5 = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 32) = *(_QWORD *)(a3 + 32);
  *(_QWORD *)(a3 + 32) = v5;
  ++*(_DWORD *)(a3 + 24);
  ++*(_DWORD *)(a2 + 24);
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN2re12DynamicArrayINS8_5audio23AcousticMeshRemovalDataEEENS9_INS_7variantIJNSA_16AcousticMeshDataENSA_21AcousticARKitMeshDataEEEEEENS9_INSD_IJNSA_22AcousticMeshUpdateDataENSA_27AcousticARKitMeshUpdateDataEEEEEEEEEE19__generic_constructB8ne180100IRKNS0_18__copy_constructorISM_LNS0_6_TraitE1EEEEEvRSN_OT_EUlRSV_OT0_E_JRNS0_6__baseILSQ_1EJSC_SH_SL_EEERKS13_EEEDcSV_DpT0_(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  return re::DynamicArray<re::audio::AcousticMeshRemovalData>::DynamicArray(a2, a3);
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN2re12DynamicArrayINS8_5audio23AcousticMeshRemovalDataEEENS9_INS_7variantIJNSA_16AcousticMeshDataENSA_21AcousticARKitMeshDataEEEEEENS9_INSD_IJNSA_22AcousticMeshUpdateDataENSA_27AcousticARKitMeshUpdateDataEEEEEEEEEE19__generic_constructB8ne180100IRKNS0_18__copy_constructorISM_LNS0_6_TraitE1EEEEEvRSN_OT_EUlRSV_OT0_E_JRNS0_6__baseILSQ_1EJSC_SH_SL_EEERKS13_EEEDcSV_DpT0_(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  return re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>::DynamicArray(a2, a3);
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN2re12DynamicArrayINS8_5audio23AcousticMeshRemovalDataEEENS9_INS_7variantIJNSA_16AcousticMeshDataENSA_21AcousticARKitMeshDataEEEEEENS9_INSD_IJNSA_22AcousticMeshUpdateDataENSA_27AcousticARKitMeshUpdateDataEEEEEEEEEE19__generic_constructB8ne180100IRKNS0_18__copy_constructorISM_LNS0_6_TraitE1EEEEEvRSN_OT_EUlRSV_OT0_E_JRNS0_6__baseILSQ_1EJSC_SH_SL_EEERKS13_EEEDcSV_DpT0_(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  return re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>::DynamicArray(a2, a3);
}

uint64_t re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  unint64_t v5;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  v3 = *a2;
  if (*a2)
  {
    v5 = a2[2];
    *(_QWORD *)a1 = v3;
    re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>::setCapacity((_QWORD *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>::copy((_QWORD *)a1, (uint64_t)a2);
  }
  return a1;
}

uint64_t re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>::copy(_QWORD *a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char v14;

  v4 = *(_QWORD *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>::setCapacity(a1, *(_QWORD *)(a2 + 16));
    result = std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData> *,std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData> *,std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData> *,0>(*(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 32) + 160 * a1[2], a1[4]);
    v8 = a1[2];
    if (v8 != v4)
    {
      v9 = 5 * v8;
      v10 = *(_QWORD *)(a2 + 32) + 32 * v9;
      v11 = a1[4] + 32 * v9;
      v12 = 160 * v4 - 32 * v9;
      do
      {
        *(_BYTE *)v11 = 0;
        *(_DWORD *)(v11 + 152) = -1;
        v13 = *(unsigned int *)(v10 + 152);
        if ((_DWORD)v13 != -1)
        {
          result = ((uint64_t (*)(char *, uint64_t, uint64_t))off_24ED3E8D0[v13])(&v14, v11, v10);
          *(_DWORD *)(v11 + 152) = v13;
        }
        v10 += 160;
        v11 += 160;
        v12 -= 160;
      }
      while (v12);
    }
  }
  else
  {
    result = std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData> *,std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData> *,std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData> *,0>(*(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 32) + 160 * v4, a1[4]);
    v6 = a1[2];
    if (v4 != v6)
    {
      result = a1[4] + 160 * v4;
      v7 = 160 * v6 - 160 * v4;
      do
      {
        result = std::__variant_detail::__dtor<std::__variant_detail::__traits<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>,(std::__variant_detail::_Trait)1>::~__dtor(result)
               + 160;
        v7 -= 160;
      }
      while (v7);
    }
  }
  a1[2] = v4;
  return result;
}

void sub_225416464(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__variant_detail::__dtor<std::__variant_detail::__traits<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>,(std::__variant_detail::_Trait)1>::~__dtor(v1);
  _Unwind_Resume(a1);
}

_QWORD *re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  char v13;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0xA0uLL))
        {
          v2 = 160 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 160 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_18;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 160, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_18:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = 160 * v9;
        v11 = v7;
        do
        {
          *(_BYTE *)v11 = 0;
          *((_DWORD *)v11 + 38) = -1;
          v12 = *(unsigned int *)(v8 + 152);
          if ((_DWORD)v12 != -1)
          {
            ((void (*)(char *, _QWORD *, uint64_t))off_24ED3E8B0[v12])(&v13, v11, v8);
            *((_DWORD *)v11 + 38) = v12;
          }
          std::__variant_detail::__dtor<std::__variant_detail::__traits<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>,(std::__variant_detail::_Trait)1>::~__dtor(v8);
          v8 += 160;
          v11 += 20;
          v10 -= 160;
        }
        while (v10);
        v8 = v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_18;
    }
  }
  return result;
}

double _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN2re5audio16AcousticMeshDataENS9_21AcousticARKitMeshDataEEEEE19__generic_constructB8ne180100INS0_18__move_constructorISC_LNS0_6_TraitE1EEEEEvRSD_OT_EUlRSJ_OT0_E_JRNS0_6__baseILSG_1EJSA_SB_EEEOSR_EEEDcSJ_DpT0_(uint64_t a1, __n128 *a2, __n128 *a3)
{
  double result;

  *(_QWORD *)&result = std::__variant_detail::__alt<0ul,re::audio::AcousticMeshData>::__alt[abi:ne180100]<re::audio::AcousticMeshData>(a2, a3).n128_u64[0];
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN2re5audio16AcousticMeshDataENS9_21AcousticARKitMeshDataEEEEE19__generic_constructB8ne180100INS0_18__move_constructorISC_LNS0_6_TraitE1EEEEEvRSD_OT_EUlRSJ_OT0_E_JRNS0_6__baseILSG_1EJSA_SB_EEEOSR_EEEDcSJ_DpT0_(uint64_t a1, uint64_t a2, __int128 *a3)
{
  __int128 v3;
  uint64_t v4;
  __n128 result;

  v3 = *a3;
  *(_QWORD *)(a2 + 16) = *((_QWORD *)a3 + 2);
  *(_OWORD *)a2 = v3;
  v4 = *((_QWORD *)a3 + 3);
  *((_QWORD *)a3 + 3) = 0;
  *(_QWORD *)(a2 + 24) = v4;
  result = (__n128)a3[2];
  *(__n128 *)(a2 + 32) = result;
  return result;
}

uint64_t std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData> *,std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData> *,std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData> *,0>(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t i;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char v9;

  if (result != a2)
  {
    for (i = result; i != a2; i += 160)
    {
      v6 = *(unsigned int *)(a3 + 152);
      v7 = *(unsigned int *)(i + 152);
      if ((_DWORD)v6 == -1)
      {
        if ((_DWORD)v7 != -1)
        {
LABEL_7:
          v8 = a3;
          result = ((uint64_t (*)(uint64_t *, uint64_t, uint64_t))off_24ED3E8C0[v7])(&v8, a3, i);
        }
      }
      else
      {
        if ((_DWORD)v7 != -1)
          goto LABEL_7;
        result = ((uint64_t (*)(char *, uint64_t))off_24ED3E780[v6])(&v9, a3);
        *(_DWORD *)(a3 + 152) = -1;
      }
      a3 += 160;
    }
  }
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJN2re5audio16AcousticMeshDataENS9_21AcousticARKitMeshDataEEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentISC_LNS0_6_TraitE1EEEEEvOT_EUlRSK_OT0_E_JRNS0_6__baseILSG_1EJSA_SB_EEERKSS_EEEDcSK_DpT0_(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  __int128 v7;
  uint64_t result;
  char v9;

  v4 = *a1;
  v5 = *(unsigned int *)(*a1 + 152);
  if ((_DWORD)v5 != -1)
  {
    if (!(_DWORD)v5)
    {
      v7 = *(_OWORD *)a3;
      *(_QWORD *)(a2 + 16) = *(_QWORD *)(a3 + 16);
      *(_OWORD *)a2 = v7;
      objc_storeStrong((id *)(a2 + 24), *(id *)(a3 + 24));
      re::DynamicArray<re::AcousticAbsorptionMaterial>::operator=(a2 + 32, (uint64_t *)(a3 + 32));
      re::DynamicArray<re::AcousticScatteringMaterial>::operator=(a2 + 72, (uint64_t *)(a3 + 72));
      return re::DynamicArray<re::AcousticSoundReductionMaterial>::operator=(a2 + 112, (uint64_t *)(a3 + 112));
    }
    ((void (*)(char *, uint64_t))off_24ED3E780[v5])(&v9, v4);
  }
  *(_DWORD *)(v4 + 152) = -1;
  result = std::__variant_detail::__alt<0ul,re::audio::AcousticMeshData>::__alt[abi:ne180100]<re::audio::AcousticMeshData const&>(v4, (__int128 *)a3);
  *(_DWORD *)(v4 + 152) = 0;
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJN2re5audio16AcousticMeshDataENS9_21AcousticARKitMeshDataEEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentISC_LNS0_6_TraitE1EEEEEvOT_EUlRSK_OT0_E_JRNS0_6__baseILSG_1EJSA_SB_EEERKSS_EEEDcSK_DpT0_(uint64_t *a1, uint64_t a2, __int128 *a3)
{
  uint64_t v4;
  uint64_t v5;
  __int128 v7;
  __n128 result;
  __int128 v9;
  char v10;

  v4 = *a1;
  v5 = *(unsigned int *)(*a1 + 152);
  if ((_DWORD)v5 != -1)
  {
    if ((_DWORD)v5 == 1)
    {
      v7 = *a3;
      *(_QWORD *)(a2 + 16) = *((_QWORD *)a3 + 2);
      *(_OWORD *)a2 = v7;
      objc_storeStrong((id *)(a2 + 24), *((id *)a3 + 3));
      result = (__n128)a3[2];
      *(__n128 *)(a2 + 32) = result;
      return result;
    }
    ((void (*)(char *, uint64_t))off_24ED3E780[v5])(&v10, v4);
  }
  *(_DWORD *)(v4 + 152) = -1;
  v9 = *a3;
  *(_QWORD *)(v4 + 16) = *((_QWORD *)a3 + 2);
  *(_OWORD *)v4 = v9;
  *(_QWORD *)(v4 + 24) = *((id *)a3 + 3);
  result = (__n128)a3[2];
  *(__n128 *)(v4 + 32) = result;
  *(_DWORD *)(v4 + 152) = 1;
  return result;
}

uint64_t re::DynamicArray<re::AcousticAbsorptionMaterial>::operator=(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  unint64_t v5;

  if ((uint64_t *)a1 != a2)
  {
    v4 = *a2;
    if (*(_QWORD *)a1)
    {
      if (v4)
      {
        re::DynamicArray<re::AcousticAbsorptionMaterial>::copy(a1, (uint64_t)a2);
        ++*(_DWORD *)(a1 + 24);
      }
      else
      {
        re::DynamicArray<re::AcousticAbsorptionMaterial>::clear((_QWORD *)a1);
      }
    }
    else if (v4)
    {
      v5 = a2[2];
      *(_QWORD *)a1 = v4;
      re::DynamicArray<re::AcousticAbsorptionMaterial>::setCapacity((_QWORD *)a1, v5);
      ++*(_DWORD *)(a1 + 24);
      re::DynamicArray<re::AcousticAbsorptionMaterial>::copy(a1, (uint64_t)a2);
    }
  }
  return a1;
}

uint64_t re::DynamicArray<re::AcousticScatteringMaterial>::operator=(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  unint64_t v5;

  if ((uint64_t *)a1 != a2)
  {
    v4 = *a2;
    if (*(_QWORD *)a1)
    {
      if (v4)
      {
        re::DynamicArray<re::AcousticAbsorptionMaterial>::copy(a1, (uint64_t)a2);
        ++*(_DWORD *)(a1 + 24);
      }
      else
      {
        re::DynamicArray<re::AcousticAbsorptionMaterial>::clear((_QWORD *)a1);
      }
    }
    else if (v4)
    {
      v5 = a2[2];
      *(_QWORD *)a1 = v4;
      re::DynamicArray<re::AcousticAbsorptionMaterial>::setCapacity((_QWORD *)a1, v5);
      ++*(_DWORD *)(a1 + 24);
      re::DynamicArray<re::AcousticAbsorptionMaterial>::copy(a1, (uint64_t)a2);
    }
  }
  return a1;
}

uint64_t re::DynamicArray<re::AcousticSoundReductionMaterial>::operator=(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  unint64_t v5;

  if ((uint64_t *)a1 != a2)
  {
    v4 = *a2;
    if (*(_QWORD *)a1)
    {
      if (v4)
      {
        re::DynamicArray<re::AcousticAbsorptionMaterial>::copy(a1, (uint64_t)a2);
        ++*(_DWORD *)(a1 + 24);
      }
      else
      {
        re::DynamicArray<re::AcousticAbsorptionMaterial>::clear((_QWORD *)a1);
      }
    }
    else if (v4)
    {
      v5 = a2[2];
      *(_QWORD *)a1 = v4;
      re::DynamicArray<re::AcousticAbsorptionMaterial>::setCapacity((_QWORD *)a1, v5);
      ++*(_DWORD *)(a1 + 24);
      re::DynamicArray<re::AcousticAbsorptionMaterial>::copy(a1, (uint64_t)a2);
    }
  }
  return a1;
}

_QWORD *re::DynamicArray<re::AcousticAbsorptionMaterial>::clear(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;

  v1 = result;
  v2 = result[2];
  result[2] = 0;
  if (v2)
  {
    v3 = (uint64_t *)(result[4] + 72);
    v4 = 112 * v2;
    do
    {
      re::DynamicArray<float>::~DynamicArray(v3);
      re::DynamicArray<float>::~DynamicArray(v3 - 5);
      result = (_QWORD *)*(v3 - 9);
      if (result)
      {
        if ((*(_BYTE *)(v3 - 8) & 1) != 0)
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, _QWORD))(*result + 40))(result, *(v3 - 7));
        *(_OWORD *)(v3 - 9) = 0u;
        *(_OWORD *)(v3 - 7) = 0u;
      }
      v3 += 14;
      v4 -= 112;
    }
    while (v4);
  }
  ++*((_DWORD *)v1 + 6);
  return result;
}

uint64_t std::__variant_detail::__alt<0ul,re::audio::AcousticMeshData>::__alt[abi:ne180100]<re::audio::AcousticMeshData const&>(uint64_t a1, __int128 *a2)
{
  __int128 v4;

  v4 = *a2;
  *(_QWORD *)(a1 + 16) = *((_QWORD *)a2 + 2);
  *(_OWORD *)a1 = v4;
  *(_QWORD *)(a1 + 24) = *((id *)a2 + 3);
  re::DynamicArray<re::AcousticAbsorptionMaterial>::DynamicArray(a1 + 32, (uint64_t *)a2 + 4);
  re::DynamicArray<re::AcousticScatteringMaterial>::DynamicArray(a1 + 72, (uint64_t *)a2 + 9);
  re::DynamicArray<re::AcousticSoundReductionMaterial>::DynamicArray(a1 + 112, (uint64_t *)a2 + 14);
  return a1;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN2re5audio16AcousticMeshDataENS9_21AcousticARKitMeshDataEEEEE19__generic_constructB8ne180100IRKNS0_18__copy_constructorISC_LNS0_6_TraitE1EEEEEvRSD_OT_EUlRSL_OT0_E_JRNS0_6__baseILSG_1EJSA_SB_EEERKST_EEEDcSL_DpT0_(uint64_t a1, uint64_t a2, __int128 *a3)
{
  return std::__variant_detail::__alt<0ul,re::audio::AcousticMeshData>::__alt[abi:ne180100]<re::audio::AcousticMeshData const&>(a2, a3);
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN2re5audio16AcousticMeshDataENS9_21AcousticARKitMeshDataEEEEE19__generic_constructB8ne180100IRKNS0_18__copy_constructorISC_LNS0_6_TraitE1EEEEEvRSD_OT_EUlRSL_OT0_E_JRNS0_6__baseILSG_1EJSA_SB_EEERKST_EEEDcSL_DpT0_(uint64_t a1, uint64_t a2, __int128 *a3)
{
  __int128 v5;
  __n128 result;

  v5 = *a3;
  *(_QWORD *)(a2 + 16) = *((_QWORD *)a3 + 2);
  *(_OWORD *)a2 = v5;
  *(_QWORD *)(a2 + 24) = *((id *)a3 + 3);
  result = (__n128)a3[2];
  *(__n128 *)(a2 + 32) = result;
  return result;
}

uint64_t re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  unint64_t v5;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  v3 = *a2;
  if (*a2)
  {
    v5 = a2[2];
    *(_QWORD *)a1 = v3;
    re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>::setCapacity((_QWORD *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>::copy((_QWORD *)a1, (uint64_t)a2);
  }
  return a1;
}

uint64_t re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>::copy(_QWORD *a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char v14;

  v4 = *(_QWORD *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>::setCapacity(a1, *(_QWORD *)(a2 + 16));
    result = std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData> *,std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData> *,std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData> *,0>(*(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 32) + 168 * a1[2], a1[4]);
    v8 = a1[2];
    if (v8 != v4)
    {
      v9 = 168 * v8;
      v10 = *(_QWORD *)(a2 + 32) + v9;
      v11 = a1[4] + v9;
      v12 = 168 * v4 - v9;
      do
      {
        *(_BYTE *)v11 = 0;
        *(_DWORD *)(v11 + 160) = -1;
        v13 = *(unsigned int *)(v10 + 160);
        if ((_DWORD)v13 != -1)
        {
          result = ((uint64_t (*)(char *, uint64_t, uint64_t))off_24ED3E900[v13])(&v14, v11, v10);
          *(_DWORD *)(v11 + 160) = v13;
        }
        v10 += 168;
        v11 += 168;
        v12 -= 168;
      }
      while (v12);
    }
  }
  else
  {
    result = std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData> *,std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData> *,std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData> *,0>(*(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 32) + 168 * v4, a1[4]);
    v6 = a1[2];
    if (v4 != v6)
    {
      result = a1[4] + 168 * v4;
      v7 = 168 * v6 - 168 * v4;
      do
      {
        result = std::__variant_detail::__dtor<std::__variant_detail::__traits<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>,(std::__variant_detail::_Trait)1>::~__dtor(result)
               + 168;
        v7 -= 168;
      }
      while (v7);
    }
  }
  a1[2] = v4;
  return result;
}

void sub_225416D88(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__variant_detail::__dtor<std::__variant_detail::__traits<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>,(std::__variant_detail::_Trait)1>::~__dtor(v1);
  _Unwind_Resume(a1);
}

_QWORD *re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  char v13;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0xA8uLL))
        {
          v2 = 168 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 168 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_18;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 168, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_18:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = 168 * v9;
        v11 = v7;
        do
        {
          *(_BYTE *)v11 = 0;
          *((_DWORD *)v11 + 40) = -1;
          v12 = *(unsigned int *)(v8 + 160);
          if ((_DWORD)v12 != -1)
          {
            ((void (*)(char *, _QWORD *, uint64_t))off_24ED3E8E0[v12])(&v13, v11, v8);
            *((_DWORD *)v11 + 40) = v12;
          }
          std::__variant_detail::__dtor<std::__variant_detail::__traits<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>,(std::__variant_detail::_Trait)1>::~__dtor(v8);
          v8 += 168;
          v11 += 21;
          v10 -= 168;
        }
        while (v10);
        v8 = v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_18;
    }
  }
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN2re5audio22AcousticMeshUpdateDataENS9_27AcousticARKitMeshUpdateDataEEEEE19__generic_constructB8ne180100INS0_18__move_constructorISC_LNS0_6_TraitE1EEEEEvRSD_OT_EUlRSJ_OT0_E_JRNS0_6__baseILSG_1EJSA_SB_EEEOSR_EEEDcSJ_DpT0_(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result;
  __int128 v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  result = *(__n128 *)a3;
  v4 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)a2 = *(_OWORD *)a3;
  *(_OWORD *)(a2 + 16) = v4;
  v5 = *(_QWORD *)(a3 + 32);
  *(_QWORD *)(a3 + 32) = 0;
  *(_QWORD *)(a2 + 72) = 0;
  *(_QWORD *)(a2 + 32) = v5;
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  *(_DWORD *)(a2 + 64) = 0;
  v6 = *(_QWORD *)(a3 + 48);
  *(_QWORD *)(a2 + 40) = *(_QWORD *)(a3 + 40);
  *(_QWORD *)(a2 + 48) = v6;
  *(_QWORD *)(a3 + 40) = 0;
  *(_QWORD *)(a3 + 48) = 0;
  v7 = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 56) = *(_QWORD *)(a3 + 56);
  *(_QWORD *)(a3 + 56) = v7;
  v8 = *(_QWORD *)(a2 + 72);
  *(_QWORD *)(a2 + 72) = *(_QWORD *)(a3 + 72);
  *(_QWORD *)(a3 + 72) = v8;
  ++*(_DWORD *)(a3 + 64);
  ++*(_DWORD *)(a2 + 64);
  *(_QWORD *)(a2 + 112) = 0;
  *(_QWORD *)(a2 + 88) = 0;
  *(_QWORD *)(a2 + 96) = 0;
  *(_QWORD *)(a2 + 80) = 0;
  *(_DWORD *)(a2 + 104) = 0;
  v9 = *(_QWORD *)(a3 + 88);
  *(_QWORD *)(a2 + 80) = *(_QWORD *)(a3 + 80);
  *(_QWORD *)(a2 + 88) = v9;
  *(_QWORD *)(a3 + 80) = 0;
  *(_QWORD *)(a3 + 88) = 0;
  v10 = *(_QWORD *)(a2 + 96);
  *(_QWORD *)(a2 + 96) = *(_QWORD *)(a3 + 96);
  *(_QWORD *)(a3 + 96) = v10;
  v11 = *(_QWORD *)(a2 + 112);
  *(_QWORD *)(a2 + 112) = *(_QWORD *)(a3 + 112);
  *(_QWORD *)(a3 + 112) = v11;
  ++*(_DWORD *)(a3 + 104);
  ++*(_DWORD *)(a2 + 104);
  *(_QWORD *)(a2 + 152) = 0;
  *(_QWORD *)(a2 + 128) = 0;
  *(_QWORD *)(a2 + 136) = 0;
  *(_QWORD *)(a2 + 120) = 0;
  *(_DWORD *)(a2 + 144) = 0;
  v12 = *(_QWORD *)(a3 + 128);
  *(_QWORD *)(a2 + 120) = *(_QWORD *)(a3 + 120);
  *(_QWORD *)(a2 + 128) = v12;
  *(_QWORD *)(a3 + 120) = 0;
  *(_QWORD *)(a3 + 128) = 0;
  v13 = *(_QWORD *)(a2 + 136);
  *(_QWORD *)(a2 + 136) = *(_QWORD *)(a3 + 136);
  *(_QWORD *)(a3 + 136) = v13;
  v14 = *(_QWORD *)(a2 + 152);
  *(_QWORD *)(a2 + 152) = *(_QWORD *)(a3 + 152);
  *(_QWORD *)(a3 + 152) = v14;
  ++*(_DWORD *)(a3 + 144);
  ++*(_DWORD *)(a2 + 144);
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN2re5audio22AcousticMeshUpdateDataENS9_27AcousticARKitMeshUpdateDataEEEEE19__generic_constructB8ne180100INS0_18__move_constructorISC_LNS0_6_TraitE1EEEEEvRSD_OT_EUlRSJ_OT0_E_JRNS0_6__baseILSG_1EJSA_SB_EEEOSR_EEEDcSJ_DpT0_(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __int128 v3;
  uint64_t v4;
  __n128 result;

  v3 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)a2 = *(_OWORD *)a3;
  *(_OWORD *)(a2 + 16) = v3;
  v4 = *(_QWORD *)(a3 + 32);
  *(_QWORD *)(a3 + 32) = 0;
  *(_QWORD *)(a2 + 32) = v4;
  result = *(__n128 *)(a3 + 40);
  *(__n128 *)(a2 + 40) = result;
  return result;
}

uint64_t std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData> *,std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData> *,std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData> *,0>(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t i;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char v9;

  if (result != a2)
  {
    for (i = result; i != a2; i += 168)
    {
      v6 = *(unsigned int *)(a3 + 160);
      v7 = *(unsigned int *)(i + 160);
      if ((_DWORD)v6 == -1)
      {
        if ((_DWORD)v7 != -1)
        {
LABEL_7:
          v8 = a3;
          result = ((uint64_t (*)(uint64_t *, uint64_t, uint64_t))off_24ED3E8F0[v7])(&v8, a3, i);
        }
      }
      else
      {
        if ((_DWORD)v7 != -1)
          goto LABEL_7;
        result = ((uint64_t (*)(char *, uint64_t))off_24ED3E790[v6])(&v9, a3);
        *(_DWORD *)(a3 + 160) = -1;
      }
      a3 += 168;
    }
  }
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJN2re5audio22AcousticMeshUpdateDataENS9_27AcousticARKitMeshUpdateDataEEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentISC_LNS0_6_TraitE1EEEEEvOT_EUlRSK_OT0_E_JRNS0_6__baseILSG_1EJSA_SB_EEERKSS_EEEDcSK_DpT0_(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  __int128 v7;
  uint64_t result;
  char v9;

  v4 = *a1;
  v5 = *(unsigned int *)(*a1 + 160);
  if ((_DWORD)v5 != -1)
  {
    if (!(_DWORD)v5)
    {
      v7 = *(_OWORD *)(a3 + 16);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)(a2 + 16) = v7;
      objc_storeStrong((id *)(a2 + 32), *(id *)(a3 + 32));
      re::DynamicArray<re::AcousticAbsorptionMaterial>::operator=(a2 + 40, (uint64_t *)(a3 + 40));
      re::DynamicArray<re::AcousticScatteringMaterial>::operator=(a2 + 80, (uint64_t *)(a3 + 80));
      return re::DynamicArray<re::AcousticSoundReductionMaterial>::operator=(a2 + 120, (uint64_t *)(a3 + 120));
    }
    ((void (*)(char *, uint64_t))off_24ED3E790[v5])(&v9, v4);
  }
  *(_DWORD *)(v4 + 160) = -1;
  result = std::__variant_detail::__alt<0ul,re::audio::AcousticMeshUpdateData>::__alt[abi:ne180100]<re::audio::AcousticMeshUpdateData const&>(v4, a3);
  *(_DWORD *)(v4 + 160) = 0;
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJN2re5audio22AcousticMeshUpdateDataENS9_27AcousticARKitMeshUpdateDataEEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentISC_LNS0_6_TraitE1EEEEEvOT_EUlRSK_OT0_E_JRNS0_6__baseILSG_1EJSA_SB_EEERKSS_EEEDcSK_DpT0_(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  __int128 v7;
  __n128 result;
  __int128 v9;
  char v10;

  v4 = *a1;
  v5 = *(unsigned int *)(*a1 + 160);
  if ((_DWORD)v5 != -1)
  {
    if ((_DWORD)v5 == 1)
    {
      v7 = *(_OWORD *)(a3 + 16);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)(a2 + 16) = v7;
      objc_storeStrong((id *)(a2 + 32), *(id *)(a3 + 32));
      result = *(__n128 *)(a3 + 40);
      *(__n128 *)(a2 + 40) = result;
      return result;
    }
    ((void (*)(char *, uint64_t))off_24ED3E790[v5])(&v10, v4);
  }
  *(_DWORD *)(v4 + 160) = -1;
  v9 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)v4 = *(_OWORD *)a3;
  *(_OWORD *)(v4 + 16) = v9;
  *(_QWORD *)(v4 + 32) = *(id *)(a3 + 32);
  result = *(__n128 *)(a3 + 40);
  *(__n128 *)(v4 + 40) = result;
  *(_DWORD *)(v4 + 160) = 1;
  return result;
}

uint64_t std::__variant_detail::__alt<0ul,re::audio::AcousticMeshUpdateData>::__alt[abi:ne180100]<re::audio::AcousticMeshUpdateData const&>(uint64_t a1, uint64_t a2)
{
  __int128 v4;

  v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v4;
  *(_QWORD *)(a1 + 32) = *(id *)(a2 + 32);
  re::DynamicArray<re::AcousticAbsorptionMaterial>::DynamicArray(a1 + 40, (uint64_t *)(a2 + 40));
  re::DynamicArray<re::AcousticScatteringMaterial>::DynamicArray(a1 + 80, (uint64_t *)(a2 + 80));
  re::DynamicArray<re::AcousticSoundReductionMaterial>::DynamicArray(a1 + 120, (uint64_t *)(a2 + 120));
  return a1;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN2re5audio22AcousticMeshUpdateDataENS9_27AcousticARKitMeshUpdateDataEEEEE19__generic_constructB8ne180100IRKNS0_18__copy_constructorISC_LNS0_6_TraitE1EEEEEvRSD_OT_EUlRSL_OT0_E_JRNS0_6__baseILSG_1EJSA_SB_EEERKST_EEEDcSL_DpT0_(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return std::__variant_detail::__alt<0ul,re::audio::AcousticMeshUpdateData>::__alt[abi:ne180100]<re::audio::AcousticMeshUpdateData const&>(a2, a3);
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN2re5audio22AcousticMeshUpdateDataENS9_27AcousticARKitMeshUpdateDataEEEEE19__generic_constructB8ne180100IRKNS0_18__copy_constructorISC_LNS0_6_TraitE1EEEEEvRSD_OT_EUlRSL_OT0_E_JRNS0_6__baseILSG_1EJSA_SB_EEERKST_EEEDcSL_DpT0_(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __int128 v5;
  __n128 result;

  v5 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)a2 = *(_OWORD *)a3;
  *(_OWORD *)(a2 + 16) = v5;
  *(_QWORD *)(a2 + 32) = *(id *)(a3 + 32);
  result = *(__n128 *)(a3 + 40);
  *(__n128 *)(a2 + 40) = result;
  return result;
}

_QWORD *std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<re::Queue<re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>>>::QueueIterator<re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>>,re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>> const&>,re::Queue<re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>>>::QueueIterator<re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>>,re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>> const&>,re::Queue<re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>>>::QueueIterator<re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>>,re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>>&>>(_QWORD *result, _QWORD *a2, uint64_t a3, _QWORD *a4, uint64_t a5, _QWORD *a6, uint64_t a7)
{
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t *v22;
  uint64_t v23;
  unint64_t v24;
  _QWORD *v25;
  _QWORD *v26;
  _QWORD *v27;
  _QWORD *v28;
  _QWORD *v29;
  uint64_t v32;

  v8 = a6;
  v9 = a5;
  v10 = a3;
  if (a2 != a4 || a3 != a5)
  {
    v29 = result;
    do
    {
      v12 = (unint64_t)(a2[3] + v10) % a2[1];
      v13 = a2[5];
      v14 = (uint64_t *)(v13 + 48 * v12);
      v15 = (unint64_t)(v8[3] + a7) % v8[1];
      v16 = v8[5];
      v17 = (uint64_t *)(v16 + 48 * v15);
      if (v17 != v14)
      {
        v18 = *v14;
        if (*v17)
        {
          if (v18)
          {
            re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>>::copy(v17, (_QWORD *)(v13 + 48 * v12));
          }
          else
          {
            v32 = a7;
            v21 = v16 + 48 * v15;
            v23 = *(_QWORD *)(v21 + 16);
            v22 = (unint64_t *)(v21 + 16);
            if (v23)
            {
              v24 = 0;
              v25 = (_QWORD *)(v16 + 48 * v15);
              v26 = v25 + 5;
              v27 = v25 + 3;
              v28 = v25 + 1;
              do
              {
                std::__variant_detail::__dtor<std::__variant_detail::__traits<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>,(std::__variant_detail::_Trait)1>::~__dtor(*v26 + 48 * ((v24 + *v27) % *v28));
                ++v24;
              }
              while (v24 < *v22);
            }
            *v22 = 0;
            v8 = a6;
            a7 = v32;
            v9 = a5;
          }
          ++*(_DWORD *)(v16 + 48 * v15 + 32);
        }
        else if (v18)
        {
          v19 = *(_QWORD *)(v13 + 48 * v12 + 16);
          *v17 = v18;
          re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>>::setCapacity(v17, v19);
          v20 = v16 + 48 * v15;
          *(_QWORD *)(v20 + 16) = 0;
          *(_QWORD *)(v20 + 24) = 0;
          *(_DWORD *)(v20 + 32) = 0;
          re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>>::copy(v17, v14);
        }
      }
      ++v10;
      ++a7;
    }
    while (a2 != a4 || v10 != v9);
    v10 = v9;
    result = v29;
  }
  *result = a2;
  result[1] = v10;
  result[2] = v8;
  result[3] = a7;
  return result;
}

uint64_t re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>>::copy(_QWORD *a1, _QWORD *a2)
{
  unint64_t v4;
  uint64_t result;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _BYTE v11[32];

  v4 = a2[2];
  if (v4 >= a1[2])
  {
    re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>>::setCapacity(a1, a2[2]);
    result = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>>::QueueIterator<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>,std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>> const&>,re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>>::QueueIterator<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>,std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>> const&>,re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>>::QueueIterator<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>,std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>&>>((uint64_t)v11, a2, 0, a2, a1[2], a1, 0);
    v7 = a1[2];
    for (a1[2] = v4; v7 != a2[2]; ++v7)
    {
      v8 = a1[5] + 48 * ((unint64_t)(v7 + a1[3]) % a1[1]);
      v9 = a2[5] + 48 * ((unint64_t)(v7 + a2[3]) % a2[1]);
      *(_BYTE *)v8 = 0;
      *(_DWORD *)(v8 + 40) = -1;
      v10 = *(unsigned int *)(v9 + 40);
      if ((_DWORD)v10 != -1)
      {
        result = ((uint64_t (*)(_BYTE *, uint64_t))off_24ED3E940[v10])(v11, v8);
        *(_DWORD *)(v8 + 40) = v10;
      }
    }
  }
  else
  {
    result = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>>::QueueIterator<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>,std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>> const&>,re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>>::QueueIterator<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>,std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>> const&>,re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>>::QueueIterator<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>,std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>&>>((uint64_t)v11, a2, 0, a2, a2[2], a1, 0);
    if (v4 != a1[2])
    {
      v6 = v4;
      do
      {
        result = std::__variant_detail::__dtor<std::__variant_detail::__traits<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>,(std::__variant_detail::_Trait)1>::~__dtor(a1[5] + 48 * ((v6 + a1[3]) % a1[1]));
        ++v6;
      }
      while (v6 != a1[2]);
    }
    a1[2] = v4;
  }
  return result;
}

void sub_2254176B0(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__variant_detail::__dtor<std::__variant_detail::__traits<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>,(std::__variant_detail::_Trait)1>::~__dtor(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>>::QueueIterator<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>,std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>> const&>,re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>>::QueueIterator<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>,std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>> const&>,re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>>::QueueIterator<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>,std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<re::audio::PHASEOccluderData>,re::DynamicArray<re::audio::PHASEOccluderUpdateData>>&>>(uint64_t result, _QWORD *a2, uint64_t a3, _QWORD *a4, uint64_t a5, _QWORD *a6, uint64_t a7)
{
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v18;
  char v19;

  v11 = (_QWORD *)result;
  if (a2 != a4 || a3 != a5)
  {
    v12 = a5 - 1;
    while (1)
    {
      v13 = a3;
      v14 = a6[5] + 48 * ((unint64_t)(a7 + a6[3]) % a6[1]);
      v15 = *(unsigned int *)(v14 + 40);
      v16 = *(unsigned int *)(a2[5] + 48 * ((unint64_t)(a3 + a2[3]) % a2[1]) + 40);
      if ((_DWORD)v15 == -1)
      {
        if ((_DWORD)v16 == -1)
          goto LABEL_9;
      }
      else if ((_DWORD)v16 == -1)
      {
        result = ((uint64_t (*)(char *, uint64_t))off_24ED3E910[v15])(&v19, v14);
        *(_DWORD *)(v14 + 40) = -1;
        goto LABEL_9;
      }
      v18 = a6[5] + 48 * ((unint64_t)(a7 + a6[3]) % a6[1]);
      result = ((uint64_t (*)(uint64_t *, uint64_t))off_24ED3E928[v16])(&v18, v14);
LABEL_9:
      a3 = v13 + 1;
      ++a7;
      if (a2 == a4 && v12 == v13)
      {
        a3 = a5;
        break;
      }
    }
  }
  *v11 = a2;
  v11[1] = a3;
  v11[2] = a6;
  v11[3] = a7;
  return result;
}

void **_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJN2re12DynamicArrayINS8_5audio23AcousticMeshRemovalDataEEENS9_INSA_17PHASEOccluderDataEEENS9_INSA_23PHASEOccluderUpdateDataEEEEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentISH_LNS0_6_TraitE1EEEEEvOT_EUlRSP_OT0_E_JRNS0_6__baseILSL_1EJSC_SE_SG_EEERKSX_EEEDcSP_DpT0_(void **result, uint64_t a2, uint64_t *a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v7;
  unint64_t v8;
  char v9;

  v4 = (uint64_t)*result;
  v5 = *((unsigned int *)*result + 10);
  if ((_DWORD)v5 == -1)
    goto LABEL_8;
  if ((_DWORD)v5)
  {
    ((void (*)(char *, uint64_t))off_24ED3E910[v5])(&v9, v4);
LABEL_8:
    *(_DWORD *)(v4 + 40) = -1;
    result = (void **)re::DynamicArray<re::audio::AcousticMeshRemovalData>::DynamicArray(v4, a3);
    *(_DWORD *)(v4 + 40) = 0;
    return result;
  }
  if ((uint64_t *)a2 != a3)
  {
    v7 = *a3;
    if (*(_QWORD *)a2)
    {
      if (v7)
        result = re::DynamicArray<re::audio::AcousticMeshRemovalData>::copy((void **)a2, (uint64_t)a3);
      else
        *(_QWORD *)(a2 + 16) = 0;
      ++*(_DWORD *)(a2 + 24);
    }
    else if (v7)
    {
      v8 = a3[2];
      *(_QWORD *)a2 = v7;
      re::DynamicArray<re::Pair<BOOL,re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription,true>>::setCapacity((_QWORD *)a2, v8);
      ++*(_DWORD *)(a2 + 24);
      return re::DynamicArray<re::audio::AcousticMeshRemovalData>::copy((void **)a2, (uint64_t)a3);
    }
  }
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJN2re12DynamicArrayINS8_5audio23AcousticMeshRemovalDataEEENS9_INSA_17PHASEOccluderDataEEENS9_INSA_23PHASEOccluderUpdateDataEEEEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentISH_LNS0_6_TraitE1EEEEEvOT_EUlRSP_OT0_E_JRNS0_6__baseILSL_1EJSC_SE_SG_EEERKSX_EEEDcSP_DpT0_(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void **v11;
  void *v12;
  char v13;

  v4 = *a1;
  v5 = *(unsigned int *)(*a1 + 40);
  if ((_DWORD)v5 == -1)
    goto LABEL_8;
  if ((_DWORD)v5 != 1)
  {
    ((void (*)(char *, uint64_t))off_24ED3E910[v5])(&v13, v4);
LABEL_8:
    *(_DWORD *)(v4 + 40) = -1;
    re::DynamicArray<re::audio::PHASEOccluderData>::DynamicArray(v4, a3);
    *(_DWORD *)(v4 + 40) = 1;
    return;
  }
  if ((uint64_t *)a2 != a3)
  {
    v7 = *a3;
    if (*(_QWORD *)a2)
    {
      if (v7)
      {
        re::DynamicArray<re::audio::PHASEOccluderData>::copy((_QWORD *)a2, (uint64_t)a3);
      }
      else
      {
        v9 = *(_QWORD *)(a2 + 16);
        *(_QWORD *)(a2 + 16) = 0;
        if (v9)
        {
          v10 = 48 * v9;
          v11 = (void **)(*(_QWORD *)(a2 + 32) + 24);
          do
          {
            v12 = *v11;
            v11 += 6;

            v10 -= 48;
          }
          while (v10);
        }
      }
      ++*(_DWORD *)(a2 + 24);
    }
    else if (v7)
    {
      v8 = a3[2];
      *(_QWORD *)a2 = v7;
      re::DynamicArray<re::audio::PHASEOccluderData>::setCapacity((_QWORD *)a2, v8);
      ++*(_DWORD *)(a2 + 24);
      re::DynamicArray<re::audio::PHASEOccluderData>::copy((_QWORD *)a2, (uint64_t)a3);
    }
  }
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJN2re12DynamicArrayINS8_5audio23AcousticMeshRemovalDataEEENS9_INSA_17PHASEOccluderDataEEENS9_INSA_23PHASEOccluderUpdateDataEEEEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentISH_LNS0_6_TraitE1EEEEEvOT_EUlRSP_OT0_E_JRNS0_6__baseILSL_1EJSC_SE_SG_EEERKSX_EEEDcSP_DpT0_(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void **v11;
  void *v12;
  char v13;

  v4 = *a1;
  v5 = *(unsigned int *)(*a1 + 40);
  if ((_DWORD)v5 == -1)
    goto LABEL_8;
  if ((_DWORD)v5 != 2)
  {
    ((void (*)(char *, uint64_t))off_24ED3E910[v5])(&v13, v4);
LABEL_8:
    *(_DWORD *)(v4 + 40) = -1;
    re::DynamicArray<re::audio::PHASEOccluderUpdateData>::DynamicArray(v4, a3);
    *(_DWORD *)(v4 + 40) = 2;
    return;
  }
  if ((uint64_t *)a2 != a3)
  {
    v7 = *a3;
    if (*(_QWORD *)a2)
    {
      if (v7)
      {
        re::DynamicArray<re::audio::PHASEOccluderUpdateData>::copy((_QWORD *)a2, (uint64_t)a3);
      }
      else
      {
        v9 = *(_QWORD *)(a2 + 16);
        *(_QWORD *)(a2 + 16) = 0;
        if (v9)
        {
          v10 = 56 * v9;
          v11 = (void **)(*(_QWORD *)(a2 + 32) + 32);
          do
          {
            v12 = *v11;
            v11 += 7;

            v10 -= 56;
          }
          while (v10);
        }
      }
      ++*(_DWORD *)(a2 + 24);
    }
    else if (v7)
    {
      v8 = a3[2];
      *(_QWORD *)a2 = v7;
      re::DynamicArray<re::audio::PHASEOccluderUpdateData>::setCapacity((_QWORD *)a2, v8);
      ++*(_DWORD *)(a2 + 24);
      re::DynamicArray<re::audio::PHASEOccluderUpdateData>::copy((_QWORD *)a2, (uint64_t)a3);
    }
  }
}

void re::DynamicArray<re::audio::PHASEOccluderData>::copy(_QWORD *a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void **v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  __int128 *v11;
  uint64_t v12;
  __int128 *v13;
  uint64_t v14;
  __int128 v15;

  v4 = *(_QWORD *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<re::audio::PHASEOccluderData>::setCapacity(a1, *(_QWORD *)(a2 + 16));
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<re::audio::PHASEOccluderData *,re::audio::PHASEOccluderData *,re::audio::PHASEOccluderData *>(*(__int128 **)(a2 + 32), (__int128 *)(*(_QWORD *)(a2 + 32) + 48 * a1[2]), a1[4]);
    v9 = a1[2];
    if (v9 != v4)
    {
      v10 = *(_QWORD *)(a2 + 32);
      v11 = (__int128 *)(v10 + 48 * v4);
      v12 = 3 * v9;
      v13 = (__int128 *)(v10 + 16 * v12);
      v14 = a1[4] + 16 * v12;
      do
      {
        v15 = *v13;
        *(_QWORD *)(v14 + 16) = *((_QWORD *)v13 + 2);
        *(_OWORD *)v14 = v15;
        *(_QWORD *)(v14 + 24) = *((id *)v13 + 3);
        *(_OWORD *)(v14 + 32) = v13[2];
        v13 += 3;
        v14 += 48;
      }
      while (v13 != v11);
    }
  }
  else
  {
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<re::audio::PHASEOccluderData *,re::audio::PHASEOccluderData *,re::audio::PHASEOccluderData *>(*(__int128 **)(a2 + 32), (__int128 *)(*(_QWORD *)(a2 + 32) + 48 * v4), a1[4]);
    v5 = a1[2];
    if (v4 != v5)
    {
      v6 = 48 * v5 - 48 * v4;
      v7 = (void **)(a1[4] + 48 * v4 + 24);
      do
      {
        v8 = *v7;
        v7 += 6;

        v6 -= 48;
      }
      while (v6);
    }
  }
  a1[2] = v4;
}

void std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<re::audio::PHASEOccluderData *,re::audio::PHASEOccluderData *,re::audio::PHASEOccluderData *>(__int128 *a1, __int128 *a2, uint64_t a3)
{
  __int128 *v5;
  __int128 v6;
  uint64_t v7;

  if (a1 != a2)
  {
    v5 = a1;
    do
    {
      v6 = *v5;
      *(_QWORD *)(a3 + 16) = *((_QWORD *)v5 + 2);
      *(_OWORD *)a3 = v6;
      objc_storeStrong((id *)(a3 + 24), *((id *)v5 + 3));
      v7 = *((_QWORD *)v5 + 4);
      *(_BYTE *)(a3 + 40) = *((_BYTE *)v5 + 40);
      *(_QWORD *)(a3 + 32) = v7;
      v5 += 3;
      a3 += 48;
    }
    while (v5 != a2);
  }
}

uint64_t re::DynamicArray<re::audio::PHASEOccluderData>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  unint64_t v5;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  v3 = *a2;
  if (*a2)
  {
    v5 = a2[2];
    *(_QWORD *)a1 = v3;
    re::DynamicArray<re::audio::PHASEOccluderData>::setCapacity((_QWORD *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::audio::PHASEOccluderData>::copy((_QWORD *)a1, (uint64_t)a2);
  }
  return a1;
}

void re::DynamicArray<re::audio::PHASEOccluderUpdateData>::copy(_QWORD *a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void **v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;

  v4 = *(_QWORD *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<re::audio::PHASEOccluderUpdateData>::setCapacity(a1, *(_QWORD *)(a2 + 16));
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<re::audio::PHASEOccluderUpdateData *,re::audio::PHASEOccluderUpdateData *,re::audio::PHASEOccluderUpdateData *>(*(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 32) + 56 * a1[2], a1[4]);
    v9 = a1[2];
    if (v9 != v4)
    {
      v10 = *(_QWORD *)(a2 + 32);
      v11 = v10 + 56 * v4;
      v12 = 56 * v9;
      v13 = v10 + v12;
      v14 = a1[4] + v12;
      do
      {
        v15 = *(_OWORD *)(v13 + 16);
        *(_OWORD *)v14 = *(_OWORD *)v13;
        *(_OWORD *)(v14 + 16) = v15;
        *(_QWORD *)(v14 + 32) = *(id *)(v13 + 32);
        *(_OWORD *)(v14 + 40) = *(_OWORD *)(v13 + 40);
        v13 += 56;
        v14 += 56;
      }
      while (v13 != v11);
    }
  }
  else
  {
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<re::audio::PHASEOccluderUpdateData *,re::audio::PHASEOccluderUpdateData *,re::audio::PHASEOccluderUpdateData *>(*(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 32) + 56 * v4, a1[4]);
    v5 = a1[2];
    if (v4 != v5)
    {
      v6 = -56 * v4 + 56 * v5;
      v7 = (void **)(56 * v4 + a1[4] + 32);
      do
      {
        v8 = *v7;
        v7 += 7;

        v6 -= 56;
      }
      while (v6);
    }
  }
  a1[2] = v4;
}

void std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<re::audio::PHASEOccluderUpdateData *,re::audio::PHASEOccluderUpdateData *,re::audio::PHASEOccluderUpdateData *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  __int128 v6;
  uint64_t v7;

  if (a1 != a2)
  {
    v5 = a1;
    do
    {
      v6 = *(_OWORD *)(v5 + 16);
      *(_OWORD *)a3 = *(_OWORD *)v5;
      *(_OWORD *)(a3 + 16) = v6;
      objc_storeStrong((id *)(a3 + 32), *(id *)(v5 + 32));
      v7 = *(_QWORD *)(v5 + 40);
      *(_BYTE *)(a3 + 48) = *(_BYTE *)(v5 + 48);
      *(_QWORD *)(a3 + 40) = v7;
      v5 += 56;
      a3 += 56;
    }
    while (v5 != a2);
  }
}

uint64_t re::DynamicArray<re::audio::PHASEOccluderUpdateData>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  unint64_t v5;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  v3 = *a2;
  if (*a2)
  {
    v5 = a2[2];
    *(_QWORD *)a1 = v3;
    re::DynamicArray<re::audio::PHASEOccluderUpdateData>::setCapacity((_QWORD *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::audio::PHASEOccluderUpdateData>::copy((_QWORD *)a1, (uint64_t)a2);
  }
  return a1;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN2re12DynamicArrayINS8_5audio23AcousticMeshRemovalDataEEENS9_INSA_17PHASEOccluderDataEEENS9_INSA_23PHASEOccluderUpdateDataEEEEEEE19__generic_constructB8ne180100IRKNS0_18__copy_constructorISH_LNS0_6_TraitE1EEEEEvRSI_OT_EUlRSQ_OT0_E_JRNS0_6__baseILSL_1EJSC_SE_SG_EEERKSY_EEEDcSQ_DpT0_(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  return re::DynamicArray<re::audio::AcousticMeshRemovalData>::DynamicArray(a2, a3);
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN2re12DynamicArrayINS8_5audio23AcousticMeshRemovalDataEEENS9_INSA_17PHASEOccluderDataEEENS9_INSA_23PHASEOccluderUpdateDataEEEEEEE19__generic_constructB8ne180100IRKNS0_18__copy_constructorISH_LNS0_6_TraitE1EEEEEvRSI_OT_EUlRSQ_OT0_E_JRNS0_6__baseILSL_1EJSC_SE_SG_EEERKSY_EEEDcSQ_DpT0_(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  return re::DynamicArray<re::audio::PHASEOccluderData>::DynamicArray(a2, a3);
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN2re12DynamicArrayINS8_5audio23AcousticMeshRemovalDataEEENS9_INSA_17PHASEOccluderDataEEENS9_INSA_23PHASEOccluderUpdateDataEEEEEEE19__generic_constructB8ne180100IRKNS0_18__copy_constructorISH_LNS0_6_TraitE1EEEEEvRSI_OT_EUlRSQ_OT0_E_JRNS0_6__baseILSL_1EJSC_SE_SG_EEERKSY_EEEDcSQ_DpT0_(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  return re::DynamicArray<re::audio::PHASEOccluderUpdateData>::DynamicArray(a2, a3);
}

uint64_t std::__function::__value_func<void ()(re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>> *)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;

  v3 = (_QWORD *)(a2 + 24);
  v4 = *(_QWORD *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(_QWORD *)(a1 + 24) = a1;
      (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(_QWORD *)(a1 + 24) = v4;
  }
  else
  {
    v3 = (_QWORD *)(a1 + 24);
  }
  *v3 = 0;
  return a1;
}

void std::__shared_ptr_pointer<re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>> *,std::function<void ()(re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>> *)>,std::allocator<re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>>>>::~__shared_ptr_pointer(std::__shared_weak_count *this)
{
  uint64_t *p_shared_owners;
  uint64_t *shared_owners;
  uint64_t v4;

  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24ED3E968;
  p_shared_owners = &this[1].__shared_owners_;
  shared_owners = (uint64_t *)this[2].__shared_owners_;
  if (shared_owners == p_shared_owners)
  {
    v4 = 4;
    shared_owners = p_shared_owners;
    goto LABEL_5;
  }
  if (shared_owners)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*shared_owners + 8 * v4))();
  }
  std::__shared_weak_count::~__shared_weak_count(this);
}

{
  uint64_t *p_shared_owners;
  uint64_t *shared_owners;
  uint64_t v4;

  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24ED3E968;
  p_shared_owners = &this[1].__shared_owners_;
  shared_owners = (uint64_t *)this[2].__shared_owners_;
  if (shared_owners == p_shared_owners)
  {
    v4 = 4;
    shared_owners = p_shared_owners;
  }
  else
  {
    if (!shared_owners)
    {
LABEL_6:
      std::__shared_weak_count::~__shared_weak_count(this);
      JUMPOUT(0x2276933B8);
    }
    v4 = 5;
  }
  (*(void (**)(void))(*shared_owners + 8 * v4))();
  goto LABEL_6;
}

_QWORD *std::__shared_ptr_pointer<re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>> *,std::function<void ()(re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>> *)>,std::allocator<re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>>>>::__on_zero_shared(_QWORD *a1)
{
  uint64_t v2;
  _QWORD *result;
  uint64_t v4;
  uint64_t v5;

  v5 = a1[3];
  v2 = a1[7];
  if (!v2)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v2 + 48))(v2, &v5);
  result = (_QWORD *)a1[7];
  if (result == a1 + 4)
  {
    v4 = 4;
    result = a1 + 4;
  }
  else
  {
    if (!result)
      return result;
    v4 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v4))();
}

uint64_t std::__shared_ptr_pointer<re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>> *,std::function<void ()(re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>> *)>,std::allocator<re::Queue<std::variant<re::DynamicArray<re::audio::AcousticMeshRemovalData>,re::DynamicArray<std::variant<re::audio::AcousticMeshData,re::audio::AcousticARKitMeshData>>,re::DynamicArray<std::variant<re::audio::AcousticMeshUpdateData,re::audio::AcousticARKitMeshUpdateData>>>>>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 32;
  }
  else
  {
    return 0;
  }
}

_QWORD *std::vector<unsigned long long>::__assign_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(_QWORD *result, char *__src, char *a3, unint64_t a4)
{
  char *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  size_t v14;
  void **v15;
  _BYTE *v16;
  unint64_t v17;
  char *v18;
  void *v19;

  v6 = __src;
  v7 = result;
  v9 = (uint64_t)(result + 2);
  v8 = result[2];
  v10 = (char *)*result;
  if (a4 > (v8 - *result) >> 3)
  {
    if (v10)
    {
      result[1] = v10;
      operator delete(v10);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 61)
      goto LABEL_23;
    v11 = v8 >> 2;
    if (v8 >> 2 <= a4)
      v11 = a4;
    v12 = (unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8 ? 0x1FFFFFFFFFFFFFFFLL : v11;
    if (v12 >> 61)
LABEL_23:
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    result = std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>(v9, v12);
    v10 = (char *)result;
    *v7 = result;
    v7[1] = result;
    v7[2] = &result[v13];
    v14 = a3 - v6;
    if (v14)
      result = memmove(result, v6, v14);
    v15 = (void **)(v7 + 1);
    goto LABEL_22;
  }
  v15 = (void **)(result + 1);
  v16 = (_BYTE *)result[1];
  v17 = (v16 - v10) >> 3;
  if (v17 >= a4)
  {
    v14 = a3 - __src;
    if (a3 == __src)
      goto LABEL_22;
    v19 = (void *)*result;
LABEL_21:
    result = memmove(v19, __src, v14);
    goto LABEL_22;
  }
  v18 = &__src[8 * v17];
  if (v16 != v10)
  {
    result = memmove((void *)*result, __src, v16 - v10);
    v10 = (char *)*v15;
  }
  v14 = a3 - v18;
  if (v14)
  {
    v19 = v10;
    __src = v18;
    goto LABEL_21;
  }
LABEL_22:
  *v15 = &v10[v14];
  return result;
}

uint64_t std::__function::__func<re::AudioManager_PHASE::prepareSource(re::AudioSourceState &,CMTime,void({block_pointer})(NSError *))::$_0,std::allocator<re::AudioManager_PHASE::prepareSource(re::AudioSourceState &,CMTime,void({block_pointer})(NSError *))::$_0>,void ()(AUAudioUnit *,NSError *)>::~__func(uint64_t a1)
{
  *(_QWORD *)a1 = &off_24ED3EA28;

  std::shared_ptr<re::AssetManager>::~shared_ptr[abi:nn180100](a1 + 40);
  return a1;
}

void std::__function::__func<re::AudioManager_PHASE::prepareSource(re::AudioSourceState &,CMTime,void({block_pointer})(NSError *))::$_0,std::allocator<re::AudioManager_PHASE::prepareSource(re::AudioSourceState &,CMTime,void({block_pointer})(NSError *))::$_0>,void ()(AUAudioUnit *,NSError *)>::~__func(uint64_t a1)
{
  *(_QWORD *)a1 = &off_24ED3EA28;

  std::shared_ptr<re::AssetManager>::~shared_ptr[abi:nn180100](a1 + 40);
  JUMPOUT(0x2276933B8);
}

_QWORD *std::__function::__func<re::AudioManager_PHASE::prepareSource(re::AudioSourceState &,CMTime,void({block_pointer})(NSError *))::$_0,std::allocator<re::AudioManager_PHASE::prepareSource(re::AudioSourceState &,CMTime,void({block_pointer})(NSError *))::$_0>,void ()(AUAudioUnit *,NSError *)>::__clone(uint64_t a1)
{
  uint64_t v1;
  _QWORD *v2;

  v1 = a1 + 8;
  v2 = operator new(0x50uLL);
  *v2 = &off_24ED3EA28;
  std::__compressed_pair_elem<re::AudioManager_PHASE::prepareSource(re::AudioSourceState &,CMTime,void({block_pointer})(NSError *))::$_0,0,false>::__compressed_pair_elem[abi:ne180100]<re::AudioManager_PHASE::prepareSource(re::AudioSourceState &,CMTime,void({block_pointer})(NSError *))::$_0 const&,0ul>((uint64_t)(v2 + 1), v1);
  return v2;
}

uint64_t std::__function::__func<re::AudioManager_PHASE::prepareSource(re::AudioSourceState &,CMTime,void({block_pointer})(NSError *))::$_0,std::allocator<re::AudioManager_PHASE::prepareSource(re::AudioSourceState &,CMTime,void({block_pointer})(NSError *))::$_0>,void ()(AUAudioUnit *,NSError *)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24ED3EA28;
  return std::__compressed_pair_elem<re::AudioManager_PHASE::prepareSource(re::AudioSourceState &,CMTime,void({block_pointer})(NSError *))::$_0,0,false>::__compressed_pair_elem[abi:ne180100]<re::AudioManager_PHASE::prepareSource(re::AudioSourceState &,CMTime,void({block_pointer})(NSError *))::$_0 const&,0ul>((uint64_t)(a2 + 1), a1 + 8);
}

void std::__function::__func<re::AudioManager_PHASE::prepareSource(re::AudioSourceState &,CMTime,void({block_pointer})(NSError *))::$_0,std::allocator<re::AudioManager_PHASE::prepareSource(re::AudioSourceState &,CMTime,void({block_pointer})(NSError *))::$_0>,void ()(AUAudioUnit *,NSError *)>::destroy(uint64_t a1)
{
  std::__function::__alloc_func<re::AudioManager_PHASE::prepareSource(re::AudioSourceState &,CMTime,void({block_pointer})(NSError *))::$_0,std::allocator<re::AudioManager_PHASE::prepareSource(re::AudioSourceState &,CMTime,void({block_pointer})(NSError *))::$_0>,void ()(AUAudioUnit *,NSError *)>::destroy[abi:ne180100]((id *)(a1 + 8));
}

void std::__function::__func<re::AudioManager_PHASE::prepareSource(re::AudioSourceState &,CMTime,void({block_pointer})(NSError *))::$_0,std::allocator<re::AudioManager_PHASE::prepareSource(re::AudioSourceState &,CMTime,void({block_pointer})(NSError *))::$_0>,void ()(AUAudioUnit *,NSError *)>::destroy_deallocate(id *a1)
{
  std::__function::__alloc_func<re::AudioManager_PHASE::prepareSource(re::AudioSourceState &,CMTime,void({block_pointer})(NSError *))::$_0,std::allocator<re::AudioManager_PHASE::prepareSource(re::AudioSourceState &,CMTime,void({block_pointer})(NSError *))::$_0>,void ()(AUAudioUnit *,NSError *)>::destroy[abi:ne180100](a1 + 1);
  operator delete(a1);
}

void std::__function::__func<re::AudioManager_PHASE::prepareSource(re::AudioSourceState &,CMTime,void({block_pointer})(NSError *))::$_0,std::allocator<re::AudioManager_PHASE::prepareSource(re::AudioSourceState &,CMTime,void({block_pointer})(NSError *))::$_0>,void ()(AUAudioUnit *,NSError *)>::operator()(uint64_t a1, id *a2, void **a3)
{
  void *v4;
  id v5;
  id v6;
  uint64_t v7;
  NSObject *v8;
  id v9;
  id v10;
  uint64_t v11;
  id v12;
  std::__shared_weak_count *v13;
  uint64_t v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  void *v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  _QWORD v21[4];
  id v22;
  id v23;
  id v24;
  id v25;
  id v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  std::__shared_weak_count *v30;
  uint64_t v31;

  v4 = *a3;
  v5 = *a2;
  v6 = v4;
  v7 = *(_QWORD *)(a1 + 56);
  v21[0] = MEMORY[0x24BDAC760];
  v21[1] = 3321888768;
  v21[2] = ___ZZN2re18AudioManager_PHASE13prepareSourceERNS_16AudioSourceStateE6CMTimeU13block_pointerFvP7NSErrorEENK3__0clEP11AUAudioUnitS5__block_invoke;
  v21[3] = &unk_24ED3EAA0;
  v27 = v7;
  v8 = *(NSObject **)(a1 + 16);
  v22 = *(id *)(a1 + 24);
  v9 = v6;
  v23 = v9;
  v10 = *(id *)(a1 + 32);
  v11 = *(_QWORD *)(a1 + 8);
  v26 = v10;
  v28 = v11;
  v12 = v5;
  v14 = *(_QWORD *)(a1 + 40);
  v13 = *(std::__shared_weak_count **)(a1 + 48);
  v24 = v12;
  v29 = v14;
  v30 = v13;
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v16 = __ldxr(p_shared_owners);
    while (__stxr(v16 + 1, p_shared_owners));
  }
  v17 = *(void **)(a1 + 72);
  v31 = *(_QWORD *)(a1 + 64);
  v25 = v17;
  dispatch_async(v8, v21);

  v18 = v30;
  if (v30)
  {
    v19 = (unint64_t *)&v30->__shared_owners_;
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }

}

uint64_t std::__function::__func<re::AudioManager_PHASE::prepareSource(re::AudioSourceState &,CMTime,void({block_pointer})(NSError *))::$_0,std::allocator<re::AudioManager_PHASE::prepareSource(re::AudioSourceState &,CMTime,void({block_pointer})(NSError *))::$_0>,void ()(AUAudioUnit *,NSError *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::AudioManager_PHASE::prepareSource(re::AudioSourceState &,CMTime,void({block_pointer})(NSError *))::$_0,std::allocator<re::AudioManager_PHASE::prepareSource(re::AudioSourceState &,CMTime,void({block_pointer})(NSError *))::$_0>,void ()(AUAudioUnit *,NSError *)>::target_type()
{
}

uint64_t std::__compressed_pair_elem<re::AudioManager_PHASE::prepareSource(re::AudioSourceState &,CMTime,void({block_pointer})(NSError *))::$_0,0,false>::__compressed_pair_elem[abi:ne180100]<re::AudioManager_PHASE::prepareSource(re::AudioSourceState &,CMTime,void({block_pointer})(NSError *))::$_0 const&,0ul>(uint64_t a1, uint64_t a2)
{
  void *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;

  v4 = *(void **)(a2 + 8);
  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)(a1 + 8) = v4;
  *(_QWORD *)(a1 + 16) = *(id *)(a2 + 16);
  v5 = _Block_copy(*(const void **)(a2 + 24));
  v7 = *(_QWORD *)(a2 + 32);
  v6 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 24) = v5;
  *(_QWORD *)(a1 + 32) = v7;
  *(_QWORD *)(a1 + 40) = v6;
  if (v6)
  {
    v8 = (unint64_t *)(v6 + 8);
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  *(_QWORD *)(a1 + 64) = *(id *)(a2 + 64);
  return a1;
}

void std::__function::__alloc_func<re::AudioManager_PHASE::prepareSource(re::AudioSourceState &,CMTime,void({block_pointer})(NSError *))::$_0,std::allocator<re::AudioManager_PHASE::prepareSource(re::AudioSourceState &,CMTime,void({block_pointer})(NSError *))::$_0>,void ()(AUAudioUnit *,NSError *)>::destroy[abi:ne180100](id *a1)
{

  std::shared_ptr<re::AssetManager>::~shared_ptr[abi:nn180100]((uint64_t)(a1 + 4));
}

void ___ZZN2re18AudioManager_PHASE13prepareSourceERNS_16AudioSourceStateE6CMTimeU13block_pointerFvP7NSErrorEENK3__0clEP11AUAudioUnitS5__block_invoke(uint64_t a1)
{
  uint64_t v2;
  re *v3;
  NSObject *v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  _QWORD v14[2];
  uint8_t buf[4];
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 72);
  v3 = (re *)objc_msgSend(*(id *)(a1 + 32), "isCancelled");
  if ((_DWORD)v3)
  {
    v4 = *re::audioLogObjects(v3);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_debug_impl(&dword_224FE9000, v4, OS_LOG_TYPE_DEBUG, "Aborting callback since the engine was shut down.", buf, 2u);
    }
  }
  else if (*(_QWORD *)(a1 + 40))
  {
    v5 = *re::audioLogObjects(v3);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v13 = *(_QWORD *)(a1 + 40);
      *(_DWORD *)buf = 138412290;
      v16 = v13;
      _os_log_error_impl(&dword_224FE9000, v5, OS_LOG_TYPE_ERROR, "Could not instantiate audio generator AU. %@", buf, 0xCu);
    }
    v6 = *(_QWORD *)(a1 + 64);
    if (v6)
      (*(void (**)(uint64_t, _QWORD))(v6 + 16))(v6, *(_QWORD *)(a1 + 40));
  }
  else
  {
    objc_storeStrong((id *)(*(_QWORD *)(a1 + 80) + 456), *(id *)(a1 + 48));
    objc_storeStrong((id *)(*(_QWORD *)(a1 + 88) + 280), *(id *)(a1 + 48));
    v7 = *(_QWORD *)(v2 + 520);
    v8 = *(std::__shared_weak_count **)(a1 + 96);
    v14[0] = *(_QWORD *)(a1 + 88);
    v14[1] = v8;
    if (v8)
    {
      p_shared_owners = (unint64_t *)&v8->__shared_owners_;
      do
        v10 = __ldxr(p_shared_owners);
      while (__stxr(v10 + 1, p_shared_owners));
    }
    re::AudioManager_PHASE_Async::prepareSourceAsync(v7, v14, *(_QWORD *)(a1 + 104), *(void **)(a1 + 56), *(void **)(v2 + 536));
    if (v8)
    {
      v11 = (unint64_t *)&v8->__shared_owners_;
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }
  }
}

void sub_2254187B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<re::AssetManager>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_88c63_ZTSNSt3__110shared_ptrIN2re5audio24REPHASESoundPrepareStateEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 96);
  *(_QWORD *)(result + 88) = *(_QWORD *)(a2 + 88);
  *(_QWORD *)(result + 96) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_ea8_88c63_ZTSNSt3__110shared_ptrIN2re5audio24REPHASESoundPrepareStateEEE(uint64_t a1)
{
  return std::shared_ptr<re::AssetManager>::~shared_ptr[abi:nn180100](a1 + 88);
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,re::AudioManager_PHASE::MixGroupState>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,re::AudioManager_PHASE::MixGroupState>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,re::AudioManager_PHASE::MixGroupState>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,re::AudioManager_PHASE::MixGroupState>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1, unsigned __int8 *a2, __int128 **a3)
{
  unint64_t v3;
  _QWORD *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint8x8_t v11;
  unint64_t v12;
  unsigned __int8 **v13;
  unsigned __int8 *i;
  unint64_t v15;
  __int128 *v16;
  _QWORD *v17;
  _QWORD *v18;
  std::string *v19;
  __int128 v20;
  float v21;
  float v22;
  _BOOL8 v23;
  unint64_t v24;
  unint64_t v25;
  int8x8_t prime;
  void *v27;
  void *v28;
  uint64_t v29;
  _QWORD *v30;
  unint64_t v31;
  uint8x8_t v32;
  unint64_t v33;
  uint8x8_t v34;
  uint64_t v35;
  _QWORD *v36;
  unint64_t v37;
  unsigned __int8 **v38;
  unint64_t v39;
  void *v41;
  _QWORD v42[2];
  char v43;

  v7 = (_QWORD *)(a1 + 24);
  v8 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  v9 = v8;
  v10 = *(_QWORD *)(a1 + 8);
  if (v10)
  {
    v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      v3 = v8;
      if (v8 >= v10)
        v3 = v8 % v10;
    }
    else
    {
      v3 = (v10 - 1) & v8;
    }
    v13 = *(unsigned __int8 ***)(*(_QWORD *)a1 + 8 * v3);
    if (v13)
    {
      for (i = *v13; i; i = *(unsigned __int8 **)i)
      {
        v15 = *((_QWORD *)i + 1);
        if (v15 == v9)
        {
          if ((std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10)
              v15 %= v10;
          }
          else
          {
            v15 &= v10 - 1;
          }
          if (v15 != v3)
            break;
        }
      }
    }
  }
  v16 = *a3;
  v17 = (_QWORD *)(a1 + 16);
  v18 = operator new(0x38uLL);
  v42[0] = v18;
  v42[1] = a1 + 16;
  v43 = 0;
  *v18 = 0;
  v18[1] = v9;
  v19 = (std::string *)(v18 + 2);
  if (*((char *)v16 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v19, *(const std::string::value_type **)v16, *((_QWORD *)v16 + 1));
  }
  else
  {
    v20 = *v16;
    v18[4] = *((_QWORD *)v16 + 2);
    *(_OWORD *)&v19->__r_.__value_.__l.__data_ = v20;
  }
  v18[5] = 0;
  v18[6] = 0;
  v43 = 1;
  v21 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v22 = *(float *)(a1 + 32);
  if (!v10 || (float)(v22 * (float)v10) < v21)
  {
    v23 = 1;
    if (v10 >= 3)
      v23 = (v10 & (v10 - 1)) != 0;
    v24 = v23 | (2 * v10);
    v25 = vcvtps_u32_f32(v21 / v22);
    if (v24 <= v25)
      prime = (int8x8_t)v25;
    else
      prime = (int8x8_t)v24;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
    }
    v10 = *(_QWORD *)(a1 + 8);
    if (*(_QWORD *)&prime > v10)
      goto LABEL_33;
    if (*(_QWORD *)&prime < v10)
    {
      v33 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v10 < 3 || (v34 = (uint8x8_t)vcnt_s8((int8x8_t)v10), v34.i16[0] = vaddlv_u8(v34), v34.u32[0] > 1uLL))
      {
        v33 = std::__next_prime(v33);
      }
      else
      {
        v35 = 1 << -(char)__clz(v33 - 1);
        if (v33 >= 2)
          v33 = v35;
      }
      if (*(_QWORD *)&prime <= v33)
        prime = (int8x8_t)v33;
      if (*(_QWORD *)&prime >= v10)
      {
        v10 = *(_QWORD *)(a1 + 8);
      }
      else
      {
        if (prime)
        {
LABEL_33:
          if (*(_QWORD *)&prime >> 61)
            std::__throw_bad_array_new_length[abi:ne180100]();
          v27 = operator new(8 * *(_QWORD *)&prime);
          v28 = *(void **)a1;
          *(_QWORD *)a1 = v27;
          if (v28)
            operator delete(v28);
          v29 = 0;
          *(int8x8_t *)(a1 + 8) = prime;
          do
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v29++) = 0;
          while (*(_QWORD *)&prime != v29);
          v30 = (_QWORD *)*v17;
          if (*v17)
          {
            v31 = v30[1];
            v32 = (uint8x8_t)vcnt_s8(prime);
            v32.i16[0] = vaddlv_u8(v32);
            if (v32.u32[0] > 1uLL)
            {
              if (v31 >= *(_QWORD *)&prime)
                v31 %= *(_QWORD *)&prime;
            }
            else
            {
              v31 &= *(_QWORD *)&prime - 1;
            }
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v31) = v17;
            v36 = (_QWORD *)*v30;
            if (*v30)
            {
              do
              {
                v37 = v36[1];
                if (v32.u32[0] > 1uLL)
                {
                  if (v37 >= *(_QWORD *)&prime)
                    v37 %= *(_QWORD *)&prime;
                }
                else
                {
                  v37 &= *(_QWORD *)&prime - 1;
                }
                if (v37 != v31)
                {
                  if (!*(_QWORD *)(*(_QWORD *)a1 + 8 * v37))
                  {
                    *(_QWORD *)(*(_QWORD *)a1 + 8 * v37) = v30;
                    goto LABEL_58;
                  }
                  *v30 = *v36;
                  *v36 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v37);
                  **(_QWORD **)(*(_QWORD *)a1 + 8 * v37) = v36;
                  v36 = v30;
                }
                v37 = v31;
LABEL_58:
                v30 = v36;
                v36 = (_QWORD *)*v36;
                v31 = v37;
              }
              while (v36);
            }
          }
          v10 = (unint64_t)prime;
          goto LABEL_62;
        }
        v41 = *(void **)a1;
        *(_QWORD *)a1 = 0;
        if (v41)
          operator delete(v41);
        v10 = 0;
        *(_QWORD *)(a1 + 8) = 0;
      }
    }
LABEL_62:
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10)
        v3 = v9 % v10;
      else
        v3 = v9;
    }
    else
    {
      v3 = (v10 - 1) & v9;
    }
  }
  v38 = *(unsigned __int8 ***)(*(_QWORD *)a1 + 8 * v3);
  i = (unsigned __int8 *)v42[0];
  if (v38)
  {
    *(_QWORD *)v42[0] = *v38;
LABEL_75:
    *v38 = i;
    goto LABEL_76;
  }
  *(_QWORD *)v42[0] = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = i;
  *(_QWORD *)(*(_QWORD *)a1 + 8 * v3) = v17;
  if (*(_QWORD *)i)
  {
    v39 = *(_QWORD *)(*(_QWORD *)i + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v39 >= v10)
        v39 %= v10;
    }
    else
    {
      v39 &= v10 - 1;
    }
    v38 = (unsigned __int8 **)(*(_QWORD *)a1 + 8 * v39);
    goto LABEL_75;
  }
LABEL_76:
  v42[0] = 0;
  ++*v7;
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,re::AudioManager_PHASE::MixGroupState>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,re::AudioManager_PHASE::MixGroupState>,void *>>>>::reset[abi:ne180100]((uint64_t)v42);
  return i;
}

void sub_225418C4C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,re::AudioManager_PHASE::MixGroupState>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,re::AudioManager_PHASE::MixGroupState>,void *>>>>::reset[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,re::AudioManager_PHASE::MixGroupState>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,re::AudioManager_PHASE::MixGroupState>,void *>>>>::reset[abi:ne180100](uint64_t a1)
{
  void *v1;

  v1 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,re::AudioManager_PHASE::MixGroupState>,0>((uint64_t)v1 + 16);
    operator delete(v1);
  }
}

re::AudioTelemetryReporter *re::AudioTelemetryReporter::AudioTelemetryReporter(re::AudioTelemetryReporter *this)
{
  NSObject *v2;
  NSObject *v3;
  dispatch_queue_t v4;
  void *v5;

  *((_QWORD *)this + 5) = 0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_DWORD *)this + 8) = 0;
  dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  v2 = objc_claimAutoreleasedReturnValue();
  dispatch_queue_attr_make_with_qos_class(v2, QOS_CLASS_UTILITY, 0);
  v3 = objc_claimAutoreleasedReturnValue();

  v4 = dispatch_queue_create("AudioTelemetry", v3);
  v5 = *(void **)this;
  *(_QWORD *)this = v4;

  return this;
}

void re::AudioTelemetryReporter::initializeTimerWith(uint64_t a1, NSObject *a2, void *a3, double a4)
{
  id v7;
  NSObject *v8;
  id v9;
  _QWORD handler[4];
  id v11;
  uint64_t v12;
  dispatch_object_t object;

  v7 = a3;
  object = dispatch_source_create(MEMORY[0x24BDACA18], 0, 0, a2);
  dispatch_source_set_timer(object, 0, (unint64_t)(a4 * 1000000000.0), 0x989680uLL);
  re::DynamicArray<NSObject  {objcproto18OS_dispatch_source}* {__strong}>::add((_anonymous_namespace_ *)(a1 + 8), (id *)&object);
  v8 = object;
  handler[0] = MEMORY[0x24BDAC760];
  handler[1] = 3221225472;
  handler[2] = ___ZN2re22AudioTelemetryReporter19initializeTimerWithEdPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFNS0_15TelemetryReportEvE_block_invoke;
  handler[3] = &unk_24ED3EB48;
  v11 = v7;
  v12 = a1;
  v9 = v7;
  dispatch_source_set_event_handler(v8, handler);
  dispatch_resume(object);

}

void sub_225418E1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
  void *v16;

  _Unwind_Resume(a1);
}

id re::DynamicArray<NSObject  {objcproto18OS_dispatch_source}* {__strong}>::add(_anonymous_namespace_ *this, id *a2)
{
  unint64_t v4;
  uint64_t v5;
  id result;

  v4 = *((_QWORD *)this + 2);
  if (v4 >= *((_QWORD *)this + 1))
  {
    re::DynamicArray<NSObject  {objcproto18OS_dispatch_source}* {__strong}>::growCapacity(this, v4 + 1);
    v4 = *((_QWORD *)this + 2);
  }
  v5 = *((_QWORD *)this + 4);
  result = *a2;
  *(_QWORD *)(v5 + 8 * v4) = result;
  ++*((_QWORD *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

void ___ZN2re22AudioTelemetryReporter19initializeTimerWithEdPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFNS0_15TelemetryReportEvE_block_invoke(uint64_t a1)
{
  NSObject **v1;
  void *v2;
  void *v3;
  id v4;
  id v5;
  id v6;

  v1 = *(NSObject ***)(a1 + 40);
  v6 = (id)(*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  v3 = v2;
  if (v2)
  {
    v4 = v6;
    v5 = v3;
    re::AudioTelemetryReporter::sendTelemetryReport(v1, v6, v3);
  }

}

void re::AudioTelemetryReporter::sendTelemetryReport(NSObject **a1, void *a2, void *a3)
{
  NSObject *v4;
  id v5;
  id v6;
  _QWORD v7[4];
  id v8;
  id v9;

  v4 = *a1;
  v7[0] = MEMORY[0x24BDAC760];
  v7[1] = 3321888768;
  v7[2] = ___ZN2re22AudioTelemetryReporter19sendTelemetryReportENS0_15TelemetryReportE_block_invoke;
  v7[3] = &__block_descriptor_48_ea8_32c50_ZTSN2re22AudioTelemetryReporter15TelemetryReportE_e5_v8__0l;
  v8 = a2;
  v9 = a3;
  v5 = a3;
  v6 = a2;
  dispatch_async(v4, v7);

}

void re::AudioTelemetryReporter::~AudioTelemetryReporter(id *this)
{
  NSObject *v2;
  id v3;
  _QWORD block[5];

  v2 = *this;
  block[0] = MEMORY[0x24BDAC760];
  block[1] = 3221225472;
  block[2] = ___ZN2re22AudioTelemetryReporterD2Ev_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = this;
  dispatch_sync(v2, block);
  v3 = *this;
  *this = 0;

  re::DynamicArray<re::ObjCObject>::deinit((uint64_t)(this + 1));
}

void ___ZN2re22AudioTelemetryReporterD2Ev_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  dispatch_source_t *v3;
  uint64_t v4;
  uint64_t v5;
  void **v6;
  uint64_t v7;
  void *v8;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(_QWORD *)(v1 + 24);
  if (v2)
  {
    v3 = *(dispatch_source_t **)(v1 + 40);
    v4 = 8 * v2;
    do
    {
      if (*v3)
        dispatch_source_cancel(*v3);
      ++v3;
      v4 -= 8;
    }
    while (v4);
    v5 = *(_QWORD *)(v1 + 24);
    v6 = *(void ***)(v1 + 40);
    *(_QWORD *)(v1 + 24) = 0;
    if (v5)
    {
      v7 = 8 * v5;
      do
      {
        v8 = *v6++;

        v7 -= 8;
      }
      while (v7);
    }
  }
  else
  {
    *(_QWORD *)(v1 + 24) = 0;
  }
  ++*(_DWORD *)(v1 + 32);
}

void ___ZN2re22AudioTelemetryReporter19sendTelemetryReportENS0_15TelemetryReportE_block_invoke(uint64_t a1)
{
  const char *v2;
  const char *v3;
  int v4;
  size_t v5;
  size_t v6;
  unint64_t v7;
  size_t v8;
  __int128 *p_dst;
  void **v10;
  char *v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD v15[5];
  __int128 __dst;
  unint64_t v17;
  uint64_t (*v18)(uint64_t, uint64_t);
  void (*v19)(uint64_t);
  id v20;
  void *__p[2];
  int64_t v22;

  std::string::basic_string[abi:ne180100]<0>(__p, "com.apple.re.tdgaudio.");
  v2 = (const char *)objc_msgSend(*(id *)(a1 + 32), "UTF8String");
  v3 = v2;
  v4 = SHIBYTE(v22);
  if (v22 >= 0)
    v5 = HIBYTE(v22);
  else
    v5 = (size_t)__p[1];
  v6 = strlen(v2);
  v7 = v5 + v6;
  if (v5 + v6 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v8 = v6;
  if (v7 <= 0x16)
  {
    v17 = 0;
    __dst = 0uLL;
    p_dst = &__dst;
    HIBYTE(v17) = v5 + v6;
    if (!v5)
      goto LABEL_11;
    goto LABEL_7;
  }
  v13 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
  if ((v7 | 7) != 0x17)
    v13 = v7 | 7;
  v14 = v13 + 1;
  p_dst = (__int128 *)operator new(v13 + 1);
  *((_QWORD *)&__dst + 1) = v7;
  v17 = v14 | 0x8000000000000000;
  *(_QWORD *)&__dst = p_dst;
  if (v5)
  {
LABEL_7:
    if (v4 >= 0)
      v10 = __p;
    else
      v10 = (void **)__p[0];
    memmove(p_dst, v10, v5);
  }
LABEL_11:
  v11 = (char *)p_dst + v5;
  if (v8)
    memmove(v11, v3, v8);
  v11[v8] = 0;
  if (v4 < 0)
    operator delete(__p[0]);
  *(_OWORD *)__p = __dst;
  v22 = v17;
  *(_QWORD *)&__dst = 0;
  *((_QWORD *)&__dst + 1) = &__dst;
  v17 = 0x3032000000;
  v18 = __Block_byref_object_copy__5;
  v19 = __Block_byref_object_dispose__5;
  v20 = xpc_dictionary_create(0, 0, 0);
  v12 = *(void **)(a1 + 40);
  v15[0] = MEMORY[0x24BDAC760];
  v15[1] = 3221225472;
  v15[2] = ___ZN2re22AudioTelemetryReporter19sendTelemetryReportENS0_15TelemetryReportE_block_invoke_3;
  v15[3] = &unk_24ED3EB70;
  v15[4] = &__dst;
  objc_msgSend(v12, "enumerateKeysAndObjectsUsingBlock:", v15);
  analytics_send_event_lazy();
  _Block_object_dispose(&__dst, 8);

  if (SHIBYTE(v22) < 0)
    operator delete(__p[0]);
}

void sub_2254192C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a30 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t __Block_byref_object_copy__5(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__5(uint64_t a1)
{

}

void ___ZN2re22AudioTelemetryReporter19sendTelemetryReportENS0_15TelemetryReportE_block_invoke_3(uint64_t a1, void *a2, void *a3)
{
  id v5;
  void *v6;
  const char *v7;
  double v8;
  id v9;

  v9 = a2;
  v5 = a3;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    xpc_dictionary_set_string(*(xpc_object_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), (const char *)objc_msgSend(objc_retainAutorelease(v9), "UTF8String"), (const char *)objc_msgSend(objc_retainAutorelease(v5), "UTF8String"));
  }
  else
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      v6 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
      v7 = (const char *)objc_msgSend(objc_retainAutorelease(v9), "UTF8String");
      objc_msgSend(v5, "doubleValue");
      xpc_dictionary_set_double(v6, v7, v8);
    }
    else
    {
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
        xpc_dictionary_set_int64(*(xpc_object_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), (const char *)objc_msgSend(objc_retainAutorelease(v9), "UTF8String"), (int)objc_msgSend(v5, "intValue"));
    }
  }

}

void sub_225419454(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

id ___ZN2re22AudioTelemetryReporter19sendTelemetryReportENS0_15TelemetryReportE_block_invoke_2(uint64_t a1)
{
  return *(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
}

id __copy_helper_block_ea8_32c50_ZTSN2re22AudioTelemetryReporter15TelemetryReportE(uint64_t a1, uint64_t a2)
{
  id result;

  *(_QWORD *)(a1 + 32) = *(id *)(a2 + 32);
  result = *(id *)(a2 + 40);
  *(_QWORD *)(a1 + 40) = result;
  return result;
}

void __destroy_helper_block_ea8_32c50_ZTSN2re22AudioTelemetryReporter15TelemetryReportE(uint64_t a1)
{

}

_QWORD *re::DynamicArray<NSObject  {objcproto18OS_dispatch_source}* {__strong}>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<REResourceSharingClientObject * {__strong}>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<REResourceSharingClientObject * {__strong}>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

re::AudioManager *re::AudioManager::AudioManager(re::AudioManager *this)
{
  uint64_t v2;
  id v3;
  id *v4;
  _REAudioManagerCancellable *v5;
  id v6;
  void *v7;
  NSObject *v8;
  id v9;
  _QWORD handler[4];
  id v12;
  re::AudioManager *v13;
  id *v14;

  *(_QWORD *)this = &unk_24ED3F020;
  v2 = MEMORY[0x24BDAC9B8];
  v3 = MEMORY[0x24BDAC9B8];
  *(_QWORD *)this = &unk_24ED3EBF8;
  *((_QWORD *)this + 1) = v2;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_DWORD *)this + 12) = 1065353216;
  *((_BYTE *)this + 56) = 0;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_DWORD *)this + 28) = 1065353216;
  *((_BYTE *)this + 128) = 0;
  *((_BYTE *)this + 208) = 0;
  *((_OWORD *)this + 14) = 0u;
  *((_OWORD *)this + 15) = 0u;
  *((_DWORD *)this + 64) = 1065353216;
  *((_QWORD *)this + 33) = 0;
  *((_BYTE *)this + 272) = 0;
  *((_DWORD *)this + 72) = 0;
  *((_BYTE *)this + 292) = 0;
  *((_QWORD *)this + 43) = 0;
  *(_OWORD *)((char *)this + 312) = 0u;
  *(_OWORD *)((char *)this + 328) = 0u;
  *(_OWORD *)((char *)this + 296) = 0u;
  *((_DWORD *)this + 88) = 1065353216;
  re::AudioSessionCache::AudioSessionCache((NSObject **)this + 45);
  *((_OWORD *)this + 27) = 0u;
  *((_OWORD *)this + 28) = 0u;
  *((_DWORD *)this + 116) = 1065353216;
  *((_QWORD *)this + 60) = 0;
  *((_QWORD *)this + 61) = 0;
  *((_QWORD *)this + 59) = 0;
  v4 = (id *)operator new();
  *v4 = 0;
  v5 = objc_alloc_init(_REAudioManagerCancellable);
  v6 = *v4;
  *v4 = v5;

  objc_msgSend(*v4, "setAudioService:", this);
  v14 = 0;
  std::unique_ptr<re::AudioManager::PrivateData>::reset[abi:ne180100]((id **)this + 39, v4);
  std::unique_ptr<re::AudioManager::PrivateData>::reset[abi:ne180100](&v14, 0);
  re::AudioManager::updateSharedAcousticPropertiesFromDefaults(this);
  (*(void (**)(re::AudioManager *))(*(_QWORD *)this + 616))(this);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  v8 = *((_QWORD *)this + 1);
  handler[0] = MEMORY[0x24BDAC760];
  handler[1] = 3221225472;
  handler[2] = ___ZN2re12AudioManagerC2Ev_block_invoke;
  handler[3] = &unk_24ED3EFC8;
  v12 = v7;
  v13 = this;
  v9 = v7;
  notify_register_dispatch("com.apple.re.acousticProperties", (int *)this + 72, v8, handler);

  return this;
}

void sub_2254197A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  id **v17;
  re::AudioSessionCache *v18;
  void *v19;
  void *v20;

  v20 = v19;

  re::InsertionOrderedMap<unsigned long long,__CFString const*,std::hash<unsigned long long>,std::equal_to<unsigned long long>>::~InsertionOrderedMap(v14 + 432);
  re::AudioSessionCache::~AudioSessionCache(v18);
  std::__hash_table<std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>,std::__unordered_map_hasher<REAudioServicesNotificationCallbackConfiguration,std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>,REAudioServicesNotificationCallbackRegistry::ConfigHasher,std::equal_to<REAudioServicesNotificationCallbackConfiguration>,true>,std::__unordered_map_equal<REAudioServicesNotificationCallbackConfiguration,std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>,std::equal_to<REAudioServicesNotificationCallbackConfiguration>,REAudioServicesNotificationCallbackRegistry::ConfigHasher,true>,std::allocator<std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>>>::~__hash_table(v14 + 320);
  std::unique_ptr<re::AudioManager::PrivateData>::reset[abi:ne180100](v17, 0);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned short>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned short>>>::~__hash_table(v16);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned short>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned short>>>::~__hash_table(v14 + 80);

  std::__hash_table<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>>>::~__hash_table(v15);
  _Unwind_Resume(a1);
}

void re::AudioManager::updateSharedAcousticPropertiesFromDefaults(re::AudioManager *this)
{
  void *v2;
  void *v3;
  void *v4;
  float v5;
  float v6;
  re *v7;
  float v8;
  NSObject *v9;
  void *v10;
  void *v11;
  float v12;
  float v13;
  re *v14;
  float v15;
  NSObject *v16;
  void *v17;
  void *v18;
  float v19;
  float v20;
  float v21;
  NSObject *v22;
  NSObject *v23;
  double v24;
  double v25;
  double v26;
  double v27;
  float v28;
  double v29;
  float v30;
  double v31;
  float v32;
  int v33;
  double v34;
  __int16 v35;
  double v36;
  __int16 v37;
  double v38;
  uint64_t v39;

  v39 = *MEMORY[0x24BDAC8D0];
  objc_msgSend(MEMORY[0x24BDBCF50], "standardUserDefaults");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  *((_DWORD *)this + 71) = 1065353216;
  objc_msgSend(v2, "objectForKey:", CFSTR("com.apple.re.voiceGain_PHASE_dB"));
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v4 = v3;
  if (v3)
  {
    objc_msgSend(v3, "floatValue");
    v6 = fminf(v5, 10.0);
    *((float *)this + 69) = v6;
    v7 = (re *)objc_msgSend(v4, "floatValue");
    if (v6 != v8)
    {
      v9 = (id)*re::audioLogObjects(v7);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        objc_msgSend(v4, "floatValue");
        v27 = *((float *)this + 69);
        v33 = 134218240;
        v34 = v28;
        v35 = 2048;
        v36 = v27;
        _os_log_error_impl(&dword_224FE9000, v9, OS_LOG_TYPE_ERROR, "Clamping provided PHASE voice level correction %f dB to %f dB", (uint8_t *)&v33, 0x16u);
      }

    }
  }
  else
  {
    *((_DWORD *)this + 69) = 0;
  }
  objc_msgSend(v2, "objectForKey:", CFSTR("com.apple.re.sharedReverbSendLevel_PHASE_dB"));
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  v11 = v10;
  if (v10)
  {
    objc_msgSend(v10, "floatValue");
    v13 = fminf(v12, 20.0);
    *((float *)this + 70) = v13;
    v14 = (re *)objc_msgSend(v11, "floatValue");
    if (v13 != v15)
    {
      v16 = (id)*re::audioLogObjects(v14);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        objc_msgSend(v11, "floatValue");
        v29 = *((float *)this + 70);
        v33 = 134218240;
        v34 = v30;
        v35 = 2048;
        v36 = v29;
        _os_log_error_impl(&dword_224FE9000, v16, OS_LOG_TYPE_ERROR, "Clamping provided PHASE shared reverb send level %f dB to %f dB", (uint8_t *)&v33, 0x16u);
      }

    }
  }
  else if (_os_feature_enabled_impl())
  {
    *((_DWORD *)this + 70) = 0;
  }
  else
  {
    *((_DWORD *)this + 70) = -1046478848;
  }
  objc_msgSend(v2, "objectForKey:", CFSTR("com.apple.re.sharedReferenceDistance"));
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = v17;
  if (v17)
  {
    objc_msgSend(v17, "floatValue");
    v20 = fmaxf(fminf(v19, 1.5), 0.2);
    *((float *)this + 71) = v20;
    v17 = (void *)objc_msgSend(v18, "floatValue");
    if (v20 != v21)
    {
      v22 = (id)*re::audioLogObjects((re *)v17);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        objc_msgSend(v18, "floatValue");
        v31 = *((float *)this + 71);
        v33 = 134218240;
        v34 = v32;
        v35 = 2048;
        v36 = v31;
        _os_log_error_impl(&dword_224FE9000, v22, OS_LOG_TYPE_ERROR, "Clamping provided reference distance %f m to %f m", (uint8_t *)&v33, 0x16u);
      }

    }
  }
  v23 = *re::audioLogObjects((re *)v17);
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    v24 = *((float *)this + 70);
    v25 = *((float *)this + 69);
    v26 = *((float *)this + 71);
    v33 = 134218496;
    v34 = v24;
    v35 = 2048;
    v36 = v25;
    v37 = 2048;
    v38 = v26;
    _os_log_impl(&dword_224FE9000, v23, OS_LOG_TYPE_DEFAULT, "Applying %f dB reverb send for PHASE control path, %f dB voice gain for PHASE control path, and %f m reference distance", (uint8_t *)&v33, 0x20u);
  }

}

void sub_225419BBC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void ___ZN2re12AudioManagerC2Ev_block_invoke(uint64_t a1)
{
  re::AudioManager *v1;
  re *v2;
  NSObject *v3;
  uint8_t v4[16];

  v1 = *(re::AudioManager **)(a1 + 40);
  v2 = (re *)objc_msgSend(*(id *)(a1 + 32), "isCancelled");
  if ((_DWORD)v2)
  {
    v3 = *re::audioLogObjects(v2);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)v4 = 0;
      _os_log_debug_impl(&dword_224FE9000, v3, OS_LOG_TYPE_DEBUG, "Aborting callback since the engine was shut down.", v4, 2u);
    }
  }
  else
  {
    re::AudioManager::updateSharedAcousticPropertiesFromDefaults(v1);
    *((_BYTE *)v1 + 292) = 1;
  }
}

uint64_t re::InsertionOrderedMap<unsigned long long,__CFString const*,std::hash<unsigned long long>,std::equal_to<unsigned long long>>::~InsertionOrderedMap(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(_QWORD *)(a1 + 48) = v2;
    operator delete(v2);
  }
  return std::__hash_table<std::__hash_value_type<unsigned long long,unsigned short>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned short>>>::~__hash_table(a1);
}

void re::AudioSessionCache::~AudioSessionCache(re::AudioSessionCache *this)
{
  re::HashTable<unsigned int,re::AudioSessionCache::CacheState,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::deinit((uint64_t *)this + 1);

}

void re::AudioManager::~AudioManager(re::AudioManager *this)
{
  _QWORD *i;
  const void *v3;
  unint64_t *v4;
  unint64_t *v5;
  const void *v6;
  const void *v7;
  CFTypeRef *j;
  CFTypeRef *k;
  void *v10;

  *(_QWORD *)this = &unk_24ED3EBF8;
  for (i = (_QWORD *)*((_QWORD *)this + 4); i; i = (_QWORD *)*i)
  {
    v3 = (const void *)i[12];
    if (v3)
      CFRelease(v3);
  }
  v4 = (unint64_t *)*((_QWORD *)this + 59);
  v5 = (unint64_t *)*((_QWORD *)this + 60);
  while (v4 != v5)
  {
    v6 = (const void *)std::__hash_table<std::__hash_value_type<unsigned long long,__CFString const*>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,__CFString const*>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,__CFString const*>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,__CFString const*>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t)this + 432, *v4, v4)[3];
    if (v6)
      CFRelease(v6);
    ++v4;
  }
  v7 = (const void *)*((_QWORD *)this + 8);
  if (v7)
    CFRelease(v7);
  for (j = (CFTypeRef *)((char *)this + 96); ; CFRelease(j[3]))
  {
    j = (CFTypeRef *)*j;
    if (!j)
      break;
  }
  for (k = (CFTypeRef *)((char *)this + 240); ; CFRelease(k[2]))
  {
    k = (CFTypeRef *)*k;
    if (!k)
      break;
  }
  notify_cancel(*((_DWORD *)this + 72));
  v10 = (void *)*((_QWORD *)this + 59);
  if (v10)
  {
    *((_QWORD *)this + 60) = v10;
    operator delete(v10);
  }
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned short>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned short>>>::~__hash_table((uint64_t)this + 432);
  re::HashTable<unsigned int,re::AudioSessionCache::CacheState,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::deinit((uint64_t *)this + 46);

  std::__hash_table<std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>,std::__unordered_map_hasher<REAudioServicesNotificationCallbackConfiguration,std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>,REAudioServicesNotificationCallbackRegistry::ConfigHasher,std::equal_to<REAudioServicesNotificationCallbackConfiguration>,true>,std::__unordered_map_equal<REAudioServicesNotificationCallbackConfiguration,std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>,std::equal_to<REAudioServicesNotificationCallbackConfiguration>,REAudioServicesNotificationCallbackRegistry::ConfigHasher,true>,std::allocator<std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>>>::~__hash_table((uint64_t)this + 320);
  std::unique_ptr<re::AudioManager::PrivateData>::reset[abi:ne180100]((id **)this + 39, 0);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned short>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned short>>>::~__hash_table((uint64_t)this + 224);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned short>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned short>>>::~__hash_table((uint64_t)this + 80);

  std::__hash_table<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>>>::~__hash_table((uint64_t)this + 16);
}

void re::AudioManager::addServiceNotificationCallback(uint64_t *a1, uint64_t a2, uint64_t a3, void *a4)
{
  __int128 v5;

  *(_QWORD *)&v5 = a2;
  *((_QWORD *)&v5 + 1) = a3;
  REAudioServicesNotificationCallbackRegistry::registerCallback(a1 + 40, &v5, a4);
  if ((unint64_t)(char)v5 <= 5 && ((0x37u >> v5) & 1) != 0 && BYTE1(v5) == 3)
    (*(void (**)(uint64_t *, _QWORD, _QWORD))(*a1 + 96))(a1, dword_226100BCC[(char)v5], *((_QWORD *)&v5 + 1));
}

uint64_t *re::AudioManager::removeServiceNotificationCallback(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t *result;
  uint64_t v5;
  uint64_t v6;

  v5 = a2;
  v6 = a3;
  result = REAudioServicesNotificationCallbackRegistry::unregisterCallback(a1 + 40, (unsigned __int8 *)&v5);
  if ((unint64_t)(char)v5 <= 5 && ((0x37u >> v5) & 1) != 0 && BYTE1(v5) == 3)
    return (uint64_t *)(*(uint64_t (**)(_QWORD *, _QWORD, uint64_t))(*a1 + 104))(a1, dword_226100BCC[(char)v5], v6);
  return result;
}

void re::AudioManager::clearAllRenderingState(re::AudioManager *this)
{
  _QWORD *i;
  const void *v3;

  for (i = (_QWORD *)*((_QWORD *)this + 4); i; i = (_QWORD *)*i)
  {
    v3 = (const void *)i[12];
    if (v3)
      CFRelease(v3);
  }
  std::__hash_table<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>>>::clear((uint64_t)this + 16);
  re::AudioSessionCache::clear((os_unfair_lock_s *)this + 90);
}

void re::AudioManager::triggerServiceReset(re::AudioManager *this)
{
  NSObject *v2;
  const void **i;
  const void **v4;
  void (**v5)(void);
  void **p_buf;
  __int128 buf;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v2 = *re::audioLogObjects(this);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 134217984;
    *(_QWORD *)((char *)&buf + 4) = this;
    _os_log_impl(&dword_224FE9000, v2, OS_LOG_TYPE_DEFAULT, "AudioManager %p clearing state and triggering reset callbacks", (uint8_t *)&buf, 0xCu);
  }
  (*(void (**)(re::AudioManager *))(*(_QWORD *)this + 856))(this);
  (*(void (**)(re::AudioManager *))(*(_QWORD *)this + 904))(this);
  REAudioServicesNotificationCallbackRegistry::getCallbacksForType((uint64_t)this + 320, 3, (uint64_t **)&buf);
  v4 = (const void **)*((_QWORD *)&buf + 1);
  for (i = (const void **)buf; i != v4; ++i)
  {
    v5 = (void (**)(void))_Block_copy(*i);
    v5[2]();

  }
  p_buf = (void **)&buf;
  std::vector<NSError * {__strong}>::__destroy_vector::operator()[abi:ne180100](&p_buf);
}

void sub_22541A0AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, char a11)
{
  void *v11;

  a10 = (void **)&a11;
  std::vector<NSError * {__strong}>::__destroy_vector::operator()[abi:ne180100](&a10);
  _Unwind_Resume(a1);
}

void re::AudioManager::triggerServiceLost(re::AudioManager *this)
{
  const void **v1;
  uint64_t *v2;
  void (**v3)(void);
  uint64_t *v4[3];
  void **v5;

  REAudioServicesNotificationCallbackRegistry::getCallbacksForType((uint64_t)this + 320, 2, v4);
  v1 = (const void **)v4[0];
  v2 = v4[1];
  while (v1 != (const void **)v2)
  {
    v3 = (void (**)(void))_Block_copy(*v1);
    v3[2]();

    ++v1;
  }
  v5 = (void **)v4;
  std::vector<NSError * {__strong}>::__destroy_vector::operator()[abi:ne180100](&v5);
}

void sub_22541A148(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  void *v12;

  a12 = (void **)&a9;
  std::vector<NSError * {__strong}>::__destroy_vector::operator()[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

void re::AudioManager::forceShutdown(id **this)
{
  objc_msgSend(*this[39], "cancel");
  std::__hash_table<std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>,std::__unordered_map_hasher<REAudioServicesNotificationCallbackConfiguration,std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>,REAudioServicesNotificationCallbackRegistry::ConfigHasher,std::equal_to<REAudioServicesNotificationCallbackConfiguration>,true>,std::__unordered_map_equal<REAudioServicesNotificationCallbackConfiguration,std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>,std::equal_to<REAudioServicesNotificationCallbackConfiguration>,REAudioServicesNotificationCallbackRegistry::ConfigHasher,true>,std::allocator<std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>>>::clear((uint64_t)(this + 40));
}

id re::AudioManager::engineCancellable(id **this)
{
  return *this[39];
}

void re::AudioManager::beforeFrameUpdate(re::AudioManager *this)
{
  _QWORD *i;
  _QWORD *j;

  for (i = (_QWORD *)*((_QWORD *)this + 4); i; i = (_QWORD *)*i)
  {
    for (j = (_QWORD *)i[9]; j; j = (_QWORD *)*j)
      std::__hash_table<std::__hash_value_type<std::string,double>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,double>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,double>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,double>>>::clear((uint64_t)(j + 8));
  }
}

void re::AudioManager::afterFrameUpdate(re::AudioManager *this)
{
  unint64_t v1;
  size_t v3;
  uint64_t *v4;
  unint64_t v5;
  int v6;
  uint64_t v7;
  unint64_t v8;
  __int128 v9;
  __int128 v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint8x8_t v14;
  _QWORD *v15;
  _QWORD *i;
  unint64_t v17;
  char *v18;
  __int128 v19;
  __int128 v20;
  float v21;
  _BOOL8 v22;
  unint64_t v23;
  unint64_t v24;
  size_t v25;
  uint64_t v26;
  _QWORD *v27;
  unint64_t v28;
  id v29;
  _QWORD *v30;
  void *v31;
  void *v32;
  void *v33;
  id v34;
  void *v35;
  re *v36;
  NSObject *v37;
  CFTypeRef *j;
  _QWORD *v39;
  _QWORD *v40;
  uint64_t v41;
  uint64_t k;
  char *v43;
  _QWORD *v44;
  id v45;
  id v46;
  __int128 v47;
  __int128 v48;
  float v49;
  const __CFString *v50;
  void *v51;
  _BYTE buf[72];
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  *((_BYTE *)this + 292) = 0;
  if (*((_BYTE *)this + 208))
  {
    v43 = (char *)this + 128;
    v3 = *((_QWORD *)this + 31);
  }
  else
  {
    v3 = *((_QWORD *)this + 31);
    if (!v3)
      goto LABEL_72;
    v43 = 0;
  }
  v47 = 0u;
  v48 = 0u;
  v49 = 1.0;
  std::__hash_table<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>>>::__rehash<true>((uint64_t)&v47, v3);
  v4 = (uint64_t *)*((_QWORD *)this + 30);
  v44 = (_QWORD *)((char *)this + 240);
  if (v4)
  {
    v5 = *((_QWORD *)&v47 + 1);
    do
    {
      v6 = *((_DWORD *)v4 + 24);
      v7 = *(uint64_t *)((char *)v4 + 100);
      v8 = v4[2];
      v9 = *((_OWORD *)v4 + 3);
      *(_OWORD *)&buf[8] = *((_OWORD *)v4 + 2);
      *(_OWORD *)&buf[24] = v9;
      v10 = *((_OWORD *)v4 + 5);
      *(_OWORD *)&buf[40] = *((_OWORD *)v4 + 4);
      *(_OWORD *)&buf[56] = v10;
      v11 = 0x9DDFEA08EB382D69 * (((8 * v8) + 8) ^ HIDWORD(v8));
      v12 = 0x9DDFEA08EB382D69 * (HIDWORD(v8) ^ (v11 >> 47) ^ v11);
      v13 = 0x9DDFEA08EB382D69 * (v12 ^ (v12 >> 47));
      if (v5)
      {
        v14 = (uint8x8_t)vcnt_s8((int8x8_t)v5);
        v14.i16[0] = vaddlv_u8(v14);
        if (v14.u32[0] > 1uLL)
        {
          v1 = 0x9DDFEA08EB382D69 * (v12 ^ (v12 >> 47));
          if (v13 >= v5)
            v1 = v13 % v5;
        }
        else
        {
          v1 = v13 & (v5 - 1);
        }
        v15 = *(_QWORD **)(v47 + 8 * v1);
        if (v15)
        {
          for (i = (_QWORD *)*v15; i; i = (_QWORD *)*i)
          {
            v17 = i[1];
            if (v17 == v13)
            {
              if (i[2] == v8)
                goto LABEL_46;
            }
            else
            {
              if (v14.u32[0] > 1uLL)
              {
                if (v17 >= v5)
                  v17 %= v5;
              }
              else
              {
                v17 &= v5 - 1;
              }
              if (v17 != v1)
                break;
            }
          }
        }
      }
      v18 = (char *)operator new(0x70uLL);
      v19 = *(_OWORD *)buf;
      *(_OWORD *)(v18 + 40) = *(_OWORD *)&buf[16];
      v20 = *(_OWORD *)&buf[48];
      *(_OWORD *)(v18 + 56) = *(_OWORD *)&buf[32];
      *(_OWORD *)(v18 + 72) = v20;
      *(_QWORD *)v18 = 0;
      *((_QWORD *)v18 + 1) = v13;
      *((_QWORD *)v18 + 2) = v8;
      *((_QWORD *)v18 + 11) = *(_QWORD *)&buf[64];
      *(_OWORD *)(v18 + 24) = v19;
      *((_DWORD *)v18 + 24) = v6;
      *(_QWORD *)(v18 + 100) = v7;
      v21 = (float)(unint64_t)(*((_QWORD *)&v48 + 1) + 1);
      if (!v5 || (float)(v49 * (float)v5) < v21)
      {
        v22 = v5 < 3 || (v5 & (v5 - 1)) != 0;
        v23 = v22 | (2 * v5);
        v24 = vcvtps_u32_f32(v21 / v49);
        if (v23 <= v24)
          v25 = v24;
        else
          v25 = v23;
        std::__hash_table<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>>>::__rehash<true>((uint64_t)&v47, v25);
        v5 = *((_QWORD *)&v47 + 1);
        if ((*((_QWORD *)&v47 + 1) & (*((_QWORD *)&v47 + 1) - 1)) != 0)
        {
          if (v13 >= *((_QWORD *)&v47 + 1))
            v1 = v13 % *((_QWORD *)&v47 + 1);
          else
            v1 = v13;
        }
        else
        {
          v1 = (*((_QWORD *)&v47 + 1) - 1) & v13;
        }
      }
      v26 = v47;
      v27 = *(_QWORD **)(v47 + 8 * v1);
      if (v27)
      {
        *(_QWORD *)v18 = *v27;
      }
      else
      {
        *(_QWORD *)v18 = v48;
        *(_QWORD *)&v48 = v18;
        *(_QWORD *)(v26 + 8 * v1) = &v48;
        if (!*(_QWORD *)v18)
          goto LABEL_45;
        v28 = *(_QWORD *)(*(_QWORD *)v18 + 8);
        if ((v5 & (v5 - 1)) != 0)
        {
          if (v28 >= v5)
            v28 %= v5;
        }
        else
        {
          v28 &= v5 - 1;
        }
        v27 = (_QWORD *)(v47 + 8 * v28);
      }
      *v27 = v18;
LABEL_45:
      ++*((_QWORD *)&v48 + 1);
LABEL_46:
      v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    v29 = objc_alloc_init(MEMORY[0x24BDBCED8]);
    v30 = (_QWORD *)*v44;
    if (*v44)
    {
      do
      {
        if (*((_BYTE *)v30 + 108))
          v31 = &unk_24EDB7A78;
        else
          v31 = &unk_24EDB7A90;
        v50 = CFSTR("STSAdditionalLabelInfoKey_DeferToSystemTuning");
        v51 = v31;
        objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", &v51, &v50, 1);
        v32 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v29, "setObject:forKeyedSubscript:", v32, v30[2]);

        v30 = (_QWORD *)*v30;
      }
      while (v30);
    }
    v33 = (void *)*((_QWORD *)this + 9);
    v46 = 0;
    objc_msgSend(v33, "updateGlobalState:labelStates:additionalLabelInfo:error:", v43, &v47, v29, &v46);
    v34 = v46;

    if (!v34)
      goto LABEL_59;
    goto LABEL_56;
  }
  v35 = (void *)*((_QWORD *)this + 9);
  v45 = 0;
  objc_msgSend(v35, "updateGlobalState:labelStates:error:", v43, &v47, &v45);
  v34 = v45;
  if (v34)
  {
LABEL_56:
    v36 = (re *)(*(uint64_t (**)(re::AudioManager *))(*(_QWORD *)this + 112))(this);
    if ((_DWORD)v36)
    {
      v37 = *re::audioLogObjects(v36);
      if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_224FE9000, v37, OS_LOG_TYPE_ERROR, "[RE/STS] failed to update STS states", buf, 2u);
      }
    }
  }
LABEL_59:
  if (*((_BYTE *)this + 208))
    *((_BYTE *)this + 208) = 0;
  for (j = (CFTypeRef *)((char *)this + 240); ; CFRelease(j[2]))
  {
    j = (CFTypeRef *)*j;
    if (!j)
      break;
  }
  if (*((_QWORD *)this + 31))
  {
    v39 = (_QWORD *)*v44;
    if (*v44)
    {
      do
      {
        v40 = (_QWORD *)*v39;
        operator delete(v39);
        v39 = v40;
      }
      while (v40);
    }
    *((_QWORD *)this + 30) = 0;
    v41 = *((_QWORD *)this + 29);
    if (v41)
    {
      for (k = 0; k != v41; ++k)
        *(_QWORD *)(*((_QWORD *)this + 28) + 8 * k) = 0;
    }
    *((_QWORD *)this + 31) = 0;
  }
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned short>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned short>>>::~__hash_table((uint64_t)&v47);

LABEL_72:
  re::AudioSessionCache::update((os_unfair_lock_s *)this + 90);
}

void sub_22541A6D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  void *v7;
  va_list va;

  va_start(va, a7);

  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned short>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned short>>>::~__hash_table((uint64_t)va);
  _Unwind_Resume(a1);
}

void re::AudioManager::setMixGroupEffectiveGain(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t *a5)
{
  unint64_t v5;
  _QWORD *v9;
  char *v10;
  uint64_t *v11;
  _QWORD *v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint8x8_t v16;
  unint64_t v17;
  char **v18;
  char *i;
  unint64_t v20;
  char *v21;
  float v27;
  float v28;
  _BOOL8 v29;
  unint64_t v30;
  unint64_t v31;
  size_t v32;
  uint64_t v33;
  _QWORD *v34;
  _QWORD *v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t *v41;

  v39 = a3;
  v40 = a2;
  v41 = &v40;
  v9 = std::__hash_table<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(a1 + 16, &v40, (uint64_t)&std::piecewise_construct, &v41);
  v10 = std::__hash_table<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene::PerConnectionState>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene::PerConnectionState>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene::PerConnectionState>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene::PerConnectionState>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v9 + 7, a3, &v39);
  v11 = (uint64_t *)(v10 + 24);
  v12 = v10 + 48;
  v13 = std::__string_hash<char>::operator()[abi:ne180100]((uint64_t)(v10 + 48), a4);
  v14 = v13;
  v15 = *((_QWORD *)v10 + 4);
  if (v15)
  {
    v16 = (uint8x8_t)vcnt_s8((int8x8_t)v15);
    v16.i16[0] = vaddlv_u8(v16);
    v17 = v16.u32[0];
    if (v16.u32[0] > 1uLL)
    {
      v5 = v13;
      if (v13 >= v15)
        v5 = v13 % v15;
    }
    else
    {
      v5 = (v15 - 1) & v13;
    }
    v18 = *(char ***)(*((_QWORD *)v10 + 3) + 8 * v5);
    if (v18)
    {
      for (i = *v18; i; i = *(char **)i)
      {
        v20 = *((_QWORD *)i + 1);
        if (v20 == v14)
        {
          if ((std::equal_to<std::string>::operator()[abi:ne180100]((uint64_t)(v10 + 56), (unsigned __int8 *)i + 16, (unsigned __int8 *)a4) & 1) != 0)goto LABEL_44;
        }
        else
        {
          if (v17 > 1)
          {
            if (v20 >= v15)
              v20 %= v15;
          }
          else
          {
            v20 &= v15 - 1;
          }
          if (v20 != v5)
            break;
        }
      }
    }
    v11 = (uint64_t *)(v10 + 24);
    v12 = v10 + 48;
  }
  v21 = (char *)operator new(0x38uLL);
  i = v21;
  *(_QWORD *)v21 = 0;
  *((_QWORD *)v21 + 1) = v14;
  if (*(char *)(a4 + 23) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)(v21 + 16), *(const std::string::value_type **)a4, *(_QWORD *)(a4 + 8));
  }
  else
  {
    *((_OWORD *)v21 + 1) = *(_OWORD *)a4;
    *((_QWORD *)v21 + 4) = *(_QWORD *)(a4 + 16);
  }
  *((_DWORD *)i + 12) = 0;
  __asm { FMOV            V0.2S, #1.0 }
  *((_QWORD *)i + 5) = _D0;
  v27 = (float)(unint64_t)(*((_QWORD *)v10 + 6) + 1);
  v28 = *((float *)v10 + 14);
  if (!v15 || (float)(v28 * (float)v15) < v27)
  {
    v29 = 1;
    if (v15 >= 3)
      v29 = (v15 & (v15 - 1)) != 0;
    v30 = v29 | (2 * v15);
    v31 = vcvtps_u32_f32(v27 / v28);
    if (v30 <= v31)
      v32 = v31;
    else
      v32 = v30;
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>((uint64_t)v11, v32);
    v15 = *((_QWORD *)v10 + 4);
    if ((v15 & (v15 - 1)) != 0)
    {
      if (v14 >= v15)
        v5 = v14 % v15;
      else
        v5 = v14;
    }
    else
    {
      v5 = (v15 - 1) & v14;
    }
  }
  v33 = *v11;
  v34 = *(_QWORD **)(*v11 + 8 * v5);
  if (v34)
  {
    *(_QWORD *)i = *v34;
LABEL_42:
    *v34 = i;
    goto LABEL_43;
  }
  v36 = *((_QWORD *)v10 + 5);
  v35 = v10 + 40;
  *(_QWORD *)i = v36;
  *v35 = i;
  *(_QWORD *)(v33 + 8 * v5) = v35;
  if (*(_QWORD *)i)
  {
    v37 = *(_QWORD *)(*(_QWORD *)i + 8);
    if ((v15 & (v15 - 1)) != 0)
    {
      if (v37 >= v15)
        v37 %= v15;
    }
    else
    {
      v37 &= v15 - 1;
    }
    v34 = (_QWORD *)(*v11 + 8 * v37);
    goto LABEL_42;
  }
LABEL_43:
  ++*v12;
LABEL_44:
  v38 = *a5;
  *((_WORD *)i + 24) = *((_WORD *)a5 + 4);
  *((_QWORD *)i + 5) = v38;
}

void sub_22541AA00(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void re::AudioManager::updateSourceState(re::AudioManager *this, const re::AudioSourceState *a2)
{
  int v4;
  void (*v5)(re::AudioManager *, const re::AudioSourceState *);
  unint64_t v6;
  unint64_t v7;
  uint64_t *v8;
  re *v9;
  void *v10;
  id v11;
  NSObject *v12;
  uint64_t v13;
  CFMutableDictionaryRef Mutable;
  __CFString *v15;
  const char *v16;
  __CFString *v17;
  void *v18;
  void *v19;
  re *v20;
  NSObject *v21;
  uint64_t v22;
  void *v23;
  unsigned __int8 v24;
  re *ShouldConfigureTuningForSTSLabels;
  NSObject *v26;
  uint64_t v27;
  uint64_t v28;
  re *v29;
  NSObject *v30;
  float v31;
  uint64_t v32;
  re *VTable;
  uint64_t (*v34)(uint64_t, uint64_t, uint64_t, CFDataRef);
  NSObject *v35;
  uint64_t v36;
  re *v37;
  int v38;
  NSObject *v39;
  NSObject *v40;
  uint64_t v41;
  re *v42;
  uint64_t (*v43)(uint64_t, uint64_t, uint64_t, CFDataRef);
  NSObject *v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  float v50;
  float v51;
  unint64_t v52;
  unint64_t v53;
  char *v54;
  uint64_t *v55;
  char v56;
  _QWORD *v57;
  float v58;
  float v59;
  float v60;
  float v61;
  float v62;
  float v63;
  float v64;
  float v65;
  uint64_t v66;
  char *v67;
  uint64_t HexCFStringForInt;
  int v69;
  uint64_t v70;
  const __CFAllocator *allocator;
  int allocatora;
  CFDataRef cf;
  CFDataRef cfa;
  int v75;
  UInt8 v76[8];
  int v77;
  UInt8 bytes[4];
  _BYTE v79[12];
  __int16 v80;
  char *v81;
  char v82;
  _BYTE buf[32];
  __int128 v84;
  __int128 v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;

  v88 = *MEMORY[0x24BDAC8D0];
  v4 = (*(uint64_t (**)(re::AudioManager *))(*(_QWORD *)this + 920))(this);
  if (*((_QWORD *)a2 + 56) == -1)
  {
    *((_QWORD *)a2 + 93) = 0;
    return;
  }
  if (!*((_QWORD *)a2 + 5) && *(_OWORD *)((char *)a2 + 232) != 0)
  {
    if (*((_BYTE *)this + 272))
    {
      *((_QWORD *)a2 + 93) = *((_QWORD *)a2 + 29);
      v5 = *(void (**)(re::AudioManager *, const re::AudioSourceState *))(*(_QWORD *)this + 936);
LABEL_18:
      v5(this, a2);
      return;
    }
    return;
  }
  v6 = *((_QWORD *)a2 + 32);
  if ((v6 & 1) != 0)
    v7 = v6 >> 1;
  else
    v7 = v6 >> 1;
  if (!v7)
  {
    if (v4)
      (*(void (**)(re::AudioManager *, const re::AudioSourceState *))(*(_QWORD *)this + 912))(this, a2);
    v5 = *(void (**)(re::AudioManager *, const re::AudioSourceState *))(*(_QWORD *)this + 928);
    goto LABEL_18;
  }
  if (*((_QWORD *)this + 8))
  {
    v8 = (uint64_t *)((char *)a2 + 448);
    v9 = (re *)std::__hash_table<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>>>::find<unsigned long long>((_QWORD *)this + 2, (unint64_t *)a2 + 56);
    if (v9 && (v10 = (void *)*((_QWORD *)v9 + 12)) != 0)
    {
      v11 = v10;
    }
    else
    {
      v12 = *re::audioLogObjects(v9);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        v13 = *v8;
        *(_DWORD *)buf = 134217984;
        *(_QWORD *)&buf[4] = v13;
        _os_log_impl(&dword_224FE9000, v12, OS_LOG_TYPE_DEFAULT, "[RE/STS] Creating sts-label-count dictionary for scene %llu", buf, 0xCu);
      }
      Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 1, MEMORY[0x24BDBD2A8], MEMORY[0x24BDBD6B0]);
      *(_QWORD *)buf = (char *)a2 + 448;
      std::__hash_table<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t)this + 16, (unint64_t *)a2 + 56, (uint64_t)&std::piecewise_construct, (_QWORD **)buf)[12] = Mutable;
      v11 = (id)std::__hash_table<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>>>::find<unsigned long long>((_QWORD *)this + 2, (unint64_t *)a2 + 56)[12];
      if (!v11)
      {
        v35 = *re::audioLogObjects(0);
        if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
        {
          v36 = *v8;
          *(_DWORD *)buf = 134217984;
          *(_QWORD *)&buf[4] = v36;
          _os_log_error_impl(&dword_224FE9000, v35, OS_LOG_TYPE_ERROR, "[RE/STS] Could not find sts-label-count dictionary for scene ID %llu", buf, 0xCu);
        }
        return;
      }
    }
    v15 = (__CFString *)*((id *)a2 + 98);
    if (!v15)
    {
      if ((*((_QWORD *)a2 + 32) & 1) != 0)
        v16 = (const char *)*((_QWORD *)a2 + 33);
      else
        v16 = (char *)a2 + 257;
      v17 = (__CFString *)CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x24BDBD240], v16, 0x8000100u);
      *((_QWORD *)a2 + 98) = v17;
      if (!v17)
      {
        snprintf(buf, 0x64uLL, "badlabel%llu", *((_QWORD *)a2 + 85));
        std::string::basic_string[abi:ne180100]<0>(v79, buf);
        v37 = (re *)re::audio::throttledLog(OS_LOG_TYPE_ERROR, (__int128 *)v79);
        v38 = (int)v37;
        if (v82 < 0)
          operator delete(*(void **)v79);
        if (v38)
        {
          v39 = (id)*re::audioLogObjects(v37);
          if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
          {
            v66 = *((_QWORD *)a2 + 85);
            if ((*((_QWORD *)a2 + 32) & 1) != 0)
              v67 = (char *)*((_QWORD *)a2 + 33);
            else
              v67 = (char *)a2 + 257;
            *(_DWORD *)v79 = 134218242;
            *(_QWORD *)&v79[4] = v66;
            v80 = 2080;
            v81 = v67;
            _os_log_error_impl(&dword_224FE9000, v39, OS_LOG_TYPE_ERROR, "[RE/STS] AudioManager failed to create sts label for token %llu's introspected value %s", v79, 0x16u);
          }

        }
        goto LABEL_100;
      }
      v15 = v17;
      objc_msgSend(v11, "objectForKey:", v15);
      v18 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(MEMORY[0x24BDD16E0], "numberWithInt:", objc_msgSend(v18, "intValue") + 1);
      v19 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v11, "setValue:forKey:", v19, v15);

      v21 = (id)*re::audioLogObjects(v20);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        v22 = *((_QWORD *)a2 + 85);
        *(_DWORD *)buf = 138412546;
        *(_QWORD *)&buf[4] = v15;
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = v22;
        _os_log_impl(&dword_224FE9000, v21, OS_LOG_TYPE_DEFAULT, "[RE/STS] AudioManager Tracking STS label %@ with token: %llu", buf, 0x16u);
      }

    }
    objc_msgSend(v11, "objectForKey:", v15);
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    if (objc_msgSend(v23, "intValue") != 1 && !*((_BYTE *)a2 + 792))
    {
LABEL_99:

LABEL_100:
      return;
    }
    if (objc_msgSend(v23, "intValue") == 1)
      *((_BYTE *)a2 + 792) = 1;
    v86 = 0;
    v87 = 0;
    if (*((_BYTE *)a2 + 280))
      v24 = 2;
    else
      v24 = *((_BYTE *)a2 + 476);
    if (v24 <= 2u)
      LODWORD(v86) = dword_226100BE4[(char)v24];
    ShouldConfigureTuningForSTSLabels = (re *)REAudioShouldConfigureTuningForSTSLabels();
    v75 = (int)ShouldConfigureTuningForSTSLabels;
    if (*((_BYTE *)a2 + 793) && *((unsigned __int8 *)a2 + 794) == v24)
    {
LABEL_74:
      v45 = *((_OWORD *)a2 + 21);
      *(_OWORD *)buf = *((_OWORD *)a2 + 20);
      *(_OWORD *)&buf[16] = v45;
      v46 = *((_OWORD *)a2 + 23);
      v84 = *((_OWORD *)a2 + 22);
      v85 = v46;
      if (v24 == 2)
      {
        v47 = xmmword_2260E5F10;
        HIDWORD(v47) = *(_DWORD *)((unint64_t)buf | 0xC);
        v48 = xmmword_2260E5F20;
        HIDWORD(v48) = *(_DWORD *)&buf[28];
        *(_OWORD *)buf = v47;
        *(_OWORD *)&buf[16] = v48;
        v49 = xmmword_2260E5F40;
        HIDWORD(v49) = HIDWORD(v84);
        v84 = v49;
      }
      v50 = 1.0;
      v51 = 1.0;
      if (*((_BYTE *)a2 + 136))
      {
        v52 = *((_QWORD *)a2 + 56);
        v53 = re::AudioSourceState::playbackHostConnectionIdentifier(a2);
        if ((*((_QWORD *)a2 + 19) & 1) != 0)
          v54 = (char *)*((_QWORD *)a2 + 20);
        else
          v54 = (char *)a2 + 153;
        std::string::basic_string[abi:ne180100]<0>(v79, v54);
        v55 = re::AudioManager::mixGroupState((uint64_t)this, v52, v53, v79);
        if (v82 < 0)
          operator delete(*(void **)v79);
        if (v55)
          v51 = *((float *)v55 + 1);
      }
      v56 = v75 ^ 1;
      if (v24)
        v56 = 1;
      if ((v56 & 1) == 0)
        v50 = *((float *)this + 71);
      *(_QWORD *)v76 = (char *)a2 + 448;
      v57 = std::__hash_table<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t)this + 16, (unint64_t *)a2 + 56, (uint64_t)&std::piecewise_construct, (_QWORD **)v76);
      v58 = 50.0;
      if (v24 == 1)
      {
        v59 = 1.0;
      }
      else
      {
        v59 = 1.0;
        if (v57[4] != -1)
        {
          v60 = *((float *)a2 + 20);
          v61 = v60 + (float)(log10f(v50) * 20.0);
          if (v61 <= 20.0)
            v62 = v61 / 20.0;
          else
            v62 = 1.0;
          v63 = __exp10f(v62);
          v64 = (float)(v63 * v63) / (float)((float)(v63 * v63) + 1.0);
          v59 = 1.0 / sqrtf(1.0 - v64);
          v58 = v64 * 100.0;
        }
      }
      if (v24 == 1)
        v65 = 1.0;
      else
        v65 = v50;
      *((float *)&v86 + 1) = log10f((float)(v59 / v65) * (float)(v51 * *((float *)a2 + 32))) * 20.0;
      *(float *)&v87 = v58;
      BYTE4(v87) = *((_BYTE *)a2 + 280);
      re::AudioManager::storePendingStateForSTSLabel((uint64_t)this, *((const __CFString **)a2 + 98), (uint64_t)buf);
      goto LABEL_99;
    }
    v26 = *re::audioLogObjects(ShouldConfigureTuningForSTSLabels);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      v27 = *((_QWORD *)a2 + 98);
      *(_DWORD *)v79 = 138412546;
      *(_QWORD *)&v79[4] = v27;
      v80 = 1024;
      LODWORD(v81) = v24;
      _os_log_impl(&dword_224FE9000, v26, OS_LOG_TYPE_DEFAULT, "[RE/STS] STSLabel %@ changed input mode to %d", v79, 0x12u);
    }
    if (!v75
      || (v28 = *((_QWORD *)a2 + 98)) == 0
      || !*((_QWORD *)this + 8)
      || (v29 = (re *)REAudioShouldConfigureTuningForSTSLabels(), !(_DWORD)v29))
    {
LABEL_71:
      if (!*((_BYTE *)a2 + 793))
        *((_BYTE *)a2 + 793) = 1;
      *((_BYTE *)a2 + 794) = v24;
      goto LABEL_74;
    }
    v30 = *re::audioLogObjects(v29);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)v79 = 138412546;
      *(_QWORD *)&v79[4] = v28;
      v80 = 1024;
      LODWORD(v81) = v24;
      _os_log_impl(&dword_224FE9000, v30, OS_LOG_TYPE_DEFAULT, "[RE/STS] updating distance attenuation model for STS label %@ based on input mode %d", v79, 0x12u);
    }
    *(_QWORD *)v76 = 0x447A00003F800000;
    v77 = 1114636288;
    *(_DWORD *)bytes = 2;
    if (!v24)
    {
      v77 = 1114636288;
      *(_DWORD *)bytes = 1;
      v31 = *((float *)this + 71) * 1000.0;
      *(_DWORD *)v76 = *((_DWORD *)this + 71);
      *(float *)&v76[4] = v31;
    }
    HexCFStringForInt = re::AudioManager::getHexCFStringForInt(this, 3013);
    allocator = (const __CFAllocator *)*MEMORY[0x24BDBD240];
    cf = CFDataCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], bytes, 4);
    v32 = *((_QWORD *)this + 8);
    VTable = (re *)CMBaseObjectGetVTable();
    v34 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, CFDataRef))(*((_QWORD *)VTable + 2) + 24);
    if (v34)
    {
      VTable = (re *)v34(v32, v28, HexCFStringForInt, cf);
      v69 = (int)VTable;
      if (!(_DWORD)VTable)
        goto LABEL_64;
    }
    else
    {
      v69 = -12782;
    }
    v40 = *re::audioLogObjects(VTable);
    if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v79 = 138412546;
      *(_QWORD *)&v79[4] = v28;
      v80 = 1024;
      LODWORD(v81) = v69;
      _os_log_error_impl(&dword_224FE9000, v40, OS_LOG_TYPE_ERROR, "[RE/STS] FigSTSSetPropertyByLabel for label %@ attenuation curve error=%d", v79, 0x12u);
    }
LABEL_64:
    CFRelease(cf);
    v70 = re::AudioManager::getHexCFStringForInt(this, 3010);
    cfa = CFDataCreate(allocator, v76, 12);
    v41 = *((_QWORD *)this + 8);
    v42 = (re *)CMBaseObjectGetVTable();
    v43 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, CFDataRef))(*((_QWORD *)v42 + 2) + 24);
    if (v43)
    {
      v42 = (re *)v43(v41, v28, v70, cfa);
      allocatora = (int)v42;
      if (!(_DWORD)v42)
      {
LABEL_70:
        CFRelease(cfa);
        goto LABEL_71;
      }
    }
    else
    {
      allocatora = -12782;
    }
    v44 = *re::audioLogObjects(v42);
    if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v79 = 138412546;
      *(_QWORD *)&v79[4] = v28;
      v80 = 1024;
      LODWORD(v81) = allocatora;
      _os_log_error_impl(&dword_224FE9000, v44, OS_LOG_TYPE_ERROR, "[RE/STS] FigSTSSetPropertyByLabel for label %@ distance params error=%d", v79, 0x12u);
    }
    goto LABEL_70;
  }
}

void sub_22541B3A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  void *v22;

  if (a22 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

uint64_t *re::AudioManager::mixGroupState(uint64_t a1, unint64_t a2, unint64_t a3, unsigned __int8 *a4)
{
  unint64_t v5;
  uint64_t *result;
  uint64_t *v7;
  char *v8;
  unint64_t v9;
  int8x8_t v10;
  unint64_t v11;
  uint8x8_t v12;
  unint64_t v13;
  unint64_t v14;
  unsigned __int8 **v15;
  unsigned __int8 *v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;

  v5 = a3;
  v18 = a3;
  v19 = a2;
  result = std::__hash_table<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>>>::find<unsigned long long>((_QWORD *)(a1 + 16), &v19);
  if (result)
  {
    v7 = result + 7;
    v8 = std::__hash_table<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene::PerConnectionState>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene::PerConnectionState>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene::PerConnectionState>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene::PerConnectionState>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(result + 7, v5, &v18);
    v9 = std::__string_hash<char>::operator()[abi:ne180100]((uint64_t)(v8 + 48), (uint64_t)a4);
    v10 = *(int8x8_t *)(v8 + 32);
    if (!*(_QWORD *)&v10)
      goto LABEL_19;
    v11 = v9;
    v12 = (uint8x8_t)vcnt_s8(v10);
    v12.i16[0] = vaddlv_u8(v12);
    v13 = v12.u32[0];
    if (v12.u32[0] > 1uLL)
    {
      v14 = v9;
      if (v9 >= *(_QWORD *)&v10)
        v14 = v9 % *(_QWORD *)&v10;
    }
    else
    {
      v14 = (*(_QWORD *)&v10 - 1) & v9;
    }
    v15 = *(unsigned __int8 ***)(*((_QWORD *)v8 + 3) + 8 * v14);
    if (!v15)
    {
LABEL_19:
      v16 = 0;
      goto LABEL_22;
    }
    v16 = *v15;
    if (*v15)
    {
      while (1)
      {
        v17 = *((_QWORD *)v16 + 1);
        if (v17 == v11)
        {
          if ((std::equal_to<std::string>::operator()[abi:ne180100]((uint64_t)(v8 + 56), v16 + 16, a4) & 1) != 0)
            goto LABEL_21;
        }
        else
        {
          if (v13 > 1)
          {
            if (v17 >= *(_QWORD *)&v10)
              v17 %= *(_QWORD *)&v10;
          }
          else
          {
            v17 &= *(_QWORD *)&v10 - 1;
          }
          if (v17 != v14)
          {
            v16 = 0;
LABEL_21:
            v5 = v18;
            break;
          }
        }
        v16 = *(unsigned __int8 **)v16;
        if (!v16)
          goto LABEL_21;
      }
    }
LABEL_22:
    std::__hash_table<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene::PerConnectionState>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene::PerConnectionState>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene::PerConnectionState>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene::PerConnectionState>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v7, v5, &v18);
    if (v16)
      return (uint64_t *)(v16 + 40);
    else
      return 0;
  }
  return result;
}

float re::AudioManager::mixGroupSignalPresent(uint64_t a1, unint64_t a2, unint64_t a3, unsigned __int8 *a4)
{
  _QWORD *v6;
  float v7;
  uint64_t *v8;
  char *v9;
  unint64_t v10;
  int8x8_t v11;
  unint64_t v12;
  uint8x8_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t **v16;
  uint64_t *v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t *v20;
  unint64_t v22;
  unint64_t v23;

  v22 = a3;
  v23 = a2;
  v6 = std::__hash_table<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>>>::find<unsigned long long>((_QWORD *)(a1 + 16), &v23);
  v7 = 0.0;
  if (v6)
  {
    v8 = v6 + 7;
    v9 = std::__hash_table<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene::PerConnectionState>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene::PerConnectionState>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene::PerConnectionState>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene::PerConnectionState>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v6 + 7, a3, &v22);
    v10 = std::__string_hash<char>::operator()[abi:ne180100]((uint64_t)(v9 + 88), (uint64_t)a4);
    v11 = *(int8x8_t *)(v9 + 72);
    if (v11)
    {
      v12 = v10;
      v13 = (uint8x8_t)vcnt_s8(v11);
      v13.i16[0] = vaddlv_u8(v13);
      v14 = v13.u32[0];
      if (v13.u32[0] > 1uLL)
      {
        v15 = v10;
        if (v10 >= *(_QWORD *)&v11)
          v15 = v10 % *(_QWORD *)&v11;
      }
      else
      {
        v15 = (*(_QWORD *)&v11 - 1) & v10;
      }
      v16 = *(uint64_t ***)(*((_QWORD *)v9 + 8) + 8 * v15);
      if (v16)
      {
        v17 = *v16;
        if (*v16)
        {
          while (1)
          {
            v18 = v17[1];
            if (v18 == v12)
            {
              if ((std::equal_to<std::string>::operator()[abi:ne180100]((uint64_t)(v9 + 96), (unsigned __int8 *)v17 + 16, a4) & 1) != 0)
              {
                std::__hash_table<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene::PerConnectionState>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene::PerConnectionState>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene::PerConnectionState>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene::PerConnectionState>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v8, v22, &v22);
                return *((float *)v17 + 10);
              }
            }
            else
            {
              if (v14 > 1)
              {
                if (v18 >= *(_QWORD *)&v11)
                  v18 %= *(_QWORD *)&v11;
              }
              else
              {
                v18 &= *(_QWORD *)&v11 - 1;
              }
              if (v18 != v15)
              {
LABEL_18:
                v19 = v22;
                v20 = v8;
                goto LABEL_20;
              }
            }
            v17 = (uint64_t *)*v17;
            if (!v17)
              goto LABEL_18;
          }
        }
      }
    }
    v20 = v8;
    v19 = a3;
LABEL_20:
    std::__hash_table<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene::PerConnectionState>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene::PerConnectionState>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene::PerConnectionState>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene::PerConnectionState>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v20, v19, &v22);
  }
  return v7;
}

unint64_t *re::AudioManager::createListenerInScene(uint64_t a1, unint64_t a2)
{
  unint64_t *v3;
  unint64_t v5;
  unint64_t *__buf;

  v5 = a2;
  for (__buf = 0; (unint64_t)__buf < 0x3E8; v3 = __buf)
    arc4random_buf(&__buf, 8uLL);
  __buf = &v5;
  std::__hash_table<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(a1 + 16, &v5, (uint64_t)&std::piecewise_construct, &__buf)[3] = v3;
  return v3;
}

uint64_t re::AudioManager::removeListenerFromScene(uint64_t this, uint64_t a2)
{
  _QWORD *i;

  for (i = *(_QWORD **)(this + 32); i; i = (_QWORD *)*i)
  {
    if (i[3] == a2)
      i[3] = 0;
  }
  return this;
}

simd_float4 *re::AudioManager::setListenerTransformAndLevel(simd_float4 *this, unint64_t a2, const simd_float4x4 *a3, float a4, uint64_t a5)
{
  simd_float4 v5;
  simd_float4 v6;
  int v7;
  simd_float4 v8;
  simd_float4 v9;

  if (this[3].i8[8])
  {
    v5 = a3->columns[0];
    v8 = a3->columns[1];
    v6 = a3->columns[2];
    v9 = a3->columns[3];
    v7 = this[13].u8[0];
    this[8].i64[0] = a5;
    this[8].i64[1] = 0;
    this[9] = v5;
    this[10] = v8;
    this[11] = v6;
    this[12] = v9;
    if (!v7)
      this[13].i8[0] = 1;
  }
  return this;
}

_QWORD *re::AudioManager::sceneContainsSystemListener(re::AudioManager *this, unint64_t a2)
{
  _QWORD *result;
  uint64_t v4;
  unint64_t v6;

  v6 = a2;
  result = std::__hash_table<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>>>::find<unsigned long long>((_QWORD *)this + 2, &v6);
  if (result)
  {
    v4 = *((_QWORD *)this + 33);
    return (_QWORD *)(result[3] == v4 && v4 != 0);
  }
  return result;
}

void re::AudioManager::applyReverbParametersToScene(re::AudioManager *this, unint64_t a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _BOOL4 v5;
  uint64_t HexCFStringForInt;
  const __CFAllocator *v7;
  CFDataRef v8;
  uint64_t v9;
  uint64_t v10;
  re *VTable;
  uint64_t (*v12)(uint64_t, uint64_t, uint64_t, CFDataRef);
  int v13;
  NSObject *v14;
  CFDataRef v15;
  uint64_t v16;
  re *v17;
  uint64_t (*v18)(uint64_t, uint64_t, const __CFString *, CFDataRef);
  int v19;
  NSObject *v20;
  int v21;
  UInt8 bytes[4];
  unint64_t v23;
  uint8_t buf[4];
  int v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v23 = a2;
  if (!*((_QWORD *)this + 8)
    || !*((_BYTE *)this + 56)
    || !(*(unsigned int (**)(re::AudioManager *))(*(_QWORD *)this + 952))(this)
    || !REAudioShouldConfigureTuningForSTSLabels())
  {
    return;
  }
  v3 = std::__hash_table<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>>>::find<unsigned long long>((_QWORD *)this + 2, &v23);
  v4 = v3;
  if (v3)
    v5 = v3[4] != -1;
  else
    v5 = 0;
  *(_DWORD *)bytes = v5;
  HexCFStringForInt = re::AudioManager::getHexCFStringForInt(this, 1005);
  v7 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  v8 = CFDataCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], bytes, 4);
  v9 = *((_QWORD *)this + 8);
  v10 = *MEMORY[0x24BE649F0];
  VTable = (re *)CMBaseObjectGetVTable();
  v12 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, CFDataRef))(*((_QWORD *)VTable + 2) + 24);
  if (v12)
  {
    VTable = (re *)v12(v9, v10, HexCFStringForInt, v8);
    v13 = (int)VTable;
    if (!(_DWORD)VTable)
      goto LABEL_14;
  }
  else
  {
    v13 = -12782;
  }
  v14 = *re::audioLogObjects(VTable);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 67109120;
    v25 = v13;
    _os_log_error_impl(&dword_224FE9000, v14, OS_LOG_TYPE_ERROR, "[RE/STS] FigSTSSetPropertyByLabel reverb enabled error=%d", buf, 8u);
  }
LABEL_14:
  CFRelease(v8);
  if (*(_DWORD *)bytes && v4[4] != -1)
  {
    v21 = v4[4];
    v15 = CFDataCreate(v7, (const UInt8 *)&v21, 4);
    v16 = *((_QWORD *)this + 8);
    v17 = (re *)CMBaseObjectGetVTable();
    v18 = *(uint64_t (**)(uint64_t, uint64_t, const __CFString *, CFDataRef))(*((_QWORD *)v17 + 2) + 24);
    if (v18)
    {
      v17 = (re *)v18(v16, v10, CFSTR("ReverbRoomType"), v15);
      v19 = (int)v17;
      if (!(_DWORD)v17)
      {
LABEL_22:
        CFRelease(v15);
        return;
      }
    }
    else
    {
      v19 = -12782;
    }
    v20 = *re::audioLogObjects(v17);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      v25 = v19;
      _os_log_error_impl(&dword_224FE9000, v20, OS_LOG_TYPE_ERROR, "[RE/STS] FigSTSSetPropertyByLabel kSTSLabelProperty_ReverbRoomType error=%d", buf, 8u);
    }
    goto LABEL_22;
  }
}

uint64_t re::AudioManager::getHexCFStringForInt(re::AudioManager *this, uint64_t a2)
{
  unsigned int v2;
  float *v3;
  unint64_t v4;
  uint8x8_t v5;
  unint64_t v6;
  uint64_t **v7;
  uint64_t *i;
  unint64_t v9;
  CFStringRef v10;
  int v12;

  v2 = a2;
  v12 = a2;
  v3 = (float *)((char *)this + 80);
  v4 = *((_QWORD *)this + 11);
  if (v4)
  {
    v5 = (uint8x8_t)vcnt_s8((int8x8_t)v4);
    v5.i16[0] = vaddlv_u8(v5);
    if (v5.u32[0] > 1uLL)
    {
      v6 = a2;
      if (v4 <= a2)
        v6 = a2 % v4;
    }
    else
    {
      v6 = ((_DWORD)v4 - 1) & a2;
    }
    v7 = *(uint64_t ***)(*(_QWORD *)v3 + 8 * v6);
    if (v7)
    {
      for (i = *v7; i; i = (uint64_t *)*i)
      {
        v9 = i[1];
        if (v9 == a2)
        {
          if (*((_DWORD *)i + 4) == (_DWORD)a2)
            return std::__hash_table<std::__hash_value_type<unsigned int,__CFString const*>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,__CFString const*>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,__CFString const*>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,__CFString const*>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(v3, v2, &v12)[3];
        }
        else
        {
          if (v5.u32[0] > 1uLL)
          {
            if (v9 >= v4)
              v9 %= v4;
          }
          else
          {
            v9 &= v4 - 1;
          }
          if (v9 != v6)
            break;
        }
      }
    }
  }
  v10 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, CFSTR("%x"), a2);
  std::__hash_table<std::__hash_value_type<unsigned int,__CFString const*>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,__CFString const*>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,__CFString const*>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,__CFString const*>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(v3, v2, &v12)[3] = v10;
  return std::__hash_table<std::__hash_value_type<unsigned int,__CFString const*>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,__CFString const*>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,__CFString const*>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,__CFString const*>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(v3, v2, &v12)[3];
}

_QWORD *re::AudioManager::setSceneReverbPreset(_QWORD *a1, unint64_t a2, uint64_t a3, int a4)
{
  uint64_t v7;
  _QWORD *result;
  BOOL v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t *v12;

  v11 = a2;
  v7 = (uint64_t)(a1 + 2);
  result = std::__hash_table<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>>>::find<unsigned long long>(a1 + 2, &v11);
  if (!result || (result[4] == a3 ? (v9 = *((unsigned __int8 *)result + 40) == a4) : (v9 = 0), !v9))
  {
    v10 = v11;
    v12 = &v11;
    std::__hash_table<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v7, &v11, (uint64_t)&std::piecewise_construct, &v12)[6] = v10;
    v12 = &v11;
    std::__hash_table<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v7, &v11, (uint64_t)&std::piecewise_construct, &v12)[4] = a3;
    v12 = &v11;
    *((_BYTE *)std::__hash_table<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v7, &v11, (uint64_t)&std::piecewise_construct, &v12)+ 40) = a4;
    return (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t))(*a1 + 944))(a1, v11);
  }
  return result;
}

uint64_t re::AudioManager::getSceneReverbPreset(int8x8_t *this, unint64_t a2)
{
  int8x8_t v2;
  uint8x8_t v3;
  unint64_t v4;
  _QWORD *v5;
  _QWORD *i;
  unint64_t v7;

  v2 = this[3];
  if (v2)
  {
    v3 = (uint8x8_t)vcnt_s8(v2);
    v3.i16[0] = vaddlv_u8(v3);
    if (v3.u32[0] > 1uLL)
    {
      v4 = a2;
      if (*(_QWORD *)&v2 <= a2)
        v4 = a2 % *(_QWORD *)&v2;
    }
    else
    {
      v4 = (*(_QWORD *)&v2 - 1) & a2;
    }
    v5 = *(_QWORD **)(*(_QWORD *)&this[2] + 8 * v4);
    if (v5)
    {
      for (i = (_QWORD *)*v5; i; i = (_QWORD *)*i)
      {
        v7 = i[1];
        if (v7 == a2)
        {
          if (i[2] == a2)
            return i[4];
        }
        else
        {
          if (v3.u32[0] > 1uLL)
          {
            if (v7 >= *(_QWORD *)&v2)
              v7 %= *(_QWORD *)&v2;
          }
          else
          {
            v7 &= *(_QWORD *)&v2 - 1;
          }
          if (v7 != v4)
            return -1;
        }
      }
    }
  }
  return -1;
}

uint64_t re::AudioManager::removeSourceFromSceneIfIncorrectlyConnected(re::AudioManager *this, const re::AudioSourceState *a2)
{
  const void *v4;
  _QWORD *v5;
  _QWORD *v6;
  void *v7;
  id v8;
  id v9;
  void *v10;
  void *v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t i;
  uint8_t buf[4];
  id v17;
  __int16 v18;
  uint64_t v19;
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  if (*((_QWORD *)a2 + 56) == -1)
  {
    v4 = (const void *)*((_QWORD *)a2 + 98);
    if (v4)
    {
      v5 = (_QWORD *)*((_QWORD *)this + 4);
      if (v5)
      {
        do
        {
          v6 = std::__hash_table<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>>>::find<unsigned long long>((_QWORD *)this + 2, v5 + 2);
          if (v6)
          {
            v7 = (void *)v6[12];
            if (v7)
            {
              v8 = v7;
              v9 = *((id *)a2 + 98);
              objc_msgSend(v8, "objectForKey:", v9);
              v10 = (void *)objc_claimAutoreleasedReturnValue();
              if ((int)objc_msgSend(v10, "intValue") < 2)
              {
                objc_msgSend(v8, "removeObjectForKey:", v9);
                v12 = (id)*re::audioLogObjects((re *)objc_msgSend(*((id *)this + 9), "cleanupLabel:", *((_QWORD *)a2 + 98)));
                if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
                {
                  v13 = *((_QWORD *)a2 + 85);
                  *(_DWORD *)buf = 138412546;
                  v17 = v9;
                  v18 = 2048;
                  v19 = v13;
                  _os_log_impl(&dword_224FE9000, v12, OS_LOG_TYPE_DEFAULT, "[RE/STS] AudioManager is no longer tracking STSLabel %@ after removing last token %llu", buf, 0x16u);
                }

                for (i = *((_QWORD *)this + 30);
                      i;
                      i = std::__hash_table<std::__hash_value_type<__CFString const*,re::AudioManager::RESTSPerLabelState>,std::__unordered_map_hasher<__CFString const*,std::__hash_value_type<__CFString const*,re::AudioManager::RESTSPerLabelState>,re::AudioManager::CFStringHash,re::AudioManager::CFStringEqual,true>,std::__unordered_map_equal<__CFString const*,std::__hash_value_type<__CFString const*,re::AudioManager::RESTSPerLabelState>,re::AudioManager::CFStringEqual,re::AudioManager::CFStringHash,true>,std::allocator<std::__hash_value_type<__CFString const*,re::AudioManager::RESTSPerLabelState>>>::erase((_QWORD *)this + 28, (uint64_t *)i))
                {
                  while (CFStringCompare(*(CFStringRef *)(i + 16), *((CFStringRef *)a2 + 98), 0))
                  {
                    i = *(_QWORD *)i;
                    if (!i)
                      goto LABEL_15;
                  }
                  CFRelease(*(CFTypeRef *)(i + 16));
                }
              }
              else
              {
                objc_msgSend(MEMORY[0x24BDD16E0], "numberWithInt:", objc_msgSend(v10, "intValue") - 1);
                v11 = (void *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(v8, "setValue:forKey:", v11, v9);

              }
LABEL_15:

            }
          }
          v5 = (_QWORD *)*v5;
        }
        while (v5);
        v4 = (const void *)*((_QWORD *)a2 + 98);
      }
      CFRelease(v4);
      *((_QWORD *)a2 + 98) = 0;
      *((_BYTE *)a2 + 792) = 0;
    }
  }
  return 0;
}

void sub_22541BFAC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

uint64_t re::AudioManager::setCustomHRIR(re::AudioManager *this, const __CFURL *a2)
{
  *((_QWORD *)this + 37) = a2;
  return (*(uint64_t (**)(re::AudioManager *))(*(_QWORD *)this + 960))(this);
}

void re::AudioManager::addTrackedCALayerEntityId(re::AudioManager *this, unint64_t a2, CFStringRef theString)
{
  unint64_t v3;
  re *Copy;
  re *v7;
  unint64_t *v8;
  unint64_t *v9;
  uint64_t *v10;
  NSObject *v11;
  unint64_t v12;
  _QWORD *v13;
  unint64_t *v14;
  int64_t v15;
  re **v16;
  unint64_t v17;
  uint8x8_t v18;
  NSObject *v19;
  const char *v20;
  re **v21;
  re *v22;
  unint64_t v23;
  float v24;
  float v25;
  _BOOL8 v26;
  unint64_t v27;
  unint64_t v28;
  size_t v29;
  uint64_t v30;
  re **v31;
  unint64_t v32;
  re *v33;
  unint64_t v34;
  _QWORD *v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  unint64_t v39;
  char *v40;
  char *v41;
  char *v42;
  uint64_t v43;
  NSObject *v44;
  re *v45;
  int64_t v46;
  re *v47;
  int v48;
  unint64_t v49;
  __int16 v50;
  re *v51;
  __int16 v52;
  re *v53;
  uint64_t v54;

  v54 = *MEMORY[0x24BDAC8D0];
  if (!*((_BYTE *)this + 56))
    return;
  if (!theString)
  {
    v19 = *re::audioLogObjects(this);
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      return;
    v48 = 134217984;
    v49 = a2;
    v20 = "[RE/STS] AudioManager has been requested to track an entity but no STS label has been provided - entityId=%llu"
          " will not be tracked.";
    goto LABEL_23;
  }
  Copy = (re *)CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x24BDBD240], theString);
  if (!Copy)
  {
    v19 = *re::audioLogObjects(0);
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      return;
    v48 = 134217984;
    v49 = a2;
    v20 = "[RE/STS] failed to copy tracked CALayer's label, entityId=%llu will not be tracked";
LABEL_23:
    _os_log_error_impl(&dword_224FE9000, v19, OS_LOG_TYPE_ERROR, v20, (uint8_t *)&v48, 0xCu);
    return;
  }
  v7 = Copy;
  v9 = (unint64_t *)*((_QWORD *)this + 59);
  v8 = (unint64_t *)*((_QWORD *)this + 60);
  if (v9 != v8)
  {
    while (*v9 != a2)
    {
      if (++v9 == v8)
      {
        v9 = (unint64_t *)*((_QWORD *)this + 60);
        break;
      }
    }
  }
  v10 = (uint64_t *)((char *)this + 432);
  if (v9 != v8)
  {
    v11 = (id)*re::audioLogObjects(Copy);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      v47 = (re *)std::__hash_table<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>>>::find<unsigned long long>((_QWORD *)this + 54, *v9)[3];
      v48 = 134218498;
      v49 = a2;
      v50 = 2112;
      v51 = v47;
      v52 = 2112;
      v53 = v7;
      _os_log_error_impl(&dword_224FE9000, v11, OS_LOG_TYPE_ERROR, "[RE/STS] AudioManager is overriding STS label for entityId=%llu. Was previously %@, is now %@.", (uint8_t *)&v48, 0x20u);
    }

    v12 = *v9;
    if (std::__hash_table<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>>>::find<unsigned long long>((_QWORD *)this + 54, *v9)[3])
    {
      objc_msgSend(*((id *)this + 9), "cleanupLabel:");
      v13 = std::__hash_table<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>>>::find<unsigned long long>((_QWORD *)this + 54, *v9);
      CFRelease((CFTypeRef)v13[3]);
      v12 = *v9;
    }
    std::__hash_table<std::__hash_value_type<unsigned long long,RESoundEventPreparingData>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,RESoundEventPreparingData>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,RESoundEventPreparingData>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,RESoundEventPreparingData>>>::__erase_unique<unsigned long long>((_QWORD *)this + 54, v12);
    v14 = (unint64_t *)*((_QWORD *)this + 60);
    v15 = (char *)v14 - (char *)(v9 + 1);
    if (v14 != v9 + 1)
      Copy = (re *)memmove(v9, v9 + 1, (char *)v14 - (char *)(v9 + 1));
    v8 = (unint64_t *)((char *)v9 + v15);
    *((_QWORD *)this + 60) = (char *)v9 + v15;
  }
  v16 = (re **)((char *)this + 472);
  v17 = *((_QWORD *)this + 55);
  if (!v17)
    goto LABEL_38;
  v18 = (uint8x8_t)vcnt_s8((int8x8_t)v17);
  v18.i16[0] = vaddlv_u8(v18);
  if (v18.u32[0] > 1uLL)
  {
    v3 = a2;
    if (v17 <= a2)
      v3 = a2 % v17;
  }
  else
  {
    v3 = (v17 - 1) & a2;
  }
  v21 = *(re ***)(*v10 + 8 * v3);
  if (!v21 || (v22 = *v21) == 0)
  {
LABEL_38:
    Copy = (re *)operator new(0x20uLL);
    v22 = Copy;
    *(_QWORD *)Copy = 0;
    *((_QWORD *)Copy + 1) = a2;
    v24 = (float)(unint64_t)(*((_QWORD *)this + 57) + 1);
    *((_QWORD *)Copy + 2) = a2;
    *((_QWORD *)Copy + 3) = v7;
    v25 = *((float *)this + 116);
    if ((((float)(v25 * (float)v17) >= v24) & ~(v17 == 0)) == 0)
    {
      v26 = 1;
      if (v17 >= 3)
        v26 = (v17 & (v17 - 1)) != 0;
      v27 = v26 | (2 * v17);
      v28 = vcvtps_u32_f32(v24 / v25);
      if (v27 <= v28)
        v29 = v28;
      else
        v29 = v27;
      std::__hash_table<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>>>::__rehash<true>((uint64_t)this + 432, v29);
      v17 = *((_QWORD *)this + 55);
      if ((v17 & (v17 - 1)) != 0)
      {
        if (v17 <= a2)
          v3 = a2 % v17;
        else
          v3 = a2;
      }
      else
      {
        v3 = (v17 - 1) & a2;
      }
    }
    v30 = *v10;
    v31 = *(re ***)(*v10 + 8 * v3);
    if (v31)
    {
      *(_QWORD *)v22 = *v31;
    }
    else
    {
      *(_QWORD *)v22 = *((_QWORD *)this + 56);
      *((_QWORD *)this + 56) = v22;
      *(_QWORD *)(v30 + 8 * v3) = (char *)this + 448;
      if (!*(_QWORD *)v22)
      {
LABEL_58:
        ++*((_QWORD *)this + 57);
        v33 = (re *)*((_QWORD *)this + 60);
        goto LABEL_59;
      }
      v32 = *(_QWORD *)(*(_QWORD *)v22 + 8);
      if ((v17 & (v17 - 1)) != 0)
      {
        if (v32 >= v17)
          v32 %= v17;
      }
      else
      {
        v32 &= v17 - 1;
      }
      v31 = (re **)(*v10 + 8 * v32);
    }
    *v31 = v22;
    goto LABEL_58;
  }
  while (1)
  {
    v23 = *((_QWORD *)v22 + 1);
    if (v23 == a2)
      break;
    if (v18.u32[0] > 1uLL)
    {
      if (v23 >= v17)
        v23 %= v17;
    }
    else
    {
      v23 &= v17 - 1;
    }
    if (v23 != v3)
      goto LABEL_38;
LABEL_37:
    v22 = *(re **)v22;
    if (!v22)
      goto LABEL_38;
  }
  if (*((_QWORD *)v22 + 2) != a2)
    goto LABEL_37;
  v45 = *v16;
  if (*v16 != (re *)v8)
  {
    while (*(_QWORD *)v45 != a2)
    {
      v45 = (re *)((char *)v45 + 8);
      if (v45 == (re *)v8)
      {
        v45 = (re *)v8;
        break;
      }
    }
  }
  v46 = (char *)v8 - ((char *)v45 + 8);
  if (v8 != (unint64_t *)((char *)v45 + 8))
    Copy = (re *)memmove(v45, (char *)v45 + 8, (char *)v8 - ((char *)v45 + 8));
  v33 = (re *)((char *)v45 + v46);
  *((_QWORD *)this + 60) = (char *)v45 + v46;
LABEL_59:
  v34 = *((_QWORD *)this + 61);
  if ((unint64_t)v33 >= v34)
  {
    Copy = *v16;
    v36 = (v33 - *v16) >> 3;
    v37 = v36 + 1;
    if ((unint64_t)(v36 + 1) >> 61)
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    v38 = v34 - (_QWORD)Copy;
    if (v38 >> 2 > v37)
      v37 = v38 >> 2;
    if ((unint64_t)v38 >= 0x7FFFFFFFFFFFFFF8)
      v39 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v39 = v37;
    if (v39)
    {
      v40 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)this + 488, v39);
      Copy = (re *)*((_QWORD *)this + 59);
      v33 = (re *)*((_QWORD *)this + 60);
    }
    else
    {
      v40 = 0;
    }
    v41 = &v40[8 * v36];
    v42 = &v40[8 * v39];
    *(_QWORD *)v41 = *((_QWORD *)v22 + 2);
    v35 = v41 + 8;
    while (v33 != Copy)
    {
      v43 = *((_QWORD *)v33 - 1);
      v33 = (re *)((char *)v33 - 8);
      *((_QWORD *)v41 - 1) = v43;
      v41 -= 8;
    }
    *((_QWORD *)this + 59) = v41;
    *((_QWORD *)this + 60) = v35;
    *((_QWORD *)this + 61) = v42;
    if (Copy)
      operator delete(Copy);
  }
  else
  {
    *(_QWORD *)v33 = *((_QWORD *)v22 + 2);
    v35 = (_QWORD *)((char *)v33 + 8);
  }
  *((_QWORD *)this + 60) = v35;
  v44 = *re::audioLogObjects(Copy);
  if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
  {
    v48 = 134218242;
    v49 = a2;
    v50 = 2112;
    v51 = v7;
    _os_log_impl(&dword_224FE9000, v44, OS_LOG_TYPE_DEFAULT, "[RE/STS] AudioManager is now tracking CALayer entityId=%llu with STS label %@", (uint8_t *)&v48, 0x16u);
  }
}

void sub_22541C560(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void re::AudioManager::removeTrackedCALayerEntityId(re::AudioManager *this, uint64_t a2)
{
  unint64_t *v4;
  unint64_t *v5;
  os_log_t *v6;
  NSObject *v7;
  NSObject *v8;
  uint64_t v9;
  unint64_t v10;
  _QWORD *v11;
  unint64_t *v12;
  int64_t v13;
  int v14;
  uint64_t v15;
  __int16 v16;
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  if (*((_BYTE *)this + 56))
  {
    v4 = (unint64_t *)*((_QWORD *)this + 59);
    v5 = (unint64_t *)*((_QWORD *)this + 60);
    if (v4 != v5)
    {
      while (*v4 != a2)
      {
        if (++v4 == v5)
        {
          v4 = (unint64_t *)*((_QWORD *)this + 60);
          break;
        }
      }
    }
    v6 = (os_log_t *)re::audioLogObjects(this);
    v7 = *v6;
    if (v4 == v5)
    {
      if (os_log_type_enabled(*v6, OS_LOG_TYPE_ERROR))
      {
        v14 = 134217984;
        v15 = a2;
        _os_log_error_impl(&dword_224FE9000, v7, OS_LOG_TYPE_ERROR, "[RE/STS] can't remove unknown tracked CALayer entityId %llu", (uint8_t *)&v14, 0xCu);
      }
    }
    else
    {
      v8 = v7;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        v9 = std::__hash_table<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>>>::find<unsigned long long>((_QWORD *)this + 54, *v4)[3];
        v14 = 134218242;
        v15 = a2;
        v16 = 2112;
        v17 = v9;
        _os_log_impl(&dword_224FE9000, v8, OS_LOG_TYPE_DEFAULT, "[RE/STS] no longer tracking CALayer entityId %llu with label %@", (uint8_t *)&v14, 0x16u);
      }

      v10 = *v4;
      if (std::__hash_table<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>>>::find<unsigned long long>((_QWORD *)this + 54, *v4)[3])
      {
        objc_msgSend(*((id *)this + 9), "cleanupLabel:");
        v11 = std::__hash_table<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>>>::find<unsigned long long>((_QWORD *)this + 54, *v4);
        CFRelease((CFTypeRef)v11[3]);
        v10 = *v4;
      }
      std::__hash_table<std::__hash_value_type<unsigned long long,RESoundEventPreparingData>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,RESoundEventPreparingData>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,RESoundEventPreparingData>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,RESoundEventPreparingData>>>::__erase_unique<unsigned long long>((_QWORD *)this + 54, v10);
      v12 = (unint64_t *)*((_QWORD *)this + 60);
      v13 = (char *)v12 - (char *)(v4 + 1);
      if (v12 != v4 + 1)
        memmove(v4, v4 + 1, (char *)v12 - (char *)(v4 + 1));
      *((_QWORD *)this + 60) = (char *)v4 + v13;
    }
  }
}

void re::AudioManager::updateTransformForTrackedCALayerEntities(uint64_t a1, uint64_t a2)
{
  unint64_t *v3;
  unint64_t *v4;
  _OWORD *v6;
  _QWORD *v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  _OWORD v11[3];
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD v15[8];
  __int128 v16;

  if (*(_BYTE *)(a1 + 56))
  {
    v3 = *(unint64_t **)(a1 + 472);
    v4 = *(unint64_t **)(a1 + 480);
    if (v3 != v4)
    {
      v6 = (_OWORD *)MEMORY[0x24BDAEE00];
      do
      {
        v7 = std::__hash_table<std::__hash_value_type<unsigned long long,__CFString const*>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,__CFString const*>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,__CFString const*>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,__CFString const*>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(a1 + 432, *v3, v3);
        *(_QWORD *)&v11[0] = *v3;
        (*(void (**)(_QWORD *__return_ptr, _QWORD, _OWORD *))(**(_QWORD **)(a2 + 32) + 16))(v15, *(_QWORD *)(a2 + 32), v11);
        if (LOBYTE(v15[0]))
        {
          v13 = 0;
          v14 = 0x100000000;
          v8 = v6[1];
          v11[0] = *v6;
          v11[1] = v8;
          v9 = v6[3];
          v11[2] = v6[2];
          HIDWORD(v12) = HIDWORD(v9);
          v10 = v16;
          HIDWORD(v10) = HIDWORD(v12);
          v12 = v10;
          re::AudioManager::storePendingStateForSTSLabel(a1, (const __CFString *)v7[3], (uint64_t)v11);
        }
        ++v3;
      }
      while (v3 != v4);
    }
  }
}

__n128 re::AudioManager::storePendingStateForSTSLabel(uint64_t a1, const __CFString *cf, uint64_t a3)
{
  unint64_t v3;
  _QWORD *v7;
  CFHashCode v8;
  int8x8_t v9;
  CFHashCode v10;
  uint8x8_t v11;
  CFHashCode v12;
  re *v13;
  __n128 result;
  int v15;
  uint64_t *v16;
  uint64_t i;
  unint64_t v18;
  NSObject *v19;
  CFHashCode v20;
  CFHashCode v21;
  unint64_t v22;
  uint8x8_t v23;
  unint64_t v24;
  uint64_t **v25;
  uint64_t *j;
  unint64_t v27;
  __n128 *v28;
  __n128 v29;
  float v30;
  _BOOL8 v31;
  unint64_t v32;
  unint64_t v33;
  int8x8_t prime;
  void *v35;
  _QWORD *v36;
  uint64_t v37;
  _QWORD *v38;
  unint64_t v39;
  unint64_t v40;
  uint64_t v41;
  _QWORD *v42;
  unint64_t v43;
  _QWORD *v44;
  __n128 **v45;
  unint64_t v46;
  __int128 v47;
  __int128 v48;
  _QWORD *v49;
  void *__p[2];
  char v51;

  if (cf)
  {
    CFRetain(cf);
    v7 = (_QWORD *)(a1 + 224);
    v8 = re::AudioManager::CFStringHash::operator()(cf);
    v9 = *(int8x8_t *)(a1 + 232);
    if (v9)
    {
      v10 = v8;
      v11 = (uint8x8_t)vcnt_s8(v9);
      v11.i16[0] = vaddlv_u8(v11);
      v3 = v11.u32[0];
      if (v11.u32[0] > 1uLL)
      {
        v12 = v8;
        if (v8 >= *(_QWORD *)&v9)
          v12 = v8 % *(_QWORD *)&v9;
      }
      else
      {
        v12 = (*(_QWORD *)&v9 - 1) & v8;
      }
      v16 = *(uint64_t **)(*v7 + 8 * v12);
      if (v16)
      {
        for (i = *v16; i; i = *(_QWORD *)i)
        {
          v18 = *(_QWORD *)(i + 8);
          if (v18 == v10)
          {
            if (re::AudioManager::CFStringEqual::operator()(*(const __CFString **)(i + 16), cf))
            {
              CFRelease(*(CFTypeRef *)(i + 16));
              std::__hash_table<std::__hash_value_type<__CFString const*,re::AudioManager::RESTSPerLabelState>,std::__unordered_map_hasher<__CFString const*,std::__hash_value_type<__CFString const*,re::AudioManager::RESTSPerLabelState>,re::AudioManager::CFStringHash,re::AudioManager::CFStringEqual,true>,std::__unordered_map_equal<__CFString const*,std::__hash_value_type<__CFString const*,re::AudioManager::RESTSPerLabelState>,re::AudioManager::CFStringEqual,re::AudioManager::CFStringHash,true>,std::allocator<std::__hash_value_type<__CFString const*,re::AudioManager::RESTSPerLabelState>>>::erase((_QWORD *)(a1 + 224), (uint64_t *)i);
              break;
            }
          }
          else
          {
            if (v3 > 1)
            {
              if (v18 >= *(_QWORD *)&v9)
                v18 %= *(_QWORD *)&v9;
            }
            else
            {
              v18 &= *(_QWORD *)&v9 - 1;
            }
            if (v18 != v12)
              break;
          }
        }
      }
    }
    v20 = re::AudioManager::CFStringHash::operator()(cf);
    v21 = v20;
    v22 = *(_QWORD *)(a1 + 232);
    if (v22)
    {
      v23 = (uint8x8_t)vcnt_s8((int8x8_t)v22);
      v23.i16[0] = vaddlv_u8(v23);
      v24 = v23.u32[0];
      if (v23.u32[0] > 1uLL)
      {
        v3 = v20;
        if (v20 >= v22)
          v3 = v20 % v22;
      }
      else
      {
        v3 = (v22 - 1) & v20;
      }
      v25 = *(uint64_t ***)(*v7 + 8 * v3);
      if (v25)
      {
        for (j = *v25; j; j = (uint64_t *)*j)
        {
          v27 = j[1];
          if (v27 == v21)
          {
            if (re::AudioManager::CFStringEqual::operator()((const __CFString *)j[2], cf))
            {
              *((_OWORD *)j + 2) = *(_OWORD *)a3;
              result = *(__n128 *)(a3 + 16);
              v47 = *(_OWORD *)(a3 + 32);
              v48 = *(_OWORD *)(a3 + 64);
              *((_OWORD *)j + 5) = *(_OWORD *)(a3 + 48);
              *((_OWORD *)j + 6) = v48;
              *((__n128 *)j + 3) = result;
              *((_OWORD *)j + 4) = v47;
              return result;
            }
          }
          else
          {
            if (v24 > 1)
            {
              if (v27 >= v22)
                v27 %= v22;
            }
            else
            {
              v27 &= v22 - 1;
            }
            if (v27 != v3)
              break;
          }
        }
      }
    }
    v28 = (__n128 *)operator new(0x70uLL);
    v28->n128_u64[0] = 0;
    v28->n128_u64[1] = v21;
    v28[1].n128_u64[0] = (unint64_t)cf;
    v29 = *(__n128 *)(a3 + 48);
    v28[4] = *(__n128 *)(a3 + 32);
    v28[5] = v29;
    v28[6] = *(__n128 *)(a3 + 64);
    result = *(__n128 *)(a3 + 16);
    v28[2] = *(__n128 *)a3;
    v28[3] = result;
    result.n128_f32[0] = (float)(unint64_t)(*(_QWORD *)(a1 + 248) + 1);
    v30 = *(float *)(a1 + 256);
    if (v22 && (float)(v30 * (float)v22) >= result.n128_f32[0])
    {
LABEL_88:
      v44 = (_QWORD *)*v7;
      v45 = *(__n128 ***)(*v7 + 8 * v3);
      if (v45)
      {
        v28->n128_u64[0] = (unint64_t)*v45;
      }
      else
      {
        v28->n128_u64[0] = *(_QWORD *)(a1 + 240);
        *(_QWORD *)(a1 + 240) = v28;
        v44[v3] = a1 + 240;
        if (!v28->n128_u64[0])
        {
LABEL_97:
          ++*(_QWORD *)(a1 + 248);
          return result;
        }
        v46 = *(_QWORD *)(v28->n128_u64[0] + 8);
        if ((v22 & (v22 - 1)) != 0)
        {
          if (v46 >= v22)
            v46 %= v22;
        }
        else
        {
          v46 &= v22 - 1;
        }
        v45 = (__n128 **)(*v7 + 8 * v46);
      }
      *v45 = v28;
      goto LABEL_97;
    }
    v31 = 1;
    if (v22 >= 3)
      v31 = (v22 & (v22 - 1)) != 0;
    v32 = v31 | (2 * v22);
    result.n128_f32[0] = result.n128_f32[0] / v30;
    v33 = vcvtps_u32_f32(result.n128_f32[0]);
    if (v32 <= v33)
      prime = (int8x8_t)v33;
    else
      prime = (int8x8_t)v32;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
    }
    v22 = *(_QWORD *)(a1 + 232);
    if (*(_QWORD *)&prime > v22)
      goto LABEL_54;
    if (*(_QWORD *)&prime < v22)
    {
      v40 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 248) / *(float *)(a1 + 256));
      if (v22 < 3
        || (result.n128_u64[0] = (unint64_t)vcnt_s8((int8x8_t)v22),
            result.n128_u16[0] = vaddlv_u8((uint8x8_t)result.n128_u64[0]),
            result.n128_u32[0] > 1uLL))
      {
        v40 = std::__next_prime(v40);
      }
      else
      {
        v41 = 1 << -(char)__clz(v40 - 1);
        if (v40 >= 2)
          v40 = v41;
      }
      if (*(_QWORD *)&prime <= v40)
        prime = (int8x8_t)v40;
      if (*(_QWORD *)&prime >= v22)
      {
        v22 = *(_QWORD *)(a1 + 232);
      }
      else
      {
        if (prime)
        {
LABEL_54:
          if (*(_QWORD *)&prime >> 61)
            std::__throw_bad_array_new_length[abi:ne180100]();
          v35 = operator new(8 * *(_QWORD *)&prime);
          v36 = (_QWORD *)*v7;
          *v7 = v35;
          if (v36)
            operator delete(v36);
          v37 = 0;
          *(int8x8_t *)(a1 + 232) = prime;
          do
            *(_QWORD *)(*v7 + 8 * v37++) = 0;
          while (*(_QWORD *)&prime != v37);
          v38 = *(_QWORD **)(a1 + 240);
          if (v38)
          {
            v39 = v38[1];
            result.n128_u64[0] = (unint64_t)vcnt_s8(prime);
            result.n128_u16[0] = vaddlv_u8((uint8x8_t)result.n128_u64[0]);
            if (result.n128_u32[0] > 1uLL)
            {
              if (v39 >= *(_QWORD *)&prime)
                v39 %= *(_QWORD *)&prime;
            }
            else
            {
              v39 &= *(_QWORD *)&prime - 1;
            }
            *(_QWORD *)(*v7 + 8 * v39) = a1 + 240;
            v42 = (_QWORD *)*v38;
            if (*v38)
            {
              do
              {
                v43 = v42[1];
                if (result.n128_u32[0] > 1uLL)
                {
                  if (v43 >= *(_QWORD *)&prime)
                    v43 %= *(_QWORD *)&prime;
                }
                else
                {
                  v43 &= *(_QWORD *)&prime - 1;
                }
                if (v43 != v39)
                {
                  if (!*(_QWORD *)(*v7 + 8 * v43))
                  {
                    *(_QWORD *)(*v7 + 8 * v43) = v38;
                    goto LABEL_79;
                  }
                  *v38 = *v42;
                  *v42 = **(_QWORD **)(*v7 + 8 * v43);
                  **(_QWORD **)(*v7 + 8 * v43) = v42;
                  v42 = v38;
                }
                v43 = v39;
LABEL_79:
                v38 = v42;
                v42 = (_QWORD *)*v42;
                v39 = v43;
              }
              while (v42);
            }
          }
          v22 = (unint64_t)prime;
          goto LABEL_83;
        }
        v49 = (_QWORD *)*v7;
        *v7 = 0;
        if (v49)
          operator delete(v49);
        v22 = 0;
        *(_QWORD *)(a1 + 232) = 0;
      }
    }
LABEL_83:
    if ((v22 & (v22 - 1)) != 0)
    {
      if (v21 >= v22)
        v3 = v21 % v22;
      else
        v3 = v21;
    }
    else
    {
      v3 = (v22 - 1) & v21;
    }
    goto LABEL_88;
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "null_label");
  v13 = (re *)re::audio::throttledLog(OS_LOG_TYPE_ERROR, (__int128 *)__p);
  v15 = (int)v13;
  if (v51 < 0)
  {
    operator delete(__p[0]);
    if (!v15)
      return result;
  }
  else if (!(_DWORD)v13)
  {
    return result;
  }
  v19 = *re::audioLogObjects(v13);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    LOWORD(__p[0]) = 0;
    _os_log_error_impl(&dword_224FE9000, v19, OS_LOG_TYPE_ERROR, "[RE/STS] AudioManager storePendingStateForSTSLabel given null label", (uint8_t *)__p, 2u);
  }
  return result;
}

void sub_22541CDBC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t re::AudioManager::enumerateTrackedCALayerEntities(uint64_t result, uint64_t a2)
{
  int8x8_t *v2;
  unint64_t *v3;
  unint64_t *i;
  int8x8_t v6;
  unint64_t v7;
  uint8x8_t v8;
  unint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  unint64_t v12;
  unint64_t v13;

  if (*(_BYTE *)(result + 56))
  {
    v2 = (int8x8_t *)result;
    v3 = *(unint64_t **)(result + 472);
    for (i = *(unint64_t **)(result + 480); v3 != i; ++v3)
    {
      v6 = v2[55];
      if (!*(_QWORD *)&v6)
        goto LABEL_22;
      v7 = *v3;
      v8 = (uint8x8_t)vcnt_s8(v6);
      v8.i16[0] = vaddlv_u8(v8);
      if (v8.u32[0] > 1uLL)
      {
        v9 = *v3;
        if (*(_QWORD *)&v6 <= v7)
          v9 = v7 % *(_QWORD *)&v6;
      }
      else
      {
        v9 = (*(_QWORD *)&v6 - 1) & v7;
      }
      v10 = *(_QWORD **)(*(_QWORD *)&v2[54] + 8 * v9);
      if (!v10 || (v11 = (_QWORD *)*v10) == 0)
LABEL_22:
        std::__throw_out_of_range[abi:ne180100]();
      while (1)
      {
        v12 = v11[1];
        if (v12 == v7)
          break;
        if (v8.u32[0] > 1uLL)
        {
          if (v12 >= *(_QWORD *)&v6)
            v12 %= *(_QWORD *)&v6;
        }
        else
        {
          v12 &= *(_QWORD *)&v6 - 1;
        }
        if (v12 != v9)
          goto LABEL_22;
LABEL_18:
        v11 = (_QWORD *)*v11;
        if (!v11)
          goto LABEL_22;
      }
      if (v11[2] != v7)
        goto LABEL_18;
      v13 = *v3;
      result = (*(uint64_t (**)(_QWORD, unint64_t *))(**(_QWORD **)(a2 + 32) + 16))(*(_QWORD *)(a2 + 32), &v13);
    }
  }
  return result;
}

CFHashCode re::AudioManager::CFStringHash::operator()(const void *a1)
{
  re *v2;
  int v3;
  NSObject *v4;
  void *__p[2];
  char v6;

  if (a1)
    return CFHash(a1);
  std::string::basic_string[abi:ne180100]<0>(__p, "null_hash_key");
  v2 = (re *)re::audio::throttledLog(OS_LOG_TYPE_FAULT, (__int128 *)__p);
  v3 = (int)v2;
  if ((v6 & 0x80000000) == 0)
  {
    if (!(_DWORD)v2)
      return 0;
LABEL_7:
    v4 = *re::audioLogObjects(v2);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_fault_impl(&dword_224FE9000, v4, OS_LOG_TYPE_FAULT, "[RE/STS] hash key is null", (uint8_t *)__p, 2u);
    }
    return 0;
  }
  operator delete(__p[0]);
  if (v3)
    goto LABEL_7;
  return 0;
}

void sub_22541CFB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

BOOL re::AudioManager::CFStringEqual::operator()(const __CFString *a1, const __CFString *a2)
{
  re *v2;
  int v3;
  _BOOL8 result;
  re *v5;
  int v6;
  NSObject *v7;
  NSObject *v8;
  void *__p[2];
  char v10;

  if (!((unint64_t)a1 | (unint64_t)a2))
  {
    std::string::basic_string[abi:ne180100]<0>(__p, "null_equal_keys");
    v2 = (re *)re::audio::throttledLog(OS_LOG_TYPE_FAULT, (__int128 *)__p);
    v3 = (int)v2;
    if (v10 < 0)
    {
      operator delete(__p[0]);
      if (!v3)
        return 1;
    }
    else if (!(_DWORD)v2)
    {
      return 1;
    }
    v7 = *re::audioLogObjects(v2);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_fault_impl(&dword_224FE9000, v7, OS_LOG_TYPE_FAULT, "[RE/STS] equal keys are null", (uint8_t *)__p, 2u);
    }
    return 1;
  }
  if (a1 && a2)
    return CFStringCompare(a1, a2, 0) == kCFCompareEqualTo;
  std::string::basic_string[abi:ne180100]<0>(__p, "null_equal_key");
  v5 = (re *)re::audio::throttledLog(OS_LOG_TYPE_FAULT, (__int128 *)__p);
  v6 = (int)v5;
  if (v10 < 0)
  {
    operator delete(__p[0]);
    if (!v6)
      return 0;
  }
  else if (!(_DWORD)v5)
  {
    return 0;
  }
  v8 = *re::audioLogObjects(v5);
  result = os_log_type_enabled(v8, OS_LOG_TYPE_FAULT);
  if (!result)
    return result;
  LOWORD(__p[0]) = 0;
  _os_log_fault_impl(&dword_224FE9000, v8, OS_LOG_TYPE_FAULT, "[RE/STS] one equal key is null", (uint8_t *)__p, 2u);
  return 0;
}

void sub_22541D11C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t re::AudioManager::setExternalSourceControl(uint64_t this, char a2)
{
  *(_BYTE *)(this + 272) = a2;
  return this;
}

uint64_t re::AudioManager::getExternalSourceControl(re::AudioManager *this)
{
  return *((unsigned __int8 *)this + 272);
}

void re::AudioManager::setSTSControl(re::AudioManager *this, int a2)
{
  uint64_t v2;

  *((_BYTE *)this + 56) = a2;
  v2 = *((_QWORD *)this + 8);
  if (a2)
  {
    if (v2)
      return;
LABEL_5:
    re::AudioManager::configureSTS(this);
    return;
  }
  if (v2)
    goto LABEL_5;
}

void re::AudioManager::configureSTS(re::AudioManager *this)
{
  const void *v2;
  CFTypeRef *v3;
  void *v4;
  re *v5;
  NSObject *v6;
  const __CFAllocator *v7;
  re *v8;
  int v9;
  NSObject *v10;
  id v11;
  CFTypeRef v12;
  uint64_t v13;
  id v14;
  void *v15;
  re *v16;
  uint64_t HexCFStringForInt;
  CFDataRef v18;
  CFTypeRef v19;
  re *VTable;
  uint64_t (*v21)(CFTypeRef, _QWORD, uint64_t, CFDataRef);
  int v22;
  NSObject *v23;
  NSObject *v24;
  _QWORD *i;
  UInt8 bytes[4];
  id v27;
  uint8_t buf[4];
  id v29;
  uint64_t v30;

  v30 = *MEMORY[0x24BDAC8D0];
  v3 = (CFTypeRef *)((char *)this + 64);
  v2 = (const void *)*((_QWORD *)this + 8);
  if (v2)
  {
    CFRelease(v2);
    *v3 = 0;
  }
  v4 = (void *)*((_QWORD *)this + 9);
  *((_QWORD *)this + 9) = 0;

  if (*((_BYTE *)this + 56))
  {
    v6 = *re::audioLogObjects(v5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_224FE9000, v6, OS_LOG_TYPE_DEFAULT, "[RE/STS] Configuring STS controller", buf, 2u);
    }
    v7 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
    v8 = (re *)FigSTSCreateRemote();
    v9 = (int)v8;
    if ((_DWORD)v8)
    {
      v10 = *re::audioLogObjects(v8);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109120;
        LODWORD(v29) = v9;
        _os_log_error_impl(&dword_224FE9000, v10, OS_LOG_TYPE_ERROR, "[RE/STS] Failed to create FigSTS object error=%d", buf, 8u);
      }
      *v3 = 0;
      return;
    }
    v11 = objc_alloc(MEMORY[0x24BDB6BF0]);
    v12 = *v3;
    v27 = 0;
    v13 = objc_msgSend(v11, "initWithSTSObject:error:", v12, &v27);
    v14 = v27;
    v15 = (void *)*((_QWORD *)this + 9);
    *((_QWORD *)this + 9) = v13;

    if (!*((_QWORD *)this + 9))
    {
      v23 = *re::audioLogObjects(v16);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138412290;
        v29 = v14;
        _os_log_error_impl(&dword_224FE9000, v23, OS_LOG_TYPE_ERROR, "[RE/STS] Failed to create STSController object: %@", buf, 0xCu);
      }
      CFRelease(*v3);
      *v3 = 0;
      goto LABEL_18;
    }
    if (!REAudioShouldConfigureTuningForSTSLabels())
    {
LABEL_24:
      for (i = (_QWORD *)((char *)this + 32);
            ;
            (*(void (**)(re::AudioManager *, _QWORD))(*(_QWORD *)this + 944))(this, i[2]))
      {
        i = (_QWORD *)*i;
        if (!i)
          break;
      }
LABEL_18:

      return;
    }
    *(_DWORD *)bytes = 1;
    HexCFStringForInt = re::AudioManager::getHexCFStringForInt(this, 3109);
    v18 = CFDataCreate(v7, bytes, 4);
    v19 = *v3;
    VTable = (re *)CMBaseObjectGetVTable();
    v21 = *(uint64_t (**)(CFTypeRef, _QWORD, uint64_t, CFDataRef))(*((_QWORD *)VTable + 2) + 24);
    if (v21)
    {
      VTable = (re *)v21(v19, *MEMORY[0x24BE649F0], HexCFStringForInt, v18);
      v22 = (int)VTable;
      if (!(_DWORD)VTable)
      {
LABEL_23:
        CFRelease(v18);
        goto LABEL_24;
      }
    }
    else
    {
      v22 = -12782;
    }
    v24 = *re::audioLogObjects(VTable);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      LODWORD(v29) = v22;
      _os_log_error_impl(&dword_224FE9000, v24, OS_LOG_TYPE_ERROR, "[RE/STS] FigSTSSetPropertyByLabel propagation delay enabled error=%d", buf, 8u);
    }
    goto LABEL_23;
  }
}

void sub_22541D458(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void re::AudioManager::setSTSObjects(uint64_t a1, const void *a2, void *a3)
{
  const void *v6;
  id v7;

  v7 = a3;
  v6 = *(const void **)(a1 + 64);
  if (v6)
    CFRelease(v6);
  *(_QWORD *)(a1 + 64) = CFRetain(a2);
  objc_storeStrong((id *)(a1 + 72), a3);
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 512))(a1, 1);

}

void sub_22541D4F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

uint64_t re::AudioManager::getSTSControl(re::AudioManager *this)
{
  return *((unsigned __int8 *)this + 56);
}

void re::AudioManager::setSystemListenerID(re::AudioManager *this, uint64_t a2)
{
  NSObject *v4;
  uint64_t v5;
  _QWORD *i;
  int v7;
  uint64_t v8;
  __int16 v9;
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  if (*((_QWORD *)this + 33) != a2)
  {
    v4 = *re::audioLogObjects(this);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
      v5 = *((_QWORD *)this + 33);
      v7 = 134218240;
      v8 = v5;
      v9 = 2048;
      v10 = a2;
      _os_log_impl(&dword_224FE9000, v4, OS_LOG_TYPE_INFO, "Changing RE's system listener ID from %llu to %llu", (uint8_t *)&v7, 0x16u);
    }
    *((_QWORD *)this + 33) = a2;
    for (i = (_QWORD *)*((_QWORD *)this + 4); i; i = (_QWORD *)*i)
    {
      if (i[3] == a2)
        (*(void (**)(re::AudioManager *, _QWORD))(*(_QWORD *)this + 944))(this, i[2]);
    }
  }
}

uint64_t re::AudioManager::currentAudioOutputType(re::AudioManager *this)
{
  return 0;
}

void re::AudioManager::sessionForID(os_unfair_lock_s *this@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  re::AudioSessionCache::sessionForID(this + 90, a2, a3);
}

uint64_t re::AudioManager::addSession(os_unfair_lock_s *this, AVAudioSession *a2)
{
  return re::AudioSessionCache::addSession(this + 90, a2);
}

void re::AudioManager::keepSessionAlive(os_unfair_lock_s *this, unsigned int a2)
{
  re::AudioSessionCache::keepSessionAlive(this + 90, a2);
}

uint64_t re::AudioManager::setSessionUsageRemovalTimer(uint64_t this, uint64_t a2)
{
  *(_QWORD *)(this + 424) = a2;
  return this;
}

uint64_t re::AudioService::addPlaybackConnectionDisconnectCallback()
{
  return 0;
}

uint64_t re::AudioService::isAudioManagerStateReady(re::AudioService *this)
{
  return 1;
}

uint64_t re::AudioService::createSamplerDefinitionForToken(re::AudioService *this)
{
  return 0;
}

__n128 re::AudioService::getPHASESourceTransformForToken(re::AudioService *this)
{
  return *(__n128 *)MEMORY[0x24BDAEE00];
}

uint64_t re::AudioService::getPHASEAssetForIdentifier(re::AudioService *this)
{
  return 0;
}

uint64_t re::AudioService::getPHASESourceForEntityID(re::AudioService *this)
{
  return 0;
}

uint64_t re::AudioManager::applyMixGroupState(re::AudioManager *this, unint64_t a2, unint64_t a3, const re::AudioMixGroup *a4)
{
  return 0;
}

void re::AudioService::setEngineQueue(uint64_t a1, void *a2)
{
  objc_storeStrong((id *)(a1 + 8), a2);
}

uint64_t re::AudioService::handlesPlaybackForFileAndBufferResources(re::AudioService *this)
{
  return 1;
}

uint64_t re::AudioService::controlsPlaybackForGeneratorResources(re::AudioService *this)
{
  return 1;
}

uint64_t re::AudioService::getConfigurationForExternalStreamController()
{
  return 0;
}

uint64_t re::AudioService::copyOrCreateEndpointForPlaybackHostingService(re::AudioService *this)
{
  return 0;
}

uint64_t re::AudioService::shouldLoadFileAssetsByAbsolutePath(re::AudioService *this)
{
  return 0;
}

uint64_t re::AudioService::playbackHostConnectionIdentifier(re::AudioService *this)
{
  return 0;
}

uint64_t re::AudioService::getRequiresAudioSessionForPlayback(re::AudioService *this)
{
  return 0;
}

uint64_t re::AudioService::currentAudioOutputType(re::AudioService *this)
{
  return 0;
}

uint64_t re::AudioService::stsObject(re::AudioService *this)
{
  return 0;
}

void re::AudioService::sessionForID(uint64_t a1@<X8>)
{
  *(_DWORD *)(a1 + 8) = 2;
}

uint64_t re::AudioService::addSession(re::AudioService *this, AVAudioSession *a2)
{
  return 0;
}

uint64_t std::__hash_table<std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>,std::__unordered_map_hasher<REAudioServicesNotificationCallbackConfiguration,std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>,REAudioServicesNotificationCallbackRegistry::ConfigHasher,std::equal_to<REAudioServicesNotificationCallbackConfiguration>,true>,std::__unordered_map_equal<REAudioServicesNotificationCallbackConfiguration,std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>,std::equal_to<REAudioServicesNotificationCallbackConfiguration>,REAudioServicesNotificationCallbackRegistry::ConfigHasher,true>,std::allocator<std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>,std::__unordered_map_hasher<REAudioServicesNotificationCallbackConfiguration,std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>,REAudioServicesNotificationCallbackRegistry::ConfigHasher,std::equal_to<REAudioServicesNotificationCallbackConfiguration>,true>,std::__unordered_map_equal<REAudioServicesNotificationCallbackConfiguration,std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>,std::equal_to<REAudioServicesNotificationCallbackConfiguration>,REAudioServicesNotificationCallbackRegistry::ConfigHasher,true>,std::allocator<std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>>>::__deallocate_node(a1, *(id **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>,std::__unordered_map_hasher<REAudioServicesNotificationCallbackConfiguration,std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>,REAudioServicesNotificationCallbackRegistry::ConfigHasher,std::equal_to<REAudioServicesNotificationCallbackConfiguration>,true>,std::__unordered_map_equal<REAudioServicesNotificationCallbackConfiguration,std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>,std::equal_to<REAudioServicesNotificationCallbackConfiguration>,REAudioServicesNotificationCallbackRegistry::ConfigHasher,true>,std::allocator<std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>>>::__deallocate_node(uint64_t a1, id *a2)
{
  id *v2;
  id *v3;

  if (a2)
  {
    v2 = a2;
    do
    {
      v3 = (id *)*v2;

      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>>>::__deallocate_node(a1, *(_QWORD **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>>>::__deallocate_node(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;

  if (a2)
  {
    v2 = a2;
    do
    {
      v3 = (_QWORD *)*v2;
      std::__hash_table<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene::PerConnectionState>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene::PerConnectionState>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene::PerConnectionState>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene::PerConnectionState>>>::~__hash_table((uint64_t)(v2 + 7));
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene::PerConnectionState>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene::PerConnectionState>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene::PerConnectionState>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene::PerConnectionState>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene::PerConnectionState>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene::PerConnectionState>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene::PerConnectionState>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene::PerConnectionState>>>::__deallocate_node(a1, *(_QWORD **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene::PerConnectionState>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene::PerConnectionState>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene::PerConnectionState>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene::PerConnectionState>>>::__deallocate_node(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;

  if (a2)
  {
    v2 = a2;
    do
    {
      v3 = (_QWORD *)*v2;
      std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table((uint64_t)(v2 + 8));
      std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table((uint64_t)(v2 + 3));
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

uint64_t std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<std::string,double>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,double>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,double>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,double>>>::__deallocate_node(a1, *(void ***)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

id **std::unique_ptr<re::AudioManager::PrivateData>::reset[abi:ne180100](id **result, id *a2)
{
  id *v2;

  v2 = *result;
  *result = a2;
  if (v2)
  {

    JUMPOUT(0x2276933B8);
  }
  return result;
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned long long,__CFString const*>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,__CFString const*>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,__CFString const*>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,__CFString const*>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(uint64_t a1, unint64_t a2, _QWORD *a3)
{
  unint64_t v3;
  unint64_t v7;
  uint8x8_t v8;
  _QWORD **v9;
  _QWORD *i;
  unint64_t v11;
  float v12;
  float v13;
  _BOOL8 v14;
  unint64_t v15;
  unint64_t v16;
  size_t v17;
  uint64_t v18;
  _QWORD *v19;
  unint64_t v20;

  v7 = *(_QWORD *)(a1 + 8);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = a2;
      if (v7 <= a2)
        v3 = a2 % v7;
    }
    else
    {
      v3 = (v7 - 1) & a2;
    }
    v9 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      for (i = *v9; i; i = (_QWORD *)*i)
      {
        v11 = i[1];
        if (v11 == a2)
        {
          if (i[2] == a2)
            return i;
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7)
              v11 %= v7;
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v3)
            break;
        }
      }
    }
  }
  i = operator new(0x20uLL);
  *i = 0;
  i[1] = a2;
  i[2] = *a3;
  i[3] = 0;
  v12 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    v14 = 1;
    if (v7 >= 3)
      v14 = (v7 & (v7 - 1)) != 0;
    v15 = v14 | (2 * v7);
    v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16)
      v17 = v16;
    else
      v17 = v15;
    std::__hash_table<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>>>::__rehash<true>(a1, v17);
    v7 = *(_QWORD *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= a2)
        v3 = a2 % v7;
      else
        v3 = a2;
    }
    else
    {
      v3 = (v7 - 1) & a2;
    }
  }
  v18 = *(_QWORD *)a1;
  v19 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v19)
  {
    *i = *v19;
LABEL_38:
    *v19 = i;
    goto LABEL_39;
  }
  *i = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = i;
  *(_QWORD *)(v18 + 8 * v3) = a1 + 16;
  if (*i)
  {
    v20 = *(_QWORD *)(*i + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7)
        v20 %= v7;
    }
    else
    {
      v20 &= v7 - 1;
    }
    v19 = (_QWORD *)(*(_QWORD *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return i;
}

void sub_22541DB30(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__hash_table<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>>>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t i;

  if (*(_QWORD *)(a1 + 24))
  {
    std::__hash_table<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>>>::__deallocate_node(a1, *(_QWORD **)(a1 + 16));
    *(_QWORD *)(a1 + 16) = 0;
    v2 = *(_QWORD *)(a1 + 8);
    if (v2)
    {
      for (i = 0; i != v2; ++i)
        *(_QWORD *)(*(_QWORD *)a1 + 8 * i) = 0;
    }
    *(_QWORD *)(a1 + 24) = 0;
  }
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(uint64_t a1, unint64_t *a2, uint64_t a3, _QWORD **a4)
{
  unint64_t v4;
  unint64_t v7;
  unint64_t v8;
  uint8x8_t v9;
  _QWORD **v10;
  _QWORD *i;
  unint64_t v12;
  _QWORD *v13;
  char *v14;
  float v15;
  float v16;
  _BOOL8 v17;
  unint64_t v18;
  unint64_t v19;
  int8x8_t prime;
  void *v21;
  void *v22;
  uint64_t v23;
  _QWORD *v24;
  unint64_t v25;
  uint8x8_t v26;
  unint64_t v27;
  uint8x8_t v28;
  uint64_t v29;
  _QWORD *v30;
  unint64_t v31;
  _QWORD *v32;
  unint64_t v33;
  void *v35;
  _QWORD v36[2];
  char v37;

  v7 = *a2;
  v8 = *(_QWORD *)(a1 + 8);
  if (v8)
  {
    v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      v4 = *a2;
      if (v7 >= v8)
        v4 = v7 % v8;
    }
    else
    {
      v4 = (v8 - 1) & v7;
    }
    v10 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v4);
    if (v10)
    {
      for (i = *v10; i; i = (_QWORD *)*i)
      {
        v12 = i[1];
        if (v12 == v7)
        {
          if (i[2] == v7)
            return i;
        }
        else
        {
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= v8)
              v12 %= v8;
          }
          else
          {
            v12 &= v8 - 1;
          }
          if (v12 != v4)
            break;
        }
      }
    }
  }
  v13 = (_QWORD *)(a1 + 16);
  v14 = (char *)operator new(0x68uLL);
  v36[0] = v14;
  v36[1] = a1 + 16;
  *(_QWORD *)v14 = 0;
  *((_QWORD *)v14 + 1) = v7;
  *((_QWORD *)v14 + 2) = **a4;
  *(_OWORD *)(v14 + 24) = 0u;
  *(_OWORD *)(v14 + 40) = 0u;
  *((_QWORD *)v14 + 11) = 0;
  *((_QWORD *)v14 + 12) = 0;
  *(_OWORD *)(v14 + 72) = 0u;
  *(_OWORD *)(v14 + 56) = 0u;
  *((_QWORD *)v14 + 4) = -1;
  v14[40] = 1;
  *((_QWORD *)v14 + 6) = -1;
  *((_DWORD *)v14 + 22) = 1065353216;
  v37 = 1;
  v15 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v16 = *(float *)(a1 + 32);
  if (!v8 || (float)(v16 * (float)v8) < v15)
  {
    v17 = 1;
    if (v8 >= 3)
      v17 = (v8 & (v8 - 1)) != 0;
    v18 = v17 | (2 * v8);
    v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19)
      prime = (int8x8_t)v19;
    else
      prime = (int8x8_t)v18;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
      v8 = *(_QWORD *)(a1 + 8);
    }
    if (*(_QWORD *)&prime > v8)
      goto LABEL_30;
    if (*(_QWORD *)&prime < v8)
    {
      v27 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v8 < 3 || (v28 = (uint8x8_t)vcnt_s8((int8x8_t)v8), v28.i16[0] = vaddlv_u8(v28), v28.u32[0] > 1uLL))
      {
        v27 = std::__next_prime(v27);
      }
      else
      {
        v29 = 1 << -(char)__clz(v27 - 1);
        if (v27 >= 2)
          v27 = v29;
      }
      if (*(_QWORD *)&prime <= v27)
        prime = (int8x8_t)v27;
      if (*(_QWORD *)&prime >= v8)
      {
        v8 = *(_QWORD *)(a1 + 8);
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(_QWORD *)&prime >> 61)
            std::__throw_bad_array_new_length[abi:ne180100]();
          v21 = operator new(8 * *(_QWORD *)&prime);
          v22 = *(void **)a1;
          *(_QWORD *)a1 = v21;
          if (v22)
            operator delete(v22);
          v23 = 0;
          *(int8x8_t *)(a1 + 8) = prime;
          do
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v23++) = 0;
          while (*(_QWORD *)&prime != v23);
          v24 = (_QWORD *)*v13;
          if (*v13)
          {
            v25 = v24[1];
            v26 = (uint8x8_t)vcnt_s8(prime);
            v26.i16[0] = vaddlv_u8(v26);
            if (v26.u32[0] > 1uLL)
            {
              if (v25 >= *(_QWORD *)&prime)
                v25 %= *(_QWORD *)&prime;
            }
            else
            {
              v25 &= *(_QWORD *)&prime - 1;
            }
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v25) = v13;
            v30 = (_QWORD *)*v24;
            if (*v24)
            {
              do
              {
                v31 = v30[1];
                if (v26.u32[0] > 1uLL)
                {
                  if (v31 >= *(_QWORD *)&prime)
                    v31 %= *(_QWORD *)&prime;
                }
                else
                {
                  v31 &= *(_QWORD *)&prime - 1;
                }
                if (v31 != v25)
                {
                  if (!*(_QWORD *)(*(_QWORD *)a1 + 8 * v31))
                  {
                    *(_QWORD *)(*(_QWORD *)a1 + 8 * v31) = v24;
                    goto LABEL_55;
                  }
                  *v24 = *v30;
                  *v30 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v31);
                  **(_QWORD **)(*(_QWORD *)a1 + 8 * v31) = v30;
                  v30 = v24;
                }
                v31 = v25;
LABEL_55:
                v24 = v30;
                v30 = (_QWORD *)*v30;
                v25 = v31;
              }
              while (v30);
            }
          }
          v8 = (unint64_t)prime;
          goto LABEL_59;
        }
        v35 = *(void **)a1;
        *(_QWORD *)a1 = 0;
        if (v35)
          operator delete(v35);
        v8 = 0;
        *(_QWORD *)(a1 + 8) = 0;
      }
    }
LABEL_59:
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8)
        v4 = v7 % v8;
      else
        v4 = v7;
    }
    else
    {
      v4 = (v8 - 1) & v7;
    }
  }
  v32 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  i = (_QWORD *)v36[0];
  if (v32)
  {
    *(_QWORD *)v36[0] = *v32;
LABEL_72:
    *v32 = i;
    goto LABEL_73;
  }
  *(_QWORD *)v36[0] = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = i;
  *(_QWORD *)(*(_QWORD *)a1 + 8 * v4) = v13;
  if (*i)
  {
    v33 = *(_QWORD *)(*i + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v33 >= v8)
        v33 %= v8;
    }
    else
    {
      v33 &= v8 - 1;
    }
    v32 = (_QWORD *)(*(_QWORD *)a1 + 8 * v33);
    goto LABEL_72;
  }
LABEL_73:
  v36[0] = 0;
  ++*(_QWORD *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,void *>>>>::reset[abi:ne180100]((uint64_t)v36);
  return i;
}

void sub_22541DFD4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,void *>>>>::reset[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene>,void *>>>>::reset[abi:ne180100](uint64_t a1)
{
  void *v1;

  v1 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__hash_table<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene::PerConnectionState>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene::PerConnectionState>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene::PerConnectionState>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene::PerConnectionState>>>::~__hash_table((uint64_t)v1 + 56);
    operator delete(v1);
  }
}

char *std::__hash_table<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene::PerConnectionState>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene::PerConnectionState>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene::PerConnectionState>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene::PerConnectionState>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(uint64_t *a1, unint64_t a2, _QWORD *a3)
{
  unint64_t v3;
  unint64_t v5;
  unint64_t v7;
  uint8x8_t v8;
  void **v9;
  char *v10;
  unint64_t v11;
  _QWORD *v12;
  float v13;
  float v14;
  _BOOL8 v15;
  unint64_t v16;
  unint64_t v17;
  int8x8_t prime;
  void *v19;
  void *v20;
  uint64_t v21;
  _QWORD *v22;
  unint64_t v23;
  uint8x8_t v24;
  unint64_t v25;
  uint8x8_t v26;
  uint64_t v27;
  _QWORD *v28;
  unint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  unint64_t v32;
  void *v34;

  v5 = a2;
  v7 = a1[1];
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = a2;
      if (v7 <= a2)
        v3 = a2 % v7;
    }
    else
    {
      v3 = (v7 - 1) & a2;
    }
    v9 = *(void ***)(*a1 + 8 * v3);
    if (v9)
    {
      v10 = (char *)*v9;
      if (*v9)
      {
        do
        {
          v11 = *((_QWORD *)v10 + 1);
          if (v11 == a2)
          {
            if (*((_QWORD *)v10 + 2) == a2)
              return v10;
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7)
                v11 %= v7;
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3)
              break;
          }
          v10 = *(char **)v10;
        }
        while (v10);
      }
    }
  }
  v12 = a1 + 2;
  v10 = (char *)operator new(0x68uLL);
  *(_QWORD *)v10 = 0;
  *((_QWORD *)v10 + 1) = v5;
  *((_QWORD *)v10 + 2) = *a3;
  *(_OWORD *)(v10 + 56) = 0u;
  *(_OWORD *)(v10 + 72) = 0u;
  *(_OWORD *)(v10 + 88) = 0u;
  *(_OWORD *)(v10 + 24) = 0u;
  *(_OWORD *)(v10 + 40) = 0u;
  *((_DWORD *)v10 + 14) = 1065353216;
  *((_OWORD *)v10 + 4) = 0u;
  *((_OWORD *)v10 + 5) = 0u;
  *((_DWORD *)v10 + 24) = 1065353216;
  v13 = (float)(unint64_t)(a1[3] + 1);
  v14 = *((float *)a1 + 8);
  if (v7 && (float)(v14 * (float)v7) >= v13)
  {
    v5 = v3;
    goto LABEL_64;
  }
  v15 = 1;
  if (v7 >= 3)
    v15 = (v7 & (v7 - 1)) != 0;
  v16 = v15 | (2 * v7);
  v17 = vcvtps_u32_f32(v13 / v14);
  if (v16 <= v17)
    prime = (int8x8_t)v17;
  else
    prime = (int8x8_t)v16;
  if (*(_QWORD *)&prime == 1)
  {
    prime = (int8x8_t)2;
  }
  else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
  {
    prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
    v7 = a1[1];
  }
  if (*(_QWORD *)&prime <= v7)
  {
    if (*(_QWORD *)&prime >= v7)
      goto LABEL_60;
    v25 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
    if (v7 < 3 || (v26 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v26.i16[0] = vaddlv_u8(v26), v26.u32[0] > 1uLL))
    {
      v25 = std::__next_prime(v25);
    }
    else
    {
      v27 = 1 << -(char)__clz(v25 - 1);
      if (v25 >= 2)
        v25 = v27;
    }
    if (*(_QWORD *)&prime <= v25)
      prime = (int8x8_t)v25;
    if (*(_QWORD *)&prime >= v7)
    {
      v7 = a1[1];
      goto LABEL_60;
    }
    if (!*(_QWORD *)&prime)
    {
      v34 = (void *)*a1;
      *a1 = 0;
      if (v34)
        operator delete(v34);
      v7 = 0;
      a1[1] = 0;
      goto LABEL_60;
    }
  }
  if (*(_QWORD *)&prime >> 61)
    std::__throw_bad_array_new_length[abi:ne180100]();
  v19 = operator new(8 * *(_QWORD *)&prime);
  v20 = (void *)*a1;
  *a1 = (uint64_t)v19;
  if (v20)
    operator delete(v20);
  v21 = 0;
  a1[1] = (uint64_t)prime;
  do
    *(_QWORD *)(*a1 + 8 * v21++) = 0;
  while (*(_QWORD *)&prime != v21);
  v22 = (_QWORD *)*v12;
  if (*v12)
  {
    v23 = v22[1];
    v24 = (uint8x8_t)vcnt_s8(prime);
    v24.i16[0] = vaddlv_u8(v24);
    if (v24.u32[0] > 1uLL)
    {
      if (v23 >= *(_QWORD *)&prime)
        v23 %= *(_QWORD *)&prime;
    }
    else
    {
      v23 &= *(_QWORD *)&prime - 1;
    }
    *(_QWORD *)(*a1 + 8 * v23) = v12;
    v28 = (_QWORD *)*v22;
    if (*v22)
    {
      do
      {
        v29 = v28[1];
        if (v24.u32[0] > 1uLL)
        {
          if (v29 >= *(_QWORD *)&prime)
            v29 %= *(_QWORD *)&prime;
        }
        else
        {
          v29 &= *(_QWORD *)&prime - 1;
        }
        if (v29 != v23)
        {
          if (!*(_QWORD *)(*a1 + 8 * v29))
          {
            *(_QWORD *)(*a1 + 8 * v29) = v22;
            goto LABEL_56;
          }
          *v22 = *v28;
          *v28 = **(_QWORD **)(*a1 + 8 * v29);
          **(_QWORD **)(*a1 + 8 * v29) = v28;
          v28 = v22;
        }
        v29 = v23;
LABEL_56:
        v22 = v28;
        v28 = (_QWORD *)*v28;
        v23 = v29;
      }
      while (v28);
    }
  }
  v7 = (unint64_t)prime;
LABEL_60:
  if ((v7 & (v7 - 1)) != 0)
  {
    if (v7 <= v5)
      v5 %= v7;
  }
  else
  {
    v5 &= v7 - 1;
  }
LABEL_64:
  v30 = *a1;
  v31 = *(_QWORD **)(*a1 + 8 * v5);
  if (v31)
  {
    *(_QWORD *)v10 = *v31;
LABEL_72:
    *v31 = v10;
    goto LABEL_73;
  }
  *(_QWORD *)v10 = *v12;
  *v12 = v10;
  *(_QWORD *)(v30 + 8 * v5) = v12;
  if (*(_QWORD *)v10)
  {
    v32 = *(_QWORD *)(*(_QWORD *)v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v32 >= v7)
        v32 %= v7;
    }
    else
    {
      v32 &= v7 - 1;
    }
    v31 = (_QWORD *)(*a1 + 8 * v32);
    goto LABEL_72;
  }
LABEL_73:
  ++a1[3];
  return v10;
}

void sub_22541E42C(_Unwind_Exception *a1)
{
  void *v1;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene::PerConnectionState>,void *>>>::operator()[abi:ne180100](1, v1);
  _Unwind_Resume(a1);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,re::AudioManager::AudioScene::PerConnectionState>,void *>>>::operator()[abi:ne180100](char a1, void *__p)
{
  if (a1)
  {
    std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table((uint64_t)__p + 64);
    std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table((uint64_t)__p + 24);
  }
  if (__p)
    operator delete(__p);
}

uint64_t std::__hash_table<std::__hash_value_type<__CFString const*,re::AudioManager::RESTSPerLabelState>,std::__unordered_map_hasher<__CFString const*,std::__hash_value_type<__CFString const*,re::AudioManager::RESTSPerLabelState>,re::AudioManager::CFStringHash,re::AudioManager::CFStringEqual,true>,std::__unordered_map_equal<__CFString const*,std::__hash_value_type<__CFString const*,re::AudioManager::RESTSPerLabelState>,re::AudioManager::CFStringEqual,re::AudioManager::CFStringHash,true>,std::allocator<std::__hash_value_type<__CFString const*,re::AudioManager::RESTSPerLabelState>>>::erase(_QWORD *a1, uint64_t *__p)
{
  int8x8_t v2;
  unint64_t v3;
  uint64_t v4;
  uint8x8_t v5;
  uint64_t *v6;
  uint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;

  v2 = (int8x8_t)a1[1];
  v4 = *__p;
  v3 = __p[1];
  v5 = (uint8x8_t)vcnt_s8(v2);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    if (v3 >= *(_QWORD *)&v2)
      v3 %= *(_QWORD *)&v2;
  }
  else
  {
    v3 &= *(_QWORD *)&v2 - 1;
  }
  v6 = *(uint64_t **)(*a1 + 8 * v3);
  do
  {
    v7 = v6;
    v6 = (uint64_t *)*v6;
  }
  while (v6 != __p);
  if (v7 != a1 + 2)
  {
    v8 = v7[1];
    if (v5.u32[0] > 1uLL)
    {
      if (v8 >= *(_QWORD *)&v2)
        v8 %= *(_QWORD *)&v2;
    }
    else
    {
      v8 &= *(_QWORD *)&v2 - 1;
    }
    v9 = *__p;
    if (v8 == v3)
    {
LABEL_20:
      if (!v9)
        goto LABEL_27;
      goto LABEL_21;
    }
  }
  if (!v4)
    goto LABEL_19;
  v10 = *(_QWORD *)(v4 + 8);
  if (v5.u32[0] > 1uLL)
  {
    if (v10 >= *(_QWORD *)&v2)
      v10 %= *(_QWORD *)&v2;
  }
  else
  {
    v10 &= *(_QWORD *)&v2 - 1;
  }
  v9 = *__p;
  if (v10 != v3)
  {
LABEL_19:
    *(_QWORD *)(*a1 + 8 * v3) = 0;
    v9 = *__p;
    goto LABEL_20;
  }
LABEL_21:
  v11 = *(_QWORD *)(v9 + 8);
  if (v5.u32[0] > 1uLL)
  {
    if (v11 >= *(_QWORD *)&v2)
      v11 %= *(_QWORD *)&v2;
  }
  else
  {
    v11 &= *(_QWORD *)&v2 - 1;
  }
  if (v11 != v3)
  {
    *(_QWORD *)(*a1 + 8 * v11) = v7;
    v9 = *__p;
  }
LABEL_27:
  *v7 = v9;
  *__p = 0;
  --a1[3];
  operator delete(__p);
  return v4;
}

void std::__throw_out_of_range[abi:ne180100]()
{
  std::logic_error *exception;

  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::out_of_range::out_of_range[abi:ne180100](exception);
  __cxa_throw(exception, (struct type_info *)off_24ED1D0D0, MEMORY[0x24BEDAB00]);
}

void sub_22541E610(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::out_of_range::out_of_range[abi:ne180100](std::logic_error *a1)
{
  std::logic_error *result;

  result = std::logic_error::logic_error(a1, "unordered_map::at: key not found");
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x24BEDB8C0] + 16);
  return result;
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned int,__CFString const*>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,__CFString const*>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,__CFString const*>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,__CFString const*>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(float *a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  uint8x8_t v8;
  void **v9;
  _QWORD *v10;
  unint64_t v11;
  float v12;
  float v13;
  _BOOL8 v14;
  unint64_t v15;
  unint64_t v16;
  int8x8_t prime;
  void *v18;
  _QWORD *v19;
  uint64_t v20;
  _QWORD *v21;
  unint64_t v22;
  uint8x8_t v23;
  unint64_t v24;
  uint8x8_t v25;
  uint64_t v26;
  _QWORD *v27;
  unint64_t v28;
  _QWORD *v29;
  _QWORD *v30;
  unint64_t v31;
  _QWORD *v33;

  v6 = a2;
  v7 = *((_QWORD *)a1 + 1);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = a2;
      if (v7 <= a2)
        v3 = a2 % v7;
    }
    else
    {
      v3 = ((_DWORD)v7 - 1) & a2;
    }
    v9 = *(void ***)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      v10 = *v9;
      if (*v9)
      {
        do
        {
          v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2)
              return v10;
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7)
                v11 %= v7;
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3)
              break;
          }
          v10 = (_QWORD *)*v10;
        }
        while (v10);
      }
    }
  }
  v10 = operator new(0x20uLL);
  *v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  v10[3] = 0;
  v12 = (float)(unint64_t)(*((_QWORD *)a1 + 3) + 1);
  v13 = a1[8];
  if (v7 && (float)(v13 * (float)v7) >= v12)
  {
    v6 = v3;
    goto LABEL_64;
  }
  v14 = 1;
  if (v7 >= 3)
    v14 = (v7 & (v7 - 1)) != 0;
  v15 = v14 | (2 * v7);
  v16 = vcvtps_u32_f32(v12 / v13);
  if (v15 <= v16)
    prime = (int8x8_t)v16;
  else
    prime = (int8x8_t)v15;
  if (*(_QWORD *)&prime == 1)
  {
    prime = (int8x8_t)2;
  }
  else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
  {
    prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
    v7 = *((_QWORD *)a1 + 1);
  }
  if (*(_QWORD *)&prime <= v7)
  {
    if (*(_QWORD *)&prime >= v7)
      goto LABEL_60;
    v24 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
    if (v7 < 3 || (v25 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v25.i16[0] = vaddlv_u8(v25), v25.u32[0] > 1uLL))
    {
      v24 = std::__next_prime(v24);
    }
    else
    {
      v26 = 1 << -(char)__clz(v24 - 1);
      if (v24 >= 2)
        v24 = v26;
    }
    if (*(_QWORD *)&prime <= v24)
      prime = (int8x8_t)v24;
    if (*(_QWORD *)&prime >= v7)
    {
      v7 = *((_QWORD *)a1 + 1);
      goto LABEL_60;
    }
    if (!*(_QWORD *)&prime)
    {
      v33 = *(_QWORD **)a1;
      *(_QWORD *)a1 = 0;
      if (v33)
        operator delete(v33);
      v7 = 0;
      *((_QWORD *)a1 + 1) = 0;
      goto LABEL_60;
    }
  }
  if (*(_QWORD *)&prime >> 61)
    std::__throw_bad_array_new_length[abi:ne180100]();
  v18 = operator new(8 * *(_QWORD *)&prime);
  v19 = *(_QWORD **)a1;
  *(_QWORD *)a1 = v18;
  if (v19)
    operator delete(v19);
  v20 = 0;
  *((int8x8_t *)a1 + 1) = prime;
  do
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v20++) = 0;
  while (*(_QWORD *)&prime != v20);
  v21 = (_QWORD *)*((_QWORD *)a1 + 2);
  if (v21)
  {
    v22 = v21[1];
    v23 = (uint8x8_t)vcnt_s8(prime);
    v23.i16[0] = vaddlv_u8(v23);
    if (v23.u32[0] > 1uLL)
    {
      if (v22 >= *(_QWORD *)&prime)
        v22 %= *(_QWORD *)&prime;
    }
    else
    {
      v22 &= *(_QWORD *)&prime - 1;
    }
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v22) = a1 + 4;
    v27 = (_QWORD *)*v21;
    if (*v21)
    {
      do
      {
        v28 = v27[1];
        if (v23.u32[0] > 1uLL)
        {
          if (v28 >= *(_QWORD *)&prime)
            v28 %= *(_QWORD *)&prime;
        }
        else
        {
          v28 &= *(_QWORD *)&prime - 1;
        }
        if (v28 != v22)
        {
          if (!*(_QWORD *)(*(_QWORD *)a1 + 8 * v28))
          {
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v28) = v21;
            goto LABEL_56;
          }
          *v21 = *v27;
          *v27 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v28);
          **(_QWORD **)(*(_QWORD *)a1 + 8 * v28) = v27;
          v27 = v21;
        }
        v28 = v22;
LABEL_56:
        v21 = v27;
        v27 = (_QWORD *)*v27;
        v22 = v28;
      }
      while (v27);
    }
  }
  v7 = (unint64_t)prime;
LABEL_60:
  if ((v7 & (v7 - 1)) != 0)
  {
    if (v7 <= v6)
      v6 %= v7;
  }
  else
  {
    v6 = ((_DWORD)v7 - 1) & v6;
  }
LABEL_64:
  v29 = *(_QWORD **)a1;
  v30 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v6);
  if (v30)
  {
    *v10 = *v30;
LABEL_72:
    *v30 = v10;
    goto LABEL_73;
  }
  *v10 = *((_QWORD *)a1 + 2);
  *((_QWORD *)a1 + 2) = v10;
  v29[v6] = a1 + 4;
  if (*v10)
  {
    v31 = *(_QWORD *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v31 >= v7)
        v31 %= v7;
    }
    else
    {
      v31 &= v7 - 1;
    }
    v30 = (_QWORD *)(*(_QWORD *)a1 + 8 * v31);
    goto LABEL_72;
  }
LABEL_73:
  ++*((_QWORD *)a1 + 3);
  return v10;
}

void sub_22541EA2C(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t re::ecs2::AudioPlayerTelemetryReporter::shouldSendReport(re::ecs2::AudioPlayerTelemetryReporter *this)
{
  uint64_t v1;
  _QWORD *v2;
  uint64_t v4;

  v1 = *((_QWORD *)this + 18);
  if (!v1)
    return 0;
  if (!*(_QWORD *)(v1 + 160))
    return 0;
  v2 = *(_QWORD **)(v1 + 256);
  if (!v2)
    return 0;
  while (1)
  {
    v4 = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(*((_QWORD *)this + 18) + 160) + 16))(*(_QWORD *)(*((_QWORD *)this + 18) + 160), v2[2]);
    if (v4)
    {
      if (!(*(unsigned int (**)(uint64_t))(*(_QWORD *)v4 + 544))(v4))
        break;
    }
    v2 = (_QWORD *)*v2;
    if (!v2)
      return 0;
  }
  return 1;
}

id re::ecs2::AudioPlayerTelemetryReporter::collectTelemetryStatistics(re::ecs2::AudioPlayerTelemetryReporter *this)
{
  uint64_t v2;
  _QWORD *i;
  re::ecs2::SceneComponentTable *v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  unsigned int *v10;
  unsigned int v11;
  unsigned int *v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  double v19;
  double v20;
  double v21;
  void *v22;
  double v23;
  double v24;
  double v25;
  uint64_t v26;
  const __CFString *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  void *v37;
  void *v38;
  void *v39;
  void *v40;
  void *v41;
  void *v42;
  void *v43;
  void *v44;
  void *v45;
  void *v46;
  void *v47;
  void *v48;
  void *v49;
  void *v50;
  _OWORD __s2[3];
  uint64_t v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  _QWORD v56[21];
  _QWORD v57[23];

  v57[21] = *MEMORY[0x24BDAC8D0];
  v2 = *((_QWORD *)this + 18);
  if (v2)
  {
    for (i = *(_QWORD **)(v2 + 256); i; i = (_QWORD *)*i)
    {
      v4 = (re::ecs2::SceneComponentTable *)(i[2] + 200);
      v5 = re::ecs2::SceneComponentTable::get(v4, (const re::ecs2::ComponentTypeBase *)re::ecs2::ComponentImpl<re::ecs2::AudioPlayerComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType);
      v6 = *(_QWORD *)(v5 + 24);
      if (v6)
      {
        v7 = *(_QWORD **)(v5 + 40);
        v8 = &v7[v6];
        do
        {
          v9 = *v7;
          v10 = (unsigned int *)(*v7 + 312);
          do
            v11 = __ldaxr(v10);
          while (__stlxr(0, v10));
          *(_DWORD *)this += v11;
          v12 = (unsigned int *)(v9 + 316);
          do
            v13 = __ldaxr(v12);
          while (__stlxr(0, v12));
          *((_DWORD *)this + 3) += v13;
          ++v7;
        }
        while (v7 != v8);
      }
      v14 = re::ecs2::SceneComponentTable::get(v4, (const re::ecs2::ComponentTypeBase *)re::ecs2::ComponentImpl<re::ecs2::SpatialAudioComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType);
      v15 = *(_QWORD *)(v14 + 24);
      if (v15)
      {
        v16 = *(_QWORD *)(v14 + 40);
        v17 = *((_DWORD *)this + 5);
        v18 = 8 * v15;
        do
        {
          switch(*(_DWORD *)(*(_QWORD *)v16 + 40))
          {
            case 0:
              ++*((_DWORD *)this + 7);
              break;
            case 1:
              ++*((_DWORD *)this + 9);
              break;
            case 2:
              ++*((_DWORD *)this + 8);
              break;
            case 3:
              ++*((_DWORD *)this + 10);
              break;
            default:
              break;
          }
          v16 += 8;
          ++v17;
          v18 -= 8;
        }
        while (v18);
        *((_DWORD *)this + 5) = v17;
      }
      *((_DWORD *)this + 6) += *(_DWORD *)(re::ecs2::SceneComponentTable::get(v4, (const re::ecs2::ComponentTypeBase *)re::ecs2::ComponentImpl<re::ecs2::AmbientAudioComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType)+ 24);
      *((_DWORD *)this + 4) += *(_DWORD *)(re::ecs2::SceneComponentTable::get(v4, (const re::ecs2::ComponentTypeBase *)re::ecs2::ComponentImpl<re::ecs2::ChannelAudioComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType)+ 24);
    }
  }
  v52 = 0;
  memset(__s2, 0, sizeof(__s2));
  v53 = xmmword_226100BF0;
  v54 = xmmword_226100C00;
  v55 = xmmword_226100C10;
  if (!memcmp(this, __s2, 0x68uLL))
  {
    v22 = 0;
  }
  else
  {
    if (*((_DWORD *)this + 12))
    {
      v20 = *((double *)this + 7);
      v19 = *((double *)this + 8);
      v21 = *((double *)this + 9);
    }
    else
    {
      v21 = -100.0;
      v19 = -100.0;
      v20 = -100.0;
    }
    if (*((_DWORD *)this + 13))
    {
      v23 = *((double *)this + 10);
      v24 = *((double *)this + 8);
      v25 = *((double *)this + 12);
    }
    else
    {
      v25 = -100.0;
      v24 = -100.0;
      v23 = -100.0;
    }
    v56[0] = CFSTR("bundleId");
    objc_msgSend(MEMORY[0x24BDD1488], "mainBundle");
    v50 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v50, "bundleIdentifier");
    v26 = objc_claimAutoreleasedReturnValue();
    v27 = &stru_24EDA2070;
    if (v26)
      v27 = (const __CFString *)v26;
    v57[0] = v27;
    v56[1] = CFSTR("play");
    v49 = (void *)v26;
    objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", *(unsigned int *)this);
    v48 = (void *)objc_claimAutoreleasedReturnValue();
    v57[1] = v48;
    v56[2] = CFSTR("maxConcurrentPlayCount");
    objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", *((unsigned int *)this + 1));
    v47 = (void *)objc_claimAutoreleasedReturnValue();
    v57[2] = v47;
    v56[3] = CFSTR("prepare");
    objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", *((unsigned int *)this + 3));
    v46 = (void *)objc_claimAutoreleasedReturnValue();
    v57[3] = v46;
    v56[4] = CFSTR("maxConcurrentPrepareCount");
    objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", *((unsigned int *)this + 2));
    v45 = (void *)objc_claimAutoreleasedReturnValue();
    v57[4] = v45;
    v56[5] = CFSTR("channelComponent");
    objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", *((unsigned int *)this + 4));
    v44 = (void *)objc_claimAutoreleasedReturnValue();
    v57[5] = v44;
    v56[6] = CFSTR("ambientComponent");
    objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", *((unsigned int *)this + 6));
    v43 = (void *)objc_claimAutoreleasedReturnValue();
    v57[6] = v43;
    v56[7] = CFSTR("spatialComponent");
    objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", *((unsigned int *)this + 5));
    v42 = (void *)objc_claimAutoreleasedReturnValue();
    v57[7] = v42;
    v56[8] = CFSTR("spatialComponentOmniCount");
    objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", *((unsigned int *)this + 7));
    v41 = (void *)objc_claimAutoreleasedReturnValue();
    v57[8] = v41;
    v56[9] = CFSTR("spatialComponentHumanDirectivityCount");
    objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", *((unsigned int *)this + 8));
    v40 = (void *)objc_claimAutoreleasedReturnValue();
    v57[9] = v40;
    v56[10] = CFSTR("spatialComponentBeamDirectivityCount");
    objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", *((unsigned int *)this + 9));
    v39 = (void *)objc_claimAutoreleasedReturnValue();
    v57[10] = v39;
    v56[11] = CFSTR("spatialComponentSphericalApproximationDirectivityCount");
    objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", *((unsigned int *)this + 10));
    v38 = (void *)objc_claimAutoreleasedReturnValue();
    v57[11] = v38;
    v56[12] = CFSTR("calibrationModeNoneCount");
    objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", *((unsigned int *)this + 11));
    v37 = (void *)objc_claimAutoreleasedReturnValue();
    v57[12] = v37;
    v56[13] = CFSTR("calibrationModeRelativeSplCount");
    objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", *((unsigned int *)this + 12));
    v28 = (void *)objc_claimAutoreleasedReturnValue();
    v57[13] = v28;
    v56[14] = CFSTR("calibrationModeAbsoluteSplCount");
    objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", *((unsigned int *)this + 13));
    v29 = (void *)objc_claimAutoreleasedReturnValue();
    v57[14] = v29;
    v56[15] = CFSTR("calibrationModeRelativeSplMinValue");
    objc_msgSend(MEMORY[0x24BDD1518], "numberWithDouble:", v20);
    v30 = (void *)objc_claimAutoreleasedReturnValue();
    v57[15] = v30;
    v56[16] = CFSTR("calibrationModeRelativeSplAverage");
    objc_msgSend(MEMORY[0x24BDD1518], "numberWithDouble:", v19);
    v31 = (void *)objc_claimAutoreleasedReturnValue();
    v57[16] = v31;
    v56[17] = CFSTR("calibrationModeRelativeSplMaxValue");
    objc_msgSend(MEMORY[0x24BDD1518], "numberWithDouble:", v21);
    v32 = (void *)objc_claimAutoreleasedReturnValue();
    v57[17] = v32;
    v56[18] = CFSTR("calibrationModeAbsoluteSplMinValue");
    objc_msgSend(MEMORY[0x24BDD1518], "numberWithDouble:", v23);
    v33 = (void *)objc_claimAutoreleasedReturnValue();
    v57[18] = v33;
    v56[19] = CFSTR("calibrationModeAbsoluteSplAverage");
    objc_msgSend(MEMORY[0x24BDD1518], "numberWithDouble:", v24);
    v34 = (void *)objc_claimAutoreleasedReturnValue();
    v57[19] = v34;
    v56[20] = CFSTR("calibrationModeAbsoluteSplMaxValue");
    objc_msgSend(MEMORY[0x24BDD1518], "numberWithDouble:", v25);
    v35 = (void *)objc_claimAutoreleasedReturnValue();
    v57[20] = v35;
    objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v57, v56, 21);
    v22 = (void *)objc_claimAutoreleasedReturnValue();

  }
  *((_QWORD *)this + 6) = 0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
  *(_OWORD *)((char *)this + 56) = xmmword_226100BF0;
  *(_OWORD *)((char *)this + 72) = xmmword_226100C00;
  *(_OWORD *)((char *)this + 88) = xmmword_226100C10;
  return v22;
}

void sub_22541F140(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18, void *a19, void *a20,void *a21,void *a22)
{
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;

  _Unwind_Resume(a1);
}

uint64_t re::ecs2::AudioPlayerTelemetryReporter::getInstance(re::ecs2::AudioPlayerTelemetryReporter *this)
{
  unsigned __int8 v1;
  id *v2;
  uint64_t result;
  NSObject *v4;
  NSObject *v5;

  v2 = (id *)&re::introspect_REStateCommandID(BOOL)::info;
  if ((v1 & 1) == 0
  {
    dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
    v4 = objc_claimAutoreleasedReturnValue();
    dispatch_queue_attr_make_with_qos_class(v4, QOS_CLASS_UTILITY, 0);
    v5 = objc_claimAutoreleasedReturnValue();
    re::ecs2::AudioPlayerTelemetryReporter::getInstance(void)::onceQueue = (uint64_t)dispatch_queue_create("AudioTelemetry", v5);

    v2 = (id *)&re::introspect_REStateCommandID(BOOL)::info;
  }
  objc_storeStrong((id *)&re::ecs2::AudioPlayerTelemetryReporter::m_playerQueue, v2[315]);
  result = re::ecs2::AudioPlayerTelemetryReporter::sharedReporter;
  if (!re::ecs2::AudioPlayerTelemetryReporter::sharedReporter)
  {
    dispatch_sync((dispatch_queue_t)re::ecs2::AudioPlayerTelemetryReporter::m_playerQueue, &__block_literal_global_6);
    return re::ecs2::AudioPlayerTelemetryReporter::sharedReporter;
  }
  return result;
}

void sub_22541F4F0(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

void re::ecs2::AudioPlayerTelemetryReporter::initializeTimerWith(uint64_t a1, void *a2, uint64_t a3)
{
  id v5;
  NSObject *v6;
  id v7;
  _QWORD block[4];
  id v9;
  uint64_t v10;
  uint64_t v11;

  v5 = a2;
  v6 = re::ecs2::AudioPlayerTelemetryReporter::m_playerQueue;
  block[0] = MEMORY[0x24BDAC760];
  block[1] = 3221225472;
  block[2] = ___ZN2re4ecs228AudioPlayerTelemetryReporter19initializeTimerWithEPU28objcproto17OS_dispatch_queue8NSObjectPNS0_17AudioPlayerSystemE_block_invoke;
  block[3] = &unk_24ED3EAE8;
  v10 = a1;
  v11 = a3;
  v9 = v5;
  v7 = v5;
  dispatch_async(v6, block);

}

void ___ZN2re4ecs228AudioPlayerTelemetryReporter19initializeTimerWithEPU28objcproto17OS_dispatch_queue8NSObjectPNS0_17AudioPlayerSystemE_block_invoke(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  NSObject *v3;
  _QWORD v4[5];

  v1 = a1[5];
  *(_QWORD *)(v1 + 144) = a1[6];
  v2 = *(_QWORD *)(v1 + 104);
  v3 = a1[4];
  v4[0] = MEMORY[0x24BDAC760];
  v4[1] = 3221225472;
  v4[2] = ___ZN2re4ecs228AudioPlayerTelemetryReporter19initializeTimerWithEPU28objcproto17OS_dispatch_queue8NSObjectPNS0_17AudioPlayerSystemE_block_invoke_2;
  v4[3] = &__block_descriptor_40_e24__TelemetryReport____8__0l;
  v4[4] = v1;
  re::AudioTelemetryReporter::initializeTimerWith(v2, v3, v4, 300.0);
}

uint64_t ___ZN2re4ecs228AudioPlayerTelemetryReporter11updateCountEjj_block_invoke(uint64_t result)
{
  _DWORD *v1;

  v1 = *(_DWORD **)(result + 32);
  *v1 += *(_DWORD *)(result + 40);
  v1[3] += *(_DWORD *)(result + 44);
  return result;
}

void re::ecs2::AudioPlayerTelemetryReporter::updateCalibrationModeStatistics(uint64_t a1, int a2, double a3)
{
  _QWORD block[6];
  int v4;

  block[0] = MEMORY[0x24BDAC760];
  block[1] = 3221225472;
  block[2] = ___ZN2re4ecs228AudioPlayerTelemetryReporter31updateCalibrationModeStatisticsE22REAudioCalibrationModed_block_invoke;
  block[3] = &__block_descriptor_52_e5_v8__0l;
  block[4] = a1;
  v4 = a2;
  *(double *)&block[5] = a3;
  dispatch_async((dispatch_queue_t)re::ecs2::AudioPlayerTelemetryReporter::m_playerQueue, block);
}

uint64_t ___ZN2re4ecs228AudioPlayerTelemetryReporter31updateCalibrationModeStatisticsE22REAudioCalibrationModed_block_invoke(uint64_t result)
{
  uint64_t v1;
  int v2;
  double v3;
  unsigned int v4;
  double v5;
  double v6;
  double v7;
  unsigned int v8;
  double v9;
  double v10;

  v1 = *(_QWORD *)(result + 32);
  v2 = *(_DWORD *)(result + 48);
  switch(v2)
  {
    case 2:
      v3 = *(double *)(v1 + 80);
      v4 = *(_DWORD *)(v1 + 52) + 1;
      *(double *)(v1 + 88) = *(double *)(v1 + 88) + (*(double *)(result + 40) - *(double *)(v1 + 88)) / (double)v4;
      *(_DWORD *)(v1 + 52) = v4;
      v5 = *(double *)(result + 40);
      if (v5 >= v3)
        v5 = v3;
      *(double *)(v1 + 80) = v5;
      v6 = *(double *)(result + 40);
      if (v6 <= *(double *)(v1 + 96))
        v6 = *(double *)(v1 + 96);
      *(double *)(v1 + 96) = v6;
      break;
    case 1:
      v7 = *(double *)(v1 + 56);
      v8 = *(_DWORD *)(v1 + 48) + 1;
      *(double *)(v1 + 64) = *(double *)(v1 + 64) + (*(double *)(result + 40) - *(double *)(v1 + 64)) / (double)v8;
      *(_DWORD *)(v1 + 48) = v8;
      v9 = *(double *)(result + 40);
      if (v9 >= v7)
        v9 = v7;
      *(double *)(v1 + 56) = v9;
      v10 = *(double *)(result + 40);
      if (v10 <= *(double *)(v1 + 72))
        v10 = *(double *)(v1 + 72);
      *(double *)(v1 + 72) = v10;
      break;
    case 0:
      ++*(_DWORD *)(v1 + 44);
      break;
  }
  return result;
}

uint64_t ___ZN2re4ecs228AudioPlayerTelemetryReporter25updateConcurrentPlayCountEj_block_invoke(uint64_t result)
{
  uint64_t v1;
  unsigned int v2;

  v1 = *(_QWORD *)(result + 32);
  v2 = *(_DWORD *)(result + 40);
  if (v2 <= *(_DWORD *)(v1 + 4))
    v2 = *(_DWORD *)(v1 + 4);
  *(_DWORD *)(v1 + 4) = v2;
  return result;
}

uint64_t ___ZN2re4ecs228AudioPlayerTelemetryReporter28updateConcurrentPrepareCountEj_block_invoke(uint64_t result)
{
  uint64_t v1;
  unsigned int v2;

  v1 = *(_QWORD *)(result + 32);
  v2 = *(_DWORD *)(result + 40);
  if (v2 <= *(_DWORD *)(v1 + 8))
    v2 = *(_DWORD *)(v1 + 8);
  *(_DWORD *)(v1 + 8) = v2;
  return result;
}

uint64_t *std::unique_ptr<re::AudioTelemetryReporter,std::function<void ()(re::AudioTelemetryReporter*)>>::~unique_ptr[abi:ne180100](uint64_t *a1)
{
  uint64_t *v2;
  uint64_t v3;

  std::unique_ptr<re::AudioTelemetryReporter,std::function<void ()(re::AudioTelemetryReporter*)>>::reset[abi:ne180100](a1, 0);
  v2 = (uint64_t *)a1[4];
  if (v2 == a1 + 1)
  {
    v3 = 4;
    v2 = a1 + 1;
    goto LABEL_5;
  }
  if (v2)
  {
    v3 = 5;
LABEL_5:
    (*(void (**)(void))(*v2 + 8 * v3))();
  }
  return a1;
}

uint64_t *std::unique_ptr<re::AudioTelemetryReporter,std::function<void ()(re::AudioTelemetryReporter*)>>::reset[abi:ne180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    v4 = v2;
    v3 = result[4];
    if (!v3)
      std::__throw_bad_function_call[abi:ne180100]();
    return (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)v3 + 48))(v3, &v4);
  }
  return result;
}

void _ZNSt3__110__function6__funcIZN2re20makeDefaultUniquePtrINS2_22AudioTelemetryReporterEJEEENS_10unique_ptrIT_NS_8functionIFvPS6_EEEEEDpOT0_EUlPS4_E_NS_9allocatorISG_EEFvSF_EED0Ev()
{
  JUMPOUT(0x2276933B8);
}

_QWORD *_ZNKSt3__110__function6__funcIZN2re20makeDefaultUniquePtrINS2_22AudioTelemetryReporterEJEEENS_10unique_ptrIT_NS_8functionIFvPS6_EEEEEDpOT0_EUlPS4_E_NS_9allocatorISG_EEFvSF_EE7__cloneEv()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_24ED3F408;
  return result;
}

void _ZNKSt3__110__function6__funcIZN2re20makeDefaultUniquePtrINS2_22AudioTelemetryReporterEJEEENS_10unique_ptrIT_NS_8functionIFvPS6_EEEEEDpOT0_EUlPS4_E_NS_9allocatorISG_EEFvSF_EE7__cloneEPNS0_6__baseISJ_EE(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24ED3F408;
}

re *_ZNSt3__110__function6__funcIZN2re20makeDefaultUniquePtrINS2_22AudioTelemetryReporterEJEEENS_10unique_ptrIT_NS_8functionIFvPS6_EEEEEDpOT0_EUlPS4_E_NS_9allocatorISG_EEFvSF_EEclEOSF_(uint64_t a1, id **a2)
{
  return re::internal::destroyPersistent<re::AudioTelemetryReporter>((re *)"operator()", 36, *a2);
}

uint64_t _ZNKSt3__110__function6__funcIZN2re20makeDefaultUniquePtrINS2_22AudioTelemetryReporterEJEEENS_10unique_ptrIT_NS_8functionIFvPS6_EEEEEDpOT0_EUlPS4_E_NS_9allocatorISG_EEFvSF_EE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *_ZNKSt3__110__function6__funcIZN2re20makeDefaultUniquePtrINS2_22AudioTelemetryReporterEJEEENS_10unique_ptrIT_NS_8functionIFvPS6_EEEEEDpOT0_EUlPS4_E_NS_9allocatorISG_EEFvSF_EE11target_typeEv()
{
}

re *re::internal::destroyPersistent<re::AudioTelemetryReporter>(re *result, uint64_t a2, id *a3)
{
  uint64_t v4;

  if (a3)
  {
    v4 = re::globalAllocators(result)[2];
    re::AudioTelemetryReporter::~AudioTelemetryReporter(a3);
    return (re *)(*(uint64_t (**)(uint64_t, id *))(*(_QWORD *)v4 + 40))(v4, a3);
  }
  return result;
}

re::AudioManager_PHASE_StateMachine *re::AudioManager_PHASE_StateMachine::AudioManager_PHASE_StateMachine(re::AudioManager_PHASE_StateMachine *this)
{
  _QWORD *v2;
  NSObject *v3;
  NSObject *v4;
  dispatch_queue_t v5;
  void *v6;
  __int128 v8;
  uint64_t v9;
  void **v10;

  v2 = (_QWORD *)operator new();
  *v2 = &off_24ED3F928;
  *(_QWORD *)this = v2;
  *((_DWORD *)this + 2) = 0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  v3 = objc_claimAutoreleasedReturnValue();
  dispatch_queue_attr_make_with_qos_class(v3, QOS_CLASS_USER_INTERACTIVE, 0);
  v4 = objc_claimAutoreleasedReturnValue();

  v5 = dispatch_queue_create("AudioManager_PHASE_StateMachine", v4);
  v6 = (void *)*((_QWORD *)this + 5);
  *((_QWORD *)this + 5) = v5;

  re::AudioManager_PHASE_State_Recovering::getInitialRequiredRecoverySteps((uint64_t **)&v8);
  std::vector<std::unique_ptr<re::AudioManager_PHASE_StateMachine_RecoveryStep>>::__vdeallocate((_QWORD *)this + 2);
  *((_OWORD *)this + 1) = v8;
  *((_QWORD *)this + 4) = v9;
  v9 = 0;
  v8 = 0uLL;
  v10 = (void **)&v8;
  std::vector<std::unique_ptr<re::AudioManager_PHASE_StateMachine_RecoveryStep>>::__destroy_vector::operator()[abi:ne180100](&v10);

  return this;
}

void sub_22541FB28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  uint64_t *v9;
  void *v10;
  uint64_t v12;

  std::vector<std::unique_ptr<re::AudioManager_PHASE_StateMachine_RecoveryStep>>::__destroy_vector::operator()[abi:ne180100](&a9);
  v12 = *v9;
  *v9 = 0;
  if (v12)
    (*(void (**)(uint64_t))(*(_QWORD *)v12 + 32))(v12);
  _Unwind_Resume(a1);
}

void re::AudioManager_PHASE_StateMachine::~AudioManager_PHASE_StateMachine(re::AudioManager_PHASE_StateMachine *this)
{
  NSObject *v2;
  uint64_t v3;
  _QWORD v4[5];
  void **v5;

  v2 = *((_QWORD *)this + 5);
  v4[0] = MEMORY[0x24BDAC760];
  v4[1] = 3221225472;
  v4[2] = ___ZN2re31AudioManager_PHASE_StateMachineD2Ev_block_invoke;
  v4[3] = &__block_descriptor_40_e5_v8__0l;
  v4[4] = this;
  dispatch_sync(v2, v4);

  v5 = (void **)((char *)this + 16);
  std::vector<std::unique_ptr<re::AudioManager_PHASE_StateMachine_RecoveryStep>>::__destroy_vector::operator()[abi:ne180100](&v5);
  v3 = *(_QWORD *)this;
  *(_QWORD *)this = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 32))(v3);
}

void ___ZN2re31AudioManager_PHASE_StateMachineD2Ev_block_invoke(uint64_t a1)
{
  os_unfair_lock_s *v1;
  uint64_t v2;
  uint64_t *v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;

  v1 = *(os_unfair_lock_s **)(a1 + 32);
  os_unfair_lock_lock(v1 + 2);
  v2 = *(_QWORD *)&v1->_os_unfair_lock_opaque;
  *(_QWORD *)&v1->_os_unfair_lock_opaque = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 32))(v2);
  os_unfair_lock_unlock(v1 + 2);
  v3 = *(uint64_t **)&v1[4]._os_unfair_lock_opaque;
  v4 = *(uint64_t **)&v1[6]._os_unfair_lock_opaque;
  if (v3 != v4)
  {
    do
    {
      v5 = *v3;
      *v3 = 0;
      if (v5)
        (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
      ++v3;
    }
    while (v3 != v4);
    v6 = *(uint64_t **)&v1[4]._os_unfair_lock_opaque;
    v3 = *(uint64_t **)&v1[6]._os_unfair_lock_opaque;
    if (v3 != v6)
    {
      do
      {
        v8 = *--v3;
        v7 = v8;
        *v3 = 0;
        if (v8)
          (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
      }
      while (v3 != v6);
      v3 = v6;
    }
  }
  *(_QWORD *)&v1[6]._os_unfair_lock_opaque = v3;
}

void re::AudioManager_PHASE_StateMachine::handleStateChangeEvent(uint64_t a1, int a2, unint64_t __val, uint64_t a4)
{
  std::string *v8;
  __int128 v9;
  NSObject *v10;
  std::string *v11;
  void **v12;
  NSObject *v13;
  _QWORD block[7];
  int v15;
  std::string v16;
  void *__p[2];
  int64_t v18;
  uint8_t buf[4];
  std::string *v20;
  __int16 v21;
  void **v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  if ((_BYTE)a4)
  {
    std::to_string(&v16, __val);
    v8 = std::string::insert(&v16, 0, " for scene ");
    v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
    v18 = v8->__r_.__value_.__r.__words[2];
    *(_OWORD *)__p = v9;
    v8->__r_.__value_.__l.__size_ = 0;
    v8->__r_.__value_.__r.__words[2] = 0;
    v8->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v16.__r_.__value_.__l.__data_);
  }
  else
  {
    v8 = (std::string *)std::string::basic_string[abi:ne180100]<0>(__p, "");
  }
  v10 = (id)*re::audioLogObjects((re *)v8);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    re::nameForAudioManagerStateMachineEvent(a2, &v16);
    if ((v16.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v11 = &v16;
    else
      v11 = (std::string *)v16.__r_.__value_.__r.__words[0];
    v12 = __p;
    if (v18 < 0)
      v12 = (void **)__p[0];
    *(_DWORD *)buf = 136315394;
    v20 = v11;
    v21 = 2080;
    v22 = v12;
    _os_log_impl(&dword_224FE9000, v10, OS_LOG_TYPE_DEFAULT, "[RE/MediaServices] [EngineStateChange] Received state change event '%s'%s.", buf, 0x16u);
    if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v16.__r_.__value_.__l.__data_);
  }

  v13 = *(NSObject **)(a1 + 40);
  block[0] = MEMORY[0x24BDAC760];
  block[1] = 3221225472;
  block[2] = ___ZN2re31AudioManager_PHASE_StateMachine22handleStateChangeEventENS_36AudioManager_PHASE_StateMachineEventENSt3__18optionalIyEE_block_invoke;
  block[3] = &__block_descriptor_60_e5_v8__0l;
  v15 = a2;
  block[4] = a1;
  block[5] = __val;
  block[6] = a4;
  dispatch_async(v13, block);
  if (SHIBYTE(v18) < 0)
    operator delete(__p[0]);
}

void sub_22541FE74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  void *v29;

  if (a29 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

void ___ZN2re31AudioManager_PHASE_StateMachine22handleStateChangeEventENS_36AudioManager_PHASE_StateMachineEventENSt3__18optionalIyEE_block_invoke(uint64_t a1)
{
  os_unfair_lock_s *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t (**v4)();
  uint64_t v5;
  uint64_t i;
  char *v7;
  uint64_t v8;
  void *v9;
  int64_t v10;
  unint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  uint64_t v16;
  _QWORD *v17;
  _QWORD *v18;
  uint64_t v19;
  int64x2_t v20;
  char *v21;
  uint64_t v22;
  char *v23;
  __int128 v24;
  NSObject *v25;
  int v26;
  void **v27;
  void **v28;
  void **v29;
  uint64_t v30;
  void *__p[2];
  char *v32;
  void *v33;
  int64x2_t v34;
  char *v35;
  void **v36;
  _BYTE buf[12];
  __int16 v38;
  void **v39;
  uint64_t v40;

  v40 = *MEMORY[0x24BDAC8D0];
  v1 = *(os_unfair_lock_s **)(a1 + 32);
  v2 = (***(uint64_t (****)(_QWORD, _QWORD, _QWORD, _QWORD))&v1->_os_unfair_lock_opaque)(*(_QWORD *)&v1->_os_unfair_lock_opaque, *(unsigned int *)(a1 + 56), *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48));
  if ((v2 & 0xFF00000000) == 0)
    return;
  if ((_DWORD)v2 == 2)
  {
    v2 = operator new();
    v3 = v2;
    v4 = &off_24ED3F928;
  }
  else
  {
    if ((_DWORD)v2 == 1)
    {
      __p[1] = 0;
      v32 = 0;
      __p[0] = 0;
      v5 = *(_QWORD *)&v1[4]._os_unfair_lock_opaque;
      for (i = *(_QWORD *)&v1[6]._os_unfair_lock_opaque; v5 != i; v5 += 8)
      {
        (*(void (**)(_BYTE *__return_ptr))(**(_QWORD **)v5 + 64))(buf);
        v7 = (char *)__p[1];
        if (__p[1] >= v32)
        {
          v10 = ((char *)__p[1] - (char *)__p[0]) >> 3;
          if ((unint64_t)(v10 + 1) >> 61)
            std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
          v11 = (v32 - (char *)__p[0]) >> 2;
          if (v11 <= v10 + 1)
            v11 = v10 + 1;
          if ((unint64_t)(v32 - (char *)__p[0]) >= 0x7FFFFFFFFFFFFFF8)
            v12 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v12 = v11;
          v36 = (void **)&v32;
          if (v12)
            v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>((uint64_t)&v32, v12);
          else
            v13 = 0;
          v14 = &v13[8 * v10];
          v15 = &v13[8 * v12];
          v35 = v15;
          v16 = *(_QWORD *)buf;
          *(_QWORD *)buf = 0;
          *(_QWORD *)v14 = v16;
          v9 = v14 + 8;
          v34.i64[1] = (uint64_t)(v14 + 8);
          v18 = __p[0];
          v17 = __p[1];
          if (__p[1] == __p[0])
          {
            v20 = vdupq_n_s64((unint64_t)__p[1]);
          }
          else
          {
            do
            {
              v19 = *--v17;
              *v17 = 0;
              *((_QWORD *)v14 - 1) = v19;
              v14 -= 8;
            }
            while (v17 != v18);
            v20 = *(int64x2_t *)__p;
            v9 = (void *)v34.i64[1];
            v15 = v35;
          }
          __p[0] = v14;
          __p[1] = v9;
          v34 = v20;
          v21 = v32;
          v32 = v15;
          v35 = v21;
          v33 = (void *)v20.i64[0];
          std::__split_buffer<std::unique_ptr<re::AudioManager_PHASE_StateMachine_RecoveryStep>>::~__split_buffer((uint64_t)&v33);
        }
        else
        {
          v8 = *(_QWORD *)buf;
          *(_QWORD *)buf = 0;
          *(_QWORD *)__p[1] = v8;
          v9 = v7 + 8;
        }
        __p[1] = v9;
        v22 = *(_QWORD *)buf;
        *(_QWORD *)buf = 0;
        if (v22)
          (*(void (**)(uint64_t))(*(_QWORD *)v22 + 8))(v22);
      }
      v3 = operator new();
      v23 = v32;
      v24 = *(_OWORD *)__p;
      __p[1] = 0;
      v32 = 0;
      __p[0] = 0;
      *(_QWORD *)v3 = &off_24ED3F650;
      *(_OWORD *)(v3 + 8) = v24;
      *(_QWORD *)(v3 + 24) = v23;
      v34 = 0uLL;
      v33 = 0;
      *(_QWORD *)buf = &v33;
      std::vector<std::unique_ptr<re::AudioManager_PHASE_StateMachine_RecoveryStep>>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
      v33 = __p;
      std::vector<std::unique_ptr<re::AudioManager_PHASE_StateMachine_RecoveryStep>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v33);
      goto LABEL_30;
    }
    if ((_DWORD)v2)
    {
      v3 = 0;
      goto LABEL_30;
    }
    v2 = operator new();
    v3 = v2;
    v4 = &off_24ED3D670;
  }
  *(_QWORD *)v2 = v4;
LABEL_30:
  v25 = (id)*re::audioLogObjects((re *)v2);
  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
  {
    (*(void (**)(void **__return_ptr))(**(_QWORD **)&v1->_os_unfair_lock_opaque + 8))(&v33);
    v26 = v34.i8[15];
    v27 = (void **)v33;
    (*(void (**)(void **__return_ptr, uint64_t))(*(_QWORD *)v3 + 8))(__p, v3);
    v28 = &v33;
    if (v26 < 0)
      v28 = v27;
    if (SHIBYTE(v32) >= 0)
      v29 = __p;
    else
      v29 = (void **)__p[0];
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = v28;
    v38 = 2080;
    v39 = v29;
    _os_log_impl(&dword_224FE9000, v25, OS_LOG_TYPE_DEFAULT, "[RE/MediaServices] [EngineStateChange] State was changed from %s to %s", buf, 0x16u);
    if (SHIBYTE(v32) < 0)
      operator delete(__p[0]);
    if (v34.i8[15] < 0)
      operator delete(v33);
  }

  os_unfair_lock_lock(v1 + 2);
  v30 = *(_QWORD *)&v1->_os_unfair_lock_opaque;
  *(_QWORD *)&v1->_os_unfair_lock_opaque = v3;
  if (v30)
    (*(void (**)(uint64_t))(*(_QWORD *)v30 + 32))(v30);
  os_unfair_lock_unlock(v1 + 2);
}

void sub_225420250(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t *a20)
{
  a20 = &a9;
  std::vector<std::unique_ptr<re::AudioManager_PHASE_StateMachine_RecoveryStep>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a20);
  _Unwind_Resume(a1);
}

uint64_t re::AudioManager_PHASE_StateMachine::getCurrentStateType(os_unfair_lock_s *this)
{
  os_unfair_lock_s *v2;
  uint64_t v3;

  v2 = this + 2;
  os_unfair_lock_lock(this + 2);
  v3 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)&this->_os_unfair_lock_opaque + 16))(*(_QWORD *)&this->_os_unfair_lock_opaque);
  os_unfair_lock_unlock(v2);
  return v3;
}

void sub_225420320(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void ___ZN2re31AudioManager_PHASE_StateMachine28registerRequiredRecoveryStepENS_36AudioManager_PHASE_StateMachineEventEy_block_invoke(uint64_t a1)
{
  uint64_t v2;
  unsigned int v3;
  NSObject *v4;
  NSObject *v5;
  uint64_t v6;
  void **v7;
  void **v8;
  void *__p[2];
  char v10;
  uint8_t buf[4];
  void **v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(_DWORD *)(a1 + 48);
  v4 = (id)*re::audioLogObjects((re *)a1);
  v5 = v4;
  if (v3 > 4)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      re::nameForAudioManagerStateMachineEvent(*(_DWORD *)(a1 + 48), __p);
      v8 = v10 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)buf = 136315138;
      v12 = v8;
      _os_log_debug_impl(&dword_224FE9000, v5, OS_LOG_TYPE_DEBUG, "[RE/MediaServices] [EngineState] Registered a recovery step for event %s", buf, 0xCu);
      if (v10 < 0)
        operator delete(__p[0]);
    }

    v6 = *(_QWORD *)(*(_QWORD *)(v2 + 16) + 8 * *(unsigned int *)(a1 + 48));
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v6 + 48))(v6, *(_QWORD *)(a1 + 40));
  }
  else
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      re::nameForAudioManagerStateMachineEvent(*(_DWORD *)(a1 + 48), __p);
      if (v10 >= 0)
        v7 = __p;
      else
        v7 = (void **)__p[0];
      *(_DWORD *)buf = 136315138;
      v12 = v7;
      _os_log_error_impl(&dword_224FE9000, v5, OS_LOG_TYPE_ERROR, "[RE/MediaServices] [EngineState] Invalid recovery step registered for event %s", buf, 0xCu);
      if (v10 < 0)
        operator delete(__p[0]);
    }

  }
}

void sub_2254204BC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void ___ZN2re31AudioManager_PHASE_StateMachine30unregisterRequiredRecoveryStepENS_36AudioManager_PHASE_StateMachineEventEy_block_invoke(uint64_t a1)
{
  _QWORD *v2;
  unsigned int v3;
  NSObject *v4;
  NSObject *v5;
  uint64_t v6;
  void **v7;
  void **v8;
  void *__p[2];
  char v10;
  uint8_t buf[4];
  void **v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD **)(a1 + 32);
  v3 = *(_DWORD *)(a1 + 48);
  v4 = (id)*re::audioLogObjects((re *)a1);
  v5 = v4;
  if (v3 > 4)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      re::nameForAudioManagerStateMachineEvent(*(_DWORD *)(a1 + 48), __p);
      v8 = v10 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)buf = 136315138;
      v12 = v8;
      _os_log_debug_impl(&dword_224FE9000, v5, OS_LOG_TYPE_DEBUG, "[RE/MediaServices] [EngineState] Unregistered a recovery step for event %s", buf, 0xCu);
      if (v10 < 0)
        operator delete(__p[0]);
    }

    v6 = *(_QWORD *)(v2[2] + 8 * *(unsigned int *)(a1 + 48));
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v6 + 40))(v6, *(_QWORD *)(a1 + 40));
    if ((*(unsigned int (**)(_QWORD))(*(_QWORD *)*v2 + 16))(*v2) == 1)
      (**(void (***)(_QWORD, _QWORD, _QWORD, uint64_t))*v2)(*v2, *(unsigned int *)(a1 + 48), *(_QWORD *)(a1 + 40), 1);
  }
  else
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      re::nameForAudioManagerStateMachineEvent(*(_DWORD *)(a1 + 48), __p);
      if (v10 >= 0)
        v7 = __p;
      else
        v7 = (void **)__p[0];
      *(_DWORD *)buf = 136315138;
      v12 = v7;
      _os_log_error_impl(&dword_224FE9000, v5, OS_LOG_TYPE_ERROR, "[RE/MediaServices] [EngineState] Invalid recovery step unregistered from event %s", buf, 0xCu);
      if (v10 < 0)
        operator delete(__p[0]);
    }

  }
}

void sub_225420694(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void std::vector<std::unique_ptr<re::AudioManager_PHASE_StateMachine_RecoveryStep>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  _QWORD *v2;
  _QWORD *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v7 = *--v4;
        v6 = v7;
        *v4 = 0;
        if (v7)
          (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<std::unique_ptr<re::AudioManager_PHASE_StateMachine_RecoveryStep>>::__vdeallocate(_QWORD *a1)
{
  _QWORD *v1;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;

  v1 = (_QWORD *)*a1;
  if (*a1)
  {
    v3 = (_QWORD *)a1[1];
    v4 = (_QWORD *)*a1;
    if (v3 != v1)
    {
      do
      {
        v6 = *--v3;
        v5 = v6;
        *v3 = 0;
        if (v6)
          (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
      }
      while (v3 != v1);
      v4 = (_QWORD *)*a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

uint64_t std::__split_buffer<std::unique_ptr<re::AudioManager_PHASE_StateMachine_RecoveryStep>>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;
  uint64_t v4;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 8;
    v4 = *(_QWORD *)(i - 8);
    *(_QWORD *)(i - 8) = 0;
    if (v4)
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void re::audio::REPHASEAudioScene::create(re::audio::REPHASEAudioScene *this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v4;
  re::audio::REPHASEAudioScene *obj;

  obj = this;
  v4 = operator new();
  *(_OWORD *)(v4 + 96) = 0u;
  *(_OWORD *)(v4 + 112) = 0u;
  *(_OWORD *)(v4 + 128) = 0u;
  *(_QWORD *)(v4 + 136) = 0;
  *(_QWORD *)(v4 + 144) = 0;
  *(_OWORD *)(v4 + 64) = 0u;
  *(_OWORD *)(v4 + 80) = 0u;
  *(_OWORD *)(v4 + 32) = 0u;
  *(_OWORD *)(v4 + 48) = 0u;
  *(_OWORD *)v4 = 0u;
  *(_OWORD *)(v4 + 16) = 0u;
  *(_DWORD *)(v4 + 56) = 1065353216;
  *(_OWORD *)(v4 + 88) = 0u;
  *(_OWORD *)(v4 + 104) = 0u;
  *(_DWORD *)(v4 + 120) = 1065353216;
  *(_QWORD *)(v4 + 128) = 0;
  *(_BYTE *)(v4 + 144) = 0;
  std::shared_ptr<re::audio::REPHASEAudioScene>::shared_ptr[abi:ne180100]<re::audio::REPHASEAudioScene,void>(a2, (_QWORD *)v4);
  objc_storeWeak((id *)(*a2 + 128), obj);

}

void sub_225420898(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void re::audio::REPHASEAudioScene::destroy(re::audio::REPHASEAudioScene *this)
{
  void *v2;

  v2 = (void *)*((_QWORD *)this + 9);
  *((_QWORD *)this + 9) = 0;

  std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<re::audio::REPHASEEntity>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<re::audio::REPHASEEntity>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<re::audio::REPHASEEntity>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<re::audio::REPHASEEntity>>>>::clear((uint64_t)this + 24);
  std::__hash_table<std::__hash_value_type<unsigned long long,PHASEObject * {__strong}>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,PHASEObject * {__strong}>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,PHASEObject * {__strong}>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,PHASEObject * {__strong}>>>::clear((uint64_t)this + 88);
}

void re::audio::REPHASEAudioScene::fillOutDebugInformation(re::audio::REPHASEAudioScene *this, NSMutableDictionary *a2)
{
  id v3;
  void *v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  void *v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  void *v14;
  _QWORD *v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *p_shared_owners;
  unint64_t v21;
  id v22;
  void *v23;
  void *v24;
  const __CFString *v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  void *v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  void *v35;
  void *v36;
  id v37;
  unint64_t v38;
  void *v39;
  void *v40;
  const __CFString *v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  void *v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  void *v51;
  void *v52;
  unint64_t *v53;
  unint64_t v54;
  os_unfair_lock_s *lock;
  NSMutableDictionary *v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;

  v56 = a2;
  os_unfair_lock_lock((os_unfair_lock_t)this + 16);
  v3 = *((id *)this + 9);
  if (v3)
  {
    objc_msgSend(MEMORY[0x24BDBCED8], "dictionary");
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v3, "transform");
    v57 = v5;
    v58 = v6;
    v59 = v7;
    v60 = v8;
    re::audio::REPHASEAudioScene::fillOutDebugInformation(NSMutableDictionary *)::$_0::operator()(&v57);
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v4, "setObject:forKey:", v9, CFSTR("transform"));

    objc_msgSend(v3, "worldTransform");
    v57 = v10;
    v58 = v11;
    v59 = v12;
    v60 = v13;
    re::audio::REPHASEAudioScene::fillOutDebugInformation(NSMutableDictionary *)::$_0::operator()(&v57);
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v4, "setObject:forKey:", v14, CFSTR("worldTransform"));

  }
  os_unfair_lock_unlock((os_unfair_lock_t)this + 16);
  lock = (os_unfair_lock_s *)((char *)this + 16);
  os_unfair_lock_lock((os_unfair_lock_t)this + 4);
  v15 = (_QWORD *)*((_QWORD *)this + 5);
  if (v15)
  {
    v16 = 0x24BDBC000uLL;
    do
    {
      v17 = v15[2];
      v18 = v15[3];
      v19 = (std::__shared_weak_count *)v15[4];
      if (v19)
      {
        p_shared_owners = (unint64_t *)&v19->__shared_owners_;
        do
          v21 = __ldxr(p_shared_owners);
        while (__stxr(v21 + 1, p_shared_owners));
      }
      if (v18)
      {
        v22 = *(id *)(v18 + 24);
        if (v22)
        {
          objc_msgSend(*(id *)(v16 + 3800), "dictionary");
          v23 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLongLong:", v17);
          v24 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v23, "setObject:forKey:", v24, CFSTR("entityID"));

          if (*(_QWORD *)(v18 + 32))
            v25 = *(const __CFString **)(v18 + 32);
          else
            v25 = CFSTR("(null)");
          objc_msgSend(v23, "setObject:forKey:", v25, CFSTR("name"));
          objc_msgSend(v22, "transform");
          v57 = v26;
          v58 = v27;
          v59 = v28;
          v60 = v29;
          re::audio::REPHASEAudioScene::fillOutDebugInformation(NSMutableDictionary *)::$_0::operator()(&v57);
          v30 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v23, "setObject:forKey:", v30, CFSTR("transform"));

          objc_msgSend(v22, "worldTransform");
          v57 = v31;
          v58 = v32;
          v59 = v33;
          v60 = v34;
          re::audio::REPHASEAudioScene::fillOutDebugInformation(NSMutableDictionary *)::$_0::operator()(&v57);
          v35 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v23, "setObject:forKey:", v35, CFSTR("worldTransform"));

          objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("Occluder Entity-%llu"), v17);
          v36 = (void *)objc_claimAutoreleasedReturnValue();
          -[NSMutableDictionary setObject:forKey:](v56, "setObject:forKey:", v23, v36);

        }
        v37 = *(id *)(v18 + 16);
        if (v37)
        {
          v38 = v16;
          objc_msgSend(*(id *)(v16 + 3800), "dictionary");
          v39 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLongLong:", v17);
          v40 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v39, "setObject:forKey:", v40, CFSTR("entityID"));

          if (*(_QWORD *)(v18 + 32))
            v41 = *(const __CFString **)(v18 + 32);
          else
            v41 = CFSTR("(null)");
          objc_msgSend(v39, "setObject:forKey:", v41, CFSTR("name"));
          objc_msgSend(v37, "transform");
          v57 = v42;
          v58 = v43;
          v59 = v44;
          v60 = v45;
          re::audio::REPHASEAudioScene::fillOutDebugInformation(NSMutableDictionary *)::$_0::operator()(&v57);
          v46 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v39, "setObject:forKey:", v46, CFSTR("transform"));

          objc_msgSend(v37, "worldTransform");
          v57 = v47;
          v58 = v48;
          v59 = v49;
          v60 = v50;
          re::audio::REPHASEAudioScene::fillOutDebugInformation(NSMutableDictionary *)::$_0::operator()(&v57);
          v51 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v39, "setObject:forKey:", v51, CFSTR("worldTransform"));

          objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("Source Entity-%llu"), v17);
          v52 = (void *)objc_claimAutoreleasedReturnValue();
          -[NSMutableDictionary setObject:forKey:](v56, "setObject:forKey:", v39, v52);

          v16 = v38;
        }
      }
      else
      {
        objc_msgSend(MEMORY[0x24BDBCE70], "dictionary");
        v22 = (id)objc_claimAutoreleasedReturnValue();
        objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("null Entity-%llu"), v17);
        v37 = (id)objc_claimAutoreleasedReturnValue();
        -[NSMutableDictionary setObject:forKey:](v56, "setObject:forKey:", v22, v37);
      }

      if (v19)
      {
        v53 = (unint64_t *)&v19->__shared_owners_;
        do
          v54 = __ldaxr(v53);
        while (__stlxr(v54 - 1, v53));
        if (!v54)
        {
          ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
          std::__shared_weak_count::__release_weak(v19);
        }
      }
      v15 = (_QWORD *)*v15;
    }
    while (v15);
  }
  os_unfair_lock_unlock(lock);

}

void sub_225420CEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12, char a13)
{
  os_unfair_lock_s *v13;
  void *v14;
  void *v15;
  void *v16;

  os_unfair_lock_unlock(v13);
  _Unwind_Resume(a1);
}

id re::audio::REPHASEAudioScene::fillOutDebugInformation(NSMutableDictionary *)::$_0::operator()(_DWORD *a1)
{
  void *v2;
  double v3;
  void *v4;
  double v5;
  void *v6;
  double v7;
  void *v8;
  double v9;
  void *v10;
  void *v11;
  double v12;
  void *v13;
  double v14;
  void *v15;
  double v16;
  void *v17;
  double v18;
  void *v19;
  void *v20;
  double v21;
  void *v22;
  double v23;
  void *v24;
  double v25;
  void *v26;
  double v27;
  void *v28;
  void *v29;
  double v30;
  void *v31;
  double v32;
  void *v33;
  double v34;
  void *v35;
  double v36;
  void *v37;
  void *v38;
  _QWORD v40[4];
  _QWORD v41[4];
  _QWORD v42[4];
  _QWORD v43[5];

  v43[4] = *MEMORY[0x24BDAC8D0];
  objc_msgSend(MEMORY[0x24BDBCEB8], "array");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  LODWORD(v3) = *a1;
  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithFloat:", v3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v43[0] = v4;
  LODWORD(v5) = a1[4];
  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithFloat:", v5);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v43[1] = v6;
  LODWORD(v7) = a1[8];
  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithFloat:", v7);
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  v43[2] = v8;
  LODWORD(v9) = a1[12];
  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithFloat:", v9);
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  v43[3] = v10;
  objc_msgSend(MEMORY[0x24BDBCE30], "arrayWithObjects:count:", v43, 4);
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "addObject:", v11);

  LODWORD(v12) = a1[1];
  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithFloat:", v12);
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  v42[0] = v13;
  LODWORD(v14) = a1[5];
  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithFloat:", v14);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  v42[1] = v15;
  LODWORD(v16) = a1[9];
  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithFloat:", v16);
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v42[2] = v17;
  LODWORD(v18) = a1[13];
  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithFloat:", v18);
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v42[3] = v19;
  objc_msgSend(MEMORY[0x24BDBCE30], "arrayWithObjects:count:", v42, 4);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "addObject:", v20);

  LODWORD(v21) = a1[2];
  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithFloat:", v21);
  v22 = (void *)objc_claimAutoreleasedReturnValue();
  v41[0] = v22;
  LODWORD(v23) = a1[6];
  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithFloat:", v23);
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v41[1] = v24;
  LODWORD(v25) = a1[10];
  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithFloat:", v25);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v41[2] = v26;
  LODWORD(v27) = a1[14];
  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithFloat:", v27);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  v41[3] = v28;
  objc_msgSend(MEMORY[0x24BDBCE30], "arrayWithObjects:count:", v41, 4);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "addObject:", v29);

  LODWORD(v30) = a1[3];
  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithFloat:", v30);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v40[0] = v31;
  LODWORD(v32) = a1[7];
  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithFloat:", v32);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  v40[1] = v33;
  LODWORD(v34) = a1[11];
  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithFloat:", v34);
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  v40[2] = v35;
  LODWORD(v36) = a1[15];
  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithFloat:", v36);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  v40[3] = v37;
  objc_msgSend(MEMORY[0x24BDBCE30], "arrayWithObjects:count:", v40, 4);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "addObject:", v38);

  return v2;
}

void sub_2254210B0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  _Unwind_Resume(a1);
}

void re::audio::REPHASEAudioScene::getOrCreateEntity(os_unfair_lock_s *this@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  os_unfair_lock_s *v5;
  os_unfair_lock_s *v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;

  v24 = a2;
  v5 = this + 4;
  os_unfair_lock_lock(this + 4);
  v22 = 0;
  v23 = 0;
  v6 = this + 6;
  v7 = std::__hash_table<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>>>::find<unsigned long long>(v6, &v24);
  if (v7)
  {
    v8 = v7[4];
    *a3 = v7[3];
    a3[1] = v8;
    if (v8)
    {
      v9 = (unint64_t *)(v8 + 8);
      do
        v10 = __ldxr(v9);
      while (__stxr(v10 + 1, v9));
    }
  }
  else
  {
    v11 = operator new();
    *(_OWORD *)v11 = 0u;
    *(_OWORD *)(v11 + 16) = 0u;
    v12 = MEMORY[0x24BDAEE00];
    v13 = *MEMORY[0x24BDAEE00];
    v14 = *(_OWORD *)(MEMORY[0x24BDAEE00] + 16);
    *(_OWORD *)(v11 + 32) = 0u;
    *(_OWORD *)(v11 + 48) = v13;
    v15 = *(_OWORD *)(v12 + 32);
    v16 = *(_OWORD *)(v12 + 48);
    *(_OWORD *)(v11 + 64) = v14;
    *(_OWORD *)(v11 + 80) = v15;
    *(_OWORD *)(v11 + 96) = v16;
    *(_OWORD *)(v11 + 112) = 0u;
    std::shared_ptr<re::audio::REPHASEEntity>::shared_ptr[abi:ne180100]<re::audio::REPHASEEntity,void>(&v20, (_QWORD *)v11);
    v17 = v20;
    v18 = v21;
    v22 = v20;
    v23 = v21;
    v19 = std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<re::audio::REPHASEEntity>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<re::audio::REPHASEEntity>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<re::audio::REPHASEEntity>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<re::audio::REPHASEEntity>>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t)v6, v24, (uint64_t *)&v24);
    std::shared_ptr<re::audio::REPHASEEntity>::operator=[abi:ne180100](v19 + 3, v17, v18);
    *a3 = v17;
    a3[1] = v18;
  }
  os_unfair_lock_unlock(v5);
}

void sub_2254212B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  os_unfair_lock_s *v4;
  va_list va;

  va_start(va, a4);
  std::shared_ptr<re::AssetManager>::~shared_ptr[abi:nn180100]((uint64_t)va);
  os_unfair_lock_unlock(v4);
  _Unwind_Resume(a1);
}

_QWORD *std::shared_ptr<re::audio::REPHASEEntity>::operator=[abi:ne180100](_QWORD *a1, uint64_t a2, uint64_t a3)
{
  unint64_t *v4;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;

  if (a3)
  {
    v4 = (unint64_t *)(a3 + 8);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  v6 = (std::__shared_weak_count *)a1[1];
  *a1 = a2;
  a1[1] = a3;
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  return a1;
}

void re::audio::REPHASEAudioScene::getOrCreateEntityWithIncrementedCount(os_unfair_lock_s *this@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  os_unfair_lock_s *v5;
  os_unfair_lock_s *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;

  v26 = a2;
  v5 = this + 4;
  os_unfair_lock_lock(this + 4);
  v24 = 0;
  v25 = 0;
  v6 = this + 6;
  v7 = std::__hash_table<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>>>::find<unsigned long long>(v6, &v26);
  if (v7)
  {
    v8 = v7[3];
    ++*(_DWORD *)(v8 + 112);
    v9 = v7[4];
    *a3 = v8;
    a3[1] = v9;
    if (v9)
    {
      v10 = (unint64_t *)(v9 + 8);
      do
        v11 = __ldxr(v10);
      while (__stxr(v11 + 1, v10));
    }
  }
  else
  {
    v12 = operator new();
    *(_OWORD *)v12 = 0u;
    *(_OWORD *)(v12 + 16) = 0u;
    v13 = MEMORY[0x24BDAEE00];
    v14 = *MEMORY[0x24BDAEE00];
    v15 = *(_OWORD *)(MEMORY[0x24BDAEE00] + 16);
    *(_OWORD *)(v12 + 32) = 0u;
    *(_OWORD *)(v12 + 48) = v14;
    v16 = *(_OWORD *)(v13 + 32);
    v17 = *(_OWORD *)(v13 + 48);
    *(_OWORD *)(v12 + 64) = v15;
    *(_OWORD *)(v12 + 80) = v16;
    *(_OWORD *)(v12 + 96) = v17;
    *(_OWORD *)(v12 + 112) = 0u;
    std::shared_ptr<re::audio::REPHASEEntity>::shared_ptr[abi:ne180100]<re::audio::REPHASEEntity,void>(&v22, (_QWORD *)v12);
    v18 = v22;
    v19 = v23;
    v24 = v22;
    v25 = v23;
    v20 = v26;
    ++*(_DWORD *)(v22 + 112);
    v21 = std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<re::audio::REPHASEEntity>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<re::audio::REPHASEEntity>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<re::audio::REPHASEEntity>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<re::audio::REPHASEEntity>>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t)v6, v20, (uint64_t *)&v26);
    std::shared_ptr<re::audio::REPHASEEntity>::operator=[abi:ne180100](v21 + 3, v18, v19);
    *a3 = v18;
    a3[1] = v19;
  }
  os_unfair_lock_unlock(v5);
}

void sub_225421468(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  os_unfair_lock_s *v4;
  va_list va;

  va_start(va, a4);
  std::shared_ptr<re::AssetManager>::~shared_ptr[abi:nn180100]((uint64_t)va);
  os_unfair_lock_unlock(v4);
  _Unwind_Resume(a1);
}

void re::audio::REPHASEAudioScene::decrementOrDestroyEntityWithZeroCount(os_unfair_lock_s *this, uint64_t a2)
{
  os_unfair_lock_s *v4;
  os_unfair_lock_s *v5;
  re *v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  int v11;
  BOOL v12;
  NSObject *v13;
  NSObject *v14;
  unint64_t *v15;
  unint64_t v16;
  _BYTE buf[24];
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  v4 = this + 4;
  os_unfair_lock_lock(this + 4);
  *(_QWORD *)buf = a2;
  v5 = this + 6;
  v6 = (re *)std::__hash_table<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>>>::find<unsigned long long>(&this[6]._os_unfair_lock_opaque, (unint64_t *)buf);
  if (v6)
  {
    v7 = *((_QWORD *)v6 + 3);
    v8 = (std::__shared_weak_count *)*((_QWORD *)v6 + 4);
    if (v8)
    {
      p_shared_owners = (unint64_t *)&v8->__shared_owners_;
      do
        v10 = __ldxr(p_shared_owners);
      while (__stxr(v10 + 1, p_shared_owners));
    }
    if (v7)
    {
      v11 = *(_DWORD *)(v7 + 112);
      v12 = __OFSUB__(v11--, 1);
      *(_DWORD *)(v7 + 112) = v11;
      if ((v11 < 0) ^ v12 | (v11 == 0))
      {
        v13 = *re::audioLogObjects(v6);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 134217984;
          *(_QWORD *)&buf[4] = a2;
          _os_log_impl(&dword_224FE9000, v13, OS_LOG_TYPE_DEFAULT, "Removing PHASEEntity with ID: %llu", buf, 0xCu);
        }
        *(_QWORD *)buf = a2;
        std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<re::audio::REPHASEEntity>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<re::audio::REPHASEEntity>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<re::audio::REPHASEEntity>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<re::audio::REPHASEEntity>>>>::__erase_unique<unsigned long long>(v5, (unint64_t *)buf);
      }
LABEL_13:
      if (!v8)
        goto LABEL_18;
      goto LABEL_14;
    }
  }
  else
  {
    v8 = 0;
  }
  v14 = *re::audioLogObjects(v6);
  if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    goto LABEL_13;
  *(_WORD *)buf = 0;
  _os_log_error_impl(&dword_224FE9000, v14, OS_LOG_TYPE_ERROR, "decrementOrDestroyEntityWithZeroCount: PHASEEntity is a nullptr", buf, 2u);
  if (!v8)
    goto LABEL_18;
LABEL_14:
  v15 = (unint64_t *)&v8->__shared_owners_;
  do
    v16 = __ldaxr(v15);
  while (__stlxr(v16 - 1, v15));
  if (!v16)
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
LABEL_18:
  os_unfair_lock_unlock(v4);
}

void sub_225421630(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  os_unfair_lock_s *v9;

  std::shared_ptr<re::AssetManager>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  os_unfair_lock_unlock(v9);
  _Unwind_Resume(a1);
}

_QWORD *re::audio::REPHASEAudioScene::getEntityUnderLock@<X0>(re::audio::REPHASEAudioScene *this@<X0>, unint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *result;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  unint64_t v8;

  v8 = a2;
  result = std::__hash_table<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>>>::find<unsigned long long>((_QWORD *)this + 3, &v8);
  if (result)
  {
    v5 = result[4];
    *a3 = result[3];
    a3[1] = v5;
    if (v5)
    {
      v6 = (unint64_t *)(v5 + 8);
      do
        v7 = __ldxr(v6);
      while (__stxr(v7 + 1, v6));
    }
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
  }
  return result;
}

void re::audio::REPHASEAudioScene::getEntity(os_unfair_lock_s *this@<X0>, unint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  os_unfair_lock_s *v6;

  v6 = this + 4;
  os_unfair_lock_lock(this + 4);
  re::audio::REPHASEAudioScene::getEntityUnderLock((re::audio::REPHASEAudioScene *)this, a2, a3);
  os_unfair_lock_unlock(v6);
}

void sub_225421700(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void re::audio::REPHASEAudioScene::removeEntity(os_unfair_lock_s *this, unint64_t a2)
{
  os_unfair_lock_s *v3;
  unint64_t v4;

  v4 = a2;
  v3 = this + 4;
  os_unfair_lock_lock(this + 4);
  std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<re::audio::REPHASEEntity>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<re::audio::REPHASEEntity>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<re::audio::REPHASEEntity>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<re::audio::REPHASEEntity>>>>::__erase_unique<unsigned long long>(&this[6]._os_unfair_lock_opaque, &v4);
  os_unfair_lock_unlock(v3);
}

void sub_22542175C(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void re::audio::REPHASEAudioScene::createListener(uint64_t a1, char a2)
{
  id *v3;
  id WeakRetained;
  void *v5;
  id *v6;
  id v7;
  id v8;
  void *v9;
  void *v10;
  id v11;
  void *v12;
  void *v13;
  int v14;
  id v15;
  os_unfair_lock_s *v16;
  id v17;

  *(_BYTE *)(a1 + 144) = a2;
  v3 = (id *)(a1 + 128);
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 128));
  objc_msgSend(WeakRetained, "maybeEngine");
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  if (v5)
  {
    v6 = (id *)(a1 + 72);
    if (!*(_QWORD *)(a1 + 72))
    {
      v7 = objc_alloc(MEMORY[0x24BDE3280]);
      v8 = objc_loadWeakRetained(v3);
      objc_msgSend(v8, "engine");
      v9 = (void *)objc_claimAutoreleasedReturnValue();
      v10 = (void *)objc_msgSend(v7, "initWithEngine:", v9);

      v11 = objc_loadWeakRetained(v3);
      objc_msgSend(v11, "engine");
      v12 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v12, "rootObject");
      v13 = (void *)objc_claimAutoreleasedReturnValue();
      v17 = 0;
      v14 = objc_msgSend(v13, "addChild:error:", v10, &v17);
      v15 = v17;

      v16 = (os_unfair_lock_s *)(a1 + 64);
      os_unfair_lock_lock(v16);
      if (v14)
        objc_storeStrong(v6, v10);
      os_unfair_lock_unlock(v16);

    }
  }
}

void sub_2254218A0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void re::audio::REPHASEAudioScene::createListenerIfPending(re::audio::REPHASEAudioScene *this)
{
  NSObject *v1;
  uint8_t v2[16];

  if (!*((_QWORD *)this + 9))
  {
    if (*((_BYTE *)this + 144))
    {
      re::audio::REPHASEAudioScene::createListener((uint64_t)this, *((_BYTE *)this + 144));
    }
    else
    {
      v1 = *re::audioLogObjects(this);
      if (os_log_type_enabled(v1, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)v2 = 0;
        _os_log_debug_impl(&dword_224FE9000, v1, OS_LOG_TYPE_DEBUG, "Cannot create a listener without a valid listener type.", v2, 2u);
      }
    }
  }
}

id re::audio::REPHASEAudioScene::getListener(re::audio::REPHASEAudioScene *this)
{
  os_unfair_lock_s *v2;
  id v3;

  v2 = (os_unfair_lock_s *)((char *)this + 64);
  os_unfair_lock_lock((os_unfair_lock_t)this + 16);
  v3 = *((id *)this + 9);
  os_unfair_lock_unlock(v2);
  return v3;
}

void re::audio::REPHASEAudioScene::removeListener(os_unfair_lock_s *this)
{
  os_unfair_lock_s *v2;
  void *v3;

  v2 = this + 16;
  os_unfair_lock_lock(this + 16);
  v3 = *(void **)&this[18]._os_unfair_lock_opaque;
  *(_QWORD *)&this[18]._os_unfair_lock_opaque = 0;

  os_unfair_lock_unlock(v2);
}

id re::audio::REPHASEAudioScene::getSessionRoot(os_unfair_lock_s *this, unint64_t a2)
{
  os_unfair_lock_s *v3;
  _QWORD *v4;
  id v5;
  unint64_t v7;

  v7 = a2;
  v3 = this + 20;
  os_unfair_lock_lock(this + 20);
  v4 = std::__hash_table<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>>>::find<unsigned long long>(&this[22]._os_unfair_lock_opaque, &v7);
  if (v4)
    v5 = (id)v4[3];
  else
    v5 = 0;
  os_unfair_lock_unlock(v3);
  return v5;
}

void sub_225421A4C(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void re::audio::REPHASEAudioScene::removeSessionRoot(os_unfair_lock_s *this, unint64_t a2)
{
  os_unfair_lock_s *v3;
  os_unfair_lock_s *v4;
  _QWORD *v5;
  unint64_t v6;

  v6 = a2;
  v3 = this + 20;
  os_unfair_lock_lock(this + 20);
  v4 = this + 22;
  v5 = std::__hash_table<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>>>::find<unsigned long long>(v4, &v6);
  if (v5)
  {
    objc_msgSend((id)v5[3], "setTransform:", *MEMORY[0x24BDAEE00], *(double *)(MEMORY[0x24BDAEE00] + 16), *(double *)(MEMORY[0x24BDAEE00] + 32), *(double *)(MEMORY[0x24BDAEE00] + 48));
    std::__hash_table<std::__hash_value_type<unsigned long long,void({block_pointer} {__strong})(REAudioPlaybackState,REAudioPlaybackState)>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,void({block_pointer} {__strong})(REAudioPlaybackState,REAudioPlaybackState)>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,void({block_pointer} {__strong})(REAudioPlaybackState,REAudioPlaybackState)>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,void({block_pointer} {__strong})(REAudioPlaybackState,REAudioPlaybackState)>>>::__erase_unique<unsigned long long>(v4, &v6);
  }
  os_unfair_lock_unlock(v3);
}

void sub_225421AD4(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void re::audio::REPHASEAudioScene::getSourceCount(os_unfair_lock_s *this, unsigned int *a2, unsigned int *a3)
{
  os_unfair_lock_s *v6;
  _QWORD *v7;
  int32x2_t v8;

  v6 = this + 4;
  os_unfair_lock_lock(this + 4);
  v7 = *(_QWORD **)&this[10]._os_unfair_lock_opaque;
  if (v7)
  {
    v8 = 0;
    do
    {
      v8 = vsub_s32(v8, vmovn_s64(vtstq_s64(*(int64x2_t *)(v7[3] + 16), *(int64x2_t *)(v7[3] + 16))));
      v7 = (_QWORD *)*v7;
    }
    while (v7);
    if (a2)
      goto LABEL_5;
  }
  else
  {
    v8 = 0;
    if (a2)
LABEL_5:
      *a2 = v8.i32[0];
  }
  if (a3)
    *a3 = v8.u32[1];
  os_unfair_lock_unlock(v6);
}

_QWORD *std::shared_ptr<re::audio::REPHASEAudioScene>::shared_ptr[abi:ne180100]<re::audio::REPHASEAudioScene,void>(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24ED3F4B8;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  std::shared_ptr<re::audio::REPHASESoundPrepareState>::__enable_weak_this[abi:ne180100]<re::audio::REPHASESoundPrepareState,re::audio::REPHASESoundPrepareState,void>((uint64_t)a1, a2, (uint64_t)a2);
  return a1;
}

void sub_225421BD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  uint64_t v10;

  a10 = 0;
  if (v10)
    std::default_delete<re::audio::REPHASEAudioScene>::operator()[abi:ne180100]((uint64_t)&a10, v10);
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<re::audio::REPHASEAudioScene *,std::shared_ptr<re::audio::REPHASEAudioScene>::__shared_ptr_default_delete<re::audio::REPHASEAudioScene,re::audio::REPHASEAudioScene>,std::allocator<re::audio::REPHASEAudioScene>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2276933B8);
}

void std::__shared_ptr_pointer<re::audio::REPHASEAudioScene *,std::shared_ptr<re::audio::REPHASEAudioScene>::__shared_ptr_default_delete<re::audio::REPHASEAudioScene,re::audio::REPHASEAudioScene>,std::allocator<re::audio::REPHASEAudioScene>>::__on_zero_shared(uint64_t a1)
{
  std::default_delete<re::audio::REPHASEAudioScene>::operator()[abi:ne180100](a1 + 24, *(_QWORD *)(a1 + 24));
}

uint64_t std::__shared_ptr_pointer<re::audio::REPHASEAudioScene *,std::shared_ptr<re::audio::REPHASEAudioScene>::__shared_ptr_default_delete<re::audio::REPHASEAudioScene,re::audio::REPHASEAudioScene>,std::allocator<re::audio::REPHASEAudioScene>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void std::default_delete<re::audio::REPHASEAudioScene>::operator()[abi:ne180100](uint64_t a1, uint64_t a2)
{
  std::__shared_weak_count *v3;

  if (a2)
  {

    objc_destroyWeak((id *)(a2 + 128));
    std::__hash_table<std::__hash_value_type<unsigned long long,void({block_pointer} {__strong})(void)>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,void({block_pointer} {__strong})(void)>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,void({block_pointer} {__strong})(void)>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,void({block_pointer} {__strong})(void)>>>::~__hash_table(a2 + 88);

    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<re::PersistedAssetData>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<re::PersistedAssetData>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<re::PersistedAssetData>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<re::PersistedAssetData>>>>::~__hash_table(a2 + 24);
    v3 = *(std::__shared_weak_count **)(a2 + 8);
    if (v3)
      std::__shared_weak_count::__release_weak(v3);
    JUMPOUT(0x2276933B8);
  }
}

void std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<re::audio::REPHASEEntity>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<re::audio::REPHASEEntity>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<re::audio::REPHASEEntity>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<re::audio::REPHASEEntity>>>>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t i;

  if (*(_QWORD *)(a1 + 24))
  {
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<re::PersistedAssetData>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<re::PersistedAssetData>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<re::PersistedAssetData>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<re::PersistedAssetData>>>>::__deallocate_node(a1, *(_QWORD **)(a1 + 16));
    *(_QWORD *)(a1 + 16) = 0;
    v2 = *(_QWORD *)(a1 + 8);
    if (v2)
    {
      for (i = 0; i != v2; ++i)
        *(_QWORD *)(*(_QWORD *)a1 + 8 * i) = 0;
    }
    *(_QWORD *)(a1 + 24) = 0;
  }
}

void std::__hash_table<std::__hash_value_type<unsigned long long,PHASEObject * {__strong}>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,PHASEObject * {__strong}>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,PHASEObject * {__strong}>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,PHASEObject * {__strong}>>>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t i;

  if (*(_QWORD *)(a1 + 24))
  {
    std::__hash_table<std::__hash_value_type<unsigned long long,void({block_pointer} {__strong})(void)>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,void({block_pointer} {__strong})(void)>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,void({block_pointer} {__strong})(void)>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,void({block_pointer} {__strong})(void)>>>::__deallocate_node(a1, *(id **)(a1 + 16));
    *(_QWORD *)(a1 + 16) = 0;
    v2 = *(_QWORD *)(a1 + 8);
    if (v2)
    {
      for (i = 0; i != v2; ++i)
        *(_QWORD *)(*(_QWORD *)a1 + 8 * i) = 0;
    }
    *(_QWORD *)(a1 + 24) = 0;
  }
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<re::audio::REPHASEEntity>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<re::audio::REPHASEEntity>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<re::audio::REPHASEEntity>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<re::audio::REPHASEEntity>>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(uint64_t a1, unint64_t a2, uint64_t *a3)
{
  unint64_t v3;
  unint64_t v5;
  unint64_t v7;
  uint8x8_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  float v15;
  float v16;
  _BOOL8 v17;
  unint64_t v18;
  unint64_t v19;
  int8x8_t prime;
  void *v21;
  void *v22;
  uint64_t v23;
  _QWORD *v24;
  unint64_t v25;
  uint8x8_t v26;
  unint64_t v27;
  uint8x8_t v28;
  uint64_t v29;
  _QWORD *v30;
  unint64_t v31;
  _QWORD *v32;
  unint64_t v33;
  void *v35;
  _QWORD v36[2];
  char v37;

  v5 = a2;
  v7 = *(_QWORD *)(a1 + 8);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = a2;
      if (v7 <= a2)
        v3 = a2 % v7;
    }
    else
    {
      v3 = (v7 - 1) & a2;
    }
    v9 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      v10 = (_QWORD *)*v9;
      if (*v9)
      {
        do
        {
          v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2)
              return v10;
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7)
                v11 %= v7;
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3)
              break;
          }
          v10 = (_QWORD *)*v10;
        }
        while (v10);
      }
    }
  }
  v12 = (_QWORD *)(a1 + 16);
  v13 = operator new(0x28uLL);
  v36[0] = v13;
  v36[1] = a1 + 16;
  *v13 = 0;
  v13[1] = v5;
  v14 = *a3;
  v13[3] = 0;
  v13[4] = 0;
  v13[2] = v14;
  v37 = 1;
  v15 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v16 = *(float *)(a1 + 32);
  if (!v7 || (float)(v16 * (float)v7) < v15)
  {
    v17 = 1;
    if (v7 >= 3)
      v17 = (v7 & (v7 - 1)) != 0;
    v18 = v17 | (2 * v7);
    v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19)
      prime = (int8x8_t)v19;
    else
      prime = (int8x8_t)v18;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
      v7 = *(_QWORD *)(a1 + 8);
    }
    if (*(_QWORD *)&prime <= v7)
    {
      if (*(_QWORD *)&prime >= v7)
        goto LABEL_60;
      v27 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (v28 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v28.i16[0] = vaddlv_u8(v28), v28.u32[0] > 1uLL))
      {
        v27 = std::__next_prime(v27);
      }
      else
      {
        v29 = 1 << -(char)__clz(v27 - 1);
        if (v27 >= 2)
          v27 = v29;
      }
      if (*(_QWORD *)&prime <= v27)
        prime = (int8x8_t)v27;
      if (*(_QWORD *)&prime >= v7)
      {
        v7 = *(_QWORD *)(a1 + 8);
        goto LABEL_60;
      }
      if (!*(_QWORD *)&prime)
      {
        v35 = *(void **)a1;
        *(_QWORD *)a1 = 0;
        if (v35)
          operator delete(v35);
        v7 = 0;
        *(_QWORD *)(a1 + 8) = 0;
        goto LABEL_60;
      }
    }
    if (*(_QWORD *)&prime >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v21 = operator new(8 * *(_QWORD *)&prime);
    v22 = *(void **)a1;
    *(_QWORD *)a1 = v21;
    if (v22)
      operator delete(v22);
    v23 = 0;
    *(int8x8_t *)(a1 + 8) = prime;
    do
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v23++) = 0;
    while (*(_QWORD *)&prime != v23);
    v24 = (_QWORD *)*v12;
    if (*v12)
    {
      v25 = v24[1];
      v26 = (uint8x8_t)vcnt_s8(prime);
      v26.i16[0] = vaddlv_u8(v26);
      if (v26.u32[0] > 1uLL)
      {
        if (v25 >= *(_QWORD *)&prime)
          v25 %= *(_QWORD *)&prime;
      }
      else
      {
        v25 &= *(_QWORD *)&prime - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v25) = v12;
      v30 = (_QWORD *)*v24;
      if (*v24)
      {
        do
        {
          v31 = v30[1];
          if (v26.u32[0] > 1uLL)
          {
            if (v31 >= *(_QWORD *)&prime)
              v31 %= *(_QWORD *)&prime;
          }
          else
          {
            v31 &= *(_QWORD *)&prime - 1;
          }
          if (v31 != v25)
          {
            if (!*(_QWORD *)(*(_QWORD *)a1 + 8 * v31))
            {
              *(_QWORD *)(*(_QWORD *)a1 + 8 * v31) = v24;
              goto LABEL_56;
            }
            *v24 = *v30;
            *v30 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v31);
            **(_QWORD **)(*(_QWORD *)a1 + 8 * v31) = v30;
            v30 = v24;
          }
          v31 = v25;
LABEL_56:
          v24 = v30;
          v30 = (_QWORD *)*v30;
          v25 = v31;
        }
        while (v30);
      }
    }
    v7 = (unint64_t)prime;
LABEL_60:
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v5)
        v5 %= v7;
    }
    else
    {
      v5 &= v7 - 1;
    }
    goto LABEL_64;
  }
  v5 = v3;
LABEL_64:
  v32 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v5);
  if (v32)
  {
    *(_QWORD *)v36[0] = *v32;
    *v32 = v36[0];
  }
  else
  {
    *(_QWORD *)v36[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v36[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v5) = v12;
    if (*(_QWORD *)v36[0])
    {
      v33 = *(_QWORD *)(*(_QWORD *)v36[0] + 8);
      if ((v7 & (v7 - 1)) != 0)
      {
        if (v33 >= v7)
          v33 %= v7;
      }
      else
      {
        v33 &= v7 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v33) = v36[0];
    }
  }
  v10 = (_QWORD *)v36[0];
  v36[0] = 0;
  ++*(_QWORD *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long long,std::shared_ptr<re::audio::REPHASEEntity>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,std::shared_ptr<re::audio::REPHASEEntity>>,void *>>>>::reset[abi:ne180100]((uint64_t)v36, 0);
  return v10;
}

void sub_225422184(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long long,std::shared_ptr<re::audio::REPHASEEntity>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,std::shared_ptr<re::audio::REPHASEEntity>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long long,std::shared_ptr<re::audio::REPHASEEntity>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,std::shared_ptr<re::audio::REPHASEEntity>>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  void *v2;

  v2 = *(void **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      std::shared_ptr<re::AssetManager>::~shared_ptr[abi:nn180100]((uint64_t)v2 + 24);
    operator delete(v2);
  }
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<re::audio::REPHASEEntity>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<re::audio::REPHASEEntity>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<re::audio::REPHASEEntity>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<re::audio::REPHASEEntity>>>>::__erase_unique<unsigned long long>(_QWORD *a1, unint64_t *a2)
{
  uint64_t result;
  _BYTE v4[24];

  result = (uint64_t)std::__hash_table<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>>>::find<unsigned long long>(a1, a2);
  if (result)
  {
    std::__hash_table<std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>>>::remove(a1, (_QWORD *)result, (uint64_t)v4);
    std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long long,std::shared_ptr<re::audio::REPHASEEntity>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,std::shared_ptr<re::audio::REPHASEEntity>>,void *>>>>::reset[abi:ne180100]((uint64_t)v4, 0);
    return 1;
  }
  return result;
}

uint64_t re::DisplayStateNotificationManager::DisplayStateNotificationManager(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  float **v4;

  *(_DWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  v4 = (float **)(a1 + 8);
  *(_QWORD *)(a1 + 16) = 0;
  std::shared_ptr<std::atomic<re::VideoReturn>>::operator=[abi:nn180100]((_QWORD *)(a1 + 8), a3);
  re::AudioEngineRunnableManager::addReason(*v4, 0);
  return a1;
}

void sub_225422274(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<re::AssetManager>::~shared_ptr[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void re::DisplayStateNotificationManager::~DisplayStateNotificationManager(re::DisplayStateNotificationManager *this)
{
  notify_cancel(*(_DWORD *)this);
  std::shared_ptr<re::AssetManager>::~shared_ptr[abi:nn180100]((uint64_t)this + 8);
}

id re::audio::SoundAssetRegistrar_Plain::registerSoundAssetWithAudioFileData(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  objc_msgSend(a2, "registerSoundAssetWithAudioFileData:identifier:assetType:fileTypeHint:channelLayout:normalizationMode:error:", a11);
  return (id)objc_claimAutoreleasedReturnValue();
}

id re::audio::SoundAssetRegistrar_Plain::registerSoundAssetAtURL(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  objc_msgSend(a2, "registerSoundAssetAtURL:identifier:assetType:channelLayout:normalizationMode:error:", a3, a4, a5, a7, a8, a11);
  return (id)objc_claimAutoreleasedReturnValue();
}

id re::audio::SoundAssetRegistrar_Plain::registerSoundAssetWithData(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  objc_msgSend(a2, "registerSoundAssetWithData:identifier:format:normalizationMode:error:", a3, a4, a5, a6, a9);
  return (id)objc_claimAutoreleasedReturnValue();
}

void re::audio::SoundAssetRegistrar_Plain::~SoundAssetRegistrar_Plain(re::audio::SoundAssetRegistrar_Plain *this)
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::audio::phasePrivateReverbPresetFor(re *a1)
{
  uint64_t v1;
  unsigned __int16 v2;
  unsigned __int16 v3;
  unsigned __int16 v4;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  unsigned __int16 v8;
  uint8_t v10[16];

  v1 = 1917742958;
  if ((uint64_t)a1 > 200)
  {
    switch((unint64_t)a1)
    {
      case 0x3E9uLL:
        v2 = 28209;
        return v2 | 0x72450000u;
      case 0x3EAuLL:
        return 1917152818;
      case 0x3EBuLL:
        v8 = 28209;
        goto LABEL_44;
      case 0x3ECuLL:
        return 1917152820;
      case 0x3EDuLL:
        return 1917152821;
      case 0x3EEuLL:
        return 1917152822;
      case 0x3EFuLL:
        return 1917152823;
      case 0x3F0uLL:
        return 1917152824;
      case 0x3F1uLL:
        return 1917152825;
      case 0x3F2uLL:
        v2 = 12592;
        return v2 | 0x72450000u;
      case 0x3F3uLL:
        return v1;
      case 0x3F4uLL:
        v8 = 12592;
LABEL_44:
        v1 = v8 | 0x72450002;
        break;
      default:
        switch((unint64_t)a1)
        {
          case 0xC9uLL:
            v1 = 1917022062;
            break;
          case 0xCAuLL:
LABEL_10:
            v3 = 29549;
LABEL_24:
            v1 = v3 | 0x724D0000u;
            break;
          case 0xCBuLL:
LABEL_11:
            v1 = 1917604403;
            break;
          case 0xCCuLL:
LABEL_12:
            v1 = 1917604404;
            break;
          case 0xCDuLL:
LABEL_13:
            v1 = 1917020526;
            break;
          case 0xCEuLL:
LABEL_14:
            v4 = 29293;
LABEL_26:
            v1 = v4 | 0x724C0000u;
            break;
          case 0xCFuLL:
LABEL_15:
            v1 = 1917613682;
            break;
          case 0xD0uLL:
LABEL_16:
            v1 = 1917547630;
            break;
          case 0xD1uLL:
LABEL_17:
            v1 = 1916952948;
            break;
          default:
            return v1;
        }
        break;
    }
  }
  else
  {
    switch((unint64_t)a1)
    {
      case 1uLL:
        return 1917669997;
      case 2uLL:
        return v1;
      case 3uLL:
        v5 = 1917666152;
        return v5 + 1225;
      case 4uLL:
        v5 = 1917600616;
        return v5 + 1225;
      case 5uLL:
        v1 = 1917600616;
        v6 = *re::audioLogObjects(a1);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)v10 = 0;
          _os_log_error_impl(&dword_224FE9000, v6, OS_LOG_TYPE_ERROR, "No PHASEPrivateReverbPreset matches kPlate", v10, 2u);
        }
        return v1;
      case 6uLL:
        v3 = 17256;
        goto LABEL_24;
      case 7uLL:
        v4 = 17256;
        goto LABEL_26;
      case 8uLL:
        return 1917023336;
      case 9uLL:
        return 1917604402;
      case 0xAuLL:
        v7 = 1917666152;
        goto LABEL_32;
      case 0xBuLL:
        return 1917667379;
      case 0xCuLL:
        v7 = 1917600616;
LABEL_32:
        v1 = v7 + 1226;
        break;
      default:
        switch((unint64_t)a1)
        {
          case 'd':
            v1 = 1916890725;
            break;
          case 'e':
            v1 = 1917810036;
            break;
          case 'f':
            goto LABEL_10;
          case 'g':
            goto LABEL_11;
          case 'h':
            goto LABEL_12;
          case 'i':
            goto LABEL_13;
          case 'j':
            goto LABEL_14;
          case 'k':
            goto LABEL_15;
          case 'l':
            goto LABEL_16;
          case 'm':
            goto LABEL_17;
          default:
            return v1;
        }
        break;
    }
  }
  return v1;
}

const char *re::audio::phasePrivateReverbPresetName(uint64_t a1)
{
  const char *v1;
  const char *result;
  uint64_t v3;
  const char *v4;
  const char *v5;
  const char *v6;
  BOOL v7;
  const char *v8;
  uint64_t v9;
  const char *v10;
  unsigned __int16 v11;
  const char *v12;
  const char *v13;
  const char *v14;
  const char *v15;

  v1 = "None";
  if (a1 > 1917547629)
  {
    if (a1 > 1917613681)
    {
      if (a1 > 1917667378)
      {
        v3 = 1917678444;
        v15 = "Outside";
        if (a1 != 1917810036)
          v15 = "None";
        if (a1 == 1917678445)
          v5 = "VeryLargeRoom";
        else
          v5 = v15;
        v6 = "MediumHall3";
        v7 = a1 == 1917669997;
        v8 = "MediumRoom";
        v9 = 1917667379;
        goto LABEL_45;
      }
      v3 = 1917667376;
      v10 = "MediumHall2";
      if (a1 != 1917667378)
        v10 = "None";
      if (a1 == 1917667377)
        v5 = "MediumHall";
      else
        v5 = v10;
      v6 = "SmallRoom";
      v7 = a1 == 1917666152;
      v8 = "MediumChamber";
      v11 = 30322;
    }
    else
    {
      if (a1 <= 1917604401)
      {
        v3 = 1917601840;
        v4 = "LargeHall2";
        if (a1 != 1917601842)
          v4 = "None";
        if (a1 == 1917601841)
          v5 = "LargeHall";
        else
          v5 = v4;
        v6 = "SmallRoomBright";
        v7 = a1 == 1917600616;
        v8 = "LargeChamber";
        v9 = 1917547630;
        goto LABEL_45;
      }
      v3 = 1917604403;
      v14 = "MediumRoomTreated";
      if (a1 != 1917612653)
        v14 = "None";
      if (a1 == 1917604404)
        v5 = "LargeRoomTreated";
      else
        v5 = v14;
      v6 = "LargeRoom2";
      v7 = a1 == 1917604403;
      v8 = "LargeRoom";
      v11 = 21042;
    }
    v9 = v11 | 0x724C0000u;
LABEL_45:
    if (v7)
      v1 = v8;
    if (a1 == v9)
      v1 = v6;
    goto LABEL_49;
  }
  if (a1 <= 1917137200)
  {
    v3 = 1917022061;
    v12 = "Cathedral";
    v13 = "Environment10";
    if (a1 != 1917137200)
      v13 = "None";
    if (a1 != 1917023336)
      v12 = v13;
    if (a1 == 1917022062)
      v5 = "ConcertHall";
    else
      v5 = v12;
    if (a1 == 1917020526)
      v1 = "MediumRoomDry";
    if (a1 == 1916952948)
      v1 = "VerySmallRoomBright";
LABEL_49:
    if (a1 <= v3)
      return v1;
    else
      return v5;
  }
  switch(a1)
  {
    case 1917152817:
      result = "Environment01";
      break;
    case 1917152818:
      result = "Environment02";
      break;
    case 1917152819:
      result = "Environment03";
      break;
    case 1917152820:
      result = "Environment04";
      break;
    case 1917152821:
      result = "Environment05";
      break;
    case 1917152822:
      result = "Environment06";
      break;
    case 1917152823:
      result = "Environment07";
      break;
    case 1917152824:
      result = "Environment08";
      break;
    case 1917152825:
      result = "Environment09";
      break;
    default:
      if (a1 == 1917137202)
        v1 = "Environment12";
      if (a1 == 1917137201)
        result = "Environment11";
      else
        result = v1;
      break;
  }
  return result;
}

void sub_2254229C0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_225422AE4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_225422B30(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_225422F74(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  id *v4;
  id *v5;
  uint64_t v6;

  objc_destroyWeak(v5);
  objc_destroyWeak(v4);
  objc_destroyWeak((id *)(v6 - 144));

  _Unwind_Resume(a1);
}

void sub_225423140(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_2254232A0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_225423358(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

void sub_225423528(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_225423784(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_2254239E0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_225423CC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location)
{
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  id *v25;
  void *v26;
  id *v27;
  void *v28;

  v28 = v26;

  objc_destroyWeak(v27);
  objc_destroyWeak(v25);
  objc_destroyWeak(&location);

  _Unwind_Resume(a1);
}

void sub_225423E30(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_225423F44(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_225424340(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

_BYTE *re::audio::AudioFileAssetReader::init(_BYTE *this, re::SeekableInputStream *a2, char a3)
{
  _BYTE *v5;
  void (***v6)(_QWORD);
  uint64_t v7;

  v5 = this;
  v6 = *(void (****)(_QWORD))this;
  if (*(_QWORD *)this && this[8])
  {
    v7 = re::globalAllocators((re *)this)[2];
    (**v6)(v6);
    this = (_BYTE *)(*(uint64_t (**)(uint64_t, void (***)(_QWORD)))(*(_QWORD *)v7 + 40))(v7, v6);
  }
  *(_QWORD *)v5 = a2;
  v5[8] = a3;
  return this;
}

void sub_2254245DC(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void sub_22542469C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

uint64_t re::audio::CanStreamAudioFiles(re::audio *this)
{
  if (qword_254105940 != -1)
    dispatch_once(&qword_254105940, &__block_literal_global_7);
  return _MergedGlobals_121;
}

uint64_t ___ZN2re5audio19CanStreamAudioFilesEv_block_invoke()
{
  uint64_t result;

  result = objc_msgSend(MEMORY[0x24BDB1810], "instancesRespondToSelector:", sel_initForReadingFromExtAudioFile_error_);
  _MergedGlobals_121 = result;
  return result;
}

uint64_t re::audio::ConvertBufferFrameLength(re::audio *this, unsigned int a2, uint64_t a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  NSObject *v9;
  const char *v10;
  NSObject *v11;
  uint32_t v12;
  NSObject *v13;
  int v15;
  uint64_t v16;
  __int16 v17;
  uint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  if ((_DWORD)this)
  {
    v6 = a2;
    v7 = a3 * a2;
    if ((a3 * (unsigned __int128)a2) >> 64 == v7 >> 63)
    {
      v8 = 0;
      *a4 = v7 / this;
      return v8;
    }
    v8 = 1685348671;
    v9 = *re::audioLogObjects(this);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v15 = 134218240;
      v16 = a3;
      v17 = 2048;
      v18 = v6;
      v10 = "ConvertBufferFrameLength: frame length (%lld) * buffer sample rate (%lld) overflows SInt64";
      v11 = v9;
      v12 = 22;
LABEL_7:
      _os_log_error_impl(&dword_224FE9000, v11, OS_LOG_TYPE_ERROR, v10, (uint8_t *)&v15, v12);
    }
  }
  else
  {
    v8 = 1685348671;
    v13 = *re::audioLogObjects(this);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v15) = 0;
      v10 = "ConvertBufferFrameLength: invalid file sample rate = 0";
      v11 = v13;
      v12 = 2;
      goto LABEL_7;
    }
  }
  return v8;
}

void re::audio::AudioFileAssetReader::~AudioFileAssetReader(re::audio::AudioFileAssetReader *this)
{
  re::audio::AudioFileAssetReader *v1;
  void (***v2)(_QWORD);
  uint64_t v3;
  re::SeekableInputStreamBufferedReader *v4;
  uint64_t v5;
  OpaqueAudioFileID *v6;
  OpaqueExtAudioFile *v7;
  void *v8;

  v1 = this;
  v2 = *(void (****)(_QWORD))this;
  if (*(_QWORD *)this)
  {
    if (*((_BYTE *)this + 8))
    {
      v3 = re::globalAllocators(this)[2];
      (**v2)(v2);
      this = (re::audio::AudioFileAssetReader *)(*(uint64_t (**)(uint64_t, void (***)(_QWORD)))(*(_QWORD *)v3 + 40))(v3, v2);
    }
    *(_QWORD *)v1 = 0;
  }
  v4 = (re::SeekableInputStreamBufferedReader *)*((_QWORD *)v1 + 2);
  if (v4)
  {
    v5 = re::globalAllocators(this)[2];
    re::SeekableInputStreamBufferedReader::~SeekableInputStreamBufferedReader(v4);
    (*(void (**)(uint64_t, re::SeekableInputStreamBufferedReader *))(*(_QWORD *)v5 + 40))(v5, v4);
    *((_QWORD *)v1 + 2) = 0;
  }
  v6 = (OpaqueAudioFileID *)*((_QWORD *)v1 + 3);
  if (v6)
  {
    AudioFileClose(v6);
    *((_QWORD *)v1 + 3) = 0;
  }
  v7 = (OpaqueExtAudioFile *)*((_QWORD *)v1 + 4);
  if (v7)
  {
    ExtAudioFileDispose(v7);
    *((_QWORD *)v1 + 4) = 0;
  }
  v8 = (void *)*((_QWORD *)v1 + 6);
  *((_QWORD *)v1 + 6) = 0;

}

uint64_t re::audio::AudioFileAssetReader::createExtAudioFile(AudioFileID *this)
{
  AudioFileID *v2;
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  ExtAudioFileRef *v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t PropertyInfo;
  NSObject *v10;
  _WORD *v11;
  uint64_t Property;
  NSObject *v13;
  int v14;
  uint64_t v15;
  NSObject *v16;
  uint64_t v17;
  NSObject *v18;
  uint64_t v19;
  NSObject *v20;
  int v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t *v24;
  NSObject *v25;
  NSObject *v27;
  const char *v28;
  NSObject *v29;
  uint32_t v30;
  uint64_t v31;
  re *v32;
  NSObject *v33;
  NSObject *v34;
  void *v35;
  uint64_t v36;
  AudioFileID v37;
  uint64_t v38;
  UInt32 ioPropertyDataSize;
  UInt32 outSize;
  uint8_t v41[4];
  int v42;
  _BYTE v43[12];
  __int16 v44;
  int v45;
  double outPropertyData[6];
  uint8_t buf[8];
  _BYTE v48[12];
  int v49;
  int v50;
  int v51;
  uint64_t v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  v2 = this + 3;
  v3 = AudioFileOpenWithCallbacks(this, (AudioFile_ReadProc)re::audio::AudioFileAssetReader::readProc, 0, (AudioFile_GetSizeProc)re::audio::AudioFileAssetReader::getSizeProc, 0, 0x6D346166u, this + 3);
  if ((_DWORD)v3)
  {
    v4 = v3;
    v5 = *re::audioLogObjects((re *)v3);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = v4;
      _os_log_error_impl(&dword_224FE9000, v5, OS_LOG_TYPE_ERROR, "Failed to read audio file, err = %d", buf, 8u);
    }
    return v4;
  }
  v6 = this + 4;
  v7 = ExtAudioFileWrapAudioFileID(this[3], 0, this + 4);
  if ((_DWORD)v7)
  {
    v4 = v7;
    v8 = *re::audioLogObjects((re *)v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = v4;
      _os_log_error_impl(&dword_224FE9000, v8, OS_LOG_TYPE_ERROR, "Failed to read audio file, err = %d", buf, 8u);
    }
    AudioFileClose(*v2);
    return v4;
  }
  outSize = 0;
  PropertyInfo = ExtAudioFileGetPropertyInfo(*v6, 0x66636C6Fu, &outSize, 0);
  v4 = PropertyInfo;
  if ((_DWORD)PropertyInfo)
  {
    v10 = *re::audioLogObjects((re *)PropertyInfo);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = v4;
      _os_log_error_impl(&dword_224FE9000, v10, OS_LOG_TYPE_ERROR, "Failed to get property info for file channel layout. err = %d", buf, 8u);
    }
    ExtAudioFileDispose(*v6);
    AudioFileClose(*v2);
    return v4;
  }
  v11 = malloc_type_malloc(outSize, 0xF8B19F29uLL);
  Property = ExtAudioFileGetProperty(*v6, 0x66636C6Fu, &outSize, v11);
  v4 = Property;
  if (!(_DWORD)Property)
  {
    v14 = (unsigned __int16)*v11;
    if (*v11)
    {
LABEL_18:
      *(_QWORD *)v48 = 0x96C70636DLL;
      *(double *)buf = 48000.0;
      v52 = 32;
      v50 = 4 * v14;
      v51 = v14;
      *(_DWORD *)&v48[8] = 4 * v14;
      v49 = 1;
      ioPropertyDataSize = 40;
      v15 = ExtAudioFileGetProperty(*v6, 0x66666D74u, &ioPropertyDataSize, outPropertyData);
      v4 = v15;
      if ((_DWORD)v15)
      {
        v16 = *re::audioLogObjects((re *)v15);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)v43 = 67109120;
          *(_DWORD *)&v43[4] = v4;
          _os_log_error_impl(&dword_224FE9000, v16, OS_LOG_TYPE_ERROR, "Failed to get file data format. err = %d", v43, 8u);
        }
LABEL_35:
        ExtAudioFileDispose(*v6);
        AudioFileClose(*v2);
        goto LABEL_36;
      }
      v19 = ExtAudioFileSetProperty(*v6, 0x63666D74u, 0x28u, buf);
      v4 = v19;
      if ((_DWORD)v19)
      {
        v20 = *re::audioLogObjects((re *)v19);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)v43 = 67109120;
          *(_DWORD *)&v43[4] = v4;
          _os_log_error_impl(&dword_224FE9000, v20, OS_LOG_TYPE_ERROR, "Failed to set client memory format. err = %d", v43, 8u);
        }
        goto LABEL_35;
      }
      outSize = 8;
      v22 = (uint64_t *)(this + 5);
      v23 = ExtAudioFileGetProperty(this[4], 0x2366726Du, &outSize, this + 5);
      v4 = v23;
      if ((_DWORD)v23)
      {
        v25 = *re::audioLogObjects((re *)v23);
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)v43 = 67109120;
          *(_DWORD *)&v43[4] = v4;
          _os_log_error_impl(&dword_224FE9000, v25, OS_LOG_TYPE_ERROR, "Failed to get file length. err = %d", v43, 8u);
        }
        goto LABEL_35;
      }
      v31 = *v22;
      if (*v22 < 0)
      {
        v4 = 1685348671;
        v34 = *re::audioLogObjects((re *)v23);
        if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
        {
          v38 = *v22;
          *(_DWORD *)v43 = 134218240;
          *(_QWORD *)&v43[4] = v38;
          v44 = 1024;
          v45 = 1685348671;
          _os_log_error_impl(&dword_224FE9000, v34, OS_LOG_TYPE_ERROR, "Invalid file length = %lld, err = %d (kAudioFileInvalidFileError)", v43, 0x12u);
        }
      }
      else
      {
        *(_QWORD *)v43 = 0;
        v32 = (re *)re::audio::ConvertBufferFrameLength((re::audio *)outPropertyData[0], *(double *)buf, v31, (uint64_t *)v43, v24);
        v4 = (uint64_t)v32;
        if (!(_DWORD)v32)
        {
          *v22 = *(_QWORD *)v43;
          v50 = 4;
          *(_QWORD *)&v48[4] = 0x400000029;
          v35 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BDB17E8]), "initWithLayout:", v11);
          v36 = objc_msgSend(objc_alloc(MEMORY[0x24BDB1818]), "initWithStreamDescription:channelLayout:", buf, v35);
          v37 = this[6];
          this[6] = (AudioFileID)v36;

          goto LABEL_36;
        }
        v33 = *re::audioLogObjects(v32);
        if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)v41 = 67109120;
          v42 = v4;
          _os_log_error_impl(&dword_224FE9000, v33, OS_LOG_TYPE_ERROR, "Failed to convert buffer frame length, err = %d", v41, 8u);
        }
      }
      *v22 = 0;
      ExtAudioFileDispose(*v6);
      AudioFileClose(*v2);
LABEL_36:
      free(v11);
      return v4;
    }
    *(_DWORD *)v43 = 40;
    v17 = ExtAudioFileGetProperty(*v6, 0x66666D74u, (UInt32 *)v43, buf);
    v4 = v17;
    if ((_DWORD)v17)
    {
      v18 = *re::audioLogObjects((re *)v17);
      if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
LABEL_24:
        ExtAudioFileDispose(*v6);
        AudioFileClose(*v2);
        goto LABEL_36;
      }
      LODWORD(outPropertyData[0]) = 67109120;
      HIDWORD(outPropertyData[0]) = v4;
      v28 = "Failed to get property for file data layout. err = %d";
      v29 = v18;
      v30 = 8;
LABEL_51:
      _os_log_error_impl(&dword_224FE9000, v29, OS_LOG_TYPE_ERROR, v28, (uint8_t *)outPropertyData, v30);
      goto LABEL_24;
    }
    v14 = v51;
    if (v51 == 1)
    {
      v21 = 6553601;
    }
    else
    {
      if (v51 != 2)
      {
        v27 = *re::audioLogObjects((re *)v17);
        if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
          goto LABEL_24;
        LOWORD(outPropertyData[0]) = 0;
        v28 = "Loaded audio file with >2 channels is missing a layout tag.";
        v29 = v27;
        v30 = 2;
        goto LABEL_51;
      }
      v21 = 6619138;
    }
    *(_DWORD *)v11 = v21;
    goto LABEL_18;
  }
  v13 = *re::audioLogObjects((re *)Property);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v4;
    _os_log_error_impl(&dword_224FE9000, v13, OS_LOG_TYPE_ERROR, "Failed to get property for file channel layout. err = %d", buf, 8u);
  }
  ExtAudioFileDispose(*v6);
  AudioFileClose(*v2);
  if (v11)
    goto LABEL_36;
  return v4;
}

void sub_225425078(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  free(v1);
  _Unwind_Resume(a1);
}

uint64_t re::audio::AudioFileAssetReader::readProc(re **this, re *a2, uint64_t a3, uint64_t a4, _DWORD *a5, unsigned int *a6)
{
  unsigned int v8;
  re *v9;
  re *v11;
  re *v12;
  void *v13;
  int v14;
  int v15;
  uint64_t result;
  NSObject *v17;
  __int16 v18[8];

  v8 = a3;
  v9 = a2;
  v11 = (re *)(*(uint64_t (**)(re *, re *, uint64_t, uint64_t, _DWORD *, unsigned int *))(*(_QWORD *)*this + 64))(*this, a2, a3, a4, a5, a6);
  if (v11 < v9)
    v9 = v11;
  if (v11 >= (re *)((char *)v9 + v8))
    v12 = (re *)((char *)v9 + v8);
  else
    v12 = v11;
  if (v12 <= v9)
  {
    v17 = *re::audioLogObjects(v11);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      v18[0] = 0;
      _os_log_error_impl(&dword_224FE9000, v17, OS_LOG_TYPE_ERROR, "AudioFileAssetReader::readProc() invalid request.", (uint8_t *)v18, 2u);
    }
    result = 4294967256;
    if (a5)
    {
      v15 = 0;
      goto LABEL_13;
    }
  }
  else
  {
    (*(void (**)(re *, re *))(*(_QWORD *)*this + 56))(*this, v9);
    v14 = re::CopyRead(*this, (re::SeekableInputStream *)((int)v12 - (int)v9), a4, v13);
    if (a5)
    {
      v15 = v14;
      result = 0;
LABEL_13:
      *a5 = v15;
      return result;
    }
    return 0;
  }
  return result;
}

uint64_t re::audio::AudioFileAssetReader::getSizeProc(re::audio::AudioFileAssetReader *this, void *a2)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)this + 64))(*(_QWORD *)this);
}

id re::audio::AudioFileAssetReader::readFromData(re::audio::AudioFileAssetReader *this)
{
  re *ExtAudioFile;
  NSObject *v4;
  void *v5;
  AudioBufferList *v6;
  UInt32 v7;
  UInt32 v8;
  UInt32 v9;
  re *v10;
  UInt32 v11;
  NSObject *v12;
  id v13;
  UInt32 v14;
  void *v15;
  unsigned int v16;
  void **p_mData;
  unsigned int v18;
  UInt32 v19;
  re *v20;
  int v21;
  UInt32 v22;
  UInt32 v23;
  _DWORD *v24;
  void **v25;
  uint64_t v26;
  _DWORD *v27;
  _DWORD *v28;
  NSObject *v29;
  uint64_t v30;
  void *v31;
  UInt32 v32;
  UInt32 ioNumberFrames;
  uint8_t buf[4];
  int v35;
  AudioBufferList ioData;
  uint64_t v37;

  v37 = *MEMORY[0x24BDAC8D0];
  ExtAudioFile = (re *)re::audio::AudioFileAssetReader::createExtAudioFile((AudioFileID *)this);
  if ((_DWORD)ExtAudioFile)
    return 0;
  v4 = *re::audioLogObjects(ExtAudioFile);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    v30 = *((_QWORD *)this + 5);
    ioData.mNumberBuffers = 134217984;
    *(_QWORD *)(&ioData.mNumberBuffers + 1) = v30;
    _os_log_debug_impl(&dword_224FE9000, v4, OS_LOG_TYPE_DEBUG, "About to read %lld samples into memory", (uint8_t *)&ioData, 0xCu);
  }
  v5 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BDB1838]), "initWithPCMFormat:frameCapacity:", *((_QWORD *)this + 6), *((unsigned int *)this + 10));
  objc_msgSend(v5, "setFrameLength:", *((unsigned int *)this + 10));
  v6 = (AudioBufferList *)objc_msgSend(v5, "mutableAudioBufferList");
  v7 = *((_DWORD *)this + 10);
  ioNumberFrames = v7;
  v8 = objc_msgSend(*((id *)this + 6), "channelCount");
  v9 = v8;
  if (v8 == 1)
  {
    v10 = (re *)ExtAudioFileRead(*((ExtAudioFileRef *)this + 4), &ioNumberFrames, v6);
    v11 = v10;
    if ((_DWORD)v10)
    {
      v12 = *re::audioLogObjects(v10);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        ioData.mNumberBuffers = 67109120;
        *(&ioData.mNumberBuffers + 1) = v11;
        _os_log_error_impl(&dword_224FE9000, v12, OS_LOG_TYPE_ERROR, "Failed to read the audio samples. err = %d", (uint8_t *)&ioData, 8u);
      }
      v13 = 0;
      goto LABEL_31;
    }
    objc_msgSend(v5, "setFrameLength:", ioNumberFrames);
  }
  else
  {
    v31 = v5;
    v14 = v8 << 12;
    v15 = malloc_type_malloc(v8 << 12, 0x934CDEDuLL);
    ioData.mNumberBuffers = 1;
    ioData.mBuffers[0].mNumberChannels = v9;
    ioData.mBuffers[0].mDataByteSize = v14;
    ioData.mBuffers[0].mData = v15;
    if (v7)
    {
      v16 = 0;
      p_mData = &v6->mBuffers[0].mData;
      v18 = v7;
      while (1)
      {
        v19 = v18 >= 0x400 ? 1024 : v18;
        v32 = v19;
        v20 = (re *)ExtAudioFileRead(*((ExtAudioFileRef *)this + 4), &v32, &ioData);
        v21 = (int)v20;
        if ((_DWORD)v20)
          break;
        v22 = v32;
        if (!v32)
        {
          objc_msgSend(v31, "setFrameLength:", v7 - v18);
          goto LABEL_29;
        }
        v23 = v32 + v16;
        v24 = v15;
        do
        {
          if (v9)
          {
            v25 = p_mData;
            v26 = v9;
            do
            {
              v28 = *v25;
              v25 += 2;
              v27 = v28;
              LODWORD(v28) = *v24++;
              v27[v16] = (_DWORD)v28;
              --v26;
            }
            while (v26);
          }
          ++v16;
        }
        while (v16 != v23);
        v16 = v23;
        v18 -= v22;
        if (!v18)
          goto LABEL_29;
      }
      v29 = *re::audioLogObjects(v20);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109120;
        v35 = v21;
        _os_log_error_impl(&dword_224FE9000, v29, OS_LOG_TYPE_ERROR, "Failed to read the audio samples. err = %d", buf, 8u);
      }
      free(v15);
      v13 = 0;
      v5 = v31;
      goto LABEL_31;
    }
LABEL_29:
    free(v15);
    v5 = v31;
  }
  v13 = v5;
LABEL_31:

  return v13;
}

void sub_2254254C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{

  _Unwind_Resume(a1);
}

BOOL re::audio::AudioFileAssetWriter::writeToStreamWithDefaultCompression(id *this)
{
  void *v2;
  const AudioStreamBasicDescription *v3;
  UInt32 mChannelsPerFrame;
  AudioStreamBasicDescription inFormat;

  objc_msgSend(*this, "format");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v3 = (const AudioStreamBasicDescription *)objc_msgSend(v2, "streamDescription");

  inFormat.mSampleRate = 48000.0;
  mChannelsPerFrame = v3->mChannelsPerFrame;
  *(_QWORD *)&inFormat.mBitsPerChannel = 0;
  inFormat.mBytesPerFrame = 0;
  inFormat.mChannelsPerFrame = mChannelsPerFrame;
  *(_OWORD *)&inFormat.mFormatID = xmmword_226100F50;
  return re::audio::AudioFileAssetWriter::writeToStream(this, v3, &inFormat, 0x6D346166u);
}

void sub_225425580(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL re::audio::AudioFileAssetWriter::writeToStream(id *this, const AudioStreamBasicDescription *a2, AudioStreamBasicDescription *inFormat, AudioFileTypeID inFileType)
{
  re *v6;
  int v7;
  NSObject *v8;
  _BOOL8 result;
  re *v10;
  int v11;
  NSObject *v12;
  void *v13;
  void *v14;
  unsigned int *v15;
  uint64_t v16;
  int v17;
  void *v18;
  const void *v19;
  re *v20;
  int v21;
  NSObject *v22;
  re *v23;
  int v24;
  NSObject *v25;
  re *v26;
  int v27;
  NSObject *v28;
  re *v29;
  int v30;
  NSObject *v31;
  ExtAudioFileRef outExtAudioFile;
  AudioFileID inFileID;
  uint8_t buf[4];
  int v35;
  uint64_t v36;

  v36 = *MEMORY[0x24BDAC8D0];
  outExtAudioFile = 0;
  inFileID = 0;
  v6 = (re *)AudioFileInitializeWithCallbacks(this, (AudioFile_ReadProc)re::audio::AudioFileAssetWriter::readProc, (AudioFile_WriteProc)re::audio::AudioFileAssetWriter::writeProc, (AudioFile_GetSizeProc)re::audio::AudioFileAssetWriter::getSizeProc, (AudioFile_SetSizeProc)re::audio::AudioFileAssetWriter::setSizeProc, inFileType, inFormat, 0, &inFileID);
  v7 = (int)v6;
  if (!(_DWORD)v6)
  {
    v10 = (re *)ExtAudioFileWrapAudioFileID(inFileID, 1u, &outExtAudioFile);
    v11 = (int)v10;
    if ((_DWORD)v10)
    {
      v12 = *re::audioLogObjects(v10);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109120;
        v35 = v11;
        _os_log_error_impl(&dword_224FE9000, v12, OS_LOG_TYPE_ERROR, "Failed to open ExtAudioFile for writing. Err = %d", buf, 8u);
      }
      AudioFileClose(inFileID);
      return 0;
    }
    objc_msgSend(*this, "format");
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v13, "channelLayout");
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    v15 = (unsigned int *)objc_msgSend(v14, "layout");

    if (!v15)
    {
LABEL_32:
      v23 = (re *)ExtAudioFileSetProperty(outExtAudioFile, 0x63666D74u, 0x28u, a2);
      v24 = (int)v23;
      if ((_DWORD)v23)
      {
        v25 = *re::audioLogObjects(v23);
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67109120;
          v35 = v24;
          _os_log_error_impl(&dword_224FE9000, v25, OS_LOG_TYPE_ERROR, "Failed to set client data format. Err = %d", buf, 8u);
        }
      }
      else
      {
        v26 = (re *)ExtAudioFileSetProperty(outExtAudioFile, 0x63636C6Fu, 0x20u, v15);
        v27 = (int)v26;
        if ((_DWORD)v26)
        {
          v28 = *re::audioLogObjects(v26);
          if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 67109120;
            v35 = v27;
            _os_log_error_impl(&dword_224FE9000, v28, OS_LOG_TYPE_ERROR, "Failed to set client channel layout. Err = %d", buf, 8u);
          }
        }
        else
        {
          v29 = (re *)ExtAudioFileWrite(outExtAudioFile, objc_msgSend(*this, "frameLength"), (const AudioBufferList *)objc_msgSend(*this, "audioBufferList"));
          v30 = (int)v29;
          if (!(_DWORD)v29)
          {
            ExtAudioFileDispose(outExtAudioFile);
            AudioFileClose(inFileID);
            (*(void (**)(id, id, int64_t))(*(_QWORD *)this[1] + 16))(this[1], this[2], (_BYTE *)this[3] - (_BYTE *)this[2]);
            return 1;
          }
          v31 = *re::audioLogObjects(v29);
          if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 67109120;
            v35 = v30;
            _os_log_error_impl(&dword_224FE9000, v31, OS_LOG_TYPE_ERROR, "Failed to write audio buffer data. Err = %d", buf, 8u);
          }
        }
      }
      ExtAudioFileDispose(outExtAudioFile);
      AudioFileClose(inFileID);
      return 0;
    }
    v16 = *v15;
    if ((int)v16 <= 9240581)
    {
      if ((int)v16 > 7864324)
      {
        if ((_DWORD)v16 == 7864325 || (_DWORD)v16 == 8126470)
          goto LABEL_27;
        v17 = 8323080;
      }
      else
      {
        if ((_DWORD)v16 == 7077892 || (_DWORD)v16 == 7471107)
          goto LABEL_27;
        v17 = 7602180;
      }
    }
    else
    {
      if ((int)v16 > 9437191)
      {
        if ((int)v16 > 12058631)
        {
          if ((_DWORD)v16 != 12058632)
          {
            if ((_DWORD)v16 != 12386312)
              goto LABEL_32;
            v16 = 11993096;
          }
        }
        else if ((_DWORD)v16 != 9437192)
        {
          v17 = 11993096;
          goto LABEL_26;
        }
LABEL_27:
        v18 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BDB17E8]), "initWithLayoutTag:", v16);
        v19 = (const void *)objc_msgSend(v18, "layout");
        v20 = (re *)ExtAudioFileSetProperty(outExtAudioFile, 0x66636C6Fu, 0x20u, v19);
        v21 = (int)v20;
        if ((_DWORD)v20)
        {
          v22 = *re::audioLogObjects(v20);
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 67109120;
            v35 = v21;
            _os_log_error_impl(&dword_224FE9000, v22, OS_LOG_TYPE_ERROR, "Failed to set file channel layout. Err = %d", buf, 8u);
          }
          ExtAudioFileDispose(outExtAudioFile);
          AudioFileClose(inFileID);

          return 0;
        }

        goto LABEL_32;
      }
      if ((_DWORD)v16 == 9240582 || (_DWORD)v16 == 9306119)
        goto LABEL_27;
      v17 = 9371655;
    }
LABEL_26:
    if ((_DWORD)v16 != v17)
      goto LABEL_32;
    goto LABEL_27;
  }
  v8 = *re::audioLogObjects(v6);
  result = os_log_type_enabled(v8, OS_LOG_TYPE_ERROR);
  if (!result)
    return result;
  *(_DWORD *)buf = 67109120;
  v35 = v7;
  _os_log_error_impl(&dword_224FE9000, v8, OS_LOG_TYPE_ERROR, "Failed to open AudioFile for writing. Err = %d", buf, 8u);
  return 0;
}

void sub_225425AB4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

BOOL re::audio::AudioFileAssetWriter::writeToStreamWithCustomOutputDescription(id *a1, AudioStreamBasicDescription *a2, uint64_t a3)
{
  void *v6;
  const AudioStreamBasicDescription *v7;
  AudioFileTypeID v8;

  objc_msgSend(*a1, "format");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v7 = (const AudioStreamBasicDescription *)objc_msgSend(v6, "streamDescription");

  if ((a3 & 0xFF00000000) != 0)
    v8 = a3;
  else
    v8 = 1667327590;
  return re::audio::AudioFileAssetWriter::writeToStream(a1, v7, a2, v8);
}

void sub_225425B48(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t re::audio::AudioFileAssetWriter::readProc(re::audio::AudioFileAssetWriter *this, char *a2, int a3, void *__dst, int *a5, unsigned int *a6)
{
  uint64_t v6;
  char *v7;
  int v9;
  uint64_t result;

  v6 = *((_QWORD *)this + 2);
  v7 = (char *)(*((_QWORD *)this + 3) - v6);
  if (v7 <= a2)
    return 4294967256;
  if (v7 >= &a2[a3])
    v7 = &a2[a3];
  v9 = (_DWORD)v7 - (_DWORD)a2;
  memcpy(__dst, &a2[v6], v7 - a2);
  result = 0;
  if (a5)
    *a5 = v9;
  return result;
}

uint64_t re::audio::AudioFileAssetWriter::writeProc(re::audio::AudioFileAssetWriter *this, char *a2, size_t __n, void *__src, _DWORD *a5, unsigned int *a6)
{
  int v8;
  size_t v10;
  uint64_t v11;
  uint64_t *v12;
  unint64_t v13;
  char *v14;

  v8 = __n;
  v10 = __n;
  v11 = *((_QWORD *)this + 2);
  v12 = (uint64_t *)((char *)this + 16);
  v13 = *((_QWORD *)this + 3) - v11;
  v14 = &a2[__n];
  if ((unint64_t)v14 > v13)
  {
    std::vector<unsigned char>::__append((unint64_t *)this + 2, (size_t)&v14[-v13]);
    v11 = *v12;
  }
  memcpy(&a2[v11], __src, v10);
  if (a5)
    *a5 = v8;
  return 0;
}

uint64_t re::audio::AudioFileAssetWriter::getSizeProc(re::audio::AudioFileAssetWriter *this, void *a2)
{
  uint64_t v2;
  NSObject *v3;
  int v5;
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v2 = *((_QWORD *)this + 3) - *((_QWORD *)this + 2);
  v3 = *re::audioLogObjects(this);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    v5 = 134217984;
    v6 = v2;
    _os_log_debug_impl(&dword_224FE9000, v3, OS_LOG_TYPE_DEBUG, "AudioFileAsset.writer.getSize() -> %lld", (uint8_t *)&v5, 0xCu);
  }
  return v2;
}

uint64_t re::audio::AudioFileAssetWriter::setSizeProc(re::audio::AudioFileAssetWriter *this, char *a2)
{
  NSObject *v4;
  uint64_t v5;
  unint64_t v6;
  int v8;
  char *v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v4 = *re::audioLogObjects(this);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    v8 = 134217984;
    v9 = a2;
    _os_log_debug_impl(&dword_224FE9000, v4, OS_LOG_TYPE_DEBUG, "AudioFileAsset.writer.setSize(%lld)", (uint8_t *)&v8, 0xCu);
  }
  v5 = *((_QWORD *)this + 2);
  v6 = *((_QWORD *)this + 3) - v5;
  if ((unint64_t)a2 <= v6)
  {
    if ((unint64_t)a2 < v6)
      *((_QWORD *)this + 3) = &a2[v5];
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)this + 2, (size_t)&a2[-v6]);
  }
  return 0;
}

void std::vector<unsigned char>::__append(unint64_t *a1, size_t a2)
{
  char *v4;
  char *v5;
  unint64_t v6;
  char *v7;
  unint64_t v8;
  unint64_t v9;
  size_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  char v15;

  v5 = (char *)a1[1];
  v4 = (char *)a1[2];
  if (v4 - v5 >= a2)
  {
    if (a2)
    {
      bzero((void *)a1[1], a2);
      v5 += a2;
    }
    a1[1] = (unint64_t)v5;
  }
  else
  {
    v6 = *a1;
    v7 = &v5[-*a1];
    v8 = (unint64_t)&v7[a2];
    if ((uint64_t)&v7[a2] < 0)
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    v9 = (unint64_t)&v4[-v6];
    if (2 * v9 > v8)
      v8 = 2 * v9;
    if (v9 >= 0x3FFFFFFFFFFFFFFFLL)
      v10 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v10 = v8;
    if (v10)
      v11 = (unint64_t)operator new(v10);
    else
      v11 = 0;
    v12 = &v7[v11];
    v13 = (char *)(v11 + v10);
    bzero(v12, a2);
    if (v5 == (char *)v6)
    {
      v11 = (unint64_t)v12;
    }
    else
    {
      v14 = &v5[~v6];
      do
      {
        v15 = *--v5;
        (v14--)[v11] = v15;
      }
      while (v5 != (char *)v6);
      v5 = (char *)*a1;
    }
    *a1 = v11;
    a1[1] = (unint64_t)&v12[a2];
    a1[2] = (unint64_t)v13;
    if (v5)
      operator delete(v5);
  }
}

void re::AudioManager_PHASE_State_Recovering::~AudioManager_PHASE_State_Recovering(re::AudioManager_PHASE_State_Recovering *this)
{
  void **v2;
  uint64_t *v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  void **v9;

  *(_QWORD *)this = &off_24ED3F650;
  v2 = (void **)((char *)this + 8);
  v3 = (uint64_t *)*((_QWORD *)this + 1);
  v4 = (uint64_t *)*((_QWORD *)this + 2);
  if (v3 != v4)
  {
    do
    {
      v5 = *v3;
      *v3 = 0;
      if (v5)
        (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
      ++v3;
    }
    while (v3 != v4);
    v6 = (uint64_t *)*((_QWORD *)this + 1);
    v3 = (uint64_t *)*((_QWORD *)this + 2);
    if (v3 != v6)
    {
      do
      {
        v8 = *--v3;
        v7 = v8;
        *v3 = 0;
        if (v8)
          (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
      }
      while (v3 != v6);
      v3 = v6;
    }
  }
  *((_QWORD *)this + 2) = v3;
  v9 = v2;
  std::vector<std::unique_ptr<re::AudioManager_PHASE_StateMachine_RecoveryStep>>::__destroy_vector::operator()[abi:ne180100](&v9);
}

{
  re::AudioManager_PHASE_State_Recovering::~AudioManager_PHASE_State_Recovering(this);
  JUMPOUT(0x2276933B8);
}

uint64_t re::AudioManager_PHASE_State_Recovering::handleStateChangeEvent(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;

  if (a2 - 2 < 8)
  {
    v5 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * a2);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v5 + 16))(v5, a3, a4);
LABEL_3:
    v6 = *(_QWORD **)(a1 + 8);
    v7 = *(_QWORD **)(a1 + 16);
    if (v6 == v7)
    {
      v9 = 0x100000000;
      v8 = 2;
    }
    else
    {
      v8 = 2;
      while (((*(uint64_t (**)(_QWORD))(*(_QWORD *)*v6 + 24))(*v6) & 1) != 0)
      {
        if (++v6 == v7)
          goto LABEL_14;
      }
      v9 = 0;
      v8 = 0;
    }
    return v8 | v9;
  }
  if (a2)
  {
    if (a2 == 1)
    {
      v9 = 0x100000000;
      v8 = 1;
      return v8 | v9;
    }
    goto LABEL_3;
  }
  v8 = 0;
LABEL_14:
  v9 = 0x100000000;
  return v8 | v9;
}

void re::AudioManager_PHASE_State_Recovering::stateDescription(re::AudioManager_PHASE_State_Recovering *this@<X0>, std::string *a2@<X8>)
{
  std::string *v4;
  __int128 v5;
  void **v6;
  std::string::size_type v7;
  std::string *v8;
  __int128 v9;
  std::string *v10;
  __int128 v11;
  void **v12;
  std::string::size_type v13;
  std::string *v14;
  __int128 v15;
  std::string *v16;
  __int128 v17;
  void **v18;
  std::string::size_type v19;
  std::string *v20;
  __int128 v21;
  std::string *v22;
  __int128 v23;
  void **v24;
  std::string::size_type v25;
  std::string *v26;
  __int128 v27;
  std::string *v28;
  __int128 v29;
  void **v30;
  std::string::size_type v31;
  std::string *v32;
  __int128 v33;
  std::string *v34;
  __int128 v35;
  void **v36;
  std::string::size_type v37;
  std::string *v38;
  __int128 v39;
  std::string *v40;
  __int128 v41;
  void **v42;
  std::string::size_type v43;
  std::string *v44;
  __int128 v45;
  std::string *v46;
  void *__p[2];
  unsigned __int8 v48;
  void *v49[2];
  unsigned __int8 v50;
  void *v51[2];
  unsigned __int8 v52;
  void *v53[2];
  unsigned __int8 v54;
  void *v55[2];
  unsigned __int8 v56;
  void *v57[2];
  unsigned __int8 v58;
  void *v59[2];
  unsigned __int8 v60;
  void *v61;
  char v62;
  std::string v63;
  std::string v64;
  std::string v65;
  std::string v66;
  std::string v67;
  std::string v68;
  std::string v69;
  std::string v70;
  std::string v71;
  std::string v72;
  std::string v73;
  std::string v74;
  std::string v75;
  std::string v76;
  std::string v77;

  (*(void (**)(void **__return_ptr))(**(_QWORD **)(*((_QWORD *)this + 1) + 16) + 32))(&v61);
  std::operator+<char>();
  v4 = std::string::append(&v63, "), (");
  v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
  v64.__r_.__value_.__r.__words[2] = v4->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v64.__r_.__value_.__l.__data_ = v5;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  (*(void (**)(void **__return_ptr))(**(_QWORD **)(*((_QWORD *)this + 1) + 24) + 32))(v59);
  if ((v60 & 0x80u) == 0)
    v6 = v59;
  else
    v6 = (void **)v59[0];
  if ((v60 & 0x80u) == 0)
    v7 = v60;
  else
    v7 = (std::string::size_type)v59[1];
  v8 = std::string::append(&v64, (const std::string::value_type *)v6, v7);
  v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
  v65.__r_.__value_.__r.__words[2] = v8->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v65.__r_.__value_.__l.__data_ = v9;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  v10 = std::string::append(&v65, "), (");
  v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
  v66.__r_.__value_.__r.__words[2] = v10->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v66.__r_.__value_.__l.__data_ = v11;
  v10->__r_.__value_.__l.__size_ = 0;
  v10->__r_.__value_.__r.__words[2] = 0;
  v10->__r_.__value_.__r.__words[0] = 0;
  (*(void (**)(void **__return_ptr))(**(_QWORD **)(*((_QWORD *)this + 1) + 40) + 32))(v57);
  if ((v58 & 0x80u) == 0)
    v12 = v57;
  else
    v12 = (void **)v57[0];
  if ((v58 & 0x80u) == 0)
    v13 = v58;
  else
    v13 = (std::string::size_type)v57[1];
  v14 = std::string::append(&v66, (const std::string::value_type *)v12, v13);
  v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
  v67.__r_.__value_.__r.__words[2] = v14->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v67.__r_.__value_.__l.__data_ = v15;
  v14->__r_.__value_.__l.__size_ = 0;
  v14->__r_.__value_.__r.__words[2] = 0;
  v14->__r_.__value_.__r.__words[0] = 0;
  v16 = std::string::append(&v67, "), (");
  v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
  v68.__r_.__value_.__r.__words[2] = v16->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v68.__r_.__value_.__l.__data_ = v17;
  v16->__r_.__value_.__l.__size_ = 0;
  v16->__r_.__value_.__r.__words[2] = 0;
  v16->__r_.__value_.__r.__words[0] = 0;
  (*(void (**)(void **__return_ptr))(**(_QWORD **)(*((_QWORD *)this + 1) + 48) + 32))(v55);
  if ((v56 & 0x80u) == 0)
    v18 = v55;
  else
    v18 = (void **)v55[0];
  if ((v56 & 0x80u) == 0)
    v19 = v56;
  else
    v19 = (std::string::size_type)v55[1];
  v20 = std::string::append(&v68, (const std::string::value_type *)v18, v19);
  v21 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
  v69.__r_.__value_.__r.__words[2] = v20->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v69.__r_.__value_.__l.__data_ = v21;
  v20->__r_.__value_.__l.__size_ = 0;
  v20->__r_.__value_.__r.__words[2] = 0;
  v20->__r_.__value_.__r.__words[0] = 0;
  v22 = std::string::append(&v69, "), (");
  v23 = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
  v70.__r_.__value_.__r.__words[2] = v22->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v70.__r_.__value_.__l.__data_ = v23;
  v22->__r_.__value_.__l.__size_ = 0;
  v22->__r_.__value_.__r.__words[2] = 0;
  v22->__r_.__value_.__r.__words[0] = 0;
  (*(void (**)(void **__return_ptr))(**(_QWORD **)(*((_QWORD *)this + 1) + 32) + 32))(v53);
  if ((v54 & 0x80u) == 0)
    v24 = v53;
  else
    v24 = (void **)v53[0];
  if ((v54 & 0x80u) == 0)
    v25 = v54;
  else
    v25 = (std::string::size_type)v53[1];
  v26 = std::string::append(&v70, (const std::string::value_type *)v24, v25);
  v27 = *(_OWORD *)&v26->__r_.__value_.__l.__data_;
  v71.__r_.__value_.__r.__words[2] = v26->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v71.__r_.__value_.__l.__data_ = v27;
  v26->__r_.__value_.__l.__size_ = 0;
  v26->__r_.__value_.__r.__words[2] = 0;
  v26->__r_.__value_.__r.__words[0] = 0;
  v28 = std::string::append(&v71, "), (");
  v29 = *(_OWORD *)&v28->__r_.__value_.__l.__data_;
  v72.__r_.__value_.__r.__words[2] = v28->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v72.__r_.__value_.__l.__data_ = v29;
  v28->__r_.__value_.__l.__size_ = 0;
  v28->__r_.__value_.__r.__words[2] = 0;
  v28->__r_.__value_.__r.__words[0] = 0;
  (*(void (**)(void **__return_ptr))(**(_QWORD **)(*((_QWORD *)this + 1) + 56) + 32))(v51);
  if ((v52 & 0x80u) == 0)
    v30 = v51;
  else
    v30 = (void **)v51[0];
  if ((v52 & 0x80u) == 0)
    v31 = v52;
  else
    v31 = (std::string::size_type)v51[1];
  v32 = std::string::append(&v72, (const std::string::value_type *)v30, v31);
  v33 = *(_OWORD *)&v32->__r_.__value_.__l.__data_;
  v73.__r_.__value_.__r.__words[2] = v32->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v73.__r_.__value_.__l.__data_ = v33;
  v32->__r_.__value_.__l.__size_ = 0;
  v32->__r_.__value_.__r.__words[2] = 0;
  v32->__r_.__value_.__r.__words[0] = 0;
  v34 = std::string::append(&v73, "), (");
  v35 = *(_OWORD *)&v34->__r_.__value_.__l.__data_;
  v74.__r_.__value_.__r.__words[2] = v34->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v74.__r_.__value_.__l.__data_ = v35;
  v34->__r_.__value_.__l.__size_ = 0;
  v34->__r_.__value_.__r.__words[2] = 0;
  v34->__r_.__value_.__r.__words[0] = 0;
  (*(void (**)(void **__return_ptr))(**(_QWORD **)(*((_QWORD *)this + 1) + 64) + 32))(v49);
  if ((v50 & 0x80u) == 0)
    v36 = v49;
  else
    v36 = (void **)v49[0];
  if ((v50 & 0x80u) == 0)
    v37 = v50;
  else
    v37 = (std::string::size_type)v49[1];
  v38 = std::string::append(&v74, (const std::string::value_type *)v36, v37);
  v39 = *(_OWORD *)&v38->__r_.__value_.__l.__data_;
  v75.__r_.__value_.__r.__words[2] = v38->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v75.__r_.__value_.__l.__data_ = v39;
  v38->__r_.__value_.__l.__size_ = 0;
  v38->__r_.__value_.__r.__words[2] = 0;
  v38->__r_.__value_.__r.__words[0] = 0;
  v40 = std::string::append(&v75, "), (");
  v41 = *(_OWORD *)&v40->__r_.__value_.__l.__data_;
  v76.__r_.__value_.__r.__words[2] = v40->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v76.__r_.__value_.__l.__data_ = v41;
  v40->__r_.__value_.__l.__size_ = 0;
  v40->__r_.__value_.__r.__words[2] = 0;
  v40->__r_.__value_.__r.__words[0] = 0;
  (*(void (**)(void **__return_ptr))(**(_QWORD **)(*((_QWORD *)this + 1) + 72) + 32))(__p);
  if ((v48 & 0x80u) == 0)
    v42 = __p;
  else
    v42 = (void **)__p[0];
  if ((v48 & 0x80u) == 0)
    v43 = v48;
  else
    v43 = (std::string::size_type)__p[1];
  v44 = std::string::append(&v76, (const std::string::value_type *)v42, v43);
  v45 = *(_OWORD *)&v44->__r_.__value_.__l.__data_;
  v77.__r_.__value_.__r.__words[2] = v44->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v77.__r_.__value_.__l.__data_ = v45;
  v44->__r_.__value_.__l.__size_ = 0;
  v44->__r_.__value_.__r.__words[2] = 0;
  v44->__r_.__value_.__r.__words[0] = 0;
  v46 = std::string::append(&v77, ").");
  *a2 = *v46;
  v46->__r_.__value_.__l.__size_ = 0;
  v46->__r_.__value_.__r.__words[2] = 0;
  v46->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v77.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v77.__r_.__value_.__l.__data_);
  if ((char)v48 < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v76.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v76.__r_.__value_.__l.__data_);
  if (SHIBYTE(v75.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v75.__r_.__value_.__l.__data_);
  if ((char)v50 < 0)
    operator delete(v49[0]);
  if (SHIBYTE(v74.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v74.__r_.__value_.__l.__data_);
  if (SHIBYTE(v73.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v73.__r_.__value_.__l.__data_);
  if ((char)v52 < 0)
    operator delete(v51[0]);
  if (SHIBYTE(v72.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v72.__r_.__value_.__l.__data_);
  if (SHIBYTE(v71.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v71.__r_.__value_.__l.__data_);
  if ((char)v54 < 0)
    operator delete(v53[0]);
  if (SHIBYTE(v70.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v70.__r_.__value_.__l.__data_);
  if (SHIBYTE(v69.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v69.__r_.__value_.__l.__data_);
  if ((char)v56 < 0)
    operator delete(v55[0]);
  if (SHIBYTE(v68.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v68.__r_.__value_.__l.__data_);
  if (SHIBYTE(v67.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v67.__r_.__value_.__l.__data_);
  if ((char)v58 < 0)
    operator delete(v57[0]);
  if (SHIBYTE(v66.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v66.__r_.__value_.__l.__data_);
  if (SHIBYTE(v65.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v65.__r_.__value_.__l.__data_);
  if ((char)v60 < 0)
    operator delete(v59[0]);
  if (SHIBYTE(v64.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v64.__r_.__value_.__l.__data_);
  if (SHIBYTE(v63.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v63.__r_.__value_.__l.__data_);
  if (v62 < 0)
    operator delete(v61);
}

void sub_2254265D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,void *a46,uint64_t a47,int a48,__int16 a49,char a50,char a51,void *a52,uint64_t a53,int a54,__int16 a55,char a56,char a57,void *a58,uint64_t a59,int a60,__int16 a61,char a62,char a63)
{
  void *a64;
  char a69;
  void *a71;
  char a72;
  void *a73;
  char a74;
  void *a75;
  char a76;
  void *a77;
  char a78;
  void *a79;
  char a80;
  void *a81;
  char a82;
  void *a83;
  char a84;
  uint64_t v84;

  if (*(char *)(v84 - 57) < 0)
    operator delete(*(void **)(v84 - 80));
  if (a15 < 0)
    operator delete(__p);
  if (*(char *)(v84 - 89) < 0)
    operator delete(*(void **)(v84 - 112));
  if (*(char *)(v84 - 121) < 0)
    operator delete(*(void **)(v84 - 144));
  if (a21 < 0)
    operator delete(a16);
  if (*(char *)(v84 - 153) < 0)
    operator delete(*(void **)(v84 - 176));
  if (*(char *)(v84 - 185) < 0)
    operator delete(*(void **)(v84 - 208));
  if (a27 < 0)
    operator delete(a22);
  if (*(char *)(v84 - 217) < 0)
    operator delete(*(void **)(v84 - 240));
  if (a84 < 0)
    operator delete(a83);
  if (a33 < 0)
    operator delete(a28);
  if (a82 < 0)
    operator delete(a81);
  if (a80 < 0)
    operator delete(a79);
  if (a39 < 0)
    operator delete(a34);
  if (a78 < 0)
    operator delete(a77);
  if (a76 < 0)
    operator delete(a75);
  if (a45 < 0)
    operator delete(a40);
  if (a74 < 0)
    operator delete(a73);
  if (a72 < 0)
    operator delete(a71);
  if (a51 < 0)
    operator delete(a46);
  if (a69 < 0)
    operator delete(a64);
  if (a63 < 0)
    operator delete(a58);
  if (a57 < 0)
    operator delete(a52);
  _Unwind_Resume(a1);
}

void sub_225426794()
{
  JUMPOUT(0x2254266ACLL);
}

void sub_22542679C()
{
  JUMPOUT(0x2254266BCLL);
}

void sub_2254267A4()
{
  JUMPOUT(0x2254266CCLL);
}

void sub_2254267AC()
{
  JUMPOUT(0x2254266DCLL);
}

void sub_2254267B4()
{
  JUMPOUT(0x2254266ECLL);
}

void sub_2254267BC()
{
  JUMPOUT(0x2254266FCLL);
}

void sub_2254267C4()
{
  JUMPOUT(0x22542670CLL);
}

void sub_2254267CC()
{
  JUMPOUT(0x22542671CLL);
}

void sub_2254267D4()
{
  JUMPOUT(0x22542672CLL);
}

void sub_2254267DC()
{
  JUMPOUT(0x22542673CLL);
}

void sub_2254267E4()
{
  JUMPOUT(0x22542674CLL);
}

void sub_2254267EC()
{
  JUMPOUT(0x22542675CLL);
}

void sub_2254267F4()
{
  JUMPOUT(0x22542676CLL);
}

void sub_2254267FC()
{
  JUMPOUT(0x22542677CLL);
}

uint64_t re::AudioManager_PHASE_State_Recovering::stateType(re::AudioManager_PHASE_State_Recovering *this)
{
  return 1;
}

uint64_t re::AudioManager_PHASE_State_Recovering::getInitialRequiredRecoverySteps@<X0>(uint64_t **a1@<X8>)
{
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  char *v12;
  uint64_t *v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  char *v19;
  uint64_t *v20;
  char *v21;
  uint64_t *v22;
  char *v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  int64x2_t v27;
  uint64_t *v28;
  int64x2_t *v30;
  int64x2_t v31;
  char *v32;
  uint64_t v33;

  v3 = 0;
  a1[2] = 0;
  v4 = (uint64_t)(a1 + 2);
  *a1 = 0;
  a1[1] = 0;
  do
  {
    if (v3 - 5 < 5)
    {
      v5 = operator new();
      v31 = 0uLL;
      v30 = &v31;
      *(_DWORD *)(v5 + 8) = v3;
      *(_QWORD *)v5 = &off_24ED3DF78;
      std::set<unsigned long long>::set[abi:ne180100]((uint64_t *)(v5 + 16), (uint64_t)&v30);
      std::__tree<unsigned long long>::destroy((uint64_t)&v30, v31.i64[0]);
      v7 = a1[1];
      v13 = a1[2];
      if (v7 >= v13)
      {
        v15 = v7 - *a1;
        if ((unint64_t)(v15 + 1) >> 61)
          std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
        v16 = (char *)v13 - (char *)*a1;
        v17 = v16 >> 2;
        if (v16 >> 2 <= (unint64_t)(v15 + 1))
          v17 = v15 + 1;
        if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8)
          v18 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v18 = v17;
        v33 = v4;
        if (v18)
          v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>(v4, v18);
        else
          v19 = 0;
        v20 = (uint64_t *)&v19[8 * v15];
        v21 = &v19[8 * v18];
        v32 = v21;
        *v20 = v5;
        v14 = v20 + 1;
        v31.i64[1] = (uint64_t)(v20 + 1);
        v25 = (char *)*a1;
        v22 = a1[1];
        if (v22 != *a1)
        {
          do
          {
            v26 = *--v22;
            *v22 = 0;
            *--v20 = v26;
          }
          while (v22 != (uint64_t *)v25);
          goto LABEL_30;
        }
LABEL_31:
        v27 = vdupq_n_s64((unint64_t)v22);
        goto LABEL_32;
      }
    }
    else
    {
      if (v3 > 4)
        goto LABEL_34;
      v5 = operator new();
      *(_DWORD *)(v5 + 8) = v3;
      *(_QWORD *)v5 = &off_24ED3D5F0;
      *(_BYTE *)(v5 + 12) = 0;
      v7 = a1[1];
      v6 = a1[2];
      if (v7 >= v6)
      {
        v8 = v7 - *a1;
        if ((unint64_t)(v8 + 1) >> 61)
          std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
        v9 = (char *)v6 - (char *)*a1;
        v10 = v9 >> 2;
        if (v9 >> 2 <= (unint64_t)(v8 + 1))
          v10 = v8 + 1;
        if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8)
          v11 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v11 = v10;
        v33 = v4;
        if (v11)
          v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long long>>(v4, v11);
        else
          v12 = 0;
        v20 = (uint64_t *)&v12[8 * v8];
        v21 = &v12[8 * v11];
        v32 = v21;
        *v20 = v5;
        v14 = v20 + 1;
        v31.i64[1] = (uint64_t)(v20 + 1);
        v23 = (char *)*a1;
        v22 = a1[1];
        if (v22 != *a1)
        {
          do
          {
            v24 = *--v22;
            *v22 = 0;
            *--v20 = v24;
          }
          while (v22 != (uint64_t *)v23);
LABEL_30:
          v27 = *(int64x2_t *)a1;
          v14 = (uint64_t *)v31.i64[1];
          v21 = v32;
LABEL_32:
          *a1 = v20;
          a1[1] = v14;
          v31 = v27;
          v28 = a1[2];
          a1[2] = (uint64_t *)v21;
          v32 = (char *)v28;
          v30 = (int64x2_t *)v27.i64[0];
          std::__split_buffer<std::unique_ptr<re::AudioManager_PHASE_StateMachine_RecoveryStep>>::~__split_buffer((uint64_t)&v30);
          goto LABEL_33;
        }
        goto LABEL_31;
      }
    }
    *v7 = v5;
    v14 = v7 + 1;
LABEL_33:
    a1[1] = v14;
LABEL_34:
    ++v3;
  }
  while (v3 != 10);
  (*(void (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)**a1 + 16))(**a1, 0, 0);
  return (*(uint64_t (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)(*a1)[1] + 16))((*a1)[1], 0, 0);
}

void sub_225426AB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  std::vector<std::unique_ptr<re::AudioManager_PHASE_StateMachine_RecoveryStep>>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

re::REPHASESpatialMixerDefinitionCache *re::REPHASESpatialMixerDefinitionCache::REPHASESpatialMixerDefinitionCache(re::REPHASESpatialMixerDefinitionCache *this)
{
  id *v2;
  id v3;
  id v4;
  void *v5;
  void *v6;
  uint64_t v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;

  *(_DWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  v2 = (id *)((char *)this + 8);
  *((_QWORD *)this + 2) = 0;
  v3 = objc_alloc_init(MEMORY[0x24BDBCE40]);
  v4 = *v2;
  *v2 = v3;

  objc_msgSend(*v2, "setTotalCostLimit:", 50);
  v5 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BDE3298]), "initWithValue:minimum:maximum:identifier:", CFSTR("reverbSend"), 1.0, 0.0, 10.0);
  v6 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BDE3298]), "initWithValue:minimum:maximum:identifier:", CFSTR("directSend"), 1.0, 0.0, 1.0);
  v7 = objc_msgSend(objc_alloc(MEMORY[0x24BDE32E8]), "initWithFlags:", 7);
  v8 = (void *)*((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = v7;

  objc_msgSend(*((id *)this + 2), "entries");
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v9, "objectForKeyedSubscript:", *MEMORY[0x24BDE3320]);
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v10, "setSendLevelMetaParameterDefinition:", v5);

  objc_msgSend(*((id *)this + 2), "entries");
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v11, "objectForKeyedSubscript:", *MEMORY[0x24BDE3318]);
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v12, "setSendLevelMetaParameterDefinition:", v5);

  objc_msgSend(*((id *)this + 2), "entries");
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v13, "objectForKeyedSubscript:", *MEMORY[0x24BDE3310]);
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v14, "setSendLevelMetaParameterDefinition:", v6);

  return this;
}

void sub_225426CA4(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  v6 = v4;

  _Unwind_Resume(a1);
}

id re::REPHASESpatialMixerDefinitionCache::getOmniSpatialMixerDefinition(re::REPHASESpatialMixerDefinitionCache *this)
{
  void *v1;
  _QWORD *v2;
  uint64_t v3;
  _QWORD v5[3];
  _QWORD *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = &off_24ED3F6A0;
  v5[1] = this;
  v6 = v5;
  re::REPHASESpatialMixerDefinitionCache::getFromCacheOrCreateAndCache((uint64_t)this, CFSTR("Omnidirectional"), 0, (uint64_t)v5);
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  v2 = v6;
  if (v6 == v5)
  {
    v3 = 4;
    v2 = v5;
    goto LABEL_5;
  }
  if (v6)
  {
    v3 = 5;
LABEL_5:
    (*(void (**)(void))(*v2 + 8 * v3))();
  }
  return v1;
}

void sub_225426DB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v13;
  char *v15;
  uint64_t v16;

  v15 = a13;
  if (a13 == v13)
  {
    v16 = 4;
    v15 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

id re::REPHASESpatialMixerDefinitionCache::getFromCacheOrCreateAndCache(uint64_t a1, void *a2, unsigned int a3, uint64_t a4)
{
  id v7;
  void *v8;
  uint64_t v9;
  id v10;

  v7 = a2;
  objc_msgSend(*(id *)(a1 + 8), "objectForKey:", v7);
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  if (!v8)
  {
    v9 = *(_QWORD *)(a4 + 24);
    if (!v9)
      std::__throw_bad_function_call[abi:ne180100]();
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 48))(v9);
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    if (v8)
      objc_msgSend(*(id *)(a1 + 8), "setObject:forKey:cost:", v8, v7, a3);
  }
  v10 = v8;

  return v10;
}

void sub_225426E9C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

id re::REPHASESpatialMixerDefinitionCache::getHumanSpatialMixerDefinition(re::REPHASESpatialMixerDefinitionCache *this)
{
  void *v1;
  _QWORD *v2;
  uint64_t v3;
  _QWORD v5[3];
  _QWORD *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = &off_24ED3F730;
  v5[1] = this;
  v6 = v5;
  re::REPHASESpatialMixerDefinitionCache::getFromCacheOrCreateAndCache((uint64_t)this, CFSTR("Frequency Independent Human"), 0, (uint64_t)v5);
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  v2 = v6;
  if (v6 == v5)
  {
    v3 = 4;
    v2 = v5;
    goto LABEL_5;
  }
  if (v6)
  {
    v3 = 5;
LABEL_5:
    (*(void (**)(void))(*v2 + 8 * v3))();
  }
  return v1;
}

void sub_225426F64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v13;
  char *v15;
  uint64_t v16;

  v15 = a13;
  if (a13 == v13)
  {
    v16 = 4;
    v15 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

id re::REPHASESpatialMixerDefinitionCache::getSphericalSpatialMixerDefinition(re::REPHASESpatialMixerDefinitionCache *this, double a2, double a3)
{
  void *v4;
  _QWORD *v5;
  void *v6;
  _QWORD *v7;
  uint64_t v8;
  double v10;
  double v11;
  _BYTE v12[24];
  _BYTE *v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v10 = a3;
  v11 = a2;
  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("Spherical with radius %.2f and opening angle %.2f."), *(_QWORD *)&a2, *(_QWORD *)&a3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v5 = operator new(0x20uLL);
  *v5 = &off_24ED3F7B0;
  v5[1] = &v11;
  v5[2] = &v10;
  v5[3] = this;
  v13 = v5;
  re::REPHASESpatialMixerDefinitionCache::getFromCacheOrCreateAndCache((uint64_t)this, v4, 1u, (uint64_t)v12);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v7 = v13;
  if (v13 == v12)
  {
    v8 = 4;
    v7 = v12;
    goto LABEL_5;
  }
  if (v13)
  {
    v8 = 5;
LABEL_5:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }

  return v6;
}

void sub_225427094(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, char *a17)
{
  void *v17;
  char *v18;
  char *v20;
  uint64_t v21;

  v20 = a17;
  if (a17 == v18)
  {
    v21 = 4;
    v20 = &a14;
  }
  else
  {
    if (!a17)
      goto LABEL_6;
    v21 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v20 + 8 * v21))();
LABEL_6:

  _Unwind_Resume(a1);
}

id re::REPHASESpatialMixerDefinitionCache::getBeamSpatialMixerDefinition(re::REPHASESpatialMixerDefinitionCache *this, double a2)
{
  void *v3;
  void *v4;
  _QWORD *v5;
  uint64_t v6;
  double v8;
  _QWORD v9[3];
  _QWORD *v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v8 = a2;
  if (a2 <= 0.0)
  {
    re::REPHASESpatialMixerDefinitionCache::getOmniSpatialMixerDefinition(this);
    return (id)objc_claimAutoreleasedReturnValue();
  }
  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("Beam with focus: %.2f"), *(_QWORD *)&a2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v9[0] = &off_24ED3F830;
  v9[1] = this;
  v9[2] = &v8;
  v10 = v9;
  re::REPHASESpatialMixerDefinitionCache::getFromCacheOrCreateAndCache((uint64_t)this, v3, 1u, (uint64_t)v9);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v5 = v10;
  if (v10 == v9)
  {
    v6 = 4;
    v5 = v9;
    goto LABEL_7;
  }
  if (v10)
  {
    v6 = 5;
LABEL_7:
    (*(void (**)(void))(*v5 + 8 * v6))();
  }

  return v4;
}

void sub_2254271E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, char *a15)
{
  void *v15;
  char *v16;
  char *v18;
  uint64_t v19;

  v18 = a15;
  if (a15 == v16)
  {
    v19 = 4;
    v18 = &a12;
  }
  else
  {
    if (!a15)
      goto LABEL_6;
    v19 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v18 + 8 * v19))();
LABEL_6:

  _Unwind_Resume(a1);
}

id re::REPHASESpatialMixerDefinitionCache::getSpatialMixerDefinitionWithDirectivity(re::REPHASESpatialMixerDefinitionCache *this, PHASEDirectivityModelParameters *a2)
{
  PHASEDirectivityModelParameters *v3;
  void *v4;
  NSObject *v5;
  void *v6;
  int v8;
  void *v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v3 = a2;
  re::REPHASESpatialMixerDefinitionCache::createBaseSpatialMixerDefinition(this);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v5 = (id)*re::audioLogObjects((re *)objc_msgSend(v4, "setSourceDirectivityModelParameters:", v3));
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    objc_msgSend(v4, "sourceDirectivityModelParameters");
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    v8 = 138412290;
    v9 = v6;
    _os_log_impl(&dword_224FE9000, v5, OS_LOG_TYPE_INFO, "REPHASESpatialMixerDefinitionCache::getSpatialMixerDefinitionWithDirectivity returning a definition with the provided directivity: %@.", (uint8_t *)&v8, 0xCu);

  }
  return v4;
}

void sub_22542730C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

id re::REPHASESpatialMixerDefinitionCache::createBaseSpatialMixerDefinition(re::REPHASESpatialMixerDefinitionCache *this)
{
  void *v2;
  void *v3;
  id v4;

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("spatialMixer-%d"), *(unsigned int *)this);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v3 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BDE32E0]), "initWithSpatialPipeline:identifier:", *((_QWORD *)this + 2), v2);
  v4 = objc_alloc_init(MEMORY[0x24BDE3270]);
  objc_msgSend(v3, "setDistanceModelParameters:", v4);

  ++*(_DWORD *)this;
  return v3;
}

void sub_2254273DC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void std::__function::__func<re::REPHASESpatialMixerDefinitionCache::getOmniSpatialMixerDefinition(void)::$_0,std::allocator<re::REPHASESpatialMixerDefinitionCache::getOmniSpatialMixerDefinition(void)::$_0>,PHASESpatialMixerDefinition * ()(void)>::~__func()
{
  JUMPOUT(0x2276933B8);
}

_QWORD *std::__function::__func<re::REPHASESpatialMixerDefinitionCache::getOmniSpatialMixerDefinition(void)::$_0,std::allocator<re::REPHASESpatialMixerDefinitionCache::getOmniSpatialMixerDefinition(void)::$_0>,PHASESpatialMixerDefinition * ()(void)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24ED3F6A0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<re::REPHASESpatialMixerDefinitionCache::getOmniSpatialMixerDefinition(void)::$_0,std::allocator<re::REPHASESpatialMixerDefinitionCache::getOmniSpatialMixerDefinition(void)::$_0>,PHASESpatialMixerDefinition * ()(void)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24ED3F6A0;
  a2[1] = v2;
  return result;
}

id std::__function::__func<re::REPHASESpatialMixerDefinitionCache::getOmniSpatialMixerDefinition(void)::$_0,std::allocator<re::REPHASESpatialMixerDefinitionCache::getOmniSpatialMixerDefinition(void)::$_0>,PHASESpatialMixerDefinition * ()(void)>::operator()(uint64_t a1)
{
  void *v1;
  NSObject *v2;
  uint8_t v4[16];

  re::REPHASESpatialMixerDefinitionCache::createBaseSpatialMixerDefinition(*(re::REPHASESpatialMixerDefinitionCache **)(a1 + 8));
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  v2 = *re::audioLogObjects((re *)objc_msgSend(v1, "setSourceDirectivityModelParameters:", 0));
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)v4 = 0;
    _os_log_impl(&dword_224FE9000, v2, OS_LOG_TYPE_INFO, "REPHASESpatialMixerDefinitionCache::getOmniSpatialMixerDefinition created and cached a new omnidirectional spatial mixer definition.", v4, 2u);
  }
  return v1;
}

void sub_2254274E8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<re::REPHASESpatialMixerDefinitionCache::getOmniSpatialMixerDefinition(void)::$_0,std::allocator<re::REPHASESpatialMixerDefinitionCache::getOmniSpatialMixerDefinition(void)::$_0>,PHASESpatialMixerDefinition * ()(void)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::REPHASESpatialMixerDefinitionCache::getOmniSpatialMixerDefinition(void)::$_0,std::allocator<re::REPHASESpatialMixerDefinitionCache::getOmniSpatialMixerDefinition(void)::$_0>,PHASESpatialMixerDefinition * ()(void)>::target_type()
{
}

void std::__function::__func<re::REPHASESpatialMixerDefinitionCache::getHumanSpatialMixerDefinition(void)::$_0,std::allocator<re::REPHASESpatialMixerDefinitionCache::getHumanSpatialMixerDefinition(void)::$_0>,PHASESpatialMixerDefinition * ()(void)>::~__func()
{
  JUMPOUT(0x2276933B8);
}

_QWORD *std::__function::__func<re::REPHASESpatialMixerDefinitionCache::getHumanSpatialMixerDefinition(void)::$_0,std::allocator<re::REPHASESpatialMixerDefinitionCache::getHumanSpatialMixerDefinition(void)::$_0>,PHASESpatialMixerDefinition * ()(void)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24ED3F730;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<re::REPHASESpatialMixerDefinitionCache::getHumanSpatialMixerDefinition(void)::$_0,std::allocator<re::REPHASESpatialMixerDefinitionCache::getHumanSpatialMixerDefinition(void)::$_0>,PHASESpatialMixerDefinition * ()(void)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24ED3F730;
  a2[1] = v2;
  return result;
}

id std::__function::__func<re::REPHASESpatialMixerDefinitionCache::getHumanSpatialMixerDefinition(void)::$_0,std::allocator<re::REPHASESpatialMixerDefinitionCache::getHumanSpatialMixerDefinition(void)::$_0>,PHASESpatialMixerDefinition * ()(void)>::operator()(uint64_t a1)
{
  re::REPHASESpatialMixerDefinitionCache *v1;
  id v2;
  id v3;
  void *v4;
  void *v5;
  void *v6;
  NSObject *v7;
  void *v8;
  int v10;
  void *v11;
  _QWORD v12[2];

  v12[1] = *MEMORY[0x24BDAC8D0];
  v1 = *(re::REPHASESpatialMixerDefinitionCache **)(a1 + 8);
  v2 = objc_alloc_init(MEMORY[0x24BDE3240]);
  objc_msgSend(v2, "setPattern:", 1.0);
  v3 = objc_alloc(MEMORY[0x24BDE3238]);
  v12[0] = v2;
  objc_msgSend(MEMORY[0x24BDBCE30], "arrayWithObjects:count:", v12, 1);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v5 = (void *)objc_msgSend(v3, "initWithSubbandParameters:", v4);

  re::REPHASESpatialMixerDefinitionCache::createBaseSpatialMixerDefinition(v1);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v7 = (id)*re::audioLogObjects((re *)objc_msgSend(v6, "setSourceDirectivityModelParameters:", v5));
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    objc_msgSend(v6, "sourceDirectivityModelParameters");
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    v10 = 138412290;
    v11 = v8;
    _os_log_impl(&dword_224FE9000, v7, OS_LOG_TYPE_INFO, "REPHASESpatialMixerDefinitionCache::getHumanSpatialMixerDefinition created and cached a new frequency-independent human directivity %@.", (uint8_t *)&v10, 0xCu);

  }
  return v6;
}

void sub_2254276F0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  v5 = v4;

  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<re::REPHASESpatialMixerDefinitionCache::getHumanSpatialMixerDefinition(void)::$_0,std::allocator<re::REPHASESpatialMixerDefinitionCache::getHumanSpatialMixerDefinition(void)::$_0>,PHASESpatialMixerDefinition * ()(void)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::REPHASESpatialMixerDefinitionCache::getHumanSpatialMixerDefinition(void)::$_0,std::allocator<re::REPHASESpatialMixerDefinitionCache::getHumanSpatialMixerDefinition(void)::$_0>,PHASESpatialMixerDefinition * ()(void)>::target_type()
{
}

void std::__function::__func<re::REPHASESpatialMixerDefinitionCache::getSphericalSpatialMixerDefinition(double,double)::$_0,std::allocator<re::REPHASESpatialMixerDefinitionCache::getSphericalSpatialMixerDefinition(double,double)::$_0>,PHASESpatialMixerDefinition * ()(void)>::~__func()
{
  JUMPOUT(0x2276933B8);
}

__n128 std::__function::__func<re::REPHASESpatialMixerDefinitionCache::getSphericalSpatialMixerDefinition(double,double)::$_0,std::allocator<re::REPHASESpatialMixerDefinitionCache::getSphericalSpatialMixerDefinition(double,double)::$_0>,PHASESpatialMixerDefinition * ()(void)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &off_24ED3F7B0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<re::REPHASESpatialMixerDefinitionCache::getSphericalSpatialMixerDefinition(double,double)::$_0,std::allocator<re::REPHASESpatialMixerDefinitionCache::getSphericalSpatialMixerDefinition(double,double)::$_0>,PHASESpatialMixerDefinition * ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_24ED3F7B0;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

id std::__function::__func<re::REPHASESpatialMixerDefinitionCache::getSphericalSpatialMixerDefinition(double,double)::$_0,std::allocator<re::REPHASESpatialMixerDefinitionCache::getSphericalSpatialMixerDefinition(double,double)::$_0>,PHASESpatialMixerDefinition * ()(void)>::operator()(uint64_t a1)
{
  re::REPHASESpatialMixerDefinitionCache *v2;
  id v3;
  void *v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  int v9;
  uint64_t v10;
  __int16 v11;
  uint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v2 = *(re::REPHASESpatialMixerDefinitionCache **)(a1 + 24);
  v3 = objc_alloc_init(MEMORY[0x24BDE32F0]);
  objc_msgSend(v3, "setSphereRadius:", **(double **)(a1 + 8));
  objc_msgSend(v3, "setCapOpeningAngle:", **(double **)(a1 + 16));
  re::REPHASESpatialMixerDefinitionCache::createBaseSpatialMixerDefinition(v2);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v5 = *re::audioLogObjects((re *)objc_msgSend(v4, "setSourceDirectivityModelParameters:", v3));
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    v6 = **(_QWORD **)(a1 + 8);
    v7 = **(_QWORD **)(a1 + 16);
    v9 = 134218240;
    v10 = v6;
    v11 = 2048;
    v12 = v7;
    _os_log_impl(&dword_224FE9000, v5, OS_LOG_TYPE_INFO, "REPHASESpatialMixerDefinitionCache::getSphericalSpatialMixerDefinition created and cached a definition for radius %f and opening angle %f.", (uint8_t *)&v9, 0x16u);
  }

  return v4;
}

void sub_225427914(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

uint64_t std::__function::__func<re::REPHASESpatialMixerDefinitionCache::getSphericalSpatialMixerDefinition(double,double)::$_0,std::allocator<re::REPHASESpatialMixerDefinitionCache::getSphericalSpatialMixerDefinition(double,double)::$_0>,PHASESpatialMixerDefinition * ()(void)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::REPHASESpatialMixerDefinitionCache::getSphericalSpatialMixerDefinition(double,double)::$_0,std::allocator<re::REPHASESpatialMixerDefinitionCache::getSphericalSpatialMixerDefinition(double,double)::$_0>,PHASESpatialMixerDefinition * ()(void)>::target_type()
{
}

void std::__function::__func<re::REPHASESpatialMixerDefinitionCache::getBeamSpatialMixerDefinition(double)::$_0,std::allocator<re::REPHASESpatialMixerDefinitionCache::getBeamSpatialMixerDefinition(double)::$_0>,PHASESpatialMixerDefinition * ()(void)>::~__func()
{
  JUMPOUT(0x2276933B8);
}

__n128 std::__function::__func<re::REPHASESpatialMixerDefinitionCache::getBeamSpatialMixerDefinition(double)::$_0,std::allocator<re::REPHASESpatialMixerDefinitionCache::getBeamSpatialMixerDefinition(double)::$_0>,PHASESpatialMixerDefinition * ()(void)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_24ED3F830;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<re::REPHASESpatialMixerDefinitionCache::getBeamSpatialMixerDefinition(double)::$_0,std::allocator<re::REPHASESpatialMixerDefinitionCache::getBeamSpatialMixerDefinition(double)::$_0>,PHASESpatialMixerDefinition * ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_24ED3F830;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

id std::__function::__func<re::REPHASESpatialMixerDefinitionCache::getBeamSpatialMixerDefinition(double)::$_0,std::allocator<re::REPHASESpatialMixerDefinitionCache::getBeamSpatialMixerDefinition(double)::$_0>,PHASESpatialMixerDefinition * ()(void)>::operator()(uint64_t a1)
{
  void *v2;
  double v3;
  double v4;
  double v5;
  id v6;
  id v7;
  id v8;
  float v9;
  id v10;
  void *v11;
  void *v12;
  re *v13;
  NSObject *v14;
  uint64_t v15;
  __int128 v17;
  id v18;
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  re::REPHASESpatialMixerDefinitionCache::createBaseSpatialMixerDefinition(*(re::REPHASESpatialMixerDefinitionCache **)(a1 + 8));
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v3 = **(double **)(a1 + 16);
  v4 = 1.0;
  if (v3 <= 1.0)
    v4 = **(double **)(a1 + 16);
  if (v3 >= 0.0)
    v5 = v4;
  else
    v5 = 0.0;
  v6 = objc_alloc_init(MEMORY[0x24BDE3240]);
  objc_msgSend(v6, "setFrequency:", 250.0);
  objc_msgSend(v6, "setPattern:", v5 * 0.25);
  objc_msgSend(v6, "setSharpness:", 1.0);
  v7 = objc_alloc_init(MEMORY[0x24BDE3240]);
  objc_msgSend(v7, "setFrequency:", 1000.0);
  objc_msgSend(v7, "setPattern:", v5 * 0.5);
  objc_msgSend(v7, "setSharpness:", 1.0);
  v8 = objc_alloc_init(MEMORY[0x24BDE3240]);
  objc_msgSend(v8, "setFrequency:", 4000.0);
  if (v5 >= 0.5)
  {
    objc_msgSend(v8, "setPattern:");
    v9 = v5 + -0.5 + v5 + -0.5;
    objc_msgSend(v8, "setSharpness:", (float)((float)(1.0 - v9) + (float)(v9 * 10.0)));
  }
  else
  {
    objc_msgSend(v8, "setPattern:", v5);
    objc_msgSend(v8, "setSharpness:", 1.0);
  }
  v10 = objc_alloc(MEMORY[0x24BDE3238]);
  *(_QWORD *)&v17 = v6;
  *((_QWORD *)&v17 + 1) = v7;
  v18 = v8;
  objc_msgSend(MEMORY[0x24BDBCE30], "arrayWithObjects:count:", &v17, 3);
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  v12 = (void *)objc_msgSend(v10, "initWithSubbandParameters:", v11);

  objc_msgSend(v2, "setSourceDirectivityModelParameters:", v12);
  v14 = *re::audioLogObjects(v13);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
  {
    v15 = **(_QWORD **)(a1 + 16);
    LODWORD(v17) = 134217984;
    *(_QWORD *)((char *)&v17 + 4) = v15;
    _os_log_impl(&dword_224FE9000, v14, OS_LOG_TYPE_INFO, "REPHASESpatialMixerDefinitionCache::getBeamSpatialMixerDefinition created and cached a definition with focus %f.", (uint8_t *)&v17, 0xCu);
  }
  return v2;
}

void sub_225427C34(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<re::REPHASESpatialMixerDefinitionCache::getBeamSpatialMixerDefinition(double)::$_0,std::allocator<re::REPHASESpatialMixerDefinitionCache::getBeamSpatialMixerDefinition(double)::$_0>,PHASESpatialMixerDefinition * ()(void)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::REPHASESpatialMixerDefinitionCache::getBeamSpatialMixerDefinition(double)::$_0,std::allocator<re::REPHASESpatialMixerDefinitionCache::getBeamSpatialMixerDefinition(double)::$_0>,PHASESpatialMixerDefinition * ()(void)>::target_type()
{
}

_QWORD *std::shared_ptr<re::audio::REPHASEEntity>::shared_ptr[abi:ne180100]<re::audio::REPHASEEntity,void>(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24ED3F8B0;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  std::shared_ptr<re::audio::REPHASESoundPrepareState>::__enable_weak_this[abi:ne180100]<re::audio::REPHASESoundPrepareState,re::audio::REPHASESoundPrepareState,void>((uint64_t)a1, a2, (uint64_t)a2);
  return a1;
}

void sub_225427D50(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<re::audio::REPHASEEntity>::reset[abi:ne180100]((id **)va, 0);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<re::audio::REPHASEEntity *,std::shared_ptr<re::audio::REPHASEEntity>::__shared_ptr_default_delete<re::audio::REPHASEEntity,re::audio::REPHASEEntity>,std::allocator<re::audio::REPHASEEntity>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2276933B8);
}

id *std::__shared_ptr_pointer<re::audio::REPHASEEntity *,std::shared_ptr<re::audio::REPHASEEntity>::__shared_ptr_default_delete<re::audio::REPHASEEntity,re::audio::REPHASEEntity>,std::allocator<re::audio::REPHASEEntity>>::__on_zero_shared(uint64_t a1)
{
  id *result;

  result = *(id **)(a1 + 24);
  if (result)
  {
    re::audio::REPHASEEntity::~REPHASEEntity(result);
    JUMPOUT(0x2276933B8);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<re::audio::REPHASEEntity *,std::shared_ptr<re::audio::REPHASEEntity>::__shared_ptr_default_delete<re::audio::REPHASEEntity,re::audio::REPHASEEntity>,std::allocator<re::audio::REPHASEEntity>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void re::audio::REPHASEEntity::~REPHASEEntity(id *this)
{
  NSObject *v2;
  int v3;
  void *v4;
  void *v5;
  std::__shared_weak_count *v6;
  _DWORD v7[2];
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  if (*((int *)this + 28) <= 0)
  {
    objc_msgSend(this[2], "parent");
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v4, "removeChild:", this[2]);

    objc_msgSend(this[3], "parent");
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v5, "removeChild:", this[3]);

  }
  else
  {
    v2 = *re::audioLogObjects((re *)this);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      v3 = *((_DWORD *)this + 28);
      v7[0] = 67109120;
      v7[1] = v3;
      _os_log_impl(&dword_224FE9000, v2, OS_LOG_TYPE_DEFAULT, "REPHASEEntity: Cannot destroy source and occluder from the engine. soundCount(%d) is greater than 0", (uint8_t *)v7, 8u);
    }
  }

  v6 = (std::__shared_weak_count *)this[1];
  if (v6)
    std::__shared_weak_count::__release_weak(v6);
}

void sub_225427F14(_Unwind_Exception *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  _Unwind_Resume(a1);
}

id *std::unique_ptr<re::audio::REPHASEEntity>::reset[abi:ne180100](id **a1, id *a2)
{
  id *result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    re::audio::REPHASEEntity::~REPHASEEntity(result);
    JUMPOUT(0x2276933B8);
  }
  return result;
}

uint64_t re::AudioManager_PHASE_State_Ready::handleStateChangeEvent(re *a1, int a2)
{
  NSObject *v4;
  int v5;
  void **v6;
  void **v7;
  void **v8;
  void *__p[2];
  char v11;
  void *v12[2];
  char v13;
  uint8_t buf[4];
  void **v15;
  __int16 v16;
  void **v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  if ((a2 - 1) >= 9)
  {
    if (!a2)
      return 0x100000000;
  }
  else
  {
    v4 = (id)*re::audioLogObjects(a1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      (*(void (**)(void **__return_ptr, re *))(*(_QWORD *)a1 + 8))(v12, a1);
      v5 = v13;
      v6 = (void **)v12[0];
      re::nameForAudioManagerStateMachineEvent(a2, __p);
      v7 = v12;
      if (v5 < 0)
        v7 = v6;
      if (v11 >= 0)
        v8 = __p;
      else
        v8 = (void **)__p[0];
      *(_DWORD *)buf = 136315394;
      v15 = v7;
      v16 = 2080;
      v17 = v8;
      _os_log_impl(&dword_224FE9000, v4, OS_LOG_TYPE_DEFAULT, "[RE/MediaServices] [EngineStateChange] Invalid state change event. Current state : %s, event '%s'.", buf, 0x16u);
      if (v11 < 0)
        operator delete(__p[0]);
      if (v13 < 0)
        operator delete(v12[0]);
    }

  }
  return 0;
}

void sub_2254280A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  void *v17;

  if (a17 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

_QWORD *re::AudioManager_PHASE_State_Ready::stateDescription@<X0>(_QWORD *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "Ready");
}

uint64_t re::AudioManager_PHASE_State_Ready::stateType(re::AudioManager_PHASE_State_Ready *this)
{
  return 2;
}

void re::AudioManager_PHASE_State_Ready::~AudioManager_PHASE_State_Ready(re::AudioManager_PHASE_State_Ready *this)
{
  JUMPOUT(0x2276933B8);
}

void sub_2254282B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  void *v14;
  id *v15;
  void *v16;

  objc_destroyWeak(v15);
  objc_destroyWeak(&location);

  _Unwind_Resume(a1);
}

void sub_225428384(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_225428424(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_22542847C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  void *v9;
  void *v10;

  v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)REAudioManagerNotificationListener;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_225428678(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  v5 = v4;

  _Unwind_Resume(a1);
}

void sub_225428960(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  v5 = v4;

  _Unwind_Resume(a1);
}

void sub_225428C94(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  v5 = v4;

  _Unwind_Resume(a1);
}

void sub_225428E98(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t *re::audio::allocInfo_AudioSourceDirectivityConfiguration(re::audio *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&_MergedGlobals_122);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&_MergedGlobals_122))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_254105978, 0);
    *(uint64_t *)((char *)&qword_254105988 + 6) = 0;
    qword_254105988 = 0;
    qword_254105998 = 0;
    qword_2541059A0 = 0xFFFFFFFFLL;
    qword_254105978 = (uint64_t)&off_24ED7DAA8;
    qword_2541059A8 = (uint64_t)"AudioSourceDirectivityConfiguration";
    dword_2541059B0 = 0;
    xmmword_2541059B8 = 0u;
    unk_2541059C8 = 0u;
    xmmword_2541059D8 = 0u;
    qword_2541059E8 = 0;
    __cxa_guard_release(&_MergedGlobals_122);
  }
  return &qword_254105978;
}

void re::audio::initInfo_AudioSourceDirectivityConfiguration(re::audio *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  const re::IntrospectionBase *v7;
  void *v8;
  uint64_t v9;
  uint64_t *v10;
  const re::IntrospectionBase *v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t *v14;
  const re::IntrospectionBase *v15;
  void *v16;
  uint64_t v17;
  uint64_t *v18;
  const re::IntrospectionBase *v19;
  void *v20;
  uint64_t v21;
  __int128 v22;
  _QWORD v23[2];
  __int128 v24;

  v23[0] = 0xE5B34C3C52C3FC9ELL;
  v23[1] = "AudioSourceDirectivityConfiguration";
  re::StringID::destroyString((re::StringID *)v23);
  *((_OWORD *)this + 2) = v24;
  v4 = atomic_load((unsigned __int8 *)&qword_254105950);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_254105950);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      v8 = re::introspect_float((re *)1, v7);
      v9 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
      *(_DWORD *)v9 = 1;
      *(_QWORD *)(v9 + 8) = "directivityFocus";
      *(_QWORD *)(v9 + 16) = v8;
      *(_QWORD *)(v9 + 24) = 0;
      *(_QWORD *)(v9 + 32) = 0x400000001;
      *(_DWORD *)(v9 + 40) = 0;
      *(_QWORD *)(v9 + 48) = 0;
      *(_QWORD *)(v9 + 56) = 0;
      *(_DWORD *)(v9 + 64) = 0;
      qword_254105958 = v9;
      v10 = re::introspectionAllocator((re *)v9);
      v12 = introspect_REAudioSourceDirectivityMode(1, v11);
      v13 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v10 + 32))(v10, 72, 8);
      *(_DWORD *)v13 = 1;
      *(_QWORD *)(v13 + 8) = "sourceDirectivityMode";
      *(_QWORD *)(v13 + 16) = v12;
      *(_QWORD *)(v13 + 24) = 0;
      *(_QWORD *)(v13 + 32) = 2;
      *(_DWORD *)(v13 + 40) = 0;
      *(_QWORD *)(v13 + 48) = 0;
      *(_QWORD *)(v13 + 56) = 0;
      *(_DWORD *)(v13 + 64) = 0;
      qword_254105960 = v13;
      v14 = re::introspectionAllocator((re *)v13);
      v16 = re::introspect_float((re *)1, v15);
      v17 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v14 + 32))(v14, 72, 8);
      *(_DWORD *)v17 = 1;
      *(_QWORD *)(v17 + 8) = "sphericalCapDiameter";
      *(_QWORD *)(v17 + 16) = v16;
      *(_QWORD *)(v17 + 24) = 0;
      *(_QWORD *)(v17 + 32) = 0x800000003;
      *(_DWORD *)(v17 + 40) = 0;
      *(_QWORD *)(v17 + 48) = 0;
      *(_QWORD *)(v17 + 56) = 0;
      *(_DWORD *)(v17 + 64) = 0;
      qword_254105968 = v17;
      v18 = re::introspectionAllocator((re *)v17);
      v20 = re::introspect_float((re *)1, v19);
      v21 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v18 + 32))(v18, 72, 8);
      *(_DWORD *)v21 = 1;
      *(_QWORD *)(v21 + 8) = "sphericalCapOpeningAngle";
      *(_QWORD *)(v21 + 16) = v20;
      *(_QWORD *)(v21 + 24) = 0;
      *(_QWORD *)(v21 + 32) = 0xC00000004;
      *(_DWORD *)(v21 + 40) = 0;
      *(_QWORD *)(v21 + 48) = 0;
      *(_QWORD *)(v21 + 56) = 0;
      *(_DWORD *)(v21 + 64) = 0;
      qword_254105970 = v21;
      __cxa_guard_release(&qword_254105950);
    }
  }
  *((_QWORD *)this + 2) = 0x1000000008;
  *((_DWORD *)this + 6) = 4;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 4;
  *((_QWORD *)this + 8) = &qword_254105958;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::audio::AudioSourceDirectivityConfiguration>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::audio::AudioSourceDirectivityConfiguration>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::audio::AudioSourceDirectivityConfiguration>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::audio::AudioSourceDirectivityConfiguration>;
  re::IntrospectionRegistry::add(this, v3);
  v22 = v24;
}

void sub_22542924C(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&qword_254105950);
  _Unwind_Resume(a1);
}

double re::internal::defaultConstruct<re::audio::AudioSourceDirectivityConfiguration>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double result;

  *(_DWORD *)a3 = 1;
  result = 6.14672757e-10;
  *(_QWORD *)(a3 + 4) = 0x3E051EB800000000;
  *(_DWORD *)(a3 + 12) = 1106247680;
  return result;
}

double re::internal::defaultConstructV2<re::audio::AudioSourceDirectivityConfiguration>(uint64_t a1)
{
  double result;

  *(_DWORD *)a1 = 1;
  result = 6.14672757e-10;
  *(_QWORD *)(a1 + 4) = 0x3E051EB800000000;
  *(_DWORD *)(a1 + 12) = 1106247680;
  return result;
}

uint64_t re::audio::introspect_AudioSourceDirectivityConfiguration(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"AudioSourceDirectivityConfiguration", (uint64_t (*)(re::internal *))re::audio::allocInfo_AudioSourceDirectivityConfiguration, (re::IntrospectionBase *(*)(void))re::audio::initInfo_AudioSourceDirectivityConfiguration, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::audio::AudioSourceDirectivityConfiguration>, this);
}

void re::AudioManagerTelemetryReporter::initializeTimerWith(uint64_t a1, uint64_t a2, void *a3)
{
  id v5;
  NSObject *v6;
  id v7;
  _QWORD block[4];
  id v9;
  uint64_t v10;
  uint64_t v11;

  v5 = a3;
  v6 = re::AudioManagerTelemetryReporter::m_managerQueue;
  block[0] = MEMORY[0x24BDAC760];
  block[1] = 3221225472;
  block[2] = ___ZN2re29AudioManagerTelemetryReporter19initializeTimerWithEPNS_18AudioManager_PHASEEPU28objcproto17OS_dispatch_queue8NSObject_block_invoke;
  block[3] = &unk_24ED3EAE8;
  v10 = a1;
  v11 = a2;
  v9 = v5;
  v7 = v5;
  dispatch_async(v6, block);

}

void ___ZN2re29AudioManagerTelemetryReporter19initializeTimerWithEPNS_18AudioManager_PHASEEPU28objcproto17OS_dispatch_queue8NSObject_block_invoke(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  NSObject *v7;
  _QWORD v8[5];
  _QWORD v9[5];

  v2 = a1[5];
  *(_QWORD *)(v2 + 40) = a1[6];
  v3 = *(_QWORD *)(v2 + 32);
  v4 = MEMORY[0x24BDAC760];
  v5 = a1[4];
  v9[0] = MEMORY[0x24BDAC760];
  v9[1] = 3221225472;
  v9[2] = ___ZN2re29AudioManagerTelemetryReporter19initializeTimerWithEPNS_18AudioManager_PHASEEPU28objcproto17OS_dispatch_queue8NSObject_block_invoke_2;
  v9[3] = &__block_descriptor_40_e24__TelemetryReport____8__0l;
  v9[4] = v2;
  re::AudioTelemetryReporter::initializeTimerWith(v3, v5, v9, 600.0);
  v6 = *(_QWORD *)(v2 + 32);
  v7 = a1[4];
  v8[0] = v4;
  v8[1] = 3221225472;
  v8[2] = ___ZN2re29AudioManagerTelemetryReporter19initializeTimerWithEPNS_18AudioManager_PHASEEPU28objcproto17OS_dispatch_queue8NSObject_block_invoke_11;
  v8[3] = &__block_descriptor_40_e24__TelemetryReport____8__0l;
  v8[4] = v2;
  re::AudioTelemetryReporter::initializeTimerWith(v6, v7, v8, 300.0);
}

void sub_22542952C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  v3 = v2;

  _Unwind_Resume(a1);
}

void sub_225429A3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18, void *a19, void *a20,void *a21,void *a22)
{
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;

  _Unwind_Resume(a1);
}

void ___ZN2re29AudioManagerTelemetryReporter23mediaServicesResetEventEv_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  double v4;
  unint64_t v5;
  unint64_t v6;
  double v7;
  uint64_t v8;
  double v9;
  void *v10;
  const __CFString *v11;
  void *v12;
  mach_timebase_info v13;
  _QWORD v14[2];
  _QWORD v15[3];

  v15[2] = *MEMORY[0x24BDAC8D0];
  v1 = *(_QWORD *)(a1 + 32);
  v2 = mach_absolute_time();
  v3 = *(_QWORD *)(v1 + 16);
  v4 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&v13))
    {
      v7 = NAN;
      goto LABEL_6;
    }
    LODWORD(v5) = v13.numer;
    LODWORD(v6) = v13.denom;
    v4 = (double)v5 / (double)v6;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v4;
  }
  v7 = v4 * (double)(v2 - v3);
LABEL_6:
  v8 = mach_absolute_time();
  v9 = v7 / 1000000.0;
  *(float *)&v9 = v7 / 1000000.0;
  *(_QWORD *)v1 = v8;
  v14[0] = CFSTR("timeSinceLastReset");
  objc_msgSend(MEMORY[0x24BDD1518], "numberWithFloat:", v9);
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  v14[1] = CFSTR("resetType");
  v15[0] = v10;
  if (*(_BYTE *)(v1 + 8))
    v11 = CFSTR("mediaServicesReset");
  else
    v11 = CFSTR("deviceReboot");
  v15[1] = v11;
  objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v15, v14, 2);
  v12 = (void *)objc_claimAutoreleasedReturnValue();

  *(_BYTE *)(v1 + 8) = 1;
  re::AudioTelemetryReporter::sendTelemetryReport(*(NSObject ***)(v1 + 32), CFSTR("media_service_reset"), v12);
}

void sub_225429CC4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t re::AudioManagerTelemetryReporter::getInstance(re::AudioManagerTelemetryReporter *this)
{
  unsigned __int8 v1;
  id *v2;
  uint64_t result;
  NSObject *v4;
  NSObject *v5;

  v2 = (id *)&re::introspect_REStateCommandID(BOOL)::info;
  if ((v1 & 1) == 0
  {
    dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
    v4 = objc_claimAutoreleasedReturnValue();
    dispatch_queue_attr_make_with_qos_class(v4, QOS_CLASS_UTILITY, 0);
    v5 = objc_claimAutoreleasedReturnValue();
    re::AudioManagerTelemetryReporter::getInstance(void)::onceQueue = (uint64_t)dispatch_queue_create("AudioTelemetry", v5);

    v2 = (id *)&re::introspect_REStateCommandID(BOOL)::info;
  }
  objc_storeStrong((id *)&re::AudioManagerTelemetryReporter::m_managerQueue, v2[319]);
  result = re::AudioManagerTelemetryReporter::sharedReporter;
  if (!re::AudioManagerTelemetryReporter::sharedReporter)
  {
    dispatch_sync((dispatch_queue_t)re::AudioManagerTelemetryReporter::m_managerQueue, &__block_literal_global_8);
    return re::AudioManagerTelemetryReporter::sharedReporter;
  }
  return result;
}

uint64_t ___ZN2re29AudioManagerTelemetryReporter22reportSoundEventPlayedEv_block_invoke(uint64_t result)
{
  ++*(_DWORD *)(*(_QWORD *)(result + 32) + 48);
  return result;
}

void re::AudioManagerTelemetryReporter::addPreparedSourceState(uint64_t a1, uint64_t *a2)
{
  NSObject *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  _QWORD block[6];
  std::__shared_weak_count *v12;

  v3 = re::AudioManagerTelemetryReporter::m_managerQueue;
  block[0] = MEMORY[0x24BDAC760];
  block[1] = 3321888768;
  block[2] = ___ZN2re29AudioManagerTelemetryReporter22addPreparedSourceStateENSt3__110shared_ptrINS_5audio24REPHASESoundPrepareStateEEE_block_invoke;
  block[3] = &__block_descriptor_56_ea8_40c64_ZTSKNSt3__110shared_ptrIN2re5audio24REPHASESoundPrepareStateEEE_e5_v8__0l;
  v5 = *a2;
  v4 = (std::__shared_weak_count *)a2[1];
  block[4] = a1;
  block[5] = v5;
  v12 = v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  dispatch_async(v3, block);
  v8 = v12;
  if (v12)
  {
    v9 = (unint64_t *)&v12->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
}

uint64_t ___ZN2re29AudioManagerTelemetryReporter22addPreparedSourceStateENSt3__110shared_ptrINS_5audio24REPHASESoundPrepareStateEEE_block_invoke(uint64_t result)
{
  _DWORD *v1;
  uint64_t v2;
  int v3;

  v1 = *(_DWORD **)(result + 32);
  v2 = *(_QWORD *)(result + 40);
  ++v1[15];
  v3 = *(unsigned __int8 *)(v2 + 100);
  if (v3 == 2)
  {
    ++v1[18];
  }
  else if (v3 == 1)
  {
    ++v1[16];
  }
  else if (!*(_BYTE *)(v2 + 100))
  {
    ++v1[17];
    switch(*(_DWORD *)(v2 + 312))
    {
      case 0:
        ++v1[19];
        break;
      case 1:
        ++v1[21];
        break;
      case 2:
        ++v1[20];
        break;
      case 3:
        ++v1[22];
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t __copy_helper_block_ea8_40c64_ZTSKNSt3__110shared_ptrIN2re5audio24REPHASESoundPrepareStateEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_ea8_40c64_ZTSKNSt3__110shared_ptrIN2re5audio24REPHASESoundPrepareStateEEE(uint64_t a1)
{
  return std::shared_ptr<re::AssetManager>::~shared_ptr[abi:nn180100](a1 + 40);
}

uint64_t ___ZN2re29AudioManagerTelemetryReporter31updateCalibrationModeStatisticsE22REAudioCalibrationModed_block_invoke(uint64_t result)
{
  uint64_t v1;
  int v2;
  double v3;
  unsigned int v4;
  double v5;
  double v6;
  double v7;
  unsigned int v8;
  double v9;
  double v10;

  v1 = *(_QWORD *)(result + 32);
  v2 = *(_DWORD *)(result + 48);
  switch(v2)
  {
    case 2:
      v3 = *(double *)(v1 + 128);
      v4 = *(_DWORD *)(v1 + 100) + 1;
      *(double *)(v1 + 136) = *(double *)(v1 + 136) + (*(double *)(result + 40) - *(double *)(v1 + 136)) / (double)v4;
      *(_DWORD *)(v1 + 100) = v4;
      v5 = *(double *)(result + 40);
      if (v5 >= v3)
        v5 = v3;
      *(double *)(v1 + 128) = v5;
      v6 = *(double *)(result + 40);
      if (v6 <= *(double *)(v1 + 144))
        v6 = *(double *)(v1 + 144);
      *(double *)(v1 + 144) = v6;
      break;
    case 1:
      v7 = *(double *)(v1 + 104);
      v8 = *(_DWORD *)(v1 + 96) + 1;
      *(double *)(v1 + 112) = *(double *)(v1 + 112) + (*(double *)(result + 40) - *(double *)(v1 + 112)) / (double)v8;
      *(_DWORD *)(v1 + 96) = v8;
      v9 = *(double *)(result + 40);
      if (v9 >= v7)
        v9 = v7;
      *(double *)(v1 + 104) = v9;
      v10 = *(double *)(result + 40);
      if (v10 <= *(double *)(v1 + 120))
        v10 = *(double *)(v1 + 120);
      *(double *)(v1 + 120) = v10;
      break;
    case 0:
      ++*(_DWORD *)(v1 + 92);
      break;
  }
  return result;
}

uint64_t ___ZN2re29AudioManagerTelemetryReporter25updateConcurrentPlayCountEj_block_invoke(uint64_t result)
{
  uint64_t v1;
  unsigned int v2;

  v1 = *(_QWORD *)(result + 32);
  v2 = *(_DWORD *)(result + 40);
  if (v2 <= *(_DWORD *)(v1 + 52))
    v2 = *(_DWORD *)(v1 + 52);
  *(_DWORD *)(v1 + 52) = v2;
  return result;
}

uint64_t ___ZN2re29AudioManagerTelemetryReporter28updateConcurrentPrepareCountEj_block_invoke(uint64_t result)
{
  uint64_t v1;
  unsigned int v2;

  v1 = *(_QWORD *)(result + 32);
  v2 = *(_DWORD *)(result + 40);
  if (v2 <= *(_DWORD *)(v1 + 56))
    v2 = *(_DWORD *)(v1 + 56);
  *(_DWORD *)(v1 + 56) = v2;
  return result;
}

void REAudioServicesNotificationCallbackRegistry::registerCallback(uint64_t *a1, _OWORD *a2, void *a3)
{
  id v5;
  void *v6;
  _QWORD *v7;
  void *v8;
  _OWORD *v9;

  v5 = a3;
  v6 = _Block_copy(v5);
  v9 = a2;
  v7 = std::__hash_table<std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>,std::__unordered_map_hasher<REAudioServicesNotificationCallbackConfiguration,std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>,REAudioServicesNotificationCallbackRegistry::ConfigHasher,std::equal_to<REAudioServicesNotificationCallbackConfiguration>,true>,std::__unordered_map_equal<REAudioServicesNotificationCallbackConfiguration,std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>,std::equal_to<REAudioServicesNotificationCallbackConfiguration>,REAudioServicesNotificationCallbackRegistry::ConfigHasher,true>,std::allocator<std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>>>::__emplace_unique_key_args<REAudioServicesNotificationCallbackConfiguration,std::piecewise_construct_t const&,std::tuple<REAudioServicesNotificationCallbackConfiguration const&>,std::tuple<>>(a1, (unsigned __int8 *)a2, (uint64_t)&std::piecewise_construct, &v9);
  v8 = (void *)v7[4];
  v7[4] = v6;

}

void sub_22542A1F0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t *REAudioServicesNotificationCallbackRegistry::unregisterCallback(_QWORD *a1, unsigned __int8 *a2)
{
  uint64_t *result;

  result = (uint64_t *)std::__hash_table<std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>,std::__unordered_map_hasher<REAudioServicesNotificationCallbackConfiguration,std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>,REAudioServicesNotificationCallbackRegistry::ConfigHasher,std::equal_to<REAudioServicesNotificationCallbackConfiguration>,true>,std::__unordered_map_equal<REAudioServicesNotificationCallbackConfiguration,std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>,std::equal_to<REAudioServicesNotificationCallbackConfiguration>,REAudioServicesNotificationCallbackRegistry::ConfigHasher,true>,std::allocator<std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>>>::find<REAudioServicesNotificationCallbackConfiguration>(a1, a2);
  if (result)
    return (uint64_t *)std::__hash_table<std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>,std::__unordered_map_hasher<REAudioServicesNotificationCallbackConfiguration,std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>,REAudioServicesNotificationCallbackRegistry::ConfigHasher,std::equal_to<REAudioServicesNotificationCallbackConfiguration>,true>,std::__unordered_map_equal<REAudioServicesNotificationCallbackConfiguration,std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>,std::equal_to<REAudioServicesNotificationCallbackConfiguration>,REAudioServicesNotificationCallbackRegistry::ConfigHasher,true>,std::allocator<std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>>>::erase(a1, result);
  return result;
}

void REAudioServicesNotificationCallbackRegistry::getCallbacksForType(uint64_t a1@<X0>, int a2@<W1>, uint64_t **a3@<X8>)
{
  uint64_t **v3;
  uint64_t *v6;
  int v7;
  void *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t *v13;
  uint64_t *v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  char *v19;
  uint64_t *v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t *v23;
  void *v24;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  v3 = *(uint64_t ***)(a1 + 16);
  if (v3)
  {
    v6 = 0;
    do
    {
      v7 = *((unsigned __int8 *)v3 + 17);
      v8 = _Block_copy(v3[4]);
      v9 = v8;
      if (v7 == a2)
      {
        v10 = objc_msgSend(v8, "copy");
        v11 = v10;
        v12 = (unint64_t)a3[2];
        if ((unint64_t)v6 >= v12)
        {
          v14 = *a3;
          v15 = v6 - *a3;
          v16 = v15 + 1;
          if ((unint64_t)(v15 + 1) >> 61)
            std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
          v17 = v12 - (_QWORD)v14;
          if (v17 >> 2 > v16)
            v16 = v17 >> 2;
          if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8)
            v18 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v18 = v16;
          if (v18)
          {
            if (v18 >> 61)
              std::__throw_bad_array_new_length[abi:ne180100]();
            v19 = (char *)operator new(8 * v18);
          }
          else
          {
            v19 = 0;
          }
          v20 = (uint64_t *)&v19[8 * v15];
          v21 = (uint64_t *)&v19[8 * v18];
          *v20 = v11;
          v13 = v20 + 1;
          if (v6 == v14)
          {
            *a3 = v20;
            a3[1] = v13;
            a3[2] = v21;
          }
          else
          {
            do
            {
              v22 = *--v6;
              *v6 = 0;
              *--v20 = v22;
            }
            while (v6 != v14);
            v6 = *a3;
            v23 = a3[1];
            *a3 = v20;
            a3[1] = v13;
            a3[2] = v21;
            while (v23 != v6)
            {
              v24 = (void *)*--v23;

            }
          }
          if (v6)
            operator delete(v6);
        }
        else
        {
          *v6 = v10;
          v13 = v6 + 1;
        }
        a3[1] = v13;
        v6 = v13;
      }

      v3 = (uint64_t **)*v3;
    }
    while (v3);
  }
}

void sub_22542A3A8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  void *v3;
  va_list va;

  va_start(va, a2);

  std::vector<NSError * {__strong}>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

void std::__hash_table<std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>,std::__unordered_map_hasher<REAudioServicesNotificationCallbackConfiguration,std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>,REAudioServicesNotificationCallbackRegistry::ConfigHasher,std::equal_to<REAudioServicesNotificationCallbackConfiguration>,true>,std::__unordered_map_equal<REAudioServicesNotificationCallbackConfiguration,std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>,std::equal_to<REAudioServicesNotificationCallbackConfiguration>,REAudioServicesNotificationCallbackRegistry::ConfigHasher,true>,std::allocator<std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>>>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t i;

  if (*(_QWORD *)(a1 + 24))
  {
    std::__hash_table<std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>,std::__unordered_map_hasher<REAudioServicesNotificationCallbackConfiguration,std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>,REAudioServicesNotificationCallbackRegistry::ConfigHasher,std::equal_to<REAudioServicesNotificationCallbackConfiguration>,true>,std::__unordered_map_equal<REAudioServicesNotificationCallbackConfiguration,std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>,std::equal_to<REAudioServicesNotificationCallbackConfiguration>,REAudioServicesNotificationCallbackRegistry::ConfigHasher,true>,std::allocator<std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>>>::__deallocate_node(a1, *(id **)(a1 + 16));
    *(_QWORD *)(a1 + 16) = 0;
    v2 = *(_QWORD *)(a1 + 8);
    if (v2)
    {
      for (i = 0; i != v2; ++i)
        *(_QWORD *)(*(_QWORD *)a1 + 8 * i) = 0;
    }
    *(_QWORD *)(a1 + 24) = 0;
  }
}

_QWORD *std::__hash_table<std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>,std::__unordered_map_hasher<REAudioServicesNotificationCallbackConfiguration,std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>,REAudioServicesNotificationCallbackRegistry::ConfigHasher,std::equal_to<REAudioServicesNotificationCallbackConfiguration>,true>,std::__unordered_map_equal<REAudioServicesNotificationCallbackConfiguration,std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>,std::equal_to<REAudioServicesNotificationCallbackConfiguration>,REAudioServicesNotificationCallbackRegistry::ConfigHasher,true>,std::allocator<std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>>>::__emplace_unique_key_args<REAudioServicesNotificationCallbackConfiguration,std::piecewise_construct_t const&,std::tuple<REAudioServicesNotificationCallbackConfiguration const&>,std::tuple<>>(uint64_t *a1, unsigned __int8 *a2, uint64_t a3, _OWORD **a4)
{
  uint64_t v4;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint8x8_t v11;
  void **v12;
  _QWORD *v13;
  unint64_t v14;
  _QWORD *v15;
  float v16;
  float v17;
  _BOOL8 v18;
  unint64_t v19;
  unint64_t v20;
  int8x8_t prime;
  void *v22;
  void *v23;
  uint64_t v24;
  _QWORD *v25;
  unint64_t v26;
  uint8x8_t v27;
  unint64_t v28;
  uint8x8_t v29;
  uint64_t v30;
  _QWORD *v31;
  unint64_t v32;
  uint64_t v33;
  _QWORD *v34;
  unint64_t v35;
  void *v37;

  v7 = *a2;
  v8 = *((_QWORD *)a2 + 1);
  v9 = (4 * a2[1]) | (2 * v7) | (8 * v8);
  v10 = a1[1];
  if (v10)
  {
    v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      v4 = (4 * a2[1]) | (2 * v7) | (8 * v8);
      if (v9 >= v10)
        v4 = v9 % v10;
    }
    else
    {
      v4 = v9 & (v10 - 1);
    }
    v12 = *(void ***)(*a1 + 8 * v4);
    if (v12)
    {
      v13 = *v12;
      if (*v12)
      {
        do
        {
          v14 = v13[1];
          if (v14 == v9)
          {
            if (__PAIR64__(*((unsigned __int8 *)v13 + 17), *((unsigned __int8 *)v13 + 16)) == __PAIR64__(a2[1], v7)
              && v13[3] == v8)
            {
              return v13;
            }
          }
          else
          {
            if (v11.u32[0] > 1uLL)
            {
              if (v14 >= v10)
                v14 %= v10;
            }
            else
            {
              v14 &= v10 - 1;
            }
            if (v14 != v4)
              break;
          }
          v13 = (_QWORD *)*v13;
        }
        while (v13);
      }
    }
  }
  v15 = a1 + 2;
  v13 = operator new(0x28uLL);
  *v13 = 0;
  v13[1] = v9;
  *((_OWORD *)v13 + 1) = **a4;
  v13[4] = 0;
  v16 = (float)(unint64_t)(a1[3] + 1);
  v17 = *((float *)a1 + 8);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    v18 = 1;
    if (v10 >= 3)
      v18 = (v10 & (v10 - 1)) != 0;
    v19 = v18 | (2 * v10);
    v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20)
      prime = (int8x8_t)v20;
    else
      prime = (int8x8_t)v19;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
      v10 = a1[1];
    }
    if (*(_QWORD *)&prime > v10)
      goto LABEL_31;
    if (*(_QWORD *)&prime < v10)
    {
      v28 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
      if (v10 < 3 || (v29 = (uint8x8_t)vcnt_s8((int8x8_t)v10), v29.i16[0] = vaddlv_u8(v29), v29.u32[0] > 1uLL))
      {
        v28 = std::__next_prime(v28);
      }
      else
      {
        v30 = 1 << -(char)__clz(v28 - 1);
        if (v28 >= 2)
          v28 = v30;
      }
      if (*(_QWORD *)&prime <= v28)
        prime = (int8x8_t)v28;
      if (*(_QWORD *)&prime >= v10)
      {
        v10 = a1[1];
      }
      else
      {
        if (prime)
        {
LABEL_31:
          if (*(_QWORD *)&prime >> 61)
            std::__throw_bad_array_new_length[abi:ne180100]();
          v22 = operator new(8 * *(_QWORD *)&prime);
          v23 = (void *)*a1;
          *a1 = (uint64_t)v22;
          if (v23)
            operator delete(v23);
          v24 = 0;
          a1[1] = (uint64_t)prime;
          do
            *(_QWORD *)(*a1 + 8 * v24++) = 0;
          while (*(_QWORD *)&prime != v24);
          v25 = (_QWORD *)*v15;
          if (*v15)
          {
            v26 = v25[1];
            v27 = (uint8x8_t)vcnt_s8(prime);
            v27.i16[0] = vaddlv_u8(v27);
            if (v27.u32[0] > 1uLL)
            {
              if (v26 >= *(_QWORD *)&prime)
                v26 %= *(_QWORD *)&prime;
            }
            else
            {
              v26 &= *(_QWORD *)&prime - 1;
            }
            *(_QWORD *)(*a1 + 8 * v26) = v15;
            v31 = (_QWORD *)*v25;
            if (*v25)
            {
              do
              {
                v32 = v31[1];
                if (v27.u32[0] > 1uLL)
                {
                  if (v32 >= *(_QWORD *)&prime)
                    v32 %= *(_QWORD *)&prime;
                }
                else
                {
                  v32 &= *(_QWORD *)&prime - 1;
                }
                if (v32 != v26)
                {
                  if (!*(_QWORD *)(*a1 + 8 * v32))
                  {
                    *(_QWORD *)(*a1 + 8 * v32) = v25;
                    goto LABEL_56;
                  }
                  *v25 = *v31;
                  *v31 = **(_QWORD **)(*a1 + 8 * v32);
                  **(_QWORD **)(*a1 + 8 * v32) = v31;
                  v31 = v25;
                }
                v32 = v26;
LABEL_56:
                v25 = v31;
                v31 = (_QWORD *)*v31;
                v26 = v32;
              }
              while (v31);
            }
          }
          v10 = (unint64_t)prime;
          goto LABEL_60;
        }
        v37 = (void *)*a1;
        *a1 = 0;
        if (v37)
          operator delete(v37);
        v10 = 0;
        a1[1] = 0;
      }
    }
LABEL_60:
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10)
        v4 = v9 % v10;
      else
        v4 = v9;
    }
    else
    {
      v4 = (v10 - 1) & v9;
    }
  }
  v33 = *a1;
  v34 = *(_QWORD **)(*a1 + 8 * v4);
  if (v34)
  {
    *v13 = *v34;
LABEL_73:
    *v34 = v13;
    goto LABEL_74;
  }
  *v13 = *v15;
  *v15 = v13;
  *(_QWORD *)(v33 + 8 * v4) = v15;
  if (*v13)
  {
    v35 = *(_QWORD *)(*v13 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v35 >= v10)
        v35 %= v10;
    }
    else
    {
      v35 &= v10 - 1;
    }
    v34 = (_QWORD *)(*a1 + 8 * v35);
    goto LABEL_73;
  }
LABEL_74:
  ++a1[3];
  return v13;
}

void sub_22542A844(_Unwind_Exception *a1)
{
  id *v1;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>,void *>>>::operator()[abi:ne180100](1, v1);
  _Unwind_Resume(a1);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>,void *>>>::operator()[abi:ne180100](char a1, id *a2)
{
  if (a1)
  {

  }
  else if (!a2)
  {
    return;
  }
  operator delete(a2);
}

uint64_t **std::__hash_table<std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>,std::__unordered_map_hasher<REAudioServicesNotificationCallbackConfiguration,std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>,REAudioServicesNotificationCallbackRegistry::ConfigHasher,std::equal_to<REAudioServicesNotificationCallbackConfiguration>,true>,std::__unordered_map_equal<REAudioServicesNotificationCallbackConfiguration,std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>,std::equal_to<REAudioServicesNotificationCallbackConfiguration>,REAudioServicesNotificationCallbackRegistry::ConfigHasher,true>,std::allocator<std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>>>::find<REAudioServicesNotificationCallbackConfiguration>(_QWORD *a1, unsigned __int8 *a2)
{
  int8x8_t v2;
  uint64_t v3;
  uint64_t *v4;
  unint64_t v5;
  uint8x8_t v6;
  uint64_t v7;
  uint64_t ***v8;
  uint64_t **result;
  unint64_t v10;

  v2 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v2)
    return 0;
  v3 = *a2;
  v4 = (uint64_t *)*((_QWORD *)a2 + 1);
  v5 = (4 * a2[1]) | (2 * v3) | (8 * (_QWORD)v4);
  v6 = (uint8x8_t)vcnt_s8(v2);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    v7 = (4 * a2[1]) | (2 * v3) | (8 * (_QWORD)v4);
    if (v5 >= *(_QWORD *)&v2)
      v7 = v5 % *(_QWORD *)&v2;
  }
  else
  {
    v7 = v5 & (*(_QWORD *)&v2 - 1);
  }
  v8 = *(uint64_t ****)(*a1 + 8 * v7);
  if (!v8)
    return 0;
  for (result = *v8; result; result = (uint64_t **)*result)
  {
    v10 = (unint64_t)result[1];
    if (v10 == v5)
    {
      if (__PAIR64__(*((unsigned __int8 *)result + 17), *((unsigned __int8 *)result + 16)) == __PAIR64__(a2[1], v3)
        && result[3] == v4)
      {
        return result;
      }
    }
    else
    {
      if (v6.u32[0] > 1uLL)
      {
        if (v10 >= *(_QWORD *)&v2)
          v10 %= *(_QWORD *)&v2;
      }
      else
      {
        v10 &= *(_QWORD *)&v2 - 1;
      }
      if (v10 != v7)
        return 0;
    }
  }
  return result;
}

uint64_t std::__hash_table<std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>,std::__unordered_map_hasher<REAudioServicesNotificationCallbackConfiguration,std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>,REAudioServicesNotificationCallbackRegistry::ConfigHasher,std::equal_to<REAudioServicesNotificationCallbackConfiguration>,true>,std::__unordered_map_equal<REAudioServicesNotificationCallbackConfiguration,std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>,std::equal_to<REAudioServicesNotificationCallbackConfiguration>,REAudioServicesNotificationCallbackRegistry::ConfigHasher,true>,std::allocator<std::__hash_value_type<REAudioServicesNotificationCallbackConfiguration,void({block_pointer} {__strong})(void)>>>::erase(_QWORD *a1, uint64_t *a2)
{
  uint64_t v2;
  id *v3;
  void *__p;
  char v6;

  v2 = *a2;
  std::__hash_table<std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::PeerIDValidator::Entry>>>::remove(a1, a2, (uint64_t)&__p);
  v3 = (id *)__p;
  __p = 0;
  if (v3)
  {
    if (v6)

    operator delete(v3);
  }
  return v2;
}

void sub_22542AA00(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t *re::allocInfo_AudioSourceSyncState(re *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&_MergedGlobals_123);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&_MergedGlobals_123))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_254105A10, 0);
    *(uint64_t *)((char *)&qword_254105A20 + 6) = 0;
    qword_254105A20 = 0;
    qword_254105A30 = 0;
    qword_254105A38 = 0xFFFFFFFFLL;
    qword_254105A10 = (uint64_t)&off_24ED7DAA8;
    qword_254105A40 = (uint64_t)"AudioSourceSyncState";
    dword_254105A48 = 0;
    xmmword_254105A50 = 0u;
    unk_254105A60 = 0u;
    xmmword_254105A70 = 0u;
    qword_254105A80 = 0;
    __cxa_guard_release(&_MergedGlobals_123);
  }
  return &qword_254105A10;
}

void re::initInfo_AudioSourceSyncState(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  const re::IntrospectionBase *v7;
  void *v8;
  uint64_t v9;
  uint64_t *v10;
  const re::IntrospectionBase *v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t *v14;
  const re::IntrospectionBase *v15;
  void *v16;
  uint64_t v17;
  uint64_t *v18;
  const re::IntrospectionBase *v19;
  void *v20;
  uint64_t v21;
  uint64_t *v22;
  const re::IntrospectionBase *v23;
  void *v24;
  uint64_t v25;
  uint64_t *v26;
  const re::IntrospectionBase *v27;
  void *v28;
  uint64_t v29;
  uint64_t *v30;
  const re::IntrospectionBase *v31;
  void *v32;
  uint64_t v33;
  uint64_t *v34;
  const re::IntrospectionBase *v35;
  void *v36;
  uint64_t v37;
  uint64_t *v38;
  const re::IntrospectionBase *v39;
  void *v40;
  uint64_t v41;
  uint64_t *v42;
  const re::IntrospectionBase *v43;
  void *v44;
  uint64_t v45;
  uint64_t *v46;
  const re::IntrospectionBase *v47;
  void *v48;
  uint64_t v49;
  uint64_t *v50;
  const re::IntrospectionBase *v51;
  void *v52;
  uint64_t v53;
  uint64_t *v54;
  const re::IntrospectionBase *v55;
  void *v56;
  uint64_t v57;
  uint64_t *v58;
  const re::IntrospectionBase *v59;
  void *v60;
  uint64_t v61;
  uint64_t *v62;
  const re::IntrospectionBase *v63;
  void *v64;
  uint64_t v65;
  uint64_t *v66;
  const re::IntrospectionBase *v67;
  uint64_t *v68;
  uint64_t v69;
  uint64_t *v70;
  const re::IntrospectionBase *v71;
  void *v72;
  uint64_t v73;
  uint64_t *v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t *v77;
  const re::IntrospectionBase *v78;
  void *v79;
  uint64_t v80;
  uint64_t *v81;
  const re::IntrospectionBase *v82;
  void *v83;
  uint64_t v84;
  __int128 v85;
  _QWORD v86[2];
  __int128 v87;

  v86[0] = 0x66DEFDF30BAE648ALL;
  v86[1] = "AudioSourceSyncState";
  re::StringID::destroyString((re::StringID *)v86);
  *((_OWORD *)this + 2) = v87;
  v4 = atomic_load((unsigned __int8 *)&qword_2541059F8);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_2541059F8);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      v8 = re::introspect_AssetHandle((re *)1, v7);
      v9 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
      *(_DWORD *)v9 = 1;
      *(_QWORD *)(v9 + 8) = "asset";
      *(_QWORD *)(v9 + 16) = v8;
      *(_QWORD *)(v9 + 24) = 0;
      *(_QWORD *)(v9 + 32) = 0x800000001;
      *(_DWORD *)(v9 + 40) = 0;
      *(_QWORD *)(v9 + 48) = 0;
      *(_QWORD *)(v9 + 56) = 0;
      *(_DWORD *)(v9 + 64) = 0;
      qword_254105A88 = v9;
      v10 = re::introspectionAllocator((re *)v9);
      v12 = introspect_REAudioPlaybackState(1, v11);
      v13 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v10 + 32))(v10, 72, 8);
      *(_DWORD *)v13 = 1;
      *(_QWORD *)(v13 + 8) = "playbackState";
      *(_QWORD *)(v13 + 16) = v12;
      *(_QWORD *)(v13 + 24) = 0;
      *(_QWORD *)(v13 + 32) = 0x2000000003;
      *(_DWORD *)(v13 + 40) = 0;
      *(_QWORD *)(v13 + 48) = 0;
      *(_QWORD *)(v13 + 56) = 0;
      *(_DWORD *)(v13 + 64) = 0;
      qword_254105A90 = v13;
      v14 = re::introspectionAllocator((re *)v13);
      v16 = re::introspect_float((re *)1, v15);
      v17 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v14 + 32))(v14, 72, 8);
      *(_DWORD *)v17 = 1;
      *(_QWORD *)(v17 + 8) = "playbackSpeed";
      *(_QWORD *)(v17 + 16) = v16;
      *(_QWORD *)(v17 + 24) = 0;
      *(_QWORD *)(v17 + 32) = 0x2800000004;
      *(_DWORD *)(v17 + 40) = 0;
      *(_QWORD *)(v17 + 48) = 0;
      *(_QWORD *)(v17 + 56) = 0;
      *(_DWORD *)(v17 + 64) = 0;
      qword_254105A98 = v17;
      v18 = re::introspectionAllocator((re *)v17);
      v20 = re::introspect_float((re *)1, v19);
      v21 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v18 + 32))(v18, 72, 8);
      *(_DWORD *)v21 = 1;
      *(_QWORD *)(v21 + 8) = "reverbSendLevel";
      *(_QWORD *)(v21 + 16) = v20;
      *(_QWORD *)(v21 + 24) = 0;
      *(_QWORD *)(v21 + 32) = 0x3800000005;
      *(_DWORD *)(v21 + 40) = 0;
      *(_QWORD *)(v21 + 48) = 0;
      *(_QWORD *)(v21 + 56) = 0;
      *(_DWORD *)(v21 + 64) = 0;
      qword_254105AA0 = v21;
      v22 = re::introspectionAllocator((re *)v21);
      v24 = re::introspect_float((re *)1, v23);
      v25 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v22 + 32))(v22, 72, 8);
      *(_DWORD *)v25 = 1;
      *(_QWORD *)(v25 + 8) = "currentGain";
      *(_QWORD *)(v25 + 16) = v24;
      *(_QWORD *)(v25 + 24) = 0;
      *(_QWORD *)(v25 + 32) = 0x5000000006;
      *(_DWORD *)(v25 + 40) = 0;
      *(_QWORD *)(v25 + 48) = 0;
      *(_QWORD *)(v25 + 56) = 0;
      *(_DWORD *)(v25 + 64) = 0;
      qword_254105AA8 = v25;
      v26 = re::introspectionAllocator((re *)v25);
      v28 = re::introspect_float((re *)1, v27);
      v29 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v26 + 32))(v26, 72, 8);
      *(_DWORD *)v29 = 1;
      *(_QWORD *)(v29 + 8) = "targetGain";
      *(_QWORD *)(v29 + 16) = v28;
      *(_QWORD *)(v29 + 24) = 0;
      *(_QWORD *)(v29 + 32) = 0x5400000007;
      *(_DWORD *)(v29 + 40) = 0;
      *(_QWORD *)(v29 + 48) = 0;
      *(_QWORD *)(v29 + 56) = 0;
      *(_DWORD *)(v29 + 64) = 0;
      qword_254105AB0 = v29;
      v30 = re::introspectionAllocator((re *)v29);
      v32 = re::introspect_double((re *)1, v31);
      v33 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v30 + 32))(v30, 72, 8);
      *(_DWORD *)v33 = 1;
      *(_QWORD *)(v33 + 8) = "fadeDuration";
      *(_QWORD *)(v33 + 16) = v32;
      *(_QWORD *)(v33 + 24) = 0;
      *(_QWORD *)(v33 + 32) = 0x6000000008;
      *(_DWORD *)(v33 + 40) = 0;
      *(_QWORD *)(v33 + 48) = 0;
      *(_QWORD *)(v33 + 56) = 0;
      *(_DWORD *)(v33 + 64) = 0;
      qword_254105AB8 = v33;
      v34 = re::introspectionAllocator((re *)v33);
      v36 = re::introspect_uint64_t((re *)1, v35);
      v37 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v34 + 32))(v34, 72, 8);
      *(_DWORD *)v37 = 1;
      *(_QWORD *)(v37 + 8) = "version";
      *(_QWORD *)(v37 + 16) = v36;
      *(_QWORD *)(v37 + 24) = 0;
      *(_QWORD *)(v37 + 32) = 11;
      *(_DWORD *)(v37 + 40) = 0;
      *(_QWORD *)(v37 + 48) = 0;
      *(_QWORD *)(v37 + 56) = 0;
      *(_DWORD *)(v37 + 64) = 0;
      qword_254105AC0 = v37;
      v38 = re::introspectionAllocator((re *)v37);
      v40 = re::introspect_uint64_t((re *)1, v39);
      v41 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v38 + 32))(v38, 72, 8);
      *(_DWORD *)v41 = 1;
      *(_QWORD *)(v41 + 8) = "timebaseID";
      *(_QWORD *)(v41 + 16) = v40;
      *(_QWORD *)(v41 + 24) = 0;
      *(_QWORD *)(v41 + 32) = 0x300000000CLL;
      *(_DWORD *)(v41 + 40) = 0;
      *(_QWORD *)(v41 + 48) = 0;
      *(_QWORD *)(v41 + 56) = 0;
      *(_DWORD *)(v41 + 64) = 0;
      qword_254105AC8 = v41;
      v42 = re::introspectionAllocator((re *)v41);
      v44 = re::introspect_uint64_t((re *)1, v43);
      v45 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v42 + 32))(v42, 72, 8);
      *(_DWORD *)v45 = 1;
      *(_QWORD *)(v45 + 8) = "firstHalfExternalStreamUUID";
      *(_QWORD *)(v45 + 16) = v44;
      *(_QWORD *)(v45 + 24) = 0;
      *(_QWORD *)(v45 + 32) = 0xD00000000FLL;
      *(_DWORD *)(v45 + 40) = 0;
      *(_QWORD *)(v45 + 48) = 0;
      *(_QWORD *)(v45 + 56) = 0;
      *(_DWORD *)(v45 + 64) = 0;
      qword_254105AD0 = v45;
      v46 = re::introspectionAllocator((re *)v45);
      v48 = re::introspect_uint64_t((re *)1, v47);
      v49 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v46 + 32))(v46, 72, 8);
      *(_DWORD *)v49 = 1;
      *(_QWORD *)(v49 + 8) = "secondHalfExternalStreamUUID";
      *(_QWORD *)(v49 + 16) = v48;
      *(_QWORD *)(v49 + 24) = 0;
      *(_QWORD *)(v49 + 32) = 0xD800000010;
      *(_DWORD *)(v49 + 40) = 0;
      *(_QWORD *)(v49 + 48) = 0;
      *(_QWORD *)(v49 + 56) = 0;
      *(_DWORD *)(v49 + 64) = 0;
      qword_254105AD8 = v49;
      v50 = re::introspectionAllocator((re *)v49);
      v52 = re::introspect_float((re *)1, v51);
      v53 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v50 + 32))(v50, 72, 8);
      *(_DWORD *)v53 = 1;
      *(_QWORD *)(v53 + 8) = "directSendLevel";
      *(_QWORD *)(v53 + 16) = v52;
      *(_QWORD *)(v53 + 24) = 0;
      *(_QWORD *)(v53 + 32) = 0x4800000012;
      *(_DWORD *)(v53 + 40) = 0;
      *(_QWORD *)(v53 + 48) = 0;
      *(_QWORD *)(v53 + 56) = 0;
      *(_DWORD *)(v53 + 64) = 0;
      qword_254105AE0 = v53;
      v54 = re::introspectionAllocator((re *)v53);
      v56 = re::IntrospectionInfo<re::DynamicString>::get(1, v55);
      v57 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v54 + 32))(v54, 72, 8);
      *(_DWORD *)v57 = 1;
      *(_QWORD *)(v57 + 8) = "stsLabel";
      *(_QWORD *)(v57 + 16) = v56;
      *(_QWORD *)(v57 + 24) = 0;
      *(_QWORD *)(v57 + 32) = 0xE000000013;
      *(_DWORD *)(v57 + 40) = 0;
      *(_QWORD *)(v57 + 48) = 0;
      *(_QWORD *)(v57 + 56) = 0;
      *(_DWORD *)(v57 + 64) = 0;
      qword_254105AE8 = v57;
      v58 = re::introspectionAllocator((re *)v57);
      v60 = re::introspect_BOOL((re *)1, v59);
      v61 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v58 + 32))(v58, 72, 8);
      *(_DWORD *)v61 = 1;
      *(_QWORD *)(v61 + 8) = "deferToSystemAcousticTuning";
      *(_QWORD *)(v61 + 16) = v60;
      *(_QWORD *)(v61 + 24) = 0;
      *(_QWORD *)(v61 + 32) = 0x10000000016;
      *(_DWORD *)(v61 + 40) = 0;
      *(_QWORD *)(v61 + 48) = 0;
      *(_QWORD *)(v61 + 56) = 0;
      *(_DWORD *)(v61 + 64) = 0;
      qword_254105AF0 = v61;
      v62 = re::introspectionAllocator((re *)v61);
      v64 = re::introspect_uint32_t((re *)1, v63);
      v65 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v62 + 32))(v62, 72, 8);
      *(_DWORD *)v65 = 1;
      *(_QWORD *)(v65 + 8) = "gainActivationCounter";
      *(_QWORD *)(v65 + 16) = v64;
      *(_QWORD *)(v65 + 24) = 0;
      *(_QWORD *)(v65 + 32) = 0x5800000017;
      *(_DWORD *)(v65 + 40) = 0;
      *(_QWORD *)(v65 + 48) = 0;
      *(_QWORD *)(v65 + 56) = 0;
      *(_DWORD *)(v65 + 64) = 0;
      qword_254105AF8 = v65;
      v66 = re::introspectionAllocator((re *)v65);
      v68 = re::IntrospectionInfo<re::Optional<re::DynamicString>>::get(1, v67);
      v69 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v66 + 32))(v66, 72, 8);
      *(_DWORD *)v69 = 1;
      *(_QWORD *)(v69 + 8) = "mixGroupName";
      *(_QWORD *)(v69 + 16) = v68;
      *(_QWORD *)(v69 + 24) = 0;
      *(_QWORD *)(v69 + 32) = 0x7000000018;
      *(_DWORD *)(v69 + 40) = 0;
      *(_QWORD *)(v69 + 48) = 0;
      *(_QWORD *)(v69 + 56) = 0;
      *(_DWORD *)(v69 + 64) = 0;
      qword_254105B00 = v69;
      v70 = re::introspectionAllocator((re *)v69);
      v72 = re::introspect_BOOL((re *)1, v71);
      v73 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v70 + 32))(v70, 72, 8);
      *(_DWORD *)v73 = 1;
      *(_QWORD *)(v73 + 8) = "oneShotSound";
      *(_QWORD *)(v73 + 16) = v72;
      *(_QWORD *)(v73 + 24) = 0;
      *(_QWORD *)(v73 + 32) = 0x4C00000019;
      *(_DWORD *)(v73 + 40) = 0;
      *(_QWORD *)(v73 + 48) = 0;
      *(_QWORD *)(v73 + 56) = 0;
      *(_DWORD *)(v73 + 64) = 0;
      qword_254105B08 = v73;
      v74 = re::introspectionAllocator((re *)v73);
      v75 = re::audio::introspect_AudioSourceDirectivityConfiguration((re::IntrospectionBase **)1);
      v76 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v74 + 32))(v74, 72, 8);
      *(_DWORD *)v76 = 1;
      *(_QWORD *)(v76 + 8) = "directivityConfig";
      *(_QWORD *)(v76 + 16) = v75;
      *(_QWORD *)(v76 + 24) = 0;
      *(_QWORD *)(v76 + 32) = 0xC00000001CLL;
      *(_DWORD *)(v76 + 40) = 0;
      *(_QWORD *)(v76 + 48) = 0;
      *(_QWORD *)(v76 + 56) = 0;
      *(_DWORD *)(v76 + 64) = 0;
      qword_254105B10 = v76;
      v77 = re::introspectionAllocator((re *)v76);
      v79 = re::introspect_BOOL((re *)1, v78);
      v80 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v77 + 32))(v77, 72, 8);
      *(_DWORD *)v80 = 1;
      *(_QWORD *)(v80 + 8) = "shouldRedactSensitiveInfoFromLogs";
      *(_QWORD *)(v80 + 16) = v79;
      *(_QWORD *)(v80 + 24) = 0;
      *(_QWORD *)(v80 + 32) = 0x1010000001DLL;
      *(_DWORD *)(v80 + 40) = 0;
      *(_QWORD *)(v80 + 48) = 0;
      *(_QWORD *)(v80 + 56) = 0;
      *(_DWORD *)(v80 + 64) = 0;
      qword_254105B18 = v80;
      v81 = re::introspectionAllocator((re *)v80);
      v83 = re::introspect_float((re *)1, v82);
      v84 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v81 + 32))(v81, 72, 8);
      *(_DWORD *)v84 = 1;
      *(_QWORD *)(v84 + 8) = "rolloffFactor";
      *(_QWORD *)(v84 + 16) = v83;
      *(_QWORD *)(v84 + 24) = 0;
      *(_QWORD *)(v84 + 32) = 0x440000001ELL;
      *(_DWORD *)(v84 + 40) = 0;
      *(_QWORD *)(v84 + 48) = 0;
      *(_QWORD *)(v84 + 56) = 0;
      *(_DWORD *)(v84 + 64) = 0;
      qword_254105B20 = v84;
      __cxa_guard_release(&qword_2541059F8);
    }
  }
  *((_QWORD *)this + 2) = 0x10800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 20;
  *((_QWORD *)this + 8) = &qword_254105A88;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::AudioSourceSyncState>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::AudioSourceSyncState>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::AudioSourceSyncState>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::AudioSourceSyncState>;
  re::IntrospectionRegistry::add(this, v3);
  v85 = v87;
}

void sub_22542B3E0(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&qword_2541059F8);
  _Unwind_Resume(a1);
}

_QWORD *re::internal::defaultConstruct<re::AudioSourceSyncState>(_anonymous_namespace_ *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  _QWORD *v9;
  _anonymous_namespace_ *v10;
  _QWORD *result;

  v3 = a3;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_QWORD *)(a3 + 32) = 9;
  *(_DWORD *)(a3 + 40) = 1065353216;
  *(_QWORD *)(a3 + 48) = 0;
  *(_QWORD *)(a3 + 56) = 0;
  *(_DWORD *)(a3 + 64) = 0;
  *(_QWORD *)(a3 + 68) = 1065353216;
  *(_BYTE *)(a3 + 76) = 0;
  __asm { FMOV            V0.2S, #1.0 }
  *(_QWORD *)(a3 + 80) = _D0;
  *(_DWORD *)(a3 + 88) = 0;
  *(_QWORD *)(a3 + 96) = 0;
  *(_DWORD *)(a3 + 104) = 1065353216;
  *(_BYTE *)(a3 + 112) = 0;
  *(_BYTE *)(a3 + 152) = 0;
  *(_OWORD *)(a3 + 176) = 0u;
  *(_OWORD *)(a3 + 160) = 0u;
  v9 = (_QWORD *)(a3 + 160);
  v10 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v9, 0);
  *(_OWORD *)(v3 + 224) = 0u;
  v3 += 224;
  *(_DWORD *)(v3 - 32) = 1;
  *(_QWORD *)(v3 - 28) = 0x3E051EB800000000;
  *(_DWORD *)(v3 - 20) = 1106247680;
  *(_OWORD *)(v3 - 16) = 0u;
  *(_OWORD *)(v3 + 16) = 0u;
  result = re::DynamicString::setCapacity((_QWORD *)v3, 0);
  *(_WORD *)(v3 + 32) = 0;
  return result;
}

void re::internal::defaultDestruct<re::AudioSourceSyncState>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  _OWORD *v5;
  uint64_t v6;
  uint64_t v7;

  v5 = (_OWORD *)(a3 + 224);
  v4 = *(_QWORD *)(a3 + 224);
  if (v4)
  {
    if ((*(_BYTE *)(a3 + 232) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, *(_QWORD *)(a3 + 240));
    *v5 = 0u;
    v5[1] = 0u;
  }
  v6 = *(_QWORD *)(a3 + 160);
  if (v6)
  {
    if ((*(_BYTE *)(a3 + 168) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v6 + 40))(v6, *(_QWORD *)(a3 + 176));
    *(_OWORD *)(a3 + 160) = 0u;
    *(_OWORD *)(a3 + 176) = 0u;
  }
  if (*(_BYTE *)(a3 + 112))
  {
    v7 = *(_QWORD *)(a3 + 120);
    if (v7)
    {
      if ((*(_BYTE *)(a3 + 128) & 1) != 0)
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v7 + 40))(v7, *(_QWORD *)(a3 + 136));
      *(_OWORD *)(a3 + 120) = 0u;
      *(_OWORD *)(a3 + 136) = 0u;
    }
  }
  re::AssetHandle::~AssetHandle((re::AssetHandle *)(a3 + 8));
}

_QWORD *re::internal::defaultConstructV2<re::AudioSourceSyncState>(uint64_t a1)
{
  uint64_t v1;
  _QWORD *v7;
  _anonymous_namespace_ *v8;
  _QWORD *result;

  v1 = a1;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_QWORD *)(a1 + 32) = 9;
  *(_DWORD *)(a1 + 40) = 1065353216;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 68) = 1065353216;
  *(_BYTE *)(a1 + 76) = 0;
  __asm { FMOV            V0.2S, #1.0 }
  *(_QWORD *)(a1 + 80) = _D0;
  *(_DWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  *(_DWORD *)(a1 + 104) = 1065353216;
  *(_BYTE *)(a1 + 112) = 0;
  *(_BYTE *)(a1 + 152) = 0;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  v7 = (_QWORD *)(a1 + 160);
  v8 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v7, 0);
  *(_OWORD *)(v1 + 224) = 0u;
  v1 += 224;
  *(_DWORD *)(v1 - 32) = 1;
  *(_QWORD *)(v1 - 28) = 0x3E051EB800000000;
  *(_DWORD *)(v1 - 20) = 1106247680;
  *(_OWORD *)(v1 - 16) = 0u;
  *(_OWORD *)(v1 + 16) = 0u;
  result = re::DynamicString::setCapacity((_QWORD *)v1, 0);
  *(_WORD *)(v1 + 32) = 0;
  return result;
}

void re::internal::defaultDestructV2<re::AudioSourceSyncState>(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;
  uint64_t v4;
  uint64_t v5;

  v3 = (_OWORD *)(a1 + 224);
  v2 = *(_QWORD *)(a1 + 224);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 232) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 240));
    *v3 = 0u;
    v3[1] = 0u;
  }
  v4 = *(_QWORD *)(a1 + 160);
  if (v4)
  {
    if ((*(_BYTE *)(a1 + 168) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, *(_QWORD *)(a1 + 176));
    *(_OWORD *)(a1 + 160) = 0u;
    *(_OWORD *)(a1 + 176) = 0u;
  }
  if (*(_BYTE *)(a1 + 112))
  {
    v5 = *(_QWORD *)(a1 + 120);
    if (v5)
    {
      if ((*(_BYTE *)(a1 + 128) & 1) != 0)
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v5 + 40))(v5, *(_QWORD *)(a1 + 136));
      *(_OWORD *)(a1 + 120) = 0u;
      *(_OWORD *)(a1 + 136) = 0u;
    }
  }
  re::AssetHandle::~AssetHandle((re::AssetHandle *)(a1 + 8));
}

uint64_t re::introspect_AudioSourceSyncState(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"AudioSourceSyncState", (uint64_t (*)(re::internal *))re::allocInfo_AudioSourceSyncState, (re::IntrospectionBase *(*)(void))re::initInfo_AudioSourceSyncState, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::AudioSourceSyncState>, this);
}

re::AudioSourceState *re::AudioSourceState::AudioSourceState(re::AudioSourceState *this)
{
  _anonymous_namespace_ *v7;
  _anonymous_namespace_ *v8;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  REAudioSourceStateWrapper *v14;
  void *v15;

  ArcSharedObject::ArcSharedObject(this, 0);
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_QWORD *)this = &off_24ED3FA10;
  *(_OWORD *)((char *)this + 40) = 0u;
  *((_QWORD *)this + 7) = 9;
  *((_DWORD *)this + 16) = 1065353216;
  *((_QWORD *)this + 9) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_DWORD *)this + 22) = 0;
  *(_QWORD *)((char *)this + 92) = 1065353216;
  *((_BYTE *)this + 100) = 0;
  __asm { FMOV            V0.2S, #1.0 }
  *((_QWORD *)this + 13) = _D0;
  *((_DWORD *)this + 28) = 0;
  *((_QWORD *)this + 15) = 0;
  *((_DWORD *)this + 32) = 1065353216;
  *((_BYTE *)this + 136) = 0;
  *((_BYTE *)this + 176) = 0;
  *(_OWORD *)((char *)this + 200) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  v8 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)this + 23, 0);
  *(_OWORD *)((char *)this + 248) = 0u;
  *((_DWORD *)this + 54) = 1;
  *(_QWORD *)((char *)this + 220) = 0x3E051EB800000000;
  *((_DWORD *)this + 57) = 1106247680;
  *(_OWORD *)((char *)this + 264) = 0u;
  *(_OWORD *)((char *)this + 232) = 0u;
  re::DynamicString::setCapacity((_QWORD *)this + 31, 0);
  *((_WORD *)this + 140) = 0;
  *((_DWORD *)this + 72) = 0;
  *((_BYTE *)this + 292) = 0;
  *((_QWORD *)this + 37) = 1065353216;
  *((_QWORD *)this + 38) = 0;
  *((_DWORD *)this + 78) = 1065353216;
  v9 = MEMORY[0x24BDAEE00];
  v10 = *MEMORY[0x24BDAEE00];
  v11 = *(_OWORD *)(MEMORY[0x24BDAEE00] + 16);
  *((_OWORD *)this + 20) = *MEMORY[0x24BDAEE00];
  *((_OWORD *)this + 21) = v11;
  v12 = *(_OWORD *)(v9 + 32);
  v13 = *(_OWORD *)(v9 + 48);
  *((_OWORD *)this + 22) = v12;
  *((_OWORD *)this + 23) = v13;
  *((_OWORD *)this + 24) = v10;
  *((_OWORD *)this + 25) = v11;
  *((_OWORD *)this + 26) = v12;
  *((_OWORD *)this + 27) = v13;
  *((_QWORD *)this + 57) = 0;
  *((_QWORD *)this + 58) = 0;
  *((_QWORD *)this + 56) = -1;
  *((_DWORD *)this + 118) = 6553601;
  *(_QWORD *)((char *)this + 476) = 0;
  *(_QWORD *)((char *)this + 481) = 0;
  *((_OWORD *)this + 31) = 0u;
  *((_OWORD *)this + 32) = 0u;
  *(_OWORD *)((char *)this + 524) = 0u;
  *(_QWORD *)((char *)this + 540) = 0x7FFFFFFFLL;
  *(_OWORD *)((char *)this + 552) = 0u;
  *(_OWORD *)((char *)this + 568) = 0u;
  *((_DWORD *)this + 146) = 0;
  *(_QWORD *)((char *)this + 588) = 0x7FFFFFFFLL;
  *((_BYTE *)this + 600) = 0;
  *((_BYTE *)this + 624) = 0;
  *((_BYTE *)this + 628) = 0;
  *((_BYTE *)this + 652) = 0;
  *((_BYTE *)this + 656) = 0;
  *((_BYTE *)this + 664) = 0;
  *((_BYTE *)this + 672) = 0;
  *((_DWORD *)this + 181) = 0;
  *((_BYTE *)this + 728) = 0;
  *((_BYTE *)this + 736) = 0;
  *((_QWORD *)this + 93) = 0;
  *((_DWORD *)this + 188) = 0;
  *((_QWORD *)this + 100) = 0;
  *(_OWORD *)((char *)this + 705) = 0u;
  *(_OWORD *)((char *)this + 680) = 0u;
  *(_OWORD *)((char *)this + 696) = 0u;
  *((_WORD *)this + 396) = 0;
  *(_OWORD *)((char *)this + 760) = 0u;
  *(_OWORD *)((char *)this + 776) = 0u;
  v14 = -[REAudioSourceStateWrapper initWithState:]([REAudioSourceStateWrapper alloc], "initWithState:", this);
  v15 = (void *)*((_QWORD *)this + 100);
  *((_QWORD *)this + 100) = v14;

  return this;
}

void sub_22542B9B4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  re::AudioSourceSyncState *v3;
  uint64_t *v4;
  uint64_t *v5;
  va_list va;

  va_start(va, a2);

  std::vector<std::function<void ()(void)>>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit(v5);
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit(v4);

  re::AudioSourceSyncState::~AudioSourceSyncState(v3);
  *(_QWORD *)v2 = &off_24ED426B8;
  objc_destructInstance((id)(v2 + 8));
  _Unwind_Resume(a1);
}

void re::AudioSourceSyncState::~AudioSourceSyncState(re::AudioSourceSyncState *this)
{
  uint64_t v2;
  _OWORD *v3;
  uint64_t v4;
  uint64_t v5;

  v3 = (_OWORD *)((char *)this + 224);
  v2 = *((_QWORD *)this + 28);
  if (v2)
  {
    if ((*((_BYTE *)this + 232) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *((_QWORD *)this + 30));
    *v3 = 0u;
    v3[1] = 0u;
  }
  v4 = *((_QWORD *)this + 20);
  if (v4)
  {
    if ((*((_BYTE *)this + 168) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, *((_QWORD *)this + 22));
    *((_OWORD *)this + 10) = 0u;
    *((_OWORD *)this + 11) = 0u;
  }
  if (*((_BYTE *)this + 112))
  {
    v5 = *((_QWORD *)this + 15);
    if (v5)
    {
      if ((*((_BYTE *)this + 128) & 1) != 0)
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v5 + 40))(v5, *((_QWORD *)this + 17));
      *(_OWORD *)((char *)this + 120) = 0u;
      *(_OWORD *)((char *)this + 136) = 0u;
    }
  }
  re::AssetHandle::~AssetHandle((re::AudioSourceSyncState *)((char *)this + 8));
}

void re::AudioSourceState::~AudioSourceState(re::AudioSourceState *this)
{
  void *v2;
  const void *v3;
  const void *v4;
  void *v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD block[5];
  void **v11[5];
  id v12;

  *(_QWORD *)this = &off_24ED3FA10;
  v2 = (void *)*((_QWORD *)this + 57);
  *((_QWORD *)this + 57) = 0;

  *((_QWORD *)this + 60) = 0;
  *((_QWORD *)this + 86) = 0;
  v3 = (const void *)*((_QWORD *)this + 98);
  if (v3)
    CFRelease(v3);
  re::AudioSourceState::setTimebase(this, 0, 0, 0);
  re::AudioSourceState::setTimebaseDispatchSource((uint64_t)this, 0);
  v4 = (const void *)*((_QWORD *)this + 88);
  *((_QWORD *)this + 88) = 0;
  if (v4)
    CFRelease(v4);
  v5 = (void *)*((_QWORD *)this + 58);
  if (v5)
  {
    v11[0] = 0;
    v11[1] = (void **)v11;
    v11[2] = (void **)0x3032000000;
    v11[3] = (void **)__Block_byref_object_copy__6;
    v11[4] = (void **)__Block_byref_object_dispose__6;
    v12 = v5;
    if (qword_254105A08 != -1)
      dispatch_once(&qword_254105A08, &__block_literal_global_9);
    v6 = (id)qword_254105A00;
    block[0] = MEMORY[0x24BDAC760];
    block[1] = 3221225472;
    block[2] = ___ZNK2re16AudioSourceState24releaseAudioSessionAsyncEv_block_invoke;
    block[3] = &unk_24ED3D730;
    block[4] = v11;
    dispatch_async(v6, block);

    _Block_object_dispose(v11, 8);
  }

  v11[0] = (void **)((char *)this + 760);
  std::vector<std::function<void ()(void)>>::__destroy_vector::operator()[abi:ne180100](v11);

  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)this + 69);
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)this + 63);

  v7 = *((_QWORD *)this + 31);
  if (v7)
  {
    if ((*((_BYTE *)this + 256) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v7 + 40))(v7, *((_QWORD *)this + 33));
    *(_OWORD *)((char *)this + 248) = 0u;
    *(_OWORD *)((char *)this + 264) = 0u;
  }
  v8 = *((_QWORD *)this + 23);
  if (v8)
  {
    if ((*((_BYTE *)this + 192) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v8 + 40))(v8, *((_QWORD *)this + 25));
    *(_OWORD *)((char *)this + 184) = 0u;
    *(_OWORD *)((char *)this + 200) = 0u;
  }
  if (*((_BYTE *)this + 136))
  {
    v9 = *((_QWORD *)this + 18);
    if (v9)
    {
      if ((*((_BYTE *)this + 152) & 1) != 0)
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v9 + 40))(v9, *((_QWORD *)this + 20));
      *((_OWORD *)this + 9) = 0u;
      *((_OWORD *)this + 10) = 0u;
    }
  }
  re::AssetHandle::~AssetHandle((re::AudioSourceState *)((char *)this + 32));
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  re::AudioSourceState::~AudioSourceState(this);
  JUMPOUT(0x2276933B8);
}

void re::AudioSourceState::setTimebase(re::AudioSourceState *this, CFTypeRef cf, char a3, void (__cdecl *a4)(CFNotificationCenterRef, void *, CFNotificationName, const void *, CFDictionaryRef))
{
  void *v6;
  CFStringRef *v7;
  CFStringRef *v8;
  CFStringRef *v9;
  __CFNotificationCenter *LocalCenter;
  __CFNotificationCenter *v12;
  __CFNotificationCenter *v13;
  NSObject *v14;
  __CFNotificationCenter *v15;
  __CFNotificationCenter *v16;
  __CFNotificationCenter *v17;
  NSObject *v18;

  v6 = (void *)*((_QWORD *)this + 87);
  *((_QWORD *)this + 87) = cf;
  v7 = (CFStringRef *)MEMORY[0x24BDC0DB0];
  v8 = (CFStringRef *)MEMORY[0x24BDC0DA0];
  v9 = (CFStringRef *)MEMORY[0x24BDC0DA8];
  if (cf)
  {
    CFRetain(cf);
    LocalCenter = CFNotificationCenterGetLocalCenter();
    CFNotificationCenterAddObserver(LocalCenter, this, a4, *v7, *((const void **)this + 87), CFNotificationSuspensionBehaviorDrop);
    v12 = CFNotificationCenterGetLocalCenter();
    CFNotificationCenterAddObserver(v12, this, a4, *v8, *((const void **)this + 87), CFNotificationSuspensionBehaviorDrop);
    v13 = CFNotificationCenterGetLocalCenter();
    CFNotificationCenterAddObserver(v13, this, a4, *v9, *((const void **)this + 87), CFNotificationSuspensionBehaviorDrop);
    v14 = *((_QWORD *)this + 89);
    if (v14)
      CMTimebaseAddTimerDispatchSource(*((CMTimebaseRef *)this + 87), v14);
  }
  if (v6)
  {
    v15 = CFNotificationCenterGetLocalCenter();
    CFNotificationCenterRemoveObserver(v15, this, *v7, v6);
    v16 = CFNotificationCenterGetLocalCenter();
    CFNotificationCenterRemoveObserver(v16, this, *v8, v6);
    v17 = CFNotificationCenterGetLocalCenter();
    CFNotificationCenterRemoveObserver(v17, this, *v9, v6);
    v18 = *((_QWORD *)this + 89);
    if (v18)
      CMTimebaseRemoveTimerDispatchSource((CMTimebaseRef)v6, v18);
    CFRelease(v6);
  }
  *((_BYTE *)this + 720) = a3;
}

void re::AudioSourceState::setTimebaseDispatchSource(uint64_t a1, void *a2)
{
  dispatch_object_t *v4;
  NSObject *v5;
  OpaqueCMTimebase *v6;
  OpaqueCMTimebase *v7;
  id v8;

  v8 = a2;
  v4 = (dispatch_object_t *)(a1 + 712);
  v5 = *(NSObject **)(a1 + 712);
  if (v5)
  {
    v6 = *(OpaqueCMTimebase **)(a1 + 696);
    if (v6)
    {
      CMTimebaseRemoveTimerDispatchSource(v6, v5);
      v5 = *v4;
    }
    dispatch_source_cancel(v5);
  }
  objc_storeStrong((id *)(a1 + 712), a2);
  if (*v4)
  {
    dispatch_resume(*v4);
    v7 = *(OpaqueCMTimebase **)(a1 + 696);
    if (v7)
      CMTimebaseAddTimerDispatchSource(v7, *v4);
  }

}

void sub_22542BEC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void ___ZN2re13getAsyncQueueEv_block_invoke()
{
  NSObject *v0;
  dispatch_queue_t v1;
  void *v2;
  NSObject *attr;

  dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  v0 = objc_claimAutoreleasedReturnValue();
  dispatch_queue_attr_make_with_qos_class(v0, QOS_CLASS_UTILITY, 0);
  attr = objc_claimAutoreleasedReturnValue();

  v1 = dispatch_queue_create("com.apple.re.AudioSourceState_SessionRelease", attr);
  v2 = (void *)qword_254105A00;
  qword_254105A00 = (uint64_t)v1;

}

uint64_t __Block_byref_object_copy__6(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__6(uint64_t a1)
{

}

void ___ZNK2re16AudioSourceState24releaseAudioSessionAsyncEv_block_invoke(re *a1)
{
  NSObject *v2;
  uint64_t v3;
  void *v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v2 = *re::audioLogObjects(a1);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    v5 = *(_QWORD *)(*(_QWORD *)(*((_QWORD *)a1 + 4) + 8) + 40);
    v6 = 138412290;
    v7 = v5;
    _os_log_debug_impl(&dword_224FE9000, v2, OS_LOG_TYPE_DEBUG, "AudioSourceState::releaseAudioSessionAsync: releasing %@", (uint8_t *)&v6, 0xCu);
  }
  v3 = *(_QWORD *)(*((_QWORD *)a1 + 4) + 8);
  v4 = *(void **)(v3 + 40);
  *(_QWORD *)(v3 + 40) = 0;

}

void re::AudioSourceState::enqueuePendingCallback(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;

  v4 = (os_unfair_lock_s *)(a1 + 752);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 752));
  std::vector<std::function<void ()(void)>>::push_back[abi:ne180100]((uint64_t *)(a1 + 760), a2);
  os_unfair_lock_unlock(v4);
}

void sub_22542C088(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::function<void ()(void)>>::push_back[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  void *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (v7 >= v6)
  {
    v10 = (uint64_t)(v7 - *a1) >> 5;
    if ((unint64_t)(v10 + 1) >> 59)
      std::vector<std::function<void ()(void)>>::__throw_length_error[abi:ne180100]();
    v11 = v5 - *a1;
    v12 = v11 >> 4;
    if (v11 >> 4 <= (unint64_t)(v10 + 1))
      v12 = v10 + 1;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFE0)
      v13 = 0x7FFFFFFFFFFFFFFLL;
    else
      v13 = v12;
    v19 = v4;
    if (v13)
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::function<void ()(void)>>>(v4, v13);
    else
      v14 = 0;
    v15 = v14;
    v16 = &v14[32 * v10];
    v18 = &v14[32 * v13];
    std::__function::__value_func<void ()(void)>::__value_func[abi:nn180100]((uint64_t)v16, a2);
    v17 = v16 + 32;
    std::vector<std::function<void ()(void)>>::__swap_out_circular_buffer(a1, &v15);
    v9 = a1[1];
    result = (uint64_t)std::__split_buffer<std::function<void ()(void)>>::~__split_buffer(&v15);
  }
  else
  {
    result = std::__function::__value_func<void ()(void)>::__value_func[abi:nn180100](*(_QWORD *)(v4 - 8), a2);
    v9 = v7 + 32;
    a1[1] = v7 + 32;
  }
  a1[1] = v9;
  return result;
}

void sub_22542C18C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  uint64_t v10;
  uint64_t v11;

  *(_QWORD *)(v10 + 8) = v11;
  _Unwind_Resume(exception_object);
}

void re::AudioSourceState::callPendingCallbacks(os_unfair_lock_s *this)
{
  os_unfair_lock_s *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  char *v12;
  char *v13;
  void ***v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  void **v19[3];
  void ***v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v2 = this + 188;
  os_unfair_lock_lock(this + 188);
  if (&v16 != (char **)&this[190])
  {
    v3 = *(_QWORD *)&this[190]._os_unfair_lock_opaque;
    v4 = *(_QWORD *)&this[192]._os_unfair_lock_opaque;
    v5 = v4 - v3;
    if (v4 == v3)
    {
      v17 = 0;
    }
    else
    {
      if (v5 < 0)
        std::vector<std::function<void ()(void)>>::__throw_length_error[abi:ne180100]();
      v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::function<void ()(void)>>>((uint64_t)&v18, v5 >> 5);
      v17 = (uint64_t)v16;
      v18 = &v16[32 * v6];
      v17 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::function<void ()(void)>>,std::function<void ()(void)>*,std::function<void ()(void)>*,std::function<void ()(void)>*>((uint64_t)&v18, v3, v4, (uint64_t)v16);
    }
  }
  v7 = *(_QWORD *)&this[192]._os_unfair_lock_opaque;
  v8 = *(_QWORD *)&this[190]._os_unfair_lock_opaque;
  if (v7 != v8)
  {
    while (1)
    {
      v9 = v7 - 32;
      v10 = *(_QWORD **)(v7 - 8);
      if ((_QWORD *)(v7 - 32) == v10)
        break;
      if (v10)
      {
        v11 = 5;
LABEL_11:
        (*(void (**)(void))(*v10 + 8 * v11))();
      }
      v7 = v9;
      if (v9 == v8)
        goto LABEL_13;
    }
    v10 = (_QWORD *)(v7 - 32);
    v11 = 4;
    goto LABEL_11;
  }
LABEL_13:
  *(_QWORD *)&this[192]._os_unfair_lock_opaque = v8;
  os_unfair_lock_unlock(v2);
  v12 = v16;
  v13 = (char *)v17;
  while (v12 != v13)
  {
    std::__function::__value_func<void ()(void)>::__value_func[abi:nn180100]((uint64_t)v19, (uint64_t)v12);
    if (!v20)
      std::__throw_bad_function_call[abi:ne180100]();
    ((void (*)(void ***))(*v20)[6])(v20);
    v14 = v20;
    if (v20 == v19)
    {
      v14 = v19;
      v15 = 4;
    }
    else
    {
      if (!v20)
        goto LABEL_21;
      v15 = 5;
    }
    ((void (*)(void))(*v14)[v15])();
LABEL_21:
    v12 += 32;
  }
  v19[0] = (void **)&v16;
  std::vector<std::function<void ()(void)>>::__destroy_vector::operator()[abi:ne180100](v19);
}

void sub_22542C364(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t *a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  os_unfair_lock_s *v15;

  os_unfair_lock_unlock(v15);
  a12 = &a9;
  std::vector<std::function<void ()(void)>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a12);
  _Unwind_Resume(a1);
}

uint64_t re::AudioSourceState::playbackHostConnectionIdentifier(re::AudioSourceState *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t result;

  v1 = *((_QWORD *)this + 60);
  if (!v1)
    return 0;
  v2 = *(_QWORD *)(v1 + 16);
  if (!v2)
    return 0;
  result = re::ecs2::EntityComponentCollection::get((re::ecs2::EntityComponentCollection *)(v2 + 32), (const re::ecs2::ComponentTypeBase *)re::ecs2::ComponentImpl<re::ecs2::AudioTransientComponent,(re::ecs2::ComponentTypeBase::Flags)1>::s_componentType);
  if (result)
    return *(_QWORD *)(result + 32);
  return result;
}

void std::vector<std::function<void ()(void)>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  char *v6;
  char *v7;
  uint64_t v8;

  v1 = *a1;
  v2 = (char *)**a1;
  if (!v2)
    return;
  v4 = (char *)v1[1];
  v5 = **a1;
  if (v4 == v2)
    goto LABEL_10;
  do
  {
    v6 = v4 - 32;
    v7 = (char *)*((_QWORD *)v4 - 1);
    if (v4 - 32 == v7)
    {
      v7 = v4 - 32;
      v8 = 4;
    }
    else
    {
      if (!v7)
        goto LABEL_8;
      v8 = 5;
    }
    (*(void (**)(void))(*(_QWORD *)v7 + 8 * v8))();
LABEL_8:
    v4 = v6;
  }
  while (v6 != v2);
  v5 = **a1;
LABEL_10:
  v1[1] = v2;
  operator delete(v5);
}

uint64_t std::vector<std::function<void ()(void)>>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::function<void ()(void)>>,std::reverse_iterator<std::function<void ()(void)>*>,std::reverse_iterator<std::function<void ()(void)>*>,std::reverse_iterator<std::function<void ()(void)>*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void std::vector<std::function<void ()(void)>>::__throw_length_error[abi:ne180100]()
{
  std::__throw_length_error[abi:ne180100]("vector");
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::function<void ()(void)>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 59)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(32 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::function<void ()(void)>>,std::reverse_iterator<std::function<void ()(void)>*>,std::reverse_iterator<std::function<void ()(void)>*>,std::reverse_iterator<std::function<void ()(void)>*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;

  v7 = a7;
  if (a3 != a5)
  {
    v10 = (_QWORD *)(a7 - 8);
    do
    {
      v11 = *(_QWORD *)(a3 - 8);
      v12 = a3 - 32;
      v13 = v10;
      if (v11)
      {
        if (v12 == v11)
        {
          *v10 = v10 - 3;
          (*(void (**)(_QWORD))(**(_QWORD **)(a3 - 8) + 24))(*(_QWORD *)(a3 - 8));
          goto LABEL_8;
        }
        *v10 = v11;
        v13 = (_QWORD *)(a3 - 8);
      }
      *v13 = 0;
LABEL_8:
      v10 -= 4;
      v7 -= 32;
      a3 = v12;
    }
    while (v12 != a5);
  }
  return a6;
}

void **std::__split_buffer<std::function<void ()(void)>>::~__split_buffer(void **a1)
{
  std::__split_buffer<std::function<void ()(void)>>::clear[abi:ne180100](a1);
  if (*a1)
    operator delete(*a1);
  return a1;
}

_QWORD *std::__split_buffer<std::function<void ()(void)>>::clear[abi:ne180100](_QWORD *result)
{
  _QWORD *v1;
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;

  v2 = (_QWORD *)result[1];
  v1 = (_QWORD *)result[2];
  if (v1 != v2)
  {
    v3 = result;
    while (1)
    {
      result = v1 - 4;
      v3[2] = v1 - 4;
      v4 = (_QWORD *)*(v1 - 1);
      if (v4 == result)
        break;
      if (v4)
      {
        result = v4;
        v5 = 5;
LABEL_7:
        (*(void (**)(void))(*result + 8 * v5))();
        result = (_QWORD *)v3[2];
      }
      v1 = result;
      if (result == v2)
        return result;
    }
    v5 = 4;
    goto LABEL_7;
  }
  return result;
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::function<void ()(void)>>,std::function<void ()(void)>*,std::function<void ()(void)>*,std::function<void ()(void)>*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v6;
  _QWORD v8[3];
  char v9;
  uint64_t v10;
  uint64_t v11;

  v4 = a4;
  v10 = a4;
  v11 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  v9 = 0;
  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      std::__function::__value_func<void ()(void)>::__value_func[abi:nn180100](v4, v6);
      v6 += 32;
      v4 = v11 + 32;
      v11 += 32;
    }
    while (v6 != a3);
  }
  v9 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::function<void ()(void)>>,std::function<void ()(void)>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v8);
  return v4;
}

void sub_22542C738(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::function<void ()(void)>>,std::function<void ()(void)>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::function<void ()(void)>>,std::function<void ()(void)>*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;

  if (!*(_BYTE *)(a1 + 24))
  {
    v2 = **(_QWORD **)(a1 + 8);
    v3 = **(_QWORD **)(a1 + 16);
    if (v3 != v2)
    {
      while (1)
      {
        v4 = v3 - 32;
        v5 = *(_QWORD **)(v3 - 8);
        if ((_QWORD *)(v3 - 32) == v5)
          break;
        if (v5)
        {
          v6 = 5;
LABEL_7:
          (*(void (**)(void))(*v5 + 8 * v6))();
        }
        v3 = v4;
        if (v4 == v2)
          return a1;
      }
      v5 = (_QWORD *)(v3 - 32);
      v6 = 4;
      goto LABEL_7;
    }
  }
  return a1;
}

uint64_t re::internal::BindNodeImplBase::readBindingKey(uint64_t a1, char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  __int128 v6;

  *(_QWORD *)a4 = 0;
  *(_QWORD *)(a4 + 8) = 0;
  if (*(_BYTE *)(a4 + 16))
    *(_BYTE *)(a4 + 16) = 0;
  v6 = 0uLL;
  result = re::internal::parseNextBindingKey(a2, &v6, a3);
  if ((_DWORD)result)
  {
    *(_OWORD *)a4 = v6;
    if (*(_BYTE *)(a4 + 16))
      *(_BYTE *)(a4 + 16) = 0;
  }
  return result;
}

double re::BindNode::deinit(re::BindNode *this)
{
  void (***v2)(_QWORD);
  uint64_t v3;
  double result;

  if (*(_QWORD *)this)
  {
    (**(void (***)(re::BindNode *))this)(this);
  }
  else
  {
    v2 = (void (***)(_QWORD))*((_QWORD *)this + 2);
    if (!v2)
      return result;
    v3 = *((_QWORD *)this + 1);
    (**v2)(*((_QWORD *)this + 2));
    (*(void (**)(uint64_t, void (***)(_QWORD)))(*(_QWORD *)v3 + 40))(v3, v2);
  }
  result = 0.0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  return result;
}

uint64_t re::BindNode::copy(re::BindNode *this, const re::BindNode *a2)
{
  __n128 v4;
  uint64_t v5;
  re::BindNode *v6;
  uint64_t result;
  uint64_t v8;
  _QWORD *v9;

  v4.n128_f64[0] = re::BindNode::deinit(this);
  v5 = *(_QWORD *)a2;
  if (*(_QWORD *)a2)
  {
    v6 = this;
    return (*(uint64_t (**)(const re::BindNode *, re::BindNode *, __n128))(v5 + 24))(a2, v6, v4);
  }
  result = *((_QWORD *)a2 + 2);
  if (result)
  {
    v8 = *((_QWORD *)a2 + 1);
    v9 = (_QWORD *)(*(uint64_t (**)(uint64_t, double))(*(_QWORD *)result + 16))(result, v4.n128_f64[0]);
    v6 = (re::BindNode *)(*(uint64_t (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)v8 + 32))(v8, *v9, v9[1]);
    *(_QWORD *)this = 0;
    *((_QWORD *)this + 1) = v8;
    *((_QWORD *)this + 2) = v6;
    v5 = *(_QWORD *)a2;
    if (!*(_QWORD *)a2)
    {
      a2 = (const re::BindNode *)*((_QWORD *)a2 + 2);
      v5 = *(_QWORD *)a2;
    }
    return (*(uint64_t (**)(const re::BindNode *, re::BindNode *, __n128))(v5 + 24))(a2, v6, v4);
  }
  return result;
}

uint64_t re::BindNode::move(re::BindNode *this, re::BindNode *a2)
{
  __n128 v4;
  uint64_t v5;
  re::BindNode *v6;
  uint64_t result;
  uint64_t v8;
  _QWORD *v9;

  v4.n128_f64[0] = re::BindNode::deinit(this);
  v5 = *(_QWORD *)a2;
  if (*(_QWORD *)a2)
  {
    v6 = this;
    return (*(uint64_t (**)(re::BindNode *, re::BindNode *, __n128))(v5 + 32))(a2, v6, v4);
  }
  result = *((_QWORD *)a2 + 2);
  if (result)
  {
    v8 = *((_QWORD *)a2 + 1);
    v9 = (_QWORD *)(*(uint64_t (**)(uint64_t, double))(*(_QWORD *)result + 16))(result, v4.n128_f64[0]);
    v6 = (re::BindNode *)(*(uint64_t (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)v8 + 32))(v8, *v9, v9[1]);
    *(_QWORD *)this = 0;
    *((_QWORD *)this + 1) = v8;
    *((_QWORD *)this + 2) = v6;
    v5 = *(_QWORD *)a2;
    if (!*(_QWORD *)a2)
    {
      a2 = (re::BindNode *)*((_QWORD *)a2 + 2);
      v5 = *(_QWORD *)a2;
    }
    return (*(uint64_t (**)(re::BindNode *, re::BindNode *, __n128))(v5 + 32))(a2, v6, v4);
  }
  return result;
}

uint64_t re::BindNode::operator==(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  BOOL v9;

  v2 = *a1;
  if (!*a1)
  {
    v6 = (uint64_t *)a1[2];
    v7 = *a2;
    v8 = a2[2];
    if (!*a2)
      a2 = (uint64_t *)a2[2];
    if (v6 != a2)
    {
      v5 = 0;
      v9 = (v7 | v8) == 0;
      if (!v6 || v9)
        return v5;
      v2 = *v6;
      return (*(uint64_t (**)(void))(v2 + 40))();
    }
    return 1;
  }
  v3 = *a2;
  v4 = a2[2];
  if (!*a2)
    a2 = (uint64_t *)a2[2];
  if (a2 == a1)
    return 1;
  if (v3 | v4)
    return (*(uint64_t (**)(void))(v2 + 40))();
  return 0;
}

double re::BindNode::relativeNode@<D0>(re::BindNode *a1@<X0>, __int128 *a2@<X1>, re::BindNode *a3@<X8>)
{
  uint64_t v5;
  __int128 *v6;
  BOOL v7;
  __int128 *v8;
  double result;
  uint64_t v10;
  uint64_t v11;
  char v12;
  __int128 v13;
  _QWORD v14[4];
  __int128 v15;
  __int128 v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  if ((*(_QWORD *)a1 || *((_QWORD *)a1 + 2)) && *((_QWORD *)a2 + 1))
  {
    v15 = 0u;
    v16 = 0u;
    re::BindNode::copy((re::BindNode *)&v15, a1);
    v13 = *a2;
    while (1)
    {
      v5 = v15;
      if ((_QWORD)v15)
      {
        if (!*((_QWORD *)&v13 + 1))
          goto LABEL_19;
        v10 = 0;
        v11 = 0;
        v6 = &v15;
        v12 = 0;
      }
      else
      {
        v6 = (__int128 *)v16;
        if ((_QWORD)v16)
          v7 = *((_QWORD *)&v13 + 1) == 0;
        else
          v7 = 1;
        if (v7)
        {
LABEL_19:
          *(_OWORD *)a3 = 0u;
          *((_OWORD *)a3 + 1) = 0u;
          re::BindNode::move(a3, (re::BindNode *)&v15);
          return re::BindNode::deinit((re::BindNode *)&v15);
        }
        v10 = 0;
        v11 = 0;
        v12 = 0;
        v5 = *(_QWORD *)v16;
      }
      if (((*(uint64_t (**)(__int128 *, __int128 *, __int128 *, uint64_t *))(v5 + 64))(v6, &v13, &v13, &v10) & 1) == 0)
        break;
      if ((_QWORD)v15)
        v8 = &v15;
      else
        v8 = (__int128 *)v16;
      (*(void (**)(_QWORD *__return_ptr, __int128 *, uint64_t *))(*(_QWORD *)v8 + 56))(v14, v8, &v10);
      re::BindNode::move((re::BindNode *)&v15, (re::BindNode *)v14);
      re::BindNode::deinit((re::BindNode *)v14);
    }
    *(_OWORD *)a3 = 0u;
    *((_OWORD *)a3 + 1) = 0u;
    return re::BindNode::deinit((re::BindNode *)&v15);
  }
  else
  {
    result = 0.0;
    *(_OWORD *)a3 = 0u;
    *((_OWORD *)a3 + 1) = 0u;
  }
  return result;
}

double re::BindNode::bindPoint@<D0>(re::BindNode **a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  __int128 *v6;
  _QWORD v8[2];
  char v9;
  __int128 v10;
  __int128 v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v10 = 0u;
  v11 = 0u;
  v8[0] = 0;
  v8[1] = 0;
  v9 = 0;
  if (re::BindNode::processBindingPath(a1, a3, (re::BindNode **)&v10, (uint64_t)v8))
  {
    if ((_QWORD)v10)
      v6 = &v10;
    else
      v6 = (__int128 *)v11;
    (*(void (**)(__int128 *, uint64_t, _QWORD *))(*(_QWORD *)v6 + 72))(v6, a2, v8);
  }
  else
  {
    *(_QWORD *)(a4 + 40) = 0;
    *(_OWORD *)a4 = 0u;
    *(_OWORD *)(a4 + 16) = 0u;
    *(_DWORD *)(a4 + 32) = 0;
  }
  return re::BindNode::deinit((re::BindNode *)&v10);
}

uint64_t re::BindNode::processBindingPath(re::BindNode **a1, uint64_t *a2, re::BindNode **this, uint64_t a4)
{
  re::BindNode *v7;
  re::BindNode *v8;
  re::BindNode *v9;
  uint64_t result;
  re::BindNode *v11;
  uint64_t v12[2];
  __int128 v13;
  _QWORD v14[5];

  v14[4] = *MEMORY[0x24BDAC8D0];
  if (!*a1 && !a1[2])
    return 0;
  if (this != a1)
    re::BindNode::copy((re::BindNode *)this, (const re::BindNode *)a1);
  v13 = *(_OWORD *)a2;
  v12[0] = 0;
  v12[1] = 0;
  if (re::internal::parseBindingURI(a2, v12, (uint64_t *)&v13))
  {
    if (*this)
      v7 = (re::BindNode *)this;
    else
      v7 = this[2];
    (*(void (**)(_QWORD *__return_ptr, re::BindNode *, uint64_t *))(*(_QWORD *)v7 + 48))(v14, v7, v12);
    if (v14 != this)
      re::BindNode::move((re::BindNode *)this, (re::BindNode *)v14);
    re::BindNode::deinit((re::BindNode *)v14);
    if (!((unint64_t)*this | (unint64_t)this[2]))
      return 0;
  }
  if (!*((_QWORD *)&v13 + 1))
    return 0;
  while (1)
  {
    *(_QWORD *)a4 = 0;
    *(_QWORD *)(a4 + 8) = 0;
    if (*(_BYTE *)(a4 + 16))
      *(_BYTE *)(a4 + 16) = 0;
    v8 = *this;
    v9 = (re::BindNode *)this;
    if (!*this)
    {
      v9 = this[2];
      v8 = *(re::BindNode **)v9;
    }
    result = (*((uint64_t (**)(re::BindNode *, __int128 *, __int128 *, uint64_t))v8 + 8))(v9, &v13, &v13, a4);
    if (!(_DWORD)result)
      break;
    if (!*((_QWORD *)&v13 + 1))
      return 1;
    if (*this)
      v11 = (re::BindNode *)this;
    else
      v11 = this[2];
    (*(void (**)(_QWORD *__return_ptr, re::BindNode *, uint64_t))(*(_QWORD *)v11 + 56))(v14, v11, a4);
    if (v14 != this)
      re::BindNode::move((re::BindNode *)this, (re::BindNode *)v14);
    re::BindNode::deinit((re::BindNode *)v14);
    if (!((unint64_t)*this | (unint64_t)this[2]))
      return 0;
  }
  return result;
}

double re::BindNode::bindPointWithOverride@<D0>(re::BindNode **a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  __int128 *v6;
  _QWORD v8[2];
  char v9;
  __int128 v10;
  __int128 v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v10 = 0u;
  v11 = 0u;
  v8[0] = 0;
  v8[1] = 0;
  v9 = 0;
  if (re::BindNode::processBindingPath(a1, a3, (re::BindNode **)&v10, (uint64_t)v8))
  {
    if ((_QWORD)v10)
      v6 = &v10;
    else
      v6 = (__int128 *)v11;
    (*(void (**)(__int128 *, uint64_t, _QWORD *))(*(_QWORD *)v6 + 80))(v6, a2, v8);
  }
  else
  {
    *(_QWORD *)(a4 + 40) = 0;
    *(_OWORD *)a4 = 0u;
    *(_OWORD *)(a4 + 16) = 0u;
    *(_DWORD *)(a4 + 32) = 0;
  }
  return re::BindNode::deinit((re::BindNode *)&v10);
}

uint64_t re::DynamicArray<re::BindPoint::BindPointData>::deinit(uint64_t a1)
{
  uint64_t result;
  re::BindPoint::BindPointData *v3;
  uint64_t v4;
  uint64_t v5;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(re::BindPoint::BindPointData **)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 32 * v4;
        do
        {
          re::BindPoint::BindPointData::deinit(v3);
          v3 = (re::BindPoint::BindPointData *)((char *)v3 + 32);
          v5 -= 32;
        }
        while (v5);
        result = *(_QWORD *)a1;
        v3 = *(re::BindPoint::BindPointData **)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, re::BindPoint::BindPointData *))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

void re::BindPoint::addToBindPointStack(re::BindPoint *this, const re::BindPoint *a2)
{
  _anonymous_namespace_ *v3;
  uint64_t v4;
  unint64_t v5;
  re::BindPoint::BindPointData *v6;
  uint64_t v7;

  v3 = (re::BindPoint *)((char *)this + 8);
  v4 = *((_QWORD *)a2 + 3);
  v5 = v4 + *((_QWORD *)this + 3);
  if (*((_QWORD *)this + 2) < v5)
  {
    re::DynamicArray<re::BindPoint::BindPointData>::setCapacity((_QWORD *)this + 1, v5);
    v4 = *((_QWORD *)a2 + 3);
  }
  if (v4)
  {
    v6 = (re::BindPoint::BindPointData *)*((_QWORD *)a2 + 5);
    v7 = 32 * v4;
    do
    {
      re::DynamicArray<re::BindPoint::BindPointData>::add(v3, v6);
      v6 = (re::BindPoint::BindPointData *)((char *)v6 + 32);
      v7 -= 32;
    }
    while (v7);
  }
}

void re::DynamicArray<re::BindPoint::BindPointData>::add(_anonymous_namespace_ *this, re::BindPoint::BindPointData *a2)
{
  unint64_t v4;
  re::BindPoint::BindPointData *v5;

  v4 = *((_QWORD *)this + 2);
  if (v4 >= *((_QWORD *)this + 1))
  {
    re::DynamicArray<re::BindPoint::BindPointData>::growCapacity(this, v4 + 1);
    v4 = *((_QWORD *)this + 2);
  }
  v5 = (re::BindPoint::BindPointData *)(*((_QWORD *)this + 4) + 32 * v4);
  *(_OWORD *)v5 = 0u;
  *((_OWORD *)v5 + 1) = 0u;
  re::BindPoint::BindPointData::copy(v5, a2);
  ++*((_QWORD *)this + 2);
  ++*((_DWORD *)this + 6);
}

void re::BindPoint::addToBindPointStack(_QWORD *a1, uint64_t a2)
{
  _anonymous_namespace_ *v3;
  uint64_t v4;
  unint64_t v5;
  _OWORD *v6;
  uint64_t v7;

  v3 = (_anonymous_namespace_ *)(a1 + 1);
  v4 = *(_QWORD *)(a2 + 24);
  v5 = v4 + a1[3];
  if (a1[2] < v5)
  {
    re::DynamicArray<re::BindPoint::BindPointData>::setCapacity(a1 + 1, v5);
    v4 = *(_QWORD *)(a2 + 24);
  }
  if (v4)
  {
    v6 = *(_OWORD **)(a2 + 40);
    v7 = 32 * v4;
    do
    {
      re::DynamicArray<re::BindPoint::BindPointData>::add(v3, v6);
      v6 += 2;
      v7 -= 32;
    }
    while (v7);
  }
}

BOOL re::BindPoint::operator==(re::BindPoint *a1, re::BindPoint *a2)
{
  uint64_t v4;
  uint64_t v5;

  v4 = re::BindPoint::baseValueUntyped(a1);
  if (v4 == re::BindPoint::baseValueUntyped(a2)
    && (v5 = re::BindPoint::overrideValueUntyped(a1), v5 == re::BindPoint::overrideValueUntyped(a2)))
  {
    return *(_QWORD *)a1 == *(_QWORD *)a2;
  }
  else
  {
    return 0;
  }
}

uint64_t re::BindPoint::baseValueUntyped(re::BindPoint *this)
{
  uint64_t v1;
  unint64_t v3;
  _QWORD *v4;
  size_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD v11[2];
  int v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  uint64_t v17;
  __int16 v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  v1 = *((_QWORD *)this + 3);
  if (!v1)
    return 0;
  MEMORY[0x24BDAC7A8](this);
  v4 = (_QWORD *)((char *)v11 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0));
  if (v3 >= 0x200)
    v5 = 512;
  else
    v5 = v3;
  bzero((char *)v11 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0), v5);
  v6 = 0;
  v7 = 0;
  v8 = *((_QWORD *)this + 3);
  do
  {
    if (v8 == v7)
    {
      v11[1] = 0;
      v23 = 0u;
      v24 = 0u;
      v21 = 0u;
      v22 = 0u;
      v20 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v12 = 136315906;
      v13 = "operator[]";
      v14 = 1024;
      v15 = 797;
      v16 = 2048;
      v17 = v8;
      v18 = 2048;
      v19 = v8;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    v9 = (_QWORD *)(*((_QWORD *)this + 5) + v6);
    if (!*v9)
      v9 = (_QWORD *)v9[2];
    v4[v7++] = v9;
    v6 += 32;
  }
  while (v1 != v7);
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD *, uint64_t))(*(_QWORD *)*v4 + 88))(*v4, 0, v4 + 1, v1 - 1);
}

uint64_t re::BindPoint::overrideValueUntyped(re::BindPoint *this)
{
  uint64_t v1;
  unint64_t v3;
  _QWORD *v4;
  size_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD v11[2];
  int v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  uint64_t v17;
  __int16 v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  v1 = *((_QWORD *)this + 3);
  if (!v1)
    return 0;
  MEMORY[0x24BDAC7A8](this);
  v4 = (_QWORD *)((char *)v11 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0));
  if (v3 >= 0x200)
    v5 = 512;
  else
    v5 = v3;
  bzero((char *)v11 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0), v5);
  v6 = 0;
  v7 = 0;
  v8 = *((_QWORD *)this + 3);
  do
  {
    if (v8 == v7)
    {
      v11[1] = 0;
      v23 = 0u;
      v24 = 0u;
      v21 = 0u;
      v22 = 0u;
      v20 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v12 = 136315906;
      v13 = "operator[]";
      v14 = 1024;
      v15 = 797;
      v16 = 2048;
      v17 = v8;
      v18 = 2048;
      v19 = v8;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    v9 = (_QWORD *)(*((_QWORD *)this + 5) + v6);
    if (!*v9)
      v9 = (_QWORD *)v9[2];
    v4[v7++] = v9;
    v6 += 32;
  }
  while (v1 != v7);
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD *, uint64_t))(*(_QWORD *)*v4 + 120))(*v4, 0, v4 + 1, v1 - 1);
}

uint64_t re::BindPoint::isWeak(re::BindPoint *this)
{
  uint64_t v1;
  unint64_t v3;
  _QWORD *v4;
  size_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD v11[2];
  int v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  uint64_t v17;
  __int16 v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  v1 = *((_QWORD *)this + 3);
  if (!v1)
    return 0;
  MEMORY[0x24BDAC7A8](this);
  v4 = (_QWORD *)((char *)v11 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0));
  if (v3 >= 0x200)
    v5 = 512;
  else
    v5 = v3;
  bzero((char *)v11 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0), v5);
  v6 = 0;
  v7 = 0;
  v8 = *((_QWORD *)this + 3);
  do
  {
    if (v8 == v7)
    {
      v11[1] = 0;
      v23 = 0u;
      v24 = 0u;
      v21 = 0u;
      v22 = 0u;
      v20 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v12 = 136315906;
      v13 = "operator[]";
      v14 = 1024;
      v15 = 797;
      v16 = 2048;
      v17 = v8;
      v18 = 2048;
      v19 = v8;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    v9 = (_QWORD *)(*((_QWORD *)this + 5) + v6);
    if (!*v9)
      v9 = (_QWORD *)v9[2];
    v4[v7++] = v9;
    v6 += 32;
  }
  while (v1 != v7);
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD *, uint64_t))(*(_QWORD *)*v4 + 56))(*v4, 0, v4 + 1, v1 - 1);
}

uint64_t re::BindPoint::isAlive(re::BindPoint *this)
{
  uint64_t v1;
  unint64_t v3;
  _QWORD *v4;
  size_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD v11[2];
  int v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  uint64_t v17;
  __int16 v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  v1 = *((_QWORD *)this + 3);
  if (!v1)
    return 0;
  MEMORY[0x24BDAC7A8](this);
  v4 = (_QWORD *)((char *)v11 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0));
  if (v3 >= 0x200)
    v5 = 512;
  else
    v5 = v3;
  bzero((char *)v11 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0), v5);
  v6 = 0;
  v7 = 0;
  v8 = *((_QWORD *)this + 3);
  do
  {
    if (v8 == v7)
    {
      v11[1] = 0;
      v23 = 0u;
      v24 = 0u;
      v21 = 0u;
      v22 = 0u;
      v20 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v12 = 136315906;
      v13 = "operator[]";
      v14 = 1024;
      v15 = 797;
      v16 = 2048;
      v17 = v8;
      v18 = 2048;
      v19 = v8;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    v9 = (_QWORD *)(*((_QWORD *)this + 5) + v6);
    if (!*v9)
      v9 = (_QWORD *)v9[2];
    v4[v7++] = v9;
    v6 += 32;
  }
  while (v1 != v7);
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD *, uint64_t))(*(_QWORD *)*v4 + 64))(*v4, 0, v4 + 1, v1 - 1);
}

uint64_t re::BindPoint::makeAlive(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  size_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD v10[2];
  int v11;
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  uint64_t v16;
  __int16 v17;
  uint64_t v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  v1 = *(_QWORD *)(this + 24);
  if (v1)
  {
    v2 = this;
    MEMORY[0x24BDAC7A8](this);
    v4 = (_QWORD *)((char *)v10 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0));
    if (v3 >= 0x200)
      v5 = 512;
    else
      v5 = v3;
    bzero((char *)v10 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0), v5);
    v6 = 0;
    v7 = 0;
    v8 = *(_QWORD *)(v2 + 24);
    do
    {
      if (v8 == v7)
      {
        v10[1] = 0;
        v22 = 0u;
        v23 = 0u;
        v20 = 0u;
        v21 = 0u;
        v19 = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        v11 = 136315906;
        v12 = "operator[]";
        v13 = 1024;
        v14 = 797;
        v15 = 2048;
        v16 = v8;
        v17 = 2048;
        v18 = v8;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      v9 = (_QWORD *)(*(_QWORD *)(v2 + 40) + v6);
      if (!*v9)
        v9 = (_QWORD *)v9[2];
      v4[v7++] = v9;
      v6 += 32;
    }
    while (v1 != v7);
    return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD *, uint64_t))(*(_QWORD *)*v4 + 72))(*v4, 0, v4 + 1, v1 - 1);
  }
  return this;
}

uint64_t re::BindPoint::targetIdentifier(re::BindPoint *this)
{
  uint64_t v1;
  unint64_t v3;
  _QWORD *v4;
  size_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD v11[2];
  int v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  uint64_t v17;
  __int16 v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  v1 = *((_QWORD *)this + 3);
  if (!v1)
    return 0;
  MEMORY[0x24BDAC7A8](this);
  v4 = (_QWORD *)((char *)v11 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0));
  if (v3 >= 0x200)
    v5 = 512;
  else
    v5 = v3;
  bzero((char *)v11 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0), v5);
  v6 = 0;
  v7 = 0;
  v8 = *((_QWORD *)this + 3);
  do
  {
    if (v8 == v7)
    {
      v11[1] = 0;
      v23 = 0u;
      v24 = 0u;
      v21 = 0u;
      v22 = 0u;
      v20 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v12 = 136315906;
      v13 = "operator[]";
      v14 = 1024;
      v15 = 797;
      v16 = 2048;
      v17 = v8;
      v18 = 2048;
      v19 = v8;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    v9 = (_QWORD *)(*((_QWORD *)this + 5) + v6);
    if (!*v9)
      v9 = (_QWORD *)v9[2];
    v4[v7++] = v9;
    v6 += 32;
  }
  while (v1 != v7);
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD *, uint64_t))(*(_QWORD *)*v4 + 80))(*v4, 0, v4 + 1, v1 - 1);
}

uint64_t re::BindPoint::boundOwner(re::BindPoint *this)
{
  uint64_t v1;
  unint64_t v3;
  _QWORD *v4;
  size_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD v11[2];
  int v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  uint64_t v17;
  __int16 v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  v1 = *((_QWORD *)this + 3);
  if (!v1)
    return 0;
  MEMORY[0x24BDAC7A8](this);
  v4 = (_QWORD *)((char *)v11 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0));
  if (v3 >= 0x200)
    v5 = 512;
  else
    v5 = v3;
  bzero((char *)v11 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0), v5);
  v6 = 0;
  v7 = 0;
  v8 = *((_QWORD *)this + 3);
  do
  {
    if (v8 == v7)
    {
      v11[1] = 0;
      v23 = 0u;
      v24 = 0u;
      v21 = 0u;
      v22 = 0u;
      v20 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v12 = 136315906;
      v13 = "operator[]";
      v14 = 1024;
      v15 = 797;
      v16 = 2048;
      v17 = v8;
      v18 = 2048;
      v19 = v8;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    v9 = (_QWORD *)(*((_QWORD *)this + 5) + v6);
    if (!*v9)
      v9 = (_QWORD *)v9[2];
    v4[v7++] = v9;
    v6 += 32;
  }
  while (v1 != v7);
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD *, uint64_t))(*(_QWORD *)*v4 + 136))(*v4, 0, v4 + 1, v1 - 1);
}

uint64_t re::BindPoint::supportsOverrideValue(re::BindPoint *this)
{
  uint64_t v1;
  unint64_t v3;
  _QWORD *v4;
  size_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD v11[2];
  int v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  uint64_t v17;
  __int16 v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  v1 = *((_QWORD *)this + 3);
  if (!v1)
    return 0;
  MEMORY[0x24BDAC7A8](this);
  v4 = (_QWORD *)((char *)v11 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0));
  if (v3 >= 0x200)
    v5 = 512;
  else
    v5 = v3;
  bzero((char *)v11 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0), v5);
  v6 = 0;
  v7 = 0;
  v8 = *((_QWORD *)this + 3);
  do
  {
    if (v8 == v7)
    {
      v11[1] = 0;
      v23 = 0u;
      v24 = 0u;
      v21 = 0u;
      v22 = 0u;
      v20 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v12 = 136315906;
      v13 = "operator[]";
      v14 = 1024;
      v15 = 797;
      v16 = 2048;
      v17 = v8;
      v18 = 2048;
      v19 = v8;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    v9 = (_QWORD *)(*((_QWORD *)this + 5) + v6);
    if (!*v9)
      v9 = (_QWORD *)v9[2];
    v4[v7++] = v9;
    v6 += 32;
  }
  while (v1 != v7);
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD *, uint64_t))(*(_QWORD *)*v4 + 96))(*v4, 0, v4 + 1, v1 - 1);
}

uint64_t re::BindPoint::isOverridden(re::BindPoint *this)
{
  uint64_t v1;
  unint64_t v3;
  _QWORD *v4;
  size_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD v11[2];
  int v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  uint64_t v17;
  __int16 v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  v1 = *((_QWORD *)this + 3);
  if (!v1)
    return 0;
  MEMORY[0x24BDAC7A8](this);
  v4 = (_QWORD *)((char *)v11 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0));
  if (v3 >= 0x200)
    v5 = 512;
  else
    v5 = v3;
  bzero((char *)v11 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0), v5);
  v6 = 0;
  v7 = 0;
  v8 = *((_QWORD *)this + 3);
  do
  {
    if (v8 == v7)
    {
      v11[1] = 0;
      v23 = 0u;
      v24 = 0u;
      v21 = 0u;
      v22 = 0u;
      v20 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v12 = 136315906;
      v13 = "operator[]";
      v14 = 1024;
      v15 = 797;
      v16 = 2048;
      v17 = v8;
      v18 = 2048;
      v19 = v8;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    v9 = (_QWORD *)(*((_QWORD *)this + 5) + v6);
    if (!*v9)
      v9 = (_QWORD *)v9[2];
    v4[v7++] = v9;
    v6 += 32;
  }
  while (v1 != v7);
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD *, uint64_t))(*(_QWORD *)*v4 + 104))(*v4, 0, v4 + 1, v1 - 1);
}

uint64_t re::BindPoint::valueUntyped(re::BindPoint *this)
{
  if (re::BindPoint::isOverridden(this))
    return re::BindPoint::overrideValueUntyped(this);
  else
    return re::BindPoint::baseValueUntyped(this);
}

uint64_t re::BindPoint::setIsOverridden(uint64_t this, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  unint64_t v5;
  _QWORD *v6;
  size_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD v12[2];
  int v13;
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  uint64_t v18;
  __int16 v19;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(this + 24);
  if (v2)
  {
    v4 = this;
    MEMORY[0x24BDAC7A8](this);
    v6 = (_QWORD *)((char *)v12 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0));
    if (v5 >= 0x200)
      v7 = 512;
    else
      v7 = v5;
    bzero((char *)v12 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0), v7);
    v8 = 0;
    v9 = 0;
    v10 = *(_QWORD *)(v4 + 24);
    do
    {
      if (v10 == v9)
      {
        v12[1] = 0;
        v24 = 0u;
        v25 = 0u;
        v22 = 0u;
        v23 = 0u;
        v21 = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        v13 = 136315906;
        v14 = "operator[]";
        v15 = 1024;
        v16 = 797;
        v17 = 2048;
        v18 = v10;
        v19 = 2048;
        v20 = v10;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      v11 = (_QWORD *)(*(_QWORD *)(v4 + 40) + v8);
      if (!*v11)
        v11 = (_QWORD *)v11[2];
      v6[v9++] = v11;
      v8 += 32;
    }
    while (v2 != v9);
    return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)*v6 + 112))(*v6, 0, v6 + 1, v2 - 1, a2);
  }
  return this;
}

uint64_t re::BindPoint::markAsWritten(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  size_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD v10[2];
  int v11;
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  uint64_t v16;
  __int16 v17;
  uint64_t v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  v1 = *(_QWORD *)(this + 24);
  if (v1)
  {
    v2 = this;
    MEMORY[0x24BDAC7A8](this);
    v4 = (_QWORD *)((char *)v10 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0));
    if (v3 >= 0x200)
      v5 = 512;
    else
      v5 = v3;
    bzero((char *)v10 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0), v5);
    v6 = 0;
    v7 = 0;
    v8 = *(_QWORD *)(v2 + 24);
    do
    {
      if (v8 == v7)
      {
        v10[1] = 0;
        v22 = 0u;
        v23 = 0u;
        v20 = 0u;
        v21 = 0u;
        v19 = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        v11 = 136315906;
        v12 = "operator[]";
        v13 = 1024;
        v14 = 797;
        v15 = 2048;
        v16 = v8;
        v17 = 2048;
        v18 = v8;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      v9 = (_QWORD *)(*(_QWORD *)(v2 + 40) + v6);
      if (!*v9)
        v9 = (_QWORD *)v9[2];
      v4[v7++] = v9;
      v6 += 32;
    }
    while (v1 != v7);
    return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD *, uint64_t))(*(_QWORD *)*v4 + 128))(*v4, 0, v4 + 1, v1 - 1);
  }
  return this;
}

void re::BindPoint::BindPointData::copy(re::BindPoint::BindPointData *this, const re::BindPoint::BindPointData *a2)
{
  re::BindPoint::BindPointData *v3;
  __n128 v4;
  uint64_t v5;
  const re::BindPoint::BindPointData *v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;

  v3 = this;
  v4.n128_f64[0] = re::BindPoint::BindPointData::deinit(this);
  v5 = *(_QWORD *)a2;
  if (!*(_QWORD *)a2)
  {
    v6 = (const re::BindPoint::BindPointData *)*((_QWORD *)a2 + 2);
    if (!v6)
      return;
    v7 = *((_QWORD *)a2 + 1);
    v8 = (_QWORD *)(*(uint64_t (**)(const re::BindPoint::BindPointData *, double))(*(_QWORD *)v6 + 16))(v6, v4.n128_f64[0]);
    v9 = (*(uint64_t (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)v7 + 32))(v7, *v8, v8[1]);
    *(_QWORD *)v3 = 0;
    *((_QWORD *)v3 + 1) = v7;
    *((_QWORD *)v3 + 2) = v9;
    v5 = *(_QWORD *)v6;
    a2 = v6;
    v3 = (re::BindPoint::BindPointData *)v9;
  }
  (*(void (**)(const re::BindPoint::BindPointData *, re::BindPoint::BindPointData *, __n128))(v5 + 24))(a2, v3, v4);
}

double re::BindPoint::BindPointData::move(re::BindPoint::BindPointData *a1, _OWORD *a2)
{
  double result;
  __int128 v5;

  result = re::BindPoint::BindPointData::deinit(a1);
  if (*(_QWORD *)a2)
  {
    (*(void (**)(_OWORD *, re::BindPoint::BindPointData *, double))(*(_QWORD *)a2 + 32))(a2, a1, result);
  }
  else if (*((_QWORD *)a2 + 2))
  {
    v5 = a2[1];
    *(_OWORD *)a1 = *a2;
    *((_OWORD *)a1 + 1) = v5;
    result = 0.0;
    *a2 = 0u;
    a2[1] = 0u;
  }
  return result;
}

uint64_t re::makeBindNode@<X0>(re *this@<X0>, const re::IntrospectionBase *a2@<X1>, uint64_t a3@<X8>)
{
  _OWORD v5[2];
  int v6;
  uint64_t v7;
  _QWORD v8[3];
  char v9;

  v8[0] = this;
  v8[1] = 0;
  v8[2] = a2;
  v9 = 0;
  v7 = 0;
  memset(v5, 0, sizeof(v5));
  v6 = 0;
  re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)v5 + 8);
  return re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)v5 + 8);
}

double `anonymous namespace'::makeBindNodeInternal@<D0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  BOOL v4;
  uint64_t v7;
  __int128 v8;
  double result;

  if (*(_QWORD *)a1)
    v4 = 0;
  else
    v4 = *(_BYTE *)(a1 + 24) == 0;
  if (v4)
  {
    result = 0.0;
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
  }
  else
  {
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_QWORD *)v7 = &off_24ED3FA88;
    v8 = *(_OWORD *)(a1 + 16);
    *(_OWORD *)(v7 + 8) = *(_OWORD *)a1;
    *(_OWORD *)(v7 + 24) = v8;
    re::BindPoint::BindPoint(v7 + 40, a2);
    *(_QWORD *)(a3 + 16) = v7;
  }
  return result;
}

double re::makeRelativeBindNode@<D0>(_anonymous_namespace_ *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6;
  __int128 v8;
  __int128 v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v8 = 0u;
  v9 = 0u;
  re::DynamicArray<re::BindPoint::BindPointData>::add((_anonymous_namespace_ *)(a2 + 1), &v8);
  re::BindPoint::BindPointData::deinit((re::BindPoint::BindPointData *)&v8);
  v6 = a2[5] + 32 * a2[3];
  *(_QWORD *)(v6 - 32) = &off_24ED40860;
  *(_QWORD *)(v6 - 24) = a1;
  *(_QWORD *)&v9 = 0;
  v8 = (unint64_t)a1;
  BYTE8(v9) = 0;
}

void re::makeBindPoint(re *this@<X0>, const re::IntrospectionBase *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _OWORD v10[2];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  if (this && a2)
  {
    if (*((_DWORD *)this + 4) == 8 && (v7 = *((unsigned int *)this + 14), (_DWORD)v7))
    {
      v8 = *((_QWORD *)this + 8);
      while (**(_DWORD **)v8 != 7)
      {
        v8 += 8;
        if (!--v7)
          goto LABEL_8;
      }
      (*(void (**)(const re::IntrospectionBase *, re *))(*(_QWORD *)v8 + 8))(a2, this);
    }
    else
    {
LABEL_8:
      *(_QWORD *)a3 = this;
      *(_QWORD *)(a3 + 40) = 0;
      *(_QWORD *)(a3 + 16) = 0;
      *(_QWORD *)(a3 + 24) = 0;
      *(_DWORD *)(a3 + 32) = 0;
      *(_QWORD *)(a3 + 8) = 0;
      memset(v10, 0, sizeof(v10));
      re::DynamicArray<re::BindPoint::BindPointData>::add((_anonymous_namespace_ *)(a3 + 8), v10);
      re::BindPoint::BindPointData::deinit((re::BindPoint::BindPointData *)v10);
      v9 = *(_QWORD *)(a3 + 40) + 32 * *(_QWORD *)(a3 + 24);
      *(_QWORD *)(v9 - 32) = &off_24ED3FE60;
      *(_QWORD *)(v9 - 24) = this;
      *(_QWORD *)(v9 - 16) = a2;
    }
  }
  else
  {
    *(_QWORD *)(a3 + 40) = 0;
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_DWORD *)(a3 + 32) = 0;
  }
}

double re::makeBindPoint@<D0>(re *this@<X0>, const re::IntrospectionBase *a2@<X1>, BOOL *a3@<X2>, void *a4@<X3>, uint64_t a5@<X8>)
{
  double result;
  uint64_t v11;
  _OWORD v12[2];
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  if (this && a2 && a3 && a4)
  {
    *(_QWORD *)a5 = this;
    *(_QWORD *)(a5 + 40) = 0;
    *(_QWORD *)(a5 + 16) = 0;
    *(_QWORD *)(a5 + 24) = 0;
    *(_DWORD *)(a5 + 32) = 0;
    *(_QWORD *)(a5 + 8) = 0;
    memset(v12, 0, sizeof(v12));
    re::DynamicArray<re::BindPoint::BindPointData>::add((_anonymous_namespace_ *)(a5 + 8), v12);
    result = re::BindPoint::BindPointData::deinit((re::BindPoint::BindPointData *)v12);
    v11 = *(_QWORD *)(a5 + 40) + 32 * *(_QWORD *)(a5 + 24);
    *(_QWORD *)(v11 - 32) = &off_24ED40930;
    *(_QWORD *)(v11 - 24) = a3;
    *(_QWORD *)(v11 - 16) = a4;
    *(_QWORD *)(v11 - 8) = a2;
  }
  else
  {
    *(_QWORD *)(a5 + 40) = 0;
    result = 0.0;
    *(_OWORD *)a5 = 0u;
    *(_OWORD *)(a5 + 16) = 0u;
    *(_DWORD *)(a5 + 32) = 0;
  }
  return result;
}

void re::makeBindPoint(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _anonymous_namespace_ *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _OWORD v11[3];
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  if (a2)
  {
    *(_QWORD *)a1 = a2;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 40) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)(a1 + 24) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    re::BindPoint::addToBindPointStack((_QWORD *)a1, a4);
    if (*(_DWORD *)(a2 + 16) == 8 && (v8 = *(unsigned int *)(a2 + 56), (_DWORD)v8))
    {
      v9 = *(_QWORD *)(a2 + 64);
      while (**(_DWORD **)v9 != 7)
      {
        v9 += 8;
        if (!--v8)
          goto LABEL_7;
      }
      (*(void (**)(_OWORD *__return_ptr, uint64_t, uint64_t))(*(_QWORD *)v9 + 8))(v11, a3, a2);
      re::BindPoint::addToBindPointStack((_QWORD *)a1, (uint64_t)v11);
      re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)v11 + 8);
      re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)v11 + 8);
    }
    else
    {
LABEL_7:
      memset(v11, 0, 32);
      re::DynamicArray<re::BindPoint::BindPointData>::add((_anonymous_namespace_ *)(a1 + 8), v11);
      re::BindPoint::BindPointData::deinit((re::BindPoint::BindPointData *)v11);
      v10 = *(_QWORD *)(a1 + 40) + 32 * *(_QWORD *)(a1 + 24);
      *(_QWORD *)(v10 - 32) = &off_24ED3FE60;
      *(_QWORD *)(v10 - 24) = a2;
      *(_QWORD *)(v10 - 16) = a3;
    }
  }
  else
  {
    *(_QWORD *)(a1 + 40) = 0;
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_DWORD *)(a1 + 32) = 0;
  }
}

void `anonymous namespace'::IntrospectionBindNodeImpl::~IntrospectionBindNodeImpl(_anonymous_namespace_::IntrospectionBindNodeImpl *this)
{
  char *v1;

  v1 = (char *)this + 48;
  re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)this + 48);
  re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)v1);
}

{
  char *v1;

  v1 = (char *)this + 48;
  re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)this + 48);
  re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)v1);
  JUMPOUT(0x2276933B8);
}

const char *re::internal::BindNodeImpl<`anonymous namespace'::IntrospectionBindNodeImpl>::implTypeInfo()
{
  return "X";
}

uint64_t re::internal::BindNodeImpl<`anonymous namespace'::IntrospectionBindNodeImpl>::copyInto(uint64_t a1, uint64_t a2)
{
  __int128 v2;

  *(_QWORD *)a2 = &off_24ED3FA88;
  v2 = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v2;
  *(_QWORD *)(a2 + 40) = *(_QWORD *)(a1 + 40);
  return re::DynamicArray<re::BindPoint::BindPointData>::DynamicArray(a2 + 48, (uint64_t *)(a1 + 48));
}

uint64_t re::internal::BindNodeImpl<`anonymous namespace'::IntrospectionBindNodeImpl>::moveInto(uint64_t a1, uint64_t a2)
{
  __int128 v2;

  *(_QWORD *)a2 = &off_24ED3FA88;
  v2 = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v2;
  return re::BindPoint::BindPoint(a2 + 40, (uint64_t *)(a1 + 40));
}

BOOL re::internal::BindNodeImpl<`anonymous namespace'::IntrospectionBindNodeImpl>::equals(_QWORD *a1, _QWORD *a2)
{
  return (char *)(*(uint64_t (**)(_QWORD *))(*a2 + 16))(a2) == "X"
      && a1[3] == a2[3]
      && a1[2] == a2[2]
      && re::BindPoint::operator==((re::BindPoint *)(a1 + 5), (re::BindPoint *)(a2 + 5));
}

double `anonymous namespace'::IntrospectionBindNodeImpl::nodeForURI@<D0>(_OWORD *a1@<X8>)
{
  double result;

  result = 0.0;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t `anonymous namespace'::IntrospectionBindNodeImpl::relativeNodeForKey@<X0>(uint64_t a1@<X0>, __int128 *a2@<X1>, uint64_t a3@<X8>)
{
  _BYTE v6[32];
  uint64_t v7;
  _BYTE v8[40];
  __int128 v9;

  v9 = *a2;
  v7 = *(_QWORD *)(a1 + 40);
  re::DynamicArray<re::BindPoint::BindPointData>::DynamicArray((uint64_t)v8, (uint64_t *)(a1 + 48));
  re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)v8);
  return re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)v8);
}

void `anonymous namespace'::IntrospectionBindNodeImpl::bindPointForKey(uint64_t a1@<X0>, uint64_t a2@<X1>, const re::IntrospectionBase *a3@<X2>, uint64_t a4@<X8>)
{
  const re::IntrospectionBase *v7;
  uint64_t *v8;
  re *v9;
  NSObject *v10;
  uint64_t v11;
  _anonymous_namespace_ *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;
  _QWORD v18[2];
  uint64_t v19;
  char v20;
  __int128 v21;
  uint8_t buf[48];
  __int128 v23;
  __int128 v24;
  int v25;
  uint64_t v26;
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  v8 = (uint64_t *)(a1 + 8);
  v7 = *(const re::IntrospectionBase **)(a1 + 8);
  if (!v7 && !*(_BYTE *)(a1 + 32))
    goto LABEL_18;
  v21 = *(_OWORD *)a3;
  if (*((_QWORD *)&v21 + 1))
  {
    v26 = 0;
    v23 = (unint64_t)a2;
    v24 = 0uLL;
    v25 = 0;
    re::BindPoint::addToBindPointStack((re::BindPoint *)&v23, (const re::BindPoint *)(a1 + 40));
    if (v18[0] || v20)
    {
      if (!v18[1])
      {
        if (v19)
        {
          if (a2)
            v16 = a2;
          else
            v16 = v18[0];
          re::makeBindPoint((uint64_t)buf, v16, v19, (uint64_t)&v23);
          *(_QWORD *)&v23 = *(_QWORD *)buf;
          re::DynamicArray<re::RigDataValue>::operator=((uint64_t)&v23 + 8, (uint64_t)&buf[8]);
          re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)&buf[8]);
          re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)&buf[8]);
        }
        v17 = v24;
        *(_OWORD *)a4 = v23;
        *(_OWORD *)(a4 + 16) = v17;
        *((_QWORD *)&v23 + 1) = 0;
        v24 = 0uLL;
        *(_QWORD *)(a4 + 40) = v26;
        v26 = 0;
        ++v25;
        *(_DWORD *)(a4 + 32) = 1;
        goto LABEL_21;
      }
    }
    else
    {
      v10 = *re::foundationBindingLogObjects(v9);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)&buf[4] = v21;
        _os_log_impl(&dword_224FE9000, v10, OS_LOG_TYPE_DEFAULT, "Invalid binding key: %s.", buf, 0xCu);
      }
    }
    *(_QWORD *)(a4 + 40) = 0;
    *(_OWORD *)a4 = 0u;
    *(_OWORD *)(a4 + 16) = 0u;
    *(_DWORD *)(a4 + 32) = 0;
LABEL_21:
    re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)&v23 + 8);
LABEL_22:
    re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)&v23 + 8);
    return;
  }
  {
LABEL_18:
    *(_QWORD *)(a4 + 40) = 0;
    *(_OWORD *)a4 = 0u;
    *(_OWORD *)(a4 + 16) = 0u;
    *(_DWORD *)(a4 + 32) = 0;
    return;
  }
  v11 = *(_QWORD *)(a1 + 24);
  if (v11)
  {
    if (a2 || (a2 = *v8) != 0)
    {
      *(_QWORD *)a4 = a2;
      *(_QWORD *)(a4 + 8) = 0;
      *(_QWORD *)(a4 + 40) = 0;
      *(_QWORD *)(a4 + 16) = 0;
      *(_QWORD *)(a4 + 24) = 0;
      *(_DWORD *)(a4 + 32) = 0;
      re::BindPoint::addToBindPointStack((re::BindPoint *)a4, (const re::BindPoint *)(a1 + 40));
      if (*(_DWORD *)(a2 + 16) != 8 || (v13 = *(unsigned int *)(a2 + 56), !(_DWORD)v13))
      {
LABEL_17:
        v23 = 0u;
        v24 = 0u;
        re::DynamicArray<re::BindPoint::BindPointData>::add((_anonymous_namespace_ *)(a4 + 8), &v23);
        re::BindPoint::BindPointData::deinit((re::BindPoint::BindPointData *)&v23);
        v15 = *(_QWORD *)(a4 + 40) + 32 * *(_QWORD *)(a4 + 24);
        *(_QWORD *)(v15 - 32) = &off_24ED3FE60;
        *(_QWORD *)(v15 - 24) = a2;
        *(_QWORD *)(v15 - 16) = v11;
        return;
      }
      v14 = *(_QWORD *)(a2 + 64);
      while (**(_DWORD **)v14 != 7)
      {
        v14 += 8;
        if (!--v13)
          goto LABEL_17;
      }
      (*(void (**)(__int128 *__return_ptr, uint64_t, uint64_t))(*(_QWORD *)v14 + 8))(&v23, v11, a2);
      re::BindPoint::addToBindPointStack((_QWORD *)a4, (uint64_t)&v23);
      re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)&v23 + 8);
      goto LABEL_22;
    }
    goto LABEL_18;
  }
  if (!a2)
    a2 = *v8;
  *(_QWORD *)(a4 + 40) = 0;
  *(_QWORD *)a4 = a2;
  *(_QWORD *)(a4 + 8) = 0;
  *(_QWORD *)(a4 + 16) = 0;
  *(_QWORD *)(a4 + 24) = 0;
  *(_DWORD *)(a4 + 32) = 0;
  re::BindPoint::addToBindPointStack((re::BindPoint *)a4, (const re::BindPoint *)(a1 + 40));
}

void `anonymous namespace'::walk(uint64_t a1, uint64_t a2, _anonymous_namespace_ *a3, uint64_t a4, _QWORD *a5)
{
  double v9;
  uint64_t v10;
  uint64_t v11;
  const char *v12;
  size_t v13;
  char *v15;
  const re::IntrospectionBase *v16;
  uint64_t v17;
  _BOOL8 isCompatibleType;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _anonymous_namespace_ *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  NSObject *v28;
  const char *v29;
  uint64_t v30;
  uint8_t buf[16];
  __int128 v32;
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  if (*(_BYTE *)(a2 + 24))
  {
    *(_OWORD *)buf = 0u;
    v32 = 0u;
    re::DynamicArray<re::BindPoint::BindPointData>::add((_anonymous_namespace_ *)(a5 + 1), buf);
    v9 = re::BindPoint::BindPointData::deinit((re::BindPoint::BindPointData *)buf);
    v10 = a5[5] + 32 * a5[3];
    *(_QWORD *)(v10 - 32) = 0;
    *(_QWORD *)v11 = &off_24ED3FB20;
    *(_QWORD *)(v11 + 8) = a3;
    v12 = *(const char **)a4;
    v13 = *(_QWORD *)(a4 + 8);
    *(_QWORD *)(v11 + 16) = 0;
    *(_QWORD *)(v11 + 24) = &str_110;
    *(_OWORD *)(v11 + 57) = 0u;
    *(_OWORD *)(v11 + 32) = 0u;
    *(_OWORD *)(v11 + 48) = 0u;
    *(_QWORD *)(v11 + 120) = 0;
    *(_OWORD *)(v11 + 80) = 0u;
    *(_OWORD *)(v11 + 96) = 0u;
    *(_DWORD *)(v11 + 112) = 0;
    *(_QWORD *)(v10 - 16) = v11;
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_BYTE *)(a1 + 24) = 1;
    return;
  }
  if (!*(_QWORD *)(a2 + 8))
  {
    switch(*(_DWORD *)(*(_QWORD *)a2 + 16))
    {
      case 0:
      case 5:
      case 6:
      case 9:
      case 0xA:
      case 0xB:
        goto LABEL_14;
      case 1:
        return;
      case 2:
        return;
      case 3:
        return;
      case 4:
        return;
      case 7:
        return;
      case 8:
        return;
      case 0xD:
        return;
      default:
        re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Unexpected introspection type.", "!\"Unreachable code\"", "walk", 919);
        _os_crash();
        __break(1u);
        JUMPOUT(0x22542F588);
    }
  }
  v30 = 0;
  v15 = *(char **)a4;
  if (**(_BYTE **)a4 == 45 || (v15 = (char *)sscanf(v15, "%zu", &v30), (_DWORD)v15 != 1))
  {
    v28 = *re::foundationBindingLogObjects((re *)v15);
    if (!os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
    {
LABEL_14:
      *(_QWORD *)a1 = 0;
      *(_QWORD *)(a1 + 8) = 0;
      *(_BYTE *)(a1 + 24) = 0;
      *(_QWORD *)(a1 + 16) = 0;
      return;
    }
    *(_WORD *)buf = 0;
    v29 = "Invalid binding key: Array index expected.";
LABEL_12:
    _os_log_impl(&dword_224FE9000, v28, OS_LOG_TYPE_DEFAULT, v29, buf, 2u);
    goto LABEL_14;
  }
  v17 = *(_QWORD *)(*(_QWORD *)(a2 + 8) + 16);
  if (!isCompatibleType)
  {
    v28 = *re::foundationBindingLogObjects((re *)isCompatibleType);
    if (!os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      goto LABEL_14;
    *(_WORD *)buf = 0;
    v29 = "Invalid binding key: Array type does not match expected type.";
    goto LABEL_12;
  }
  if (*(_QWORD *)(a2 + 16))
  {
    v19 = *(_QWORD *)a2;
    v20 = *(_QWORD *)(a2 + 16);
    *(_OWORD *)buf = 0u;
    v32 = 0u;
    re::DynamicArray<re::BindPoint::BindPointData>::add((_anonymous_namespace_ *)(a5 + 1), buf);
    re::BindPoint::BindPointData::deinit((re::BindPoint::BindPointData *)buf);
    v21 = a5[5] + 32 * a5[3];
    *(_QWORD *)(v21 - 32) = &off_24ED3FE60;
    *(_QWORD *)(v21 - 24) = v19;
    *(_QWORD *)(v21 - 16) = v20;
    v23 = *(_QWORD *)(a2 + 8);
    *(_OWORD *)buf = 0u;
    v32 = 0u;
    re::DynamicArray<re::BindPoint::BindPointData>::add((_anonymous_namespace_ *)(a5 + 1), buf);
    re::BindPoint::BindPointData::deinit((re::BindPoint::BindPointData *)buf);
    v24 = a5[5] + 32 * a5[3];
    *(_QWORD *)(v24 - 32) = &off_24ED3FBF0;
    *(_QWORD *)(v24 - 24) = v23;
  }
  v25 = v30;
  *(_OWORD *)buf = 0u;
  v32 = 0u;
  re::DynamicArray<re::BindPoint::BindPointData>::add((_anonymous_namespace_ *)(a5 + 1), buf);
  re::BindPoint::BindPointData::deinit((re::BindPoint::BindPointData *)buf);
  v26 = a5[5] + 32 * a5[3];
  *(_QWORD *)(v26 - 32) = &off_24ED3FCC0;
  *(_QWORD *)(v26 - 24) = v25;
  v27 = *(_QWORD *)(v17 + 48);
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = v27;
  *(_BYTE *)(a1 + 24) = 0;
}

void `anonymous namespace'::walkCStyleArray(re *a1, _QWORD *a2, uint64_t a3, char *a4, _QWORD *a5)
{
  re *v5;
  uint64_t v9;
  NSObject *v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint8_t buf[16];
  __int128 v21;
  uint64_t v22;

  v5 = a1;
  v22 = *MEMORY[0x24BDAC8D0];
  v19 = 0;
  if (*a4 == 45 || (a1 = (re *)sscanf(a4, "%zu", &v19), (_DWORD)a1 != 1))
  {
    v10 = *re::foundationBindingLogObjects(a1);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      v11 = "Invalid binding key: Array index expected.";
      goto LABEL_10;
    }
LABEL_11:
    *(_QWORD *)v5 = 0;
    *((_QWORD *)v5 + 1) = 0;
    *((_BYTE *)v5 + 24) = 0;
    *((_QWORD *)v5 + 2) = 0;
    return;
  }
  v9 = *a2;
  if (v19 >= *(int *)(*a2 + 64))
  {
    v10 = *re::foundationBindingLogObjects(a1);
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      goto LABEL_11;
    *(_WORD *)buf = 0;
    v11 = "Invalid binding key: Array index out of range.";
    goto LABEL_10;
  }
  if (a3 && *(_QWORD *)(v9 + 48) != a3)
  {
    v10 = *re::foundationBindingLogObjects(a1);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      v11 = "Invalid binding key: Array type does not match expected type.";
LABEL_10:
      _os_log_impl(&dword_224FE9000, v10, OS_LOG_TYPE_DEFAULT, v11, buf, 2u);
      goto LABEL_11;
    }
    goto LABEL_11;
  }
  v12 = a2[2];
  if (v12)
  {
    v13 = *(_QWORD *)(v9 + 48);
    v14 = v12 + v19 * *(int *)(v13 + 20);
    *(_QWORD *)v5 = v13;
    *((_QWORD *)v5 + 1) = 0;
    *((_QWORD *)v5 + 2) = v14;
  }
  else
  {
    v15 = *(_QWORD *)(v9 + 48);
    v16 = v19 * *(int *)(v15 + 20);
    *(_OWORD *)buf = 0u;
    v21 = 0u;
    re::DynamicArray<re::BindPoint::BindPointData>::add((_anonymous_namespace_ *)(a5 + 1), buf);
    re::BindPoint::BindPointData::deinit((re::BindPoint::BindPointData *)buf);
    v17 = a5[5] + 32 * a5[3];
    *(_QWORD *)(v17 - 32) = &off_24ED3FD90;
    *(_QWORD *)(v17 - 24) = v15;
    *(_QWORD *)(v17 - 16) = v16;
    v18 = *(_QWORD *)(v9 + 48);
    *((_QWORD *)v5 + 1) = 0;
    *((_QWORD *)v5 + 2) = 0;
    *(_QWORD *)v5 = v18;
  }
  *((_BYTE *)v5 + 24) = 0;
}

void `anonymous namespace'::walkDynamicArray(re *a1, uint64_t *a2, _anonymous_namespace_ *a3, char *a4, _QWORD *a5)
{
  re *v5;
  const re::IntrospectionBase *v9;
  uint64_t v10;
  _BOOL8 isCompatibleType;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  const char *v16;
  uint64_t v17;
  uint8_t buf[16];
  __int128 v19;
  uint64_t v20;

  v5 = a1;
  v20 = *MEMORY[0x24BDAC8D0];
  v17 = 0;
  if (*a4 == 45 || (a1 = (re *)sscanf(a4, "%zu", &v17), (_DWORD)a1 != 1))
  {
    v15 = *re::foundationBindingLogObjects(a1);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      v16 = "Invalid binding key: Array index expected.";
LABEL_9:
      _os_log_impl(&dword_224FE9000, v15, OS_LOG_TYPE_DEFAULT, v16, buf, 2u);
    }
  }
  else
  {
    if (a2[2])
    {
    }
    v10 = *a2;
    if (isCompatibleType)
    {
      v12 = v17;
      *(_OWORD *)buf = 0u;
      v19 = 0u;
      re::DynamicArray<re::BindPoint::BindPointData>::add((_anonymous_namespace_ *)(a5 + 1), buf);
      re::BindPoint::BindPointData::deinit((re::BindPoint::BindPointData *)buf);
      v13 = a5[5] + 32 * a5[3];
      *(_QWORD *)(v13 - 32) = &off_24ED3FF30;
      *(_QWORD *)(v13 - 24) = v10;
      *(_QWORD *)(v13 - 16) = v12;
      v14 = *(_QWORD *)(v10 + 48);
      *((_QWORD *)v5 + 1) = 0;
      *((_QWORD *)v5 + 2) = 0;
      *(_QWORD *)v5 = v14;
      *((_BYTE *)v5 + 24) = 0;
      return;
    }
    v15 = *re::foundationBindingLogObjects((re *)isCompatibleType);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      v16 = "Invalid binding key: Dynamic Array type does not match expected type.";
      goto LABEL_9;
    }
  }
  *(_QWORD *)v5 = 0;
  *((_QWORD *)v5 + 1) = 0;
  *((_BYTE *)v5 + 24) = 0;
  *((_QWORD *)v5 + 2) = 0;
}

void `anonymous namespace'::walkFixedArray(re *a1, uint64_t *a2, _anonymous_namespace_ *a3, char *a4, _QWORD *a5)
{
  re *v5;
  const re::IntrospectionBase *v9;
  uint64_t v10;
  _BOOL8 isCompatibleType;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  const char *v16;
  uint64_t v17;
  uint8_t buf[16];
  __int128 v19;
  uint64_t v20;

  v5 = a1;
  v20 = *MEMORY[0x24BDAC8D0];
  v17 = 0;
  if (*a4 == 45 || (a1 = (re *)sscanf(a4, "%zu", &v17), (_DWORD)a1 != 1))
  {
    v15 = *re::foundationBindingLogObjects(a1);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      v16 = "Invalid binding key: Array index expected.";
LABEL_9:
      _os_log_impl(&dword_224FE9000, v15, OS_LOG_TYPE_DEFAULT, v16, buf, 2u);
    }
  }
  else
  {
    if (a2[2])
    {
    }
    v10 = *a2;
    if (isCompatibleType)
    {
      v12 = v17;
      *(_OWORD *)buf = 0u;
      v19 = 0u;
      re::DynamicArray<re::BindPoint::BindPointData>::add((_anonymous_namespace_ *)(a5 + 1), buf);
      re::BindPoint::BindPointData::deinit((re::BindPoint::BindPointData *)buf);
      v13 = a5[5] + 32 * a5[3];
      *(_QWORD *)(v13 - 32) = &off_24ED40000;
      *(_QWORD *)(v13 - 24) = v10;
      *(_QWORD *)(v13 - 16) = v12;
      v14 = *(_QWORD *)(v10 + 48);
      *((_QWORD *)v5 + 1) = 0;
      *((_QWORD *)v5 + 2) = 0;
      *(_QWORD *)v5 = v14;
      *((_BYTE *)v5 + 24) = 0;
      return;
    }
    v15 = *re::foundationBindingLogObjects((re *)isCompatibleType);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      v16 = "Invalid binding key: Fixed Array type does not match expected type.";
      goto LABEL_9;
    }
  }
  *(_QWORD *)v5 = 0;
  *((_QWORD *)v5 + 1) = 0;
  *((_BYTE *)v5 + 24) = 0;
  *((_QWORD *)v5 + 2) = 0;
}

void `anonymous namespace'::walkPointer(_anonymous_namespace_ *a1, uint64_t *a2, uint64_t a3, uint64_t a4, _QWORD *a5)
{
  _anonymous_namespace_ *v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int8 v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  uint64_t v17;
  _DWORD *v18;
  _DWORD *v19;
  BOOL v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  size_t v24;
  const char *v25;
  _anonymous_namespace_ *v26;
  uint64_t v27;
  uint64_t v28;
  StringID v29;
  uint64_t v30;
  __int128 v31;
  __int128 v32;
  uint64_t v33;

  v9 = a1;
  v33 = *MEMORY[0x24BDAC8D0];
  if (a2[2])
  {
  }
  v10 = *a2;
  v11 = *(_QWORD *)(*a2 + 48);
  v12 = atomic_load((unsigned __int8 *)&qword_254105B30);
  if ((v12 & 1) == 0)
  {
    a1 = (_anonymous_namespace_ *)__cxa_guard_acquire(&qword_254105B30);
    if ((_DWORD)a1)
    {
      _MergedGlobals_124 = re::introspect_KeyValueStoreInterface(0);
      __cxa_guard_release(&qword_254105B30);
    }
  }
  if (v11 == _MergedGlobals_124)
  {
    v25 = *(const char **)a4;
    v24 = *(_QWORD *)(a4 + 8);
    *(_QWORD *)&v29.var0 = 0;
    v29.var1 = (char *)&str_110;
    v30 = a3;
    v31 = 0u;
    v32 = 0u;
    re::DynamicArray<re::BindPoint::BindPointData>::add((_anonymous_namespace_ *)(a5 + 1), &v31);
    re::BindPoint::BindPointData::deinit((re::BindPoint::BindPointData *)&v31);
    v27 = a5[5] + 32 * a5[3];
    *(_QWORD *)(v27 - 32) = &off_24ED400D0;
    re::StringID::StringID((re::StringID *)(v27 - 24), &v29);
    *(_QWORD *)(v27 - 8) = a3;
    re::StringID::destroyString((re::StringID *)&v29);
    v28 = *(_QWORD *)(v10 + 48);
    *((_QWORD *)v9 + 1) = 0;
    *((_QWORD *)v9 + 2) = 0;
    *(_QWORD *)v9 = v28;
    *((_BYTE *)v9 + 24) = 0;
  }
  else
  {
    v13 = *(_QWORD *)(v10 + 48);
    v14 = *(unsigned int *)(v13 + 56);
    if (!(_DWORD)v14)
      goto LABEL_20;
    v15 = *(_QWORD **)(v13 + 64);
    v16 = v15;
    v17 = v14;
    do
    {
      v18 = (_DWORD *)*v16;
      if (*(_DWORD *)*v16 == 2)
        goto LABEL_10;
      ++v16;
      --v17;
    }
    while (v17);
    v18 = 0;
LABEL_10:
    while (1)
    {
      v19 = (_DWORD *)*v15;
      if (*(_DWORD *)*v15 == 3)
        break;
      ++v15;
      if (!--v14)
      {
        v19 = 0;
        break;
      }
    }
    if (v18 && (v19 ? (v20 = *((_QWORD *)v18 + 1) == 0) : (v20 = 1), !v20 && *((_QWORD *)v19 + 1)))
    {
      v31 = 0u;
      v32 = 0u;
      re::DynamicArray<re::BindPoint::BindPointData>::add((_anonymous_namespace_ *)(a5 + 1), &v31);
      re::BindPoint::BindPointData::deinit((re::BindPoint::BindPointData *)&v31);
      v21 = a5[5] + 32 * a5[3];
      *(_QWORD *)(v21 - 32) = &off_24ED401A0;
      *(_QWORD *)(v21 - 24) = v10;
      v31 = 0uLL;
      *(_QWORD *)&v32 = 0;
      BYTE8(v32) = 1;
    }
    else
    {
LABEL_20:
      v31 = 0u;
      v32 = 0u;
      re::DynamicArray<re::BindPoint::BindPointData>::add((_anonymous_namespace_ *)(a5 + 1), &v31);
      re::BindPoint::BindPointData::deinit((re::BindPoint::BindPointData *)&v31);
      v22 = a5[5] + 32 * a5[3];
      *(_QWORD *)(v22 - 32) = &off_24ED40270;
      *(_QWORD *)(v22 - 24) = v10;
      v23 = *(_QWORD *)(v10 + 48);
      *(_QWORD *)&v32 = 0;
      v31 = v23;
      BYTE8(v32) = 0;
    }
  }
}

void `anonymous namespace'::walkHashTable(uint64_t a1, uint64_t *a2, _anonymous_namespace_ *a3, uint64_t a4, _QWORD *a5)
{
  uint64_t v6;
  int v7;
  _BOOL8 isCompatibleType;
  _anonymous_namespace_ *v13;
  uint64_t v14;
  size_t v15;
  double v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  NSObject *v20;
  const char *v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _OWORD v28[2];
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  v6 = *a2;
  v7 = *(_DWORD *)(*(_QWORD *)(*a2 + 48) + 16);
  if (v7 != 6 && v7 != 10)
  {
    v20 = *re::foundationBindingLogObjects((re *)a1);
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      goto LABEL_21;
    LOWORD(v23) = 0;
    v22 = "Failed to create binding. Hash table keys need to be of type DynamicString or StringID.";
    goto LABEL_20;
  }
  if (!isCompatibleType)
  {
    v20 = *re::foundationBindingLogObjects((re *)isCompatibleType);
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
LABEL_21:
      *(_QWORD *)a1 = 0;
      *(_QWORD *)(a1 + 8) = 0;
      *(_BYTE *)(a1 + 24) = 0;
      *(_QWORD *)(a1 + 16) = 0;
      return;
    }
    LOWORD(v23) = 0;
    v22 = "Invalid binding key: Hash Table Value type does not match expected type.";
LABEL_20:
    _os_log_impl(&dword_224FE9000, v20, OS_LOG_TYPE_DEFAULT, v22, (uint8_t *)&v23, 2u);
    goto LABEL_21;
  }
  if (a2[2])
  {
  }
  v23 = v6;
  v26 = 0;
  v27 = 0;
  v14 = *(_QWORD *)(a4 + 8);
  if (v14)
    v15 = v14 + 1;
  else
    v15 = 0;
  v25 = 0;
  re::DynamicString::setCapacity(&v24, v15);
  re::DynamicString::operator=((re::DynamicString *)&v24, a4);
  memset(v28, 0, sizeof(v28));
  re::DynamicArray<re::BindPoint::BindPointData>::add((_anonymous_namespace_ *)(a5 + 1), v28);
  v16 = re::BindPoint::BindPointData::deinit((re::BindPoint::BindPointData *)v28);
  v17 = a5[5] + 32 * a5[3];
  *(_QWORD *)(v17 - 32) = 0;
  *v18 = off_24ED40340;
  v18[1] = v23;
  re::DynamicString::DynamicString((re::DynamicString *)(v18 + 2), (const re::DynamicString *)&v24);
  *(_QWORD *)(v17 - 16) = v18;
  if (v24 && (v25 & 1) != 0)
    (*(void (**)(void))(*v24 + 40))();
  v19 = *(_QWORD *)(v6 + 64);
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = v19;
  *(_BYTE *)(a1 + 24) = 0;
}

void `anonymous namespace'::walkStructure(uint64_t a1, uint64_t *a2, _anonymous_namespace_ *a3, uint64_t a4, _QWORD *a5)
{
  uint64_t v5;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int8 v13;
  uint64_t v14;
  const re::IntrospectionBase *v15;
  uint64_t v16;
  _anonymous_namespace_ *v17;
  size_t v18;
  const char *v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  _BOOL8 v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const char *v29;
  size_t v30;
  uint64_t v31;
  uint64_t v32;
  _BOOL8 v33;
  uint64_t v34;
  uint64_t v35;
  _BOOL8 isCompatibleType;
  NSObject *v37;
  const char *v38;
  uint64_t v40;
  StringID v41;
  void *v42;
  uint8_t buf[16];
  __int128 v44;
  uint64_t v45;

  v45 = *MEMORY[0x24BDAC8D0];
  v5 = *a2;
  if (!*(_DWORD *)(*a2 + 56))
  {
LABEL_15:
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_BYTE *)(a1 + 24) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    return;
  }
  v40 = a1;
  v9 = 0;
  v10 = 0;
  do
  {
    v11 = *(_QWORD *)(*(_QWORD *)(v5 + 64) + 8 * v9);
    if (*(_DWORD *)v11 != 1)
      goto LABEL_9;
    if (*(_DWORD *)(v11 + 40) != 3)
    {
      a1 = re::introspectionPrettyNameCompare(*(const char **)(v11 + 8), *(const char **)a4, *(_QWORD *)(a4 + 8));
      if (!(_DWORD)a1)
        goto LABEL_9;
      v21 = a2[2];
      if (v21)
      {
        if (!*(_DWORD *)(v11 + 40))
        {
          v35 = *(int *)(v11 + 36);
          if (isCompatibleType)
          {
            *(_QWORD *)v40 = *(_QWORD *)(v11 + 16);
            *(_QWORD *)(v40 + 8) = 0;
            *(_QWORD *)(v40 + 16) = v21 + v35;
            *(_BYTE *)(v40 + 24) = 0;
            return;
          }
          v37 = *re::foundationBindingLogObjects((re *)isCompatibleType);
          if (!os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
            goto LABEL_43;
          *(_WORD *)buf = 0;
          v38 = "Invalid binding key: Absolute struct member type does not match expected type.";
          goto LABEL_42;
        }
      }
      v22 = *(_DWORD *)(v11 + 40);
      if (v22 == 2)
      {
        *(_OWORD *)buf = 0u;
        v44 = 0u;
        re::DynamicArray<re::BindPoint::BindPointData>::add((_anonymous_namespace_ *)(a5 + 1), buf);
        re::BindPoint::BindPointData::deinit((re::BindPoint::BindPointData *)buf);
        v32 = a5[5] + 32 * a5[3];
        *(_QWORD *)(v32 - 32) = &off_24ED406C0;
        *(_QWORD *)(v32 - 24) = v11;
        *(_OWORD *)v40 = 0u;
        *(_OWORD *)(v40 + 16) = 0u;
        *(_BYTE *)(v40 + 24) = 1;
        return;
      }
      if (v22 == 1)
      {
        if (v33)
        {
          *(_OWORD *)buf = 0u;
          v44 = 0u;
          re::DynamicArray<re::BindPoint::BindPointData>::add((_anonymous_namespace_ *)(a5 + 1), buf);
          re::BindPoint::BindPointData::deinit((re::BindPoint::BindPointData *)buf);
          v34 = a5[5] + 32 * a5[3];
          *(_QWORD *)(v34 - 32) = &off_24ED3FBF0;
          *(_QWORD *)(v34 - 24) = v11;
          v28 = v40;
          *(_QWORD *)v40 = *a2;
          *(_QWORD *)(v40 + 8) = v11;
          *(_QWORD *)(v40 + 16) = 0;
          goto LABEL_33;
        }
        v37 = *re::foundationBindingLogObjects((re *)v33);
        if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          v38 = "Invalid binding key: Struct array member type does not match expected type.";
LABEL_42:
          _os_log_impl(&dword_224FE9000, v37, OS_LOG_TYPE_DEFAULT, v38, buf, 2u);
        }
      }
      else
      {
        if (v22)
        {
          re::internal::assertLog((re::internal *)4, v14, "assertion failure: '%s' (%s:line %i) Invalid structure member type.", "!\"Unreachable code\"", "walkStructure", 838);
          _os_crash();
          __break(1u);
          return;
        }
        if (v23)
        {
          v24 = *(int *)(v11 + 36);
          v25 = *(_QWORD *)(v11 + 16);
          *(_OWORD *)buf = 0u;
          v44 = 0u;
          re::DynamicArray<re::BindPoint::BindPointData>::add((_anonymous_namespace_ *)(a5 + 1), buf);
          re::BindPoint::BindPointData::deinit((re::BindPoint::BindPointData *)buf);
          v26 = a5[5] + 32 * a5[3];
          *(_QWORD *)(v26 - 32) = &off_24ED3FD90;
          *(_QWORD *)(v26 - 24) = v25;
          *(_QWORD *)(v26 - 16) = v24;
          v27 = *(_QWORD *)(v11 + 16);
          v28 = v40;
          *(_QWORD *)(v40 + 8) = 0;
          *(_QWORD *)(v40 + 16) = 0;
          *(_QWORD *)v40 = v27;
LABEL_33:
          *(_BYTE *)(v28 + 24) = 0;
          return;
        }
        v37 = *re::foundationBindingLogObjects((re *)v23);
        if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          v38 = "Invalid binding key: Struct member type does not match expected type.";
          goto LABEL_42;
        }
      }
LABEL_43:
      *(_QWORD *)v40 = 0;
      *(_QWORD *)(v40 + 8) = 0;
      *(_BYTE *)(v40 + 24) = 0;
      *(_QWORD *)(v40 + 16) = 0;
      return;
    }
    v12 = *(_QWORD *)(v11 + 16);
    v13 = atomic_load((unsigned __int8 *)&qword_254105B30);
    if ((v13 & 1) == 0)
    {
      a1 = __cxa_guard_acquire(&qword_254105B30);
      if ((_DWORD)a1)
      {
        _MergedGlobals_124 = re::introspect_KeyValueStoreInterface(0);
        __cxa_guard_release(&qword_254105B30);
      }
    }
    v10 = v11;
    if (v12 == _MergedGlobals_124)
    {
      if (a2[2])
      {
      }
      if (a3)
      {
        v19 = *(const char **)a4;
        v18 = *(_QWORD *)(a4 + 8);
        *(_QWORD *)&v41.var0 = a3;
        v41.var1 = 0;
        v42 = &str_110;
        *(_OWORD *)buf = 0u;
        v44 = 0u;
        re::DynamicArray<re::BindPoint::BindPointData>::add((_anonymous_namespace_ *)(a5 + 1), buf);
        re::BindPoint::BindPointData::deinit((re::BindPoint::BindPointData *)buf);
        v20 = a5[5] + 32 * a5[3];
        *(_QWORD *)(v20 - 32) = &off_24ED40520;
        *(_QWORD *)(v20 - 24) = a3;
        re::StringID::StringID((re::StringID *)(v20 - 16), (const StringID *)&v41.var1);
        re::StringID::destroyString((re::StringID *)&v41.var1);
        *(_QWORD *)(v40 + 8) = 0;
        *(_QWORD *)(v40 + 16) = 0;
        *(_QWORD *)v40 = a3;
        *(_BYTE *)(v40 + 24) = 0;
      }
      else
      {
        v29 = *(const char **)a4;
        v30 = *(_QWORD *)(a4 + 8);
        *(_QWORD *)&v41.var0 = 0;
        v41.var1 = (char *)&str_110;
        *(_OWORD *)buf = 0u;
        v44 = 0u;
        re::DynamicArray<re::BindPoint::BindPointData>::add((_anonymous_namespace_ *)(a5 + 1), buf);
        re::BindPoint::BindPointData::deinit((re::BindPoint::BindPointData *)buf);
        v31 = a5[5] + 32 * a5[3];
        *(_QWORD *)(v31 - 32) = &off_24ED405F0;
        re::StringID::StringID((re::StringID *)(v31 - 24), &v41);
        re::StringID::destroyString((re::StringID *)&v41);
        *(_OWORD *)v40 = 0u;
        *(_OWORD *)(v40 + 16) = 0u;
        *(_BYTE *)(v40 + 24) = 1;
      }
      return;
    }
LABEL_9:
    ++v9;
  }
  while (v9 < *(unsigned int *)(v5 + 56));
  a1 = v40;
  if (!v10)
    goto LABEL_15;
  v16 = a2[2] + *(int *)(v10 + 36);
  *(_QWORD *)buf = *(_QWORD *)(v10 + 16);
  *(_QWORD *)&buf[8] = 0;
  *(_QWORD *)&v44 = v16;
  BYTE8(v44) = 0;
}

uint64_t `anonymous namespace'::walkOptional(_anonymous_namespace_ *a1, uint64_t *a2, int a3, uint64_t a4, _QWORD *a5)
{
  int v7;
  uint64_t v8;
  uint64_t v10;
  unint64_t v11;
  __int128 v13;
  __int128 v14;
  uint64_t v15;

  v7 = (int)a1;
  v15 = *MEMORY[0x24BDAC8D0];
  v8 = *a2;
  if (a2[2])
  {
  }
  v13 = 0u;
  v14 = 0u;
  re::DynamicArray<re::BindPoint::BindPointData>::add((_anonymous_namespace_ *)(a5 + 1), &v13);
  re::BindPoint::BindPointData::deinit((re::BindPoint::BindPointData *)&v13);
  v10 = a5[5] + 32 * a5[3];
  *(_QWORD *)(v10 - 32) = &off_24ED40790;
  *(_QWORD *)(v10 - 24) = v8;
  v11 = *(_QWORD *)(v8 + 48);
  *(_QWORD *)&v14 = 0;
  v13 = v11;
  BYTE8(v14) = 0;
}

void `anonymous namespace'::PolymorphicMemberBindPointImpl::~PolymorphicMemberBindPointImpl(_anonymous_namespace_::PolymorphicMemberBindPointImpl *this)
{
  char *v2;

  v2 = (char *)this + 88;
  re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)this + 88);
  re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)v2);
  re::StringID::destroyString((_anonymous_namespace_::PolymorphicMemberBindPointImpl *)((char *)this + 16));
}

{
  char *v2;

  v2 = (char *)this + 88;
  re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)this + 88);
  re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)v2);
  re::StringID::destroyString((_anonymous_namespace_::PolymorphicMemberBindPointImpl *)((char *)this + 16));
  JUMPOUT(0x2276933B8);
}

void *re::internal::BindPointImpl<`anonymous namespace'::PolymorphicMemberBindPointImpl>::implTypeInfo()
{
}

uint64_t re::internal::BindPointImpl<`anonymous namespace'::PolymorphicMemberBindPointImpl>::copyInto(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  __int128 v5;

  v4 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a2 = &off_24ED3FB20;
  *(_QWORD *)(a2 + 8) = v4;
  re::StringID::StringID((re::StringID *)(a2 + 16), (const StringID *)(a1 + 16));
  *(_OWORD *)(a2 + 32) = *(_OWORD *)(a1 + 32);
  v5 = *(_OWORD *)(a1 + 64);
  *(_OWORD *)(a2 + 48) = *(_OWORD *)(a1 + 48);
  *(_OWORD *)(a2 + 64) = v5;
  *(_QWORD *)(a2 + 80) = *(_QWORD *)(a1 + 80);
  return re::DynamicArray<re::BindPoint::BindPointData>::DynamicArray(a2 + 88, (uint64_t *)(a1 + 88));
}

uint64_t re::internal::BindPointImpl<`anonymous namespace'::PolymorphicMemberBindPointImpl>::moveInto(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  __int128 v4;
  uint64_t v5;
  _OWORD v7[2];
  int v8;
  uint64_t v9;
  _QWORD v10[2];

  *(_QWORD *)a2 = &off_24ED3FB20;
  *(_QWORD *)(a2 + 8) = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a2 + 16) = *(_QWORD *)(a2 + 16) & 0xFFFFFFFFFFFFFFFELL | v3 & 1;
  *(_QWORD *)(a2 + 16) = *(_QWORD *)(a1 + 16) & 0xFFFFFFFFFFFFFFFELL | v3 & 1;
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = &str_110;
  *(_OWORD *)(a2 + 32) = *(_OWORD *)(a1 + 32);
  v4 = *(_OWORD *)(a1 + 64);
  *(_OWORD *)(a2 + 48) = *(_OWORD *)(a1 + 48);
  *(_OWORD *)(a2 + 64) = v4;
  re::BindPoint::BindPoint(a2 + 80, (uint64_t *)(a1 + 80));
  v10[0] = 0;
  v10[1] = &str_110;
  v5 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)&v7[0] = *(_QWORD *)(a1 + 16) & 1;
  *((_QWORD *)&v7[0] + 1) = v5;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = &str_110;
  re::StringID::destroyString((re::StringID *)v7);
  re::StringID::destroyString((re::StringID *)v10);
  *(_OWORD *)(a1 + 57) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  v9 = 0;
  memset(v7, 0, sizeof(v7));
  v8 = 0;
  *(_QWORD *)(a1 + 80) = 0;
  re::DynamicArray<re::RigDataValue>::operator=(a1 + 88, (uint64_t)v7 + 8);
  re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)v7 + 8);
  return re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)v7 + 8);
}

BOOL re::internal::BindPointImpl<`anonymous namespace'::PolymorphicMemberBindPointImpl>::equals(uint64_t a1, _QWORD *a2)
{
      && *(_QWORD *)(a1 + 8) == a2[1]
      && re::StringID::operator==((_QWORD *)(a1 + 16), a2 + 2);
}

unint64_t `anonymous namespace'::PolymorphicMemberBindPointImpl::hash(_OWORD *a1, _QWORD *a2, uint64_t *a3, unint64_t a4)
{
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  __int128 v15;
  unint64_t v16;
  uint64_t v17;
  _QWORD v18[2];

  v18[0] = a3;
  v18[1] = a4;
  v7 = re::BindPoint::baseValueUntyped((re::BindPoint *)(a1 + 5));
  v8 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (v7 ^ (v7 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v7 ^ (v7 >> 30))) >> 27));
  v9 = v8 ^ (v8 >> 31);
  if (v7 && a4)
  {
    v10 = a1[4];
    v15 = a1[3];
    v17 = *((_QWORD *)&v10 + 1);
    v16 = v7;
    v11 = *a3;
    v12 = re::Slice<re::internal::BindPointImplBase const*>::range(v18, 1uLL, a4);
    v9 ^= (v9 << 6)
        + (v9 >> 2)
        + (*(uint64_t (**)(uint64_t, __int128 *, uint64_t, uint64_t))(*(_QWORD *)v11 + 48))(v11, &v15, v12, v13)- 0x61C8864680B583E9;
  }
  return v9;
}

uint64_t `anonymous namespace'::PolymorphicMemberBindPointImpl::isWeak()
{
  return 1;
}

uint64_t `anonymous namespace'::PolymorphicMemberBindPointImpl::isAlive(_OWORD *a1, _QWORD *a2, uint64_t *a3, unint64_t a4)
{
  uint64_t result;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD v15[2];

  v15[0] = a3;
  v15[1] = a4;
  result = re::BindPoint::baseValueUntyped((re::BindPoint *)(a1 + 5));
  if (result)
  {
    v8 = a1[4];
    v12 = a1[3];
    v14 = *((_QWORD *)&v8 + 1);
    v13 = result;
    if (a4)
    {
      v9 = *a3;
      v10 = re::Slice<re::internal::BindPointImplBase const*>::range(v15, 1uLL, a4);
      return (*(uint64_t (**)(uint64_t, __int128 *, uint64_t, uint64_t))(*(_QWORD *)v9 + 64))(v9, &v12, v10, v11);
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t `anonymous namespace'::PolymorphicMemberBindPointImpl::baseValueUntyped(_OWORD *a1, _QWORD *a2, uint64_t *a3, unint64_t a4)
{
  uint64_t result;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD v15[2];

  v15[0] = a3;
  v15[1] = a4;
  result = re::BindPoint::baseValueUntyped((re::BindPoint *)(a1 + 5));
  if (result)
  {
    v8 = a1[4];
    v12 = a1[3];
    v14 = *((_QWORD *)&v8 + 1);
    v13 = result;
    if (a4)
    {
      v9 = *a3;
      v10 = re::Slice<re::internal::BindPointImplBase const*>::range(v15, 1uLL, a4);
      return (*(uint64_t (**)(uint64_t, __int128 *, uint64_t, uint64_t))(*(_QWORD *)v9 + 88))(v9, &v12, v10, v11);
    }
  }
  return result;
}

uint64_t `anonymous namespace'::PolymorphicMemberBindPointImpl::supportsOverrideValue(_OWORD *a1, _QWORD *a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v7;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD v16[2];

  v16[0] = a3;
  v16[1] = a4;
  if (!a4)
    return re::BindPoint::supportsOverrideValue((re::BindPoint *)(a1 + 5));
  v7 = re::BindPoint::baseValueUntyped((re::BindPoint *)(a1 + 5));
  if (!v7)
    return re::BindPoint::supportsOverrideValue((re::BindPoint *)(a1 + 5));
  v8 = a1[4];
  v13 = a1[3];
  v15 = *((_QWORD *)&v8 + 1);
  v14 = v7;
  v9 = *a3;
  v10 = re::Slice<re::internal::BindPointImplBase const*>::range(v16, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, __int128 *, uint64_t, uint64_t))(*(_QWORD *)v9 + 96))(v9, &v13, v10, v11);
}

uint64_t `anonymous namespace'::PolymorphicMemberBindPointImpl::isOverridden(_OWORD *a1, _QWORD *a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v7;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD v16[2];

  v16[0] = a3;
  v16[1] = a4;
  if (!a4)
    return re::BindPoint::isOverridden((re::BindPoint *)(a1 + 5));
  v7 = re::BindPoint::baseValueUntyped((re::BindPoint *)(a1 + 5));
  if (!v7)
    return re::BindPoint::isOverridden((re::BindPoint *)(a1 + 5));
  v8 = a1[4];
  v13 = a1[3];
  v15 = *((_QWORD *)&v8 + 1);
  v14 = v7;
  v9 = *a3;
  v10 = re::Slice<re::internal::BindPointImplBase const*>::range(v16, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, __int128 *, uint64_t, uint64_t))(*(_QWORD *)v9 + 104))(v9, &v13, v10, v11);
}

uint64_t `anonymous namespace'::PolymorphicMemberBindPointImpl::setIsOverridden(_OWORD *a1, _QWORD *a2, uint64_t *a3, unint64_t a4, uint64_t a5)
{
  uint64_t v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD v18[2];

  v18[0] = a3;
  v18[1] = a4;
  if (a4)
  {
    v9 = re::BindPoint::baseValueUntyped((re::BindPoint *)(a1 + 5));
    if (v9)
    {
      v10 = a1[4];
      v15 = a1[3];
      v17 = *((_QWORD *)&v10 + 1);
      v16 = v9;
      v11 = *a3;
      v12 = re::Slice<re::internal::BindPointImplBase const*>::range(v18, 1uLL, a4);
      (*(void (**)(uint64_t, __int128 *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v11 + 112))(v11, &v15, v12, v13, a5);
    }
  }
  return re::BindPoint::setIsOverridden((uint64_t)(a1 + 5), a5);
}

uint64_t `anonymous namespace'::PolymorphicMemberBindPointImpl::overrideValueUntyped(_OWORD *a1, _QWORD *a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v7;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD v16[2];

  v16[0] = a3;
  v16[1] = a4;
  if (!a4)
    return re::BindPoint::overrideValueUntyped((re::BindPoint *)(a1 + 5));
  v7 = re::BindPoint::baseValueUntyped((re::BindPoint *)(a1 + 5));
  if (!v7)
    return re::BindPoint::overrideValueUntyped((re::BindPoint *)(a1 + 5));
  v8 = a1[4];
  v13 = a1[3];
  v15 = *((_QWORD *)&v8 + 1);
  v14 = v7;
  v9 = *a3;
  v10 = re::Slice<re::internal::BindPointImplBase const*>::range(v16, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, __int128 *, uint64_t, uint64_t))(*(_QWORD *)v9 + 120))(v9, &v13, v10, v11);
}

uint64_t `anonymous namespace'::PolymorphicMemberBindPointImpl::markAsWritten(_OWORD *a1, _QWORD *a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v7;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD v16[2];

  v16[0] = a3;
  v16[1] = a4;
  if (!a4)
    return re::BindPoint::markAsWritten((uint64_t)(a1 + 5));
  v7 = re::BindPoint::baseValueUntyped((re::BindPoint *)(a1 + 5));
  if (!v7)
    return re::BindPoint::markAsWritten((uint64_t)(a1 + 5));
  v8 = a1[4];
  v13 = a1[3];
  v15 = *((_QWORD *)&v8 + 1);
  v14 = v7;
  v9 = *a3;
  v10 = re::Slice<re::internal::BindPointImplBase const*>::range(v16, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, __int128 *, uint64_t, uint64_t))(*(_QWORD *)v9 + 128))(v9, &v13, v10, v11);
}

uint64_t `anonymous namespace'::PolymorphicMemberBindPointImpl::boundOwner()
{
  return 0;
}

void `anonymous namespace'::PolymorphicMemberBindPointImpl::updateCachedBinding(_anonymous_namespace_::PolymorphicMemberBindPointImpl *this, _QWORD *a2)
{
  uint64_t v4;
  unint64_t v5;
  _QWORD *v6;
  char *v7;
  _anonymous_namespace_ *v8;
  size_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD v12[2];
  _BYTE v13[32];
  int v14;
  uint64_t v15;

  v4 = a2[2];
  if (*a2 != *((_QWORD *)this + 5) || v4 != *((_QWORD *)this + 4))
  {
    *((_QWORD *)this + 4) = v4;
    v5 = *((_QWORD *)this + 1);
    v15 = 0;
    *(_OWORD *)v13 = v5;
    *(_QWORD *)&v13[16] = 0;
    *(_QWORD *)&v13[24] = 0;
    v14 = 0;
    *((_QWORD *)this + 10) = v5;
    v6 = (_QWORD *)((char *)this + 80);
    v7 = (char *)this + 88;
    re::DynamicArray<re::RigDataValue>::operator=((uint64_t)this + 88, (uint64_t)&v13[8]);
    re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)&v13[8]);
    re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)&v13[8]);
    *((_QWORD *)this + 5) = 0;
    v8 = (_anonymous_namespace_ *)*((_QWORD *)this + 1);
    v9 = strlen(*((const char **)this + 3));
    v12[0] = *((_QWORD *)this + 3);
    v12[1] = v9;
    *((_OWORD *)this + 3) = *(_OWORD *)v13;
    *(_OWORD *)((char *)this + 57) = *(_OWORD *)&v13[9];
    v10 = *((_QWORD *)this + 6);
    if (v10 || *((_BYTE *)this + 72))
    {
      *((_QWORD *)this + 5) = *a2;
      v11 = *((_QWORD *)this + 8);
      if (v11)
      {
        re::makeBindPoint((uint64_t)v13, v10, v11, (uint64_t)v6);
        *v6 = *(_QWORD *)v13;
        re::DynamicArray<re::RigDataValue>::operator=((uint64_t)v7, (uint64_t)&v13[8]);
        re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)&v13[8]);
        re::DynamicArray<re::BindPoint::BindPointData>::deinit((uint64_t)&v13[8]);
      }
    }
  }
}

uint64_t re::Slice<re::internal::BindPointImplBase const*>::range(_QWORD *a1, unint64_t a2, unint64_t a3)
{
  unint64_t v3;
  uint64_t result;

  v3 = a1[1];
  if (v3 < a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. fromInclusive = %zu, size = %zu", "fromInclusive <= size()", "range", 241, a2, v3);
    _os_crash();
    __break(1u);
  }
  else if (v3 >= a3)
  {
    return *a1 + 8 * a2;
  }
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. toExclusive = %zu, size = %zu", "toExclusive <= size()", "range", 242, a2, v3);
  result = _os_crash();
  __break(1u);
  return result;
}

BOOL `anonymous namespace'::isCompatibleType(_anonymous_namespace_ *this, const re::IntrospectionBase *a2, const re::IntrospectionBase *a3)
{
  unsigned __int8 v3;
  __objc2_class_ro **p_info;
  _anonymous_namespace_ *v5;
  unsigned __int8 v6;
  BOOL v8;
  unsigned __int8 v9;
  __objc2_class_ro **v10;
  unsigned __int8 v11;
  const re::IntrospectionBase *v12;
  int v13;
  BOOL v14;
  int v15;
  int v16;
  BOOL v17;
  int v18;
  char v19;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  _anonymous_namespace_ *v30;
  BOOL v31;
  BOOL v32;
  const re::IntrospectionBase *v33;
  const re::IntrospectionBase *v34;
  const re::IntrospectionBase *v35;
  const re::IntrospectionBase *v36;
  _anonymous_namespace_ *v37;
  _anonymous_namespace_ *v38;
  _anonymous_namespace_ *v39;
  _anonymous_namespace_ *v40;

  if (!this)
    return 1;
  p_info = VideoSpillMapMetalSession.info;
  if ((v3 & 1) == 0)
  {
    v37 = this;
    v33 = a2;
    p_info = (__objc2_class_ro **)(VideoSpillMapMetalSession + 32);
    a2 = v33;
    v23 = v22;
    this = v37;
    if (v23)
    {
      re::introspect<float>(void)::info = re::introspect_float(0, v33);
      p_info = (__objc2_class_ro **)(VideoSpillMapMetalSession + 32);
      this = v37;
      a2 = v33;
    }
  }
  v5 = (_anonymous_namespace_ *)p_info[7];
  if ((v6 & 1) == 0)
  {
    v38 = this;
    v30 = (_anonymous_namespace_ *)p_info[7];
    v34 = a2;
    v5 = v30;
    a2 = v34;
    p_info = (__objc2_class_ro **)(VideoSpillMapMetalSession + 32);
    v25 = v24;
    this = v38;
    if (v25)
    {
      re::introspect<float>(void)::info = re::introspect_float(0, v34);
      v5 = v30;
      a2 = v34;
      p_info = (__objc2_class_ro **)(VideoSpillMapMetalSession + 32);
      this = v38;
    }
  }
  v8 = v5 != this && p_info[7] != (__objc2_class_ro *)a2;
  v10 = VideoSpillMapMetalSession.info;
  if ((v9 & 1) == 0)
  {
    v39 = this;
    v35 = a2;
    v31 = v8;
    v8 = v31;
    v10 = (__objc2_class_ro **)(VideoSpillMapMetalSession + 32);
    a2 = v35;
    v27 = v26;
    this = v39;
    if (v27)
    {
      re::introspect<double>(void)::info = (uint64_t)re::introspect_double(0, v35);
      v8 = v31;
      v10 = (__objc2_class_ro **)(VideoSpillMapMetalSession + 32);
      this = v39;
      a2 = v35;
    }
  }
  if (v10[9] == (__objc2_class_ro *)this)
    v8 = 0;
  if ((v11 & 1) == 0)
  {
    v40 = this;
    v36 = a2;
    v32 = v8;
    v8 = v32;
    v10 = (__objc2_class_ro **)(VideoSpillMapMetalSession + 32);
    a2 = v36;
    v29 = v28;
    this = v40;
    if (v29)
    {
      re::introspect<double>(void)::info = (uint64_t)re::introspect_double(0, v36);
      v8 = v32;
      v10 = (__objc2_class_ro **)(VideoSpillMapMetalSession + 32);
      this = v40;
      a2 = v36;
    }
  }
  v12 = (const re::IntrospectionBase *)v10[9];
  v13 = *((_DWORD *)this + 4);
  if (v13)
    v14 = v13 == 9;
  else
    v14 = 1;
  v15 = v14;
  v16 = *((_DWORD *)a2 + 4);
  if (v16)
    v17 = v16 == 9;
  else
    v17 = 1;
  v18 = v17;
  v19 = !v8;
  if (v12 == a2)
    v19 = 1;
  if ((v19 & 1) == 0 && v15 && v18)
    return *((_DWORD *)this + 5) == *((_DWORD *)a2 + 5);
  else
    return this == a2;
}

void `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayMemberWithSizePointerInfo>::~PointerBindPointImpl()
{
  JUMPOUT(0x2276933B8);
}

void *re::internal::BindPointImpl<`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayMemberWithSizePointerInfo>>::implTypeInfo()
{
}

uint64_t re::internal::BindPointImpl<`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayMemberWithSizePointerInfo>>::copyInto(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24ED3FBF0;
  a2[1] = v2;
  return result;
}

uint64_t re::internal::BindPointImpl<`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayMemberWithSizePointerInfo>>::moveInto(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24ED3FBF0;
  a2[1] = v2;
  return result;
}

BOOL re::internal::BindPointImpl<`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayMemberWithSizePointerInfo>>::equals(uint64_t a1, _QWORD *a2)
{
      && *(_QWORD *)(a1 + 8) == a2[1];
}

unint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayMemberWithSizePointerInfo>::hash(uint64_t a1, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD v13[3];
  char v14;
  _QWORD v15[2];

  v15[0] = a3;
  v15[1] = a4;
  v4 = a2[2];
  v5 = *(_QWORD *)(a1 + 8);
  v6 = *(_QWORD *)(v4 + *(int *)(v5 + 36));
  if (v6)
  {
    v6 = *a2;
  }
  else
  {
    v5 = 0;
    v4 = 0;
  }
  v13[0] = v6;
  v13[1] = v5;
  v13[2] = v4;
  v14 = 0;
  v7 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (v4 ^ (v4 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v4 ^ (v4 >> 30))) >> 27));
  v8 = v7 ^ (v7 >> 31);
  if (a4 && v4)
  {
    v9 = *a3;
    v10 = re::Slice<re::internal::BindPointImplBase const*>::range(v15, 1uLL, a4);
    v8 ^= (v8 << 6)
        + (v8 >> 2)
        + (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v9 + 48))(v9, v13, v10, v11)
        - 0x61C8864680B583E9;
  }
  return v8;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayMemberWithSizePointerInfo>::isWeak()
{
  return 1;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayMemberWithSizePointerInfo>::isAlive(uint64_t a1, _QWORD *a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v10[3];
  char v11;
  _QWORD v12[2];

  v12[0] = a3;
  v12[1] = a4;
  v4 = a2[2];
  v5 = *(_QWORD *)(a1 + 8);
  if (!*(_QWORD *)(v4 + *(int *)(v5 + 36)))
    return 0;
  v10[0] = *a2;
  v10[1] = v5;
  v10[2] = v4;
  v11 = 0;
  if (!a4)
    return 1;
  v6 = *a3;
  v7 = re::Slice<re::internal::BindPointImplBase const*>::range(v12, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v6 + 64))(v6, v10, v7, v8);
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayMemberWithSizePointerInfo>::baseValueUntyped(uint64_t a1, _QWORD *a2, uint64_t *a3, unint64_t a4)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v10[3];
  char v11;
  _QWORD v12[2];

  v12[0] = a3;
  v12[1] = a4;
  result = a2[2];
  v6 = *(_QWORD *)(a1 + 8);
  if (!*(_QWORD *)(result + *(int *)(v6 + 36)))
    return 0;
  v10[0] = *a2;
  v10[1] = v6;
  v10[2] = result;
  v11 = 0;
  if (a4)
  {
    v7 = *a3;
    v8 = re::Slice<re::internal::BindPointImplBase const*>::range(v12, 1uLL, a4);
    return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v7 + 88))(v7, v10, v8, v9);
  }
  return result;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayMemberWithSizePointerInfo>::supportsOverrideValue(uint64_t a1, _QWORD *a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v10[3];
  char v11;
  _QWORD v12[2];

  v12[0] = a3;
  v12[1] = a4;
  if (!a4)
    return 0;
  v4 = a2[2];
  v5 = *(_QWORD *)(a1 + 8);
  if (!*(_QWORD *)(v4 + *(int *)(v5 + 36)))
    return 0;
  v10[0] = *a2;
  v10[1] = v5;
  v10[2] = v4;
  v11 = 0;
  v6 = *a3;
  v7 = re::Slice<re::internal::BindPointImplBase const*>::range(v12, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v6 + 96))(v6, v10, v7, v8);
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayMemberWithSizePointerInfo>::isOverridden(uint64_t a1, _QWORD *a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v10[3];
  char v11;
  _QWORD v12[2];

  v12[0] = a3;
  v12[1] = a4;
  if (!a4)
    return 0;
  v4 = a2[2];
  v5 = *(_QWORD *)(a1 + 8);
  if (!*(_QWORD *)(v4 + *(int *)(v5 + 36)))
    return 0;
  v10[0] = *a2;
  v10[1] = v5;
  v10[2] = v4;
  v11 = 0;
  v6 = *a3;
  v7 = re::Slice<re::internal::BindPointImplBase const*>::range(v12, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v6 + 104))(v6, v10, v7, v8);
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayMemberWithSizePointerInfo>::setIsOverridden(uint64_t result, _QWORD *a2, uint64_t *a3, unint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD v11[3];
  char v12;
  _QWORD v13[2];

  v13[0] = a3;
  v13[1] = a4;
  if (a4)
  {
    v5 = a2[2];
    v6 = *(_QWORD *)(result + 8);
    if (*(_QWORD *)(v5 + *(int *)(v6 + 36)))
    {
      v11[0] = *a2;
      v11[1] = v6;
      v11[2] = v5;
      v12 = 0;
      v8 = *a3;
      v9 = re::Slice<re::internal::BindPointImplBase const*>::range(v13, 1uLL, a4);
      return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v8 + 112))(v8, v11, v9, v10, a5);
    }
  }
  return result;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayMemberWithSizePointerInfo>::overrideValueUntyped(uint64_t a1, _QWORD *a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v10[3];
  char v11;
  _QWORD v12[2];

  v12[0] = a3;
  v12[1] = a4;
  if (!a4)
    return 0;
  v4 = a2[2];
  v5 = *(_QWORD *)(a1 + 8);
  if (!*(_QWORD *)(v4 + *(int *)(v5 + 36)))
    return 0;
  v10[0] = *a2;
  v10[1] = v5;
  v10[2] = v4;
  v11 = 0;
  v6 = *a3;
  v7 = re::Slice<re::internal::BindPointImplBase const*>::range(v12, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v6 + 120))(v6, v10, v7, v8);
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayMemberWithSizePointerInfo>::markAsWritten(uint64_t result, _QWORD *a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v9[3];
  char v10;
  _QWORD v11[2];

  v11[0] = a3;
  v11[1] = a4;
  if (a4)
  {
    v4 = a2[2];
    v5 = *(_QWORD *)(result + 8);
    if (*(_QWORD *)(v4 + *(int *)(v5 + 36)))
    {
      v9[0] = *a2;
      v9[1] = v5;
      v9[2] = v4;
      v10 = 0;
      v6 = *a3;
      v7 = re::Slice<re::internal::BindPointImplBase const*>::range(v11, 1uLL, a4);
      return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v6 + 128))(v6, v9, v7, v8);
    }
  }
  return result;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayMemberWithSizePointerInfo>::boundOwner()
{
  return 0;
}

void `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayMemberWithSizeIndexPointerInfo>::~PointerBindPointImpl()
{
  JUMPOUT(0x2276933B8);
}

void *re::internal::BindPointImpl<`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayMemberWithSizeIndexPointerInfo>>::implTypeInfo()
{
}

uint64_t re::internal::BindPointImpl<`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayMemberWithSizeIndexPointerInfo>>::copyInto(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24ED3FCC0;
  a2[1] = v2;
  return result;
}

uint64_t re::internal::BindPointImpl<`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayMemberWithSizeIndexPointerInfo>>::moveInto(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24ED3FCC0;
  a2[1] = v2;
  return result;
}

BOOL re::internal::BindPointImpl<`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayMemberWithSizeIndexPointerInfo>>::equals(uint64_t a1, _QWORD *a2)
{
      && *(_QWORD *)(a1 + 8) == a2[1];
}

unint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayMemberWithSizeIndexPointerInfo>::hash(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD v12[2];
  unint64_t v13;
  _QWORD v14[2];

  v14[0] = a3;
  v14[1] = a4;
  v6 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (v13 ^ (v13 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v13 ^ (v13 >> 30))) >> 27));
  v7 = v6 ^ (v6 >> 31);
  if (a4 && v13)
  {
    v8 = *a3;
    v9 = re::Slice<re::internal::BindPointImplBase const*>::range(v14, 1uLL, a4);
    v7 ^= (v7 << 6)
        + (v7 >> 2)
        + (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v8 + 48))(v8, v12, v9, v10)
        - 0x61C8864680B583E9;
  }
  return v7;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayMemberWithSizeIndexPointerInfo>::isWeak()
{
  return 1;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayMemberWithSizeIndexPointerInfo>::isAlive(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v10[4];
  _QWORD v11[2];

  v11[0] = a3;
  v11[1] = a4;
  if (!v10[2])
    return 0;
  if (!a4)
    return 1;
  v6 = *a3;
  v7 = re::Slice<re::internal::BindPointImplBase const*>::range(v11, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v6 + 64))(v6, v10, v7, v8);
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayMemberWithSizeIndexPointerInfo>::baseValueUntyped(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v10[2];
  uint64_t v11;
  _QWORD v12[2];

  v12[0] = a3;
  v12[1] = a4;
  result = v11;
  if (v11)
  {
    if (a4)
    {
      v7 = *a3;
      v8 = re::Slice<re::internal::BindPointImplBase const*>::range(v12, 1uLL, a4);
      return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v7 + 88))(v7, v10, v8, v9);
    }
  }
  return result;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayMemberWithSizeIndexPointerInfo>::supportsOverrideValue(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v10[4];
  _QWORD v11[2];

  v11[0] = a3;
  v11[1] = a4;
  if (!a4)
    return 0;
  if (!v10[2])
    return 0;
  v6 = *a3;
  v7 = re::Slice<re::internal::BindPointImplBase const*>::range(v11, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v6 + 96))(v6, v10, v7, v8);
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayMemberWithSizeIndexPointerInfo>::isOverridden(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v10[4];
  _QWORD v11[2];

  v11[0] = a3;
  v11[1] = a4;
  if (!a4)
    return 0;
  if (!v10[2])
    return 0;
  v6 = *a3;
  v7 = re::Slice<re::internal::BindPointImplBase const*>::range(v11, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v6 + 104))(v6, v10, v7, v8);
}

_QWORD *`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayMemberWithSizeIndexPointerInfo>::setIsOverridden(_QWORD *result, uint64_t a2, uint64_t *a3, unint64_t a4, uint64_t a5)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD v11[4];
  _QWORD v12[2];

  v12[0] = a3;
  v12[1] = a4;
  if (a4)
  {
    if (v11[2])
    {
      v8 = *a3;
      v9 = re::Slice<re::internal::BindPointImplBase const*>::range(v12, 1uLL, a4);
      return (_QWORD *)(*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v8 + 112))(v8, v11, v9, v10, a5);
    }
  }
  return result;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayMemberWithSizeIndexPointerInfo>::overrideValueUntyped(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v10[4];
  _QWORD v11[2];

  v11[0] = a3;
  v11[1] = a4;
  if (!a4)
    return 0;
  if (!v10[2])
    return 0;
  v6 = *a3;
  v7 = re::Slice<re::internal::BindPointImplBase const*>::range(v11, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v6 + 120))(v6, v10, v7, v8);
}

_QWORD *`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayMemberWithSizeIndexPointerInfo>::markAsWritten(_QWORD *result, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v9[4];
  _QWORD v10[2];

  v10[0] = a3;
  v10[1] = a4;
  if (a4)
  {
    if (v9[2])
    {
      v6 = *a3;
      v7 = re::Slice<re::internal::BindPointImplBase const*>::range(v10, 1uLL, a4);
      return (_QWORD *)(*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v6 + 128))(v6, v9, v7, v8);
    }
  }
  return result;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayMemberWithSizeIndexPointerInfo>::boundOwner()
{
  return 0;
}

_QWORD *`anonymous namespace'::ArrayMemberWithSizeIndexPointerInfo::pointerReference(_QWORD *result, unint64_t *a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v4;
  uint64_t v6;
  const void *v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t __dst;

  v4 = result;
  if (*(_DWORD *)(a3 + 40) == 1
    && (v6 = *(_QWORD *)(a3 + 48)) != 0
    && (v9 = (const void *)(a4 + *(int *)(a3 + 64)),
        __dst = 0,
        result = memcpy(&__dst, v9, *(int *)(v6 + 20)),
        v10 = *a2,
        *a2 < __dst)
    && (v11 = *(_QWORD *)(a4 + *(int *)(a3 + 36))) != 0)
  {
    v12 = *(_QWORD *)(*(_QWORD *)(a3 + 16) + 48);
    *v4 = v12;
    v4[1] = 0;
    v4[2] = v11 + v10 * *(int *)(v12 + 20);
    *((_BYTE *)v4 + 24) = 0;
  }
  else
  {
    *v4 = 0;
    v4[1] = 0;
    *((_BYTE *)v4 + 24) = 0;
    v4[2] = 0;
  }
  return result;
}

void `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::RelativeMemberOffsetPointerInfo>::~PointerBindPointImpl()
{
  JUMPOUT(0x2276933B8);
}

void *re::internal::BindPointImpl<`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::RelativeMemberOffsetPointerInfo>>::implTypeInfo()
{
}

__n128 re::internal::BindPointImpl<`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::RelativeMemberOffsetPointerInfo>>::copyInto(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_24ED3FD90;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 re::internal::BindPointImpl<`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::RelativeMemberOffsetPointerInfo>>::moveInto(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_24ED3FD90;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

BOOL re::internal::BindPointImpl<`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::RelativeMemberOffsetPointerInfo>>::equals(uint64_t a1, _QWORD *a2)
{
      && *(_QWORD *)(a1 + 8) == a2[1]
      && *(_QWORD *)(a1 + 16) == a2[2];
}

unint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::RelativeMemberOffsetPointerInfo>::hash(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD v12[3];
  char v13;
  _QWORD v14[2];

  v14[0] = a3;
  v14[1] = a4;
  v4 = *(_QWORD *)(a1 + 16);
  v12[0] = *(_QWORD *)(a1 + 8);
  v12[1] = 0;
  v5 = v4 + *(_QWORD *)(a2 + 16);
  v12[2] = v5;
  v13 = 0;
  v6 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (v5 ^ (v5 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v5 ^ (v5 >> 30))) >> 27));
  v7 = v6 ^ (v6 >> 31);
  if (a4 && v5)
  {
    v8 = *a3;
    v9 = re::Slice<re::internal::BindPointImplBase const*>::range(v14, 1uLL, a4);
    v7 ^= (v7 << 6)
        + (v7 >> 2)
        + (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v8 + 48))(v8, v12, v9, v10)
        - 0x61C8864680B583E9;
  }
  return v7;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::RelativeMemberOffsetPointerInfo>::isWeak()
{
  return 1;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::RelativeMemberOffsetPointerInfo>::isAlive(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v10[3];
  char v11;
  _QWORD v12[2];

  v12[0] = a3;
  v12[1] = a4;
  v4 = *(_QWORD *)(a1 + 16);
  v10[0] = *(_QWORD *)(a1 + 8);
  v10[1] = 0;
  v5 = *(_QWORD *)(a2 + 16);
  v11 = 0;
  v10[2] = v4 + v5;
  if (!(v4 + v5))
    return 0;
  if (!a4)
    return 1;
  v6 = *a3;
  v7 = re::Slice<re::internal::BindPointImplBase const*>::range(v12, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v6 + 64))(v6, v10, v7, v8);
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::RelativeMemberOffsetPointerInfo>::baseValueUntyped(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v10[3];
  char v11;
  _QWORD v12[2];

  v12[0] = a3;
  v12[1] = a4;
  v4 = *(_QWORD *)(a1 + 16);
  v10[0] = *(_QWORD *)(a1 + 8);
  v10[1] = 0;
  v5 = *(_QWORD *)(a2 + 16);
  v11 = 0;
  result = v4 + v5;
  v10[2] = v4 + v5;
  if (v4 + v5)
  {
    if (a4)
    {
      v7 = *a3;
      v8 = re::Slice<re::internal::BindPointImplBase const*>::range(v12, 1uLL, a4);
      return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v7 + 88))(v7, v10, v8, v9);
    }
  }
  return result;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::RelativeMemberOffsetPointerInfo>::supportsOverrideValue(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v10[3];
  char v11;
  _QWORD v12[2];

  v12[0] = a3;
  v12[1] = a4;
  if (!a4)
    return 0;
  v4 = *(_QWORD *)(a1 + 16);
  v10[0] = *(_QWORD *)(a1 + 8);
  v10[1] = 0;
  v5 = *(_QWORD *)(a2 + 16);
  v11 = 0;
  v10[2] = v4 + v5;
  if (!(v4 + v5))
    return 0;
  v6 = *a3;
  v7 = re::Slice<re::internal::BindPointImplBase const*>::range(v12, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v6 + 96))(v6, v10, v7, v8);
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::RelativeMemberOffsetPointerInfo>::isOverridden(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v10[3];
  char v11;
  _QWORD v12[2];

  v12[0] = a3;
  v12[1] = a4;
  if (!a4)
    return 0;
  v4 = *(_QWORD *)(a1 + 16);
  v10[0] = *(_QWORD *)(a1 + 8);
  v10[1] = 0;
  v5 = *(_QWORD *)(a2 + 16);
  v11 = 0;
  v10[2] = v4 + v5;
  if (!(v4 + v5))
    return 0;
  v6 = *a3;
  v7 = re::Slice<re::internal::BindPointImplBase const*>::range(v12, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v6 + 104))(v6, v10, v7, v8);
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::RelativeMemberOffsetPointerInfo>::setIsOverridden(uint64_t result, uint64_t a2, uint64_t *a3, unint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD v11[3];
  char v12;
  _QWORD v13[2];

  v13[0] = a3;
  v13[1] = a4;
  if (a4)
  {
    v5 = *(_QWORD *)(result + 16);
    v11[0] = *(_QWORD *)(result + 8);
    v11[1] = 0;
    v6 = *(_QWORD *)(a2 + 16);
    v12 = 0;
    v11[2] = v5 + v6;
    if (v5 + v6)
    {
      v8 = *a3;
      v9 = re::Slice<re::internal::BindPointImplBase const*>::range(v13, 1uLL, a4);
      return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v8 + 112))(v8, v11, v9, v10, a5);
    }
  }
  return result;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::RelativeMemberOffsetPointerInfo>::overrideValueUntyped(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v10[3];
  char v11;
  _QWORD v12[2];

  v12[0] = a3;
  v12[1] = a4;
  if (!a4)
    return 0;
  v4 = *(_QWORD *)(a1 + 16);
  v10[0] = *(_QWORD *)(a1 + 8);
  v10[1] = 0;
  v5 = *(_QWORD *)(a2 + 16);
  v11 = 0;
  v10[2] = v4 + v5;
  if (!(v4 + v5))
    return 0;
  v6 = *a3;
  v7 = re::Slice<re::internal::BindPointImplBase const*>::range(v12, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v6 + 120))(v6, v10, v7, v8);
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::RelativeMemberOffsetPointerInfo>::markAsWritten(uint64_t result, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v9[3];
  char v10;
  _QWORD v11[2];

  v11[0] = a3;
  v11[1] = a4;
  if (a4)
  {
    v4 = *(_QWORD *)(result + 16);
    v9[0] = *(_QWORD *)(result + 8);
    v9[1] = 0;
    v5 = *(_QWORD *)(a2 + 16);
    v10 = 0;
    v9[2] = v4 + v5;
    if (v4 + v5)
    {
      v6 = *a3;
      v7 = re::Slice<re::internal::BindPointImplBase const*>::range(v11, 1uLL, a4);
      return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v6 + 128))(v6, v9, v7, v8);
    }
  }
  return result;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::RelativeMemberOffsetPointerInfo>::boundOwner()
{
  return 0;
}

void re::BindPoint::addToBindPointStack<`anonymous namespace'::IntrospectionBindPointImpl,`anonymous namespace'::IntrospectedObject const&>(_QWORD *a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _OWORD v7[2];
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  memset(v7, 0, sizeof(v7));
  re::DynamicArray<re::BindPoint::BindPointData>::add((_anonymous_namespace_ *)(a1 + 1), v7);
  re::BindPoint::BindPointData::deinit((re::BindPoint::BindPointData *)v7);
  v4 = a1[5] + 32 * a1[3];
  v5 = *a2;
  v6 = a2[2];
  *(_QWORD *)(v4 - 32) = &off_24ED3FE60;
  *(_QWORD *)(v4 - 24) = v5;
  *(_QWORD *)(v4 - 16) = v6;
}

void `anonymous namespace'::IntrospectionBindPointImpl::~IntrospectionBindPointImpl(_anonymous_namespace_::IntrospectionBindPointImpl *this)
{
  JUMPOUT(0x2276933B8);
}

void *re::internal::BindPointImpl<`anonymous namespace'::IntrospectionBindPointImpl>::implTypeInfo()
{
}

__n128 re::internal::BindPointImpl<`anonymous namespace'::IntrospectionBindPointImpl>::copyInto(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_24ED3FE60;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 re::internal::BindPointImpl<`anonymous namespace'::IntrospectionBindPointImpl>::moveInto(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_24ED3FE60;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

BOOL re::internal::BindPointImpl<`anonymous namespace'::IntrospectionBindPointImpl>::equals(uint64_t a1, _QWORD *a2)
{
      && *(_QWORD *)(a1 + 8) == a2[1]
      && *(_QWORD *)(a1 + 16) == a2[2];
}

unint64_t `anonymous namespace'::IntrospectionBindPointImpl::hash(uint64_t a1)
{
  unint64_t v1;

  v1 = 0xBF58476D1CE4E5B9 * (*(_QWORD *)(a1 + 16) ^ (*(_QWORD *)(a1 + 16) >> 30));
  return (0x94D049BB133111EBLL * (v1 ^ (v1 >> 27))) ^ ((0x94D049BB133111EBLL * (v1 ^ (v1 >> 27))) >> 31);
}

uint64_t `anonymous namespace'::IntrospectionBindPointImpl::isWeak(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD v9[3];
  char v10;
  _QWORD v11[2];

  v11[0] = a3;
  v11[1] = a4;
  v4 = *(_QWORD *)(a1 + 16);
  v9[0] = *(_QWORD *)(a1 + 8);
  v9[1] = 0;
  v9[2] = v4;
  v10 = 0;
  if (!a4)
    return 0;
  v5 = *a3;
  v6 = re::Slice<re::internal::BindPointImplBase const*>::range(v11, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v5 + 56))(v5, v9, v6, v7);
}

uint64_t `anonymous namespace'::IntrospectionBindPointImpl::isAlive(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD v9[3];
  char v10;
  _QWORD v11[2];

  v11[0] = a3;
  v11[1] = a4;
  v4 = *(_QWORD *)(a1 + 16);
  v9[0] = *(_QWORD *)(a1 + 8);
  v9[1] = 0;
  v9[2] = v4;
  v10 = 0;
  if (!a4)
    return 1;
  v5 = *a3;
  v6 = re::Slice<re::internal::BindPointImplBase const*>::range(v11, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v5 + 64))(v5, v9, v6, v7);
}

uint64_t `anonymous namespace'::IntrospectionBindPointImpl::baseValueUntyped(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v9[3];
  char v10;
  _QWORD v11[2];

  v11[0] = a3;
  v11[1] = a4;
  v5 = *(_QWORD *)(a1 + 8);
  result = *(_QWORD *)(a1 + 16);
  v9[0] = v5;
  v9[1] = 0;
  v9[2] = result;
  v10 = 0;
  if (a4)
  {
    v6 = *a3;
    v7 = re::Slice<re::internal::BindPointImplBase const*>::range(v11, 1uLL, a4);
    return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v6 + 88))(v6, v9, v7, v8);
  }
  return result;
}

uint64_t `anonymous namespace'::IntrospectionBindPointImpl::supportsOverrideValue(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD v9[3];
  char v10;
  _QWORD v11[2];

  v11[0] = a3;
  v11[1] = a4;
  if (!a4)
    return 0;
  v4 = *(_QWORD *)(a1 + 16);
  v9[0] = *(_QWORD *)(a1 + 8);
  v9[1] = 0;
  v9[2] = v4;
  v10 = 0;
  v5 = *a3;
  v6 = re::Slice<re::internal::BindPointImplBase const*>::range(v11, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v5 + 96))(v5, v9, v6, v7);
}

uint64_t `anonymous namespace'::IntrospectionBindPointImpl::isOverridden(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD v9[3];
  char v10;
  _QWORD v11[2];

  v11[0] = a3;
  v11[1] = a4;
  if (!a4)
    return 0;
  v4 = *(_QWORD *)(a1 + 16);
  v9[0] = *(_QWORD *)(a1 + 8);
  v9[1] = 0;
  v9[2] = v4;
  v10 = 0;
  v5 = *a3;
  v6 = re::Slice<re::internal::BindPointImplBase const*>::range(v11, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v5 + 104))(v5, v9, v6, v7);
}

uint64_t `anonymous namespace'::IntrospectionBindPointImpl::setIsOverridden(uint64_t result, uint64_t a2, uint64_t *a3, unint64_t a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v10[3];
  char v11;
  _QWORD v12[2];

  v12[0] = a3;
  v12[1] = a4;
  if (a4)
  {
    v6 = *(_QWORD *)(result + 16);
    v10[0] = *(_QWORD *)(result + 8);
    v10[1] = 0;
    v10[2] = v6;
    v11 = 0;
    v7 = *a3;
    v8 = re::Slice<re::internal::BindPointImplBase const*>::range(v12, 1uLL, a4);
    return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v7 + 112))(v7, v10, v8, v9, a5);
  }
  return result;
}

uint64_t `anonymous namespace'::IntrospectionBindPointImpl::overrideValueUntyped(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD v9[3];
  char v10;
  _QWORD v11[2];

  v11[0] = a3;
  v11[1] = a4;
  if (!a4)
    return 0;
  v4 = *(_QWORD *)(a1 + 16);
  v9[0] = *(_QWORD *)(a1 + 8);
  v9[1] = 0;
  v9[2] = v4;
  v10 = 0;
  v5 = *a3;
  v6 = re::Slice<re::internal::BindPointImplBase const*>::range(v11, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v5 + 120))(v5, v9, v6, v7);
}

uint64_t `anonymous namespace'::IntrospectionBindPointImpl::markAsWritten(uint64_t result, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD v8[3];
  char v9;
  _QWORD v10[2];

  v10[0] = a3;
  v10[1] = a4;
  if (a4)
  {
    v4 = *(_QWORD *)(result + 16);
    v8[0] = *(_QWORD *)(result + 8);
    v8[1] = 0;
    v8[2] = v4;
    v9 = 0;
    v5 = *a3;
    v6 = re::Slice<re::internal::BindPointImplBase const*>::range(v10, 1uLL, a4);
    return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v5 + 128))(v5, v8, v6, v7);
  }
  return result;
}

uint64_t `anonymous namespace'::IntrospectionBindPointImpl::boundOwner()
{
  return 0;
}

void `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayIndexPointerInfo<re::IntrospectionDynamicArrayBase>>::~PointerBindPointImpl()
{
  JUMPOUT(0x2276933B8);
}

void *re::internal::BindPointImpl<`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayIndexPointerInfo<re::IntrospectionDynamicArrayBase>>>::implTypeInfo()
{
}

__n128 re::internal::BindPointImpl<`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayIndexPointerInfo<re::IntrospectionDynamicArrayBase>>>::copyInto(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_24ED3FF30;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 re::internal::BindPointImpl<`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayIndexPointerInfo<re::IntrospectionDynamicArrayBase>>>::moveInto(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_24ED3FF30;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

BOOL re::internal::BindPointImpl<`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayIndexPointerInfo<re::IntrospectionDynamicArrayBase>>>::equals(uint64_t a1, _QWORD *a2)
{
      && *(_QWORD *)(a1 + 8) == a2[1]
      && *(_QWORD *)(a1 + 16) == a2[2];
}

unint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayIndexPointerInfo<re::IntrospectionDynamicArrayBase>>::hash(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _BYTE v12[16];
  unint64_t v13;
  _QWORD v14[2];

  v14[0] = a3;
  v14[1] = a4;
  v6 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (v13 ^ (v13 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v13 ^ (v13 >> 30))) >> 27));
  v7 = v6 ^ (v6 >> 31);
  if (a4 && v13)
  {
    v8 = *a3;
    v9 = re::Slice<re::internal::BindPointImplBase const*>::range(v14, 1uLL, a4);
    v7 ^= (v7 << 6)
        + (v7 >> 2)
        + (*(uint64_t (**)(uint64_t, _BYTE *, uint64_t, uint64_t))(*(_QWORD *)v8 + 48))(v8, v12, v9, v10)
        - 0x61C8864680B583E9;
  }
  return v7;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayIndexPointerInfo<re::IntrospectionDynamicArrayBase>>::isWeak()
{
  return 1;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayIndexPointerInfo<re::IntrospectionDynamicArrayBase>>::isAlive(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v10[4];
  _QWORD v11[2];

  v11[0] = a3;
  v11[1] = a4;
  if (!v10[2])
    return 0;
  if (!a4)
    return 1;
  v6 = *a3;
  v7 = re::Slice<re::internal::BindPointImplBase const*>::range(v11, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v6 + 64))(v6, v10, v7, v8);
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayIndexPointerInfo<re::IntrospectionDynamicArrayBase>>::baseValueUntyped(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _BYTE v10[16];
  uint64_t v11;
  _QWORD v12[2];

  v12[0] = a3;
  v12[1] = a4;
  result = v11;
  if (v11)
  {
    if (a4)
    {
      v7 = *a3;
      v8 = re::Slice<re::internal::BindPointImplBase const*>::range(v12, 1uLL, a4);
      return (*(uint64_t (**)(uint64_t, _BYTE *, uint64_t, uint64_t))(*(_QWORD *)v7 + 88))(v7, v10, v8, v9);
    }
  }
  return result;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayIndexPointerInfo<re::IntrospectionDynamicArrayBase>>::supportsOverrideValue(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v10[4];
  _QWORD v11[2];

  v11[0] = a3;
  v11[1] = a4;
  if (!a4)
    return 0;
  if (!v10[2])
    return 0;
  v6 = *a3;
  v7 = re::Slice<re::internal::BindPointImplBase const*>::range(v11, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v6 + 96))(v6, v10, v7, v8);
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayIndexPointerInfo<re::IntrospectionDynamicArrayBase>>::isOverridden(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v10[4];
  _QWORD v11[2];

  v11[0] = a3;
  v11[1] = a4;
  if (!a4)
    return 0;
  if (!v10[2])
    return 0;
  v6 = *a3;
  v7 = re::Slice<re::internal::BindPointImplBase const*>::range(v11, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v6 + 104))(v6, v10, v7, v8);
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayIndexPointerInfo<re::IntrospectionDynamicArrayBase>>::setIsOverridden(uint64_t result, uint64_t a2, uint64_t *a3, unint64_t a4, uint64_t a5)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD v11[4];
  _QWORD v12[2];

  v12[0] = a3;
  v12[1] = a4;
  if (a4)
  {
    if (v11[2])
    {
      v8 = *a3;
      v9 = re::Slice<re::internal::BindPointImplBase const*>::range(v12, 1uLL, a4);
      return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v8 + 112))(v8, v11, v9, v10, a5);
    }
  }
  return result;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayIndexPointerInfo<re::IntrospectionDynamicArrayBase>>::overrideValueUntyped(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v10[4];
  _QWORD v11[2];

  v11[0] = a3;
  v11[1] = a4;
  if (!a4)
    return 0;
  if (!v10[2])
    return 0;
  v6 = *a3;
  v7 = re::Slice<re::internal::BindPointImplBase const*>::range(v11, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v6 + 120))(v6, v10, v7, v8);
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayIndexPointerInfo<re::IntrospectionDynamicArrayBase>>::markAsWritten(uint64_t result, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v9[4];
  _QWORD v10[2];

  v10[0] = a3;
  v10[1] = a4;
  if (a4)
  {
    if (v9[2])
    {
      v6 = *a3;
      v7 = re::Slice<re::internal::BindPointImplBase const*>::range(v10, 1uLL, a4);
      return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v6 + 128))(v6, v9, v7, v8);
    }
  }
  return result;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayIndexPointerInfo<re::IntrospectionDynamicArrayBase>>::boundOwner()
{
  return 0;
}

uint64_t `anonymous namespace'::ArrayIndexPointerInfo<re::IntrospectionDynamicArrayBase>::pointerReference(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  unint64_t v6;
  uint64_t v7;
  uint64_t result;

  v6 = a2[1];
  if (v6 >= (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*a2 + 88))(*a2, *(_QWORD *)(a3 + 16)))
  {
    v7 = 0;
    result = 0;
  }
  else
  {
    v7 = (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*a2 + 40))(*a2, 0);
    result = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)*a2 + 96))(*a2, *(_QWORD *)(a3 + 16), a2[1]);
  }
  *(_QWORD *)a1 = v7;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = result;
  *(_BYTE *)(a1 + 24) = 0;
  return result;
}

void `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayIndexPointerInfo<re::IntrospectionFixedArrayBase>>::~PointerBindPointImpl()
{
  JUMPOUT(0x2276933B8);
}

void *re::internal::BindPointImpl<`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayIndexPointerInfo<re::IntrospectionFixedArrayBase>>>::implTypeInfo()
{
}

__n128 re::internal::BindPointImpl<`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayIndexPointerInfo<re::IntrospectionFixedArrayBase>>>::copyInto(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_24ED40000;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 re::internal::BindPointImpl<`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayIndexPointerInfo<re::IntrospectionFixedArrayBase>>>::moveInto(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_24ED40000;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

BOOL re::internal::BindPointImpl<`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayIndexPointerInfo<re::IntrospectionFixedArrayBase>>>::equals(uint64_t a1, _QWORD *a2)
{
      && *(_QWORD *)(a1 + 8) == a2[1]
      && *(_QWORD *)(a1 + 16) == a2[2];
}

unint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayIndexPointerInfo<re::IntrospectionFixedArrayBase>>::hash(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _BYTE v12[16];
  unint64_t v13;
  _QWORD v14[2];

  v14[0] = a3;
  v14[1] = a4;
  v6 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (v13 ^ (v13 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v13 ^ (v13 >> 30))) >> 27));
  v7 = v6 ^ (v6 >> 31);
  if (a4 && v13)
  {
    v8 = *a3;
    v9 = re::Slice<re::internal::BindPointImplBase const*>::range(v14, 1uLL, a4);
    v7 ^= (v7 << 6)
        + (v7 >> 2)
        + (*(uint64_t (**)(uint64_t, _BYTE *, uint64_t, uint64_t))(*(_QWORD *)v8 + 48))(v8, v12, v9, v10)
        - 0x61C8864680B583E9;
  }
  return v7;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayIndexPointerInfo<re::IntrospectionFixedArrayBase>>::isWeak()
{
  return 1;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayIndexPointerInfo<re::IntrospectionFixedArrayBase>>::isAlive(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v10[4];
  _QWORD v11[2];

  v11[0] = a3;
  v11[1] = a4;
  if (!v10[2])
    return 0;
  if (!a4)
    return 1;
  v6 = *a3;
  v7 = re::Slice<re::internal::BindPointImplBase const*>::range(v11, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v6 + 64))(v6, v10, v7, v8);
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayIndexPointerInfo<re::IntrospectionFixedArrayBase>>::baseValueUntyped(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _BYTE v10[16];
  uint64_t v11;
  _QWORD v12[2];

  v12[0] = a3;
  v12[1] = a4;
  result = v11;
  if (v11)
  {
    if (a4)
    {
      v7 = *a3;
      v8 = re::Slice<re::internal::BindPointImplBase const*>::range(v12, 1uLL, a4);
      return (*(uint64_t (**)(uint64_t, _BYTE *, uint64_t, uint64_t))(*(_QWORD *)v7 + 88))(v7, v10, v8, v9);
    }
  }
  return result;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayIndexPointerInfo<re::IntrospectionFixedArrayBase>>::supportsOverrideValue(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v10[4];
  _QWORD v11[2];

  v11[0] = a3;
  v11[1] = a4;
  if (!a4)
    return 0;
  if (!v10[2])
    return 0;
  v6 = *a3;
  v7 = re::Slice<re::internal::BindPointImplBase const*>::range(v11, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v6 + 96))(v6, v10, v7, v8);
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayIndexPointerInfo<re::IntrospectionFixedArrayBase>>::isOverridden(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v10[4];
  _QWORD v11[2];

  v11[0] = a3;
  v11[1] = a4;
  if (!a4)
    return 0;
  if (!v10[2])
    return 0;
  v6 = *a3;
  v7 = re::Slice<re::internal::BindPointImplBase const*>::range(v11, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v6 + 104))(v6, v10, v7, v8);
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayIndexPointerInfo<re::IntrospectionFixedArrayBase>>::setIsOverridden(uint64_t result, uint64_t a2, uint64_t *a3, unint64_t a4, uint64_t a5)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD v11[4];
  _QWORD v12[2];

  v12[0] = a3;
  v12[1] = a4;
  if (a4)
  {
    if (v11[2])
    {
      v8 = *a3;
      v9 = re::Slice<re::internal::BindPointImplBase const*>::range(v12, 1uLL, a4);
      return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v8 + 112))(v8, v11, v9, v10, a5);
    }
  }
  return result;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayIndexPointerInfo<re::IntrospectionFixedArrayBase>>::overrideValueUntyped(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v10[4];
  _QWORD v11[2];

  v11[0] = a3;
  v11[1] = a4;
  if (!a4)
    return 0;
  if (!v10[2])
    return 0;
  v6 = *a3;
  v7 = re::Slice<re::internal::BindPointImplBase const*>::range(v11, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v6 + 120))(v6, v10, v7, v8);
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayIndexPointerInfo<re::IntrospectionFixedArrayBase>>::markAsWritten(uint64_t result, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v9[4];
  _QWORD v10[2];

  v10[0] = a3;
  v10[1] = a4;
  if (a4)
  {
    if (v9[2])
    {
      v6 = *a3;
      v7 = re::Slice<re::internal::BindPointImplBase const*>::range(v10, 1uLL, a4);
      return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v6 + 128))(v6, v9, v7, v8);
    }
  }
  return result;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::ArrayIndexPointerInfo<re::IntrospectionFixedArrayBase>>::boundOwner()
{
  return 0;
}

uint64_t `anonymous namespace'::ArrayIndexPointerInfo<re::IntrospectionFixedArrayBase>::pointerReference(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  unint64_t v6;
  uint64_t v7;
  uint64_t result;

  v6 = a2[1];
  if (v6 >= (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*a2 + 80))(*a2, *(_QWORD *)(a3 + 16)))
  {
    v7 = 0;
    result = 0;
  }
  else
  {
    v7 = (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*a2 + 40))(*a2, 0);
    result = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)*a2 + 96))(*a2, *(_QWORD *)(a3 + 16), a2[1]);
  }
  *(_QWORD *)a1 = v7;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = result;
  *(_BYTE *)(a1 + 24) = 0;
  return result;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::KeyValueStorePointerInfo>::~PointerBindPointImpl(uint64_t a1)
{
  re::StringID::destroyString((re::StringID *)(a1 + 8));
  return a1;
}

void `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::KeyValueStorePointerInfo>::~PointerBindPointImpl(uint64_t a1)
{
  re::StringID::destroyString((re::StringID *)(a1 + 8));
  JUMPOUT(0x2276933B8);
}

const char *re::internal::BindPointImpl<`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::KeyValueStorePointerInfo>>::implTypeInfo()
{
  return " ";
}

re::StringID *re::internal::BindPointImpl<`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::KeyValueStorePointerInfo>>::copyInto(uint64_t a1, _QWORD *a2)
{
  re::StringID *result;

  *a2 = &off_24ED400D0;
  result = re::StringID::StringID((re::StringID *)(a2 + 1), (const StringID *)(a1 + 8));
  a2[3] = *(_QWORD *)(a1 + 24);
  return result;
}

re::StringID *re::internal::BindPointImpl<`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::KeyValueStorePointerInfo>>::moveInto(uint64_t a1, _QWORD *a2)
{
  re::StringID *result;

  *a2 = &off_24ED400D0;
  result = re::StringID::StringID((re::StringID *)(a2 + 1), (const StringID *)(a1 + 8));
  a2[3] = *(_QWORD *)(a1 + 24);
  return result;
}

BOOL re::internal::BindPointImpl<`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::KeyValueStorePointerInfo>>::equals(uint64_t a1, _QWORD *a2)
{
  _BOOL8 result;

  if ((char *)(*(uint64_t (**)(_QWORD *))(*a2 + 16))(a2) != " ")
    return 0;
  result = re::StringID::operator==((_QWORD *)(a1 + 8), a2 + 1);
  if (result)
    return *(_QWORD *)(a1 + 24) == a2[3];
  return result;
}

unint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::KeyValueStorePointerInfo>::hash(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD v15[3];
  char v16;
  _QWORD v17[2];

  v17[0] = a3;
  v17[1] = a4;
  v6 = **(_QWORD **)(a2 + 16);
  if (v6)
  {
    v7 = *(_QWORD *)(a1 + 24);
    v8 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(*(_QWORD *)v6 + 8))(**(_QWORD **)(a2 + 16), v7, a1 + 8);
  }
  else
  {
    v7 = 0;
    v8 = 0;
  }
  v15[0] = v7;
  v15[1] = 0;
  v15[2] = v8;
  v16 = 0;
  v9 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (v8 ^ (v8 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v8 ^ (v8 >> 30))) >> 27));
  v10 = v9 ^ (v9 >> 31);
  if (a4 && v8)
  {
    v11 = *a3;
    v12 = re::Slice<re::internal::BindPointImplBase const*>::range(v17, 1uLL, a4);
    v10 ^= (v10 << 6)
         + (v10 >> 2)
         + (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v11 + 48))(v11, v15, v12, v13)
         - 0x61C8864680B583E9;
  }
  return v10;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::KeyValueStorePointerInfo>::isWeak()
{
  return 1;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::KeyValueStorePointerInfo>::isAlive(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v4;
  uint64_t v7;
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD v12[3];
  char v13;
  _QWORD v14[2];

  v14[0] = a3;
  v14[1] = a4;
  v4 = **(_QWORD **)(a2 + 16);
  if (!v4)
    return 0;
  v7 = *(_QWORD *)(a1 + 24);
  result = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(*(_QWORD *)v4 + 8))(**(_QWORD **)(a2 + 16), v7, a1 + 8);
  v12[0] = v7;
  v12[1] = 0;
  v12[2] = result;
  v13 = 0;
  if (result)
  {
    if (a4)
    {
      v9 = *a3;
      v10 = re::Slice<re::internal::BindPointImplBase const*>::range(v14, 1uLL, a4);
      return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v9 + 64))(v9, v12, v10, v11);
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::KeyValueStorePointerInfo>::baseValueUntyped(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v4;
  uint64_t v7;
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD v12[3];
  char v13;
  _QWORD v14[2];

  v14[0] = a3;
  v14[1] = a4;
  v4 = **(_QWORD **)(a2 + 16);
  if (!v4)
    return 0;
  v7 = *(_QWORD *)(a1 + 24);
  result = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(*(_QWORD *)v4 + 8))(**(_QWORD **)(a2 + 16), v7, a1 + 8);
  v12[0] = v7;
  v12[1] = 0;
  v12[2] = result;
  v13 = 0;
  if (result)
  {
    if (a4)
    {
      v9 = *a3;
      v10 = re::Slice<re::internal::BindPointImplBase const*>::range(v14, 1uLL, a4);
      return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v9 + 88))(v9, v12, v10, v11);
    }
  }
  return result;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::KeyValueStorePointerInfo>::supportsOverrideValue(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v4;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD v13[3];
  char v14;
  _QWORD v15[2];

  v15[0] = a3;
  v15[1] = a4;
  if (!a4)
    return 0;
  v4 = **(_QWORD **)(a2 + 16);
  if (!v4)
    return 0;
  v7 = *(_QWORD *)(a1 + 24);
  v8 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(*(_QWORD *)v4 + 8))(**(_QWORD **)(a2 + 16), v7, a1 + 8);
  v13[0] = v7;
  v13[1] = 0;
  v13[2] = v8;
  v14 = 0;
  if (!v8)
    return 0;
  v9 = *a3;
  v10 = re::Slice<re::internal::BindPointImplBase const*>::range(v15, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v9 + 96))(v9, v13, v10, v11);
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::KeyValueStorePointerInfo>::isOverridden(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v4;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD v13[3];
  char v14;
  _QWORD v15[2];

  v15[0] = a3;
  v15[1] = a4;
  if (!a4)
    return 0;
  v4 = **(_QWORD **)(a2 + 16);
  if (!v4)
    return 0;
  v7 = *(_QWORD *)(a1 + 24);
  v8 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(*(_QWORD *)v4 + 8))(**(_QWORD **)(a2 + 16), v7, a1 + 8);
  v13[0] = v7;
  v13[1] = 0;
  v13[2] = v8;
  v14 = 0;
  if (!v8)
    return 0;
  v9 = *a3;
  v10 = re::Slice<re::internal::BindPointImplBase const*>::range(v15, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v9 + 104))(v9, v13, v10, v11);
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::KeyValueStorePointerInfo>::setIsOverridden(uint64_t result, uint64_t a2, uint64_t *a3, unint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD v13[3];
  char v14;
  _QWORD v15[2];

  v15[0] = a3;
  v15[1] = a4;
  if (a4)
  {
    v5 = **(_QWORD **)(a2 + 16);
    if (v5)
    {
      v9 = *(_QWORD *)(result + 24);
      result = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(*(_QWORD *)v5 + 8))(**(_QWORD **)(a2 + 16), v9, result + 8);
      v13[0] = v9;
      v13[1] = 0;
      v13[2] = result;
      v14 = 0;
      if (result)
      {
        v10 = *a3;
        v11 = re::Slice<re::internal::BindPointImplBase const*>::range(v15, 1uLL, a4);
        return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v10 + 112))(v10, v13, v11, v12, a5);
      }
    }
  }
  return result;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::KeyValueStorePointerInfo>::overrideValueUntyped(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v4;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD v13[3];
  char v14;
  _QWORD v15[2];

  v15[0] = a3;
  v15[1] = a4;
  if (!a4)
    return 0;
  v4 = **(_QWORD **)(a2 + 16);
  if (!v4)
    return 0;
  v7 = *(_QWORD *)(a1 + 24);
  v8 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(*(_QWORD *)v4 + 8))(**(_QWORD **)(a2 + 16), v7, a1 + 8);
  v13[0] = v7;
  v13[1] = 0;
  v13[2] = v8;
  v14 = 0;
  if (!v8)
    return 0;
  v9 = *a3;
  v10 = re::Slice<re::internal::BindPointImplBase const*>::range(v15, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v9 + 120))(v9, v13, v10, v11);
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::KeyValueStorePointerInfo>::markAsWritten(uint64_t result, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v4;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD v11[3];
  char v12;
  _QWORD v13[2];

  v13[0] = a3;
  v13[1] = a4;
  if (a4)
  {
    v4 = **(_QWORD **)(a2 + 16);
    if (v4)
    {
      v7 = *(_QWORD *)(result + 24);
      result = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(*(_QWORD *)v4 + 8))(**(_QWORD **)(a2 + 16), v7, result + 8);
      v11[0] = v7;
      v11[1] = 0;
      v11[2] = result;
      v12 = 0;
      if (result)
      {
        v8 = *a3;
        v9 = re::Slice<re::internal::BindPointImplBase const*>::range(v13, 1uLL, a4);
        return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v8 + 128))(v8, v11, v9, v10);
      }
    }
  }
  return result;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::KeyValueStorePointerInfo>::boundOwner()
{
  return 0;
}

void `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::PolymorphicPointerInfo>::~PointerBindPointImpl()
{
  JUMPOUT(0x2276933B8);
}

void *re::internal::BindPointImpl<`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::PolymorphicPointerInfo>>::implTypeInfo()
{
}

uint64_t re::internal::BindPointImpl<`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::PolymorphicPointerInfo>>::copyInto(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24ED401A0;
  a2[1] = v2;
  return result;
}

uint64_t re::internal::BindPointImpl<`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::PolymorphicPointerInfo>>::moveInto(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24ED401A0;
  a2[1] = v2;
  return result;
}

BOOL re::internal::BindPointImpl<`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::PolymorphicPointerInfo>>::equals(uint64_t a1, _QWORD *a2)
{
      && *(_QWORD *)(a1 + 8) == a2[1];
}

unint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::PolymorphicPointerInfo>::hash(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD v12[2];
  unint64_t v13;
  _QWORD v14[2];

  v14[0] = a3;
  v14[1] = a4;
  v6 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (v13 ^ (v13 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v13 ^ (v13 >> 30))) >> 27));
  v7 = v6 ^ (v6 >> 31);
  if (a4 && v13)
  {
    v8 = *a3;
    v9 = re::Slice<re::internal::BindPointImplBase const*>::range(v14, 1uLL, a4);
    v7 ^= (v7 << 6)
        + (v7 >> 2)
        + (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v8 + 48))(v8, v12, v9, v10)
        - 0x61C8864680B583E9;
  }
  return v7;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::PolymorphicPointerInfo>::isWeak()
{
  return 1;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::PolymorphicPointerInfo>::isAlive(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v10[4];
  _QWORD v11[2];

  v11[0] = a3;
  v11[1] = a4;
  if (!v10[2])
    return 0;
  if (!a4)
    return 1;
  v6 = *a3;
  v7 = re::Slice<re::internal::BindPointImplBase const*>::range(v11, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v6 + 64))(v6, v10, v7, v8);
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::PolymorphicPointerInfo>::baseValueUntyped(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v10[2];
  uint64_t v11;
  _QWORD v12[2];

  v12[0] = a3;
  v12[1] = a4;
  result = v11;
  if (v11)
  {
    if (a4)
    {
      v7 = *a3;
      v8 = re::Slice<re::internal::BindPointImplBase const*>::range(v12, 1uLL, a4);
      return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v7 + 88))(v7, v10, v8, v9);
    }
  }
  return result;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::PolymorphicPointerInfo>::supportsOverrideValue(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v10[4];
  _QWORD v11[2];

  v11[0] = a3;
  v11[1] = a4;
  if (!a4)
    return 0;
  if (!v10[2])
    return 0;
  v6 = *a3;
  v7 = re::Slice<re::internal::BindPointImplBase const*>::range(v11, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v6 + 96))(v6, v10, v7, v8);
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::PolymorphicPointerInfo>::isOverridden(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v10[4];
  _QWORD v11[2];

  v11[0] = a3;
  v11[1] = a4;
  if (!a4)
    return 0;
  if (!v10[2])
    return 0;
  v6 = *a3;
  v7 = re::Slice<re::internal::BindPointImplBase const*>::range(v11, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v6 + 104))(v6, v10, v7, v8);
}

_QWORD *`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::PolymorphicPointerInfo>::setIsOverridden(_QWORD *result, uint64_t a2, uint64_t *a3, unint64_t a4, uint64_t a5)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD v11[4];
  _QWORD v12[2];

  v12[0] = a3;
  v12[1] = a4;
  if (a4)
  {
    if (v11[2])
    {
      v8 = *a3;
      v9 = re::Slice<re::internal::BindPointImplBase const*>::range(v12, 1uLL, a4);
      return (_QWORD *)(*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v8 + 112))(v8, v11, v9, v10, a5);
    }
  }
  return result;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::PolymorphicPointerInfo>::overrideValueUntyped(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v10[4];
  _QWORD v11[2];

  v11[0] = a3;
  v11[1] = a4;
  if (!a4)
    return 0;
  if (!v10[2])
    return 0;
  v6 = *a3;
  v7 = re::Slice<re::internal::BindPointImplBase const*>::range(v11, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v6 + 120))(v6, v10, v7, v8);
}

_QWORD *`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::PolymorphicPointerInfo>::markAsWritten(_QWORD *result, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v9[4];
  _QWORD v10[2];

  v10[0] = a3;
  v10[1] = a4;
  if (a4)
  {
    if (v9[2])
    {
      v6 = *a3;
      v7 = re::Slice<re::internal::BindPointImplBase const*>::range(v10, 1uLL, a4);
      return (_QWORD *)(*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v6 + 128))(v6, v9, v7, v8);
    }
  }
  return result;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::PolymorphicPointerInfo>::boundOwner()
{
  return 0;
}

_QWORD *`anonymous namespace'::PolymorphicPointerInfo::pointerReference(_QWORD *result, uint64_t a2, re::IntrospectionBase *a3)
{
  uint64_t v3;
  _QWORD v5[3];

  v3 = (uint64_t)result;
  if (a3)
  {
    re::PolymorphicData::makeWithPointer(*(_QWORD *)(*(_QWORD *)a2 + 48), a3, v5);
  }
  else
  {
    *result = 0;
    result[1] = 0;
    *((_BYTE *)result + 24) = 0;
    result[2] = 0;
  }
  return result;
}

void *`anonymous namespace'::makePolymorphicPointer(uint64_t a1, uint64_t a2, uint64_t a3)
{
  const void *v6;
  uint64_t v7;
  void *result;
  unsigned int *v9;
  uint64_t v10;
  int *v11;
  uint64_t v12;
  uint64_t __dst;

  v6 = *(const void **)a2;
  v7 = *(_QWORD *)(a2 + 8);
  __dst = 0;
  result = memcpy(&__dst, v6, *(int *)(v7 + 20));
  v9 = *(unsigned int **)(a2 + 16);
  v10 = *v9;
  if ((_DWORD)v10)
  {
    v11 = (int *)(*((_QWORD *)v9 + 1) + 32);
    while (*((_QWORD *)v11 - 1) != __dst)
    {
      v11 += 10;
      if (!--v10)
      {
        v12 = 0;
        goto LABEL_8;
      }
    }
    v10 = a3 + *v11;
    v12 = *((_QWORD *)v11 - 3);
  }
  else
  {
    v12 = 0;
    v10 = 0;
  }
LABEL_8:
  *(_QWORD *)a1 = v12;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = v10;
  *(_BYTE *)(a1 + 24) = 0;
  return result;
}

void `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::RawPointerInfo>::~PointerBindPointImpl()
{
  JUMPOUT(0x2276933B8);
}

void *re::internal::BindPointImpl<`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::RawPointerInfo>>::implTypeInfo()
{
}

uint64_t re::internal::BindPointImpl<`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::RawPointerInfo>>::copyInto(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24ED40270;
  a2[1] = v2;
  return result;
}

uint64_t re::internal::BindPointImpl<`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::RawPointerInfo>>::moveInto(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24ED40270;
  a2[1] = v2;
  return result;
}

BOOL re::internal::BindPointImpl<`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::RawPointerInfo>>::equals(uint64_t a1, _QWORD *a2)
{
      && *(_QWORD *)(a1 + 8) == a2[1];
}

unint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::RawPointerInfo>::hash(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD v12[3];
  char v13;
  _QWORD v14[2];

  v14[0] = a3;
  v14[1] = a4;
  v4 = **(_QWORD **)(a2 + 16);
  if (v4)
    v5 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 48);
  else
    v5 = 0;
  v12[0] = v5;
  v12[1] = 0;
  v12[2] = v4;
  v13 = 0;
  v6 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (v4 ^ (v4 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v4 ^ (v4 >> 30))) >> 27));
  v7 = v6 ^ (v6 >> 31);
  if (a4 && v4)
  {
    v8 = *a3;
    v9 = re::Slice<re::internal::BindPointImplBase const*>::range(v14, 1uLL, a4);
    v7 ^= (v7 << 6)
        + (v7 >> 2)
        + (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v8 + 48))(v8, v12, v9, v10)
        - 0x61C8864680B583E9;
  }
  return v7;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::RawPointerInfo>::isWeak()
{
  return 1;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::RawPointerInfo>::isAlive(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD v9[3];
  char v10;
  _QWORD v11[2];

  v11[0] = a3;
  v11[1] = a4;
  v4 = **(_QWORD **)(a2 + 16);
  if (!v4)
    return 0;
  v9[0] = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 48);
  v9[1] = 0;
  v9[2] = v4;
  v10 = 0;
  if (!a4)
    return 1;
  v5 = *a3;
  v6 = re::Slice<re::internal::BindPointImplBase const*>::range(v11, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v5 + 64))(v5, v9, v6, v7);
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::RawPointerInfo>::baseValueUntyped(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v9[3];
  char v10;
  _QWORD v11[2];

  v11[0] = a3;
  v11[1] = a4;
  result = **(_QWORD **)(a2 + 16);
  if (result)
  {
    v9[0] = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 48);
    v9[1] = 0;
    v9[2] = result;
    v10 = 0;
    if (a4)
    {
      v6 = *a3;
      v7 = re::Slice<re::internal::BindPointImplBase const*>::range(v11, 1uLL, a4);
      return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v6 + 88))(v6, v9, v7, v8);
    }
  }
  return result;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::RawPointerInfo>::supportsOverrideValue(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD v9[3];
  char v10;
  _QWORD v11[2];

  v11[0] = a3;
  v11[1] = a4;
  if (!a4)
    return 0;
  v4 = **(_QWORD **)(a2 + 16);
  if (!v4)
    return 0;
  v9[0] = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 48);
  v9[1] = 0;
  v9[2] = v4;
  v10 = 0;
  v5 = *a3;
  v6 = re::Slice<re::internal::BindPointImplBase const*>::range(v11, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v5 + 96))(v5, v9, v6, v7);
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::RawPointerInfo>::isOverridden(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD v9[3];
  char v10;
  _QWORD v11[2];

  v11[0] = a3;
  v11[1] = a4;
  if (!a4)
    return 0;
  v4 = **(_QWORD **)(a2 + 16);
  if (!v4)
    return 0;
  v9[0] = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 48);
  v9[1] = 0;
  v9[2] = v4;
  v10 = 0;
  v5 = *a3;
  v6 = re::Slice<re::internal::BindPointImplBase const*>::range(v11, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v5 + 104))(v5, v9, v6, v7);
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::RawPointerInfo>::setIsOverridden(uint64_t result, uint64_t a2, uint64_t *a3, unint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v10[3];
  char v11;
  _QWORD v12[2];

  v12[0] = a3;
  v12[1] = a4;
  if (a4)
  {
    v5 = **(_QWORD **)(a2 + 16);
    if (v5)
    {
      v10[0] = *(_QWORD *)(*(_QWORD *)(result + 8) + 48);
      v10[1] = 0;
      v10[2] = v5;
      v11 = 0;
      v7 = *a3;
      v8 = re::Slice<re::internal::BindPointImplBase const*>::range(v12, 1uLL, a4);
      return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v7 + 112))(v7, v10, v8, v9, a5);
    }
  }
  return result;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::RawPointerInfo>::overrideValueUntyped(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD v9[3];
  char v10;
  _QWORD v11[2];

  v11[0] = a3;
  v11[1] = a4;
  if (!a4)
    return 0;
  v4 = **(_QWORD **)(a2 + 16);
  if (!v4)
    return 0;
  v9[0] = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 48);
  v9[1] = 0;
  v9[2] = v4;
  v10 = 0;
  v5 = *a3;
  v6 = re::Slice<re::internal::BindPointImplBase const*>::range(v11, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v5 + 120))(v5, v9, v6, v7);
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::RawPointerInfo>::markAsWritten(uint64_t result, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD v8[3];
  char v9;
  _QWORD v10[2];

  v10[0] = a3;
  v10[1] = a4;
  if (a4)
  {
    v4 = **(_QWORD **)(a2 + 16);
    if (v4)
    {
      v8[0] = *(_QWORD *)(*(_QWORD *)(result + 8) + 48);
      v8[1] = 0;
      v8[2] = v4;
      v9 = 0;
      v5 = *a3;
      v6 = re::Slice<re::internal::BindPointImplBase const*>::range(v10, 1uLL, a4);
      return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v5 + 128))(v5, v8, v6, v7);
    }
  }
  return result;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::RawPointerInfo>::boundOwner()
{
  return 0;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::HashTableKeyPointerInfo>::~PointerBindPointImpl(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;

  v3 = (_OWORD *)(a1 + 16);
  v2 = *(_QWORD *)(a1 + 16);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 24) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 32));
    *v3 = 0u;
    v3[1] = 0u;
  }
  return a1;
}

void `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::HashTableKeyPointerInfo>::~PointerBindPointImpl(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;

  v3 = (_OWORD *)(a1 + 16);
  v2 = *(_QWORD *)(a1 + 16);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 24) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 32));
    *v3 = 0u;
    v3[1] = 0u;
  }
  JUMPOUT(0x2276933B8);
}

const char *re::internal::BindPointImpl<`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::HashTableKeyPointerInfo>>::implTypeInfo()
{
  return "0";
}

re::DynamicString *re::internal::BindPointImpl<`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::HashTableKeyPointerInfo>>::copyInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = off_24ED40340;
  a2[1] = v2;
  return re::DynamicString::DynamicString((re::DynamicString *)(a2 + 2), (const re::DynamicString *)(a1 + 16));
}

re::DynamicString *re::internal::BindPointImpl<`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::HashTableKeyPointerInfo>>::moveInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = off_24ED40340;
  a2[1] = v2;
  return re::DynamicString::DynamicString((re::DynamicString *)(a2 + 2), (const re::DynamicString *)(a1 + 16));
}

BOOL re::internal::BindPointImpl<`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::HashTableKeyPointerInfo>>::equals(uint64_t a1, _QWORD *a2)
{
  return (char *)(*(uint64_t (**)(_QWORD *))(*a2 + 16))(a2) == "0"
      && *(_QWORD *)(a1 + 8) == a2[1]
      && re::DynamicString::operator==(a1 + 16, (uint64_t)(a2 + 2));
}

unint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::HashTableKeyPointerInfo>::hash(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _BYTE v12[16];
  unint64_t v13;
  _QWORD v14[2];

  v14[0] = a3;
  v14[1] = a4;
  v6 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (v13 ^ (v13 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v13 ^ (v13 >> 30))) >> 27));
  v7 = v6 ^ (v6 >> 31);
  if (a4 && v13)
  {
    v8 = *a3;
    v9 = re::Slice<re::internal::BindPointImplBase const*>::range(v14, 1uLL, a4);
    v7 ^= (v7 << 6)
        + (v7 >> 2)
        + (*(uint64_t (**)(uint64_t, _BYTE *, uint64_t, uint64_t))(*(_QWORD *)v8 + 48))(v8, v12, v9, v10)
        - 0x61C8864680B583E9;
  }
  return v7;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::HashTableKeyPointerInfo>::isWeak()
{
  return 1;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::HashTableKeyPointerInfo>::isAlive(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v10[4];
  _QWORD v11[2];

  v11[0] = a3;
  v11[1] = a4;
  if (!v10[2])
    return 0;
  if (!a4)
    return 1;
  v6 = *a3;
  v7 = re::Slice<re::internal::BindPointImplBase const*>::range(v11, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v6 + 64))(v6, v10, v7, v8);
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::HashTableKeyPointerInfo>::baseValueUntyped(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _BYTE v10[16];
  uint64_t v11;
  _QWORD v12[2];

  v12[0] = a3;
  v12[1] = a4;
  result = v11;
  if (v11)
  {
    if (a4)
    {
      v7 = *a3;
      v8 = re::Slice<re::internal::BindPointImplBase const*>::range(v12, 1uLL, a4);
      return (*(uint64_t (**)(uint64_t, _BYTE *, uint64_t, uint64_t))(*(_QWORD *)v7 + 88))(v7, v10, v8, v9);
    }
  }
  return result;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::HashTableKeyPointerInfo>::supportsOverrideValue(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v10[4];
  _QWORD v11[2];

  v11[0] = a3;
  v11[1] = a4;
  if (!a4)
    return 0;
  if (!v10[2])
    return 0;
  v6 = *a3;
  v7 = re::Slice<re::internal::BindPointImplBase const*>::range(v11, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v6 + 96))(v6, v10, v7, v8);
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::HashTableKeyPointerInfo>::isOverridden(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v10[4];
  _QWORD v11[2];

  v11[0] = a3;
  v11[1] = a4;
  if (!a4)
    return 0;
  if (!v10[2])
    return 0;
  v6 = *a3;
  v7 = re::Slice<re::internal::BindPointImplBase const*>::range(v11, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v6 + 104))(v6, v10, v7, v8);
}

void `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::HashTableKeyPointerInfo>::setIsOverridden(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4, uint64_t a5)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD v11[4];
  _QWORD v12[2];

  v12[0] = a3;
  v12[1] = a4;
  if (a4)
  {
    if (v11[2])
    {
      v8 = *a3;
      v9 = re::Slice<re::internal::BindPointImplBase const*>::range(v12, 1uLL, a4);
      (*(void (**)(uint64_t, _QWORD *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v8 + 112))(v8, v11, v9, v10, a5);
    }
  }
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::HashTableKeyPointerInfo>::overrideValueUntyped(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v10[4];
  _QWORD v11[2];

  v11[0] = a3;
  v11[1] = a4;
  if (!a4)
    return 0;
  if (!v10[2])
    return 0;
  v6 = *a3;
  v7 = re::Slice<re::internal::BindPointImplBase const*>::range(v11, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v6 + 120))(v6, v10, v7, v8);
}

void `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::HashTableKeyPointerInfo>::markAsWritten(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v9[4];
  _QWORD v10[2];

  v10[0] = a3;
  v10[1] = a4;
  if (a4)
  {
    if (v9[2])
    {
      v6 = *a3;
      v7 = re::Slice<re::internal::BindPointImplBase const*>::range(v10, 1uLL, a4);
      (*(void (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v6 + 128))(v6, v9, v7, v8);
    }
  }
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::HashTableKeyPointerInfo>::boundOwner()
{
  return 0;
}

void `anonymous namespace'::HashTableKeyPointerInfo::pointerReference(uint64_t a1, char *a2, uint64_t a3)
{
  _QWORD *v4;
  uint64_t v5;
  unint64_t v6;
  char *v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unsigned __int8 v11;
  __guard *v12;
  uint64_t v13;
  unsigned __int8 v14;
  __guard *v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t (**v18)();
  _QWORD *v19;
  uint64_t v20;
  int v21;
  const re::IntrospectionBase *v22;
  int v23;
  const re::IntrospectionBase *v24;
  uint64_t v25;
  uint64_t v26;
  _QWORD v27[2];
  uint64_t v28;
  _BYTE v29[24];
  _BYTE *v30;
  uint64_t v31;

  v31 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD **)a2;
  *(_QWORD *)a1 = *(_QWORD *)(*(_QWORD *)a2 + 64);
  *(_QWORD *)(a1 + 8) = 0;
  v5 = *(_QWORD *)(a3 + 16);
  v6 = *((_QWORD *)a2 + 2);
  v7 = (char *)*((_QWORD *)a2 + 3);
  if ((v6 & 1) == 0)
    v7 = a2 + 17;
  v8 = v6 >> 1;
  v9 = v6 >> 1;
  if ((*((_QWORD *)a2 + 2) & 1) != 0)
    v9 = v8;
  v27[0] = v7;
  v27[1] = v9;
  v10 = v4[6];
  if ((v11 & 1) == 0)
  {
    v25 = v4[6];
    v10 = v25;
    if (v21)
    {
      re::introspect<re::DynamicString>(void)::info = (uint64_t)re::IntrospectionInfo<re::DynamicString>::get(0, v22);
      v10 = v25;
    }
  }
  if (v10 == v12[42])
  {
    v28 = 0;
    v17 = operator new(0x20uLL);
    v18 = &off_24ED40410;
    goto LABEL_12;
  }
  v13 = v4[6];
  if ((v14 & 1) == 0)
  {
    v26 = v4[6];
    v13 = v26;
    if (v23)
    {
      re::introspect<re::StringID>(void)::info = (uint64_t)re::IntrospectionInfo<re::StringID>::get(0, v24);
      v13 = v26;
    }
  }
  if (v13 == v15[169])
  {
    v28 = 0;
    v17 = operator new(0x20uLL);
    v18 = &off_24ED404A0;
LABEL_12:
    *v17 = v18;
    v17[1] = v4;
    v17[2] = v27;
    v17[3] = &v28;
    v30 = v17;
    (*(void (**)(_QWORD *, uint64_t, _BYTE *))(*v4 + 104))(v4, v5, v29);
    v19 = v30;
    if (v30 == v29)
    {
      v20 = 4;
      v19 = v29;
    }
    else
    {
      if (!v30)
      {
LABEL_17:
        v16 = v28;
        goto LABEL_18;
      }
      v20 = 5;
    }
    (*(void (**)(void))(*v19 + 8 * v20))();
    goto LABEL_17;
  }
  v16 = 0;
LABEL_18:
  *(_QWORD *)(a1 + 16) = v16;
  *(_BYTE *)(a1 + 24) = 0;
}

void std::__function::__func<void * `anonymous namespace'::tryGetValue<re::DynamicString>(re::IntrospectionHashTableBase const*,void *,re::StringSlice const&)::{lambda(void const*,void *)#1},std::allocator<void * `anonymous namespace'::tryGetValue<re::DynamicString>(re::IntrospectionHashTableBase const*,void *,re::StringSlice const&)::{lambda(void const*,void *)#1}>,BOOL ()(void const*,void *)>::~__func()
{
  JUMPOUT(0x2276933B8);
}

__n128 std::__function::__func<void * `anonymous namespace'::tryGetValue<re::DynamicString>(re::IntrospectionHashTableBase const*,void *,re::StringSlice const&)::{lambda(void const*,void *)#1},std::allocator<void * `anonymous namespace'::tryGetValue<re::DynamicString>(re::IntrospectionHashTableBase const*,void *,re::StringSlice const&)::{lambda(void const*,void *)#1}>,BOOL ()(void const*,void *)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &off_24ED40410;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<void * `anonymous namespace'::tryGetValue<re::DynamicString>(re::IntrospectionHashTableBase const*,void *,re::StringSlice const&)::{lambda(void const*,void *)#1},std::allocator<void * `anonymous namespace'::tryGetValue<re::DynamicString>(re::IntrospectionHashTableBase const*,void *,re::StringSlice const&)::{lambda(void const*,void *)#1}>,BOOL ()(void const*,void *)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_24ED40410;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<void * `anonymous namespace'::tryGetValue<re::DynamicString>(re::IntrospectionHashTableBase const*,void *,re::StringSlice const&)::{lambda(void const*,void *)#1},std::allocator<void * `anonymous namespace'::tryGetValue<re::DynamicString>(re::IntrospectionHashTableBase const*,void *,re::StringSlice const&)::{lambda(void const*,void *)#1}>,BOOL ()(void const*,void *)>::operator()(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  size_t v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const void *v12;
  uint64_t result;

  v4 = *a2;
  v5 = *(_QWORD *)(a1 + 16);
  v6 = *(_QWORD *)(*a2 + 8);
  if ((v6 & 1) != 0)
    v7 = v6 >> 1;
  else
    v7 = v6 >> 1;
  if (*(_QWORD *)(v5 + 8) != v7)
    return 1;
  v9 = *a3;
  v10 = v4 + 9;
  v11 = *(_QWORD *)(v4 + 16);
  v12 = (const void *)((v6 & 1) != 0 ? v11 : v10);
  result = memcmp(*(const void **)v5, v12, v7);
  if ((_DWORD)result)
    return 1;
  **(_QWORD **)(a1 + 24) = v9;
  return result;
}

uint64_t std::__function::__func<void * `anonymous namespace'::tryGetValue<re::DynamicString>(re::IntrospectionHashTableBase const*,void *,re::StringSlice const&)::{lambda(void const*,void *)#1},std::allocator<void * `anonymous namespace'::tryGetValue<re::DynamicString>(re::IntrospectionHashTableBase const*,void *,re::StringSlice const&)::{lambda(void const*,void *)#1}>,BOOL ()(void const*,void *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void * `anonymous namespace'::tryGetValue<re::DynamicString>(re::IntrospectionHashTableBase const*,void *,re::StringSlice const&)::{lambda(void const*,void *)#1},std::allocator<void * `anonymous namespace'::tryGetValue<re::DynamicString>(re::IntrospectionHashTableBase const*,void *,re::StringSlice const&)::{lambda(void const*,void *)#1}>,BOOL ()(void const*,void *)>::target_type()
{
}

void std::__function::__func<void * `anonymous namespace'::tryGetValue<re::StringID>(re::IntrospectionHashTableBase const*,void *,re::StringSlice const&)::{lambda(void const*,void *)#1},std::allocator<void * `anonymous namespace'::tryGetValue<re::StringID>(re::IntrospectionHashTableBase const*,void *,re::StringSlice const&)::{lambda(void const*,void *)#1}>,BOOL ()(void const*,void *)>::~__func()
{
  JUMPOUT(0x2276933B8);
}

__n128 std::__function::__func<void * `anonymous namespace'::tryGetValue<re::StringID>(re::IntrospectionHashTableBase const*,void *,re::StringSlice const&)::{lambda(void const*,void *)#1},std::allocator<void * `anonymous namespace'::tryGetValue<re::StringID>(re::IntrospectionHashTableBase const*,void *,re::StringSlice const&)::{lambda(void const*,void *)#1}>,BOOL ()(void const*,void *)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &off_24ED404A0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<void * `anonymous namespace'::tryGetValue<re::StringID>(re::IntrospectionHashTableBase const*,void *,re::StringSlice const&)::{lambda(void const*,void *)#1},std::allocator<void * `anonymous namespace'::tryGetValue<re::StringID>(re::IntrospectionHashTableBase const*,void *,re::StringSlice const&)::{lambda(void const*,void *)#1}>,BOOL ()(void const*,void *)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_24ED404A0;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<void * `anonymous namespace'::tryGetValue<re::StringID>(re::IntrospectionHashTableBase const*,void *,re::StringSlice const&)::{lambda(void const*,void *)#1},std::allocator<void * `anonymous namespace'::tryGetValue<re::StringID>(re::IntrospectionHashTableBase const*,void *,re::StringSlice const&)::{lambda(void const*,void *)#1}>,BOOL ()(void const*,void *)>::operator()(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4;
  uint64_t v5;
  const char *v6;
  size_t v7;
  uint64_t result;

  v4 = *a3;
  v5 = *(_QWORD *)(a1 + 16);
  v6 = *(const char **)(*(_QWORD *)a2 + 8);
  v7 = strlen(v6);
  if (*(_QWORD *)(v5 + 8) != v7)
    return 1;
  result = memcmp(*(const void **)v5, v6, v7);
  if ((_DWORD)result)
    return 1;
  **(_QWORD **)(a1 + 24) = v4;
  return result;
}

uint64_t std::__function::__func<void * `anonymous namespace'::tryGetValue<re::StringID>(re::IntrospectionHashTableBase const*,void *,re::StringSlice const&)::{lambda(void const*,void *)#1},std::allocator<void * `anonymous namespace'::tryGetValue<re::StringID>(re::IntrospectionHashTableBase const*,void *,re::StringSlice const&)::{lambda(void const*,void *)#1}>,BOOL ()(void const*,void *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void * `anonymous namespace'::tryGetValue<re::StringID>(re::IntrospectionHashTableBase const*,void *,re::StringSlice const&)::{lambda(void const*,void *)#1},std::allocator<void * `anonymous namespace'::tryGetValue<re::StringID>(re::IntrospectionHashTableBase const*,void *,re::StringSlice const&)::{lambda(void const*,void *)#1}>,BOOL ()(void const*,void *)>::target_type()
{
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::KeyValueStoreTypedMemberPointerInfo>::~PointerBindPointImpl(uint64_t a1)
{
  re::StringID::destroyString((re::StringID *)(a1 + 16));
  return a1;
}

void `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::KeyValueStoreTypedMemberPointerInfo>::~PointerBindPointImpl(uint64_t a1)
{
  re::StringID::destroyString((re::StringID *)(a1 + 16));
  JUMPOUT(0x2276933B8);
}

const char *re::internal::BindPointImpl<`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::KeyValueStoreTypedMemberPointerInfo>>::implTypeInfo()
{
  return " ";
}

re::StringID *re::internal::BindPointImpl<`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::KeyValueStoreTypedMemberPointerInfo>>::copyInto(const StringID *a1, _QWORD *a2)
{
  char *var1;

  var1 = a1->var1;
  *a2 = &off_24ED40520;
  a2[1] = var1;
  return re::StringID::StringID((re::StringID *)(a2 + 2), a1 + 1);
}

re::StringID *re::internal::BindPointImpl<`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::KeyValueStoreTypedMemberPointerInfo>>::moveInto(const StringID *a1, _QWORD *a2)
{
  char *var1;

  var1 = a1->var1;
  *a2 = &off_24ED40520;
  a2[1] = var1;
  return re::StringID::StringID((re::StringID *)(a2 + 2), a1 + 1);
}

BOOL re::internal::BindPointImpl<`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::KeyValueStoreTypedMemberPointerInfo>>::equals(uint64_t a1, _QWORD *a2)
{
  return (char *)(*(uint64_t (**)(_QWORD *))(*a2 + 16))(a2) == " "
      && *(_QWORD *)(a1 + 8) == a2[1]
      && re::StringID::operator==((_QWORD *)(a1 + 16), a2 + 2);
}

unint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::KeyValueStoreTypedMemberPointerInfo>::hash(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD v14[3];
  char v15;
  _QWORD v16[2];

  v16[0] = a3;
  v16[1] = a4;
  v6 = *(_QWORD *)(a2 + 16);
  v14[0] = *(_QWORD *)(a1 + 8);
  v14[1] = 0;
  v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
  v14[2] = v7;
  v15 = 0;
  v8 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (v7 ^ (v7 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v7 ^ (v7 >> 30))) >> 27));
  v9 = v8 ^ (v8 >> 31);
  if (a4 && v7)
  {
    v10 = *a3;
    v11 = re::Slice<re::internal::BindPointImplBase const*>::range(v16, 1uLL, a4);
    v9 ^= (v9 << 6)
        + (v9 >> 2)
        + (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v10 + 48))(v10, v14, v11, v12)
        - 0x61C8864680B583E9;
  }
  return v9;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::KeyValueStoreTypedMemberPointerInfo>::isWeak()
{
  return 1;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::KeyValueStoreTypedMemberPointerInfo>::isAlive(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v6;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD v11[3];
  char v12;
  _QWORD v13[2];

  v13[0] = a3;
  v13[1] = a4;
  v6 = *(_QWORD *)(a2 + 16);
  v11[0] = *(_QWORD *)(a1 + 8);
  v11[1] = 0;
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
  v11[2] = result;
  v12 = 0;
  if (result)
  {
    if (a4)
    {
      v8 = *a3;
      v9 = re::Slice<re::internal::BindPointImplBase const*>::range(v13, 1uLL, a4);
      return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v8 + 64))(v8, v11, v9, v10);
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::KeyValueStoreTypedMemberPointerInfo>::baseValueUntyped(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v6;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD v11[3];
  char v12;
  _QWORD v13[2];

  v13[0] = a3;
  v13[1] = a4;
  v6 = *(_QWORD *)(a2 + 16);
  v11[0] = *(_QWORD *)(a1 + 8);
  v11[1] = 0;
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
  v11[2] = result;
  v12 = 0;
  if (result)
  {
    if (a4)
    {
      v8 = *a3;
      v9 = re::Slice<re::internal::BindPointImplBase const*>::range(v13, 1uLL, a4);
      return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v8 + 88))(v8, v11, v9, v10);
    }
  }
  return result;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::KeyValueStoreTypedMemberPointerInfo>::supportsOverrideValue(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v6;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD v11[3];
  char v12;
  _QWORD v13[2];

  v13[0] = a3;
  v13[1] = a4;
  if (!a4)
    return 0;
  v6 = *(_QWORD *)(a2 + 16);
  v11[0] = *(_QWORD *)(a1 + 8);
  v11[1] = 0;
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
  v11[2] = result;
  v12 = 0;
  if (result)
  {
    v8 = *a3;
    v9 = re::Slice<re::internal::BindPointImplBase const*>::range(v13, 1uLL, a4);
    return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v8 + 96))(v8, v11, v9, v10);
  }
  return result;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::KeyValueStoreTypedMemberPointerInfo>::isOverridden(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v6;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD v11[3];
  char v12;
  _QWORD v13[2];

  v13[0] = a3;
  v13[1] = a4;
  if (!a4)
    return 0;
  v6 = *(_QWORD *)(a2 + 16);
  v11[0] = *(_QWORD *)(a1 + 8);
  v11[1] = 0;
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
  v11[2] = result;
  v12 = 0;
  if (result)
  {
    v8 = *a3;
    v9 = re::Slice<re::internal::BindPointImplBase const*>::range(v13, 1uLL, a4);
    return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v8 + 104))(v8, v11, v9, v10);
  }
  return result;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::KeyValueStoreTypedMemberPointerInfo>::setIsOverridden(uint64_t result, uint64_t a2, uint64_t *a3, unint64_t a4, uint64_t a5)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD v12[3];
  char v13;
  _QWORD v14[2];

  v14[0] = a3;
  v14[1] = a4;
  if (a4)
  {
    v8 = *(_QWORD *)(a2 + 16);
    v12[0] = *(_QWORD *)(result + 8);
    v12[1] = 0;
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v8 + 8))(v8);
    v12[2] = result;
    v13 = 0;
    if (result)
    {
      v9 = *a3;
      v10 = re::Slice<re::internal::BindPointImplBase const*>::range(v14, 1uLL, a4);
      return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v9 + 112))(v9, v12, v10, v11, a5);
    }
  }
  return result;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::KeyValueStoreTypedMemberPointerInfo>::overrideValueUntyped(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v6;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD v11[3];
  char v12;
  _QWORD v13[2];

  v13[0] = a3;
  v13[1] = a4;
  if (!a4)
    return 0;
  v6 = *(_QWORD *)(a2 + 16);
  v11[0] = *(_QWORD *)(a1 + 8);
  v11[1] = 0;
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
  v11[2] = result;
  v12 = 0;
  if (result)
  {
    v8 = *a3;
    v9 = re::Slice<re::internal::BindPointImplBase const*>::range(v13, 1uLL, a4);
    return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v8 + 120))(v8, v11, v9, v10);
  }
  return result;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::KeyValueStoreTypedMemberPointerInfo>::markAsWritten(uint64_t result, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v10[3];
  char v11;
  _QWORD v12[2];

  v12[0] = a3;
  v12[1] = a4;
  if (a4)
  {
    v6 = *(_QWORD *)(a2 + 16);
    v10[0] = *(_QWORD *)(result + 8);
    v10[1] = 0;
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
    v10[2] = result;
    v11 = 0;
    if (result)
    {
      v7 = *a3;
      v8 = re::Slice<re::internal::BindPointImplBase const*>::range(v12, 1uLL, a4);
      return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v7 + 128))(v7, v10, v8, v9);
    }
  }
  return result;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::KeyValueStoreTypedMemberPointerInfo>::boundOwner()
{
  return 0;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::KeyValueStoreMemberPointerInfo>::~PointerBindPointImpl(uint64_t a1)
{
  re::StringID::destroyString((re::StringID *)(a1 + 8));
  return a1;
}

void `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::KeyValueStoreMemberPointerInfo>::~PointerBindPointImpl(uint64_t a1)
{
  re::StringID::destroyString((re::StringID *)(a1 + 8));
  JUMPOUT(0x2276933B8);
}

void *re::internal::BindPointImpl<`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::KeyValueStoreMemberPointerInfo>>::implTypeInfo()
{
}

re::StringID *re::internal::BindPointImpl<`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::KeyValueStoreMemberPointerInfo>>::copyInto(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24ED405F0;
  return re::StringID::StringID((re::StringID *)(a2 + 1), (const StringID *)(a1 + 8));
}

re::StringID *re::internal::BindPointImpl<`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::KeyValueStoreMemberPointerInfo>>::moveInto(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24ED405F0;
  return re::StringID::StringID((re::StringID *)(a2 + 1), (const StringID *)(a1 + 8));
}

BOOL re::internal::BindPointImpl<`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::KeyValueStoreMemberPointerInfo>>::equals(uint64_t a1, _QWORD *a2)
{
      && re::StringID::operator==((_QWORD *)(a1 + 8), a2 + 1);
}

unint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::KeyValueStoreMemberPointerInfo>::hash(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD v15[3];
  char v16;
  _QWORD v17[2];

  v17[0] = a3;
  v17[1] = a4;
  v6 = a1 + 8;
  v7 = *(_QWORD *)(a2 + 16);
  v15[0] = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v7 + 24))(v7, a1 + 8);
  v15[1] = 0;
  v8 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)v7 + 8))(v7, 0, v6);
  v15[2] = v8;
  v16 = 0;
  v9 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (v8 ^ (v8 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v8 ^ (v8 >> 30))) >> 27));
  v10 = v9 ^ (v9 >> 31);
  if (a4 && v8)
  {
    v11 = *a3;
    v12 = re::Slice<re::internal::BindPointImplBase const*>::range(v17, 1uLL, a4);
    v10 ^= (v10 << 6)
         + (v10 >> 2)
         + (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v11 + 48))(v11, v15, v12, v13)
         - 0x61C8864680B583E9;
  }
  return v10;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::KeyValueStoreMemberPointerInfo>::isWeak()
{
  return 1;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::KeyValueStoreMemberPointerInfo>::isAlive(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD v12[3];
  char v13;
  _QWORD v14[2];

  v14[0] = a3;
  v14[1] = a4;
  v6 = a1 + 8;
  v7 = *(_QWORD *)(a2 + 16);
  v12[0] = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v7 + 24))(v7, a1 + 8);
  v12[1] = 0;
  result = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)v7 + 8))(v7, 0, v6);
  v12[2] = result;
  v13 = 0;
  if (result)
  {
    if (a4)
    {
      v9 = *a3;
      v10 = re::Slice<re::internal::BindPointImplBase const*>::range(v14, 1uLL, a4);
      return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v9 + 64))(v9, v12, v10, v11);
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::KeyValueStoreMemberPointerInfo>::baseValueUntyped(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD v12[3];
  char v13;
  _QWORD v14[2];

  v14[0] = a3;
  v14[1] = a4;
  v6 = a1 + 8;
  v7 = *(_QWORD *)(a2 + 16);
  v12[0] = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v7 + 24))(v7, a1 + 8);
  v12[1] = 0;
  result = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)v7 + 8))(v7, 0, v6);
  v12[2] = result;
  v13 = 0;
  if (result)
  {
    if (a4)
    {
      v9 = *a3;
      v10 = re::Slice<re::internal::BindPointImplBase const*>::range(v14, 1uLL, a4);
      return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v9 + 88))(v9, v12, v10, v11);
    }
  }
  return result;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::KeyValueStoreMemberPointerInfo>::supportsOverrideValue(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD v12[3];
  char v13;
  _QWORD v14[2];

  v14[0] = a3;
  v14[1] = a4;
  if (!a4)
    return 0;
  v6 = a1 + 8;
  v7 = *(_QWORD *)(a2 + 16);
  v12[0] = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v7 + 24))(v7, a1 + 8);
  v12[1] = 0;
  result = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)v7 + 8))(v7, 0, v6);
  v12[2] = result;
  v13 = 0;
  if (result)
  {
    v9 = *a3;
    v10 = re::Slice<re::internal::BindPointImplBase const*>::range(v14, 1uLL, a4);
    return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v9 + 96))(v9, v12, v10, v11);
  }
  return result;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::KeyValueStoreMemberPointerInfo>::isOverridden(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD v12[3];
  char v13;
  _QWORD v14[2];

  v14[0] = a3;
  v14[1] = a4;
  if (!a4)
    return 0;
  v6 = a1 + 8;
  v7 = *(_QWORD *)(a2 + 16);
  v12[0] = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v7 + 24))(v7, a1 + 8);
  v12[1] = 0;
  result = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)v7 + 8))(v7, 0, v6);
  v12[2] = result;
  v13 = 0;
  if (result)
  {
    v9 = *a3;
    v10 = re::Slice<re::internal::BindPointImplBase const*>::range(v14, 1uLL, a4);
    return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v9 + 104))(v9, v12, v10, v11);
  }
  return result;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::KeyValueStoreMemberPointerInfo>::setIsOverridden(uint64_t result, uint64_t a2, uint64_t *a3, unint64_t a4, uint64_t a5)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD v13[3];
  char v14;
  _QWORD v15[2];

  v15[0] = a3;
  v15[1] = a4;
  if (a4)
  {
    v8 = result + 8;
    v9 = *(_QWORD *)(a2 + 16);
    v13[0] = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v9 + 24))(v9, result + 8);
    v13[1] = 0;
    result = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)v9 + 8))(v9, 0, v8);
    v13[2] = result;
    v14 = 0;
    if (result)
    {
      v10 = *a3;
      v11 = re::Slice<re::internal::BindPointImplBase const*>::range(v15, 1uLL, a4);
      return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v10 + 112))(v10, v13, v11, v12, a5);
    }
  }
  return result;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::KeyValueStoreMemberPointerInfo>::overrideValueUntyped(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD v12[3];
  char v13;
  _QWORD v14[2];

  v14[0] = a3;
  v14[1] = a4;
  if (!a4)
    return 0;
  v6 = a1 + 8;
  v7 = *(_QWORD *)(a2 + 16);
  v12[0] = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v7 + 24))(v7, a1 + 8);
  v12[1] = 0;
  result = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)v7 + 8))(v7, 0, v6);
  v12[2] = result;
  v13 = 0;
  if (result)
  {
    v9 = *a3;
    v10 = re::Slice<re::internal::BindPointImplBase const*>::range(v14, 1uLL, a4);
    return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v9 + 120))(v9, v12, v10, v11);
  }
  return result;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::KeyValueStoreMemberPointerInfo>::markAsWritten(uint64_t result, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD v11[3];
  char v12;
  _QWORD v13[2];

  v13[0] = a3;
  v13[1] = a4;
  if (a4)
  {
    v6 = result + 8;
    v7 = *(_QWORD *)(a2 + 16);
    v11[0] = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v7 + 24))(v7, result + 8);
    v11[1] = 0;
    result = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)v7 + 8))(v7, 0, v6);
    v11[2] = result;
    v12 = 0;
    if (result)
    {
      v8 = *a3;
      v9 = re::Slice<re::internal::BindPointImplBase const*>::range(v13, 1uLL, a4);
      return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v8 + 128))(v8, v11, v9, v10);
    }
  }
  return result;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::KeyValueStoreMemberPointerInfo>::boundOwner()
{
  return 0;
}

void `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::PolymorphicMemberPointerInfo>::~PointerBindPointImpl()
{
  JUMPOUT(0x2276933B8);
}

void *re::internal::BindPointImpl<`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::PolymorphicMemberPointerInfo>>::implTypeInfo()
{
}

uint64_t re::internal::BindPointImpl<`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::PolymorphicMemberPointerInfo>>::copyInto(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24ED406C0;
  a2[1] = v2;
  return result;
}

uint64_t re::internal::BindPointImpl<`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::PolymorphicMemberPointerInfo>>::moveInto(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24ED406C0;
  a2[1] = v2;
  return result;
}

BOOL re::internal::BindPointImpl<`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::PolymorphicMemberPointerInfo>>::equals(uint64_t a1, _QWORD *a2)
{
      && *(_QWORD *)(a1 + 8) == a2[1];
}

unint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::PolymorphicMemberPointerInfo>::hash(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD v12[2];
  unint64_t v13;
  _QWORD v14[2];

  v14[0] = a3;
  v14[1] = a4;
  v6 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (v13 ^ (v13 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v13 ^ (v13 >> 30))) >> 27));
  v7 = v6 ^ (v6 >> 31);
  if (a4 && v13)
  {
    v8 = *a3;
    v9 = re::Slice<re::internal::BindPointImplBase const*>::range(v14, 1uLL, a4);
    v7 ^= (v7 << 6)
        + (v7 >> 2)
        + (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v8 + 48))(v8, v12, v9, v10)
        - 0x61C8864680B583E9;
  }
  return v7;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::PolymorphicMemberPointerInfo>::isWeak()
{
  return 1;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::PolymorphicMemberPointerInfo>::isAlive(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v10[4];
  _QWORD v11[2];

  v11[0] = a3;
  v11[1] = a4;
  if (!v10[2])
    return 0;
  if (!a4)
    return 1;
  v6 = *a3;
  v7 = re::Slice<re::internal::BindPointImplBase const*>::range(v11, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v6 + 64))(v6, v10, v7, v8);
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::PolymorphicMemberPointerInfo>::baseValueUntyped(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v10[2];
  uint64_t v11;
  _QWORD v12[2];

  v12[0] = a3;
  v12[1] = a4;
  result = v11;
  if (v11)
  {
    if (a4)
    {
      v7 = *a3;
      v8 = re::Slice<re::internal::BindPointImplBase const*>::range(v12, 1uLL, a4);
      return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v7 + 88))(v7, v10, v8, v9);
    }
  }
  return result;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::PolymorphicMemberPointerInfo>::supportsOverrideValue(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v10[4];
  _QWORD v11[2];

  v11[0] = a3;
  v11[1] = a4;
  if (!a4)
    return 0;
  if (!v10[2])
    return 0;
  v6 = *a3;
  v7 = re::Slice<re::internal::BindPointImplBase const*>::range(v11, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v6 + 96))(v6, v10, v7, v8);
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::PolymorphicMemberPointerInfo>::isOverridden(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v10[4];
  _QWORD v11[2];

  v11[0] = a3;
  v11[1] = a4;
  if (!a4)
    return 0;
  if (!v10[2])
    return 0;
  v6 = *a3;
  v7 = re::Slice<re::internal::BindPointImplBase const*>::range(v11, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v6 + 104))(v6, v10, v7, v8);
}

_QWORD *`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::PolymorphicMemberPointerInfo>::setIsOverridden(_QWORD *result, uint64_t a2, uint64_t *a3, unint64_t a4, uint64_t a5)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD v11[4];
  _QWORD v12[2];

  v12[0] = a3;
  v12[1] = a4;
  if (a4)
  {
    if (v11[2])
    {
      v8 = *a3;
      v9 = re::Slice<re::internal::BindPointImplBase const*>::range(v12, 1uLL, a4);
      return (_QWORD *)(*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v8 + 112))(v8, v11, v9, v10, a5);
    }
  }
  return result;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::PolymorphicMemberPointerInfo>::overrideValueUntyped(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v10[4];
  _QWORD v11[2];

  v11[0] = a3;
  v11[1] = a4;
  if (!a4)
    return 0;
  if (!v10[2])
    return 0;
  v6 = *a3;
  v7 = re::Slice<re::internal::BindPointImplBase const*>::range(v11, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v6 + 120))(v6, v10, v7, v8);
}

_QWORD *`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::PolymorphicMemberPointerInfo>::markAsWritten(_QWORD *result, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v9[4];
  _QWORD v10[2];

  v10[0] = a3;
  v10[1] = a4;
  if (a4)
  {
    if (v9[2])
    {
      v6 = *a3;
      v7 = re::Slice<re::internal::BindPointImplBase const*>::range(v10, 1uLL, a4);
      return (_QWORD *)(*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v6 + 128))(v6, v9, v7, v8);
    }
  }
  return result;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::PolymorphicMemberPointerInfo>::boundOwner()
{
  return 0;
}

_QWORD *`anonymous namespace'::PolymorphicMemberPointerInfo::pointerReference(_QWORD *result, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  _DWORD *v7;
  _DWORD **v8;
  uint64_t v9;
  _DWORD *v10;
  uint64_t v11;
  _QWORD v12[3];

  v4 = *(_QWORD *)(a3 + *(int *)(a2 + 36));
  if (v4)
  {
    v5 = *(_QWORD *)(*(_QWORD *)(a2 + 16) + 48);
    v6 = *(_QWORD **)(v5 + 64);
    v7 = (_DWORD *)*v6;
    if (*(_DWORD *)*v6 != 2)
    {
      v8 = (_DWORD **)(v6 + 1);
      v9 = *(unsigned int *)(v5 + 56) - 1;
      do
      {
        v10 = *v8++;
        v7 = v10;
        --v9;
      }
      while (*v10 != 2);
    }
    v11 = *(_QWORD *)(a2 + 48);
    v12[0] = a3 + *(int *)(a2 + 64);
    v12[1] = v11;
    v12[2] = *((_QWORD *)v7 + 1);
  }
  else
  {
    *result = 0;
    result[1] = 0;
    *((_BYTE *)result + 24) = 0;
    result[2] = 0;
  }
  return result;
}

void `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::OptionalValuePointerInfo>::~PointerBindPointImpl()
{
  JUMPOUT(0x2276933B8);
}

void *re::internal::BindPointImpl<`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::OptionalValuePointerInfo>>::implTypeInfo()
{
}

uint64_t re::internal::BindPointImpl<`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::OptionalValuePointerInfo>>::copyInto(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24ED40790;
  a2[1] = v2;
  return result;
}

uint64_t re::internal::BindPointImpl<`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::OptionalValuePointerInfo>>::moveInto(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24ED40790;
  a2[1] = v2;
  return result;
}

BOOL re::internal::BindPointImpl<`anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::OptionalValuePointerInfo>>::equals(uint64_t a1, _QWORD *a2)
{
      && *(_QWORD *)(a1 + 8) == a2[1];
}

unint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::OptionalValuePointerInfo>::hash(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  _QWORD *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD v17[3];
  char v18;
  _QWORD v19[2];

  v19[0] = a3;
  v19[1] = a4;
  if ((*(unsigned int (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 8) + 56))(*(_QWORD *)(a1 + 8), *(_QWORD *)(a2 + 16)))
  {
    v8 = *(_QWORD **)(a1 + 8);
    v9 = v8[6];
    v10 = (*(uint64_t (**)(_QWORD *, _QWORD))(*v8 + 72))(v8, *(_QWORD *)(a2 + 16));
  }
  else
  {
    v9 = 0;
    v10 = 0;
  }
  v17[0] = v9;
  v17[1] = 0;
  v17[2] = v10;
  v18 = 0;
  v11 = 0x94D049BB133111EBLL
      * ((0xBF58476D1CE4E5B9 * (v10 ^ (v10 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v10 ^ (v10 >> 30))) >> 27));
  v12 = v11 ^ (v11 >> 31);
  if (a4 && v10)
  {
    v13 = *a3;
    v14 = re::Slice<re::internal::BindPointImplBase const*>::range(v19, 1uLL, a4);
    v12 ^= (v12 << 6)
         + (v12 >> 2)
         + (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v13 + 48))(v13, v17, v14, v15)
         - 0x61C8864680B583E9;
  }
  return v12;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::OptionalValuePointerInfo>::isWeak()
{
  return 1;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::OptionalValuePointerInfo>::isAlive(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t result;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD v14[3];
  char v15;
  _QWORD v16[2];

  v16[0] = a3;
  v16[1] = a4;
  result = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 8) + 56))(*(_QWORD *)(a1 + 8), *(_QWORD *)(a2 + 16));
  if ((_DWORD)result)
  {
    v9 = *(_QWORD **)(a1 + 8);
    v10 = v9[6];
    result = (*(uint64_t (**)(_QWORD *, _QWORD))(*v9 + 72))(v9, *(_QWORD *)(a2 + 16));
    v14[0] = v10;
    v14[1] = 0;
    v14[2] = result;
    v15 = 0;
    if (result)
    {
      if (a4)
      {
        v11 = *a3;
        v12 = re::Slice<re::internal::BindPointImplBase const*>::range(v16, 1uLL, a4);
        return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v11 + 64))(v11, v14, v12, v13);
      }
      else
      {
        return 1;
      }
    }
  }
  return result;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::OptionalValuePointerInfo>::baseValueUntyped(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  _QWORD *v8;
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD v14[3];
  char v15;
  _QWORD v16[2];

  v16[0] = a3;
  v16[1] = a4;
  if (!(*(unsigned int (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 8) + 56))(*(_QWORD *)(a1 + 8), *(_QWORD *)(a2 + 16)))return 0;
  v8 = *(_QWORD **)(a1 + 8);
  v9 = v8[6];
  result = (*(uint64_t (**)(_QWORD *, _QWORD))(*v8 + 72))(v8, *(_QWORD *)(a2 + 16));
  v14[0] = v9;
  v14[1] = 0;
  v14[2] = result;
  v15 = 0;
  if (result)
  {
    if (a4)
    {
      v11 = *a3;
      v12 = re::Slice<re::internal::BindPointImplBase const*>::range(v16, 1uLL, a4);
      return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v11 + 88))(v11, v14, v12, v13);
    }
  }
  return result;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::OptionalValuePointerInfo>::supportsOverrideValue(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD v15[3];
  char v16;
  _QWORD v17[2];

  v17[0] = a3;
  v17[1] = a4;
  if (!a4)
    return 0;
  if (!(*(unsigned int (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 8) + 56))(*(_QWORD *)(a1 + 8), *(_QWORD *)(a2 + 16)))return 0;
  v8 = *(_QWORD **)(a1 + 8);
  v9 = v8[6];
  v10 = (*(uint64_t (**)(_QWORD *, _QWORD))(*v8 + 72))(v8, *(_QWORD *)(a2 + 16));
  v15[0] = v9;
  v15[1] = 0;
  v15[2] = v10;
  v16 = 0;
  if (!v10)
    return 0;
  v11 = *a3;
  v12 = re::Slice<re::internal::BindPointImplBase const*>::range(v17, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v11 + 96))(v11, v15, v12, v13);
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::OptionalValuePointerInfo>::isOverridden(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD v15[3];
  char v16;
  _QWORD v17[2];

  v17[0] = a3;
  v17[1] = a4;
  if (!a4)
    return 0;
  if (!(*(unsigned int (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 8) + 56))(*(_QWORD *)(a1 + 8), *(_QWORD *)(a2 + 16)))return 0;
  v8 = *(_QWORD **)(a1 + 8);
  v9 = v8[6];
  v10 = (*(uint64_t (**)(_QWORD *, _QWORD))(*v8 + 72))(v8, *(_QWORD *)(a2 + 16));
  v15[0] = v9;
  v15[1] = 0;
  v15[2] = v10;
  v16 = 0;
  if (!v10)
    return 0;
  v11 = *a3;
  v12 = re::Slice<re::internal::BindPointImplBase const*>::range(v17, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v11 + 104))(v11, v15, v12, v13);
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::OptionalValuePointerInfo>::setIsOverridden(uint64_t result, uint64_t a2, uint64_t *a3, unint64_t a4, uint64_t a5)
{
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD v15[3];
  char v16;
  _QWORD v17[2];

  v17[0] = a3;
  v17[1] = a4;
  if (a4)
  {
    v9 = result;
    result = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(result + 8) + 56))(*(_QWORD *)(result + 8), *(_QWORD *)(a2 + 16));
    if ((_DWORD)result)
    {
      v10 = *(_QWORD **)(v9 + 8);
      v11 = v10[6];
      result = (*(uint64_t (**)(_QWORD *, _QWORD))(*v10 + 72))(v10, *(_QWORD *)(a2 + 16));
      v15[0] = v11;
      v15[1] = 0;
      v15[2] = result;
      v16 = 0;
      if (result)
      {
        v12 = *a3;
        v13 = re::Slice<re::internal::BindPointImplBase const*>::range(v17, 1uLL, a4);
        return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v12 + 112))(v12, v15, v13, v14, a5);
      }
    }
  }
  return result;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::OptionalValuePointerInfo>::overrideValueUntyped(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD v15[3];
  char v16;
  _QWORD v17[2];

  v17[0] = a3;
  v17[1] = a4;
  if (!a4)
    return 0;
  if (!(*(unsigned int (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 8) + 56))(*(_QWORD *)(a1 + 8), *(_QWORD *)(a2 + 16)))return 0;
  v8 = *(_QWORD **)(a1 + 8);
  v9 = v8[6];
  v10 = (*(uint64_t (**)(_QWORD *, _QWORD))(*v8 + 72))(v8, *(_QWORD *)(a2 + 16));
  v15[0] = v9;
  v15[1] = 0;
  v15[2] = v10;
  v16 = 0;
  if (!v10)
    return 0;
  v11 = *a3;
  v12 = re::Slice<re::internal::BindPointImplBase const*>::range(v17, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v11 + 120))(v11, v15, v12, v13);
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::OptionalValuePointerInfo>::markAsWritten(uint64_t result, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD v13[3];
  char v14;
  _QWORD v15[2];

  v15[0] = a3;
  v15[1] = a4;
  if (a4)
  {
    v7 = result;
    result = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(result + 8) + 56))(*(_QWORD *)(result + 8), *(_QWORD *)(a2 + 16));
    if ((_DWORD)result)
    {
      v8 = *(_QWORD **)(v7 + 8);
      v9 = v8[6];
      result = (*(uint64_t (**)(_QWORD *, _QWORD))(*v8 + 72))(v8, *(_QWORD *)(a2 + 16));
      v13[0] = v9;
      v13[1] = 0;
      v13[2] = result;
      v14 = 0;
      if (result)
      {
        v10 = *a3;
        v11 = re::Slice<re::internal::BindPointImplBase const*>::range(v15, 1uLL, a4);
        return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v10 + 128))(v10, v13, v11, v12);
      }
    }
  }
  return result;
}

uint64_t `anonymous namespace'::PointerBindPointImpl<`anonymous namespace'::OptionalValuePointerInfo>::boundOwner()
{
  return 0;
}

void `anonymous namespace'::RelativeBindPointImpl::~RelativeBindPointImpl(_anonymous_namespace_::RelativeBindPointImpl *this)
{
  JUMPOUT(0x2276933B8);
}

void *re::internal::BindPointImpl<`anonymous namespace'::RelativeBindPointImpl>::implTypeInfo()
{
}

uint64_t re::internal::BindPointImpl<`anonymous namespace'::RelativeBindPointImpl>::copyInto(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24ED40860;
  a2[1] = v2;
  return result;
}

uint64_t re::internal::BindPointImpl<`anonymous namespace'::RelativeBindPointImpl>::moveInto(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24ED40860;
  a2[1] = v2;
  return result;
}

BOOL re::internal::BindPointImpl<`anonymous namespace'::RelativeBindPointImpl>::equals(uint64_t a1, _QWORD *a2)
{
      && *(_QWORD *)(a1 + 8) == a2[1];
}

uint64_t `anonymous namespace'::RelativeBindPointImpl::hash(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t `anonymous namespace'::RelativeBindPointImpl::isWeak(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD v8[3];
  char v9;
  _QWORD v10[2];

  v10[0] = a3;
  v10[1] = a4;
  v8[0] = *(_QWORD *)(a1 + 8);
  v8[1] = 0;
  v8[2] = a2;
  v9 = 0;
  if (!a4)
    return 0;
  v4 = *a3;
  v5 = re::Slice<re::internal::BindPointImplBase const*>::range(v10, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v4 + 56))(v4, v8, v5, v6);
}

uint64_t `anonymous namespace'::RelativeBindPointImpl::isAlive(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD v8[3];
  char v9;
  _QWORD v10[2];

  v10[0] = a3;
  v10[1] = a4;
  v8[0] = *(_QWORD *)(a1 + 8);
  v8[1] = 0;
  v8[2] = a2;
  v9 = 0;
  if (!a4)
    return 1;
  v4 = *a3;
  v5 = re::Slice<re::internal::BindPointImplBase const*>::range(v10, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v4 + 64))(v4, v8, v5, v6);
}

uint64_t `anonymous namespace'::RelativeBindPointImpl::targetIdentifier(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 88))(a1);
}

uint64_t `anonymous namespace'::RelativeBindPointImpl::baseValueUntyped(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD v8[3];
  char v9;
  _QWORD v10[2];

  v10[0] = a3;
  v10[1] = a4;
  v8[0] = *(_QWORD *)(a1 + 8);
  v8[1] = 0;
  v8[2] = a2;
  v9 = 0;
  if (a4)
  {
    v4 = *a3;
    v5 = re::Slice<re::internal::BindPointImplBase const*>::range(v10, 1uLL, a4);
    return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v4 + 88))(v4, v8, v5, v6);
  }
  return a2;
}

uint64_t `anonymous namespace'::RelativeBindPointImpl::supportsOverrideValue(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD v8[3];
  char v9;
  _QWORD v10[2];

  v10[0] = a3;
  v10[1] = a4;
  v8[0] = *(_QWORD *)(a1 + 8);
  v8[1] = 0;
  v8[2] = a2;
  v9 = 0;
  if (!a4)
    return 0;
  v4 = *a3;
  v5 = re::Slice<re::internal::BindPointImplBase const*>::range(v10, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v4 + 96))(v4, v8, v5, v6);
}

uint64_t `anonymous namespace'::RelativeBindPointImpl::isOverridden(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD v8[3];
  char v9;
  _QWORD v10[2];

  v10[0] = a3;
  v10[1] = a4;
  v8[0] = *(_QWORD *)(a1 + 8);
  v8[1] = 0;
  v8[2] = a2;
  v9 = 0;
  if (!a4)
    return 0;
  v4 = *a3;
  v5 = re::Slice<re::internal::BindPointImplBase const*>::range(v10, 1uLL, a4);
  return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v4 + 104))(v4, v8, v5, v6);
}

uint64_t `anonymous namespace'::RelativeBindPointImpl::setIsOverridden(uint64_t result, uint64_t a2, uint64_t *a3, unint64_t a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v9[3];
  char v10;
  _QWORD v11[2];

  v11[0] = a3;
  v11[1] = a4;
  if (a4)
  {
    v9[0] = *(_QWORD *)(result + 8);
    v9[1] = 0;
    v9[2] = a2;
    v10 = 0;
    v6 = *a3;
    v7 = re::Slice<re::internal::BindPointImplBase const*>::range(v11, 1uLL, a4);
    return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v6 + 112))(v6, v9, v7, v8, a5);
  }
  return result;
}

uint64_t `anonymous namespace'::RelativeBindPointImpl::overrideValueUntyped(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD v8[3];
  char v9;
  _QWORD v10[2];

  v10[0] = a3;
  v10[1] = a4;
  v8[0] = *(_QWORD *)(a1 + 8);
  v8[1] = 0;
  v8[2] = a2;
  v9 = 0;
  if (a4)
  {
    v4 = *a3;
    v5 = re::Slice<re::internal::BindPointImplBase const*>::range(v10, 1uLL, a4);
    return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v4 + 120))(v4, v8, v5, v6);
  }
  return a2;
}

uint64_t `anonymous namespace'::RelativeBindPointImpl::markAsWritten(uint64_t result, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD v7[3];
  char v8;
  _QWORD v9[2];

  v9[0] = a3;
  v9[1] = a4;
  if (a4)
  {
    v7[0] = *(_QWORD *)(result + 8);
    v7[1] = 0;
    v7[2] = a2;
    v8 = 0;
    v4 = *a3;
    v5 = re::Slice<re::internal::BindPointImplBase const*>::range(v9, 1uLL, a4);
    return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)v4 + 128))(v4, v7, v5, v6);
  }
  return result;
}

uint64_t `anonymous namespace'::RelativeBindPointImpl::boundOwner()
{
  return 0;
}

void `anonymous namespace'::OverridableBindPointImpl::~OverridableBindPointImpl(_anonymous_namespace_::OverridableBindPointImpl *this)
{
  JUMPOUT(0x2276933B8);
}

const char *re::internal::BindPointImpl<`anonymous namespace'::OverridableBindPointImpl>::implTypeInfo()
{
  return " ";
}

__n128 re::internal::BindPointImpl<`anonymous namespace'::OverridableBindPointImpl>::copyInto(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_24ED40930;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 re::internal::BindPointImpl<`anonymous namespace'::OverridableBindPointImpl>::moveInto(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_24ED40930;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  return result;
}

BOOL re::internal::BindPointImpl<`anonymous namespace'::OverridableBindPointImpl>::equals(_QWORD *a1, _QWORD *a2)
{
  return (char *)(*(uint64_t (**)(_QWORD *))(*a2 + 16))(a2) == " "
      && a1[2] == a2[2]
      && a1[1] == a2[1]
      && a1[3] == a2[3];
}

unint64_t `anonymous namespace'::OverridableBindPointImpl::hash(uint64_t a1)
{
  unint64_t v1;

  v1 = 0xBF58476D1CE4E5B9 * (*(_QWORD *)(a1 + 8) ^ (*(_QWORD *)(a1 + 8) >> 30));
  return (0x94D049BB133111EBLL * (v1 ^ (v1 >> 27))) ^ ((0x94D049BB133111EBLL * (v1 ^ (v1 >> 27))) >> 31);
}

uint64_t `anonymous namespace'::OverridableBindPointImpl::isWeak()
{
  return 0;
}

uint64_t `anonymous namespace'::OverridableBindPointImpl::isAlive()
{
  return 1;
}

uint64_t `anonymous namespace'::OverridableBindPointImpl::targetIdentifier(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 88))(a1);
}

uint64_t `anonymous namespace'::OverridableBindPointImpl::baseValueUntyped(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t `anonymous namespace'::OverridableBindPointImpl::supportsOverrideValue()
{
  return 1;
}

uint64_t `anonymous namespace'::OverridableBindPointImpl::isOverridden(uint64_t a1)
{
  return **(unsigned __int8 **)(a1 + 24);
}

uint64_t `anonymous namespace'::OverridableBindPointImpl::setIsOverridden(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
  **(_BYTE **)(result + 24) = a5;
  return result;
}

uint64_t `anonymous namespace'::OverridableBindPointImpl::overrideValueUntyped(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

uint64_t `anonymous namespace'::OverridableBindPointImpl::boundOwner()
{
  return 0;
}

uint64_t *re::allocInfo_KeyValueStoreInterface(re *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&_MergedGlobals_125);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&_MergedGlobals_125))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_254105B40, 0);
    *(uint64_t *)((char *)&qword_254105B50 + 6) = 0;
    qword_254105B50 = 0;
    qword_254105B60 = 0;
    qword_254105B68 = 0xFFFFFFFFLL;
    qword_254105B40 = (uint64_t)&off_24ED7DAA8;
    qword_254105B70 = (uint64_t)"KeyValueStoreInterface";
    dword_254105B78 = 0;
    unk_254105B80 = 0u;
    unk_254105B90 = 0u;
    unk_254105BA0 = 0u;
    qword_254105BB0 = 0;
    __cxa_guard_release(&_MergedGlobals_125);
  }
  return &qword_254105B40;
}

void re::initInfo_KeyValueStoreInterface(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  __int128 v4;
  _QWORD v5[2];
  __int128 v6;

  v5[0] = 0x8BFD87A3D5E850D4;
  v5[1] = "KeyValueStoreInterface";
  re::StringID::destroyString((re::StringID *)v5);
  *((_OWORD *)this + 2) = v6;
  *((_QWORD *)this + 2) = 0x800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 8) = &re::initInfo_KeyValueStoreInterface(re::IntrospectionBase *)::structureAttributes;
  re::IntrospectionRegistry::add(this, v3);
  v4 = v6;
}

uint64_t re::introspect_KeyValueStoreInterface(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"KeyValueStoreInterface", (uint64_t (*)(re::internal *))re::allocInfo_KeyValueStoreInterface, (re::IntrospectionBase *(*)(void))re::initInfo_KeyValueStoreInterface, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::KeyValueStoreInterface>, this);
}

uint64_t *re::foundationBindingLogObjects(re *this)
{
  unsigned __int8 v1;

  {
    re::foundationBindingLogObjects(void)::logObjects = (uint64_t)os_log_create("com.apple.re", "Foundation.Binding");
  }
  return &re::foundationBindingLogObjects(void)::logObjects;
}

BOOL re::internal::doesBindingKeyNeedUnescaping(uint64_t *a1)
{
  unint64_t v1;
  unint64_t v2;
  uint64_t v3;
  BOOL v4;
  int v5;
  char *v6;
  char *v7;
  int64_t v8;

  v1 = a1[1];
  if (v1)
  {
    v2 = 0;
    v3 = *a1;
    v4 = 1;
    do
    {
      if (v2 < v1 - 1 && *(_BYTE *)(v3 + v2) == 92)
      {
        v5 = *(char *)(v3 + v2 + 1);
        v6 = (char *)memchr(".[]", v5, 3uLL);
        v7 = "";
        if (v6)
          v7 = v6;
        v8 = v7 - ".[]";
        if (v5 == 92 || v8 != 3)
          break;
      }
      v4 = ++v2 < v1;
    }
    while (v1 != v2);
  }
  else
  {
    return 0;
  }
  return v4;
}

uint64_t re::internal::escapeBindingKey(_QWORD *a1, re::DynamicString *this)
{
  uint64_t v4;
  _BYTE *v5;
  uint64_t result;
  unint64_t v7;
  unint64_t v8;
  int v9;
  char *v10;
  uint64_t v11;
  char *v12;
  int64_t v13;
  char __src;
  char v16;

  v4 = *((_QWORD *)this + 1);
  if ((v4 & 1) != 0)
  {
    *((_QWORD *)this + 1) = 1;
    v5 = (_BYTE *)*((_QWORD *)this + 2);
  }
  else
  {
    *((_BYTE *)this + 8) = v4 & 1;
    v5 = (char *)this + 9;
  }
  *v5 = 0;
  result = (uint64_t)re::DynamicString::setCapacity(this, a1[1] + 10);
  v7 = a1[1];
  if (v7)
  {
    v8 = 0;
    while (1)
    {
      v9 = *(char *)(*a1 + v8);
      v10 = (char *)memchr(".[]", v9, 3uLL);
      v12 = "";
      if (v10)
        v12 = v10;
      v13 = v12 - ".[]";
      if (v9 == 92 || v13 != 3)
      {
        __src = 92;
        re::DynamicString::append(this, &__src, 1uLL);
        v7 = a1[1];
      }
      if (v7 <= v8)
        break;
      v16 = *(_BYTE *)(*a1 + v8);
      result = (uint64_t)re::DynamicString::append(this, &v16, 1uLL);
      ++v8;
      v7 = a1[1];
      if (v8 >= v7)
        return result;
    }
    re::internal::assertLog((re::internal *)6, v11, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v8, v7);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::internal::unescapeBindingKey(uint64_t *a1, re::DynamicString *this)
{
  unint64_t v2;
  uint64_t v5;
  _BYTE *v6;
  uint64_t result;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  int v12;
  char *v13;
  char *v14;
  char __src;

  v5 = *((_QWORD *)this + 1);
  if ((v5 & 1) != 0)
  {
    *((_QWORD *)this + 1) = 1;
    v6 = (_BYTE *)*((_QWORD *)this + 2);
  }
  else
  {
    *((_BYTE *)this + 8) = v5 & 1;
    v6 = (char *)this + 9;
  }
  *v6 = 0;
  result = (uint64_t)re::DynamicString::setCapacity(this, a1[1]);
  v9 = a1[1];
  if (v9)
  {
    v10 = 0;
    while (1)
    {
      v11 = *a1;
      if (*(_BYTE *)(*a1 + v10) == 92)
      {
        if (v10 >= v9 - 1)
          return result;
        v2 = v10 + 1;
        if (v9 <= v10 + 1)
          goto LABEL_20;
        v12 = *(char *)(v11 + v2);
        v13 = (char *)memchr(".[]", v12, 3uLL);
        v14 = "";
        if (v13)
          v14 = v13;
        if (v14 - ".[]" != 3 || v12 == 92)
          ++v10;
      }
      if (v9 <= v10)
        break;
      __src = *(_BYTE *)(v11 + v10);
      result = (uint64_t)re::DynamicString::append(this, &__src, 1uLL);
      ++v10;
      v9 = a1[1];
      if (v10 >= v9)
        return result;
    }
    re::internal::assertLog((re::internal *)6, v8, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v10, v9);
    _os_crash();
    __break(1u);
LABEL_20:
    re::internal::assertLog((re::internal *)6, v8, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v2, v9);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::internal::parseBindingURI(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  int v3;
  unint64_t v4;
  unint64_t v8;
  uint64_t v9;
  int v10;
  char *v11;
  char *v12;
  int64_t v13;
  BOOL v14;
  int v15;
  unint64_t v16;
  uint64_t result;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;

  v4 = a1[1];
  if (v4 < 3)
  {
    v15 = 0;
    return v15 & v3;
  }
  v8 = 0;
  v9 = *a1;
  while (1)
  {
    if (v4 == v8)
    {
      re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v4, v4);
      _os_crash();
      __break(1u);
      goto LABEL_26;
    }
    v10 = *(char *)(v9 + v8);
    v11 = (char *)memchr(".[]", v10, 3uLL);
    v12 = "";
    if (v11)
      v12 = v11;
    v13 = v12 - ".[]";
    v14 = v10 != 92 && v13 == 3;
    v15 = !v14;
    if (!v14)
    {
LABEL_16:
      v3 = 0;
      return v15 & v3;
    }
    v16 = v8 + 1;
    if (v10 == 58)
      break;
    ++v8;
    if (v4 - 2 == v16)
      goto LABEL_16;
  }
  if (v4 <= v16)
  {
LABEL_26:
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v16, v4);
    _os_crash();
    __break(1u);
    goto LABEL_27;
  }
  if (*(_BYTE *)(v9 + v8 + 1) != 47)
  {
LABEL_24:
    v3 = 0;
    v15 = 1;
    return v15 & v3;
  }
  v18 = v8 + 2;
  if (v4 > v8 + 2)
  {
    if (*(_BYTE *)(v9 + v8 + 2) == 47)
    {
      *a2 = re::Slice<char>::range(a1, 0, v8);
      a2[1] = v19;
      *a3 = re::Slice<char>::range(a1, v8 + 3, a1[1]);
      a3[1] = v20;
      v15 = 1;
      v3 = 1;
      return v15 & v3;
    }
    goto LABEL_24;
  }
LABEL_27:
  re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v18, v4);
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::internal::parseNextBindingKey(char *a1, _QWORD *a2, uint64_t a3)
{
  unint64_t v3;
  uint64_t v7;
  char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  NSObject *v12;
  _BOOL4 v13;
  uint64_t result;
  const char *v15;
  uint64_t v16;
  _BOOL4 v17;
  const char *v18;
  uint64_t v19;
  unint64_t v20;

  *a2 = *(_QWORD *)a1;
  a2[1] = 0;
  *(_OWORD *)a3 = *(_OWORD *)a1;
  v3 = *((_QWORD *)a1 + 1);
  if (!v3)
    return 1;
  v20 = 0;
  v7 = *(_QWORD *)a1;
  if (**(_BYTE **)a1 == 91)
  {
    v18 = "]";
    v19 = 1;
    if (v20 >= v3)
    {
      v12 = *re::foundationBindingLogObjects((re *)v8);
      v13 = os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT);
      result = 0;
      if (!v13)
        return result;
      LOWORD(v18) = 0;
      v15 = "Invalid binding path: Closing bracket is missing.";
LABEL_17:
      _os_log_impl(&dword_224FE9000, v12, OS_LOG_TYPE_DEFAULT, v15, (uint8_t *)&v18, 2u);
      return 0;
    }
    v9 = v20 - 1;
    v10 = v7 + 1;
    v11 = v20 + 1;
  }
  else
  {
    v18 = ".[]";
    v19 = 3;
    v11 = v20;
    v10 = v7;
    v9 = v20;
  }
  if (v11 >= v3)
  {
LABEL_12:
    *a2 = v10;
    a2[1] = v9;
    *(_QWORD *)a3 = re::Slice<char>::range(a1, v11, *((_QWORD *)a1 + 1));
    *(_QWORD *)(a3 + 8) = v16;
    return 1;
  }
  if (*(_BYTE *)(v7 + v11) == 46)
  {
    ++v11;
    goto LABEL_12;
  }
  if (v9)
    goto LABEL_12;
  v12 = *re::foundationBindingLogObjects((re *)v8);
  v17 = os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT);
  result = 0;
  if (v17)
  {
    LOWORD(v18) = 0;
    v15 = "Delimiter . expected";
    goto LABEL_17;
  }
  return result;
}

char *`anonymous namespace'::extractBindingKey(char *result, unint64_t a2, uint64_t a3, unint64_t *a4)
{
  unint64_t v5;
  unint64_t v6;
  char v7;
  uint64_t v8;
  void *v9;
  size_t v10;
  size_t v11;
  int v12;
  char *v13;

  *a4 = a2;
  v5 = *((_QWORD *)result + 1);
  if (v5 > a2)
  {
    v6 = a2;
    v7 = 0;
    v8 = *(_QWORD *)result;
    v9 = *(void **)a3;
    v10 = *(_QWORD *)(a3 + 8);
    v11 = *(_QWORD *)a3 + v10;
    while (1)
    {
      if ((v7 & 1) != 0)
        goto LABEL_10;
      v12 = *(char *)(v8 + v6);
      if (v12 != 92)
        break;
      v7 = 1;
LABEL_11:
      if (v5 == ++v6)
        goto LABEL_14;
    }
    result = (char *)memchr(v9, v12, v10);
    if (result)
      v13 = result;
    else
      v13 = (char *)v11;
    if (v13 - (_BYTE *)v9 != v10)
    {
      v5 = v6;
      goto LABEL_14;
    }
LABEL_10:
    v7 = 0;
    goto LABEL_11;
  }
LABEL_14:
  *a4 = v5;
  return result;
}

uint64_t *re::internal::parseSkeletalPoseJointPinName(uint64_t a1, uint64_t a2, re::StringID *this, re::StringID *a4, re::StringID *a5)
{
  _anonymous_namespace_ *BindingKey;
  uint64_t *v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  _anonymous_namespace_ *v15;
  unint64_t v16;
  void *v17;
  uint64_t v18;
  void *v19;
  _anonymous_namespace_ *v20;
  uint64_t v21;
  void *v22;
  uint64_t v23;
  void *v24;
  uint64_t *result;
  uint64_t v26;
  void *v27;
  uint64_t *v28;
  void *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32[2];
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37[2];
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42[2];
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  void *v46;

  re::StringID::destroyString(this);
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = "";
  re::StringID::destroyString(a4);
  *(_QWORD *)a4 = 0;
  *((_QWORD *)a4 + 1) = "";
  re::StringID::destroyString(a5);
  *(_QWORD *)a5 = 0;
  *((_QWORD *)a5 + 1) = "";
  v43 = a1;
  v44 = a2;
  v42[0] = 0;
  v42[1] = 0;
  BindingKey = (_anonymous_namespace_ *)re::internal::parseNextBindingKey((char *)&v43, v42, (uint64_t)&v43);
  v39 = 0;
  v40 = 0;
  v41 = 0;
  re::DynamicString::setCapacity(&v38, 0);
  re::internal::unescapeBindingKey(v42, (re::DynamicString *)&v38);
  re::StringID::StringID((re::StringID *)&v28, (const re::DynamicString *)&v38);
  v11 = v28;
  v12 = v29;
  v28 = 0;
  v29 = &str_110;
  v13 = *(_QWORD *)this;
  v14 = *((_QWORD *)this + 1);
  *(_QWORD *)this = v11;
  *((_QWORD *)this + 1) = v12;
  v33 = (uint64_t *)((unint64_t)v11 & 0xFFFFFFFFFFFFFFFELL | v13 & 1);
  v34 = v14;
  re::StringID::destroyString((re::StringID *)&v33);
  re::StringID::destroyString((re::StringID *)&v28);
  if (v44)
  {
    v37[0] = 0;
    v37[1] = 0;
    v15 = (_anonymous_namespace_ *)re::internal::parseNextBindingKey((char *)&v43, v37, (uint64_t)&v43);
    v34 = 0;
    v35 = 0;
    v36 = 0;
    re::DynamicString::setCapacity(&v33, 0);
    re::internal::unescapeBindingKey(v37, (re::DynamicString *)&v33);
    re::StringID::StringID((re::StringID *)&v45, (const re::DynamicString *)&v33);
    v16 = v45;
    v17 = v46;
    v45 = 0;
    v46 = &str_110;
    v18 = *(_QWORD *)a4;
    v19 = (void *)*((_QWORD *)a4 + 1);
    *(_QWORD *)a4 = v16;
    *((_QWORD *)a4 + 1) = v17;
    v28 = (uint64_t *)(v16 & 0xFFFFFFFFFFFFFFFELL | v18 & 1);
    v29 = v19;
    re::StringID::destroyString((re::StringID *)&v28);
    re::StringID::destroyString((re::StringID *)&v45);
    if (v44)
    {
      v32[0] = 0;
      v32[1] = 0;
      v20 = (_anonymous_namespace_ *)re::internal::parseNextBindingKey((char *)&v43, v32, (uint64_t)&v43);
      v29 = 0;
      v30 = 0;
      v31 = 0;
      re::DynamicString::setCapacity(&v28, 0);
      re::internal::unescapeBindingKey(v32, (re::DynamicString *)&v28);
      re::StringID::StringID((re::StringID *)&v26, (const re::DynamicString *)&v28);
      v21 = v26;
      v22 = v27;
      v26 = 0;
      v27 = &str_110;
      v23 = *(_QWORD *)a5;
      v24 = (void *)*((_QWORD *)a5 + 1);
      *(_QWORD *)a5 = v21;
      *((_QWORD *)a5 + 1) = v22;
      v45 = v21 & 0xFFFFFFFFFFFFFFFELL | v23 & 1;
      v46 = v24;
      re::StringID::destroyString((re::StringID *)&v45);
      re::StringID::destroyString((re::StringID *)&v26);
      if (v28)
      {
        if ((v29 & 1) != 0)
          (*(void (**)(void))(*v28 + 40))();
      }
    }
    if (v33 && (v34 & 1) != 0)
      (*(void (**)(void))(*v33 + 40))();
  }
  result = v38;
  if (v38)
  {
    if ((v39 & 1) != 0)
      return (uint64_t *)(*(uint64_t (**)(void))(*v38 + 40))();
  }
  return result;
}

uint64_t re::GeometricObjectBase::scalePose(float32x4_t *a1, float32x4_t *a2, char a3)
{
  uint64_t v6;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  float32x4_t v11;
  float32x4_t v12[2];

  v6 = (*(uint64_t (**)(float32x4_t *))(a1->i64[0] + 16))(a1);
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 24))(v6);
  if ((_DWORD)result == 7)
  {
    result = (*(uint64_t (**)(float32x4_t *))(a1->i64[0] + 16))(a1);
    v8 = *(_QWORD *)(result + 32);
    if (v8)
    {
      v9 = *(_QWORD *)(result + 40);
      v10 = 240 * v8;
      do
      {
        result = re::GeometricObjectBase::scalePose(v9, a2, 0);
        v9 += 240;
        v10 -= 240;
      }
      while (v10);
    }
  }
  if ((a3 & 1) == 0)
  {
    v11 = a1[2];
    v12[0] = a1[1];
    v12[1] = v11;
    v12[0] = vmulq_f32(v12[0], *a2);
    return (*(uint64_t (**)(float32x4_t *, float32x4_t *))(a1->i64[0] + 64))(a1, v12);
  }
  return result;
}

uint64_t re::GeometricObjectBase::onScaleChanged(float32x4_t *a1, uint64_t a2, float32x4_t *a3)
{
  return re::GeometricObjectBase::scalePose(a1, a3, 1);
}

float32x4_t re::GeometricObjectBase::parentPose@<Q0>(re::GeometricObjectBase *this@<X0>, float32x4_t *a2@<X8>, float32x4_t result@<Q0>)
{
  _QWORD *v4;
  float32x4_t v5;
  float32x4_t v7;
  float32x4_t v8;
  float32x4_t v9;
  int32x4_t v10;
  float32x4_t v11;
  float32x4_t v13;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;

  a2->i64[0] = 0;
  a2->i64[1] = 0;
  a2[1].i64[0] = 0;
  a2[1].i64[1] = 0x3F80000000000000;
  v4 = (_QWORD *)*((_QWORD *)this + 6);
  if (v4 && v4[6])
  {
    v5 = (float32x4_t)xmmword_2260E5D70;
    result = 0uLL;
    do
    {
      v19 = result;
      v20 = v5;
      (*(void (**)(float32x4_t *__return_ptr, _QWORD *))(*v4 + 40))(&v21, v4);
      _Q0 = (int32x4_t)v22;
      v7 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(_Q0, _Q0), v22, 0xCuLL);
      v8 = vnegq_f32((float32x4_t)v22);
      v9 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v19, (int32x4_t)v19), (int8x16_t)v19, 0xCuLL), v8), v19, v7);
      v10 = (int32x4_t)vaddq_f32(v9, v9);
      v11 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v10, v10), (int8x16_t)v10, 0xCuLL);
      _Q6 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v11, (int32x4_t)v11), (int8x16_t)v11, 0xCuLL), v8), v11, v7);
      v13 = vaddq_f32(vaddq_f32(v19, vmulq_laneq_f32(v11, (float32x4_t)v22, 3)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(_Q6, _Q6), (int8x16_t)_Q6, 0xCuLL));
      _Q4 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v20, (int32x4_t)v20), (int8x16_t)v20, 0xCuLL), v8), v20, v7);
      v5 = vmlaq_laneq_f32(vmlaq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(_Q4, _Q4), (int8x16_t)_Q4, 0xCuLL), v20, (float32x4_t)v22, 3), (float32x4_t)v22, v20, 3);
      _Q6.i32[0] = v20.i32[3];
      __asm { FMLA            S4, S6, V0.S[3] }
      v5.i32[3] = _Q4.i32[0];
      result = vaddq_f32(v21, v13);
      *a2 = result;
      a2[1] = v5;
      v4 = (_QWORD *)v4[6];
    }
    while (v4[6]);
  }
  return result;
}

uint64_t re::GeometricObject::deinit(re::GeometricObject *this)
{
  uint64_t v2;
  void (***v3)(_QWORD);
  uint64_t result;

  v2 = *((_QWORD *)this + 29);
  if (v2)
  {
    v3 = (void (***)(_QWORD))*((_QWORD *)this + 8);
    if (v3)
    {
      (**v3)(*((_QWORD *)this + 8));
      (*(void (**)(uint64_t, void (***)(_QWORD)))(*(_QWORD *)v2 + 40))(v2, v3);
    }
    *((_QWORD *)this + 8) = 0;
  }
  result = *((_QWORD *)this + 18);
  if (result)
  {
    if (*((_QWORD *)this + 22))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *((_QWORD *)this + 22) = 0;
    *((_QWORD *)this + 19) = 0;
    *((_QWORD *)this + 20) = 0;
    *((_QWORD *)this + 18) = 0;
    ++*((_DWORD *)this + 42);
  }
  return result;
}

void re::GeometricObject::setPoseInternal(uint64_t a1, uint64_t a2)
{
  _OWORD *v4;
  __int128 v5;

  v4 = (_OWORD *)(a1 + 112);
  if (!re::areAlmostEqual<float>((float *)a2, (float *)(a1 + 112)))
  {
    v5 = *(_OWORD *)(a2 + 16);
    *v4 = *(_OWORD *)a2;
    v4[1] = v5;
    re::Event<re::GeometricObjectBase>::raise(a1 + 144, a1);
  }
}

BOOL re::areAlmostEqual<float>(float *a1, float *a2)
{
  float v2;
  float v3;
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;

  v2 = a1[4];
  v3 = a2[4];
  if (v2 != v3 && vabds_f32(v2, v3) >= (float)((float)((float)(fabsf(v2) + fabsf(v3)) + 1.0) * 0.00001))
    return 0;
  v4 = a1[5];
  v5 = a2[5];
  if (v4 != v5 && vabds_f32(v4, v5) >= (float)((float)((float)(fabsf(v4) + fabsf(v5)) + 1.0) * 0.00001))
    return 0;
  v6 = a1[6];
  v7 = a2[6];
  if (v6 != v7 && vabds_f32(v6, v7) >= (float)((float)((float)(fabsf(v6) + fabsf(v7)) + 1.0) * 0.00001))
    return 0;
  v8 = a1[7];
  v9 = a2[7];
  if (v8 != v9 && vabds_f32(v8, v9) >= (float)((float)((float)(fabsf(v8) + fabsf(v9)) + 1.0) * 0.00001))
    return 0;
  if (*a1 != *a2 && vabds_f32(*a1, *a2) >= (float)((float)((float)(fabsf(*a1) + fabsf(*a2)) + 1.0) * 0.00001))
    return 0;
  v10 = a1[1];
  v11 = a2[1];
  if (v10 != v11 && vabds_f32(v10, v11) >= (float)((float)((float)(fabsf(v10) + fabsf(v11)) + 1.0) * 0.00001))
    return 0;
  v12 = a1[2];
  v13 = a2[2];
  return v12 == v13 || vabds_f32(v12, v13) < (float)((float)((float)(fabsf(v12) + fabsf(v13)) + 1.0) * 0.00001);
}

{
  float v2;
  float v3;
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;

  if (*a1 != *a2 && vabds_f32(*a1, *a2) >= (float)((float)((float)(fabsf(*a1) + fabsf(*a2)) + 1.0) * 0.00001))
    return 0;
  v2 = a1[1];
  v3 = a2[1];
  if (v2 != v3 && vabds_f32(v2, v3) >= (float)((float)((float)(fabsf(v2) + fabsf(v3)) + 1.0) * 0.00001))
    return 0;
  v4 = a1[2];
  v5 = a2[2];
  if (v4 != v5 && vabds_f32(v4, v5) >= (float)((float)((float)(fabsf(v4) + fabsf(v5)) + 1.0) * 0.00001))
    return 0;
  v6 = a1[3];
  v7 = a2[3];
  if (v6 != v7 && vabds_f32(v6, v7) >= (float)((float)((float)(fabsf(v6) + fabsf(v7)) + 1.0) * 0.00001))
    return 0;
  v8 = a1[4];
  v9 = a2[4];
  if (v8 != v9 && vabds_f32(v8, v9) >= (float)((float)((float)(fabsf(v8) + fabsf(v9)) + 1.0) * 0.00001))
    return 0;
  v10 = a1[5];
  v11 = a2[5];
  if (v10 != v11 && vabds_f32(v10, v11) >= (float)((float)((float)(fabsf(v10) + fabsf(v11)) + 1.0) * 0.00001))
    return 0;
  v12 = a1[6];
  v13 = a2[6];
  if (v12 != v13 && vabds_f32(v12, v13) >= (float)((float)((float)(fabsf(v12) + fabsf(v13)) + 1.0) * 0.00001))
    return 0;
  v14 = a1[7];
  v15 = a2[7];
  if (v14 != v15 && vabds_f32(v14, v15) >= (float)((float)((float)(fabsf(v14) + fabsf(v15)) + 1.0) * 0.00001))
    return 0;
  v16 = a1[8];
  v17 = a2[8];
  if (v16 != v17 && vabds_f32(v16, v17) >= (float)((float)((float)(fabsf(v16) + fabsf(v17)) + 1.0) * 0.00001))
    return 0;
  v18 = a1[9];
  v19 = a2[9];
  if (v18 != v19 && vabds_f32(v18, v19) >= (float)((float)((float)(fabsf(v18) + fabsf(v19)) + 1.0) * 0.00001))
    return 0;
  v20 = a1[10];
  v21 = a2[10];
  if (v20 != v21 && vabds_f32(v20, v21) >= (float)((float)((float)(fabsf(v20) + fabsf(v21)) + 1.0) * 0.00001))
    return 0;
  v22 = a1[11];
  v23 = a2[11];
  if (v22 != v23 && vabds_f32(v22, v23) >= (float)((float)((float)(fabsf(v22) + fabsf(v23)) + 1.0) * 0.00001))
    return 0;
  v24 = a1[12];
  v25 = a2[12];
  if (v24 != v25 && vabds_f32(v24, v25) >= (float)((float)((float)(fabsf(v24) + fabsf(v25)) + 1.0) * 0.00001))
    return 0;
  v26 = a1[13];
  v27 = a2[13];
  if (v26 != v27 && vabds_f32(v26, v27) >= (float)((float)((float)(fabsf(v26) + fabsf(v27)) + 1.0) * 0.00001))
    return 0;
  v28 = a1[14];
  v29 = a2[14];
  if (v28 != v29 && vabds_f32(v28, v29) >= (float)((float)((float)(fabsf(v28) + fabsf(v29)) + 1.0) * 0.00001))
    return 0;
  v30 = a1[15];
  v31 = a2[15];
  return v30 == v31 || vabds_f32(v30, v31) < (float)((float)((float)(fabsf(v30) + fabsf(v31)) + 1.0) * 0.00001);
}

void re::Event<re::GeometricObjectBase>::raise(uint64_t a1, uint64_t a2)
{
  int v3;
  unint64_t v5;

  v3 = *(_DWORD *)(a1 + 80);
  *(_DWORD *)(a1 + 80) = v3 + 1;
  if (*(_QWORD *)(a1 + 16))
  {
    v5 = 0;
    do
    {
      if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)(a1 + 32) + 32 * v5 + 24))(a2) == 1)
        re::DynamicArray<re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription>::removeStableAt((_QWORD *)a1, v5);
      else
        ++v5;
    }
    while (v5 < *(_QWORD *)(a1 + 16));
    v3 = *(_DWORD *)(a1 + 80) - 1;
  }
  *(_DWORD *)(a1 + 80) = v3;
  if (!v3)
    re::Event<re::GeometricObjectBase>::doDeferredActions((_anonymous_namespace_ *)a1);
}

void *re::introspect_GeometricObjectType(re *this, const re::IntrospectionBase *a2)
{
  int v2;
  unsigned __int8 v3;
  unsigned __int8 v4;
  char v5;
  re *v6;
  std::__shared_mutex_base *v7;
  re *v8;
  std::__shared_mutex_base *v9;
  re *v11;
  uint64_t *v12;
  re *v13;
  uint64_t *v14;
  re *v15;
  uint64_t *v16;
  uint64_t v17;
  re::IntrospectionBasic *v18;
  uint64_t v19[2];
  __int128 v20;

  v2 = (int)this;
  if ((v3 & 1) == 0)
  {
    if ((_DWORD)v11)
    {
      v12 = re::introspectionAllocator(v11);
      v13 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v12 + 32))(v12, 24, 8);
      *(_DWORD *)v13 = 1;
      *((_QWORD *)v13 + 1) = 0;
      *((_QWORD *)v13 + 2) = "Unknown";
      re::introspect_GeometricObjectType(BOOL)::enumAttributes = (uint64_t)v13;
      v14 = re::introspectionAllocator(v13);
      v15 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v14 + 32))(v14, 24, 8);
      *(_DWORD *)v15 = 1;
      *((_QWORD *)v15 + 1) = 1;
      *((_QWORD *)v15 + 2) = "GeometricObject";
      qword_255827A20 = (uint64_t)v15;
      v16 = re::introspectionAllocator(v15);
      v17 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v16 + 32))(v16, 24, 8);
      *(_DWORD *)v17 = 1;
      *(_QWORD *)(v17 + 8) = 2;
      *(_QWORD *)(v17 + 16) = "RigidBody";
      qword_255827A28 = v17;
    }
  }
  {
    v18 = re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&re::introspect_GeometricObjectType(BOOL)::info, "GeometricObjectType", 4, 4, 1, 1);
    *(_QWORD *)v18 = &off_24ED7D9E8;
    *((_QWORD *)v18 + 8) = &re::introspect_GeometricObjectType(BOOL)::enumTable;
    *((_DWORD *)v18 + 4) = 9;
  }
  if (v2)
  {
    if ((re::introspect_GeometricObjectType(BOOL)::isInitialized & 1) != 0)
      return &re::introspect_GeometricObjectType(BOOL)::info;
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v20);
    v5 = re::introspect_GeometricObjectType(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v20);
    if ((v5 & 1) != 0)
      return &re::introspect_GeometricObjectType(BOOL)::info;
    v7 = re::introspectionSharedMutex(v6);
    std::__shared_mutex_base::lock(v7);
    if ((re::introspect_GeometricObjectType(BOOL)::isInitialized & 1) != 0)
    {
LABEL_9:
      v9 = re::introspectionSharedMutex(v8);
      std::__shared_mutex_base::unlock(v9);
      return &re::introspect_GeometricObjectType(BOOL)::info;
    }
  }
  re::introspect_GeometricObjectType(BOOL)::isInitialized = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&re::introspect_GeometricObjectType(BOOL)::info, a2);
  v19[0] = 0x871260762363F434;
  v19[1] = (uint64_t)"GeometricObjectType";
  xmmword_255827A58 = v20;
  re::StringID::destroyString((re::StringID *)v19);
  if ((v2 & 1) == 0)
    goto LABEL_9;
  return &re::introspect_GeometricObjectType(BOOL)::info;
}

void re::internal::registerEnumType<re::GeometricObjectType>(re::TypeRegistry *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, _QWORD *a4@<X8>)
{
  uint64_t *v8;
  uint64_t v9;
  _anonymous_namespace_ *v10;
  uint64_t v11;
  unsigned int *v12;
  unint64_t v13;
  unint64_t i;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  char v18;
  unsigned __int8 *v19;
  int v20;
  uint64_t v21;
  unint64_t j;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  char v26;
  unsigned __int8 *v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  StringID v31;
  _QWORD v32[2];
  _QWORD v33[61];

  v33[0] = 208862;
  v33[1] = "int";
  v8 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a1 + 200, v33);
  if (!v8)
  {
    re::StringID::destroyString((re::StringID *)v33);
    goto LABEL_29;
  }
  v9 = *v8;
  re::StringID::destroyString((re::StringID *)v33);
  if (!a1)
  {
LABEL_29:
    re::internal::assertLog((re::internal *)5, v11, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, a3[1]);
    _os_crash();
    __break(1u);
    return;
  }
  v12 = *(unsigned int **)(a2 + 64);
  v32[0] = a1;
  v32[1] = v9;
  re::TypeBuilder::beginEnumType((uint64_t)v33, a3, 1, 1, (uint64_t)v32);
  v13 = *v12;
  if ((_DWORD)v13)
  {
    for (i = 0; i < v13; ++i)
    {
      v15 = *(_QWORD *)(*((_QWORD *)v12 + 1) + 8 * i);
      if (*(_DWORD *)v15 == 1)
      {
        v16 = *(char **)(v15 + 16);
        if (v16)
        {
          v17 = *v16;
          if (*v16)
          {
            v18 = v16[1];
            if (v18)
            {
              v19 = (unsigned __int8 *)(v16 + 2);
              do
              {
                v17 = 31 * v17 + v18;
                v20 = *v19++;
                v18 = v20;
              }
              while (v20);
            }
          }
        }
        else
        {
          v17 = 0;
        }
        v21 = *(_QWORD *)(v15 + 8);
        *(_QWORD *)&v31.var0 = 2 * v17;
        v31.var1 = v16;
        re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v33, v21, &v31);
        re::StringID::destroyString((re::StringID *)&v31);
        v13 = *v12;
      }
    }
    if (v13)
    {
      for (j = 0; j < v13; ++j)
      {
        v23 = *(_QWORD *)(*((_QWORD *)v12 + 1) + 8 * j);
        if (*(_DWORD *)v23 == 2)
        {
          v24 = *(char **)(v23 + 16);
          if (v24)
          {
            v25 = *v24;
            if (*v24)
            {
              v26 = v24[1];
              if (v26)
              {
                v27 = (unsigned __int8 *)(v24 + 2);
                do
                {
                  v25 = 31 * v25 + v26;
                  v28 = *v27++;
                  v26 = v28;
                }
                while (v28);
              }
            }
          }
          else
          {
            v25 = 0;
          }
          v29 = *(_QWORD *)(v23 + 8);
          *(_QWORD *)&v31.var0 = 2 * v25;
          v31.var1 = v24;
          re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v33, v29, &v31);
          re::StringID::destroyString((re::StringID *)&v31);
          v13 = *v12;
        }
      }
    }
  }
  re::TypeBuilder::commitTo((re::TypeBuilder *)v33, a1, a4);
  re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v33, v30);
}

void re::GeometricObject::~GeometricObject(re::GeometricObject *this)
{
  re::GeometricObject::deinit(this);
  re::Event<re::Engine>::~Event((uint64_t *)this + 18);
}

{
  re::GeometricObject::deinit(this);
  re::Event<re::Engine>::~Event((uint64_t *)this + 18);
  JUMPOUT(0x2276933B8);
}

uint64_t re::GeometricObject::shape(re::GeometricObject *this)
{
  return *((_QWORD *)this + 8);
}

{
  return *((_QWORD *)this + 8);
}

__n128 re::GeometricObject::pose@<Q0>(__n128 *this@<X0>, __n128 *a2@<X8>)
{
  __n128 result;
  __n128 v3;

  result = this[7];
  v3 = this[8];
  *a2 = result;
  a2[1] = v3;
  return result;
}

uint64_t re::GeometricObject::poseDidChange(re::GeometricObject *this)
{
  return (uint64_t)this + 144;
}

uint64_t re::GeometricObject::type(re::GeometricObject *this)
{
  return 1;
}

_QWORD *re::DynamicArray<re::Event<re::GeometricObjectBase>::Subscription>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  void *v7;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (*v5)
      {
        if (!a2)
        {
          v7 = 0;
          if (!v3)
            goto LABEL_9;
          goto LABEL_8;
        }
        if (a2 >> 59)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 32, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          v2 = 32 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 32 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
            {
LABEL_9:
              v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            memcpy(v7, (const void *)v5[4], 32 * v5[2]);
            result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
      }
      else
      {
        result = (_QWORD *)re::DynamicArray<re::Event<re::GeometricObjectBase>::Subscription>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

void re::Event<re::GeometricObjectBase>::doDeferredActions(_anonymous_namespace_ *a1)
{
  uint64_t v1;
  uint64_t v3;
  unint64_t i;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __int128 v8;
  _OWORD v9[2];
  uint64_t v10;
  int v11;
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  unint64_t v16;
  __int16 v17;
  unint64_t v18;
  _OWORD v19[5];
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  v1 = *((_QWORD *)a1 + 7);
  if (v1)
  {
    v3 = 0;
    for (i = 0; i != v1; ++i)
    {
      v5 = *((_QWORD *)a1 + 7);
      if (v5 <= i)
      {
        memset(v19, 0, sizeof(v19));
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        v11 = 136315906;
        v12 = "operator[]";
        v13 = 1024;
        v14 = 789;
        v15 = 2048;
        v16 = i;
        v17 = 2048;
        v18 = v5;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      v6 = *((_QWORD *)a1 + 9) + v3;
      v7 = *(_QWORD *)(v6 + 32);
      v8 = *(_OWORD *)(v6 + 16);
      v9[0] = *(_OWORD *)v6;
      v9[1] = v8;
      v10 = v7;
      if (LOBYTE(v9[0]))
      {
        re::DynamicArray<re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription>::indexOf((uint64_t)a1, (_QWORD *)v9 + 1, (uint64_t)v19);
        if (!LOBYTE(v19[0]))
          re::DynamicArray<re::Event<re::GeometricObjectBase>::Subscription>::add(a1, (uint64_t)v9 + 8);
      }
      else
      {
        re::DynamicArray<re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription>::removeStable(a1, (_QWORD *)v9 + 1);
      }
      v3 += 40;
    }
  }
}

__n128 re::DynamicArray<re::Event<re::GeometricObjectBase>::Subscription>::add(_anonymous_namespace_ *this, uint64_t a2)
{
  unint64_t v4;
  _OWORD *v5;
  __n128 result;
  __int128 v7;

  v4 = *((_QWORD *)this + 2);
  if (v4 >= *((_QWORD *)this + 1))
  {
    re::DynamicArray<re::Event<re::GeometricObjectBase>::Subscription>::growCapacity(this, v4 + 1);
    v4 = *((_QWORD *)this + 2);
  }
  v5 = (_OWORD *)(*((_QWORD *)this + 4) + 32 * v4);
  result = *(__n128 *)a2;
  v7 = *(_OWORD *)(a2 + 16);
  *v5 = *(_OWORD *)a2;
  v5[1] = v7;
  ++*((_QWORD *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

_QWORD *re::DynamicArray<re::Event<re::GeometricObjectBase>::Subscription>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<re::Event<re::GeometricObjectBase>::Subscription>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::Event<re::GeometricObjectBase>::Subscription>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

void *re::introspect_CollisionObjectType(re *this, const re::IntrospectionBase *a2)
{
  int v2;
  unsigned __int8 v3;
  unsigned __int8 v4;
  char v5;
  re *v6;
  std::__shared_mutex_base *v7;
  re *v8;
  std::__shared_mutex_base *v9;
  re *v11;
  uint64_t *v12;
  re *v13;
  uint64_t *v14;
  uint64_t v15;
  re::IntrospectionBasic *v16;
  uint64_t v17[2];
  __int128 v18;

  v2 = (int)this;
  if ((v3 & 1) == 0)
  {
    if ((_DWORD)v11)
    {
      v12 = re::introspectionAllocator(v11);
      v13 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v12 + 32))(v12, 24, 8);
      *(_DWORD *)v13 = 1;
      *((_QWORD *)v13 + 1) = 0;
      *((_QWORD *)v13 + 2) = "Default";
      re::introspect_CollisionObjectType(BOOL)::enumAttributes = (uint64_t)v13;
      v14 = re::introspectionAllocator(v13);
      v15 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v14 + 32))(v14, 24, 8);
      *(_DWORD *)v15 = 1;
      *(_QWORD *)(v15 + 8) = 1;
      *(_QWORD *)(v15 + 16) = "Trigger";
      qword_255827A98 = v15;
    }
  }
  {
    v16 = re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&re::introspect_CollisionObjectType(BOOL)::info, "CollisionObjectType", 1, 1, 1, 1);
    *(_QWORD *)v16 = &off_24ED7D9E8;
    *((_QWORD *)v16 + 8) = &re::introspect_CollisionObjectType(BOOL)::enumTable;
    *((_DWORD *)v16 + 4) = 9;
  }
  if (v2)
  {
    if ((re::introspect_CollisionObjectType(BOOL)::isInitialized & 1) != 0)
      return &re::introspect_CollisionObjectType(BOOL)::info;
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v18);
    v5 = re::introspect_CollisionObjectType(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v18);
    if ((v5 & 1) != 0)
      return &re::introspect_CollisionObjectType(BOOL)::info;
    v7 = re::introspectionSharedMutex(v6);
    std::__shared_mutex_base::lock(v7);
    if ((re::introspect_CollisionObjectType(BOOL)::isInitialized & 1) != 0)
    {
LABEL_9:
      v9 = re::introspectionSharedMutex(v8);
      std::__shared_mutex_base::unlock(v9);
      return &re::introspect_CollisionObjectType(BOOL)::info;
    }
  }
  re::introspect_CollisionObjectType(BOOL)::isInitialized = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&re::introspect_CollisionObjectType(BOOL)::info, a2);
  v17[0] = 0x601C7BD2D83C0796;
  v17[1] = (uint64_t)"CollisionObjectType";
  xmmword_255827AC8 = v18;
  re::StringID::destroyString((re::StringID *)v17);
  if ((v2 & 1) == 0)
    goto LABEL_9;
  return &re::introspect_CollisionObjectType(BOOL)::info;
}

float re::PhysXCapsuleShape::height(re::PhysXCapsuleShape *this)
{
  return (float)(*((float *)this + 7) + *((float *)this + 6)) + (float)(*((float *)this + 7) + *((float *)this + 6));
}

float re::PhysXCapsuleShape::radius(re::PhysXCapsuleShape *this)
{
  return *((float *)this + 6);
}

double re::PhysXCapsuleShape::aabb@<D0>(re::PhysXCapsuleShape *a1@<X0>, float32x4_t *a2@<X1>, _OWORD *a3@<X8>)
{
  float32x4_t v7;
  float32x4_t v8;
  float32x4_t v9;
  int8x16_t v10;
  float32x4_t v11;
  int8x16_t v12;
  int8x16_t v13;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  double result;
  __int128 v29;
  uint64_t v30;
  __int32 v31;
  __int32 v32;
  uint64_t v33;
  __int32 v34;
  _BYTE v35[20];
  int v36;

  re::PhysXCapsuleShape::localTransform(a1);
  _Q0 = a2[1];
  v7 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q0, (int32x4_t)_Q0), (int8x16_t)_Q0, 0xCuLL);
  v8 = vnegq_f32(_Q0);
  v9 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)xmmword_254105BD0, (int32x4_t)xmmword_254105BD0), (int8x16_t)xmmword_254105BD0, 0xCuLL), v8), (float32x4_t)xmmword_254105BD0, v7);
  v10 = (int8x16_t)vaddq_f32(v9, v9);
  v11 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v10, (int32x4_t)v10), v10, 0xCuLL);
  v12 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v11, (int32x4_t)v11), (int8x16_t)v11, 0xCuLL), v8), v11, v7);
  v13 = (int8x16_t)vaddq_f32(*a2, vaddq_f32(vaddq_f32((float32x4_t)xmmword_254105BD0, vmulq_laneq_f32(v11, _Q0, 3)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v12, (int32x4_t)v12), v12, 0xCuLL)));
  _Q3 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(*(int32x4_t *)&qword_254105BE0, *(int32x4_t *)&qword_254105BE0), *(int8x16_t *)&qword_254105BE0, 0xCuLL), v8), *(float32x4_t *)&qword_254105BE0, v7);
  v15 = vmlaq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q3, (int32x4_t)_Q3), _Q3, 0xCuLL), *(float32x4_t *)&qword_254105BE0, _Q0, 3);
  _Q3.i32[0] = unk_254105BEC;
  v16 = vmlaq_laneq_f32(v15, _Q0, *(float32x4_t *)&qword_254105BE0, 3);
  v17 = vmulq_f32(_Q0, *(float32x4_t *)&qword_254105BE0);
  v18 = vaddq_f32(v17, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v17.f32, 1));
  _Q4 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v17, 2), v18);
  v31 = v16.i32[2];
  __asm { FMLA            S4, S3, V0.S[3] }
  v32 = _Q4.i32[0];
  v33 = v13.i64[0];
  v34 = v13.i32[2];
  _Q0.i32[0] = 0;
  v13.i32[0] = 1.0;
  physx::Gu::computeBounds((float32x2_t *)v35, (uint64_t)a1 + 20, (uint64_t)&v30, 0, _Q0, v13, *(double *)v16.i64, *(double *)_Q3.i64, *(double *)_Q4.i64, *(double *)v18.i64, *(double *)v8.i64, (int32x4_t)v12, v24, v25, v26, v27, v16.i8[0]);
  result = *(double *)v35;
  *(_QWORD *)&v29 = *(_QWORD *)&v35[12];
  DWORD2(v29) = v36;
  *a3 = *(_OWORD *)v35;
  a3[1] = v29;
  return result;
}

__int128 *re::PhysXCapsuleShape::localTransform(re::PhysXCapsuleShape *this)
{
  unsigned __int8 v1;
  uint64_t Rotation;
  uint64_t v4;
  float32x4_t v5;

  v1 = atomic_load((unsigned __int8 *)_MergedGlobals_126);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(_MergedGlobals_126))
  {
    v5.i64[0] = 0;
    v5.i64[1] = 1065353216;
    Rotation = re::Quaternion<float>::makeRotation(&v5, 1.5708);
    xmmword_254105BD0 = 0uLL;
    qword_254105BE0 = Rotation;
    unk_254105BE8 = v4;
    __cxa_guard_release(_MergedGlobals_126);
  }
  return &xmmword_254105BD0;
}

void re::PhysXCapsuleShape::~PhysXCapsuleShape(re::PhysXCapsuleShape *this)
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::CapsuleShape::type(re::CapsuleShape *this)
{
  return 4;
}

uint64_t re::PhysXCapsuleShape::requiresLocalTransform(re::PhysXCapsuleShape *this)
{
  return 1;
}

uint64_t re::CollisionShape::isStaticShape(re::CollisionShape *this)
{
  return 0;
}

void re::introspect_CollisionQueryType(re *this, const re::IntrospectionBase *a2)
{
  unsigned __int8 v2;
  unsigned __int8 v3;
  uint64_t *v4;
  uint64_t v5;
  unsigned int *v6;
  _anonymous_namespace_ *v7;
  unint64_t v8;
  unint64_t i;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  char v13;
  unsigned __int8 *v14;
  int v15;
  uint64_t v16;
  unint64_t j;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  char v21;
  unsigned __int8 *v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  re *v26;
  uint64_t *v27;
  re *v28;
  uint64_t *v29;
  re *v30;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  const char *v35;
  StringID v36;
  _QWORD v37[2];
  _QWORD v38[61];

  v2 = atomic_load((unsigned __int8 *)&qword_254105BF8);
  if ((v2 & 1) == 0)
  {
    v26 = (re *)__cxa_guard_acquire(&qword_254105BF8);
    if ((_DWORD)v26)
    {
      v27 = re::introspectionAllocator(v26);
      v28 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v27 + 32))(v27, 24, 8);
      *(_DWORD *)v28 = 1;
      *((_QWORD *)v28 + 1) = 0;
      *((_QWORD *)v28 + 2) = "Nearest";
      qword_254105C28 = (uint64_t)v28;
      v29 = re::introspectionAllocator(v28);
      v30 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v29 + 32))(v29, 24, 8);
      *(_DWORD *)v30 = 1;
      *((_QWORD *)v30 + 1) = 1;
      *((_QWORD *)v30 + 2) = "All";
      qword_254105C30 = (uint64_t)v30;
      v31 = re::introspectionAllocator(v30);
      v32 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v31 + 32))(v31, 24, 8);
      *(_DWORD *)v32 = 1;
      *(_QWORD *)(v32 + 8) = 2;
      *(_QWORD *)(v32 + 16) = "Any";
      qword_254105C38 = v32;
      __cxa_guard_release(&qword_254105BF8);
    }
  }
  v3 = atomic_load((unsigned __int8 *)&qword_254105C00);
  if ((v3 & 1) == 0 && __cxa_guard_acquire(&qword_254105C00))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_254105C40, "CollisionQueryType", 1, 1, 1, 1);
    qword_254105C40 = (uint64_t)&off_24ED7D9E8;
    qword_254105C80 = (uint64_t)&re::introspect_CollisionQueryType(BOOL)::enumTable;
    dword_254105C50 = 9;
    __cxa_guard_release(&qword_254105C00);
  }
  if ((_MergedGlobals_127 & 1) == 0)
  {
    _MergedGlobals_127 = 1;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_254105C40, a2);
    v34 = 0x139DD67E02300A60;
    v35 = "CollisionQueryType";
    v38[0] = 0x31CD534126;
    v38[1] = "uint8_t";
    v4 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v38);
    if (v4)
    {
      v5 = *v4;
      re::StringID::destroyString((re::StringID *)v38);
      v6 = (unsigned int *)qword_254105C80;
      v37[1] = v5;
      re::TypeBuilder::beginEnumType((uint64_t)v38, &v34, 1, 1, (uint64_t)v37);
      v8 = *v6;
      if ((_DWORD)v8)
      {
        for (i = 0; i < v8; ++i)
        {
          v10 = *(_QWORD *)(*((_QWORD *)v6 + 1) + 8 * i);
          if (*(_DWORD *)v10 == 1)
          {
            v11 = *(char **)(v10 + 16);
            if (v11)
            {
              v12 = *v11;
              if (*v11)
              {
                v13 = v11[1];
                if (v13)
                {
                  v14 = (unsigned __int8 *)(v11 + 2);
                  do
                  {
                    v12 = 31 * v12 + v13;
                    v15 = *v14++;
                    v13 = v15;
                  }
                  while (v15);
                }
              }
            }
            else
            {
              v12 = 0;
            }
            v16 = *(_QWORD *)(v10 + 8);
            *(_QWORD *)&v36.var0 = 2 * v12;
            v36.var1 = v11;
            re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v38, v16, &v36);
            re::StringID::destroyString((re::StringID *)&v36);
            v8 = *v6;
          }
        }
        if (v8)
        {
          for (j = 0; j < v8; ++j)
          {
            v18 = *(_QWORD *)(*((_QWORD *)v6 + 1) + 8 * j);
            if (*(_DWORD *)v18 == 2)
            {
              v19 = *(char **)(v18 + 16);
              if (v19)
              {
                v20 = *v19;
                if (*v19)
                {
                  v21 = v19[1];
                  if (v21)
                  {
                    v22 = (unsigned __int8 *)(v19 + 2);
                    do
                    {
                      v20 = 31 * v20 + v21;
                      v23 = *v22++;
                      v21 = v23;
                    }
                    while (v23);
                  }
                }
              }
              else
              {
                v20 = 0;
              }
              v24 = *(_QWORD *)(v18 + 8);
              *(_QWORD *)&v36.var0 = 2 * v20;
              v36.var1 = v19;
              re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v38, v24, &v36);
              re::StringID::destroyString((re::StringID *)&v36);
              v8 = *v6;
            }
          }
        }
      }
      re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v38, v25);
      xmmword_254105C60 = (__int128)v36;
      re::StringID::destroyString((re::StringID *)&v34);
    }
    else
    {
      re::StringID::destroyString((re::StringID *)v38);
      re::internal::assertLog((re::internal *)5, v33, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "CollisionQueryType", v34, v35);
      _os_crash();
      __break(1u);
    }
  }
}

uint64_t *re::allocInfo_CollisionCastConfiguration(re *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&qword_254105C08);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_254105C08))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_254105C88, 0);
    *(uint64_t *)((char *)&qword_254105C98 + 6) = 0;
    qword_254105C98 = 0;
    qword_254105CA8 = 0;
    qword_254105CB0 = 0xFFFFFFFFLL;
    qword_254105C88 = (uint64_t)&off_24ED7DAA8;
    qword_254105CB8 = (uint64_t)"CollisionCastConfiguration";
    dword_254105CC0 = 0;
    xmmword_254105CC8 = 0u;
    unk_254105CD8 = 0u;
    xmmword_254105CE8 = 0u;
    qword_254105CF8 = 0;
    __cxa_guard_release(&qword_254105C08);
  }
  return &qword_254105C88;
}

void re::initInfo_CollisionCastConfiguration(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  const re::IntrospectionBase *v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  _QWORD v13[2];
  __int128 v14;

  v13[0] = 0x577B5ED3A5088E0ALL;
  v13[1] = "CollisionCastConfiguration";
  re::StringID::destroyString((re::StringID *)v13);
  *((_OWORD *)this + 2) = v14;
  v4 = atomic_load((unsigned __int8 *)&qword_254105C10);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_254105C10);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      re::introspect_CollisionQueryType((re *)v6, v7);
      v8 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
      *(_DWORD *)v8 = 1;
      *(_QWORD *)(v8 + 8) = "queryType";
      *(_QWORD *)(v8 + 16) = &qword_254105C40;
      *(_QWORD *)(v8 + 24) = 0;
      *(_QWORD *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + 40) = 0;
      *(_QWORD *)(v8 + 48) = 0;
      *(_QWORD *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_254105C18 = v8;
      v9 = re::introspectionAllocator((re *)v8);
      v10 = re::introspect_CollisionFilter((re::IntrospectionBase **)1);
      v11 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v9 + 32))(v9, 72, 8);
      *(_DWORD *)v11 = 1;
      *(_QWORD *)(v11 + 8) = "filter";
      *(_QWORD *)(v11 + 16) = v10;
      *(_QWORD *)(v11 + 24) = 0;
      *(_QWORD *)(v11 + 32) = 0x400000002;
      *(_DWORD *)(v11 + 40) = 0;
      *(_QWORD *)(v11 + 48) = 0;
      *(_QWORD *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_254105C20 = v11;
      __cxa_guard_release(&qword_254105C10);
    }
  }
  *((_QWORD *)this + 2) = 0x2000000008;
  *((_DWORD *)this + 6) = 16;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 2;
  *((_QWORD *)this + 8) = &qword_254105C18;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::CollisionCastConfiguration>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::CollisionCastConfiguration>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::CollisionCastConfiguration>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::CollisionCastConfiguration>;
  re::IntrospectionRegistry::add(this, v3);
  v12 = v14;
}

void re::internal::defaultConstruct<re::CollisionCastConfiguration>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)a3 = 0;
  *(_QWORD *)(a3 + 4) = 0xFFFFFFFF00000001;
  *(_QWORD *)(a3 + 20) = 0;
  *(_QWORD *)(a3 + 12) = 0;
  *(_DWORD *)(a3 + 28) = 0;
}

uint64_t re::internal::defaultConstructV2<re::CollisionCastConfiguration>(uint64_t result)
{
  *(_DWORD *)result = 0;
  *(_QWORD *)(result + 4) = 0xFFFFFFFF00000001;
  *(_QWORD *)(result + 20) = 0;
  *(_QWORD *)(result + 12) = 0;
  *(_DWORD *)(result + 28) = 0;
  return result;
}

uint64_t re::introspect_CollisionCastConfiguration(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"CollisionCastConfiguration", (uint64_t (*)(re::internal *))re::allocInfo_CollisionCastConfiguration, (re::IntrospectionBase *(*)(void))re::initInfo_CollisionCastConfiguration, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::CollisionCastConfiguration>, this);
}

re *re::PhysXCPUDispatcher::reset(re *this)
{
  uint64_t v1;
  re *v2;
  uint64_t v3;

  v1 = *((_QWORD *)this + 5);
  if (v1)
  {
    v2 = this;
    do
    {
      this = re::internal::destroyPersistent<re::Job>((re *)"reset", 26, *(_QWORD *)(*((_QWORD *)v2 + 7) + 8 * v1 - 8));
      v3 = *((_QWORD *)v2 + 5);
      ++*((_DWORD *)v2 + 12);
      v1 = v3 - 1;
      *((_QWORD *)v2 + 5) = v1;
    }
    while (v1);
  }
  return this;
}

re *re::internal::destroyPersistent<re::Job>(re *result, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  if (a3)
  {
    v4 = re::globalAllocators(result)[2];

    return (re *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v4 + 40))(v4, a3);
  }
  return result;
}

uint64_t re::PhysXCPUDispatcher::submitTask(os_unfair_lock_s *this, physx::PxBaseTask *a2)
{
  unsigned int *p_os_unfair_lock_opaque;
  unsigned int v5;
  uint64_t *v6;
  uint64_t (**v7)(uint64_t);
  _anonymous_namespace_ *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  BOOL v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t result;

  if (*(_QWORD *)&this[2]._os_unfair_lock_opaque && LOBYTE(this[4]._os_unfair_lock_opaque))
  {
    p_os_unfair_lock_opaque = &this[16]._os_unfair_lock_opaque;
    do
      v5 = __ldxr(p_os_unfair_lock_opaque);
    while (__stxr(v5 + 1, p_os_unfair_lock_opaque));
    v6 = re::globalAllocators((re *)this);
    v7 = (uint64_t (**)(uint64_t))(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v6[2] + 32))(v6[2], 64, 8);
    v7[2] = 0;
    v7[3] = (uint64_t (*)(uint64_t))"Unnamed";
    *v7 = re::Job::init<re::PhysXCPUDispatcher::submitTask(physx::PxBaseTask &)::$_0>(re::PhysXCPUDispatcher::submitTask(physx::PxBaseTask &)::$_0 &&)::{lambda(re::Job&)#1}::__invoke;
    v7[1] = 0;
    v7[4] = (uint64_t (*)(uint64_t))this;
    v7[5] = (uint64_t (*)(uint64_t))a2;
    os_unfair_lock_lock(this + 5);
    v9 = *(_QWORD *)&this[8]._os_unfair_lock_opaque;
    v10 = *(_QWORD *)&this[10]._os_unfair_lock_opaque;
    if (v10 >= v9)
    {
      v11 = v10 + 1;
      if (v9 < v10 + 1)
      {
        if (*(_QWORD *)&this[6]._os_unfair_lock_opaque)
        {
          v12 = 2 * v9;
          v13 = v9 == 0;
          v14 = 8;
          if (!v13)
            v14 = v12;
          if (v14 <= v11)
            v15 = v11;
          else
            v15 = v14;
          re::DynamicArray<float *>::setCapacity(&this[6]._os_unfair_lock_opaque, v15);
        }
        else
        {
          re::DynamicArray<float *>::setCapacity(&this[6]._os_unfair_lock_opaque, v11);
          ++this[12]._os_unfair_lock_opaque;
        }
      }
      v10 = *(_QWORD *)&this[10]._os_unfair_lock_opaque;
    }
    *(_QWORD *)(*(_QWORD *)&this[14]._os_unfair_lock_opaque + 8 * v10) = v7;
    *(_QWORD *)&this[10]._os_unfair_lock_opaque = v10 + 1;
    ++this[12]._os_unfair_lock_opaque;
    os_unfair_lock_unlock(this + 5);
    return (*(uint64_t (**)(_QWORD, uint64_t (**)(uint64_t), uint64_t, _QWORD, _QWORD))(**(_QWORD **)&this[2]._os_unfair_lock_opaque + 48))(*(_QWORD *)&this[2]._os_unfair_lock_opaque, v7, 1, 0, 0);
  }
  else
  {
    if (re::internal::enableSignposts(0, 0) && re::internal::enableHighFrequencyTracing(0, 0))
      kdebug_trace();
    (*(void (**)(physx::PxBaseTask *))(*(_QWORD *)a2 + 16))(a2);
    (*(void (**)(physx::PxBaseTask *))(*(_QWORD *)a2 + 56))(a2);
    result = re::internal::enableSignposts(0, 0);
    if ((_DWORD)result)
    {
      result = re::internal::enableHighFrequencyTracing(0, 0);
      if ((_DWORD)result)
        return kdebug_trace();
    }
  }
  return result;
}

uint64_t re::PhysXCPUDispatcher::getWorkerCount(re::PhysXCPUDispatcher *this)
{
  uint64_t v2;

  v2 = *((_QWORD *)this + 1);
  if (v2 && *((_BYTE *)this + 16))
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 16))(v2);
  else
    return 0;
}

void re::PhysXCPUDispatcher::~PhysXCPUDispatcher(re::PhysXCPUDispatcher *this)
{
  uint64_t v2;
  _QWORD *v3;

  *(_QWORD *)this = &off_24ED40B60;
  v3 = (_QWORD *)((char *)this + 24);
  v2 = *((_QWORD *)this + 3);
  if (v2)
  {
    if (*((_QWORD *)this + 7))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *((_QWORD *)this + 7) = 0;
    v3[1] = 0;
    v3[2] = 0;
    *v3 = 0;
    ++*((_DWORD *)this + 12);
  }
}

{
  uint64_t v2;
  _QWORD *v3;

  *(_QWORD *)this = &off_24ED40B60;
  v3 = (_QWORD *)((char *)this + 24);
  v2 = *((_QWORD *)this + 3);
  if (v2)
  {
    if (*((_QWORD *)this + 7))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *((_QWORD *)this + 7) = 0;
    v3[1] = 0;
    v3[2] = 0;
    *v3 = 0;
    ++*((_DWORD *)this + 12);
  }
  JUMPOUT(0x2276933B8);
}

uint64_t re::Job::init<re::PhysXCPUDispatcher::submitTask(physx::PxBaseTask &)::$_0>(re::PhysXCPUDispatcher::submitTask(physx::PxBaseTask &)::$_0 &&)::{lambda(re::Job&)#1}::__invoke(uint64_t a1)
{
  uint64_t v2;
  unsigned int *v3;
  unsigned int v4;
  uint64_t result;

  v2 = *(_QWORD *)(a1 + 32);
  if (re::internal::enableSignposts(0, 0) && re::internal::enableHighFrequencyTracing(0, 0))
    kdebug_trace();
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 40) + 16))(*(_QWORD *)(a1 + 40));
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 40) + 56))(*(_QWORD *)(a1 + 40));
  v3 = (unsigned int *)(v2 + 64);
  do
    v4 = __ldxr(v3);
  while (__stlxr(v4 - 1, v3));
  result = re::internal::enableSignposts(0, 0);
  if ((_DWORD)result)
  {
    result = re::internal::enableHighFrequencyTracing(0, 0);
    if ((_DWORD)result)
      result = kdebug_trace();
  }
  *(_QWORD *)a1 = 0;
  return result;
}

double re::EmptyShape::massProperties(uint64_t a1, _DWORD *a2, _QWORD *a3, _OWORD *a4)
{
  double result;

  *a2 = 0;
  *a3 = 0;
  a3[1] = 0;
  result = 0.0;
  a4[1] = 0u;
  a4[2] = 0u;
  *a4 = 0u;
  return result;
}

uint64_t re::EmptyShape::type(re::EmptyShape *this)
{
  return 1;
}

uint64_t re::CollisionShape::requiresLocalTransform(re::CollisionShape *this)
{
  return 0;
}

re::PhysXCollisionFactory *re::initCollision(re *this)
{
  uint64_t *v1;
  re::PhysXCollisionFactory *v2;
  re::PhysXCollisionFactory *result;

  v1 = re::globalAllocators(this);
  v2 = (re::PhysXCollisionFactory *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v1[2] + 32))(v1[2], 56, 8);
  result = re::PhysXCollisionFactory::PhysXCollisionFactory(v2);
  return result;
}

re *re::deinitCollision(re *this)
{
  void (***v1)(_QWORD);
  uint64_t v2;

  {
    v2 = re::globalAllocators(this)[2];
    (**v1)(v1);
    this = (re *)(*(uint64_t (**)(uint64_t, void (***)(_QWORD)))(*(_QWORD *)v2 + 40))(v2, v1);
  }
  return this;
}

uint64_t re::PhysXPlaneShape::PhysXPlaneShape(uint64_t a1, _OWORD *a2, float a3)
{
  int v4;
  __int128 v5;
  _BYTE v7[28];
  _OWORD v8[2];
  int32x2_t v9;
  int v10;
  float v11;

  *(_DWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = &off_24ED40BD0;
  *(_QWORD *)(a1 + 8) = a1 + 96;
  *(_OWORD *)(a1 + 32) = *a2;
  *(float *)(a1 + 48) = a3;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0x3F80000000000000;
  *(_DWORD *)(a1 + 96) = 1;
  v4 = *(_DWORD *)(a1 + 40);
  v9 = *(int32x2_t *)(a1 + 32);
  v10 = v4;
  v11 = -a3;
  physx::PxTransformFromPlaneEquation((float *)&v9, (uint64_t)v7, v9);
  re::internal::nvphysx::fromPhysX((uint64_t)v7, v8);
  v5 = v8[1];
  *(_OWORD *)(a1 + 64) = v8[0];
  *(_OWORD *)(a1 + 80) = v5;
  return a1;
}

_QWORD *re::internal::nvphysx::fromPhysX@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v7;
  uint64_t v8;

  v3 = re::internal::nvphysx::fromPhysX(a1 + 16);
  v8 = v4;
  v7 = v3;
  v5 = (uint64_t *)re::internal::nvphysx::fromPhysX(a1);
  return re::Pose<float>::Pose(a2, v7, v8, *v5, v5[1]);
}

uint64_t re::PhysXPlaneShape::normal(re::PhysXPlaneShape *this)
{
  return (uint64_t)this + 32;
}

float re::PhysXPlaneShape::distanceFromOrigin(re::PhysXPlaneShape *this)
{
  return *((float *)this + 12);
}

double re::PhysXPlaneShape::aabb@<D0>(_OWORD *a1@<X8>)
{
  unsigned __int8 v1;
  double result;
  __int128 v3;
  _OWORD *v4;
  int v5;
  __int128 v6;

  v1 = atomic_load((unsigned __int8 *)_MergedGlobals_128);
  if ((v1 & 1) == 0)
  {
    v4 = a1;
    v5 = __cxa_guard_acquire(_MergedGlobals_128);
    a1 = v4;
    if (v5)
    {
      *(_QWORD *)&v6 = 0x7F0000007FLL;
      *((_QWORD *)&v6 + 1) = 0x7F0000007FLL;
      xmmword_254105D10 = v6;
      unk_254105D20 = vdupq_n_s32(0x7F800000u);
      __cxa_guard_release(_MergedGlobals_128);
      a1 = v4;
    }
  }
  result = *(double *)&xmmword_254105D10;
  v3 = unk_254105D20;
  *a1 = xmmword_254105D10;
  a1[1] = v3;
  return result;
}

uint64_t re::PhysXPlaneShape::localTransform(re::PhysXPlaneShape *this)
{
  return (uint64_t)this + 64;
}

void re::PhysXPlaneShape::~PhysXPlaneShape(re::PhysXPlaneShape *this)
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::PlaneShape::type(re::PlaneShape *this)
{
  return 6;
}

uint64_t re::PhysXPlaneShape::requiresLocalTransform(re::PhysXPlaneShape *this)
{
  return 1;
}

uint64_t re::PlaneShape::isStaticShape(re::PlaneShape *this)
{
  return 1;
}

uint64_t re::internal::nvphysx::fromPhysX(uint64_t a1)
{
  return *(_QWORD *)a1;
}

const void **re::PhysXDebugRenderer::deinit(const void **this)
{
  const void **v1;

  if (*this)
  {
    v1 = this;
    _Block_release(this[13]);
    _Block_release(v1[12]);
    _Block_release(v1[11]);
    _Block_release(v1[10]);
    *((_OWORD *)v1 + 5) = 0u;
    *((_OWORD *)v1 + 6) = 0u;
    this = (const void **)(*(uint64_t (**)(const void *, _QWORD, float))(*(_QWORD *)*v1 + 552))(*v1, 0, 0.0);
    *v1 = 0;
  }
  return this;
}

void *re::PhysXDebugRenderer::init(_QWORD *a1, uint64_t a2, const void *a3, const void *a4, const void *a5, const void *a6)
{
  const void *v11;
  const void *v12;
  const void *v13;
  const void *v14;
  void *result;

  re::PhysXDebugRenderer::setScene(a1, a2);
  v11 = (const void *)a1[10];
  if (v11)
    _Block_release(v11);
  v12 = (const void *)a1[11];
  if (v12)
    _Block_release(v12);
  v13 = (const void *)a1[12];
  if (v13)
    _Block_release(v13);
  v14 = (const void *)a1[13];
  if (v14)
    _Block_release(v14);
  a1[10] = _Block_copy(a3);
  a1[11] = _Block_copy(a4);
  a1[12] = _Block_copy(a5);
  result = _Block_copy(a6);
  a1[13] = result;
  return result;
}

uint64_t re::PhysXDebugRenderer::setScene(_QWORD *a1, uint64_t a2)
{
  *a1 = a2;
  (*(void (**)(uint64_t, _QWORD, float))(*(_QWORD *)a2 + 552))(a2, 0, 0.5);
  (*(void (**)(_QWORD, uint64_t, float))(*(_QWORD *)*a1 + 552))(*a1, 12, 0.5);
  (*(void (**)(_QWORD, uint64_t, float))(*(_QWORD *)*a1 + 552))(*a1, 20, 0.5);
  (*(void (**)(_QWORD, uint64_t, float))(*(_QWORD *)*a1 + 552))(*a1, 21, 0.5);
  (*(void (**)(_QWORD, uint64_t, float))(*(_QWORD *)*a1 + 552))(*a1, 6, 0.5);
  (*(void (**)(_QWORD, uint64_t, float))(*(_QWORD *)*a1 + 552))(*a1, 10, 0.5);
  return (*(uint64_t (**)(_QWORD, uint64_t, float))(*(_QWORD *)*a1 + 552))(*a1, 3, 0.5);
}

float re::PhysXDebugRenderer::setRenderingTransform(uint64_t a1, _OWORD *a2)
{
  float32x4_t v2;
  int32x4_t v3;
  int32x4_t v4;
  float32x4_t v5;
  float32x4_t v6;
  float v7;
  float result;

  v3 = *((int32x4_t *)a2 + 2);
  v2 = *((float32x4_t *)a2 + 3);
  v4 = *((int32x4_t *)a2 + 1);
  *(_OWORD *)(a1 + 16) = *a2;
  *(int32x4_t *)(a1 + 32) = v4;
  *(int32x4_t *)(a1 + 48) = v3;
  *(float32x4_t *)(a1 + 64) = v2;
  v2.i64[0] = *(_QWORD *)(a1 + 16);
  v3.i64[0] = *(_QWORD *)(a1 + 32);
  v4.i64[0] = *(_QWORD *)(a1 + 48);
  v2.i32[2] = *(_DWORD *)(a1 + 24);
  v3.i32[2] = *(_DWORD *)(a1 + 40);
  v4.i32[2] = *(_DWORD *)(a1 + 56);
  v5 = vmulq_f32(v2, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v4, (int8x16_t)v4, 0xCuLL), (int8x16_t)v4, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v3, v3), (int8x16_t)v3, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v4, v4), (int8x16_t)v4, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v3, (int8x16_t)v3, 0xCuLL), (int8x16_t)v3, 8uLL)));
  v6 = vmulq_f32(v2, v2);
  v7 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v6, 2), vaddq_f32(v6, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v6.f32, 1))).f32[0]);
  if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v5, 2), vaddq_f32(v5, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 1))).f32[0] <= 0.0)v7 = -v7;
  result = v7 * 0.1;
  *(float *)(a1 + 112) = result;
  return result;
}

uint64_t re::PhysXDebugRenderer::draw(re::PhysXDebugRenderer *this)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t result;
  unint64_t v14;

  v2 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)this + 584))(*(_QWORD *)this);
  v3 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v2 + 16))(v2))
  {
    v4 = 0;
    v5 = v3 + 12;
    do
    {
      v5 += 16;
      (*(void (**)(float))(*((_QWORD *)this + 11) + 16))(*((float *)this + 28));
      ++v4;
    }
    while (v4 < (*(unsigned int (**)(uint64_t))(*(_QWORD *)v2 + 16))(v2));
  }
  v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v2 + 32))(v2))
  {
    v7 = 0;
    v8 = v6 + 12;
    do
    {
      v8 += 32;
      (*(void (**)(void))(*((_QWORD *)this + 10) + 16))();
      ++v7;
    }
    while (v7 < (*(unsigned int (**)(uint64_t))(*(_QWORD *)v2 + 32))(v2));
  }
  v9 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 56))(v2);
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2))
  {
    v10 = 0;
    v11 = v9 + 24;
    do
    {
      (*(void (**)(void))(*((_QWORD *)this + 10) + 16))();
      (*(void (**)(void))(*((_QWORD *)this + 10) + 16))();
      (*(void (**)(void))(*((_QWORD *)this + 10) + 16))();
      ++v10;
      v11 += 48;
    }
    while (v10 < (*(unsigned int (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2));
  }
  v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 72))(v2);
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 64))(v2);
  if ((_DWORD)result)
  {
    v14 = 0;
    do
    {
      (*(void (**)(void))(*((_QWORD *)this + 12) + 16))();
      ++v14;
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 64))(v2);
      v12 += 32;
    }
    while (v14 < result);
  }
  return result;
}

float32x4_t re::CompoundShape::calculateAABB@<Q0>(_QWORD *a1@<X0>, uint64_t a2@<X1>, float32x4_t *a3@<X8>)
{
  float32x4_t v4;
  float32x4_t v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t result;
  float32x4_t v15;
  float32x4_t v16;
  _OWORD v17[2];
  _QWORD v18[4];

  v4 = (float32x4_t)vdupq_n_s32(0x7F800000u);
  v5.i64[0] = 0x7F0000007FLL;
  v5.i64[1] = 0x7F0000007FLL;
  *a3 = v4;
  a3[1] = v5;
  if (a2)
  {
    v6 = a1;
    v7 = 240 * a2;
    v8 = a1;
    do
    {
      v15 = v5;
      v16 = v4;
      v9 = (*(uint64_t (**)(_QWORD *))(*v6 + 24))(v6);
      v10 = *v8;
      v8 += 30;
      (*(void (**)(_QWORD *__return_ptr, _QWORD *))(v10 + 40))(v18, v6);
      (*(void (**)(_OWORD *__return_ptr, uint64_t, _QWORD *))(*(_QWORD *)v9 + 16))(v17, v9, v18);
      v12 = v15;
      v11 = v16;
      v11.i32[3] = 0;
      result = (float32x4_t)v17[0];
      v13 = (float32x4_t)v17[1];
      result.i32[3] = 0;
      v12.i32[3] = 0;
      v13.i32[3] = 0;
      v4 = vminnmq_f32(v11, result);
      v5 = vmaxnmq_f32(v12, v13);
      *a3 = v4;
      a3[1] = v5;
      v6 = v8;
      v7 -= 240;
    }
    while (v7);
  }
  return result;
}

uint64_t re::CompoundShape::CompoundShape(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __int128 *a5, unint64_t a6, uint64_t a7)
{
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  __int128 v21;
  __int128 v22;
  _DWORD *v23;
  double v24;
  uint64_t v25;
  _DWORD *v26;
  uint64_t v27;
  _QWORD *v28;
  uint64_t v29;
  float32x4_t v30;
  float32x4_t v31;
  _QWORD *v32;
  uint64_t v33;
  uint64_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v42;
  float32x4_t v43;
  _BYTE v44[38];
  _OWORD v45[2];
  __int128 v46;
  __int128 v47;
  __int128 v48;
  uint64_t v49;

  v49 = *MEMORY[0x24BDAC8D0];
  *(_DWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = off_24ED40C48;
  *(_QWORD *)(a1 + 8) = a3;
  *(_QWORD *)(a1 + 32) = a6;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 24) = a2;
  if (a6)
  {
    if (a6 >= 0x111111111111112)
    {
LABEL_26:
      re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 240, a6);
      _os_crash();
      __break(1u);
LABEL_27:
      re::internal::assertLog((re::internal *)4, v14, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
      _os_crash();
      __break(1u);
    }
    v13 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 240 * a6, 16);
    *(_QWORD *)(a1 + 40) = v13;
    if (!v13)
      goto LABEL_27;
    v15 = a6 - 1;
    if (a6 != 1)
    {
      do
      {
        *(_OWORD *)(v13 + 144) = 0uLL;
        *(_OWORD *)(v13 + 160) = 0uLL;
        *(_OWORD *)(v13 + 208) = 0uLL;
        *(_OWORD *)(v13 + 224) = 0uLL;
        *(_OWORD *)(v13 + 176) = 0uLL;
        *(_OWORD *)(v13 + 192) = 0uLL;
        *(_OWORD *)(v13 + 112) = 0uLL;
        *(_OWORD *)(v13 + 64) = 0uLL;
        *(_OWORD *)(v13 + 80) = 0uLL;
        *(_OWORD *)(v13 + 48) = 0uLL;
        *(_OWORD *)v13 = 0uLL;
        *(_OWORD *)(v13 + 16) = 0uLL;
        *(_QWORD *)(v13 + 32) = 0;
        *(_QWORD *)(v13 + 40) = 0x3F80000000000000;
        *(_QWORD *)v13 = &off_24ED40A60;
        *(_QWORD *)(v13 + 96) = 0;
        *(_QWORD *)(v13 + 104) = 0x3F80000000000000;
        *(_QWORD *)(v13 + 128) = 0;
        *(_QWORD *)(v13 + 136) = 0x3F80000000000000;
        *(_QWORD *)(v13 + 144) = 0;
        *(_QWORD *)(v13 + 152) = 0;
        *(_DWORD *)(v13 + 168) = 0;
        *(_QWORD *)(v13 + 160) = 0;
        *(_DWORD *)(v13 + 208) = 0;
        *(_OWORD *)(v13 + 176) = 0uLL;
        *(_OWORD *)(v13 + 192) = 0uLL;
        v13 += 240;
        --v15;
      }
      while (v15);
    }
    *(_OWORD *)(v13 + 144) = 0u;
    *(_OWORD *)(v13 + 160) = 0u;
    *(_OWORD *)(v13 + 208) = 0u;
    *(_OWORD *)(v13 + 224) = 0u;
    *(_OWORD *)(v13 + 176) = 0u;
    *(_OWORD *)(v13 + 192) = 0u;
    *(_OWORD *)(v13 + 112) = 0u;
    *(_OWORD *)(v13 + 64) = 0u;
    *(_OWORD *)(v13 + 80) = 0u;
    *(_OWORD *)(v13 + 48) = 0u;
    *(_OWORD *)v13 = 0u;
    *(_OWORD *)(v13 + 16) = 0u;
    *(_QWORD *)(v13 + 32) = 0;
    *(_QWORD *)(v13 + 40) = 0x3F80000000000000;
    *(_QWORD *)v13 = &off_24ED40A60;
    *(_QWORD *)(v13 + 96) = 0;
    *(_QWORD *)(v13 + 104) = 0x3F80000000000000;
    *(_QWORD *)(v13 + 128) = 0;
    *(_QWORD *)(v13 + 136) = 0x3F80000000000000;
    *(_QWORD *)(v13 + 144) = 0;
    *(_QWORD *)(v13 + 152) = 0;
    *(_DWORD *)(v13 + 168) = 0;
    *(_QWORD *)(v13 + 160) = 0;
    *(_DWORD *)(v13 + 208) = 0;
    *(_OWORD *)(v13 + 176) = 0u;
    *(_OWORD *)(v13 + 192) = 0u;
  }
  *(_QWORD *)(a1 + 56) = a2;
  *(_QWORD *)(a1 + 48) = a2;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 128) = 0;
  *(_DWORD *)(a1 + 136) = 0;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_DWORD *)(a1 + 120) = 0;
  re::DynamicArray<re::Event<re::GeometricObjectBase>::Subscription>::setCapacity((_QWORD *)(a1 + 56), 0);
  ++*(_DWORD *)(a1 + 80);
  if (a6)
  {
    v16 = 0;
    v17 = 232;
    while (1)
    {
      v18 = *(_QWORD *)(a1 + 32);
      if (v18 <= v16)
        break;
      v19 = *(_QWORD *)(a4 + 8 * v16);
      v20 = (_QWORD *)(*(_QWORD *)(a1 + 40) + v17);
      v21 = *a5;
      *(_OWORD *)(v20 - 25) = a5[1];
      *(_OWORD *)(v20 - 27) = v21;
      *(v20 - 21) = v19;
      v22 = *a5;
      *(_OWORD *)(v20 - 13) = a5[1];
      *(_OWORD *)(v20 - 15) = v22;
      *(v20 - 11) = a2;
      re::DynamicArray<re::Event<re::GeometricObjectBase>::Subscription>::setCapacity(v20 - 11, 0);
      ++*((_DWORD *)v20 - 16);
      *v20 = a7;
      v18 = *(_QWORD *)(a1 + 32);
      if (v18 <= v16)
        goto LABEL_23;
      v23 = (_DWORD *)(*(_QWORD *)(a1 + 40) + v17 - 88);
      *(_QWORD *)&v45[0] = a1;
      *(_OWORD *)((char *)v45 + 8) = xmmword_226102640;
      *((_QWORD *)&v45[1] + 1) = re::Event<re::GeometricObjectBase>::createSubscription<re::CompoundShape>(re::CompoundShape *,REEventHandlerResult (re::CompoundShape::*)(re::GeometricObjectBase*))::{lambda(re::GeometricObjectBase*,re::Event<re::GeometricObjectBase>::Subscription const&)#1}::__invoke;
      v24 = re::Event<re::GeometricObjectBase>::addSubscription(v23, (uint64_t)v45);
      v18 = *(_QWORD *)(a1 + 32);
      if (v18 <= v16)
        goto LABEL_24;
      v25 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + v17 - 168);
      if ((*(unsigned int (**)(uint64_t, double))(*(_QWORD *)v25 + 24))(v25, v24) == 7)
      {
        v18 = *(_QWORD *)(a1 + 32);
        if (v18 <= v16)
          goto LABEL_25;
        v26 = (_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + v17 - 168) + 56);
        *(_QWORD *)&v45[0] = a1;
        *(_OWORD *)((char *)v45 + 8) = xmmword_226102640;
        *((_QWORD *)&v45[1] + 1) = re::Event<re::GeometricObjectBase>::createSubscription<re::CompoundShape>(re::CompoundShape *,REEventHandlerResult (re::CompoundShape::*)(re::GeometricObjectBase*))::{lambda(re::GeometricObjectBase*,re::Event<re::GeometricObjectBase>::Subscription const&)#1}::__invoke;
        re::Event<re::GeometricObjectBase>::addSubscription(v26, (uint64_t)v45);
      }
      ++v16;
      v17 += 240;
      a5 += 2;
      if (a6 == v16)
        goto LABEL_16;
    }
    v47 = 0u;
    v48 = 0u;
    v46 = 0u;
    memset(v45, 0, sizeof(v45));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v44 = 136315906;
    *(_QWORD *)&v44[4] = "operator[]";
    *(_WORD *)&v44[12] = 1024;
    *(_DWORD *)&v44[14] = 468;
    *(_WORD *)&v44[18] = 2048;
    *(_QWORD *)&v44[20] = v16;
    *(_WORD *)&v44[28] = 2048;
    *(_QWORD *)&v44[30] = v18;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_23:
    v47 = 0u;
    v48 = 0u;
    v46 = 0u;
    memset(v45, 0, sizeof(v45));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v44 = 136315906;
    *(_QWORD *)&v44[4] = "operator[]";
    *(_WORD *)&v44[12] = 1024;
    *(_DWORD *)&v44[14] = 468;
    *(_WORD *)&v44[18] = 2048;
    *(_QWORD *)&v44[20] = v16;
    *(_WORD *)&v44[28] = 2048;
    *(_QWORD *)&v44[30] = v18;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_24:
    v47 = 0u;
    v48 = 0u;
    v46 = 0u;
    memset(v45, 0, sizeof(v45));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v44 = 136315906;
    *(_QWORD *)&v44[4] = "operator[]";
    *(_WORD *)&v44[12] = 1024;
    *(_DWORD *)&v44[14] = 468;
    *(_WORD *)&v44[18] = 2048;
    *(_QWORD *)&v44[20] = v16;
    *(_WORD *)&v44[28] = 2048;
    *(_QWORD *)&v44[30] = v18;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_25:
    v47 = 0u;
    v48 = 0u;
    v46 = 0u;
    memset(v45, 0, sizeof(v45));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v44 = 136315906;
    *(_QWORD *)&v44[4] = "operator[]";
    *(_WORD *)&v44[12] = 1024;
    *(_DWORD *)&v44[14] = 468;
    *(_WORD *)&v44[18] = 2048;
    *(_QWORD *)&v44[20] = v16;
    *(_WORD *)&v44[28] = 2048;
    *(_QWORD *)&v44[30] = v18;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_26;
  }
LABEL_16:
  v27 = *(_QWORD *)(a1 + 32);
  if (v27)
  {
    v28 = *(_QWORD **)(a1 + 40);
    v29 = 240 * v27;
    v30 = (float32x4_t)vdupq_n_s32(0x7F800000u);
    v31.i64[0] = 0x7F0000007FLL;
    v31.i64[1] = 0x7F0000007FLL;
    v32 = v28;
    do
    {
      v42 = v31;
      v43 = v30;
      v33 = (*(uint64_t (**)(_QWORD *))(*v28 + 24))(v28);
      v34 = *v32;
      v32 += 30;
      (*(void (**)(_OWORD *__return_ptr, _QWORD *))(v34 + 40))(v45, v28);
      (*(void (**)(_BYTE *__return_ptr, uint64_t, _OWORD *))(*(_QWORD *)v33 + 16))(v44, v33, v45);
      v36 = v42;
      v35 = v43;
      v35.i32[3] = 0;
      v37 = *(float32x4_t *)v44;
      v38 = *(float32x4_t *)&v44[16];
      v37.i32[3] = 0;
      v36.i32[3] = 0;
      v30 = vminnmq_f32(v35, v37);
      v38.i32[3] = 0;
      v31 = vmaxnmq_f32(v36, v38);
      v28 = v32;
      v29 -= 240;
    }
    while (v29);
    v39 = vsubq_f32(v31, v30);
  }
  else
  {
    v39.i64[0] = 0x7F0000007FLL;
    v39.i32[2] = 127;
  }
  v39.i32[3] = 0;
  v40 = vmaxnmq_f32(v39, (float32x4_t)0);
  *(float *)(a1 + 16) = fminf(fminf(v40.f32[0], v40.f32[2]), v40.f32[1]);
  return a1;
}

void re::CompoundShape::~CompoundShape(re::CompoundShape *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  re::CompoundShape *v6;
  __int128 v7;
  uint64_t (*v8)(uint64_t, _QWORD *);
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)this = off_24ED40C48;
  v2 = *((_QWORD *)this + 4);
  if (v2)
  {
    v3 = 240 * v2;
    v4 = *((_QWORD *)this + 5) + 144;
    do
    {
      v6 = this;
      v7 = xmmword_226102640;
      v8 = re::Event<re::GeometricObjectBase>::createSubscription<re::CompoundShape>(re::CompoundShape *,REEventHandlerResult (re::CompoundShape::*)(re::GeometricObjectBase*))::{lambda(re::GeometricObjectBase*,re::Event<re::GeometricObjectBase>::Subscription const&)#1}::__invoke;
      re::Event<re::GeometricObjectBase>::removeSubscription(v4, (__int128 *)&v6);
      if ((*(unsigned int (**)(_QWORD))(**(_QWORD **)(v4 - 80) + 24))(*(_QWORD *)(v4 - 80)) == 7)
      {
        v5 = *(_QWORD *)(v4 - 80) + 56;
        v6 = this;
        v7 = xmmword_226102640;
        v8 = re::Event<re::GeometricObjectBase>::createSubscription<re::CompoundShape>(re::CompoundShape *,REEventHandlerResult (re::CompoundShape::*)(re::GeometricObjectBase*))::{lambda(re::GeometricObjectBase*,re::Event<re::GeometricObjectBase>::Subscription const&)#1}::__invoke;
        re::Event<re::GeometricObjectBase>::removeSubscription(v5, (__int128 *)&v6);
      }
      v4 += 240;
      v3 -= 240;
    }
    while (v3);
  }
  re::Event<re::Engine>::~Event((uint64_t *)this + 7);
  re::FixedArray<re::GeometricObject>::deinit((_QWORD *)this + 3);
}

uint64_t re::CompoundShape::onChildPoseDidChange(re::CompoundShape *this, re::GeometricObjectBase *a2)
{
  re::Event<re::GeometricObjectBase>::raise((uint64_t)this + 56, (uint64_t)a2);
  return 0;
}

uint64_t re::CompoundShape::isStaticShape(re::CompoundShape *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t result;
  BOOL v6;

  v1 = *((_QWORD *)this + 4);
  if (!v1)
    return 1;
  v2 = 240 * v1 - 240;
  v3 = (uint64_t *)(*((_QWORD *)this + 5) + 64);
  do
  {
    v4 = *v3;
    v3 += 30;
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 56))(v4);
    if ((_DWORD)result)
      v6 = v2 == 0;
    else
      v6 = 1;
    v2 -= 240;
  }
  while (!v6);
  return result;
}

double re::CompoundShape::massProperties(uint64_t a1, _DWORD *a2, _OWORD *a3, _OWORD *a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  char *v12;
  uint64_t v13;
  char *v14;
  unint64_t v15;
  uint64_t v16;
  _DWORD *v17;
  char *v18;
  uint64_t v19;
  __int128 v20;
  uint64_t v21;
  int v22;
  __int128 v23;
  unint64_t v24;
  int v25;
  uint64_t v26;
  double result;
  __int128 v28;
  __int128 v29;
  uint64_t v30;
  _DWORD *v31;
  _OWORD *v32;
  _OWORD *v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  int v38;
  uint64_t v39;
  char v40;
  int v41;
  const char *v42;
  __int16 v43;
  int v44;
  __int16 v45;
  unint64_t v46;
  __int16 v47;
  unint64_t v48;
  _OWORD v49[5];
  uint64_t v50;

  v50 = *MEMORY[0x24BDAC8D0];
  v8 = MEMORY[0x24BDAC7A8](a1);
  v11 = (char *)&v30 - v10;
  if (v9)
  {
    v31 = a2;
    v32 = a3;
    v33 = a4;
    v12 = (char *)&v30 - v10;
    do
    {
      *(_OWORD *)v12 = xmmword_2260E5F10;
      *((_OWORD *)v12 + 1) = xmmword_2260E5F10;
      *((_OWORD *)v12 + 2) = xmmword_2260E5F10;
      *((_DWORD *)v12 + 12) = 1065353216;
      v12 += 52;
    }
    while (v12 != &v11[52 * v9]);
    MEMORY[0x24BDAC7A8](v8);
    v14 = (char *)&v30 - v13;
    v15 = 0;
    v16 = *(_QWORD *)(a1 + 40);
    v17 = v14 + 24;
    v18 = v11 + 24;
    v19 = 128;
    do
    {
      v38 = 0;
      v37 = 0u;
      v36 = 0u;
      v35 = 0u;
      v34 = 0u;
      (*(void (**)(_QWORD, int *, __int128 *, __int128 *))(**(_QWORD **)(v16 + v19 - 64) + 32))(*(_QWORD *)(v16 + v19 - 64), &v38, &v37, &v34);
      *(_QWORD *)&v20 = *(_QWORD *)((char *)&v34 + 4);
      v21 = v35;
      v22 = DWORD2(v35);
      *(_QWORD *)&v23 = v36;
      *((_DWORD *)v18 - 6) = v34;
      *((_QWORD *)&v20 + 1) = v21;
      *(_OWORD *)(v18 - 20) = v20;
      *((_DWORD *)v18 - 1) = v22;
      *((_QWORD *)&v23 + 1) = __PAIR64__(v37, DWORD2(v36));
      *(_OWORD *)v18 = v23;
      *((_QWORD *)v18 + 2) = *(_QWORD *)((char *)&v37 + 4);
      *((_DWORD *)v18 + 6) = v38;
      v24 = *(_QWORD *)(a1 + 32);
      if (v24 <= v15)
      {
        v39 = 0;
        memset(v49, 0, sizeof(v49));
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        v41 = 136315906;
        v42 = "operator[]";
        v43 = 1024;
        v44 = 476;
        v45 = 2048;
        v46 = v15;
        v47 = 2048;
        v48 = v24;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      v16 = *(_QWORD *)(a1 + 40);
      v25 = *(_DWORD *)(v16 + v19 - 8);
      v26 = *(_QWORD *)(v16 + v19 - 16);
      *(_OWORD *)(v17 - 6) = *(_OWORD *)(v16 + v19);
      ++v15;
      *((_QWORD *)v17 - 1) = v26;
      *v17 = v25;
      v17 += 7;
      v19 += 240;
      v18 += 52;
    }
    while (v15 < v24);
    a4 = v33;
    a3 = v32;
    a2 = v31;
  }
  else
  {
    LODWORD(v24) = 0;
    v14 = &v40;
  }
  physx::PxMassProperties::sum((uint64_t)v11, (uint64_t)v14, v24, (float *)v49);
  *a2 = v49[3];
  *a3 = *(_OWORD *)((char *)&v49[2] + 4);
  result = *(double *)v49;
  v28 = *(_OWORD *)((char *)v49 + 12);
  v29 = *(_OWORD *)((char *)&v49[1] + 8);
  *a4 = v49[0];
  a4[1] = v28;
  a4[2] = v29;
  return result;
}

uint64_t physx::PxMassProperties::sum@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, unsigned int a3@<W2>, float *a4@<X8>)
{
  uint64_t v4;
  float *v5;
  float *v6;
  float v7;
  uint64_t v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float *v25;
  float *v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;
  float v60;
  float v61;
  float v62;
  float v63;
  float v64;
  float v65;
  float v66;
  float v67;
  float v68;
  float v69;
  float v70;
  float v71;
  float v72;
  float v73;
  float v74;
  float v75;
  float v76;
  float v77;
  float v78;
  float v79;
  float v80;
  float v81;
  float v82;
  float v83;
  float v84;
  float v85;
  float v86;
  float v87;
  float v88;
  float v89;
  float v90;
  float v91;
  float v92;
  float v93;
  float v94;
  float v95;
  float v96;
  float v97;
  float v98;
  float v99;
  float v100;
  float v101;
  float v102;
  float v103;
  float v104;
  float v105;
  float v106;
  float v107;
  float v108;
  float v109;
  float v110;
  float v111;
  float v112;
  float v113;
  float v114;
  float v115;
  float v116;
  float v117;
  float v118;
  float v119;
  float v120;
  float v121;
  float v122;
  float v123;
  float v124;
  float v125;
  float v126;
  float v127;
  float v128;
  float v129;
  float v130;
  float v131;
  float v132;
  float v133;
  float v134;
  float v135;
  float v136;
  float v137;
  float v138;
  float v139;
  float v140;
  float v141;
  float v142;
  float v143;
  float v144;
  float v145;
  float v146;
  float v147;
  float v148;
  float v149;
  float v150;

  if (a3)
  {
    v4 = a3;
    v5 = (float *)(a2 + 12);
    v6 = (float *)(result + 48);
    v7 = 0.0;
    v8 = a3;
    v9 = 0.0;
    v10 = 0.0;
    v11 = 0.0;
    do
    {
      v12 = *(v6 - 3) + *(v6 - 3);
      v13 = *(v6 - 2) + *(v6 - 2);
      v14 = *(v6 - 1) + *(v6 - 1);
      v15 = *(v5 - 3);
      v16 = *(v5 - 2);
      v17 = (float)(*v5 * *v5) + -0.5;
      v18 = *(v5 - 1);
      v19 = (float)((float)(v13 * v16) + (float)(v15 * v12)) + (float)(v18 * v14);
      v20 = *v6;
      v6 += 13;
      v7 = v7 + v20;
      v11 = v11
          + (float)(v20
                  * (float)(v5[1]
                          + (float)((float)((float)(*v5 * (float)((float)(v16 * v14) - (float)(v18 * v13)))
                                          + (float)(v12 * v17))
                                  + (float)(v15 * v19))));
      v10 = v10
          + (float)(v20
                  * (float)(v5[2]
                          + (float)((float)((float)(*v5 * (float)((float)(v18 * v12) - (float)(v15 * v14)))
                                          + (float)(v13 * v17))
                                  + (float)(v16 * v19))));
      v9 = v9
         + (float)(v20
                 * (float)(v5[3]
                         + (float)((float)((float)(*v5 * (float)((float)(v15 * v13) - (float)(v16 * v12)))
                                         + (float)(v14 * v17))
                                 + (float)(v18 * v19))));
      v5 += 7;
      --v8;
    }
    while (v8);
    v21 = 1.0;
    if (v7 <= 0.0)
      v22 = v11;
    else
      v22 = (float)(1.0 / v7) * v11;
    if (v7 <= 0.0)
      v23 = v10;
    else
      v23 = (float)(1.0 / v7) * v10;
    if (v7 <= 0.0)
      v24 = v9;
    else
      v24 = (float)(1.0 / v7) * v9;
    v25 = (float *)(result + 24);
    v26 = (float *)(a2 + 12);
    v27 = 0.0;
    v28 = 0.0;
    v29 = 0.0;
    v30 = 0.0;
    v31 = 0.0;
    v32 = 0.0;
    v33 = 0.0;
    v34 = 0.0;
    v35 = 0.0;
    v147 = v24;
    v145 = v7;
    v146 = v23;
    do
    {
      v148 = v31;
      v149 = v34;
      v150 = v35;
      v36 = v25[2];
      v37 = v25[3] + v25[3];
      v38 = v25[4] + v25[4];
      v39 = v25[5] + v25[5];
      v40 = v22;
      v41 = (float)(*v26 * *v26) + -0.5;
      v42 = *(v26 - 3);
      v43 = *(v26 - 2);
      v44 = *(v26 - 1);
      v45 = (float)((float)(v38 * v43) + (float)(v42 * v37)) + (float)(v44 * v39);
      v46 = (float)(*v26 * (float)((float)(v43 * v39) - (float)(v44 * v38))) + (float)(v37 * v41);
      v47 = *v26 * (float)((float)(v44 * v37) - (float)(v42 * v39));
      v48 = *v26 * (float)((float)(v42 * v38) - (float)(v43 * v37));
      v49 = v47 + (float)(v38 * v41);
      v50 = v48 + (float)(v39 * v41);
      v51 = v42 + v42;
      v52 = v43 + v43;
      v53 = v42 * (float)(v42 + v42);
      v54 = v46 + (float)(v42 * v45);
      v55 = v43 * (float)(v43 + v43);
      v56 = v44 * (float)(v44 + v44);
      v57 = v51 * v43;
      v58 = v51 * v44;
      v59 = *v26 * v51;
      v60 = v49 + (float)(v43 * v45);
      v61 = (float)(v43 + v43) * v44;
      v62 = *v26 * v52;
      v63 = *v26 * (float)(v44 + v44);
      v64 = (float)(v21 - v55) - v56;
      v65 = v50 + (float)(v44 * v45);
      v66 = v57 + v63;
      v67 = v58 - v62;
      v68 = v57 - v63;
      v69 = (float)(v21 - v53) - v56;
      v70 = v59 + v61;
      v71 = v58 + v62;
      v72 = v61 - v59;
      v74 = *(v25 - 6);
      v73 = *(v25 - 5);
      v75 = (float)(v21 - v53) - v55;
      v76 = v66 * v74;
      v77 = v69 * v73;
      v78 = (float)(v64 * v74) + (float)(v68 * v73);
      v79 = (float)(v67 * v74) + (float)(v70 * v73);
      v80 = *(v25 - 4);
      v81 = *(v25 - 3);
      v82 = v76 + v77;
      v83 = v78 + (float)(v71 * v80);
      v84 = v79 + (float)(v75 * v80);
      v85 = v82 + (float)(v72 * v80);
      v86 = v64 * v81;
      v87 = v66 * v81;
      v88 = v67 * v81;
      v89 = v33;
      v91 = *(v25 - 2);
      v90 = *(v25 - 1);
      v92 = v26[1] + v54;
      v93 = v87 + (float)(v69 * v91);
      v94 = (float)(v88 + (float)(v70 * v91)) + (float)(v75 * v90);
      v95 = v26[3] + v65;
      v96 = v25[1];
      v97 = (float)(v86 + (float)(v68 * v91)) + (float)(v71 * v90);
      v98 = (float)(v66 * *v25) + (float)(v69 * v96);
      v99 = v93 + (float)(v72 * v90);
      v100 = (float)(v67 * *v25) + (float)(v70 * v96);
      v101 = (float)((float)(v64 * *v25) + (float)(v68 * v96)) + (float)(v71 * v36);
      v102 = v98 + (float)(v72 * v36);
      v103 = v100 + (float)(v75 * v36);
      v104 = (float)(v64 * v85) + (float)(v68 * v99);
      v105 = (float)((float)(v64 * v83) + (float)(v68 * v97)) + (float)(v71 * v101);
      v106 = (float)((float)(v64 * v84) + (float)(v68 * v94)) + (float)(v71 * v103);
      v107 = v104 + (float)(v71 * v102);
      v108 = (float)((float)(v66 * v83) + (float)(v69 * v97)) + (float)(v72 * v101);
      v109 = (float)((float)(v66 * v85) + (float)(v69 * v99)) + (float)(v72 * v102);
      v110 = (float)((float)(v66 * v84) + (float)(v69 * v94)) + (float)(v72 * v103);
      v111 = v70 * v97;
      v112 = v70 * v99;
      v113 = v70 * v94;
      v22 = v40;
      v114 = (float)(v67 * v83) + v111;
      v115 = (float)(v67 * v85) + v112;
      v116 = v75 * v101;
      v117 = v75 * v102;
      v118 = v75 * v103;
      v119 = v147;
      v120 = v114 + v116;
      v121 = v115 + v117;
      v122 = (float)((float)(v67 * v84) + v113) + v118;
      v123 = v40 - v92;
      v124 = v146;
      v125 = v146 - (float)(v26[2] + v60);
      v126 = v147 - v95;
      v127 = v125 * 0.0;
      v128 = v126 * v126;
      v129 = (float)((float)(v126 * 0.0) - (float)(v126 * 0.0)) - (float)(v125 * v123);
      v130 = (float)(v125 * 0.0) - (float)(v126 * v123);
      v131 = v126 * v125;
      v132 = v125 * v125;
      v133 = v130 - v127;
      v134 = v123 * v123;
      v135 = (float)(v123 * 0.0) + (float)((float)(v123 * -0.0) - v131);
      v136 = v128 + v132;
      v137 = v128 + v134;
      v138 = v132 + v134;
      v139 = v25[6];
      v140 = v129 * v139;
      v141 = v133 * v139;
      v142 = v135 * v139;
      v27 = v27 + (float)((float)(v136 * v139) + v105);
      v143 = v89;
      v21 = 1.0;
      v28 = v28 + (float)(v140 + v107);
      v29 = v29 + (float)(v141 + v106);
      v30 = v30 + (float)(v140 + v108);
      v31 = v148 + (float)((float)(v137 * v139) + v109);
      v32 = v32 + (float)(v142 + v110);
      v33 = v143 + (float)(v141 + v120);
      v34 = v149 + (float)(v142 + v121);
      v35 = v150 + (float)((float)(v138 * v139) + v122);
      v25 += 13;
      v26 += 7;
      --v4;
    }
    while (v4);
    v144 = v145;
  }
  else
  {
    v119 = 0.0;
    v124 = 0.0;
    v22 = 0.0;
    v144 = 0.0;
    v35 = 0.0;
    v34 = 0.0;
    v33 = 0.0;
    v32 = 0.0;
    v31 = 0.0;
    v30 = 0.0;
    v29 = 0.0;
    v28 = 0.0;
    v27 = 0.0;
  }
  *a4 = v27;
  a4[1] = v28;
  a4[2] = v29;
  a4[3] = v30;
  a4[4] = v31;
  a4[5] = v32;
  a4[6] = v33;
  a4[7] = v34;
  a4[8] = v35;
  a4[9] = v22;
  a4[10] = v124;
  a4[11] = v119;
  a4[12] = v144;
  return result;
}

uint64_t re::CompoundShape::type(re::CompoundShape *this)
{
  return 7;
}

_QWORD *re::FixedArray<re::GeometricObject>::deinit(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  _QWORD *v3;
  uint64_t *v4;
  uint64_t v5;

  if (*result)
  {
    v1 = result;
    v3 = result + 1;
    v2 = result[1];
    if (v2)
    {
      v4 = (uint64_t *)result[2];
      v5 = 240 * v2;
      do
      {
        re::GeometricObject::deinit((re::GeometricObject *)v4);
        re::Event<re::Engine>::~Event(v4 + 18);
        v4 += 30;
        v5 -= 240;
      }
      while (v5);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v1 + 40))(*v1, v1[2]);
      *v3 = 0;
      v3[1] = 0;
    }
    *v1 = 0;
  }
  return result;
}

double re::Event<re::GeometricObjectBase>::addSubscription(_DWORD *a1, uint64_t a2)
{
  double result;
  __int128 v5;
  char v6[8];
  __int128 v7;
  __int128 v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  re::DynamicArray<re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription>::indexOf((uint64_t)a1, (_QWORD *)a2, (uint64_t)v6);
  if (!v6[0])
  {
    if (a1[20])
    {
      v6[0] = 1;
      v5 = *(_OWORD *)(a2 + 16);
      v7 = *(_OWORD *)a2;
      v8 = v5;
      *(_QWORD *)&result = re::DynamicArray<re::Pair<BOOL,re::Event<re::NetworkSystem,re::ecs2::Component *>::Subscription,true>>::add((_anonymous_namespace_ *)(a1 + 10), (uint64_t)v6).n128_u64[0];
    }
    else
    {
      *(_QWORD *)&result = re::DynamicArray<re::Event<re::GeometricObjectBase>::Subscription>::add((_anonymous_namespace_ *)a1, a2).n128_u64[0];
    }
  }
  return result;
}

uint64_t re::Event<re::GeometricObjectBase>::createSubscription<re::CompoundShape>(re::CompoundShape *,REEventHandlerResult (re::CompoundShape::*)(re::GeometricObjectBase*))::{lambda(re::GeometricObjectBase*,re::Event<re::GeometricObjectBase>::Subscription const&)#1}::__invoke(uint64_t a1, _QWORD *a2)
{
  uint64_t (*v3)(_QWORD *, uint64_t);
  uint64_t v4;
  _QWORD *v5;

  v3 = (uint64_t (*)(_QWORD *, uint64_t))a2[1];
  v4 = a2[2];
  v5 = (_QWORD *)(*a2 + (v4 >> 1));
  if ((v4 & 1) != 0)
    v3 = *(uint64_t (**)(_QWORD *, uint64_t))(*v5 + v3);
  return v3(v5, a1);
}

void re::Event<re::GeometricObjectBase>::removeSubscription(uint64_t a1, __int128 *a2)
{
  __int128 v4;
  _BYTE v5[8];
  __int128 v6;
  __int128 v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  re::DynamicArray<re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription>::indexOf(a1, a2, (uint64_t)v5);
  if (v5[0])
  {
    if (*(_DWORD *)(a1 + 80))
    {
      v5[0] = 0;
      v4 = a2[1];
      v6 = *a2;
      v7 = v4;
      re::DynamicArray<re::Pair<BOOL,re::Event<re::NetworkSystem,re::ecs2::Component *>::Subscription,true>>::add((_anonymous_namespace_ *)(a1 + 40), (uint64_t)v5);
    }
    else
    {
      re::DynamicArray<re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription>::removeStable((_QWORD *)a1, a2);
    }
  }
}

float re::PhysXConeShape::height(re::PhysXConeShape *this)
{
  return *((float *)this + 8);
}

float re::PhysXConeShape::radius(re::PhysXConeShape *this)
{
  return *((float *)this + 7);
}

double re::PhysXConeShape::aabb@<D0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X4>, uint64_t a4@<X5>, uint64_t a5@<X6>, uint64_t a6@<X7>, _OWORD *a7@<X8>, int8x16_t a8@<Q1>, double a9@<D2>, double a10@<D3>, double a11@<D4>, double a12@<D5>, double a13@<D6>, int32x4_t a14@<Q7>)
{
  float32x4_t v15;
  double result;
  __int128 v17;
  __int128 v18;
  uint64_t v19;
  int v20;
  _BYTE v21[20];
  int v22;

  v18 = *((_OWORD *)a2 + 1);
  v15.i64[1] = *((_QWORD *)&v18 + 1);
  v19 = *a2;
  v15.i32[1] = HIDWORD(v19);
  v20 = *((_DWORD *)a2 + 2);
  v15.i32[0] = 0;
  a8.i32[0] = 1.0;
  physx::Gu::computeBounds((float32x2_t *)v21, a1 + 24, (uint64_t)&v18, 0, v15, a8, a9, a10, a11, a12, a13, a14, a3, a4, a5, a6, v18);
  result = *(double *)v21;
  *(_QWORD *)&v17 = *(_QWORD *)&v21[12];
  DWORD2(v17) = v22;
  *a7 = *(_OWORD *)v21;
  a7[1] = v17;
  return result;
}

void re::PhysXConeShape::~PhysXConeShape(re::PhysXConeShape *this)
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::ConeShape::type(re::ConeShape *this)
{
  return 9;
}

float re::CapsuleShape::massProperties(uint64_t a1, _DWORD *a2, _QWORD *a3, uint64_t a4)
{
  float32x4_t v7;
  float32x4_t v8;
  float32x4_t v9;
  float result;
  _QWORD v11[4];
  float32x4_t v12[2];

  memset(v11, 0, 24);
  v11[3] = 0x3F80000000000000;
  (*(void (**)(float32x4_t *__return_ptr, uint64_t, _QWORD *))(*(_QWORD *)a1 + 16))(v12, a1, v11);
  v7 = vsubq_f32(v12[1], v12[0]);
  v7.i32[3] = 0;
  v8 = vmaxnmq_f32(v7, (float32x4_t)0);
  v9 = vmulq_f32(v8, v8);
  v8.f32[0] = vmulq_laneq_f32(vmulq_lane_f32(v8, *(float32x2_t *)v8.f32, 1), v8, 2).f32[0];
  *a2 = v8.i32[0];
  v8.f32[0] = v8.f32[0] / 12.0;
  *(_QWORD *)(a4 + 12) = 0;
  *(_QWORD *)(a4 + 4) = 0;
  *(_QWORD *)(a4 + 24) = 0;
  *(_QWORD *)(a4 + 32) = 0;
  *(float *)a4 = (float)(v9.f32[1] + v9.f32[2]) * v8.f32[0];
  *(float *)(a4 + 20) = (float)(v9.f32[0] + v9.f32[2]) * v8.f32[0];
  result = vaddv_f32(*(float32x2_t *)v9.f32) * v8.f32[0];
  *(float *)(a4 + 40) = result;
  *(_DWORD *)(a4 + 44) = 0;
  *a3 = 0;
  a3[1] = 0;
  return result;
}

uint64_t re::PhysXIndexedTriangleMesh::PhysXIndexedTriangleMesh(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char v8;
  uint64_t v10;

  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 56))(a2);
  v5 = (*(unsigned int (**)(uint64_t))(*(_QWORD *)a2 + 48))(a2);
  v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 88))(a2);
  v7 = 3 * (*(unsigned int (**)(uint64_t))(*(_QWORD *)a2 + 80))(a2);
  (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(_QWORD *)a2 + 96))(&v10, a2);
  if ((v10 & 2) != 0)
    v8 = 1;
  else
    v8 = 2;
  *(_QWORD *)(a1 + 32) = 12;
  *(_QWORD *)(a1 + 40) = v7;
  *(_QWORD *)(a1 + 48) = 0;
  *(_WORD *)(a1 + 56) = 0;
  *(_BYTE *)(a1 + 58) = v8;
  *(_QWORD *)(a1 + 16) = v6;
  *(_QWORD *)(a1 + 24) = v5;
  *(_QWORD *)a1 = off_24ED40D50;
  *(_QWORD *)(a1 + 8) = v4;
  *(_QWORD *)(a1 + 64) = a2;
  return a1;
}

uint64_t re::PhysXIndexedTriangleMesh::materialIndexForTriangle(re::PhysXIndexedTriangleMesh *this, uint64_t a2)
{
  uint64_t v3;

  v3 = *(unsigned int *)((*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 8) + 104))(*((_QWORD *)this + 8))
                       + 4 * a2);
  return (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)this + 8) + 112))(*((_QWORD *)this + 8), v3);
}

void re::PhysXIndexedTriangleMesh::~PhysXIndexedTriangleMesh(re::PhysXIndexedTriangleMesh *this)
{
  void (***v2)(_QWORD);

  *(_QWORD *)this = off_24ED40D50;
  v2 = (void (***)(_QWORD))*((_QWORD *)this + 8);
  if (v2)
    (**v2)(v2);
  *(_QWORD *)this = off_24ED40E30;
  if (*((_QWORD *)this + 1))
  {
    if ((*((_WORD *)this + 28) & 1) != 0)
      re::IndexedTriangleMesh::freeData(this);
  }
}

{
  void (***v2)(_QWORD);

  *(_QWORD *)this = off_24ED40D50;
  v2 = (void (***)(_QWORD))*((_QWORD *)this + 8);
  if (v2)
    (**v2)(v2);
  *(_QWORD *)this = off_24ED40E30;
  if (*((_QWORD *)this + 1))
  {
    if ((*((_WORD *)this + 28) & 1) != 0)
      re::IndexedTriangleMesh::freeData(this);
  }
  JUMPOUT(0x2276933B8);
}

uint64_t re::PhysXConvexPolyhedronShape::PhysXConvexPolyhedronShape(uint64_t a1, uint64_t a2)
{
  float v4;
  float v5;
  uint64_t v7;
  float v8;
  float v9;
  float v10;
  float v11;

  *(_QWORD *)a1 = &off_24ED40D90;
  if (a2)
  {
    (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(_QWORD *)a2 + 112))(&v7, a2);
    v4 = v9 - *(float *)&v7;
    v5 = v10 - *((float *)&v7 + 1);
    if ((float)(v10 - *((float *)&v7 + 1)) >= (float)(v11 - v8))
      v5 = v11 - v8;
    if (v4 >= v5)
      v4 = v5;
  }
  else
  {
    v4 = 0.0;
  }
  *(float *)(a1 + 16) = v4;
  *(_QWORD *)a1 = &off_24ED40D90;
  *(_QWORD *)(a1 + 8) = a1 + 24;
  *(_DWORD *)(a1 + 24) = 4;
  *(_OWORD *)(a1 + 28) = xmmword_2260EDC60;
  *(_DWORD *)(a1 + 44) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 52) = 1065353216;
  *(_QWORD *)(a1 + 56) = a2;
  *(_BYTE *)(a1 + 64) = 1;
  *(_WORD *)(a1 + 65) = 0;
  *(_BYTE *)(a1 + 67) = 0;
  return a1;
}

void re::PhysXConvexPolyhedronShape::aabb(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X4>, uint64_t a4@<X5>, uint64_t a5@<X6>, uint64_t a6@<X7>, int32x4_t *a7@<X8>, int8x16_t a8@<Q1>, double a9@<D2>, double a10@<D3>, double a11@<D4>, double a12@<D5>, double a13@<D6>, int32x4_t a14@<Q7>)
{
  float32x4_t v15;
  int32x4_t v16;
  int32x4_t v17;
  __int128 v18;
  uint64_t v19;
  int v20;
  _BYTE v21[20];
  __int32 v22;

  if (*(_QWORD *)(a1 + 56))
  {
    v18 = *((_OWORD *)a2 + 1);
    v15.i64[1] = *((_QWORD *)&v18 + 1);
    v19 = *a2;
    v15.i32[1] = HIDWORD(v19);
    v20 = *((_DWORD *)a2 + 2);
    v15.i32[0] = 0;
    a8.i32[0] = 1.0;
    physx::Gu::computeBounds((float32x2_t *)v21, a1 + 24, (uint64_t)&v18, 0, v15, a8, a9, a10, a11, a12, a13, a14, a3, a4, a5, a6, v18);
    v16 = *(int32x4_t *)v21;
    v17.i64[0] = *(_QWORD *)&v21[12];
    v17.i32[2] = v22;
  }
  else
  {
    v16 = vdupq_n_s32(0x7F800000u);
    v17.i64[0] = 0x7F0000007FLL;
    v17.i64[1] = 0x7F0000007FLL;
  }
  *a7 = v16;
  a7[1] = v17;
}

double re::PhysXConvexPolyhedronShape::massProperties(uint64_t a1, _DWORD *a2, uint64_t a3, _OWORD *a4)
{
  __int128 v7;
  __int128 v8;
  double result;
  _BYTE v10[52];

  if (*(_QWORD *)(a1 + 56))
  {
    physx::PxMassProperties::PxMassProperties((uint64_t)v10, a1 + 24);
    *a2 = *(_DWORD *)&v10[48];
    v7 = *(_OWORD *)&v10[12];
    v8 = *(_OWORD *)&v10[24];
    *a4 = *(_OWORD *)v10;
    a4[1] = v7;
    a4[2] = v8;
    result = *(double *)&v10[36];
    *(_OWORD *)a3 = *(_OWORD *)&v10[36];
  }
  else
  {
    result = 0.0;
    a4[1] = 0u;
    a4[2] = 0u;
    *a4 = 0u;
    *(_QWORD *)a3 = 0;
    *(_QWORD *)(a3 + 8) = 0;
    *a2 = 897988541;
  }
  return result;
}

uint64_t re::PhysXConvexPolyhedronShape::vertices(re::PhysXConvexPolyhedronShape *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 7);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 56))(result);
  return result;
}

uint64_t re::PhysXConvexPolyhedronShape::vertexStride(re::PhysXConvexPolyhedronShape *this)
{
  if (*((_QWORD *)this + 7))
    return 12;
  else
    return 0;
}

uint64_t re::PhysXConvexPolyhedronShape::vertexCount(re::PhysXConvexPolyhedronShape *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 7);
  if (result)
    return (*(unsigned int (**)(uint64_t))(*(_QWORD *)result + 48))(result);
  return result;
}

unint64_t re::PhysXConvexPolyhedronShape::dumpTriangles(re::PhysXConvexPolyhedronShape *this, unsigned __int16 *a2, unint64_t a3)
{
  uint64_t v4;
  int v7;
  uint64_t v8;
  int v9;
  unint64_t v10;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  unsigned __int8 *v19;
  uint64_t v20;
  unsigned __int16 v21;
  _BYTE v22[16];
  unsigned __int16 v23;
  unsigned __int16 v24;

  v4 = *((_QWORD *)this + 7);
  if (!v4)
    return 0;
  v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 72))(v4);
  if (v7)
  {
    v8 = 0;
    v9 = 0;
    do
    {
      (*(void (**)(_QWORD, uint64_t, _BYTE *))(**((_QWORD **)this + 7) + 80))(*((_QWORD *)this + 7), v8, v22);
      v9 = v9 + v23 - 2;
      v8 = (v8 + 1);
    }
    while (v7 != (_DWORD)v8);
    v10 = (3 * v9);
    if (!a2)
      return v10;
  }
  else
  {
    v10 = 0;
    if (!a2)
      return v10;
  }
  if (v10 > a3)
    return 0;
  v12 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 7) + 64))(*((_QWORD *)this + 7));
  if (v7)
  {
    v13 = v12;
    v14 = 0;
    v15 = 0;
    v16 = v12 + 2;
    do
    {
      (*(void (**)(_QWORD, uint64_t, _BYTE *))(**((_QWORD **)this + 7) + 80))(*((_QWORD *)this + 7), v14, v22);
      if (v23 >= 3uLL)
      {
        v17 = v24;
        v18 = 3 * v15;
        v19 = (unsigned __int8 *)(v16 + v24);
        v20 = v23 - 1 - 1;
        v15 = v15 + v23 - 2;
        do
        {
          a2[v18] = *(unsigned __int8 *)(v13 + v17);
          a2[v18 + 1] = *(v19 - 1);
          v21 = *v19++;
          a2[v18 + 2] = v21;
          v18 += 3;
          --v20;
        }
        while (v20);
      }
      v14 = (v14 + 1);
    }
    while ((_DWORD)v14 != v7);
  }
  return v10;
}

void re::PhysXConvexPolyhedronShape::~PhysXConvexPolyhedronShape(re::PhysXConvexPolyhedronShape *this)
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::ConvexPolyhedronShape::type(re::ConvexPolyhedronShape *this)
{
  return 5;
}

uint64_t physx::PxMassProperties::PxMassProperties(uint64_t a1, uint64_t a2)
{
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float *v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  __int128 v43;
  _OWORD v45[2];
  int v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v57[9];
  float v58;
  float v59;
  float v60;

  switch(*(_DWORD *)a2)
  {
    case 0xFFFFFFFF:
    case 1:
    case 5:
    case 6:
    case 7:
      *(_OWORD *)a1 = xmmword_2260E5F10;
      *(_OWORD *)(a1 + 16) = xmmword_2260E5F10;
      *(_OWORD *)(a1 + 32) = xmmword_2260E5F10;
      *(_DWORD *)(a1 + 48) = 1065353216;
      break;
    case 0:
      v4 = *(float *)(a2 + 4);
      v5 = v4 * (float)(v4 * (float)(v4 * 4.1888));
      *(float *)(a1 + 48) = v5;
      v6 = v4 * (float)(v4 * (float)(v5 * 0.4));
      *(float *)a1 = v6;
      *(_QWORD *)(a1 + 4) = 0;
      *(_DWORD *)(a1 + 12) = 0;
      *(float *)(a1 + 16) = v6;
      *(_QWORD *)(a1 + 20) = 0;
      *(_DWORD *)(a1 + 28) = 0;
      *(float *)(a1 + 32) = v6;
      *(_QWORD *)(a1 + 36) = 0;
      goto LABEL_5;
    case 2:
      v7 = *(float *)(a2 + 4);
      v8 = *(float *)(a2 + 8);
      *(float *)(a1 + 48) = v7 * (float)(v7 * (float)((float)((float)(v8 + v8) + (float)(v7 * 1.3333)) * 3.1416));
      v9 = v7 * (float)(v7 * v7);
      v10 = v7 * (float)(v7 * v8);
      *(float *)a1 = v7 * (float)(v7 * (float)((float)(v10 + (float)(v9 * 0.53333)) * 3.1416));
      *(_QWORD *)(a1 + 4) = 0;
      *(_DWORD *)(a1 + 12) = 0;
      v11 = v7
          * (float)(v7
                  * (float)((float)((float)((float)((float)(v10 * 1.5) + (float)(v9 * 0.53333))
                                          + (float)((float)(v7 * (float)(v8 * v8)) * 1.3333))
                                  + (float)((float)(v8 * (float)(v8 * v8)) * 0.66667))
                          * 3.1416));
      *(float *)(a1 + 16) = v11;
      *(_QWORD *)(a1 + 20) = 0;
      *(_DWORD *)(a1 + 28) = 0;
      *(float *)(a1 + 32) = v11;
      *(_QWORD *)(a1 + 36) = 0;
LABEL_5:
      *(_DWORD *)(a1 + 44) = 0;
      break;
    case 3:
      v12 = *(float *)(a2 + 4);
      v13 = *(float *)(a2 + 8);
      v14 = *(float *)(a2 + 12);
      v15 = (float)((float)(v12 * v13) * v14) * 8.0;
      *(float *)(a1 + 48) = v15;
      v16 = v12 * v12;
      v17 = v13 * v13;
      v18 = v14 * v14;
      v19 = v15 / 3.0;
      *(float *)a1 = (float)(v17 + v18) * v19;
      *(float *)(a1 + 4) = v19 * 0.0;
      *(float *)(a1 + 8) = v19 * 0.0;
      *(float *)(a1 + 12) = v19 * 0.0;
      *(float *)(a1 + 16) = (float)(v16 + v18) * v19;
      *(float *)(a1 + 20) = v19 * 0.0;
      *(float *)(a1 + 24) = v19 * 0.0;
      *(float *)(a1 + 28) = v19 * 0.0;
      *(float *)(a1 + 32) = (float)(v16 + v17) * v19;
      *(_QWORD *)(a1 + 40) = 0;
      *(_DWORD *)(a1 + 36) = 0;
      break;
    case 4:
      v47 = 0.0;
      (*(void (**)(_QWORD, float *, float *, float *))(**(_QWORD **)(a2 + 32) + 104))(*(_QWORD *)(a2 + 32), &v47, v57, &v58);
      v21 = v59;
      v20 = v60;
      v22 = v58;
      v56 = v57[8] - (float)(v47 * (float)((float)(v21 * v21) + (float)(v22 * v22)));
      v48 = v57[0] - (float)(v47 * (float)((float)(v20 * v20) + (float)(v21 * v21)));
      v49 = v57[1] + (float)(v47 * (float)(v59 * v58));
      v52 = v57[4] - (float)(v47 * (float)((float)(v22 * v22) + (float)(v20 * v20)));
      v53 = v57[5] + (float)(v47 * (float)(v59 * v60));
      v54 = v57[2] + (float)(v47 * (float)(v60 * v58));
      v55 = v53;
      v24 = *(float *)(a2 + 16);
      v23 = (float *)(a2 + 16);
      v25 = *(v23 - 3);
      v50 = v54;
      v51 = v49;
      v26 = *(v23 - 2);
      v27 = *(v23 - 1);
      *(float *)(a1 + 48) = (float)((float)(v47 * v25) * v26) * v27;
      v28 = v22 + v22;
      v29 = v21 + v21;
      v30 = v20 + v20;
      v32 = v23[2];
      v31 = v23[3];
      v33 = (float)(v31 * v31) + -0.5;
      v34 = v23[1];
      v35 = (float)((float)(v29 * v34) + (float)(v24 * v28)) + (float)(v32 * v30);
      v36 = (float)((float)(v31 * (float)((float)(v34 * v30) - (float)(v32 * v29))) + (float)(v28 * v33))
          + (float)(v24 * v35);
      v37 = (float)((float)(v31 * (float)((float)(v32 * v28) - (float)(v24 * v30))) + (float)(v29 * v33))
          + (float)(v34 * v35);
      v38 = (float)((float)(v31 * (float)((float)(v24 * v29) - (float)(v34 * v28))) + (float)(v30 * v33))
          + (float)(v32 * v35);
      v39 = (float)(v25 * v36) + (float)(v25 * v36);
      v40 = (float)(v26 * v37) + (float)(v26 * v37);
      v41 = (float)(v27 * v38) + (float)(v27 * v38);
      v42 = (float)((float)(v34 * v40) + (float)(v24 * v39)) + (float)(v32 * v41);
      *(float *)(a1 + 36) = (float)((float)(v39 * v33) - (float)((float)((float)(v34 * v41) - (float)(v32 * v40)) * v31))
                          + (float)(v24 * v42);
      *(float *)(a1 + 40) = (float)((float)(v40 * v33) - (float)((float)((float)(v32 * v39) - (float)(v24 * v41)) * v31))
                          + (float)(v34 * v42);
      *(float *)(a1 + 44) = (float)((float)(v41 * v33) - (float)((float)((float)(v24 * v40) - (float)(v34 * v39)) * v31))
                          + (float)(v32 * v42);
      physx::PxMassProperties::scaleInertia(&v48, v23, v23 - 3, (float *)v45);
      v43 = v45[1];
      *(_OWORD *)a1 = v45[0];
      *(_OWORD *)(a1 + 16) = v43;
      *(_DWORD *)(a1 + 32) = v46;
      break;
    default:
      return a1;
  }
  return a1;
}

float physx::PxMassProperties::scaleInertia@<S0>(float *a1@<X0>, float *a2@<X1>, float *a3@<X2>, float *a4@<X8>)
{
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;
  float v60;
  float v61;
  float v62;
  float v63;
  float v64;
  float v65;
  float v66;
  float v67;
  float v68;
  float v69;
  float v70;
  float v71;
  float v72;
  float v73;
  float v74;
  float v75;
  float v76;
  float v77;
  float v78;
  float v79;
  float v80;
  float v81;
  float v82;
  float v83;
  float v84;
  float v85;
  float v86;
  float v87;
  float v88;
  float v89;
  float v90;
  float v91;
  float v92;
  float v93;
  float v94;
  float v95;
  float v96;
  float v97;
  float v98;
  float v99;
  float v100;
  float v101;
  float v102;
  float v103;
  float v104;
  float v105;
  float v106;
  float v107;
  float v108;
  float v109;
  float v110;
  float v111;
  float v112;
  float v113;
  float v114;
  float v115;
  float v116;
  float v117;
  float v118;
  float v119;
  float v120;
  float v121;
  float v122;
  float v123;
  float v124;
  float v125;
  float v126;
  float v127;
  float v128;
  float v129;
  float v130;
  float v131;
  float result;

  v4 = *a2;
  v5 = a2[1];
  v7 = a2[2];
  v6 = a2[3];
  v8 = v5 * (float)(v5 + v5);
  v9 = v7 * (float)(v7 + v7);
  v10 = (float)(v4 + v4) * v5;
  v11 = (float)(v4 + v4) * v7;
  v12 = (float)(v4 + v4) * v6;
  v13 = (float)(v5 + v5) * v7;
  v14 = (float)(v5 + v5) * v6;
  v15 = (float)(v7 + v7) * v6;
  v16 = (float)(1.0 - v8) - v9;
  v17 = v10 + v15;
  v18 = v11 - v14;
  v19 = v10 - v15;
  v20 = 1.0 - (float)(v4 * (float)(v4 + v4));
  v21 = v20 - v9;
  v22 = v13 + v12;
  v23 = v11 + v14;
  v24 = v13 - v12;
  v25 = v20 - v8;
  v26 = a1[1];
  v27 = (float)(*a1 * v16) + (float)(v19 * v26);
  v28 = (float)(*a1 * v17) + (float)(v21 * v26);
  v29 = (float)(*a1 * v18) + (float)(v22 * v26);
  v30 = a1[2];
  v31 = a1[3];
  v32 = v27 + (float)(v23 * v30);
  v33 = v28 + (float)(v24 * v30);
  v34 = v29 + (float)(v25 * v30);
  v35 = a1[4];
  v36 = a1[5];
  v37 = (float)((float)(v16 * v31) + (float)(v19 * v35)) + (float)(v23 * v36);
  v38 = (float)((float)(v17 * v31) + (float)(v21 * v35)) + (float)(v24 * v36);
  v39 = (float)((float)(v18 * v31) + (float)(v22 * v35)) + (float)(v25 * v36);
  v40 = a1[6];
  v41 = a1[7];
  v42 = (float)(v16 * v40) + (float)(v19 * v41);
  v43 = (float)(v17 * v40) + (float)(v21 * v41);
  v44 = (float)(v18 * v40) + (float)(v22 * v41);
  v45 = a1[8];
  v46 = v43 + (float)(v24 * v45);
  v47 = v44 + (float)(v25 * v45);
  v48 = (float)(v16 * v32) + (float)(v19 * v37);
  v49 = (float)(v16 * v33) + (float)(v19 * v38);
  v50 = (float)(v16 * v34) + (float)(v19 * v39);
  v51 = v48 + (float)(v23 * (float)(v42 + (float)(v23 * v45)));
  v52 = v49 + (float)(v23 * v46);
  v53 = v50 + (float)(v23 * v47);
  v54 = v17 * v33;
  v55 = (float)(v17 * v34) + (float)(v21 * v39);
  v56 = (float)(v54 + (float)(v21 * v38)) + (float)(v24 * v46);
  v57 = v55 + (float)(v24 * v47);
  v58 = (float)((float)(v18 * v34) + (float)(v22 * v39)) + (float)(v25 * v47);
  v59 = (float)((float)(v56 * 0.5) + (float)(v51 * 0.5)) + (float)(v58 * 0.5);
  v60 = v59 - v56;
  v61 = a3[1];
  v62 = a3[2];
  v63 = *a3 * (float)(*a3 * (float)(v59 - v51));
  v64 = v61 * (float)(v61 * v60);
  v65 = v62 * (float)(v62 * (float)(v59 - v58));
  v66 = v64 + v65;
  v67 = v65 + v63;
  v68 = v63 + v64;
  v69 = v61 * (float)(*a3 * v52);
  v70 = v62 * (float)(v61 * v57);
  v71 = (float)(*a3 * v61) * v62;
  v72 = v71 * v66;
  v73 = v71 * v69;
  v74 = v71 * (float)(v62 * (float)(*a3 * v53));
  v75 = v71 * v67;
  v76 = v71 * v70;
  v77 = v71 * v68;
  v78 = (float)-*a2 - *a2;
  v79 = (float)-v5 - v5;
  v80 = (float)-v7 - v7;
  v81 = -(float)(v5 * v79);
  v82 = -(float)(v7 * v80);
  v83 = -(float)(v5 * v78);
  v84 = -(float)(v7 * v78);
  v85 = v78 * v6;
  v86 = -(float)(v7 * v79);
  v87 = v79 * v6;
  v88 = v80 * v6;
  v89 = (float)(1.0 - v81) - v82;
  v90 = v83 + v88;
  v91 = v84 - v87;
  v92 = v83 - v88;
  v93 = (float)(*a2 * v78) + 1.0;
  v94 = v93 - v82;
  v95 = v86 + v85;
  v96 = v84 + v87;
  v97 = v86 - v85;
  v98 = v93 - v81;
  v99 = (float)((float)(v84 + v87) * v74) + (float)((float)(v92 * v73) + (float)(v89 * v72));
  v100 = (float)((float)(v86 - v85) * v74) + (float)((float)(v94 * v73) + (float)(v90 * v72));
  v101 = (float)(v98 * v74) + (float)((float)((float)(v86 + v85) * v73) + (float)((float)(v84 - v87) * v72));
  v102 = (float)(v89 * v73) + (float)(v92 * v75);
  v103 = (float)(v90 * v73) + (float)(v94 * v75);
  v104 = (float)(v91 * v73) + (float)(v95 * v75);
  v105 = (float)(v96 * v76) + v102;
  v106 = (float)(v97 * v76) + v103;
  v107 = (float)(v98 * v76) + v104;
  v108 = v90 * v74;
  v109 = v94 * v76;
  v110 = (float)(v89 * v74) + (float)(v92 * v76);
  v111 = (float)(v91 * v74) + (float)(v95 * v76);
  v112 = v110 + (float)(v96 * v77);
  v113 = (float)(v108 + v109) + (float)(v97 * v77);
  v114 = v111 + (float)(v98 * v77);
  v115 = (float)(v96 * v112) + (float)((float)(v89 * v99) + (float)(v92 * v105));
  v116 = (float)(v96 * v113) + (float)((float)(v89 * v100) + (float)(v92 * v106));
  v117 = (float)(v96 * v114) + (float)((float)(v89 * v101) + (float)(v92 * v107));
  v118 = (float)(v90 * v99) + (float)(v94 * v105);
  v119 = (float)(v90 * v100) + (float)(v94 * v106);
  v120 = (float)(v90 * v101) + (float)(v94 * v107);
  v121 = (float)(v97 * v112) + v118;
  v122 = (float)(v97 * v113) + v119;
  v123 = (float)(v97 * v114) + v120;
  v124 = v91 * v99;
  v125 = v91 * v100;
  v126 = v91 * v101;
  v127 = v95 * v105;
  v128 = v95 * v106;
  v129 = v126 + (float)(v95 * v107);
  v130 = (float)(v98 * v112) + (float)(v124 + v127);
  v131 = (float)(v98 * v113) + (float)(v125 + v128);
  *a4 = v115;
  a4[1] = v116;
  a4[2] = v117;
  a4[3] = v121;
  a4[4] = v122;
  a4[5] = v123;
  result = (float)(v98 * v114) + v129;
  a4[6] = v130;
  a4[7] = v131;
  a4[8] = result;
  return result;
}

_QWORD *re::IndexedTriangleMesh::freeData(_QWORD *this)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t *v7;

  v1 = this;
  v2 = this[6];
  if (v2)
  {
    v3 = re::globalAllocators((re *)this);
    this = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v3[2] + 40))(v3[2], v2);
  }
  v4 = v1[2];
  if (v4)
  {
    v5 = re::globalAllocators((re *)this);
    this = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v5[2] + 40))(v5[2], v4);
  }
  v6 = v1[1];
  if (v6)
  {
    v7 = re::globalAllocators((re *)this);
    return (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v7[2] + 40))(v7[2], v6);
  }
  return this;
}

BOOL re::IndexedTriangleMesh::isValid(re::IndexedTriangleMesh *this)
{
  unint64_t v2;
  _BOOL8 result;
  unint64_t v4;
  int v5;
  _BOOL4 v6;
  _BOOL4 v7;

  if (!*((_QWORD *)this + 1))
    return 0;
  if (!*((_QWORD *)this + 2))
    return 0;
  v2 = *((_QWORD *)this + 3);
  if (!v2)
    return 0;
  result = 0;
  v4 = *((_QWORD *)this + 5);
  if (v4 && !(v4 % 3))
  {
    v5 = *((unsigned __int8 *)this + 58);
    v6 = HIDWORD(v2) == 0;
    v7 = v2 < 0x10000;
    if (v5 != 1)
      v7 = 0;
    if (v5 == 2)
      return v6;
    else
      return v7;
  }
  return result;
}

float re::BoxShape::massProperties(uint64_t a1, float *a2, _QWORD *a3, uint64_t a4)
{
  float32x4_t v7;
  uint64_t v8;
  float32x4_t v9;
  float v10;
  float v11;
  float result;

  v7.i64[0] = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
  v7.i64[1] = v8;
  v9 = vmulq_f32(v7, v7);
  v10 = vmuls_lane_f32(vmuls_lane_f32(v7.f32[0], *(float32x2_t *)v7.f32, 1), v7, 2);
  *a2 = v10;
  v11 = v10 / 12.0;
  *(_QWORD *)(a4 + 4) = 0;
  *(_QWORD *)(a4 + 12) = 0;
  *(_QWORD *)(a4 + 24) = 0;
  *(_QWORD *)(a4 + 32) = 0;
  *(float *)a4 = (float)(v9.f32[1] + v9.f32[2]) * v11;
  *(float *)(a4 + 20) = (float)(v9.f32[0] + v9.f32[2]) * v11;
  result = vaddv_f32(*(float32x2_t *)v9.f32) * v11;
  *(float *)(a4 + 40) = result;
  *(_DWORD *)(a4 + 44) = 0;
  *a3 = 0;
  a3[1] = 0;
  return result;
}

uint64_t re::BoxShape::type(re::BoxShape *this)
{
  return 3;
}

float re::CylinderShape::massProperties(uint64_t a1, float *a2, _QWORD *a3, uint64_t a4)
{
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float result;

  v8 = (*(float (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
  v9 = (*(float (**)(uint64_t))(*(_QWORD *)a1 + 72))(a1);
  v10 = v9 * v9;
  v11 = v8 * (float)(v10 * 3.1416);
  *a2 = v11;
  v12 = (float)((float)(v8 * v8) + (float)(v10 * 3.0)) * (float)(v11 * 0.083333);
  *(_QWORD *)(a4 + 4) = 0;
  *(_QWORD *)(a4 + 12) = 0;
  *(_QWORD *)(a4 + 24) = 0;
  *(_QWORD *)(a4 + 32) = 0;
  *(float *)a4 = v12;
  result = v10 * (float)(v11 * 0.5);
  *(float *)(a4 + 20) = result;
  *(float *)(a4 + 40) = v12;
  *(_DWORD *)(a4 + 44) = 0;
  *a3 = 0;
  a3[1] = 0;
  return result;
}

uint64_t re::CylinderShape::type(re::CylinderShape *this)
{
  return 8;
}

uint64_t re::CastHitCallback<physx::PxRaycastHit>::addHit(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t result;
  _DWORD *v11;
  int v12;
  __int128 v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;

  v4 = re::BucketArray<re::CollisionCastHit,10ul>::addUninitialized(*(_QWORD *)(a1 + 96));
  *(_QWORD *)v4 = 0;
  *(_OWORD *)(v4 + 16) = 0u;
  *(_OWORD *)(v4 + 32) = 0u;
  *(_DWORD *)(v4 + 48) = 2139095039;
  *(_QWORD *)(v4 + 52) = 0xFFFFFFFF00000000;
  *(_QWORD *)(v4 + 64) = 0;
  v6 = *(_QWORD *)(a1 + 96);
  v7 = *(_QWORD *)(v6 + 40);
  if (v7)
  {
    v8 = re::BucketArray<re::CollisionCastHit,10ul>::operator[](v6, v7 - 1);
    *(float *)(v8 + 48) = *(float *)(a2 + 48) / *(float *)(a1 + 2156);
    *(_OWORD *)(v8 + 16) = *(_OWORD *)(a2 + 24);
    *(_OWORD *)(v8 + 32) = *(_OWORD *)(a2 + 36);
    v9 = *(_QWORD *)(*(_QWORD *)a2 + 16);
    *(_QWORD *)v8 = v9;
    *(_DWORD *)(v8 + 52) = re::internal::nvphysx::findShapeIndex(v9, *(_QWORD *)(a2 + 8));
    result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a2 + 8) + 64))(*(_QWORD *)(a2 + 8));
    if ((_DWORD)result == 5)
    {
      v12 = 5;
      v13 = xmmword_2260EDC60;
      v14 = 0;
      v15 = 0;
      v16 = 1065353216;
      v17 = 0;
      (*(void (**)(_QWORD, int *))(**(_QWORD **)(a2 + 8) + 128))(*(_QWORD *)(a2 + 8), &v12);
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v17 + 104))(v17);
      if (result)
      {
        result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v17 + 104))(v17);
        v11 = (_DWORD *)(result + 4 * *(unsigned int *)(a2 + 16));
      }
      else
      {
        v11 = (_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(v8 + 56) = *v11;
      *(_QWORD *)(v8 + 64) = *(_QWORD *)(a2 + 52);
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::PhysXCollisionWorld::PhysXCollisionWorld(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  *(_DWORD *)(a1 + 40) = 0;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 8) = 0u;
  v5 = a1 + 8;
  *(_QWORD *)(a1 + 44) = 0x7FFFFFFFLL;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_DWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 108) = 0x7FFFFFFFLL;
  *(_QWORD *)(a1 + 120) = a1;
  *(_QWORD *)(a1 + 128) = a1;
  *(_QWORD *)a1 = &off_24ED40E98;
  *(_QWORD *)(a1 + 136) = 0;
  *(_QWORD *)(a1 + 144) = a3;
  v6 = a1 + 176;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_QWORD *)(a1 + 184) = 0;
  *(_DWORD *)(a1 + 192) = 1;
  *(_QWORD *)(a1 + 208) = 0;
  *(_QWORD *)(a1 + 216) = 0;
  *(_DWORD *)(a1 + 224) = 0;
  *(_QWORD *)(a1 + 200) = 0;
  re::BucketArray<re::PhysXManifold,256ul>::init(a1 + 176, a2, 1uLL);
  v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 32, 8);
  *(_QWORD *)v7 = &off_24ED41B40;
  *(_QWORD *)(v7 + 8) = v6;
  *(_QWORD *)(v7 + 16) = v5;
  *(_BYTE *)(v7 + 24) = 0;
  *(_QWORD *)(a1 + 232) = v7;
  *(_QWORD *)(a1 + 240) = a2;
  *(_QWORD *)(a1 + 256) = 0;
  *(_OWORD *)(a1 + 272) = xmmword_2260E5F10;
  *(_OWORD *)(a1 + 288) = xmmword_2260E5F20;
  *(_OWORD *)(a1 + 304) = xmmword_2260E5F40;
  *(_OWORD *)(a1 + 320) = xmmword_2260E5D70;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_DWORD *)(a1 + 368) = 1036831949;
  *(_DWORD *)(a1 + 384) = 0;
  *(_DWORD *)(a1 + 387) = 0;
  *(_QWORD *)(a1 + 392) = 0;
  *(_QWORD *)(a1 + 400) = 0;
  return a1;
}

void re::PhysXCollisionWorld::~PhysXCollisionWorld(re::PhysXCollisionWorld *this)
{
  uint64_t v2;
  unint64_t i;
  uint64_t v4;
  uint64_t v5;
  void (***v6)(_QWORD);
  uint64_t v7;

  re::PhysXCollisionWorld::deinit(this);
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 30) + 40))(*((_QWORD *)this + 30), *((_QWORD *)this + 29));
  re::PhysXDebugRenderer::deinit((const void **)this + 32);
  v2 = *((_QWORD *)this + 27);
  if (v2)
  {
    for (i = 0; i != v2; ++i)
    {
      v4 = re::BucketArray<re::PhysXManifold,256ul>::operator[]((uint64_t)this + 176, i);
      v5 = *(_QWORD *)(v4 + 16);
      if (v5)
      {
        if (*(_QWORD *)(v4 + 48))
          (*(void (**)(uint64_t))(*(_QWORD *)v5 + 40))(v5);
        *(_QWORD *)(v4 + 48) = 0;
        *(_QWORD *)(v4 + 24) = 0;
        *(_QWORD *)(v4 + 32) = 0;
        *(_QWORD *)(v4 + 16) = 0;
        ++*(_DWORD *)(v4 + 40);
      }
    }
  }
  while (*((_QWORD *)this + 23))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)this + 22);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 176);
  *((_QWORD *)this + 27) = 0;
  ++*((_DWORD *)this + 56);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 176);
  v6 = (void (***)(_QWORD))*((_QWORD *)this + 20);
  if (v6)
    (**v6)(v6);
  v7 = *((_QWORD *)this + 19);
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 16))(v7);
  re::CollisionWorld::~CollisionWorld(this);
}

{
  re::PhysXCollisionWorld::~PhysXCollisionWorld(this);
  JUMPOUT(0x2276933B8);
}

void re::PhysXCollisionWorld::deinit(re::PhysXCollisionWorld *this)
{
  void (***v2)(_QWORD);
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if (*((_QWORD *)this + 7))
  {
    re::PhysXDebugRenderer::deinit((const void **)this + 32);
    v2 = (void (***)(_QWORD))*((_QWORD *)this + 20);
    if (v2)
      (**v2)(v2);
    *((_QWORD *)this + 20) = 0;
    v3 = *((_QWORD *)this + 21);
    if (v3)
    {
      v4 = *((_QWORD *)this + 7);
      (*(void (**)(_QWORD))(*(_QWORD *)v3 + 16))(*((_QWORD *)this + 21));
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v4 + 40))(v4, v3);
      v5 = *((_QWORD *)this + 19);
      if (v5)
        (*(void (**)(uint64_t))(*(_QWORD *)v5 + 16))(v5);
    }
    *((_QWORD *)this + 19) = 0;
    if (*((_QWORD *)this + 7))
    {
      if (*((_QWORD *)this + 9))
        re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::deinit((uint64_t *)this + 9);
      *((_QWORD *)this + 7) = 0;
    }
  }
}

uint64_t re::QueryFilterCallback::preFilter(_DWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  int v6;
  int v7;

  (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(_QWORD *)a3 + 192))(&v5, a3);
  if ((v7 & a1[4]) != 0 && (a1[5] & v6) != 0)
    return a1[6];
  else
    return 0;
}

uint64_t re::PhysXCollisionWorld::setCollisionFlags(uint64_t result, int a2)
{
  uint64_t v3;
  float32x4_t v4;
  uint64_t v5;
  __int32 v6;
  float32x4_t v7;

  if (*(_DWORD *)(result + 384) != a2)
  {
    v3 = result;
    (*(void (**)(uint64_t *__return_ptr))(**(_QWORD **)(result + 152) + 488))(&v5);
    v4.i64[0] = v5;
    v4.i32[2] = v6;
    v7 = v4;
    return re::PhysXCollisionWorld::createScene(v3, &v7, a2);
  }
  return result;
}

uint64_t re::PhysXCollisionWorld::createScene(uint64_t a1, float32x4_t *a2, int a3)
{
  int v6;
  uint64_t v7;
  _anonymous_namespace_ *v8;
  unint64_t v9;
  char v10;
  BOOL v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t *v15;
  char *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t *v22;
  unint64_t *v23;
  unint64_t *v24;
  uint64_t v25;
  unint64_t *v26;
  unint64_t *v27;
  unint64_t v28;
  unint64_t *v29;
  unint64_t *v30;
  unint64_t v31;
  void (***v32)(_QWORD);
  uint64_t v33;
  _anonymous_namespace_ *v34;
  unint64_t v35;
  char v36;
  char v37;
  unint64_t v38;
  uint64_t v39;
  _BYTE *v40;
  uint64_t v41;
  _BYTE *v42;
  _BYTE *v43;
  uint64_t v44;
  float32x2_t *v45;
  int32x2_t v46;
  uint64_t v47;
  float32x4_t v48;
  physx::shdfnd::Foundation *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t ControllerManager;
  void (***v57)(_QWORD);
  uint64_t v58;
  _BYTE *v59;
  unint64_t *v60;
  unint64_t *v61;
  uint64_t result;
  int v63;
  __int16 v64;
  __int16 v65;
  unint64_t v66;
  uint64_t v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  int v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  int32x2_t v77;
  __int32 v78;
  int v79;
  int v80;
  uint64_t v81;
  uint64_t v82;
  __int128 v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  int v87;
  uint64_t v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  uint64_t v93;
  float32x2_t v94;
  _BYTE v95[20];
  _BYTE v96[260];
  uint64_t *v97;
  unint64_t v98;
  int v99;
  unint64_t v100;
  unint64_t *v101;
  uint64_t v102;

  v102 = *MEMORY[0x24BDAC8D0];
  if (physx::shdfnd::g_isLockingEnabled)
    v6 = 1;
  else
    v6 = physx::shdfnd::g_alwaysUseLocking;
  v63 = v6;
  if ((physx::shdfnd::g_alwaysUseLocking & 1) == 0 && physx::shdfnd::g_isLockingEnabled)
    physx::shdfnd::g_isLockingEnabled = 0;
  v97 = 0;
  v98 = 0;
  v99 = 1;
  v100 = 0;
  v101 = 0;
  v7 = *(_QWORD *)(a1 + 160);
  if (v7)
  {
    v8 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 16))(v7);
    if ((_DWORD)v8)
    {
      v9 = v8;
      re::DynamicOverflowArray<re::PhysXCollisionWorld::createScene(re::Vector3<float> const&,re::CollisionWorld::CollisionFlags)::ControllerInfo,4ul>::setCapacity(&v97, v9);
      v10 = v99;
      v99 += 2;
      v11 = (v10 & 1) == 0;
      v12 = 4;
      if (v11)
        v12 = v100;
      if (v12 < v9)
        re::DynamicOverflowArray<re::PhysXCollisionWorld::createScene(re::Vector3<float> const&,re::CollisionWorld::CollisionFlags)::ControllerInfo,4ul>::setCapacity(&v97, v9);
      v13 = v9 - v98;
      if (v9 > v98)
      {
        v14 = v98 << 6;
        do
        {
          if ((v99 & 1) != 0)
            v15 = &v100;
          else
            v15 = v101;
          v16 = (char *)v15 + v14;
          *(_QWORD *)v16 = 0;
          *((_OWORD *)v16 + 1) = 0uLL;
          *((_OWORD *)v16 + 2) = 0uLL;
          *((_QWORD *)v16 + 6) = 0;
          v14 += 64;
          --v13;
        }
        while (v13);
      }
      v17 = 0;
      v18 = 0;
      v98 = v9;
      v99 += 2;
      while (1)
      {
        v19 = (*(uint64_t (**)(_QWORD, unint64_t))(**(_QWORD **)(a1 + 160) + 24))(*(_QWORD *)(a1 + 160), v18);
        v20 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v19 + 160))(v19);
        v21 = v98;
        if (v98 <= v18)
          break;
        if ((v99 & 1) != 0)
          v22 = &v100;
        else
          v22 = v101;
        v22[v17] = v20;
        if ((v99 & 1) != 0)
          v23 = &v100;
        else
          v23 = v101;
        v24 = &v23[v17];
        v25 = *(_QWORD *)(v23[v17] + 56);
        v66 = 0;
        (*(void (**)(uint64_t, unint64_t *, uint64_t, _QWORD))(*(_QWORD *)v25 + 216))(v25, &v66, 1, 0);
        v24[6] = v66;
        if ((v99 & 1) != 0)
          v26 = &v100;
        else
          v26 = v101;
        v27 = &v26[v17];
        v27[2] = (*(uint64_t (**)(unint64_t))(*(_QWORD *)v26[v17] + 88))(v26[v17]);
        v27[3] = v28;
        v21 = v98;
        if (v98 <= v18)
          goto LABEL_93;
        if ((v99 & 1) != 0)
          v29 = &v100;
        else
          v29 = v101;
        v30 = &v29[v17];
        v30[4] = (*(uint64_t (**)(unint64_t))(*(_QWORD *)v29[v17] + 160))(v29[v17]);
        v30[5] = v31;
        ++v18;
        v17 += 8;
        if (v9 == v18)
          goto LABEL_35;
      }
      v67 = 0;
      v71 = 0u;
      v72 = 0u;
      v69 = 0u;
      v70 = 0u;
      v68 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v95 = 136315906;
      *(_QWORD *)&v95[4] = "operator[]";
      *(_WORD *)&v95[12] = 1024;
      *(_DWORD *)&v95[14] = 858;
      *(_WORD *)&v95[18] = 2048;
      *(_QWORD *)v96 = v18;
      *(_WORD *)&v96[8] = 2048;
      *(_QWORD *)&v96[10] = v21;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_93:
      v67 = 0;
      v71 = 0u;
      v72 = 0u;
      v69 = 0u;
      v70 = 0u;
      v68 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v95 = 136315906;
      *(_QWORD *)&v95[4] = "operator[]";
      *(_WORD *)&v95[12] = 1024;
      *(_DWORD *)&v95[14] = 858;
      *(_WORD *)&v95[18] = 2048;
      *(_QWORD *)v96 = v18;
      *(_WORD *)&v96[8] = 2048;
      *(_QWORD *)&v96[10] = v21;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
LABEL_35:
    (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 160) + 40))(*(_QWORD *)(a1 + 160));
    v32 = *(void (****)(_QWORD))(a1 + 160);
    if (v32)
      (**v32)(v32);
    *(_QWORD *)(a1 + 160) = 0;
  }
  *(_QWORD *)v95 = 0;
  *(_QWORD *)&v95[8] = 0;
  *(_DWORD *)&v95[16] = 1;
  *(_QWORD *)&v96[4] = 0;
  *(_QWORD *)&v96[12] = 0;
  v33 = *(_QWORD *)(a1 + 152);
  if (v33)
  {
    v65 = 3;
    v34 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, __int16 *))(*(_QWORD *)v33 + 152))(v33, &v65);
    v35 = v34;
    if (*(_QWORD *)&v95[8] >= (unint64_t)v34)
    {
      if (*(_QWORD *)&v95[8] <= (unint64_t)v34)
      {
        v37 = v95[16];
LABEL_55:
        v41 = *(_QWORD *)(a1 + 152);
        v64 = 3;
        if ((v37 & 1) != 0)
          v42 = &v96[4];
        else
          v42 = *(_BYTE **)&v96[12];
        (*(void (**)(uint64_t, __int16 *, _BYTE *, unint64_t, _QWORD))(*(_QWORD *)v41 + 160))(v41, &v64, v42, v35, 0);
        if ((v95[16] & 1) != 0)
          v43 = &v96[4];
        else
          v43 = *(_BYTE **)&v96[12];
        (*(void (**)(_QWORD, _BYTE *, unint64_t, uint64_t))(**(_QWORD **)(a1 + 152) + 120))(*(_QWORD *)(a1 + 152), v43, v35, 1);
        v44 = *(_QWORD *)(a1 + 152);
        if (v44)
          (*(void (**)(uint64_t))(*(_QWORD *)v44 + 16))(v44);
        *(_QWORD *)(a1 + 152) = 0;
        goto LABEL_64;
      }
    }
    else
    {
      if (*(_QWORD *)v95)
      {
        v36 = v95[16];
      }
      else
      {
        re::DynamicOverflowArray<physx::PxActor *,32ul>::setCapacity(v95, v35);
        v36 = v95[16] + 2;
        *(_DWORD *)&v95[16] += 2;
      }
      v11 = (v36 & 1) == 0;
      v38 = 32;
      if (v11)
        v38 = *(_QWORD *)&v96[4];
      if (v38 < v35)
        re::DynamicOverflowArray<physx::PxActor *,32ul>::setCapacity(v95, v35);
      v39 = *(_QWORD *)&v95[8];
      if (*(_QWORD *)&v95[8] < v35)
      {
        do
        {
          if ((v95[16] & 1) != 0)
            v40 = &v96[4];
          else
            v40 = *(_BYTE **)&v96[12];
          *(_QWORD *)&v40[8 * v39++] = 0;
        }
        while (v35 != v39);
      }
    }
    *(_QWORD *)&v95[8] = v35;
    v37 = v95[16] + 2;
    *(_DWORD *)&v95[16] += 2;
    goto LABEL_55;
  }
LABEL_64:
  v45 = (float32x2_t *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 144) + 40))(*(_QWORD *)(a1 + 144));
  *(_QWORD *)&v68 = 0;
  DWORD2(v68) = 0;
  v69 = 0u;
  v70 = 0u;
  LODWORD(v71) = 0;
  *((_QWORD *)&v71 + 1) = 0;
  *(_QWORD *)&v72 = 0;
  *((_QWORD *)&v72 + 1) = 0x100000001;
  v73 = 2;
  v74 = 0u;
  v75 = 0u;
  v76 = 0u;
  v46 = (int32x2_t)vmul_f32(*v45, (float32x2_t)0x3E4CCCCD3D23D70ALL);
  v77 = vrev64_s32(v46);
  v78 = v46.i32[0];
  v79 = 0;
  v80 = 64;
  v81 = 0;
  v82 = 0;
  v83 = xmmword_226102760;
  v84 = 0;
  v85 = 0x1000000080;
  v86 = 0x1000000000000;
  v87 = 2139095039;
  v88 = 0x100002000;
  v89 = xmmword_226102770;
  v90 = xmmword_226102780;
  v91 = xmmword_226102790;
  v92 = xmmword_2261027A0;
  v93 = 8;
  v94 = *v45;
  v81 = *(_QWORD *)(a1 + 168);
  HIDWORD(v76) = 1;
  v47 = *(_QWORD *)(a1 + 232);
  *((_QWORD *)&v71 + 1) = SimulationFilterShader;
  *(_QWORD *)&v69 = v47;
  v80 = 17474;
  HIDWORD(v86) = 64;
  *(_QWORD *)&v68 = a2->i64[0];
  DWORD2(v68) = a2->i32[2];
  v48 = vmulq_f32(*a2, *a2);
  *(float *)v77.i32 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v48, 2), vaddq_f32(v48, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v48.f32, 1))).f32[0])* 0.2;
  if ((a3 & 1) != 0)
    HIDWORD(v72) = 0;
  if ((a3 & 2) != 0)
    DWORD2(v72) = 0;
  *(_DWORD *)(a1 + 384) = a3;
  v49 = (physx::shdfnd::Foundation *)(*(uint64_t (**)(_QWORD, __int128 *))(**(_QWORD **)(a1 + 144) + 144))(*(_QWORD *)(a1 + 144), &v68);
  ControllerManager = PxCreateControllerManager(v49, 0, v50, v51, v52, v53, v54, v55);
  v57 = *(void (****)(_QWORD))(a1 + 160);
  if (v57)
    (**v57)(v57);
  *(_QWORD *)(a1 + 160) = ControllerManager;
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)ControllerManager + 104))(ControllerManager, 1);
  v58 = *(_QWORD *)(a1 + 152);
  if (v58)
    (*(void (**)(uint64_t))(*(_QWORD *)v58 + 16))(v58);
  *(_QWORD *)(a1 + 152) = v49;
  if ((v95[16] & 1) != 0)
    v59 = &v96[4];
  else
    v59 = *(_BYTE **)&v96[12];
  (*(void (**)(physx::shdfnd::Foundation *, _BYTE *, _QWORD))(*(_QWORD *)v49 + 96))(v49, v59, *(unsigned int *)&v95[8]);
  if ((v99 & 1) != 0)
    v60 = &v100;
  else
    v60 = v101;
  if (v98)
  {
    v61 = &v60[8 * v98];
    do
    {
      re::internal::PhysXCapsuleController::recreateUnderlying((_QWORD *)*v60, (float32x2_t *)v60 + 2, (uint64_t *)v60 + 4, a1, v60[6]);
      v60 += 8;
    }
    while (v60 != v61);
  }
  if (*(_QWORD *)(a1 + 256))
    re::PhysXDebugRenderer::setScene((_QWORD *)(a1 + 256), *(_QWORD *)(a1 + 152));
  if (*(_QWORD *)v95 && (v95[16] & 1) == 0)
    (*(void (**)(void))(**(_QWORD **)v95 + 40))();
  result = (uint64_t)v97;
  if (v97 && (v99 & 1) == 0)
    result = (*(uint64_t (**)(void))(*v97 + 40))();
  if (physx::shdfnd::g_isLockingEnabled != v63)
    physx::shdfnd::g_isLockingEnabled = v63;
  return result;
}

uint64_t SimulationFilterShader@<X0>(uint64_t result@<X0>, _DWORD *a2@<X1>, int a3@<W2>, _DWORD *a4@<X3>, __int16 *a5@<X4>, _WORD *a6@<X8>)
{
  __int16 v6;

  if ((a4[3] & a2[2]) != 0 && (a2[3] & a4[2]) != 0)
  {
    if (((a3 | result) & 0x20) != 0)
    {
      v6 = 1044;
    }
    else if (((*a4 | *a2) & 1) != 0)
    {
      if (((*a4 | *a2) & 2) != 0)
        v6 = 3597;
      else
        v6 = 1549;
      if ((result & a3 & 0x10) != 0)
        v6 = 1548;
      if ((*a2 & *a4 & 4) == 0)
        v6 = 1548;
    }
    else
    {
      v6 = 1548;
    }
    *a5 = v6;
  }
  *a6 = 0;
  return result;
}

uint64_t re::PhysXCollisionWorld::init(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, physx::shdfnd::Foundation *a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t ControllerManager;
  void (***v18)(_QWORD);
  uint64_t v20;
  float32x4_t v21;

  *(_QWORD *)(a1 + 56) = a2;
  re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::init(a1 + 72, a2, 3);
  *(_QWORD *)(a1 + 392) = a4;
  *(_QWORD *)(a1 + 400) = 0;
  if (a5)
  {
    v16 = *(_QWORD *)(a1 + 152);
    if (v16)
      (*(void (**)(uint64_t))(*(_QWORD *)v16 + 16))(v16);
    *(_QWORD *)(a1 + 152) = a5;
    ControllerManager = PxCreateControllerManager(a5, 0, v10, v11, v12, v13, v14, v15);
    v18 = *(void (****)(_QWORD))(a1 + 160);
    if (v18)
      (**v18)(v18);
    *(_QWORD *)(a1 + 160) = ControllerManager;
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)ControllerManager + 104))(ControllerManager, 1);
  }
  else
  {
    v20 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 72, 8);
    *(_QWORD *)v20 = &off_24ED40B60;
    *(_QWORD *)(v20 + 8) = a3;
    *(_BYTE *)(v20 + 16) = 0;
    *(_QWORD *)(v20 + 56) = 0;
    *(_DWORD *)(v20 + 64) = 0;
    *(_OWORD *)(v20 + 20) = 0u;
    *(_OWORD *)(v20 + 36) = 0u;
    *(_QWORD *)(a1 + 168) = v20;
    v21 = 0uLL;
    return re::PhysXCollisionWorld::createScene(a1, &v21, *(_DWORD *)(a1 + 384));
  }
}

uint64_t re::PhysXCollisionWorld::isMultithreadingEnabled(re::PhysXCollisionWorld *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 21);
  if (result)
    return (*(unsigned int (**)(uint64_t))(*(_QWORD *)result + 8))(result) != 0;
  return result;
}

uint64_t re::PhysXCollisionWorld::setIsMultithreadingEnabled(uint64_t this, int a2)
{
  uint64_t v2;
  BOOL v3;

  *(_BYTE *)(this + 388) = a2;
  if (!a2)
  {
    v2 = *(_QWORD *)(this + 168);
    if (!v2)
      return this;
    v3 = *(_BYTE *)(this + 389) != 0;
    goto LABEL_8;
  }
  if ((physx::shdfnd::g_alwaysUseLocking & 1) == 0)
    physx::shdfnd::g_alwaysUseLocking = 1;
  v2 = *(_QWORD *)(this + 168);
  if (v2)
  {
    v3 = 1;
LABEL_8:
    *(_BYTE *)(v2 + 16) = v3;
  }
  return this;
}

void re::PhysXCollisionWorld::reportCollisions(re::PhysXCollisionWorld *this)
{
  _QWORD v2[2];

  v2[0] = &off_24ED41188;
  v2[1] = (char *)this + 176;
  re::ContactSetCollection::set((uint64_t)this + 72, (uint64_t)v2);
  re::CollisionWorld::reportTriggerEvents(this);
}

BOOL re::PhysXCollisionWorld::canRecreateScene(re::PhysXCollisionWorld *this)
{
  uint64_t v2;
  int v3;
  BOOL v4;
  __int16 v6;

  v2 = *((_QWORD *)this + 19);
  v6 = 3;
  v3 = (*(uint64_t (**)(uint64_t, __int16 *))(*(_QWORD *)v2 + 152))(v2, &v6);
  if (*((_QWORD *)this + 21))
    v4 = v3 == 0;
  else
    v4 = 0;
  return v4
      && !(*(unsigned int (**)(_QWORD))(**((_QWORD **)this + 20) + 16))(*((_QWORD *)this + 20))
      && (*(unsigned int (**)(_QWORD))(**((_QWORD **)this + 20) + 64))(*((_QWORD *)this + 20)) == 0;
}

void re::PhysXCollisionWorld::update(re::PhysXCollisionWorld *this)
{
  int v2;
  re *v3;
  _QWORD v4[2];

  if (physx::shdfnd::g_isLockingEnabled)
    v2 = 1;
  else
    v2 = physx::shdfnd::g_alwaysUseLocking;
  if ((physx::shdfnd::g_alwaysUseLocking & 1) == 0 && physx::shdfnd::g_isLockingEnabled)
    physx::shdfnd::g_isLockingEnabled = 0;
  re::BucketArray<re::PhysXManifold,256ul>::clear((_QWORD *)this + 22);
  re::BucketArray<re::PhysXManifold,256ul>::setBucketsCapacity((uint64_t *)this + 22, (unint64_t)(*((_QWORD *)this + 27) + 255) >> 8);
  (*(void (**)(_QWORD, _QWORD, _QWORD, _QWORD, uint64_t, float))(**((_QWORD **)this + 19) + 400))(*((_QWORD *)this + 19), 0, 0, 0, 1, 0.016667);
  (*(void (**)(_QWORD, uint64_t, _QWORD))(**((_QWORD **)this + 19) + 440))(*((_QWORD *)this + 19), 1, 0);
  v3 = (re *)*((_QWORD *)this + 21);
  if (v3)
    re::PhysXCPUDispatcher::reset(v3);
  v4[0] = &off_24ED41188;
  v4[1] = (char *)this + 176;
  re::ContactSetCollection::set((uint64_t)this + 72, (uint64_t)v4);
  re::CollisionWorld::reportTriggerEvents(this);
  re::PhysXCollisionWorld::updateCharacterControllerVelocities(this);
  if (physx::shdfnd::g_isLockingEnabled != v2)
    physx::shdfnd::g_isLockingEnabled = v2;
}

_QWORD *re::BucketArray<re::PhysXManifold,256ul>::clear(_QWORD *result)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t i;
  uint64_t v4;

  v1 = (uint64_t)result;
  v2 = result[5];
  if (v2)
  {
    for (i = 0; i != v2; ++i)
    {
      v4 = re::BucketArray<re::PhysXManifold,256ul>::operator[](v1, i);
      result = *(_QWORD **)(v4 + 16);
      if (result)
      {
        if (*(_QWORD *)(v4 + 48))
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 40))(result);
        *(_QWORD *)(v4 + 48) = 0;
        *(_QWORD *)(v4 + 24) = 0;
        *(_QWORD *)(v4 + 32) = 0;
        *(_QWORD *)(v4 + 16) = 0;
        ++*(_DWORD *)(v4 + 40);
      }
    }
  }
  *(_QWORD *)(v1 + 40) = 0;
  ++*(_DWORD *)(v1 + 48);
  return result;
}

void re::PhysXCollisionWorld::updateCharacterControllerVelocities(re::PhysXCollisionWorld *this)
{
  int v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  re::internal::PhysXCapsuleController *v6;
  double v7;

  v2 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 20) + 16))(*((_QWORD *)this + 20));
  if (v2 >= 1)
  {
    v3 = v2;
    v4 = 0;
    do
    {
      v5 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)this + 20) + 24))(*((_QWORD *)this + 20), v4);
      v6 = (re::internal::PhysXCapsuleController *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 160))(v5);
      re::internal::PhysXCapsuleController::updateVelocity(v6, v7);
      v4 = (v4 + 1);
    }
    while (v3 != (_DWORD)v4);
  }
}

void re::PhysXCollisionWorld::updateFromPhysics(re::PhysXCollisionWorld *this)
{
  int v2;
  re *v3;
  _BYTE v4[16];

  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v4, 7022, (uint64_t)this);
  if (physx::shdfnd::g_isLockingEnabled)
    v2 = 1;
  else
    v2 = physx::shdfnd::g_alwaysUseLocking;
  if ((physx::shdfnd::g_alwaysUseLocking & 1) == 0 && physx::shdfnd::g_isLockingEnabled)
    physx::shdfnd::g_isLockingEnabled = 0;
  re::BucketArray<re::PhysXManifold,256ul>::clear((_QWORD *)this + 22);
  re::BucketArray<re::PhysXManifold,256ul>::setBucketsCapacity((uint64_t *)this + 22, (unint64_t)(*((_QWORD *)this + 27) + 255) >> 8);
  (*(void (**)(_QWORD, uint64_t, _QWORD))(**((_QWORD **)this + 19) + 440))(*((_QWORD *)this + 19), 1, 0);
  v3 = (re *)*((_QWORD *)this + 21);
  if (v3)
    re::PhysXCPUDispatcher::reset(v3);
  if (physx::shdfnd::g_isLockingEnabled != v2)
    physx::shdfnd::g_isLockingEnabled = v2;
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v4);
}

BOOL re::PhysXCollisionWorld::doContactTest(re::PhysXCollisionWorld *this, re::CollisionObject *a2)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  BOOL v10;
  uint64_t v11;
  uint64_t v12;
  float v14[7];
  _QWORD v15[3];
  int v16;
  _QWORD v17[2];
  __int16 v18;
  _QWORD v19[3];
  int v20;
  char v21;
  _QWORD *v22;
  uint64_t v23;
  _QWORD v24[2];
  int v25;
  _QWORD *v26;
  _QWORD v27[8];

  v27[6] = *MEMORY[0x24BDAC8D0];
  if (physx::shdfnd::g_isLockingEnabled)
    v4 = 1;
  else
    v4 = physx::shdfnd::g_alwaysUseLocking;
  if ((physx::shdfnd::g_alwaysUseLocking & 1) == 0 && physx::shdfnd::g_isLockingEnabled)
    physx::shdfnd::g_isLockingEnabled = 0;
  v24[0] = 0;
  v24[1] = 0;
  v25 = -1;
  v19[1] = 0;
  v19[2] = 0;
  v20 = -1;
  v21 = 0;
  v22 = v24;
  v23 = 1;
  v19[0] = off_24ED410D8;
  v17[0] = 0;
  v17[1] = 0;
  v18 = 7;
  v15[0] = off_24ED41130;
  v15[1] = 0;
  v5 = *((_QWORD *)a2 + 3);
  v6 = *((_QWORD *)a2 + 4);
  v15[2] = v6;
  v16 = 1;
  v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 184))(v5);
  if (v7)
  {
    v8 = v7;
    v9 = 0;
    v10 = 1;
    do
    {
      v11 = re::PhysXCollisionObject::pxShape((uint64_t)a2, v9, v14);
      v12 = *((_QWORD *)this + 19);
      (*(void (**)(_QWORD *__return_ptr))(*(_QWORD *)v11 + 80))(v27);
      v26 = v27;
      if ((*(unsigned int (**)(uint64_t, _QWORD *, float *, _QWORD *, _QWORD *, _QWORD *))(*(_QWORD *)v12 + 712))(v12, v27, v14, v19, v17, v15))
      {
        break;
      }
      v9 = (v9 + 1);
      v10 = v9 < v8;
    }
    while (v8 != (_DWORD)v9);
  }
  else
  {
    v10 = 0;
  }
  if (physx::shdfnd::g_isLockingEnabled != v4)
    physx::shdfnd::g_isLockingEnabled = v4;
  return v10;
}

uint64_t re::PhysXCollisionWorld::doContactPairTest(re::PhysXCollisionWorld *this, re::CollisionObject *a2, re::CollisionObject *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint32x4_t v9;
  uint32x4_t v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t result;
  float v20[7];
  float32x4_t v21[2];
  float32x4_t *v22;
  float32x4_t v23[3];
  _QWORD v24[8];

  v24[6] = *MEMORY[0x24BDAC8D0];
  v5 = *((_QWORD *)a2 + 2);
  v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 24))(v5);
  (*(void (**)(_QWORD *__return_ptr, uint64_t))(*(_QWORD *)v5 + 40))(v24, v5);
  (*(void (**)(float32x4_t *__return_ptr, uint64_t, _QWORD *))(*(_QWORD *)v6 + 16))(v23, v6, v24);
  v7 = *((_QWORD *)a3 + 2);
  v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 24))(v7);
  (*(void (**)(_QWORD *__return_ptr, uint64_t))(*(_QWORD *)v7 + 40))(v24, v7);
  (*(void (**)(float32x4_t *__return_ptr, uint64_t, _QWORD *))(*(_QWORD *)v8 + 16))(v21, v8, v24);
  v9 = (uint32x4_t)vcgtq_f32(v23[0], v21[1]);
  v9.i32[3] = v9.i32[2];
  if ((vmaxvq_u32(v9) & 0x80000000) != 0)
    return 0;
  v10 = (uint32x4_t)vcgtq_f32(v21[0], v23[1]);
  v10.i32[3] = v10.i32[2];
  if ((vmaxvq_u32(v10) & 0x80000000) != 0)
    return 0;
  v11 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)a2 + 3) + 184))(*((_QWORD *)a2 + 3));
  v12 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)a3 + 3) + 184))(*((_QWORD *)a3 + 3));
  if (!v11)
    return 0;
  v13 = v12;
  v14 = 0;
  while (1)
  {
    v15 = re::PhysXCollisionObject::pxShape((uint64_t)a2, v14, v21[0].f32);
    if (v13)
      break;
LABEL_9:
    result = 0;
    v14 = (v14 + 1);
    if ((_DWORD)v14 == v11)
      return result;
  }
  v16 = v15;
  v17 = 0;
  while (1)
  {
    v18 = re::PhysXCollisionObject::pxShape((uint64_t)a3, v17, v20);
    (*(void (**)(_QWORD *__return_ptr, uint64_t))(*(_QWORD *)v16 + 80))(v24, v16);
    v23[0].i64[0] = (uint64_t)v24;
    (*(void (**)(float32x4_t *__return_ptr, uint64_t))(*(_QWORD *)v18 + 80))(v23, v18);
    v22 = v23;
    if (physx::PxGeometryQuery::overlap((int *)v24, (uint64_t)v21, (int *)v23, (uint64_t)v20))
      return 1;
    v17 = (v17 + 1);
    if (v13 == (_DWORD)v17)
      goto LABEL_9;
  }
}

uint64_t re::PhysXCollisionWorld::rayCast(uint64_t a1, uint64_t a2, unsigned __int8 *a3, unint64_t a4)
{
  int v8;
  uint64_t v9;
  unsigned int v10;
  int v11;
  uint64_t v12;
  _QWORD *v13;
  __int16 v14;
  int v15;
  uint64_t v16;
  uint64_t result;
  __int16 v18;
  _QWORD v19[3];
  int v20;
  _QWORD v21[2];
  __int16 v22;
  _QWORD v23[3];
  int v24;
  __int16 v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  char v31;
  uint64_t *v32;
  int v33;
  int v34;
  unint64_t v35;
  uint64_t v36;
  char v37;
  int v38;

  if (physx::shdfnd::g_isLockingEnabled)
    v8 = 1;
  else
    v8 = physx::shdfnd::g_alwaysUseLocking;
  if ((physx::shdfnd::g_alwaysUseLocking & 1) == 0 && physx::shdfnd::g_isLockingEnabled)
    physx::shdfnd::g_isLockingEnabled = 0;
  re::BucketArray<re::CollisionCastHit,10ul>::clear(a4);
  v10 = *a3;
  v11 = *(_DWORD *)(a2 + 32);
  v23[1] = 0;
  v23[2] = 0;
  v24 = -1;
  v25 = 0;
  v27 = 0;
  v28 = 0;
  v26 = 0;
  v29 = 2139095039;
  v30 = 0;
  v31 = 0;
  v32 = &v36;
  v33 = 32 * (v10 == 1);
  v34 = 0;
  v23[0] = off_24ED40FD0;
  v12 = 13;
  v35 = a4;
  do
  {
    v13 = &v23[v12];
    *v13 = 0;
    v13[1] = 0;
    *((_DWORD *)v13 + 4) = -1;
    *((_WORD *)v13 + 10) = 0;
    v13[4] = 0;
    v13[5] = 0;
    v13[3] = 0;
    v13[6] = 2139095039;
    v12 += 8;
    *((_DWORD *)v13 + 14) = 0;
  }
  while (v13 + 8 != (_QWORD *)&v37);
  v37 = v10;
  v38 = v11;
  if (v10 >= 3)
  {
    re::internal::assertLog((re::internal *)4, v9, "assertion failure: '%s' (%s:line %i) Unsupported collision query type!", "!\"Unreachable code\"", "toPhysX", 89);
    result = _os_crash();
    __break(1u);
  }
  else
  {
    v14 = 32 * v10 + 1027;
    v21[0] = 0;
    v21[1] = 0;
    v22 = 7;
    v19[0] = off_24ED41130;
    v19[1] = 0;
    v19[2] = *(_QWORD *)(a3 + 4);
    if (v10 == 1)
      v15 = 1;
    else
      v15 = 2;
    v20 = v15;
    v16 = *(_QWORD *)(a1 + 152);
    v18 = v14;
    result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD *, __int16 *, _QWORD *, _QWORD *, _QWORD))(*(_QWORD *)v16 + 696))(v16, a2, a2 + 16, v23, &v18, v21, v19, 0);
    if (physx::shdfnd::g_isLockingEnabled != v8)
      physx::shdfnd::g_isLockingEnabled = v8;
  }
  return result;
}

unint64_t re::BucketArray<re::CollisionCastHit,10ul>::clear(unint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t i;

  v1 = result;
  v2 = *(_QWORD *)(result + 40);
  if (v2)
  {
    for (i = 0; i != v2; ++i)
      result = re::BucketArray<re::CollisionCastHit,10ul>::operator[](v1, i);
  }
  *(_QWORD *)(v1 + 40) = 0;
  ++*(_DWORD *)(v1 + 48);
  return result;
}

uint64_t re::PhysXCollisionWorld::convexCast(uint64_t a1, uint64_t a2, float32x4_t *a3, float32x4_t *a4, unsigned __int8 *a5, unint64_t a6)
{
  int v10;
  float32x4_t v11;
  float32x4_t v12;
  float v13;
  uint64_t result;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  _QWORD *v18;
  _QWORD v19[3];
  int v20;
  __int16 v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  char v26;
  uint64_t *v27;
  int v28;
  int v29;
  unint64_t v30;
  uint64_t v31;
  char v32;
  float v33;
  float32x4_t v34;

  if (physx::shdfnd::g_isLockingEnabled)
    v10 = 1;
  else
    v10 = physx::shdfnd::g_alwaysUseLocking;
  if ((physx::shdfnd::g_alwaysUseLocking & 1) == 0 && physx::shdfnd::g_isLockingEnabled)
    physx::shdfnd::g_isLockingEnabled = 0;
  v11 = vsubq_f32(*a4, *a3);
  v12 = vmulq_f32(v11, v11);
  v13 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 2), vaddq_f32(v12, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 1))).f32[0]);
  v34 = vmulq_n_f32(v11, 1.0 / v13);
  result = re::BucketArray<re::CollisionCastHit,10ul>::clear(a6);
  v15 = *(_QWORD *)(a2 + 8);
  if (v15)
  {
    v16 = *a5;
    v19[1] = 0;
    v19[2] = 0;
    v20 = -1;
    v21 = 0;
    v22 = 0;
    v23 = 0;
    v24 = 0;
    v25 = 2139095039;
    v26 = 0;
    v27 = &v31;
    v28 = 32 * (v16 == 1);
    v29 = 0;
    v19[0] = off_24ED41018;
    v30 = a6;
    v17 = 12;
    do
    {
      v18 = &v19[v17];
      *v18 = 0;
      v18[1] = 0;
      *((_DWORD *)v18 + 4) = -1;
      *((_WORD *)v18 + 10) = 0;
      v18[4] = 0;
      v18[5] = 0;
      v18[3] = 0;
      v17 += 7;
      *((_DWORD *)v18 + 12) = 2139095039;
    }
    while (v18 + 7 != (_QWORD *)&v32);
    v32 = v16;
    v33 = v13;
    if (v16 >= 3)
    {
      re::internal::assertLog((re::internal *)4, v15, "assertion failure: '%s' (%s:line %i) Unsupported collision query type!", "!\"Unreachable code\"", "toPhysX", 89);
      result = _os_crash();
      __break(1u);
      return result;
    }
    result = (*(uint64_t (**)(_QWORD, float, float))(**(_QWORD **)(a1 + 152) + 704))(*(_QWORD *)(a1 + 152), v13, 0.0);
  }
  if (physx::shdfnd::g_isLockingEnabled != v10)
    physx::shdfnd::g_isLockingEnabled = v10;
  return result;
}

uint64_t re::PhysXCollisionWorld::contacts(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t result;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  __int16 v13;
  uint64_t v14;
  int v15;
  float v16[7];
  _QWORD v17[3];
  int v18;
  __int16 v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  char v24;
  uint64_t *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _QWORD v30[3];
  int v31;
  _QWORD v32[2];
  __int16 v33;
  _QWORD v34[7];

  v34[6] = *MEMORY[0x24BDAC8D0];
  v32[1] = 0;
  v32[0] = 0;
  v33 = 7;
  v5 = *(_QWORD *)(a2 + 32);
  v30[0] = off_24ED41130;
  v30[1] = 0;
  v30[2] = v5;
  v31 = 1;
  v17[1] = 0;
  v17[2] = 0;
  v18 = -1;
  v19 = 0;
  v21 = 0;
  v22 = 0;
  v20 = 0;
  v23 = 2139095039;
  v24 = 0;
  v25 = &v29;
  v17[0] = off_24ED41070;
  v27 = a2;
  v28 = a3;
  v6 = 13;
  v26 = 32;
  do
  {
    v7 = &v17[v6];
    *v7 = 0;
    v7[1] = 0;
    *((_DWORD *)v7 + 4) = -1;
    *((_WORD *)v7 + 10) = 0;
    v7[4] = 0;
    v7[5] = 0;
    v7[3] = 0;
    v6 += 7;
    *((_DWORD *)v7 + 12) = 2139095039;
  }
  while (v7 + 7 != v30);
  result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a2 + 24) + 184))(*(_QWORD *)(a2 + 24));
  if ((_DWORD)result)
  {
    v9 = result;
    v10 = 0;
    do
    {
      v11 = re::PhysXCollisionObject::pxShape(a2, v10, v16);
      v12 = *(_QWORD *)(a1 + 152);
      (*(void (**)(_QWORD *__return_ptr))(*(_QWORD *)v11 + 80))(v34);
      v14 = 0;
      v15 = 1065353216;
      v13 = 512;
      result = (*(uint64_t (**)(uint64_t, _QWORD *, float *, uint64_t *, _QWORD *, __int16 *, _QWORD *, _QWORD *, float, float, _QWORD))(*(_QWORD *)v12 + 704))(v12, v34, v16, &v14, v17, &v13, v32, v30, 0.0, 0.0, 0);
      v10 = (v10 + 1);
    }
    while (v9 != (_DWORD)v10);
  }
  return result;
}

uint64_t re::PhysXCollisionWorld::overlap@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, int a4@<W3>, uint64_t a5@<X8>)
{
  uint64_t v10;
  _anonymous_namespace_ *v11;
  int v12;
  unint64_t v13;
  uint64_t v14;
  unsigned int v15;
  int v16;
  uint64_t v17;
  unint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t result;
  _QWORD v22[2];
  __int16 v23;
  uint64_t (**v24)();
  _QWORD v25[2];
  int v26;
  unsigned __int8 v27;
  uint64_t v28;
  int v29;
  unsigned int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  __int16 v34;

  v10 = *(_QWORD *)(a1 + 152);
  v34 = 2;
  v11 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, __int16 *))(*(_QWORD *)v10 + 152))(v10, &v34);
  v12 = (int)v11;
  v13 = v11;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  v25[0] = 0;
  v25[1] = 0;
  v26 = -1;
  v27 = 0;
  v28 = v33;
  v29 = v12;
  v30 = 0;
  v24 = off_24ED410D8;
  v14 = *(_QWORD *)(a1 + 152);
  v22[0] = 0;
  v22[1] = 0;
  v23 = 3;
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t (***)(), _QWORD *, _QWORD))(*(_QWORD *)v14
                                                                                                  + 712))(v14, a2, a3, &v24, v22, 0);
  *(_QWORD *)(a5 + 32) = 0;
  *(_QWORD *)(a5 + 8) = 0;
  *(_QWORD *)(a5 + 16) = 0;
  *(_QWORD *)a5 = 0;
  *(_DWORD *)(a5 + 24) = 0;
  v15 = v30;
  v16 = v27;
  if (v30 + v27)
  {
    v17 = 0;
    v18 = 0;
    do
    {
      v19 = (_QWORD *)(v28 + v17);
      if (v18 >= v15)
        v19 = v25;
      v20 = *(_QWORD *)(*v19 + 16);
      if ((*(_DWORD *)(v20 + 32) & a4) != 0)
      {
        v22[0] = v20;
        re::DynamicArray<re::CollisionObject *>::add((_QWORD *)a5, v22);
        v15 = v30;
        v16 = v27;
      }
      ++v18;
      v17 += 24;
    }
    while (v18 < v15 + v16);
  }
  result = v31;
  if (v31)
  {
    if (v32)
      return (*(uint64_t (**)(void))(*(_QWORD *)v31 + 40))();
  }
  return result;
}

_QWORD *re::DynamicArray<re::CollisionObject *>::add(_QWORD *this, _QWORD *a2)
{
  _QWORD *v3;
  unint64_t v4;

  v3 = this;
  v4 = this[2];
  if (v4 >= this[1])
  {
    this = re::DynamicArray<re::CollisionObject *>::growCapacity(this, v4 + 1);
    v4 = v3[2];
  }
  *(_QWORD *)(v3[4] + 8 * v4) = *a2;
  v3[2] = v4 + 1;
  ++*((_DWORD *)v3 + 6);
  return this;
}

uint64_t re::PhysXCollisionWorld::overlaps(re::PhysXCollisionWorld *this, re::CollisionObject *a2, re::ContactSetCollection *a3)
{
  uint64_t v6;
  _anonymous_namespace_ *v7;
  int v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  unint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t result;
  __int128 v19;
  uint64_t v20;
  int v21;
  _QWORD v22[3];
  int v23;
  _QWORD v24[2];
  __int16 v25;
  uint64_t (**v26)();
  _QWORD v27[2];
  int v28;
  unsigned __int8 v29;
  uint64_t v30;
  int v31;
  unsigned int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  __int16 v36;
  uint64_t v37;
  re::CollisionObject *v38;
  __int128 v39;
  uint64_t v40;
  int v41;
  _QWORD v42[2];
  __int128 v43;
  __int128 v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;

  v48 = *MEMORY[0x24BDAC8D0];
  v6 = *((_QWORD *)this + 19);
  v36 = 3;
  v7 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, __int16 *))(*(_QWORD *)v6 + 152))(v6, &v36);
  v8 = (int)v7;
  v9 = v7;
  v33 = 0;
  v34 = 0;
  v35 = 0;
  v27[0] = 0;
  v27[1] = 0;
  v28 = -1;
  v29 = 0;
  v30 = v35;
  v31 = v8;
  v32 = 0;
  v26 = off_24ED410D8;
  v24[0] = 0;
  v24[1] = 0;
  v25 = 7;
  v10 = *((_QWORD *)a2 + 4);
  v22[0] = off_24ED41130;
  v22[1] = 0;
  v22[2] = v10;
  v23 = 1;
  v11 = *(_QWORD *)((*(uint64_t (**)(_QWORD))(**((_QWORD **)a2 + 2) + 16))(*((_QWORD *)a2 + 2)) + 8);
  (*(void (**)(uint64_t *__return_ptr))(**((_QWORD **)a2 + 2) + 40))(&v37);
  v19 = v39;
  v20 = v37;
  v21 = (int)v38;
  (*(void (**)(_QWORD, uint64_t, __int128 *, uint64_t (***)(), _QWORD *, _QWORD *))(**((_QWORD **)this + 19) + 712))(*((_QWORD *)this + 19), v11, &v19, &v26, v24, v22);
  v12 = v32;
  if (v32 + v29)
  {
    v13 = 0;
    v14 = 0;
    do
    {
      if (v14 >= v12)
        v15 = v27;
      else
        v15 = (_QWORD *)(v30 + v13);
      v16 = *(_QWORD *)(*v15 + 16);
      v17 = *(_QWORD *)a3;
      v43 = 0u;
      v44 = 0u;
      v45 = 0;
      v40 = 0;
      v41 = 0;
      v42[0] = 0;
      *(_DWORD *)((char *)v42 + 7) = 0;
      v46 = 0;
      v47 = 0;
      v37 = v16;
      v38 = a2;
      v39 = v17;
      re::DynamicArray<re::Contact>::setCapacity(&v39, 0);
      ++v41;
      re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::addNew((uint64_t)a3, &v37);
      re::ContactSet::~ContactSet((re::ContactSet *)&v37);
      ++v14;
      v12 = v32;
      v13 += 24;
    }
    while (v14 < v32 + v29);
  }
  result = v33;
  if (v33)
  {
    if (v34)
      return (*(uint64_t (**)(void))(*(_QWORD *)v33 + 40))();
  }
  return result;
}

void re::PhysXCollisionWorld::contacts(re::PhysXCollisionWorld *this, re::CollisionObject *a2, re::CollisionObject *a3, re::ContactSet *a4)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  BOOL v8;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint32x4_t v16;
  uint32x4_t v17;
  int v18;
  int v19;
  int v20;
  uint64_t v21;
  _anonymous_namespace_ *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  float32x4_t v27;
  int v28;
  float v29;
  float32x2_t v30;
  int v31;
  float v32[7];
  float v33[7];
  float32x4_t v34[2];
  float32x4_t v35[3];
  uint64_t v36;
  uint64_t v37;
  float v38;
  float32x4_t v39[3];
  uint64_t v40;

  v40 = *MEMORY[0x24BDAC8D0];
  *((_QWORD *)a4 + 4) = 0;
  ++*((_DWORD *)a4 + 10);
  v4 = *((_QWORD *)a2 + 4);
  v5 = *((_QWORD *)a3 + 4);
  v6 = v5 & HIDWORD(v4);
  v7 = v4 & HIDWORD(v5);
  if (v6)
    v8 = v7 == 0;
  else
    v8 = 1;
  if (!v8)
  {
    *(_QWORD *)a4 = a2;
    *((_QWORD *)a4 + 1) = a3;
    v12 = *((_QWORD *)a2 + 2);
    v13 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v12 + 24))(v12);
    (*(void (**)(float32x4_t *__return_ptr, uint64_t))(*(_QWORD *)v12 + 40))(v35, v12);
    (*(void (**)(float32x4_t *__return_ptr, uint64_t, float32x4_t *))(*(_QWORD *)v13 + 16))(v39, v13, v35);
    v14 = *((_QWORD *)a3 + 2);
    v15 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v14 + 24))(v14);
    (*(void (**)(float32x4_t *__return_ptr, uint64_t))(*(_QWORD *)v14 + 40))(v35, v14);
    (*(void (**)(float32x4_t *__return_ptr, uint64_t, float32x4_t *))(*(_QWORD *)v15 + 16))(v34, v15, v35);
    v16 = (uint32x4_t)vcgtq_f32(v39[0], v34[1]);
    v16.i32[3] = v16.i32[2];
    if ((vmaxvq_u32(v16) & 0x80000000) == 0)
    {
      v17 = (uint32x4_t)vcgtq_f32(v34[0], v39[1]);
      v17.i32[3] = v17.i32[2];
      if ((vmaxvq_u32(v17) & 0x80000000) == 0)
      {
        v18 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)a2 + 3) + 184))(*((_QWORD *)a2 + 3));
        v19 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)a3 + 3) + 184))(*((_QWORD *)a3 + 3));
        if (v18)
        {
          v20 = v19;
          v21 = 0;
          v22 = (re::ContactSet *)((char *)a4 + 16);
          while (1)
          {
            v28 = v21;
            v23 = re::PhysXCollisionObject::pxShape((uint64_t)a2, v21, v33);
            if (v20)
              break;
LABEL_13:
            v21 = (v28 + 1);
            if ((_DWORD)v21 == v18)
              return;
          }
          v24 = v23;
          v25 = 0;
          while (1)
          {
            v26 = re::PhysXCollisionObject::pxShape((uint64_t)a3, v25, v32);
            v29 = 0.0;
            (*(void (**)(float32x4_t *__return_ptr, uint64_t))(*(_QWORD *)v24 + 80))(v35, v24);
            v39[0].i64[0] = (uint64_t)v35;
            (*(void (**)(float32x4_t *__return_ptr, uint64_t))(*(_QWORD *)v26 + 80))(v39, v26);
            v34[0].i64[0] = (uint64_t)v39;
            if (!physx::PxGeometryQuery::computePenetration(&v30, (uint64_t)&v29, (int *)v35, (uint64_t)v33, (int *)v39, (uint64_t)v32))break;
            (*(void (**)(float32x4_t *__return_ptr))(**((_QWORD **)a2 + 2) + 40))(v39);
            (*(void (**)(float32x4_t *__return_ptr))(**((_QWORD **)a3 + 2) + 40))(v34);
            *(float32x2_t *)v27.f32 = v30;
            v27.i32[2] = v31;
            v35[0] = v39[0];
            v35[1] = v34[0];
            v35[2] = v27;
            v36 = 0;
            v37 = 0;
            v38 = -v29;
            re::DynamicArray<re::Contact>::add(v22, (uint64_t)v35);
            v25 = (v25 + 1);
            if (v20 == (_DWORD)v25)
              goto LABEL_13;
          }
        }
      }
    }
  }
}

float re::PhysXCollisionWorld::closestPoint(uint64_t a1, float32x2_t *a2, uint64_t a3, uint64_t a4)
{
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  float v11;
  uint64_t v12;
  double v13;
  double v14;
  double v15;
  int32x4_t v16;
  float v17;
  float32x2_t v18;
  float32x2_t v19;
  float32x2_t v20;
  _QWORD *v22;
  int v23;
  float32x2_t v24;
  __int32 v25;
  float v26[7];
  _QWORD v27[7];

  v27[6] = *MEMORY[0x24BDAC8D0];
  *(_OWORD *)a4 = *(_OWORD *)a2->f32;
  if (physx::shdfnd::g_isLockingEnabled)
    v7 = 1;
  else
    v7 = physx::shdfnd::g_alwaysUseLocking;
  if ((physx::shdfnd::g_alwaysUseLocking & 1) == 0 && physx::shdfnd::g_isLockingEnabled)
    physx::shdfnd::g_isLockingEnabled = 0;
  v8 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a3 + 24) + 184))(*(_QWORD *)(a3 + 24));
  if (v8)
  {
    v9 = v8;
    v10 = 0;
    v11 = INFINITY;
    do
    {
      v12 = re::PhysXCollisionObject::pxShape(a3, v10, v26);
      v24 = *a2;
      v25 = a2[1].i32[0];
      (*(void (**)(_QWORD *__return_ptr))(*(_QWORD *)v12 + 80))(v27);
      v22 = v27;
      physx::PxGeometryQuery::pointDistance(&v24, (uint64_t)v27, (uint64_t)v26, (float32x2_t *)&v22, v13, v14, v15, v16);
      if (v17 < 0.0)
        v17 = INFINITY;
      if (v17 < v11)
      {
        if (v17 <= 0.0)
        {
          v20 = *a2;
          v19 = a2[1];
        }
        else
        {
          v18.i32[0] = v23;
          v19 = v18;
          v20 = (float32x2_t)v22;
        }
        *(float32x2_t *)a4 = v20;
        *(float32x2_t *)(a4 + 8) = v19;
        v11 = v17;
      }
      v10 = (v10 + 1);
    }
    while (v9 != (_DWORD)v10);
  }
  else
  {
    v11 = INFINITY;
  }
  if (physx::shdfnd::g_isLockingEnabled != v7)
    physx::shdfnd::g_isLockingEnabled = v7;
  return v11;
}

void re::PhysXCollisionWorld::closestPointToRayRadian(uint64_t a1, float32x4_t *a2, uint64_t a3, int8x16_t *a4)
{
  int v7;
  float32x4_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  float32x4_t v12;
  int32x4_t v13;
  float32x2_t v14;
  float32x2_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  float32x4_t v20;
  int8x16_t v21;
  float32x4_t v22;
  float32x4_t v23;
  int8x16_t v24;
  float32x4_t v25;
  int8x16_t v26;
  float32x4_t v27;
  float32x4_t v28;
  int8x16_t v29;
  float32x4_t v30;
  int8x16_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float v34;
  int v35;
  int v36;
  float32x4_t v37;
  int v38;
  int v39;
  float32x4_t v40;
  int v41;
  float32x4_t v42;
  float32x4_t v43;
  int32x4_t v44;
  float32x2_t v45;
  float32x2_t v46;
  float32x4_t v47;
  float v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  int8x16_t v59;
  float32x4_t v60;
  int8x16_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x2_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  int8x16_t v72;
  int v73;
  float32x2_t v74;
  float v75;
  float v76[7];
  _QWORD v77[5];
  float v78;
  float32x4_t v79;
  int32x4_t v80;
  float32x4_t v81;

  v7 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a3 + 24) + 184))(*(_QWORD *)(a3 + 24));
  if (v7)
  {
    v9 = v7;
    v10 = 0;
    v8.i32[0] = 0;
    v62 = v8;
    v61 = 0u;
    do
    {
      v11 = re::PhysXCollisionObject::pxShape(a3, v10, v76);
      if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v11 + 64))(v11) == 3)
      {
        v73 = 3;
        v74 = 0;
        v75 = 0.0;
        (*(void (**)(uint64_t, int *))(*(_QWORD *)v11 + 88))(v11, &v73);
        v12 = a2[1];
        v13 = (int32x4_t)vmulq_f32(v12, v12);
        v13.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v13, 2), vadd_f32(*(float32x2_t *)v13.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v13.i8, 1))).u32[0];
        v14 = vrsqrte_f32((float32x2_t)v13.u32[0]);
        v15 = vmul_f32(v14, vrsqrts_f32((float32x2_t)v13.u32[0], vmul_f32(v14, v14)));
        v70 = vmulq_n_f32(v12, vmul_f32(v15, vrsqrts_f32((float32x2_t)v13.u32[0], vmul_f32(v15, v15))).f32[0]);
        v72 = 0u;
        v81 = v70;
        re::internal::nvphysx::fromPhysX((uint64_t)v76, &v79);
        v16 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v80, v80), (int8x16_t)v80, 0xCuLL);
        v17 = vnegq_f32((float32x4_t)v80);
        v18 = vmlaq_f32(vmulq_f32((float32x4_t)v80, (float32x4_t)xmmword_2261027B0), (float32x4_t)xmmword_2260E5F10, v16);
        v19 = (int8x16_t)vaddq_f32(v18, v18);
        v20 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v19, (int32x4_t)v19), v19, 0xCuLL);
        v21 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v20, (int32x4_t)v20), (int8x16_t)v20, 0xCuLL), v17), v20, v16);
        v22 = vaddq_f32(vaddq_f32(vmulq_laneq_f32(v20, (float32x4_t)v80, 3), (float32x4_t)xmmword_2260E5F10), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v21, (int32x4_t)v21), v21, 0xCuLL));
        v23 = vmlaq_f32(vmulq_f32((float32x4_t)v80, (float32x4_t)xmmword_2261027C0), (float32x4_t)xmmword_2260E5F20, v16);
        v24 = (int8x16_t)vaddq_f32(v23, v23);
        v25 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v24, (int32x4_t)v24), v24, 0xCuLL);
        v26 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v25, (int32x4_t)v25), (int8x16_t)v25, 0xCuLL), v17), v25, v16);
        v27 = vaddq_f32(vaddq_f32(vmulq_laneq_f32(v25, (float32x4_t)v80, 3), (float32x4_t)xmmword_2260E5F20), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v26, (int32x4_t)v26), v26, 0xCuLL));
        v28 = vmlaq_f32(vmulq_f32((float32x4_t)v80, (float32x4_t)xmmword_2261027D0), (float32x4_t)xmmword_2260E5F40, v16);
        v29 = (int8x16_t)vaddq_f32(v28, v28);
        v30 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v29, (int32x4_t)v29), v29, 0xCuLL);
        v31 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v30, (int32x4_t)v30), (int8x16_t)v30, 0xCuLL), v17), v30, v16);
        v32 = vaddq_f32(vaddq_f32(vmulq_laneq_f32(v30, (float32x4_t)v80, 3), (float32x4_t)xmmword_2260E5F40), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v31, (int32x4_t)v31), v31, 0xCuLL));
        v33 = *a2;
        v34 = 0.0;
        v35 = -1;
        do
        {
          v36 = v35;
          v37 = vaddq_f32(v79, vmulq_n_f32(v22, v74.f32[0] * (float)v35));
          v38 = -1;
          do
          {
            v39 = v38;
            v40 = vaddq_f32(v37, vmulq_n_f32(v27, v74.f32[1] * (float)v38));
            v41 = -3;
            do
            {
              v42 = vaddq_f32(v40, vmulq_n_f32(v32, v75 * (float)(v41 + 2)));
              v43 = vsubq_f32(v42, v33);
              v44 = (int32x4_t)vmulq_f32(v43, v43);
              v44.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v44, 2), vadd_f32(*(float32x2_t *)v44.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v44.i8, 1))).u32[0];
              v45 = vrsqrte_f32((float32x2_t)v44.u32[0]);
              v46 = vmul_f32(v45, vrsqrts_f32((float32x2_t)v44.u32[0], vmul_f32(v45, v45)));
              v47 = vmulq_f32(v70, vmulq_n_f32(v43, vmul_f32(v46, vrsqrts_f32((float32x2_t)v44.u32[0], vmul_f32(v46, v46))).f32[0]));
              v48 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v47, 2), vaddq_f32(v47, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v47.f32, 1))).f32[0];
              if (v48 > v34)
              {
                v72 = (int8x16_t)v42;
                v34 = v48;
              }
              v41 += 2;
            }
            while (v41 < 0);
            v38 = v39 + 2;
          }
          while (v39 < 0);
          v35 = v36 + 2;
        }
        while (v36 < 0);
        v78 = v34;
        v77[0] = a2;
        v77[1] = &v81;
        v77[2] = a2;
        v77[3] = &v78;
        v77[4] = &v72;
        v68 = v22;
        v71 = vmulq_n_f32(v22, v74.f32[0]);
        v65 = vmulq_n_f32(v27, -v74.f32[1]);
        v66 = v74;
        v49 = vaddq_f32(v65, vaddq_f32(v79, v71));
        v63 = vmulq_n_f32(v32, v75);
        v64 = vmulq_n_f32(v32, -v75);
        v60 = v27;
        boxClosestPointToRayRadian(re::RayF const&,physx::PxBoxGeometry const&,physx::PxTransform const&,re::Vector3<float> &)::$_3::operator()((uint64_t)v77, vaddq_f32(v63, v49), vaddq_f32(v64, v49));
        v69 = vmulq_n_f32(v68, -v66.f32[0]);
        boxClosestPointToRayRadian(re::RayF const&,physx::PxBoxGeometry const&,physx::PxTransform const&,re::Vector3<float> &)::$_3::operator()((uint64_t)v77, vaddq_f32(v64, vaddq_f32(v65, vaddq_f32(v71, v79))), vaddq_f32(v64, vaddq_f32(v65, vaddq_f32(v69, v79))));
        v50 = vaddq_f32(v65, vaddq_f32(v69, v79));
        boxClosestPointToRayRadian(re::RayF const&,physx::PxBoxGeometry const&,physx::PxTransform const&,re::Vector3<float> &)::$_3::operator()((uint64_t)v77, vaddq_f32(v64, v50), vaddq_f32(v63, v50));
        boxClosestPointToRayRadian(re::RayF const&,physx::PxBoxGeometry const&,physx::PxTransform const&,re::Vector3<float> &)::$_3::operator()((uint64_t)v77, vaddq_f32(v63, vaddq_f32(v65, vaddq_f32(v69, v79))), vaddq_f32(v63, vaddq_f32(v65, vaddq_f32(v71, v79))));
        v51 = vaddq_f32(v71, v79);
        v67 = vmulq_lane_f32(v60, v66, 1);
        boxClosestPointToRayRadian(re::RayF const&,physx::PxBoxGeometry const&,physx::PxTransform const&,re::Vector3<float> &)::$_3::operator()((uint64_t)v77, vaddq_f32(v63, vaddq_f32(v65, v51)), vaddq_f32(v63, vaddq_f32(v67, v51)));
        v52 = vaddq_f32(v71, v79);
        boxClosestPointToRayRadian(re::RayF const&,physx::PxBoxGeometry const&,physx::PxTransform const&,re::Vector3<float> &)::$_3::operator()((uint64_t)v77, vaddq_f32(v64, vaddq_f32(v65, v52)), vaddq_f32(v64, vaddq_f32(v67, v52)));
        v53 = vaddq_f32(v69, v79);
        boxClosestPointToRayRadian(re::RayF const&,physx::PxBoxGeometry const&,physx::PxTransform const&,re::Vector3<float> &)::$_3::operator()((uint64_t)v77, vaddq_f32(v64, vaddq_f32(v65, v53)), vaddq_f32(v64, vaddq_f32(v67, v53)));
        v54 = vaddq_f32(v69, v79);
        boxClosestPointToRayRadian(re::RayF const&,physx::PxBoxGeometry const&,physx::PxTransform const&,re::Vector3<float> &)::$_3::operator()((uint64_t)v77, vaddq_f32(v63, vaddq_f32(v65, v54)), vaddq_f32(v63, vaddq_f32(v67, v54)));
        v55 = vaddq_f32(v67, vaddq_f32(v71, v79));
        boxClosestPointToRayRadian(re::RayF const&,physx::PxBoxGeometry const&,physx::PxTransform const&,re::Vector3<float> &)::$_3::operator()((uint64_t)v77, vaddq_f32(v63, v55), vaddq_f32(v64, v55));
        boxClosestPointToRayRadian(re::RayF const&,physx::PxBoxGeometry const&,physx::PxTransform const&,re::Vector3<float> &)::$_3::operator()((uint64_t)v77, vaddq_f32(v64, vaddq_f32(v67, vaddq_f32(v71, v79))), vaddq_f32(v64, vaddq_f32(v67, vaddq_f32(v69, v79))));
        v56 = vaddq_f32(v67, vaddq_f32(v69, v79));
        boxClosestPointToRayRadian(re::RayF const&,physx::PxBoxGeometry const&,physx::PxTransform const&,re::Vector3<float> &)::$_3::operator()((uint64_t)v77, vaddq_f32(v64, v56), vaddq_f32(v63, v56));
        v57 = boxClosestPointToRayRadian(re::RayF const&,physx::PxBoxGeometry const&,physx::PxTransform const&,re::Vector3<float> &)::$_3::operator()((uint64_t)v77, vaddq_f32(v63, vaddq_f32(v67, vaddq_f32(v69, v79))), vaddq_f32(v63, vaddq_f32(v67, vaddq_f32(v71, v79))));
        v57.f32[0] = v78;
        v58 = v62;
        v59 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(v57, v62), 0), v72, v61);
        if (v78 > v62.f32[0])
          v58.f32[0] = v78;
        v61 = v59;
        v62 = v58;
      }
      v10 = (v10 + 1);
    }
    while ((_DWORD)v10 != v9);
    if (v62.f32[0] > 0.0)
      *a4 = v61;
  }
}

void *re::PhysXCollisionWorld::initDebugRenderer(uint64_t a1, const void *a2, const void *a3, const void *a4, const void *a5)
{
  return re::PhysXDebugRenderer::init((_QWORD *)(a1 + 256), *(_QWORD *)(a1 + 152), a2, a3, a4, a5);
}

float re::PhysXCollisionWorld::setRenderingFromPhysicsTransform(uint64_t a1, _OWORD *a2)
{
  return re::PhysXDebugRenderer::setRenderingTransform(a1 + 256, a2);
}

uint64_t re::PhysXCollisionWorld::draw(re::PhysXCollisionWorld *this)
{
  return re::PhysXDebugRenderer::draw((re::PhysXCollisionWorld *)((char *)this + 256));
}

uint64_t re::PhysXCollisionWorld::numCollisionObjects(re::PhysXCollisionWorld *this)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  __int16 v6;
  __int16 v7;

  v2 = *((_QWORD *)this + 19);
  v7 = 1;
  v3 = (*(uint64_t (**)(uint64_t, __int16 *))(*(_QWORD *)v2 + 152))(v2, &v7);
  v4 = *((_QWORD *)this + 19);
  v6 = 2;
  return (*(unsigned int (**)(uint64_t, __int16 *))(*(_QWORD *)v4 + 152))(v4, &v6) + v3;
}

uint64_t re::PhysXCollisionWorld::collisionObjectAtIndex(re::PhysXCollisionWorld *this, unint64_t a2)
{
  uint64_t v4;
  unsigned int v5;
  BOOL v6;
  unsigned int v7;
  uint64_t v8;
  __int16 v9;
  __int16 v11;
  uint64_t v12;
  __int16 v13;

  v4 = *((_QWORD *)this + 19);
  v13 = 1;
  v5 = (*(uint64_t (**)(uint64_t, __int16 *))(*(_QWORD *)v4 + 152))(v4, &v13);
  v6 = v5 > a2;
  if (v5 <= a2)
    v7 = v5;
  else
    v7 = 0;
  v12 = 0;
  v8 = *((_QWORD *)this + 19);
  if (v6)
    v9 = 1;
  else
    v9 = 2;
  v11 = v9;
  if ((*(unsigned int (**)(uint64_t, __int16 *, uint64_t *, uint64_t, _QWORD))(*(_QWORD *)v8 + 160))(v8, &v11, &v12, 1, a2 - v7))
  {
    return *(_QWORD *)(v12 + 16);
  }
  else
  {
    return 0;
  }
}

uint64_t re::PhysXCollisionWorld::addCollisionObject(re::PhysXCollisionWorld *this, re::CollisionObject *a2)
{
  int v4;
  float32x4_t v5;
  uint64_t v6;
  uint64_t result;
  uint64_t v8;
  __int32 v9;
  float32x4_t v10;

  if (physx::shdfnd::g_isLockingEnabled)
    v4 = 1;
  else
    v4 = physx::shdfnd::g_alwaysUseLocking;
  if ((physx::shdfnd::g_alwaysUseLocking & 1) == 0 && physx::shdfnd::g_isLockingEnabled)
    physx::shdfnd::g_isLockingEnabled = 0;
  if (*((_BYTE *)this + 390))
  {
    *((_BYTE *)this + 390) = 0;
    if (re::PhysXCollisionWorld::canRecreateScene(this))
    {
      (*(void (**)(uint64_t *__return_ptr))(**((_QWORD **)this + 19) + 488))(&v8);
      v5.i64[0] = v8;
      v5.i32[2] = v9;
      v10 = v5;
      re::PhysXCollisionWorld::createScene((uint64_t)this, &v10, *((_DWORD *)this + 96));
    }
  }
  v6 = *((_QWORD *)a2 + 3);
  result = (*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(**((_QWORD **)this + 19) + 88))(*((_QWORD *)this + 19), v6, 0);
  if (v6 && *(_WORD *)(v6 + 8) == 5)
    ++*((_QWORD *)this + 50);
  if (physx::shdfnd::g_isLockingEnabled != v4)
    physx::shdfnd::g_isLockingEnabled = v4;
  return result;
}

BOOL re::PhysXCollisionWorld::removeCollisionObject(re::PhysXCollisionWorld *this, re::CollisionObject *a2)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int *v8;
  int v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  re::CollisionObject *v13;
  re::CollisionObject *v14;
  uint64_t *v15;
  unsigned int v17;
  unsigned int v18;
  _WORD *v19;
  _BOOL8 result;

  if (physx::shdfnd::g_isLockingEnabled)
    v4 = 1;
  else
    v4 = physx::shdfnd::g_alwaysUseLocking;
  if ((physx::shdfnd::g_alwaysUseLocking & 1) == 0 && physx::shdfnd::g_isLockingEnabled)
    physx::shdfnd::g_isLockingEnabled = 0;
  v5 = *((_QWORD *)this + 8);
  if (v5)
  {
    v6 = *((unsigned int *)this + 10);
    if ((_DWORD)v6)
    {
      v7 = 0;
      v8 = (int *)(*((_QWORD *)this + 3) + 8);
      while (1)
      {
        v9 = *v8;
        v8 += 10;
        if (v9 < 0)
          break;
        if (v6 == ++v7)
        {
          LODWORD(v7) = *((_DWORD *)this + 10);
          break;
        }
      }
    }
    else
    {
      LODWORD(v7) = 0;
    }
    if ((_DWORD)v6 != (_DWORD)v7)
    {
      v10 = v7;
      v11 = *((_DWORD *)this + 10);
      do
      {
        v12 = *((_QWORD *)this + 3) + 40 * v10;
        v13 = *(re::CollisionObject **)(v12 + 16);
        v14 = *(re::CollisionObject **)(v12 + 24);
        v15 = (uint64_t *)(v12 + 16);
        if (v13 == a2 || v14 == a2)
        {
          (*(void (**)(uint64_t))(*(_QWORD *)v5 + 32))(v5);
          re::HashSetBase<re::TriggerPair,re::TriggerPair,re::internal::ValueAsKey<re::TriggerPair>,re::Hash<re::TriggerPair>,re::EqualTo<re::TriggerPair>,true,false>::remove((uint64_t)this + 8, v15);
          v11 = *((_DWORD *)this + 10);
        }
        if (v11 <= (int)v7 + 1)
          v17 = v7 + 1;
        else
          v17 = v11;
        while (1)
        {
          v10 = (v7 + 1);
          if (v17 - 1 == (_DWORD)v7)
            break;
          LODWORD(v7) = v7 + 1;
          v18 = v10;
          if ((*(_DWORD *)(*((_QWORD *)this + 3) + 40 * v10 + 8) & 0x80000000) != 0)
            goto LABEL_29;
        }
        v18 = v17;
LABEL_29:
        LODWORD(v7) = v18;
      }
      while ((_DWORD)v6 != v18);
    }
  }
  v19 = (_WORD *)*((_QWORD *)a2 + 3);
  if ((*(uint64_t (**)(_WORD *))(*(_QWORD *)v19 + 56))(v19))
    (*(void (**)(_QWORD, _WORD *, uint64_t))(**((_QWORD **)this + 19) + 112))(*((_QWORD *)this + 19), v19, 1);
  if (v19[4] == 5)
    --*((_QWORD *)this + 50);
  result = re::PhysXCollisionWorld::canRecreateScene(this);
  *((_BYTE *)this + 390) = result;
  if (physx::shdfnd::g_isLockingEnabled != v4)
    physx::shdfnd::g_isLockingEnabled = v4;
  return result;
}

uint64_t re::HashSetBase<re::TriggerPair,re::TriggerPair,re::internal::ValueAsKey<re::TriggerPair>,re::Hash<re::TriggerPair>,re::EqualTo<re::TriggerPair>,true,false>::remove(uint64_t a1, uint64_t *a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int *v19;
  int v20;
  int v21;

  v2 = *(unsigned int *)(a1 + 24);
  if (!(_DWORD)v2)
    return 0;
  v3 = *a2;
  v4 = a2[1];
  v5 = ((v4 + (*a2 << 6) + ((unint64_t)*a2 >> 2) - 0x61C8864680B583E9) ^ *a2) % v2;
  v6 = *(_QWORD *)(a1 + 8);
  v7 = *(unsigned int *)(v6 + 4 * v5);
  if ((_DWORD)v7 == 0x7FFFFFFF)
    return 0;
  v8 = *(_QWORD *)(a1 + 16);
  v9 = 0x7FFFFFFFLL;
  while (1)
  {
    v10 = v8 + 40 * v7;
    v13 = *(_QWORD *)(v10 + 16);
    v12 = v10 + 16;
    v11 = v13;
    if (v13 == v3 && *(_QWORD *)(v12 + 8) == v4)
      break;
    if (v11 == v4 && *(_QWORD *)(v12 + 8) == v3)
      break;
    v9 = v7;
    v7 = *(_DWORD *)(v8 + 40 * v7 + 8) & 0x7FFFFFFF;
    if (v7 == 0x7FFFFFFF)
      return 0;
  }
  v15 = *(_DWORD *)(v8 + 40 * v7 + 8) & 0x7FFFFFFF;
  if (v9 == 0x7FFFFFFF)
    *(_DWORD *)(v6 + 4 * v5) = v15;
  else
    *(_DWORD *)(v8 + 40 * v9 + 8) = *(_DWORD *)(v8 + 40 * v9 + 8) & 0x80000000 | v15;
  v16 = *(_QWORD *)(a1 + 16);
  v17 = v16 + 40 * v7;
  v20 = *(_DWORD *)(v17 + 8);
  v19 = (int *)(v17 + 8);
  v18 = v20;
  if (v20 < 0)
  {
    *v19 = v18 & 0x7FFFFFFF;
    v16 = *(_QWORD *)(a1 + 16);
    v18 = *(_DWORD *)(v16 + 40 * v7 + 8);
  }
  v21 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(v16 + 40 * v7 + 8) = *(_DWORD *)(a1 + 36) | v18 & 0x80000000;
  --*(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 36) = v7;
  *(_DWORD *)(a1 + 40) = v21 + 1;
  return 1;
}

uint64_t re::QueryFilterCallback::postFilter()
{
  return 0;
}

void re::QueryFilterCallback::~QueryFilterCallback(re::QueryFilterCallback *this)
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::PhysXCollisionWorld::collisionFlags(re::PhysXCollisionWorld *this)
{
  return *((unsigned int *)this + 96);
}

uint64_t re::PhysXCollisionWorld::parentPhysicsSimulation(re::PhysXCollisionWorld *this)
{
  return *((_QWORD *)this + 49);
}

uint64_t re::PhysXCollisionWorld::setSimulationEventCallbackContext(uint64_t result, _BYTE *a2)
{
  *(_BYTE *)(*(_QWORD *)(result + 232) + 24) = *a2;
  return result;
}

__n128 re::DynamicArray<re::Contact>::add(_anonymous_namespace_ *this, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  __n128 result;
  __int128 v7;
  __int128 v8;

  v4 = *((_QWORD *)this + 2);
  if (v4 >= *((_QWORD *)this + 1))
  {
    re::DynamicArray<re::Contact>::growCapacity(this, v4 + 1);
    v4 = *((_QWORD *)this + 2);
  }
  v5 = *((_QWORD *)this + 4) + 80 * v4;
  *(_OWORD *)v5 = *(_OWORD *)a2;
  result = *(__n128 *)(a2 + 16);
  v7 = *(_OWORD *)(a2 + 32);
  v8 = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(v5 + 48) = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(v5 + 64) = v8;
  *(__n128 *)(v5 + 16) = result;
  *(_OWORD *)(v5 + 32) = v7;
  ++*((_QWORD *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

_QWORD *re::DynamicArray<re::Contact>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<re::Contact>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::Contact>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

_QWORD *re::DynamicArray<re::Contact>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  void *v7;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (*v5)
      {
        if (!a2)
        {
          v7 = 0;
          if (!v3)
            goto LABEL_9;
          goto LABEL_8;
        }
        if (is_mul_ok(a2, 0x50uLL))
        {
          v2 = 80 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 80 * a2, 16);
          if (result)
          {
            v7 = result;
            if (!v5[1])
            {
LABEL_9:
              v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            memcpy(v7, (const void *)v5[4], 80 * v5[2]);
            result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 80, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
      }
      else
      {
        result = (_QWORD *)re::DynamicArray<re::Contact>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

float32x4_t boxClosestPointToRayRadian(re::RayF const&,physx::PxBoxGeometry const&,physx::PxTransform const&,re::Vector3<float> &)::$_3::operator()(uint64_t a1, float32x4_t result, float32x4_t a3)
{
  float32x4_t *v3;
  float32x4_t v4;
  float32x4_t v5;
  int32x4_t v6;
  float32x2_t v7;
  float32x2_t v8;
  float32x4_t v9;
  float32x4_t v10;
  float32x4_t v11;
  int32x4_t v12;
  float32x2_t v13;
  float32x2_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  int32x4_t v25;
  float32x2_t v26;
  float32x2_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  int32x4_t v32;
  float32x2_t v33;
  float32x2_t v34;
  float32x4_t v35;
  float32x4_t v36;
  int32x4_t v37;
  float32x4_t v38;
  float v39;
  float v40;
  int32x4_t v41;
  float32x4_t v42;
  BOOL v43;
  int8x16_t v44;
  int8x16_t v45;
  int32x4_t v47;
  float32x4_t v52;

  v3 = *(float32x4_t **)(a1 + 16);
  v4 = v3[1];
  v5 = vsubq_f32(result, *v3);
  v6 = (int32x4_t)vmulq_f32(v5, v5);
  v6.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v6, 2), vadd_f32(*(float32x2_t *)v6.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v6.i8, 1))).u32[0];
  v7 = vrsqrte_f32((float32x2_t)v6.u32[0]);
  v8 = vmul_f32(v7, vrsqrts_f32((float32x2_t)v6.u32[0], vmul_f32(v7, v7)));
  v9 = vmulq_n_f32(v5, vmul_f32(v8, vrsqrts_f32((float32x2_t)v6.u32[0], vmul_f32(v8, v8))).f32[0]);
  v10 = vmulq_f32(v9, v4);
  if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v10, 2), vaddq_f32(v10, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v10.f32, 1))).f32[0] > 0.00001)
  {
    v11 = vsubq_f32(a3, *v3);
    v12 = (int32x4_t)vmulq_f32(v11, v11);
    v12.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v12, 2), vadd_f32(*(float32x2_t *)v12.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v12.i8, 1))).u32[0];
    v13 = vrsqrte_f32((float32x2_t)v12.u32[0]);
    v14 = vmul_f32(v13, vrsqrts_f32((float32x2_t)v12.u32[0], vmul_f32(v13, v13)));
    v15 = vmulq_n_f32(v11, vmul_f32(v14, vrsqrts_f32((float32x2_t)v12.u32[0], vmul_f32(v14, v14))).f32[0]);
    v16 = vmulq_f32(v4, v15);
    if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v16, 2), vaddq_f32(v16, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v16.f32, 1))).f32[0] > 0.00001)
    {
      v17 = vmulq_f32(v9, v15);
      if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v17, 2), vaddq_f32(v17, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v17.f32, 1))).f32[0] < 0.99999)
      {
        v18 = *(float32x4_t *)*(_QWORD *)a1;
        v19 = vsubq_f32(result, v18);
        v20 = vsubq_f32(a3, v18);
        v21 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v19, (int32x4_t)v19), (int8x16_t)v19, 0xCuLL);
        v22 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v20, (int32x4_t)v20), (int8x16_t)v20, 0xCuLL);
        v23 = vmlaq_f32(vmulq_f32(v22, vnegq_f32(v19)), v20, v21);
        v24 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v23, (int32x4_t)v23), (int8x16_t)v23, 0xCuLL);
        v25 = (int32x4_t)vmulq_f32(v23, v23);
        v25.i32[0] = vadd_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v25.i8, 1), vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v25, 2), *(float32x2_t *)v25.i8)).u32[0];
        v26 = vrsqrte_f32((float32x2_t)v25.u32[0]);
        v27 = vmul_f32(v26, vrsqrts_f32((float32x2_t)v25.u32[0], vmul_f32(v26, v26)));
        v28 = vmulq_n_f32(v24, vmul_f32(v27, vrsqrts_f32((float32x2_t)v25.u32[0], vmul_f32(v27, v27))).f32[0]);
        v29 = *(float32x4_t *)*(_QWORD *)(a1 + 8);
        v30 = vmulq_f32(v29, v28);
        v31 = vsubq_f32(v29, vmulq_n_f32(v28, vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v30, 2), vaddq_f32(v30, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v30.f32, 1))).f32[0]));
        v32 = (int32x4_t)vmulq_f32(v31, v31);
        v32.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v32, 2), vadd_f32(*(float32x2_t *)v32.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v32.i8, 1))).u32[0];
        v33 = vrsqrte_f32((float32x2_t)v32.u32[0]);
        v34 = vmul_f32(v33, vrsqrts_f32((float32x2_t)v32.u32[0], vmul_f32(v33, v33)));
        v35 = vmulq_n_f32(v31, vmul_f32(v34, vrsqrts_f32((float32x2_t)v32.u32[0], vmul_f32(v34, v34))).f32[0]);
        v36 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v35, (int32x4_t)v35), (int8x16_t)v35, 0xCuLL);
        v37 = (int32x4_t)vmlaq_f32(vmulq_f32(v21, vnegq_f32(v35)), v19, v36);
        v38 = vmulq_f32(v28, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v37, v37), (int8x16_t)v37, 0xCuLL));
        v34.f32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v38, 2), vaddq_f32(v38, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v38.f32, 1))).f32[0];
        v39 = 0.0;
        if (v34.f32[0] <= 0.0)
        {
          v41 = (int32x4_t)vmlaq_f32(vmulq_f32(v36, vnegq_f32(v20)), v35, v22);
          v42 = vmulq_f32(v28, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v41, v41), (int8x16_t)v41, 0xCuLL));
          v43 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v42, 2), vaddq_f32(v42, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v42.f32, 1))).f32[0] <= 0.0;
          v40 = 0.0;
          if (v43)
          {
            v44 = (int8x16_t)vmulq_f32(v19, v19);
            v45 = (int8x16_t)vmulq_f32(v20, v20);
            *(float32x2_t *)v44.i8 = vsqrt_f32(vadd_f32((float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v44, v44, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v45, v45, 8uLL)), vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v44.i8, *(int32x2_t *)v45.i8), (float32x2_t)vzip2_s32(*(int32x2_t *)v44.i8, *(int32x2_t *)v45.i8))));
            _Q4 = (int32x4_t)vmulq_f32(vdivq_f32(v19, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v44.i8, 0)), v35);
            v47 = (int32x4_t)vmulq_f32(vdivq_f32(v20, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v44.i8, 1)), v35);
            *(float32x2_t *)v47.i8 = vadd_f32((float32x2_t)*(_OWORD *)&vzip2q_s32(_Q4, v47), vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)_Q4.i8, *(int32x2_t *)v47.i8), (float32x2_t)vzip2_s32(*(int32x2_t *)_Q4.i8, *(int32x2_t *)v47.i8)));
            __asm { FMOV            V4.2S, #1.0 }
            *(float32x2_t *)_Q4.i8 = vmls_f32(*(float32x2_t *)_Q4.i8, *(float32x2_t *)v47.i8, *(float32x2_t *)v47.i8);
            *(float32x2_t *)v47.i8 = vmul_f32(*(float32x2_t *)v44.i8, vsqrt_f32((float32x2_t)vbic_s8(*(int8x8_t *)_Q4.i8, (int8x8_t)vcltz_f32(*(float32x2_t *)_Q4.i8))));
            LODWORD(v39) = vdiv_f32(*(float32x2_t *)v47.i8, vadd_f32(*(float32x2_t *)v47.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v47.i8, 1))).u32[0];
            v52 = vmulq_f32(v29, v35);
            LODWORD(v40) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v52, 2), vaddq_f32(v52, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v52.f32, 1))).u32[0];
          }
        }
        else
        {
          v40 = 0.0;
        }
        if (v40 > **(float **)(a1 + 24))
        {
          result = vaddq_f32(vmulq_n_f32(a3, v39), vmulq_n_f32(result, 1.0 - v39));
          *(float32x4_t *)*(_QWORD *)(a1 + 32) = result;
          **(float **)(a1 + 24) = v40;
        }
      }
    }
  }
  return result;
}

uint64_t re::BucketArray<re::PhysXManifold,256ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1011, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(_QWORD *)(a1 + 8) <= a2 >> 8)
    goto LABEL_8;
  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
    v3 = a1 + 24;
  else
    v3 = *(_QWORD *)(a1 + 32);
  return *(_QWORD *)(v3 + 8 * (a2 >> 8)) + 56 * a2;
}

uint64_t re::BucketArray<re::CollisionCastHit,10ul>::addUninitialized(uint64_t a1)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = *(_QWORD *)(a1 + 40);
  v3 = *(_QWORD *)(a1 + 8);
  if (10 * v3 < v2 + 1)
  {
    re::BucketArray<re::CollisionCastHit,10ul>::setBucketsCapacity((uint64_t *)a1, (v2 + 10) / 0xA);
    v3 = *(_QWORD *)(a1 + 8);
  }
  if (v3 <= v2 / 0xA)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
    v4 = a1 + 24;
  else
    v4 = *(_QWORD *)(a1 + 32);
  v5 = *(_QWORD *)(v4 + 8 * (v2 / 0xA));
  ++*(_QWORD *)(a1 + 40);
  ++*(_DWORD *)(a1 + 48);
  return v5 + 80 * (v2 % 0xA);
}

uint64_t *re::BucketArray<re::CollisionCastHit,10ul>::setBucketsCapacity(uint64_t *result, unint64_t a2)
{
  uint64_t *v3;
  unint64_t v4;
  uint64_t v5;

  v3 = result;
  if (*result)
  {
    if (10 * a2 > result[5])
    {
      while (1)
      {
        v4 = v3[1];
        if (v4 <= a2)
          break;
        result = (uint64_t *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      while (v4 < a2)
      {
        v5 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)*v3 + 32))(*v3, 800, 0);
        result = (uint64_t *)re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::add((uint64_t)v3, &v5);
        v4 = v3[1];
      }
    }
  }
  else
  {
  }
  return result;
}

uint64_t re::BucketArray<re::CollisionCastHit,10ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t result;

  *(_QWORD *)a1 = a2;
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::setCapacity((_QWORD *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(_QWORD *)(a1 + 40) = 0;
  result = re::BucketArray<re::CollisionCastHit,10ul>::setBucketsCapacity(a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

_QWORD *re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  _QWORD *v4;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  unint64_t v9;
  void *v10;
  uint64_t v11;
  void *v12;
  const void *v13;
  void *v14;
  uint64_t v15;
  const void *v16;
  int v17;

  v4 = result;
  v5 = *result;
  if (a2 && !v5)
  {
    result = (_QWORD *)re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::setCapacity(v4, a2);
    v6 = *((_DWORD *)v4 + 4) + 2;
LABEL_4:
    *((_DWORD *)v4 + 4) = v6;
    return result;
  }
  v7 = *((_DWORD *)result + 4);
  if ((v7 & 1) != 0)
    v8 = 2;
  else
    v8 = result[3];
  if (v8 != a2)
  {
    v9 = result[1];
    if (v9 <= a2 && (a2 > 2 || (v7 & 1) == 0))
    {
      if (a2 < 3)
      {
        v14 = result + 3;
        v15 = v4[4];
        if ((v7 & 1) != 0)
          v16 = v4 + 3;
        else
          v16 = (const void *)v4[4];
        memcpy(v14, v16, 8 * v9);
        result = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v5 + 40))(v5, v15);
        v6 = *((_DWORD *)v4 + 4) | 1;
        goto LABEL_4;
      }
      if (a2 >> 61)
      {
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicOverflowArray<T, N>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 646, 8, a2);
        _os_crash();
        __break(1u);
      }
      else
      {
        v2 = 8 * a2;
        v10 = (void *)(*(uint64_t (**)(_QWORD, unint64_t, uint64_t))(*(_QWORD *)v5 + 32))(*result, 8 * a2, 8);
        if (v10)
        {
          v12 = v10;
          if ((v4[2] & 1) != 0)
            v13 = v4 + 3;
          else
            v13 = (const void *)v4[4];
          result = memcpy(v10, v13, 8 * v4[1]);
          v17 = *((_DWORD *)v4 + 4);
          if ((v17 & 1) == 0)
          {
            result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v4 + 40))(*v4, v4[4]);
            v17 = *((_DWORD *)v4 + 4);
          }
          *((_DWORD *)v4 + 4) = v17 & 0xFFFFFFFE;
          v4[3] = a2;
          v4[4] = v12;
          return result;
        }
      }
      re::internal::assertLog((re::internal *)6, v11, "assertion failure: '%s' (%s:line %i) DynamicOverflowArray<T, N> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 650, v2, *(_QWORD *)(*v4 + 8));
      result = (_QWORD *)_os_crash();
      __break(1u);
    }
  }
  return result;
}

_anonymous_namespace_ *re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::add(uint64_t a1, _QWORD *a2)
{
  _anonymous_namespace_ *result;
  uint64_t v5;
  uint64_t v6;

  result = re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::ensureCapacity((_anonymous_namespace_ *)a1);
  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
    v5 = a1 + 24;
  else
    v5 = *(_QWORD *)(a1 + 32);
  v6 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(v5 + 8 * v6) = *a2;
  *(_QWORD *)(a1 + 8) = v6 + 1;
  *(_DWORD *)(a1 + 16) += 2;
  return result;
}

_anonymous_namespace_ *re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::ensureCapacity(_anonymous_namespace_ *result)
{
  _anonymous_namespace_ *v1;
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;

  v1 = result;
  if (*(_QWORD *)result)
  {
    v2 = *((_QWORD *)result + 1);
    if ((*((_BYTE *)result + 16) & 1) != 0)
      v3 = 2;
    else
      v3 = *((_QWORD *)result + 3);
    if (v2 >= v3)
      return re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::growCapacity(result, v2 + 1);
  }
  else
  {
    v4 = *((_QWORD *)v1 + 1) + 1;
    result = (_anonymous_namespace_ *)re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::setCapacity(v1, v4);
    *((_DWORD *)v1 + 4) += 2;
  }
  return result;
}

_anonymous_namespace_ *re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::growCapacity(_anonymous_namespace_ *result, unint64_t a2)
{
  unint64_t v2;
  _anonymous_namespace_ *v3;
  unint64_t v4;
  unint64_t v5;

  v2 = a2;
  v3 = result;
  if (!*(_QWORD *)result)
  {
    result = (_anonymous_namespace_ *)re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::setCapacity(v3, v2);
    *((_DWORD *)v3 + 4) += 2;
    return result;
  }
  if ((*((_BYTE *)result + 16) & 1) != 0)
  {
    if (a2 <= 2)
      return result;
    v5 = 4;
  }
  else
  {
    v4 = *((_QWORD *)result + 3);
    if (v4 >= a2)
      return result;
    v5 = 2 * v4;
  }
  if (v5 > a2)
    a2 = v5;
  return (_anonymous_namespace_ *)re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::setCapacity(result, a2);
}

uint64_t re::BucketArray<re::PhysXManifold,256ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t result;

  *(_QWORD *)a1 = a2;
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::setCapacity((_QWORD *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(_QWORD *)(a1 + 40) = 0;
  result = re::BucketArray<re::PhysXManifold,256ul>::setBucketsCapacity(a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

uint64_t *re::BucketArray<re::PhysXManifold,256ul>::setBucketsCapacity(uint64_t *result, unint64_t a2)
{
  uint64_t *v3;
  unint64_t v4;
  uint64_t v5;

  v3 = result;
  if (*result)
  {
    if (result[5] < a2 << 8)
    {
      while (1)
      {
        v4 = v3[1];
        if (v4 <= a2)
          break;
        result = (uint64_t *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      while (v4 < a2)
      {
        v5 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)*v3 + 32))(*v3, 14336, 0);
        result = (uint64_t *)re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::add((uint64_t)v3, &v5);
        v4 = v3[1];
      }
    }
  }
  else
  {
  }
  return result;
}

_QWORD *re::DynamicOverflowArray<re::PhysXCollisionWorld::createScene(re::Vector3<float> const&,re::CollisionWorld::CollisionFlags)::ControllerInfo,4ul>::setCapacity(_QWORD *result, unint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  int v5;
  int v6;
  uint64_t v7;
  unint64_t v8;
  void *v9;
  uint64_t v10;
  void *v11;
  const void *v12;
  void *v13;
  uint64_t v14;
  const void *v15;
  int v16;

  v3 = result;
  v4 = *result;
  if (a2 && !v4)
  {
    result = (_QWORD *)re::DynamicOverflowArray<re::PhysXCollisionWorld::createScene(re::Vector3<float> const&,re::CollisionWorld::CollisionFlags)::ControllerInfo,4ul>::setCapacity(v3, a2);
    v5 = *((_DWORD *)v3 + 4) + 2;
LABEL_4:
    *((_DWORD *)v3 + 4) = v5;
    return result;
  }
  v6 = *((_DWORD *)result + 4);
  if ((v6 & 1) != 0)
    v7 = 4;
  else
    v7 = result[4];
  if (v7 != a2)
  {
    v8 = result[1];
    if (v8 <= a2 && (a2 > 4 || (v6 & 1) == 0))
    {
      if (a2 < 5)
      {
        v13 = result + 4;
        v14 = v3[5];
        if ((v6 & 1) != 0)
          v15 = v3 + 4;
        else
          v15 = (const void *)v3[5];
        memcpy(v13, v15, v8 << 6);
        result = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v4 + 40))(v4, v14);
        v5 = *((_DWORD *)v3 + 4) | 1;
        goto LABEL_4;
      }
      v9 = (void *)(*(uint64_t (**)(_QWORD, unint64_t, uint64_t))(*(_QWORD *)v4 + 32))(*result, a2 << 6, 16);
      if (v9)
      {
        v11 = v9;
        if ((v3[2] & 1) != 0)
          v12 = v3 + 4;
        else
          v12 = (const void *)v3[5];
        result = memcpy(v9, v12, v3[1] << 6);
        v16 = *((_DWORD *)v3 + 4);
        if ((v16 & 1) == 0)
        {
          result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v3 + 40))(*v3, v3[5]);
          v16 = *((_DWORD *)v3 + 4);
        }
        *((_DWORD *)v3 + 4) = v16 & 0xFFFFFFFE;
        v3[4] = a2;
        v3[5] = v11;
      }
      else
      {
        re::internal::assertLog((re::internal *)6, v10, "assertion failure: '%s' (%s:line %i) DynamicOverflowArray<T, N> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 650, a2 << 6, *(_QWORD *)(*v3 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
      }
    }
  }
  return result;
}

_QWORD *re::DynamicOverflowArray<physx::PxActor *,32ul>::setCapacity(_QWORD *result, unint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  int v5;
  int v6;
  uint64_t v7;
  unint64_t v8;
  void *v9;
  uint64_t v10;
  void *v11;
  const void *v12;
  void *v13;
  uint64_t v14;
  const void *v15;
  int v16;

  v3 = result;
  v4 = *result;
  if (a2 && !v4)
  {
    result = (_QWORD *)re::DynamicOverflowArray<physx::PxActor *,32ul>::setCapacity(v3, a2);
    v5 = *((_DWORD *)v3 + 4) + 2;
LABEL_4:
    *((_DWORD *)v3 + 4) = v5;
    return result;
  }
  v6 = *((_DWORD *)result + 4);
  if ((v6 & 1) != 0)
    v7 = 32;
  else
    v7 = result[3];
  if (v7 != a2)
  {
    v8 = result[1];
    if (v8 <= a2 && (a2 > 0x20 || (v6 & 1) == 0))
    {
      if (a2 < 0x21)
      {
        v13 = result + 3;
        v14 = v3[4];
        if ((v6 & 1) != 0)
          v15 = v3 + 3;
        else
          v15 = (const void *)v3[4];
        memcpy(v13, v15, 8 * v8);
        result = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v4 + 40))(v4, v14);
        v5 = *((_DWORD *)v3 + 4) | 1;
        goto LABEL_4;
      }
      v9 = (void *)(*(uint64_t (**)(_QWORD, unint64_t, uint64_t))(*(_QWORD *)v4 + 32))(*result, 8 * a2, 8);
      if (v9)
      {
        v11 = v9;
        if ((v3[2] & 1) != 0)
          v12 = v3 + 3;
        else
          v12 = (const void *)v3[4];
        result = memcpy(v9, v12, 8 * v3[1]);
        v16 = *((_DWORD *)v3 + 4);
        if ((v16 & 1) == 0)
        {
          result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v3 + 40))(*v3, v3[4]);
          v16 = *((_DWORD *)v3 + 4);
        }
        *((_DWORD *)v3 + 4) = v16 & 0xFFFFFFFE;
        v3[3] = a2;
        v3[4] = v11;
      }
      else
      {
        re::internal::assertLog((re::internal *)6, v10, "assertion failure: '%s' (%s:line %i) DynamicOverflowArray<T, N> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 650, 8 * a2, *(_QWORD *)(*v3 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
      }
    }
  }
  return result;
}

uint64_t physx::PxHitBuffer<physx::PxOverlapHit>::processTouches()
{
  return 0;
}

void physx::PxHitBuffer<physx::PxOverlapHit>::~PxHitBuffer()
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::CastHitCallback<physx::PxRaycastHit>::processTouches(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v5;

  if (a3)
  {
    v5 = a3;
    do
    {
      re::CastHitCallback<physx::PxRaycastHit>::addHit(a1, a2);
      a2 += 64;
      --v5;
    }
    while (v5);
  }
  return 1;
}

uint64_t re::CastHitCallback<physx::PxRaycastHit>::finalizeQuery(uint64_t result)
{
  if (*(_BYTE *)(result + 72))
    return re::CastHitCallback<physx::PxRaycastHit>::addHit(result, result + 8);
  return result;
}

void re::CastHitCallback<physx::PxRaycastHit>::~CastHitCallback()
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::CastHitCallback<physx::PxSweepHit>::processTouches(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v5;

  if (a3)
  {
    v5 = a3;
    do
    {
      re::CastHitCallback<physx::PxSweepHit>::addHit(a1, a2);
      a2 += 56;
      --v5;
    }
    while (v5);
  }
  return 1;
}

uint64_t re::CastHitCallback<physx::PxSweepHit>::finalizeQuery(uint64_t result)
{
  if (*(_BYTE *)(result + 64))
    return re::CastHitCallback<physx::PxSweepHit>::addHit(result, result + 8);
  return result;
}

void re::CastHitCallback<physx::PxSweepHit>::~CastHitCallback()
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::CastHitCallback<physx::PxSweepHit>::addHit(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t result;

  v4 = re::BucketArray<re::CollisionCastHit,10ul>::addUninitialized(*(_QWORD *)(a1 + 88));
  *(_QWORD *)v4 = 0;
  *(_OWORD *)(v4 + 16) = 0u;
  *(_OWORD *)(v4 + 32) = 0u;
  *(_DWORD *)(v4 + 48) = 2139095039;
  *(_QWORD *)(v4 + 52) = 0xFFFFFFFF00000000;
  *(_QWORD *)(v4 + 64) = 0;
  v6 = *(_QWORD *)(a1 + 88);
  v7 = *(_QWORD *)(v6 + 40);
  if (v7)
  {
    v8 = re::BucketArray<re::CollisionCastHit,10ul>::operator[](v6, v7 - 1);
    *(float *)(v8 + 48) = *(float *)(a2 + 48) / *(float *)(a1 + 1892);
    *(_OWORD *)(v8 + 16) = *(_OWORD *)(a2 + 24);
    *(_OWORD *)(v8 + 32) = *(_OWORD *)(a2 + 36);
    v9 = *(_QWORD *)(a2 + 8);
    v10 = *(_QWORD *)(*(_QWORD *)a2 + 16);
    *(_QWORD *)v8 = v10;
    result = re::internal::nvphysx::findShapeIndex(v10, v9);
    *(_DWORD *)(v8 + 52) = result;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::ContactHitCallback<physx::PxSweepHit>::processTouches(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v4;
  _DWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  float32x4_t v9;
  float32x4_t v10;
  unint64_t *v11;
  unint64_t v12;
  float v13;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  if (a3)
  {
    v4 = a3;
    v5 = (_DWORD *)(a2 + 48);
    do
    {
      v6 = *(_QWORD *)(*((_QWORD *)v5 - 6) + 16);
      v7 = *(_QWORD *)(a1 + 96);
      v15.i64[0] = *(_QWORD *)(a1 + 88);
      v15.i64[1] = v6;
      v8 = re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::tryGet(v7, (uint64_t *)&v15);
      if (!v8)
      {
        v11 = *(unint64_t **)(a1 + 96);
        v12 = *v11;
        v22 = 0;
        v20 = 0u;
        v21 = 0u;
        *(_QWORD *)&v19 = 0;
        *(_DWORD *)((char *)&v19 + 7) = 0;
        v23 = 0;
        v24 = 0;
        v18.i64[0] = 0;
        v18.i32[2] = 0;
        v16 = v15;
        v17 = (float32x4_t)v12;
        re::DynamicArray<re::Contact>::setCapacity(&v17, 0);
        ++v18.i32[2];
        v8 = re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::addNew((uint64_t)v11, (uint64_t *)&v16);
        re::ContactSet::~ContactSet((re::ContactSet *)&v16);
      }
      v9.i64[0] = *((_QWORD *)v5 - 3);
      v9.i32[2] = *(v5 - 4);
      v10.i64[0] = *(_QWORD *)(v5 - 3);
      v10.i32[2] = *(v5 - 1);
      v13 = *(float *)v5;
      v5 += 14;
      v16 = vaddq_f32(v9, vmulq_n_f32(v10, v13));
      v17 = v9;
      v18 = v10;
      v19 = 0uLL;
      *(float *)&v20 = v13;
      re::DynamicArray<re::Contact>::add((_anonymous_namespace_ *)(v8 + 16), (uint64_t)&v16);
      --v4;
    }
    while (v4);
  }
  return 1;
}

void re::ContactHitCallback<physx::PxSweepHit>::~ContactHitCallback()
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::tryGet(uint64_t a1, uint64_t *a2)
{
  unint64_t v2;
  uint64_t result;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v2 = *(unsigned int *)(a1 + 24);
  if (!(_DWORD)v2)
    return 0;
  result = 0;
  v5 = *a2;
  v6 = a2[1];
  v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  v9 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (v6 ^ (v6 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v6 ^ (v6 >> 30))) >> 27));
  v10 = v9 ^ (v9 >> 31);
  if (v8 == v10)
    v10 = 0;
  v11 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * ((v10 ^ v8) % v2));
  if ((_DWORD)v11 != 0x7FFFFFFF)
  {
    v12 = *(_QWORD *)(a1 + 16);
    while (1)
    {
      v13 = v12 + 144 * v11;
      v15 = *(_QWORD *)(v13 + 16);
      result = v13 + 16;
      v14 = v15;
      if (v15 == v5 && *(_QWORD *)(result + 8) == v6)
        break;
      if (v14 == v6 && *(_QWORD *)(result + 8) == v5)
        break;
      v11 = *(_DWORD *)(v12 + 144 * v11) & 0x7FFFFFFF;
      if (v11 == 0x7FFFFFFF)
        return 0;
    }
  }
  return result;
}

_QWORD *re::FixedArray<physx::PxOverlapHit>::init<>(_QWORD *result, uint64_t a2, unint64_t a3)
{
  _QWORD *v4;
  uint64_t v5;
  unint64_t v6;

  *result = a2;
  result[1] = a3;
  if (!a3)
    return result;
  if (a3 >= 0xAAAAAAAAAAAAAABLL)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 24, a3);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  v4 = result;
  result = (_QWORD *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 24 * a3, 8);
  v4[2] = result;
  if (!result)
  {
LABEL_9:
    re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    result = (_QWORD *)_os_crash();
    __break(1u);
    return result;
  }
  v6 = a3 - 1;
  if (a3 != 1)
  {
    do
    {
      *result = 0;
      result[1] = 0;
      result[2] = 0xFFFFFFFFLL;
      result += 3;
      --v6;
    }
    while (v6);
  }
  *result = 0;
  result[1] = 0;
  result[2] = 0xFFFFFFFFLL;
  return result;
}

_QWORD *re::DynamicArray<re::CollisionObject *>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<re::CollisionObject *>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::CollisionObject *>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

_QWORD *re::DynamicArray<re::CollisionObject *>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  void *v7;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (*v5)
      {
        if (!a2)
        {
          v7 = 0;
          if (!v3)
            goto LABEL_9;
          goto LABEL_8;
        }
        if (a2 >> 61)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 8, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          v2 = 8 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 8 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
            {
LABEL_9:
              v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            memcpy(v7, (const void *)v5[4], 8 * v5[2]);
            result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
      }
      else
      {
        result = (_QWORD *)re::DynamicArray<re::CollisionObject *>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

re::Allocator *re::internal::nvphysx::initPhysX(re::internal::nvphysx *this)
{
  uint64_t *v1;
  re::Allocator *v2;
  re::Allocator *result;

  v1 = re::globalAllocators(this);
  v2 = (re::Allocator *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v1[2] + 32))(v1[2], 24, 8);
  result = re::Allocator::Allocator(v2, "PhysX", 1);
  *(_QWORD *)result = &off_24ED42648;
  return result;
}

re *re::internal::destroyPersistent<re::MallocAllocator>(re *result, uint64_t a2, re::Allocator *a3)
{
  uint64_t v4;

  if (a3)
  {
    v4 = re::globalAllocators(result)[2];
    re::Allocator::~Allocator(a3);
    return (re *)(*(uint64_t (**)(uint64_t, re::Allocator *))(*(_QWORD *)v4 + 40))(v4, a3);
  }
  return result;
}

uint64_t re::internal::nvphysx::findShapeIndex(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;

  v3 = *(_QWORD *)(a1 + 24);
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v3 + 184))(v3) == 1)
    return 0;
  if (!(*(unsigned int (**)(uint64_t))(*(_QWORD *)v3 + 184))(v3))
    return 0xFFFFFFFFLL;
  v4 = 0;
  while (1)
  {
    v6 = 0;
    (*(void (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(*(_QWORD *)v3 + 192))(v3, &v6, 1, v4);
    if (v6 == a2)
      break;
    v4 = (v4 + 1);
    if (v4 >= (*(unsigned int (**)(uint64_t))(*(_QWORD *)v3 + 184))(v3))
      return 0xFFFFFFFFLL;
  }
  return v4;
}

double re::TriangleMeshShape::massProperties(uint64_t a1, _DWORD *a2, _QWORD *a3, _OWORD *a4)
{
  double result;

  result = 0.0;
  a4[1] = 0u;
  a4[2] = 0u;
  *a4 = 0u;
  *a3 = 0;
  a3[1] = 0;
  *a2 = 0;
  return result;
}

uint64_t re::TriangleMeshShape::type(re::TriangleMeshShape *this)
{
  return 12;
}

uint64_t re::TriangleMeshShape::isStaticShape(re::TriangleMeshShape *this)
{
  return 1;
}

uint64_t *re::introspect_ShapeType(re *this, const re::IntrospectionBase *a2)
{
  int v2;
  unsigned __int8 v3;
  unsigned __int8 v4;
  char v5;
  re *v6;
  std::__shared_mutex_base *v7;
  re *v8;
  uint64_t *v9;
  uint64_t v10;
  unsigned int *v11;
  _anonymous_namespace_ *v12;
  unint64_t v13;
  unint64_t i;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  char v18;
  unsigned __int8 *v19;
  int v20;
  uint64_t v21;
  unint64_t j;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  char v26;
  unsigned __int8 *v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  std::__shared_mutex_base *v31;
  uint64_t *result;
  re *v33;
  uint64_t *v34;
  re *v35;
  uint64_t *v36;
  re *v37;
  uint64_t *v38;
  re *v39;
  uint64_t *v40;
  re *v41;
  uint64_t *v42;
  re *v43;
  uint64_t *v44;
  re *v45;
  uint64_t *v46;
  re *v47;
  uint64_t *v48;
  re *v49;
  uint64_t *v50;
  re *v51;
  uint64_t *v52;
  re *v53;
  uint64_t *v54;
  re *v55;
  uint64_t *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  const char *v60;
  StringID v61;
  _QWORD v62[2];
  _QWORD v63[61];

  v2 = (int)this;
  v3 = atomic_load((unsigned __int8 *)&qword_254105D38);
  if ((v3 & 1) == 0)
  {
    v33 = (re *)__cxa_guard_acquire(&qword_254105D38);
    if ((_DWORD)v33)
    {
      v34 = re::introspectionAllocator(v33);
      v35 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v34 + 32))(v34, 24, 8);
      *(_DWORD *)v35 = 1;
      *((_QWORD *)v35 + 1) = 0;
      *((_QWORD *)v35 + 2) = "Unknown";
      qword_254105DB8 = (uint64_t)v35;
      v36 = re::introspectionAllocator(v35);
      v37 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v36 + 32))(v36, 24, 8);
      *(_DWORD *)v37 = 1;
      *((_QWORD *)v37 + 1) = 3;
      *((_QWORD *)v37 + 2) = "Box";
      qword_254105DC0 = (uint64_t)v37;
      v38 = re::introspectionAllocator(v37);
      v39 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v38 + 32))(v38, 24, 8);
      *(_DWORD *)v39 = 1;
      *((_QWORD *)v39 + 1) = 4;
      *((_QWORD *)v39 + 2) = "Capsule";
      qword_254105DC8 = (uint64_t)v39;
      v40 = re::introspectionAllocator(v39);
      v41 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v40 + 32))(v40, 24, 8);
      *(_DWORD *)v41 = 1;
      *((_QWORD *)v41 + 1) = 7;
      *((_QWORD *)v41 + 2) = "Compound";
      qword_254105DD0 = (uint64_t)v41;
      v42 = re::introspectionAllocator(v41);
      v43 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v42 + 32))(v42, 24, 8);
      *(_DWORD *)v43 = 1;
      *((_QWORD *)v43 + 1) = 9;
      *((_QWORD *)v43 + 2) = "Cone";
      qword_254105DD8 = (uint64_t)v43;
      v44 = re::introspectionAllocator(v43);
      v45 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v44 + 32))(v44, 24, 8);
      *(_DWORD *)v45 = 1;
      *((_QWORD *)v45 + 1) = 5;
      *((_QWORD *)v45 + 2) = "ConvexPolyhedron";
      qword_254105DE0 = (uint64_t)v45;
      v46 = re::introspectionAllocator(v45);
      v47 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v46 + 32))(v46, 24, 8);
      *(_DWORD *)v47 = 1;
      *((_QWORD *)v47 + 1) = 8;
      *((_QWORD *)v47 + 2) = "Cylinder";
      qword_254105DE8 = (uint64_t)v47;
      v48 = re::introspectionAllocator(v47);
      v49 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v48 + 32))(v48, 24, 8);
      *(_DWORD *)v49 = 1;
      *((_QWORD *)v49 + 1) = 1;
      *((_QWORD *)v49 + 2) = "Empty";
      qword_254105DF0 = (uint64_t)v49;
      v50 = re::introspectionAllocator(v49);
      v51 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v50 + 32))(v50, 24, 8);
      *(_DWORD *)v51 = 1;
      *((_QWORD *)v51 + 1) = 6;
      *((_QWORD *)v51 + 2) = "Plane";
      qword_254105DF8 = (uint64_t)v51;
      v52 = re::introspectionAllocator(v51);
      v53 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v52 + 32))(v52, 24, 8);
      *(_DWORD *)v53 = 1;
      *((_QWORD *)v53 + 1) = 11;
      *((_QWORD *)v53 + 2) = "Rectangle";
      qword_254105E00 = (uint64_t)v53;
      v54 = re::introspectionAllocator(v53);
      v55 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v54 + 32))(v54, 24, 8);
      *(_DWORD *)v55 = 1;
      *((_QWORD *)v55 + 1) = 2;
      *((_QWORD *)v55 + 2) = "Sphere";
      qword_254105E08 = (uint64_t)v55;
      v56 = re::introspectionAllocator(v55);
      v57 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v56 + 32))(v56, 24, 8);
      *(_DWORD *)v57 = 1;
      *(_QWORD *)(v57 + 8) = 12;
      *(_QWORD *)(v57 + 16) = "TriangleMesh";
      qword_254105E10 = v57;
      __cxa_guard_release(&qword_254105D38);
    }
  }
  v4 = atomic_load((unsigned __int8 *)&qword_254105D40);
  if ((v4 & 1) == 0 && __cxa_guard_acquire(&qword_254105D40))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_254105D70, "ShapeType", 4, 4, 1, 1);
    qword_254105D70 = (uint64_t)&off_24ED7D9E8;
    qword_254105DB0 = (uint64_t)&re::introspect_ShapeType(BOOL)::enumTable;
    dword_254105D80 = 9;
    __cxa_guard_release(&qword_254105D40);
  }
  if (v2)
  {
    if ((_MergedGlobals_129 & 1) != 0)
      return &qword_254105D70;
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)v63);
    v5 = _MergedGlobals_129;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)v63);
    if ((v5 & 1) != 0)
      return &qword_254105D70;
    v7 = re::introspectionSharedMutex(v6);
    std::__shared_mutex_base::lock(v7);
    if ((_MergedGlobals_129 & 1) != 0)
    {
LABEL_34:
      v31 = re::introspectionSharedMutex(v8);
      std::__shared_mutex_base::unlock(v31);
      return &qword_254105D70;
    }
  }
  _MergedGlobals_129 = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_254105D70, a2);
  v59 = 0x86222B7974B6;
  v60 = "ShapeType";
  v63[0] = 208862;
  v63[1] = "int";
  v9 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v63);
  if (v9)
  {
    v10 = *v9;
    re::StringID::destroyString((re::StringID *)v63);
    v11 = (unsigned int *)qword_254105DB0;
    v62[1] = v10;
    re::TypeBuilder::beginEnumType((uint64_t)v63, &v59, 1, 1, (uint64_t)v62);
    v13 = *v11;
    if ((_DWORD)v13)
    {
      for (i = 0; i < v13; ++i)
      {
        v15 = *(_QWORD *)(*((_QWORD *)v11 + 1) + 8 * i);
        if (*(_DWORD *)v15 == 1)
        {
          v16 = *(char **)(v15 + 16);
          if (v16)
          {
            v17 = *v16;
            if (*v16)
            {
              v18 = v16[1];
              if (v18)
              {
                v19 = (unsigned __int8 *)(v16 + 2);
                do
                {
                  v17 = 31 * v17 + v18;
                  v20 = *v19++;
                  v18 = v20;
                }
                while (v20);
              }
            }
          }
          else
          {
            v17 = 0;
          }
          v21 = *(_QWORD *)(v15 + 8);
          *(_QWORD *)&v61.var0 = 2 * v17;
          v61.var1 = v16;
          re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v63, v21, &v61);
          re::StringID::destroyString((re::StringID *)&v61);
          v13 = *v11;
        }
      }
      if (v13)
      {
        for (j = 0; j < v13; ++j)
        {
          v23 = *(_QWORD *)(*((_QWORD *)v11 + 1) + 8 * j);
          if (*(_DWORD *)v23 == 2)
          {
            v24 = *(char **)(v23 + 16);
            if (v24)
            {
              v25 = *v24;
              if (*v24)
              {
                v26 = v24[1];
                if (v26)
                {
                  v27 = (unsigned __int8 *)(v24 + 2);
                  do
                  {
                    v25 = 31 * v25 + v26;
                    v28 = *v27++;
                    v26 = v28;
                  }
                  while (v28);
                }
              }
            }
            else
            {
              v25 = 0;
            }
            v29 = *(_QWORD *)(v23 + 8);
            *(_QWORD *)&v61.var0 = 2 * v25;
            v61.var1 = v24;
            re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v63, v29, &v61);
            re::StringID::destroyString((re::StringID *)&v61);
            v13 = *v11;
          }
        }
      }
    }
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v63, v30);
    xmmword_254105D90 = (__int128)v61;
    re::StringID::destroyString((re::StringID *)&v59);
    if ((v2 & 1) != 0)
      return &qword_254105D70;
    goto LABEL_34;
  }
  re::StringID::destroyString((re::StringID *)v63);
  re::internal::assertLog((re::internal *)5, v58, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "ShapeType", v59, v60);
  result = (uint64_t *)_os_crash();
  __break(1u);
  return result;
}

uint64_t *re::CollisionShape::localTransform(re::CollisionShape *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&qword_254105D48);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_254105D48))
  {
    qword_254105D50 = 0;
    unk_254105D58 = 0;
    qword_254105D60 = 0;
    unk_254105D68 = 0x3F80000000000000;
    __cxa_guard_release(&qword_254105D48);
  }
  return &qword_254105D50;
}

uint64_t re::PhysXManifoldContainer::size(re::PhysXManifoldContainer *this)
{
  return *(unsigned int *)(*((_QWORD *)this + 1) + 40);
}

uint64_t re::PhysXManifoldContainer::rawManifold(re::PhysXManifoldContainer *this, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *((_QWORD *)this + 1);
  if (*(_QWORD *)(v2 + 40) <= (unint64_t)a2)
    return 0;
  if (*(_QWORD *)(v2 + 8) <= (unint64_t)a2 >> 8)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if ((*(_BYTE *)(v2 + 16) & 1) != 0)
    v3 = v2 + 24;
  else
    v3 = *(_QWORD *)(v2 + 32);
  return *(_QWORD *)(v3 + 8 * ((unint64_t)a2 >> 8)) + 56 * a2;
}

uint64_t re::PhysXManifoldContainer::numContacts(re::PhysXManifoldContainer *this, unsigned int *a2)
{
  return a2[8];
}

uint64_t re::PhysXManifoldContainer::collisionObjectA(re::PhysXManifoldContainer *this, const void *a2)
{
  return *(_QWORD *)a2;
}

uint64_t re::PhysXManifoldContainer::collisionObjectB(re::PhysXManifoldContainer *this, _QWORD *a2)
{
  return a2[1];
}

float32_t re::PhysXManifoldContainer::setContacts(re::PhysXManifoldContainer *this, _QWORD *a2, re::ContactSet *a3, signed __int32 a4, int a5, char a6, int32x4_t a7, int32x4_t a8, int32x4_t a9, float32x4_t a10, float32x4_t a11, float32x4_t a12, float32x4_t a13, float32x4_t a14)
{
  float v14;
  float32x4_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  float32x4_t v19;
  uint64_t v20;
  float32x4_t v21;
  float32x2_t v22;
  __n128 *v23;
  float v24;
  float32x4_t v25;
  float32x4_t v26;

  if (a5)
  {
    if (!a2[4])
      goto LABEL_22;
    a7.i32[0] = 0;
    v14 = -*(float *)(a2[6] + 12);
    a9.i32[0] = a4;
    v15 = (float32x4_t)vandq_s8(*((int8x16_t *)a3 + 5), (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8((int8x16_t)vceqq_s32(a9, a7)), 0));
    if (a4)
      v14 = *((float *)a3 + 24);
    if (a5 >= 1)
    {
      v16 = 0;
      v17 = 0;
      v18 = 80 * a4;
      v19 = 0uLL;
      while (a2[4] > v17)
      {
        v20 = a2[6] + v16;
        if ((a6 & 1) != 0)
        {
          a12.i64[0] = *(_QWORD *)v20;
          a10.i64[0] = *(_QWORD *)(v20 + 12);
          v21 = a10;
          v21.i32[1] = *(_DWORD *)(v20 + 20);
          *(float32x2_t *)a11.f32 = vadd_f32(vmul_f32((float32x2_t)vrev64_s32(*(int32x2_t *)a10.f32), *(float32x2_t *)v21.f32), *(float32x2_t *)v20);
          a12.i32[2] = *(_DWORD *)(v20 + 8);
          a11.f32[2] = a12.f32[2] + (float)(*(float *)(v20 + 24) * a10.f32[0]);
          a13.i64[0] = *(_QWORD *)(v20 + 16);
          a13.i32[2] = *(_DWORD *)(v20 + 24);
          a13 = vnegq_f32(a13);
          v21.i64[0] = *(_QWORD *)(v20 + 32);
          v21.i32[2] = *(_DWORD *)(v20 + 40);
          a14 = vnegq_f32(v21);
        }
        else
        {
          a10.i64[0] = *(_QWORD *)(v20 + 12);
          a11 = a10;
          a11.i32[1] = *(_DWORD *)(v20 + 20);
          v22 = vmul_f32((float32x2_t)vrev64_s32(*(int32x2_t *)a10.f32), *(float32x2_t *)a11.f32);
          a11.i64[0] = *(_QWORD *)v20;
          *(float32x2_t *)a12.f32 = vadd_f32(v22, *(float32x2_t *)v20);
          a12.f32[2] = (float)(*(float *)(v20 + 24) * a10.f32[0]) + *(float *)(v20 + 8);
          a11.i32[2] = *(_DWORD *)(v20 + 8);
          a13.i64[0] = *(_QWORD *)(v20 + 16);
          a13.i32[2] = *(_DWORD *)(v20 + 24);
          a14.i64[0] = *(_QWORD *)(v20 + 32);
          a14.i32[2] = *(_DWORD *)(v20 + 40);
        }
        if (*((_QWORD *)a3 + 4) <= a4 + v17)
          goto LABEL_21;
        v23 = (__n128 *)(*((_QWORD *)a3 + 6) + v18);
        *v23 = (__n128)a12;
        v23[1] = (__n128)a11;
        v23[2] = (__n128)a13;
        v23[3] = (__n128)a14;
        v23[4].n128_u32[0] = a10.i32[0];
        a11 = vaddq_f32(a11, a12);
        v19 = vaddq_f32(v19, a11);
        v15 = vaddq_f32(v15, a14);
        v24 = -a10.f32[0];
        if (v14 < v24)
          v14 = v24;
        ++v17;
        v16 += 48;
        v18 += 80;
        if (48 * a5 == v16)
          goto LABEL_19;
      }
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_21:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_22:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
  else
  {
    a7.i32[0] = 0;
    a8.i32[0] = a4;
    v15 = (float32x4_t)vandq_s8(*((int8x16_t *)a3 + 5), (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8((int8x16_t)vceqq_s32(a8, a7)), 0));
    v14 = *((float *)a3 + 24);
    if (!a4)
      v14 = 0.0;
  }
  v19 = 0uLL;
LABEL_19:
  a10.f32[0] = (float)(2 * a5);
  v25 = vaddq_f32(vdivq_f32(v19, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a10.f32, 0)), *((float32x4_t *)a3 + 4));
  v26.i64[0] = 0x3F0000003F000000;
  v26.i64[1] = 0x3F0000003F000000;
  *((float32x4_t *)a3 + 4) = vmulq_f32(v25, v26);
  *((float32x4_t *)a3 + 5) = v15;
  *((float *)a3 + 24) = v14;
  return v15.f32[0];
}

void re::PhysXManifoldContainer::~PhysXManifoldContainer(re::PhysXManifoldContainer *this)
{
  JUMPOUT(0x2276933B8);
}

void re::internal::PhysXControllerHitReport::onHit(uint64_t a1, _QWORD *a2, float64x2_t *a3)
{
  float64x2_t v5;
  float v6;
  float32x4_t v7;
  uint64_t v8;
  float32x4_t v9;
  float32x4_t v10;
  uint64_t v11;
  float32x4_t v12;
  uint64_t v13;
  float32x4_t v14;
  float v15;
  float64_t v16;
  re::CollisionObject *v17;
  int v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t i;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  __int128 v26;
  float32x4_t v27;
  float v28;
  _OWORD v29[2];
  uint64_t v30;
  int v31;
  const char *v32;
  __int16 v33;
  int v34;
  __int16 v35;
  unint64_t v36;
  __int16 v37;
  unint64_t v38;
  id from[2];
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  uint64_t v44;

  v44 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)&a3->f64[0] = a1;
  v5 = *(float64x2_t *)(a2 + 1);
  *(float32x2_t *)&v5.f64[0] = vcvt_f32_f64(v5);
  v6 = *((double *)a2 + 3);
  *(float *)&v5.f64[1] = v6;
  a3[1] = v5;
  v5.f64[0] = (float64_t)a2[4];
  LODWORD(v5.f64[1]) = *((_DWORD *)a2 + 10);
  a3[2] = v5;
  LODWORD(a3[4].f64[0]) = *((_DWORD *)a2 + 14);
  v5.f64[0] = *(float64_t *)((char *)a2 + 44);
  LODWORD(v5.f64[1]) = *((_DWORD *)a2 + 13);
  a3[3] = v5;
  v7.i64[0] = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 160))(a1);
  v7.i64[1] = v8;
  v9 = vmulq_f32((float32x4_t)a3[1], v7);
  v28 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v9, 2), vaddq_f32(v9, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v9.f32, 1))).f32[0];
  v10.i64[0] = (*(uint64_t (**)(_QWORD))(**(_QWORD **)&a3->f64[0] + 88))(*(_QWORD *)&a3->f64[0]);
  v10.i64[1] = v11;
  v27 = v10;
  v12.i64[0] = (*(uint64_t (**)(_QWORD))(**(_QWORD **)&a3->f64[0] + 160))(*(_QWORD *)&a3->f64[0]);
  v12.i64[1] = v13;
  v14 = vmulq_f32(v27, v12);
  v27.f32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 2), vaddq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 1))).f32[0];
  v15 = (*(float (**)(_QWORD))(*(_QWORD *)*a2 + 232))(*a2);
  v16 = a3->f64[0];
  if (v28 < (float)(v27.f32[0] + (float)(v15 * -0.5)))
  {
    *(_BYTE *)(*(_QWORD *)&v16 + 76) |= 1u;
    v17 = *(re::CollisionObject **)&a3->f64[1];
    if ((*((_BYTE *)v17 + 8) & 1) != 0)
    {
      re::CollisionObject::weakPointer(v17, from);
      if (from != (id *)(*(_QWORD *)&v16 + 96))
      {
        objc_destroyWeak((id *)(*(_QWORD *)&v16 + 96));
        *(_QWORD *)(*(_QWORD *)&v16 + 96) = 0;
        objc_moveWeak((id *)(*(_QWORD *)&v16 + 96), from);
      }
      objc_destroyWeak(from);
      (*(void (**)(id *__return_ptr))(**(_QWORD **)(*(_QWORD *)&a3->f64[1] + 16) + 40))(from);
      *(_OWORD *)(*(_QWORD *)&v16 + 80) = *(_OWORD *)from;
    }
    else
    {
      objc_destroyWeak((id *)(*(_QWORD *)&v16 + 96));
      *(_QWORD *)(*(_QWORD *)&v16 + 96) = 0;
    }
  }
  v18 = *(_DWORD *)(*(_QWORD *)&v16 + 248);
  *(_DWORD *)(*(_QWORD *)&v16 + 248) = v18 + 1;
  if (*(_QWORD *)(*(_QWORD *)&v16 + 184))
  {
    v19 = 0;
    do
    {
      if ((*(unsigned int (**)(float64x2_t *))(*(_QWORD *)(*(_QWORD *)&v16 + 200) + 32 * v19 + 24))(a3) == 1)
        re::DynamicArray<re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription>::removeStableAt((_QWORD *)(*(_QWORD *)&v16 + 168), v19);
      else
        ++v19;
    }
    while (v19 < *(_QWORD *)(*(_QWORD *)&v16 + 184));
    v18 = *(_DWORD *)(*(_QWORD *)&v16 + 248) - 1;
  }
  *(_DWORD *)(*(_QWORD *)&v16 + 248) = v18;
  if (!v18)
  {
    v20 = *(_QWORD *)(*(_QWORD *)&v16 + 224);
    if (v20)
    {
      v21 = 0;
      for (i = 0; i != v20; ++i)
      {
        v23 = *(_QWORD *)(*(_QWORD *)&v16 + 224);
        if (v23 <= i)
        {
          v42 = 0u;
          v43 = 0u;
          v41 = 0u;
          *(_OWORD *)from = 0u;
          v40 = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          v31 = 136315906;
          v32 = "operator[]";
          v33 = 1024;
          v34 = 789;
          v35 = 2048;
          v36 = i;
          v37 = 2048;
          v38 = v23;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        v24 = *(_QWORD *)(*(_QWORD *)&v16 + 240) + v21;
        v25 = *(_QWORD *)(v24 + 32);
        v26 = *(_OWORD *)(v24 + 16);
        v29[0] = *(_OWORD *)v24;
        v29[1] = v26;
        v30 = v25;
        if (LOBYTE(v29[0]))
        {
          re::DynamicArray<re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription>::indexOf(*(_QWORD *)&v16 + 168, (_QWORD *)v29 + 1, (uint64_t)from);
          if (!LOBYTE(from[0]))
            re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)(*(_QWORD *)&v16 + 168), (uint64_t)v29 + 8);
        }
        else
        {
          re::DynamicArray<re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription>::indexOf(*(_QWORD *)&v16 + 168, (_QWORD *)v29 + 1, (uint64_t)from);
          if (LOBYTE(from[0]))
            re::DynamicArray<re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription>::removeStableAt((_QWORD *)(*(_QWORD *)&v16 + 168), (unint64_t)from[1]);
        }
        v21 += 40;
      }
    }
  }
}

void re::internal::PhysXControllerHitReport::onShapeHit(uint64_t a1, _QWORD *a2)
{
  float64x2_t v2[5];
  uint64_t v3;

  v3 = *MEMORY[0x24BDAC8D0];
  memset(&v2[1], 0, 48);
  v2[0].f64[1] = *(float64_t *)(a2[9] + 16);
  re::internal::PhysXControllerHitReport::onHit(*(_QWORD *)(a1 + 8), a2, v2);
}

void re::internal::PhysXControllerHitReport::onControllerHit(uint64_t a1, _QWORD *a2)
{
  float64x2_t v4[5];
  uint64_t v5;

  v5 = *MEMORY[0x24BDAC8D0];
  memset(&v4[1], 0, 48);
  v4[0].f64[1] = *(float64_t *)((*(uint64_t (**)(_QWORD))(*(_QWORD *)*a2 + 160))(*a2) + 136);
  re::internal::PhysXControllerHitReport::onHit(*(_QWORD *)(a1 + 8), a2, v4);
}

void re::internal::PhysXCapsuleController::~PhysXCapsuleController(re::internal::PhysXCapsuleController *this)
{
  *(_QWORD *)this = &off_24ED41200;
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 17) + 40))(*((_QWORD *)this + 17), 0);
  (*(void (**)(_QWORD))(**((_QWORD **)this + 19) + 8))(*((_QWORD *)this + 19));
  *((_QWORD *)this + 19) = 0;
  re::CharacterController::~CharacterController(this);
}

{
  *(_QWORD *)this = &off_24ED41200;
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 17) + 40))(*((_QWORD *)this + 17), 0);
  (*(void (**)(_QWORD))(**((_QWORD **)this + 19) + 8))(*((_QWORD *)this + 19));
  *((_QWORD *)this + 19) = 0;
  re::CharacterController::~CharacterController(this);
  JUMPOUT(0x2276933B8);
}

__n128 re::internal::PhysXCapsuleController::pose@<Q0>(re::internal::PhysXCapsuleController *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  float64x2_t *v4;
  float v5;
  float64x2_t v6;
  __n128 result;
  float v8[3];
  uint64_t v9;
  int v10;

  v3 = *((_QWORD *)this + 19);
  v4 = (float64x2_t *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 32))(v3);
  v9 = 0x3F80000000000000;
  v10 = 0;
  (*(void (**)(float *__return_ptr, uint64_t))(*(_QWORD *)v3 + 112))(v8, v3);
  physx::PxShortestRotation((float *)&v9, v8, (float *)(a2 + 16));
  v6 = *v4;
  *(float32x2_t *)&v6.f64[0] = vcvt_f32_f64(*v4);
  v5 = v4[1].f64[0];
  *(float *)&v6.f64[1] = v5;
  *(float64x2_t *)a2 = v6;
  result.n128_u64[0] = *(_QWORD *)&v6.f64[0];
  result.n128_u32[2] = LODWORD(v6.f64[1]);
  return result;
}

uint64_t re::internal::PhysXCapsuleController::setPoseInternal(uint64_t a1, uint64_t a2)
{
  int v4;
  uint64_t v5;
  double v6;
  float32x4_t v7;
  float32x4_t v8;
  float32x4_t v9;
  int32x4_t v10;
  float32x4_t v11;
  int32x4_t v12;
  float32x4_t v13;
  uint64_t result;
  float64x2_t v15;
  double v16;

  if (physx::shdfnd::g_isLockingEnabled)
    v4 = 1;
  else
    v4 = physx::shdfnd::g_alwaysUseLocking;
  if ((physx::shdfnd::g_alwaysUseLocking & 1) == 0 && physx::shdfnd::g_isLockingEnabled)
    physx::shdfnd::g_isLockingEnabled = 0;
  v5 = *(_QWORD *)(a1 + 152);
  v6 = *(float *)(a2 + 8);
  v15 = vcvtq_f64_f32(*(float32x2_t *)a2);
  v16 = v6;
  (*(void (**)(uint64_t, float64x2_t *))(*(_QWORD *)v5 + 24))(v5, &v15);
  v7 = *(float32x4_t *)(a2 + 16);
  v8 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v7, (int32x4_t)v7), (int8x16_t)v7, 0xCuLL);
  v9 = vmlaq_f32(vmulq_f32(v7, (float32x4_t)xmmword_2261027C0), (float32x4_t)xmmword_2260E5F20, v8);
  v10 = (int32x4_t)vaddq_f32(v9, v9);
  v11 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v10, v10), (int8x16_t)v10, 0xCuLL);
  v12 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v11, (int32x4_t)v11), (int8x16_t)v11, 0xCuLL), vnegq_f32(v7)), v11, v8);
  v13 = vaddq_f32(vaddq_f32(vmulq_laneq_f32(v11, v7, 3), (float32x4_t)xmmword_2260E5F20), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v12, v12), (int8x16_t)v12, 0xCuLL));
  *(_QWORD *)&v15.f64[0] = v13.i64[0];
  LODWORD(v15.f64[1]) = v13.i32[2];
  result = (*(uint64_t (**)(uint64_t, float64x2_t *))(*(_QWORD *)v5 + 120))(v5, &v15);
  *(_QWORD *)(a1 + 256) = 0;
  *(_QWORD *)(a1 + 264) = 0;
  *(_QWORD *)(a1 + 112) = 0;
  *(_QWORD *)(a1 + 120) = 0;
  *(_DWORD *)(a1 + 128) = 0;
  *(_BYTE *)(a1 + 132) = 1;
  if (physx::shdfnd::g_isLockingEnabled != v4)
    physx::shdfnd::g_isLockingEnabled = v4;
  return result;
}

void re::internal::PhysXCapsuleController::updateVelocity(re::internal::PhysXCapsuleController *this, double a2)
{
  int v3;
  float32x4_t v4;
  uint64_t v5;
  float32x4_t v6;
  uint64_t v7;
  float32x4_t v8;
  uint64_t v9;
  float32x4_t v10;
  float64x2_t v11;
  double v12;
  float32x4_t v13[2];

  if (physx::shdfnd::g_isLockingEnabled)
    v3 = 1;
  else
    v3 = physx::shdfnd::g_alwaysUseLocking;
  if ((physx::shdfnd::g_alwaysUseLocking & 1) == 0 && physx::shdfnd::g_isLockingEnabled)
    physx::shdfnd::g_isLockingEnabled = 0;
  if (*((_BYTE *)this + 132))
  {
    LODWORD(a2) = *((_DWORD *)this + 32);
    v4 = 0uLL;
    if (*(float *)&a2 > 0.0)
      v4 = vdivq_f32(*((float32x4_t *)this + 7), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a2, 0));
    *((float32x4_t *)this + 16) = v4;
    *((_QWORD *)this + 14) = 0;
    *((_QWORD *)this + 15) = 0;
    *(_QWORD *)((char *)this + 125) = 0;
  }
  if (re::CharacterController::onPlatform((id *)this))
  {
    if ((*((_BYTE *)this + 76) & 1) != 0)
    {
      v5 = re::CharacterController::onPlatform((id *)this);
      (*(void (**)(float32x4_t *__return_ptr))(**(_QWORD **)(v5 + 16) + 40))(v13);
      v10 = vsubq_f32(v13[0], *((float32x4_t *)this + 5));
      v6.i64[0] = (*(uint64_t (**)(re::internal::PhysXCapsuleController *))(*(_QWORD *)this + 88))(this);
      v6.i64[1] = v7;
      v8 = vaddq_f32(v10, v6);
      v9 = *((_QWORD *)this + 19);
      v11 = vcvtq_f64_f32(*(float32x2_t *)v8.f32);
      v12 = v8.f32[2];
      (*(void (**)(uint64_t, float64x2_t *))(*(_QWORD *)v9 + 24))(v9, &v11);
      *((float32x4_t *)this + 5) = v13[0];
    }
    else
    {
      objc_destroyWeak((id *)this + 12);
      *((_QWORD *)this + 12) = 0;
    }
  }
  if (physx::shdfnd::g_isLockingEnabled != v3)
    physx::shdfnd::g_isLockingEnabled = v3;
}

uint64_t re::internal::PhysXCapsuleController::move(float32x4_t *a1, float32x4_t *a2, float a3)
{
  int v6;
  int v7;
  float32x4_t v8;
  uint64_t v9;
  float32x4_t v10;
  uint64_t v11;
  float32x4_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  double v20;
  uint64_t v21;
  __int32 v22;
  float64x2_t *v23;
  float32x4_t v24;
  unsigned int v25;
  float32x4_t v26;
  uint64_t v27;
  float32x4_t v28;
  uint64_t v29;
  float32x4_t v30;
  float32x4_t v31;
  uint64_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float v37;
  float32x4_t v38;
  uint64_t v39;
  float32x4_t v40;
  float v41;
  uint64_t v42;
  float32x4_t v43;
  uint64_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  int32x2_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float v52;
  float32x4_t v54;
  float v55;
  float32x4_t v56;
  float64x2_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  uint64_t v61;
  __int32 v62;
  unsigned __int8 v63;
  _QWORD v64[2];
  __int16 v65;
  uint64_t v66;
  uint64_t v67;
  int v68;
  int v69;
  _QWORD v70[2];
  int v71;
  int v72;
  int v73;

  v6 = physx::shdfnd::g_isLockingEnabled;
  if (physx::shdfnd::g_isLockingEnabled)
    v7 = 1;
  else
    v7 = physx::shdfnd::g_alwaysUseLocking;
  if ((physx::shdfnd::g_alwaysUseLocking & 1) == 0 && physx::shdfnd::g_isLockingEnabled)
  {
    v6 = 0;
    physx::shdfnd::g_isLockingEnabled = 0;
  }
  a1[8].f32[0] = a1[8].f32[0] + a3;
  a1[8].i8[4] = 1;
  v8 = vmulq_f32(*a2, *a2);
  if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v8, 2), vaddq_f32(v8, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.f32, 1))).f32[0] >= 1.0e-10)
  {
    v10.i64[0] = (*(uint64_t (**)(float32x4_t *))(a1->i64[0] + 160))(a1);
    v10.i64[1] = v11;
    v12 = vmulq_f32(*a2, v10);
    v60 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 2), vaddq_f32(v12, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 1)));
    v13 = (*(uint64_t (**)(float32x4_t *))(a1->i64[0] + 160))(a1);
    v15 = v14;
    if (v60.f32[0] > 0.0)
      a1[4].i8[12] &= ~1u;
    v16 = *(_DWORD *)(a1[8].i64[1] + 32);
    v17 = *(_DWORD *)(a1[8].i64[1] + 36);
    v70[0] = off_24ED41130;
    v70[1] = 0;
    v71 = v16;
    v72 = v17;
    v73 = 2;
    v67 = 0;
    v68 = v16;
    v69 = v17;
    v64[0] = &v67;
    v64[1] = v70;
    v65 = 7;
    v66 = 0;
    v18 = a1[9].i64[1];
    v19 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v18 + 32))(v18);
    v20 = *(double *)(v19 + 16);
    v21 = a1[9].i64[1];
    v22 = a2->i32[2];
    v61 = a2->i64[0];
    v62 = v22;
    v57 = *(float64x2_t *)v19;
    (*(void (**)(unsigned __int8 *__return_ptr, uint64_t, uint64_t *, _QWORD *, _QWORD, float, float))(*(_QWORD *)v21 + 16))(&v63, v21, &v61, v64, 0, 0.0, a3);
    v9 = v63;
    v23 = (float64x2_t *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v18 + 32))(v18);
    *(float32x2_t *)v24.f32 = vcvt_f32_f64(vsubq_f64(*v23, v57));
    *(float *)&v25 = v23[1].f64[0] - v20;
    v24.i64[1] = __PAIR64__(HIDWORD(v57.f64[1]), v25);
    v58 = v24;
    v26.i64[0] = (*(uint64_t (**)(float32x4_t *))(a1->i64[0] + 160))(a1);
    v26.i64[1] = v27;
    v28 = vmulq_f32(v58, v26);
    v56 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v28, 2), vaddq_f32(v28, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v28.f32, 1)));
    v29 = (*(uint64_t (**)(float32x4_t *))(a1->i64[0] + 160))(a1);
    v30 = v56;
    v31.i64[0] = v29;
    v31.i64[1] = v32;
    v33 = vmulq_n_f32(v31, v56.f32[0]);
    v34 = vsubq_f32(v58, v33);
    v35 = *a2;
    v36 = vmulq_f32(*a2, v33);
    if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v36, 2), vaddq_f32(v36, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v36.f32, 1))).f32[0] > 0.0)
    {
      v37 = fabsf(v60.f32[0]);
      if (v37 > 0.00001)
      {
        v59 = v34;
        v54 = v33;
        v38.i64[0] = (*(uint64_t (**)(float32x4_t *))(a1->i64[0] + 160))(a1);
        v38.i64[1] = v39;
        v40 = vmulq_f32(v54, v38);
        v41 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v40, 2), vaddq_f32(v40, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v40.f32, 1))).f32[0];
        if (v37 <= v41)
          v41 = v37;
        v55 = v41;
        v42 = (*(uint64_t (**)(float32x4_t *))(a1->i64[0] + 160))(a1);
        v30 = v56;
        v34 = v59;
        v43.i64[0] = v42;
        v43.i64[1] = v44;
        a1[7] = vaddq_f32(a1[7], vmulq_n_f32(v43, v55));
        v35 = *a2;
      }
    }
    v45 = vmulq_f32(v34, v35);
    if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v45, 2), vaddq_f32(v45, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v45.f32, 1))).f32[0] > 0.0)
    {
      v46.i64[0] = v13;
      v46.i64[1] = v15;
      v47 = vsubq_f32(v35, vmulq_n_f32(v46, v60.f32[0]));
      v48 = vmulq_f32(v47, v47);
      v49 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v48, 2), vaddq_f32(v48, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v48.f32, 1))).u64[0];
      *(float *)v49.i32 = sqrtf(*(float *)v49.i32);
      if (*(float *)v49.i32 > 0.00001)
      {
        v50 = vdivq_f32(v47, (float32x4_t)vdupq_lane_s32(v49, 0));
        v51 = vmulq_f32(v34, v50);
        v52 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v51, 2), vaddq_f32(v51, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v51.f32, 1))).f32[0];
        if (*(float *)v49.i32 > v52)
          *(float *)v49.i32 = v52;
        a1[7] = vaddq_f32(vmulq_n_f32(v50, *(float *)v49.i32), a1[7]);
      }
    }
    if (v60.f32[0] < 0.0 && (a1[4].i8[12] & 1) != 0 && v30.f32[0] < 0.0 && fabsf(vsubq_f32(v60, v30).f32[0]) < 0.0001)
      a1[4].i8[12] &= ~1u;
    v6 = physx::shdfnd::g_isLockingEnabled;
  }
  else
  {
    v9 = 0;
  }
  if (v6 != v7)
    physx::shdfnd::g_isLockingEnabled = v7;
  return v9;
}

float32x2_t re::internal::PhysXCapsuleController::position(re::internal::PhysXCapsuleController *this)
{
  return vcvt_f32_f64(*(float64x2_t *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 19) + 32))(*((_QWORD *)this + 19)));
}

float32x2_t re::internal::PhysXCapsuleController::footPosition(re::internal::PhysXCapsuleController *this)
{
  float64x2_t v1;
  float64_t v2;

  v1.f64[0] = (*(double (**)(_QWORD))(**((_QWORD **)this + 19) + 48))(*((_QWORD *)this + 19));
  v1.f64[1] = v2;
  return vcvt_f32_f64(v1);
}

uint64_t re::internal::PhysXCapsuleController::setFootPosition(uint64_t a1, float32x2_t *a2)
{
  int v2;
  uint64_t v3;
  double v4;
  uint64_t result;
  float64x2_t v6;
  double v7;

  if (physx::shdfnd::g_isLockingEnabled)
    v2 = 1;
  else
    v2 = physx::shdfnd::g_alwaysUseLocking;
  if ((physx::shdfnd::g_alwaysUseLocking & 1) == 0 && physx::shdfnd::g_isLockingEnabled)
    physx::shdfnd::g_isLockingEnabled = 0;
  v3 = *(_QWORD *)(a1 + 152);
  v4 = a2[1].f32[0];
  v6 = vcvtq_f64_f32(*a2);
  v7 = v4;
  result = (*(uint64_t (**)(uint64_t, float64x2_t *))(*(_QWORD *)v3 + 40))(v3, &v6);
  if (physx::shdfnd::g_isLockingEnabled != v2)
    physx::shdfnd::g_isLockingEnabled = v2;
  return result;
}

void re::internal::PhysXCapsuleController::setPosition(uint64_t a1, float32x2_t *a2)
{
  int v3;
  uint64_t v4;
  double v5;
  float64x2_t v6;
  double v7;

  if (physx::shdfnd::g_isLockingEnabled)
    v3 = 1;
  else
    v3 = physx::shdfnd::g_alwaysUseLocking;
  if ((physx::shdfnd::g_alwaysUseLocking & 1) == 0 && physx::shdfnd::g_isLockingEnabled)
    physx::shdfnd::g_isLockingEnabled = 0;
  v4 = *(_QWORD *)(a1 + 152);
  v5 = a2[1].f32[0];
  v6 = vcvtq_f64_f32(*a2);
  v7 = v5;
  (*(void (**)(uint64_t, float64x2_t *))(*(_QWORD *)v4 + 24))(v4, &v6);
  objc_destroyWeak((id *)(a1 + 96));
  *(_QWORD *)(a1 + 96) = 0;
  *(_BYTE *)(a1 + 76) &= ~1u;
  *(_QWORD *)(a1 + 256) = 0;
  *(_QWORD *)(a1 + 264) = 0;
  *(_QWORD *)(a1 + 112) = 0;
  *(_QWORD *)(a1 + 120) = 0;
  *(_DWORD *)(a1 + 128) = 0;
  *(_BYTE *)(a1 + 132) = 1;
  if (physx::shdfnd::g_isLockingEnabled != v3)
    physx::shdfnd::g_isLockingEnabled = v3;
}

float re::internal::PhysXCapsuleController::radius(re::internal::PhysXCapsuleController *this)
{
  return *((float *)this + 85);
}

uint64_t re::internal::PhysXCapsuleController::setRadius(re::internal::PhysXCapsuleController *this, float a2)
{
  uint64_t v2;
  float v3;

  *((float *)this + 85) = a2;
  v2 = *((_QWORD *)this + 19);
  v3 = COERCE_FLOAT((*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 17) + 16))(*((_QWORD *)this + 17))) * a2;
  return (*(uint64_t (**)(uint64_t, float))(*(_QWORD *)v2 + 224))(v2, v3);
}

float re::internal::PhysXCapsuleController::height(re::internal::PhysXCapsuleController *this)
{
  float v1;

  v1 = *((float *)this + 84);
  return v1
       + (float)((*(float (**)(re::internal::PhysXCapsuleController *))(*(_QWORD *)this + 176))(this) * 2.0);
}

uint64_t re::internal::PhysXCapsuleController::setHeight(re::internal::PhysXCapsuleController *this, float a2)
{
  float v3;
  float v4;
  uint64_t v5;
  float v6;

  v3 = a2
     + (float)((*(float (**)(re::internal::PhysXCapsuleController *))(*(_QWORD *)this + 176))(this) * -2.0);
  if (v3 >= 0.01)
    v4 = v3;
  else
    v4 = 0.01;
  *((float *)this + 84) = v4;
  v5 = *((_QWORD *)this + 19);
  v6 = v4 * COERCE_FLOAT((*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 17) + 16))(*((_QWORD *)this + 17)));
  return (*(uint64_t (**)(uint64_t, float))(*(_QWORD *)v5 + 240))(v5, v6);
}

uint64_t re::internal::PhysXCapsuleController::resize(re::internal::PhysXCapsuleController *this, float a2)
{
  float v3;
  float v4;
  uint64_t v5;
  float v6;

  v3 = a2
     + (float)((*(float (**)(re::internal::PhysXCapsuleController *))(*(_QWORD *)this + 176))(this) * -2.0);
  if (v3 >= 0.01)
    v4 = v3;
  else
    v4 = 0.01;
  *((float *)this + 84) = v4;
  v5 = *((_QWORD *)this + 19);
  v6 = v4 * COERCE_FLOAT((*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 17) + 16))(*((_QWORD *)this + 17)));
  return (*(uint64_t (**)(uint64_t, float))(*(_QWORD *)v5 + 192))(v5, v6);
}

uint64_t re::internal::PhysXCapsuleController::setSkinWidth(re::internal::PhysXCapsuleController *this, float a2)
{
  float v4;
  float v5;

  LODWORD(v4) = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 17) + 16))(*((_QWORD *)this + 17));
  v5 = (*(float (**)(re::internal::PhysXCapsuleController *))(*(_QWORD *)this + 176))(this) * 0.1;
  if (v5 > a2)
    v5 = a2;
  *((float *)this + 16) = v5;
  return (*(uint64_t (**)(_QWORD, float))(**((_QWORD **)this + 19) + 104))(*((_QWORD *)this + 19), v5 * v4);
}

float re::internal::PhysXCapsuleController::skinWidth(re::internal::PhysXCapsuleController *this)
{
  return *((float *)this + 16);
}

uint64_t re::internal::PhysXCapsuleController::setSlopeLimit(re::internal::PhysXCapsuleController *this, float a2)
{
  float v2;
  float v3;
  uint64_t v4;
  float v5;

  v2 = 1.0;
  if (a2 <= 1.0)
    v2 = a2;
  if (a2 >= 0.0)
    v3 = v2;
  else
    v3 = 0.0;
  *((float *)this + 18) = v3;
  v4 = *((_QWORD *)this + 19);
  v5 = cosf(v3);
  return (*(uint64_t (**)(uint64_t, float))(*(_QWORD *)v4 + 136))(v4, v5);
}

float re::internal::PhysXCapsuleController::slopeLimit(re::internal::PhysXCapsuleController *this)
{
  return *((float *)this + 18);
}

uint64_t re::internal::PhysXCapsuleController::setStepLimit(re::internal::PhysXCapsuleController *this, float a2)
{
  float v3;
  float v4;
  float v5;

  if (a2 >= 0.0)
    v3 = a2;
  else
    v3 = 0.0;
  LODWORD(v4) = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 17) + 16))(*((_QWORD *)this + 17));
  v5 = (*(float (**)(re::internal::PhysXCapsuleController *))(*(_QWORD *)this + 176))(this) * 0.2;
  if (v5 > v3)
    v5 = v3;
  *((float *)this + 17) = v5;
  return (*(uint64_t (**)(_QWORD, float))(**((_QWORD **)this + 19) + 64))(*((_QWORD *)this + 19), v5 * v4);
}

float re::internal::PhysXCapsuleController::stepLimit(re::internal::PhysXCapsuleController *this)
{
  return *((float *)this + 17);
}

uint64_t re::internal::PhysXCapsuleController::setUpVector(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  int v3;
  uint64_t v5;
  int v6;

  v2 = *(_QWORD *)(a1 + 152);
  v3 = *((_DWORD *)a2 + 2);
  v5 = *a2;
  v6 = v3;
  return (*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)v2 + 120))(v2, &v5);
}

uint64_t re::internal::PhysXCapsuleController::upVector(re::internal::PhysXCapsuleController *this)
{
  uint64_t v2;

  (*(void (**)(uint64_t *__return_ptr))(**((_QWORD **)this + 19) + 112))(&v2);
  return v2;
}

uint64_t re::internal::PhysXCapsuleController::onScaleChanged(float *a1)
{
  (*(void (**)(float *, float))(*(_QWORD *)a1 + 184))(a1, a1[85]);
  (*(void (**)(float *, float))(*(_QWORD *)a1 + 200))(a1, a1[84] + (float)(a1[85] * 2.0));
  (*(void (**)(float *, float))(*(_QWORD *)a1 + 104))(a1, a1[17]);
  return (*(uint64_t (**)(float *, float))(*(_QWORD *)a1 + 136))(a1, a1[17]);
}

uint64_t re::internal::PhysXCapsuleController::onCollisionFilterChanged(re::internal::PhysXCapsuleController *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 19) + 144))(*((_QWORD *)this + 19));
}

uint64_t re::internal::PhysXCapsuleController::recreateUnderlying(_QWORD *a1, float32x2_t *a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  _QWORD *v10;
  float v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  float v16[3];
  uint64_t v17;
  float v18;
  float v19;
  uint64_t v20;

  v20 = 0x100000000;
  v18 = (*(float (**)(_QWORD *))(*a1 + 192))(a1);
  v19 = (*(float (**)(_QWORD *))(*a1 + 176))(a1);
  v16[0] = (*(float (**)(_QWORD *))(*a1 + 112))(a1);
  v16[1] = (*(float (**)(_QWORD *))(*a1 + 128))(a1);
  v16[2] = (*(float (**)(_QWORD *))(*a1 + 144))(a1);
  v10 = (_QWORD *)a1[17];
  v17 = v10[4];
  LODWORD(v11) = (*(uint64_t (**)(_QWORD *))(*v10 + 16))(v10);
  v12 = a1[46];
  v13 = (*(uint64_t (**)(_QWORD *))(*a1 + 16))(a1);
  re::internal::PhysXCapsuleController::createUnderlyingController(a1, v12, v13, v16, a2, a3, a4, a5, v11);
  v14 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)a1[19] + 56))(a1[19]);
  return (*(uint64_t (**)(_QWORD *, uint64_t))(*v10 + 40))(v10, v14);
}

uint64_t re::internal::PhysXCapsuleController::createUnderlyingController(_QWORD *a1, uint64_t a2, uint64_t a3, float *a4, float32x2_t *a5, uint64_t *a6, uint64_t a7, uint64_t a8, float a9)
{
  float v13;
  float v14;
  float v15;
  double v16;
  int v17;
  uint64_t v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t result;
  uint64_t v32;
  uint64_t (**v33)(physx::PxCapsuleControllerDesc *__hidden);
  float64x2_t v34;
  double v35;
  uint64_t v36;
  int v37;
  float v38;
  uint64_t v39;
  float v40;
  float v41;
  uint64_t v42;
  int v43;
  _QWORD *v44;
  _QWORD *v45;
  int v46;
  uint64_t v47;
  char v48;
  uint64_t v49;
  int v50;
  float v51;
  float v52;
  int v53;

  v13 = a4[6];
  v14 = a4[5] + (float)(v13 * -2.0);
  if (v14 < 0.01)
    v14 = 0.01;
  v50 = 1;
  v43 = 1069547520;
  v49 = 0;
  v39 = 0;
  v48 = 1;
  v33 = &off_24ED41370;
  v15 = v14 * a9;
  v51 = v13 * a9;
  v52 = v14 * a9;
  v16 = a5[1].f32[0];
  v34 = vcvtq_f64_f32(*a5);
  v47 = a8;
  v17 = *((_DWORD *)a6 + 2);
  v18 = *a6;
  v35 = v16;
  v36 = v18;
  v37 = v17;
  v19 = (float)(v13 * a9) * 0.1;
  v20 = a4[1];
  if (v19 > (float)(*a4 * a9))
    v19 = *a4 * a9;
  v21 = v15 * 0.2;
  v22 = a4[2] * a9;
  if (v21 <= v22)
    v23 = v21;
  else
    v23 = v22;
  v40 = v19;
  v41 = v23;
  v24 = cosf(v20);
  v38 = v24;
  v42 = 0x3F80000041200000;
  v53 = 1;
  v46 = 1;
  v44 = a1 + 43;
  v45 = a1 + 45;
  if (v23 < 0.0)
    v41 = 0.0;
  v25 = 0.0;
  if (v24 < 0.0 || (v25 = 1.0, v24 > 1.0))
    v38 = v25;
  v26 = (*(uint64_t (**)(_QWORD, uint64_t (***)(physx::PxCapsuleControllerDesc *__hidden)))(**(_QWORD **)(a7 + 160) + 32))(*(_QWORD *)(a7 + 160), &v33);
  if (v26)
  {
    v28 = v26;
    a1[19] = v26;
    (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v26 + 168))(v26, a1);
    v29 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v28 + 56))(v28);
    v32 = 0;
    (*(void (**)(uint64_t, uint64_t *, uint64_t, _QWORD))(*(_QWORD *)v29 + 192))(v29, &v32, 1, 0);
    v30 = v32;
    a1[7] = v32;
    *(_QWORD *)(v30 + 16) = a1;
    result = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(a7 + 152) + 112))(*(_QWORD *)(a7 + 152), v29, 1);
    a1[18] = a3;
    a1[46] = a2;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v27, "assertion failure: '%s' (%s:line %i) Error creating character controller, check parameters", "pxcontroller != nullptr", "createUnderlyingController", 373);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

void re::internal::PhysXControllerHitReport::~PhysXControllerHitReport(re::internal::PhysXControllerHitReport *this)
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::CharacterController::shape(re::CharacterController *this)
{
  return *((_QWORD *)this + 18);
}

{
  return *((_QWORD *)this + 18);
}

void re::internal::PhysXCapsuleController::poseDidChange(re::internal::PhysXCapsuleController *this, uint64_t a2)
{
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Not supported.", "!\"Unreachable code\"", "poseDidChange", 137);
  _os_crash();
  __break(1u);
}

uint64_t re::CharacterController::type(re::CharacterController *this)
{
  return 1;
}

BOOL physx::PxCapsuleControllerDesc::isValid(physx::PxCapsuleControllerDesc *this)
{
  float v1;
  float v2;
  float v3;
  float v4;
  float v5;
  float v6;

  if (*((_DWORD *)this + 32) <= 1u
    && *((float *)this + 17) >= 0.0
    && *((float *)this + 18) >= 1.0
    && *((float *)this + 16) >= 0.0
    && *((float *)this + 11) >= 0.0
    && (v1 = *((float *)this + 15), v1 >= 0.0)
    && *((float *)this + 14) > 0.0
    && *((_QWORD *)this + 13)
    && (v2 = *((double *)this + 1), (~LODWORD(v2) & 0x7F800000) != 0)
    && (v3 = *((double *)this + 2), (~LODWORD(v3) & 0x7F800000) != 0)
    && (v4 = *((double *)this + 3), (~LODWORD(v4) & 0x7F800000) != 0)
    && (v5 = *((float *)this + 33), v5 > 0.0)
    && (v6 = *((float *)this + 34), v6 > 0.0))
  {
    return v1 <= (float)(v6 + (float)(v5 * 2.0));
  }
  else
  {
    return 0;
  }
}

void physx::PxCapsuleControllerDesc::~PxCapsuleControllerDesc(physx::PxCapsuleControllerDesc *this)
{
  JUMPOUT(0x2276933B8);
}

double physx::PxCapsuleControllerDesc::setToDefault(physx::PxCapsuleControllerDesc *this)
{
  double result;

  result = 0.0078125;
  *((_QWORD *)this + 8) = 0x3F4CCCCD41200000;
  *((_DWORD *)this + 18) = 1069547520;
  *((_QWORD *)this + 15) = 0;
  *((_QWORD *)this + 13) = 0;
  *((_OWORD *)this + 2) = xmmword_226102A10;
  *((_OWORD *)this + 3) = xmmword_226102A20;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = 0;
  *((_DWORD *)this + 24) = 0;
  *((_BYTE *)this + 112) = 1;
  *((_QWORD *)this + 17) = 0;
  *((_DWORD *)this + 33) = 0;
  return result;
}

void re::ContactSetCollection::~ContactSetCollection(re::ContactSetCollection *this)
{
  if (*(_QWORD *)this)
    re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::deinit((uint64_t *)this);
  re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::deinit((uint64_t *)this);
}

void re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 144 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &memset_pattern_10, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 600);
    _os_crash();
    __break(1u);
  }
}

double re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::deinit(uint64_t *a1)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t i;
  uint64_t v6;
  int v7;
  double result;

  v2 = *a1;
  if (v2)
  {
    v3 = *((unsigned int *)a1 + 8);
    if ((_DWORD)v3)
    {
      v4 = 0;
      for (i = 0; i < v3; ++i)
      {
        v6 = a1[2];
        v7 = *(_DWORD *)(v6 + v4);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + v4) = v7 & 0x7FFFFFFF;
          re::ContactSet::~ContactSet((re::ContactSet *)(v6 + v4 + 16));
          v3 = *((unsigned int *)a1 + 8);
        }
        v4 += 144;
      }
      v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

void re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::clear(uint64_t a1)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t i;
  uint64_t v6;
  int v7;
  int v8;

  if (*(_DWORD *)(a1 + 28))
  {
    v2 = *(unsigned int *)(a1 + 24);
    if ((_DWORD)v2)
      memset_pattern16(*(void **)(a1 + 8), &memset_pattern_8, 4 * v2);
    v3 = *(unsigned int *)(a1 + 32);
    if ((_DWORD)v3)
    {
      v4 = 0;
      for (i = 0; i < v3; ++i)
      {
        v6 = *(_QWORD *)(a1 + 16);
        v7 = *(_DWORD *)(v6 + v4);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + v4) = v7 & 0x7FFFFFFF;
          re::ContactSet::~ContactSet((re::ContactSet *)(v6 + v4 + 16));
          v3 = *(unsigned int *)(a1 + 32);
        }
        v4 += 144;
      }
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    v8 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v8;
  }
}

void re::ContactSetCollection::set(uint64_t a1, uint64_t a2)
{
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  int *v8;
  int v9;
  uint64_t v10;
  _QWORD *v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  int *v16;
  int v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int *v36;
  int v37;
  unsigned int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  int v45;
  int v46;
  uint64_t v47;
  int *v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  _BYTE *v53;
  uint64_t v54;
  int v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  float *v59;
  float32x4_t v60;
  _QWORD *v61;
  uint64_t v62;
  int v63;
  BOOL v64;
  char v65;
  char v66;
  int v67;
  int v68;
  uint64_t v69;
  uint64_t v70;
  int *v71;
  int v72;
  uint64_t v73;
  unsigned int v74;
  uint64_t v75;
  uint64_t v76;
  _BYTE *v77;
  int v78;
  uint64_t *v79;
  unsigned int v80;
  unsigned int v81;
  __int128 v82;
  __int128 v83;
  _QWORD v84[3];
  int v85;
  _QWORD v86[2];
  __int128 v87;
  __int128 v88;
  int v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;

  v92 = *MEMORY[0x24BDAC8D0];
  v4 = *(_DWORD *)(a1 + 28);
  v5 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
  if (*(_DWORD *)(a1 + 24) < (v5 + v4))
  {
    v6 = *(unsigned int *)(a1 + 32);
    if ((_DWORD)v6)
    {
      v7 = 0;
      v8 = *(int **)(a1 + 16);
      while (1)
      {
        v9 = *v8;
        v8 += 36;
        if (v9 < 0)
          break;
        if (v6 == ++v7)
        {
          LODWORD(v7) = *(_DWORD *)(a1 + 32);
          break;
        }
      }
    }
    else
    {
      LODWORD(v7) = 0;
    }
    if ((_DWORD)v6 != (_DWORD)v7)
    {
      v10 = v7;
      do
      {
        v11 = (_QWORD *)(*(_QWORD *)(a1 + 16) + 144 * v10);
        *(_QWORD *)(v11[2] + 80) = 0;
        *(_QWORD *)(v11[3] + 80) = 0;
        v11[16] = 0;
        v11[17] = 0;
        if (*(_DWORD *)(a1 + 32) <= (v7 + 1))
          v12 = v7 + 1;
        else
          v12 = *(_DWORD *)(a1 + 32);
        v13 = v7;
        while (1)
        {
          v10 = (v13 + 1);
          if (v12 - 1 == v13)
            break;
          ++v13;
          LODWORD(v7) = v10;
          if ((*(_DWORD *)(*(_QWORD *)(a1 + 16) + 144 * v10) & 0x80000000) != 0)
            goto LABEL_18;
        }
        LODWORD(v7) = v12;
LABEL_18:
        ;
      }
      while ((_DWORD)v6 != (_DWORD)v7);
    }
    re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::setCapacity(a1, 2 * (v5 + v4));
    v14 = *(unsigned int *)(a1 + 32);
    if ((_DWORD)v14)
    {
      v15 = 0;
      v16 = *(int **)(a1 + 16);
      while (1)
      {
        v17 = *v16;
        v16 += 36;
        if (v17 < 0)
          break;
        if (v14 == ++v15)
        {
          LODWORD(v15) = *(_DWORD *)(a1 + 32);
          break;
        }
      }
    }
    else
    {
      LODWORD(v15) = 0;
    }
    if ((_DWORD)v14 != (_DWORD)v15)
    {
      v18 = v15;
      do
      {
        v19 = (_QWORD *)(*(_QWORD *)(a1 + 16) + 144 * v18);
        v20 = v19[2];
        v19 += 2;
        v19[14] = *(_QWORD *)(v20 + 80);
        *(_QWORD *)(v20 + 80) = v19;
        v21 = v19[1];
        v19[15] = *(_QWORD *)(v21 + 80);
        *(_QWORD *)(v21 + 80) = v19;
        if (v14 <= (int)v15 + 1)
          v22 = v15 + 1;
        else
          v22 = v14;
        v23 = v15;
        while (1)
        {
          v18 = (v23 + 1);
          if (v22 - 1 == v23)
            break;
          ++v23;
          LODWORD(v15) = v18;
          if ((*(_DWORD *)(*(_QWORD *)(a1 + 16) + 144 * v18) & 0x80000000) != 0)
            goto LABEL_35;
        }
        LODWORD(v15) = v22;
LABEL_35:
        ;
      }
      while ((_DWORD)v14 != (_DWORD)v15);
    }
  }
  if (v5)
  {
    v24 = 0;
    do
    {
      v25 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 24))(a2, v24);
      v26 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 40))(a2, v25);
      v27 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 48))(a2, v25);
      *(_QWORD *)&v82 = v26;
      *((_QWORD *)&v82 + 1) = v27;
      v28 = (unsigned int *)re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::tryGet(a1, (uint64_t *)&v82);
      if (!v28)
      {
        v29 = *(_QWORD *)a1;
        v87 = 0u;
        v88 = 0u;
        v89 = 0;
        v86[0] = 0;
        *(_DWORD *)((char *)v86 + 7) = 0;
        v90 = 0;
        v91 = 0;
        v84[1] = 0;
        v84[2] = 0;
        v85 = 0;
        v83 = v82;
        v84[0] = v29;
        re::DynamicArray<re::Contact>::setCapacity(v84, 0);
        ++v85;
        v28 = (unsigned int *)re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::addNew(a1, (uint64_t *)&v83);
        re::ContactSet::~ContactSet((re::ContactSet *)&v83);
        v30 = *(_QWORD *)v28;
        *((_QWORD *)v28 + 14) = *(_QWORD *)(*(_QWORD *)v28 + 80);
        *(_QWORD *)(v30 + 80) = v28;
        v31 = *((_QWORD *)v28 + 1);
        *((_QWORD *)v28 + 15) = *(_QWORD *)(v31 + 80);
        *(_QWORD *)(v31 + 80) = v28;
      }
      if (*((_BYTE *)v28 + 56))
      {
        re::ContactSet::merge(v28, a2, v25);
      }
      else
      {
        re::ContactSet::set(v28, a2, v25);
        *((_BYTE *)v28 + 56) = 1;
      }
      v24 = (v24 + 1);
    }
    while (v5 != (_DWORD)v24);
  }
  v32 = *(_QWORD *)(a1 + 48);
  if (v32)
  {
    v33 = *(_QWORD *)(v32 + 64);
    if (v33)
    {
      v34 = *(unsigned int *)(a1 + 32);
      if ((_DWORD)v34)
      {
        v35 = 0;
        v36 = *(int **)(a1 + 16);
        while (1)
        {
          v37 = *v36;
          v36 += 36;
          if (v37 < 0)
            break;
          if (v34 == ++v35)
          {
            LODWORD(v35) = *(_DWORD *)(a1 + 32);
            break;
          }
        }
      }
      else
      {
        LODWORD(v35) = 0;
      }
      v38 = *(_DWORD *)(a1 + 32);
      if ((_DWORD)v34 != (_DWORD)v35)
      {
        v39 = v35;
        do
        {
          v40 = *(_QWORD *)(a1 + 16);
          v41 = v40 + 144 * v39;
          v43 = *(_QWORD *)(v41 + 16);
          v42 = v41 + 16;
          v44 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v43 + 48))(v43);
          if (v44)
            LOBYTE(v44) = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v42 + 8) + 48))(*(_QWORD *)(v42 + 8));
          *(_BYTE *)(v40 + 144 * v39 + 74) = v44;
          v38 = *(_DWORD *)(a1 + 32);
          if (v38 <= (int)v35 + 1)
            v45 = v35 + 1;
          else
            v45 = *(_DWORD *)(a1 + 32);
          while (1)
          {
            v39 = (v35 + 1);
            if (v45 - 1 == (_DWORD)v35)
              break;
            LODWORD(v35) = v35 + 1;
            v46 = v39;
            if ((*(_DWORD *)(*(_QWORD *)(a1 + 16) + 144 * v39) & 0x80000000) != 0)
              goto LABEL_63;
          }
          v46 = v45;
LABEL_63:
          LODWORD(v35) = v46;
        }
        while ((_DWORD)v34 != v46);
      }
      v47 = 0;
      if (v38)
      {
        v48 = *(int **)(a1 + 16);
        while (1)
        {
          v49 = *v48;
          v48 += 36;
          if (v49 < 0)
            break;
          if (v38 == ++v47)
          {
            LODWORD(v47) = v38;
            break;
          }
        }
      }
      if (v38 != (_DWORD)v47)
      {
        v50 = v47;
        do
        {
          v51 = *(_QWORD *)(a1 + 16);
          v52 = v51 + 144 * v50;
          v55 = *(unsigned __int8 *)(v52 + 72);
          v53 = (_BYTE *)(v52 + 72);
          LODWORD(v54) = v55;
          if (v55)
          {
            v56 = v51 + 144 * v50;
            v57 = *(_QWORD *)(v56 + 48);
            if (v57)
            {
              v58 = *(_QWORD *)(v56 + 64);
              v54 = 80 * v57;
              v59 = (float *)(v58 + 64);
              while (*v59 > 0.0)
              {
                v60 = vmulq_f32(*(float32x4_t *)(v59 - 4), *(float32x4_t *)(v59 - 4));
                if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v60, 2), vaddq_f32(v60, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v60.f32, 1))).f32[0] != 0.0)break;
                v59 += 20;
                v54 -= 80;
                if (!v54)
                  goto LABEL_80;
              }
              LODWORD(v54) = 1;
            }
            else
            {
              LODWORD(v54) = 0;
            }
          }
LABEL_80:
          v61 = v53 - 56;
          v62 = v51 + 144 * v50;
          v63 = *(unsigned __int8 *)(v62 + 73);
          if (*(_BYTE *)(v62 + 73))
            v64 = *(_BYTE *)(v62 + 74) == 0;
          else
            v64 = 1;
          if (v64)
            v65 = v54;
          else
            v65 = 1;
          *(_BYTE *)(v62 + 73) = v65;
          if (v64)
          {
            if (!v63 && ((v54 ^ 1) & 1) == 0)
            {
              (*(void (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)v33 + 16))(v33, *((_QWORD *)v53 - 7), *((_QWORD *)v53 - 6));
              goto LABEL_99;
            }
          }
          else
          {
            *v53 = 1;
          }
          v66 = v65 ^ 1;
          if (!v63)
            v66 = 1;
          if ((v66 & 1) != 0)
          {
            if (!v63)
              v65 = 1;
            if ((v65 & 1) == 0)
              (*(void (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)v33 + 32))(v33, *v61, v61[1]);
          }
          else
          {
            (*(void (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)v33 + 24))(v33, *v61, v61[1]);
          }
LABEL_99:
          if (*(_DWORD *)(a1 + 32) <= (v47 + 1))
            v67 = v47 + 1;
          else
            v67 = *(_DWORD *)(a1 + 32);
          while (1)
          {
            v50 = (v47 + 1);
            if (v67 - 1 == (_DWORD)v47)
              break;
            LODWORD(v47) = v47 + 1;
            v68 = v50;
            if ((*(_DWORD *)(*(_QWORD *)(a1 + 16) + 144 * v50) & 0x80000000) != 0)
              goto LABEL_106;
          }
          v68 = v67;
LABEL_106:
          LODWORD(v47) = v68;
        }
        while (v38 != v68);
      }
    }
  }
  v69 = *(unsigned int *)(a1 + 32);
  if ((_DWORD)v69)
  {
    v70 = 0;
    v71 = *(int **)(a1 + 16);
    while (1)
    {
      v72 = *v71;
      v71 += 36;
      if (v72 < 0)
        break;
      if (v69 == ++v70)
      {
        LODWORD(v70) = *(_DWORD *)(a1 + 32);
        break;
      }
    }
  }
  else
  {
    LODWORD(v70) = 0;
  }
  if ((_DWORD)v69 != (_DWORD)v70)
  {
    v73 = v70;
    v74 = *(_DWORD *)(a1 + 32);
    do
    {
      v75 = *(_QWORD *)(a1 + 16);
      v76 = v75 + 144 * v73;
      v78 = *(unsigned __int8 *)(v76 + 72);
      v77 = (_BYTE *)(v76 + 72);
      if (v78)
      {
        *v77 = 0;
      }
      else
      {
        v79 = (uint64_t *)(v75 + 144 * v73 + 16);
        re::ContactSetCollection::removeFromLinkedLists(v79);
        re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::remove(a1, v79);
        v74 = *(_DWORD *)(a1 + 32);
      }
      if (v74 <= (int)v70 + 1)
        v80 = v70 + 1;
      else
        v80 = v74;
      while (1)
      {
        v73 = (v70 + 1);
        if (v80 - 1 == (_DWORD)v70)
          break;
        LODWORD(v70) = v70 + 1;
        v81 = v73;
        if ((*(_DWORD *)(*(_QWORD *)(a1 + 16) + 144 * v73) & 0x80000000) != 0)
          goto LABEL_125;
      }
      v81 = v80;
LABEL_125:
      LODWORD(v70) = v81;
    }
    while ((_DWORD)v69 != v81);
  }
}

void re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  unsigned int v7;
  __int128 v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  signed int v16;
  _BYTE v17[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v17, 0, 36);
      *(_QWORD *)&v17[36] = 0x7FFFFFFFLL;
      re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::init((uint64_t)v17, v4, a2);
      v5 = *(_OWORD *)v17;
      *(_OWORD *)v17 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      v6 = *(_QWORD *)&v17[16];
      *(_QWORD *)&v17[16] = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 16) = v6;
      v8 = *(_OWORD *)&v17[24];
      *(_OWORD *)&v17[24] = *(_OWORD *)(a1 + 24);
      v7 = *(_DWORD *)&v17[32];
      *(_OWORD *)(a1 + 24) = v8;
      v9 = v7;
      if (v7)
      {
        v10 = 0;
        v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(_QWORD *)&v17[16] + v10) & 0x80000000) != 0)
          {
            v12 = 0x94D049BB133111EBLL
                * ((0xBF58476D1CE4E5B9
                  * (*(_QWORD *)(*(_QWORD *)&v17[16] + v10 + 16) ^ (*(_QWORD *)(*(_QWORD *)&v17[16] + v10 + 16) >> 30))) ^ ((0xBF58476D1CE4E5B9 * (*(_QWORD *)(*(_QWORD *)&v17[16] + v10 + 16) ^ (*(_QWORD *)(*(_QWORD *)&v17[16] + v10 + 16) >> 30))) >> 27));
            v13 = v12 ^ (v12 >> 31);
            v14 = 0xBF58476D1CE4E5B9
                * (*(_QWORD *)(*(_QWORD *)&v17[16] + v10 + 24) ^ (*(_QWORD *)(*(_QWORD *)&v17[16] + v10 + 24) >> 30));
            v15 = (0x94D049BB133111EBLL * (v14 ^ (v14 >> 27))) ^ ((0x94D049BB133111EBLL * (v14 ^ (v14 >> 27))) >> 31);
            if (v13 == v15)
              v15 = 0;
            re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::addAsMove(a1, (v15 ^ v13) % *(unsigned int *)(a1 + 24), v15 ^ v13, *(_QWORD *)&v17[16] + v10 + 16);
            v9 = *(_DWORD *)&v17[32];
          }
          ++v11;
          v10 += 144;
        }
        while (v11 < v9);
      }
      re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::deinit((uint64_t *)v17);
    }
  }
  else
  {
    if (a2)
      v16 = a2;
    else
      v16 = 3;
  }
}

uint64_t re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::addNew(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t result;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;

  v4 = *a2;
  v5 = a2[1];
  v6 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v7 = (0x94D049BB133111EBLL * (v6 ^ (v6 >> 27))) ^ ((0x94D049BB133111EBLL * (v6 ^ (v6 >> 27))) >> 31);
  v8 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (v5 ^ (v5 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v5 ^ (v5 >> 30))) >> 27));
  v9 = v8 ^ (v8 >> 31);
  if (v7 == v9)
    v9 = 0;
  v10 = v9 ^ v7;
  v11 = *(unsigned int *)(a1 + 24);
  if (!(_DWORD)v11)
  {
    LODWORD(v12) = 0;
    goto LABEL_13;
  }
  v12 = v10 % v11;
  v13 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * (v10 % v11));
  if ((_DWORD)v13 == 0x7FFFFFFF)
  {
LABEL_13:
    v19 = re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::addAsMove(a1, v12, v10, (uint64_t)a2);
    ++*(_DWORD *)(a1 + 40);
    return *(_QWORD *)(a1 + 16) + 144 * v19 + 16;
  }
  v14 = *(_QWORD *)(a1 + 16);
  while (1)
  {
    v15 = v14 + 144 * v13;
    v18 = *(_QWORD *)(v15 + 16);
    result = v15 + 16;
    v17 = v18;
    if (v18 == v4 && *(_QWORD *)(result + 8) == v5)
      return result;
    if (v17 == v5 && *(_QWORD *)(result + 8) == v4)
      return result;
    v13 = *(_DWORD *)(v14 + 144 * v13) & 0x7FFFFFFF;
    if (v13 == 0x7FFFFFFF)
      goto LABEL_13;
  }
}

_QWORD *re::ContactSetCollection::removeFromLinkedLists(_QWORD *result)
{
  uint64_t v1;
  uint64_t v2;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;

  v1 = *result;
  v2 = result[14];
  v3 = *(_QWORD **)(*result + 80);
  if (v3 == result)
  {
    *(_QWORD *)(v1 + 80) = v2;
  }
  else
  {
    do
    {
      v4 = v3;
      v5 = *v3;
      if (*v3 == v1)
        v6 = 14;
      else
        v6 = 15;
      v3 = (_QWORD *)v4[v6];
    }
    while (v3 != result);
    if (v5 == v1)
      v4[14] = v2;
    else
      v4[15] = v2;
  }
  v7 = result[1];
  v8 = result[15];
  v9 = *(_QWORD **)(v7 + 80);
  if (v9 == result)
  {
    *(_QWORD *)(v7 + 80) = v8;
  }
  else
  {
    do
    {
      v10 = v9;
      v11 = *v9;
      if (*v9 == v7)
        v12 = 14;
      else
        v12 = 15;
      v9 = (_QWORD *)v10[v12];
    }
    while (v9 != result);
    if (v11 == v7)
      v10[14] = v8;
    else
      v10[15] = v8;
  }
  result[14] = 0;
  result[15] = 0;
  return result;
}

uint64_t re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::remove(uint64_t a1, uint64_t *a2)
{
  unint64_t v2;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v20;
  uint64_t v21;
  int *v22;
  int v23;
  int v24;

  v2 = *(unsigned int *)(a1 + 24);
  if (!(_DWORD)v2)
    return 0;
  v4 = *a2;
  v5 = a2[1];
  v6 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v7 = (0x94D049BB133111EBLL * (v6 ^ (v6 >> 27))) ^ ((0x94D049BB133111EBLL * (v6 ^ (v6 >> 27))) >> 31);
  v8 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (v5 ^ (v5 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v5 ^ (v5 >> 30))) >> 27));
  v9 = v8 ^ (v8 >> 31);
  if (v7 == v9)
    v9 = 0;
  v10 = (v9 ^ v7) % v2;
  v11 = *(_QWORD *)(a1 + 8);
  v12 = *(unsigned int *)(v11 + 4 * v10);
  if ((_DWORD)v12 == 0x7FFFFFFF)
    return 0;
  v13 = *(_QWORD *)(a1 + 16);
  v14 = 0x7FFFFFFFLL;
  while (1)
  {
    v15 = v13 + 144 * v12;
    v18 = *(_QWORD *)(v15 + 16);
    v16 = v15 + 16;
    v17 = v18;
    if (v18 == v4 && *(_QWORD *)(v16 + 8) == v5)
      break;
    if (v17 == v5 && *(_QWORD *)(v16 + 8) == v4)
      break;
    v14 = v12;
    v12 = *(_DWORD *)(v13 + 144 * v12) & 0x7FFFFFFF;
    if (v12 == 0x7FFFFFFF)
      return 0;
  }
  v20 = *(_DWORD *)(v13 + 144 * v12) & 0x7FFFFFFF;
  if (v14 == 0x7FFFFFFF)
    *(_DWORD *)(v11 + 4 * v10) = v20;
  else
    *(_DWORD *)(v13 + 144 * v14) = *(_DWORD *)(v13 + 144 * v14) & 0x80000000 | v20;
  v21 = *(_QWORD *)(a1 + 16);
  v22 = (int *)(v21 + 144 * v12);
  v23 = *v22;
  if (*v22 < 0)
  {
    *v22 = v23 & 0x7FFFFFFF;
    re::ContactSet::~ContactSet((re::ContactSet *)(v21 + 144 * v12 + 16));
    v21 = *(_QWORD *)(a1 + 16);
    v23 = *(_DWORD *)(v21 + 144 * v12);
  }
  v24 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(v21 + 144 * v12) = *(_DWORD *)(a1 + 36) | v23 & 0x80000000;
  --*(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 36) = v12;
  *(_DWORD *)(a1 + 40) = v24 + 1;
  return 1;
}

uint64_t re::ContactSetCollection::remove(re::ContactSetCollection *this, re::ContactSet *a2)
{
  if (*((_QWORD *)this + 6))
    re::ContactSetCollection::removeFromLinkedLists(a2);
  return re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::remove((uint64_t)this, (uint64_t *)a2);
}

uint64_t re::ContactSetCollection::remove(uint64_t this, re::CollisionObject *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t i;
  uint64_t v7;
  re::ContactSet *v8;
  uint64_t v9;
  uint64_t v10;
  int *v11;
  int v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  re::CollisionObject **v16;
  re::CollisionObject *v17;
  unsigned int v18;
  unsigned int v19;

  v3 = this;
  v4 = *(_QWORD *)(this + 48);
  if (v4)
  {
    v5 = *(_QWORD *)(v4 + 64);
    if (v5)
    {
      for (i = *((_QWORD *)a2 + 10); i; i = *(_QWORD *)(i + v7))
      {
        if (*(_BYTE *)(i + 57))
        {
          *(_BYTE *)(i + 57) = 0;
          this = (*(uint64_t (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)v5 + 32))(v5, *(_QWORD *)i, *(_QWORD *)(i + 8));
        }
        if (*(re::CollisionObject **)i == a2)
          v7 = 112;
        else
          v7 = 120;
      }
    }
    while (1)
    {
      v8 = (re::ContactSet *)*((_QWORD *)a2 + 10);
      if (!v8)
        break;
      this = re::ContactSetCollection::remove((re::ContactSetCollection *)v3, v8);
    }
  }
  else
  {
    v9 = *(unsigned int *)(this + 32);
    if ((_DWORD)v9)
    {
      v10 = 0;
      v11 = *(int **)(this + 16);
      while (1)
      {
        v12 = *v11;
        v11 += 36;
        if (v12 < 0)
          break;
        if (v9 == ++v10)
        {
          LODWORD(v10) = *(_DWORD *)(this + 32);
          break;
        }
      }
    }
    else
    {
      LODWORD(v10) = 0;
    }
    if ((_DWORD)v9 != (_DWORD)v10)
    {
      v13 = v10;
      v14 = *(_DWORD *)(this + 32);
      do
      {
        v15 = *(_QWORD *)(v3 + 16) + 144 * v13;
        v17 = *(re::CollisionObject **)(v15 + 16);
        v16 = (re::CollisionObject **)(v15 + 16);
        if (v17 == a2 || v16[1] == a2)
        {
          this = re::ContactSetCollection::remove((re::ContactSetCollection *)v3, (re::ContactSet *)v16);
          v14 = *(_DWORD *)(v3 + 32);
        }
        if (v14 <= (int)v10 + 1)
          v18 = v10 + 1;
        else
          v18 = v14;
        while (1)
        {
          v13 = (v10 + 1);
          if (v18 - 1 == (_DWORD)v10)
            break;
          LODWORD(v10) = v10 + 1;
          v19 = v13;
          if ((*(_DWORD *)(*(_QWORD *)(v3 + 16) + 144 * v13) & 0x80000000) != 0)
            goto LABEL_32;
        }
        v19 = v18;
LABEL_32:
        LODWORD(v10) = v19;
      }
      while ((_DWORD)v9 != v19);
    }
  }
  return this;
}

uint64_t re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t a4)
{
  uint64_t v6;
  int v7;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;

  v6 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v6 == 0x7FFFFFFF)
  {
    v6 = *(unsigned int *)(a1 + 32);
    v7 = v6;
    if ((_DWORD)v6 == *(_DWORD *)(a1 + 24))
    {
      re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::setCapacity(a1, (2 * *(_DWORD *)(a1 + 28)));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v7 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v7 + 1;
    v9 = *(_QWORD *)(a1 + 16);
    v10 = *(_DWORD *)(v9 + 144 * v6);
  }
  else
  {
    v9 = *(_QWORD *)(a1 + 16);
    v10 = *(_DWORD *)(v9 + 144 * v6);
    *(_DWORD *)(a1 + 36) = v10 & 0x7FFFFFFF;
  }
  v11 = 144 * v6;
  *(_DWORD *)(v9 + v11) = v10 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + v11) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 144 * v6) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  v12 = *(_QWORD *)(a1 + 16) + 144 * v6;
  *(_OWORD *)(v12 + 16) = *(_OWORD *)a4;
  *(_QWORD *)(v12 + 64) = 0;
  *(_QWORD *)(v12 + 40) = 0;
  *(_QWORD *)(v12 + 48) = 0;
  *(_QWORD *)(v12 + 32) = 0;
  *(_DWORD *)(v12 + 56) = 0;
  v13 = *(_QWORD *)(a4 + 24);
  *(_QWORD *)(v12 + 32) = *(_QWORD *)(a4 + 16);
  *(_QWORD *)(v12 + 40) = v13;
  *(_QWORD *)(a4 + 16) = 0;
  *(_QWORD *)(a4 + 24) = 0;
  v14 = *(_QWORD *)(v12 + 48);
  *(_QWORD *)(v12 + 48) = *(_QWORD *)(a4 + 32);
  *(_QWORD *)(a4 + 32) = v14;
  v15 = *(_QWORD *)(v12 + 64);
  *(_QWORD *)(v12 + 64) = *(_QWORD *)(a4 + 48);
  *(_QWORD *)(a4 + 48) = v15;
  ++*(_DWORD *)(a4 + 40);
  ++*(_DWORD *)(v12 + 56);
  *(_OWORD *)(v12 + 72) = *(_OWORD *)(a4 + 56);
  v16 = *(_OWORD *)(a4 + 72);
  v17 = *(_OWORD *)(a4 + 88);
  v18 = *(_OWORD *)(a4 + 104);
  *(_QWORD *)(v12 + 136) = *(_QWORD *)(a4 + 120);
  *(_OWORD *)(v12 + 120) = v18;
  *(_OWORD *)(v12 + 104) = v17;
  *(_OWORD *)(v12 + 88) = v16;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v6;
  ++*(_DWORD *)(a1 + 28);
  return v6;
}

void re::introspect_CharacterControllerType(re *this, const re::IntrospectionBase *a2)
{
  unsigned __int8 v2;
  unsigned __int8 v3;
  uint64_t *v4;
  uint64_t v5;
  unsigned int *v6;
  _anonymous_namespace_ *v7;
  unint64_t v8;
  unint64_t i;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  char v13;
  unsigned __int8 *v14;
  int v15;
  uint64_t v16;
  unint64_t j;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  char v21;
  unsigned __int8 *v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  re *v26;
  uint64_t *v27;
  re *v28;
  uint64_t *v29;
  re *v30;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  const char *v35;
  StringID v36;
  _QWORD v37[2];
  _QWORD v38[61];

  v2 = atomic_load((unsigned __int8 *)&qword_254105E20);
  if ((v2 & 1) == 0)
  {
    v26 = (re *)__cxa_guard_acquire(&qword_254105E20);
    if ((_DWORD)v26)
    {
      v27 = re::introspectionAllocator(v26);
      v28 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v27 + 32))(v27, 24, 8);
      *(_DWORD *)v28 = 1;
      *((_QWORD *)v28 + 1) = 0;
      *((_QWORD *)v28 + 2) = "Undefined";
      qword_254105E58 = (uint64_t)v28;
      v29 = re::introspectionAllocator(v28);
      v30 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v29 + 32))(v29, 24, 8);
      *(_DWORD *)v30 = 1;
      *((_QWORD *)v30 + 1) = 1;
      *((_QWORD *)v30 + 2) = "Capsule";
      qword_254105E60 = (uint64_t)v30;
      v31 = re::introspectionAllocator(v30);
      v32 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v31 + 32))(v31, 24, 8);
      *(_DWORD *)v32 = 1;
      *(_QWORD *)(v32 + 8) = 2;
      *(_QWORD *)(v32 + 16) = "Box";
      qword_254105E68 = v32;
      __cxa_guard_release(&qword_254105E20);
    }
  }
  v3 = atomic_load((unsigned __int8 *)&qword_254105E28);
  if ((v3 & 1) == 0 && __cxa_guard_acquire(&qword_254105E28))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_254105EA8, "CharacterControllerType", 2, 2, 1, 1);
    qword_254105EA8 = (uint64_t)&off_24ED7D9E8;
    qword_254105EE8 = (uint64_t)&re::introspect_CharacterControllerType(BOOL)::enumTable;
    dword_254105EB8 = 9;
    __cxa_guard_release(&qword_254105E28);
  }
  if ((_MergedGlobals_130 & 1) == 0)
  {
    _MergedGlobals_130 = 1;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_254105EA8, a2);
    v34 = 0x7A5112036B46B8BELL;
    v35 = "CharacterControllerType";
    v38[0] = 0x607DD0D4E68;
    v38[1] = "uint16_t";
    v4 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v38);
    if (v4)
    {
      v5 = *v4;
      re::StringID::destroyString((re::StringID *)v38);
      v6 = (unsigned int *)qword_254105EE8;
      v37[1] = v5;
      re::TypeBuilder::beginEnumType((uint64_t)v38, &v34, 1, 1, (uint64_t)v37);
      v8 = *v6;
      if ((_DWORD)v8)
      {
        for (i = 0; i < v8; ++i)
        {
          v10 = *(_QWORD *)(*((_QWORD *)v6 + 1) + 8 * i);
          if (*(_DWORD *)v10 == 1)
          {
            v11 = *(char **)(v10 + 16);
            if (v11)
            {
              v12 = *v11;
              if (*v11)
              {
                v13 = v11[1];
                if (v13)
                {
                  v14 = (unsigned __int8 *)(v11 + 2);
                  do
                  {
                    v12 = 31 * v12 + v13;
                    v15 = *v14++;
                    v13 = v15;
                  }
                  while (v15);
                }
              }
            }
            else
            {
              v12 = 0;
            }
            v16 = *(_QWORD *)(v10 + 8);
            *(_QWORD *)&v36.var0 = 2 * v12;
            v36.var1 = v11;
            re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v38, v16, &v36);
            re::StringID::destroyString((re::StringID *)&v36);
            v8 = *v6;
          }
        }
        if (v8)
        {
          for (j = 0; j < v8; ++j)
          {
            v18 = *(_QWORD *)(*((_QWORD *)v6 + 1) + 8 * j);
            if (*(_DWORD *)v18 == 2)
            {
              v19 = *(char **)(v18 + 16);
              if (v19)
              {
                v20 = *v19;
                if (*v19)
                {
                  v21 = v19[1];
                  if (v21)
                  {
                    v22 = (unsigned __int8 *)(v19 + 2);
                    do
                    {
                      v20 = 31 * v20 + v21;
                      v23 = *v22++;
                      v21 = v23;
                    }
                    while (v23);
                  }
                }
              }
              else
              {
                v20 = 0;
              }
              v24 = *(_QWORD *)(v18 + 8);
              *(_QWORD *)&v36.var0 = 2 * v20;
              v36.var1 = v19;
              re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v38, v24, &v36);
              re::StringID::destroyString((re::StringID *)&v36);
              v8 = *v6;
            }
          }
        }
      }
      re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v38, v25);
      xmmword_254105EC8 = (__int128)v36;
      re::StringID::destroyString((re::StringID *)&v34);
    }
    else
    {
      re::StringID::destroyString((re::StringID *)v38);
      re::internal::assertLog((re::internal *)5, v33, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "CharacterControllerType", v34, v35);
      _os_crash();
      __break(1u);
    }
  }
}

void re::introspect_CharacterControllerFlags(re *this, const re::IntrospectionBase *a2)
{
  unsigned __int8 v2;
  unsigned __int8 v3;
  uint64_t *v4;
  uint64_t v5;
  unsigned int *v6;
  _anonymous_namespace_ *v7;
  unint64_t v8;
  unint64_t i;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  char v13;
  unsigned __int8 *v14;
  int v15;
  uint64_t v16;
  unint64_t j;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  char v21;
  unsigned __int8 *v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  re *v26;
  uint64_t *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  const char *v31;
  StringID v32;
  _QWORD v33[2];
  _QWORD v34[61];

  v2 = atomic_load((unsigned __int8 *)&qword_254105E38);
  if ((v2 & 1) == 0)
  {
    v26 = (re *)__cxa_guard_acquire(&qword_254105E38);
    if ((_DWORD)v26)
    {
      v27 = re::introspectionAllocator(v26);
      v28 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v27 + 32))(v27, 24, 8);
      *(_DWORD *)v28 = 1;
      *(_QWORD *)(v28 + 8) = 0;
      *(_QWORD *)(v28 + 16) = "None";
      qword_254105E30 = v28;
      __cxa_guard_release(&qword_254105E38);
    }
  }
  v3 = atomic_load((unsigned __int8 *)&qword_254105E40);
  if ((v3 & 1) == 0 && __cxa_guard_acquire(&qword_254105E40))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_254105EF0, "CharacterControllerFlags", 2, 2, 1, 1);
    qword_254105EF0 = (uint64_t)&off_24ED7D9E8;
    qword_254105F30 = (uint64_t)&re::introspect_CharacterControllerFlags(BOOL)::enumTable;
    dword_254105F00 = 9;
    __cxa_guard_release(&qword_254105E40);
  }
  if ((byte_254105E19 & 1) == 0)
  {
    byte_254105E19 = 1;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_254105EF0, a2);
    v30 = 0xCFD12E69FBF98C04;
    v31 = "CharacterControllerFlags";
    v34[0] = 0x607DD0D4E68;
    v34[1] = "uint16_t";
    v4 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v34);
    if (v4)
    {
      v5 = *v4;
      re::StringID::destroyString((re::StringID *)v34);
      v6 = (unsigned int *)qword_254105F30;
      v33[1] = v5;
      re::TypeBuilder::beginEnumType((uint64_t)v34, &v30, 1, 1, (uint64_t)v33);
      v8 = *v6;
      if ((_DWORD)v8)
      {
        for (i = 0; i < v8; ++i)
        {
          v10 = *(_QWORD *)(*((_QWORD *)v6 + 1) + 8 * i);
          if (*(_DWORD *)v10 == 1)
          {
            v11 = *(char **)(v10 + 16);
            if (v11)
            {
              v12 = *v11;
              if (*v11)
              {
                v13 = v11[1];
                if (v13)
                {
                  v14 = (unsigned __int8 *)(v11 + 2);
                  do
                  {
                    v12 = 31 * v12 + v13;
                    v15 = *v14++;
                    v13 = v15;
                  }
                  while (v15);
                }
              }
            }
            else
            {
              v12 = 0;
            }
            v16 = *(_QWORD *)(v10 + 8);
            *(_QWORD *)&v32.var0 = 2 * v12;
            v32.var1 = v11;
            re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v34, v16, &v32);
            re::StringID::destroyString((re::StringID *)&v32);
            v8 = *v6;
          }
        }
        if (v8)
        {
          for (j = 0; j < v8; ++j)
          {
            v18 = *(_QWORD *)(*((_QWORD *)v6 + 1) + 8 * j);
            if (*(_DWORD *)v18 == 2)
            {
              v19 = *(char **)(v18 + 16);
              if (v19)
              {
                v20 = *v19;
                if (*v19)
                {
                  v21 = v19[1];
                  if (v21)
                  {
                    v22 = (unsigned __int8 *)(v19 + 2);
                    do
                    {
                      v20 = 31 * v20 + v21;
                      v23 = *v22++;
                      v21 = v23;
                    }
                    while (v23);
                  }
                }
              }
              else
              {
                v20 = 0;
              }
              v24 = *(_QWORD *)(v18 + 8);
              *(_QWORD *)&v32.var0 = 2 * v20;
              v32.var1 = v19;
              re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v34, v24, &v32);
              re::StringID::destroyString((re::StringID *)&v32);
              v8 = *v6;
            }
          }
        }
      }
      re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v34, v25);
      xmmword_254105F10 = (__int128)v32;
      re::StringID::destroyString((re::StringID *)&v30);
    }
    else
    {
      re::StringID::destroyString((re::StringID *)v34);
      re::internal::assertLog((re::internal *)5, v29, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "CharacterControllerFlags", v30, v31);
      _os_crash();
      __break(1u);
    }
  }
}

uint64_t *re::allocInfo_CharacterControllerDescription(re *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  v1 = atomic_load((unsigned __int8 *)&qword_254105E48);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_254105E48))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_254105F38, 0);
    *(_QWORD *)(v3 + 22) = 0;
    qword_254105F48 = 0;
    qword_254105F58 = 0;
    qword_254105F60 = 0xFFFFFFFFLL;
    qword_254105F38 = (uint64_t)&off_24ED7DAA8;
    qword_254105F68 = (uint64_t)"CharacterControllerDescription";
    dword_254105F70 = 0;
    xmmword_254105F78 = 0u;
    unk_254105F88 = 0u;
    xmmword_254105F98 = 0u;
    qword_254105FA8 = 0;
    __cxa_guard_release(&qword_254105E48);
  }
  return &qword_254105F38;
}

void re::initInfo_CharacterControllerDescription(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  const re::IntrospectionBase *v7;
  void *v8;
  uint64_t v9;
  uint64_t *v10;
  const re::IntrospectionBase *v11;
  void *v12;
  uint64_t v13;
  uint64_t *v14;
  const re::IntrospectionBase *v15;
  void *v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t *v21;
  const re::IntrospectionBase *v22;
  void *v23;
  uint64_t v24;
  uint64_t *v25;
  const re::IntrospectionBase *v26;
  uint64_t v27;
  uint64_t *v28;
  const re::IntrospectionBase *v29;
  uint64_t v30;
  __int128 v31;
  _QWORD v32[2];
  __int128 v33;

  v32[0] = 0x34296DE90D87266ELL;
  v32[1] = "CharacterControllerDescription";
  re::StringID::destroyString((re::StringID *)v32);
  *((_OWORD *)this + 2) = v33;
  v4 = atomic_load((unsigned __int8 *)&qword_254105E50);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_254105E50);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      v8 = re::introspect_float((re *)1, v7);
      v9 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
      *(_DWORD *)v9 = 1;
      *(_QWORD *)(v9 + 8) = "skinWidth";
      *(_QWORD *)(v9 + 16) = v8;
      *(_QWORD *)(v9 + 24) = 0;
      *(_QWORD *)(v9 + 32) = 1;
      *(_DWORD *)(v9 + 40) = 0;
      *(_QWORD *)(v9 + 48) = 0;
      *(_QWORD *)(v9 + 56) = 0;
      *(_DWORD *)(v9 + 64) = 0;
      qword_254105E70 = v9;
      v10 = re::introspectionAllocator((re *)v9);
      v12 = re::introspect_float((re *)1, v11);
      v13 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v10 + 32))(v10, 72, 8);
      *(_DWORD *)v13 = 1;
      *(_QWORD *)(v13 + 8) = "slopeLimit";
      *(_QWORD *)(v13 + 16) = v12;
      *(_QWORD *)(v13 + 24) = 0;
      *(_QWORD *)(v13 + 32) = 0x400000002;
      *(_DWORD *)(v13 + 40) = 0;
      *(_QWORD *)(v13 + 48) = 0;
      *(_QWORD *)(v13 + 56) = 0;
      *(_DWORD *)(v13 + 64) = 0;
      qword_254105E78 = v13;
      v14 = re::introspectionAllocator((re *)v13);
      v16 = re::introspect_float((re *)1, v15);
      v17 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v14 + 32))(v14, 72, 8);
      *(_DWORD *)v17 = 1;
      *(_QWORD *)(v17 + 8) = "stepLimit";
      *(_QWORD *)(v17 + 16) = v16;
      *(_QWORD *)(v17 + 24) = 0;
      *(_QWORD *)(v17 + 32) = 0x800000003;
      *(_DWORD *)(v17 + 40) = 0;
      *(_QWORD *)(v17 + 48) = 0;
      *(_QWORD *)(v17 + 56) = 0;
      *(_DWORD *)(v17 + 64) = 0;
      qword_254105E80 = v17;
      v18 = re::introspectionAllocator((re *)v17);
      v19 = re::introspect_CollisionFilter((re::IntrospectionBase **)1);
      v20 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v18 + 32))(v18, 72, 8);
      *(_DWORD *)v20 = 1;
      *(_QWORD *)(v20 + 8) = "collisionFilter";
      *(_QWORD *)(v20 + 16) = v19;
      *(_QWORD *)(v20 + 24) = 0;
      *(_QWORD *)(v20 + 32) = 0xC00000004;
      *(_DWORD *)(v20 + 40) = 0;
      *(_QWORD *)(v20 + 48) = 0;
      *(_QWORD *)(v20 + 56) = 0;
      *(_DWORD *)(v20 + 64) = 0;
      qword_254105E88 = v20;
      v21 = re::introspectionAllocator((re *)v20);
      v23 = re::IntrospectionInfo<float [3]>::get(1, v22);
      v24 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v21 + 32))(v21, 72, 8);
      *(_DWORD *)v24 = 1;
      *(_QWORD *)(v24 + 8) = "extents";
      *(_QWORD *)(v24 + 16) = v23;
      *(_QWORD *)(v24 + 24) = 0;
      *(_QWORD *)(v24 + 32) = 0x1400000005;
      *(_DWORD *)(v24 + 40) = 0;
      *(_QWORD *)(v24 + 48) = 0;
      *(_QWORD *)(v24 + 56) = 0;
      *(_DWORD *)(v24 + 64) = 0;
      qword_254105E90 = v24;
      v25 = re::introspectionAllocator((re *)v24);
      re::introspect_CharacterControllerType((re *)v25, v26);
      v27 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v25 + 32))(v25, 72, 8);
      *(_DWORD *)v27 = 1;
      *(_QWORD *)(v27 + 8) = "type";
      *(_QWORD *)(v27 + 16) = &qword_254105EA8;
      *(_QWORD *)(v27 + 24) = 0;
      *(_QWORD *)(v27 + 32) = 0x2000000006;
      *(_DWORD *)(v27 + 40) = 0;
      *(_QWORD *)(v27 + 48) = 0;
      *(_QWORD *)(v27 + 56) = 0;
      *(_DWORD *)(v27 + 64) = 0;
      qword_254105E98 = v27;
      v28 = re::introspectionAllocator((re *)v27);
      re::introspect_CharacterControllerFlags((re *)v28, v29);
      v30 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v28 + 32))(v28, 72, 8);
      *(_DWORD *)v30 = 1;
      *(_QWORD *)(v30 + 8) = "flags";
      *(_QWORD *)(v30 + 16) = &qword_254105EF0;
      *(_QWORD *)(v30 + 24) = 0;
      *(_QWORD *)(v30 + 32) = 0x2200000007;
      *(_DWORD *)(v30 + 40) = 0;
      *(_QWORD *)(v30 + 48) = 0;
      *(_QWORD *)(v30 + 56) = 0;
      *(_DWORD *)(v30 + 64) = 0;
      qword_254105EA0 = v30;
      __cxa_guard_release(&qword_254105E50);
    }
  }
  *((_QWORD *)this + 2) = 0x2400000008;
  *((_DWORD *)this + 6) = 4;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 7;
  *((_QWORD *)this + 8) = &qword_254105E70;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::CharacterControllerDescription>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::CharacterControllerDescription>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::CharacterControllerDescription>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::CharacterControllerDescription>;
  re::IntrospectionRegistry::add(this, v3);
  v31 = v33;
}

void *re::IntrospectionInfo<float [3]>::get(int a1, const re::IntrospectionBase *a2)
{
  unsigned __int8 v3;
  int v4;
  re *v5;
  std::__shared_mutex_base *v6;
  re *v7;
  const re::IntrospectionBase *v8;
  re::IntrospectionRegistry *v9;
  const re::IntrospectionBase *v10;
  const char *v11;
  std::__shared_mutex_base *v12;
  __int128 v14;
  __int128 v15;
  const char *v16;
  uint64_t v17[2];

  {
    re::IntrospectionCStyleArray::IntrospectionCStyleArray((re::IntrospectionCStyleArray *)&re::IntrospectionInfo<float [3]>::get(BOOL)::info);
  }
  if (a1)
  {
    if (re::IntrospectionInfo<float [3]>::get(BOOL)::isInitialized)
      return &re::IntrospectionInfo<float [3]>::get(BOOL)::info;
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v15);
    v4 = re::IntrospectionInfo<float [3]>::get(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v15);
    if (v4)
      return &re::IntrospectionInfo<float [3]>::get(BOOL)::info;
    v6 = re::introspectionSharedMutex(v5);
    std::__shared_mutex_base::lock(v6);
    if (re::IntrospectionInfo<float [3]>::get(BOOL)::isInitialized)
    {
LABEL_14:
      v12 = re::introspectionSharedMutex(v7);
      std::__shared_mutex_base::unlock(v12);
      return &re::IntrospectionInfo<float [3]>::get(BOOL)::info;
    }
  }
  re::IntrospectionInfo<float [3]>::get(BOOL)::isInitialized = 1;
  v8 = (const re::IntrospectionBase *)re::introspect_float((re *)1, a2);
  re::IntrospectionCStyleArray::IntrospectionCStyleArray((re::IntrospectionCStyleArray *)&re::IntrospectionInfo<float [3]>::get(BOOL)::info, v8, 3);
  re::IntrospectionRegistry::add(v9, v10);
  re::getPrettyTypeName((re *)&re::IntrospectionInfo<float [3]>::get(BOOL)::info, (const re::IntrospectionBase *)&v15);
  if ((BYTE8(v15) & 1) != 0)
    v11 = v16;
  else
    v11 = (char *)&v15 + 9;
  if ((_QWORD)v15 && (BYTE8(v15) & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v15 + 40))();
  v15 = *((_OWORD *)v8 + 2);
  xmmword_2558015F0 = v14;
  re::StringID::destroyString((re::StringID *)v17);
  if ((a1 & 1) == 0)
    goto LABEL_14;
  return &re::IntrospectionInfo<float [3]>::get(BOOL)::info;
}

double re::internal::defaultConstruct<re::CharacterControllerDescription>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double result;

  *(_QWORD *)a3 = 0x3F490FD83C23D70ALL;
  *(_DWORD *)(a3 + 8) = 1045220557;
  result = NAN;
  *(_QWORD *)(a3 + 12) = 0xFFFFFFFF00000001;
  *(_DWORD *)(a3 + 20) = 0;
  *(_DWORD *)(a3 + 24) = 0;
  *(_QWORD *)(a3 + 28) = 0x100000000;
  return result;
}

double re::internal::defaultConstructV2<re::CharacterControllerDescription>(uint64_t a1)
{
  double result;

  *(_QWORD *)a1 = 0x3F490FD83C23D70ALL;
  *(_DWORD *)(a1 + 8) = 1045220557;
  result = NAN;
  *(_QWORD *)(a1 + 12) = 0xFFFFFFFF00000001;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 28) = 0x100000000;
  return result;
}

uint64_t re::introspect_CharacterControllerDescription(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"CharacterControllerDescription", (uint64_t (*)(re::internal *))re::allocInfo_CharacterControllerDescription, (re::IntrospectionBase *(*)(void))re::initInfo_CharacterControllerDescription, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::CharacterControllerDescription>, this);
}

re::CharacterController *re::CharacterController::CharacterController(re::CharacterController *this, re::Allocator *a2, float a3, float a4, float a5)
{
  _anonymous_namespace_ *inited;

  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0x3F80000000000000;
  *(_QWORD *)this = off_24ED413E0;
  *((float *)this + 16) = a3;
  *((float *)this + 17) = a4;
  *((float *)this + 18) = a5;
  *((_BYTE *)this + 76) = 0;
  *((_OWORD *)this + 5) = 0u;
  inited = (_anonymous_namespace_ *)objc_initWeak((id *)this + 12, 0);
  *((_QWORD *)this + 14) = 0;
  *((_QWORD *)this + 15) = 0;
  *(_QWORD *)((char *)this + 125) = 0;
  *((_QWORD *)this + 17) = 0;
  *((_QWORD *)this + 18) = 0;
  *((_QWORD *)this + 19) = 0;
  *((_QWORD *)this + 20) = a2;
  *((_QWORD *)this + 22) = 0;
  *((_QWORD *)this + 23) = 0;
  *((_DWORD *)this + 48) = 0;
  *((_QWORD *)this + 21) = 0;
  *((_QWORD *)this + 30) = 0;
  *((_DWORD *)this + 62) = 0;
  *(_OWORD *)((char *)this + 200) = 0u;
  *(_OWORD *)((char *)this + 216) = 0u;
  *((_DWORD *)this + 58) = 0;
  *((_OWORD *)this + 19) = 0u;
  *((_OWORD *)this + 20) = 0u;
  *((_OWORD *)this + 17) = 0u;
  *((_OWORD *)this + 18) = 0u;
  *((_OWORD *)this + 16) = 0u;
  re::DynamicArray<re::EvaluationRegister>::setCapacity((_QWORD *)this + 21, 0);
  ++*((_DWORD *)this + 48);
  return this;
}

void re::CharacterController::~CharacterController(re::CharacterController *this)
{
  void (**v2)(re::CharacterController *__hidden);
  void (***v3)(_QWORD);
  uint64_t v4;
  uint64_t v5;
  void (***v6)(_QWORD);
  void (***v7)(_QWORD);

  v2 = off_24ED413E0;
  *(_QWORD *)this = off_24ED413E0;
  v3 = (void (***)(_QWORD))*((_QWORD *)this + 17);
  if (v3)
  {
    v4 = *((_QWORD *)this + 20);
    (**v3)(*((_QWORD *)this + 17));
    (*(void (**)(uint64_t, void (***)(_QWORD)))(*(_QWORD *)v4 + 40))(v4, v3);
    v2 = *(void (***)(re::CharacterController *__hidden))this;
  }
  v5 = *((_QWORD *)this + 20);
  v6 = (void (***)(_QWORD))((uint64_t (*)(re::CharacterController *))v2[2])(this);
  if (v6)
  {
    v7 = v6;
    (**v6)(v6);
    (*(void (**)(uint64_t, void (***)(_QWORD)))(*(_QWORD *)v5 + 40))(v5, v7);
  }
  re::Event<re::Engine>::~Event((uint64_t *)this + 21);
  objc_destroyWeak((id *)this + 12);
  *((_QWORD *)this + 12) = 0;
}

uint64_t re::CharacterController::onPlatform(id *this)
{
  _QWORD *WeakRetained;
  uint64_t v2;

  WeakRetained = objc_loadWeakRetained(this + 12);
  if (!WeakRetained)
    return 0;
  v2 = WeakRetained[2];

  return v2;
}

double re::PlaneShape::massProperties(uint64_t a1, _DWORD *a2, _QWORD *a3, _OWORD *a4)
{
  double result;

  *a2 = 0;
  *a3 = 0;
  a3[1] = 0;
  result = 0.0;
  a4[1] = 0u;
  a4[2] = 0u;
  *a4 = 0u;
  return result;
}

float32x2_t re::PhysXRectangleShape::extent(re::PhysXRectangleShape *this)
{
  float32x2_t v1;

  v1.i32[0] = *((_DWORD *)this + 6);
  v1.i32[1] = *((_DWORD *)this + 8);
  return vadd_f32(v1, v1);
}

double re::PhysXRectangleShape::aabb@<D0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X4>, uint64_t a4@<X5>, uint64_t a5@<X6>, uint64_t a6@<X7>, _OWORD *a7@<X8>, int8x16_t a8@<Q1>, double a9@<D2>, double a10@<D3>, double a11@<D4>, double a12@<D5>, double a13@<D6>, int32x4_t a14@<Q7>)
{
  float32x4_t v15;
  double result;
  __int128 v17;
  __int128 v18;
  uint64_t v19;
  int v20;
  _BYTE v21[20];
  int v22;

  v18 = *((_OWORD *)a2 + 1);
  v15.i64[1] = *((_QWORD *)&v18 + 1);
  v19 = *a2;
  v15.i32[1] = HIDWORD(v19);
  v20 = *((_DWORD *)a2 + 2);
  v15.i32[0] = 0;
  a8.i32[0] = 1.0;
  physx::Gu::computeBounds((float32x2_t *)v21, a1 + 20, (uint64_t)&v18, 0, v15, a8, a9, a10, a11, a12, a13, a14, a3, a4, a5, a6, v18);
  result = *(double *)v21;
  *(_QWORD *)&v17 = *(_QWORD *)&v21[12];
  DWORD2(v17) = v22;
  *a7 = *(_OWORD *)v21;
  a7[1] = v17;
  return result;
}

void re::PhysXRectangleShape::~PhysXRectangleShape(re::PhysXRectangleShape *this)
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::RectangleShape::type(re::RectangleShape *this)
{
  return 11;
}

float re::PhysXCylinderShape::height(re::PhysXCylinderShape *this)
{
  return *((float *)this + 8);
}

float re::PhysXCylinderShape::radius(re::PhysXCylinderShape *this)
{
  return *((float *)this + 7);
}

double re::PhysXCylinderShape::aabb@<D0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X4>, uint64_t a4@<X5>, uint64_t a5@<X6>, uint64_t a6@<X7>, _OWORD *a7@<X8>, int8x16_t a8@<Q1>, double a9@<D2>, double a10@<D3>, double a11@<D4>, double a12@<D5>, double a13@<D6>, int32x4_t a14@<Q7>)
{
  float32x4_t v15;
  double result;
  __int128 v17;
  __int128 v18;
  uint64_t v19;
  int v20;
  _BYTE v21[20];
  int v22;

  v18 = *((_OWORD *)a2 + 1);
  v15.i64[1] = *((_QWORD *)&v18 + 1);
  v19 = *a2;
  v15.i32[1] = HIDWORD(v19);
  v20 = *((_DWORD *)a2 + 2);
  v15.i32[0] = 0;
  a8.i32[0] = 1.0;
  physx::Gu::computeBounds((float32x2_t *)v21, a1 + 24, (uint64_t)&v18, 0, v15, a8, a9, a10, a11, a12, a13, a14, a3, a4, a5, a6, v18);
  result = *(double *)v21;
  *(_QWORD *)&v17 = *(_QWORD *)&v21[12];
  DWORD2(v17) = v22;
  *a7 = *(_OWORD *)v21;
  a7[1] = v17;
  return result;
}

void re::PhysXCylinderShape::~PhysXCylinderShape(re::PhysXCylinderShape *this)
{
  JUMPOUT(0x2276933B8);
}

uint64_t *re::allocInfo_CollisionFilter(re *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&_MergedGlobals_131);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&_MergedGlobals_131))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_254105FD0, 0);
    *(uint64_t *)((char *)&qword_254105FE0 + 6) = 0;
    qword_254105FE0 = 0;
    qword_254105FF0 = 0;
    qword_254105FF8 = 0xFFFFFFFFLL;
    qword_254105FD0 = (uint64_t)&off_24ED7DAA8;
    qword_254106000 = (uint64_t)"CollisionFilter";
    dword_254106008 = 0;
    xmmword_254106010 = 0u;
    unk_254106020 = 0u;
    xmmword_254106030 = 0u;
    qword_254106040 = 0;
    __cxa_guard_release(&_MergedGlobals_131);
  }
  return &qword_254105FD0;
}

void re::initInfo_CollisionFilter(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  const re::IntrospectionBase *v7;
  void *v8;
  uint64_t v9;
  uint64_t *v10;
  const re::IntrospectionBase *v11;
  void *v12;
  uint64_t v13;
  __int128 v14;
  _QWORD v15[2];
  __int128 v16;

  v15[0] = 0xF1C766E267541254;
  v15[1] = "CollisionFilter";
  re::StringID::destroyString((re::StringID *)v15);
  *((_OWORD *)this + 2) = v16;
  v4 = atomic_load((unsigned __int8 *)&qword_254105FB8);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_254105FB8);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      v8 = re::introspect_uint32_t((re *)1, v7);
      v9 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
      *(_DWORD *)v9 = 1;
      *(_QWORD *)(v9 + 8) = "group";
      *(_QWORD *)(v9 + 16) = v8;
      *(_QWORD *)(v9 + 24) = 0;
      *(_QWORD *)(v9 + 32) = 1;
      *(_DWORD *)(v9 + 40) = 0;
      *(_QWORD *)(v9 + 48) = 0;
      *(_QWORD *)(v9 + 56) = 0;
      *(_DWORD *)(v9 + 64) = 0;
      qword_254105FC0 = v9;
      v10 = re::introspectionAllocator((re *)v9);
      v12 = re::introspect_uint32_t((re *)1, v11);
      v13 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v10 + 32))(v10, 72, 8);
      *(_DWORD *)v13 = 1;
      *(_QWORD *)(v13 + 8) = "mask";
      *(_QWORD *)(v13 + 16) = v12;
      *(_QWORD *)(v13 + 24) = 0;
      *(_QWORD *)(v13 + 32) = 0x400000002;
      *(_DWORD *)(v13 + 40) = 0;
      *(_QWORD *)(v13 + 48) = 0;
      *(_QWORD *)(v13 + 56) = 0;
      *(_DWORD *)(v13 + 64) = 0;
      qword_254105FC8 = v13;
      __cxa_guard_release(&qword_254105FB8);
    }
  }
  *((_QWORD *)this + 2) = 0x800000008;
  *((_DWORD *)this + 6) = 4;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 2;
  *((_QWORD *)this + 8) = &qword_254105FC0;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::CollisionFilter>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::CollisionFilter>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::CollisionFilter>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::CollisionFilter>;
  re::IntrospectionRegistry::add(this, v3);
  v14 = v16;
}

double re::internal::defaultConstruct<re::CollisionFilter>(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  double result;

  result = NAN;
  *a3 = 0xFFFFFFFF00000001;
  return result;
}

double re::internal::defaultConstructV2<re::CollisionFilter>(_QWORD *a1)
{
  double result;

  result = NAN;
  *a1 = 0xFFFFFFFF00000001;
  return result;
}

uint64_t re::introspect_CollisionFilter(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"CollisionFilter", (uint64_t (*)(re::internal *))re::allocInfo_CollisionFilter, (re::IntrospectionBase *(*)(void))re::initInfo_CollisionFilter, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::CollisionFilter>, this);
}

void re::CollisionWorld::~CollisionWorld(re::CollisionWorld *this)
{
  uint64_t *v2;

  *(_QWORD *)this = off_24ED415B8;
  if (*((_QWORD *)this + 7))
  {
    v2 = (uint64_t *)((char *)this + 72);
    if (*((_QWORD *)this + 9))
      re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::deinit(v2);
    *((_QWORD *)this + 7) = 0;
  }
  re::ContactSetCollection::~ContactSetCollection((re::CollisionWorld *)((char *)this + 72));
  re::HashTable<re::AssetType const*,std::pair<unsigned long,unsigned long>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::deinit((uint64_t *)this + 1);
}

void re::CollisionWorld::deinit(re::CollisionWorld *this)
{
  uint64_t *v2;
  uint64_t v3;

  if (*((_QWORD *)this + 7))
  {
    v3 = *((_QWORD *)this + 9);
    v2 = (uint64_t *)((char *)this + 72);
    if (v3)
      re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::deinit(v2);
    *((_QWORD *)this + 7) = 0;
  }
}

uint64_t re::CollisionWorld::hasContact(_QWORD *a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  float *v6;
  float32x4_t v7;
  uint64_t v8;

  if (!a2 || *(_QWORD *)(a2 + 56) != a1[16])
    return (*(uint64_t (**)(_QWORD *))(*a1 + 232))(a1);
  v3 = *(_QWORD **)(a2 + 80);
  if (!v3)
    return 0;
  while (1)
  {
    v4 = v3[4];
    if (v4)
      break;
LABEL_10:
    if (*v3 == a2)
      v8 = 14;
    else
      v8 = 15;
    v3 = (_QWORD *)v3[v8];
    if (!v3)
      return 0;
  }
  v5 = 80 * v4;
  v6 = (float *)(v3[6] + 64);
  while (*v6 > 0.0)
  {
    v7 = vmulq_f32(*(float32x4_t *)(v6 - 4), *(float32x4_t *)(v6 - 4));
    if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2), vaddq_f32(v7, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 1))).f32[0] != 0.0)break;
    v6 += 20;
    v5 -= 80;
    if (!v5)
      goto LABEL_10;
  }
  return 1;
}

uint64_t re::CollisionWorld::haveContact(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  BOOL v8;
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  float *v12;
  float32x4_t v13;
  uint64_t v14[2];

  if (!a2 || !a3 || (v3 = *(_QWORD *)(a2 + 56), v3 != a1[16]) || *(_QWORD *)(a3 + 56) != v3)
  {
    v4 = *(_QWORD *)(a2 + 32);
    v5 = *(_QWORD *)(a3 + 32);
    v6 = v5 & HIDWORD(v4);
    v7 = v4 & HIDWORD(v5);
    if (v6)
      v8 = v7 == 0;
    else
      v8 = 1;
    if (!v8)
      return (*(uint64_t (**)(_QWORD *))(*a1 + 240))(a1);
    return 0;
  }
  v14[0] = a2;
  v14[1] = a3;
  result = re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::tryGet((uint64_t)(a1 + 9), v14);
  if (result)
  {
    v10 = *(_QWORD *)(result + 32);
    if (!v10)
      return 0;
    v11 = 80 * v10;
    v12 = (float *)(*(_QWORD *)(result + 48) + 64);
    result = 0;
    while (*v12 > 0.0)
    {
      v13 = vmulq_f32(*(float32x4_t *)(v12 - 4), *(float32x4_t *)(v12 - 4));
      if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 2), vaddq_f32(v13, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13.f32, 1))).f32[0] != 0.0)break;
      v12 += 20;
      v11 -= 80;
      if (!v11)
        return result;
    }
    return 1;
  }
  return result;
}

double re::CollisionWorld::DEPRECATED_copyRayHitsToContactSet(uint64_t a1, float *a2, float a3)
{
  uint64_t v3;
  float v4;
  __int128 v5;
  double result;
  _OWORD v7[3];
  uint64_t v8;
  uint64_t v9;
  float v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)a2;
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = v3;
  *(_QWORD *)(a1 + 32) = 0;
  ++*(_DWORD *)(a1 + 40);
  v4 = -(float)(a2[12] * a3);
  v5 = *((_OWORD *)a2 + 2);
  v7[0] = *((_OWORD *)a2 + 1);
  v7[1] = v7[0];
  v7[2] = v5;
  v8 = 0;
  v9 = 0;
  v10 = v4;
  *(_QWORD *)&result = re::DynamicArray<re::Contact>::add((_anonymous_namespace_ *)(a1 + 16), (uint64_t)v7).n128_u64[0];
  return result;
}

void re::CollisionWorld::DEPRECATED_copyRayHitsToContactSetCollection(uint64_t a1, uint64_t a2, float a3)
{
  uint64_t v5;
  uint64_t v6;
  int *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  uint64_t v14;
  unint64_t i;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  float v20;
  __int128 v21;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  v5 = *(unsigned int *)(a1 + 32);
  if ((_DWORD)v5)
  {
    v6 = 0;
    v7 = *(int **)(a1 + 16);
    while (1)
    {
      v8 = *v7;
      v7 += 36;
      if (v8 < 0)
        break;
      if (v5 == ++v6)
      {
        LODWORD(v6) = *(_DWORD *)(a1 + 32);
        break;
      }
    }
  }
  else
  {
    LODWORD(v6) = 0;
  }
  if ((_DWORD)v5 != (_DWORD)v6)
  {
    v9 = v6;
    v10 = *(_QWORD *)(a1 + 16);
    do
    {
      v11 = v10 + 144 * v9;
      *(_QWORD *)(v11 + 48) = 0;
      ++*(_DWORD *)(v11 + 56);
      v10 = *(_QWORD *)(a1 + 16);
      if (v5 <= (int)v6 + 1)
        v12 = v6 + 1;
      else
        v12 = v5;
      v13 = v6;
      while (1)
      {
        v9 = (v13 + 1);
        if (v12 - 1 == v13)
          break;
        ++v13;
        LODWORD(v6) = v9;
        if ((*(_DWORD *)(v10 + 144 * v9) & 0x80000000) != 0)
          goto LABEL_17;
      }
      LODWORD(v6) = v12;
LABEL_17:
      ;
    }
    while ((_DWORD)v5 != (_DWORD)v6);
  }
  v14 = *(_QWORD *)(a2 + 40);
  if (v14)
  {
    for (i = 0; i != v14; ++i)
    {
      v16 = re::BucketArray<re::CollisionCastHit,10ul>::operator[](a2, i);
      v17 = *(_QWORD *)v16;
      *(_QWORD *)&v23 = 0;
      *((_QWORD *)&v23 + 1) = v17;
      v18 = re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::tryGet(a1, (uint64_t *)&v23);
      if (!v18)
      {
        v19 = *(_QWORD *)a1;
        v28 = 0u;
        v29 = 0u;
        v30 = 0;
        *(_QWORD *)&v27 = 0;
        *(_DWORD *)((char *)&v27 + 7) = 0;
        v31 = 0;
        v32 = 0;
        *(_QWORD *)&v26 = 0;
        DWORD2(v26) = 0;
        v24 = v23;
        v25 = v19;
        re::DynamicArray<re::Contact>::setCapacity(&v25, 0);
        ++DWORD2(v26);
        v18 = re::HashSetBase<re::Pair<re::CollisionObject *,re::CollisionObject *,false>,re::ContactSet,re::ContactSetCollection::Key,re::ContactSetCollection::Hash,re::ContactSetCollection::EqualTo,false,false>::addNew(a1, (uint64_t *)&v24);
        re::ContactSet::~ContactSet((re::ContactSet *)&v24);
      }
      v20 = -(float)(*(float *)(v16 + 48) * a3);
      v21 = *(_OWORD *)(v16 + 32);
      v24 = *(_OWORD *)(v16 + 16);
      v25 = v24;
      v26 = v21;
      v27 = 0uLL;
      *(float *)&v28 = v20;
      re::DynamicArray<re::Contact>::add((_anonymous_namespace_ *)(v18 + 16), (uint64_t)&v24);
    }
  }
}

uint64_t re::CollisionWorld::printDebugInformation(re::CollisionWorld *this, const char *a2)
{
  const char *v3;
  uint64_t v4;

  if (a2)
    v3 = a2;
  else
    v3 = "";
  printf("%sCollision world:\n", v3);
  v4 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 16) + 176))(*((_QWORD *)this + 16));
  printf("%s    # of collision objects: %zu\n", v3, v4);
  return printf("%s    # of contact sets: %zu\n", v3, *((unsigned int *)this + 25));
}

void re::CollisionWorld::reportTriggerEvents(re::CollisionWorld *this)
{
  uint64_t v1;
  re::CollisionWorld *v2;
  uint64_t v3;
  uint64_t v4;
  int *v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  _BYTE *v13;
  int v14;
  int v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  _QWORD v23[2];
  __int128 v24;
  __int128 v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  v1 = *((_QWORD *)this + 8);
  if (v1)
  {
    v2 = this;
    v3 = *((unsigned int *)this + 10);
    if ((_DWORD)v3)
    {
      v4 = 0;
      v5 = (int *)(*((_QWORD *)this + 3) + 8);
      while (1)
      {
        v6 = *v5;
        v5 += 10;
        if (v6 < 0)
          break;
        if (v3 == ++v4)
        {
          LODWORD(v4) = *((_DWORD *)this + 10);
          break;
        }
      }
    }
    else
    {
      LODWORD(v4) = 0;
    }
    if ((_DWORD)v3 != (_DWORD)v4)
    {
      v7 = v4;
      v16 = (char *)this + 8;
      while (1)
      {
        v8 = *((_QWORD *)v2 + 3) + 40 * v7;
        v11 = *(_QWORD *)(v8 + 16);
        v10 = *(_QWORD *)(v8 + 24);
        v9 = v8 + 16;
        v13 = (_BYTE *)(v9 + 16);
        v12 = *(unsigned __int8 *)(v9 + 16);
        if (v12 == 2)
        {
          re::HashSetBase<re::TriggerPair,re::TriggerPair,re::internal::ValueAsKey<re::TriggerPair>,re::Hash<re::TriggerPair>,re::EqualTo<re::TriggerPair>,true,false>::remove((uint64_t)v16, (uint64_t *)v9);
          this = (re::CollisionWorld *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v1 + 32))(v1, v11, v10);
          goto LABEL_17;
        }
        if (v12 == 1)
          break;
        if (!*(_BYTE *)(v9 + 16))
        {
          v26 = 0;
          v24 = 0u;
          v25 = 0u;
          v20 = 0;
          v21 = 0;
          v22 = 0;
          v23[0] = 0;
          *(_DWORD *)((char *)v23 + 7) = 0;
          v27 = 0;
          v28 = 0;
          v17 = v11;
          v18 = v10;
          re::DynamicArray<re::Contact>::setCapacity(&v19, 0);
          ++v22;
          (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(*(_QWORD *)v1 + 16))(v1, v11, v10, &v17);
          *v13 = 1;
LABEL_15:
          re::ContactSet::~ContactSet((re::ContactSet *)&v17);
        }
LABEL_17:
        if (*((_DWORD *)v2 + 10) <= (v4 + 1))
          v14 = v4 + 1;
        else
          v14 = *((_DWORD *)v2 + 10);
        while (1)
        {
          v7 = (v4 + 1);
          if (v14 - 1 == (_DWORD)v4)
            break;
          LODWORD(v4) = v4 + 1;
          v15 = v7;
          if ((*(_DWORD *)(*((_QWORD *)v2 + 3) + 40 * v7 + 8) & 0x80000000) != 0)
            goto LABEL_24;
        }
        v15 = v14;
LABEL_24:
        LODWORD(v4) = v15;
        if ((_DWORD)v3 == v15)
          return;
      }
      v26 = 0;
      v24 = 0u;
      v25 = 0u;
      v20 = 0;
      v21 = 0;
      v22 = 0;
      v23[0] = 0;
      *(_DWORD *)((char *)v23 + 7) = 0;
      v27 = 0;
      v28 = 0;
      v17 = v11;
      v18 = v10;
      re::DynamicArray<re::Contact>::setCapacity(&v19, 0);
      ++v22;
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(*(_QWORD *)v1 + 24))(v1, v11, v10, &v17);
      goto LABEL_15;
    }
  }
}

uint64_t *re::allocInfo_CollisionWorld(re *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&_MergedGlobals_132);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&_MergedGlobals_132))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_254106050, 0);
    *(uint64_t *)((char *)&qword_254106060 + 6) = 0;
    qword_254106060 = 0;
    qword_254106070 = 0;
    qword_254106078 = 0xFFFFFFFFLL;
    qword_254106050 = (uint64_t)&off_24ED7DAA8;
    qword_254106080 = (uint64_t)"CollisionWorld";
    dword_254106088 = 0;
    *(_OWORD *)&algn_25410608C[4] = 0u;
    *(_OWORD *)&algn_25410608C[20] = 0u;
    *(_OWORD *)&algn_25410608C[36] = 0u;
    qword_2541060C0 = 0;
    __cxa_guard_release(&_MergedGlobals_132);
  }
  return &qword_254106050;
}

void re::initInfo_CollisionWorld(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  __int128 v4;
  _QWORD v5[2];
  __int128 v6;

  v5[0] = 0x28D4E2496010BF40;
  v5[1] = "CollisionWorld";
  re::StringID::destroyString((re::StringID *)v5);
  *((_OWORD *)this + 2) = v6;
  *((_QWORD *)this + 2) = 0x9000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 8) = &re::initInfo_CollisionWorld(re::IntrospectionBase *)::structureAttributes;
  re::IntrospectionRegistry::add(this, v3);
  v4 = v6;
}

uint64_t re::introspect_CollisionWorld(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"CollisionWorld", (uint64_t (*)(re::internal *))re::allocInfo_CollisionWorld, (re::IntrospectionBase *(*)(void))re::initInfo_CollisionWorld, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::CollisionWorld>, this);
}

uint64_t re::CollisionWorld::isMultithreadingEnabled(re::CollisionWorld *this)
{
  return 0;
}

uint64_t re::CollisionWorld::numCollisionObjects(re::CollisionWorld *this)
{
  return 0;
}

uint64_t re::CollisionWorld::collisionObjectAtIndex(re::CollisionWorld *this)
{
  return 0;
}

uint64_t re::CollisionWorld::doContactTest()
{
  return 0;
}

uint64_t re::CollisionWorld::doContactPairTest()
{
  return 0;
}

uint64_t *re::collisionLogObjects(re *this)
{
  unsigned __int8 v1;

  {
    re::collisionLogObjects(void)::logObjects = (uint64_t)os_log_create("com.apple.re", "Collision");
  }
  return &re::collisionLogObjects(void)::logObjects;
}

uint64_t re::PhysXCompoundShape::useAABBTree(re::PhysXCompoundShape *this)
{
  return 1;
}

float32x4_t *re::PhysXCompoundShape::aabb@<X0>(uint64_t a1@<X0>, float32x4_t *a2@<X1>, uint64_t a3@<X8>)
{
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float32x4_t v20;
  float v21;
  float32_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v27[4];
  float32x4_t v28[2];

  re::CompoundShape::calculateAABB(*(_QWORD **)(a1 + 40), *(_QWORD *)(a1 + 32), v28);
  v5 = a2[1].f32[0];
  v6 = a2[1].f32[1];
  v7 = v5 + v5;
  v8 = v6 + v6;
  v9 = a2[1].f32[2];
  v10 = a2[1].f32[3];
  v11 = v9 + v9;
  v12 = v5 * (float)(v5 + v5);
  v13 = v6 * (float)(v6 + v6);
  v14 = v9 * (float)(v9 + v9);
  v15 = v7 * v6;
  v16 = v7 * v9;
  v17 = v8 * v9;
  v18 = v8 * v10;
  v19 = v11 * v10;
  v20.i32[3] = 0;
  v20.f32[0] = 1.0 - (float)(v13 + v14);
  v20.f32[1] = v15 + v19;
  v20.f32[2] = v16 - v18;
  v21 = v7 * v10;
  v22 = 1.0 - (float)(v12 + v14);
  v23.i32[3] = 0;
  v23.f32[0] = v15 - v19;
  v23.f32[1] = v22;
  v23.f32[2] = v17 + v21;
  v24.i32[3] = 0;
  v24.f32[0] = v16 + v18;
  v24.f32[1] = v17 - v21;
  v24.f32[2] = 1.0 - (float)(v12 + v13);
  v27[0] = v20;
  v27[1] = v23;
  v25 = *a2;
  v25.i32[3] = 1.0;
  v27[2] = v24;
  v27[3] = v25;
  return re::AABB::transform(v28, v27, a3);
}

void re::PhysXCompoundShape::~PhysXCompoundShape(re::PhysXCompoundShape *this)
{
  re::CompoundShape::~CompoundShape(this);
  JUMPOUT(0x2276933B8);
}

float re::ConeShape::massProperties(uint64_t a1, float *a2, _OWORD *a3, uint64_t a4)
{
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float result;
  unint64_t v14;

  v8 = (*(float (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
  v9 = (*(float (**)(uint64_t))(*(_QWORD *)a1 + 72))(a1);
  v10 = v9 * v9;
  v11 = v8 * (float)(v10 * 1.0472);
  *a2 = v11;
  v12 = (float)((float)(v8 * (float)(v8 * 0.0375)) + (float)(v10 * 0.15)) * v11;
  *(_QWORD *)(a4 + 4) = 0;
  *(_QWORD *)(a4 + 12) = 0;
  *(_QWORD *)(a4 + 24) = 0;
  *(_QWORD *)(a4 + 32) = 0;
  *(float *)a4 = v12;
  *(float *)(a4 + 20) = v10 * (float)(v11 * 0.3);
  *(float *)(a4 + 40) = v12;
  *(_DWORD *)(a4 + 44) = 0;
  result = v8 * -0.25;
  LODWORD(v14) = 0;
  *((float *)&v14 + 1) = v8 * -0.25;
  *a3 = v14;
  return result;
}

int32x4_t re::PhysXEmptyShape::aabb@<Q0>(uint64_t a1@<X8>)
{
  int32x4_t result;
  __int128 v2;

  result = vdupq_n_s32(0x7F800000u);
  *(_QWORD *)&v2 = 0x7F0000007FLL;
  *((_QWORD *)&v2 + 1) = 0x7F0000007FLL;
  *(int32x4_t *)a1 = result;
  *(_OWORD *)(a1 + 16) = v2;
  return result;
}

void re::PhysXEmptyShape::~PhysXEmptyShape(re::PhysXEmptyShape *this)
{
  JUMPOUT(0x2276933B8);
}

float re::RectangleShape::massProperties(uint64_t a1, float *a2, _QWORD *a3, uint64_t a4)
{
  float v8;
  uint64_t v9;
  float32x4_t v10;
  float32x4_t v11;
  float v12;
  float v13;
  float result;
  float v15;

  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
  v15 = v8;
  v9 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
  v10.i64[0] = LODWORD(v15) | 0x3400000000000000;
  v10.i64[1] = HIDWORD(v9) | 0x3400000000000000;
  v11 = vmulq_f32(v10, v10);
  v12 = (float)(v15 * 0.00000011921) * *((float *)&v9 + 1);
  *a2 = v12;
  v13 = v12 / 12.0;
  *(_QWORD *)(a4 + 4) = 0;
  *(_QWORD *)(a4 + 12) = 0;
  *(_QWORD *)(a4 + 24) = 0;
  *(_QWORD *)(a4 + 32) = 0;
  *(float *)a4 = v13 * (float)(v11.f32[1] + v11.f32[2]);
  *(float *)(a4 + 20) = v13 * (float)(v11.f32[0] + v11.f32[2]);
  result = v13 * vaddv_f32(*(float32x2_t *)v11.f32);
  *(float *)(a4 + 40) = result;
  *(_DWORD *)(a4 + 44) = 0;
  *a3 = 0;
  a3[1] = 0;
  return result;
}

re::PhysXCollisionFactory *re::PhysXCollisionFactory::PhysXCollisionFactory(re::PhysXCollisionFactory *this)
{
  re::PhysXCollisionFactory *v1;
  uint64_t *v2;
  unsigned __int8 v3;
  unsigned __int8 v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t Instance;
  physx::Dy *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  physx::Dy *v16;
  physx::Dy *v17;
  uint64_t v18;
  uint64_t v19;
  __n128 Cooking;
  uint64_t v21;
  uint64_t v22;
  void (***v23)(_QWORD, __n128);
  uint64_t v24;
  void (***v25)(_QWORD);
  uint64_t v26;
  uint64_t v27;
  uint64_t i;
  __float2 v29;
  __int128 v30;
  uint64_t ConvexMesh;
  void (***v32)(_QWORD);
  uint64_t v33;
  uint64_t v34;
  uint64_t j;
  __int128 v36;
  __float2 v37;
  __int128 v38;
  _OWORD *v39;
  uint64_t v40;
  void (***v41)(_QWORD);
  float v43;
  _DWORD v44[6];
  uint64_t v45;
  int v46;
  int v47;
  int v48;
  __int128 v49;
  uint64_t v50;

  v1 = this;
  v50 = *MEMORY[0x24BDAC8D0];
  *(_OWORD *)((char *)this + 8) = 0u;
  v2 = (uint64_t *)((char *)this + 8);
  *(_QWORD *)this = &off_24ED417E0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  v3 = atomic_load((unsigned __int8 *)&qword_2541060D0);
  if ((v3 & 1) == 0)
  {
    this = (re::PhysXCollisionFactory *)__cxa_guard_acquire(&qword_2541060D0);
    if ((_DWORD)this)
    {
      _MergedGlobals_133 = (uint64_t)&off_24ED978F0;
      __cxa_guard_release(&qword_2541060D0);
    }
  }
  v4 = atomic_load((unsigned __int8 *)&qword_2541060E0);
  if ((v4 & 1) == 0)
  {
    this = (re::PhysXCollisionFactory *)__cxa_guard_acquire(&qword_2541060E0);
    if ((_DWORD)this)
    {
      qword_2541060D8 = 0x412000003F800000;
      __cxa_guard_release(&qword_2541060E0);
    }
  }
  re::internal::nvphysx::initPhysX(this);
  Instance = physx::shdfnd::Foundation::createInstance(67174656, (uint64_t)&_MergedGlobals_133, (uint64_t)&re::PhysXCollisionFactory::PhysXCollisionFactory(void)::s_allocatorCallback);
  if (*v2)
    (**(void (***)(uint64_t))*v2)(*v2);
  *v2 = Instance;
  v10 = (physx::Dy *)physx::NpPhysics::createInstance((physx::shdfnd::Foundation *)0x4010100, Instance, (float *)&qword_2541060D8, 0, v5, v6, v7, v8);
  v16 = v10;
  if (v10)
  {
    physx::Dy::PxvRegisterArticulations(v10);
    physx::Dy::PxvRegisterArticulationsReducedCoordinate(v17);
    off_255825CE8 = physx::PxcContactSphereHeightField;
    off_255825D58 = physx::PxcContactCapsuleHeightField;
    off_255825D90 = physx::PxcContactBoxHeightField;
    off_255825DC8 = physx::PxcContactConvexHeightField;
    off_255825E70 = physx::PxcPCMContactSphereHeightField;
    off_255825EE0 = physx::PxcPCMContactCapsuleHeightField;
    off_255825F18 = physx::PxcPCMContactBoxHeightField;
    off_255825F50 = physx::PxcPCMContactConvexHeightField;
    qword_255826828 = (uint64_t)raycast_heightField;
    off_255826588[0] = (uint64_t (*)())sweepCapsule_HeightFieldGeom;
    off_2558265C0[0] = (uint64_t (*)())sweepCapsule_HeightFieldGeom;
    off_2558265F8[0] = (uint64_t (*)())sweepBox_HeightFieldGeom;
    off_255826630[0] = (uint64_t (*)())sweepBox_HeightFieldGeom_Precise;
    off_255826668[0] = (uint64_t (*)())sweepConvex_HeightFieldGeom;
    off_2558266A0 = (uint64_t (*)())GeomOverlapCallback_SphereHeightfield;
    off_255826710 = (uint64_t (*)())GeomOverlapCallback_CapsuleHeightfield;
    off_255826748 = (uint64_t (*)())GeomOverlapCallback_BoxHeightfield;
    off_255826780 = (uint64_t (*)())GeomOverlapCallback_ConvexHeightfield;
  }
  v18 = *((_QWORD *)v1 + 2);
  if (v18)
    (*(void (**)(uint64_t))(*(_QWORD *)v18 + 16))(v18);
  *((_QWORD *)v1 + 2) = v16;
  v19 = *((_QWORD *)v1 + 1);
  v43 = *(float *)&qword_2541060D8 * (float)(*(float *)&qword_2541060D8 * 0.06);
  *(_QWORD *)v44 = 976715828;
  *(_DWORD *)((char *)&v44[1] + 3) = 0;
  *(_QWORD *)&v44[3] = qword_2541060D8;
  v44[5] = 0;
  v45 = 0x3F0CCCCD00000000;
  v46 = 0;
  v47 = 0;
  v48 = 32;
  Cooking = PxCreateCooking((physx::shdfnd::Foundation *)0x4010100, v19, (uint64_t)&v43, v11, v12, v13, v14, v15);
  v22 = v21;
  v23 = (void (***)(_QWORD, __n128))*((_QWORD *)v1 + 3);
  if (v23)
    (**v23)(v23, Cooking);
  *((_QWORD *)v1 + 3) = v22;
  v24 = (*(uint64_t (**)(_QWORD, float, float, float))(**((_QWORD **)v1 + 2) + 240))(*((_QWORD *)v1 + 2), 0.5, 0.5, 0.1);
  v25 = (void (***)(_QWORD))*((_QWORD *)v1 + 6);
  if (v25)
    (**v25)(v25);
  *((_QWORD *)v1 + 6) = v24;
  v27 = *((_QWORD *)v1 + 2);
  v26 = *((_QWORD *)v1 + 3);
  bzero(&v43, 0x3C0uLL);
  for (i = 0; i != 60; ++i)
  {
    v29 = __sincosf_stret((float)((float)((float)(int)i / 60.0) + (float)((float)(int)i / 60.0)) * 3.1416);
    *(_QWORD *)&v30 = LODWORD(v29.__cosval) | 0xBF00000000000000;
    *((_QWORD *)&v30 + 1) = LODWORD(v29.__sinval) | 0xBF00000000000000;
    *(_OWORD *)&v44[4 * i - 1] = v30;
  }
  v49 = xmmword_226102C50;
  v32 = (void (***)(_QWORD))*((_QWORD *)v1 + 4);
  if (v32)
    (**v32)(v32);
  *((_QWORD *)v1 + 4) = ConvexMesh;
  v34 = *((_QWORD *)v1 + 2);
  v33 = *((_QWORD *)v1 + 3);
  bzero(&v43, 0x780uLL);
  for (j = 0; j != 60; ++j)
  {
    v37 = __sincosf_stret((float)((float)((float)(int)j / 60.0) + (float)((float)(int)j / 60.0)) * 3.1416);
    *(float *)&v36 = v37.__cosval;
    v38 = v36;
    DWORD1(v38) = -0.5;
    DWORD2(v38) = LODWORD(v37.__sinval);
    v39 = (_OWORD *)&v44[4 * j - 1];
    DWORD1(v36) = 0.5;
    *v39 = v38;
    DWORD2(v36) = LODWORD(v37.__sinval);
    v39[60] = v36;
  }
  v41 = (void (***)(_QWORD))*((_QWORD *)v1 + 5);
  if (v41)
    (**v41)(v41);
  *((_QWORD *)v1 + 5) = v40;
  return v1;
}

void re::PhysXCollisionFactory::~PhysXCollisionFactory(re::PhysXCollisionFactory *this)
{
  void (***v2)(_QWORD);
  void (***v3)(_QWORD);
  void (***v4)(_QWORD);
  void (***v5)(_QWORD);
  uint64_t v6;
  void (***v7)(_QWORD);
  void (***v8)(_QWORD);
  void (***v9)(_QWORD);
  void (***v10)(_QWORD);
  void (***v11)(_QWORD);
  uint64_t v12;
  void (***v13)(_QWORD);

  v2 = (void (***)(_QWORD))*((_QWORD *)this + 5);
  if (v2)
    (**v2)(v2);
  *((_QWORD *)this + 5) = 0;
  v3 = (void (***)(_QWORD))*((_QWORD *)this + 4);
  if (v3)
    (**v3)(v3);
  *((_QWORD *)this + 4) = 0;
  v4 = (void (***)(_QWORD))*((_QWORD *)this + 6);
  if (v4)
    (**v4)(v4);
  *((_QWORD *)this + 6) = 0;
  v5 = (void (***)(_QWORD))*((_QWORD *)this + 3);
  if (v5)
    (**v5)(v5);
  *((_QWORD *)this + 3) = 0;
  v6 = *((_QWORD *)this + 2);
  if (v6)
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 16))(v6);
  *((_QWORD *)this + 2) = 0;
  v7 = (void (***)(_QWORD))*((_QWORD *)this + 1);
  if (v7)
    (**v7)(v7);
  *((_QWORD *)this + 1) = 0;
  v8 = (void (***)(_QWORD))*((_QWORD *)this + 6);
  if (v8)
    (**v8)(v8);
  v9 = (void (***)(_QWORD))*((_QWORD *)this + 5);
  if (v9)
    (**v9)(v9);
  v10 = (void (***)(_QWORD))*((_QWORD *)this + 4);
  if (v10)
    (**v10)(v10);
  v11 = (void (***)(_QWORD))*((_QWORD *)this + 3);
  if (v11)
    (**v11)(v11);
  v12 = *((_QWORD *)this + 2);
  if (v12)
    (*(void (**)(uint64_t))(*(_QWORD *)v12 + 16))(v12);
  v13 = (void (***)(_QWORD))*((_QWORD *)this + 1);
  if (v13)
    (**v13)(v13);
}

{
  re::PhysXCollisionFactory::~PhysXCollisionFactory(this);
  JUMPOUT(0x2276933B8);
}

uint64_t re::PhysXCollisionFactory::createCollisionWorld(re::PhysXCollisionFactory *this, re::Allocator *a2)
{
  uint64_t v4;

  v4 = (*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 416, 16);
  return re::PhysXCollisionWorld::PhysXCollisionWorld(v4, (uint64_t)a2, *((_QWORD *)this + 2));
}

float re::PhysXCollisionFactory::createBoxShape(double a1, double a2, float a3, uint64_t a4, const char *a5, float *a6)
{
  float v8;
  const char *v9;
  float v10;
  float v11;
  float v12;
  const char *v13;
  float v14;
  float v15;
  float v16;
  uint64_t v17;
  float v18;
  float result;

  v8 = *a6 * 0.5;
  if (re::RECollisionFeatureFlags::getMinimumBoxDimension(void)::onceToken != -1)
    dispatch_once(&re::RECollisionFeatureFlags::getMinimumBoxDimension(void)::onceToken, &__block_literal_global_10);
  v12 = a6[1] * 0.5;
  if (re::RECollisionFeatureFlags::getMinimumBoxDimension(void)::onceToken != -1)
    dispatch_once(&re::RECollisionFeatureFlags::getMinimumBoxDimension(void)::onceToken, &__block_literal_global_10);
  v15 = a6[2];
  if (re::RECollisionFeatureFlags::getMinimumBoxDimension(void)::onceToken != -1)
    dispatch_once(&re::RECollisionFeatureFlags::getMinimumBoxDimension(void)::onceToken, &__block_literal_global_10);
  v17 = (*(uint64_t (**)(const char *, uint64_t, uint64_t))(*(_QWORD *)a5 + 32))(a5, 40, 8);
  v18 = fminf(fminf(v11, v16), v14);
  *(_DWORD *)(v17 + 20) = 3;
  result = v18 + v18;
  *(float *)(v17 + 16) = result;
  *(_QWORD *)v17 = &off_24ED41AD0;
  *(_QWORD *)(v17 + 8) = v17 + 20;
  *(float *)(v17 + 24) = v11;
  *(float *)(v17 + 28) = v14;
  *(float *)(v17 + 32) = v16;
  return result;
}

float `anonymous namespace'::ensureValidExtent(_anonymous_namespace_ *this, float a2, const char *a3, float a4, float a5)
{
  float v5;
  float v6;
  NSObject *v8;
  int v10;
  _anonymous_namespace_ *v11;
  __int16 v12;
  double v13;
  uint64_t v14;

  v5 = a2;
  v14 = *MEMORY[0x24BDAC8D0];
  if (a2 < a4)
    a2 = a4;
  if ((LODWORD(a2) & 0x7FFFFFFFu) >= 0x7F800000)
    v6 = 1000000.0;
  else
    v6 = a2;
  if (v6 != v5)
  {
    v8 = *re::collisionLogObjects(this);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v10 = 136315394;
      v11 = this;
      v12 = 2048;
      v13 = v5;
      _os_log_impl(&dword_224FE9000, v8, OS_LOG_TYPE_DEFAULT, "Bad parameter (%s), value = %f, passed to shape creation.", (uint8_t *)&v10, 0x16u);
    }
  }
  return v6;
}

float re::PhysXCollisionFactory::createCapsuleShape(re::PhysXCollisionFactory *this, re::Allocator *a2, float a3, float a4, float a5)
{
  float v7;
  const char *v8;
  float v9;
  float v10;
  uint64_t v11;
  float v12;
  float result;

  v11 = (*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 32, 8);
  if (v10 <= v7)
    v12 = v10;
  else
    v12 = v7;
  result = v12 + v12;
  *(_DWORD *)(v11 + 20) = 2;
  *(float *)(v11 + 16) = result;
  *(_QWORD *)v11 = &off_24ED40AE8;
  *(_QWORD *)(v11 + 8) = v11 + 20;
  *(float *)(v11 + 24) = v7;
  *(float *)(v11 + 28) = v10;
  return result;
}

uint64_t re::PhysXCollisionFactory::createConvexPolyhedronShape(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;

  if (result)
  {
    v7 = result;
    v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 72, 8);
    return re::PhysXConvexPolyhedronShape::PhysXConvexPolyhedronShape(v8, v7);
  }
  return result;
}

uint64_t `anonymous namespace'::createConvexMesh(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  uint64_t v7;
  re *v8;
  uint64_t v9;
  NSObject *v10;
  int v12;
  uint64_t (**v13)(physx::PxDefaultMemoryOutputStream *__hidden, const void *, unsigned int);
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  int v20;
  uint64_t v21;
  int v22;
  int v23;
  uint64_t v24;
  int v25;
  int v26;
  __int16 v27;
  uint8_t buf[8];
  int v29;
  uint64_t v30;
  int v31;
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  v21 = 0;
  v22 = 0;
  v23 = 0;
  v24 = 0;
  v27 = 255;
  v20 = 0;
  v19 = a4;
  v18 = a3;
  v17 = a5;
  v25 = 0;
  v26 = 16711762;
  v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)physx::shdfnd::Foundation::mInstance + 32))(physx::shdfnd::Foundation::mInstance);
  v13 = &off_24ED97C50;
  v14 = v7;
  v15 = 0;
  v16 = 0;
  v12 = 0;
  v8 = (re *)(*(uint64_t (**)(uint64_t, int *, uint64_t (***)(physx::PxDefaultMemoryOutputStream *__hidden, const void *, unsigned int), int *))(*(_QWORD *)a1 + 56))(a1, &v17, &v13, &v12);
  if ((v8 & 1) != 0)
  {
    *(_QWORD *)buf = &off_24ED97C88;
    v30 = v15;
    v29 = v16;
    v31 = 0;
    v9 = (*(uint64_t (**)(uint64_t, uint8_t *))(*(_QWORD *)a2 + 96))(a2, buf);
  }
  else
  {
    v10 = *re::collisionLogObjects(v8);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = v12;
      _os_log_error_impl(&dword_224FE9000, v10, OS_LOG_TYPE_ERROR, "Failed to cook convex mesh (0x%x)", buf, 8u);
    }
    v9 = 0;
  }
  v13 = &off_24ED97C50;
  if (v15)
    (*(void (**)(uint64_t))(*(_QWORD *)v14 + 24))(v14);
  return v9;
}

uint64_t re::PhysXCollisionFactory::createConvexPolyhedronShape(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  return re::PhysXCollisionFactory::createConvexPolyhedronShape(a1, a2, a3, a4, 16);
}

{
  return re::PhysXCollisionFactory::createConvexPolyhedronShape(a1, a2, a3, a4, 16);
}

uint64_t re::PhysXCollisionFactory::createConvexPolyhedronShape(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return re::PhysXCollisionFactory::createConvexPolyhedronShape(a1, a2, *(_QWORD *)(a3 + 32), *(_QWORD *)(a3 + 16), 16);
}

uint64_t re::PhysXCollisionFactory::createConvexPolyhedronShape(re::PhysXCollisionFactory *this, Allocator *a2, const re::ConvexPolyhedronShape *a3)
{
  uint64_t v3;
  uint64_t v4;

  v3 = *(_QWORD *)(*((_QWORD *)a3 + 1) + 32);
  v4 = (*((uint64_t (**)(Allocator *, uint64_t, uint64_t))a2->var0 + 4))(a2, 72, 8);
  return re::PhysXConvexPolyhedronShape::PhysXConvexPolyhedronShape(v4, v3);
}

uint64_t *re::PhysXCollisionFactory::emptyShape(re::PhysXCollisionFactory *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&qword_2541060E8);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_2541060E8))
  {
    dword_254106100 = 0;
    qword_2541060F0 = (uint64_t)&off_24ED41760;
    unk_2541060F8 = 0;
    __cxa_guard_release(&qword_2541060E8);
  }
  return &qword_2541060F0;
}

uint64_t re::PhysXCollisionFactory::createEmptyShape(re::PhysXCollisionFactory *this, Allocator *a2)
{
  uint64_t result;

  result = (*((uint64_t (**)(Allocator *, uint64_t, uint64_t))a2->var0 + 4))(a2, 24, 8);
  *(_DWORD *)(result + 16) = 0;
  *(_QWORD *)result = &off_24ED41760;
  *(_QWORD *)(result + 8) = 0;
  return result;
}

uint64_t re::PhysXCollisionFactory::createPlaneShape(float a1, uint64_t a2, uint64_t a3, _OWORD *a4)
{
  uint64_t v6;

  v6 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a3 + 32))(a3, 112, 16);
  return re::PhysXPlaneShape::PhysXPlaneShape(v6, a4, a1);
}

uint64_t re::PhysXCollisionFactory::createSphereShape(re::PhysXCollisionFactory *this, re::Allocator *a2, float a3, double a4, float a5)
{
  float v6;
  uint64_t result;

  result = (*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 32, 8);
  *(_DWORD *)(result + 20) = 0;
  *(float *)(result + 16) = v6;
  *(_QWORD *)result = &off_24ED41A60;
  *(_QWORD *)(result + 8) = result + 20;
  *(float *)(result + 24) = v6;
  return result;
}

double re::PhysXCollisionFactory::createConeShape(re::PhysXCollisionFactory *this, re::Allocator *a2, float a3, float a4, float a5)
{
  float v8;
  const char *v9;
  float v10;
  float v11;
  uint64_t v12;
  uint64_t v13;
  float v14;
  double result;

  v12 = (*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 72, 8);
  v13 = *((_QWORD *)this + 4);
  v14 = v8 + v8;
  *(_DWORD *)(v12 + 24) = 4;
  if ((float)(v8 + v8) > v11)
    v14 = v11;
  *(float *)(v12 + 16) = v14;
  *(_QWORD *)v12 = &off_24ED40CC0;
  *(_QWORD *)(v12 + 8) = v12 + 24;
  *(float *)(v12 + 28) = v8;
  *(float *)(v12 + 32) = v11;
  *(float *)(v12 + 36) = v8;
  result = 0.0;
  *(_OWORD *)(v12 + 40) = xmmword_2260E5D70;
  *(_QWORD *)(v12 + 56) = v13;
  *(_BYTE *)(v12 + 64) = 1;
  *(_BYTE *)(v12 + 67) = 0;
  *(_WORD *)(v12 + 65) = 0;
  return result;
}

double re::PhysXCollisionFactory::createCylinderShape(re::PhysXCollisionFactory *this, re::Allocator *a2, float a3, float a4, float a5)
{
  float v8;
  const char *v9;
  float v10;
  float v11;
  uint64_t v12;
  uint64_t v13;
  float v14;
  double result;

  v12 = (*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 72, 8);
  v13 = *((_QWORD *)this + 5);
  v14 = v8 + v8;
  *(_DWORD *)(v12 + 24) = 4;
  if ((float)(v8 + v8) > v11)
    v14 = v11;
  *(float *)(v12 + 16) = v14;
  *(_QWORD *)v12 = &off_24ED41540;
  *(_QWORD *)(v12 + 8) = v12 + 24;
  *(float *)(v12 + 28) = v8;
  *(float *)(v12 + 32) = v11;
  *(float *)(v12 + 36) = v8;
  result = 0.0;
  *(_OWORD *)(v12 + 40) = xmmword_2260E5D70;
  *(_QWORD *)(v12 + 56) = v13;
  *(_BYTE *)(v12 + 64) = 1;
  *(_BYTE *)(v12 + 67) = 0;
  *(_WORD *)(v12 + 65) = 0;
  return result;
}

float re::PhysXCollisionFactory::createRectangleShape(double a1, double a2, float a3, uint64_t a4, const char *a5, float *a6)
{
  float v8;
  const char *v9;
  float v10;
  float v11;
  uint64_t v12;
  float v13;
  float result;

  v12 = (*(uint64_t (**)(const char *, uint64_t, uint64_t))(*(_QWORD *)a5 + 32))(a5, 40, 8);
  *(_DWORD *)(v12 + 20) = 3;
  if (v11 >= v8)
    v13 = v8;
  else
    v13 = v11;
  result = v13 + v13;
  *(float *)(v12 + 16) = result;
  *(_QWORD *)v12 = &off_24ED414D0;
  *(_QWORD *)(v12 + 8) = v12 + 20;
  *(float *)(v12 + 24) = v8;
  *(_DWORD *)(v12 + 28) = 872415232;
  *(float *)(v12 + 32) = v11;
  return result;
}

_QWORD *re::PhysXCollisionFactory::createCompoundShape(uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4, unint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v12;
  _QWORD *result;

  v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 144, 8);
  result = (_QWORD *)re::CompoundShape::CompoundShape(v12, a2, 0, a3, a4, a5, a7);
  *result = &off_24ED416D0;
  return result;
}

uint64_t re::PhysXCollisionFactory::createTriangleMeshShape(re::PhysXCollisionFactory *this, Allocator *a2, const re::IndexedTriangleMesh *a3)
{
  uint64_t result;
  float v6;
  float v7;
  uint64_t v8;
  uint64_t v9;
  float v10;
  float v11;
  float v12;
  float v13;

  if (!a3)
    return 0;
  result = *((_QWORD *)a3 + 8);
  if (result)
  {
    (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)result + 120))(&v9);
    v6 = v12 - *((float *)&v9 + 1);
    if ((float)(v12 - *((float *)&v9 + 1)) >= (float)(v13 - v10))
      v6 = v13 - v10;
    if ((float)(v11 - *(float *)&v9) >= v6)
      v7 = v6;
    else
      v7 = v11 - *(float *)&v9;
    result = (*((uint64_t (**)(Allocator *, uint64_t, uint64_t))a2->var0 + 4))(a2, 80, 8);
    *(_DWORD *)(result + 32) = 5;
    *(float *)(result + 16) = v7;
    *(_QWORD *)(result + 24) = a3;
    *(_QWORD *)result = &off_24ED41BB8;
    *(_QWORD *)(result + 8) = result + 32;
    v8 = *((_QWORD *)a3 + 8);
    *(_OWORD *)(result + 36) = xmmword_2260EDC60;
    *(_DWORD *)(result + 52) = 0;
    *(_DWORD *)(result + 56) = 0;
    *(_QWORD *)(result + 60) = 1065353216;
    *(_QWORD *)(result + 72) = v8;
  }
  return result;
}

re::PhysXCollisionObject *re::PhysXCollisionFactory::createCollisionObject(re::CollisionFactory *a1, re::Allocator *a2, const re::CollisionShape *a3, uint64_t *a4, unsigned int a5, uint64_t a6)
{
  const re::CollisionShape *v9;
  int v12;
  uint64_t v13;
  _QWORD *v14;
  _QWORD *GeometricObject;
  uint64_t v16;
  uint64_t v17;
  int v18;
  re::PhysXCollisionObject *v19;
  int32x2_t v20;
  float32x4_t v22;
  uint64_t v23;
  uint64_t v24;
  __int128 v25;
  uint64_t v26;
  int v27;
  uint64_t v28;

  v9 = a3;
  v28 = *MEMORY[0x24BDAC8D0];
  v12 = (*(uint64_t (**)(const re::CollisionShape *))(*(_QWORD *)a3 + 56))(a3);
  v13 = *((_QWORD *)a1 + 2);
  if ((a5 & 9) != 0 || v12)
  {
    v25 = *((_OWORD *)a4 + 1);
    v26 = *a4;
    v27 = *((_DWORD *)a4 + 2);
    v14 = (_QWORD *)(*(uint64_t (**)(uint64_t, __int128 *))(*(_QWORD *)v13 + 168))(v13, &v25);
    if (a6)
      goto LABEL_7;
  }
  else
  {
    v25 = *((_OWORD *)a4 + 1);
    v26 = *a4;
    v27 = *((_DWORD *)a4 + 2);
    v14 = (_QWORD *)(*(uint64_t (**)(uint64_t, __int128 *))(*(_QWORD *)v13 + 176))(v13, &v25);
    (*(void (**)(_QWORD *, uint64_t, uint64_t))(*v14 + 560))(v14, 1, 1);
    (*(void (**)(_QWORD *, uint64_t, uint64_t))(*v14 + 560))(v14, 2, 1);
    (*(void (**)(_QWORD *, uint64_t, uint64_t))(*v14 + 560))(v14, 4, 1);
    (*(void (**)(_QWORD *, uint64_t, uint64_t))(*v14 + 560))(v14, 8, 1);
    (*(void (**)(_QWORD *, uint64_t, uint64_t))(*v14 + 560))(v14, 16, 1);
    (*(void (**)(_QWORD *, uint64_t, uint64_t))(*v14 + 560))(v14, 32, 1);
    if (a6)
      goto LABEL_7;
  }
  v9 = (const re::CollisionShape *)re::CollisionFactory::deepCopyShape(a1, a2, v9);
  a6 = (uint64_t)a2;
LABEL_7:
  GeometricObject = (_QWORD *)re::CollisionFactory::createGeometricObject((uint64_t)a1, (uint64_t)a2, (uint64_t)v9, a4, a6);
  v16 = *((_QWORD *)a1 + 6);
  v17 = *((_QWORD *)a1 + 2);
  v22 = 0uLL;
  v24 = 0x3F80000000000000;
  *(_QWORD *)&v25 = v16;
  v23 = 0;
  if (attachShape(v17, (uint64_t)v14, GeometricObject, 0, &v22, (uint64_t)&v25, 1, (a5 >> 1) & 1))
    v18 = 2;
  else
    v18 = 0;
  v19 = (re::PhysXCollisionObject *)(*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 144, 16);
  v20.i32[0] = 1.0;
  return re::PhysXCollisionObject::PhysXCollisionObject(v19, v18, a5, (uint64_t)GeometricObject, (uint64_t)a2, v14, v20);
}

uint64_t attachShape(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4, float32x4_t *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v16;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  int32x4_t v21;
  float32x4_t v22;
  int32x4_t v23;
  float32x4_t v24;
  float32x4_t v26;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  float32x4_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  float32x4_t v41;
  float32x4_t v43;
  float32x4_t v44;
  int32x4_t v45;
  float32x4_t v46;
  int32x4_t v47;
  float32x4_t v48;
  float32x4_t v50;
  __int32 v51;
  char v53;
  _OWORD v54[2];
  int32x4_t v55;
  int32x4_t v56;

  v16 = (*(uint64_t (**)(_QWORD *))(*a3 + 16))(a3);
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v16 + 24))(v16) == 1)
    return 0;
  if (a4)
  {
    (*(void (**)(int32x4_t *__return_ptr, _QWORD *))(*a3 + 40))(&v55, a3);
    _Q0 = a5[1];
    v18 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q0, (int32x4_t)_Q0), (int8x16_t)_Q0, 0xCuLL);
    v19 = vnegq_f32(_Q0);
    v20 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v55, v55), (int8x16_t)v55, 0xCuLL), v19), (float32x4_t)v55, v18);
    v21 = (int32x4_t)vaddq_f32(v20, v20);
    v22 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v21, v21), (int8x16_t)v21, 0xCuLL);
    v23 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v22, (int32x4_t)v22), (int8x16_t)v22, 0xCuLL), v19), v22, v18);
    v24 = vaddq_f32(vaddq_f32((float32x4_t)v55, vmulq_laneq_f32(v22, _Q0, 3)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v23, v23), (int8x16_t)v23, 0xCuLL));
    _Q5 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v56, v56), (int8x16_t)v56, 0xCuLL), v19), (float32x4_t)v56, v18);
    v26 = vmlaq_laneq_f32(vmlaq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(_Q5, _Q5), (int8x16_t)_Q5, 0xCuLL), (float32x4_t)v56, _Q0, 3), _Q0, (float32x4_t)v56, 3);
    _S4 = v56.i32[3];
    __asm { FMLA            S5, S4, V0.S[3] }
    v26.i32[3] = _Q5.i32[0];
    *a5 = vaddq_f32(*a5, v24);
    a5[1] = v26;
  }
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v16 + 24))(v16) == 7)
  {
    v32 = *(_QWORD *)(v16 + 32);
    if (v32)
    {
      v33 = *(_QWORD *)(v16 + 40);
      v34 = 240 * v32;
      LODWORD(v16) = 1;
      do
      {
        v35 = a5[1];
        v54[0] = *a5;
        v54[1] = v35;
        v16 = v16 & attachShape(a1, a2, v33, a3, v54, a6, a7, a8);
        v33 += 240;
        v34 -= 240;
      }
      while (v34);
      return v16;
    }
    return 1;
  }
  v36 = *(_QWORD *)(v16 + 8);
  if (!v36)
    return 1;
  a3[6] = a4;
  v53 = 11;
  v37 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, char *))(*(_QWORD *)a1 + 192))(a1, v36, a6, a7, 1, &v53);
  v38 = v37;
  if ((_DWORD)a8)
  {
    (*(void (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v37 + 296))(v37, 1, 0);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v38 + 296))(v38, 4, 1);
  }
  else if (!v37)
  {
    return 1;
  }
  if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)v16 + 40))(v16) & 1) != 0)
  {
    v39 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v16 + 48))(v16);
    _Q2 = a5[1];
    v41 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q2, (int32x4_t)_Q2), (int8x16_t)_Q2, 0xCuLL);
    _Q4 = *(float32x4_t *)(v39 + 16);
    v43 = vnegq_f32(_Q2);
    v44 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(*(int32x4_t *)v39, *(int32x4_t *)v39), *(int8x16_t *)v39, 0xCuLL), v43), *(float32x4_t *)v39, v41);
    v45 = (int32x4_t)vaddq_f32(v44, v44);
    v46 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v45, v45), (int8x16_t)v45, 0xCuLL);
    v47 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v46, (int32x4_t)v46), (int8x16_t)v46, 0xCuLL), v43), v46, v41);
    v48 = vaddq_f32(*a5, vaddq_f32(vaddq_f32(*(float32x4_t *)v39, vmulq_laneq_f32(v46, _Q2, 3)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v47, v47), (int8x16_t)v47, 0xCuLL)));
    _Q3 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q4, (int32x4_t)_Q4), (int8x16_t)_Q4, 0xCuLL), v43), _Q4, v41);
    v50 = vmlaq_laneq_f32(vmlaq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(_Q3, _Q3), (int8x16_t)_Q3, 0xCuLL), _Q4, _Q2, 3), _Q2, _Q4, 3);
    _Q4.i32[0] = _Q4.i32[3];
    __asm { FMLA            S3, S4, V2.S[3] }
    v50.i32[3] = _Q3.i32[0];
    *a5 = v48;
    a5[1] = v50;
    v51 = v48.i32[2];
  }
  else
  {
    v50 = a5[1];
    v48.i64[0] = a5->i64[0];
    v51 = a5->i32[2];
  }
  a3[7] = v38;
  v55 = (int32x4_t)v50;
  v56.i64[0] = v48.i64[0];
  v56.i32[2] = v51;
  (*(void (**)(uint64_t, int32x4_t *))(*(_QWORD *)v38 + 152))(v38, &v55);
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 168))(a2, v38);
  v16 = (*(unsigned int (**)(uint64_t))(*(_QWORD *)v38 + 64))(v38) == 3
     || (*(unsigned int (**)(uint64_t))(*(_QWORD *)v38 + 64))(v38) == 4
     || (*(unsigned int (**)(uint64_t))(*(_QWORD *)v38 + 64))(v38) == 5;
  (**(void (***)(uint64_t))v38)(v38);
  return v16;
}

re::PhysXCollisionObject *re::PhysXCollisionFactory::createCollisionObject(re::PhysXCollisionFactory *this, re::Allocator *a2, re::GeometricObjectBase *a3, _QWORD *a4, void *const *a5, uint64_t a6)
{
  uint64_t v9;
  int v10;
  re::PhysXCollisionObject *v11;
  int32x2_t v12;
  float32x4_t v14;
  uint64_t v15;
  uint64_t v16;

  v9 = *((_QWORD *)this + 2);
  v14 = 0uLL;
  v15 = 0;
  v16 = 0x3F80000000000000;
  if (attachShape(v9, (uint64_t)a4, a3, 0, &v14, (uint64_t)a5, a6, 0))
    v10 = 3;
  else
    v10 = 1;
  v11 = (re::PhysXCollisionObject *)(*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 144, 16);
  v12.i32[0] = 1.0;
  return re::PhysXCollisionObject::PhysXCollisionObject(v11, v10, 8, (uint64_t)a3, 0, a4, v12);
}

uint64_t re::PhysXCollisionFactory::createIndexedTriangleMesh(re *a1, uint64_t a2, uint64_t a3, int a4, int a5, uint64_t a6, unint64_t a7, int a8, uint64_t a9, unint64_t a10)
{
  NSObject *v11;
  const char *v12;
  NSObject *v13;
  uint32_t v14;
  NSObject *v17;
  uint64_t v18;
  int v20;
  uint64_t v21;
  re *v22;
  uint64_t v23;
  NSObject *v24;
  int v25;
  uint64_t (**v26)(physx::PxDefaultMemoryOutputStream *__hidden, const void *, unsigned int);
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint8_t v30[8];
  int v31;
  uint64_t v32;
  int v33;
  uint8_t buf[4];
  _BYTE v35[12];
  int v36;
  int v37;
  uint64_t v38;
  int v39;
  __int16 v40;
  int v41;
  uint64_t v42;
  uint64_t v43;

  v43 = *MEMORY[0x24BDAC8D0];
  if (!a3)
  {
    v11 = *re::collisionLogObjects(a1);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      v12 = "Triangle mesh positions must not be null.";
      goto LABEL_10;
    }
    return 0;
  }
  if (!a6)
  {
    v11 = *re::collisionLogObjects(a1);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      v12 = "Triangle mesh indices must not be null.";
      goto LABEL_10;
    }
    return 0;
  }
  if (a7 != 3 * (a7 / 3))
  {
    v11 = *re::collisionLogObjects(a1);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      v12 = "Triangle mesh index count is not a multiple of 3.";
LABEL_10:
      v13 = v11;
      v14 = 2;
LABEL_11:
      _os_log_error_impl(&dword_224FE9000, v13, OS_LOG_TYPE_ERROR, v12, buf, v14);
      return 0;
    }
    return 0;
  }
  if (a9 && a7 / 3 > a10)
  {
    v17 = *re::collisionLogObjects(a1);
    if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      return 0;
    *(_DWORD *)buf = 134217984;
    *(_QWORD *)v35 = a7;
    v12 = "Failed to cook triangle mesh material index count is too small, expected %zu material indices";
    v13 = v17;
    v14 = 12;
    goto LABEL_11;
  }
  v40 = 0;
  v36 = a4;
  *(_QWORD *)&v35[4] = a3;
  *(_DWORD *)buf = a5;
  v39 = a7 / 3;
  v38 = a6;
  if (a8 == 1)
  {
    v40 = 2;
    v20 = 6;
  }
  else
  {
    v20 = 12;
  }
  v42 = a9;
  v37 = v20;
  v41 = 2 * (a9 != 0);
  v21 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)physx::shdfnd::Foundation::mInstance + 32))(physx::shdfnd::Foundation::mInstance);
  v26 = &off_24ED97C50;
  v27 = v21;
  v28 = 0;
  v29 = 0;
  v25 = 0;
  v22 = (re *)(*(uint64_t (**)(_QWORD *, uint8_t *, uint64_t (***)(physx::PxDefaultMemoryOutputStream *__hidden, const void *, unsigned int), int *))(**((_QWORD **)a1 + 3) + 32))(*((_QWORD **)a1 + 3), buf, &v26, &v25);
  if ((v22 & 1) != 0)
  {
    *(_QWORD *)v30 = &off_24ED97C88;
    v31 = v29;
    v32 = v28;
    v33 = 0;
    v23 = (*(uint64_t (**)(_QWORD *, uint8_t *))(**((_QWORD **)a1 + 2) + 48))(*((_QWORD **)a1 + 2), v30);
    v18 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 72, 8);
    re::PhysXIndexedTriangleMesh::PhysXIndexedTriangleMesh(v18, v23);
  }
  else
  {
    v24 = *re::collisionLogObjects(v22);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v30 = 67109120;
      *(_DWORD *)&v30[4] = v25;
      _os_log_error_impl(&dword_224FE9000, v24, OS_LOG_TYPE_ERROR, "Failed to cook triangle mesh (0x%x)", v30, 8u);
    }
    v18 = 0;
  }
  v26 = &off_24ED97C50;
  if (v28)
    (*(void (**)(uint64_t))(*(_QWORD *)v27 + 24))(v27);
  return v18;
}

uint64_t re::PhysXCollisionFactory::createCharacterController(uint64_t a1, re::Allocator *a2, uint64_t a3, float32x2_t *a4, uint64_t *a5, uint64_t a6, float a7)
{
  float v14;
  float v15;
  uint64_t v16;
  re::CharacterController *v17;
  float v18;
  uint64_t v19;
  _QWORD *v20;
  re::PhysXCollisionObject *v21;
  int32x2_t v22;
  re::PhysXCollisionObject *v23;
  uint64_t v24;

  v14 = *(float *)(a3 + 24);
  if ((float)(*(float *)(a3 + 20) + (float)(v14 * -2.0)) >= 0.01)
    v15 = *(float *)(a3 + 20) + (float)(v14 * -2.0);
  else
    v15 = 0.01;
  v16 = (*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 384, 16);
  v17 = re::CharacterController::CharacterController((re::CharacterController *)v16, a2, *(float *)a3, *(float *)(a3 + 8), *(float *)(a3 + 4));
  *((float *)v17 + 84) = (float)(v15 + (float)(v14 * 2.0)) + (float)(v14 * -2.0);
  *((float *)v17 + 85) = v14;
  *(_QWORD *)v17 = &off_24ED41200;
  *((_QWORD *)v17 + 43) = off_24ED412F8;
  *((_QWORD *)v17 + 44) = v17;
  *((_QWORD *)v17 + 45) = &off_24ED41928;
  *((_QWORD *)v17 + 46) = 0;
  re::PhysXCollisionFactory::createCapsuleShape(v17, a2, (float)(v15 + (float)(*(float *)(a3 + 24) * 2.0)) * a7, *(float *)(a3 + 24) * a7, v18);
  re::internal::PhysXCapsuleController::createUnderlyingController((_QWORD *)v16, (uint64_t)a2, v19, (float *)a3, a4, a5, a6, *(_QWORD *)(a1 + 48), a7);
  v20 = (_QWORD *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(v16 + 152) + 56))(*(_QWORD *)(v16 + 152));
  v21 = (re::PhysXCollisionObject *)(*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 144, 16);
  *(float *)v22.i32 = a7;
  v23 = re::PhysXCollisionObject::PhysXCollisionObject(v21, 1, 0, v16, 0, v20, v22);
  *(_QWORD *)(v16 + 136) = v23;
  v24 = *(_QWORD *)(a3 + 12);
  if (*((_QWORD *)v23 + 4) != v24)
  {
    *((_QWORD *)v23 + 4) = v24;
    (*(void (**)(re::PhysXCollisionObject *))(*(_QWORD *)v23 + 80))(v23);
  }
  return v16;
}

_QWORD *re::PhysXCollisionFactory::serializeRawShape@<X0>(re::Allocator *a1@<X2>, uint64_t a2@<X8>)
{
  _QWORD *result;

  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 24) = 0;
  *(_QWORD *)a2 = a1;
  result = re::DynamicArray<BOOL>::setCapacity((_QWORD *)a2, 0);
  ++*(_DWORD *)(a2 + 24);
  return result;
}

uint64_t re::PhysXCollisionFactory::type(re::PhysXCollisionFactory *this)
{
  return 0;
}

void `anonymous namespace'::PhysXAllocator::~PhysXAllocator(_anonymous_namespace_::PhysXAllocator *this)
{
  JUMPOUT(0x2276933B8);
}

uint64_t `anonymous namespace'::PhysXAllocator::allocate(_anonymous_namespace_::PhysXAllocator *this, uint64_t a2, const char *a3, const char *a4)
{
}

uint64_t `anonymous namespace'::PhysXAllocator::deallocate(_anonymous_namespace_::PhysXAllocator *this, void *a2)
{
}

void re::internal::PhysXControllerBehaviorCallback::getBehaviorFlags(_BYTE *a1@<X8>)
{
  *a1 = 4;
}

{
  *a1 = 4;
}

{
  *a1 = 4;
}

void re::internal::PhysXControllerBehaviorCallback::~PhysXControllerBehaviorCallback(re::internal::PhysXControllerBehaviorCallback *this)
{
  JUMPOUT(0x2276933B8);
}

void ___ZN2re23RECollisionFeatureFlags22getMinimumBoxDimensionEv_block_invoke(uint64_t a1, const char *a2)
{
  re *v2;
  NSObject *v3;
  int v4;
  double v5;
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  re::Defaults::floatValue((re::Defaults *)"RECollisionMinimumBoxDimension", a2, (uint64_t)&v4);
  if ((_BYTE)v4)
    re::RECollisionFeatureFlags::gMinimumBoxDimension = LODWORD(v5);
  v3 = *re::collisionLogObjects(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = 134217984;
    v5 = *(float *)&re::RECollisionFeatureFlags::gMinimumBoxDimension;
    _os_log_impl(&dword_224FE9000, v3, OS_LOG_TYPE_DEFAULT, "RECollisionMinimumBoxDimension is now %f.", (uint8_t *)&v4, 0xCu);
  }
}

void re::ContactSet::~ContactSet(re::ContactSet *this)
{
  uint64_t v2;

  re::ContactSet::deinit(this);
  v2 = *((_QWORD *)this + 2);
  if (v2)
  {
    if (*((_QWORD *)this + 6))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *((_QWORD *)this + 6) = 0;
    *((_QWORD *)this + 3) = 0;
    *((_QWORD *)this + 4) = 0;
    *((_QWORD *)this + 2) = 0;
    ++*((_DWORD *)this + 10);
  }
}

uint64_t re::ContactSet::deinit(re::ContactSet *this)
{
  uint64_t result;
  _QWORD *v3;

  v3 = (_QWORD *)((char *)this + 16);
  result = *((_QWORD *)this + 2);
  if (result)
  {
    if (*((_QWORD *)this + 6))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *((_QWORD *)this + 6) = 0;
    v3[1] = 0;
    v3[2] = 0;
    *v3 = 0;
    ++*((_DWORD *)this + 10);
    *((_QWORD *)this + 14) = 0;
    *((_QWORD *)this + 15) = 0;
  }
  return result;
}

uint64_t re::ContactSet::set(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  _BOOL8 v8;

  v6 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, a3);
  re::DynamicArray<re::Contact>::resize(a1 + 2, (int)v6);
  v7 = *(_QWORD *)(*a1 + 24);
  v8 = v7 != *(_QWORD *)((*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 40))(a2, a3) + 24);
  return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD *, _QWORD, uint64_t, _BOOL8))(*(_QWORD *)a2 + 56))(a2, a3, a1, 0, v6, v8);
}

_QWORD *re::DynamicArray<re::Contact>::resize(_QWORD *result, unint64_t a2)
{
  _QWORD *v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;

  v3 = result;
  v4 = result[2];
  if (v4 >= a2)
  {
    if (v4 <= a2)
      return result;
  }
  else
  {
    if (result[1] < a2)
    {
      result = re::DynamicArray<re::Contact>::setCapacity(result, a2);
      v4 = v3[2];
    }
    if (v4 < a2)
    {
      v5 = v3[4];
      v6 = v5 + 80 * v4;
      v7 = v5 + 80 * a2 - v6;
      if (v7 >= 1)
      {
        v8 = v7 / 0x50uLL + 1;
        do
        {
          *(_DWORD *)(v6 + 64) = 0;
          *(_OWORD *)(v6 + 32) = 0uLL;
          *(_OWORD *)(v6 + 48) = 0uLL;
          *(_OWORD *)v6 = 0uLL;
          *(_OWORD *)(v6 + 16) = 0uLL;
          v6 += 80;
          --v8;
        }
        while (v8 > 1);
      }
    }
  }
  v3[2] = a2;
  ++*((_DWORD *)v3 + 6);
  return result;
}

uint64_t re::ContactSet::merge(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _BOOL8 v10;

  v6 = a1 + 4;
  v7 = a1[8];
  v8 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, a3);
  re::DynamicArray<re::Contact>::resize(v6, (int)v8 + (int)v7);
  v9 = *(_QWORD *)(*(_QWORD *)a1 + 24);
  v10 = v9 != *(_QWORD *)((*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 40))(a2, a3) + 24);
  return (*(uint64_t (**)(uint64_t, uint64_t, unsigned int *, uint64_t, uint64_t, _BOOL8))(*(_QWORD *)a2 + 56))(a2, a3, a1, v7, v8, v10);
}

re::PhysXCollisionObject *re::PhysXCollisionObject::PhysXCollisionObject(re::PhysXCollisionObject *a1, int a2, int a3, uint64_t a4, uint64_t a5, _QWORD *a6, int32x2_t a7)
{
  int32x4_t *v10;
  uint64_t v11;
  __n128 v12;
  uint64_t v13;
  _anonymous_namespace_ *v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  _DWORD *v25;
  int v26;
  uint64_t v29;
  uint64_t v30;
  int v31;
  __int128 v32;
  unint64_t v33;
  _BYTE v34[12];
  uint64_t v35;
  _BYTE v36[18];
  __int16 v37;
  unint64_t v38;
  __int16 v39;
  unint64_t v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  uint64_t v46;

  v46 = *MEMORY[0x24BDAC8D0];
  v10 = (int32x4_t *)re::CollisionObject::CollisionObject((uint64_t)a1, a2, a3, a4, a5, (uint64_t)a6);
  v10->i64[0] = (uint64_t)&off_24ED419D8;
  v10[7].i64[0] = 0;
  v10[7].i64[1] = 0;
  v10[6].i64[1] = 0;
  v10[8] = vdupq_lane_s32(a7, 0);
  a6[2] = v10;
  v11 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a4 + 16))(a4);
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v11 + 24))(v11) == 7)
  {
    v13 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a4 + 16))(a4);
    *(_QWORD *)&v41 = a1;
    *((_QWORD *)&v41 + 1) = re::PhysXCollisionObject::onChildPoseDidChange;
    *(_QWORD *)&v42 = 0;
    *((_QWORD *)&v42 + 1) = re::Event<re::GeometricObjectBase>::createSubscription<re::PhysXCollisionObject>(re::PhysXCollisionObject *,REEventHandlerResult (re::PhysXCollisionObject::*)(re::GeometricObjectBase*))::{lambda(re::GeometricObjectBase*,re::Event<re::GeometricObjectBase>::Subscription const&)#1}::__invoke;
    v12.n128_f64[0] = re::Event<re::GeometricObjectBase>::addSubscription((_DWORD *)(v13 + 56), (uint64_t)&v41);
  }
  v14 = (_anonymous_namespace_ *)(*(uint64_t (**)(_QWORD *, __n128))(*a6 + 184))(a6, v12);
  v15 = (int)v14;
  v16 = v14;
  *((_QWORD *)a1 + 14) = v16;
  if (v15)
  {
    *((_QWORD *)a1 + 15) = v17;
    if (!v17)
    {
LABEL_26:
      re::internal::assertLog((re::internal *)4, v18, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
      _os_crash();
      __break(1u);
LABEL_27:
      re::internal::assertLog((re::internal *)4, v23, "assertion failure: '%s' (%s:line %i) Unsupported geometry type!", "!\"Unreachable code\"", "getExtentsForAllShapes", 63);
      _os_crash();
      __break(1u);
    }
  }
  v19 = (*(uint64_t (**)(_QWORD *))(*a6 + 184))(a6);
  if (v19)
  {
    v20 = 0;
    v21 = v19;
    v22 = 8;
    while (1)
    {
      v29 = 0;
      (*(void (**)(_QWORD *, uint64_t *, uint64_t, unint64_t))(*a6 + 192))(a6, &v29, 1, v20);
      switch((*(unsigned int (**)(uint64_t))(*(_QWORD *)v29 + 64))(v29))
      {
        case 0u:
          v30 = 0;
          (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v29 + 96))(v29, &v30);
          v24 = *((_QWORD *)a1 + 14);
          if (v24 <= v20)
          {
            *(_QWORD *)v36 = 0;
            v44 = 0u;
            v45 = 0u;
            v42 = 0u;
            v43 = 0u;
            v41 = 0u;
            os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
            v31 = 136315906;
            *(_QWORD *)&v32 = "operator[]";
            WORD4(v32) = 1024;
            *(_DWORD *)((char *)&v32 + 10) = 468;
            HIWORD(v32) = 2048;
            v33 = v20;
            *(_WORD *)v34 = 2048;
            *(_QWORD *)&v34[2] = v24;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_22:
            v30 = 0;
            v44 = 0u;
            v45 = 0u;
            v42 = 0u;
            v43 = 0u;
            v41 = 0u;
            os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
            v31 = 136315906;
            *(_QWORD *)&v32 = "operator[]";
            WORD4(v32) = 1024;
            *(_DWORD *)((char *)&v32 + 10) = 468;
            HIWORD(v32) = 2048;
            v33 = v20;
            *(_WORD *)v34 = 2048;
            *(_QWORD *)&v34[2] = v24;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_23:
            v30 = 0;
            v44 = 0u;
            v45 = 0u;
            v42 = 0u;
            v43 = 0u;
            v41 = 0u;
            os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
            v31 = 136315906;
            *(_QWORD *)&v32 = "operator[]";
            WORD4(v32) = 1024;
            *(_DWORD *)((char *)&v32 + 10) = 468;
            HIWORD(v32) = 2048;
            v33 = v20;
            *(_WORD *)v34 = 2048;
            *(_QWORD *)&v34[2] = v24;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_24:
            v30 = 0;
            v44 = 0u;
            v45 = 0u;
            v42 = 0u;
            v43 = 0u;
            v41 = 0u;
            os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
            *(_DWORD *)v36 = 136315906;
            *(_QWORD *)&v36[4] = "operator[]";
            *(_WORD *)&v36[12] = 1024;
            *(_DWORD *)&v36[14] = 468;
            v37 = 2048;
            v38 = v20;
            v39 = 2048;
            v40 = v24;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_25:
            v30 = 0;
            v44 = 0u;
            v45 = 0u;
            v42 = 0u;
            v43 = 0u;
            v41 = 0u;
            os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
            *(_DWORD *)v36 = 136315906;
            *(_QWORD *)&v36[4] = "operator[]";
            *(_WORD *)&v36[12] = 1024;
            *(_DWORD *)&v36[14] = 468;
            v37 = 2048;
            v38 = v20;
            v39 = 2048;
            v40 = v24;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
            goto LABEL_26;
          }
          *(_DWORD *)(*((_QWORD *)a1 + 15) + v22 - 8) = HIDWORD(v30);
LABEL_19:
          ++v20;
          v22 += 12;
          if (v21 == v20)
            goto LABEL_20;
          break;
        case 1u:
          goto LABEL_19;
        case 2u:
          *(_DWORD *)&v36[8] = 0;
          *(_QWORD *)v36 = 2;
          (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)v29 + 104))(v29, v36);
          v24 = *((_QWORD *)a1 + 14);
          if (v24 <= v20)
            goto LABEL_22;
          *(int32x2_t *)(*((_QWORD *)a1 + 15) + v22 - 8) = vrev64_s32(*(int32x2_t *)&v36[4]);
          goto LABEL_19;
        case 3u:
          *(_QWORD *)v36 = 3;
          *(_QWORD *)&v36[8] = 0;
          (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)v29 + 88))(v29, v36);
          v24 = *((_QWORD *)a1 + 14);
          if (v24 <= v20)
            goto LABEL_23;
          v25 = (_DWORD *)(*((_QWORD *)a1 + 15) + v22);
          *((_QWORD *)v25 - 1) = *(_QWORD *)&v36[4];
          v26 = *(_DWORD *)&v36[12];
          goto LABEL_18;
        case 4u:
          v31 = 4;
          v32 = xmmword_2260EDC60;
          v33 = 0;
          *(_DWORD *)v34 = 1065353216;
          *(_QWORD *)&v34[4] = 0;
          LOBYTE(v35) = 1;
          *(_WORD *)((char *)&v35 + 1) = 0;
          BYTE3(v35) = 0;
          (*(void (**)(uint64_t, int *))(*(_QWORD *)v29 + 120))(v29, &v31);
          v24 = *((_QWORD *)a1 + 14);
          if (v24 <= v20)
            goto LABEL_24;
          goto LABEL_17;
        case 5u:
          v31 = 5;
          v32 = xmmword_2260EDC60;
          v33 = 0;
          *(_QWORD *)v34 = 1065353216;
          v35 = 0;
          (*(void (**)(uint64_t, int *))(*(_QWORD *)v29 + 128))(v29, &v31);
          v24 = *((_QWORD *)a1 + 14);
          if (v24 <= v20)
            goto LABEL_25;
LABEL_17:
          v25 = (_DWORD *)(*((_QWORD *)a1 + 15) + v22);
          *((_QWORD *)v25 - 1) = v32;
          v26 = DWORD2(v32);
LABEL_18:
          *v25 = v26;
          goto LABEL_19;
        default:
          goto LABEL_27;
      }
    }
  }
LABEL_20:
  re::PhysXCollisionObject::updateFilterData(a1);
  return a1;
}

uint64_t re::PhysXCollisionObject::onChildPoseDidChange(re::PhysXCollisionObject *this, re::GeometricObjectBase *a2, float32x4_t a3)
{
  float32x4_t v5[2];

  re::GeometricObjectBase::parentPose(a2, v5, a3);
  updateLocalPoses(a2, v5);
  return 0;
}

uint64_t re::PhysXCollisionObject::updateFilterData(re::PhysXCollisionObject *this)
{
  unsigned __int16 *v2;
  int v3;
  BOOL v4;
  unsigned int v5;
  uint64_t result;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD v12[2];
  uint64_t v13;

  v2 = (unsigned __int16 *)*((_QWORD *)this + 3);
  v3 = *((_DWORD *)this + 2) & 1;
  if (v2)
    v4 = v2[4] == 5;
  else
    v4 = 0;
  if (v4)
  {
    (*(void (**)(_QWORD *__return_ptr, _QWORD))(*(_QWORD *)v2 + 432))(v12, *((_QWORD *)this + 3));
    v3 |= (LOBYTE(v12[0]) >> 1) & 2;
  }
  v5 = *((_DWORD *)this + 22);
  result = (*(uint64_t (**)(unsigned __int16 *))(*(_QWORD *)v2 + 184))(v2);
  if ((_DWORD)result)
  {
    v7 = 0;
    v8 = (v5 >> 1) & 4 | v3;
    do
    {
      v13 = 0;
      (*(void (**)(unsigned __int16 *, uint64_t *, uint64_t, uint64_t))(*(_QWORD *)v2 + 192))(v2, &v13, 1, v7);
      v9 = *((_QWORD *)this + 4);
      v12[0] = v8;
      v12[1] = v9;
      (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v13 + 168))(v13, v12);
      (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v13 + 184))(v13, v12);
      v7 = (v7 + 1);
      result = (*(uint64_t (**)(unsigned __int16 *))(*(_QWORD *)v2 + 184))(v2);
    }
    while (v7 < result);
  }
  v10 = *((_QWORD *)this + 7);
  if (v10)
  {
    re::ContactSetCollection::remove(*(_QWORD *)(v10 + 128) + 72, this);
    (*(void (**)(_QWORD, re::PhysXCollisionObject *))(**(_QWORD **)(v10 + 128) + 200))(*(_QWORD *)(v10 + 128), this);
    v11 = *(_QWORD *)(v10 + 128);
    *((_QWORD *)this + 7) = v11;
    return (*(uint64_t (**)(uint64_t, re::PhysXCollisionObject *))(*(_QWORD *)v11 + 192))(v11, this);
  }
  return result;
}

void re::PhysXCollisionObject::~PhysXCollisionObject(re::PhysXCollisionObject *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void (***v5)(_QWORD);
  uint64_t v6;
  __int128 v7;
  uint64_t v8;
  uint64_t (*v9)(uint64_t, _QWORD *);
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v2 = *((_QWORD *)this + 2);
  v3 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 16))(v2);
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3) == 7)
  {
    v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 16))(v2);
    *(_QWORD *)&v7 = this;
    *((_QWORD *)&v7 + 1) = re::PhysXCollisionObject::onChildPoseDidChange;
    v8 = 0;
    v9 = re::Event<re::GeometricObjectBase>::createSubscription<re::PhysXCollisionObject>(re::PhysXCollisionObject *,REEventHandlerResult (re::PhysXCollisionObject::*)(re::GeometricObjectBase*))::{lambda(re::GeometricObjectBase*,re::Event<re::GeometricObjectBase>::Subscription const&)#1}::__invoke;
    re::Event<re::GeometricObjectBase>::removeSubscription(v4 + 56, &v7);
  }
  v5 = (void (***)(_QWORD))*((_QWORD *)this + 3);
  if (v5)
    (**v5)(v5);
  v6 = *((_QWORD *)this + 13);
  if (v6)
  {
    if (*((_QWORD *)this + 14))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v6 + 40))(v6, *((_QWORD *)this + 15));
      *((_QWORD *)this + 14) = 0;
      *((_QWORD *)this + 15) = 0;
    }
    *((_QWORD *)this + 13) = 0;
  }
  re::CollisionObject::~CollisionObject(this);
}

{
  re::PhysXCollisionObject::~PhysXCollisionObject(this);
  JUMPOUT(0x2276933B8);
}

re::PhysXCollisionObject *re::PhysXCollisionObject::setRawCollisionObject(re::PhysXCollisionObject *this, _QWORD *a2)
{
  *((_QWORD *)this + 3) = a2;
  if (a2)
  {
    a2[2] = this;
    return (re::PhysXCollisionObject *)re::PhysXCollisionObject::updateFilterData(this);
  }
  return this;
}

uint64_t re::PhysXCollisionObject::poseDidChange(re::PhysXCollisionObject *this, re::GeometricObjectBase *a2)
{
  uint64_t v2;
  uint64_t v4;
  int v5;
  __int128 v6;
  __int128 v7;
  uint64_t v8;
  int v9;

  v2 = *((_QWORD *)this + 3);
  (*(void (**)(uint64_t *__return_ptr, re::GeometricObjectBase *))(*(_QWORD *)a2 + 40))(&v4, a2);
  v7 = v6;
  v8 = v4;
  v9 = v5;
  (*(void (**)(uint64_t, __int128 *, uint64_t))(*(_QWORD *)v2 + 160))(v2, &v7, 1);
  return 0;
}

uint64_t updateLocalPoses(_QWORD *a1, float32x4_t *a2)
{
  float32x4_t v6;
  float32x4_t v7;
  int32x4_t v8;
  float32x4_t v9;
  int32x4_t v10;
  float32x4_t v12;
  float32x4_t v13;
  _QWORD *v18;
  uint64_t result;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  float32x4_t v25;
  float32x4_t v28;
  int32x4_t v29;
  float32x4_t v30;
  int32x4_t v31;
  float32x4_t v32;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  __int32 v37;
  float32x4_t v38;
  int32x4_t v39;
  int32x4_t v40;
  _OWORD v41[2];

  (*(void (**)(int32x4_t *__return_ptr))(*a1 + 40))(&v39);
  _Q0 = a2[1];
  _Q2 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q0, (int32x4_t)_Q0), (int8x16_t)_Q0, 0xCuLL);
  v6 = vnegq_f32(_Q0);
  v7 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v39, v39), (int8x16_t)v39, 0xCuLL), v6), (float32x4_t)v39, _Q2);
  v8 = (int32x4_t)vaddq_f32(v7, v7);
  v9 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v8, v8), (int8x16_t)v8, 0xCuLL);
  v10 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v9, (int32x4_t)v9), (int8x16_t)v9, 0xCuLL), v6), v9, _Q2);
  _Q1 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v40, v40), (int8x16_t)v40, 0xCuLL), v6), (float32x4_t)v40, _Q2);
  v12 = vmlaq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(_Q1, _Q1), (int8x16_t)_Q1, 0xCuLL), (float32x4_t)v40, _Q0, 3);
  _Q1.i32[0] = v40.i32[3];
  v13 = vmlaq_laneq_f32(v12, _Q0, (float32x4_t)v40, 3);
  __asm { FMLA            S2, S1, V0.S[3] }
  v36 = v13;
  v37 = _Q2.i32[0];
  v13.i32[3] = _Q2.i32[0];
  v38 = vaddq_f32(*a2, vaddq_f32(vaddq_f32((float32x4_t)v39, vmulq_laneq_f32(v9, _Q0, 3)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v10, v10), (int8x16_t)v10, 0xCuLL)));
  v41[0] = v38;
  v41[1] = v13;
  v35 = v13;
  v18 = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*a1 + 16))(a1);
  result = (*(uint64_t (**)(_QWORD *))(*v18 + 24))(v18);
  if ((_DWORD)result != 1)
  {
    if ((_DWORD)result == 7)
    {
      v20 = v18[4];
      if (v20)
      {
        v21 = v18[5];
        v22 = 240 * v20;
        do
        {
          result = updateLocalPoses(v21, v41);
          v21 += 240;
          v22 -= 240;
        }
        while (v22);
      }
    }
    else
    {
      v23 = a1[7];
      if ((*(unsigned int (**)(_QWORD *))(*v18 + 40))(v18))
      {
        v24 = (*(uint64_t (**)(_QWORD *))(*v18 + 48))(v18);
        v25 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v36, (int32x4_t)v36), (int8x16_t)v36, 0xCuLL);
        _Q2 = *(float32x4_t *)(v24 + 16);
        _Q4 = vnegq_f32(v36);
        v28 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(*(int32x4_t *)v24, *(int32x4_t *)v24), *(int8x16_t *)v24, 0xCuLL), _Q4), *(float32x4_t *)v24, v25);
        v29 = (int32x4_t)vaddq_f32(v28, v28);
        v30 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v29, v29), (int8x16_t)v29, 0xCuLL);
        v31 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v30, (int32x4_t)v30), (int8x16_t)v30, 0xCuLL), _Q4), v30, v25);
        v32 = vaddq_f32(v38, vaddq_f32(vaddq_f32(*(float32x4_t *)v24, vmulq_laneq_f32(v30, v35, 3)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v31, v31), (int8x16_t)v31, 0xCuLL)));
        _Q3 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q2, (int32x4_t)_Q2), (int8x16_t)_Q2, 0xCuLL), _Q4), _Q2, v25);
        v34 = vmlaq_laneq_f32(vmlaq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(_Q3, _Q3), (int8x16_t)_Q3, 0xCuLL), _Q2, v35, 3), v36, _Q2, 3);
        _Q4.i32[0] = v37;
        __asm { FMLA            S3, S4, V2.S[3] }
        v39.i64[0] = v34.i64[0];
        v39.i64[1] = __PAIR64__(_Q3.u32[0], v34.u32[2]);
        v40.i64[0] = v32.i64[0];
        v40.i32[2] = v32.i32[2];
      }
      else
      {
        v39.i64[0] = v36.i64[0];
        v39.i64[1] = __PAIR64__(v37, v36.u32[2]);
        v40.i64[0] = v38.i64[0];
        v40.i32[2] = v38.i32[2];
      }
      return (*(uint64_t (**)(uint64_t, int32x4_t *))(*(_QWORD *)v23 + 152))(v23, &v39);
    }
  }
  return result;
}

uint64_t re::PhysXCollisionObject::pxShape(uint64_t a1, uint64_t a2, float *a3)
{
  uint64_t v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  uint64_t v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  uint64_t v22;
  uint64_t v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;

  v5 = *(_QWORD *)(a1 + 24);
  (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(_QWORD *)v5 + 152))(&v23, v5);
  v22 = 0;
  (*(void (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(*(_QWORD *)v5 + 192))(v5, &v22, 1, a2);
  if (a3)
  {
    (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v22 + 160))(&v16);
    v6 = (float)(v25 * v25) + -0.5;
    v7 = (float)((float)((float)(v20 + v20) * *((float *)&v23 + 1)) + (float)(*(float *)&v23 * (float)(v19 + v19)))
       + (float)(v24 * (float)(v21 + v21));
    v8 = (float)((float)(v25
                       * (float)((float)(*(float *)&v23 * (float)(v20 + v20))
                               - (float)(*((float *)&v23 + 1) * (float)(v19 + v19))))
               + (float)((float)(v21 + v21) * v6))
       + (float)(v24 * v7);
    v9 = v26
       + (float)((float)((float)(v25
                               * (float)((float)(*((float *)&v23 + 1) * (float)(v21 + v21))
                                       - (float)(v24 * (float)(v20 + v20))))
                       + (float)((float)(v19 + v19) * v6))
               + (float)(*(float *)&v23 * v7));
    v10 = v27
        + (float)((float)((float)(v25
                                * (float)((float)(v24 * (float)(v19 + v19))
                                        - (float)(*(float *)&v23 * (float)(v21 + v21))))
                        + (float)((float)(v20 + v20) * v6))
                + (float)(*((float *)&v23 + 1) * v7));
    v11 = (float)((float)((float)(*((float *)&v23 + 1) * v18) + (float)(v25 * *((float *)&v16 + 1)))
                + (float)(v24 * *(float *)&v16))
        - (float)(v17 * *(float *)&v23);
    v12 = (float)((float)((float)(v24 * v18) + (float)(v25 * v17)) + (float)(*(float *)&v23 * *((float *)&v16 + 1)))
        - (float)(*(float *)&v16 * *((float *)&v23 + 1));
    v13 = v28;
    v14 = (float)((float)((float)(v25 * v18) - (float)(*(float *)&v23 * *(float *)&v16))
                - (float)(*((float *)&v23 + 1) * *((float *)&v16 + 1)))
        - (float)(v24 * v17);
    *a3 = (float)((float)((float)(*(float *)&v23 * v18) + (float)(v25 * *(float *)&v16))
                + (float)(*((float *)&v23 + 1) * v17))
        - (float)(*((float *)&v16 + 1) * v24);
    a3[1] = v11;
    a3[2] = v12;
    a3[3] = v14;
    a3[4] = v9;
    a3[5] = v10;
    a3[6] = v13 + v8;
  }
  return v22;
}

uint64_t re::PhysXCollisionObject::hasTriggerShapes(re::PhysXCollisionObject *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  unsigned __int8 v5;
  uint64_t v6;

  v1 = *((_QWORD *)this + 3);
  if (!(*(unsigned int (**)(uint64_t))(*(_QWORD *)v1 + 184))(v1))
    return 1;
  v2 = 0;
  do
  {
    v6 = 0;
    (*(void (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(*(_QWORD *)v1 + 192))(v1, &v6, 1, v2);
    (*(void (**)(unsigned __int8 *__return_ptr))(*(_QWORD *)v6 + 312))(&v5);
    v3 = (v5 >> 2) & 1;
    if ((v5 & 4) == 0)
      break;
    v2 = (v2 + 1);
  }
  while (v2 < (*(unsigned int (**)(uint64_t))(*(_QWORD *)v1 + 184))(v1));
  return v3;
}

__n128 re::PhysXCollisionObject::setScaleInternal(uint64_t a1, float32x2_t *a2)
{
  _WORD *v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  void (*v9)(void);
  float32x2_t *v10;
  float v11;
  float32x2_t *v12;
  float v13;
  __n128 result;
  uint64_t v15;
  uint64_t v16;
  int v17;
  __int128 v18;
  unint64_t v19;
  _BYTE v20[12];
  uint64_t v21;
  _BYTE v22[18];
  __int16 v23;
  unint64_t v24;
  __int16 v25;
  unint64_t v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  v4 = *(_WORD **)(a1 + 24);
  if ((*(unsigned int (**)(_WORD *))(*(_QWORD *)v4 + 184))(v4))
  {
    v5 = 0;
    v6 = 0;
    do
    {
      v15 = 0;
      (*(void (**)(_WORD *, uint64_t *, uint64_t, unint64_t))(*(_QWORD *)v4 + 192))(v4, &v15, 1, v6);
      switch((*(unsigned int (**)(uint64_t))(*(_QWORD *)v15 + 64))(v15))
      {
        case 0u:
          v16 = 0;
          (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v15 + 96))(v15, &v16);
          v8 = *(_QWORD *)(a1 + 112);
          if (v8 <= v6)
          {
            *(_QWORD *)v22 = 0;
            v30 = 0u;
            v31 = 0u;
            v28 = 0u;
            v29 = 0u;
            v27 = 0u;
            os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
            v17 = 136315906;
            *(_QWORD *)&v18 = "operator[]";
            WORD4(v18) = 1024;
            *(_DWORD *)((char *)&v18 + 10) = 468;
            HIWORD(v18) = 2048;
            v19 = v6;
            *(_WORD *)v20 = 2048;
            *(_QWORD *)&v20[2] = v8;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_23:
            v16 = 0;
            v30 = 0u;
            v31 = 0u;
            v28 = 0u;
            v29 = 0u;
            v27 = 0u;
            os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
            v17 = 136315906;
            *(_QWORD *)&v18 = "operator[]";
            WORD4(v18) = 1024;
            *(_DWORD *)((char *)&v18 + 10) = 468;
            HIWORD(v18) = 2048;
            v19 = v6;
            *(_WORD *)v20 = 2048;
            *(_QWORD *)&v20[2] = v8;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_24:
            v16 = 0;
            v30 = 0u;
            v31 = 0u;
            v28 = 0u;
            v29 = 0u;
            v27 = 0u;
            os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
            v17 = 136315906;
            *(_QWORD *)&v18 = "operator[]";
            WORD4(v18) = 1024;
            *(_DWORD *)((char *)&v18 + 10) = 468;
            HIWORD(v18) = 2048;
            v19 = v6;
            *(_WORD *)v20 = 2048;
            *(_QWORD *)&v20[2] = v8;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_25:
            v16 = 0;
            v30 = 0u;
            v31 = 0u;
            v28 = 0u;
            v29 = 0u;
            v27 = 0u;
            os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
            *(_DWORD *)v22 = 136315906;
            *(_QWORD *)&v22[4] = "operator[]";
            *(_WORD *)&v22[12] = 1024;
            *(_DWORD *)&v22[14] = 468;
            v23 = 2048;
            v24 = v6;
            v25 = 2048;
            v26 = v8;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_26:
            v16 = 0;
            v30 = 0u;
            v31 = 0u;
            v28 = 0u;
            v29 = 0u;
            v27 = 0u;
            os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
            *(_DWORD *)v22 = 136315906;
            *(_QWORD *)&v22[4] = "operator[]";
            *(_WORD *)&v22[12] = 1024;
            *(_DWORD *)&v22[14] = 468;
            v23 = 2048;
            v24 = v6;
            v25 = 2048;
            v26 = v8;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_27:
            re::internal::assertLog((re::internal *)4, v7, "assertion failure: '%s' (%s:line %i) Unsupported geometry type!", "!\"Unreachable code\"", "setScaleInternal", 238);
            _os_crash();
            __break(1u);
          }
          *((float *)&v16 + 1) = *(float *)(*(_QWORD *)(a1 + 120) + v5) * a2->f32[0];
          v9 = *(void (**)(void))(*(_QWORD *)v15 + 72);
          break;
        case 1u:
          goto LABEL_16;
        case 2u:
          *(_DWORD *)&v22[8] = 0;
          *(_QWORD *)v22 = 2;
          (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)v15 + 104))(v15, v22);
          v8 = *(_QWORD *)(a1 + 112);
          if (v8 <= v6)
            goto LABEL_23;
          *(int32x2_t *)&v22[4] = vrev64_s32((int32x2_t)vmul_n_f32(*(float32x2_t *)(*(_QWORD *)(a1 + 120) + v5), COERCE_FLOAT(*a2)));
          goto LABEL_10;
        case 3u:
          *(_QWORD *)v22 = 3;
          *(_QWORD *)&v22[8] = 0;
          (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)v15 + 88))(v15, v22);
          v8 = *(_QWORD *)(a1 + 112);
          if (v8 <= v6)
            goto LABEL_24;
          v10 = (float32x2_t *)(*(_QWORD *)(a1 + 120) + v5);
          v11 = v10[1].f32[0] * a2[1].f32[0];
          *(float32x2_t *)&v22[4] = vmul_f32(*v10, *a2);
          *(float *)&v22[12] = v11;
LABEL_10:
          v9 = *(void (**)(void))(*(_QWORD *)v15 + 72);
          break;
        case 4u:
          v17 = 4;
          v18 = xmmword_2260EDC60;
          v19 = 0;
          *(_DWORD *)v20 = 1065353216;
          *(_QWORD *)&v20[4] = 0;
          LOBYTE(v21) = 1;
          *(_WORD *)((char *)&v21 + 1) = 0;
          BYTE3(v21) = 0;
          (*(void (**)(uint64_t, int *))(*(_QWORD *)v15 + 120))(v15, &v17);
          v8 = *(_QWORD *)(a1 + 112);
          if (v8 <= v6)
            goto LABEL_25;
          goto LABEL_14;
        case 5u:
          v17 = 5;
          v18 = xmmword_2260EDC60;
          v19 = 0;
          *(_QWORD *)v20 = 1065353216;
          v21 = 0;
          (*(void (**)(uint64_t, int *))(*(_QWORD *)v15 + 128))(v15, &v17);
          v8 = *(_QWORD *)(a1 + 112);
          if (v8 <= v6)
            goto LABEL_26;
LABEL_14:
          v12 = (float32x2_t *)(*(_QWORD *)(a1 + 120) + v5);
          v13 = v12[1].f32[0] * a2[1].f32[0];
          *(float32x2_t *)&v18 = vmul_f32(*v12, *a2);
          *((float *)&v18 + 2) = v13;
          v9 = *(void (**)(void))(*(_QWORD *)v15 + 72);
          break;
        default:
          goto LABEL_27;
      }
      v9();
LABEL_16:
      if (v4[4] == 5
        && (*(uint64_t (**)(_WORD *))(*(_QWORD *)v4 + 56))(v4)
        && (*(unsigned int (**)(_WORD *))(*(_QWORD *)v4 + 512))(v4))
      {
        (*(void (**)(_WORD *))(*(_QWORD *)v4 + 592))(v4);
      }
      ++v6;
      v5 += 12;
    }
    while (v6 < (*(unsigned int (**)(_WORD *))(*(_QWORD *)v4 + 184))(v4));
  }
  result = *(__n128 *)a2->f32;
  *(_OWORD *)(a1 + 128) = *(_OWORD *)a2->f32;
  return result;
}

uint64_t re::PhysXCollisionObject::scale(re::PhysXCollisionObject *this)
{
  return *((_QWORD *)this + 16);
}

void re::PhysXCollisionObject::logState(re::PhysXCollisionObject *this)
{
  uint64_t v2;
  re *v3;
  re *v4;
  int v5;
  NSObject *v6;
  _BOOL8 v7;
  NSObject *v8;
  re *v9;
  NSObject *v10;
  re *v11;
  NSObject *v12;
  _BOOL8 v13;
  NSObject *v14;
  _BOOL8 v15;
  double v16;
  double v17;
  double v18;
  NSObject *v19;
  _BOOL8 v20;
  int v21;
  NSObject *v22;
  _BOOL8 v23;
  float v24;
  NSObject *v25;
  _BOOL8 v26;
  float v27;
  NSObject *v28;
  _BOOL8 v29;
  NSObject *v30;
  float v31;
  re *v32;
  NSObject *v33;
  re *v34;
  NSObject *v35;
  _BOOL8 v36;
  NSObject *v37;
  _BOOL8 v38;
  float v39;
  NSObject *v40;
  float v41;
  re *v42;
  NSObject *v43;
  re *v44;
  NSObject *v45;
  _BOOL8 v46;
  NSObject *v47;
  _BOOL8 v48;
  float v49;
  NSObject *v50;
  _BOOL8 v51;
  float v52;
  NSObject *v53;
  float v54;
  const char *v55;
  NSObject *v56;
  uint32_t v57;
  NSObject *v58;
  int v59;
  uint64_t v60;
  float v61;
  uint64_t v62;
  float v63;
  __int128 v64;
  uint64_t v65;
  float v66;
  _BYTE buf[24];
  double v68;
  __int16 v69;
  double v70;
  __int16 v71;
  double v72;
  __int16 v73;
  double v74;
  __int16 v75;
  double v76;
  uint64_t v77;

  v77 = *MEMORY[0x24BDAC8D0];
  v2 = *((_QWORD *)this + 3);
  v3 = (re *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
  if (!(_DWORD)v3)
  {
    v58 = *re::collisionLogObjects(v3);
    if (!os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
      return;
    *(_DWORD *)buf = 134218240;
    *(_QWORD *)&buf[4] = this;
    *(_WORD *)&buf[12] = 2048;
    *(_QWORD *)&buf[14] = v2;
    v55 = "%p (%p) - Actor type: static";
    v56 = v58;
    v57 = 22;
    goto LABEL_46;
  }
  v4 = (re *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
  v5 = (int)v4;
  v6 = *re::collisionLogObjects(v4);
  v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  if (v5 != 1)
  {
    if (!v7)
      return;
    v59 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
    *(_DWORD *)buf = 134218240;
    *(_QWORD *)&buf[4] = this;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v59;
    v55 = "%p - Actor type: unknown! %d";
    v56 = v6;
    v57 = 18;
    goto LABEL_46;
  }
  if (v7)
  {
    *(_DWORD *)buf = 134218240;
    *(_QWORD *)&buf[4] = this;
    *(_WORD *)&buf[12] = 2048;
    *(_QWORD *)&buf[14] = v2;
    _os_log_impl(&dword_224FE9000, v6, OS_LOG_TYPE_DEFAULT, "%p (%p) - Actor type: dynamic", buf, 0x16u);
  }
  v8 = *re::collisionLogObjects((re *)v7);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    (*(void (**)(__int128 *__return_ptr, uint64_t))(*(_QWORD *)v2 + 432))(&v64, v2);
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v64;
    _os_log_impl(&dword_224FE9000, v8, OS_LOG_TYPE_DEFAULT, "RB flags: %#010x", buf, 8u);
  }
  v9 = (re *)(*(uint64_t (**)(uint64_t, __int128 *))(*(_QWORD *)v2 + 504))(v2, &v64);
  if ((_DWORD)v9)
  {
    v10 = *re::collisionLogObjects(v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134218496;
      *(double *)&buf[4] = *(float *)&v65;
      *(_WORD *)&buf[12] = 2048;
      *(double *)&buf[14] = *((float *)&v65 + 1);
      *(_WORD *)&buf[22] = 2048;
      v68 = v66;
      _os_log_impl(&dword_224FE9000, v10, OS_LOG_TYPE_DEFAULT, "Kinematic target set to: %f, %f, %f", buf, 0x20u);
    }
  }
  v11 = (re *)(*(_QWORD *(**)(_BYTE *__return_ptr, uint64_t))(*(_QWORD *)v2 + 152))(buf, v2);
  v64 = *(_OWORD *)buf;
  v65 = *(_QWORD *)&buf[16];
  v66 = *(float *)&v68;
  v12 = *re::collisionLogObjects(v11);
  v13 = os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT);
  if (v13)
  {
    *(_DWORD *)buf = 134218496;
    *(double *)&buf[4] = *(float *)&v65;
    *(_WORD *)&buf[12] = 2048;
    *(double *)&buf[14] = *((float *)&v65 + 1);
    *(_WORD *)&buf[22] = 2048;
    v68 = v66;
    _os_log_impl(&dword_224FE9000, v12, OS_LOG_TYPE_DEFAULT, "Pose: %f, %f, %f", buf, 0x20u);
  }
  v14 = *re::collisionLogObjects((re *)v13);
  v15 = os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT);
  if (v15)
  {
    v16 = *((float *)this + 32);
    v17 = *((float *)this + 33);
    v18 = *((float *)this + 34);
    *(_DWORD *)buf = 134218496;
    *(double *)&buf[4] = v16;
    *(_WORD *)&buf[12] = 2048;
    *(double *)&buf[14] = v17;
    *(_WORD *)&buf[22] = 2048;
    v68 = v18;
    _os_log_impl(&dword_224FE9000, v14, OS_LOG_TYPE_DEFAULT, "Scale: %f, %f, %f", buf, 0x20u);
  }
  v19 = *re::collisionLogObjects((re *)v15);
  v20 = os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT);
  if (v20)
  {
    v21 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 512))(v2);
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v21;
    _os_log_impl(&dword_224FE9000, v19, OS_LOG_TYPE_DEFAULT, "Sleeping: %d", buf, 8u);
  }
  v22 = *re::collisionLogObjects((re *)v20);
  v23 = os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT);
  if (v23)
  {
    v24 = (*(float (**)(uint64_t))(*(_QWORD *)v2 + 528))(v2);
    *(_DWORD *)buf = 134217984;
    *(double *)&buf[4] = v24;
    _os_log_impl(&dword_224FE9000, v22, OS_LOG_TYPE_DEFAULT, "Sleep threshold: %f", buf, 0xCu);
  }
  v25 = *re::collisionLogObjects((re *)v23);
  v26 = os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT);
  if (v26)
  {
    v27 = (*(float (**)(uint64_t))(*(_QWORD *)v2 + 584))(v2);
    *(_DWORD *)buf = 134217984;
    *(double *)&buf[4] = v27;
    _os_log_impl(&dword_224FE9000, v25, OS_LOG_TYPE_DEFAULT, "Wake counter: %f", buf, 0xCu);
  }
  v28 = *re::collisionLogObjects((re *)v26);
  v29 = os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT);
  if (v29)
  {
    (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(_QWORD *)v2 + 552))(&v62, v2);
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v62;
    _os_log_impl(&dword_224FE9000, v28, OS_LOG_TYPE_DEFAULT, "Lock Flags %#010x", buf, 8u);
  }
  v30 = *re::collisionLogObjects((re *)v29);
  if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
  {
    v31 = (*(float (**)(uint64_t))(*(_QWORD *)v2 + 240))(v2);
    *(_DWORD *)buf = 134217984;
    *(double *)&buf[4] = v31;
    _os_log_impl(&dword_224FE9000, v30, OS_LOG_TYPE_DEFAULT, "Mass: %f", buf, 0xCu);
  }
  v32 = (re *)(*(_QWORD *(**)(_BYTE *__return_ptr, uint64_t))(*(_QWORD *)v2 + 224))(buf, v2);
  v64 = *(_OWORD *)buf;
  v65 = *(_QWORD *)&buf[16];
  v66 = *(float *)&v68;
  v33 = *re::collisionLogObjects(v32);
  if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134219520;
    *(double *)&buf[4] = *(float *)&v65;
    *(_WORD *)&buf[12] = 2048;
    *(double *)&buf[14] = *((float *)&v65 + 1);
    *(_WORD *)&buf[22] = 2048;
    v68 = v66;
    v69 = 2048;
    v70 = *(float *)&v64;
    v71 = 2048;
    v72 = *((float *)&v64 + 1);
    v73 = 2048;
    v74 = *((float *)&v64 + 2);
    v75 = 2048;
    v76 = *((float *)&v64 + 3);
    _os_log_impl(&dword_224FE9000, v33, OS_LOG_TYPE_DEFAULT, "CMass local pose: %f, %f, %f, %f, %f, %f, %f", buf, 0x48u);
  }
  v34 = (re *)(*(_QWORD *(**)(uint64_t *__return_ptr, uint64_t))(*(_QWORD *)v2 + 264))(&v62, v2);
  v35 = *re::collisionLogObjects(v34);
  v36 = os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT);
  if (v36)
  {
    *(_DWORD *)buf = 134218496;
    *(double *)&buf[4] = *(float *)&v62;
    *(_WORD *)&buf[12] = 2048;
    *(double *)&buf[14] = *((float *)&v62 + 1);
    *(_WORD *)&buf[22] = 2048;
    v68 = v63;
    _os_log_impl(&dword_224FE9000, v35, OS_LOG_TYPE_DEFAULT, "MassSpace inertia tensor: %f, %f, %f", buf, 0x20u);
  }
  v37 = *re::collisionLogObjects((re *)v36);
  v38 = os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT);
  if (v38)
  {
    v39 = (*(float (**)(uint64_t))(*(_QWORD *)v2 + 288))(v2);
    *(_DWORD *)buf = 134217984;
    *(double *)&buf[4] = v39;
    _os_log_impl(&dword_224FE9000, v37, OS_LOG_TYPE_DEFAULT, "Linear damping: %f", buf, 0xCu);
  }
  v40 = *re::collisionLogObjects((re *)v38);
  if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
  {
    v41 = (*(float (**)(uint64_t))(*(_QWORD *)v2 + 304))(v2);
    *(_DWORD *)buf = 134217984;
    *(double *)&buf[4] = v41;
    _os_log_impl(&dword_224FE9000, v40, OS_LOG_TYPE_DEFAULT, "Angular damping: %f", buf, 0xCu);
  }
  v42 = (re *)(*(_QWORD *(**)(uint64_t *__return_ptr, uint64_t))(*(_QWORD *)v2 + 312))(&v60, v2);
  v43 = *re::collisionLogObjects(v42);
  if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134218496;
    *(double *)&buf[4] = *(float *)&v60;
    *(_WORD *)&buf[12] = 2048;
    *(double *)&buf[14] = *((float *)&v60 + 1);
    *(_WORD *)&buf[22] = 2048;
    v68 = v61;
    _os_log_impl(&dword_224FE9000, v43, OS_LOG_TYPE_DEFAULT, "Linear velocity: %f, %f, %f", buf, 0x20u);
  }
  v44 = (re *)(*(_QWORD *(**)(_BYTE *__return_ptr, uint64_t))(*(_QWORD *)v2 + 328))(buf, v2);
  v60 = *(_QWORD *)buf;
  v61 = *(float *)&buf[8];
  v45 = *re::collisionLogObjects(v44);
  v46 = os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT);
  if (v46)
  {
    *(_DWORD *)buf = 134218496;
    *(double *)&buf[4] = *(float *)&v60;
    *(_WORD *)&buf[12] = 2048;
    *(double *)&buf[14] = *((float *)&v60 + 1);
    *(_WORD *)&buf[22] = 2048;
    v68 = v61;
    _os_log_impl(&dword_224FE9000, v45, OS_LOG_TYPE_DEFAULT, "Angular velocity: %f, %f, %f", buf, 0x20u);
  }
  v47 = *re::collisionLogObjects((re *)v46);
  v48 = os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT);
  if (v48)
  {
    v49 = (*(float (**)(uint64_t))(*(_QWORD *)v2 + 352))(v2);
    *(_DWORD *)buf = 134217984;
    *(double *)&buf[4] = v49;
    _os_log_impl(&dword_224FE9000, v47, OS_LOG_TYPE_DEFAULT, "Max angular velocity: %f", buf, 0xCu);
  }
  v50 = *re::collisionLogObjects((re *)v48);
  v51 = os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT);
  if (v51)
  {
    v52 = (*(float (**)(uint64_t))(*(_QWORD *)v2 + 368))(v2);
    *(_DWORD *)buf = 134217984;
    *(double *)&buf[4] = v52;
    _os_log_impl(&dword_224FE9000, v50, OS_LOG_TYPE_DEFAULT, "Max angular velocity: %f", buf, 0xCu);
  }
  v53 = *re::collisionLogObjects((re *)v51);
  if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
  {
    v54 = (*(float (**)(uint64_t))(*(_QWORD *)v2 + 448))(v2);
    *(_DWORD *)buf = 134217984;
    *(double *)&buf[4] = v54;
    v55 = "Max CCD advance coefficient: %f";
    v56 = v53;
    v57 = 12;
LABEL_46:
    _os_log_impl(&dword_224FE9000, v56, OS_LOG_TYPE_DEFAULT, v55, buf, v57);
  }
}

_QWORD *re::PhysXCollisionObject::internalLocalPose@<X0>(re::GeometricObject *a1@<X1>, uint64_t a2@<X8>)
{
  _QWORD *result;
  __int128 v7;
  _QWORD v8[3];

  result = (_QWORD *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)a1 + 8) + 24))(*((_QWORD *)a1 + 8));
  if ((_DWORD)result == 7 || (_DWORD)result == 1)
  {
    v7 = *((_OWORD *)a1 + 8);
    *(_OWORD *)a2 = *((_OWORD *)a1 + 7);
    *(_OWORD *)(a2 + 16) = v7;
  }
  else
  {
    (*(void (**)(_QWORD *__return_ptr))(**((_QWORD **)a1 + 7) + 160))(v8);
    return re::internal::nvphysx::fromPhysX((uint64_t)v8, (_QWORD *)a2);
  }
  return result;
}

uint64_t re::PhysXCollisionObject::isSleeping(re::PhysXCollisionObject *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 3);
  if (result)
  {
    if (*(_WORD *)(result + 8) == 5)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 512))(result);
    else
      return 1;
  }
  return result;
}

uint64_t re::PhysXCollisionObject::rayCastInternal(uint64_t a1, uint64_t a2, unsigned __int8 *a3, uint64_t a4, __n128 a5)
{
  uint64_t v8;
  _BYTE *v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t result;
  uint64_t v13;
  uint64_t v14;
  float v15;
  float v16;
  float v17;
  uint64_t (*v18)();
  unsigned int v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  __int128 v26;
  uint64_t *v27;
  __int16 v28;
  uint64_t v29;
  float v30[7];
  uint64_t v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  int *v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  _BYTE v43[32];
  uint64_t v44;
  int v45;
  __int128 v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;

  v8 = 0;
  v50 = *MEMORY[0x24BDAC8D0];
  a5.n128_u64[0] = 2139095039;
  do
  {
    v9 = &v43[v8];
    *(_QWORD *)v9 = 0;
    *((_QWORD *)v9 + 1) = 0;
    *((_DWORD *)v9 + 4) = -1;
    *((_WORD *)v9 + 10) = 0;
    *((_QWORD *)v9 + 4) = 0;
    *((_QWORD *)v9 + 5) = 0;
    *((_QWORD *)v9 + 3) = 0;
    *((_QWORD *)v9 + 6) = 2139095039;
    v8 += 64;
    *((_DWORD *)v9 + 14) = 0;
  }
  while (v8 != 2048);
  v10 = *a3;
  if (v10 >= 3)
    goto LABEL_18;
  v11 = *(_QWORD *)(a1 + 24);
  result = (*(uint64_t (**)(uint64_t, __n128))(*(_QWORD *)v11 + 184))(v11, a5);
  if ((_DWORD)result)
  {
    v13 = 0;
    v28 = (32 * v10) | 3;
    while (1)
    {
      v29 = 0;
      (*(void (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(*(_QWORD *)v11 + 192))(v11, &v29, 1, v13);
      v14 = v29;
      v15 = *(float *)(a2 + 32);
      (*(void (**)(int *__return_ptr, uint64_t))(*(_QWORD *)v29 + 80))(&v45, v29);
      v37 = &v45;
      (*(void (**)(int **__return_ptr, uint64_t))(*(_QWORD *)v11 + 152))(&v37, v11);
      (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(_QWORD *)v14 + 160))(&v31, v14);
      v16 = (float)(v39 * v39) + -0.5;
      v17 = (float)((float)((float)(v35 + v35) * *((float *)&v37 + 1)) + (float)(*(float *)&v37 * (float)(v34 + v34)))
          + (float)(v38 * (float)(v36 + v36));
      v30[0] = (float)((float)((float)(*(float *)&v37 * v33) + (float)(v39 * *(float *)&v31))
                     + (float)(*((float *)&v37 + 1) * v32))
             - (float)(*((float *)&v31 + 1) * v38);
      v30[1] = (float)((float)((float)(*((float *)&v37 + 1) * v33) + (float)(v39 * *((float *)&v31 + 1)))
                     + (float)(v38 * *(float *)&v31))
             - (float)(v32 * *(float *)&v37);
      v30[2] = (float)((float)((float)(v38 * v33) + (float)(v39 * v32)) + (float)(*(float *)&v37 * *((float *)&v31 + 1)))
             - (float)(*(float *)&v31 * *((float *)&v37 + 1));
      v30[3] = (float)((float)((float)(v39 * v33) - (float)(*(float *)&v37 * *(float *)&v31))
                     - (float)(*((float *)&v37 + 1) * *((float *)&v31 + 1)))
             - (float)(v38 * v32);
      v30[4] = v40
             + (float)((float)((float)(v39
                                     * (float)((float)(*((float *)&v37 + 1) * (float)(v36 + v36))
                                             - (float)(v38 * (float)(v35 + v35))))
                             + (float)((float)(v34 + v34) * v16))
                     + (float)(*(float *)&v37 * v17));
      v30[5] = v41
             + (float)((float)((float)(v39
                                     * (float)((float)(v38 * (float)(v34 + v34))
                                             - (float)(*(float *)&v37 * (float)(v36 + v36))))
                             + (float)((float)(v35 + v35) * v16))
                     + (float)(*((float *)&v37 + 1) * v17));
      v30[6] = v42
             + (float)((float)((float)(v39
                                     * (float)((float)(*(float *)&v37 * (float)(v35 + v35))
                                             - (float)(*((float *)&v37 + 1) * (float)(v34 + v34))))
                             + (float)((float)(v36 + v36) * v16))
                     + (float)(v38 * v17));
      v18 = gRaycastMap[v45];
      LOWORD(v37) = v28;
      v19 = ((uint64_t (*)(int *, float *, uint64_t, uint64_t, int **, uint64_t, _BYTE *, float))v18)(&v45, v30, a2, a2 + 16, &v37, 32, v43, v15);
      if (v19)
        break;
LABEL_15:
      v13 = (v13 + 1);
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v11 + 184))(v11);
      if (v13 >= result)
        return result;
    }
    v20 = v19;
    v21 = &v44;
    while (1)
    {
      v22 = re::BucketArray<re::CollisionCastHit,10ul>::addUninitialized(a4);
      *(_QWORD *)v22 = 0;
      *(_OWORD *)(v22 + 16) = 0u;
      *(_OWORD *)(v22 + 32) = 0u;
      *(_DWORD *)(v22 + 48) = 2139095039;
      *(_QWORD *)(v22 + 52) = 0xFFFFFFFF00000000;
      *(_QWORD *)(v22 + 64) = 0;
      v24 = *(_QWORD *)(a4 + 40);
      if (!v24)
        break;
      v25 = re::BucketArray<re::CollisionCastHit,10ul>::operator[](a4, v24 - 1);
      *(float *)(v25 + 48) = *((float *)v21 + 4) / *(float *)(a2 + 32);
      *(_QWORD *)&v26 = *(v21 - 1);
      DWORD2(v26) = *(_DWORD *)v21;
      *(_OWORD *)(v25 + 16) = v26;
      *(_QWORD *)&v26 = *(uint64_t *)((char *)v21 + 4);
      DWORD2(v26) = *((_DWORD *)v21 + 3);
      *(_OWORD *)(v25 + 32) = v26;
      *(_QWORD *)v25 = a1;
      *(_DWORD *)(v25 + 52) = v13;
      if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v29 + 64))(v29) == 5)
      {
        v46 = xmmword_2260EDC60;
        v47 = 0;
        v45 = 5;
        v48 = 1065353216;
        v49 = 0;
        (*(void (**)(uint64_t, int *))(*(_QWORD *)v29 + 128))(v29, &v45);
        if ((*(uint64_t (**)(uint64_t))(*(_QWORD *)v49 + 104))(v49))
          v27 = (uint64_t *)((*(uint64_t (**)(uint64_t))(*(_QWORD *)v49 + 104))(v49)
                          + 4 * *((unsigned int *)v21 - 4));
        else
          v27 = v21 - 2;
        *(_DWORD *)(v25 + 56) = *(_DWORD *)v27;
        *(_QWORD *)(v25 + 64) = *(uint64_t *)((char *)v21 + 20);
      }
      v21 += 8;
      if (!--v20)
        goto LABEL_15;
    }
    re::internal::assertLog((re::internal *)4, v23, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    _os_crash();
    __break(1u);
LABEL_18:
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Unsupported collision query type!", "!\"Unreachable code\"", "toPhysX", 89);
    _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::Event<re::GeometricObjectBase>::createSubscription<re::PhysXCollisionObject>(re::PhysXCollisionObject *,REEventHandlerResult (re::PhysXCollisionObject::*)(re::GeometricObjectBase*))::{lambda(re::GeometricObjectBase*,re::Event<re::GeometricObjectBase>::Subscription const&)#1}::__invoke(uint64_t a1, _QWORD *a2)
{
  uint64_t (*v3)(_QWORD *, uint64_t);
  uint64_t v4;
  _QWORD *v5;

  v3 = (uint64_t (*)(_QWORD *, uint64_t))a2[1];
  v4 = a2[2];
  v5 = (_QWORD *)(*a2 + (v4 >> 1));
  if ((v4 & 1) != 0)
    v3 = *(uint64_t (**)(_QWORD *, uint64_t))(*v5 + v3);
  return v3(v5, a1);
}

float re::PhysXSphereShape::radius(re::PhysXSphereShape *this)
{
  return *((float *)this + 6);
}

double re::PhysXSphereShape::aabb@<D0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X4>, uint64_t a4@<X5>, uint64_t a5@<X6>, uint64_t a6@<X7>, _OWORD *a7@<X8>, int8x16_t a8@<Q1>, double a9@<D2>, double a10@<D3>, double a11@<D4>, double a12@<D5>, double a13@<D6>, int32x4_t a14@<Q7>)
{
  float32x4_t v15;
  double result;
  __int128 v17;
  __int128 v18;
  uint64_t v19;
  int v20;
  _BYTE v21[20];
  int v22;

  v18 = *((_OWORD *)a2 + 1);
  v15.i64[1] = *((_QWORD *)&v18 + 1);
  v19 = *a2;
  v15.i32[1] = HIDWORD(v19);
  v20 = *((_DWORD *)a2 + 2);
  v15.i32[0] = 0;
  a8.i32[0] = 1.0;
  physx::Gu::computeBounds((float32x2_t *)v21, a1 + 20, (uint64_t)&v18, 0, v15, a8, a9, a10, a11, a12, a13, a14, a3, a4, a5, a6, v18);
  result = *(double *)v21;
  *(_QWORD *)&v17 = *(_QWORD *)&v21[12];
  DWORD2(v17) = v22;
  *a7 = *(_OWORD *)v21;
  a7[1] = v17;
  return result;
}

void re::PhysXSphereShape::~PhysXSphereShape(re::PhysXSphereShape *this)
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::SphereShape::type(re::SphereShape *this)
{
  return 2;
}

double re::PhysXBoxShape::extent(re::PhysXBoxShape *this, float32x4_t a2)
{
  a2.i64[0] = *((_QWORD *)this + 3);
  a2.i32[2] = *((_DWORD *)this + 8);
  a2.i64[0] = vaddq_f32(a2, a2).u64[0];
  return *(double *)a2.i64;
}

double re::PhysXBoxShape::aabb@<D0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X4>, uint64_t a4@<X5>, uint64_t a5@<X6>, uint64_t a6@<X7>, _OWORD *a7@<X8>, int8x16_t a8@<Q1>, double a9@<D2>, double a10@<D3>, double a11@<D4>, double a12@<D5>, double a13@<D6>, int32x4_t a14@<Q7>)
{
  float32x4_t v15;
  double result;
  __int128 v17;
  __int128 v18;
  uint64_t v19;
  int v20;
  _BYTE v21[20];
  int v22;

  v18 = *((_OWORD *)a2 + 1);
  v15.i64[1] = *((_QWORD *)&v18 + 1);
  v19 = *a2;
  v15.i32[1] = HIDWORD(v19);
  v20 = *((_DWORD *)a2 + 2);
  v15.i32[0] = 0;
  a8.i32[0] = 1.0;
  physx::Gu::computeBounds((float32x2_t *)v21, a1 + 20, (uint64_t)&v18, 0, v15, a8, a9, a10, a11, a12, a13, a14, a3, a4, a5, a6, v18);
  result = *(double *)v21;
  *(_QWORD *)&v17 = *(_QWORD *)&v21[12];
  DWORD2(v17) = v22;
  *a7 = *(_OWORD *)v21;
  a7[1] = v17;
  return result;
}

void re::PhysXBoxShape::~PhysXBoxShape(re::PhysXBoxShape *this)
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::PhysXSimulationEventCallback::onContact(uint64_t result, _QWORD *a2, uint64_t a3, unsigned int a4)
{
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t v20;
  unsigned __int8 *v21;
  int v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;
  _DWORD *v26;
  uint64_t v27;
  unsigned int v28;
  uint64_t v29;
  unsigned int v30;
  uint64_t v31;
  unsigned int v32;
  float32x2_t *v33;
  __int8 v34;
  int v35;
  int v36;
  unsigned int v37;
  unsigned int v38;
  int v39;
  int v40;
  unsigned int v41;
  uint64_t v42;
  _OWORD *v43;
  uint64_t v44;
  int *v45;
  __int16 v46;
  unsigned int v47;
  BOOL v48;
  BOOL v49;
  unsigned int v50;
  uint64_t v51;
  unsigned int v52;
  BOOL v53;
  _BOOL4 v54;
  uint64_t v55;
  uint64_t v56;
  float32x2_t v57;
  float v58;
  int v59;
  int v60;
  float32x2_t v61;
  float v62;
  float v63;
  float32x2_t *v64;

  if (!*(_BYTE *)(result + 24))
    return result;
  v7 = result;
  v8 = *(_QWORD *)(result + 8);
  v9 = *(_QWORD *)(v8 + 40);
  v10 = v9 + 1;
  if (v9 == -1)
  {
    v11 = 0;
    do
    {
      v13 = re::BucketArray<re::PhysXManifold,256ul>::operator[](v8, v11);
      v14 = *(_QWORD *)(v13 + 16);
      if (v14)
      {
        v12 = *(_QWORD *)(v13 + 48);
        if (v12)
          (*(void (**)(uint64_t))(*(_QWORD *)v14 + 40))(v14);
        *(_QWORD *)(v13 + 48) = 0;
        *(_QWORD *)(v13 + 24) = 0;
        *(_QWORD *)(v13 + 32) = 0;
        *(_QWORD *)(v13 + 16) = 0;
        ++*(_DWORD *)(v13 + 40);
      }
      ++v11;
    }
    while (v11 != *(_QWORD *)(v8 + 40));
    *(_QWORD *)(v8 + 40) = v10;
  }
  else
  {
    if (v10 <= *(_QWORD *)(v8 + 8) << 8)
    {
      *(_QWORD *)(v8 + 40) = v10;
    }
    else
    {
      re::BucketArray<re::PhysXManifold,256ul>::setBucketsCapacity(*(uint64_t **)(result + 8), (v9 + 256) >> 8);
      v9 = *(_QWORD *)(v8 + 40);
      *(_QWORD *)(v8 + 40) = v10;
      if (v9 == v10)
        goto LABEL_15;
    }
    do
    {
      v15 = re::BucketArray<re::PhysXManifold,256ul>::operator[](v8, v9);
      *(_QWORD *)(v15 + 48) = 0;
      *(_OWORD *)v15 = 0u;
      *(_OWORD *)(v15 + 16) = 0u;
      *(_OWORD *)(v15 + 28) = 0u;
      ++v9;
    }
    while (v9 != *(_QWORD *)(v8 + 40));
  }
LABEL_15:
  ++*(_DWORD *)(v8 + 48);
  v16 = *(_QWORD *)(v7 + 8);
  v17 = *(_QWORD *)(v16 + 40);
  if (!v17)
    goto LABEL_69;
  result = re::BucketArray<re::PhysXManifold,256ul>::operator[](v16, v17 - 1);
  v18 = result;
  *(_QWORD *)result = *(_QWORD *)(*a2 + 16);
  *(_QWORD *)(result + 8) = *(_QWORD *)(a2[1] + 16);
  v19 = 0;
  if (a4)
  {
    v20 = a4;
    v21 = (unsigned __int8 *)(a3 + 44);
    do
    {
      v22 = *v21;
      v21 += 64;
      v19 += v22;
      --v20;
    }
    while (v20);
  }
  v23 = v19;
  v24 = *(_QWORD *)(result + 32);
  if (v24 < v19)
  {
    if (*(_QWORD *)(result + 24) < (unint64_t)v19)
    {
      result = (uint64_t)re::DynamicArray<physx::PxContactPairPoint>::setCapacity((_QWORD *)(result + 16), v19);
      v24 = *(_QWORD *)(v18 + 32);
    }
    v25 = v23 - v24;
    if (v23 > v24)
    {
      v26 = (_DWORD *)(*(_QWORD *)(v18 + 48) + 48 * v24 + 44);
      do
      {
        *(v26 - 8) = 0;
        *(v26 - 4) = 0;
        *v26 = 0;
        v26 += 12;
        --v25;
      }
      while (v25);
    }
    goto LABEL_27;
  }
  if (v24 > v19)
  {
LABEL_27:
    *(_QWORD *)(v18 + 32) = v23;
    ++*(_DWORD *)(v18 + 40);
  }
  if (a4 && (_DWORD)v23)
  {
    v27 = 0;
    v28 = 0;
    v29 = a4;
    while (1)
    {
      v30 = v28;
      if (*(_QWORD *)(v18 + 32) <= (unint64_t)v28)
        break;
      v31 = a3 + (v27 << 6);
      v32 = *(unsigned __int8 *)(v31 + 44);
      if (*(_BYTE *)(v31 + 44))
      {
        v33 = *(float32x2_t **)(v31 + 16);
        if (v33)
        {
          v34 = v33[5].i8[3];
          v35 = v34;
          v36 = v34 & 1;
          if ((v34 & 2) != 0)
            v37 = 64;
          else
            v37 = 16;
          if (v35 < 0)
            v37 = 32;
        }
        else
        {
          v36 = 0;
          v37 = 0;
        }
        result = *(unsigned __int8 *)(v31 + 45);
        if (*(_BYTE *)(v31 + 45))
        {
          v38 = 0;
          v39 = 0;
          v40 = 0;
          v41 = 0;
          v42 = *(_QWORD *)(v18 + 48) + 48 * v30;
          v43 = *(_OWORD **)(v31 + 24);
          v44 = *(_QWORD *)(v31 + 32);
          v45 = (int *)(v44 + 4 * v32);
          v46 = *(_WORD *)(a3 + (v27 << 6) + 48);
          do
          {
            if (v40)
            {
              v47 = v33[5].u8[1];
              v48 = v47 >= v41;
              v50 = v47 - v41;
              v49 = v50 != 0 && v48;
              LODWORD(v51) = v50 * v37;
              if (v49)
                v51 = v51;
              else
                v51 = 0;
              v43 = (_OWORD *)((char *)v43 + v51);
              v33 += 6;
            }
            ++v40;
            v41 = v33[5].u8[1];
            v52 = v41;
            while (v52)
            {
              v53 = v39 == 0;
              v54 = v39 != 0;
              if (v53)
                v55 = 0;
              else
                v55 = v37;
              v43 = (_OWORD *)((char *)v43 + v55);
              v45 += v54;
              v56 = v42 + 48 * v38;
              *(_OWORD *)v56 = *v43;
              v57 = v33[2];
              *(float32x2_t *)(v56 + 16) = v57;
              v58 = v33[3].f32[0];
              *(float *)(v56 + 24) = v58;
              if ((v46 & 0x20) != 0)
              {
                if (v36)
                  v60 = *v45;
                else
                  v60 = -1;
                *(_DWORD *)(v42 + 48 * v38 + 28) = v60;
                v59 = -1;
              }
              else
              {
                v59 = -1;
                *(_DWORD *)(v42 + 48 * v38 + 28) = -1;
                if (v36)
                  v59 = *v45;
              }
              *(_DWORD *)(v42 + 48 * v38 + 44) = v59;
              if ((v46 & 0x10) != 0)
              {
                v63 = *(float *)(v44 + 4 * v38);
                v61 = vmul_n_f32(v57, v63);
                v62 = v58 * v63;
              }
              else
              {
                v61 = 0;
                v62 = 0.0;
              }
              v64 = (float32x2_t *)(v42 + 48 * v38);
              v64[4] = v61;
              v64[5].f32[0] = v62;
              ++v38;
              --v52;
              v39 = 1;
              if (v32 == v38)
                goto LABEL_66;
            }
          }
          while (v40 != (_DWORD)result);
        }
      }
LABEL_66:
      v28 = v30 + v32;
      if (++v27 == v29)
        return result;
    }
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_69:
    re::internal::assertLog((re::internal *)4, v12, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    _os_crash();
    __break(1u);
  }
  return result;
}

void re::PhysXSimulationEventCallback::onTrigger(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  __int128 v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  __int128 v37;
  uint64_t v38;

  if (*(_BYTE *)(a1 + 24))
  {
    v6 = *(_QWORD *)(a1 + 16);
    v7 = *(_DWORD *)(v6 + 28) + a3;
    if (*(_DWORD *)(v6 + 24) < v7)
      re::HashSetBase<re::TriggerPair,re::TriggerPair,re::internal::ValueAsKey<re::TriggerPair>,re::Hash<re::TriggerPair>,re::EqualTo<re::TriggerPair>,true,false>::setCapacity(v6, v7);
    if (a3)
    {
      v8 = 0;
      v9 = a3;
      do
      {
        v10 = a2 + 40 * v8;
        v11 = *(_QWORD *)(*(_QWORD *)(v10 + 24) + 16);
        v12 = *(_QWORD *)(*(_QWORD *)(v10 + 8) + 16);
        *(_QWORD *)&v37 = v11;
        *((_QWORD *)&v37 + 1) = v12;
        LOBYTE(v38) = 0;
        if ((*(_BYTE *)(v10 + 32) & 0x10) != 0)
        {
          v23 = *(_QWORD *)(a1 + 16);
          if ((*(_BYTE *)(a2 + 40 * v8 + 36) & 3) != 0)
          {
            re::HashSetBase<re::TriggerPair,re::TriggerPair,re::internal::ValueAsKey<re::TriggerPair>,re::Hash<re::TriggerPair>,re::EqualTo<re::TriggerPair>,true,false>::remove(v23, (uint64_t *)&v37);
          }
          else
          {
            v30 = *(unsigned int *)(v23 + 24);
            if ((_DWORD)v30)
            {
              v31 = *(unsigned int *)(*(_QWORD *)(v23 + 8)
                                    + 4 * ((((v11 << 6) - 0x61C8864680B583E9 + (v11 >> 2) + v12) ^ v11) % v30));
              if ((_DWORD)v31 != 0x7FFFFFFF)
              {
                v32 = *(_QWORD *)(v23 + 16);
                while (1)
                {
                  v33 = v32 + 40 * v31;
                  v36 = *(_QWORD *)(v33 + 16);
                  v34 = v33 + 16;
                  v35 = v36;
                  if (v36 == v11 && *(_QWORD *)(v34 + 8) == v12)
                    break;
                  if (v35 == v12 && *(_QWORD *)(v34 + 8) == v11)
                    break;
                  v31 = *(_DWORD *)(v32 + 40 * v31 + 8) & 0x7FFFFFFF;
                  if (v31 == 0x7FFFFFFF)
                    goto LABEL_25;
                }
                *(_BYTE *)(v32 + 40 * v31 + 32) = 2;
              }
            }
          }
          goto LABEL_25;
        }
        v13 = *(_QWORD *)(a1 + 16);
        v14 = ((v11 << 6) - 0x61C8864680B583E9 + (v11 >> 2) + v12) ^ v11;
        v15 = *(unsigned int *)(v13 + 24);
        if ((_DWORD)v15)
        {
          v16 = v14 % v15;
          v17 = *(unsigned int *)(*(_QWORD *)(v13 + 8) + 4 * (v14 % v15));
          if ((_DWORD)v17 != 0x7FFFFFFF)
          {
            v18 = *(_QWORD *)(v13 + 16);
            do
            {
              v19 = v18 + 40 * v17;
              v22 = *(_QWORD *)(v19 + 16);
              v20 = v19 + 16;
              v21 = v22;
              if (v22 == v11 && *(_QWORD *)(v20 + 8) == v12)
                goto LABEL_25;
              if (v21 == v12 && *(_QWORD *)(v20 + 8) == v11)
                goto LABEL_25;
              v17 = *(_DWORD *)(v18 + 40 * v17 + 8) & 0x7FFFFFFF;
            }
            while (v17 != 0x7FFFFFFF);
          }
        }
        else
        {
          v16 = 0;
        }
        v24 = *(unsigned int *)(v13 + 36);
        if ((_DWORD)v24 == 0x7FFFFFFF)
        {
          v24 = *(unsigned int *)(v13 + 32);
          v25 = v24;
          if ((_DWORD)v24 == (_DWORD)v15)
          {
            re::HashSetBase<re::TriggerPair,re::TriggerPair,re::internal::ValueAsKey<re::TriggerPair>,re::Hash<re::TriggerPair>,re::EqualTo<re::TriggerPair>,true,false>::setCapacity(*(_QWORD *)(a1 + 16), 2 * *(_DWORD *)(v13 + 28));
            v16 = v14 % *(unsigned int *)(v13 + 24);
            v25 = *(_DWORD *)(v13 + 32);
          }
          *(_DWORD *)(v13 + 32) = v25 + 1;
          v26 = *(_QWORD *)(v13 + 16);
          v27 = *(_DWORD *)(v26 + 40 * v24 + 8);
        }
        else
        {
          v26 = *(_QWORD *)(v13 + 16);
          v27 = *(_DWORD *)(v26 + 40 * v24 + 8);
          *(_DWORD *)(v13 + 36) = v27 & 0x7FFFFFFF;
        }
        *(_DWORD *)(v26 + 40 * v24 + 8) = v27 | 0x80000000;
        *(_DWORD *)(*(_QWORD *)(v13 + 16) + 40 * v24 + 8) = *(_DWORD *)(*(_QWORD *)(v13 + 16) + 40 * v24 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(v13 + 8) + 4 * v16);
        *(_QWORD *)(*(_QWORD *)(v13 + 16) + 40 * v24) = v14;
        v28 = *(_QWORD *)(v13 + 16) + 40 * v24;
        v29 = v37;
        *(_QWORD *)(v28 + 32) = v38;
        *(_OWORD *)(v28 + 16) = v29;
        *(_DWORD *)(*(_QWORD *)(v13 + 8) + 4 * v16) = v24;
        ++*(_DWORD *)(v13 + 28);
        ++*(_DWORD *)(v13 + 40);
LABEL_25:
        ++v8;
      }
      while (v8 != v9);
    }
  }
}

void re::HashSetBase<re::TriggerPair,re::TriggerPair,re::internal::ValueAsKey<re::TriggerPair>,re::Hash<re::TriggerPair>,re::EqualTo<re::TriggerPair>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  __int128 v7;
  unsigned int v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  int v12;
  uint64_t v13;
  __int128 *v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  __int128 v23;
  signed int v24;
  _BYTE v25[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v25, 0, 36);
      *(_QWORD *)&v25[36] = 0x7FFFFFFFLL;
      re::HashSetBase<re::TriggerPair,re::TriggerPair,re::internal::ValueAsKey<re::TriggerPair>,re::Hash<re::TriggerPair>,re::EqualTo<re::TriggerPair>,true,false>::init((uint64_t)v25, v4, a2);
      v5 = *(_OWORD *)a1;
      *(_QWORD *)a1 = *(_QWORD *)v25;
      v6 = *(_QWORD *)(a1 + 16);
      v7 = *(_OWORD *)&v25[8];
      *(_OWORD *)v25 = v5;
      *(_QWORD *)&v25[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      v9 = *(_OWORD *)&v25[24];
      *(_OWORD *)&v25[24] = *(_OWORD *)(a1 + 24);
      v8 = *(_DWORD *)&v25[32];
      *(_OWORD *)(a1 + 24) = v9;
      v10 = v8;
      if (v8)
      {
        v11 = 0;
        v12 = DWORD1(v9);
        v13 = v7;
        v14 = (__int128 *)(v6 + 16);
        do
        {
          if ((*((_DWORD *)v14 - 2) & 0x80000000) != 0)
          {
            v15 = *((_QWORD *)v14 - 2);
            v16 = *(unsigned int *)(a1 + 24);
            v17 = v15 % v16;
            v18 = *(unsigned int *)(a1 + 36);
            if ((_DWORD)v18 == 0x7FFFFFFF)
            {
              v18 = *(unsigned int *)(a1 + 32);
              v19 = v18;
              if ((_DWORD)v18 == (_DWORD)v16)
              {
                re::HashSetBase<re::TriggerPair,re::TriggerPair,re::internal::ValueAsKey<re::TriggerPair>,re::Hash<re::TriggerPair>,re::EqualTo<re::TriggerPair>,true,false>::setCapacity(a1, (2 * v12));
                v17 = v15 % *(unsigned int *)(a1 + 24);
                v19 = *(_DWORD *)(a1 + 32);
                v13 = *(_QWORD *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v19 + 1;
              v20 = *(_QWORD *)(a1 + 16);
              v21 = *(_DWORD *)(v20 + 40 * v18 + 8);
            }
            else
            {
              v20 = *(_QWORD *)(a1 + 16);
              v21 = *(_DWORD *)(v20 + 40 * v18 + 8);
              *(_DWORD *)(a1 + 36) = v21 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v20 + 40 * v18 + 8) = v21 | 0x80000000;
            *(_DWORD *)(*(_QWORD *)(a1 + 16) + 40 * v18 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 40 * v18 + 8) & 0x80000000 | *(_DWORD *)(v13 + 4 * v17);
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 40 * v18) = v15;
            v22 = *(_QWORD *)(a1 + 16) + 40 * v18;
            v23 = *v14;
            *(_QWORD *)(v22 + 32) = *((_QWORD *)v14 + 2);
            *(_OWORD *)(v22 + 16) = v23;
            v13 = *(_QWORD *)(a1 + 8);
            *(_DWORD *)(v13 + 4 * v17) = v18;
            v12 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v12;
          }
          ++v11;
          v14 = (__int128 *)((char *)v14 + 40);
        }
        while (v11 < v10);
      }
      re::HashTable<re::AssetType const*,std::pair<unsigned long,unsigned long>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::deinit((uint64_t *)v25);
    }
  }
  else
  {
    if (a2)
      v24 = a2;
    else
      v24 = 3;
  }
}

void re::PhysXSimulationEventCallback::~PhysXSimulationEventCallback(re::PhysXSimulationEventCallback *this)
{
  JUMPOUT(0x2276933B8);
}

_QWORD *re::DynamicArray<physx::PxContactPairPoint>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  _QWORD *v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;

  v2 = result[1];
  if (v2 != a2)
  {
    v4 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v4)
      {
        result = (_QWORD *)re::DynamicArray<physx::PxContactPairPoint>::setCapacity(v4, a2);
        ++*((_DWORD *)v4 + 6);
        return result;
      }
      if (a2)
      {
        result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 48 * a2, 4);
        if (!result)
        {
          re::internal::assertLog((re::internal *)6, v5, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, 48 * a2, *(_QWORD *)(*v4 + 8));
          result = (_QWORD *)_os_crash();
          __break(1u);
          return result;
        }
        v6 = result;
        if (!v4[1])
          goto LABEL_14;
      }
      else
      {
        v6 = 0;
        if (!v2)
        {
LABEL_14:
          v4[4] = v6;
          v4[1] = a2;
          return result;
        }
      }
      v7 = v4[4];
      v8 = v4[2];
      if (v8)
      {
        v9 = v7 + 48 * v8;
        v10 = v6;
        v11 = v4[4];
        do
        {
          *(_OWORD *)v10 = *(_OWORD *)v11;
          v10[2] = *(_QWORD *)(v11 + 16);
          *((_DWORD *)v10 + 6) = *(_DWORD *)(v11 + 24);
          *((_DWORD *)v10 + 7) = *(_DWORD *)(v11 + 28);
          v10[4] = *(_QWORD *)(v11 + 32);
          *((_DWORD *)v10 + 10) = *(_DWORD *)(v11 + 40);
          *((_DWORD *)v10 + 11) = *(_DWORD *)(v11 + 44);
          v11 += 48;
          v10 += 6;
        }
        while (v11 != v9);
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v4 + 40))(*v4, v7);
      goto LABEL_14;
    }
  }
  return result;
}

void re::HashSetBase<re::TriggerPair,re::TriggerPair,re::internal::ValueAsKey<re::TriggerPair>,re::Hash<re::TriggerPair>,re::EqualTo<re::TriggerPair>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 40 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &unk_2260EB7B0, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 600);
    _os_crash();
    __break(1u);
  }
}

uint64_t re::CollisionFactory::createGeometricObject(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4, uint64_t a5)
{
  uint64_t v9;
  __int128 v10;
  __int128 v11;

  v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 240, 16);
  *(_OWORD *)v9 = 0u;
  *(_OWORD *)(v9 + 16) = 0u;
  *(_OWORD *)(v9 + 48) = 0u;
  *(_OWORD *)(v9 + 64) = 0u;
  *(_OWORD *)(v9 + 80) = 0u;
  *(_OWORD *)(v9 + 112) = 0u;
  *(_OWORD *)(v9 + 160) = 0u;
  *(_OWORD *)(v9 + 176) = 0u;
  *(_OWORD *)(v9 + 192) = 0u;
  *(_OWORD *)(v9 + 224) = 0u;
  *(_OWORD *)(v9 + 144) = 0u;
  *(_QWORD *)(v9 + 32) = 0;
  *(_QWORD *)(v9 + 40) = 0x3F80000000000000;
  *(_QWORD *)v9 = &off_24ED40A60;
  *(_QWORD *)(v9 + 96) = 0;
  *(_QWORD *)(v9 + 104) = 0x3F80000000000000;
  *(_QWORD *)(v9 + 128) = 0;
  *(_QWORD *)(v9 + 136) = 0x3F80000000000000;
  *(_QWORD *)(v9 + 152) = 0;
  *(_QWORD *)(v9 + 160) = 0;
  *(_OWORD *)(v9 + 192) = 0u;
  *(_OWORD *)(v9 + 208) = 0u;
  *(_QWORD *)(v9 + 144) = 0;
  *(_DWORD *)(v9 + 168) = 0;
  *(_DWORD *)(v9 + 208) = 0;
  *(_OWORD *)(v9 + 176) = 0u;
  v10 = a4[1];
  *(_OWORD *)(v9 + 16) = *a4;
  *(_OWORD *)(v9 + 32) = v10;
  *(_QWORD *)(v9 + 64) = a3;
  v11 = a4[1];
  *(_OWORD *)(v9 + 112) = *a4;
  *(_OWORD *)(v9 + 128) = v11;
  *(_QWORD *)(v9 + 144) = a2;
  re::DynamicArray<re::Event<re::GeometricObjectBase>::Subscription>::setCapacity((_QWORD *)(v9 + 144), 0);
  ++*(_DWORD *)(v9 + 168);
  *(_QWORD *)(v9 + 232) = a5;
  return v9;
}

uint64_t re::CollisionFactory::deepCopyShape(re::CollisionFactory *this, re::Allocator *a2, const re::CollisionShape *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;
  float v11;
  float v12;
  uint64_t (*v13)(re::CollisionFactory *, re::Allocator *, float, float);
  uint64_t (*v14)(re::CollisionFactory *, re::Allocator *, const re::CollisionShape *);
  re::CollisionFactory *v15;
  re::Allocator *v16;
  const re::CollisionShape *v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  const re::CollisionShape **v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  _OWORD *v27;
  __int128 v28;
  __int128 v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  const char *v40;
  __int16 v41;
  int v42;
  __int16 v43;
  unint64_t v44;
  __int16 v45;
  unint64_t v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  uint64_t v52;

  v52 = *MEMORY[0x24BDAC8D0];
  v7 = 0;
  switch((*(unsigned int (**)(const re::CollisionShape *))(*(_QWORD *)a3 + 24))(a3))
  {
    case 0u:
      re::internal::assertLog((re::internal *)4, v6, "assertion failure: '%s' (%s:line %i) ", "!\"Unreachable code\"", "deepCopyShape", 45);
      _os_crash();
      __break(1u);
      JUMPOUT(0x22544BF80);
    case 1u:
      return (*(uint64_t (**)(re::CollisionFactory *, re::Allocator *))(*(_QWORD *)this + 96))(this, a2);
    case 2u:
      (*(void (**)(const re::CollisionShape *))(*(_QWORD *)a3 + 64))(a3);
      return (*(uint64_t (**)(re::CollisionFactory *, re::Allocator *))(*(_QWORD *)this + 112))(this, a2);
    case 3u:
      *(_QWORD *)&v47 = (*(uint64_t (**)(const re::CollisionShape *))(*(_QWORD *)a3 + 64))(a3);
      *((_QWORD *)&v47 + 1) = v9;
      return (*(uint64_t (**)(re::CollisionFactory *, re::Allocator *, __int128 *))(*(_QWORD *)this + 32))(this, a2, &v47);
    case 4u:
      v11 = (*(float (**)(const re::CollisionShape *))(*(_QWORD *)a3 + 64))(a3);
      (*(void (**)(const re::CollisionShape *))(*(_QWORD *)a3 + 72))(a3);
      v13 = *(uint64_t (**)(re::CollisionFactory *, re::Allocator *, float, float))(*(_QWORD *)this + 40);
      return v13(this, a2, v11, v12);
    case 5u:
      v14 = *(uint64_t (**)(re::CollisionFactory *, re::Allocator *, const re::CollisionShape *))(*(_QWORD *)this + 80);
      v15 = this;
      v16 = a2;
      v17 = a3;
      return v14(v15, v16, v17);
    case 6u:
      v18 = (*(uint64_t (**)(const re::CollisionShape *))(*(_QWORD *)a3 + 64))(a3);
      (*(void (**)(const re::CollisionShape *))(*(_QWORD *)a3 + 72))(a3);
      return (*(uint64_t (**)(re::CollisionFactory *, re::Allocator *, uint64_t))(*(_QWORD *)this + 104))(this, a2, v18);
    case 7u:
      v19 = *((_QWORD *)a3 + 4);
      v20 = *((_QWORD *)a3 + 5);
      v35 = 0;
      v36 = 0;
      v37 = 0;
      re::FixedArray<unsigned long>::init<>(&v35, (uint64_t)a2, v19);
      v32 = 0;
      v33 = 0;
      v34 = 0;
      re::FixedArray<re::Pose<float>>::init<>(&v32, (uint64_t)a2, v19);
      if (v19)
      {
        v21 = 0;
        v22 = 0;
        v23 = (const re::CollisionShape **)(v20 + 112);
        do
        {
          v24 = re::CollisionFactory::deepCopyShape(this, a2, *(v23 - 6));
          v25 = v36;
          if (v36 <= v22)
          {
            v38 = 0;
            v50 = 0u;
            v51 = 0u;
            v49 = 0u;
            v47 = 0u;
            v48 = 0u;
            os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
            v39 = 136315906;
            v40 = "operator[]";
            v41 = 1024;
            v42 = 468;
            v43 = 2048;
            v44 = v22;
            v45 = 2048;
            v46 = v25;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_30:
            v38 = 0;
            v50 = 0u;
            v51 = 0u;
            v49 = 0u;
            v47 = 0u;
            v48 = 0u;
            os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
            v39 = 136315906;
            v40 = "operator[]";
            v41 = 1024;
            v42 = 468;
            v43 = 2048;
            v44 = v22;
            v45 = 2048;
            v46 = v25;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
          }
          *(_QWORD *)(v37 + 8 * v22) = v24;
          v25 = v33;
          if (v33 <= v22)
            goto LABEL_30;
          v26 = v34;
          v27 = (_OWORD *)(v34 + v21);
          v28 = *(_OWORD *)v23;
          v29 = *((_OWORD *)v23 + 1);
          v23 += 30;
          *v27 = v28;
          v27[1] = v29;
          ++v22;
          v21 += 32;
        }
        while (v19 != v22);
      }
      else
      {
        v26 = v34;
      }
      v30 = v37;
      v31 = (*(uint64_t (**)(const re::CollisionShape *))(*(_QWORD *)a3 + 64))(a3);
      v7 = (*(uint64_t (**)(re::CollisionFactory *, re::Allocator *, uint64_t, uint64_t, unint64_t, uint64_t, re::Allocator *))(*(_QWORD *)this + 160))(this, a2, v30, v26, v19, v31, a2);
      if (v32 && v33)
        (*(void (**)(void))(*(_QWORD *)v32 + 40))();
      if (v35 && v36)
        (*(void (**)(void))(*(_QWORD *)v35 + 40))();
      return v7;
    case 8u:
      v11 = (*(float (**)(const re::CollisionShape *))(*(_QWORD *)a3 + 64))(a3);
      (*(void (**)(const re::CollisionShape *))(*(_QWORD *)a3 + 72))(a3);
      v13 = *(uint64_t (**)(re::CollisionFactory *, re::Allocator *, float, float))(*(_QWORD *)this + 128);
      return v13(this, a2, v11, v12);
    case 9u:
      v11 = (*(float (**)(const re::CollisionShape *))(*(_QWORD *)a3 + 64))(a3);
      (*(void (**)(const re::CollisionShape *))(*(_QWORD *)a3 + 72))(a3);
      v13 = *(uint64_t (**)(re::CollisionFactory *, re::Allocator *, float, float))(*(_QWORD *)this + 120);
      return v13(this, a2, v11, v12);
    case 0xBu:
      *(_QWORD *)&v47 = (*(uint64_t (**)(const re::CollisionShape *))(*(_QWORD *)a3 + 64))(a3);
      return (*(uint64_t (**)(re::CollisionFactory *, re::Allocator *, __int128 *))(*(_QWORD *)this + 136))(this, a2, &v47);
    case 0xCu:
      v17 = (const re::CollisionShape *)*((_QWORD *)a3 + 3);
      v14 = *(uint64_t (**)(re::CollisionFactory *, re::Allocator *, const re::CollisionShape *))(*(_QWORD *)this + 144);
      v15 = this;
      v16 = a2;
      return v14(v15, v16, v17);
    default:
      return v7;
  }
}

void re::PhysXTriangleMeshShape::aabb(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X4>, uint64_t a4@<X5>, uint64_t a5@<X6>, uint64_t a6@<X7>, int32x4_t *a7@<X8>, int8x16_t a8@<Q1>, double a9@<D2>, double a10@<D3>, double a11@<D4>, double a12@<D5>, double a13@<D6>, int32x4_t a14@<Q7>)
{
  float32x4_t v15;
  int32x4_t v16;
  int32x4_t v17;
  __int128 v18;
  uint64_t v19;
  int v20;
  _BYTE v21[20];
  __int32 v22;

  if (*(_QWORD *)(a1 + 72))
  {
    v18 = *((_OWORD *)a2 + 1);
    v15.i64[1] = *((_QWORD *)&v18 + 1);
    v19 = *a2;
    v15.i32[1] = HIDWORD(v19);
    v20 = *((_DWORD *)a2 + 2);
    v15.i32[0] = 0;
    a8.i32[0] = 1.0;
    physx::Gu::computeBounds((float32x2_t *)v21, a1 + 32, (uint64_t)&v18, 0, v15, a8, a9, a10, a11, a12, a13, a14, a3, a4, a5, a6, v18);
    v16 = *(int32x4_t *)v21;
    v17.i64[0] = *(_QWORD *)&v21[12];
    v17.i32[2] = v22;
  }
  else
  {
    v16 = vdupq_n_s32(0x7F800000u);
    v17.i64[0] = 0x7F0000007FLL;
    v17.i64[1] = 0x7F0000007FLL;
  }
  *a7 = v16;
  a7[1] = v17;
}

uint64_t re::PhysXTriangleMeshShape::vertices(re::PhysXTriangleMeshShape *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 9) + 56))(*((_QWORD *)this + 9));
}

uint64_t re::PhysXTriangleMeshShape::vertexStride(re::PhysXTriangleMeshShape *this)
{
  return 12;
}

uint64_t re::PhysXTriangleMeshShape::vertexCount(re::PhysXTriangleMeshShape *this)
{
  return (*(unsigned int (**)(_QWORD))(**((_QWORD **)this + 9) + 48))(*((_QWORD *)this + 9));
}

uint64_t re::PhysXTriangleMeshShape::indexFormat(re::PhysXTriangleMeshShape *this)
{
  uint64_t var1;

  (*(void (**)(uint64_t *__return_ptr))(**((_QWORD **)this + 9) + 96))(&var1);
  if ((var1 & 2) != 0)
    return 1;
  else
    return 2;
}

uint64_t re::PhysXTriangleMeshShape::indexCount(re::PhysXTriangleMeshShape *this)
{
  return 3 * (*(unsigned int (**)(_QWORD))(**((_QWORD **)this + 9) + 80))(*((_QWORD *)this + 9));
}

uint64_t re::PhysXTriangleMeshShape::indices(re::PhysXTriangleMeshShape *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 9) + 88))(*((_QWORD *)this + 9));
}

void re::PhysXTriangleMeshShape::~PhysXTriangleMeshShape(re::PhysXTriangleMeshShape *this)
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::CollisionObject::CollisionObject(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  _DWORD *v7;
  uint64_t v9;
  __int128 v10;
  uint64_t (*v11)(uint64_t, _QWORD *);
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)a1 = off_24ED41C50;
  *(_DWORD *)(a1 + 8) = a2;
  *(_QWORD *)(a1 + 16) = a4;
  *(_QWORD *)(a1 + 24) = a6;
  *(_OWORD *)(a1 + 32) = xmmword_226102DE0;
  *(_BYTE *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  *(_BYTE *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 88) = a3;
  *(_QWORD *)(a1 + 96) = a5;
  if ((a2 & 1) == 0)
  {
    v7 = (_DWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a4 + 48))(a4);
    v9 = a1;
    v10 = xmmword_226102DF0;
    v11 = re::Event<re::GeometricObjectBase>::createSubscription<re::CollisionObject>(re::CollisionObject *,REEventHandlerResult (re::CollisionObject::*)(re::GeometricObjectBase*))::{lambda(re::GeometricObjectBase*,re::Event<re::GeometricObjectBase>::Subscription const&)#1}::__invoke;
    re::Event<re::GeometricObjectBase>::addSubscription(v7, (uint64_t)&v9);
  }
  return a1;
}

void re::CollisionObject::~CollisionObject(re::CollisionObject *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  re::CollisionObject *v6;
  __int128 v7;
  uint64_t (*v8)(uint64_t, _QWORD *);
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)this = off_24ED41C50;
  if ((*((_BYTE *)this + 8) & 1) == 0)
  {
    v2 = *((_QWORD *)this + 2);
    v3 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
    v6 = this;
    v7 = xmmword_226102DF0;
    v8 = re::Event<re::GeometricObjectBase>::createSubscription<re::CollisionObject>(re::CollisionObject *,REEventHandlerResult (re::CollisionObject::*)(re::GeometricObjectBase*))::{lambda(re::GeometricObjectBase*,re::Event<re::GeometricObjectBase>::Subscription const&)#1}::__invoke;
    re::Event<re::GeometricObjectBase>::removeSubscription(v3, (__int128 *)&v6);
    v4 = *((_QWORD *)this + 12);
    (**(void (***)(uint64_t))v2)(v2);
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v4 + 40))(v4, v2);
  }
  if (*((_BYTE *)this + 64))
  {
    v5 = *((_QWORD *)this + 9);
    if (v5)
    {

      *((_QWORD *)this + 9) = 0;
    }
  }
}

uint64_t re::CollisionObject::setScale(uint64_t a1, float32x4_t *a2)
{
  float32x4_t v3;
  int8x16_t v4;
  int32x4_t v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t result;
  uint64_t v9;
  float v10;
  uint8_t buf[8];
  uint64_t v12;
  int8x16_t v13;

  v3 = *a2;
  v3.i32[3] = 0;
  v4 = (int8x16_t)vmaxnmq_f32(v3, (float32x4_t)xmmword_226102E00);
  v13 = v4;
  if ((*(_BYTE *)(a1 + 8) & 2) != 0)
  {
    v5.i32[1] = v4.i32[1];
    v5.i32[0] = vextq_s8(v4, v4, 8uLL).u32[0];
  }
  else
  {
    v5 = vdupq_lane_s32(*(int32x2_t *)v4.i8, 0);
    v13 = (int8x16_t)v5;
  }
  v6 = v5.i64[0];
  v10 = *(float *)v4.i32;
  if (*(float *)v4.i32 <= 0.00001 || *(float *)&v5.i32[1] <= 0.00001 || *(float *)v5.i32 <= 0.00001)
  {
    v7 = *re::collisionLogObjects((re *)a1);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_224FE9000, v7, OS_LOG_TYPE_DEFAULT, "Collider scale, 0 or negative is not supported. Setting scale to epsilon value.", buf, 2u);
    }
  }
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  *(_QWORD *)buf = result;
  v12 = v9;
  if (v10 != *(float *)&result
    && vabds_f32(*(float *)&result, v10) >= (float)((float)((float)(fabsf(v10) + fabsf(*(float *)&result)) + 1.0)
                                                  * 0.0001)
    || *((float *)&v6 + 1) != *((float *)&result + 1)
    && vabds_f32(*((float *)&result + 1), *((float *)&v6 + 1)) >= (float)((float)((float)(fabsf(*((float *)&v6 + 1))
                                                                                        + fabsf(*((float *)&result + 1)))
                                                                                + 1.0)
                                                                        * 0.0001)
    || *(float *)&v6 != *(float *)&v9
    && vabds_f32(*(float *)&v9, *(float *)&v6) >= (float)((float)((float)(fabsf(*(float *)&v6) + fabsf(*(float *)&v9))
                                                                + 1.0)
                                                        * 0.0001))
  {
    (*(void (**)(uint64_t, int8x16_t *))(*(_QWORD *)a1 + 72))(a1, &v13);
    return (*(uint64_t (**)(_QWORD, uint8_t *, int8x16_t *))(**(_QWORD **)(a1 + 16) + 32))(*(_QWORD *)(a1 + 16), buf, &v13);
  }
  return result;
}

unint64_t re::CollisionObject::rayCast(_QWORD *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t result;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  BOOL v13;

  result = re::BucketArray<re::CollisionCastHit,10ul>::clear(a4);
  v9 = *(_QWORD *)(a3 + 4);
  v10 = a1[4];
  v11 = v10 & HIDWORD(v9);
  v12 = v9 & HIDWORD(v10);
  if (v11)
    v13 = v12 == 0;
  else
    v13 = 1;
  if (!v13)
    return (*(uint64_t (**)(_QWORD *, uint64_t, uint64_t, unint64_t))(*a1 + 88))(a1, a2, a3, a4);
  return result;
}

id re::CollisionObject::weakPointer@<X0>(re::CollisionObject *this@<X0>, id *a2@<X8>)
{
  char *v4;
  uint64_t v5;
  void *v6;
  re::CollisionObject *v8;
  _anonymous_namespace_ *v9;
  unsigned __int8 v10[8];
  _anonymous_namespace_ *v11;

  v4 = (char *)this + 64;
  if (!*((_BYTE *)this + 64))
  {
    v8 = this;
    re::make::shared::object<re::CollisionObject::Shareable,re::CollisionObject*>((re *)&v8, &v9);
    v10[0] = 1;
    v11 = v9;
    v9 = 0;
    re::Optional<re::SharedPtr<re::CollisionObject::Shareable>>::operator=((uint64_t)v4, v10);
    if (v10[0] && v11)
    {

      v11 = 0;
    }
    if (v9)

  }
  v5 = *((_QWORD *)this + 9);
  if (v5)
    v6 = (void *)(v5 + 8);
  else
    v6 = 0;
  return objc_initWeak(a2, v6);
}

uint64_t re::Optional<re::SharedPtr<re::CollisionObject::Shareable>>::operator=(uint64_t a1, unsigned __int8 *a2)
{
  int v3;
  BOOL v4;
  BOOL v5;
  BOOL v6;
  uint64_t v7;
  uint64_t v8;

  v3 = *a2;
  if (*(_BYTE *)a1)
    v4 = 0;
  else
    v4 = v3 == 0;
  if (!v4)
  {
    if (*(_BYTE *)a1)
      v5 = v3 == 0;
    else
      v5 = 0;
    if (v5)
    {
      v8 = *(_QWORD *)(a1 + 8);
      if (v8)
      {

        *(_QWORD *)(a1 + 8) = 0;
      }
      *(_BYTE *)a1 = 0;
    }
    else
    {
      if (*(_BYTE *)a1)
        v6 = 1;
      else
        v6 = v3 == 0;
      if (v6)
      {
        v7 = *(_QWORD *)(a1 + 8);
        *(_QWORD *)(a1 + 8) = *((_QWORD *)a2 + 1);
        *((_QWORD *)a2 + 1) = v7;
      }
      else
      {
        *(_BYTE *)a1 = 1;
        *(_QWORD *)(a1 + 8) = *((_QWORD *)a2 + 1);
        *((_QWORD *)a2 + 1) = 0;
      }
    }
  }
  return a1;
}

uint64_t re::CollisionObject::setRawCollisionObject(uint64_t this, void *a2)
{
  *(_QWORD *)(this + 24) = a2;
  return this;
}

uint64_t re::Event<re::GeometricObjectBase>::createSubscription<re::CollisionObject>(re::CollisionObject *,REEventHandlerResult (re::CollisionObject::*)(re::GeometricObjectBase*))::{lambda(re::GeometricObjectBase*,re::Event<re::GeometricObjectBase>::Subscription const&)#1}::__invoke(uint64_t a1, _QWORD *a2)
{
  uint64_t (*v3)(_QWORD *, uint64_t);
  uint64_t v4;
  _QWORD *v5;

  v3 = (uint64_t (*)(_QWORD *, uint64_t))a2[1];
  v4 = a2[2];
  v5 = (_QWORD *)(*a2 + (v4 >> 1));
  if ((v4 & 1) != 0)
    v3 = *(uint64_t (**)(_QWORD *, uint64_t))(*v5 + v3);
  return v3(v5, a1);
}

void re::make::shared::object<re::CollisionObject::Shareable,re::CollisionObject*>(re *a1@<X0>, _anonymous_namespace_ **a2@<X8>)
{
  uint64_t *v4;
  _anonymous_namespace_ *v5;
  uint64_t v6;

  v4 = re::globalAllocators(a1);
  v5 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v4[2] + 32))(v4[2], 32, 8);
  v6 = *(_QWORD *)a1;
  ArcSharedObject::ArcSharedObject(v5, 0);
  *(_QWORD *)v5 = &off_24ED41CD0;
  *((_QWORD *)v5 + 3) = v6;
  *a2 = v5;
}

void re::CollisionObject::Shareable::~Shareable(re::CollisionObject::Shareable *this)
{
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

float re::SphereShape::massProperties(uint64_t a1, float *a2, _QWORD *a3, uint64_t a4)
{
  float v7;
  float v8;
  float v9;
  float result;

  v7 = (*(float (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
  v8 = v7 * v7;
  v9 = v7 * (float)((float)(v7 * v7) * 4.1888);
  *a2 = v9;
  *(_QWORD *)(a4 + 4) = 0;
  result = v8 * (float)(v9 * 0.4);
  *(_QWORD *)(a4 + 12) = 0;
  *(_QWORD *)(a4 + 24) = 0;
  *(_QWORD *)(a4 + 32) = 0;
  *(float *)a4 = result;
  *(float *)(a4 + 20) = result;
  *(float *)(a4 + 40) = result;
  *(_DWORD *)(a4 + 44) = 0;
  *a3 = 0;
  a3[1] = 0;
  return result;
}

void re::basicLocalWallTime(re *this@<X0>, re::DynamicString *a2@<X8>)
{
  id v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  id v11;
  _anonymous_namespace_ *v12;
  id v13;

  objc_msgSend(MEMORY[0x24BDBCE60], "date");
  v13 = (id)objc_claimAutoreleasedReturnValue();
  v5 = objc_alloc_init(MEMORY[0x24BDD1500]);
  objc_msgSend(MEMORY[0x24BDBCF38], "localTimeZone");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v5, "setTimeZone:", v6);

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", this);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v5, "setDateFormat:", v7);

  v8 = (void *)MEMORY[0x24BDD17C8];
  objc_msgSend(v5, "stringFromDate:", v13);
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v8, "stringWithFormat:", CFSTR("%@"), v9);
  v10 = (void *)objc_claimAutoreleasedReturnValue();

  v11 = objc_retainAutorelease(v10);
  v12 = (_anonymous_namespace_ *)objc_msgSend(v11, "UTF8String");

}

void re::WrappedError::make(re::WrappedError *this@<X0>, const __CFString *a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  id v6;

  objc_msgSend(MEMORY[0x24BDD1540], "errorWithDomain:code:userInfo:", this, a2, a3);
  v6 = (id)objc_claimAutoreleasedReturnValue();
  *a4 = v6;

}

{
  void *v8;
  void *v9;
  id v10;
  uint64_t v11;
  _QWORD v12[2];

  v12[1] = *MEMORY[0x24BDAC8D0];
  v11 = *MEMORY[0x24BDD0FC8];
  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithCString:encoding:", a3, 4);
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  v12[0] = v8;
  objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v12, &v11, 1);
  v9 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD1540], "errorWithDomain:code:userInfo:", this, a2, v9);
  v10 = (id)objc_claimAutoreleasedReturnValue();
  *a4 = v10;

}

void re::WrappedError::make(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, id *a4@<X3>, _QWORD *a5@<X8>)
{
  void *v9;
  void *v10;
  id v11;
  void *v12;
  id v13;
  _QWORD v14[2];
  void *v15;
  id v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v14[0] = *MEMORY[0x24BDD0FC8];
  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithCString:encoding:", a3, 4);
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  v14[1] = *MEMORY[0x24BDD1398];
  v15 = v9;
  v16 = *a4;
  v10 = (void *)MEMORY[0x24BDBCE70];
  v11 = v16;
  objc_msgSend(v10, "dictionaryWithObjects:forKeys:count:", &v15, v14, 2);
  v12 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD1540], "errorWithDomain:code:userInfo:", a1, a2, v12);
  v13 = (id)objc_claimAutoreleasedReturnValue();
  *a5 = v13;

}

uint64_t re::WrappedError::localizedDescription(id *this)
{
  id v1;
  uint64_t v2;

  objc_msgSend(*this, "localizedDescription");
  v1 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
  v2 = objc_msgSend(v1, "UTF8String");

  return v2;
}

CFErrorDomain re::WrappedError::domain(id *this)
{
  return CFErrorGetDomain((CFErrorRef)objc_retainAutorelease(*this));
}

void re::formattedErrorMessage<re::DetailedError>(uint64_t a1@<X0>, re::DynamicString *a2@<X8>)
{
  std::string *v4;
  uint64_t v5;
  std::string v6;

  std::error_code::message(&v6, (const std::error_code *)a1);
  if ((v6.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v4 = &v6;
  else
    v4 = (std::string *)v6.__r_.__value_.__r.__words[0];
  if ((*(_QWORD *)(a1 + 24) & 1) != 0)
    v5 = *(_QWORD *)(a1 + 32);
  else
    v5 = a1 + 25;
  re::DynamicString::format((re::DynamicString *)"%s. %s", a2, v4, v5);
  if (SHIBYTE(v6.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v6.__r_.__value_.__l.__data_);
}

void re::runInLocalAutoreleasePool(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  re::StackScratchAllocator *v4;

  v2 = (void *)MEMORY[0x227694090]();
  v3 = *(_QWORD *)(a1 + 24);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 48))(v3);
    objc_autoreleasePoolPop(v2);
  }
  else
  {
    v4 = (re::StackScratchAllocator *)std::__throw_bad_function_call[abi:nn180100]();
    re::StackScratchAllocator::FreePersistentBlocks(v4);
  }
}

void re::StackScratchAllocator::FreePersistentBlocks(re::StackScratchAllocator *this)
{
  re *v1;
  unint64_t i;
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  unint64_t v7;

  std::mutex::lock(&re::StackScratchAllocator::s_mutex);
  if (atomic_load(&re::StackScratchAllocator::s_rootsWithPersistentBlocksCount))
  {
    for (i = 0; i < v7; ++i)
    {
      v4 = re::StackScratchAllocator::s_rootsWithPersistentBlocks[i];
      v5 = *(_QWORD *)(v4 + 8);
      if (v5)
      {
        v6 = re::globalAllocators(v1);
        v1 = (re *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v6[2] + 40))(v6[2], v5);
        v4 = re::StackScratchAllocator::s_rootsWithPersistentBlocks[i];
      }
      *(_QWORD *)(v4 + 8) = 0;
      v7 = atomic_load(&re::StackScratchAllocator::s_rootsWithPersistentBlocksCount);
    }
  }
  atomic_store(0, &re::StackScratchAllocator::s_rootsWithPersistentBlocksCount);
  std::mutex::unlock(&re::StackScratchAllocator::s_mutex);
}

re::StackScratchAllocator *re::StackScratchAllocator::StackScratchAllocator(re::StackScratchAllocator *this)
{
  uint64_t (*v2)(_QWORD);
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  void *v7;
  uint64_t v8;

  *((_BYTE *)this + 16) = 0;
  *(_QWORD *)this = &off_24ED41D30;
  *((_QWORD *)this + 1) = "Thread-local Scratch Allocator";
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *((_DWORD *)this + 26) = 0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 52) = 0u;
  *(_QWORD *)((char *)this + 108) = 0x7FFFFFFFLL;
  {
    v7 = (void *)re::StackScratchAllocator::StackScratchAllocator(void)::root(&re::StackScratchAllocator::StackScratchAllocator(void)::root);
    _tlv_atexit((void (__cdecl *)(void *))re::StackScratchAllocator::Root::~Root, v7);
  }
  v3 = (uint64_t *)re::StackScratchAllocator::StackScratchAllocator(void)::root(&re::StackScratchAllocator::StackScratchAllocator(void)::root);
  v4 = *v3;
  if (*v3)
  {
    *((_QWORD *)this + 6) = v4;
    *(_OWORD *)((char *)this + 24) = *(_OWORD *)(v4 + 24);
    v5 = v3[1];
  }
  else
  {
    v5 = v3[1];
    if (!v5)
      goto LABEL_6;
    v8 = v5 + *(_QWORD *)(v5 + 8);
    *((_QWORD *)this + 3) = v5 + 16;
    *((_QWORD *)this + 4) = v8;
  }
  *((_QWORD *)this + 5) = v5;
LABEL_6:
  *v3 = (uint64_t)this;
  *((_QWORD *)this + 7) = v3;
  return this;
}

void re::StackScratchAllocator::Root::~Root(re::StackScratchAllocator::Root *this)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;

  v2 = *((_QWORD *)this + 1);
  if (v2)
  {
    v3 = re::globalAllocators(this);
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v3[2] + 40))(v3[2], v2);
    std::mutex::lock(&re::StackScratchAllocator::s_mutex);
    v5 = &re::StackScratchAllocator::s_rootsWithPersistentBlocksCount;
    if (atomic_load(&re::StackScratchAllocator::s_rootsWithPersistentBlocksCount))
    {
      v7 = 0;
      v8 = &re::StackScratchAllocator::s_rootsWithPersistentBlocks;
      while (*((re::StackScratchAllocator::Root **)&re::StackScratchAllocator::s_rootsWithPersistentBlocks + v7) != this)
      {
        ++v7;
        v9 = atomic_load(&re::StackScratchAllocator::s_rootsWithPersistentBlocksCount);
        if (v7 >= v9)
          goto LABEL_6;
      }
    }
    else
    {
LABEL_6:
      re::internal::assertLog((re::internal *)4, v4, "assertion failure: '%s' (%s:line %i) Can't find allocated block", "!\"Unreachable code\"", "~Root", 190);
      _os_crash();
      __break(1u);
    }
    do
      v10 = __ldaxr(v5);
    while (__stlxr(v10 - 1, v5));
    v11 = atomic_load(v5);
    v12 = v8[v7];
    v8[v7] = v8[v11];
    v8[v11] = v12;
    std::mutex::unlock(&re::StackScratchAllocator::s_mutex);
  }
}

void re::StackScratchAllocator::~StackScratchAllocator(re::StackScratchAllocator *this)
{
  re::StackScratchAllocator *v1;
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *i;
  uint64_t *v6;

  v1 = this;
  *(_QWORD *)this = &off_24ED41D30;
  v2 = (_QWORD *)*((_QWORD *)this + 7);
  v3 = v2 + 1;
  v4 = (_QWORD *)v2[1];
  for (i = (_QWORD *)*((_QWORD *)this + 5); v4 != i && *v4; i = (_QWORD *)*((_QWORD *)v1 + 5))
  {
    *v3 = *v4;
    v6 = re::globalAllocators(this);
    this = (re::StackScratchAllocator *)(*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v6[2] + 40))(v6[2], v4);
    v2 = (_QWORD *)*((_QWORD *)v1 + 7);
    v3 = v2 + 1;
    v4 = (_QWORD *)v2[1];
  }
  *v2 = *((_QWORD *)v1 + 6);
  re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::deinit((uint64_t *)v1 + 9);
  re::Allocator::~Allocator(v1);
}

{
  re::StackScratchAllocator::~StackScratchAllocator(this);
  JUMPOUT(0x2276933B8);
}

re::StackScratchAllocator **re::StackScratchAllocator::alloc(re::StackScratchAllocator ***this, uint64_t a2, unint64_t a3)
{
  re::StackScratchAllocator ***v3;
  uint64_t v4;
  unint64_t v5;
  re::StackScratchAllocator **result;

  if (*this[7] != (re::StackScratchAllocator *)this)
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Attempting to allocate from a StackScratchAlloc object that is not top of stack", "m_root->m_top == this", "alloc", 90);
    _os_crash();
    __break(1u);
LABEL_7:
    re::StackScratchAllocator::growAndAlign((re::StackScratchAllocator *)v3, v4, a3);
    result = v3[3];
    goto LABEL_5;
  }
  v4 = a2;
  v3 = this;
  if (a3 <= 1)
    a3 = 1;
  v5 = (unint64_t)this[4];
  result = (re::StackScratchAllocator **)(((unint64_t)this[3] + a3 - 1) & -(uint64_t)a3);
  v3[3] = result;
  if ((unint64_t)result + a2 > v5)
    goto LABEL_7;
LABEL_5:
  v3[3] = (re::StackScratchAllocator **)((char *)result + v4);
  return result;
}

void re::StackScratchAllocator::growAndAlign(re::StackScratchAllocator *this, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;

  if ((unint64_t)(a3 + a2) <= 0x80000)
    v5 = 0x100000;
  else
    v5 = a3 + a2 + 0x100000;
  v6 = re::globalAllocators(this);
  v7 = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v6[2] + 32))(v6[2], v5, 0);
  v8 = *((_QWORD *)this + 7);
  *v7 = *(_QWORD *)(v8 + 8);
  v7[1] = v5;
  if (*((_QWORD *)this + 3))
    goto LABEL_9;
  std::mutex::lock(&re::StackScratchAllocator::s_mutex);
  do
    v10 = __ldaxr(&re::StackScratchAllocator::s_rootsWithPersistentBlocksCount);
  while (__stlxr(v10 + 1, &re::StackScratchAllocator::s_rootsWithPersistentBlocksCount));
  if (v10 < 0x100)
  {
    re::StackScratchAllocator::s_rootsWithPersistentBlocks[v10] = *((_QWORD *)this + 7);
    std::mutex::unlock(&re::StackScratchAllocator::s_mutex);
    v8 = *((_QWORD *)this + 7);
LABEL_9:
    *(_QWORD *)(v8 + 8) = v7;
    *((_QWORD *)this + 3) = ((unint64_t)v7 + a3 + 15) & -a3;
    *((_QWORD *)this + 4) = (char *)v7 + v5;
    return;
  }
  re::internal::assertLog((re::internal *)4, v9, "assertion failure: '%s' (%s:line %i) ", "index < MAX_THREADS", "growAndAlign", 158);
  _os_crash();
  __break(1u);
}

uint64_t re::StackScratchAllocator::free(uint64_t this, uint64_t a2)
{
  if (**(_QWORD **)(this + 56) != this)
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Attempting to free from a StackScratchAlloc object that is not top of stack", "m_root->m_top == this", "free", 121);
    this = _os_crash();
    __break(1u);
  }
  return this;
}

uint64_t re::StackScratchAllocator::statistics(re::StackScratchAllocator *this)
{
  return 0;
}

uint64_t re::Allocator::addDestructor(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t re::Allocator::destructorCalledByDefault(re::Allocator *this)
{
  return 1;
}

uint64_t re::StackScratchAllocator::parent(re::StackScratchAllocator *this)
{
  return 0;
}

void re::Data::makeDataWithBytes(re::Data *this@<X0>, const void *a2@<X1>, _QWORD *a3@<X8>)
{
  id v4;

  objc_msgSend(MEMORY[0x24BDBCE50], "dataWithBytes:length:", this, a2);
  v4 = (id)objc_claimAutoreleasedReturnValue();
  *a3 = v4;

}

void re::Data::makeDataWithBytesNoCopy(re::Data *this@<X0>, const void *a2@<X1>, _QWORD *a3@<X8>)
{
  id v4;

  objc_msgSend(MEMORY[0x24BDBCE50], "dataWithBytesNoCopy:length:freeWhenDone:", this, a2, 0);
  v4 = (id)objc_claimAutoreleasedReturnValue();
  *a3 = v4;

}

void re::Data::makeDataWithContentsOfFile(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  _BOOL8 v4;
  void *v5;
  void *v6;
  void *v7;
  id v8;
  void *v9;
  id v10;
  id v11;

  v4 = a2 == 1;
  v5 = (void *)MEMORY[0x24BDBCE50];
  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", a1);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v11 = 0;
  objc_msgSend(v5, "dataWithContentsOfFile:options:error:", v6, v4, &v11);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  v8 = v11;

  if (v7)
    v9 = v7;
  else
    v9 = v8;
  v10 = v9;
  *(_BYTE *)a3 = v7 != 0;
  *(_QWORD *)(a3 + 8) = v10;

}

uint64_t *re::globalAllocators(re *this)
{
  unsigned __int8 v1;
  _anonymous_namespace_ *v3;

  if ((v1 & 1) == 0)
  {
    if ((_DWORD)v3)
    {
      re::globalAllocators(void)::s_instance = (uint64_t)&off_24ED41DD0;
      byte_255828338 = 0;
      unk_255828348 = 0u;
      unk_255828358 = 0u;
      re::GlobalAllocators::init((_anonymous_namespace_ *)&re::globalAllocators(void)::s_instance);
    }
  }
  return &re::globalAllocators(void)::s_instance;
}

void `anonymous namespace'::internalSystemAllocator(_anonymous_namespace_ *this)
{
  unsigned __int8 v1;

  if ((v1 & 1) == 0)
  {
    {
      byte_2558283B8 = 0;
      unk_2558283B0 = "System allocator";
    }
  }
}

_anonymous_namespace_ *re::initGlobalAllocators(re *this)
{
  _anonymous_namespace_ *result;

  result = (_anonymous_namespace_ *)re::globalAllocators(this);
  if (!byte_255828338)
  {
    re::globalAllocators(result);
    return re::GlobalAllocators::init((_anonymous_namespace_ *)&re::globalAllocators(void)::s_instance);
  }
  return result;
}

_anonymous_namespace_ *re::GlobalAllocators::init(_anonymous_namespace_ *this)
{
  _anonymous_namespace_ *v1;
  uint64_t v2;
  re::Allocator *v3;
  uint64_t v4;
  re::Allocator *v5;
  uint64_t v6;
  re::Allocator *v7;
  uint64_t v8;

  if (!*((_BYTE *)this + 8))
  {
    v1 = this;
    re::globalMemoryTracker(this);
    if (!re::globalMemoryTracker(void)::s_instance)
    {
      qword_255828378[0] = *((_QWORD *)v1 + 2);
      re::DynamicArray<re::Allocator const*>::setCapacity(qword_255828378, 0x400uLL);
      ++dword_255828390;
      re::globalMemoryTracker(void)::s_instance = 1;
    }
    re::MemoryTracker::track((os_unfair_lock_s *)&re::globalMemoryTracker(void)::s_instance, *((const re::Allocator **)v1 + 2));
    v2 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**((_QWORD **)v1 + 2) + 32))(*((_QWORD *)v1 + 2), 104, 8);
    v3 = re::Allocator::Allocator((re::Allocator *)v2, "SIMD-aligned allocator", 1);
    *((_QWORD *)v3 + 8) = 0;
    *((_QWORD *)v3 + 9) = 0;
    *(_OWORD *)((char *)v3 + 20) = 0u;
    *(_OWORD *)((char *)v3 + 36) = 0u;
    *(_QWORD *)((char *)v3 + 52) = 0;
    *(_QWORD *)v3 = &off_24ED42238;
    *((_QWORD *)v3 + 10) = 0;
    *((_QWORD *)v3 + 11) = 0;
    re::BaseAllocator::init(v3);
    *(_DWORD *)(v2 + 20) |= 1u;
    *(_QWORD *)(v2 + 80) = 16;
    *((_QWORD *)v1 + 3) = v2;
    v4 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**((_QWORD **)v1 + 2) + 32))(*((_QWORD *)v1 + 2), 104, 8);
    v5 = re::Allocator::Allocator((re::Allocator *)v4, "Cache-aligned allocator", 1);
    *((_QWORD *)v5 + 8) = 0;
    *((_QWORD *)v5 + 9) = 0;
    *(_OWORD *)((char *)v5 + 20) = 0u;
    *(_OWORD *)((char *)v5 + 36) = 0u;
    *(_QWORD *)((char *)v5 + 52) = 0;
    *(_QWORD *)v5 = &off_24ED42238;
    *((_QWORD *)v5 + 10) = 0;
    *((_QWORD *)v5 + 11) = 0;
    re::BaseAllocator::init(v5);
    *(_DWORD *)(v4 + 20) |= 1u;
    *(_QWORD *)(v4 + 80) = 64;
    *((_QWORD *)v1 + 4) = v4;
    v6 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**((_QWORD **)v1 + 2) + 32))(*((_QWORD *)v1 + 2), 104, 8);
    v7 = re::Allocator::Allocator((re::Allocator *)v6, "TLB-aligned allocator", 1);
    *((_QWORD *)v7 + 8) = 0;
    *((_QWORD *)v7 + 9) = 0;
    *(_OWORD *)((char *)v7 + 20) = 0u;
    *(_OWORD *)((char *)v7 + 36) = 0u;
    *(_QWORD *)((char *)v7 + 52) = 0;
    *(_QWORD *)v7 = &off_24ED42238;
    *((_QWORD *)v7 + 10) = 0;
    *((_QWORD *)v7 + 11) = 0;
    re::BaseAllocator::init(v7);
    *(_DWORD *)(v6 + 20) |= 1u;
    *(_QWORD *)(v6 + 80) = 0x4000;
    *((_QWORD *)v1 + 5) = v6;
    v8 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**((_QWORD **)v1 + 2) + 32))(*((_QWORD *)v1 + 2), 5304, 8);
    *(_BYTE *)v8 = 0;
    *(_QWORD *)(v8 + 88) = 0;
    *(_QWORD *)(v8 + 96) = 0;
    *(_DWORD *)(v8 + 104) = 0;
    *(_OWORD *)(v8 + 8) = 0u;
    *(_OWORD *)(v8 + 24) = 0u;
    *(_OWORD *)(v8 + 40) = 0u;
    *(_OWORD *)(v8 + 56) = 0u;
    *(_OWORD *)(v8 + 68) = 0u;
    *(_QWORD *)(v8 + 108) = 0x1FFFFFFFFLL;
    *(_DWORD *)(v8 + 120) = 0;
    *(_QWORD *)(v8 + 136) = 0;
    *(_QWORD *)(v8 + 144) = 0;
    *(_QWORD *)(v8 + 128) = 0;
    *(_DWORD *)(v8 + 152) = 0;
    bzero((void *)(v8 + 160), 0x1418uLL);
    *((_QWORD *)v1 + 6) = v8;
    this = re::PerFrameAllocatorManager::init((_anonymous_namespace_ *)v8);
    *((_BYTE *)v1 + 8) = 1;
  }
  return this;
}

void re::deinitGlobalAllocators(re *this)
{
  uint64_t *v1;

  v1 = re::globalAllocators(this);
  if (byte_255828338)
  {
    re::globalAllocators((re *)v1);
    re::GlobalAllocators::deinit((re **)&re::globalAllocators(void)::s_instance);
  }
}

void re::GlobalAllocators::deinit(re **this)
{
  re *v2;
  const re::Allocator *v3;
  re *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  re *v16;
  re *v17;
  re *v18;
  _anonymous_namespace_ *v19;

  if (*((_BYTE *)this + 8))
  {
    re::StackScratchAllocator::FreePersistentBlocks((re::StackScratchAllocator *)this);
    re::globalMemoryTracker(v2);
    re::PerFrameAllocatorManager::deinit(this[6]);
    v3 = this[2];
    v4 = this[6];
    if (v4)
    {
      v5 = 5120;
      do
      {
        *(_QWORD *)((char *)v4 + v5 + 128) = 0;
        v5 -= 40;
      }
      while (v5);
      v6 = *((_QWORD *)v4 + 16);
      if (v6)
      {
        v7 = *((_QWORD *)v4 + 20);
        if (v7)
        {
          v8 = *((_QWORD *)v4 + 18);
          if (v8)
          {
            v9 = 88 * v8;
            v10 = v7 + 40;
            do
            {
              v11 = *(_QWORD *)(v10 + 8);
              if (v11)
              {
                if (*(_QWORD *)(v10 + 40))
                  (*(void (**)(uint64_t))(*(_QWORD *)v11 + 40))(v11);
                *(_QWORD *)(v10 + 40) = 0;
                *(_QWORD *)(v10 + 16) = 0;
                *(_QWORD *)(v10 + 24) = 0;
                *(_QWORD *)(v10 + 8) = 0;
                ++*(_DWORD *)(v10 + 32);
              }
              v12 = *(_QWORD *)(v10 - 32);
              if (v12)
              {
                if (*(_QWORD *)v10)
                  (*(void (**)(uint64_t))(*(_QWORD *)v12 + 40))(v12);
                *(_QWORD *)v10 = 0;
                *(_QWORD *)(v10 - 24) = 0;
                *(_QWORD *)(v10 - 16) = 0;
                *(_QWORD *)(v10 - 32) = 0;
                ++*(_DWORD *)(v10 - 8);
              }
              v10 += 88;
              v9 -= 88;
            }
            while (v9);
            v6 = *((_QWORD *)v4 + 16);
            v7 = *((_QWORD *)v4 + 20);
          }
          (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v6 + 40))(v6, v7);
        }
        *((_QWORD *)v4 + 20) = 0;
        *((_QWORD *)v4 + 17) = 0;
        *((_QWORD *)v4 + 18) = 0;
        *((_QWORD *)v4 + 16) = 0;
        ++*((_DWORD *)v4 + 38);
      }
      re::DataArray<re::PerFrameAllocatorImpl>::deinit((uint64_t)v4 + 56);
      v13 = *((_QWORD *)v4 + 7);
      if (v13)
      {
        if (*((_QWORD *)v4 + 11))
          (*(void (**)(uint64_t))(*(_QWORD *)v13 + 40))(v13);
        *((_QWORD *)v4 + 11) = 0;
        *((_QWORD *)v4 + 8) = 0;
        *((_QWORD *)v4 + 9) = 0;
        *((_QWORD *)v4 + 7) = 0;
        ++*((_DWORD *)v4 + 20);
      }
      v14 = *((_QWORD *)v4 + 4);
      if (v14)
      {
        if (*((_QWORD *)v4 + 5))
        {
          (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v14 + 40))(v14, *((_QWORD *)v4 + 6));
          *((_QWORD *)v4 + 5) = 0;
          *((_QWORD *)v4 + 6) = 0;
        }
        *((_QWORD *)v4 + 4) = 0;
      }
      v15 = *((_QWORD *)v4 + 1);
      if (v15)
      {
        if (*((_QWORD *)v4 + 2))
        {
          (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v15 + 40))(v15, *((_QWORD *)v4 + 3));
          *((_QWORD *)v4 + 2) = 0;
          *((_QWORD *)v4 + 3) = 0;
        }
        *((_QWORD *)v4 + 1) = 0;
      }
      (*(void (**)(const re::Allocator *, re *))(*(_QWORD *)v3 + 40))(v3, v4);
      v3 = this[2];
    }
    this[6] = 0;
    v16 = this[5];
    if (v16)
    {
      (**(void (***)(re *))v16)(this[5]);
      (*(void (**)(const re::Allocator *, re *))(*(_QWORD *)v3 + 40))(v3, v16);
      v3 = this[2];
    }
    this[5] = 0;
    v17 = this[4];
    if (v17)
    {
      (**(void (***)(re *))v17)(this[4]);
      (*(void (**)(const re::Allocator *, re *))(*(_QWORD *)v3 + 40))(v3, v17);
      v3 = this[2];
    }
    this[4] = 0;
    v18 = this[3];
    if (v18)
    {
      (**(void (***)(re *))v18)(this[3]);
      (*(void (**)(const re::Allocator *, re *))(*(_QWORD *)v3 + 40))(v3, v18);
      v3 = this[2];
    }
    this[3] = 0;
    re::MemoryTracker::untrack((os_unfair_lock_s *)&re::globalMemoryTracker(void)::s_instance, v3);
    v19 = (_anonymous_namespace_ *)re::MemoryTracker::deinit(&re::globalMemoryTracker(void)::s_instance);
    *((_BYTE *)this + 8) = 0;
  }
}

void re::GlobalAllocators::~GlobalAllocators(re **this)
{
  *this = (re *)&off_24ED41DD0;
  re::GlobalAllocators::deinit(this);
}

{
  *this = (re *)&off_24ED41DD0;
  re::GlobalAllocators::deinit(this);
  JUMPOUT(0x2276933B8);
}

char *re::globalMemoryTracker(re *this)
{
  unsigned __int8 v1;
  _anonymous_namespace_ *v3;

  if ((v1 & 1) == 0)
  {
    if ((_DWORD)v3)
    {
      re::globalMemoryTracker(void)::s_instance = 0;
      qword_255828398 = 0;
      *(_OWORD *)&algn_255828371[3] = 0u;
      unk_255828384 = 0u;
      re::DynamicArray<re::Allocator const*>::setCapacity(qword_255828378, 0x400uLL);
      ++dword_255828390;
      re::globalMemoryTracker(void)::s_instance = 1;
    }
  }
  return &re::globalMemoryTracker(void)::s_instance;
}

uint64_t re::DataArray<re::PerFrameAllocatorImpl>::deinit(uint64_t result)
{
  uint64_t *v1;
  double v2;
  _QWORD *v3;

  if (*(_DWORD *)(result + 44))
  {
    v1 = (uint64_t *)result;
    v2 = re::DataArray<re::PerFrameAllocatorImpl>::clear((_QWORD *)result);
    if (!v1[2])
    {
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    v3 = (_QWORD *)v1[4];
    (*(void (**)(uint64_t, _QWORD, double))(*(_QWORD *)*v1 + 40))(*v1, *v3, v2);
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)*v1 + 40))(*v1, v3[1]);
    result = *v1;
    if (*v1)
    {
      if (v1[4])
        result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
      v1[4] = 0;
      v1[1] = 0;
      v1[2] = 0;
      *v1 = 0;
      ++*((_DWORD *)v1 + 6);
    }
    *((_DWORD *)v1 + 11) = 0;
  }
  return result;
}

double re::DataArray<re::PerFrameAllocatorImpl>::clear(_QWORD *a1)
{
  unint64_t v4;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  double result;
  _OWORD v12[5];
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::DataArrayIterator((uint64_t)v12, (uint64_t)a1, 0);
  if (*(_QWORD **)&v12[0] != a1 || WORD4(v12[0]) != 0xFFFFLL || (DWORD2(v12[0]) & 0xFFFF0000) != 4294901760)
  {
    do
    {
      v4 = re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::handle((unsigned __int16 *)v12);
      re::DataArray<re::PerFrameAllocatorImpl>::destroy((uint64_t)a1, v4);
      re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::increment(v12);
    }
    while (*(_QWORD **)&v12[0] != a1 || WORD4(v12[0]) != 0xFFFF || WORD5(v12[0]) != 0xFFFF);
  }
  v7 = a1[2];
  v8 = v7 - 1;
  if (v7 != 1)
  {
    v9 = 16 * v7;
    do
    {
      if (a1[2] <= v8)
      {
        memset(v12, 0, sizeof(v12));
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      v10 = a1[4] + v9;
      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*a1 + 40))(*a1, *(_QWORD *)(v10 - 16));
      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*a1 + 40))(*a1, *(_QWORD *)(v10 - 8));
      re::DynamicArray<re::DataArray<re::RigGraphOperatorDefinition>::ElementBlock>::removeAt((uint64_t)a1, v8);
      v9 -= 16;
      --v8;
    }
    while (v8);
  }
  result = NAN;
  a1[6] = 0xFFFFFFFF00000000;
  return result;
}

uint64_t (***re::DataArray<re::PerFrameAllocatorImpl>::destroy(uint64_t a1, unint64_t a2))(_QWORD)
{
  int v2;
  unint64_t v4;
  uint64_t (***result)(_QWORD);
  _DWORD *v6;

  v2 = a2;
  v4 = a2 >> 16;
  result = (uint64_t (***)(_QWORD))re::DataArray<re::PerFrameAllocatorImpl>::tryGet(a1, a2 & 0xFFFFFFFF00000000 | ((unint64_t)WORD1(a2) << 16) | (unsigned __int16)a2);
  if (result)
  {
    v6 = result;
    result = (uint64_t (***)(_QWORD))(**result)(result);
    if (*(_QWORD *)(a1 + 16) <= (unint64_t)HIWORD(v2))
    {
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 16 * HIWORD(v2) + 8) + 4 * (unsigned __int16)v2) = 0;
    *v6 = *(_DWORD *)(a1 + 52);
    *(_WORD *)(a1 + 52) = v2;
    *(_WORD *)(a1 + 54) = v4;
    --*(_DWORD *)(a1 + 40);
  }
  return result;
}

uint64_t re::DataArray<re::PerFrameAllocatorImpl>::tryGet(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unsigned int v3;
  uint64_t v4;
  int v5;
  BOOL v6;

  v2 = *(_QWORD *)(a1 + 16);
  if (WORD1(a2) < v2
    && ((unsigned __int16)(v2 - 1) != WORD1(a2) ? (v3 = *(_DWORD *)(a1 + 44)) : (v3 = *(_DWORD *)(a1 + 48)),
        (unsigned __int16)a2 < v3
     && ((v4 = *(_QWORD *)(a1 + 32),
          (v5 = *(_DWORD *)(*(_QWORD *)(v4 + 16 * WORD1(a2) + 8) + 4 * (unsigned __int16)a2)) != 0)
       ? (v6 = v5 == (HIDWORD(a2) & 0xFFFFFF))
       : (v6 = 0),
         v6)))
  {
    return *(_QWORD *)(v4 + 16 * WORD1(a2)) + 184 * (unsigned __int16)a2;
  }
  else
  {
    return 0;
  }
}

void re::StringID::init(re::StringID *this, re::Allocator *a2, const char *__s)
{
  size_t v6;

  if (__s)
    v6 = strlen(__s);
  else
    v6 = 0;
  re::StringID::init(this, a2, __s, v6);
}

re::StringID *re::StringID::StringID(re::StringID *this, const char *a2)
{
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = &str_110;
  return this;
}

void re::StringID::init(re::StringID *this, re::Allocator *a2, const char *a3, size_t a4)
{
  uint64_t v7;
  size_t v8;
  const char *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  unint64_t v19;
  uint64_t v20;

  if (!a3)
  {
    re::StringID::invalid((re::StringID *)&v17);
    v12 = v17;
    v13 = v18;
    v17 = 0;
    v18 = &str_110;
    v14 = *(_QWORD *)this;
    v15 = *((_QWORD *)this + 1);
    *(_QWORD *)this = v12;
    *((_QWORD *)this + 1) = v13;
    v19 = v12 & 0xFFFFFFFFFFFFFFFELL | v14 & 1;
    v20 = v15;
LABEL_9:
    re::StringID::destroyString((re::StringID *)&v19);
    re::StringID::destroyString((re::StringID *)&v17);
    return;
  }
  if (!a4)
  {
    v17 = 0;
    v18 = &str_110;
    v16 = *((_QWORD *)this + 1);
    v19 = *(_QWORD *)this & 1;
    v20 = v16;
    *(_QWORD *)this = 0;
    *((_QWORD *)this + 1) = &str_110;
    goto LABEL_9;
  }
  v7 = *a3;
  v8 = a4 - 1;
  if (a4 != 1)
  {
    v9 = a3 + 1;
    do
    {
      v10 = *v9++;
      v7 = v10 - v7 + 32 * v7;
      --v8;
    }
    while (v8);
  }
  *(_QWORD *)this = *(_QWORD *)this & 1 | (2 * v7);
  v11 = (void *)(*(uint64_t (**)(re::Allocator *, size_t, _QWORD))(*(_QWORD *)a2 + 32))(a2, a4 + 1, 0);
  memcpy(v11, a3, a4);
  *((_BYTE *)v11 + a4) = 0;
  *(_QWORD *)this |= 1uLL;
  *((_QWORD *)this + 1) = v11;
}

re::StringID *re::StringID::StringID(re::StringID *this, const re::DynamicString *a2)
{
  unint64_t v3;
  const char *v4;
  size_t v5;
  size_t v6;
  size_t v7;

  v3 = *((_QWORD *)a2 + 1);
  if ((v3 & 1) != 0)
    v4 = (const char *)*((_QWORD *)a2 + 2);
  else
    v4 = (char *)a2 + 9;
  v5 = v3 >> 1;
  v6 = v3 >> 1;
  if ((*((_QWORD *)a2 + 1) & 1) != 0)
    v7 = v5;
  else
    v7 = v6;
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = &str_110;
  return this;
}

re::StringID *re::StringID::StringID(re::StringID *this, const StringID *a2)
{
  uint64_t v4;
  unint64_t v5;
  char *v6;
  char *var1;
  size_t v8;

  v4 = *(_QWORD *)&a2->var0;
  *(_QWORD *)this = *(_QWORD *)&a2->var0 & 0xFFFFFFFFFFFFFFFELL | *(_QWORD *)this & 1;
  if ((*(_BYTE *)&a2->var0 & 1) != 0)
  {
    var1 = a2->var1;
    v8 = strlen(var1);
    memcpy(v6, var1, v8);
    v6[v8] = 0;
    v5 = *(_QWORD *)this | 1;
  }
  else
  {
    v5 = v4 & 0xFFFFFFFFFFFFFFFELL;
    v6 = a2->var1;
  }
  *(_QWORD *)this = v5;
  *((_QWORD *)this + 1) = v6;
  return this;
}

void re::StringID::destroyString(re::StringID *this)
{
  if ((*(_BYTE *)this & 1) != 0)
  {
    if ((*(_BYTE *)this & 1) != 0)
  }
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = &str_110;
}

unint64_t *re::StringID::operator=(unint64_t *a1, uint64_t *a2)
{
  _anonymous_namespace_ *v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  const char *v8;
  size_t v9;

  re::StringID::destroyString((re::StringID *)a1);
  v5 = *a2;
  *a1 = *a2 & 0xFFFFFFFFFFFFFFFELL | *a1 & 1;
  v6 = *a2;
  *a1 = v5 & 0xFFFFFFFFFFFFFFFELL | *a2 & 1;
  if ((v6 & 1) != 0)
  {
    v8 = (const char *)a2[1];
    v9 = strlen(v8);
    memcpy(v7, v8, v9);
    *((_BYTE *)v7 + v9) = 0;
  }
  else
  {
    v7 = (void *)a2[1];
  }
  a1[1] = (unint64_t)v7;
  return a1;
}

uint64_t *re::StringID::operator=(uint64_t *a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD v8[2];

  v3 = *a2;
  v4 = a2[1];
  *a2 = 0;
  a2[1] = (uint64_t)&str_110;
  v5 = *a1;
  v6 = a1[1];
  *a1 = v3;
  a1[1] = v4;
  v8[0] = v3 & 0xFFFFFFFFFFFFFFFELL | v5 & 1;
  v8[1] = v6;
  re::StringID::destroyString((re::StringID *)v8);
  return a1;
}

void re::StringID::~StringID(re::StringID *this)
{
  re::StringID::destroyString(this);
}

re::StringID *re::StringID::invalid@<X0>(re::StringID *a1@<X8>)
{
  unsigned __int8 v3;
  int v5;
  re::StringID *v6;

  if ((v3 & 1) == 0)
  {
    v6 = a1;
    a1 = v6;
    if (v5)
    {
      *(_QWORD *)&re::StringID::invalid(void)::invalid.var0 = -2;
      re::StringID::invalid(void)::invalid.var1 = (char *)&str_110;
      a1 = v6;
    }
  }
  return re::StringID::StringID(a1, &re::StringID::invalid(void)::invalid);
}

char *re::WeakStringID::debugStr(re::WeakStringID *this)
{
  char *v1;

  if (*(_QWORD *)this == 0x7FFFFFFFFFFFFFFFLL)
    return 0;
  if (!*(_QWORD *)this)
    return (char *)&str_110;
  v1 = re::WeakStringID::debugStr(void)const::msg;
  snprintf(re::WeakStringID::debugStr(void)const::msg, 0x50uLL, "%llu", *(_QWORD *)this);
  return v1;
}

void re::StringID::copy(re::StringID *this, const char **a2, re::Allocator *a3)
{
  if ((*(_BYTE *)this & 1) != 0)
    (*(void (**)(re::Allocator *, _QWORD))(*(_QWORD *)a3 + 40))(a3, *((_QWORD *)this + 1));
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = &str_110;
  if ((*(_BYTE *)a2 & 1) != 0)
    re::StringID::init(this, a3, a2[1]);
  else
    re::StringID::operator=((unint64_t *)this, (uint64_t *)a2);
}

BOOL re::StringID::operator==(_QWORD *a1, _QWORD *a2)
{
  const char *v2;
  const char *v3;

  if ((*a2 & 0x7FFFFFFFFFFFFFFFLL) != *a1 >> 1)
    return 0;
  v2 = (const char *)a1[1];
  v3 = (const char *)a2[1];
  return v2 == v3 || strcmp(v2, v3) == 0;
}

{
  const char *v2;
  const char *v3;

  if ((*a2 ^ *a1) > 1)
    return 0;
  v2 = (const char *)a1[1];
  v3 = (const char *)a2[1];
  return v2 == v3 || strcmp(v2, v3) == 0;
}

_QWORD *re::MemoryTracker::deinit(_QWORD *this)
{
  _QWORD *v1;
  _QWORD *v2;

  if (*(_BYTE *)this)
  {
    v1 = this;
    v2 = this + 1;
    this = (_QWORD *)this[1];
    if (this)
    {
      if (v1[5])
        this = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*this + 40))(this);
      v1[5] = 0;
      v2[1] = 0;
      v2[2] = 0;
      *v2 = 0;
      ++*((_DWORD *)v1 + 8);
    }
    *(_BYTE *)v1 = 0;
  }
  return this;
}

void re::MemoryTracker::track(os_unfair_lock_s *this, const re::Allocator *a2)
{
  os_unfair_lock_s *v3;
  const re::Allocator *v4;

  v4 = a2;
  v3 = this + 1;
  os_unfair_lock_lock(this + 1);
  re::DynamicArray<re::Allocator const*>::add(&this[2]._os_unfair_lock_opaque, &v4);
  os_unfair_lock_unlock(v3);
}

_QWORD *re::DynamicArray<re::Allocator const*>::add(_QWORD *this, _QWORD *a2)
{
  _QWORD *v3;
  unint64_t v4;

  v3 = this;
  v4 = this[2];
  if (v4 >= this[1])
  {
    this = re::DynamicArray<re::Allocator const*>::growCapacity(this, v4 + 1);
    v4 = v3[2];
  }
  *(_QWORD *)(v3[4] + 8 * v4) = *a2;
  v3[2] = v4 + 1;
  ++*((_DWORD *)v3 + 6);
  return this;
}

void re::MemoryTracker::untrack(os_unfair_lock_s *this, const re::Allocator *a2)
{
  os_unfair_lock_s *v3;
  const re::Allocator *v4;

  v4 = a2;
  v3 = this + 1;
  os_unfair_lock_lock(this + 1);
  re::DynamicArray<re::Allocator const*>::removeStable(&this[2]._os_unfair_lock_opaque, &v4);
  os_unfair_lock_unlock(v3);
}

BOOL re::DynamicArray<re::Allocator const*>::removeStable(_QWORD *a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;

  v2 = a1[4];
  v3 = a1[2];
  if (v3)
  {
    v4 = 8 * v3;
    v5 = (_QWORD *)a1[4];
    while (*v5 != *a2)
    {
      ++v5;
      v4 -= 8;
      if (!v4)
      {
        v5 = (_QWORD *)(v2 + 8 * v3);
        break;
      }
    }
  }
  else
  {
    v5 = (_QWORD *)a1[4];
  }
  v6 = (uint64_t)v5 - v2;
  v7 = v6 >> 3;
  if (v6 >> 3 != v3)
    re::DynamicArray<re::Allocator const*>::removeStableAt(a1, v6 >> 3);
  return v7 != v3;
}

uint64_t re::MemoryTracker::statistics(os_unfair_lock_s *this)
{
  os_unfair_lock_s *v2;
  _QWORD v4[2];

  v4[0] = 0;
  v4[1] = 0;
  v2 = this + 1;
  os_unfair_lock_lock(this + 1);
  re::MemoryTracker::statistics((uint64_t)this, 0, v4);
  os_unfair_lock_unlock(v2);
  return v4[0];
}

uint64_t re::MemoryTracker::statistics(uint64_t result, uint64_t a2, _QWORD *a3)
{
  uint64_t v3;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v3 = *(_QWORD *)(result + 24);
  if (v3)
  {
    v6 = result;
    v7 = *(_QWORD **)(result + 40);
    v8 = 8 * v3;
    do
    {
      v9 = *v7;
      result = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v7 + 48))(*v7);
      if (result == a2)
      {
        v10 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v9 + 56))(v9);
        v12 = a3[1] + v11;
        *a3 += v10;
        a3[1] = v12;
        result = re::MemoryTracker::statistics(v6, v9, a3);
      }
      ++v7;
      v8 -= 8;
    }
    while (v8);
  }
  return result;
}

void re::MemoryTracker::logMemoryLeaks(os_unfair_lock_s *this)
{
  os_unfair_lock_s *v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;

  v2 = this + 1;
  os_unfair_lock_lock(this + 1);
  v3 = *(_QWORD *)&this[6]._os_unfair_lock_opaque;
  if (v3)
  {
    v4 = *(_QWORD **)&this[10]._os_unfair_lock_opaque;
    v5 = 8 * v3;
    do
    {
      v6 = *v4;
      if (!(*(uint64_t (**)(_QWORD))(*(_QWORD *)*v4 + 48))(*v4))
        (*(void (**)(uint64_t))(*(_QWORD *)v6 + 64))(v6);
      ++v4;
      v5 -= 8;
    }
    while (v5);
  }
  os_unfair_lock_unlock(v2);
}

_QWORD *re::DynamicArray<re::Allocator const*>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  void *v7;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (*v5)
      {
        if (!a2)
        {
          v7 = 0;
          if (!v3)
            goto LABEL_9;
          goto LABEL_8;
        }
        if (a2 >> 61)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 8, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          v2 = 8 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 8 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
            {
LABEL_9:
              v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            memcpy(v7, (const void *)v5[4], 8 * v5[2]);
            result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
      }
      else
      {
        result = (_QWORD *)re::DynamicArray<re::Allocator const*>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

_QWORD *re::DynamicArray<re::Allocator const*>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<re::Allocator const*>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::Allocator const*>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

_QWORD *re::DynamicArray<re::Allocator const*>::removeStableAt(_QWORD *result, unint64_t a2)
{
  unint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;

  v2 = result[2];
  if (v2 <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  v3 = result;
  v4 = v2 - 1;
  if (v2 - 1 > a2)
  {
    v5 = result[4];
    result = (_QWORD *)(v5 + 8 * a2);
    v6 = (char *)(v5 + 8 * v2);
    if (v6 != (char *)(result + 1))
    {
      result = memmove(result, result + 1, v6 - (char *)(result + 1));
      v4 = v3[2] - 1;
    }
  }
  v3[2] = v4;
  ++*((_DWORD *)v3 + 6);
  return result;
}

unsigned __int8 *re::StringSlice::findFirstOf@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  unsigned __int8 *result;
  char v7;

  result = std::__search_impl[abi:nn180100]<char const*,char const*,char const*,char const*,std::__equal_to,std::__identity,std::__identity>((unsigned __int8 *)(*a1 + a3), *a1 + a1[1], *(unsigned __int8 **)a2, (unsigned __int8 *)(*(_QWORD *)a2 + *(_QWORD *)(a2 + 8)));
  if ((unsigned __int8 *)(*a1 + a1[1]) == result)
  {
    v7 = 0;
  }
  else
  {
    *(_QWORD *)(a4 + 8) = &result[-*a1];
    v7 = 1;
  }
  *(_BYTE *)a4 = v7;
  return result;
}

uint64_t *re::StringSlice::findLastOf@<X0>(uint64_t *result@<X0>, unsigned __int8 **a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v4;
  unsigned __int8 *v5;
  uint64_t v7;
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  unsigned __int8 *v10;
  uint64_t v11;
  int v12;

  v4 = result[1];
  v5 = a2[1];
  if (v4 == a3 || v5 == 0)
    goto LABEL_17;
  v7 = *result;
  v8 = (unsigned __int8 *)(*result + v4);
  v9 = (unsigned __int8 *)(*result + a3);
  v10 = v8;
  do
  {
    if (*v9 == **a2)
    {
      v11 = 1;
      while (v5 != (unsigned __int8 *)v11)
      {
        if (&v9[v11] == v8)
          goto LABEL_15;
        v12 = v9[v11];
        result = (uint64_t *)(*a2)[v11++];
        if (v12 != (_DWORD)result)
          goto LABEL_7;
      }
      v10 = v9;
    }
LABEL_7:
    ++v9;
  }
  while (v9 != v8);
LABEL_15:
  if (v10 == v8)
  {
LABEL_17:
    *(_BYTE *)a4 = 0;
  }
  else
  {
    *(_BYTE *)a4 = 1;
    *(_QWORD *)(a4 + 8) = &v10[-v7];
  }
  return result;
}

unsigned __int8 *std::__search_impl[abi:nn180100]<char const*,char const*,char const*,char const*,std::__equal_to,std::__identity,std::__identity>(unsigned __int8 *a1, uint64_t a2, unsigned __int8 *a3, unsigned __int8 *a4)
{
  int64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned __int8 *v7;
  int v8;
  int v9;
  unsigned __int8 *v10;
  unsigned __int8 *v11;
  int v12;
  int v13;
  int v14;

  v4 = a4 - a3;
  if (a4 == a3)
    return a1;
  v5 = a2;
  if (a2 - (uint64_t)a1 >= v4)
  {
    v6 = a2 - v4 + 1;
    if ((unsigned __int8 *)v6 != a1)
    {
      v9 = *a3;
      v7 = a3 + 1;
      v8 = v9;
      while (*a1 != v8)
      {
LABEL_9:
        if (++a1 == (unsigned __int8 *)v6)
          return (unsigned __int8 *)v5;
      }
      v10 = a1 + 1;
      v11 = v7;
      while (v11 != a4)
      {
        v13 = *v10++;
        v12 = v13;
        v14 = *v11++;
        if (v12 != v14)
          goto LABEL_9;
      }
      return a1;
    }
  }
  return (unsigned __int8 *)v5;
}

void re::EventQueue::postEvent(os_unfair_lock_s *this, const void *a2, size_t a3)
{
  uint32_t os_unfair_lock_opaque;
  os_unfair_lock_s *v7;
  unint64_t v8;
  os_unfair_lock_s *v9;
  unint64_t v10;
  BOOL v11;
  unint64_t v12;
  _BOOL4 v13;
  uint64_t v14;

  if (!a2)
  {
    re::internal::assertLog((re::internal *)4, 0, "assertion failure: '%s' (%s:line %i) event must not be null.", "event", "postEvent", 28);
    _os_crash();
    __break(1u);
    goto LABEL_11;
  }
  if (a3 <= 3)
  {
LABEL_11:
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Invalid size.", "size >= sizeof(uint32_t)", "postEvent", 29);
    _os_crash();
    __break(1u);
LABEL_12:
    re::internal::assertLog((re::internal *)4, v12, "assertion failure: '%s' (%s:line %i) Invalid size. Size causes arithmetic overflow.", "!overflow", "postEvent", 44);
    _os_crash();
    __break(1u);
LABEL_13:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  os_unfair_lock_lock(this);
  os_unfair_lock_opaque = this[22]._os_unfair_lock_opaque;
  v7 = &this[10 * os_unfair_lock_opaque];
  v10 = *(_QWORD *)&v7[6]._os_unfair_lock_opaque;
  v9 = v7 + 6;
  v8 = v10;
  v11 = v10 >= 0xFFFFFFFFFFFFFFFCLL;
  v12 = a3 + v10 + 4;
  v13 = __CFADD__(a3, v10 + 4);
  if (v11 || v13)
    goto LABEL_12;
  re::DynamicArray<char>::resize((uint64_t)&this[10 * os_unfair_lock_opaque + 2], v12);
  if (*(_QWORD *)&v9->_os_unfair_lock_opaque <= v8)
    goto LABEL_13;
  v14 = *(_QWORD *)&this[10 * os_unfair_lock_opaque + 10]._os_unfair_lock_opaque;
  *(_DWORD *)(v14 + v8) = a3;
  memcpy((void *)(v14 + v8 + 4), a2, a3);
  os_unfair_lock_unlock(this);
}

void re::DynamicArray<char>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v4;

  v4 = *(_QWORD *)(a1 + 16);
  if (v4 >= a2)
  {
    if (v4 <= a2)
      return;
  }
  else
  {
    if (*(_QWORD *)(a1 + 8) < a2)
    {
      re::DynamicArray<char>::setCapacity((_QWORD *)a1, a2);
      v4 = *(_QWORD *)(a1 + 16);
    }
    if (v4 < a2 && (uint64_t)(a2 - v4) >= 1)
      bzero((void *)(*(_QWORD *)(a1 + 32) + v4), a2 - v4);
  }
  *(_QWORD *)(a1 + 16) = a2;
  ++*(_DWORD *)(a1 + 24);
}

void re::EventQueue::swapBuffers(os_unfair_lock_s *this)
{
  _BOOL4 v2;
  os_unfair_lock_s *v3;

  os_unfair_lock_lock(this);
  v2 = (this[22]._os_unfair_lock_opaque & 1) == 0;
  this[22]._os_unfair_lock_opaque = v2;
  v3 = &this[10 * v2];
  *(_QWORD *)&v3[6]._os_unfair_lock_opaque = 0;
  ++v3[8]._os_unfair_lock_opaque;
  *(_QWORD *)&this[24]._os_unfair_lock_opaque = 0;
  os_unfair_lock_unlock(this);
}

uint64_t re::EventQueue::peekEvent(re::EventQueue *this, unint64_t a2)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;

  v2 = *((_QWORD *)this + 12);
  v3 = *((_QWORD *)this + 5 * ((*((_DWORD *)this + 22) & 1) == 0) + 3);
  if (v3 == v2)
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) EventQueue is empty.", "!isEmpty()", "peekEvent", 100);
    _os_crash();
    __break(1u);
    goto LABEL_6;
  }
  if (v3 - v2 - 8 < a2)
  {
LABEL_6:
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Invalid offset.", "offset <= events.size() - payloadOffset - sizeof(uint32_t)", "peekEvent", 105);
    _os_crash();
    __break(1u);
LABEL_7:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  v4 = a2 + v2 + 4;
  if (v3 <= v4)
    goto LABEL_7;
  return *(unsigned int *)(*((_QWORD *)this + 5 * ((*((_DWORD *)this + 22) & 1) == 0) + 5) + v4);
}

void *re::EventQueue::readEvent(re::EventQueue *this, void *__dst, size_t __n)
{
  unint64_t v3;
  unint64_t v4;
  uint64_t v7;
  unint64_t v8;
  void *result;

  v3 = *((_QWORD *)this + 12);
  v4 = *((_QWORD *)this + 5 * ((*((_DWORD *)this + 22) & 1) == 0) + 3);
  if (v3 == v4)
  {
    re::internal::assertLog((re::internal *)4, (uint64_t)__dst, __n, "assertion failure: '%s' (%s:line %i) EventQueue is empty.", "!isEmpty()", "readEvent", 115);
    _os_crash();
    __break(1u);
    goto LABEL_8;
  }
  if (!__dst)
  {
LABEL_8:
    re::internal::assertLog((re::internal *)4, (uint64_t)__dst, __n, "assertion failure: '%s' (%s:line %i) buffer must not be null.", "buffer", "readEvent", 116);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  if (v4 <= v3)
  {
LABEL_9:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_10;
  }
  v7 = *((_QWORD *)this + 5 * ((*((_DWORD *)this + 22) & 1) == 0) + 5);
  if (*(_DWORD *)(v7 + v3) != __n)
  {
LABEL_10:
    re::internal::assertLog((re::internal *)4, (uint64_t)__dst, "assertion failure: '%s' (%s:line %i) Specified size does not match event size.", "size == nextEventSize()", "readEvent", 117);
    _os_crash();
    __break(1u);
LABEL_11:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  v8 = v3 + 4;
  if (v4 <= v8)
    goto LABEL_11;
  result = memcpy(__dst, (const void *)(v7 + v8), __n);
  *((_QWORD *)this + 12) += __n + 4;
  return result;
}

void re::internal::refCountCheckFailHandler(re::internal *this, const void *a2, const void *a3)
{
  const char *v5;
  const char *v6;
  unsigned __int8 v7;
  const char *v8;
  uint8_t v9;
  uint8_t buf[4];
  const char *v11;
  __int16 v12;
  const void *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  int v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  if ((_DWORD)this)
    v5 = "Retain";
  else
    v5 = "Release";
  fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Ref count out of range on %s. %p (retain count is %d 0x%x)\n", v5, a2, (_DWORD)a3, (_DWORD)a3);
  v7 = atomic_load((unsigned __int8 *)&qword_254106110);
  if ((v7 & 1) == 0 && __cxa_guard_acquire(&qword_254106110))
  {
    re::Defaults::BOOLValue((re::Defaults *)"crashOnRefCountCheckFail", v6, (char *)buf);
    if (buf[0])
      v9 = buf[1];
    else
      v9 = 0;
    _MergedGlobals_134 = v9;
    __cxa_guard_release(&qword_254106110);
  }
  if (_MergedGlobals_134)
  {
    re::internal::assertLog((re::internal *)8, (uint64_t)v6, "assertion failure: '%s' (%s:line %i) Ref count out of range on %s. %p (retain count is %d 0x%x)\n", "false", "refCountCheckFailHandler", 30, v5, a2, a3, a3);
    _os_crash();
    __break(1u);
  }
  if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136315906;
    v11 = v5;
    v12 = 2048;
    v13 = a2;
    v14 = 1024;
    v15 = (int)a3;
    v16 = 1024;
    v17 = (int)a3;
    _os_log_error_impl(&dword_224FE9000, MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR, "Ref count out of range on %s. %p (retain count is %d 0x%x)\n", buf, 0x22u);
  }
  re::internal::logStackTrace(0, 0, v8);
}

re::PageDebugAllocator *re::PageDebugAllocator::PageDebugAllocator(re::PageDebugAllocator *this, const char *a2, int a3, unint64_t a4)
{
  re::Allocator *v6;
  uint64_t *v7;

  v6 = re::Allocator::Allocator(this, a2, a3);
  *(_QWORD *)v6 = &off_24ED41E00;
  *((_DWORD *)v6 + 5) = 0;
  *((_OWORD *)v6 + 3) = 0u;
  *((_QWORD *)v6 + 8) = 0;
  *((_OWORD *)v6 + 2) = 0u;
  v7 = (uint64_t *)((char *)v6 + 32);
  return this;
}

void re::PageDebugAllocator::~PageDebugAllocator(os_unfair_lock_s *this)
{
  os_unfair_lock_s *v2;
  os_unfair_lock_s *v3;
  uint64_t v4;
  uint64_t v5;
  vm_map_t *v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;

  v2 = this + 5;
  os_unfair_lock_lock(this + 5);
  v4 = *(_QWORD *)&this[14]._os_unfair_lock_opaque;
  v5 = *(_QWORD *)&this[16]._os_unfair_lock_opaque;
  v3 = this + 14;
  if (v4 != v5)
  {
    v6 = (vm_map_t *)MEMORY[0x24BDAEC58];
    do
    {
      v7 = *(_QWORD *)&this[10]._os_unfair_lock_opaque;
      v8 = (v7 - 1) & v4;
      if (v7 <= v8)
      {
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      mach_vm_deallocate(*v6, *(_QWORD *)(*(_QWORD *)&this[12]._os_unfair_lock_opaque + 16 * v8), *(_QWORD *)(*(_QWORD *)&this[12]._os_unfair_lock_opaque + 16 * v8 + 8));
      ++v4;
    }
    while (v5 != v4);
  }
  *(_QWORD *)&v3->_os_unfair_lock_opaque = 0;
  *(_QWORD *)&this[16]._os_unfair_lock_opaque = 0;
  os_unfair_lock_unlock(v2);
  *(_QWORD *)&v3->_os_unfair_lock_opaque = 0;
  *(_QWORD *)&this[16]._os_unfair_lock_opaque = 0;
  v9 = *(_QWORD *)&this[8]._os_unfair_lock_opaque;
  if (v9)
  {
    if (*(_QWORD *)&this[10]._os_unfair_lock_opaque)
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v9 + 40))(v9, *(_QWORD *)&this[12]._os_unfair_lock_opaque);
      *(_QWORD *)&this[10]._os_unfair_lock_opaque = 0;
      *(_QWORD *)&this[12]._os_unfair_lock_opaque = 0;
    }
    *(_QWORD *)&this[8]._os_unfair_lock_opaque = 0;
  }
  re::Allocator::~Allocator((re::Allocator *)this);
}

{
  re::PageDebugAllocator::~PageDebugAllocator(this);
  JUMPOUT(0x2276933B8);
}

mach_vm_address_t re::PageDebugAllocator::alloc(os_unfair_lock_s *this, uint64_t a2)
{
  os_unfair_lock_s *v3;
  mach_vm_size_t v4;
  mach_vm_address_t v5;
  mach_vm_address_t v6;
  mach_vm_address_t address;

  v3 = this + 5;
  os_unfair_lock_lock(this + 5);
  v4 = ~*MEMORY[0x24BDB03B8] & (unint64_t)(a2 + *MEMORY[0x24BDB03B8] + 16);
  address = 0;
  v5 = 0;
  if (!mach_vm_map(*MEMORY[0x24BDAEC58], &address, v4, 0, 1, 0, 0, 0, 3, 3, 2u))
  {
    v6 = address;
    *(_QWORD *)address = a2;
    *(_QWORD *)(v6 + 8) = v4;
    v5 = v6 + 16;
    __dmb(0xBu);
  }
  os_unfair_lock_unlock(v3);
  return v5;
}

void re::PageDebugAllocator::free(os_unfair_lock_s *this, _QWORD *a2)
{
  os_unfair_lock_s *v4;
  char *v5;
  mach_vm_size_t v6;
  vm_map_t *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  mach_vm_address_t *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  mach_vm_address_t address;
  uint64_t v17;
  int v18;
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  unint64_t v23;
  __int16 v24;
  unint64_t v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  uint64_t v31;

  v31 = *MEMORY[0x24BDAC8D0];
  v4 = this + 5;
  os_unfair_lock_lock(this + 5);
  __dmb(0xBu);
  v5 = (char *)(a2 - 2);
  v6 = *(a2 - 1);
  address = (mach_vm_address_t)v5;
  v7 = (vm_map_t *)MEMORY[0x24BDAEC58];
  mach_vm_map(*MEMORY[0x24BDAEC58], &address, v6, 0, 0x4000, 0, 0, 0, 0, 3, 2u);
  v9 = *(_QWORD *)&this[14]._os_unfair_lock_opaque;
  v8 = *(_QWORD *)&this[16]._os_unfair_lock_opaque;
  v10 = v8 - v9;
  v11 = *(_QWORD *)&this[10]._os_unfair_lock_opaque;
  if (v8 - v9 == v11)
  {
    v11 = (v10 - 1) & v9;
    if (v10 <= v11)
      goto LABEL_9;
    v12 = (mach_vm_address_t *)(*(_QWORD *)&this[12]._os_unfair_lock_opaque + 16 * v11);
    mach_vm_deallocate(*v7, *v12, v12[1]);
    *v12 = 0;
    v12[1] = 0;
    v8 = *(_QWORD *)&this[16]._os_unfair_lock_opaque;
    v13 = *(_QWORD *)&this[14]._os_unfair_lock_opaque + 1;
    *(_QWORD *)&this[14]._os_unfair_lock_opaque = v13;
    v11 = *(_QWORD *)&this[10]._os_unfair_lock_opaque;
    v10 = v8 - v13;
  }
  v14 = v8 + 1;
  if (v10 == v11)
    *(_QWORD *)&this[14]._os_unfair_lock_opaque = v14 - v10;
  *(_QWORD *)&this[16]._os_unfair_lock_opaque = v14;
  v10 = (v11 - 1) & v8;
  if (v11 <= v10)
  {
    v17 = 0;
    v29 = 0u;
    v30 = 0u;
    v27 = 0u;
    v28 = 0u;
    v26 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v18 = 136315906;
    v19 = "operator[]";
    v20 = 1024;
    v21 = 468;
    v22 = 2048;
    v23 = v10;
    v24 = 2048;
    v25 = v11;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_9:
    v17 = 0;
    v29 = 0u;
    v30 = 0u;
    v27 = 0u;
    v28 = 0u;
    v26 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v18 = 136315906;
    v19 = "operator[]";
    v20 = 1024;
    v21 = 468;
    v22 = 2048;
    v23 = v11;
    v24 = 2048;
    v25 = v10;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  v15 = (_QWORD *)(*(_QWORD *)&this[12]._os_unfair_lock_opaque + 16 * v10);
  *v15 = v5;
  v15[1] = v6;
  os_unfair_lock_unlock(v4);
}

uint64_t re::PageDebugAllocator::statistics(os_unfair_lock_s *this)
{
  os_unfair_lock_s *v1;

  v1 = this + 5;
  os_unfair_lock_lock(this + 5);
  os_unfair_lock_unlock(v1);
  return 0;
}

void re::PageDebugAllocator::logMemoryLeaks(os_unfair_lock_s *this)
{
  os_unfair_lock_s *v1;

  v1 = this + 5;
  os_unfair_lock_lock(this + 5);
  os_unfair_lock_unlock(v1);
}

uint64_t re::PageDebugAllocator::parent(re::PageDebugAllocator *this)
{
  return 0;
}

void re::FixedArray<re::PageDebugAllocator::DeferredFree>::init<>(uint64_t *a1, uint64_t a2, unint64_t a3)
{
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;

  *a1 = a2;
  a1[1] = a3;
  if (!a3)
    return;
  if (a3 >> 60)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 16, a3);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  v5 = 16 * a3;
  v6 = (_QWORD *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 16 * a3, 8);
  a1[2] = (uint64_t)v6;
  if (!v6)
  {
LABEL_9:
    re::internal::assertLog((re::internal *)4, v7, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    _os_crash();
    __break(1u);
    return;
  }
  v8 = v6;
  if (a3 != 1)
  {
    bzero(v6, v5 - 16);
    v8 = (_QWORD *)((char *)v8 + v5 - 16);
  }
  *v8 = 0;
  v8[1] = 0;
}

id *re::ObjCObject::operator=(id *location, id *a2)
{
  if (location != a2)
    objc_storeStrong(location, *a2);
  return location;
}

void **re::ObjCObject::operator=(void **a1, void *a2)
{
  id v3;
  void *v4;

  v3 = a2;
  v4 = *a1;
  if (*a1 != v3)
  {
    *a1 = v3;

    v3 = 0;
  }

  return a1;
}

const char *re::ObjCObject::description(id *this)
{
  void *v1;
  void *v2;
  const char *v3;

  objc_msgSend(*this, "description");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  v2 = v1;
  if (v1)
    v3 = (const char *)objc_msgSend(objc_retainAutorelease(v1), "UTF8String");
  else
    v3 = "nil";

  return v3;
}

re::ns::String *re::ns::String::String(re::ns::String *this, re::ns *a2)
{
  id v3;

  re::ns::convertToNSString(a2, (const char *)a2);
  v3 = (id)objc_claimAutoreleasedReturnValue();
  *(_QWORD *)this = v3;

  return this;
}

re::ns *re::ns::convertToNSString(re::ns *this, const char *a2)
{
  if (this)
  {
    objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", this);
    this = (re::ns *)objc_claimAutoreleasedReturnValue();
  }
  return this;
}

void re::ns::String::format(re::ns::String *this@<X0>, _QWORD *a2@<X8>, ...)
{
  id v5;
  void *v6;
  void *v7;
  id v8;
  va_list va;

  va_start(va, a2);
  v5 = objc_alloc(MEMORY[0x24BDD17C8]);
  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", this);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v7 = (void *)objc_msgSend(v5, "initWithFormat:arguments:", v6, va);

  v8 = v7;
  *a2 = v8;

}

re::PoolAllocator *re::PoolAllocator::PoolAllocator(re::PoolAllocator *this, const char *a2, unint64_t a3, uint64_t a4, re::Allocator *a5, unint64_t a6)
{
  re::Allocator *v11;
  uint64_t v12;
  int8x8_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint8x8_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  re::PoolAllocator *result;

  v11 = re::Allocator::Allocator(this, a2, 1);
  *(_QWORD *)v11 = &off_24ED41E70;
  *((_QWORD *)v11 + 3) = a5;
  *((_DWORD *)v11 + 8) = 0;
  *((_DWORD *)v11 + 10) = 0;
  *((_OWORD *)v11 + 3) = 0u;
  *((_OWORD *)v11 + 4) = 0u;
  *((_DWORD *)v11 + 20) = 0;
  *(_QWORD *)((char *)v11 + 84) = 0x7FFFFFFFLL;
  *((_QWORD *)v11 + 16) = 0;
  *((_QWORD *)v11 + 13) = 0;
  *((_QWORD *)v11 + 14) = 0;
  *((_DWORD *)v11 + 30) = 0;
  *((_QWORD *)v11 + 12) = a5;
  re::DynamicArray<float *>::setCapacity((_QWORD *)v11 + 12, 0);
  ++*((_DWORD *)this + 30);
  *((_QWORD *)this + 17) = a5;
  *((_QWORD *)this + 21) = 0;
  *((_QWORD *)this + 18) = 0;
  *((_QWORD *)this + 19) = 0;
  *((_DWORD *)this + 40) = 0;
  re::DynamicArray<re::RigNodeConstraint>::setCapacity((_QWORD *)this + 17, 0);
  ++*((_DWORD *)this + 40);
  *((_QWORD *)this + 26) = 0;
  *((_QWORD *)this + 28) = 0;
  *((_WORD *)this + 116) = 1;
  v13 = (int8x8_t)16;
  if (a6 > 0x10)
    v13 = (int8x8_t)a6;
  *((int8x8_t *)this + 22) = v13;
  v14 = 32;
  if (a4)
    v14 = a4;
  *((_QWORD *)this + 24) = a3;
  v15 = 8;
  if (a3 > 8)
    v15 = a3;
  if (v15 >= 0x18)
  {
    *((_QWORD *)this + 26) = 8;
    v15 = (v15 + 7) & 0xFFFFFFFFFFFFFFF8;
    *((_QWORD *)this + 28) = v15 - 8;
    *((_BYTE *)this + 233) = 1;
  }
  v16 = v15 + 7;
  *((_QWORD *)this + 27) = v16 & 0xFFFFFFFFFFFFFFF8;
  v17 = (uint8x8_t)vcnt_s8(v13);
  v17.i16[0] = vaddlv_u8(v17);
  v18 = (v16 | 7) + *(_QWORD *)&v13;
  v19 = v18 / *(_QWORD *)&v13 * *(_QWORD *)&v13;
  v20 = v18 & -*(_QWORD *)&v13;
  if (v17.u32[0] != 1)
    v20 = v19;
  *((_QWORD *)this + 23) = v20;
  v21 = v20 * v14;
  *((_QWORD *)this + 25) = v21;
  if (HIDWORD(v21))
  {
    re::internal::assertLog((re::internal *)4, v12, "assertion failure: '%s' (%s:line %i) ", "m_blockSize <= std::numeric_limits<uint32_t>::max()", "PoolAllocator", 52);
    result = (re::PoolAllocator *)_os_crash();
    __break(1u);
  }
  else
  {
    *((_QWORD *)this + 25) = v21 + *(_QWORD *)&v13;
    return this;
  }
  return result;
}

void re::PoolAllocator::~PoolAllocator(re::PoolAllocator *this)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (*((_QWORD *)this + 3))
  {
    v2 = *((_QWORD *)this + 14);
    if (v2)
    {
      v3 = (uint64_t *)*((_QWORD *)this + 16);
      v4 = 8 * v2;
      do
      {
        v5 = *v3++;
        (*(void (**)(_QWORD, uint64_t))(**((_QWORD **)this + 3) + 40))(*((_QWORD *)this + 3), v5);
        v4 -= 8;
      }
      while (v4);
    }
    *((_QWORD *)this + 14) = 0;
    ++*((_DWORD *)this + 30);
    *((_QWORD *)this + 3) = 0;
  }
  v6 = *((_QWORD *)this + 17);
  if (v6)
  {
    if (*((_QWORD *)this + 21))
      (*(void (**)(uint64_t))(*(_QWORD *)v6 + 40))(v6);
    *((_QWORD *)this + 21) = 0;
    *((_QWORD *)this + 18) = 0;
    *((_QWORD *)this + 19) = 0;
    *((_QWORD *)this + 17) = 0;
    ++*((_DWORD *)this + 40);
  }
  v7 = *((_QWORD *)this + 12);
  if (v7)
  {
    if (*((_QWORD *)this + 16))
      (*(void (**)(uint64_t))(*(_QWORD *)v7 + 40))(v7);
    *((_QWORD *)this + 16) = 0;
    *((_QWORD *)this + 13) = 0;
    *((_QWORD *)this + 14) = 0;
    *((_QWORD *)this + 12) = 0;
    ++*((_DWORD *)this + 30);
  }
  re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::deinit((uint64_t *)this + 6);
  re::Allocator::~Allocator(this);
}

{
  re::PoolAllocator::~PoolAllocator(this);
  JUMPOUT(0x2276933B8);
}

unint64_t re::PoolAllocator::alloc(re::PoolAllocator *this, unint64_t a2, unint64_t a3)
{
  unint64_t v4;
  unint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  _anonymous_namespace_ *v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  unint64_t v18;
  int v19;
  char *v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  __n128 v27;

  if (!*((_QWORD *)this + 3) || *((_QWORD *)this + 22) < a3 || *((_QWORD *)this + 24) < a2)
    return 0;
  os_unfair_lock_lock((os_unfair_lock_t)this + 8);
  if (!*((_QWORD *)this + 19))
  {
    v11 = *((_QWORD *)this + 3);
    if (!v11)
      goto LABEL_38;
    v12 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)v11 + 32))(v11, *((_QWORD *)this + 25), *((_QWORD *)this + 22));
    if (v12)
    {
      v4 = (unint64_t)v12;
      *(_OWORD *)v12 = xmmword_226102ED0;
      v13 = *((_QWORD *)this + 14);
      if (HIDWORD(v13))
        goto LABEL_41;
      *((_DWORD *)v12 + 2) = v13;
      v14 = *((_QWORD *)this + 23);
      v15 = (unint64_t)v12 + *((_QWORD *)this + 22);
      v16 = (char *)v12 + *((_QWORD *)this + 25) - v14;
      if (v15 <= (unint64_t)v16)
      {
        v19 = *((unsigned __int8 *)this + 233);
        v20 = (char *)v12 + *((_QWORD *)this + 22);
        v17 = *((_QWORD *)this + 26);
        v21 = *((_QWORD *)this + 27);
        do
        {
          *(_QWORD *)&v20[v21] = v12;
          if (v19)
          {
            *(_QWORD *)v20 = 0xFEEFED900143AD35;
            *(_QWORD *)&v20[*((_QWORD *)this + 28)] = 0xDFFDFE9001F00735;
          }
          *(_QWORD *)&v20[v17] = &v20[v14];
          v20 += v14;
        }
        while (v20 <= v16);
      }
      else
      {
        v17 = *((_QWORD *)this + 26);
      }
      *(_QWORD *)&v16[v17] = 0;
      v22 = *((_QWORD *)this + 13);
      if (v13 >= v22)
      {
        v23 = v13 + 1;
        if (v22 < v13 + 1)
        {
          if (*((_QWORD *)this + 12))
          {
            v24 = 2 * v22;
            if (!v22)
              v24 = 8;
            if (v24 <= v23)
              v25 = v23;
            else
              v25 = v24;
            re::DynamicArray<float *>::setCapacity((_QWORD *)this + 12, v25);
          }
          else
          {
            re::DynamicArray<float *>::setCapacity((_QWORD *)this + 12, v23);
            ++*((_DWORD *)this + 30);
          }
        }
        v13 = *((_QWORD *)this + 14);
      }
      *(_QWORD *)(*((_QWORD *)this + 16) + 8 * v13) = v4;
      *((_QWORD *)this + 14) = v13 + 1;
      ++*((_DWORD *)this + 30);
      v26 = *((_QWORD *)this + 19);
      v27.n128_u64[0] = v4;
      v27.n128_u64[1] = v15;
      re::DynamicArray<re::Pair<float *,re::AnimationBlendTreeInstance<float>::SampleFlags,true>>::add((uint64_t)this + 136, &v27);
      *(_DWORD *)(v4 + 12) = v26;
    }
    if (!*((_QWORD *)this + 19))
    {
LABEL_38:
      v4 = 0;
      goto LABEL_39;
    }
  }
  v7 = *((_QWORD *)this + 21);
  v4 = *(_QWORD *)(v7 + 8);
  if (*((_BYTE *)this + 233)
    && (*(_QWORD *)v4 != 0xFEEFED900143AD35 || *(_QWORD *)(v4 + *((_QWORD *)this + 28)) != 0xDFFDFE9001F00735))
  {
    goto LABEL_42;
  }
  v8 = *(_QWORD *)(v4 + *((_QWORD *)this + 27));
  v9 = *(_DWORD *)(v8 + 4) + *((_DWORD *)this + 46);
  *(_DWORD *)(v8 + 4) = v9;
  v10 = *(_QWORD *)(v4 + *((_QWORD *)this + 26));
  if (v10)
  {
    *(_QWORD *)(v7 + 8) = v10;
LABEL_20:
    *(_QWORD *)(v4 + *((_QWORD *)this + 26)) = 0;
LABEL_39:
    os_unfair_lock_unlock((os_unfair_lock_t)this + 8);
    return v4;
  }
  if (*((_QWORD *)this + 22) + v9 == *((_QWORD *)this + 25))
  {
    v18 = *(unsigned int *)(v8 + 12);
    re::DynamicArray<re::DataArray<re::RigGraphOperatorDefinition>::ElementBlock>::removeAt((uint64_t)this + 136, v18);
    if (*((_QWORD *)this + 19) > v18)
      *(_DWORD *)(*(_QWORD *)(*((_QWORD *)this + 21) + 16 * v18) + 12) = v18;
    goto LABEL_20;
  }
  re::internal::assertLog((re::internal *)4, v6, "assertion failure: '%s' (%s:line %i) ", "isBlockFull(block)", "alloc", 113);
  _os_crash();
  __break(1u);
LABEL_41:
  re::internal::assertLog((re::internal *)4, v6, "assertion failure: '%s' (%s:line %i) ", "m_blocks.size() <= std::numeric_limits<uint32_t>::max()", "addPoolBlock", 281);
  _os_crash();
  __break(1u);
LABEL_42:
  re::internal::assertLog((re::internal *)5, v6, "assertion failure: '%s' (%s:line %i) Free pool entry %p is corrupted", "!hasEntryMemoryBeenStomped(entry)", "alloc", 104, v4);
  result = _os_crash();
  __break(1u);
  return result;
}

void re::PoolAllocator::free(os_unfair_lock_s *this, char *a2)
{
  uint64_t v4;
  _DWORD *v5;
  uint64_t v6;
  BOOL v7;
  uint64_t v8;
  uint64_t v9;
  char *i;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  NSObject *v20;
  uint64_t v21;
  uint32_t os_unfair_lock_opaque;
  uint64_t v23;
  const char *v24;
  const char *v25;
  uint8_t buf[16];
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  uint64_t v31;

  v31 = *MEMORY[0x24BDAC8D0];
  if (a2)
  {
    if (*(_QWORD *)&this[6]._os_unfair_lock_opaque)
    {
      os_unfair_lock_lock(this + 8);
      v5 = *(_DWORD **)&a2[*(_QWORD *)&this[54]._os_unfair_lock_opaque];
      if (!LOBYTE(this[58]._os_unfair_lock_opaque) || *v5 == -1159983635)
      {
        if (!BYTE1(this[58]._os_unfair_lock_opaque)
          || *(_QWORD *)a2 == 0xFEEFED900143AD35
          && *(_QWORD *)&a2[*(_QWORD *)&this[56]._os_unfair_lock_opaque] == 0xDFFDFE9001F00735)
        {
          v6 = *(_QWORD *)&this[38]._os_unfair_lock_opaque;
          if (v6)
          {
            v7 = 0;
            v8 = *(_QWORD *)&this[42]._os_unfair_lock_opaque;
            v9 = v8 + 16 * v6;
            do
            {
              if (!v7)
              {
                for (i = *(char **)(v8 + 8); i; i = *(char **)&i[*(_QWORD *)&this[52]._os_unfair_lock_opaque])
                {
                  v7 = i == a2;
                  if (i == a2)
                    break;
                }
              }
              v8 += 16;
            }
            while (v8 != v9);
            if (v7)
              goto LABEL_35;
          }
        }
        v11 = v5[1];
        v12 = *(_QWORD *)&this[44]._os_unfair_lock_opaque;
        v13 = *(_QWORD *)&this[50]._os_unfair_lock_opaque;
        v14 = v11 - this[46]._os_unfair_lock_opaque;
        v5[1] = v14;
        if (!v14)
        {
          if (!*(_QWORD *)&this[6]._os_unfair_lock_opaque)
          {
LABEL_35:
            os_unfair_lock_unlock(this + 8);
            return;
          }
          v15 = v5[2];
          if (*(_QWORD *)&this[28]._os_unfair_lock_opaque > v15)
          {
            v16 = *(_QWORD *)(*(_QWORD *)&this[32]._os_unfair_lock_opaque + 8 * v15);
            v17 = *(unsigned int *)(v16 + 12);
            re::DynamicArray<re::DataArray<re::RigGraphOperatorDefinition>::ElementBlock>::removeAt((uint64_t)&this[34], v17);
            if (*(_QWORD *)&this[38]._os_unfair_lock_opaque > v17)
              *(_DWORD *)(*(_QWORD *)(*(_QWORD *)&this[42]._os_unfair_lock_opaque + 16 * v17) + 12) = v17;
            (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)&this[6]._os_unfair_lock_opaque + 40))(*(_QWORD *)&this[6]._os_unfair_lock_opaque, v16);
            v18 = *(_QWORD *)&this[28]._os_unfair_lock_opaque;
            if (v18 > v15)
            {
              v19 = v18 - 1;
              if (v18 - 1 <= v15)
              {
                *(_QWORD *)&this[28]._os_unfair_lock_opaque = v19;
                ++this[30]._os_unfair_lock_opaque;
              }
              else
              {
                *(_QWORD *)(*(_QWORD *)&this[32]._os_unfair_lock_opaque + 8 * v15) = *(_QWORD *)(*(_QWORD *)&this[32]._os_unfair_lock_opaque
                                                                                               + 8 * v18
                                                                                               - 8);
                *(_QWORD *)&this[28]._os_unfair_lock_opaque = v19;
                ++this[30]._os_unfair_lock_opaque;
                *(_DWORD *)(*(_QWORD *)(*(_QWORD *)&this[32]._os_unfair_lock_opaque + 8 * v15) + 8) = v15;
              }
              goto LABEL_35;
            }
LABEL_46:
            v29 = 0u;
            v30 = 0u;
            v27 = 0u;
            v28 = 0u;
            *(_OWORD *)buf = 0u;
            os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
          }
LABEL_45:
          v29 = 0u;
          v30 = 0u;
          v27 = 0u;
          v28 = 0u;
          *(_OWORD *)buf = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
          goto LABEL_46;
        }
        if (v12 + v11 == v13)
        {
          os_unfair_lock_opaque = this[38]._os_unfair_lock_opaque;
          *(_QWORD *)buf = v5;
          *(_QWORD *)&buf[8] = 0;
          re::DynamicArray<re::Pair<float *,re::AnimationBlendTreeInstance<float>::SampleFlags,true>>::add((uint64_t)&this[34], (__n128 *)buf);
          v5[3] = os_unfair_lock_opaque;
        }
        else
        {
          os_unfair_lock_opaque = v5[3];
        }
        if (*(_QWORD *)&this[38]._os_unfair_lock_opaque > (unint64_t)os_unfair_lock_opaque)
        {
          v23 = *(_QWORD *)(*(_QWORD *)&this[42]._os_unfair_lock_opaque + 16 * os_unfair_lock_opaque + 8);
          if (BYTE1(this[58]._os_unfair_lock_opaque))
          {
            *(_QWORD *)a2 = 0xFEEFED900143AD35;
            *(_QWORD *)&a2[*(_QWORD *)&this[56]._os_unfair_lock_opaque] = 0xDFFDFE9001F00735;
          }
          *(_QWORD *)&a2[*(_QWORD *)&this[52]._os_unfair_lock_opaque] = v23;
          *(_QWORD *)(*(_QWORD *)&this[42]._os_unfair_lock_opaque + 16 * os_unfair_lock_opaque + 8) = a2;
          goto LABEL_35;
        }
LABEL_44:
        v29 = 0u;
        v30 = 0u;
        v27 = 0u;
        v28 = 0u;
        *(_OWORD *)buf = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_45;
      }
      re::internal::assertLog((re::internal *)4, v4, "assertion failure: '%s' (%s:line %i) Pool block is invalid. This could mean the memory address was not allocated from this pool, or other corruption. Enable RE_MEMORY_TRACKING to debug", "!m_enableAsserts || block->m_magic == blockGuard", "free", 149);
      _os_crash();
      __break(1u);
LABEL_40:
      if (*(_QWORD *)&this[2]._os_unfair_lock_opaque)
        v25 = *(const char **)&this[2]._os_unfair_lock_opaque;
      else
        v25 = "<UNKNOWN>";
      re::internal::assertLog((re::internal *)5, v21, "assertion failure: '%s' (%s:line %i) Called free() on pool %s which is not bound to a parent allocator (already destroyed?)", "!m_enableAsserts", "free", 133, v25);
      _os_crash();
      __break(1u);
      goto LABEL_44;
    }
    v20 = *re::foundationMemoryLogObjects((re *)this);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      v24 = *(const char **)&this[2]._os_unfair_lock_opaque;
      if (!v24)
        v24 = "<UNKNOWN>";
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = v24;
      _os_log_error_impl(&dword_224FE9000, v20, OS_LOG_TYPE_ERROR, "Called free() on pool %s which is not bound to a parent allocator (already destroyed?)", buf, 0xCu);
    }
    if (LOBYTE(this[58]._os_unfair_lock_opaque))
      goto LABEL_40;
  }
}

uint64_t re::PoolAllocator::statistics(os_unfair_lock_s *this)
{
  os_unfair_lock_s *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;

  v2 = this + 8;
  os_unfair_lock_lock(this + 8);
  v3 = *(_QWORD *)&this[28]._os_unfair_lock_opaque;
  v4 = 16 * *(_QWORD *)&this[38]._os_unfair_lock_opaque + 8 * v3;
  v5 = 16 * *(_QWORD *)&this[36]._os_unfair_lock_opaque + 8 * *(_QWORD *)&this[26]._os_unfair_lock_opaque;
  if (v3)
  {
    v6 = *(uint64_t **)&this[32]._os_unfair_lock_opaque;
    v7 = 8 * v3;
    do
    {
      v8 = *v6++;
      v5 += *(_QWORD *)&this[50]._os_unfair_lock_opaque;
      v4 += *(unsigned int *)(v8 + 4);
      v7 -= 8;
    }
    while (v7);
  }
  os_unfair_lock_unlock(v2);
  return v4;
}

uint64_t re::PoolAllocator::parent(re::PoolAllocator *this)
{
  return *((_QWORD *)this + 3);
}

re::DynamicString *re::DynamicString::DynamicString(re::DynamicString *this)
{
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  re::DynamicString::setCapacity(this, 0);
  return this;
}

re::DynamicString *re::DynamicString::DynamicString(re::DynamicString *this, const char *__s, re::Allocator *a3)
{
  size_t v6;
  size_t v7;

  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  v6 = strlen(__s);
  if (v6)
  {
    v7 = v6;
    *(_QWORD *)this = a3;
    re::DynamicString::setCapacity(this, v6 + 1);
    re::DynamicString::assign(this, __s, v7);
  }
  else
  {
    *(_QWORD *)this = a3;
    re::DynamicString::setCapacity(this, 0);
  }
  return this;
}

void *re::DynamicString::assign(re::DynamicString *this, const char *__src, size_t __len)
{
  uint64_t v6;
  size_t v7;
  char *v8;
  void *result;
  char *v10;
  uint64_t v11;

  v6 = *((_QWORD *)this + 1);
  if ((v6 & 1) != 0)
    v7 = *((_QWORD *)this + 3);
  else
    v7 = 23;
  if (v7 <= __len)
  {
    re::DynamicString::growCapacity(this, __len + 1);
    v6 = *((_QWORD *)this + 1);
  }
  if ((v6 & 1) != 0)
    v8 = (char *)*((_QWORD *)this + 2);
  else
    v8 = (char *)this + 9;
  result = memmove(v8, __src, __len);
  if ((*((_BYTE *)this + 8) & 1) != 0)
    v10 = (char *)*((_QWORD *)this + 2);
  else
    v10 = (char *)this + 9;
  v10[__len] = 0;
  v11 = *((_QWORD *)this + 1);
  if ((v11 & 1) != 0)
    *((_QWORD *)this + 1) = (2 * __len) | 1;
  else
    *((_BYTE *)this + 8) = v11 & 1 | (2 * __len);
  return result;
}

re::DynamicString *re::DynamicString::DynamicString(re::DynamicString *this, const char *a2, size_t a3, re::Allocator *a4)
{
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  if (a3)
  {
    *(_QWORD *)this = a4;
    re::DynamicString::setCapacity(this, a3 + 1);
    re::DynamicString::assign(this, a2, a3);
  }
  else
  {
    *(_QWORD *)this = a4;
    re::DynamicString::setCapacity(this, 0);
  }
  return this;
}

re::DynamicString *re::DynamicString::DynamicString(re::DynamicString *this, const re::DynamicString *a2)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t *v6;

  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  v4 = *((_QWORD *)a2 + 1);
  if ((v4 & 1) != 0)
    v5 = v4 >> 1;
  else
    v5 = v4 >> 1;
  if (v5)
  {
    *(_QWORD *)this = *(_QWORD *)a2;
    re::DynamicString::setCapacity(this, v5 + 1);
    re::DynamicString::copy(this, a2);
  }
  else
  {
    v6 = *(uint64_t **)a2;
    if (!*(_QWORD *)a2)
    {
    }
    *(_QWORD *)this = v6;
    re::DynamicString::setCapacity(this, 0);
  }
  return this;
}

_QWORD *re::DynamicString::copy(_QWORD *this, const re::DynamicString *a2)
{
  _QWORD *v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v7;
  _BYTE *v8;
  void *v9;
  unint64_t v10;
  char *v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v2 = this;
  v3 = *((_QWORD *)a2 + 1);
  v4 = v3 >> 1;
  if ((v3 & 1) == 0)
    v4 = v3 >> 1;
  v5 = this[1];
  if (v4)
  {
    if ((v5 & 1) != 0)
      v7 = this[3];
    else
      v7 = 23;
    if (v4 >= v7)
    {
      re::DynamicString::setCapacity(this, v4 + 1);
      v5 = v2[1];
    }
    if ((v5 & 1) != 0)
      v9 = (void *)v2[2];
    else
      v9 = (char *)v2 + 9;
    v10 = *((_QWORD *)a2 + 1);
    if ((v10 & 1) != 0)
      v11 = (char *)*((_QWORD *)a2 + 2);
    else
      v11 = (char *)a2 + 9;
    v12 = v10 >> 1;
    v13 = v10 >> 1;
    if ((*((_QWORD *)a2 + 1) & 1) != 0)
      v13 = v12;
    this = memmove(v9, v11, v13 + 1);
    v14 = v2[1];
    if ((v14 & 1) != 0)
    {
      v15 = *((_QWORD *)a2 + 1);
      v16 = 254;
      if ((v15 & 1) != 0)
        v16 = -2;
      v2[1] = v16 & v15 | 1;
    }
    else
    {
      *((_BYTE *)v2 + 8) = *((_BYTE *)a2 + 8) & 0xFE | v14 & 1;
    }
  }
  else
  {
    if ((v5 & 1) != 0)
    {
      this[1] = 1;
      v8 = (_BYTE *)this[2];
    }
    else
    {
      *((_BYTE *)this + 8) = v5 & 1;
      v8 = (char *)this + 9;
    }
    *v8 = 0;
  }
  return this;
}

re::DynamicString *re::DynamicString::operator=(re::DynamicString *this, uint64_t a2)
{
  size_t v3;
  uint64_t v5;
  _BYTE *v6;

  v3 = *(_QWORD *)(a2 + 8);
  if (v3)
  {
    if (!*(_QWORD *)this)
    {
      re::DynamicString::setCapacity(this, v3 + 1);
    }
    re::DynamicString::assign(this, *(const char **)a2, v3);
  }
  else
  {
    v5 = *((_QWORD *)this + 1);
    if ((v5 & 1) != 0)
    {
      *((_QWORD *)this + 1) = 1;
      v6 = (_BYTE *)*((_QWORD *)this + 2);
    }
    else
    {
      *((_BYTE *)this + 8) = v5 & 1;
      v6 = (char *)this + 9;
    }
    *v6 = 0;
  }
  return this;
}

re::DynamicString *re::DynamicString::DynamicString(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  size_t v6;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  v5 = *(_QWORD *)(a2 + 8);
  if (v5)
    v6 = v5 + 1;
  else
    v6 = 0;
  *(_QWORD *)a1 = a3;
  re::DynamicString::setCapacity((_QWORD *)a1, v6);
  return re::DynamicString::operator=((re::DynamicString *)a1, a2);
}

_QWORD *re::DynamicString::setCapacity(_QWORD *this, size_t __n)
{
  _QWORD *v3;
  unint64_t v4;
  int v5;
  uint64_t v6;
  size_t v7;
  const void *v8;
  unint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  unint64_t v12;
  unint64_t v13;
  const void *v14;
  uint64_t v15;

  v3 = this;
  v4 = this[1];
  if (__n <= 0x17)
  {
    if ((v4 & 1) == 0)
      return this;
    goto LABEL_6;
  }
  if ((v4 & 1) != 0)
  {
LABEL_6:
    v5 = 0;
    v6 = this[3];
    goto LABEL_7;
  }
  v5 = 1;
  v6 = 23;
LABEL_7:
  if (v6 != __n)
  {
    v7 = v5 ? v4 >> 1 : v4 >> 1;
    if (v7 < __n)
    {
      if (__n > 0x16)
      {
        this = (_QWORD *)(*(uint64_t (**)(void))(*(_QWORD *)*this + 32))();
        if (!this)
        {
          re::internal::assertLog((re::internal *)4, v10, "assertion failure: '%s' (%s:line %i) Out of memory.", "newBuffer", "setCapacity", 455);
          this = (_QWORD *)_os_crash();
          __break(1u);
          return this;
        }
        v11 = this;
        *(_BYTE *)this = 0;
        v12 = v3[1];
        v13 = v12 >> 1;
        if ((v12 & 1) == 0)
          v13 = v12 >> 1;
        if (v13)
        {
          if ((v12 & 1) != 0)
            v14 = (const void *)v3[2];
          else
            v14 = (char *)v3 + 9;
          this = memcpy(this, v14, v13 + 1);
          v12 = v3[1];
        }
        if ((v12 & 1) != 0)
        {
          this = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v3 + 40))(*v3, v3[2]);
          v15 = v3[1];
        }
        else
        {
          v15 = v12 & 0xFE;
        }
        v3[2] = v11;
        v3[3] = __n;
        v9 = v15 | 1;
      }
      else
      {
        v8 = (const void *)this[2];
        *((_BYTE *)this + 8) = v4;
        memcpy((char *)this + 9, v8, __n);
        this = (_QWORD *)(*(uint64_t (**)(_QWORD, const void *))(*(_QWORD *)*v3 + 40))(*v3, v8);
        v9 = v3[1] & 0xFFFFFFFFFFFFFFFELL;
      }
      v3[1] = v9;
    }
  }
  return this;
}

re::DynamicString *re::DynamicString::operator=(re::DynamicString *this, re::DynamicString *a2)
{
  uint64_t v4;
  uint64_t v5;
  _BYTE *v6;
  unint64_t v7;
  unint64_t v8;

  if (this == a2)
    return this;
  v4 = *(_QWORD *)a2;
  if (!*(_QWORD *)this)
  {
    if (!v4)
      return this;
    v7 = *((_QWORD *)a2 + 1);
    if ((v7 & 1) != 0)
      v8 = v7 >> 1;
    else
      v8 = v7 >> 1;
    *(_QWORD *)this = v4;
    re::DynamicString::setCapacity(this, v8 + 1);
LABEL_11:
    re::DynamicString::copy(this, a2);
    return this;
  }
  if (v4)
    goto LABEL_11;
  v5 = *((_QWORD *)this + 1);
  if ((v5 & 1) != 0)
  {
    *((_QWORD *)this + 1) = 1;
    v6 = (_BYTE *)*((_QWORD *)this + 2);
  }
  else
  {
    *((_BYTE *)this + 8) = v5 & 1;
    v6 = (char *)this + 9;
  }
  *v6 = 0;
  return this;
}

{
  uint64_t v3;
  uint64_t v4;
  BOOL v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _BYTE *v11;

  if (this != a2)
  {
    v3 = *(_QWORD *)this;
    v4 = *(_QWORD *)a2;
    if (*(_QWORD *)this)
      v5 = v3 == v4;
    else
      v5 = 1;
    if (v5)
    {
      *(_QWORD *)this = v4;
      *(_QWORD *)a2 = v3;
      v6 = *((_QWORD *)this + 3);
      *((_QWORD *)this + 3) = *((_QWORD *)a2 + 3);
      *((_QWORD *)a2 + 3) = v6;
      v8 = *((_QWORD *)this + 1);
      v7 = *((_QWORD *)this + 2);
      v9 = *((_QWORD *)a2 + 2);
      *((_QWORD *)this + 1) = *((_QWORD *)a2 + 1);
      *((_QWORD *)this + 2) = v9;
      *((_QWORD *)a2 + 1) = v8;
      *((_QWORD *)a2 + 2) = v7;
    }
    else if (v4)
    {
      re::DynamicString::copy(this, a2);
    }
    else
    {
      v10 = *((_QWORD *)this + 1);
      if ((v10 & 1) != 0)
      {
        *((_QWORD *)this + 1) = 1;
        v11 = (_BYTE *)*((_QWORD *)this + 2);
      }
      else
      {
        *((_BYTE *)this + 8) = v10 & 1;
        v11 = (char *)this + 9;
      }
      *v11 = 0;
    }
  }
  return this;
}

re::DynamicString *re::DynamicString::operator=(re::DynamicString *a1, char *__s)
{
  _QWORD v4[2];

  v4[0] = __s;
  v4[1] = strlen(__s);
  return re::DynamicString::operator=(a1, (uint64_t)v4);
}

void re::DynamicString::~DynamicString(re::DynamicString *this)
{
  uint64_t v2;

  v2 = *(_QWORD *)this;
  if (v2)
  {
    if ((*((_BYTE *)this + 8) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *((_QWORD *)this + 2));
    *(_OWORD *)this = 0u;
    *((_OWORD *)this + 1) = 0u;
  }
}

uint64_t re::DynamicString::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t result;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = v2 >> 1;
  if ((v2 & 1) == 0)
    v3 = v2 >> 1;
  if (v3 < a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, length = %zu", "index <= size()", "operator[]", 180, a2, v3);
    result = _os_crash();
    __break(1u);
  }
  else
  {
    if ((v2 & 1) != 0)
      v4 = *(_QWORD *)(a1 + 16);
    else
      v4 = a1 + 9;
    return v4 + a2;
  }
  return result;
}

{
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t result;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = v2 >> 1;
  if ((v2 & 1) == 0)
    v3 = v2 >> 1;
  if (v3 < a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, length = %zu", "index <= size()", "operator[]", 188, a2, v3);
    result = _os_crash();
    __break(1u);
  }
  else
  {
    if ((v2 & 1) != 0)
      v4 = *(_QWORD *)(a1 + 16);
    else
      v4 = a1 + 9;
    return v4 + a2;
  }
  return result;
}

BOOL re::DynamicString::operator==(uint64_t a1, uint64_t a2)
{
  const char *v2;
  const char *v3;

  if ((*(_BYTE *)(a1 + 8) & 1) != 0)
    v2 = *(const char **)(a1 + 16);
  else
    v2 = (const char *)(a1 + 9);
  if ((*(_QWORD *)(a2 + 8) & 1) != 0)
    v3 = *(const char **)(a2 + 16);
  else
    v3 = (const char *)(a2 + 9);
  return strcmp(v2, v3) == 0;
}

BOOL re::DynamicString::operator!=(uint64_t a1, uint64_t a2)
{
  const char *v2;
  const char *v3;

  if ((*(_BYTE *)(a1 + 8) & 1) != 0)
    v2 = *(const char **)(a1 + 16);
  else
    v2 = (const char *)(a1 + 9);
  if ((*(_QWORD *)(a2 + 8) & 1) != 0)
    v3 = *(const char **)(a2 + 16);
  else
    v3 = (const char *)(a2 + 9);
  return strcmp(v2, v3) != 0;
}

uint64_t re::DynamicString::operator<(uint64_t a1, uint64_t a2)
{
  const char *v2;
  const char *v3;

  if ((*(_BYTE *)(a1 + 8) & 1) != 0)
    v2 = *(const char **)(a1 + 16);
  else
    v2 = (const char *)(a1 + 9);
  if ((*(_QWORD *)(a2 + 8) & 1) != 0)
    v3 = *(const char **)(a2 + 16);
  else
    v3 = (const char *)(a2 + 9);
  return strcmp(v2, v3) >> 31;
}

void *re::DynamicString::append(re::DynamicString *this, const char *__src, size_t __len)
{
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  unint64_t v11;
  void *result;
  uint64_t v13;
  size_t v14;
  char *v15;
  size_t v16;

  v6 = *((_QWORD *)this + 1);
  v7 = v6 >> 1;
  if ((v6 & 1) == 0)
    v7 = v6 >> 1;
  v8 = v7 + __len;
  if ((v6 & 1) != 0)
    v9 = *((_QWORD *)this + 3);
  else
    v9 = 23;
  if (v8 >= v9)
  {
    re::DynamicString::growCapacity(this, v8 + 1);
    v6 = *((_QWORD *)this + 1);
  }
  if ((v6 & 1) != 0)
    v10 = (char *)*((_QWORD *)this + 2);
  else
    v10 = (char *)this + 9;
  if ((v6 & 1) != 0)
    v11 = v6 >> 1;
  else
    v11 = v6 >> 1;
  result = memmove(&v10[v11], __src, __len);
  v13 = *((_QWORD *)this + 1);
  if ((v13 & 1) != 0)
  {
    v14 = v13 + 2 * __len;
    *((_QWORD *)this + 1) = v14;
    if ((v14 & 1) != 0)
      goto LABEL_16;
  }
  else
  {
    *((_BYTE *)this + 8) = v13 + 2 * __len;
    v14 = *((_QWORD *)this + 1);
    if ((v14 & 1) != 0)
    {
LABEL_16:
      v15 = (char *)*((_QWORD *)this + 2);
      goto LABEL_19;
    }
  }
  v15 = (char *)this + 9;
LABEL_19:
  if ((v14 & 1) != 0)
    v16 = v14 >> 1;
  else
    v16 = v14 >> 1;
  v15[v16] = 0;
  return result;
}

void *re::DynamicString::operator+@<X0>(re::DynamicString *a1@<X0>, uint64_t a2@<X1>, re::DynamicString *a3@<X8>)
{
  re::DynamicString *v4;
  unint64_t v5;
  const char *v6;
  size_t v7;
  size_t v8;
  size_t v9;

  v4 = re::DynamicString::DynamicString(a3, a1);
  v5 = *(_QWORD *)(a2 + 8);
  if ((v5 & 1) != 0)
    v6 = *(const char **)(a2 + 16);
  else
    v6 = (const char *)(a2 + 9);
  v7 = v5 >> 1;
  v8 = v5 >> 1;
  if ((*(_QWORD *)(a2 + 8) & 1) != 0)
    v9 = v7;
  else
    v9 = v8;
  return re::DynamicString::append(v4, v6, v9);
}

void *re::DynamicString::operator+@<X0>(re::DynamicString *a1@<X0>, const char *a2@<X1>, re::DynamicString *a3@<X8>)
{
  size_t v5;

  re::DynamicString::DynamicString(a3, a1);
  v5 = strlen(a2);
  return re::DynamicString::append(a3, a2, v5);
}

uint64_t re::DynamicString::compare(re::DynamicString *this, const re::DynamicString *a2)
{
  const char *v2;
  const char *v3;

  if ((*((_BYTE *)this + 8) & 1) != 0)
    v2 = (const char *)*((_QWORD *)this + 2);
  else
    v2 = (char *)this + 9;
  if ((*((_QWORD *)a2 + 1) & 1) != 0)
    v3 = (const char *)*((_QWORD *)a2 + 2);
  else
    v3 = (char *)a2 + 9;
  return strcmp(v2, v3);
}

_QWORD *re::DynamicString::growCapacity(_QWORD *this, size_t a2)
{
  unint64_t v2;
  size_t v3;

  if ((this[1] & 1) != 0)
  {
    v3 = this[3];
    if (v3 >= a2)
      return this;
    v2 = 2 * v3;
  }
  else
  {
    if (a2 <= 0x17)
      return this;
    v2 = 64;
  }
  if (v2 > a2)
    a2 = v2;
  return re::DynamicString::setCapacity(this, a2);
}

uint64_t re::DynamicString::appendf(re::DynamicString *this, const char *a2, ...)
{
  va_list va;

  va_start(va, a2);
  return re::DynamicString::vappendf(this, a2, va);
}

uint64_t re::DynamicString::vappendf(re::DynamicString *this, const char *__format, va_list a3)
{
  unint64_t v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t result;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  char *v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;

  v5 = *((_QWORD *)this + 1);
  if ((v5 & 1) != 0)
  {
    v6 = v5 >> 1;
    v8 = *((_QWORD *)this + 3);
    v7 = (char *)(*((_QWORD *)this + 2) + (v5 >> 1));
  }
  else
  {
    v6 = v5 >> 1;
    v7 = (char *)this + v6 + 9;
    v8 = 23;
  }
  result = vsnprintf(v7, v8 - v6, __format, a3);
  v10 = *((_QWORD *)this + 1);
  if ((result & 0x80000000) == 0)
  {
    v11 = v10 >> 1;
    v12 = v10 >> 1;
    if ((v10 & 1) != 0)
      v12 = v10 >> 1;
    v13 = v12 + result;
    if ((v10 & 1) != 0)
    {
      if (v13 >= *((_QWORD *)this + 3))
      {
        v14 = (char *)*((_QWORD *)this + 2);
        if (!v14)
        {
LABEL_16:
          re::DynamicString::growCapacity(this, result + v11 + 1);
          v17 = *((_QWORD *)this + 1);
          if ((v17 & 1) != 0)
          {
            v18 = v17 >> 1;
            v20 = *((_QWORD *)this + 3);
            v19 = (char *)(*((_QWORD *)this + 2) + (v17 >> 1));
          }
          else
          {
            v18 = v17 >> 1;
            v19 = (char *)this + v18 + 9;
            v20 = 23;
          }
          result = vsnprintf(v19, v20 - v18, __format, a3);
          goto LABEL_25;
        }
LABEL_14:
        v14[v12] = 0;
        v16 = *((_QWORD *)this + 1);
        v11 = v16 >> 1;
        if ((v16 & 1) == 0)
          v11 = v16 >> 1;
        goto LABEL_16;
      }
    }
    else if (v13 >= 0x17)
    {
      v14 = (char *)this + 9;
      goto LABEL_14;
    }
LABEL_25:
    v22 = *((_QWORD *)this + 1);
    if ((v22 & 1) != 0)
      *((_QWORD *)this + 1) = v22 + 2 * (int)result;
    else
      *((_BYTE *)this + 8) = v22 + 2 * result;
    return result;
  }
  if ((v10 & 1) != 0)
  {
    v15 = (char *)*((_QWORD *)this + 2);
    if (!v15)
      return result;
  }
  else
  {
    v15 = (char *)this + 9;
  }
  if ((v10 & 1) != 0)
    v21 = v10 >> 1;
  else
    v21 = v10 >> 1;
  v15[v21] = 0;
  return result;
}

uint64_t re::DynamicString::assignf(re::DynamicString *this, const char *a2, ...)
{
  va_list va;

  va_start(va, a2);
  return re::DynamicString::vassignf(this, a2, va);
}

uint64_t re::DynamicString::vassignf(re::DynamicString *this, const char *__format, va_list a3)
{
  uint64_t v3;
  _BYTE *v4;

  v3 = *((_QWORD *)this + 1);
  if ((v3 & 1) != 0)
  {
    *((_QWORD *)this + 1) = 1;
    v4 = (_BYTE *)*((_QWORD *)this + 2);
  }
  else
  {
    *((_BYTE *)this + 8) = v3 & 1;
    v4 = (char *)this + 9;
  }
  *v4 = 0;
  return re::DynamicString::vappendf(this, __format, a3);
}

_QWORD *re::DynamicString::resize(_QWORD *this, unint64_t a2, int a3)
{
  unint64_t v3;
  unint64_t v4;
  _QWORD *v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  char *v11;
  uint64_t v12;

  v3 = this[1];
  if ((v3 & 1) != 0)
    v4 = v3 >> 1;
  else
    v4 = v3 >> 1;
  if (v4 != a2)
  {
    v7 = this;
    this = re::DynamicString::growCapacity(this, a2 + 1);
    v8 = v7[1];
    v9 = v8 >> 1;
    if ((v8 & 1) == 0)
      v9 = v8 >> 1;
    if (a2 > v9)
    {
      if ((v8 & 1) != 0)
        v10 = (char *)v7[2];
      else
        v10 = (char *)v7 + 9;
      this = memset(&v10[v9], a3, a2 - v9);
      v8 = v7[1];
    }
    if ((v8 & 1) != 0)
      v11 = (char *)v7[2];
    else
      v11 = (char *)v7 + 9;
    v11[a2] = 0;
    v12 = v7[1];
    if ((v12 & 1) != 0)
      v7[1] = (2 * a2) | 1;
    else
      *((_BYTE *)v7 + 8) = v12 & 1 | (2 * a2);
  }
  return this;
}

_QWORD *re::DynamicString::trimExcess(_QWORD *this)
{
  unint64_t v1;
  _QWORD *v2;

  v2 = this + 1;
  v1 = this[1];
  if ((v1 & 1) != 0)
  {
    if (v1 > 1)
    {
      return re::DynamicString::setCapacity(this, (v1 >> 1) + 1);
    }
    else
    {
      this = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*this + 40))(*this, this[2]);
      *v2 = 0;
      v2[1] = 0;
      v2[2] = 0;
    }
  }
  return this;
}

uint64_t re::DynamicString::insert(re::DynamicString *this, unint64_t a2, uint64_t a3, uint64_t __c)
{
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  int v9;
  size_t v12;
  unint64_t v13;
  char *v14;
  unint64_t v15;
  char *v16;
  uint64_t result;
  unint64_t v18;
  char *v19;
  unint64_t v20;

  v5 = *((_QWORD *)this + 1);
  v6 = v5 >> 1;
  v7 = v5 >> 1;
  if ((v5 & 1) != 0)
    v8 = v5 >> 1;
  else
    v8 = v5 >> 1;
  if (v8 < a2)
  {
    re::internal::assertLog((re::internal *)6, a2, a3, __c, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index <= size()", "insert", 529, a2, v8);
    result = _os_crash();
    __break(1u);
  }
  else
  {
    v9 = __c;
    v12 = a3 + v8 + 1;
    if ((v5 & 1) != 0)
      v13 = *((_QWORD *)this + 3);
    else
      v13 = 23;
    if (v12 >= v13)
    {
      re::DynamicString::growCapacity(this, v12);
      v5 = *((_QWORD *)this + 1);
      v6 = v5 >> 1;
      v7 = v5 >> 1;
    }
    if ((v5 & 1) == 0)
      v6 = v7;
    if (v6 != a2)
    {
      if ((v5 & 1) != 0)
        v14 = (char *)*((_QWORD *)this + 2);
      else
        v14 = (char *)this + 9;
      memmove(&v14[a2 + a3], &v14[a2], v6 - a2);
      v5 = *((_QWORD *)this + 1);
    }
    if ((v5 & 1) != 0)
    {
      v15 = v5 + 2 * a3;
      *((_QWORD *)this + 1) = v15;
    }
    else
    {
      *((_BYTE *)this + 8) = v5 + 2 * a3;
      v15 = *((_QWORD *)this + 1);
    }
    if ((v15 & 1) != 0)
      v16 = (char *)*((_QWORD *)this + 2);
    else
      v16 = (char *)this + 9;
    result = (uint64_t)memset(&v16[a2], v9, a3 + a2);
    v18 = *((_QWORD *)this + 1);
    if ((v18 & 1) != 0)
      v19 = (char *)*((_QWORD *)this + 2);
    else
      v19 = (char *)this + 9;
    if ((v18 & 1) != 0)
      v20 = v18 >> 1;
    else
      v20 = v18 >> 1;
    v19[v20] = 0;
  }
  return result;
}

uint64_t re::DynamicString::insert(re::DynamicString *this, unint64_t a2, const char *__src, size_t __len)
{
  unint64_t v5;
  unint64_t v6;
  size_t v10;
  unint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  uint64_t result;
  uint64_t v16;
  size_t v17;
  char *v18;
  size_t v19;

  v5 = *((_QWORD *)this + 1);
  v6 = v5 >> 1;
  if ((v5 & 1) == 0)
    v6 = v5 >> 1;
  if (v6 < a2)
  {
    re::internal::assertLog((re::internal *)6, a2, __src, __len, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index <= size()", "insert", 561, a2, v6);
    _os_crash();
    __break(1u);
    goto LABEL_28;
  }
  v10 = __len + v6 + 1;
  if ((v5 & 1) != 0)
    v11 = *((_QWORD *)this + 3);
  else
    v11 = 23;
  if (v10 >= v11)
  {
    re::DynamicString::growCapacity(this, v10);
    v5 = *((_QWORD *)this + 1);
  }
  if ((v5 & 1) != 0)
  {
    v13 = (char *)*((_QWORD *)this + 2);
    if (v13)
    {
      v12 = v5 >> 1;
      if (v5 >> 1 == a2)
        goto LABEL_15;
      goto LABEL_14;
    }
LABEL_28:
    re::internal::assertLog((re::internal *)4, v10, "assertion failure: '%s' (%s:line %i) Unexpected null buffer after growCapacity", "data() != nullptr", "insert", 567);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v12 = v5 >> 1;
  if (v12 == a2)
    goto LABEL_15;
  v13 = (char *)this + 9;
LABEL_14:
  memmove(&v13[a2 + __len], &v13[a2], v12 - a2);
  v5 = *((_QWORD *)this + 1);
LABEL_15:
  if ((v5 & 1) != 0)
    v14 = (char *)*((_QWORD *)this + 2);
  else
    v14 = (char *)this + 9;
  result = (uint64_t)memmove(&v14[a2], __src, __len);
  v16 = *((_QWORD *)this + 1);
  if ((v16 & 1) != 0)
  {
    v17 = v16 + 2 * __len;
    *((_QWORD *)this + 1) = v17;
    if ((v17 & 1) != 0)
      goto LABEL_20;
LABEL_22:
    v18 = (char *)this + 9;
    goto LABEL_23;
  }
  *((_BYTE *)this + 8) = v16 + 2 * __len;
  v17 = *((_QWORD *)this + 1);
  if ((v17 & 1) == 0)
    goto LABEL_22;
LABEL_20:
  v18 = (char *)*((_QWORD *)this + 2);
LABEL_23:
  if ((v17 & 1) != 0)
    v19 = v17 >> 1;
  else
    v19 = v17 >> 1;
  v18[v19] = 0;
  return result;
}

uint64_t re::DynamicString::removeAt(re::DynamicString *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  char *v5;
  char *v6;
  uint64_t result;

  v2 = *((_QWORD *)this + 1);
  if ((v2 & 1) != 0)
    v3 = v2 >> 1;
  else
    v3 = v2 >> 1;
  if (v3 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "removeAt", 590, a2, v3);
    result = _os_crash();
    __break(1u);
  }
  else
  {
    if ((v2 & 1) != 0)
    {
      v5 = (char *)*((_QWORD *)this + 2);
      v6 = &v5[v2 >> 1];
    }
    else
    {
      v5 = (char *)this + 9;
      v6 = (char *)this + (v2 >> 1) + 9;
    }
    result = (uint64_t)&v5[a2];
    if (v6 != &v5[a2])
    {
      result = (uint64_t)memmove((void *)result, (const void *)(result + 1), (size_t)&v6[-result]);
      v2 = *((_QWORD *)this + 1);
    }
    if ((v2 & 1) != 0)
      *((_QWORD *)this + 1) = (v2 | 1) - 2;
    else
      *((_BYTE *)this + 8) = v2 - 2;
  }
  return result;
}

void *re::DynamicString::substr@<X0>(re::DynamicString *this@<X0>, unint64_t a2@<X1>, size_t a3@<X2>, re::DynamicString *a4@<X8>)
{
  unint64_t v6;
  unint64_t v7;
  size_t v9;
  char *v10;
  void *result;

  v6 = *((_QWORD *)this + 1);
  if ((v6 & 1) != 0)
    v7 = v6 >> 1;
  else
    v7 = v6 >> 1;
  if (v7 < a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index <= size()", "substr", 610, a2, v7);
    result = (void *)_os_crash();
    __break(1u);
  }
  else
  {
    if (v7 - a2 >= a3)
      v9 = a3;
    else
      v9 = v7 - a2;
    *((_QWORD *)a4 + 1) = 0;
    *((_QWORD *)a4 + 2) = 0;
    *((_QWORD *)a4 + 3) = 0;
    re::DynamicString::setCapacity(a4, 0);
    *(_QWORD *)a4 = *(_QWORD *)this;
    re::DynamicString::setCapacity(a4, v9);
    if ((*((_BYTE *)this + 8) & 1) != 0)
      v10 = (char *)*((_QWORD *)this + 2);
    else
      v10 = (char *)this + 9;
    return re::DynamicString::assign(a4, &v10[a2], v9);
  }
  return result;
}

char *re::DynamicString::find@<X0>(re::DynamicString *this@<X0>, char *a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v6;
  unint64_t v7;
  char *v9;
  char *v10;
  char *result;
  char *v12;

  v6 = *((_QWORD *)this + 1);
  v7 = v6 >> 1;
  if ((v6 & 1) == 0)
    v7 = v6 >> 1;
  if (v7 < a4)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) offset out of range. offset = %zu, size = %zu", "offset <= this->size()", "find", 631, a4, v7);
    result = (char *)_os_crash();
    __break(1u);
  }
  else
  {
    if ((v6 & 1) != 0)
      v9 = (char *)*((_QWORD *)this + 2);
    else
      v9 = (char *)this + 9;
    v10 = &v9[v7];
    result = (char *)std::__search_impl[abi:nn180100]<char const*,char const*,char const*,char const*,std::__equal_to,std::__identity,std::__identity>((unsigned __int8 *)&v9[a4], (uint64_t)&v9[v7], (unsigned __int8 *)a2, (unsigned __int8 *)&a2[a3]);
    if (v10 == result)
    {
      *(_BYTE *)a5 = 0;
    }
    else
    {
      if ((*((_BYTE *)this + 8) & 1) != 0)
        v12 = (char *)*((_QWORD *)this + 2);
      else
        v12 = (char *)this + 9;
      *(_BYTE *)a5 = 1;
      *(_QWORD *)(a5 + 8) = result - v12;
    }
  }
  return result;
}

uint64_t re::DynamicString::rfind@<X0>(uint64_t this@<X0>, uint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  unint64_t v3;
  unint64_t v4;

  v3 = *(_QWORD *)(this + 8);
  if ((v3 & 1) != 0)
    v4 = v3 >> 1;
  else
    v4 = v3 >> 1;
  if (v4)
    return re::DynamicString::rfind(this, a2, v4 - 1, (uint64_t)a3);
  *a3 = 0;
  return this;
}

uint64_t re::DynamicString::rfind@<X0>(uint64_t this@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v4 = *(_QWORD *)(this + 8);
  v5 = v4 >> 1;
  if ((v4 & 1) == 0)
    v5 = v4 >> 1;
  if (v5 <= a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) offset out of range. offset = %zu, size = %zu", "offset < size()", "rfind", 667, a3, v5);
    this = _os_crash();
    __break(1u);
  }
  else
  {
    if ((v4 & 1) != 0)
      v6 = *(_QWORD *)(this + 16);
    else
      v6 = this + 9;
    v7 = this + 9;
    v8 = a3 + v6;
    v9 = -(uint64_t)(a3 + v6);
    v10 = v8 + 1;
    while (*(unsigned __int8 *)(v10 - 1) != a2)
    {
      v11 = this + 9;
      if ((v4 & 1) != 0)
        v11 = *(_QWORD *)(this + 16);
      ++v9;
      if (--v10 == v11)
      {
        *(_BYTE *)a4 = 0;
        return this;
      }
    }
    if ((v4 & 1) != 0)
      v7 = *(_QWORD *)(this + 16);
    *(_BYTE *)a4 = 1;
    *(_QWORD *)(a4 + 8) = -(v7 + v9);
  }
  return this;
}

uint64_t re::DynamicString::rfind@<X0>(uint64_t this@<X0>, const char *__s@<X1>, _BYTE *a3@<X8>)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v7;
  size_t v8;

  v4 = *(_QWORD *)(this + 8);
  if ((v4 & 1) != 0)
    v5 = v4 >> 1;
  else
    v5 = v4 >> 1;
  if (v5)
  {
    v7 = this;
    v8 = strlen(__s);
    return re::DynamicString::rfind(v7, __s, v8, v5 - 1, (uint64_t)a3);
  }
  else
  {
    *a3 = 0;
  }
  return this;
}

uint64_t re::DynamicString::rfind@<X0>(uint64_t this@<X0>, const char *a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v5;
  unint64_t v6;
  unsigned __int8 *v7;
  unsigned __int8 *v8;
  uint64_t v9;
  const char *v10;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  unsigned __int8 *v15;
  uint64_t v17;
  int v18;
  int v19;
  uint64_t v20;

  v5 = *(_QWORD *)(this + 8);
  v6 = v5 >> 1;
  if ((v5 & 1) == 0)
    v6 = v5 >> 1;
  if (v6 <= a4)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) offset out of range. offset = %zu, size = %zu", "offset < this->size()", "rfind", 700, a4, v6);
    this = _os_crash();
    __break(1u);
  }
  else
  {
    if ((v5 & 1) != 0)
    {
      v7 = *(unsigned __int8 **)(this + 16);
      if (!a3)
      {
LABEL_25:
        *(_BYTE *)a5 = 0;
        return this;
      }
    }
    else
    {
      v7 = (unsigned __int8 *)(this + 9);
      if (!a3)
        goto LABEL_25;
    }
    v8 = &v7[a4];
    v9 = (uint64_t)&v7[a4 + 1];
    if (v7 == (unsigned __int8 *)v9)
      goto LABEL_25;
    v12 = *(unsigned __int8 *)a2;
    v10 = a2 + 1;
    v11 = v12;
    v13 = a3 - 1;
    v14 = (uint64_t)&v7[a4 + 1];
    do
    {
      v15 = v7;
      while (*v15 != v11)
      {
        if (v15++ == v8)
          goto LABEL_22;
      }
      v17 = 0;
      while (v13 != v17)
      {
        if (&v15[v17] == v8)
          goto LABEL_22;
        v18 = v15[v17 + 1];
        v19 = v10[v17++];
        if (v18 != v19)
          goto LABEL_21;
      }
      v14 = (uint64_t)v15;
LABEL_21:
      v7 = v15 + 1;
    }
    while (v15 != v8);
LABEL_22:
    if (v14 == v9)
      goto LABEL_25;
    if ((v5 & 1) != 0)
      v20 = *(_QWORD *)(this + 16);
    else
      v20 = this + 9;
    *(_BYTE *)a5 = 1;
    *(_QWORD *)(a5 + 8) = v14 - v20;
  }
  return this;
}

uint64_t re::DynamicString::toLowerCase(uint64_t this)
{
  unint64_t v1;
  char *v2;
  unint64_t v3;

  v1 = *(_QWORD *)(this + 8);
  if ((v1 & 1) != 0)
    v2 = *(char **)(this + 16);
  else
    v2 = (char *)(this + 9);
  if ((v1 & 1) != 0)
    v3 = v1 >> 1;
  else
    v3 = v1 >> 1;
  for (; v3; --v3)
  {
    this = __tolower(*v2);
    *v2++ = this;
  }
  return this;
}

uint64_t re::DynamicString::format@<X0>(re::DynamicString *this@<X0>, re::Allocator *a2@<X1>, re::DynamicString *a3@<X8>, ...)
{
  va_list va;

  va_start(va, a3);
  *((_QWORD *)a3 + 2) = 0;
  *((_QWORD *)a3 + 3) = 0;
  *(_QWORD *)a3 = this;
  *((_QWORD *)a3 + 1) = 0;
  re::DynamicString::setCapacity(a3, 0);
  return re::DynamicString::vassignf(a3, (const char *)a2, va);
}

uint64_t re::DynamicString::format@<X0>(re::DynamicString *this@<X0>, re::DynamicString *a2@<X8>, ...)
{
  va_list va;

  va_start(va, a2);
  *((_QWORD *)a2 + 1) = 0;
  *((_QWORD *)a2 + 2) = 0;
  *((_QWORD *)a2 + 3) = 0;
  re::DynamicString::setCapacity(a2, 0);
  return re::DynamicString::vassignf(a2, (const char *)this, va);
}

__n128 re::internal::`anonymous namespace'::RegexOperationList::parseRegex(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, char *a5, _BYTE *a6)
{
  char *v6;
  unsigned __int8 *v9;
  __n128 result;
  unsigned __int8 *v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  char *v17;
  int v18;
  uint64_t v19;
  int v20;
  BOOL v21;
  uint64_t v22;
  int v23;
  unsigned __int8 *v24;
  int v25;
  __int16 v27;
  __int16 v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  uint64_t v32;
  unint64_t v33;
  unint64_t v34;
  uint64_t v35;
  unint64_t v36;
  unint64_t v37;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  uint64_t v45;
  unint64_t v46;
  unint64_t v47;
  char *v48;
  uint64_t v49;
  BOOL v50;
  int v51;
  int v52;
  int v53;
  unint64_t v54;
  unint64_t v55;
  char *v56;
  int v57;
  unint64_t v58;
  int v59;
  char v60;
  int v61;
  int v62;
  uint64_t v63;
  int v64;
  int v65;
  char *v67;
  int v68;
  unint64_t v69;
  unint64_t v70;
  unint64_t v71;
  uint64_t v72;
  unint64_t v73;
  unint64_t v74;
  uint64_t v75;
  int v76;
  char v77;
  unsigned __int8 *v78;
  int v79;
  uint64_t v80;
  unint64_t v81;
  unint64_t v82;
  unint64_t v83;
  unint64_t v84;
  unint64_t v85;
  uint64_t v86;
  unint64_t v87;
  unint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  char *v94;
  uint64_t v95;
  unint64_t v96;
  _anonymous_namespace_ *v97;
  re::DynamicString *v98;
  _OWORD *v99;
  _anonymous_namespace_ *v100;
  _anonymous_namespace_ *v101;
  _anonymous_namespace_ *v102;
  _anonymous_namespace_ *v103;
  unsigned __int8 *v104;
  _anonymous_namespace_ *v107;
  _anonymous_namespace_ *v109;
  uint64_t v110;
  __int16 v111;
  char v112;
  unsigned __int8 v113;
  __int128 v114;
  _BYTE v115[24];
  unint64_t v116;
  __n128 v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  int v121;
  uint64_t v122;
  char *__endptr[2];
  uint64_t v124;
  __n128 v125;
  unint64_t v126;
  _BYTE v127[24];
  __n128 v128;
  uint64_t v129;
  __n128 v130;
  uint64_t v131;
  int v132;
  uint64_t v133;

  v6 = a4;
  *(_QWORD *)(a2 + 16) = 0;
  ++*(_DWORD *)(a2 + 24);
  if (a4 >= a5)
  {
LABEL_190:
    *(_BYTE *)a1 = 1;
    *(_QWORD *)(a1 + 8) = v6;
    return result;
  }
  v109 = (_anonymous_namespace_ *)(a3 + 320);
  v97 = (_anonymous_namespace_ *)(a3 + 120);
  v107 = (_anonymous_namespace_ *)(a3 + 40);
  v110 = a3 + 240;
  v101 = (_anonymous_namespace_ *)(a3 + 200);
  v102 = (_anonymous_namespace_ *)(a3 + 160);
  v98 = (re::DynamicString *)&v127[16];
  v99 = (_OWORD *)(a1 + 8);
  v103 = (_anonymous_namespace_ *)(a3 + 280);
  v104 = a6 + 1;
  v100 = (_anonymous_namespace_ *)(a3 + 80);
  while (2)
  {
    v117.n128_u8[0] = 0;
    v117.n128_u64[1] = -1;
    v118 = 0;
    v122 = 0;
    v119 = 0;
    v120 = 0;
    v121 = 1;
    if (*v6 != 40)
    {
      v14 = 1;
      v113 = 1;
      *(_QWORD *)&v114 = 0;
      v15 = 1;
      goto LABEL_30;
    }
    v9 = (unsigned __int8 *)(v6 + 1);
    do
    {
      if (v9 == (unsigned __int8 *)a5)
        goto LABEL_29;
      v133 = 0;
      v131 = 0;
      v130 = 0uLL;
      v132 = 0;
      if (v127[0])
      {
        v11 = *(unsigned __int8 **)&v127[8];
        if (!*(_QWORD *)&v127[8])
        {
          v13 = 3;
          goto LABEL_19;
        }
        __endptr[0] = *(char **)(a3 + 336);
        re::DynamicArray<unsigned long>::add(&v118, __endptr);
        v12 = *v11;
        if (v12 == 41)
        {
          v13 = 1;
          v113 = 1;
          *(_QWORD *)&v114 = v11 + 1;
          v9 = v11;
        }
        else
        {
          if (v12 == 124)
            v9 = v11 + 1;
          else
            v9 = v11;
          if (v12 == 124)
            v13 = 2;
          else
            v13 = 3;
        }
      }
      else
      {
        *(_OWORD *)__endptr = *(_OWORD *)&v127[8];
        re::DynamicString::DynamicString((re::DynamicString *)&v124, (const re::DynamicString *)&v128);
        v113 = 0;
        v114 = *(_OWORD *)__endptr;
        *(_QWORD *)v115 = v124;
        v116 = v126;
        result = v125;
        *(__n128 *)&v115[8] = v125;
        v13 = 1;
      }
      if (!v127[0] && v128.n128_u64[0] && (v128.n128_u8[8] & 1) != 0)
        (*(void (**)(unint64_t, uint64_t))(*(_QWORD *)v128.n128_u64[0] + 40))(v128.n128_u64[0], v129);
LABEL_19:
      if (v130.n128_u64[0] && v133)
        (*(void (**)(unint64_t))(*(_QWORD *)v130.n128_u64[0] + 40))(v130.n128_u64[0]);
    }
    while (v13 == 2);
    if (v13 == 3)
    {
LABEL_29:
      re::DynamicString::format((re::DynamicString *)"Regular expression group missing corresponding ')'.", (re::DynamicString *)v127, v97, v98);
      v14 = 0;
      v15 = 0;
      result = *(__n128 *)v127;
      v113 = 0;
      *(_QWORD *)&v114 = 100;
      *((_QWORD *)&v114 + 1) = &re::FoundationErrorCategory(void)::instance;
      *(_OWORD *)v115 = *(_OWORD *)v127;
      *(_QWORD *)&v115[16] = *(_QWORD *)&v127[16];
      v116 = v128.n128_u64[0];
      goto LABEL_30;
    }
    v14 = v113;
    if (v113)
    {
      if ((_QWORD)v114)
      {
        v117.n128_u8[0] = 5;
        v42 = *(_QWORD *)(a3 + 128);
        v43 = *(_QWORD *)(a3 + 136);
        v117.n128_u64[1] = v43;
        if (v43 >= v42)
        {
          v44 = v43 + 1;
          if (v42 < v43 + 1)
          {
            if (*(_QWORD *)v97)
            {
              v45 = 2 * v42;
              v21 = v42 == 0;
              v46 = 8;
              if (!v21)
                v46 = v45;
              if (v46 <= v44)
                v47 = v44;
              else
                v47 = v46;
              re::DynamicArray<re::DynamicArray<unsigned char>>::setCapacity(v97, v47);
            }
            else
            {
              re::DynamicArray<re::DynamicArray<unsigned char>>::setCapacity(v97, v44);
              ++*(_DWORD *)(a3 + 144);
            }
          }
        }
        v15 = 0;
        v91 = *(_QWORD *)(a3 + 152) + 40 * *(_QWORD *)(a3 + 136);
        *(_QWORD *)(v91 + 32) = 0;
        *(_DWORD *)(v91 + 24) = 0;
        *(_QWORD *)(v91 + 8) = 0;
        *(_QWORD *)(v91 + 16) = 0;
        *(_QWORD *)v91 = 0;
        *(_QWORD *)v91 = v118;
        v118 = 0;
        *(_QWORD *)(v91 + 8) = v119;
        v119 = 0;
        v92 = *(_QWORD *)(v91 + 16);
        *(_QWORD *)(v91 + 16) = v120;
        v120 = v92;
        v93 = *(_QWORD *)(v91 + 32);
        *(_QWORD *)(v91 + 32) = v122;
        v122 = v93;
        ++v121;
        ++*(_DWORD *)(v91 + 24);
        ++*(_QWORD *)(a3 + 136);
        ++*(_DWORD *)(a3 + 144);
      }
      else
      {
        v15 = 1;
      }
    }
    else
    {
      v15 = 0;
    }
LABEL_30:
    if (v118 && v122)
      (*(void (**)(void))(*(_QWORD *)v118 + 40))();
    if (v15)
    {
      *(_QWORD *)v127 = &off_24ED41EE0;
      v129 = 0;
      *(_QWORD *)&v127[16] = 0;
      v128.n128_u64[0] = 0;
      *(_QWORD *)&v127[8] = 0;
      v128.n128_u32[2] = 1;
      v16 = *v6;
      if (v16 == 91)
      {
        v17 = v6 + 1;
        while (v17 != a5)
        {
          v18 = *v17;
          if (v18 == 93)
            goto LABEL_77;
          v130.n128_u8[0] = 0;
          v130.n128_u64[1] = -1;
          __endptr[0] = (char *)&off_24ED41F80;
          if (a5 - v17 >= 2 && v18 == 92)
          {
            LOBYTE(__endptr[1]) = v17[1];
            v17 += 2;
            v130.n128_u8[0] = 2;
            v130.n128_u64[1] = *(_QWORD *)(a3 + 56);
          }
          else
          {
            if ((unint64_t)(a5 - v17) < 3)
              goto LABEL_57;
            v19 = 0;
            do
            {
              v21 = v20 == v18 || v19++ == 8;
            }
            while (!v21);
            if (v20 == v18 || v17[1] != 45)
              goto LABEL_57;
            v22 = 0;
            v24 = (unsigned __int8 *)(v17 + 2);
            v23 = v17[2];
            do
            while (v25 != v23 && v22++ != 8);
            if (v25 == v23)
            {
LABEL_57:
              __endptr[0] = (char *)&off_24ED41FB0;
              LOBYTE(__endptr[1]) = v18;
              ++v17;
              v130.n128_u8[0] = 1;
              v130.n128_u64[1] = *(_QWORD *)(a3 + 16);
            }
            else
            {
              if (v23 >= v18)
                v24 = (unsigned __int8 *)v17;
              v27 = *v24;
              if (v18 <= v23)
                v28 = v17[2];
              else
                v28 = v18;
              v130.n128_u8[0] = 3;
              v29 = *(_QWORD *)(a3 + 88);
              v30 = *(_QWORD *)(a3 + 96);
              v130.n128_u64[1] = v30;
              if (v30 >= v29)
              {
                v31 = v30 + 1;
                if (v29 < v30 + 1)
                {
                  if (*(_QWORD *)v100)
                  {
                    v32 = 2 * v29;
                    v21 = v29 == 0;
                    v33 = 8;
                    if (!v21)
                      v33 = v32;
                    if (v33 <= v31)
                      v34 = v31;
                    else
                      v34 = v33;
                  }
                  else
                  {
                    ++*(_DWORD *)(a3 + 104);
                  }
                }
              }
              v17 += 3;
              v35 = *(_QWORD *)(a3 + 112) + 16 * *(_QWORD *)(a3 + 96);
              *(_QWORD *)v35 = &off_24ED41F20;
              *(_WORD *)(v35 + 8) = v27 | (v28 << 8);
              ++*(_QWORD *)(a3 + 96);
              ++*(_DWORD *)(a3 + 104);
            }
          }
          __endptr[0] = *(char **)(a3 + 256);
          re::DynamicArray<unsigned long>::add(&v127[8], __endptr);
        }
        v17 = a5;
        if (*a5 != 93)
        {
          re::DynamicString::format((re::DynamicString *)"Character set missing corresponding ']'.", (re::DynamicString *)__endptr);
          v14 = 0;
          result = *(__n128 *)__endptr;
          v113 = 0;
          *(_QWORD *)&v114 = 100;
          *((_QWORD *)&v114 + 1) = &re::FoundationErrorCategory(void)::instance;
          *(_OWORD *)v115 = *(_OWORD *)__endptr;
          *(_QWORD *)&v115[16] = v124;
          v116 = v125.n128_u64[0];
          goto LABEL_95;
        }
LABEL_77:
        v113 = 1;
        *(_QWORD *)&v114 = v17 + 1;
        v117.n128_u8[0] = 6;
        v36 = *(_QWORD *)(a3 + 168);
        v117.n128_u64[1] = *(_QWORD *)(a3 + 176);
        v37 = v117.n128_u64[1] + 1;
        if (v117.n128_u64[1] >= v36 && v36 < v37)
        {
          if (*(_QWORD *)v102)
          {
            v80 = 2 * v36;
            v21 = v36 == 0;
            v81 = 8;
            if (!v21)
              v81 = v80;
            if (v81 <= v37)
              v82 = v117.n128_u64[1] + 1;
            else
              v82 = v81;
          }
          else
          {
            ++*(_DWORD *)(a3 + 184);
          }
        }
        v39 = *(_QWORD *)(a3 + 192) + 48 * *(_QWORD *)(a3 + 176);
        *(_QWORD *)(v39 + 40) = 0;
        *(_DWORD *)(v39 + 32) = 0;
        *(_QWORD *)(v39 + 16) = 0;
        *(_QWORD *)(v39 + 24) = 0;
        *(_QWORD *)v39 = &off_24ED41EE0;
        *(_QWORD *)(v39 + 8) = 0;
        *(_QWORD *)(v39 + 8) = *(_QWORD *)&v127[8];
        *(_QWORD *)&v127[8] = 0;
        *(_QWORD *)(v39 + 16) = *(_QWORD *)&v127[16];
        *(_QWORD *)&v127[16] = 0;
        v40 = *(_QWORD *)(v39 + 24);
        *(_QWORD *)(v39 + 24) = v128.n128_u64[0];
        v128.n128_u64[0] = v40;
        v41 = *(_QWORD *)(v39 + 40);
        *(_QWORD *)(v39 + 40) = v129;
        v129 = v41;
        ++v128.n128_u32[2];
        ++*(_DWORD *)(v39 + 32);
        ++*(_QWORD *)(a3 + 176);
        ++*(_DWORD *)(a3 + 184);
        v14 = 1;
      }
      else
      {
        v14 = 1;
        v113 = 1;
        *(_QWORD *)&v114 = 0;
      }
LABEL_95:
      *(_QWORD *)v127 = &off_24ED41EE0;
      if (*(_QWORD *)&v127[8] && v129)
        (*(void (**)(_QWORD))(**(_QWORD **)&v127[8] + 40))(*(_QWORD *)&v127[8]);
      if (v16 != 91)
      {
        if (v6 == a5)
          goto LABEL_124;
        v59 = *v6;
        switch(v59)
        {
          case '$':
            v60 = 3;
            break;
          case '.':
            v60 = 1;
            break;
          case '^':
            v60 = 2;
            break;
          default:
LABEL_124:
            *(_QWORD *)v127 = &off_24ED41F80;
            if (a5 - v6 >= 2 && *v6 == 92)
            {
              v127[8] = v6[1];
              v113 = 1;
              *(_QWORD *)&v114 = v6 + 2;
              v117.n128_u8[0] = 2;
              v117.n128_u64[1] = *(_QWORD *)(a3 + 56);
            }
            else
            {
              *(_QWORD *)v127 = &off_24ED41FB0;
              if (v6 == a5)
                goto LABEL_190;
              v63 = 0;
              v64 = *v6;
              v127[8] = *v6;
              do
              while (v65 != v64 && v63++ != 8);
              if (v65 == v64)
                goto LABEL_190;
              v113 = 1;
              *(_QWORD *)&v114 = v6 + 1;
              v117.n128_u8[0] = 1;
              v117.n128_u64[1] = *(_QWORD *)(a3 + 16);
            }
LABEL_100:
            v48 = (char *)v114;
            if (!(_QWORD)v114)
              goto LABEL_190;
            v49 = *(_QWORD *)(a3 + 256);
            if ((char *)v114 == a5)
            {
              LODWORD(v54) = 1;
              *(_BYTE *)a1 = 1;
              *(_QWORD *)(a1 + 8) = a5;
              if (!a5)
                goto LABEL_190;
              v50 = 0;
              v52 = 1;
              v6 = a5;
LABEL_150:
              *(_QWORD *)v127 = *(_QWORD *)(a3 + 296);
              re::DynamicArray<unsigned long>::add((_QWORD *)a2, v127);
              v69 = *(_QWORD *)(a3 + 288);
              v70 = *(_QWORD *)(a3 + 296);
              if (v70 >= v69)
              {
                v71 = v70 + 1;
                if (v69 < v70 + 1)
                {
                  if (*(_QWORD *)v103)
                  {
                    v72 = 2 * v69;
                    v21 = v69 == 0;
                    v73 = 8;
                    if (!v21)
                      v73 = v72;
                    if (v73 <= v71)
                      v74 = v71;
                    else
                      v74 = v73;
                    re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity(v103, v74);
                  }
                  else
                  {
                    re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity(v103, v71);
                    ++*(_DWORD *)(a3 + 304);
                  }
                }
              }
              v75 = *(_QWORD *)(a3 + 312) + 24 * *(_QWORD *)(a3 + 296);
              *(_QWORD *)v75 = v49;
              *(_BYTE *)(v75 + 8) = v50;
              *(_BYTE *)(v75 + 11) = v112;
              *(_WORD *)(v75 + 9) = v111;
              *(_DWORD *)(v75 + 12) = v54;
              *(_DWORD *)(v75 + 16) = v52;
              ++*(_QWORD *)(a3 + 296);
              ++*(_DWORD *)(a3 + 304);
              v76 = *a6;
              if (*a6)
              {
                v77 = 0;
                v78 = v104;
                do
                {
                  v77 |= v76 == *v6;
                  v79 = *v78++;
                  v76 = v79;
                }
                while (v79);
                if ((v77 & 1) != 0)
                  goto LABEL_190;
              }
              if (v6 >= a5)
                goto LABEL_190;
              continue;
            }
            v50 = 0;
            v51 = *(char *)v114;
            v52 = 1;
            if (v51 <= 62)
            {
              if (v51 == 42)
              {
                LODWORD(v54) = 0;
                v61 = *(unsigned __int8 *)(v114 + 1);
                v48 = (char *)(v114 + 1);
                v50 = v61 != 63;
                if (v61 == 63)
                  v48 = (char *)(v114 + 2);
              }
              else
              {
                if (v51 != 43)
                {
                  LODWORD(v54) = 1;
                  goto LABEL_149;
                }
                v53 = *(unsigned __int8 *)(v114 + 1);
                v48 = (char *)(v114 + 1);
                v50 = v53 != 63;
                if (v53 == 63)
                  v48 = (char *)(v114 + 2);
                LODWORD(v54) = 1;
              }
              v52 = 0x7FFFFFFF;
LABEL_149:
              *(_BYTE *)a1 = 1;
              *(_QWORD *)(a1 + 8) = v48;
              v6 = v48;
              goto LABEL_150;
            }
            if (v51 == 63)
            {
              LODWORD(v54) = 0;
              v62 = *(unsigned __int8 *)(v114 + 1);
              v48 = (char *)(v114 + 1);
              v50 = v62 != 63;
              if (v62 == 63)
                v48 = (char *)(v114 + 2);
              v52 = 1;
              goto LABEL_149;
            }
            LODWORD(v54) = 1;
            if (v51 != 123)
              goto LABEL_149;
            __endptr[0] = 0;
            v55 = strtol((const char *)(v114 + 1), __endptr, 10);
            if ((v55 & 0x8000000000000000) != 0)
            {
              v94 = "Repetition brace requires valid positive number.";
            }
            else
            {
              v54 = v55;
              if (v55 >= 0xFFFFFFFF)
              {
                v94 = "Repetition brace exceeded maximum match count.";
              }
              else
              {
                v56 = __endptr[0];
                v57 = *__endptr[0];
                if (v57 == 44)
                {
                  v58 = strtol(__endptr[0] + 1, __endptr, 10);
                  if ((v58 & 0x8000000000000000) != 0)
                  {
                    v94 = "Repetition brace maximum requires valid positive number.";
                    goto LABEL_201;
                  }
                  v52 = v58;
                  if (v58 >= 0xFFFFFFFF)
                  {
                    v94 = "Repetition brace maximum exceeded maximum match count.";
                    goto LABEL_201;
                  }
                  if (v58 < v54)
                  {
                    v94 = "Repetition brace maximum must be larger than the minimum.";
                    goto LABEL_201;
                  }
                  v56 = __endptr[0];
                  v57 = *__endptr[0];
                }
                else
                {
                  v52 = v55;
                }
                if (v57 == 125)
                {
                  v68 = v56[1];
                  v67 = v56 + 1;
                  v50 = v68 != 63;
                  if (v68 == 63)
                    v48 = v67 + 1;
                  else
                    v48 = v67;
                  goto LABEL_149;
                }
                v94 = "Repetition brace expected closing '}'.";
              }
            }
LABEL_201:
            re::DynamicString::format((re::DynamicString *)v94, (re::DynamicString *)v127, v97);
            result = *(__n128 *)v127;
            v95 = *(_QWORD *)&v127[16];
            v96 = v128.n128_u64[0];
            *(_BYTE *)a1 = 0;
            *(_QWORD *)(a1 + 8) = 100;
            *(_QWORD *)(a1 + 16) = &re::FoundationErrorCategory(void)::instance;
            *(__n128 *)(a1 + 24) = result;
            *(_QWORD *)(a1 + 40) = v95;
            *(_QWORD *)(a1 + 48) = v96;
            return result;
        }
        v113 = 1;
        *(_QWORD *)&v114 = v6 + 1;
        v117.n128_u8[0] = 4;
        v83 = *(_QWORD *)(a3 + 208);
        v84 = *(_QWORD *)(a3 + 216);
        v117.n128_u64[1] = v84;
        if (v84 >= v83)
        {
          v85 = v84 + 1;
          if (v83 < v84 + 1)
          {
            if (*(_QWORD *)v101)
            {
              v86 = 2 * v83;
              v21 = v83 == 0;
              v87 = 8;
              if (!v21)
                v87 = v86;
              if (v87 <= v85)
                v88 = v85;
              else
                v88 = v87;
            }
            else
            {
              ++*(_DWORD *)(a3 + 224);
            }
          }
        }
        v89 = *(_QWORD *)(a3 + 216);
        v90 = *(_QWORD *)(a3 + 232) + 16 * v89;
        *(_QWORD *)v90 = &off_24ED41F50;
        *(_BYTE *)(v90 + 8) = v60;
        *(_QWORD *)(a3 + 216) = v89 + 1;
        ++*(_DWORD *)(a3 + 224);
        goto LABEL_100;
      }
    }
    break;
  }
  if (v14)
    goto LABEL_100;
  *(_OWORD *)v127 = v114;
  re::DynamicString::DynamicString(v98, (const re::DynamicString *)v115);
  *(_BYTE *)a1 = 0;
  *v99 = *(_OWORD *)v127;
  *(_QWORD *)(a1 + 24) = *(_QWORD *)&v127[16];
  *(_QWORD *)(a1 + 48) = v129;
  result = v128;
  *(__n128 *)(a1 + 32) = v128;
  if (*(_QWORD *)v115 && (v115[8] & 1) != 0)
    (*(void (**)(void))(**(_QWORD **)v115 + 40))();
  return result;
}

_anonymous_namespace_ *re::DynamicArray<re::internal::`anonymous namespace'::RegexOperationList>::add(_anonymous_namespace_ *result, uint64_t a2)
{
  _anonymous_namespace_ *v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  BOOL v13;
  unint64_t v14;
  unint64_t v15;

  v3 = result;
  v4 = *((_QWORD *)result + 1);
  v5 = *((_QWORD *)result + 2);
  v6 = v5 + 1;
  if (v5 >= v4 && v4 < v6)
  {
    if (*(_QWORD *)result)
    {
      v12 = 2 * v4;
      v13 = v4 == 0;
      v14 = 8;
      if (!v13)
        v14 = v12;
      if (v14 <= v6)
        v15 = v6;
      else
        v15 = v14;
      result = (_anonymous_namespace_ *)re::DynamicArray<re::DynamicArray<unsigned char>>::setCapacity(result, v15);
    }
    else
    {
      result = (_anonymous_namespace_ *)re::DynamicArray<re::DynamicArray<unsigned char>>::setCapacity(v3, v6);
      ++*((_DWORD *)v3 + 6);
    }
  }
  v8 = *((_QWORD *)v3 + 4) + 40 * *((_QWORD *)v3 + 2);
  *(_QWORD *)(v8 + 32) = 0;
  *(_DWORD *)(v8 + 24) = 0;
  *(_QWORD *)(v8 + 8) = 0;
  *(_QWORD *)(v8 + 16) = 0;
  *(_QWORD *)v8 = 0;
  v9 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)v8 = *(_QWORD *)a2;
  *(_QWORD *)(v8 + 8) = v9;
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  v10 = *(_QWORD *)(v8 + 16);
  *(_QWORD *)(v8 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v10;
  v11 = *(_QWORD *)(v8 + 32);
  *(_QWORD *)(v8 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 32) = v11;
  ++*(_DWORD *)(a2 + 24);
  ++*(_DWORD *)(v8 + 24);
  ++*((_QWORD *)v3 + 2);
  ++*((_DWORD *)v3 + 6);
  return result;
}

uint64_t re::BucketArray<re::internal::`anonymous namespace'::MatchStackItem,64ul>::~BucketArray(uint64_t a1)
{
  uint64_t v2;
  unint64_t i;

  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    for (i = 0; i != v2; ++i)
  }
  while (*(_QWORD *)(a1 + 8))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)a1);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1);
  *(_QWORD *)(a1 + 40) = 0;
  ++*(_DWORD *)(a1 + 48);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1);
  return a1;
}

BOOL re::internal::RegexRoot::fullMatch(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  unint64_t *v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  BOOL v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  _anonymous_namespace_ *v16;
  _anonymous_namespace_ *v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t i;
  uint64_t v28;
  _QWORD v30[2];
  int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  _QWORD v36[3];
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  uint64_t v45;
  int v46;
  const char *v47;
  __int16 v48;
  int v49;
  __int16 v50;
  unint64_t v51;
  __int16 v52;
  unint64_t v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  uint64_t v59;

  v59 = *MEMORY[0x24BDAC8D0];
  v5 = a1[47];
  if (!v5)
    return a2 == a3;
  v36[0] = a1;
  v36[1] = a2;
  v36[2] = a3;
  v37 = a2;
  v38 = 0;
  v39 = 0;
  v40 = 1;
  v42 = 0;
  v43 = 0;
  v41 = 0;
  v44 = 0;
  v30[0] = 0;
  v30[1] = 0;
  v31 = 1;
  v33 = 0;
  v34 = 0;
  v32 = 0;
  v8 = (unint64_t *)a1[49];
  v9 = &v8[v5];
  v35 = 0;
  while (1)
  {
    v10 = *v8;
    v11 = a1[42];
    if (v11 <= *v8)
      goto LABEL_50;
    if (v37 == a3)
      break;
    do
    {
      v11 = a1[42];
      if (v11 <= v10)
      {
        v45 = 0;
        v57 = 0u;
        v58 = 0u;
        v55 = 0u;
        v56 = 0u;
        v54 = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        v46 = 136315906;
        v47 = "operator[]";
        v48 = 1024;
        v49 = 797;
        v50 = 2048;
        v51 = v10;
        v52 = 2048;
        v53 = v11;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_50:
        v45 = 0;
        v57 = 0u;
        v58 = 0u;
        v55 = 0u;
        v56 = 0u;
        v54 = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        v46 = 136315906;
        v47 = "operator[]";
        v48 = 1024;
        v49 = 797;
        v50 = 2048;
        v51 = v10;
        v52 = 2048;
        v53 = v11;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      else
        v12 = 1;
    }
    while (!v12);
    if (v37 == a3)
      break;
LABEL_13:
    if (++v8 == v9)
    {
      v13 = 0;
      goto LABEL_34;
    }
  }
  *(_QWORD *)(a4 + 16) = 0;
  ++*(_DWORD *)(a4 + 24);
  v14 = v34;
  if (v34)
  {
    v15 = 0;
    do
    {
      if (*(_BYTE *)v16 == 5)
      {
        v17 = v16;
        v18 = *(_QWORD *)(a4 + 8);
        v19 = *(_QWORD *)(a4 + 16);
        if (v19 >= v18)
        {
          v20 = v19 + 1;
          if (v18 < v19 + 1)
          {
            if (*(_QWORD *)a4)
            {
              if (v18)
                v21 = 2 * v18;
              else
                v21 = 8;
              if (v21 <= v20)
                v22 = v19 + 1;
              else
                v22 = v21;
              re::DynamicArray<re::RigNodeConstraint>::setCapacity((_QWORD *)a4, v22);
            }
            else
            {
              re::DynamicArray<re::RigNodeConstraint>::setCapacity((_QWORD *)a4, v20);
              ++*(_DWORD *)(a4 + 24);
            }
          }
          v19 = *(_QWORD *)(a4 + 16);
        }
        *(_OWORD *)(*(_QWORD *)(a4 + 32) + 16 * v19) = *((_OWORD *)v17 + 1);
        ++*(_QWORD *)(a4 + 16);
        ++*(_DWORD *)(a4 + 24);
      }
      ++v15;
    }
    while (v14 != v15);
  }
  v13 = 1;
LABEL_34:
  v23 = v43;
  if (v43)
  {
    v24 = 0;
    do
    {
      re::BucketArray<unsigned long,8ul>::deinit(v25 + 64);
      re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(v25 + 64);
      v26 = *(_QWORD *)(v25 + 48);
      if (v26)
      {
        for (i = 0; i != v26; ++i)
        {
        }
      }
      while (*(_QWORD *)(v25 + 16))
        re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)(v25 + 8));
      re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(v25 + 8);
      *(_QWORD *)(v25 + 48) = 0;
      ++*(_DWORD *)(v25 + 56);
      re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(v25 + 8);
      ++v24;
    }
    while (v24 != v23);
  }
  for (; v39; --v39)
  {
    (*(void (**)(void))(*(_QWORD *)v38 + 40))();
    v40 += 2;
  }
  if (v38 && (v40 & 1) == 0)
    (*(void (**)(void))(*(_QWORD *)v38 + 40))();
  return v13;
}

uint64_t re::internal::`anonymous namespace'::RegexOperationList::unwindMatch(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  unint64_t v3;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;

  v3 = *(_QWORD *)(a1 + 16);
  if (!v3)
    return 0;
  v7 = v3 - 1;
  while (1)
  {
    if (*(_QWORD *)(a1 + 16) <= v7)
    {
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_17:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_18:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    v8 = (_QWORD *)*a2;
    v9 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v7);
    if (*(_QWORD *)(*a2 + 296) <= v9)
      goto LABEL_17;
    v10 = v8[39];
    v11 = *(_QWORD *)(v10 + 24 * v9);
    if (v8[32] <= v11)
      goto LABEL_18;
    v12 = a2[3];
    {
      break;
    }
    --v7;
LABEL_13:
    if (v7 >= v3)
      return 0;
  }
    goto LABEL_13;
  return 1;
}

uint64_t *re::internal::regularExpressionCreate@<X0>(re::internal *this@<X0>, uint64_t a2@<X8>)
{
  char *v3;
  uint64_t *v4;
  uint64_t v5;
  char *v6;
  char *v7;
  int v8;
  uint64_t v9;
  _BYTE *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v14;
  char v16;
  __int128 v17;
  __int128 v18;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  uint64_t v22;
  uint64_t v23;
  _QWORD v24[3];
  int v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD v28[3];
  _QWORD *v29;
  _BYTE v30[24];
  __int128 v31;
  uint64_t v32;
  uint64_t v33;

  v3 = (char *)this;
  v33 = *MEMORY[0x24BDAC8D0];
  v4 = re::globalAllocators(this);
  v5 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v4[2] + 32))(v4[2], 400, 8);
  *(_OWORD *)v5 = 0u;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(_OWORD *)(v5 + 48) = 0u;
  *(_OWORD *)(v5 + 64) = 0u;
  *(_OWORD *)(v5 + 80) = 0u;
  *(_OWORD *)(v5 + 96) = 0u;
  *(_OWORD *)(v5 + 112) = 0u;
  *(_OWORD *)(v5 + 128) = 0u;
  *(_OWORD *)(v5 + 144) = 0u;
  *(_OWORD *)(v5 + 160) = 0u;
  *(_OWORD *)(v5 + 176) = 0u;
  *(_OWORD *)(v5 + 192) = 0u;
  *(_OWORD *)(v5 + 208) = 0u;
  *(_OWORD *)(v5 + 224) = 0u;
  *(_OWORD *)(v5 + 240) = 0u;
  *(_OWORD *)(v5 + 256) = 0u;
  *(_OWORD *)(v5 + 272) = 0u;
  *(_OWORD *)(v5 + 288) = 0u;
  *(_OWORD *)(v5 + 304) = 0u;
  *(_OWORD *)(v5 + 320) = 0u;
  *(_OWORD *)(v5 + 336) = 0u;
  *(_OWORD *)(v5 + 352) = 0u;
  *(_OWORD *)(v5 + 368) = 0u;
  *(_OWORD *)(v5 + 384) = 0u;
  v29 = v28;
  v27 = v5;
  v28[0] = &off_24ED41FE0;
  v6 = &v3[strlen(v3)];
  do
  {
    if (v3 >= v6)
      goto LABEL_21;
    v26 = 0;
    memset(v24, 0, sizeof(v24));
    v25 = 0;
    if (!v30[0])
    {
      v16 = 0;
      v17 = *(_OWORD *)&v30[8];
      re::DynamicString::DynamicString((re::DynamicString *)&v18, (const re::DynamicString *)&v31);
      if ((_QWORD)v31 && (BYTE8(v31) & 1) != 0)
        (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)v31 + 40))(v31, v32);
      goto LABEL_12;
    }
    v7 = *(char **)&v30[8];
    if (!*(_QWORD *)&v30[8])
    {
      re::DynamicString::format((re::DynamicString *)"Unknown error parsing regular expression.", (re::DynamicString *)&v21);
      v16 = 0;
      *(_QWORD *)&v17 = 100;
      *((_QWORD *)&v17 + 1) = &re::FoundationErrorCategory(void)::instance;
      v18 = v21;
      v19 = v22;
      v20 = v23;
LABEL_12:
      v8 = 1;
      goto LABEL_16;
    }
    *(_QWORD *)&v21 = *(_QWORD *)(v5 + 336);
    re::DynamicArray<unsigned long>::add((_QWORD *)(v5 + 360), &v21);
    if (!*v7)
    {
      v8 = 3;
LABEL_15:
      v3 = v7;
      goto LABEL_16;
    }
    if (*v7 != 124)
    {
      re::DynamicString::format((re::DynamicString *)"Could not parse regular expression: %s.", (re::DynamicString *)&v21, v7);
      v16 = 0;
      *(_QWORD *)&v17 = 100;
      *((_QWORD *)&v17 + 1) = &re::FoundationErrorCategory(void)::instance;
      v18 = v21;
      v19 = v22;
      v20 = v23;
      v8 = 1;
      goto LABEL_15;
    }
    v3 = v7 + 1;
    v8 = 2;
LABEL_16:
    if (v24[0] && v26)
      (*(void (**)(void))(*(_QWORD *)v24[0] + 40))();
  }
  while (v8 == 2);
  if (v8 == 3)
  {
LABEL_21:
    v16 = 1;
    goto LABEL_23;
  }
  if (v16)
  {
LABEL_23:
    v9 = v27;
    v10 = v29;
    v27 = 0;
    *(_QWORD *)v30 = v9;
    if (v29)
    {
      if (v29 != v28)
      {
        v29 = 0;
        *(_BYTE *)a2 = 1;
        v11 = a2;
        *((_QWORD *)&v31 + 1) = v10;
        *(_QWORD *)v30 = 0;
        *(_QWORD *)(a2 + 8) = v9;
LABEL_29:
        if (v10 == &v30[8])
        {
          *(_QWORD *)(v11 + 40) = v11 + 16;
          (*(void (**)(_BYTE *))(*(_QWORD *)&v30[8] + 24))(&v30[8]);
        }
        else
        {
          *(_QWORD *)(v11 + 40) = v10;
          *((_QWORD *)&v31 + 1) = 0;
        }
LABEL_32:
        std::unique_ptr<re::RigHierarchy,std::function<void ()(re::RigHierarchy*)>>::~unique_ptr[abi:nn180100]((uint64_t *)v30);
        goto LABEL_33;
      }
      *((_QWORD *)&v31 + 1) = &v30[8];
      (*(void (**)(void))(v28[0] + 24))();
      v12 = *(_QWORD *)v30;
      v10 = (_BYTE *)*((_QWORD *)&v31 + 1);
      *(_BYTE *)a2 = 1;
      v11 = a2;
      *(_QWORD *)v30 = 0;
      *(_QWORD *)(a2 + 8) = v12;
      if (v10)
        goto LABEL_29;
    }
    else
    {
      v11 = a2;
      *(_BYTE *)a2 = 1;
      *((_QWORD *)&v31 + 1) = 0;
      *(_QWORD *)v30 = 0;
      *(_QWORD *)(a2 + 8) = v9;
    }
    *(_QWORD *)(v11 + 40) = 0;
    goto LABEL_32;
  }
  *(_OWORD *)v30 = v17;
  re::DynamicString::DynamicString((re::DynamicString *)&v30[16], (const re::DynamicString *)&v18);
  *(_BYTE *)a2 = 0;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)v30;
  v14 = v32;
  *(_QWORD *)(a2 + 24) = *(_QWORD *)&v30[16];
  *(_QWORD *)(a2 + 48) = v14;
  *(_OWORD *)(a2 + 32) = v31;
LABEL_33:
  if (!v16 && (_QWORD)v18 && (BYTE8(v18) & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v18 + 40))();
  return std::unique_ptr<re::RigHierarchy,std::function<void ()(re::RigHierarchy*)>>::~unique_ptr[abi:nn180100](&v27);
}

uint64_t re::internal::regularExpressionFullMatch@<X0>(char *__s@<X1>, _QWORD **a2@<X0>, uint64_t a3@<X8>)
{
  size_t v6;
  uint64_t result;
  uint64_t v8;
  __int128 v9;
  int v10;
  uint64_t v11;

  v6 = strlen(__s);
  v11 = 0;
  v9 = 0uLL;
  v8 = 0;
  v10 = 0;
  result = re::internal::RegexRoot::fullMatch(*a2, (uint64_t)__s, (uint64_t)&__s[v6], (uint64_t)&v8);
  if ((_DWORD)result)
  {
    *(_QWORD *)(a3 + 8) = v8;
    *(_OWORD *)(a3 + 16) = v9;
    *(_QWORD *)(a3 + 40) = v11;
    *(_DWORD *)(a3 + 32) = 1;
    *(_BYTE *)a3 = 1;
  }
  else
  {
    result = v8;
    *(_BYTE *)a3 = 0;
    if (result)
    {
      if (v11)
        return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    }
  }
  return result;
}

__n128 re::DynamicArray<re::internal::`anonymous namespace'::RegexToken>::add(uint64_t a1, __n128 *a2)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  __n128 result;
  uint64_t v9;
  BOOL v10;
  unint64_t v11;
  unint64_t v12;

  v4 = *(_QWORD *)(a1 + 8);
  v5 = *(_QWORD *)(a1 + 16);
  v6 = v5 + 1;
  if (v5 >= v4 && v4 < v6)
  {
    if (*(_QWORD *)a1)
    {
      v9 = 2 * v4;
      v10 = v4 == 0;
      v11 = 8;
      if (!v10)
        v11 = v9;
      if (v11 <= v6)
        v12 = v6;
      else
        v12 = v11;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity((_QWORD *)a1, v12);
    }
    else
    {
      re::DynamicArray<re::RigNodeConstraint>::setCapacity((_QWORD *)a1, v6);
      ++*(_DWORD *)(a1 + 24);
    }
  }
  result = *a2;
  *(__n128 *)(*(_QWORD *)(a1 + 32) + 16 * (*(_QWORD *)(a1 + 16))++) = *a2;
  ++*(_DWORD *)(a1 + 24);
  return result;
}

_anonymous_namespace_ *re::DynamicArray<re::internal::`anonymous namespace'::RegexTokenEscapedCharacter>::add(_anonymous_namespace_ *result, uint64_t a2)
{
  _anonymous_namespace_ *v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  BOOL v11;
  unint64_t v12;
  unint64_t v13;

  v3 = result;
  v4 = *((_QWORD *)result + 1);
  v5 = *((_QWORD *)result + 2);
  v6 = v5 + 1;
  if (v5 >= v4 && v4 < v6)
  {
    if (*(_QWORD *)result)
    {
      v10 = 2 * v4;
      v11 = v4 == 0;
      v12 = 8;
      if (!v11)
        v12 = v10;
      if (v12 <= v6)
        v13 = v6;
      else
        v13 = v12;
    }
    else
    {
      ++*((_DWORD *)v3 + 6);
    }
  }
  v8 = *((_QWORD *)v3 + 2);
  v9 = *((_QWORD *)v3 + 4) + 16 * v8;
  *(_QWORD *)v9 = &off_24ED41F80;
  *(_BYTE *)(v9 + 8) = *(_BYTE *)(a2 + 8);
  *((_QWORD *)v3 + 2) = v8 + 1;
  ++*((_DWORD *)v3 + 6);
  return result;
}

_anonymous_namespace_ *re::DynamicArray<re::internal::`anonymous namespace'::RegexTokenCharacter>::add(_anonymous_namespace_ *result, uint64_t a2)
{
  _anonymous_namespace_ *v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  BOOL v11;
  unint64_t v12;
  unint64_t v13;

  v3 = result;
  v4 = *((_QWORD *)result + 1);
  v5 = *((_QWORD *)result + 2);
  v6 = v5 + 1;
  if (v5 >= v4 && v4 < v6)
  {
    if (*(_QWORD *)result)
    {
      v10 = 2 * v4;
      v11 = v4 == 0;
      v12 = 8;
      if (!v11)
        v12 = v10;
      if (v12 <= v6)
        v13 = v6;
      else
        v13 = v12;
    }
    else
    {
      ++*((_DWORD *)v3 + 6);
    }
  }
  v8 = *((_QWORD *)v3 + 2);
  v9 = *((_QWORD *)v3 + 4) + 16 * v8;
  *(_QWORD *)v9 = &off_24ED41FB0;
  *(_BYTE *)(v9 + 8) = *(_BYTE *)(a2 + 8);
  *((_QWORD *)v3 + 2) = v8 + 1;
  ++*((_DWORD *)v3 + 6);
  return result;
}

uint64_t re::internal::`anonymous namespace'::RegexTokenCharacterSet::tryMatch(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  unint64_t *v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v11[2];
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  int v18;
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  unint64_t v23;
  __int16 v24;
  unint64_t v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  uint64_t v31;

  v31 = *MEMORY[0x24BDAC8D0];
  v11[0] = 0;
  v11[1] = 0;
  v12 = 1;
  v14 = 0;
  v15 = 0;
  v13 = 0;
  v16 = 0;
  v2 = *(_QWORD *)(a1 + 24);
  if (v2)
  {
    v4 = *(unint64_t **)(a1 + 40);
    v5 = 8 * v2 - 8;
    do
    {
      v6 = *v4;
      v7 = *(_QWORD *)(*a2 + 256);
      if (v7 <= *v4)
      {
        v17 = 0;
        v29 = 0u;
        v30 = 0u;
        v27 = 0u;
        v28 = 0u;
        v26 = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        v18 = 136315906;
        v19 = "operator[]";
        v20 = 1024;
        v21 = 797;
        v22 = 2048;
        v23 = v6;
        v24 = 2048;
        v25 = v7;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      if ((v8 & 1) != 0)
        break;
      ++v4;
      v9 = v5;
      v5 -= 8;
    }
    while (v9);
  }
  else
  {
    v8 = 0;
  }
  return v8;
}

uint64_t re::internal::`anonymous namespace'::RegexToken::match(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  _BYTE *v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t (***v10)(_QWORD, uint64_t);
  char v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  int v15;
  uint64_t v17;
  BOOL v18;
  unint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  int v32;
  uint64_t v34;
  _BYTE v35[20];
  _BYTE v36[20];
  uint64_t v37;
  int v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  _BYTE v50[12];
  __int16 v51;
  int v52;
  __int16 v53;
  unint64_t v54;
  __int16 v55;
  unint64_t v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  uint64_t v62;

  v62 = *MEMORY[0x24BDAC8D0];
  v6 = (_BYTE *)a2;
  v7 = (unint64_t)&v39;
  switch(*(_BYTE *)a1)
  {
    case 1:
      v8 = *(_QWORD *)(a1 + 8);
      v9 = *(_QWORD *)(*a3 + 16);
      if (v9 <= v8)
        goto LABEL_65;
      v10 = (uint64_t (***)(_QWORD, uint64_t))(*(_QWORD *)(*a3 + 32) + 16 * v8);
      v11 = 1;
    case 2:
      v8 = *(_QWORD *)(a1 + 8);
      v9 = *(_QWORD *)(*a3 + 56);
      if (v9 <= v8)
        goto LABEL_66;
      v10 = (uint64_t (***)(_QWORD, uint64_t))(*(_QWORD *)(*a3 + 72) + 16 * v8);
      v11 = 2;
    case 3:
      v8 = *(_QWORD *)(a1 + 8);
      v9 = *(_QWORD *)(*a3 + 96);
      if (v9 <= v8)
        goto LABEL_67;
      v10 = (uint64_t (***)(_QWORD, uint64_t))(*(_QWORD *)(*a3 + 112) + 16 * v8);
      v11 = 3;
    case 4:
      v8 = *(_QWORD *)(a1 + 8);
      v9 = *(_QWORD *)(*a3 + 216);
      if (v9 <= v8)
        goto LABEL_68;
      v10 = (uint64_t (***)(_QWORD, uint64_t))(*(_QWORD *)(*a3 + 232) + 16 * v8);
      v11 = 4;
    case 5:
      v8 = *(_QWORD *)(a1 + 8);
      v9 = *(_QWORD *)(*a3 + 136);
      if (v9 <= v8)
        goto LABEL_69;
      v12 = *(_QWORD *)(*a3 + 152);
      LOBYTE(v39) = 0;
      v13 = v12 + 40 * v8;
      *((_QWORD *)&v39 + 1) = 0;
      *(_QWORD *)&v40 = 0;
      DWORD2(v40) = 1;
      *(_QWORD *)&v42 = 0;
      v41 = 0uLL;
      DWORD2(v42) = 0;
      v43 = 0;
      v44 = 0;
      v45 = 1;
      v47 = 0;
      v48 = 0;
      v46 = 0;
      v49 = 0;
      v34 = a3[3];
      v14 = *(_QWORD *)(v13 + 16);
      if (*(int *)(a2 + 4) < 1)
      {
        v32 = *(_DWORD *)(a2 + 4);
        goto LABEL_27;
      }
      if (v14)
      {
        v15 = 0;
        while (1)
        {
          v31 = v15;
          v9 = 0;
          while (1)
          {
            *(_QWORD *)v35 = 0;
            *(_QWORD *)&v35[8] = 0;
            *(_DWORD *)&v35[16] = 1;
            v37 = 0;
            *(_OWORD *)&v36[4] = 0uLL;
            v38 = 0;
            v8 = *(_QWORD *)(v13 + 16);
            if (v8 <= v9)
            {
              v60 = 0u;
              v61 = 0u;
              v58 = 0u;
              v59 = 0u;
              v57 = 0u;
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              *(_DWORD *)v50 = 136315906;
              *(_QWORD *)&v50[4] = "operator[]";
              v51 = 1024;
              v52 = 797;
              v53 = 2048;
              v54 = v9;
              v55 = 2048;
              v56 = v8;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_62:
              v60 = 0u;
              v61 = 0u;
              v58 = 0u;
              v59 = 0u;
              v57 = 0u;
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              *(_DWORD *)v50 = 136315906;
              *(_QWORD *)&v50[4] = "operator[]";
              v51 = 1024;
              v52 = 797;
              v53 = 2048;
              v54 = v7;
              v55 = 2048;
              v56 = v8;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_63:
              v60 = 0u;
              v61 = 0u;
              v58 = 0u;
              v59 = 0u;
              v57 = 0u;
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              *(_DWORD *)v50 = 136315906;
              *(_QWORD *)&v50[4] = "operator[]";
              v51 = 1024;
              v52 = 797;
              v53 = 2048;
              v54 = v9;
              v55 = 2048;
              v56 = v8;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_64:
              v60 = 0u;
              v61 = 0u;
              v58 = 0u;
              v59 = 0u;
              v57 = 0u;
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              *(_DWORD *)v50 = 136315906;
              *(_QWORD *)&v50[4] = "operator[]";
              v51 = 1024;
              v52 = 797;
              v53 = 2048;
              v54 = v7;
              v55 = 2048;
              v56 = v8;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_65:
              *(_QWORD *)v35 = 0;
              *(_OWORD *)(v7 + 64) = 0u;
              v41 = 0u;
              v42 = 0u;
              v39 = 0u;
              v40 = 0u;
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              LODWORD(v57) = 136315906;
              *(_QWORD *)(v7 + 180) = "operator[]";
              WORD6(v57) = 1024;
              *(_DWORD *)(v7 + 190) = 797;
              WORD1(v58) = 2048;
              *(_QWORD *)(v7 + 196) = v8;
              WORD6(v58) = 2048;
              *(_QWORD *)(v7 + 206) = v9;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_66:
              *(_QWORD *)v35 = 0;
              *(_OWORD *)(v7 + 64) = 0u;
              v41 = 0u;
              v42 = 0u;
              v39 = 0u;
              v40 = 0u;
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              LODWORD(v57) = 136315906;
              *(_QWORD *)(v7 + 180) = "operator[]";
              WORD6(v57) = 1024;
              *(_DWORD *)(v7 + 190) = 797;
              WORD1(v58) = 2048;
              *(_QWORD *)(v7 + 196) = v8;
              WORD6(v58) = 2048;
              *(_QWORD *)(v7 + 206) = v9;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_67:
              *(_QWORD *)v35 = 0;
              *(_OWORD *)(v7 + 64) = 0u;
              v41 = 0u;
              v42 = 0u;
              v39 = 0u;
              v40 = 0u;
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              LODWORD(v57) = 136315906;
              *(_QWORD *)(v7 + 180) = "operator[]";
              WORD6(v57) = 1024;
              *(_DWORD *)(v7 + 190) = 797;
              WORD1(v58) = 2048;
              *(_QWORD *)(v7 + 196) = v8;
              WORD6(v58) = 2048;
              *(_QWORD *)(v7 + 206) = v9;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_68:
              *(_QWORD *)v35 = 0;
              *(_OWORD *)(v7 + 64) = 0u;
              v41 = 0u;
              v42 = 0u;
              v39 = 0u;
              v40 = 0u;
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              LODWORD(v57) = 136315906;
              *(_QWORD *)(v7 + 180) = "operator[]";
              WORD6(v57) = 1024;
              *(_DWORD *)(v7 + 190) = 797;
              WORD1(v58) = 2048;
              *(_QWORD *)(v7 + 196) = v8;
              WORD6(v58) = 2048;
              *(_QWORD *)(v7 + 206) = v9;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_69:
              *(_QWORD *)v35 = 0;
              *(_OWORD *)(v7 + 64) = 0u;
              v41 = 0u;
              v42 = 0u;
              v39 = 0u;
              v40 = 0u;
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              LODWORD(v57) = 136315906;
              *(_QWORD *)(v7 + 180) = "operator[]";
              WORD6(v57) = 1024;
              *(_DWORD *)(v7 + 190) = 797;
              WORD1(v58) = 2048;
              *(_QWORD *)(v7 + 196) = v8;
              WORD6(v58) = 2048;
              *(_QWORD *)(v7 + 206) = v9;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_70:
              *(_QWORD *)v35 = 0;
              *(_OWORD *)(v7 + 64) = 0u;
              v41 = 0u;
              v42 = 0u;
              v39 = 0u;
              v40 = 0u;
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              LODWORD(v57) = 136315906;
              *(_QWORD *)(v7 + 180) = "operator[]";
              WORD6(v57) = 1024;
              *(_DWORD *)(v7 + 190) = 797;
              WORD1(v58) = 2048;
              *(_QWORD *)(v7 + 196) = v8;
              WORD6(v58) = 2048;
              *(_QWORD *)(v7 + 206) = v9;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
              goto LABEL_71;
            }
            v7 = *(_QWORD *)(*(_QWORD *)(v13 + 32) + 8 * v9);
            v8 = *(_QWORD *)(*a3 + 336);
            if (v8 <= v7)
              goto LABEL_62;
            if (v14 == ++v9)
              goto LABEL_25;
          }
          *(_QWORD *)re::BucketArray<unsigned long,8ul>::addUninitialized((uint64_t)&v43) = v9;
          v15 = v31 + 1;
          if (v31 + 1 >= *(_DWORD *)(a2 + 4))
          {
            v32 = *(_DWORD *)(a2 + 4);
            v6 = (_BYTE *)a2;
LABEL_27:
            if (*v6)
            {
              LOBYTE(v39) = 1;
              if (v32 < *(_DWORD *)(a2 + 8))
              {
                if (v14)
                {
                  v30 = a3[3];
                  do
                  {
                    v18 = 0;
                    v9 = 0;
                    while (1)
                    {
                      *(_QWORD *)v35 = 0;
                      *(_QWORD *)&v35[8] = 0;
                      *(_DWORD *)&v35[16] = 1;
                      *(_QWORD *)&v36[12] = 0;
                      v37 = 0;
                      *(_QWORD *)&v36[4] = 0;
                      v38 = 0;
                      v8 = *(_QWORD *)(v13 + 16);
                      if (v8 <= v9)
                        goto LABEL_63;
                      v7 = *(_QWORD *)(*(_QWORD *)(v13 + 32) + 8 * v9);
                      v8 = *(_QWORD *)(*a3 + 336);
                      if (v8 <= v7)
                        goto LABEL_64;
                      v18 = ++v9 >= v14;
                      if (v14 == v9)
                        goto LABEL_39;
                    }
                    *(_QWORD *)re::BucketArray<unsigned long,8ul>::addUninitialized((uint64_t)&v43) = v9;
                    if (v18 || v30 == a3[3])
                      break;
                    v30 = a3[3];
                    ++v32;
                  }
                  while (v32 < *(_DWORD *)(a2 + 8));
                }
              }
            }
LABEL_39:
            v19 = a3[9];
            v9 = a3[5];
            if (v19 + 1 > v9 << 6)
            {
              v9 = a3[5];
            }
            v7 = v19 >> 6;
            if (v9 > v19 >> 6)
            {
              v20 = (_QWORD *)a3[8];
              if ((a3[6] & 1) != 0)
                v20 = a3 + 7;
              v21 = v20[v7];
              ++a3[9];
              ++*((_DWORD *)a3 + 20);
              v22 = v21 + 120 * (v19 & 0x3F);
              *(_BYTE *)v22 = v39;
              *(_QWORD *)(v22 + 8) = 0;
              *(_QWORD *)(v22 + 16) = 0;
              *(_QWORD *)(v22 + 40) = 0;
              *(_QWORD *)(v22 + 48) = 0;
              *(_QWORD *)(v22 + 32) = 0;
              *(_DWORD *)(v22 + 56) = 0;
              *((_QWORD *)&v58 + 1) = 0;
              *(_QWORD *)&v59 = 0;
              v57 = 0uLL;
              *(_DWORD *)(v22 + 24) = 3;
              LODWORD(v58) = 3;
              if ((_QWORD)v57 && (v58 & 1) == 0)
                (*(void (**)(void))(*(_QWORD *)v57 + 40))();
              v23 = v21 + 120 * (v19 & 0x3F);
              v24 = *(_QWORD *)(v23 + 48);
              *(_QWORD *)(v23 + 48) = v42;
              *(_QWORD *)&v42 = v24;
              ++*(_DWORD *)(v23 + 56);
              ++DWORD2(v42);
              *(_QWORD *)(v23 + 64) = 0;
              *(_QWORD *)(v23 + 72) = 0;
              v23 += 64;
              v17 = 1;
              *(_DWORD *)(v23 + 16) = 1;
              *(_QWORD *)(v23 + 32) = 0;
              *(_QWORD *)(v23 + 40) = 0;
              *(_QWORD *)(v23 + 24) = 0;
              *(_DWORD *)(v23 + 48) = 0;
              re::BucketArray<RESubscriptionHandle,8ul>::swap(v23, (uint64_t)&v43);
              LOBYTE(v57) = 5;
              v25 = a3[3] - v34;
              *((_QWORD *)&v57 + 1) = a3[9] - 1;
              *(_QWORD *)&v58 = v34;
              *((_QWORD *)&v58 + 1) = v25;
              goto LABEL_48;
            }
LABEL_71:
            *(_QWORD *)v50 = 0;
            v60 = 0u;
            v61 = 0u;
            v58 = 0u;
            v59 = 0u;
            v57 = 0u;
            os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
            *(_DWORD *)v35 = 136315906;
            *(_QWORD *)&v35[4] = "operator[]";
            *(_WORD *)&v35[12] = 1024;
            *(_DWORD *)&v35[14] = 858;
            *(_WORD *)&v35[18] = 2048;
            *(_QWORD *)v36 = v7;
            *(_WORD *)&v36[8] = 2048;
            *(_QWORD *)&v36[10] = v9;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
          }
        }
      }
LABEL_25:
      v17 = 0;
      a3[3] = v34;
LABEL_48:
      re::BucketArray<unsigned long,8ul>::deinit((uint64_t)&v43);
      if (v43)
      {
        v26 = v45;
        if ((v45 & 1) == 0)
        {
          (*(void (**)(void))(*(_QWORD *)v43 + 40))();
          v26 = v45;
        }
        v43 = 0;
        v44 = 0;
        v45 = (v26 | 1) + 2;
      }
      v27 = v42;
      if ((_QWORD)v42)
      {
        v28 = 0;
        do
        {
          ++v28;
        }
        while (v27 != v28);
      }
      for (; (_QWORD)v40; *(_QWORD *)&v40 = v40 - 1)
      {
        (*(void (**)(void))(**((_QWORD **)&v39 + 1) + 40))();
        DWORD2(v40) += 2;
      }
      if (*((_QWORD *)&v39 + 1))
      {
        if ((BYTE8(v40) & 1) == 0)
          (*(void (**)(void))(**((_QWORD **)&v39 + 1) + 40))();
      }
      return v17;
    case 6:
      v8 = *(_QWORD *)(a1 + 8);
      v9 = *(_QWORD *)(*a3 + 176);
      if (v9 <= v8)
        goto LABEL_70;
      v10 = (uint64_t (***)(_QWORD, uint64_t))(*(_QWORD *)(*a3 + 192) + 48 * v8);
      v11 = 6;
    default:
      re::internal::assertLog((re::internal *)4, a2, a2, "assertion failure: '%s' (%s:line %i) Invalid token type.", "!\"Unreachable code\"", "match", 915);
      _os_crash();
      __break(1u);
      JUMPOUT(0x22545533CLL);
  }
}

uint64_t re::internal::`anonymous namespace'::RegexBasicToken::match(uint64_t (***a1)(_QWORD, uint64_t), char a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t result;
  _BYTE v15[8];
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v10 = *(_QWORD *)(a4 + 24);
  v11 = *(_DWORD *)(a3 + 4);
  if (v11 < 1)
  {
LABEL_5:
    if (*(_BYTE *)a3)
    {
      while (v11 < *(_DWORD *)(a3 + 8) && ((**a1)(a1, a4) & 1) != 0)
        ++v11;
    }
    v15[0] = a2;
    v13 = *(_QWORD *)(a4 + 24) - v10;
    v16 = -1;
    v17 = v10;
    v18 = v13;
    return 1;
  }
  else
  {
    v12 = 0;
    while (((**a1)(a1, a4) & 1) != 0)
    {
      ++v12;
      v11 = *(_DWORD *)(a3 + 4);
      if (v12 >= v11)
        goto LABEL_5;
    }
    result = 0;
    *(_QWORD *)(a4 + 24) = v10;
  }
  return result;
}

__n128 re::BucketArray<re::internal::`anonymous namespace'::MatchStackItem,64ul>::add(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _OWORD *v8;
  __n128 result;
  __int128 v10;

  v4 = *(_QWORD *)(a1 + 40);
  v5 = *(_QWORD *)(a1 + 8);
  if (v4 + 1 > v5 << 6)
  {
    v5 = *(_QWORD *)(a1 + 8);
  }
  if (v5 <= v4 >> 6)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
    v6 = a1 + 24;
  else
    v6 = *(_QWORD *)(a1 + 32);
  v7 = *(_QWORD *)(v6 + 8 * (v4 >> 6));
  ++*(_QWORD *)(a1 + 40);
  ++*(_DWORD *)(a1 + 48);
  v8 = (_OWORD *)(v7 + 32 * (v4 & 0x3F));
  result = *(__n128 *)a2;
  v10 = *(_OWORD *)(a2 + 16);
  *v8 = *(_OWORD *)a2;
  v8[1] = v10;
  return result;
}

_QWORD *re::BucketArray<re::internal::`anonymous namespace'::MatchStackItem,64ul>::setBucketsCapacity(_QWORD *result, unint64_t a2)
{
  _QWORD *v3;
  unint64_t v4;
  unint64_t *v5;
  _QWORD *v6;
  unint64_t v7;
  int v8;
  unint64_t v9;
  unint64_t v10;
  BOOL v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  _QWORD *v15;
  unint64_t v16;

  v3 = result;
  if (*result)
  {
    if (result[5] < a2 << 6)
    {
      while (1)
      {
        v4 = v3[1];
        if (v4 <= a2)
          break;
        result = (_QWORD *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        v5 = v3 + 3;
        do
        {
          result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(*(_QWORD *)*v3 + 32))(*v3, 2048, 0);
          v6 = result;
          if (*v3)
          {
            v7 = v3[1];
            v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              v9 = *v5;
              v11 = v7 >= *v5;
              v10 = v7 + 1;
              v11 = !v11 || v9 >= v10;
              if (v11)
                goto LABEL_22;
              v12 = 2 * v9;
              goto LABEL_18;
            }
            v10 = v7 + 1;
            if (v10 >= 3)
            {
              v12 = 4;
LABEL_18:
              if (v12 <= v10)
                v14 = v10;
              else
                v14 = v12;
              result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v14);
              v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            v13 = v3[1] + 1;
            result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v13);
            v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + 4) = v8;
          }
LABEL_22:
          v15 = v3 + 3;
          if ((v8 & 1) == 0)
            v15 = (_QWORD *)v3[4];
          v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
    re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, a2);
    *((_DWORD *)v3 + 4) += 2;
    v3[5] = 0;
    ++*((_DWORD *)v3 + 12);
  }
  return result;
}

uint64_t re::BucketArray<re::BucketArray<re::internal::`anonymous namespace'::MatchStackItem,64ul>,8ul>::add(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(a1 + 40);
  v5 = *(_QWORD *)(a1 + 8);
  if (v4 + 1 > 8 * v5)
  {
    v5 = *(_QWORD *)(a1 + 8);
  }
  if (v5 <= v4 >> 3)
  {
    v15 = 0u;
    v16 = 0u;
    v13 = 0u;
    v14 = 0u;
    v12 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
    v6 = a1 + 24;
  else
    v6 = *(_QWORD *)(a1 + 32);
  v7 = *(_QWORD *)(v6 + 8 * (v4 >> 3));
  ++*(_QWORD *)(a1 + 40);
  ++*(_DWORD *)(a1 + 48);
  v8 = v7 + 56 * (v4 & 7);
  *(_QWORD *)v8 = 0;
  *(_QWORD *)(v8 + 8) = 0;
  *(_QWORD *)(v8 + 32) = 0;
  *(_QWORD *)(v8 + 40) = 0;
  *(_QWORD *)(v8 + 24) = 0;
  *(_DWORD *)(v8 + 48) = 0;
  *((_QWORD *)&v13 + 1) = 0;
  *(_QWORD *)&v14 = 0;
  v12 = 0uLL;
  *(_DWORD *)(v8 + 16) = 3;
  LODWORD(v13) = 3;
  result = v12;
  if ((_QWORD)v12 && (v13 & 1) == 0)
    result = (*(uint64_t (**)(void))(*(_QWORD *)v12 + 40))();
  v10 = v7 + 56 * (v4 & 7);
  v11 = *(_QWORD *)(v10 + 40);
  *(_QWORD *)(v10 + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = v11;
  ++*(_DWORD *)(v10 + 48);
  ++*(_DWORD *)(a2 + 48);
  return result;
}

_QWORD *re::BucketArray<re::BucketArray<re::internal::`anonymous namespace'::MatchStackItem,64ul>,8ul>::setBucketsCapacity(_QWORD *result, unint64_t a2)
{
  _QWORD *v3;
  unint64_t v4;
  unint64_t *v5;
  _QWORD *v6;
  unint64_t v7;
  int v8;
  unint64_t v9;
  unint64_t v10;
  BOOL v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  _QWORD *v15;
  unint64_t v16;

  v3 = result;
  if (*result)
  {
    if (result[5] < 8 * a2)
    {
      while (1)
      {
        v4 = v3[1];
        if (v4 <= a2)
          break;
        result = (_QWORD *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        v5 = v3 + 3;
        do
        {
          result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(*(_QWORD *)*v3 + 32))(*v3, 448, 0);
          v6 = result;
          if (*v3)
          {
            v7 = v3[1];
            v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              v9 = *v5;
              v11 = v7 >= *v5;
              v10 = v7 + 1;
              v11 = !v11 || v9 >= v10;
              if (v11)
                goto LABEL_22;
              v12 = 2 * v9;
              goto LABEL_18;
            }
            v10 = v7 + 1;
            if (v10 >= 3)
            {
              v12 = 4;
LABEL_18:
              if (v12 <= v10)
                v14 = v10;
              else
                v14 = v12;
              result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v14);
              v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            v13 = v3[1] + 1;
            result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v13);
            v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + 4) = v8;
          }
LABEL_22:
          v15 = v3 + 3;
          if ((v8 & 1) == 0)
            v15 = (_QWORD *)v3[4];
          v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
    re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, a2);
    *((_DWORD *)v3 + 4) += 2;
    v3[5] = 0;
    ++*((_DWORD *)v3 + 12);
  }
  return result;
}

uint64_t re::DynamicOverflowArray<re::internal::`anonymous namespace'::MatchStackItem *,2ul>::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _DWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  const void *v11;
  void *v12;
  const void *v13;
  uint64_t v14;
  int v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  uint64_t result;

  if (a1 == a2)
    return a1;
  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (*(_QWORD *)a2 && v4 != *(_QWORD *)a2)
    {
      re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) ", "!isInitialized() || !other.isInitialized() || m_allocator == other.m_allocator", "operator=", 527);
      result = _os_crash();
      __break(1u);
      return result;
    }
  }
  if ((*(_BYTE *)(a2 + 16) & 1) != 0)
  {
    v10 = *(_QWORD *)(a2 + 8);
    if (v10)
    {
      *(_QWORD *)a1 = *(_QWORD *)a2;
      if (v10 >= *(_QWORD *)(a1 + 8))
      {
        re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((_QWORD *)a1, v10);
        if ((*(_BYTE *)(a2 + 16) & 1) != 0)
          v13 = (const void *)(a2 + 24);
        else
          v13 = *(const void **)(a2 + 32);
        v14 = *(_QWORD *)(a1 + 8);
        v15 = *(_DWORD *)(a1 + 16);
        if ((v15 & 1) != 0)
          v16 = (void *)(a1 + 24);
        else
          v16 = *(void **)(a1 + 32);
        if (v14)
        {
          memmove(v16, v13, 8 * v14);
          v15 = *(_DWORD *)(a1 + 16);
        }
        if ((v15 & 1) != 0)
          v17 = a1 + 24;
        else
          v17 = *(_QWORD *)(a1 + 32);
        v18 = *(_QWORD *)(a1 + 8);
        v19 = (void *)(v17 + 8 * v18);
        if ((*(_DWORD *)(a2 + 16) & 1) != 0)
          v20 = a2 + 24;
        else
          v20 = *(_QWORD *)(a2 + 32);
        memcpy(v19, (const void *)(v20 + 8 * v18), 8 * v10 - 8 * v18);
      }
      else
      {
        if ((*(_BYTE *)(a2 + 16) & 1) != 0)
          v11 = (const void *)(a2 + 24);
        else
          v11 = *(const void **)(a2 + 32);
        if ((*(_BYTE *)(a1 + 16) & 1) != 0)
          v12 = (void *)(a1 + 24);
        else
          v12 = *(void **)(a1 + 32);
        memmove(v12, v11, 8 * v10);
      }
      *(_QWORD *)(a1 + 8) = v10;
      *(_QWORD *)(a2 + 8) = 0;
      *(_DWORD *)(a2 + 16) += 4;
      v6 = (_DWORD *)(a1 + 16);
      goto LABEL_37;
    }
    re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1);
    *(_QWORD *)a1 = *(_QWORD *)a2;
    v6 = (_DWORD *)(a1 + 16);
  }
  else
  {
    *(_QWORD *)(a1 + 8) = 0;
    v6 = (_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 16) += 2;
    v7 = *(_QWORD *)(a2 + 8);
    *(_QWORD *)a1 = *(_QWORD *)a2;
    *(_QWORD *)(a1 + 8) = v7;
    *(_QWORD *)a2 = v4;
    *(_QWORD *)(a2 + 8) = 0;
    v8 = *(_QWORD *)(a1 + 32);
    *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
    *(_QWORD *)(a2 + 32) = v8;
    *(_DWORD *)(a2 + 16) = *(_DWORD *)(a2 + 16) & 0xFFFFFFFE | *(_DWORD *)(a1 + 16) & 1;
    *(_DWORD *)(a1 + 16) &= ~1u;
    v9 = *(_QWORD *)(a1 + 24);
    *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
    *(_QWORD *)(a2 + 24) = v9;
  }
  *(_DWORD *)(a2 + 16) += 2;
LABEL_37:
  *v6 += 2;
  return a1;
}

uint64_t re::BucketArray<unsigned long,8ul>::addUninitialized(uint64_t a1)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = *(_QWORD *)(a1 + 40);
  v3 = *(_QWORD *)(a1 + 8);
  if (v2 + 1 > 8 * v3)
  {
    re::BucketArray<unsigned long,8ul>::setBucketsCapacity((uint64_t *)a1, (v2 + 8) >> 3);
    v3 = *(_QWORD *)(a1 + 8);
  }
  if (v3 <= v2 >> 3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
    v4 = a1 + 24;
  else
    v4 = *(_QWORD *)(a1 + 32);
  v5 = *(_QWORD *)(v4 + 8 * (v2 >> 3));
  ++*(_QWORD *)(a1 + 40);
  ++*(_DWORD *)(a1 + 48);
  return v5 + 8 * (v2 & 7);
}

uint64_t *re::BucketArray<unsigned long,8ul>::setBucketsCapacity(uint64_t *result, unint64_t a2)
{
  uint64_t *v3;
  unint64_t v4;
  uint64_t v5;

  v3 = result;
  if (*result)
  {
    if (result[5] < 8 * a2)
    {
      while (1)
      {
        v4 = v3[1];
        if (v4 <= a2)
          break;
        result = (uint64_t *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      while (v4 < a2)
      {
        v5 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)*v3 + 32))(*v3, 64, 0);
        result = (uint64_t *)re::DynamicOverflowArray<RESubscriptionHandle *,2ul>::add((uint64_t)v3, &v5);
        v4 = v3[1];
      }
    }
  }
  else
  {
  }
  return result;
}

uint64_t re::BucketArray<unsigned long,8ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t result;

  *(_QWORD *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((_QWORD *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(_QWORD *)(a1 + 40) = 0;
  result = re::BucketArray<unsigned long,8ul>::setBucketsCapacity(a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

_QWORD *re::BucketArray<re::internal::`anonymous namespace'::RegexTokenGroup::RegexTokenGroupState,64ul>::setBucketsCapacity(_QWORD *result, unint64_t a2)
{
  _QWORD *v3;
  unint64_t v4;
  unint64_t *v5;
  _QWORD *v6;
  unint64_t v7;
  int v8;
  unint64_t v9;
  unint64_t v10;
  BOOL v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  _QWORD *v15;
  unint64_t v16;

  v3 = result;
  if (*result)
  {
    if (result[5] < a2 << 6)
    {
      while (1)
      {
        v4 = v3[1];
        if (v4 <= a2)
          break;
        result = (_QWORD *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        v5 = v3 + 3;
        do
        {
          result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(*(_QWORD *)*v3 + 32))(*v3, 7680, 0);
          v6 = result;
          if (*v3)
          {
            v7 = v3[1];
            v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              v9 = *v5;
              v11 = v7 >= *v5;
              v10 = v7 + 1;
              v11 = !v11 || v9 >= v10;
              if (v11)
                goto LABEL_22;
              v12 = 2 * v9;
              goto LABEL_18;
            }
            v10 = v7 + 1;
            if (v10 >= 3)
            {
              v12 = 4;
LABEL_18:
              if (v12 <= v10)
                v14 = v10;
              else
                v14 = v12;
              result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v14);
              v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            v13 = v3[1] + 1;
            result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v13);
            v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + 4) = v8;
          }
LABEL_22:
          v15 = v3 + 3;
          if ((v8 & 1) == 0)
            v15 = (_QWORD *)v3[4];
          v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
    re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, a2);
    *((_DWORD *)v3 + 4) += 2;
    v3[5] = 0;
    ++*((_DWORD *)v3 + 12);
  }
  return result;
}

uint64_t re::BucketArray<unsigned long,8ul>::deinit(uint64_t a1)
{
  uint64_t v2;
  unint64_t i;
  uint64_t result;

  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    for (i = 0; i != v2; ++i)
      re::BucketArray<NS::SharedPtr<MTL::Buffer>,8ul>::operator[](a1, i);
  }
  while (*(_QWORD *)(a1 + 8))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)a1);
  result = re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1);
  *(_QWORD *)(a1 + 40) = 0;
  ++*(_DWORD *)(a1 + 48);
  return result;
}

uint64_t re::BucketArray<re::BucketArray<re::internal::`anonymous namespace'::MatchStackItem,64ul>,8ul>::BucketArrayIterator<re::BucketArray<re::internal::`anonymous namespace'::MatchStackItem,64ul>,re::BucketArray<re::internal::`anonymous namespace'::MatchStackItem,64ul>&,re::BucketArray<re::BucketArray<re::internal::`anonymous namespace'::MatchStackItem,64ul>,8ul>&,true>::operator*(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1011, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(_QWORD *)(a1 + 8) <= a2 >> 3)
    goto LABEL_8;
  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
    v3 = a1 + 24;
  else
    v3 = *(_QWORD *)(a1 + 32);
  return *(_QWORD *)(v3 + 8 * (a2 >> 3)) + 56 * (a2 & 7);
}

uint64_t re::internal::`anonymous namespace'::RegexTokenCharacterRange::tryMatch(uint64_t a1, uint64_t a2)
{
  char *v2;
  int v3;

  v2 = *(char **)(a2 + 24);
  if ((uint64_t)(*(_QWORD *)(a2 + 16) - (_QWORD)v2) < 1)
    return 0;
  v3 = *v2;
  if (v3 < *(char *)(a1 + 8) || v3 > *(char *)(a1 + 9))
    return 0;
  *(_QWORD *)(a2 + 24) = v2 + 1;
  return 1;
}

_QWORD *re::DynamicArray<re::internal::`anonymous namespace'::RegexTokenCharacterRange>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __int16 *v11;
  _QWORD *v12;
  __int16 v13;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (a2 >> 60)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 16, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          v2 = 16 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 16 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_16;
            goto LABEL_11;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = 16 * v9;
        v11 = (__int16 *)(v8 + 8);
        v12 = v7;
        do
        {
          *v12 = &off_24ED41F20;
          v13 = *v11;
          v11 += 8;
          *((_WORD *)v12 + 4) = v13;
          v12 += 2;
          v10 -= 16;
        }
        while (v10);
        v8 = v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

_QWORD *re::DynamicArray<re::internal::`anonymous namespace'::RegexTokenCharacterSet>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x30uLL))
        {
          v2 = 48 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 48 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_20;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 48, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_20:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = 48 * v9;
        v11 = (_QWORD *)(v8 + 40);
        v12 = v7;
        do
        {
          v12[5] = 0;
          *v12 = &off_24ED41EE0;
          v12[1] = 0;
          v12[2] = 0;
          v12[3] = 0;
          *((_DWORD *)v12 + 8) = 0;
          v13 = *(v11 - 3);
          v12[1] = *(v11 - 4);
          *(v11 - 4) = 0;
          v12[2] = v13;
          *(v11 - 3) = 0;
          v14 = v12[3];
          v12[3] = *(v11 - 2);
          *(v11 - 2) = v14;
          v15 = v12[5];
          v12[5] = *v11;
          *v11 = v15;
          ++*((_DWORD *)v11 - 2);
          ++*((_DWORD *)v12 + 8);
          *(v11 - 5) = &off_24ED41EE0;
          v16 = *(v11 - 4);
          if (v16)
          {
            if (v15)
              (*(void (**)(uint64_t))(*(_QWORD *)v16 + 40))(v16);
            *v11 = 0;
            *(v11 - 3) = 0;
            *(v11 - 2) = 0;
            *(v11 - 4) = 0;
            ++*((_DWORD *)v11 - 2);
          }
          v11 += 6;
          v12 += 6;
          v10 -= 48;
        }
        while (v10);
        v8 = v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_20;
    }
  }
  return result;
}

uint64_t re::internal::`anonymous namespace'::RegexTokenMarker::tryMatch(uint64_t a1, _QWORD *a2)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t result;

  v2 = *(unsigned __int8 *)(a1 + 8);
  if (v2 == 3)
  {
    v5 = a2[2];
    v4 = a2[3];
    return v4 == v5;
  }
  if (v2 == 2)
  {
    v4 = a2[3];
    v5 = a2[1];
    return v4 == v5;
  }
  if (v2 != 1)
  {
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Invalid token marker type.", "!\"Unreachable code\"", "tryMatch", 511);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v3 = a2[3];
  if (v3 == a2[2])
    return 0;
  a2[3] = v3 + 1;
  return 1;
}

_QWORD *re::DynamicArray<re::internal::`anonymous namespace'::RegexTokenMarker>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  _QWORD *v12;
  char v13;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (a2 >> 60)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 16, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          v2 = 16 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 16 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_15;
            goto LABEL_11;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_15:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = 16 * v9;
        v11 = (char *)(v8 + 8);
        v12 = v7;
        do
        {
          *v12 = &off_24ED41F50;
          v13 = *v11;
          v11 += 16;
          *((_BYTE *)v12 + 8) = v13;
          v12 += 2;
          v10 -= 16;
        }
        while (v10);
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_15;
    }
  }
  return result;
}

uint64_t re::internal::`anonymous namespace'::RegexTokenEscapedCharacter::tryMatch(uint64_t a1, _QWORD *a2)
{
  char *v3;
  unsigned __int8 *v4;
  int v5;
  int v6;
  BOOL v7;
  int v9;
  BOOL v10;
  unsigned int v12;
  unsigned int v14;

  v4 = (unsigned __int8 *)a2[2];
  v3 = (char *)a2[3];
  v5 = *(char *)(a1 + 8);
  if (v5 > 89)
  {
    if (v5 <= 114)
    {
      if (v5 != 90)
      {
        if (v5 == 100)
        {
          if (v4 != (unsigned __int8 *)v3 && *v3 - 48 <= 9)
            goto LABEL_55;
          return 0;
        }
        goto LABEL_47;
      }
      return v4 == (unsigned __int8 *)v3;
    }
    if (v5 != 115)
    {
      if (v5 == 119)
      {
        if (v4 != (unsigned __int8 *)v3)
        {
          v9 = *v3;
          v10 = v9 != 95 && (v9 - 48) >= 0xA;
          if (!v10 || (v9 & 0xFFFFFFDF) - 65 <= 0x19)
            goto LABEL_55;
        }
        return 0;
      }
      goto LABEL_47;
    }
    if (v4 == (unsigned __int8 *)v3)
      return 0;
    v14 = *v3;
    if ((v14 & 0x80000000) != 0)
    {
      if (!__maskrune(v14, 0x4000uLL))
        return 0;
    }
    else if ((*(_DWORD *)(MEMORY[0x24BDAC740] + 4 * v14 + 60) & 0x4000) == 0)
    {
      return 0;
    }
  }
  else
  {
    if (v5 <= 82)
    {
      if (v5 != 65)
      {
        if (v5 == 68)
        {
          if (v4 != (unsigned __int8 *)v3 && *v3 - 58 <= 0xFFFFFFF5)
            goto LABEL_55;
          return 0;
        }
LABEL_47:
        if (v4 != (unsigned __int8 *)v3 && *(unsigned __int8 *)(a1 + 8) == *v3)
          goto LABEL_55;
        return 0;
      }
      v4 = (unsigned __int8 *)a2[1];
      return v4 == (unsigned __int8 *)v3;
    }
    if (v5 != 83)
    {
      if (v5 == 87)
      {
        if (v4 != (unsigned __int8 *)v3)
        {
          v6 = *v3;
          v7 = v6 != 95 && (v6 - 48) >= 0xA;
          if (v7 && (v6 & 0xFFFFFFDF) - 65 >= 0x1A)
            goto LABEL_55;
        }
        return 0;
      }
      goto LABEL_47;
    }
    if (v4 == (unsigned __int8 *)v3)
      return 0;
    v12 = *v3;
    if ((v12 & 0x80000000) != 0
       ? __maskrune(v12, 0x4000uLL)
       : *(_DWORD *)(MEMORY[0x24BDAC740] + 4 * v12 + 60) & 0x4000)
    {
      return 0;
    }
  }
  v3 = (char *)a2[3];
LABEL_55:
  a2[3] = v3 + 1;
  return 1;
}

_QWORD *re::DynamicArray<re::internal::`anonymous namespace'::RegexTokenEscapedCharacter>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  _QWORD *v12;
  char v13;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (a2 >> 60)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 16, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          v2 = 16 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 16 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_15;
            goto LABEL_11;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_15:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = 16 * v9;
        v11 = (char *)(v8 + 8);
        v12 = v7;
        do
        {
          *v12 = &off_24ED41F80;
          v13 = *v11;
          v11 += 16;
          *((_BYTE *)v12 + 8) = v13;
          v12 += 2;
          v10 -= 16;
        }
        while (v10);
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_15;
    }
  }
  return result;
}

BOOL re::internal::`anonymous namespace'::RegexTokenCharacter::tryMatch(uint64_t a1, uint64_t a2)
{
  int v2;
  unsigned __int8 *v3;
  int v4;

  v2 = *(unsigned __int8 *)(a1 + 8);
  v3 = *(unsigned __int8 **)(a2 + 24);
  v4 = *v3;
  if (v2 == v4)
    *(_QWORD *)(a2 + 24) = v3 + 1;
  return v2 == v4;
}

_QWORD *re::DynamicArray<re::internal::`anonymous namespace'::RegexTokenCharacter>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  _QWORD *v12;
  char v13;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (a2 >> 60)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 16, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          v2 = 16 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 16 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_15;
            goto LABEL_11;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_15:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = 16 * v9;
        v11 = (char *)(v8 + 8);
        v12 = v7;
        do
        {
          *v12 = &off_24ED41FB0;
          v13 = *v11;
          v11 += 16;
          *((_BYTE *)v12 + 8) = v13;
          v12 += 2;
          v10 -= 16;
        }
        while (v10);
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_15;
    }
  }
  return result;
}

uint64_t re::internal::`anonymous namespace'::RegexOperationList::matchFrom(uint64_t a1, unint64_t a2, _QWORD *a3, uint64_t a4)
{
  unint64_t v8;
  _QWORD *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v19;

  v19 = *(_QWORD *)(a1 + 16);
  if (v19 > a2)
  {
    v8 = a2;
    do
    {
      if (*(_QWORD *)(a1 + 16) <= v8)
        goto LABEL_21;
      v9 = (_QWORD *)*a3;
      v10 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v8);
      if (*(_QWORD *)(*a3 + 296) <= v10)
      {
LABEL_22:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_23:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      v11 = v9[39];
      v12 = *(_QWORD *)(v11 + 24 * v10);
      if (v9[32] <= v12)
        goto LABEL_23;
      {
        v13 = v8 + 1;
      }
      else
      {
        do
        {
          v13 = v8;
          if (v8 <= a2)
            break;
          --v8;
          if (*(_QWORD *)(a1 + 16) <= v13 - 1)
          {
            os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_19:
            os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_20:
            os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_21:
            os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
            goto LABEL_22;
          }
          v14 = (_QWORD *)*a3;
          v15 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v13 - 8);
          if (*(_QWORD *)(*a3 + 296) <= v15)
            goto LABEL_19;
          v16 = v14[39];
          v17 = *(_QWORD *)(v16 + 24 * v15);
          if (v14[32] <= v17)
            goto LABEL_20;
        }
        if (a2 == v13)
          return 0;
      }
      v8 = v13;
    }
    while (v13 < v19);
  }
  return 1;
}

uint64_t re::internal::`anonymous namespace'::RegexToken::unwindMatch(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  unint64_t v4;
  _BYTE *v5;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t (***v12)(_QWORD, uint64_t);
  uint64_t v13;
  uint64_t v14;
  __int128 *v15;
  __int128 v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t result;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  __int128 v31;
  __int128 v32;
  uint64_t v33;
  _BYTE v34[20];
  _BYTE v35[20];
  uint64_t v36;
  int v37;
  _BYTE v38[12];
  __int16 v39;
  int v40;
  __int16 v41;
  unint64_t v42;
  __int16 v43;
  _BYTE *v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  uint64_t v50;

  v50 = *MEMORY[0x24BDAC8D0];
  v8 = a2;
  switch(*(_BYTE *)a1)
  {
    case 1:
      v9 = *(_QWORD *)(a1 + 8);
      v10 = *(_QWORD *)(*a3 + 16);
      if (v10 <= v9)
        goto LABEL_51;
      v11 = *(_QWORD *)(*a3 + 32);
      goto LABEL_10;
    case 2:
      v9 = *(_QWORD *)(a1 + 8);
      v10 = *(_QWORD *)(*a3 + 56);
      if (v10 <= v9)
        goto LABEL_52;
      v11 = *(_QWORD *)(*a3 + 72);
      goto LABEL_10;
    case 3:
      v9 = *(_QWORD *)(a1 + 8);
      v10 = *(_QWORD *)(*a3 + 96);
      if (v10 <= v9)
        goto LABEL_53;
      v11 = *(_QWORD *)(*a3 + 112);
      goto LABEL_10;
    case 4:
      v9 = *(_QWORD *)(a1 + 8);
      v10 = *(_QWORD *)(*a3 + 216);
      if (v10 <= v9)
        goto LABEL_54;
      v11 = *(_QWORD *)(*a3 + 232);
LABEL_10:
      v12 = (uint64_t (***)(_QWORD, uint64_t))(v11 + 16 * v9);
    case 5:
      v9 = *(_QWORD *)(a1 + 8);
      v10 = *(_QWORD *)(*a3 + 136);
      if (v10 <= v9)
        goto LABEL_55;
      v13 = *(_QWORD *)(a4 + 40);
      if (!v13)
        goto LABEL_57;
      v14 = *(_QWORD *)(*a3 + 152) + 40 * v9;
      v16 = v15[1];
      v31 = *v15;
      v32 = v16;
      --*(_QWORD *)(a4 + 40);
      ++*(_DWORD *)(a4 + 48);
      v9 = v17;
      v18 = *(_QWORD *)(v14 + 16);
      v30 = v8;
      if (*(_BYTE *)v17)
        goto LABEL_22;
      if (*(_QWORD *)(v17 + 104) >= (unint64_t)*(int *)(v8 + 8) || !v18)
        goto LABEL_21;
      v4 = 0;
      v28 = v17 + 64;
      v19 = 40;
      break;
    case 6:
      v9 = *(_QWORD *)(a1 + 8);
      v10 = *(_QWORD *)(*a3 + 176);
      if (v10 <= v9)
        goto LABEL_56;
      v12 = (uint64_t (***)(_QWORD, uint64_t))(*(_QWORD *)(*a3 + 192) + 48 * v9);
    default:
      re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Invalid token type.", "!\"Unreachable code\"", "unwindMatch", 948);
      _os_crash();
      __break(1u);
      JUMPOUT(0x225458224);
  }
  do
  {
    *(_QWORD *)v34 = 0;
    *(_QWORD *)&v34[8] = 0;
    *(_DWORD *)&v34[16] = 1;
    v36 = 0;
    *(_OWORD *)&v35[4] = 0uLL;
    v37 = 0;
    v10 = *(_QWORD *)(v14 + 16);
    if (v10 <= v4)
      goto LABEL_47;
    v10 = *(_QWORD *)(*(_QWORD *)(v14 + 32) + 8 * v4);
    v5 = *(_BYTE **)(*a3 + 336);
    if ((unint64_t)v5 <= v10)
      goto LABEL_48;
    {
      *(_QWORD *)re::BucketArray<unsigned long,8ul>::addUninitialized(v28) = v4;
LABEL_42:
      *((_QWORD *)&v32 + 1) = a3[3] - v32;
      return 1;
    }
    ++v4;
  }
  while (v18 != v4);
LABEL_21:
  *(_BYTE *)v9 = 1;
  v8 = v30;
LABEL_22:
  v20 = *(_QWORD *)(v9 + 104);
  if (v20 && v20 >= *(int *)(v8 + 4))
  {
    v21 = v9 + 64;
    v5 = &v35[4];
    v27 = v9 + 8;
    v29 = v9 + 64;
    while (1)
    {
      v19 = *(_QWORD *)re::BucketArray<NS::SharedPtr<MTL::Buffer>,8ul>::operator[](v21, v20 - 1);
      v10 = *(_QWORD *)(v14 + 16);
      if (v10 <= v19)
        goto LABEL_49;
      v10 = *(_QWORD *)(*(_QWORD *)(v14 + 32) + 8 * v19);
      v4 = *(_QWORD *)(*a3 + 336);
      if (v4 <= v10)
        goto LABEL_50;
      if (++v19 < v18)
        break;
LABEL_34:
      --*(_QWORD *)(v9 + 48);
      ++*(_DWORD *)(v9 + 56);
      v21 = v9 + 64;
      re::BucketArray<NS::SharedPtr<MTL::Buffer>,8ul>::operator[](v29, *(_QWORD *)(v9 + 104) - 1);
      v23 = *(_QWORD *)(v9 + 104);
      ++*(_DWORD *)(v9 + 112);
      v20 = v23 - 1;
      *(_QWORD *)(v9 + 104) = v20;
      if (!v20 || v20 < *(int *)(v30 + 4))
        goto LABEL_36;
    }
    v26 = a3[3];
    while (1)
    {
      *(_QWORD *)v34 = 0;
      *(_QWORD *)&v34[8] = 0;
      *(_DWORD *)&v34[16] = 1;
      *(_QWORD *)&v35[12] = 0;
      v36 = 0;
      *(_QWORD *)&v35[4] = 0;
      v37 = 0;
      v10 = *(_QWORD *)(v14 + 16);
      if (v10 <= v19)
        break;
      v10 = *(_QWORD *)(*(_QWORD *)(v14 + 32) + 8 * v19);
      v4 = *(_QWORD *)(*a3 + 336);
      if (v4 <= v10)
        goto LABEL_46;
      {
        *(_QWORD *)re::BucketArray<unsigned long,8ul>::addUninitialized(v29) = v19;
        v25 = a3[3] - v26;
        *(_QWORD *)&v32 = v26;
        *((_QWORD *)&v32 + 1) = v25;
        return 1;
      }
      if (v18 == ++v19)
        goto LABEL_34;
    }
    v33 = 0;
    v48 = 0u;
    v49 = 0u;
    v46 = 0u;
    v47 = 0u;
    v45 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v38 = 136315906;
    *(_QWORD *)&v38[4] = "operator[]";
    v39 = 1024;
    v40 = 797;
    v41 = 2048;
    v42 = v19;
    v43 = 2048;
    v44 = (_BYTE *)v10;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_46:
    v33 = 0;
    v48 = 0u;
    v49 = 0u;
    v46 = 0u;
    v47 = 0u;
    v45 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v38 = 136315906;
    *(_QWORD *)&v38[4] = "operator[]";
    v39 = 1024;
    v40 = 797;
    v41 = 2048;
    v42 = v10;
    v43 = 2048;
    v44 = (_BYTE *)v4;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_47:
    v33 = 0;
    v48 = 0u;
    v49 = 0u;
    v46 = 0u;
    v47 = 0u;
    v45 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v38 = 136315906;
    *(_QWORD *)&v38[4] = "operator[]";
    v39 = 1024;
    v40 = 797;
    v41 = 2048;
    v42 = v4;
    v43 = 2048;
    v44 = (_BYTE *)v10;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_48:
    v33 = 0;
    v48 = 0u;
    v49 = 0u;
    v46 = 0u;
    v47 = 0u;
    v45 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v38 = 136315906;
    *(_QWORD *)&v38[4] = "operator[]";
    v39 = 1024;
    v40 = 797;
    v41 = 2048;
    v42 = v10;
    v43 = 2048;
    v44 = v5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_49:
    *(_QWORD *)v38 = 0;
    v48 = 0u;
    v49 = 0u;
    v46 = 0u;
    v47 = 0u;
    v45 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v34 = 136315906;
    *(_QWORD *)&v34[4] = "operator[]";
    *(_WORD *)&v34[12] = 1024;
    *(_DWORD *)&v34[14] = 797;
    *(_WORD *)&v34[18] = 2048;
    *(_QWORD *)v35 = v19;
    *(_WORD *)&v35[8] = 2048;
    *(_QWORD *)&v35[10] = v10;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_50:
    *(_QWORD *)v38 = 0;
    v48 = 0u;
    v49 = 0u;
    v46 = 0u;
    v47 = 0u;
    v45 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v34 = 136315906;
    *(_QWORD *)&v34[4] = "operator[]";
    *(_WORD *)&v34[12] = 1024;
    *(_DWORD *)&v34[14] = 797;
    *(_WORD *)&v34[18] = 2048;
    *(_QWORD *)v35 = v10;
    *(_WORD *)&v35[8] = 2048;
    *(_QWORD *)&v35[10] = v4;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_51:
    *(_QWORD *)v38 = 0;
    v48 = 0u;
    v49 = 0u;
    v46 = 0u;
    v47 = 0u;
    v45 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v34 = 136315906;
    *(_QWORD *)&v34[4] = "operator[]";
    *(_WORD *)&v34[12] = 1024;
    *(_DWORD *)&v34[14] = 797;
    *(_WORD *)&v34[18] = 2048;
    *(_QWORD *)v35 = v9;
    *(_WORD *)&v35[8] = 2048;
    *(_QWORD *)&v35[10] = v10;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_52:
    *(_QWORD *)v38 = 0;
    v48 = 0u;
    v49 = 0u;
    v46 = 0u;
    v47 = 0u;
    v45 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v34 = 136315906;
    *(_QWORD *)&v34[4] = "operator[]";
    *(_WORD *)&v34[12] = 1024;
    *(_DWORD *)&v34[14] = 797;
    *(_WORD *)&v34[18] = 2048;
    *(_QWORD *)v35 = v9;
    *(_WORD *)&v35[8] = 2048;
    *(_QWORD *)&v35[10] = v10;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_53:
    *(_QWORD *)v38 = 0;
    v48 = 0u;
    v49 = 0u;
    v46 = 0u;
    v47 = 0u;
    v45 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v34 = 136315906;
    *(_QWORD *)&v34[4] = "operator[]";
    *(_WORD *)&v34[12] = 1024;
    *(_DWORD *)&v34[14] = 797;
    *(_WORD *)&v34[18] = 2048;
    *(_QWORD *)v35 = v9;
    *(_WORD *)&v35[8] = 2048;
    *(_QWORD *)&v35[10] = v10;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_54:
    *(_QWORD *)v38 = 0;
    v48 = 0u;
    v49 = 0u;
    v46 = 0u;
    v47 = 0u;
    v45 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v34 = 136315906;
    *(_QWORD *)&v34[4] = "operator[]";
    *(_WORD *)&v34[12] = 1024;
    *(_DWORD *)&v34[14] = 797;
    *(_WORD *)&v34[18] = 2048;
    *(_QWORD *)v35 = v9;
    *(_WORD *)&v35[8] = 2048;
    *(_QWORD *)&v35[10] = v10;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_55:
    *(_QWORD *)v38 = 0;
    v48 = 0u;
    v49 = 0u;
    v46 = 0u;
    v47 = 0u;
    v45 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v34 = 136315906;
    *(_QWORD *)&v34[4] = "operator[]";
    *(_WORD *)&v34[12] = 1024;
    *(_DWORD *)&v34[14] = 797;
    *(_WORD *)&v34[18] = 2048;
    *(_QWORD *)v35 = v9;
    *(_WORD *)&v35[8] = 2048;
    *(_QWORD *)&v35[10] = v10;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_56:
    *(_QWORD *)v38 = 0;
    v48 = 0u;
    v49 = 0u;
    v46 = 0u;
    v47 = 0u;
    v45 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v34 = 136315906;
    *(_QWORD *)&v34[4] = "operator[]";
    *(_WORD *)&v34[12] = 1024;
    *(_DWORD *)&v34[14] = 797;
    *(_WORD *)&v34[18] = 2048;
    *(_QWORD *)v35 = v9;
    *(_WORD *)&v35[8] = 2048;
    *(_QWORD *)&v35[10] = v10;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_57:
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    _os_crash();
    __break(1u);
  }
LABEL_36:
  result = 0;
  a3[3] = v32;
  return result;
}

uint64_t re::internal::`anonymous namespace'::RegexBasicToken::unwindMatch(uint64_t (***a1)(_QWORD, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  char v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t result;

  v4 = *(_QWORD *)(a4 + 40);
  if (v4)
  {
    v10 = *(_DWORD *)(v9 + 24);
    if (v10)
    {
      v11 = v9;
      if (*(_BYTE *)a2)
      {
        if (*(_DWORD *)(a2 + 4) < v10)
        {
          v12 = *(_QWORD *)(a3 + 24) - 1;
          *(_QWORD *)(a3 + 24) = v12;
          *(_QWORD *)(v9 + 24) = v12 - *(_QWORD *)(v9 + 16);
          return 1;
        }
        v14 = *(_QWORD *)(v9 + 16);
      }
      else
      {
        v13 = (**a1)(a1, a3);
        v14 = *(_QWORD *)(v11 + 16);
        if ((v13 & 1) != 0)
        {
          v15 = *(_QWORD *)(a3 + 24) - v14;
          *(_QWORD *)(v11 + 24) = v15;
          if (v15 <= *(int *)(a2 + 8))
            return 1;
        }
      }
      *(_QWORD *)(a3 + 24) = v14;
    }
    result = 0;
    --*(_QWORD *)(a4 + 40);
    ++*(_DWORD *)(a4 + 48);
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::BucketArray<re::internal::`anonymous namespace'::MatchStackItem,64ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1011, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(_QWORD *)(a1 + 8) <= a2 >> 6)
    goto LABEL_8;
  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
    v3 = a1 + 24;
  else
    v3 = *(_QWORD *)(a1 + 32);
  return *(_QWORD *)(v3 + 8 * (a2 >> 6)) + 32 * (a2 & 0x3F);
}

uint64_t re::BucketArray<re::internal::`anonymous namespace'::RegexTokenGroup::RegexTokenGroupState,64ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1011, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(_QWORD *)(a1 + 8) <= a2 >> 6)
    goto LABEL_8;
  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
    v3 = a1 + 24;
  else
    v3 = *(_QWORD *)(a1 + 32);
  return *(_QWORD *)(v3 + 8 * (a2 >> 6)) + 120 * (a2 & 0x3F);
}

void std::__function::__func<re::internal::regularExpressionCreate(char const*)::$_0,std::allocator<re::internal::regularExpressionCreate(char const*)::$_0>,void ()(re::internal::RegexRoot *)>::~__func()
{
  JUMPOUT(0x2276933B8);
}

_QWORD *std::__function::__func<re::internal::regularExpressionCreate(char const*)::$_0,std::allocator<re::internal::regularExpressionCreate(char const*)::$_0>,void ()(re::internal::RegexRoot *)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_24ED41FE0;
  return result;
}

void std::__function::__func<re::internal::regularExpressionCreate(char const*)::$_0,std::allocator<re::internal::regularExpressionCreate(char const*)::$_0>,void ()(re::internal::RegexRoot *)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24ED41FE0;
}

re *std::__function::__func<re::internal::regularExpressionCreate(char const*)::$_0,std::allocator<re::internal::regularExpressionCreate(char const*)::$_0>,void ()(re::internal::RegexRoot *)>::operator()(re *result, _QWORD **a2)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  v2 = *a2;
  if (*a2)
  {
    v3 = re::globalAllocators(result)[2];
    v4 = v2[45];
    if (v4)
    {
      if (v2[49])
        (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
      v2[49] = 0;
      v2[46] = 0;
      v2[47] = 0;
      v2[45] = 0;
      ++*((_DWORD *)v2 + 96);
    }
    v5 = v2[40];
    if (v5)
    {
      v6 = v2[44];
      if (v6)
      {
        v7 = v2[42];
        if (v7)
        {
          v8 = 40 * v7;
          v9 = (_QWORD *)(v6 + 32);
          do
          {
            v10 = *(v9 - 4);
            if (v10)
            {
              if (*v9)
                (*(void (**)(uint64_t))(*(_QWORD *)v10 + 40))(v10);
              *v9 = 0;
              *(v9 - 3) = 0;
              *(v9 - 2) = 0;
              *(v9 - 4) = 0;
              ++*((_DWORD *)v9 - 2);
            }
            v9 += 5;
            v8 -= 40;
          }
          while (v8);
          v5 = v2[40];
          v6 = v2[44];
        }
        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v5 + 40))(v5, v6);
      }
      v2[44] = 0;
      v2[41] = 0;
      v2[42] = 0;
      v2[40] = 0;
      ++*((_DWORD *)v2 + 86);
    }
    v11 = v2[35];
    if (v11)
    {
      if (v2[39])
        (*(void (**)(uint64_t))(*(_QWORD *)v11 + 40))(v11);
      v2[39] = 0;
      v2[36] = 0;
      v2[37] = 0;
      v2[35] = 0;
      ++*((_DWORD *)v2 + 76);
    }
    v12 = v2[30];
    if (v12)
    {
      if (v2[34])
        (*(void (**)(uint64_t))(*(_QWORD *)v12 + 40))(v12);
      v2[34] = 0;
      v2[31] = 0;
      v2[32] = 0;
      v2[30] = 0;
      ++*((_DWORD *)v2 + 66);
    }
    v13 = v2[25];
    if (v13)
    {
      if (v2[29])
        (*(void (**)(uint64_t))(*(_QWORD *)v13 + 40))(v13);
      v2[29] = 0;
      v2[26] = 0;
      v2[27] = 0;
      v2[25] = 0;
      ++*((_DWORD *)v2 + 56);
    }
    v14 = v2[20];
    if (v14)
    {
      v15 = v2[24];
      if (v15)
      {
        v16 = v2[22];
        if (v16)
        {
          v17 = 48 * v16;
          v18 = (_QWORD *)(v15 + 40);
          do
          {
            v19 = *(v18 - 4);
            *(v18 - 5) = &off_24ED41EE0;
            if (v19)
            {
              if (*v18)
                (*(void (**)(uint64_t))(*(_QWORD *)v19 + 40))(v19);
              *v18 = 0;
              *(v18 - 3) = 0;
              *(v18 - 2) = 0;
              *(v18 - 4) = 0;
              ++*((_DWORD *)v18 - 2);
            }
            v18 += 6;
            v17 -= 48;
          }
          while (v17);
          v14 = v2[20];
          v15 = v2[24];
        }
        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v14 + 40))(v14, v15);
      }
      v2[24] = 0;
      v2[21] = 0;
      v2[22] = 0;
      v2[20] = 0;
      ++*((_DWORD *)v2 + 46);
    }
    v20 = v2[15];
    if (v20)
    {
      v21 = v2[19];
      if (v21)
      {
        v22 = v2[17];
        if (v22)
        {
          v23 = 40 * v22;
          v24 = (_QWORD *)(v21 + 32);
          do
          {
            v25 = *(v24 - 4);
            if (v25)
            {
              if (*v24)
                (*(void (**)(uint64_t))(*(_QWORD *)v25 + 40))(v25);
              *v24 = 0;
              *(v24 - 3) = 0;
              *(v24 - 2) = 0;
              *(v24 - 4) = 0;
              ++*((_DWORD *)v24 - 2);
            }
            v24 += 5;
            v23 -= 40;
          }
          while (v23);
          v20 = v2[15];
          v21 = v2[19];
        }
        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v20 + 40))(v20, v21);
      }
      v2[19] = 0;
      v2[16] = 0;
      v2[17] = 0;
      v2[15] = 0;
      ++*((_DWORD *)v2 + 36);
    }
    v26 = v2[10];
    if (v26)
    {
      if (v2[14])
        (*(void (**)(uint64_t))(*(_QWORD *)v26 + 40))(v26);
      v2[14] = 0;
      v2[11] = 0;
      v2[12] = 0;
      v2[10] = 0;
      ++*((_DWORD *)v2 + 26);
    }
    v27 = v2[5];
    if (v27)
    {
      if (v2[9])
        (*(void (**)(uint64_t))(*(_QWORD *)v27 + 40))(v27);
      v2[9] = 0;
      v2[6] = 0;
      v2[7] = 0;
      v2[5] = 0;
      ++*((_DWORD *)v2 + 16);
    }
    if (*v2)
    {
      if (v2[4])
        (*(void (**)(_QWORD))(*(_QWORD *)*v2 + 40))(*v2);
      v2[4] = 0;
      v2[1] = 0;
      v2[2] = 0;
      *v2 = 0;
      ++*((_DWORD *)v2 + 6);
    }
    return (re *)(*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v3 + 40))(v3, v2);
  }
  return result;
}

uint64_t std::__function::__func<re::internal::regularExpressionCreate(char const*)::$_0,std::allocator<re::internal::regularExpressionCreate(char const*)::$_0>,void ()(re::internal::RegexRoot *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::internal::regularExpressionCreate(char const*)::$_0,std::allocator<re::internal::regularExpressionCreate(char const*)::$_0>,void ()(re::internal::RegexRoot *)>::target_type()
{
}

uint64_t re::internal::assertLog(re::internal *this, uint64_t a2, ...)
{
  return os_log_with_args();
}

size_t re::internal::FixedLengthString::append(size_t this, const char *a2)
{
  size_t v2;
  size_t v3;
  size_t v4;

  v2 = *(_QWORD *)(this + 8);
  if (v2)
  {
    v3 = this;
    strncpy(*(char **)this, a2, v2);
    *(_BYTE *)(*(_QWORD *)(v3 + 8) + *(_QWORD *)v3 - 1) = 0;
    this = strlen(*(const char **)v3);
    v4 = *(_QWORD *)(v3 + 8) - this;
    *(_QWORD *)v3 += this;
    *(_QWORD *)(v3 + 8) = v4;
  }
  return this;
}

void re::internal::logStackTrace(re::internal *this, const char *a2, const char *a3)
{
  int v5;
  char **v6;
  const char *v7;
  const char *v8;
  unint64_t v9;
  const char *v10;
  uint64_t v11;
  NSObject *v12;
  const char *v13;
  int v14;
  const char *v15;
  int v16;
  int v17;
  int v18;
  int v19;
  const char *v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  const char *v27;
  char *v28;
  const char *v29;
  const char *v30;
  uint8_t v31[4];
  const char *v32;
  __int16 v33;
  _BYTE *v34;
  _BYTE buf[264];
  void *v36[2];
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  uint64_t v68;

  v68 = *MEMORY[0x24BDAC8D0];
  if (os_variant_has_internal_diagnostics()
    && (unint64_t)re::internal::logStackTrace(char const*,char const*)::nInvocations <= 0x3F)
  {
    ++re::internal::logStackTrace(char const*,char const*)::nInvocations;
    v66 = 0u;
    v67 = 0u;
    v64 = 0u;
    v65 = 0u;
    v62 = 0u;
    v63 = 0u;
    v60 = 0u;
    v61 = 0u;
    v58 = 0u;
    v59 = 0u;
    v56 = 0u;
    v57 = 0u;
    v54 = 0u;
    v55 = 0u;
    v52 = 0u;
    v53 = 0u;
    v50 = 0u;
    v51 = 0u;
    v48 = 0u;
    v49 = 0u;
    v46 = 0u;
    v47 = 0u;
    v44 = 0u;
    v45 = 0u;
    v42 = 0u;
    v43 = 0u;
    v40 = 0u;
    v41 = 0u;
    v38 = 0u;
    v39 = 0u;
    *(_OWORD *)v36 = 0u;
    v37 = 0u;
    v5 = backtrace(v36, 64);
    v6 = backtrace_symbols(v36, v5);
    if (os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_DEFAULT))
    {
      if (a2)
        v7 = a2;
      else
        v7 = "";
      v8 = "Stack trace:";
      if (this)
        v8 = (const char *)this;
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = v7;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = v8;
      _os_log_impl(&dword_224FE9000, MEMORY[0x24BDACB70], OS_LOG_TYPE_DEFAULT, "%s%s", buf, 0x16u);
    }
    v9 = v5 - 1;
    if (v9 >= 3)
    {
      if (a2)
        v10 = a2;
      else
        v10 = "";
      v30 = v10;
      v11 = 2;
      v12 = MEMORY[0x24BDACB70];
      do
      {
        v13 = v6[v11];
        v14 = *(unsigned __int8 *)v13;
        v15 = v13;
        while ((v14 & 0xFFFFFFDF) != 0)
        {
          v16 = *(unsigned __int8 *)++v15;
          v14 = v16;
        }
        while (v14 == 32)
        {
          v17 = *(unsigned __int8 *)++v15;
          v14 = v17;
        }
        if ((v14 & 0xFFFFFFDF) != 0)
        {
          do
          {
            v18 = *(unsigned __int8 *)++v15;
            v14 = v18;
          }
          while ((v18 & 0xFFFFFFDF) != 0);
          while (v14 == 32)
          {
            v19 = *(unsigned __int8 *)++v15;
            v14 = v19;
          }
        }
        v20 = v15;
        if (v14)
        {
          v20 = v15 + 1;
          v21 = *((unsigned __int8 *)v15 + 1);
          *v15 = 0;
          while ((v21 & 0xFFFFFFDF) != 0)
          {
            v22 = *(unsigned __int8 *)++v20;
            v21 = v22;
          }
          while (v21 == 32)
          {
            v23 = *(unsigned __int8 *)++v20;
            v21 = v23;
          }
          if (v21)
          {
            v24 = 0;
            v15 = v20;
            while (v21 != 32 || v24)
            {
              v25 = v24 - 1;
              if (v21 == 91)
                ++v24;
              if (v21 == 93)
                v24 = v25;
              v26 = *(unsigned __int8 *)++v15;
              v21 = v26;
              if (!v26)
                goto LABEL_43;
            }
            *v15 = 0;
          }
          else
          {
            v15 = v20;
          }
        }
LABEL_43:
        v27 = v15 + 1;
        v28 = __cxa_demangle(v20, 0, 0, 0);
        *(_QWORD *)buf = &buf[16];
        *(_QWORD *)&buf[8] = 256;
        re::internal::FixedLengthString::append((size_t)buf, v13);
        re::internal::FixedLengthString::append((size_t)buf, " ");
        if (v28)
          v29 = v28;
        else
          v29 = v20;
        re::internal::FixedLengthString::append((size_t)buf, v29);
        re::internal::FixedLengthString::append((size_t)buf, " ");
        re::internal::FixedLengthString::append((size_t)buf, v27);
        if (v28)
          free(v28);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)v31 = 136315394;
          v32 = v30;
          v33 = 2080;
          v34 = &buf[16];
          _os_log_impl(&dword_224FE9000, v12, OS_LOG_TYPE_DEFAULT, "%s%s", v31, 0x16u);
        }
        ++v11;
      }
      while (v11 != v9);
    }
    free(v6);
  }
}

void re::readBooleanEnvironmentVariable(re *this@<X0>, uint64_t a2@<X8>)
{
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  int v9;
  id v10;

  v10 = objc_alloc_init(MEMORY[0x24BDD1760]);
  objc_msgSend(v10, "environment");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", this);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v5, "objectForKey:", v6);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v7, "lowercaseString");
  v8 = (void *)objc_claimAutoreleasedReturnValue();

  if (v8)
  {
    if (objc_msgSend(v8, "isEqualToString:", CFSTR("1"))
      || objc_msgSend(v8, "isEqualToString:", CFSTR("true")))
    {
      *(_WORD *)a2 = 257;
    }
    else
    {
      v9 = objc_msgSend(v8, "isEqualToString:", CFSTR("yes"));
      *(_BYTE *)a2 = 1;
      if (v9)
        *(_BYTE *)(a2 + 1) = 1;
      else
        *(_BYTE *)(a2 + 1) = 0;
    }
  }
  else
  {
    *(_BYTE *)a2 = 0;
  }

}

uint64_t *re::foundationCoreLogObjects(re *this)
{
  unsigned __int8 v1;

  {
    re::foundationCoreLogObjects(void)::logObjects = (uint64_t)os_log_create("com.apple.re", "Foundation.Core");
  }
  return &re::foundationCoreLogObjects(void)::logObjects;
}

size_t re::packCharArrayToUInt64ForAriadne(re *this, const char *a2)
{
  int v2;
  size_t result;
  unint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;

  v2 = (int)a2;
  result = strlen((const char *)this);
  if (result)
  {
    if (result <= v2)
      return 0;
    v5 = result - v2;
    if (v5 >= 8)
      LODWORD(v5) = 8;
    v6 = result <= 8 ? result : v5;
    if (v6 < 1)
    {
      return 0;
    }
    else
    {
      v7 = 0;
      v8 = v6 + v2;
      do
      {
        result = v7 | *((char *)this + v8 - 1);
        v7 = result << 8;
        --v8;
      }
      while (v8 > v2);
    }
  }
  return result;
}

BOOL re::internal::enableSignposts(re::internal *this, uint64_t a2)
{
  unsigned __int8 v2;
  int v4;
  BOOL v5;
  char v6;
  unsigned int v7;
  char v8;
  _BYTE v9[4];
  int v10;

  if ((v2 & 1) == 0)
  {
    v7 = a2;
    v8 = (char)this;
    a2 = v7;
    LOBYTE(this) = v8;
    if (v4)
    {
      re::Defaults::intValue((re::Defaults *)"enableSignposts", (const char *)v7, (uint64_t)v9);
      if (v9[0])
        v5 = v10 == 0;
      else
        v5 = 0;
      v6 = !v5;
      re::internal::enableSignposts(BOOL,BOOL)::value = v6;
      a2 = v7;
      LOBYTE(this) = v8;
    }
  }
  if ((this & 1) == 0)
    return re::internal::enableSignposts(BOOL,BOOL)::value != 0;
  re::internal::enableSignposts(BOOL,BOOL)::value = a2;
  return a2;
}

BOOL re::internal::enableHighFrequencyTracing(re::internal *this, uint64_t a2)
{
  unsigned __int8 v2;
  int v4;
  BOOL v5;
  char v6;
  unsigned int v7;
  char v8;
  _BYTE v9[4];
  int v10;

  if ((v2 & 1) == 0)
  {
    v7 = a2;
    v8 = (char)this;
    a2 = v7;
    LOBYTE(this) = v8;
    if (v4)
    {
      re::Defaults::intValue((re::Defaults *)"enableHighFrequencyTracing", (const char *)v7, (uint64_t)v9);
      if (v9[0])
        v5 = v10 == 0;
      else
        v5 = 1;
      v6 = !v5;
      re::internal::enableHighFrequencyTracing(BOOL,BOOL)::value = v6;
      a2 = v7;
      LOBYTE(this) = v8;
    }
  }
  if ((this & 1) == 0)
    return re::internal::enableHighFrequencyTracing(BOOL,BOOL)::value != 0;
  re::internal::enableHighFrequencyTracing(BOOL,BOOL)::value = a2;
  return a2;
}

BOOL re::internal::enableHighFrequencyNetworkTracing(re::internal *this, uint64_t a2)
{
  unsigned __int8 v2;
  int v4;
  BOOL v5;
  char v6;
  unsigned int v7;
  char v8;
  _BYTE v9[4];
  int v10;

  if ((v2 & 1) == 0)
  {
    v7 = a2;
    v8 = (char)this;
    a2 = v7;
    LOBYTE(this) = v8;
    if (v4)
    {
      re::Defaults::intValue((re::Defaults *)"enableHighFrequencyNetworkTracing", (const char *)v7, (uint64_t)v9);
      if (v9[0])
        v5 = v10 == 0;
      else
        v5 = 1;
      v6 = !v5;
      re::internal::enableHighFrequencyNetworkTracing(BOOL,BOOL)::value = v6;
      a2 = v7;
      LOBYTE(this) = v8;
    }
  }
  if ((this & 1) == 0)
    return re::internal::enableHighFrequencyNetworkTracing(BOOL,BOOL)::value != 0;
  re::internal::enableHighFrequencyNetworkTracing(BOOL,BOOL)::value = a2;
  return a2;
}

void re::FoundationErrorCategoryImpl::~FoundationErrorCategoryImpl(std::error_category *this)
{
  std::error_category::~error_category(this);
  JUMPOUT(0x2276933B8);
}

const char *re::FoundationErrorCategoryImpl::name(re::FoundationErrorCategoryImpl *this)
{
  return "REFoundation error";
}

_QWORD *re::FoundationErrorCategoryImpl::message@<X0>(int a1@<W1>, _QWORD *a2@<X8>)
{
  char *v3;

  if (a1 > 299)
  {
    if (a1 == 300)
    {
      v3 = "File I/O error";
      return std::string::basic_string[abi:nn180100]<0>(a2, v3);
    }
    if (a1 == 400)
    {
      v3 = "Serialization error";
      return std::string::basic_string[abi:nn180100]<0>(a2, v3);
    }
LABEL_9:
    v3 = "Unknown REFoundation error";
    return std::string::basic_string[abi:nn180100]<0>(a2, v3);
  }
  if (a1 == 100)
  {
    v3 = "Unexpected error";
    return std::string::basic_string[abi:nn180100]<0>(a2, v3);
  }
  if (a1 != 200)
    goto LABEL_9;
  v3 = "JSON serialization error";
  return std::string::basic_string[abi:nn180100]<0>(a2, v3);
}

void re::EventBus::~EventBus(re::EventBus *this)
{
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)this + 19);
  re::Queue<re::EventBus::DeferredEvent>::deinit((uint64_t *)this + 13);
  re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)this + 24);
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  re::EventBus::~EventBus(this);
  JUMPOUT(0x2276933B8);
}

_QWORD *re::EventBus::EventInfo::publish(re::EventBus::EventInfo *this, uint64_t a2, uint64_t a3, const void *a4)
{
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  _QWORD *v13;
  double v14;
  __n128 v15;
  uint64_t v17;
  const void *v18;

  ++*((_DWORD *)this + 4);
  if (a4 && a2 && *((_BYTE *)this + 23))
  {
    v17 = a2;
    v18 = a4;
    v8 = re::HashBrown<re::Pair<void const*,void const*,true>,re::EventBus::Subscriptions,re::Hash<re::Pair<void const*,void const*,true>>,re::EqualTo<re::Pair<void const*,void const*,true>>,void,false>::find((uint64_t *)this + 27, &v17);
    if (v8 == -1)
      v9 = 0;
    else
      v9 = (_QWORD *)(*((_QWORD *)this + 28) + 144 * v8 + 16);
    re::EventBus::EventInfo::publish(void *,void const*,void const*)::$_0::operator()<re::EventBus::Subscriptions>((uint64_t)this, v9, a2, a3);
  }
  if (a2 && *((_BYTE *)this + 21))
  {
    v17 = a2;
    v18 = 0;
    v10 = re::HashBrown<re::Pair<void const*,void const*,true>,re::EventBus::Subscriptions,re::Hash<re::Pair<void const*,void const*,true>>,re::EqualTo<re::Pair<void const*,void const*,true>>,void,false>::find((uint64_t *)this + 27, &v17);
    if (v10 == -1)
      v11 = 0;
    else
      v11 = (_QWORD *)(*((_QWORD *)this + 28) + 144 * v10 + 16);
    re::EventBus::EventInfo::publish(void *,void const*,void const*)::$_0::operator()<re::EventBus::Subscriptions>((uint64_t)this, v11, a2, a3);
  }
  if (a4 && *((_BYTE *)this + 22))
  {
    v17 = 0;
    v18 = a4;
    v12 = re::HashBrown<re::Pair<void const*,void const*,true>,re::EventBus::Subscriptions,re::Hash<re::Pair<void const*,void const*,true>>,re::EqualTo<re::Pair<void const*,void const*,true>>,void,false>::find((uint64_t *)this + 27, &v17);
    if (v12 == -1)
      v13 = 0;
    else
      v13 = (_QWORD *)(*((_QWORD *)this + 28) + 144 * v12 + 16);
    re::EventBus::EventInfo::publish(void *,void const*,void const*)::$_0::operator()<re::EventBus::Subscriptions>((uint64_t)this, v13, a2, a3);
  }
  re::EventBus::EventInfo::publish(void *,void const*,void const*)::$_0::operator()<re::EventBus::Subscriptions>((uint64_t)this, (_QWORD *)this + 11, a2, a3);
  return re::EventBus::EventInfo::stopPublishing(this, v14, v15);
}

uint64_t re::EventBus::EventInfo::publish(void *,void const*,void const*)::$_0::operator()<re::EventBus::Subscriptions>(uint64_t result, _QWORD *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  re::EventBus::EventInfo *v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  unint64_t v12;
  unint64_t v13;
  _BYTE v14[12];
  __int16 v15;
  int v16;
  __int16 v17;
  unint64_t v18;
  __int16 v19;
  unint64_t v20;
  _OWORD v21[5];
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  if (a2)
  {
    v5 = a2[2];
    if (v5)
    {
      v8 = (re::EventBus::EventInfo *)result;
      v9 = a2[4];
      v10 = v5 << 6;
      v11 = (_QWORD *)(v9 + 56);
      do
      {
        *(_QWORD *)&v21[0] = a3;
        *(_QWORD *)v14 = a4;
        result = (*(uint64_t (**)(_QWORD, _OWORD *, _BYTE *))(*(_QWORD *)*v11 + 16))(*v11, v21, v14);
        if ((_DWORD)result == 1)
        {
          v12 = (v9 - a2[4]) >> 6;
          v13 = a2[7];
          if (v13 <= v12)
          {
            memset(v21, 0, sizeof(v21));
            os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
            *(_DWORD *)v14 = 136315906;
            *(_QWORD *)&v14[4] = "operator[]";
            v15 = 1024;
            v16 = 797;
            v17 = 2048;
            v18 = v12;
            v19 = 2048;
            v20 = v13;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
          }
          result = re::EventBus::EventInfo::removeSubscription(v8, *(_QWORD *)(a2[9] + 8 * v12));
        }
        v9 += 64;
        v11 += 8;
        v10 -= 64;
      }
      while (v10);
    }
  }
  return result;
}

_QWORD *re::EventBus::EventInfo::stopPublishing(_QWORD *this, double a2, __n128 a3)
{
  int v3;
  _QWORD *v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  __n128 v9;
  unsigned __int16 v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD v17[2];
  uint64_t v18;

  v3 = *((_DWORD *)this + 4) - 1;
  *((_DWORD *)this + 4) = v3;
  if (!v3)
  {
    v4 = this;
    if (this[38])
    {
      v17[0] = this + 35;
      v5 = this[37];
      if (v5 >= 0x10)
      {
        v6 = 0;
        v7 = this[35];
        v8 = v5 >> 4;
        v9 = (__n128)xmmword_2260EE390;
        a3.n128_u64[0] = 0x3830282018100800;
        while (1)
        {
          v10 = vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vcltzq_s8(*(int8x16_t *)(v7 + v6)), (int8x16_t)xmmword_2260EE390)))), (int8x8_t)0x3830282018100800).u16[0];
          v17[1] = (unsigned __int16)~v10;
          if (v10 != 0xFFFF)
            break;
          v6 += 16;
          if (!--v8)
            goto LABEL_12;
        }
        v11 = __clz(__rbit64((unsigned __int16)~v10)) + v6;
        v18 = v11;
        if (v11 != -1)
        {
          do
          {
            v12 = *(_QWORD *)(*(_QWORD *)(v17[0] + 8) + 56 * v11 + 48);
            (*(void (**)(uint64_t, __n128, __n128))(*(_QWORD *)v12 + 16))(v12, v9, a3);
            this = re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::HashBrownIterator<re::KeyValuePair<unsigned long long const&,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>&>>::operator++(v17);
            v11 = v18;
          }
          while (v18 != -1);
          v5 = v4[37];
        }
      }
LABEL_12:
      v4[40] = 0;
      v4[41] = 0;
      v4[38] = 0;
      v4[39] = v5;
      if (v5 >= 0x10)
      {
        v13 = 0;
        *(_QWORD *)&v14 = -1;
        *((_QWORD *)&v14 + 1) = -1;
        do
        {
          *(_OWORD *)(v4[35] + 16 * v13++) = v14;
          v5 = v4[37];
        }
        while (v13 < v5 >> 4);
      }
      if (v5)
      {
        v15 = 56 * v5;
        v16 = v4[36] + 16;
        do
        {
          this = re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable(v16);
          v16 += 56;
          v15 -= 56;
        }
        while (v15);
      }
    }
  }
  return this;
}

uint64_t re::EventBus::publish(re::EventBus *this, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, const void *a6)
{
  uint64_t result;
  uint64_t v11;

  v11 = a3;
  result = re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::find((_QWORD *)this + 3, &v11);
  if (result != -1)
  {
    result = *(_QWORD *)(*((_QWORD *)this + 4) + 48 * result + 8);
    if (result)
      return (uint64_t)re::EventBus::EventInfo::publish((re::EventBus::EventInfo *)result, a2, a4, a6);
  }
  return result;
}

uint64_t *re::EventBus::EventInfo::addToBatch(re::EventBus::EventInfo *this, re::EventBus *a2, uint64_t a3, const void *a4, size_t __n, const void *a6)
{
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v18;
  const void *v19;
  uint64_t v20[2];

  v20[0] = (uint64_t)a2;
  v20[1] = (uint64_t)this;
  if (a3 && a6 && *((_BYTE *)this + 23))
  {
    v18 = a3;
    v19 = a6;
    v11 = re::HashBrown<re::Pair<void const*,void const*,true>,re::EventBus::Subscriptions,re::Hash<re::Pair<void const*,void const*,true>>,re::EqualTo<re::Pair<void const*,void const*,true>>,void,false>::find((uint64_t *)this + 27, &v18);
    if (v11 == -1)
      v12 = 0;
    else
      v12 = (_QWORD *)(*((_QWORD *)this + 28) + 144 * v11 + 16);
    re::EventBus::EventInfo::addToBatch(re::EventBus*,void *,void const*,unsigned long,void const*)::$_0::operator()<re::EventBus::Subscriptions>(v20, v12, a3, a4, __n);
  }
  if (a3 && *((_BYTE *)this + 21))
  {
    v18 = a3;
    v19 = 0;
    v13 = re::HashBrown<re::Pair<void const*,void const*,true>,re::EventBus::Subscriptions,re::Hash<re::Pair<void const*,void const*,true>>,re::EqualTo<re::Pair<void const*,void const*,true>>,void,false>::find((uint64_t *)this + 27, &v18);
    if (v13 == -1)
      v14 = 0;
    else
      v14 = (_QWORD *)(*((_QWORD *)this + 28) + 144 * v13 + 16);
    re::EventBus::EventInfo::addToBatch(re::EventBus*,void *,void const*,unsigned long,void const*)::$_0::operator()<re::EventBus::Subscriptions>(v20, v14, a3, a4, __n);
  }
  if (a3 && *((_BYTE *)this + 22))
  {
    v18 = 0;
    v19 = a6;
    v15 = re::HashBrown<re::Pair<void const*,void const*,true>,re::EventBus::Subscriptions,re::Hash<re::Pair<void const*,void const*,true>>,re::EqualTo<re::Pair<void const*,void const*,true>>,void,false>::find((uint64_t *)this + 27, &v18);
    if (v15 == -1)
      v16 = 0;
    else
      v16 = (_QWORD *)(*((_QWORD *)this + 28) + 144 * v15 + 16);
    re::EventBus::EventInfo::addToBatch(re::EventBus*,void *,void const*,unsigned long,void const*)::$_0::operator()<re::EventBus::Subscriptions>(v20, v16, a3, a4, __n);
  }
  return re::EventBus::EventInfo::addToBatch(re::EventBus*,void *,void const*,unsigned long,void const*)::$_0::operator()<re::EventBus::Subscriptions>(v20, (_QWORD *)this + 11, a3, a4, __n);
}

uint64_t *re::EventBus::EventInfo::addToBatch(re::EventBus*,void *,void const*,unsigned long,void const*)::$_0::operator()<re::EventBus::Subscriptions>(uint64_t *result, _QWORD *a2, uint64_t a3, const void *a4, size_t __n)
{
  uint64_t v5;
  size_t v6;
  unint64_t v7;
  uint64_t v8;
  size_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  char v13;
  unint64_t *v14;
  char v15;
  BOOL v16;
  unint64_t v17;
  size_t v18;
  unint64_t *v19;
  unint64_t *v20;
  _anonymous_namespace_ *v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  uint64_t *v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  _OWORD *v37;
  unint64_t v39;
  uint64_t v40;
  _QWORD *v41;
  uint64_t *v44;
  unint64_t v45;
  __int128 v46;
  __int128 v47;
  uint64_t *v48;
  size_t v49;
  int v50;
  unint64_t v51;
  unint64_t *v52;
  uint64_t v53;
  int v54;
  const char *v55;
  __int16 v56;
  int v57;
  __int16 v58;
  unint64_t v59;
  __int16 v60;
  unint64_t v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  uint64_t v67;

  v44 = result;
  v67 = *MEMORY[0x24BDAC8D0];
  if (a2)
  {
    v5 = a2[2];
    if (v5)
    {
      v6 = __n;
      v7 = result[1];
      v8 = a2[4];
      v39 = __n + 7;
      v40 = v8 + (v5 << 6);
      v9 = (__n + 7) >> 3;
      v10 = 0x94D049BB133111EBLL
          * ((0xBF58476D1CE4E5B9 * (v7 ^ (v7 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v7 ^ (v7 >> 30))) >> 27));
      v45 = v10 ^ (v10 >> 31);
      v41 = a2;
      do
      {
        v11 = (v8 - a2[4]) >> 6;
        *(_QWORD *)&v46 = v7;
        *((_QWORD *)&v46 + 1) = v8;
        v12 = a2[7];
        if (v12 <= v11)
        {
          v53 = 0;
          v65 = 0u;
          v66 = 0u;
          v63 = 0u;
          v64 = 0u;
          v62 = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          v54 = 136315906;
          v55 = "operator[]";
          v56 = 1024;
          v57 = 797;
          v58 = 2048;
          v59 = v11;
          v60 = 2048;
          v61 = v12;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        *(_QWORD *)&v47 = *(_QWORD *)(a2[9] + 8 * v11);
        *((_QWORD *)&v47 + 1) = a3;
        v48 = 0;
        v49 = 0;
        v13 = 1;
        v50 = 1;
        v51 = 0;
        v52 = 0;
        if (v39 >= 8)
        {
          re::DynamicOverflowArray<re::internal::TimelineTree const*,4ul>::setCapacity(&v48, v9);
          v15 = v50;
          v50 += 2;
          v16 = (v15 & 1) == 0;
          v17 = 4;
          if (v16)
            v17 = v51;
          if (v17 < v9)
            re::DynamicOverflowArray<re::internal::TimelineTree const*,4ul>::setCapacity(&v48, v9);
          v18 = v49;
          if (v49 < v9)
          {
            do
            {
              if ((v50 & 1) != 0)
                v19 = &v51;
              else
                v19 = v52;
              v19[v18++] = 0;
            }
            while (v9 != v18);
          }
          v49 = v9;
          v13 = v50 + 2;
          v50 += 2;
          v14 = v52;
        }
        else
        {
          v14 = 0;
        }
        if ((v13 & 1) != 0)
          v20 = &v51;
        else
          v20 = v14;
        v21 = (_anonymous_namespace_ *)memcpy(v20, a4, v6);
        v22 = *v44;
        v23 = *(unsigned int *)(*v44 + 176);
        if ((_DWORD)v23)
        {
          v24 = v45 % v23;
          v25 = *(unsigned int *)(*(_QWORD *)(v22 + 160) + 4 * (v45 % v23));
          if ((_DWORD)v25 != 0x7FFFFFFF)
          {
            v26 = *(_QWORD *)(v22 + 168);
            while (*(_QWORD *)(v26 + 24 * v25 + 16) != v7)
            {
              LODWORD(v25) = *(_DWORD *)(v26 + 24 * v25 + 8) & 0x7FFFFFFF;
              if ((_DWORD)v25 == 0x7FFFFFFF)
                goto LABEL_27;
            }
            goto LABEL_33;
          }
        }
        else
        {
          v24 = 0;
        }
LABEL_27:
        v27 = *(unsigned int *)(v22 + 188);
        if ((_DWORD)v27 == 0x7FFFFFFF)
        {
          v27 = *(unsigned int *)(v22 + 184);
          v28 = v27;
          if ((_DWORD)v27 == (_DWORD)v23)
          {
            re::HashSetBase<re::TextureAsset *,re::TextureAsset *,re::internal::ValueAsKey<re::TextureAsset *>,re::Hash<re::TextureAsset *>,re::EqualTo<re::TextureAsset *>,true,false>::setCapacity(v22 + 152, 2 * *(_DWORD *)(v22 + 180));
            v24 = v45 % *(unsigned int *)(v22 + 176);
            v28 = *(_DWORD *)(v22 + 184);
          }
          *(_DWORD *)(v22 + 184) = v28 + 1;
          v29 = *(_QWORD *)(v22 + 168);
          v30 = *(_DWORD *)(v29 + 24 * v27 + 8);
        }
        else
        {
          v29 = *(_QWORD *)(v22 + 168);
          v30 = *(_DWORD *)(v29 + 24 * v27 + 8);
          *(_DWORD *)(v22 + 188) = v30 & 0x7FFFFFFF;
        }
        *(_DWORD *)(v29 + 24 * v27 + 8) = v30 | 0x80000000;
        *(_DWORD *)(*(_QWORD *)(v22 + 168) + 24 * v27 + 8) = *(_DWORD *)(*(_QWORD *)(v22 + 168) + 24 * v27 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(v22 + 160) + 4 * v24);
        *(_QWORD *)(*(_QWORD *)(v22 + 168) + 24 * v27) = v45;
        *(_QWORD *)(*(_QWORD *)(v22 + 168) + 24 * v27 + 16) = v7;
        *(_DWORD *)(*(_QWORD *)(v22 + 160) + 4 * v24) = v27;
        ++*(_DWORD *)(v22 + 180);
        ++*(_DWORD *)(v22 + 192);
LABEL_33:
        v32 = (uint64_t *)(v22 + 120);
        v31 = *(_QWORD *)(v22 + 120);
        v33 = v31 + 1;
        v34 = *(_QWORD *)(v22 + 112);
        if (v31 + 1 >= v34)
        {
          if (v34 < v33)
          {
            if (*(_QWORD *)(v22 + 104))
            {
              v35 = 2 * v34;
              if (!v34)
                v35 = 8;
              if (v35 <= v33)
                v36 = v33;
              else
                v36 = v35;
              re::Queue<re::EventBus::DeferredEvent>::setCapacity((_QWORD *)(v22 + 104), v36);
              v31 = *v32;
            }
            else
            {
              re::Queue<re::EventBus::DeferredEvent>::setCapacity((_QWORD *)(v22 + 104), v33);
              v31 = 0;
              *v32 = 0;
              *(_QWORD *)(v22 + 128) = 0;
              *(_DWORD *)(v22 + 136) = 0;
            }
            v6 = __n;
          }
          v34 = *(_QWORD *)(v22 + 112);
        }
        v37 = (_OWORD *)(*(_QWORD *)(v22 + 144) + 88 * ((*(_QWORD *)(v22 + 128) + v31) % v34));
        *v37 = v46;
        v37[1] = v47;
        re::DynamicOverflowArray<unsigned long,4ul>::DynamicOverflowArray((uint64_t)(v37 + 2), (uint64_t)&v48);
        ++*(_QWORD *)(v22 + 120);
        ++*(_DWORD *)(v22 + 136);
        result = v48;
        if (v48)
        {
          if ((v50 & 1) == 0)
            result = (uint64_t *)(*(uint64_t (**)(void))(*v48 + 40))();
        }
        v8 += 64;
        a2 = v41;
      }
      while (v8 != v40);
    }
  }
  return result;
}

void re::EventBus::endBatch(re::EventBus *this, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  __int128 v6;
  __n128 v7;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  int v11;
  uint64_t v12;
  int v13;
  int v14;
  _OWORD *v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  int *v20;
  int v21;
  uint64_t v22;
  int v23;
  int v24;
  re::EventBus::EventInfo *v25[2];
  unint64_t v26[2];
  uint64_t v27;
  int v28;
  _QWORD v29[5];
  __int128 v30;
  uint64_t v31;
  __int128 v32;
  int v33;
  _QWORD *v34;
  unint64_t v35;

  v2 = *((_QWORD *)this + 12);
  if (v2)
  {
    v4 = v2 - 1;
    *((_QWORD *)this + 12) = v4;
    if (!v4)
    {
      v33 = 0;
      v30 = *(_OWORD *)((char *)this + 152);
      *((_QWORD *)this + 19) = 0;
      *((_QWORD *)this + 20) = 0;
      v5 = *((_QWORD *)this + 21);
      v31 = v5;
      *((_QWORD *)this + 21) = 0;
      v32 = *((_OWORD *)this + 11);
      v6 = v32;
      v7 = (__n128)xmmword_2260F5A80;
      *((_OWORD *)this + 11) = xmmword_2260F5A80;
      v8 = 0;
      v9 = DWORD2(v6);
      if (DWORD2(v6))
      {
        v10 = (int *)(v5 + 8);
        while (1)
        {
          v11 = *v10;
          v10 += 6;
          if (v11 < 0)
            break;
          if (DWORD2(v6) == ++v8)
          {
            LODWORD(v8) = DWORD2(v6);
            break;
          }
        }
      }
      if (DWORD2(v6) != (_DWORD)v8)
      {
        v12 = v8;
        do
        {
          ++*(_DWORD *)(*(_QWORD *)(v5 + 24 * v12 + 16) + 16);
          if (DWORD2(v6) <= (v8 + 1))
            v13 = v8 + 1;
          else
            v13 = DWORD2(v6);
          v14 = v8;
          while (1)
          {
            v12 = (v14 + 1);
            if (v13 - 1 == v14)
              break;
            ++v14;
            LODWORD(v8) = v12;
            if ((*(_DWORD *)(v5 + 24 * v12 + 8) & 0x80000000) != 0)
              goto LABEL_18;
          }
          LODWORD(v8) = v13;
LABEL_18:
          ;
        }
        while (DWORD2(v6) != (_DWORD)v8);
      }
      while (*((_QWORD *)this + 15))
      {
        v15 = (_OWORD *)(*((_QWORD *)this + 18) + 88 * *((_QWORD *)this + 16));
        *(_OWORD *)v25 = *v15;
        *(_OWORD *)v26 = v15[1];
        re::DynamicOverflowArray<unsigned long,4ul>::DynamicOverflowArray((uint64_t)&v27, (uint64_t)(v15 + 2));
        re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(*((_QWORD *)this + 18)
                                                                   + 88 * *((_QWORD *)this + 16) + 32);
        v16 = *((_QWORD *)this + 16);
        if ((unint64_t)(v16 + 1) < *((_QWORD *)this + 14))
          v17 = v16 + 1;
        else
          v17 = 0;
        --*((_QWORD *)this + 15);
        *((_QWORD *)this + 16) = v17;
        ++*((_DWORD *)this + 34);
        if ((v28 & 1) != 0)
          v18 = v29;
        else
          v18 = (_QWORD *)v29[1];
        v34 = v18;
        v35 = v26[1];
        if ((*(unsigned int (**)(_QWORD, unint64_t *, _QWORD **))(**((_QWORD **)v25[1] + 7) + 16))(*((_QWORD *)v25[1] + 7), &v35, &v34) == 1)re::EventBus::EventInfo::removeSubscription(v25[0], v26[0]);
        if (v27 && (v28 & 1) == 0)
          (*(void (**)(void))(*(_QWORD *)v27 + 40))();
      }
      v19 = 0;
      if ((_DWORD)v9)
      {
        v20 = (int *)(v5 + 8);
        while (1)
        {
          v21 = *v20;
          v20 += 6;
          if (v21 < 0)
            break;
          if (v9 == ++v19)
          {
            LODWORD(v19) = v9;
            break;
          }
        }
      }
      if ((_DWORD)v9 != (_DWORD)v19)
      {
        v22 = v19;
        do
        {
          re::EventBus::EventInfo::stopPublishing(*(_QWORD **)(v5 + 24 * v22 + 16), *(double *)&v6, v7);
          if (v9 <= (int)v19 + 1)
            v23 = v19 + 1;
          else
            v23 = v9;
          v24 = v19;
          while (1)
          {
            v22 = (v24 + 1);
            if (v23 - 1 == v24)
              break;
            ++v24;
            LODWORD(v19) = v22;
            if ((*(_DWORD *)(v5 + 24 * v22 + 8) & 0x80000000) != 0)
              goto LABEL_47;
          }
          LODWORD(v19) = v23;
LABEL_47:
          ;
        }
        while ((_DWORD)v9 != (_DWORD)v19);
      }
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v30);
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Unbalanced beginBatch/endBatch", "m_batchLevel > 0", "endBatch", 108);
    _os_crash();
    __break(1u);
  }
}

uint64_t re::EventBus::EventInfo::removeSubscription(re::EventBus::EventInfo *this, unint64_t a2)
{
  uint64_t *v3;
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD v10[2];
  unint64_t v11;

  v10[1] = a2;
  v11 = a2;
  v3 = (uint64_t *)((char *)this + 24);
  v10[0] = *(_QWORD *)this;
  re::HashBrown<RESubscriptionHandle,re::Function<void ()(void)>,re::Hash<RESubscriptionHandle>,re::EqualTo<RESubscriptionHandle>,void,false>::remove((uint64_t *)this + 35, v10);
  result = re::HashBrown<unsigned long long,re::Pair<void const*,void const*,true>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::find(v3, (uint64_t *)&v11);
  if (result != -1)
  {
    v5 = *((_QWORD *)this + 4);
    v6 = v5 + 24 * result;
    v8 = *(_QWORD *)(v6 + 8);
    v7 = (_QWORD *)(v6 + 8);
    if (v8 || *(_QWORD *)(v5 + 24 * result + 16))
      v9 = (_QWORD *)(*((_QWORD *)this + 28)
                    + 144
                    * re::HashBrown<re::Pair<void const*,void const*,true>,re::EventBus::Subscriptions,re::Hash<re::Pair<void const*,void const*,true>>,re::EqualTo<re::Pair<void const*,void const*,true>>,void,false>::find((uint64_t *)this + 27, v7)+ 16);
    else
      v9 = (_QWORD *)((char *)this + 88);
    re::EventBus::Subscriptions::remove(v9, v11);
    return re::HashBrown<unsigned long long,re::Pair<void const*,void const*,true>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::remove(v3, (uint64_t *)&v11);
  }
  return result;
}

uint64_t re::EventBus::subscribe(re::EventBus *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6)
{
  unint64_t EventInfo;
  uint64_t v11;
  _QWORD v13[6];
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  EventInfo = re::EventBus::addOrGetEventInfo(a1, a2);
  re::EventBus::createHandler(a4, a6, v13);
  v11 = re::EventBus::EventInfo::addSubscription(EventInfo, (uint64_t)v13, a3, a5);
  if (v15)
  {
    (*(void (**)(_QWORD *))*v15)(v15);
    if (v15 != v13)
      (*(void (**)(uint64_t))(*(_QWORD *)v14 + 40))(v14);
  }
  return v11;
}

uint64_t re::EventBus::createHandler@<X0>(uint64_t a1@<X2>, char a2@<W4>, _QWORD *a3@<X8>)
{
  uint64_t result;
  re *v5;
  _BYTE v6[24];
  uint64_t v7;
  _BYTE *v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  if ((a2 & 1) != 0)
  {
    v7 = *(_QWORD *)(a1 + 24);
    v8 = 0;
    v5 = (re *)re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::operator=<24ul>((uint64_t)v6, a1);
    a3[6] = re::globalAllocators(v5)[2];
    a3[7] = 0;
    *a3 = &off_24ED42170;
    a3[4] = v7;
    a3[5] = 0;
    re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::operator=<24ul>((uint64_t)(a3 + 1), (uint64_t)v6);
    a3[7] = a3;
    result = (uint64_t)v8;
    if (v8)
    {
      result = (**(uint64_t (***)(_BYTE *))v8)(v8);
      if (v8 != v6)
        return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 40))(v7);
    }
  }
  else
  {
    a3[6] = *(_QWORD *)(a1 + 24);
    a3[7] = 0;
    return re::FunctionBase<48ul,REEventHandlerResult ()(void *,void const*)>::operator=<24ul>((uint64_t)a3, a1);
  }
  return result;
}

uint64_t re::EventBus::unsubscribe(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t result;
  uint64_t v6;

  v6 = a2;
  result = re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::find((_QWORD *)(a1 + 24), &v6);
  if (result != -1)
  {
    result = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 48 * result + 8);
    if (result)
      return re::EventBus::EventInfo::removeSubscription((re::EventBus::EventInfo *)result, a3);
  }
  return result;
}

unint64_t re::EventBus::getTypeId(re::EventBus *this, const char *a2)
{
  size_t v3;
  unint64_t v4;
  unint64_t v5;
  char *v7;
  unint64_t v8;
  char *v9;
  char v10;
  const char *v11;
  _BYTE v13[128];
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v3 = strlen((const char *)this);
  if (v3)
  {
    v4 = 0;
    do
    {
      v5 = v4 + 1;
      v13[v4] = (v3 % 0xA) | 0x30;
      if (v3 < 0xA)
        break;
      v3 /= 0xAuLL;
    }
    while (v4++ < 0x7E);
    if (v5 != 1)
    {
      v7 = &v13[v5 - 1];
      v8 = v5 >> 1;
      v9 = v13;
      do
      {
        v10 = *v9;
        *v9++ = *v7;
        *v7-- = v10;
        --v8;
      }
      while (v8);
    }
  }
  else
  {
    v13[0] = 48;
    v5 = 1;
  }
  v13[v5] = 0;
  strncpy(&v13[v5], (const char *)this, 128 - v5);
  v13[127] = 0;
  return re::EventBus::typeStringToId((re::EventBus *)v13, v11);
}

_QWORD *re::Queue<re::EventBus::DeferredEvent>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  _OWORD *v11;
  __int128 v12;
  _OWORD *v13;
  uint64_t v14;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    v6 = result + 2;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::Queue<re::EventBus::DeferredEvent>::setCapacity(v5, a2);
        *v6 = 0;
        v6[1] = 0;
        *((_DWORD *)v6 + 4) = 0;
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x58uLL))
        {
          v2 = 88 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 88 * a2, 8);
          if (result)
          {
            v8 = result;
            if (!v5[1])
              goto LABEL_18;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in Queue<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 440, 88, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v7, "assertion failure: '%s' (%s:line %i) Queue<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 444, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v8 = 0;
      if (!v3)
      {
LABEL_18:
        v5[5] = v8;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      if (v5[2])
      {
        v9 = 0;
        v10 = v5[3];
        do
        {
          v11 = (_OWORD *)(v5[5] + 88 * ((unint64_t)(v9 + v5[3]) % v5[1]));
          v12 = v11[1];
          v13 = &v8[11 * v10];
          *v13 = *v11;
          v13[1] = v12;
          v14 = (uint64_t)(v11 + 2);
          re::DynamicOverflowArray<unsigned long,4ul>::DynamicOverflowArray((uint64_t)(v13 + 2), (uint64_t)(v11 + 2));
          re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(v14);
          if (v10 + 1 < a2)
            ++v10;
          else
            v10 = 0;
          ++v9;
        }
        while (v9 != v5[2]);
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v5 + 40))(*v5, v5[5]);
      goto LABEL_18;
    }
  }
  return result;
}

uint64_t re::DynamicOverflowArray<unsigned long,4ul>::DynamicOverflowArray(uint64_t a1, uint64_t a2)
{
  char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  const void *v9;
  uint64_t v10;
  int v11;
  void *v12;
  uint64_t v13;
  int v14;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 1;
  *(_QWORD *)(a1 + 24) = 0;
  v4 = (char *)(a1 + 24);
  *(_QWORD *)(a1 + 32) = 0;
  if ((*(_BYTE *)(a2 + 16) & 1) == 0)
  {
    *(_DWORD *)(a1 + 16) = 3;
    v5 = *(_QWORD *)(a2 + 8);
    *(_QWORD *)a1 = *(_QWORD *)a2;
    *(_QWORD *)(a1 + 8) = v5;
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    v6 = *(_QWORD *)(a1 + 32);
    *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
    *(_QWORD *)(a2 + 32) = v6;
    *(_DWORD *)(a2 + 16) = *(_DWORD *)(a2 + 16) & 0xFFFFFFFE | *(_DWORD *)(a1 + 16) & 1;
    *(_DWORD *)(a1 + 16) &= ~1u;
    v7 = *(_QWORD *)(a1 + 24);
    *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
    *(_QWORD *)(a2 + 24) = v7;
LABEL_18:
    v14 = 2;
    goto LABEL_19;
  }
  v8 = *(_QWORD *)(a2 + 8);
  if (!v8)
  {
    re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1);
    *(_QWORD *)a1 = *(_QWORD *)a2;
    goto LABEL_18;
  }
  *(_QWORD *)a1 = *(_QWORD *)a2;
  re::DynamicOverflowArray<re::internal::TimelineTree const*,4ul>::setCapacity((_QWORD *)a1, v8);
  if ((*(_BYTE *)(a2 + 16) & 1) != 0)
    v9 = (const void *)(a2 + 24);
  else
    v9 = *(const void **)(a2 + 32);
  v10 = *(_QWORD *)(a1 + 8);
  v11 = *(_DWORD *)(a1 + 16);
  v12 = v4;
  if ((v11 & 1) == 0)
    v12 = *(void **)(a1 + 32);
  if (v10)
  {
    memmove(v12, v9, 8 * v10);
    v11 = *(_DWORD *)(a1 + 16);
  }
  if ((v11 & 1) == 0)
    v4 = *(char **)(a1 + 32);
  if ((*(_DWORD *)(a2 + 16) & 1) != 0)
    v13 = a2 + 24;
  else
    v13 = *(_QWORD *)(a2 + 32);
  memcpy(&v4[8 * *(_QWORD *)(a1 + 8)], (const void *)(v13 + 8 * *(_QWORD *)(a1 + 8)), 8 * v8 - 8 * *(_QWORD *)(a1 + 8));
  *(_QWORD *)(a1 + 8) = v8;
  *(_QWORD *)(a2 + 8) = 0;
  v14 = 4;
LABEL_19:
  *(_DWORD *)(a2 + 16) = ((*(_DWORD *)(a2 + 16) & 0xFFFFFFFE) + v14) | *(_DWORD *)(a2 + 16) & 1;
  *(_DWORD *)(a1 + 16) += 2;
  return a1;
}

BOOL re::HashBrown<RESubscriptionHandle,re::Function<void ()(void)>,re::Hash<RESubscriptionHandle>,re::EqualTo<RESubscriptionHandle>,void,false>::remove(uint64_t *a1, _QWORD *a2)
{
  uint64_t v3;
  uint64_t v4;
  int8x16_t *v5;
  int8x16_t v6;
  int8x8_t v7;
  char v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char v13;

  v3 = re::HashBrown<RESubscriptionHandle,re::Function<void ()(void)>,re::Hash<RESubscriptionHandle>,re::EqualTo<RESubscriptionHandle>,void,false>::find(a1, a2);
  v4 = v3;
  if (v3 != -1)
  {
    v5 = (int8x16_t *)(*a1 + (v3 & 0xFFFFFFFFFFFFFFF0));
    v6.i64[0] = -1;
    v6.i64[1] = -1;
    v7 = vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vceqq_s8(*v5, v6), (int8x16_t)xmmword_2260EE390)))), (int8x8_t)0x3830282018100800);
    if (v7)
      v8 = -1;
    else
      v8 = 0x80;
    v5->i8[v3 & 0xF] = v8;
    a1[5] ^= re::Hash<re::Pair<void const*,void const*,true>>::operator()((uint64_t)&v13, (_QWORD *)(a1[1] + 56 * v3));
    re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable(a1[1] + 56 * v4 + 16);
    if (v7)
      v9 = a1[4] + 1;
    else
      v9 = a1[4];
    v10 = a1[2];
    v11 = a1[3] - 1;
    a1[3] = v11;
    a1[4] = v9;
    if (v10 >= 0x11 && v11 < v10 >> 2)
      re::HashBrown<RESubscriptionHandle,re::Function<void ()(void)>,re::Hash<RESubscriptionHandle>,re::EqualTo<RESubscriptionHandle>,void,false>::resize(a1, 0);
  }
  return v4 != -1;
}

_QWORD *re::EventBus::Subscriptions::remove(_QWORD *this, uint64_t a2)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  unint64_t v17;
  __int16 v18;
  unint64_t v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;

  v2 = this;
  v25 = *MEMORY[0x24BDAC8D0];
  v3 = this[9];
  v4 = this[7];
  if (v4)
  {
    v5 = 8 * v4;
    v6 = (_QWORD *)this[9];
    while (*v6 != a2)
    {
      ++v6;
      v5 -= 8;
      if (!v5)
      {
        v6 = (_QWORD *)(v3 + 8 * v4);
        break;
      }
    }
  }
  else
  {
    v6 = (_QWORD *)this[9];
  }
  v7 = ((uint64_t)v6 - v3) >> 3;
  if (v7 != v4)
  {
    v10 = ((uint64_t)v6 - v3) >> 3;
    v8 = this[2];
    if (v8 <= v7)
    {
      v11 = 0;
      v24 = 0u;
      v22 = 0u;
      v23 = 0u;
      v20 = 0u;
      v21 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v12 = 136315906;
      v13 = "operator[]";
      v14 = 1024;
      v15 = 789;
      v16 = 2048;
      v17 = v7;
      v18 = 2048;
      v19 = v8;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    else
    {
      v9 = (_QWORD *)(this[4] + (v7 << 6));
      re::FunctionBase<48ul,REEventHandlerResult ()(void *,void const*)>::destroyCallable((uint64_t)v9);
      *v9 = &off_24ED42118;
      v9[7] = v9;
      v8 = v2[7];
      if (v8 > v7)
      {
        *(_QWORD *)(v2[9] + 8 * v7) = 0;
        this = re::DynamicArray<unsigned long>::add(v2 + 10, &v10);
        --v2[15];
        return this;
      }
    }
    v11 = 0;
    v24 = 0u;
    v22 = 0u;
    v23 = 0u;
    v20 = 0u;
    v21 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v12 = 136315906;
    v13 = "operator[]";
    v14 = 1024;
    v15 = 789;
    v16 = 2048;
    v17 = v7;
    v18 = 2048;
    v19 = v8;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return this;
}

BOOL re::HashBrown<unsigned long long,re::Pair<void const*,void const*,true>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::remove(uint64_t *a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  int8x16_t *v5;
  int8x16_t v6;
  int8x8_t v7;
  char v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;

  v3 = re::HashBrown<unsigned long long,re::Pair<void const*,void const*,true>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::find(a1, a2);
  v4 = v3;
  if (v3 != -1)
  {
    v5 = (int8x16_t *)(*a1 + (v3 & 0xFFFFFFFFFFFFFFF0));
    v6.i64[0] = -1;
    v6.i64[1] = -1;
    v7 = vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vceqq_s8(*v5, v6), (int8x16_t)xmmword_2260EE390)))), (int8x8_t)0x3830282018100800);
    if (v7)
      v8 = -1;
    else
      v8 = 0x80;
    v5->i8[v3 & 0xF] = v8;
    v9 = a1[2];
    v10 = *(_QWORD *)(a1[1] + 24 * v3);
    v11 = 0x94D049BB133111EBLL
        * ((0xBF58476D1CE4E5B9 * (v10 ^ (v10 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v10 ^ (v10 >> 30))) >> 27));
    a1[5] ^= (v11 >> 31) ^ v11;
    v12 = a1[4];
    if (v7)
      ++v12;
    v13 = a1[3] - 1;
    a1[3] = v13;
    a1[4] = v12;
    if (v9 >= 0x11 && v13 < v9 >> 2)
      re::HashBrown<unsigned long long,re::Pair<void const*,void const*,true>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::resize(a1, 0);
  }
  return v4 != -1;
}

void re::internal::Callable<re::EventBus::Subscriptions::remove(unsigned long long)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::~Callable()
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::internal::Callable<re::EventBus::Subscriptions::remove(unsigned long long)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::operator()()
{
  return 0;
}

_QWORD *re::internal::Callable<re::EventBus::Subscriptions::remove(unsigned long long)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  _QWORD *result;

  result = a2;
  *a2 = &off_24ED42118;
  return result;
}

_QWORD *re::internal::Callable<re::EventBus::Subscriptions::remove(unsigned long long)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::moveInto(uint64_t a1, _QWORD *a2)
{
  _QWORD *result;

  result = a2;
  *a2 = &off_24ED42118;
  return result;
}

uint64_t re::internal::Callable<re::EventBus::Subscriptions::remove(unsigned long long)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::size()
{
  return 16;
}

_QWORD *re::internal::Callable<re::EventBus::createHandler(void *,re::Function<REEventHandlerResult ()(void *,void const*)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::~Callable(_QWORD *a1)
{
  *a1 = &off_24ED42170;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable((uint64_t)(a1 + 1));
  return a1;
}

void re::internal::Callable<re::EventBus::createHandler(void *,re::Function<REEventHandlerResult ()(void *,void const*)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::~Callable(_QWORD *a1)
{
  *a1 = &off_24ED42170;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable((uint64_t)(a1 + 1));
  JUMPOUT(0x2276933B8);
}

uint64_t re::internal::Callable<re::EventBus::createHandler(void *,re::Function<REEventHandlerResult ()(void *,void const*)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::operator()(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;

  v3 = *a2;
  v5 = *a3;
  v6 = v3;
  (*(void (**)(_QWORD, uint64_t *, uint64_t *))(**(_QWORD **)(a1 + 40) + 16))(*(_QWORD *)(a1 + 40), &v6, &v5);
  return 1;
}

_QWORD *re::internal::Callable<re::EventBus::createHandler(void *,re::Function<REEventHandlerResult ()(void *,void const*)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24ED42170;
  a2[4] = *(_QWORD *)(a1 + 32);
  a2[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::operator=<24ul>((uint64_t)(a2 + 1), a1 + 8);
  return a2;
}

_QWORD *re::internal::Callable<re::EventBus::createHandler(void *,re::Function<REEventHandlerResult ()(void *,void const*)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::moveInto(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24ED42170;
  a2[4] = *(_QWORD *)(a1 + 32);
  a2[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::operator=<24ul>((uint64_t)(a2 + 1), a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::EventBus::createHandler(void *,re::Function<REEventHandlerResult ()(void *,void const*)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::size()
{
  return 48;
}

uint64_t re::FunctionBase<48ul,REEventHandlerResult ()(void *,void const*)>::operator=<24ul>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;

  re::FunctionBase<48ul,REEventHandlerResult ()(void *,void const*)>::destroyCallable(a1);
  v4 = *(_QWORD *)(a2 + 32);
  if (v4)
  {
    v5 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    v6 = a1;
    if (v5 >= 0x31)
    {
      v7 = v5;
      v8 = *(_QWORD *)(a1 + 48);
      if (v8)
        v6 = (*(uint64_t (**)(uint64_t, unint64_t, _QWORD))(*(_QWORD *)v8 + 32))(v8, v7, 0);
      else
        v6 = 0;
    }
    *(_QWORD *)(a1 + 56) = v6;
    (*(void (**)(_QWORD))(**(_QWORD **)(a2 + 32) + 24))(*(_QWORD *)(a2 + 32));
  }
  return a1;
}

double re::Queue<re::EventBus::DeferredEvent>::deinit(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  double result;

  v2 = *a1;
  if (v2)
  {
    v3 = a1[5];
    if (v3)
    {
      if (a1[2])
      {
        v4 = 0;
        do
        {
          re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1[5]
                                                                     + 88 * ((v4 + a1[3]) % (unint64_t)a1[1]) + 32);
          ++v4;
        }
        while (v4 != a1[2]);
        v2 = *a1;
        v3 = a1[5];
      }
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, v3);
    }
    a1[5] = 0;
    result = 0.0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *((_DWORD *)a1 + 8) = 0;
  }
  return result;
}

BOOL re::isEngineFrameworkIdentifier(re *this, const char *a2)
{
  return !strcmp((const char *)this, "com.apple.REResources")
      || !strcmp((const char *)this, "com.apple.CoreRE")
      || strcmp((const char *)this, "com.apple.RealityKit") == 0;
}

BOOL re::isEngineFrameworkPath(re *this, const char *a2)
{
  return !strncmp((const char *)this, "com.apple.REResources", 0x15uLL)
      || !strncmp((const char *)this, "com.apple.CoreRE", 0x10uLL)
      || strncmp((const char *)this, "com.apple.RealityKit", 0x14uLL) == 0;
}

uint64_t re::protectionOptions(re *this)
{
  unsigned __int8 v1;
  _QWORD *v2;
  int v4;
  const char *v5;
  uint64_t v6;
  _BYTE v7[4];
  int v8;

  v2 = &unk_255828000;
  if ((v1 & 1) == 0)
  {
    v2 = (_QWORD *)&unk_255828000;
    if (v4)
    {
      re::Defaults::intValue((re::Defaults *)"protection.options", v5, (uint64_t)v7);
      v6 = v8;
      if (!v7[0])
        v6 = 0;
      re::protectionOptions(void)::options = v6;
      v2 = (_QWORD *)&unk_255828000;
    }
  }
  return v2[142];
}

void re::Defaults::intValue(re::Defaults *this@<X0>, const char *a2@<X1>, uint64_t a3@<X8>)
{
  void *v4;
  char v5;
  void *v6;

  v4 = (void *)objc_claimAutoreleasedReturnValue();
  if (v4)
  {
    v6 = v4;
    *(_DWORD *)(a3 + 4) = objc_msgSend(v4, "intValue");
    v4 = v6;
    v5 = 1;
  }
  else
  {
    v5 = 0;
  }
  *(_BYTE *)a3 = v5;

}

id `anonymous namespace'::getValue(_anonymous_namespace_ *this, const char *a2)
{
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  re *v7;
  void *v8;
  uint64_t v9;
  __CFString *v10;
  void *v11;
  NSObject *v12;
  uint8_t buf[16];

  objc_msgSend(MEMORY[0x24BDBCF50], "standardUserDefaults");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("%s.%s"), "com.apple.re", this);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "objectForKey:", v4);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  if (!v5)
  {
    objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", this);
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v3, "objectForKey:", v6);
    v7 = (re *)objc_claimAutoreleasedReturnValue();
    if (v7)
    {
      v5 = v7;
      v8 = v6;
    }
    else
    {
      v9 = objc_msgSend(v4, "rangeOfString:options:", CFSTR("."), 4);
      objc_msgSend(v4, "substringToIndex:", v9);
      v10 = (__CFString *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v4, "substringFromIndex:", v9 + 1);
      v8 = (void *)objc_claimAutoreleasedReturnValue();

      if (-[__CFString isEqualToString:](v10, "isEqualToString:", CFSTR("com.apple.re.network.multipeerservice")))
      {

        v10 = CFSTR("com.apple.renetwork.multipeerservice");
      }
      objc_msgSend(v3, "dictionaryForKey:", v10);
      v11 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v11, "objectForKey:", v8);
      v5 = (void *)objc_claimAutoreleasedReturnValue();

      if (!v5)
        goto LABEL_9;
    }
    v12 = *re::foundationCoreLogObjects(v7);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
    }
LABEL_9:

  }
  return v5;
}

void re::Defaults::BOOLValue(re::Defaults *this@<X0>, const char *a2@<X1>, char *a3@<X8>)
{
  void *v4;
  char v5;
  void *v6;

  v4 = (void *)objc_claimAutoreleasedReturnValue();
  if (v4)
  {
    v6 = v4;
    a3[1] = objc_msgSend(v4, "BOOLValue");
    v4 = v6;
    v5 = 1;
  }
  else
  {
    v5 = 0;
  }
  *a3 = v5;

}

void re::Defaults::uintValue(re::Defaults *this@<X0>, const char *a2@<X1>, uint64_t a3@<X8>)
{
  void *v4;
  char v5;
  void *v6;

  v4 = (void *)objc_claimAutoreleasedReturnValue();
  if (v4)
  {
    v6 = v4;
    *(_DWORD *)(a3 + 4) = objc_msgSend(v4, "unsignedIntValue");
    v4 = v6;
    v5 = 1;
  }
  else
  {
    v5 = 0;
  }
  *(_BYTE *)a3 = v5;

}

void re::Defaults::uint64Value(re::Defaults *this@<X0>, const char *a2@<X1>, uint64_t a3@<X8>)
{
  void *v4;
  char v5;
  void *v6;

  v4 = (void *)objc_claimAutoreleasedReturnValue();
  if (v4)
  {
    v6 = v4;
    *(_QWORD *)(a3 + 8) = objc_msgSend(v4, "unsignedLongLongValue");
    v4 = v6;
    v5 = 1;
  }
  else
  {
    v5 = 0;
  }
  *(_BYTE *)a3 = v5;

}

void re::Defaults::floatValue(re::Defaults *this@<X0>, const char *a2@<X1>, uint64_t a3@<X8>)
{
  void *v4;
  int v5;
  char v6;
  void *v7;

  v4 = (void *)objc_claimAutoreleasedReturnValue();
  if (v4)
  {
    v7 = v4;
    objc_msgSend(v4, "floatValue");
    v4 = v7;
    *(_DWORD *)(a3 + 4) = v5;
    v6 = 1;
  }
  else
  {
    v6 = 0;
  }
  *(_BYTE *)a3 = v6;

}

void re::Defaults::doubleValue(re::Defaults *this@<X0>, const char *a2@<X1>, uint64_t a3@<X8>)
{
  void *v4;
  uint64_t v5;
  char v6;
  void *v7;

  v4 = (void *)objc_claimAutoreleasedReturnValue();
  if (v4)
  {
    v7 = v4;
    objc_msgSend(v4, "doubleValue");
    v4 = v7;
    *(_QWORD *)(a3 + 8) = v5;
    v6 = 1;
  }
  else
  {
    v6 = 0;
  }
  *(_BYTE *)a3 = v6;

}

void re::Defaults::stringValue(re::Defaults *this@<X0>, const char *a2@<X1>, uint64_t a3@<X8>)
{
  void *v4;
  void *v5;
  _anonymous_namespace_ *v6;
  char v7;
  uint64_t v8;
  __int128 v9;
  uint64_t v10;

  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v5 = v4;
  if (v4)
  {
    v6 = (_anonymous_namespace_ *)objc_msgSend(objc_retainAutorelease(v4), "UTF8String");
    *(_QWORD *)(a3 + 8) = v8;
    *(_QWORD *)(a3 + 32) = v10;
    *(_OWORD *)(a3 + 16) = v9;
    v7 = 1;
  }
  else
  {
    v7 = 0;
  }
  *(_BYTE *)a3 = v7;

}

void re::LeakTestAllocator::~LeakTestAllocator(re::LeakTestAllocator *this, uint64_t a2)
{
  if (*((_DWORD *)this + 15))
  {
    re::internal::assertLog((re::internal *)5, a2, "assertion failure: '%s' (%s:line %i) %u memory leaks found.", "m_allocations.size() == 0", "~LeakTestAllocator", 18, *((unsigned int *)this + 15));
    _os_crash();
    __break(1u);
  }
  else
  {
    re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)this + 4);
    re::Allocator::~Allocator(this);
  }
}

{
  re::LeakTestAllocator::~LeakTestAllocator(this, a2);
  JUMPOUT(0x2276933B8);
}

uint64_t re::LeakTestAllocator::alloc(re::LeakTestAllocator *this)
{
  uint64_t v3;

  v3 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 3) + 32))(*((_QWORD *)this + 3));
  re::HashSetBase<void *,void *,re::internal::ValueAsKey<void *>,re::Hash<void *>,re::EqualTo<void *>,true,false>::add((uint64_t)this + 32, &v3);
  return v3;
}

uint64_t re::HashSetBase<void *,void *,re::internal::ValueAsKey<void *>,re::Hash<void *>,re::EqualTo<void *>,true,false>::add(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;

  v4 = *a2;
  v5 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v6 = (0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) ^ ((0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) >> 31);
  v7 = *(unsigned int *)(a1 + 24);
  if (!(_DWORD)v7)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  v8 = v6 % v7;
  v9 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * (v6 % v7));
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
LABEL_8:
    v12 = re::HashSetBase<void *,void *,re::internal::ValueAsKey<void *>,re::Hash<void *>,re::EqualTo<void *>,true,false>::addAsMove(a1, v8, v6, (uint64_t)a2, a2);
    ++*(_DWORD *)(a1 + 40);
    v11 = *(_QWORD *)(a1 + 16) + 24 * v12;
    return v11 + 16;
  }
  v10 = *(_QWORD *)(a1 + 16);
  while (*(_QWORD *)(v10 + 24 * v9 + 16) != v4)
  {
    LODWORD(v9) = *(_DWORD *)(v10 + 24 * v9 + 8) & 0x7FFFFFFF;
    if ((_DWORD)v9 == 0x7FFFFFFF)
      goto LABEL_8;
  }
  v11 = v10 + 24 * v9;
  return v11 + 16;
}

uint64_t re::LeakTestAllocator::free(re::LeakTestAllocator *this, uint64_t a2)
{
  uint64_t v4;

  v4 = a2;
  re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::remove((uint64_t)this + 32, &v4);
  return (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)this + 3) + 40))(*((_QWORD *)this + 3), v4);
}

uint64_t re::LeakTestAllocator::parent(re::LeakTestAllocator *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 3) + 48))(*((_QWORD *)this + 3));
}

uint64_t re::LeakTestAllocator::statistics(re::LeakTestAllocator *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 3) + 56))(*((_QWORD *)this + 3));
}

uint64_t re::AlignedAllocator::deinit(re::AlignedAllocator *this)
{
  uint64_t result;
  _QWORD *v3;

  v3 = (_QWORD *)((char *)this + 32);
  result = *((_QWORD *)this + 4);
  if (result)
  {
    *((_QWORD *)this + 10) = 0;
    *((_QWORD *)this + 11) = 0;
    if (*((_QWORD *)this + 8))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *((_QWORD *)this + 8) = 0;
    v3[1] = 0;
    v3[2] = 0;
    *v3 = 0;
    ++*((_DWORD *)this + 14);
  }
  return result;
}

void re::BaseAllocator::~BaseAllocator(re::BaseAllocator *this)
{
  uint64_t v2;
  _QWORD *v3;

  *(_QWORD *)this = off_24ED422C0;
  v3 = (_QWORD *)((char *)this + 32);
  v2 = *((_QWORD *)this + 4);
  if (v2)
  {
    if (*((_QWORD *)this + 8))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *((_QWORD *)this + 8) = 0;
    v3[1] = 0;
    v3[2] = 0;
    *v3 = 0;
    ++*((_DWORD *)this + 14);
  }
  re::Allocator::~Allocator(this);
}

void re::AlignedAllocator::~AlignedAllocator(re::AlignedAllocator *this)
{
  re::AlignedAllocator::deinit(this);
  re::BaseAllocator::~BaseAllocator(this);
}

{
  re::AlignedAllocator::deinit(this);
  re::BaseAllocator::~BaseAllocator(this);
  JUMPOUT(0x2276933B8);
}

void *re::AlignedAllocator::alloc(re::AlignedAllocator *this, size_t size)
{
  uint64_t v4;
  void *result;
  size_t v6;
  void *memptr;

  v4 = *((_QWORD *)this + 11);
  if (v4)
  {
    result = (void *)(*(uint64_t (**)(uint64_t, size_t, _QWORD))(*(_QWORD *)v4 + 32))(v4, size, 0);
  }
  else
  {
    v6 = (*((_QWORD *)this + 10) + 7) & 0xFFFFFFFFFFFFFFF8;
    memptr = 0;
    malloc_type_posix_memalign(&memptr, v6, size, 0xC75C8B65uLL);
    result = memptr;
  }
  __dmb(0xBu);
  return result;
}

void re::AlignedAllocator::free(re::AlignedAllocator *this, void *a2)
{
  uint64_t v2;

  __dmb(0xBu);
  v2 = *((_QWORD *)this + 11);
  if (v2)
    (*(void (**)(uint64_t, void *))(*(_QWORD *)v2 + 40))(v2, a2);
  else
    free(a2);
}

uint64_t re::AlignedAllocator::statistics(re::AlignedAllocator *this)
{
  return 0;
}

uint64_t re::AlignedAllocator::parent(re::AlignedAllocator *this)
{
  return *((_QWORD *)this + 11);
}

uint64_t re::Allocator::useMallocAllocator(re::Allocator *this)
{
  unsigned __int8 v1;
  unsigned __int8 *v2;
  _anonymous_namespace_ *v4;

  v2 = (unsigned __int8 *)&unk_255828000;
  if ((v1 & 1) == 0)
  {
    v2 = (_BYTE *)&unk_255828000;
    if ((_DWORD)v4)
    {
      v2 = (_BYTE *)&unk_255828000;
    }
  }
  return v2[1152];
}

BOOL `anonymous namespace'::memoryDebugStatus(_anonymous_namespace_ *this)
{
  char *v1;
  _BOOL4 v2;

  v1 = getenv("RE_USE_POOL_ALLOCATOR");
  if (v1)
    v2 = atoi(v1) == 0;
  else
    v2 = 0;
  if (getenv("MallocTracing"))
    return 1;
  if (getenv("MallocStackLogging"))
    return 1;
  return v2;
}

re::Allocator *re::Allocator::Allocator(re::Allocator *this, const char *a2, int a3)
{
  char *v4;
  char *v5;

  *(_QWORD *)this = off_24ED42318;
  *((_QWORD *)this + 1) = a2;
  *((_BYTE *)this + 16) = a3;
  if (a3)
  {
    v4 = re::globalMemoryTracker(this);
    if (*v4)
    {
      v5 = re::globalMemoryTracker((re *)v4);
      re::MemoryTracker::track((os_unfair_lock_s *)v5, this);
    }
  }
  return this;
}

void re::Allocator::~Allocator(re::Allocator *this)
{
  char *v2;
  char *v3;

  *(_QWORD *)this = off_24ED42318;
  if (*((_BYTE *)this + 16))
  {
    v2 = re::globalMemoryTracker(this);
    if (*v2)
    {
      v3 = re::globalMemoryTracker((re *)v2);
      re::MemoryTracker::untrack((os_unfair_lock_s *)v3, this);
    }
  }
}

void re::PerFrameAllocatorImpl::~PerFrameAllocatorImpl(re::PerFrameAllocatorImpl *this)
{
  uint64_t *v2;
  uint64_t v3;
  unint64_t i;
  uint64_t v5;
  uint64_t v6;

  *(_QWORD *)this = &off_24ED42380;
  v2 = (uint64_t *)((char *)this + 96);
  v3 = *((_QWORD *)this + 17);
  if (v3)
  {
    for (i = 0; i != v3; ++i)
    {
      v5 = re::BucketArray<re::Pair<void *,re::Function<void ()(void *)>,true>,64ul>::operator[]((uint64_t)v2, i);
      re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable(v5 + 8);
    }
  }
  while (*((_QWORD *)this + 13))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v2);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)v2);
  *((_QWORD *)this + 17) = 0;
  ++*((_DWORD *)this + 36);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)v2);
  v6 = *((_QWORD *)this + 7);
  if (v6)
  {
    if (*((_QWORD *)this + 11))
      (*(void (**)(uint64_t))(*(_QWORD *)v6 + 40))(v6);
    *((_QWORD *)this + 11) = 0;
    *((_QWORD *)this + 8) = 0;
    *((_QWORD *)this + 9) = 0;
    *((_QWORD *)this + 7) = 0;
    ++*((_DWORD *)this + 20);
  }
  re::Allocator::~Allocator(this);
}

{
  re::PerFrameAllocatorImpl::~PerFrameAllocatorImpl(this);
  JUMPOUT(0x2276933B8);
}

uint64_t re::PerFrameAllocatorManager::sizeToIndex(re::PerFrameAllocatorManager *this, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  signed int v4;
  uint64_t result;

  if (this)
  {
    v4 = 16 - __clz((_DWORD)this - 1);
    return v4 & ~(v4 >> 31);
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) ", "size > 0", "sizeToIndex", 320, v2, v3);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::PerFrameAllocatorImpl::alloc(re::PerFrameAllocatorImpl *this, unint64_t a2, unint64_t a3)
{
  uint64_t result;
  _QWORD *v7;
  _opaque_pthread_t *v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  int64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  signed int v30;
  unint64_t v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  re::PerFrameAllocatorManager *v35;
  uint64_t v36;
  unint64_t v37;
  re *v38;
  uint64_t *v39;
  uint64_t *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  const char *v47;
  __int16 v48;
  int v49;
  __int16 v50;
  unint64_t v51;
  __int16 v52;
  unint64_t v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  uint64_t v59;

  v59 = *MEMORY[0x24BDAC8D0];
  if (!a2 || *((_BYTE *)this + 168))
    return 0;
  if (pthread_self() != *((pthread_t *)this + 20))
  {
    v7 = (_QWORD *)re::PerFrameAllocatorManager::perFrameAllocator(*((_QWORD *)this + 19), *((_QWORD *)this + 3));
    v8 = (_opaque_pthread_t *)v7[20];
    if (v8 == pthread_self())
      return (*(uint64_t (**)(_QWORD *, unint64_t, unint64_t))(*v7 + 32))(v7, a2, a3);
  }
  v9 = 0;
  if (a3 <= 0x10)
    v10 = 16;
  else
    v10 = a3;
  v11 = (char *)this + 32;
  do
  {
    v12 = *(_QWORD *)&v11[v9];
    if (v12)
    {
      v14 = *(_QWORD *)(v12 + 56);
      v13 = *(_QWORD *)(v12 + 64);
      if (v10 + a2 < v13 - v14)
        goto LABEL_30;
    }
    v9 += 8;
  }
  while (v9 != 24);
  v15 = *((_QWORD *)this + 19);
  if (a2 <= 0x10000)
    v16 = 0x10000;
  else
    v16 = a2;
  v43 = *((_QWORD *)this + 3);
  os_unfair_lock_lock((os_unfair_lock_t)(v15 + 120));
  v18 = re::PerFrameAllocatorManager::sizeToIndex((re::PerFrameAllocatorManager *)v16, v17);
  v20 = *(_QWORD *)(v15 + 144);
  if (v18 >= v20)
    goto LABEL_41;
  v21 = v18;
  v22 = *(_QWORD *)(v15 + 160);
  v23 = v22 + 88 * v18;
  v26 = *(_QWORD *)(v23 + 24);
  v24 = (unint64_t *)(v23 + 24);
  v25 = v26;
  if (v26)
    goto LABEL_19;
  v35 = (re::PerFrameAllocatorManager *)(0x10000 << v18);
  if (v18 < v20 - 1)
  {
    v21 = v18 + 1;
    if (v20 <= v18 + 1)
    {
LABEL_43:
      v45 = 0;
      v57 = 0u;
      v58 = 0u;
      v55 = 0u;
      v56 = 0u;
      v54 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v46 = 136315906;
      v47 = "operator[]";
      v48 = 1024;
      v49 = 789;
      v50 = 2048;
      v51 = v21;
      v52 = 2048;
      v53 = v20;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_44;
    }
    if (2 * v16 > (unint64_t)v35)
    {
      v36 = v22 + 88 * v21;
      v37 = *(_QWORD *)(v36 + 24);
      v24 = (unint64_t *)(v36 + 24);
      v25 = v37;
      if (v37 >= 2)
      {
LABEL_19:
        v27 = v25 - 1;
        v12 = *(_QWORD *)(*(_QWORD *)(v22 + 88 * v21 + 40) + 8 * v27);
        *v24 = v27;
        ++*(_DWORD *)(v22 + 88 * v21 + 32);
        goto LABEL_20;
      }
    }
  }
  v20 = 0x10000 << v18;
  v38 = (re *)re::PerFrameAllocatorManager::sizeToIndex(v35, v19);
  if ((unint64_t)v38 >= *(_QWORD *)(v15 + 144))
  {
LABEL_41:
    os_unfair_lock_unlock((os_unfair_lock_t)(v15 + 120));
    return 0;
  }
  v21 = (unint64_t)v38;
  if (a3 <= 0x100)
    a3 = 256;
  v39 = re::globalAllocators(v38);
  v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v39[2] + 32))(v39[2], 144, 8);
  *(_BYTE *)(v12 + 32) = 0;
  *(_QWORD *)(v12 + 16) = &off_24ED42408;
  *(_QWORD *)(v12 + 24) = "PerFrameAllocatoChunk-Linear";
  *(_OWORD *)(v12 + 80) = 0u;
  *(_OWORD *)(v12 + 96) = 0u;
  *(_DWORD *)(v12 + 112) = 0;
  *(_OWORD *)(v12 + 40) = 0u;
  *(_OWORD *)(v12 + 56) = 0u;
  *(_DWORD *)(v12 + 72) = 0;
  *(_QWORD *)(v12 + 116) = 0x7FFFFFFFLL;
  *(_BYTE *)(v12 + 128) = 1;
  *(_QWORD *)(v12 + 136) = 0xFFFFFFFFFFFFFFFLL;
  v44 = v12;
  *(_QWORD *)v12 = 0;
  *(_QWORD *)(v12 + 8) = v20;
  v40 = re::globalAllocators((re *)v12);
  v41 = (*(uint64_t (**)(uint64_t, unint64_t, unint64_t))(*(_QWORD *)v40[2] + 32))(v40[2], v20, a3);
  *(_QWORD *)v12 = v41;
  v42 = *(_QWORD *)(v12 + 8) + v41;
  *(_QWORD *)(v12 + 40) = v41;
  *(_QWORD *)(v12 + 48) = v42;
  *(_QWORD *)(v12 + 56) = v41;
  *(_QWORD *)(v12 + 64) = v42;
  a3 = *(_QWORD *)(v15 + 144);
  if (a3 <= v21)
  {
LABEL_44:
    v45 = 0;
    v57 = 0u;
    v58 = 0u;
    v55 = 0u;
    v56 = 0u;
    v54 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v46 = 136315906;
    v47 = "operator[]";
    v48 = 1024;
    v49 = 789;
    v50 = 2048;
    v51 = v21;
    v52 = 2048;
    v53 = a3;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  re::DynamicArray<re::RigDataValue *>::add((_anonymous_namespace_ *)(*(_QWORD *)(v15 + 160) + 88 * v21 + 48), &v44);
LABEL_20:
  *(_QWORD *)(v12 + 136) = v43;
  *(_OWORD *)(v12 + 56) = *(_OWORD *)(v12 + 40);
  os_unfair_lock_unlock((os_unfair_lock_t)(v15 + 120));
  *(_QWORD *)&v54 = v12;
  re::DynamicArray<re::RigDataValue *>::add((re::PerFrameAllocatorImpl *)((char *)this + 56), &v54);
  v29 = 0;
  v30 = 0;
  v31 = -1;
  while (1)
  {
    v32 = *(_QWORD *)&v11[8 * v29];
    if (!v32)
      break;
    v33 = *(_QWORD *)(v32 + 64) - *(_QWORD *)(v32 + 56);
    if (v33 < v31)
    {
      v31 = v33;
      v30 = v29;
    }
    if (++v29 == 3)
      goto LABEL_28;
  }
  v30 = v29;
LABEL_28:
  if (v30 >= 3)
  {
    re::internal::assertLog((re::internal *)6, v28, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < N", "operator[]", 234, v30, 3);
    _os_crash();
    __break(1u);
    goto LABEL_43;
  }
  *(_QWORD *)&v11[8 * v30] = v12;
  v14 = *(_QWORD *)(v12 + 56);
  v13 = *(_QWORD *)(v12 + 64);
LABEL_30:
  result = 0;
  v34 = (v10 + v14 - 1) & -v10;
  if ((uint64_t)(v34 + a2) <= v13)
  {
    *(_QWORD *)(v12 + 56) = v34 + a2;
    return (v10 + v14 - 1) & -v10;
  }
  return result;
}

uint64_t re::PerFrameAllocatorManager::perFrameAllocator(uint64_t a1, unint64_t a2)
{
  re::Allocator *v2;
  uint64_t v3;
  unint64_t v4;
  re::Allocator *v5;
  unint64_t v6;
  re::Allocator *v7;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _opaque_pthread_t *v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int v22;
  uint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  re::Allocator *v26;
  uint64_t v28;
  char v29[16];
  int v30;
  const char *v31;
  __int16 v32;
  int v33;
  __int16 v34;
  unint64_t v35;
  __int16 v36;
  re::Allocator *v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  uint64_t v43;

  v5 = (re::Allocator *)&v38;
  v43 = *MEMORY[0x24BDAC8D0];
  v6 = a2 >> 60;
  v7 = *(re::Allocator **)(a1 + 16);
  if ((unint64_t)v7 <= a2 >> 60)
  {
    *(_QWORD *)v29 = 0;
    v42 = 0u;
    v40 = 0u;
    v41 = 0u;
    v38 = 0u;
    v39 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v30 = 136315906;
    v31 = "operator[]";
    v32 = 1024;
    v33 = 468;
    v34 = 2048;
    v35 = v6;
    v36 = 2048;
    v37 = v7;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_31;
  }
  v10 = pthread_getspecific(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 8 * v6));
  if (!v10 || (v11 = re::DataArray<re::PerFrameAllocatorImpl>::tryGet(a1 + 56, (uint64_t)v10)) == 0)
  {
LABEL_10:
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 120));
    v29[0] = 0;
    v15 = pthread_self();
    pthread_getname_np(v15, v29, 0xAuLL);
    v16 = *(_QWORD *)(a1 + 5296);
    if (v16 - *(_QWORD *)(a1 + 5288) == 128)
      *(_QWORD *)(a1 + 5288) = v16 - 127;
    v17 = a1 + 168;
    *(_QWORD *)(a1 + 5296) = v16 + 1;
    v18 = v16 & 0x7F;
    re::InlineString<32ul>::format((uint64_t)&v38, (char)v29);
    v20 = v38;
    if ((_QWORD)v38)
    {
      if ((unint64_t)v38 >= 0x20)
      {
LABEL_32:
        re::internal::assertLog((re::internal *)4, v19, "assertion failure: '%s' (%s:line %i) ", "other.m_length < m_capacity", "copy", 481);
        _os_crash();
        __break(1u);
LABEL_33:
        *((_OWORD *)v5 + 4) = 0u;
        v40 = 0u;
        v41 = 0u;
        v38 = 0u;
        v39 = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        v30 = 136315906;
        v31 = "operator[]";
        v32 = 1024;
        v33 = 789;
        v34 = 2048;
        v35 = v4;
        v36 = 2048;
        v37 = 0;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_34;
      }
      memcpy((void *)(v17 + 40 * v18 + 8), (char *)&v38 + 8, v38 + 1);
    }
    *(_QWORD *)(v17 + 40 * v18) = v20;
    v21 = *(_DWORD *)(a1 + 112);
    if ((v21 + 1) >> 24)
      v22 = 1;
    else
      v22 = v21 + 1;
    *(_DWORD *)(a1 + 112) = v22;
    v3 = *(unsigned __int16 *)(a1 + 108);
    v4 = *(unsigned __int16 *)(a1 + 110);
    if (v3 == 0xFFFF && (_DWORD)v4 == 0xFFFF)
    {
      if (*(_DWORD *)(a1 + 104) >= *(_DWORD *)(a1 + 100))
        re::DataArray<re::PerFrameAllocatorImpl>::allocBlock((_QWORD *)(a1 + 56));
      v23 = *(_QWORD *)(a1 + 72);
      v4 = (unsigned __int16)(v23 - 1);
      if (!v23)
        goto LABEL_33;
      v3 = *(unsigned int *)(a1 + 104);
      if (v3 >= 0x10000)
        goto LABEL_35;
      v24 = (_QWORD *)(*(_QWORD *)(a1 + 88) + 16 * v4);
      *(_DWORD *)(a1 + 104) = v3 + 1;
      *(_DWORD *)(v24[1] + 4 * v3) = *(_DWORD *)(a1 + 112);
      v5 = (re::Allocator *)(*v24 + 184 * v3);
    }
    else
    {
      v5 = *(re::Allocator **)(a1 + 72);
      if ((unint64_t)v5 <= v4)
      {
LABEL_34:
        v28 = 0;
        v42 = 0u;
        v40 = 0u;
        v41 = 0u;
        v38 = 0u;
        v39 = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        v30 = 136315906;
        v31 = "operator[]";
        v32 = 1024;
        v33 = 789;
        v34 = 2048;
        v35 = v4;
        v36 = 2048;
        v37 = v5;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_35:
        re::internal::assertLog((re::internal *)5, v19, "assertion failure: '%s' (%s:line %i) m_tailBlockLinearAllocationCount (%u) is too large for a 16-bit unsigned integer", "!overflow", "create", 601, v3, v28, *(_QWORD *)v29);
        _os_crash();
        __break(1u);
      }
      v25 = (_QWORD *)(*(_QWORD *)(a1 + 88) + 16 * v4);
      *(_DWORD *)(v25[1] + 4 * v3) = v22;
      v5 = (re::Allocator *)(*v25 + 184 * v3);
      *(_DWORD *)(a1 + 108) = *(_DWORD *)v5;
    }
    ++*(_DWORD *)(a1 + 96);
    v26 = re::Allocator::Allocator(v5, (const char *)(v17 + 40 * v18 + 8), 0);
    *(_QWORD *)v5 = &off_24ED42380;
    *((_DWORD *)v5 + 28) = 1;
    *((_DWORD *)v5 + 43) = 3;
    *((_QWORD *)v5 + 8) = 0;
    *((_QWORD *)v5 + 9) = 0;
    *((_DWORD *)v5 + 20) = 0;
    *((_QWORD *)v5 + 12) = 0;
    *((_QWORD *)v5 + 13) = 0;
    *((_QWORD *)v5 + 11) = 0;
    *((_QWORD *)v5 + 16) = 0;
    *((_QWORD *)v5 + 17) = 0;
    *((_QWORD *)v5 + 15) = 0;
    *((_DWORD *)v5 + 36) = 0;
    *((_QWORD *)v5 + 19) = a1;
    *((_BYTE *)v5 + 168) = 0;
    *((_BYTE *)v5 + 176) = 0;
    *((_QWORD *)v5 + 3) = a2;
    *((_QWORD *)v5 + 4) = 0;
    *((_QWORD *)v5 + 5) = 0;
    *((_QWORD *)v5 + 6) = 0;
    *((_QWORD *)v26 + 7) = 0;
    re::DynamicArray<float *>::setCapacity((_QWORD *)v26 + 7, 0x40uLL);
    *((_QWORD *)v5 + 20) = pthread_self();
    v2 = *(re::Allocator **)(a1 + 16);
    if ((unint64_t)v2 > v6)
    {
      pthread_setspecific(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 8 * v6), (const void *)((v4 << 16) | ((unint64_t)(*(_DWORD *)(a1 + 112) & 0xFFFFFF) << 32) | v3));
      v12 = re::DataArray<re::PerFrameAllocatorImpl>::get(a1 + 56, ((_DWORD)v4 << 16) | v3);
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 120));
      return v12;
    }
LABEL_31:
    v42 = 0u;
    v40 = 0u;
    v41 = 0u;
    v38 = 0u;
    v39 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v30 = 136315906;
    v31 = "operator[]";
    v32 = 1024;
    v33 = 468;
    v34 = 2048;
    v35 = v6;
    v36 = 2048;
    v37 = v2;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_32;
  }
  v12 = v11;
  v13 = *(_QWORD *)(v11 + 24) & 0xFFFFFFFFFFFFFFFLL;
  v14 = a2 & 0xFFFFFFFFFFFFFFFLL;
  if (v13 == 0xFFFFFFFFFFFFFFFLL)
  {
    if (v14 == 0xFFFFFFFFFFFFFFFLL)
      return v12;
    goto LABEL_9;
  }
  if (v14 == 0xFFFFFFFFFFFFFFFLL || v13 != v14)
  {
LABEL_9:
    *(_BYTE *)(v11 + 176) = 1;
    goto LABEL_10;
  }
  return v12;
}

uint64_t re::LinearAllocator::alloc(re::LinearAllocator *this, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;

  v3 = 0;
  v4 = (a3 + *((_QWORD *)this + 5) - 1) & -a3;
  if (v4 + a2 <= *((_QWORD *)this + 6))
  {
    *((_QWORD *)this + 5) = v4 + a2;
    return v4;
  }
  return v3;
}

uint64_t re::PerFrameAllocatorImpl::parent(re::PerFrameAllocatorImpl *this)
{
  return 0;
}

uint64_t re::PerFrameAllocatorImpl::addDestructor(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  _BYTE v12[24];
  uint64_t v13;
  _BYTE *v14;
  int v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  unint64_t v20;
  __int16 v21;
  unint64_t v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  v13 = *(_QWORD *)(a3 + 24);
  v14 = 0;
  re::FunctionBase<24ul,void ()(void)>::operator=<24ul>((uint64_t)v12, a3);
  v5 = *(_QWORD *)(a1 + 136);
  v6 = *(_QWORD *)(a1 + 104);
  if (v5 + 1 > v6 << 6)
  {
    re::BucketArray<re::Pair<void *,re::Function<void ()(void *)>,true>,64ul>::setBucketsCapacity((_QWORD *)(a1 + 96), (v5 + 64) >> 6);
    v6 = *(_QWORD *)(a1 + 104);
  }
  if (v6 <= v5 >> 6)
  {
    v26 = 0u;
    v27 = 0u;
    v25 = 0u;
    v23 = 0u;
    v24 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v15 = 136315906;
    v16 = "operator[]";
    v17 = 1024;
    v18 = 858;
    v19 = 2048;
    v20 = v5 >> 6;
    v21 = 2048;
    v22 = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if ((*(_BYTE *)(a1 + 112) & 1) != 0)
    v7 = a1 + 120;
  else
    v7 = *(_QWORD *)(a1 + 128);
  v8 = *(_QWORD *)(v7 + 8 * (v5 >> 6));
  ++*(_QWORD *)(a1 + 136);
  ++*(_DWORD *)(a1 + 144);
  v9 = (_QWORD *)(v8 + 48 * (v5 & 0x3F));
  *v9 = a2;
  v9[4] = v13;
  v9[5] = 0;
  re::FunctionBase<24ul,void ()(void)>::operator=<24ul>((uint64_t)(v9 + 1), (uint64_t)v12);
  if (v14)
  {
    (**(void (***)(_BYTE *))v14)(v14);
    if (v14 != v12)
      (*(void (**)(uint64_t))(*(_QWORD *)v13 + 40))(v13);
  }
  return a2;
}

uint64_t re::PerFrameAllocatorImpl::statistics(re::PerFrameAllocatorImpl *this)
{
  uint64_t v1;
  uint64_t result;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;

  v1 = *((_QWORD *)this + 9);
  if (!v1)
    return 0;
  result = 0;
  v4 = 0;
  v5 = (_QWORD *)*((_QWORD *)this + 11);
  v6 = 8 * v1;
  do
  {
    v7 = (_QWORD *)*v5++;
    v8 = v7[5];
    v9 = v7[6];
    v4 = v4 - v8 + v9;
    result = v7[7] + result + v9 - (v8 + v7[8]);
    v6 -= 8;
  }
  while (v6);
  return result;
}

uint64_t re::LinearAllocator::statistics(re::LinearAllocator *this)
{
  return *((_QWORD *)this + 5) + *((_QWORD *)this + 4) - (*((_QWORD *)this + 3) + *((_QWORD *)this + 6));
}

_anonymous_namespace_ *re::PerFrameAllocatorManager::init(_anonymous_namespace_ *this)
{
  _anonymous_namespace_ *v1;
  uint64_t *v2;
  _anonymous_namespace_ *v3;
  _anonymous_namespace_ *v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  _anonymous_namespace_ *v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  char *v22;

  if (!*(_BYTE *)this)
  {
    v1 = this;
    v2 = (uint64_t *)((char *)this + 8);
    v5 = 0;
    *(_BYTE *)v1 = 1;
    do
    {
      if (*((_QWORD *)v1 + 5) <= v5)
      {
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_29:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      *(_QWORD *)(*((_QWORD *)v1 + 6) + 8 * v5) = 0;
      if (*((_QWORD *)v1 + 2) <= v5)
        goto LABEL_29;
      *(_QWORD *)(*((_QWORD *)v1 + 3) + 8 * v5++) = 0;
    }
    while (v5 != 16);
    v6 = *((_QWORD *)v1 + 18);
    if (v6 > 0xE)
    {
      if (v6 == 15)
        goto LABEL_25;
      v11 = 15;
      v12 = 1400;
      do
      {
        v13 = *((_QWORD *)v1 + 20);
        v14 = v13 + v12;
        v15 = *(_QWORD *)(v13 + v12 - 32);
        if (v15)
        {
          if (*(_QWORD *)(v13 + v12))
            (*(void (**)(uint64_t))(*(_QWORD *)v15 + 40))(v15);
          v16 = (_QWORD *)(v13 + v12);
          *v16 = 0;
          *(_QWORD *)(v13 + v12 - 24) = 0;
          *(_QWORD *)(v13 + v12 - 16) = 0;
          *(_QWORD *)(v13 + v12 - 32) = 0;
          *((_DWORD *)v16 - 2) = *(_DWORD *)(v13 + v12 - 8) + 1;
        }
        v18 = *(_anonymous_namespace_ **)(v14 - 72);
        v17 = (_QWORD *)(v14 - 72);
        v4 = v18;
        if (v18)
        {
          v19 = v13 + v12;
          if (*(_QWORD *)(v19 - 40))
            v4 = (_anonymous_namespace_ *)(*(uint64_t (**)(_anonymous_namespace_ *))(*(_QWORD *)v4 + 40))(v4);
          *(_QWORD *)(v19 - 40) = 0;
          v17[1] = 0;
          v17[2] = 0;
          *v17 = 0;
          ++*(_DWORD *)(v19 - 48);
        }
        ++v11;
        v12 += 88;
      }
      while (v11 < *((_QWORD *)v1 + 18));
    }
    else if (*((_QWORD *)v1 + 17) > 0xEuLL
           || (v4 = (_anonymous_namespace_ *)re::DynamicArray<re::PerFrameAllocatorManager::ChunkGroup>::setCapacity((_QWORD *)v1 + 16),
               v6 = *((_QWORD *)v1 + 18),
               v6 <= 0xE))
    {
      v7 = v6 - 15;
      v8 = 88 * v6;
      do
      {
        v9 = *((_QWORD *)v1 + 20) + v8;
        *(_QWORD *)(v9 + 80) = 0;
        *(_OWORD *)v9 = 0uLL;
        *(_OWORD *)(v9 + 16) = 0uLL;
        *(_DWORD *)(v9 + 32) = 0;
        *(_OWORD *)(v9 + 40) = 0uLL;
        *(_OWORD *)(v9 + 56) = 0uLL;
        *(_DWORD *)(v9 + 72) = 0;
        v8 += 88;
      }
      while (!__CFADD__(v7++, 1));
    }
    *((_QWORD *)v1 + 18) = 15;
    ++*((_DWORD *)v1 + 38);
LABEL_25:
    v20 = 0;
    v21 = (_QWORD *)*((_QWORD *)v1 + 20);
    do
    {
      *v21 = 0x10000 << v20;
      v21 += 11;
      ++v20;
    }
    while (v20 != 15);
    v22 = (char *)v1 + 56;
    re::DynamicArray<re::RigNodeConstraint>::setCapacity(v22, 0);
    ++*((_DWORD *)v22 + 6);
    *((_DWORD *)v22 + 11) = 16;
    return re::DataArray<re::PerFrameAllocatorImpl>::allocBlock(v22);
  }
  return this;
}

re *re::PerFrameAllocatorManager::deinit(re *this)
{
  re *v1;
  unint64_t v2;
  unint64_t i;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  unint64_t j;

  if (*(_BYTE *)this)
  {
    v1 = this;
    this = (re *)re::DataArray<re::PerFrameAllocatorImpl>::deinit((uint64_t)this + 56);
    v2 = *((_QWORD *)v1 + 18);
    if (v2)
    {
      for (i = 0; i < v2; ++i)
      {
        v4 = *((_QWORD *)v1 + 20);
        v5 = v4 + 88 * i;
        v8 = *(_QWORD *)(v5 + 64);
        v7 = (unint64_t *)(v5 + 64);
        v6 = v8;
        if (v8)
        {
          v9 = 0;
          v10 = (_QWORD *)(v4 + 88 * i + 80);
          do
          {
            v11 = **(_QWORD **)(*v10 + 8 * v9);
            if (v11)
            {
              v12 = re::globalAllocators(this);
              (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v12[2] + 40))(v12[2], v11);
              v6 = *v7;
            }
            if (v6 <= v9)
            {
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_20:
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_21:
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_22:
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
            }
            this = re::internal::destroyPersistent<re::internal::PerFrameAllocatorChunk>(*(re **)(*v10 + 8 * v9));
            v6 = *v7;
            if (*v7 <= v9)
              goto LABEL_20;
            *(_QWORD *)(*v10 + 8 * v9++) = 0;
          }
          while (v6 > v9);
          v2 = *((_QWORD *)v1 + 18);
        }
        *v7 = 0;
        v13 = v4 + 88 * i;
        ++*(_DWORD *)(v13 + 72);
        *(_QWORD *)(v13 + 24) = 0;
        ++*(_DWORD *)(v13 + 32);
      }
    }
    for (j = 0; j != 16; ++j)
    {
      if (*((_QWORD *)v1 + 5) <= j)
        goto LABEL_21;
      *(_QWORD *)(*((_QWORD *)v1 + 6) + 8 * j) = 0;
      if (*((_QWORD *)v1 + 2) <= j)
        goto LABEL_22;
      *(_QWORD *)(*((_QWORD *)v1 + 3) + 8 * j) = 0;
    }
    *(_BYTE *)v1 = 0;
  }
  return this;
}

re *re::internal::destroyPersistent<re::internal::PerFrameAllocatorChunk>(re *result)
{
  re *v1;
  uint64_t v2;

  if (result)
  {
    v1 = result;
    v2 = re::globalAllocators(result)[2];
    *(_OWORD *)((char *)v1 + 40) = 0u;
    *(_OWORD *)((char *)v1 + 56) = 0u;
    re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::deinit((uint64_t *)v1 + 10);
    re::Allocator::~Allocator((re *)((char *)v1 + 16));
    return (re *)(*(uint64_t (**)(uint64_t, re *))(*(_QWORD *)v2 + 40))(v2, v1);
  }
  return result;
}

unint64_t re::PerFrameAllocatorManager::addOwner(os_unfair_lock_s *this, void *a2)
{
  os_unfair_lock_s *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t i;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  __int128 v13;

  v4 = this + 30;
  os_unfair_lock_lock(this + 30);
  v6 = 0;
  for (i = 0; i != 16; ++i)
  {
    if (*(_QWORD *)&this[10]._os_unfair_lock_opaque == i)
    {
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_10:
      v12 = 0;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      LODWORD(v13) = 136315906;
      *(_QWORD *)((char *)&v13 + 4) = "operator[]";
      WORD6(v13) = 1024;
      HIWORD(v13) = 468;
      _os_log_send_and_compose_impl();
      v9 = _os_crash_msg();
      __break(1u);
LABEL_11:
      re::internal::assertLog((re::internal *)5, v10, "assertion failure: '%s' (%s:line %i) pthread_key_create failed: %d", "result == 0", "addOwner", 271, v9, v12, v13);
      _os_crash();
      __break(1u);
    }
    v8 = *(_QWORD *)&this[12]._os_unfair_lock_opaque;
    if (!*(_QWORD *)(v8 + 8 * i))
      goto LABEL_6;
    v6 -= 8;
  }
  re::internal::assertLog((re::internal *)5, v5, "assertion failure: '%s' (%s:line %i) Too many PerFrameAllocator owners (more than %llu FrameManagers)", "!\"Unreachable code\"", "addOwner", 278, 16);
  _os_crash();
  __break(1u);
LABEL_6:
  *(_QWORD *)(v8 + 8 * i) = a2;
  if (*(_QWORD *)&this[4]._os_unfair_lock_opaque <= i)
    goto LABEL_10;
  v9 = pthread_key_create((pthread_key_t *)(*(_QWORD *)&this[6]._os_unfair_lock_opaque - v6), 0);
  if ((_DWORD)v9)
    goto LABEL_11;
  os_unfair_lock_unlock(v4);
  return i;
}

void re::PerFrameAllocatorManager::removeOwner(os_unfair_lock_s *this, unint64_t a2)
{
  os_unfair_lock_s *v4;
  char *v5;
  int v8;
  uint64_t v9;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD v23[2];
  uint64_t v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  _BYTE v28[18];
  __int16 v29;
  unint64_t v30;
  __int16 v31;
  unint64_t v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  uint64_t v38;

  v38 = *MEMORY[0x24BDAC8D0];
  v4 = this + 30;
  os_unfair_lock_lock(this + 30);
  v26 = 0;
  v23[1] = 0;
  v24 = 0;
  v23[0] = 0;
  v5 = (char *)&this[14];
  v25 = 0;
  re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::DataArrayIterator((uint64_t)&v33, (uint64_t)&this[14], 0);
  *(_OWORD *)v28 = v33;
  if (&this[14] == (os_unfair_lock_s *)v33 && WORD4(v33) == 0xFFFFLL && (DWORD2(v33) & 0xFFFF0000) == 4294901760)
  {
    v13 = 0;
  }
  else
  {
    do
    {
      v8 = re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::handle((unsigned __int16 *)v28);
      v9 = re::DataArray<re::PerFrameAllocatorImpl>::get((uint64_t)&this[14], v8);
      if (a2 == *(_QWORD *)(v9 + 24) >> 60 && *(_BYTE *)(v9 + 168) != 0)
      {
        *(_QWORD *)&v33 = re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::handle((unsigned __int16 *)v28);
        re::DynamicArray<re::DataArrayHandle<re::PerFrameAllocatorImpl>>::add((_anonymous_namespace_ *)v23, &v33);
      }
      re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::increment(v28);
    }
    while (*(char **)v28 != v5 || *(unsigned __int16 *)&v28[8] != 0xFFFF || *(unsigned __int16 *)&v28[10] != 0xFFFF);
    v13 = v26;
    if (v24)
    {
      v14 = 0;
      v15 = 8 * v24;
      do
      {
        re::DataArray<re::PerFrameAllocatorImpl>::destroy((uint64_t)&this[14], *(_QWORD *)(v13 + v14));
        v14 += 8;
      }
      while (v15 != v14);
    }
  }
  re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::DataArrayIterator((uint64_t)&v33, (uint64_t)&this[14], 0);
  if (v5 != (char *)v33 || WORD4(v33) != 0xFFFFLL || (DWORD2(v33) & 0xFFFF0000) != 4294901760)
  {
    do
    {
      re::DataArray<re::PerFrameAllocatorImpl>::DataArrayIterator<re::PerFrameAllocatorImpl,re::PerFrameAllocatorImpl&>::operator*((unsigned __int16 *)&v33);
      re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::increment(&v33);
    }
    while ((char *)v33 != v5 || WORD4(v33) != 0xFFFF || WORD5(v33) != 0xFFFF);
  }
  v20 = *(_QWORD *)&this[10]._os_unfair_lock_opaque;
  if (v20 <= a2)
  {
    v27 = 0;
    v36 = 0u;
    v37 = 0u;
    v34 = 0u;
    v35 = 0u;
    v33 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v28 = 136315906;
    *(_QWORD *)&v28[4] = "operator[]";
    *(_WORD *)&v28[12] = 1024;
    *(_DWORD *)&v28[14] = 468;
    v29 = 2048;
    v30 = a2;
    v31 = 2048;
    v32 = v20;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_50;
  }
  *(_QWORD *)(*(_QWORD *)&this[12]._os_unfair_lock_opaque + 8 * a2) = 0;
  v20 = *(_QWORD *)&this[4]._os_unfair_lock_opaque;
  if (v20 <= a2)
  {
LABEL_50:
    v27 = 0;
    v36 = 0u;
    v37 = 0u;
    v34 = 0u;
    v35 = 0u;
    v33 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v28 = 136315906;
    *(_QWORD *)&v28[4] = "operator[]";
    *(_WORD *)&v28[12] = 1024;
    *(_DWORD *)&v28[14] = 468;
    v29 = 2048;
    v30 = a2;
    v31 = 2048;
    v32 = v20;
    _os_log_send_and_compose_impl();
    v21 = _os_crash_msg();
    __break(1u);
    goto LABEL_51;
  }
  v21 = pthread_key_delete(*(_QWORD *)(*(_QWORD *)&this[6]._os_unfair_lock_opaque + 8 * a2));
  if ((_DWORD)v21)
  {
LABEL_51:
    re::internal::assertLog((re::internal *)5, v22, "assertion failure: '%s' (%s:line %i) pthread_key_delete failed: %d", "result == 0", "removeOwner", 314, v21);
    _os_crash();
    __break(1u);
LABEL_52:
    v27 = 0;
    v36 = 0u;
    v37 = 0u;
    v34 = 0u;
    v35 = 0u;
    v33 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v28 = 136315906;
    *(_QWORD *)&v28[4] = "operator[]";
    *(_WORD *)&v28[12] = 1024;
    *(_DWORD *)&v28[14] = 468;
    v29 = 2048;
    v30 = a2;
    v31 = 2048;
    v32 = v20;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  v20 = *(_QWORD *)&this[4]._os_unfair_lock_opaque;
  if (v20 <= a2)
    goto LABEL_52;
  *(_QWORD *)(*(_QWORD *)&this[6]._os_unfair_lock_opaque + 8 * a2) = 0;
  if (v23[0] && v13)
    (*(void (**)(void))(*(_QWORD *)v23[0] + 40))();
  os_unfair_lock_unlock(v4);
}

uint64_t re::DataArray<re::PerFrameAllocatorImpl>::get(uint64_t a1, int a2)
{
  if (*(_QWORD *)(a1 + 16) <= (unint64_t)HIWORD(a2))
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(*(_QWORD *)(a1 + 32) + 16 * HIWORD(a2)) + 184 * (unsigned __int16)a2;
}

_anonymous_namespace_ *re::DynamicArray<re::DataArrayHandle<re::PerFrameAllocatorImpl>>::add(_anonymous_namespace_ *result, _QWORD *a2)
{
  _anonymous_namespace_ *v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  BOOL v8;
  unint64_t v9;
  unint64_t v10;

  v3 = result;
  v4 = *((_QWORD *)result + 1);
  v5 = *((_QWORD *)result + 2);
  if (v5 >= v4)
  {
    v6 = v5 + 1;
    if (v4 < v5 + 1)
    {
      if (*(_QWORD *)result)
      {
        v7 = 2 * v4;
        v8 = v4 == 0;
        v9 = 8;
        if (!v8)
          v9 = v7;
        if (v9 <= v6)
          v10 = v6;
        else
          v10 = v9;
        result = (_anonymous_namespace_ *)re::DynamicArray<float *>::setCapacity(result, v10);
      }
      else
      {
        result = (_anonymous_namespace_ *)re::DynamicArray<float *>::setCapacity(v3, v6);
        ++*((_DWORD *)v3 + 6);
      }
    }
    v5 = *((_QWORD *)v3 + 2);
  }
  *(_QWORD *)(*((_QWORD *)v3 + 4) + 8 * v5) = *a2;
  ++*((_QWORD *)v3 + 2);
  ++*((_DWORD *)v3 + 6);
  return result;
}

uint64_t re::DataArray<re::PerFrameAllocatorImpl>::DataArrayIterator<re::PerFrameAllocatorImpl,re::PerFrameAllocatorImpl&>::operator*(unsigned __int16 *a1)
{
  unint64_t v1;

  v1 = a1[5];
  if (*(_QWORD *)(*(_QWORD *)a1 + 16) <= v1)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 32) + 16 * v1) + 184 * a1[4];
}

uint64_t re::PerFrameAllocatorManager::freeAllocatorsWithPredicate(uint64_t a1, unint64_t a2, uint64_t a3)
{
  os_unfair_lock_s *v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t i;
  _anonymous_namespace_ *v18;
  _anonymous_namespace_ *v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  unint64_t j;
  uint64_t v26;
  uint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  int v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  int v36;
  _QWORD *v39;
  _QWORD *v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t *v46;
  uint64_t v47;
  unint64_t *v48;
  unint64_t v49;
  BOOL v50;
  uint64_t result;
  uint64_t v52;
  uint64_t v53;
  char v54;
  os_unfair_lock_s *lock;
  os_unfair_lock_t locka;
  unint64_t v57;
  unint64_t v58;
  uint64_t v59;
  _QWORD *v60;
  unint64_t v61;
  uint64_t v62;
  unint64_t v63;
  uint64_t v64;
  uint64_t v65;
  int v66;
  unint64_t *v67;
  unint64_t v68;
  uint64_t v69;
  uint64_t v70;
  int v71;
  _QWORD *v72;
  uint64_t *v73;
  unint64_t v74;
  unint64_t v75;
  int v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  unint64_t v80;

  v77 = 0;
  v74 = 0;
  v75 = 0;
  v73 = 0;
  v6 = (os_unfair_lock_s *)(a1 + 120);
  v76 = 0;
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 120));
  v7 = a2 >> 60;
  v8 = a1 + 56;
  re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::DataArrayIterator((uint64_t)&v68, a1 + 56, 0);
  v63 = v68;
  v64 = v69;
  if (a1 + 56 == v68 && (unsigned __int16)v69 == 0xFFFFLL && (v69 & 0xFFFF0000) == 4294901760)
  {
    os_unfair_lock_unlock(v6);
    v12 = 0;
LABEL_43:
    v54 = 1;
    goto LABEL_44;
  }
  lock = v6;
  v57 = a2 >> 60;
  v11 = 0;
  v12 = 0;
  v58 = a2;
  v59 = a3;
  do
  {
    v13 = re::DataArray<re::PerFrameAllocatorImpl>::DataArrayIterator<re::PerFrameAllocatorImpl,re::PerFrameAllocatorImpl&>::operator*((unsigned __int16 *)&v63);
    v14 = *(_QWORD *)(v13 + 24);
    if (v7 == v14 >> 60)
    {
      v15 = v13;
      v68 = a2;
      v78 = v14;
      if ((*(unsigned int (**)(_QWORD, unint64_t *, unint64_t *))(**(_QWORD **)(a3 + 32) + 16))(*(_QWORD *)(a3 + 32), &v68, &v78))
      {
        v16 = *(_QWORD *)(v15 + 136);
        if (v16)
        {
          for (i = 0; i != v16; ++i)
          {
            v18 = (_anonymous_namespace_ *)re::BucketArray<re::Pair<void *,re::Function<void ()(void *)>,true>,64ul>::operator[](v15 + 96, i);
            v19 = v18;
            if (v12 >= v74)
            {
              v20 = v12 + 1;
              if (v74 < v20)
              {
                if (v73)
                {
                  v21 = 8;
                  if (v74)
                    v21 = 2 * v74;
                  if (v21 <= v20)
                    v22 = v20;
                  else
                    v22 = v21;
                  re::DynamicArray<re::Pair<void *,re::Function<void ()(void *)>,true>>::setCapacity(&v73, v22);
                }
                else
                {
                  re::DynamicArray<re::Pair<void *,re::Function<void ()(void *)>,true>>::setCapacity(&v73, v20);
                  ++v76;
                }
              }
              v12 = v75;
              v11 = v77;
            }
            v23 = (_QWORD *)(v11 + 48 * v12);
            *v23 = *(_QWORD *)v19;
            v23[4] = *((_QWORD *)v19 + 4);
            v23[5] = 0;
            re::FunctionBase<24ul,void ()(void)>::operator=<24ul>((uint64_t)(v23 + 1), (uint64_t)v19 + 8);
            v12 = ++v75;
            ++v76;
          }
          v24 = *(_QWORD *)(v15 + 136);
          if (v24)
          {
            for (j = 0; j != v24; ++j)
            {
              v26 = re::BucketArray<re::Pair<void *,re::Function<void ()(void *)>,true>,64ul>::operator[](v15 + 96, j);
              re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable(v26 + 8);
            }
          }
          a2 = v58;
          a3 = v59;
          v7 = v57;
        }
        *(_QWORD *)(v15 + 136) = 0;
        ++*(_DWORD *)(v15 + 144);
      }
    }
    re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::increment(&v63);
  }
  while (v63 != v8 || (unsigned __int16)v64 != 0xFFFF || WORD1(v64) != 0xFFFF);
  v6 = lock;
  os_unfair_lock_unlock(lock);
  if (!v12)
    goto LABEL_43;
  v29 = v77;
  v30 = 48 * v12;
  do
  {
    v68 = *(_QWORD *)(v29 + v30 - 48);
    (*(void (**)(_QWORD, unint64_t *))(**(_QWORD **)(v29 + v30 - 8) + 16))(*(_QWORD *)(v29 + v30 - 8), &v68);
    v30 -= 48;
  }
  while (v30);
  v54 = 0;
  v6 = lock;
LABEL_44:
  os_unfair_lock_lock(v6);
  v72 = 0;
  v69 = 0;
  v70 = 0;
  v67 = 0;
  v68 = 0;
  v71 = 0;
  v64 = 0;
  v65 = 0;
  v63 = 0;
  v66 = 0;
  re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::DataArrayIterator((uint64_t)&v78, a1 + 56, 0);
  v61 = v78;
  v62 = v79;
  if (v8 == v78 && (unsigned __int16)v79 == 0xFFFFLL && (v79 & 0xFFFF0000) == 0xFFFF0000)
  {
    v31 = 0;
  }
  else
  {
    do
    {
      v32 = re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::handle((unsigned __int16 *)&v61);
      v33 = re::DataArray<re::PerFrameAllocatorImpl>::get(a1 + 56, v32);
      v34 = *(_QWORD *)(v33 + 24);
      if (v7 == v34 >> 60)
      {
        v35 = v33;
        v78 = a2;
        v80 = v34;
        if ((*(unsigned int (**)(_QWORD, unint64_t *, unint64_t *))(**(_QWORD **)(a3 + 32)
                                                                                            + 16))(*(_QWORD *)(a3 + 32), &v78, &v80))
        {
          v78 = re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::handle((unsigned __int16 *)&v61);
          re::DynamicArray<re::DataArrayHandle<re::PerFrameAllocatorImpl>>::add((_anonymous_namespace_ *)&v68, &v78);
        }
        if (*(_BYTE *)(v35 + 168))
        {
          v36 = *(_DWORD *)(v35 + 172);
          if (v36 >= 1)
            *(_DWORD *)(v35 + 172) = --v36;
          if (!v36 && *(_BYTE *)(v35 + 176))
          {
            v78 = re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::handle((unsigned __int16 *)&v61);
            re::DynamicArray<re::DataArrayHandle<re::PerFrameAllocatorImpl>>::add((_anonymous_namespace_ *)&v63, &v78);
          }
        }
      }
      re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::increment(&v61);
    }
    while (v61 != v8 || (unsigned __int16)v62 != 0xFFFF || WORD1(v62) != 0xFFFF);
    v31 = v72;
    if (v70)
    {
      locka = v6;
      v39 = v72;
      v60 = v72;
      v40 = &v72[v70];
      do
      {
        v42 = re::DataArray<re::PerFrameAllocatorImpl>::get(a1 + 56, *v39);
        *(_BYTE *)(v42 + 168) = 1;
        if (*(_QWORD *)(v42 + 72))
        {
          v43 = 0;
          do
          {
            v44 = *(_QWORD *)(*(_QWORD *)(v42 + 88) + 8 * v43);
            v78 = v44;
            v45 = re::PerFrameAllocatorManager::sizeToIndex(*(re::PerFrameAllocatorManager **)(v44 + 8), v41);
            if (v45 < *(_QWORD *)(a1 + 144))
            {
              *(_OWORD *)(v44 + 56) = *(_OWORD *)(v44 + 40);
              re::DynamicArray<re::RigDataValue *>::add((_anonymous_namespace_ *)(*(_QWORD *)(a1 + 160) + 88 * v45 + 8), &v78);
            }
            ++v43;
          }
          while (*(_QWORD *)(v42 + 72) > v43);
        }
        *(_QWORD *)(v42 + 72) = 0;
        ++*(_DWORD *)(v42 + 80);
        *(_QWORD *)(v42 + 40) = 0;
        *(_QWORD *)(v42 + 48) = 0;
        *(_QWORD *)(v42 + 32) = 0;
        ++v39;
      }
      while (v39 != v40);
      v6 = locka;
      v31 = v60;
    }
  }
  v46 = v67;
  if (v65)
  {
    v47 = 8 * v65;
    v48 = v67;
    do
    {
      v49 = *v48++;
      re::DataArray<re::PerFrameAllocatorImpl>::destroy(v8, v49);
      v47 -= 8;
    }
    while (v47);
  }
  if (v63)
    v50 = v46 == 0;
  else
    v50 = 1;
  if (!v50)
    (*(void (**)(void))(*(_QWORD *)v63 + 40))();
  if (v68 && v31)
    (*(void (**)(void))(*(_QWORD *)v68 + 40))();
  os_unfair_lock_unlock(v6);
  result = (uint64_t)v73;
  if (v73 && v77)
  {
    if ((v54 & 1) == 0)
    {
      v52 = 48 * v12;
      v53 = v77 + 8;
      do
      {
        re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable(v53);
        v53 += 48;
        v52 -= 48;
      }
      while (v52);
      result = (uint64_t)v73;
    }
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
  }
  return result;
}

uint64_t re::PerFrameAllocatorManager::freeAllocatorsOlderOrEqual(re *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t result;
  _QWORD v6[3];
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v4 = re::globalAllocators(a1)[2];
  v6[0] = &off_24ED42478;
  v7 = v4;
  v8 = v6;
  re::PerFrameAllocatorManager::freeAllocatorsWithPredicate((uint64_t)a1, a2, (uint64_t)v6);
  result = (uint64_t)v8;
  if (v8)
  {
    result = (*(uint64_t (**)(_QWORD *))*v8)(v8);
    if (v8 != v6)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 40))(v7);
  }
  return result;
}

uint64_t re::PerFrameAllocatorManager::freeAllocatorsForFrame(re *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t result;
  _QWORD v6[3];
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v4 = re::globalAllocators(a1)[2];
  v6[0] = &off_24ED424E0;
  v7 = v4;
  v8 = v6;
  re::PerFrameAllocatorManager::freeAllocatorsWithPredicate((uint64_t)a1, a2, (uint64_t)v6);
  result = (uint64_t)v8;
  if (v8)
  {
    result = (*(uint64_t (**)(_QWORD *))*v8)(v8);
    if (v8 != v6)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 40))(v7);
  }
  return result;
}

uint64_t re::InlineString<32ul>::format@<X0>(uint64_t a1@<X8>, char a2)
{
  uint64_t result;
  uint64_t v4;
  unint64_t v5;

  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_QWORD *)a1 = 0;
  result = vsnprintf((char *)(a1 + 8), 0x20uLL, "PerThreadAllocator.%s", &a2);
  if ((result & 0x80000000) != 0)
  {
    *(_BYTE *)(a1 + *(_QWORD *)a1 + 8) = 0;
  }
  else
  {
    v5 = *(_QWORD *)a1 + result;
    if (v5 >= 0x20)
    {
      re::internal::assertLog((re::internal *)4, v4, "assertion failure: '%s' (%s:line %i) ", "m_length + result < m_capacity", "vappendf", 446);
      result = _os_crash();
      __break(1u);
    }
    else
    {
      *(_QWORD *)a1 = v5;
    }
  }
  return result;
}

uint64_t *re::getValidAllocator(re *a1)
{
  uint64_t *v2;
  uint64_t *result;

  v2 = re::globalAllocators(a1);
  result = (uint64_t *)re::PerFrameAllocatorManager::perFrameAllocator(v2[6], (unint64_t)a1);
  if (*((_BYTE *)result + 168))
  {
  }
  return result;
}

uint64_t re::PerFrameAllocatorImpl::destructorCalledByDefault(re::PerFrameAllocatorImpl *this)
{
  return 0;
}

void re::LinearAllocator::~LinearAllocator(re::LinearAllocator *this)
{
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::deinit((uint64_t *)this + 8);
  re::Allocator::~Allocator(this);
}

{
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::deinit((uint64_t *)this + 8);
  re::Allocator::~Allocator(this);
  JUMPOUT(0x2276933B8);
}

uint64_t re::LinearAllocator::parent(re::LinearAllocator *this)
{
  return 0;
}

void re::internal::Callable<re::PerFrameAllocatorManager::freeAllocatorsOlderOrEqual(re::FrameCount)::$_0,BOOL ()(re::FrameCount,re::FrameCount)>::~Callable()
{
  JUMPOUT(0x2276933B8);
}

BOOL re::internal::Callable<re::PerFrameAllocatorManager::freeAllocatorsOlderOrEqual(re::FrameCount)::$_0,BOOL ()(re::FrameCount,re::FrameCount)>::operator()(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return (*a3 & 0xFFFFFFFFFFFFFFFuLL) <= (*a2 & 0xFFFFFFFFFFFFFFFuLL);
}

_QWORD *re::internal::Callable<re::PerFrameAllocatorManager::freeAllocatorsOlderOrEqual(re::FrameCount)::$_0,BOOL ()(re::FrameCount,re::FrameCount)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  _QWORD *result;

  result = a2;
  *a2 = &off_24ED42478;
  return result;
}

_QWORD *re::internal::Callable<re::PerFrameAllocatorManager::freeAllocatorsOlderOrEqual(re::FrameCount)::$_0,BOOL ()(re::FrameCount,re::FrameCount)>::moveInto(uint64_t a1, _QWORD *a2)
{
  _QWORD *result;

  result = a2;
  *a2 = &off_24ED42478;
  return result;
}

uint64_t re::internal::Callable<re::PerFrameAllocatorManager::freeAllocatorsOlderOrEqual(re::FrameCount)::$_0,BOOL ()(re::FrameCount,re::FrameCount)>::size()
{
  return 16;
}

void re::internal::Callable<re::PerFrameAllocatorManager::freeAllocatorsForFrame(re::FrameCount)::$_0,BOOL ()(re::FrameCount,re::FrameCount)>::~Callable()
{
  JUMPOUT(0x2276933B8);
}

BOOL re::internal::Callable<re::PerFrameAllocatorManager::freeAllocatorsForFrame(re::FrameCount)::$_0,BOOL ()(re::FrameCount,re::FrameCount)>::operator()(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  _BOOL4 v6;
  _BOOL4 v7;

  v3 = *a3 & 0xFFFFFFFFFFFFFFFLL;
  v4 = *a2 & 0xFFFFFFFFFFFFFFFLL;
  v6 = v4 != 0xFFFFFFFFFFFFFFFLL && v3 == v4;
  v7 = v4 == 0xFFFFFFFFFFFFFFFLL;
  if (v3 == 0xFFFFFFFFFFFFFFFLL)
    return v7;
  else
    return v6;
}

_QWORD *re::internal::Callable<re::PerFrameAllocatorManager::freeAllocatorsForFrame(re::FrameCount)::$_0,BOOL ()(re::FrameCount,re::FrameCount)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  _QWORD *result;

  result = a2;
  *a2 = &off_24ED424E0;
  return result;
}

_QWORD *re::internal::Callable<re::PerFrameAllocatorManager::freeAllocatorsForFrame(re::FrameCount)::$_0,BOOL ()(re::FrameCount,re::FrameCount)>::moveInto(uint64_t a1, _QWORD *a2)
{
  _QWORD *result;

  result = a2;
  *a2 = &off_24ED424E0;
  return result;
}

uint64_t re::internal::Callable<re::PerFrameAllocatorManager::freeAllocatorsForFrame(re::FrameCount)::$_0,BOOL ()(re::FrameCount,re::FrameCount)>::size()
{
  return 16;
}

_QWORD *re::BucketArray<re::Pair<void *,re::Function<void ()(void *)>,true>,64ul>::setBucketsCapacity(_QWORD *result, unint64_t a2)
{
  _QWORD *v3;
  unint64_t v4;
  unint64_t *v5;
  _QWORD *v6;
  unint64_t v7;
  int v8;
  unint64_t v9;
  unint64_t v10;
  BOOL v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  _QWORD *v15;
  unint64_t v16;

  v3 = result;
  if (*result)
  {
    if (result[5] < a2 << 6)
    {
      while (1)
      {
        v4 = v3[1];
        if (v4 <= a2)
          break;
        result = (_QWORD *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        v5 = v3 + 3;
        do
        {
          result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(*(_QWORD *)*v3 + 32))(*v3, 3072, 0);
          v6 = result;
          if (*v3)
          {
            v7 = v3[1];
            v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              v9 = *v5;
              v11 = v7 >= *v5;
              v10 = v7 + 1;
              v11 = !v11 || v9 >= v10;
              if (v11)
                goto LABEL_22;
              v12 = 2 * v9;
              goto LABEL_18;
            }
            v10 = v7 + 1;
            if (v10 >= 3)
            {
              v12 = 4;
LABEL_18:
              if (v12 <= v10)
                v14 = v10;
              else
                v14 = v12;
              result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v14);
              v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            v13 = v3[1] + 1;
            result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v13);
            v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + 4) = v8;
          }
LABEL_22:
          v15 = v3 + 3;
          if ((v8 & 1) == 0)
            v15 = (_QWORD *)v3[4];
          v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
    re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, a2);
    *((_DWORD *)v3 + 4) += 2;
    v3[5] = 0;
    result = (_QWORD *)re::BucketArray<re::Pair<void *,re::Function<void ()(void *)>,true>,64ul>::setBucketsCapacity(v3, a2);
    ++*((_DWORD *)v3 + 12);
  }
  return result;
}

_QWORD *re::DynamicArray<re::PerFrameAllocatorManager::ChunkGroup>::setCapacity(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  if (result[1] != 15)
  {
    v1 = result;
    if (result[2] <= 0xFuLL)
    {
      v2 = *result;
      if (*v1)
      {
        result = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v2 + 32))(v2, 1320, 8);
        if (result)
        {
          v4 = result;
          if (v1[1])
          {
            v5 = v1[4];
            v6 = v1[2];
            if (v6)
            {
              v7 = v5 + 40;
              v8 = 88 * v6;
              v9 = result;
              do
              {
                v10 = *(_QWORD *)(v7 - 40);
                v9[5] = 0;
                v9[1] = 0;
                v9[2] = 0;
                *((_DWORD *)v9 + 8) = 0;
                v9[3] = 0;
                v12 = (_QWORD *)(v7 - 32);
                v11 = *(_QWORD *)(v7 - 32);
                *v9 = v10;
                v13 = *(_QWORD *)(v7 - 24);
                v9[1] = v11;
                *(_QWORD *)(v7 - 32) = 0;
                v9[2] = v13;
                *(_QWORD *)(v7 - 24) = 0;
                v14 = v9[3];
                v9[3] = *(_QWORD *)(v7 - 16);
                *(_QWORD *)(v7 - 16) = v14;
                v15 = v9[5];
                v9[5] = *(_QWORD *)v7;
                *(_QWORD *)v7 = v15;
                ++*(_DWORD *)(v7 - 8);
                ++*((_DWORD *)v9 + 8);
                v9[10] = 0;
                v9[7] = 0;
                v9[8] = 0;
                v9[6] = 0;
                *((_DWORD *)v9 + 18) = 0;
                v9[6] = *(_QWORD *)(v7 + 8);
                *(_QWORD *)(v7 + 8) = 0;
                v16 = v9[10];
                v9[10] = *(_QWORD *)(v7 + 40);
                v17 = *(_QWORD *)(v7 + 8);
                v9[7] = *(_QWORD *)(v7 + 16);
                *(_QWORD *)(v7 + 16) = 0;
                v18 = v9[8];
                v9[8] = *(_QWORD *)(v7 + 24);
                *(_QWORD *)(v7 + 24) = v18;
                ++*(_DWORD *)(v7 + 32);
                ++*((_DWORD *)v9 + 18);
                *(_QWORD *)(v7 + 40) = v16;
                if (v17)
                {
                  if (v16)
                    (*(void (**)(uint64_t))(*(_QWORD *)v17 + 40))(v17);
                  *(_QWORD *)(v7 + 40) = 0;
                  *(_QWORD *)(v7 + 16) = 0;
                  *(_QWORD *)(v7 + 24) = 0;
                  *(_QWORD *)(v7 + 8) = 0;
                  ++*(_DWORD *)(v7 + 32);
                }
                if (*v12)
                {
                  if (*(_QWORD *)v7)
                    (*(void (**)(_QWORD))(*(_QWORD *)*v12 + 40))(*v12);
                  *(_QWORD *)v7 = 0;
                  *(_QWORD *)(v7 - 24) = 0;
                  *(_QWORD *)(v7 - 16) = 0;
                  *v12 = 0;
                  ++*(_DWORD *)(v7 - 8);
                }
                v7 += 88;
                v9 += 11;
                v8 -= 88;
              }
              while (v8);
              v5 = v1[4];
            }
            result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v1 + 40))(*v1, v5);
          }
          v1[4] = v4;
          v1[1] = 15;
        }
        else
        {
          re::internal::assertLog((re::internal *)6, v3, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, 1320, *(_QWORD *)(*v1 + 8));
          result = (_QWORD *)_os_crash();
          __break(1u);
        }
      }
      else
      {
        result = (_QWORD *)re::DynamicArray<re::PerFrameAllocatorManager::ChunkGroup>::setCapacity(v1);
        ++*((_DWORD *)v1 + 6);
      }
    }
  }
  return result;
}

_anonymous_namespace_ *re::DataArray<re::PerFrameAllocatorImpl>::allocBlock(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _anonymous_namespace_ *result;
  uint64_t v8;
  _anonymous_namespace_ *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t *v15;

  v3 = 184 * *((unsigned int *)a1 + 11);
  v4 = (*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(*(_QWORD *)*a1 + 32))(*a1, v3, 0);
  if (!v4)
  {
    re::internal::assertLog((re::internal *)6, v5, "assertion failure: '%s' (%s:line %i) DataArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "block.elements", "allocBlock", 520, v3, *(_QWORD *)(*a1 + 8));
    _os_crash();
    __break(1u);
    goto LABEL_16;
  }
  v6 = v4;
  v1 = 4 * *((unsigned int *)a1 + 11);
  result = (_anonymous_namespace_ *)(*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(*(_QWORD *)*a1 + 32))(*a1, v1, 0);
  if (!result)
  {
LABEL_16:
    re::internal::assertLog((re::internal *)6, v8, "assertion failure: '%s' (%s:line %i) DataArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "block.allocationCounters", "allocBlock", 528, v1, *(_QWORD *)(*a1 + 8));
    result = (_anonymous_namespace_ *)_os_crash();
    __break(1u);
    return result;
  }
  v9 = result;
  v11 = a1[1];
  v10 = a1[2];
  if (v10 >= v11)
  {
    v12 = v10 + 1;
    if (v11 < v10 + 1)
    {
      if (*a1)
      {
        v13 = 2 * v11;
        if (!v11)
          v13 = 8;
        if (v13 <= v12)
          v14 = v12;
        else
          v14 = v13;
        result = (_anonymous_namespace_ *)re::DynamicArray<re::RigNodeConstraint>::setCapacity(a1, v14);
      }
      else
      {
        result = (_anonymous_namespace_ *)re::DynamicArray<re::RigNodeConstraint>::setCapacity(a1, v12);
        ++*((_DWORD *)a1 + 6);
      }
    }
    v10 = a1[2];
  }
  v15 = (uint64_t *)(a1[4] + 16 * v10);
  *v15 = v6;
  v15[1] = (uint64_t)v9;
  a1[2] = v10 + 1;
  ++*((_DWORD *)a1 + 6);
  *((_DWORD *)a1 + 12) = 0;
  return result;
}

uint64_t re::BucketArray<re::Pair<void *,re::Function<void ()(void *)>,true>,64ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1011, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(_QWORD *)(a1 + 8) <= a2 >> 6)
    goto LABEL_8;
  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
    v3 = a1 + 24;
  else
    v3 = *(_QWORD *)(a1 + 32);
  return *(_QWORD *)(v3 + 8 * (a2 >> 6)) + 48 * (a2 & 0x3F);
}

_QWORD *re::DynamicArray<re::Pair<void *,re::Function<void ()(void *)>,true>>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::Pair<void *,re::Function<void ()(void *)>,true>>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x30uLL))
        {
          v2 = 48 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 48 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_16;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 48, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = (_QWORD *)v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = &v8[6 * v9];
        v11 = v7;
        do
        {
          *v11 = *v8;
          v11[4] = v8[4];
          v11[5] = 0;
          re::FunctionBase<24ul,void ()(void)>::operator=<24ul>((uint64_t)(v11 + 1), (uint64_t)(v8 + 1));
          re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable((uint64_t)(v8 + 1));
          v8 += 6;
          v11 += 6;
        }
        while (v8 != v10);
        v8 = (_QWORD *)v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

void re::AutoFreeAllocator::~AutoFreeAllocator(re::AutoFreeAllocator *this)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  int *v5;
  int v6;
  uint64_t v7;
  int v8;
  int v9;
  uint64_t v10;

  v2 = (uint64_t *)((char *)this + 32);
  v3 = *((unsigned int *)this + 16);
  if ((_DWORD)v3)
  {
    v4 = 0;
    v5 = (int *)(*((_QWORD *)this + 6) + 8);
    while (1)
    {
      v6 = *v5;
      v5 += 6;
      if (v6 < 0)
        break;
      if (v3 == ++v4)
      {
        LODWORD(v4) = *((_DWORD *)this + 16);
        break;
      }
    }
  }
  else
  {
    LODWORD(v4) = 0;
  }
  if ((_DWORD)v3 != (_DWORD)v4)
  {
    v7 = v4;
    do
    {
      v10 = *(_QWORD *)(*((_QWORD *)this + 6) + 24 * v7 + 16);
      re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::remove((uint64_t)v2, &v10);
      (*(void (**)(_QWORD, uint64_t))(**((_QWORD **)this + 3) + 40))(*((_QWORD *)this + 3), v10);
      if (*((_DWORD *)this + 16) <= (v4 + 1))
        v8 = v4 + 1;
      else
        v8 = *((_DWORD *)this + 16);
      v9 = v4;
      while (1)
      {
        v7 = (v9 + 1);
        if (v8 - 1 == v9)
          break;
        ++v9;
        LODWORD(v4) = v7;
        if ((*(_DWORD *)(*((_QWORD *)this + 6) + 24 * v7 + 8) & 0x80000000) != 0)
          goto LABEL_17;
      }
      LODWORD(v4) = v8;
LABEL_17:
      ;
    }
    while ((_DWORD)v3 != (_DWORD)v4);
  }
  re::HashSetBase<void *,void *,re::internal::ValueAsKey<void *>,re::Hash<void *>,re::EqualTo<void *>,true,false>::clear((uint64_t)v2);
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(v2);
  re::Allocator::~Allocator(this);
}

{
  re::AutoFreeAllocator::~AutoFreeAllocator(this);
  JUMPOUT(0x2276933B8);
}

uint64_t re::AutoFreeAllocator::free(re::AutoFreeAllocator *this, uint64_t a2)
{
  uint64_t v4;

  v4 = a2;
  re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::remove((uint64_t)this + 32, &v4);
  return (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)this + 3) + 40))(*((_QWORD *)this + 3), v4);
}

uint64_t re::AutoFreeAllocator::alloc(re::AutoFreeAllocator *this, uint64_t a2)
{
  uint64_t v4;

  v4 = (*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(**((_QWORD **)this + 3) + 32))(*((_QWORD *)this + 3), a2, 0);
  re::HashSetBase<void *,void *,re::internal::ValueAsKey<void *>,re::Hash<void *>,re::EqualTo<void *>,true,false>::add((uint64_t)this + 32, &v4);
  return v4;
}

void re::ThreadSafeAutoFreeAllocator::~ThreadSafeAutoFreeAllocator(re::ThreadSafeAutoFreeAllocator *this)
{
  uint64_t v2;
  uint64_t v3;
  int *v4;
  int v5;
  uint64_t v6;
  int v7;
  int v8;

  v2 = *((unsigned int *)this + 16);
  if ((_DWORD)v2)
  {
    v3 = 0;
    v4 = (int *)(*((_QWORD *)this + 6) + 8);
    while (1)
    {
      v5 = *v4;
      v4 += 6;
      if (v5 < 0)
        break;
      if (v2 == ++v3)
      {
        LODWORD(v3) = *((_DWORD *)this + 16);
        break;
      }
    }
  }
  else
  {
    LODWORD(v3) = 0;
  }
  if ((_DWORD)v2 != (_DWORD)v3)
  {
    v6 = v3;
    do
    {
      re::ThreadSafeAutoFreeAllocator::free((os_unfair_lock_s *)this, *(_QWORD *)(*((_QWORD *)this + 6) + 24 * v6 + 16));
      if (*((_DWORD *)this + 16) <= (v3 + 1))
        v7 = v3 + 1;
      else
        v7 = *((_DWORD *)this + 16);
      v8 = v3;
      while (1)
      {
        v6 = (v8 + 1);
        if (v7 - 1 == v8)
          break;
        ++v8;
        LODWORD(v3) = v6;
        if ((*(_DWORD *)(*((_QWORD *)this + 6) + 24 * v6 + 8) & 0x80000000) != 0)
          goto LABEL_17;
      }
      LODWORD(v3) = v7;
LABEL_17:
      ;
    }
    while ((_DWORD)v2 != (_DWORD)v3);
  }
  re::HashSetBase<void *,void *,re::internal::ValueAsKey<void *>,re::Hash<void *>,re::EqualTo<void *>,true,false>::clear((uint64_t)this + 32);
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)this + 4);
  re::Allocator::~Allocator(this);
}

{
  re::ThreadSafeAutoFreeAllocator::~ThreadSafeAutoFreeAllocator(this);
  JUMPOUT(0x2276933B8);
}

uint64_t re::ThreadSafeAutoFreeAllocator::free(os_unfair_lock_s *this, uint64_t a2)
{
  os_unfair_lock_s *v3;
  uint64_t v5;

  v5 = a2;
  v3 = this + 20;
  os_unfair_lock_lock(this + 20);
  re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::remove((uint64_t)&this[8], &v5);
  os_unfair_lock_unlock(v3);
  return (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)&this[6]._os_unfair_lock_opaque + 40))(*(_QWORD *)&this[6]._os_unfair_lock_opaque, v5);
}

uint64_t re::ThreadSafeAutoFreeAllocator::alloc(re::ThreadSafeAutoFreeAllocator *this, uint64_t a2)
{
  uint64_t v4;

  v4 = (*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(**((_QWORD **)this + 3) + 32))(*((_QWORD *)this + 3), a2, 0);
  os_unfair_lock_lock((os_unfair_lock_t)this + 20);
  re::HashSetBase<void *,void *,re::internal::ValueAsKey<void *>,re::Hash<void *>,re::EqualTo<void *>,true,false>::add((uint64_t)this + 32, &v4);
  os_unfair_lock_unlock((os_unfair_lock_t)this + 20);
  return v4;
}

uint64_t re::AutoFreeAllocator::parent(re::AutoFreeAllocator *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 3) + 48))(*((_QWORD *)this + 3));
}

uint64_t re::AutoFreeAllocator::statistics(re::AutoFreeAllocator *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 3) + 56))(*((_QWORD *)this + 3));
}

uint64_t re::ThreadSafeAutoFreeAllocator::parent(re::ThreadSafeAutoFreeAllocator *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 3) + 48))(*((_QWORD *)this + 3));
}

uint64_t re::ThreadSafeAutoFreeAllocator::statistics(re::ThreadSafeAutoFreeAllocator *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 3) + 56))(*((_QWORD *)this + 3));
}

pthread_t re::BaseAllocator::init(re::BaseAllocator *this)
{
  re::BaseAllocator *v1;
  pthread_t result;

  v1 = this;
  *((_QWORD *)this + 3) = 0;
  v1 = (re::BaseAllocator *)((char *)v1 + 32);
  re::DynamicArray<re::internal::MemBlock>::setCapacity(v1, 0);
  ++*((_DWORD *)v1 + 6);
  result = pthread_self();
  *((_QWORD *)v1 + 5) = result;
  return result;
}

_QWORD *re::DynamicArray<re::internal::MemBlock>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  void *v7;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (*v5)
      {
        if (!a2)
        {
          v7 = 0;
          if (!v3)
            goto LABEL_9;
          goto LABEL_8;
        }
        if (is_mul_ok(a2, 0x18uLL))
        {
          v2 = 24 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 24 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
            {
LABEL_9:
              v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            memcpy(v7, (const void *)v5[4], 24 * v5[2]);
            result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 24, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
      }
      else
      {
        result = (_QWORD *)re::DynamicArray<re::internal::MemBlock>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

void re::defaultTemporaryDirectoryPath(uint64_t a1@<X8>)
{
  void *v3;
  void *v4;
  void *v5;
  _anonymous_namespace_ *v6;
  char v7;
  uint64_t v8;
  __int128 v9;
  uint64_t v10;

  objc_msgSend(MEMORY[0x24BDD1580], "defaultManager");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "temporaryDirectory");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v4, "path");
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  if (v5)
  {
    v6 = (_anonymous_namespace_ *)objc_msgSend(objc_retainAutorelease(v5), "UTF8String");
    *(_QWORD *)(a1 + 8) = v8;
    *(_QWORD *)(a1 + 32) = v10;
    *(_OWORD *)(a1 + 16) = v9;
    v7 = 1;
  }
  else
  {
    v7 = 0;
  }
  *(_BYTE *)a1 = v7;

}

uint64_t *re::foundationMemoryLogObjects(re *this)
{
  unsigned __int8 v1;

  {
    re::foundationMemoryLogObjects(void)::logObjects = (uint64_t)os_log_create("com.apple.re", "Foundation.Memory");
  }
  return &re::foundationMemoryLogObjects(void)::logObjects;
}

uint64_t MurmurHash3_x64_128(uint64_t result, int a2, unsigned int a3, unint64_t *a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unsigned __int8 *v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;

  v4 = a3;
  if (a2 < 16)
  {
    v7 = a3;
  }
  else
  {
    v5 = (_QWORD *)(result + 8);
    v6 = (a2 / 16);
    v7 = v4;
    do
    {
      v4 = 5
         * (__ROR8__((0x4CF5AD432745937FLL * ((0x88A129EA80000000 * *(v5 - 1)) | ((0x87C37B91114253D5 * *(v5 - 1)) >> 33))) ^ v4, 37)+ v7)+ 1390208809;
      v7 = 5
         * (v4
          + __ROR8__((0x87C37B91114253D5* ((0x4E8B26FE00000000 * *v5) | ((unint64_t)(0x4CF5AD432745937FLL * *v5) >> 31))) ^ v7, 33))+ 944331445;
      v5 += 2;
      --v6;
    }
    while (v6);
  }
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  v21 = (unsigned __int8 *)(result + 16 * (a2 / 16));
  switch(a2 & 0xF)
  {
    case 1:
      goto LABEL_21;
    case 2:
      goto LABEL_20;
    case 3:
      goto LABEL_19;
    case 4:
      goto LABEL_18;
    case 5:
      goto LABEL_17;
    case 6:
      goto LABEL_16;
    case 7:
      goto LABEL_15;
    case 8:
      goto LABEL_14;
    case 9:
      goto LABEL_13;
    case 0xA:
      goto LABEL_12;
    case 0xB:
      goto LABEL_11;
    case 0xC:
      goto LABEL_10;
    case 0xD:
      goto LABEL_9;
    case 0xE:
      goto LABEL_8;
    case 0xF:
      v8 = (unint64_t)v21[14] << 48;
LABEL_8:
      v9 = v8 | ((unint64_t)v21[13] << 40);
LABEL_9:
      v10 = v9 ^ ((unint64_t)v21[12] << 32);
LABEL_10:
      v11 = v10 ^ ((unint64_t)v21[11] << 24);
LABEL_11:
      v12 = v11 ^ ((unint64_t)v21[10] << 16);
LABEL_12:
      v13 = v12 ^ ((unint64_t)v21[9] << 8);
LABEL_13:
      v7 ^= 0x87C37B91114253D5
          * ((0x4E8B26FE00000000 * (v13 ^ v21[8])) | ((0x4CF5AD432745937FLL * (v13 ^ v21[8])) >> 31));
LABEL_14:
      v14 = (unint64_t)v21[7] << 56;
LABEL_15:
      v15 = v14 | ((unint64_t)v21[6] << 48);
LABEL_16:
      v16 = v15 ^ ((unint64_t)v21[5] << 40);
LABEL_17:
      v17 = v16 ^ ((unint64_t)v21[4] << 32);
LABEL_18:
      v18 = v17 ^ ((unint64_t)v21[3] << 24);
LABEL_19:
      v19 = v18 ^ ((unint64_t)v21[2] << 16);
LABEL_20:
      v20 = v19 ^ ((unint64_t)v21[1] << 8);
LABEL_21:
      v4 ^= 0x4CF5AD432745937FLL
          * ((0x88A129EA80000000 * (v20 ^ *v21)) | ((0x87C37B91114253D5 * (v20 ^ *v21)) >> 33));
      break;
    default:
      break;
  }
  v22 = v7 ^ a2;
  v23 = (v4 ^ a2) + v22;
  v24 = v23 + v22;
  v25 = 0xC4CEB9FE1A85EC53
      * ((0xFF51AFD7ED558CCDLL * (v23 ^ (v23 >> 33))) ^ ((0xFF51AFD7ED558CCDLL * (v23 ^ (v23 >> 33))) >> 33));
  v26 = 0xC4CEB9FE1A85EC53
      * ((0xFF51AFD7ED558CCDLL * (v24 ^ (v24 >> 33))) ^ ((0xFF51AFD7ED558CCDLL * (v24 ^ (v24 >> 33))) >> 33));
  v27 = v26 ^ (v26 >> 33);
  v28 = v27 + (v25 ^ (v25 >> 33));
  *a4 = v28;
  a4[1] = v28 + v27;
  return result;
}

uint64_t re::SharedObjectBase::dispose(re::SharedObjectBase *this)
{
  uint64_t v2;

  v2 = (*(uint64_t (**)(re::SharedObjectBase *))(*(_QWORD *)this + 24))(this);
  (**(void (***)(re::SharedObjectBase *))this)(this);
  return (*(uint64_t (**)(uint64_t, re::SharedObjectBase *))(*(_QWORD *)v2 + 40))(v2, this);
}

uint64_t re::SharedObject::dispose(re::SharedObject *this)
{
  uint64_t v2;

  v2 = *((_QWORD *)this + 2);
  (**(void (***)(re::SharedObject *))this)(this);
  return (*(uint64_t (**)(uint64_t, re::SharedObject *))(*(_QWORD *)v2 + 40))(v2, this);
}

void re::MallocAllocator::~MallocAllocator(re::MallocAllocator *this)
{
  re::Allocator::~Allocator(this);
  JUMPOUT(0x2276933B8);
}

void *re::MallocAllocator::alloc(re::MallocAllocator *this, size_t size, unint64_t a3)
{
  uint64_t v3;
  void *result;
  void *memptr;

  v3 = 16;
  if (a3 > 0x10)
    v3 = a3;
  memptr = 0;
  malloc_type_posix_memalign(&memptr, (v3 + 7) & 0xFFFFFFFFFFFFFFF8, size, 0xC75C8B65uLL);
  result = memptr;
  __dmb(0xBu);
  return result;
}

void re::MallocAllocator::free(re::MallocAllocator *this, void *a2)
{
  __dmb(0xBu);
  free(a2);
}

uint64_t re::MallocAllocator::statistics(re::MallocAllocator *this)
{
  return 0;
}

uint64_t re::MallocAllocator::parent(re::MallocAllocator *this)
{
  return 0;
}

uint64_t ArcObjectDestroy(char *a1, objc_selector *a2)
{
  if (a1)
    return (*(uint64_t (**)(char *))(*((_QWORD *)a1 - 1) + 16))(a1 - 8);
  else
    return (*(uint64_t (**)(_QWORD))(MEMORY[0] + 16))(0);
}

void ArcSharedObject::ArcSharedObject(ArcSharedObject *this, Class cls)
{
  objc_class *v2;
  unsigned __int8 v4;
  objc_class *v5;
  objc_class *ClassPair;
  objc_class *Class;

  v2 = cls;
  *(_QWORD *)this = &off_24ED426B8;
  if (!cls)
  {
    v4 = atomic_load((unsigned __int8 *)&qword_254106120);
    if ((v4 & 1) == 0 && __cxa_guard_acquire(&qword_254106120))
    {
      v5 = (objc_class *)objc_opt_class();
      ClassPair = objc_allocateClassPair(v5, "_REArcObject", 0);
      if (ClassPair)
      {
        Class = ClassPair;
        class_addMethod(ClassPair, sel_dealloc, (IMP)ArcObjectDestroy, "");
        objc_registerClassPair(Class);
      }
      else
      {
        Class = objc_getClass("_REArcObject");
      }
      _MergedGlobals_135 = (uint64_t)Class;
      __cxa_guard_release(&qword_254106120);
    }
    v2 = (objc_class *)_MergedGlobals_135;
  }
  *((_QWORD *)this + 1) = 0;
  objc_constructInstance(v2, (char *)this + 8);
}

void ArcSharedObject::~ArcSharedObject(ArcSharedObject *this)
{
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

void ArcSharedObject::dispose(ArcSharedObject *this)
{
  (**(void (***)(ArcSharedObject *))this)(this);
  free(this);
}

re::DynamicString *re::AnimationLibraryCompiler::getCurrentCompiledAssetInfo@<X0>(re::AnimationLibraryCompiler *this@<X0>, _QWORD *a2@<X8>)
{
  re::DynamicString *v2;
  _anonymous_namespace_ *v3;
  const char *v4;

  *a2 = 0x100000001;
  v2 = (re::DynamicString *)(a2 + 1);
  v3 = (_anonymous_namespace_ *)re::AnimationLibraryAsset::assetType(this);
  v4 = *(const char **)v3;
}

__guard re::AnimationLibraryCompiler::assetIntrospectionType(re::AnimationLibraryCompiler *this)
{
  unsigned __int8 v1;
  __guard *v2;
  int v4;

  if ((v1 & 1) == 0)
  {
    if (v4)
    {
      re::introspect<re::AnimationLibraryAsset>(void)::info = re::introspect_AnimationLibraryAsset(0);
    }
  }
  return v2[71];
}

uint64_t re::AnimationLibraryCompiler::getSupportedExtensions@<X0>(uint64_t a1@<X8>)
{
  _QWORD v3[2];
  const char *v4;

  v4 = "reAnimationLibrary";
  v3[0] = &v4;
  v3[1] = 1;
  return re::DynamicArray<char const*>::DynamicArray(a1, (uint64_t)v3);
}

uint64_t *re::AnimationLibraryCompiler::compile@<X0>(re::AnimationLibraryCompiler *this@<X0>, char *a2@<X1>, re::AssetSerializationScheme *a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t *v8;
  uint64_t v9;
  char *v10;
  __int128 v11;
  __int128 v12;
  unsigned __int8 v13;
  __guard *v14;
  uint64_t v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  int v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v24;
  _BYTE v25[8];
  uint64_t v26;
  char v27;
  uint64_t v28;
  _QWORD v29[5];

  v29[4] = *MEMORY[0x24BDAC8D0];
  v8 = re::globalAllocators(this);
  v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v8[2] + 32))(v8[2], 224, 8);
  *(_OWORD *)(v9 + 176) = 0u;
  *(_OWORD *)(v9 + 192) = 0u;
  *(_OWORD *)v9 = 0u;
  *(_OWORD *)(v9 + 16) = 0u;
  *(_OWORD *)(v9 + 32) = 0u;
  *(_OWORD *)(v9 + 48) = 0u;
  *(_OWORD *)(v9 + 64) = 0u;
  *(_OWORD *)(v9 + 80) = 0u;
  *(_OWORD *)(v9 + 96) = 0u;
  *(_OWORD *)(v9 + 112) = 0u;
  *(_OWORD *)(v9 + 128) = 0u;
  *(_OWORD *)(v9 + 144) = 0u;
  *(_OWORD *)(v9 + 160) = 0u;
  *(_DWORD *)(v9 + 196) = 0x7FFFFFFF;
  *(_QWORD *)(v9 + 208) = 0;
  *(_QWORD *)(v9 + 216) = &str_110;
  v29[3] = v29;
  v28 = v9;
  v29[0] = &off_24ED42758;
  v10 = strrchr(a2, 46);
  if (!strcasecmp(v10 + 1, "reanimationlibrary"))
  {
    if ((v13 & 1) == 0)
    {
      if (v20)
      {
        re::introspect<re::AnimationLibraryAsset>(void)::info = re::introspect_AnimationLibraryAsset(0);
      }
    }
    re::AssetUtilities::readSourceJson((re::AssetUtilities *)a2, (const char *)v9, v14[71], a3, (uint64_t)v25);
    if (v25[0])
    {
      v15 = v28;
      v28 = 0;
      *(_BYTE *)a4 = 1;
      *(_QWORD *)(a4 + 8) = v15;
    }
    else
    {
      *(_QWORD *)&v21 = 100;
      *((_QWORD *)&v21 + 1) = &re::AssetErrorCategory(void)::instance;
      re::DynamicString::DynamicString((re::DynamicString *)&v22, (const re::DynamicString *)&v26);
      v16 = v22;
      *(_OWORD *)(a4 + 8) = v21;
      v17 = v23;
      v18 = v24;
      *(_BYTE *)a4 = 0;
      *(_OWORD *)(a4 + 24) = v16;
      *(_QWORD *)(a4 + 40) = v17;
      *(_QWORD *)(a4 + 48) = v18;
      if (!v25[0] && v26 && (v27 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v26 + 40))();
    }
  }
  else
  {
    re::DynamicString::format((re::DynamicString *)"Invalid Asset Path: %s.", (re::DynamicString *)&v21, a2);
    v11 = v21;
    v12 = v22;
    *(_BYTE *)a4 = 0;
    *(_QWORD *)(a4 + 8) = 200;
    *(_QWORD *)(a4 + 16) = &re::AssetErrorCategory(void)::instance;
    *(_OWORD *)(a4 + 24) = v11;
    *(_OWORD *)(a4 + 40) = v12;
  }
  return std::unique_ptr<re::RigHierarchy,std::function<void ()(re::RigHierarchy*)>>::~unique_ptr[abi:nn180100](&v28);
}

re *re::AnimationLibraryCompiler::deleteAsset(re::AnimationLibraryCompiler *this, uint64_t a2)
{
  return re::internal::destroyPersistent<re::AnimationLibraryAsset>((re *)"deleteAsset", 53, a2);
}

void re::AnimationLibraryCompiler::~AnimationLibraryCompiler(re::AnimationLibraryCompiler *this)
{
  JUMPOUT(0x2276933B8);
}

void std::__function::__func<re::AnimationLibraryCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::AnimationLibraryCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,void ()(re::AnimationLibraryAsset *)>::~__func()
{
  JUMPOUT(0x2276933B8);
}

_QWORD *std::__function::__func<re::AnimationLibraryCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::AnimationLibraryCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,void ()(re::AnimationLibraryAsset *)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_24ED42758;
  return result;
}

void std::__function::__func<re::AnimationLibraryCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::AnimationLibraryCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,void ()(re::AnimationLibraryAsset *)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24ED42758;
}

re *std::__function::__func<re::AnimationLibraryCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::AnimationLibraryCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,void ()(re::AnimationLibraryAsset *)>::operator()(uint64_t a1, uint64_t *a2)
{
  return re::internal::destroyPersistent<re::AnimationLibraryAsset>((re *)"operator()", 34, *a2);
}

uint64_t std::__function::__func<re::AnimationLibraryCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::AnimationLibraryCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,void ()(re::AnimationLibraryAsset *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::AnimationLibraryCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::AnimationLibraryCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,void ()(re::AnimationLibraryAsset *)>::target_type()
{
}

uint64_t re::TextureBuilder::TextureBuilder(uint64_t a1, uint64_t a2, void *a3)
{
  id *v6;
  id v7;
  uint64_t v8;
  char v9;
  uint64_t result;

  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(_QWORD *)a1 = &off_24ED427E8;
  *(_QWORD *)(a1 + 24) = re::ServiceLocator::serviceOrNull<re::AssetService>(a2);
  v6 = (id *)re::ServiceLocator::service<re::ImportGraphicsResources>(a2);
  re::ImportGraphicsContext::ImportGraphicsContext((re::ImportGraphicsContext *)(a1 + 32), v6);
  v7 = objc_msgSend(a3, sel_copy);
  *(_QWORD *)(a1 + 64) = v7;
  v9 = *(_BYTE *)(a1 + 51);
  if (v9)
    v9 = *(_BYTE *)(a1 + 52);
  *(_BYTE *)(a1 + 72) = v9;
  *(_OWORD *)(a1 + 76) = 0u;
  *(_OWORD *)(a1 + 92) = 0u;
  *(_DWORD *)(a1 + 108) = 0;
  if (*(_QWORD *)(a1 + 24))
  {
    if (v7)
      return a1;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v8, "assertion failure: '%s' (%s:line %i) TextureBuilder expected an AssetManager", "m_assetManager", "TextureBuilder", 138);
    _os_crash();
    __break(1u);
  }
  re::internal::assertLog((re::internal *)4, v8, "assertion failure: '%s' (%s:line %i) TextureBuilder expected a MTLTextureDescriptor", "m_textureDescriptor.isValid()", "TextureBuilder", 139);
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::ServiceLocator::service<re::ImportGraphicsResources>(uint64_t a1)
{
  uint64_t result;
  __objc2_class_ro *v2;
  __objc2_class_ro *v3;
  uint64_t v4;
  _BYTE *v5;
  _BYTE v6[16];
  _BYTE v7[9];
  _BYTE v8[23];

  result = re::ServiceLocator::serviceOrNull<re::ImportGraphicsResources>(a1);
  if (!result)
  {
    v2 = re::introspect<re::ImportGraphicsResources>();
    re::StringID::invalid((re::StringID *)v6);
    re::internal::missingServiceErrorMessage((re::internal *)v2, (const re::IntrospectionBase *)v6, (re::DynamicString *)v7);
    re::DynamicString::~DynamicString((re::DynamicString *)v7);
    re::StringID::~StringID((re::StringID *)v6);
    v3 = re::introspect<re::ImportGraphicsResources>();
    re::StringID::invalid((re::StringID *)v6);
    re::internal::missingServiceErrorMessage((re::internal *)v3, (const re::IntrospectionBase *)v6, (re::DynamicString *)v7);
    if ((v7[8] & 1) != 0)
      v5 = *(_BYTE **)&v8[7];
    else
      v5 = v8;
    re::internal::assertLog((re::internal *)5, v4, "assertion failure: '%s' (%s:line %i) %s", "service", "service", 69, v5);
    re::DynamicString::~DynamicString((re::DynamicString *)v7);
    re::StringID::~StringID((re::StringID *)v6);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

void re::TextureBuilder::~TextureBuilder(re::TextureBuilder *this)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  *(_QWORD *)this = &off_24ED427E8;
  v2 = (void *)*((_QWORD *)this + 13);
  if (v2)
  {
    objc_msgSend(v2, "endEncoding");
    v3 = (void *)*((_QWORD *)this + 13);
    *((_QWORD *)this + 13) = 0;

    v4 = (void *)*((_QWORD *)this + 13);
  }
  else
  {
    v4 = 0;
  }

  v5 = (void *)*((_QWORD *)this + 11);
  if (v5)
  {

    *((_QWORD *)this + 11) = 0;
  }

  v6 = (void *)*((_QWORD *)this + 8);
  if (v6)
  {

    *((_QWORD *)this + 8) = 0;
  }

  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  re::TextureBuilder::~TextureBuilder(this);
  JUMPOUT(0x2276933B8);
}

BOOL re::TextureBuilder::beginEncodeBlitCommands(re::TextureBuilder *this)
{
  _QWORD *v3;
  uint64_t v4;
  _QWORD v5[3];
  _QWORD *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  if (*((_QWORD *)this + 10))
    return 0;
  v5[0] = &off_24ED428A8;
  v5[1] = this;
  v6 = v5;
  re::runInLocalAutoreleasePool((uint64_t)v5);
  v3 = v6;
  if (v6 == v5)
  {
    v4 = 4;
    v3 = v5;
    goto LABEL_8;
  }
  if (v6)
  {
    v4 = 5;
LABEL_8:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  if (*((_QWORD *)this + 11) && *((_QWORD *)this + 12))
    return *((_QWORD *)this + 13) != 0;
  return 0;
}

_QWORD *re::TextureBuilder::commitCommandBuffer(_QWORD *this)
{
  uint64_t v1;
  _QWORD v2[3];
  _QWORD *v3;
  uint64_t v4;

  v4 = *MEMORY[0x24BDAC8D0];
  if (this[12])
  {
    v2[0] = &off_24ED42928;
    v2[1] = this;
    v3 = v2;
    re::runInLocalAutoreleasePool((uint64_t)v2);
    this = v3;
    if (v3 == v2)
    {
      v1 = 4;
      this = v2;
    }
    else
    {
      if (!v3)
        return this;
      v1 = 5;
    }
    return (_QWORD *)(*(uint64_t (**)(void))(*this + 8 * v1))();
  }
  return this;
}

uint64_t re::TextureBuilder::makeTextureAsset(id *this)
{
  void *CGColorSpaceNameForPixelFormat;
  id v3;
  int v4;
  uint64_t TextureAsset;
  _BYTE v7[2];
  __int16 v8;
  char v9;
  int v10;
  _QWORD v11[2];
  int v12;
  _BYTE v13[8];
  id v14[10];
  unsigned int v15;
  id v16;
  char v17;

  if ((*((_DWORD *)this + 19) - 3) > 1)
    CGColorSpaceNameForPixelFormat = 0;
  else
    CGColorSpaceNameForPixelFormat = (void *)re::ColorHelpers::getCGColorSpaceNameForPixelFormat((int)objc_msgSend(this[8], sel_pixelFormat), *((unsigned __int8 *)this + 72));
  v13[0] = 0;
  v14[0] = this[11];
  v15 = 0;
  v16 = CGColorSpaceNameForPixelFormat;
  v3 = objc_msgSend(this[8], sel_mipmapLevelCount);
  v4 = *((_DWORD *)this + 19);
  v7[0] = (unint64_t)v3 > 1;
  v7[1] = (unint64_t)v3 > 1;
  v8 = 256;
  v9 = 1;
  v10 = 1;
  v11[0] = 0;
  *(_QWORD *)((char *)v11 + 5) = 0;
  v12 = 0;
  TextureAsset = re::TextureAsset::makeTextureAsset((re *)(this + 4), (uint64_t)v13, v4, (__int128 *)v7);
  *(_BYTE *)(TextureAsset + 125) = 1;

  if (v15 != -1)
    ((void (*)(char *, id *))*(&off_24ED42820 + v15))(&v17, v14);
  return TextureAsset;
}

void re::TextureBuilder::makeAssetSync(re::TextureBuilder *this@<X0>, uint64_t a2@<X8>)
{
  void *v3;
  id *v4;
  id v5;
  id *v7;
  re::TextureAsset *TextureAsset;
  uint64_t v9;
  uint64_t *v10;
  unsigned int v11;
  char *v12;
  id v13;
  id v14;
  id v15;
  void *v16;
  id v17;
  id v18;
  __int128 v19;
  char *v20;
  id v21;
  uint64_t v22;
  uint64_t v23;

  v4 = (id *)((char *)this + 80);
  v3 = (void *)*((_QWORD *)this + 10);
  if (v3)
  {
    v5 = v3;
    *(_BYTE *)a2 = 0;
    *(_QWORD *)(a2 + 8) = v5;

  }
  else
  {
    v7 = (id *)((char *)this + 96);
    if (*((_QWORD *)this + 12)
      && (re::TextureBuilder::commitCommandBuffer(this),
          objc_msgSend(*((id *)this + 12), "waitUntilCompleted"),
          objc_msgSend(*((id *)this + 12), "status") != 4))
    {
      re::internal::makeCommandBufferError((id *)&v19, v7);
      if (v4 != (id *)&v19)
      {
        v16 = (void *)v19;
        *(_QWORD *)&v19 = 0;
        v17 = *v4;
        *v4 = v16;

      }
      v18 = *v4;
      *(_BYTE *)a2 = 0;
      *(_QWORD *)(a2 + 8) = v18;
    }
    else
    {
      TextureAsset = (re::TextureAsset *)re::TextureBuilder::makeTextureAsset((id *)this);
      v9 = *((_QWORD *)this + 3);
      v10 = re::TextureAsset::assetType(TextureAsset);
      (*(void (**)(uint64_t *__return_ptr, uint64_t, re::TextureAsset *, uint64_t *, uint64_t, uint64_t, _QWORD))(*(_QWORD *)v9 + 416))(&v22, v9, TextureAsset, v10, 1, 1, 0);
      if (v23 && (v11 = atomic_load((unsigned int *)(v23 + 704)), v11 == 3))
      {
        re::AssetHandle::loadFailedMessage((re::AssetHandle *)&v22, (re::DynamicString *)&v19);
        if ((BYTE8(v19) & 1) != 0)
          v12 = v20;
        else
          v12 = (char *)&v19 + 9;
        re::WrappedError::make((re::WrappedError *)CFSTR("RETextureBuilderErrorDomain"), (const __CFString *)2, (uint64_t)v12, &v21);
        if (v4 != &v21)
        {
          v13 = v21;
          v21 = 0;
          v14 = *v4;
          *v4 = v13;

        }
        if ((_QWORD)v19)
        {
          if ((BYTE8(v19) & 1) != 0)
            (*(void (**)(void))(*(_QWORD *)v19 + 40))();
        }
        v15 = *v4;
        *(_BYTE *)a2 = 0;
        *(_QWORD *)(a2 + 8) = v15;
      }
      else
      {
        re::AssetHandle::AssetHandle((re::AssetHandle *)&v19, (const re::AssetHandle *)&v22);
        *(_BYTE *)a2 = 1;
        *(_OWORD *)(a2 + 8) = v19;
        v19 = 0uLL;
        *(_QWORD *)(a2 + 24) = v20;
        v20 = 0;
        re::AssetHandle::~AssetHandle((re::AssetHandle *)&v19);
      }
      re::AssetHandle::~AssetHandle((re::AssetHandle *)&v22);
    }
  }
}

void re::internal::makeCommandBufferError(id *this, id *a2)
{
  re *v4;
  NSObject *v5;
  void *v6;
  id v7;
  uint64_t v8;
  id v9;
  _BYTE v10[12];
  __int16 v11;
  id v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  re::mtl::CommandBuffer::error(a2, this);
  v5 = *re::pipelineLogObjects(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    v8 = (int)objc_msgSend(*a2, "status");
    v9 = *this;
    *(_DWORD *)v10 = 134218242;
    *(_QWORD *)&v10[4] = v8;
    v11 = 2112;
    v12 = v9;
    _os_log_error_impl(&dword_224FE9000, v5, OS_LOG_TYPE_ERROR, "TextureBuilder command buffer did not complete (status = %zu, error = %@)", v10, 0x16u);
  }
  if (!*this)
  {
    re::WrappedError::make((re::WrappedError *)CFSTR("RETextureBuilderErrorDomain"), (const __CFString *)3, (uint64_t)"Command buffer did not complete", v10);
    if (v10 != (_BYTE *)this)
    {
      v6 = *(void **)v10;
      *(_QWORD *)v10 = 0;
      v7 = *this;
      *this = v6;

    }
  }
}

void re::TextureBuilder::makeAssetAsync(uint64_t a1, uint64_t a2)
{
  void *v3;
  uint64_t *v5;
  uint64_t v6;
  re *v7;
  uint64_t *v8;
  re::TextureAsset *TextureAsset;
  uint64_t v10;
  uint64_t *v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  id v23;
  _QWORD *v24;
  uint64_t v25;
  char v26[8];
  id v27;
  re::AssetLoadRequest *v28;
  __int128 v29;
  uint64_t v30;
  unsigned __int8 v31[8];
  id v32;
  _QWORD v33[3];
  _QWORD *v34;
  _QWORD v35[3];
  uint64_t v36;
  _QWORD *v37;
  uint64_t v38;

  v38 = *MEMORY[0x24BDAC8D0];
  v3 = *(void **)(a1 + 80);
  if (v3)
  {
    v31[0] = 0;
    v32 = v3;
    (*(void (**)(_QWORD, unsigned __int8 *))(**(_QWORD **)(a2 + 32) + 16))(*(_QWORD *)(a2 + 32), v31);
    re::Result<re::AssetHandle,re::WrappedError>::~Result(v31);
    return;
  }
  v5 = re::globalAllocators((re *)a1);
  v6 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v5[2] + 32))(v5[2], 112, 8);
  *(_OWORD *)v6 = 0u;
  *(_OWORD *)(v6 + 16) = 0u;
  *(_OWORD *)(v6 + 32) = 0u;
  *(_OWORD *)(v6 + 48) = 0u;
  *(_OWORD *)(v6 + 64) = 0u;
  *(_OWORD *)(v6 + 80) = 0u;
  *(_OWORD *)(v6 + 96) = 0u;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v6, 0);
  *(_QWORD *)v6 = &off_24ED429A8;
  *(_OWORD *)(v6 + 24) = 0u;
  *(_OWORD *)(v6 + 40) = 0u;
  *(_QWORD *)(v6 + 80) = re::globalAllocators(v7)[2];
  *(_QWORD *)(v6 + 88) = 0;
  v8 = (uint64_t *)(v6 + 88);
  *(_QWORD *)(v6 + 104) = 0;
  *(_QWORD *)(v6 + 94) = 0;
  TextureAsset = (re::TextureAsset *)re::TextureBuilder::makeTextureAsset((id *)a1);
  v10 = *(_QWORD *)(a1 + 24);
  v11 = re::TextureAsset::assetType(TextureAsset);
  (*(void (**)(__int128 *__return_ptr, uint64_t, re::TextureAsset *, uint64_t *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v10 + 416))(&v29, v10, TextureAsset, v11, 1, 1, 1);
  v12 = *(_OWORD *)(v6 + 24);
  *(_OWORD *)(v6 + 24) = v29;
  v29 = v12;
  v13 = *(_QWORD *)(v6 + 40);
  *(_QWORD *)(v6 + 40) = v30;
  v30 = v13;
  re::AssetManager::makeLoadRequest(*(re::AssetManager **)(a1 + 24), &v28);
  v14 = *(_QWORD *)(v6 + 48);
  *(_QWORD *)(v6 + 48) = v28;
  v28 = (re::AssetLoadRequest *)v14;
  if (v14)

  v15 = v6 + 56;
  if (v6 + 56 != a2)
  {
    re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable(v6 + 56);
    v16 = *(_QWORD *)(a2 + 32);
    if (*(_QWORD *)(v6 + 80) == *(_QWORD *)(a2 + 24))
    {
      v17 = a2;
      if (v16 != a2)
      {
        *v8 = v16;
        *(_QWORD *)(a2 + 32) = 0;
        goto LABEL_16;
      }
    }
    else
    {
      v17 = *(_QWORD *)(a2 + 32);
      if (!v16)
        goto LABEL_16;
    }
    v18 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v17 + 40))(v17);
    if (v18 >= 0x19)
    {
      v19 = v18;
      v20 = *(_QWORD *)(v6 + 80);
      if (v20)
        v15 = (*(uint64_t (**)(uint64_t, unint64_t, _QWORD))(*(_QWORD *)v20 + 32))(v20, v19, 0);
      else
        v15 = 0;
    }
    *v8 = v15;
    (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a2 + 32) + 32))(*(_QWORD *)(a2 + 32), v15);
    re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable(a2);
  }
LABEL_16:
  re::AssetHandle::~AssetHandle((re::AssetHandle *)&v29);
  if (*(_QWORD *)(a1 + 104))
  {
    v21 = re::globalAllocators((re *)(id)(v6 + 8))[2];
    v35[0] = &off_24ED42840;
    v35[1] = v6;
    v36 = v21;
    v37 = v35;
    re::mtl::CommandBuffer::addCompletionHandler((void **)(a1 + 96), (uint64_t)v35);
    if (v37)
    {
      (*(void (**)(_QWORD *))*v37)(v37);
      if (v37 != v35)
        (*(void (**)(uint64_t))(*(_QWORD *)v36 + 40))(v36);
      v37 = 0;
    }
    re::TextureBuilder::commitCommandBuffer((_QWORD *)a1);
  }
  else
  {
    v26[0] = 1;
    re::internal::TextureBuilderAsync::commandBufferDidComplete(v6, (uint64_t)v26);
    if (!v26[0])

  }
  v22 = *(_QWORD *)(v6 + 48);
  v23 = (id)(v6 + 8);
  v33[0] = &off_24ED429F0;
  v33[1] = v6;
  v34 = v33;
  re::AssetLoadRequest::setCompletionHandler(v22, (uint64_t)v33, 0);
  v24 = v34;
  if (v34 == v33)
  {
    v25 = 4;
    v24 = v33;
    goto LABEL_28;
  }
  if (v34)
  {
    v25 = 5;
LABEL_28:
    (*(void (**)(void))(*v24 + 8 * v25))();
  }
  re::AssetLoadRequest::addAsset(*(re::AssetLoadRequest::Data ***)(v6 + 48), (const re::AssetHandle *)(v6 + 24));

}

void re::internal::TextureBuilderAsync::commandBufferDidComplete(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  uint64_t v5;
  int v6;

  v4 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  if (*(_BYTE *)(a1 + 100))
  {
    re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) ", "!m_commandBufferCompleted", "commandBufferDidComplete", 54);
    _os_crash();
    __break(1u);
  }
  else
  {
    *(_BYTE *)(a1 + 100) = 1;
    if (*(_BYTE *)a2 || (re::ObjCObject::operator=((id *)(a1 + 104), (id *)(a2 + 8)), *(_BYTE *)(a1 + 100)))
    {
      v6 = *(unsigned __int8 *)(a1 + 101);
      os_unfair_lock_unlock(v4);
      if (v6)
        re::internal::TextureBuilderAsync::callCompletionHandler((re::internal::TextureBuilderAsync *)a1);
    }
    else
    {
      os_unfair_lock_unlock(v4);
    }
  }
}

_QWORD *re::internal::Callable<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_0,void ()(re::mtl::CommandBuffer const&)>::~Callable(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24ED42840;
  v2 = a1[1];
  if (v2)
  {

    a1[1] = 0;
  }
  return a1;
}

void re::internal::Callable<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_0,void ()(re::mtl::CommandBuffer const&)>::~Callable(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24ED42840;
  v2 = a1[1];
  if (v2)
  {

    a1[1] = 0;
  }
  JUMPOUT(0x2276933B8);
}

void re::internal::Callable<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_0,void ()(re::mtl::CommandBuffer const&)>::operator()(uint64_t a1, id *a2)
{
  int v4;
  uint64_t v5;
  id v6;
  id v7;
  id v8;
  char v9[8];
  id v10;

  v4 = objc_msgSend(*a2, "status");
  v5 = *(_QWORD *)(a1 + 8);
  if (v4 == 4)
  {
    v9[0] = 1;
    re::internal::TextureBuilderAsync::commandBufferDidComplete(v5, (uint64_t)v9);
    if (v9[0])
      return;
    v6 = v10;
  }
  else
  {
    re::internal::makeCommandBufferError(&v8, a2);
    v7 = v8;
    v8 = 0;
    v9[0] = 0;
    v10 = v7;
    re::internal::TextureBuilderAsync::commandBufferDidComplete(v5, (uint64_t)v9);
    if (!v9[0])

    v6 = v8;
  }

}

_QWORD *re::internal::Callable<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_0,void ()(re::mtl::CommandBuffer const&)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;
  id v4;

  v3 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED42840;
  a2[1] = v3;
  if (v3)
    v4 = (id)(v3 + 8);
  return a2;
}

_QWORD *re::internal::Callable<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_0,void ()(re::mtl::CommandBuffer const&)>::moveInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED42840;
  a2[1] = v2;
  *(_QWORD *)(a1 + 8) = 0;
  return a2;
}

uint64_t re::internal::Callable<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_0,void ()(re::mtl::CommandBuffer const&)>::size()
{
  return 16;
}

uint64_t (***re::internal::TextureBuilderAsync::callCompletionHandler(re::internal::TextureBuilderAsync *this))(_QWORD)
{
  uint64_t v2;
  __int128 v3;
  uint64_t v4;
  uint64_t v5;
  unsigned __int8 v7[8];
  uint64_t v8;
  __int128 v9;
  uint64_t v10;
  unsigned __int8 v11[8];
  __int128 v12;
  uint64_t v13;

  v2 = *((_QWORD *)this + 13);
  if (v2)
  {
    *((_QWORD *)this + 13) = 0;
    v7[0] = 0;
    v8 = v2;
    (*(void (**)(_QWORD, unsigned __int8 *))(**((_QWORD **)this + 11) + 16))(*((_QWORD *)this + 11), v7);
    re::Result<re::AssetHandle,re::WrappedError>::~Result(v7);
  }
  else
  {
    v3 = *(_OWORD *)((char *)this + 24);
    *(_OWORD *)((char *)this + 24) = 0u;
    v4 = *((_QWORD *)this + 5);
    *((_QWORD *)this + 5) = 0;
    v11[0] = 1;
    v12 = v3;
    v9 = 0u;
    v13 = v4;
    v10 = 0;
    (*(void (**)(_QWORD, unsigned __int8 *))(**((_QWORD **)this + 11) + 16))(*((_QWORD *)this + 11), v11);
    re::Result<re::AssetHandle,re::WrappedError>::~Result(v11);
    re::AssetHandle::~AssetHandle((re::AssetHandle *)&v9);
  }
  v5 = *((_QWORD *)this + 3);
  if (v5)
  {

    *((_QWORD *)this + 3) = 0;
  }
  *((_QWORD *)this + 4) = 0;
  return re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable((uint64_t)this + 56);
}

__objc2_class_ro *re::introspect<re::ImportGraphicsResources>()
{
  unsigned __int8 v0;
  __objc2_class_ro **p_info;
  int v3;

  p_info = VideoSpillMapMetalSession.info;
  if ((v0 & 1) == 0)
  {
    p_info = (__objc2_class_ro **)(VideoSpillMapMetalSession + 32);
    if (v3)
    {
      re::introspect<re::ImportGraphicsResources>(void)::info = re::introspect_ImportGraphicsResources(0);
      p_info = (__objc2_class_ro **)(VideoSpillMapMetalSession + 32);
    }
  }
  return p_info[402];
}

void std::__function::__func<re::TextureBuilder::beginEncodeBlitCommands(void)::$_0,std::allocator<re::TextureBuilder::beginEncodeBlitCommands(void)::$_0>,void ()(void)>::~__func()
{
  JUMPOUT(0x2276933B8);
}

_QWORD *std::__function::__func<re::TextureBuilder::beginEncodeBlitCommands(void)::$_0,std::allocator<re::TextureBuilder::beginEncodeBlitCommands(void)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24ED428A8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<re::TextureBuilder::beginEncodeBlitCommands(void)::$_0,std::allocator<re::TextureBuilder::beginEncodeBlitCommands(void)::$_0>,void ()(void)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24ED428A8;
  a2[1] = v2;
  return result;
}

void std::__function::__func<re::TextureBuilder::beginEncodeBlitCommands(void)::$_0,std::allocator<re::TextureBuilder::beginEncodeBlitCommands(void)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1;
  void **v2;
  re *v3;
  NSObject *v4;
  const char *v5;
  uint64_t v6;
  re *v7;
  NSObject *v8;
  void **v9;
  void *v10;
  void *v11;
  id *v12;
  void *v13;
  id v14;
  _BYTE *v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  id v19;
  id v20;
  id v21;
  id v22;
  id v23;
  _BYTE v24[22];
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  v1 = *(_QWORD *)(a1 + 8);
  v2 = (void **)(v1 + 88);
  if (*(_QWORD *)(v1 + 88))
    goto LABEL_19;
  if (*(_BYTE *)(*(_QWORD *)(v1 + 24) + 1408)
    && objc_msgSend(*(id *)(v1 + 32), "supportsSharedTextureHandles"))
  {
    objc_msgSend(*(id *)(v1 + 64), sel_setStorageMode_, 2);
    re::mtl::Device::makeSharedTexture(*(id *)(v1 + 64), (id *)(v1 + 32), v24);
    NS::SharedPtr<MTL::Texture>::operator=(v2, (void **)v24);
    v3 = *(re **)v24;
    if (*(_QWORD *)v24)

    if (*v2)
      goto LABEL_19;
    v4 = *re::pipelineLogObjects(v3);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v21 = objc_msgSend(*(id *)(v1 + 64), sel_width);
      v22 = objc_msgSend(*(id *)(v1 + 64), sel_height);
      *(_DWORD *)v24 = 134218240;
      *(_QWORD *)&v24[4] = v21;
      *(_WORD *)&v24[12] = 2048;
      *(_QWORD *)&v24[14] = v22;
      _os_log_error_impl(&dword_224FE9000, v4, OS_LOG_TYPE_ERROR, "Failed to allocate shared texture with dimensions %zu x %zu", v24, 0x16u);
    }
    v5 = "Failed to allocate shared texture";
    v6 = 1;
  }
  else
  {
    re::mtl::Device::makeTexture(*(id *)(v1 + 64), (id *)(v1 + 32), v24);
    NS::SharedPtr<MTL::Texture>::operator=(v2, (void **)v24);
    v7 = *(re **)v24;
    if (*(_QWORD *)v24)

    if (*v2)
      goto LABEL_19;
    v8 = *re::pipelineLogObjects(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      v19 = objc_msgSend(*(id *)(v1 + 64), sel_width);
      v20 = objc_msgSend(*(id *)(v1 + 64), sel_height);
      *(_DWORD *)v24 = 134218240;
      *(_QWORD *)&v24[4] = v19;
      *(_WORD *)&v24[12] = 2048;
      *(_QWORD *)&v24[14] = v20;
      _os_log_error_impl(&dword_224FE9000, v8, OS_LOG_TYPE_ERROR, "Failed to allocate texture with dimensions %zu x %zu", v24, 0x16u);
    }
    v5 = "Failed to allocate texture";
    v6 = 0;
  }
  re::WrappedError::make((re::WrappedError *)CFSTR("RETextureBuilderErrorDomain"), (const __CFString *)v6, (uint64_t)v5, v24);
  v9 = (void **)(v1 + 80);
  if ((_BYTE *)(v1 + 80) != v24)
  {
    v10 = *(void **)v24;
    *(_QWORD *)v24 = 0;
    v11 = *v9;
    *v9 = v10;

  }
  if (*v2)
  {
LABEL_19:
    v12 = (id *)(v1 + 96);
    if (!*(_QWORD *)(v1 + 96))
    {
      *(_QWORD *)v24 = 0x60C128E0D03BE2D1;
      *(_QWORD *)&v24[8] = "TextureBuilderQueue";
      re::ImportGraphicsContext::getOrCreateCommandQueue(v1 + 32, (uint64_t)v24, (const char *)1, &v23);
      re::mtl::CommandQueue::makeCommandBuffer(&v23, v24);
      if (v12 != (id *)v24)
      {
        v13 = *(void **)v24;
        *(_QWORD *)v24 = 0;
        v14 = *v12;
        *v12 = v13;

      }
    }
    v16 = *(_QWORD *)(v1 + 104);
    v15 = (_BYTE *)(v1 + 104);
    if (!v16)
    {
      re::mtl::CommandBuffer::makeBlitCommandEncoder(v12, v24);
      if (v15 != v24)
      {
        v17 = *(_QWORD *)v24;
        *(_QWORD *)v24 = 0;
        v18 = *(void **)v15;
        *(_QWORD *)v15 = v17;

      }
    }
  }
}

uint64_t std::__function::__func<re::TextureBuilder::beginEncodeBlitCommands(void)::$_0,std::allocator<re::TextureBuilder::beginEncodeBlitCommands(void)::$_0>,void ()(void)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::TextureBuilder::beginEncodeBlitCommands(void)::$_0,std::allocator<re::TextureBuilder::beginEncodeBlitCommands(void)::$_0>,void ()(void)>::target_type()
{
}

void std::__function::__func<re::TextureBuilder::commitCommandBuffer(void)::$_0,std::allocator<re::TextureBuilder::commitCommandBuffer(void)::$_0>,void ()(void)>::~__func()
{
  JUMPOUT(0x2276933B8);
}

_QWORD *std::__function::__func<re::TextureBuilder::commitCommandBuffer(void)::$_0,std::allocator<re::TextureBuilder::commitCommandBuffer(void)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24ED42928;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<re::TextureBuilder::commitCommandBuffer(void)::$_0,std::allocator<re::TextureBuilder::commitCommandBuffer(void)::$_0>,void ()(void)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24ED42928;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<re::TextureBuilder::commitCommandBuffer(void)::$_0,std::allocator<re::TextureBuilder::commitCommandBuffer(void)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1;
  void *v2;
  void *v3;

  v1 = *(_QWORD *)(a1 + 8);
  v2 = *(void **)(v1 + 104);
  if (v2)
  {
    objc_msgSend(v2, "endEncoding");
    v3 = *(void **)(v1 + 104);
    *(_QWORD *)(v1 + 104) = 0;

  }
  return objc_msgSend(*(id *)(v1 + 96), "commit");
}

uint64_t std::__function::__func<re::TextureBuilder::commitCommandBuffer(void)::$_0,std::allocator<re::TextureBuilder::commitCommandBuffer(void)::$_0>,void ()(void)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::TextureBuilder::commitCommandBuffer(void)::$_0,std::allocator<re::TextureBuilder::commitCommandBuffer(void)::$_0>,void ()(void)>::target_type()
{
}

void re::internal::TextureBuilderAsync::~TextureBuilderAsync(id *this)
{
  char *v2;

  *this = &off_24ED429A8;

  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable((uint64_t)(this + 7));
  v2 = (char *)this[6];
  if (v2)
  {

    this[6] = 0;
  }
  re::AssetHandle::~AssetHandle((re::AssetHandle *)(this + 3));
  *this = &off_24ED426B8;
  objc_destructInstance(this + 1);
}

{
  char *v2;

  *this = &off_24ED429A8;

  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable((uint64_t)(this + 7));
  v2 = (char *)this[6];
  if (v2)
  {

    this[6] = 0;
  }
  re::AssetHandle::~AssetHandle((re::AssetHandle *)(this + 3));
  *this = &off_24ED426B8;
  objc_destructInstance(this + 1);
  JUMPOUT(0x2276933B8);
}

_QWORD *std::__function::__func<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1,std::allocator<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1>,void ()(BOOL)>::~__func(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24ED429F0;
  v2 = a1[1];
  if (v2)
  {

    a1[1] = 0;
  }
  return a1;
}

void std::__function::__func<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1,std::allocator<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1>,void ()(BOOL)>::~__func(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_24ED429F0;
  v2 = a1[1];
  if (v2)
  {

    a1[1] = 0;
  }
  JUMPOUT(0x2276933B8);
}

_QWORD *std::__function::__func<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1,std::allocator<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1>,void ()(BOOL)>::__clone(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  id v4;

  v2 = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *v2 = &off_24ED429F0;
  v2[1] = v3;
  if (v3)
    v4 = (id)(v3 + 8);
  return v2;
}

_QWORD *std::__function::__func<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1,std::allocator<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1>,void ()(BOOL)>::__clone(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;

  v2 = result[1];
  *a2 = &off_24ED429F0;
  a2[1] = v2;
  if (v2)
    return (id)(v2 + 8);
  return result;
}

void std::__function::__func<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1,std::allocator<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1>,void ()(BOOL)>::destroy(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 8);
  if (v1)
  {

    *(_QWORD *)(a1 + 8) = 0;
  }
}

void std::__function::__func<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1,std::allocator<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1>,void ()(BOOL)>::destroy_deallocate(_QWORD *__p)
{
  uint64_t v2;

  v2 = __p[1];
  if (v2)

  operator delete(__p);
}

void std::__function::__func<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1,std::allocator<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1>,void ()(BOOL)>::operator()(uint64_t a1, unsigned __int8 *a2)
{
  int v2;
  _QWORD *v3;
  _QWORD *v4;
  _BYTE *v5;
  id v6;
  uint64_t v7;
  uint64_t (***v8)();
  uint64_t v9;
  uint64_t v10;
  id v11;
  char v12[8];
  id v13;
  uint64_t (**v14)();
  char v15;
  _BYTE v16[15];
  uint64_t (***v17)();
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  v2 = *a2;
  v3 = *(_QWORD **)(a1 + 8);
  if (v3)
    v4 = v3 + 1;
  if (v2)
  {
    v12[0] = 1;
    re::internal::TextureBuilderAsync::assetLoadDidComplete((uint64_t)v3, (uint64_t)v12);
    if (!v12[0])

  }
  else
  {
    re::AssetHandle::loadFailedMessage((re::AssetHandle *)(v3 + 3), (re::DynamicString *)&v14);
    if ((v15 & 1) != 0)
      v5 = *(_BYTE **)&v16[7];
    else
      v5 = v16;
    re::WrappedError::make((re::WrappedError *)CFSTR("RETextureBuilderErrorDomain"), (const __CFString *)2, (uint64_t)v5, &v11);
    v6 = v11;
    v11 = 0;
    v12[0] = 0;
    v13 = v6;
    re::internal::TextureBuilderAsync::assetLoadDidComplete((uint64_t)v3, (uint64_t)v12);
    if (!v12[0])

    if (v14 && (v15 & 1) != 0)
      (*((void (**)(void))*v14 + 5))();
  }
  v7 = v3[6];
  v14 = &off_24ED42A60;
  v17 = &v14;
  re::AssetLoadRequest::setCompletionHandler(v7, (uint64_t)&v14, 0);
  v8 = v17;
  if (v17 == &v14)
  {
    v9 = 4;
    v8 = &v14;
  }
  else
  {
    if (!v17)
      goto LABEL_19;
    v9 = 5;
  }
  (*v8)[v9]();
LABEL_19:
  v10 = v3[6];
  if (v10)
  {

    v3[6] = 0;
  }

}

uint64_t std::__function::__func<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1,std::allocator<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1>,void ()(BOOL)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1,std::allocator<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1>,void ()(BOOL)>::target_type()
{
}

void re::internal::TextureBuilderAsync::assetLoadDidComplete(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  uint64_t v5;
  int v6;

  v4 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  if (*(_BYTE *)(a1 + 101))
  {
    re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) ", "!m_assetLoadCompleted", "assetLoadDidComplete", 74);
    _os_crash();
    __break(1u);
  }
  else
  {
    *(_BYTE *)(a1 + 101) = 1;
    if (!*(_BYTE *)a2 && !*(_QWORD *)(a1 + 104))
      re::ObjCObject::operator=((id *)(a1 + 104), (id *)(a2 + 8));
    if (*(_BYTE *)(a1 + 100))
    {
      v6 = *(unsigned __int8 *)(a1 + 101);
      os_unfair_lock_unlock(v4);
      if (v6)
        re::internal::TextureBuilderAsync::callCompletionHandler((re::internal::TextureBuilderAsync *)a1);
    }
    else
    {
      os_unfair_lock_unlock(v4);
    }
  }
}

void std::__function::__func<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1::operator() const(BOOL)::{lambda(BOOL)#1},std::allocator<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1::operator() const(BOOL)::{lambda(BOOL)#1}>,void ()(BOOL)>::~__func()
{
  JUMPOUT(0x2276933B8);
}

_QWORD *std::__function::__func<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1::operator() const(BOOL)::{lambda(BOOL)#1},std::allocator<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1::operator() const(BOOL)::{lambda(BOOL)#1}>,void ()(BOOL)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_24ED42A60;
  return result;
}

void std::__function::__func<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1::operator() const(BOOL)::{lambda(BOOL)#1},std::allocator<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1::operator() const(BOOL)::{lambda(BOOL)#1}>,void ()(BOOL)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24ED42A60;
}

uint64_t std::__function::__func<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1::operator() const(BOOL)::{lambda(BOOL)#1},std::allocator<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1::operator() const(BOOL)::{lambda(BOOL)#1}>,void ()(BOOL)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1::operator() const(BOOL)::{lambda(BOOL)#1},std::allocator<re::TextureBuilder::makeAssetAsync(re::Function<void ()(re::Result<re::AssetHandle,re::WrappedError>)>)::$_1::operator() const(BOOL)::{lambda(BOOL)#1}>,void ()(BOOL)>::target_type()
{
}

re::DynamicString *re::SkeletonCompiler::getCurrentCompiledAssetInfo@<X0>(re::SkeletonCompiler *this@<X0>, uint64_t a2@<X8>)
{
  re::SkeletonAsset *v3;
  const char *v5[2];

  *(_QWORD *)(a2 + 32) = 0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  v3 = (re::SkeletonAsset *)re::DynamicString::setCapacity((_QWORD *)(a2 + 8), 0);
  *(_QWORD *)a2 = 0x100000001;
  v5[0] = (const char *)*re::SkeletonAsset::assetType(v3);
  v5[1] = (const char *)strlen(v5[0]);
  return re::DynamicString::operator=((re::DynamicString *)(a2 + 8), (uint64_t)v5);
}

__guard re::SkeletonCompiler::assetIntrospectionType(re::SkeletonCompiler *this)
{
  unsigned __int8 v1;
  __guard *v2;
  int v4;

  if ((v1 & 1) == 0)
  {
    if (v4)
    {
      re::introspect<re::SkeletonAsset>(void)::info = re::introspect_SkeletonAsset(0);
    }
  }
  return v2[41];
}

uint64_t re::SkeletonCompiler::getSupportedExtensions@<X0>(uint64_t a1@<X8>)
{
  _QWORD v3[2];

  v3[0] = re::SkeletonCompiler::getSupportedExtensions(void)const::supportedExtensions;
  v3[1] = 1;
  return re::DynamicArray<char const*>::DynamicArray(a1, (uint64_t)v3);
}

uint64_t *re::SkeletonCompiler::compile@<X0>(re::SkeletonCompiler *this@<X0>, re::AssetUtilities *a2@<X1>, re::AssetSerializationScheme *a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;
  __int128 v17;
  __int128 v18;
  uint64_t v19;
  uint64_t v20;
  _BYTE v21[8];
  uint64_t v22;
  char v23;
  uint64_t v24;
  _QWORD v25[5];

  v25[4] = *MEMORY[0x24BDAC8D0];
  v9 = re::globalAllocators(this);
  v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v9[2] + 32))(v9[2], 248, 8);
  *(_OWORD *)v10 = 0u;
  *(_OWORD *)(v10 + 16) = 0u;
  *(_OWORD *)(v10 + 32) = 0u;
  *(_OWORD *)(v10 + 48) = 0u;
  *(_OWORD *)(v10 + 64) = 0u;
  *(_OWORD *)(v10 + 80) = 0u;
  *(_OWORD *)(v10 + 96) = 0u;
  *(_OWORD *)(v10 + 112) = 0u;
  *(_OWORD *)(v10 + 128) = 0u;
  *(_OWORD *)(v10 + 144) = 0u;
  *(_OWORD *)(v10 + 160) = 0u;
  *(_OWORD *)(v10 + 176) = 0u;
  *(_OWORD *)(v10 + 192) = 0u;
  *(_OWORD *)(v10 + 208) = 0u;
  *(_OWORD *)(v10 + 224) = 0u;
  *(_QWORD *)(v10 + 8) = &str_110;
  *(_QWORD *)(v10 + 96) = &str_110;
  *(_OWORD *)(v10 + 104) = 0u;
  *(_OWORD *)(v10 + 120) = 0u;
  *(_OWORD *)(v10 + 136) = 0u;
  *(_OWORD *)(v10 + 152) = 0u;
  *(_OWORD *)(v10 + 168) = 0u;
  *(_OWORD *)(v10 + 184) = 0u;
  *(_OWORD *)(v10 + 200) = 0u;
  *(_OWORD *)(v10 + 216) = 0u;
  *(_QWORD *)(v10 + 232) = 0x7FFFFFFF00000000;
  *(_QWORD *)(v10 + 240) = 0;
  v25[3] = v25;
  v24 = v10;
  v25[0] = &off_24ED42B58;
  v11 = (*(uint64_t (**)(re::SkeletonCompiler *))(*(_QWORD *)this + 24))(this);
  re::AssetUtilities::readSourceJson(a2, (const char *)v10, v11, a3, (uint64_t)v21);
  if (v21[0])
  {
    v12 = v24;
    v24 = 0;
    *(_BYTE *)a4 = 1;
    *(_QWORD *)(a4 + 8) = v12;
  }
  else
  {
    *(_QWORD *)&v17 = 100;
    *((_QWORD *)&v17 + 1) = &re::AssetErrorCategory(void)::instance;
    re::DynamicString::DynamicString((re::DynamicString *)&v18, (const re::DynamicString *)&v22);
    v13 = v18;
    *(_OWORD *)(a4 + 8) = v17;
    v14 = v19;
    v15 = v20;
    *(_BYTE *)a4 = 0;
    *(_OWORD *)(a4 + 24) = v13;
    *(_QWORD *)(a4 + 40) = v14;
    *(_QWORD *)(a4 + 48) = v15;
    if (!v21[0] && v22 && (v23 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v22 + 40))();
  }
  return std::unique_ptr<re::RigHierarchy,std::function<void ()(re::RigHierarchy*)>>::~unique_ptr[abi:nn180100](&v24);
}

re *re::SkeletonCompiler::deleteAsset(re::SkeletonCompiler *this, _QWORD *a2)
{
  return re::internal::destroyPersistent<re::SkeletonAsset>((re *)"deleteAsset", 55, a2);
}

re *re::internal::destroyPersistent<re::SkeletonAsset>(re *result, uint64_t a2, _QWORD *a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  if (a3)
  {
    v4 = re::globalAllocators(result)[2];
    re::Skeleton::~Skeleton((re::Skeleton *)(a3 + 11));
    v5 = a3[8];
    if (v5)
    {
      if (a3[9])
      {
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v5 + 40))(v5, a3[10]);
        a3[9] = 0;
        a3[10] = 0;
      }
      a3[8] = 0;
    }
    v6 = a3[5];
    if (v6)
    {
      if (a3[6])
      {
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v6 + 40))(v6, a3[7]);
        a3[6] = 0;
        a3[7] = 0;
      }
      a3[5] = 0;
    }
    re::FixedArray<re::StringID>::deinit(a3 + 2);
    re::StringID::destroyString((re::StringID *)a3);
    return (re *)(*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v4 + 40))(v4, a3);
  }
  return result;
}

void re::SkeletonCompiler::~SkeletonCompiler(re::SkeletonCompiler *this)
{
  JUMPOUT(0x2276933B8);
}

void std::__function::__func<re::SkeletonCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::SkeletonCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,void ()(re::SkeletonAsset *)>::~__func()
{
  JUMPOUT(0x2276933B8);
}

_QWORD *std::__function::__func<re::SkeletonCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::SkeletonCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,void ()(re::SkeletonAsset *)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_24ED42B58;
  return result;
}

void std::__function::__func<re::SkeletonCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::SkeletonCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,void ()(re::SkeletonAsset *)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24ED42B58;
}

re *std::__function::__func<re::SkeletonCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::SkeletonCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,void ()(re::SkeletonAsset *)>::operator()(uint64_t a1, _QWORD **a2)
{
  return re::internal::destroyPersistent<re::SkeletonAsset>((re *)"operator()", 40, *a2);
}

uint64_t std::__function::__func<re::SkeletonCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::SkeletonCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,void ()(re::SkeletonAsset *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::SkeletonCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0,std::allocator<re::SkeletonCompiler::compile(char const*,void *,re::AssetSerializationScheme &)::$_0>,void ()(re::SkeletonAsset *)>::target_type()
{
}

uint64_t re::TextureAssetData::TextureAssetData(uint64_t a1, uint64_t a2, int a3, _OWORD *a4)
{
  uint64_t v8;
  __int128 v9;

  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(_QWORD *)a1 = off_24ED42BE8;
  *(_BYTE *)(a1 + 24) = *(_BYTE *)a2;
  *(_BYTE *)(v8 + 32) = 0;
  *(_DWORD *)(a1 + 112) = -1;
  std::__variant_detail::__ctor<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>>::__generic_construct[abi:nn180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>,(std::__variant_detail::_Trait)1> const&>(v8 + 32, a2 + 8);
  *(_QWORD *)(a1 + 120) = *(id *)(a2 + 96);
  *(_DWORD *)(a1 + 128) = a3;
  v9 = a4[1];
  *(_OWORD *)(a1 + 132) = *a4;
  *(_OWORD *)(a1 + 148) = v9;
  return a1;
}

void re::TextureAssetData::~TextureAssetData(id *this)
{
  uint64_t v2;
  char v3;

  *this = off_24ED42BE8;

  v2 = *((unsigned int *)this + 28);
  if ((_DWORD)v2 != -1)
    ((void (*)(char *, id *))*(&off_24ED42C20 + v2))(&v3, this + 4);
  *((_DWORD *)this + 28) = -1;
  *this = &off_24ED426B8;
  objc_destructInstance(this + 1);
}

{
  uint64_t v2;
  char v3;

  *this = off_24ED42BE8;

  v2 = *((unsigned int *)this + 28);
  if ((_DWORD)v2 != -1)
    ((void (*)(char *, id *))*(&off_24ED42C20 + v2))(&v3, this + 4);
  *((_DWORD *)this + 28) = -1;
  *this = &off_24ED426B8;
  objc_destructInstance(this + 1);
  MEMORY[0x2276933B8](this, 0x10F3C409B209BBFLL);
}

re::DynamicString *re::MeshCompiler::getCurrentCompiledAssetInfo@<X0>(re::MeshCompiler *this@<X0>, uint64_t a2@<X8>)
{
  re::MeshAsset *v3;
  const char *v5[2];

  *(_QWORD *)(a2 + 32) = 0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  v3 = (re::MeshAsset *)re::DynamicString::setCapacity((_QWORD *)(a2 + 8), 0);
  *(_QWORD *)a2 = 0x100000001;
  v5[0] = (const char *)*re::MeshAsset::assetType(v3);
  v5[1] = (const char *)strlen(v5[0]);
  return re::DynamicString::operator=((re::DynamicString *)(a2 + 8), (uint64_t)v5);
}

__guard re::MeshCompiler::assetIntrospectionType(re::MeshCompiler *this)
{
  unsigned __int8 v1;
  __guard *v2;
  int v4;

  if ((v1 & 1) == 0)
  {
    if (v4)
    {
      re::introspect<re::MeshAsset>(void)::info = re::introspect_MeshAsset(0);
    }
  }
  return v2[290];
}

_QWORD *re::MeshCompiler::getSupportedExtensions@<X0>(uint64_t a1@<X8>)
{
  uint64_t v3;
  _QWORD *result;

  v3 = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  do
    result = re::DynamicArray<re::TransitionCondition *>::add((_QWORD *)a1, &re::MeshCompiler::getSupportedExtensions(void)const::supportedExtensions[v3++]);
  while (v3 != 5);
  return result;
}

void re::MeshCompiler::compile(const char *a1@<X1>, char *a2@<X2>, uint64_t a3@<X8>)
{
  int v8;
  re *v9;
  uint64_t *v10;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  _BYTE v15[8];
  uint64_t v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD v20[3];
  int v21;
  uint64_t v22;
  _BYTE v23[40];
  uint64_t v24[6];
  _BYTE v25[8];
  uint64_t v26[5];
  uint64_t v27[3];
  int v28;
  uint64_t v29;
  uint64_t v30[5];
  uint64_t v31[6];
  _BYTE v32[21];
  uint64_t v33[4];
  __int128 v34;
  _BYTE v35[16];

  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v35, 4500, 0);
  *(_DWORD *)v32 = 16842752;
  v32[4] = 1;
  *(_DWORD *)&v32[5] = 0;
  *(_WORD *)&v32[9] = 0;
  *(_DWORD *)&v32[12] = 1036831949;
  *(_DWORD *)&v32[16] = 16843008;
  v32[20] = 0;
  v34 = 0u;
  memset(v33, 0, sizeof(v33));
  DWORD1(v34) = 0x7FFFFFFF;
  if (a2)
  {
    *(_OWORD *)v32 = *(_OWORD *)a2;
    *(_QWORD *)&v32[13] = *(_QWORD *)(a2 + 13);
    re::HashTable<re::DynamicString,re::MeshAttributeCompressionOption,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=((uint64_t)v33, (uint64_t)(a2 + 24));
  }
  re::loadGeomSceneFromFile(a1, (uint64_t)v32, (uint64_t)v25);
  if (v25[0])
  {
    re::DynamicArray<re::GeomModelWithLods>::DynamicArray((uint64_t)&v17, v26);
    re::DynamicArray<re::GeomInstance>::DynamicArray((uint64_t)v20, v27);
    re::DynamicArray<re::GeomSkeleton>::DynamicArray((uint64_t)v23, v30);
    re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::HashTable((uint64_t)v24, (uint64_t)v31);
    re::makeMeshAssetDataFromGeomScene((unint64_t)&v17, (uint64_t)v32, (uint64_t)v15);
    v8 = v15[0];
    v10 = re::globalAllocators(v9);
    v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v10[2] + 32))(v10[2], 960, 8);
    if (v8)
    {
      v11 = re::MeshAsset::MeshAsset(v11, (uint64_t)&v16);
    }
    else
    {
      *(_QWORD *)v11 = &off_24ED30A60;
      *(_QWORD *)(v11 + 8) = 0;
      *(_QWORD *)(v11 + 16) = 0;
      *(_QWORD *)(v11 + 24) = 0;
      *(_DWORD *)(v11 + 32) = 0;
      *(_OWORD *)(v11 + 40) = 0u;
      *(_OWORD *)(v11 + 56) = 0u;
      *(_DWORD *)(v11 + 72) = 0;
      *(_OWORD *)(v11 + 80) = 0u;
      *(_OWORD *)(v11 + 96) = 0u;
      *(_DWORD *)(v11 + 112) = 0;
      *(_OWORD *)(v11 + 120) = 0u;
      *(_OWORD *)(v11 + 136) = 0u;
      *(_DWORD *)(v11 + 152) = 0;
      *(_DWORD *)(v11 + 424) = 0;
      *(_OWORD *)(v11 + 392) = 0u;
      *(_OWORD *)(v11 + 408) = 0u;
      *(_OWORD *)(v11 + 484) = 0u;
      *(_OWORD *)(v11 + 472) = 0u;
      *(_OWORD *)(v11 + 456) = 0u;
      *(_DWORD *)(v11 + 192) = 0;
      *(_OWORD *)(v11 + 160) = 0u;
      *(_OWORD *)(v11 + 176) = 0u;
      *(_OWORD *)(v11 + 200) = 0u;
      *(_OWORD *)(v11 + 216) = 0u;
      *(_DWORD *)(v11 + 232) = 0;
      *(_OWORD *)(v11 + 240) = 0u;
      *(_OWORD *)(v11 + 256) = 0u;
      *(_DWORD *)(v11 + 272) = 0;
      *(_OWORD *)(v11 + 280) = 0u;
      *(_OWORD *)(v11 + 296) = 0u;
      *(_OWORD *)(v11 + 312) = 0u;
      *(_OWORD *)(v11 + 328) = 0u;
      *(_OWORD *)(v11 + 344) = 0u;
      *(_OWORD *)(v11 + 360) = 0u;
      *(_OWORD *)(v11 + 372) = 0u;
      *(_DWORD *)(v11 + 448) = 0;
      *(_QWORD *)(v11 + 432) = 0;
      *(_QWORD *)(v11 + 440) = 0;
      *(_QWORD *)(v11 + 500) = 0x7FFFFFFFLL;
      *(_DWORD *)(v11 + 544) = 0;
      *(_OWORD *)(v11 + 512) = 0u;
      *(_OWORD *)(v11 + 528) = 0u;
      *(_QWORD *)(v11 + 548) = 0x7FFFFFFFLL;
      *(_OWORD *)(v11 + 905) = 0u;
      *(_OWORD *)(v11 + 880) = 0u;
      *(_OWORD *)(v11 + 896) = 0u;
      *(_OWORD *)(v11 + 848) = 0u;
      *(_OWORD *)(v11 + 864) = 0u;
      *(_OWORD *)(v11 + 816) = 0u;
      *(_OWORD *)(v11 + 832) = 0u;
      *(_OWORD *)(v11 + 784) = 0u;
      *(_OWORD *)(v11 + 800) = 0u;
      *(_OWORD *)(v11 + 752) = 0u;
      *(_OWORD *)(v11 + 768) = 0u;
      *(_OWORD *)(v11 + 720) = 0u;
      *(_OWORD *)(v11 + 736) = 0u;
      *(_OWORD *)(v11 + 688) = 0u;
      *(_OWORD *)(v11 + 704) = 0u;
      *(_OWORD *)(v11 + 656) = 0u;
      *(_OWORD *)(v11 + 672) = 0u;
      *(_OWORD *)(v11 + 624) = 0u;
      *(_OWORD *)(v11 + 640) = 0u;
      *(_OWORD *)(v11 + 592) = 0u;
      *(_OWORD *)(v11 + 608) = 0u;
      *(_OWORD *)(v11 + 560) = 0u;
      *(_OWORD *)(v11 + 576) = 0u;
      *(_DWORD *)(v11 + 924) = 2;
      *(_QWORD *)(v11 + 928) = 0;
      *(_QWORD *)(v11 + 944) = 0;
      *(_QWORD *)(v11 + 936) = 0;
      *(_BYTE *)(v11 + 952) = 0;
    }
    *(_BYTE *)a3 = 1;
    *(_QWORD *)(a3 + 8) = v11;
    re::Result<re::MeshAssetData,re::DetailedError>::~Result((uint64_t)v15);
    re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit(v24);
    re::DynamicArray<re::GeomSkeleton>::deinit((uint64_t)v23);
    if (v20[0])
    {
      if (v22)
        (*(void (**)(void))(*(_QWORD *)v20[0] + 40))();
      v22 = 0;
      memset(v20, 0, sizeof(v20));
      ++v21;
    }
    re::DynamicArray<re::GeomModelWithLods>::deinit((uint64_t)&v17);
  }
  else
  {
    re::DynamicString::format((re::DynamicString *)"Failed to load '%s", (re::DynamicString *)&v17, a1);
    v12 = v17;
    v13 = v18;
    v14 = v19;
    *(_BYTE *)a3 = 0;
    *(_QWORD *)(a3 + 8) = 100;
    *(_QWORD *)(a3 + 16) = &re::AssetErrorCategory(void)::instance;
    *(_OWORD *)(a3 + 24) = v12;
    *(_QWORD *)(a3 + 40) = v13;
    *(_QWORD *)(a3 + 48) = v14;
  }
  if (v25[0])
  {
    re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit(v31);
    re::DynamicArray<re::GeomSkeleton>::deinit((uint64_t)v30);
    if (v27[0])
    {
      if (v29)
        (*(void (**)(void))(*(_QWORD *)v27[0] + 40))();
      v29 = 0;
      memset(v27, 0, sizeof(v27));
      ++v28;
    }
    re::DynamicArray<re::GeomModelWithLods>::deinit((uint64_t)v26);
  }
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v33, *(double *)&v12);
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v35);
}

re *re::MeshCompiler::deleteAsset(re *this, void (***a2)(_QWORD))
{
  uint64_t v3;

  if (a2)
  {
    v3 = re::globalAllocators(this)[2];
    (**a2)(a2);
    return (re *)(*(uint64_t (**)(uint64_t, void (***)(_QWORD)))(*(_QWORD *)v3 + 40))(v3, a2);
  }
  return this;
}

re *re::MeshCompiler::deleteAssetCompileOptions(re *this, uint64_t *a2)
{
  uint64_t v3;
  double v4;
  double v5;

  if (a2)
  {
    v3 = re::globalAllocators(this)[2];
    v5 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(a2 + 3, v4);
    return (re *)(*(uint64_t (**)(uint64_t, uint64_t *, double))(*(_QWORD *)v3 + 40))(v3, a2, v5);
  }
  return this;
}

void re::MeshCompiler::~MeshCompiler(re::MeshCompiler *this)
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::DynamicArray<re::GeomModelWithLods>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  unint64_t v5;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  v3 = *a2;
  if (*a2)
  {
    v5 = a2[2];
    *(_QWORD *)a1 = v3;
    re::DynamicArray<re::GeomModelWithLods>::setCapacity((_QWORD *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::GeomModelWithLods>::copy((_QWORD *)a1, (uint64_t)a2);
  }
  return a1;
}

uint64_t re::DynamicArray<re::GeomModelWithLods>::copy(_QWORD *a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char v19;
  char v20;

  v4 = *(_QWORD *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<re::GeomModelWithLods>::setCapacity(a1, *(_QWORD *)(a2 + 16));
    result = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::GeomModelWithLods *,re::GeomModelWithLods *,re::GeomModelWithLods *>((uint64_t)&v20, *(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 32) + 152 * a1[2], a1[4]);
    v14 = a1[2];
    if (v14 != v4)
    {
      v15 = *(_QWORD *)(a2 + 32);
      v16 = a1[4];
      v17 = 152 * v14;
      v18 = 152 * v4;
      do
      {
        re::DynamicString::DynamicString((re::DynamicString *)(v16 + v17), (const re::DynamicString *)(v15 + v17));
        re::DynamicArray<re::GeomModel>::DynamicArray(v16 + v17 + 32, (uint64_t *)(v15 + v17 + 32));
        re::DynamicArray<float>::DynamicArray(v16 + v17 + 72, (uint64_t *)(v15 + v17 + 72));
        result = re::DynamicArray<float>::DynamicArray(v16 + v17 + 112, (uint64_t *)(v15 + v17 + 112));
        v15 += 152;
        v18 -= 152;
        v16 += 152;
      }
      while (v17 != v18);
    }
  }
  else
  {
    result = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::GeomModelWithLods *,re::GeomModelWithLods *,re::GeomModelWithLods *>((uint64_t)&v19, *(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 32) + 152 * v4, a1[4]);
    v6 = a1[2];
    if (v4 != v6)
    {
      v7 = a1[4];
      v8 = 152 * v4;
      v9 = 152 * v6;
      do
      {
        v10 = v7 + v8;
        v11 = *(_QWORD *)(v7 + v8 + 112);
        if (v11)
        {
          if (*(_QWORD *)(v10 + 144))
            (*(void (**)(uint64_t))(*(_QWORD *)v11 + 40))(v11);
          *(_QWORD *)(v10 + 144) = 0;
          *(_QWORD *)(v7 + v8 + 120) = 0;
          *(_QWORD *)(v7 + v8 + 128) = 0;
          *(_QWORD *)(v7 + v8 + 112) = 0;
          ++*(_DWORD *)(v7 + v8 + 136);
        }
        v12 = *(_QWORD *)(v10 + 72);
        if (v12)
        {
          v13 = v7 + v8;
          if (*(_QWORD *)(v7 + v8 + 104))
            (*(void (**)(uint64_t))(*(_QWORD *)v12 + 40))(v12);
          *(_QWORD *)(v13 + 104) = 0;
          *(_QWORD *)(v10 + 80) = 0;
          *(_QWORD *)(v10 + 88) = 0;
          *(_QWORD *)(v10 + 72) = 0;
          ++*(_DWORD *)(v13 + 96);
        }
        re::DynamicArray<re::GeomModel>::deinit(v7 + v8 + 32);
        result = *(_QWORD *)(v7 + 152 * v4);
        if (result)
        {
          if ((*(_BYTE *)(v7 + v8 + 8) & 1) != 0)
            result = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)result + 40))(result, *(_QWORD *)(v7 + v8 + 16));
          *(_OWORD *)v10 = 0u;
          *(_OWORD *)(v10 + 16) = 0u;
        }
        v7 += 152;
        v9 -= 152;
      }
      while (v8 != v9);
    }
  }
  a1[2] = v4;
  return result;
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::GeomModelWithLods *,re::GeomModelWithLods *,re::GeomModelWithLods *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t v7;

  if (a2 == a3)
    return a2;
  v6 = a3;
  v7 = 0;
  do
  {
    re::DynamicString::operator=((re::DynamicString *)(a4 + v7), (re::DynamicString *)(a2 + v7));
    re::DynamicArray<re::GeomModel>::operator=(a4 + v7 + 32, (uint64_t *)(a2 + v7 + 32));
    re::DynamicArray<float>::operator=(a4 + v7 + 72, (uint64_t *)(a2 + v7 + 72));
    re::DynamicArray<float>::operator=(a4 + v7 + 112, (uint64_t *)(a2 + v7 + 112));
    v7 += 152;
  }
  while (a2 + v7 != v6);
  return v6;
}

uint64_t re::DynamicArray<re::GeomModel>::operator=(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  unint64_t v5;

  if ((uint64_t *)a1 != a2)
  {
    v4 = *a2;
    if (*(_QWORD *)a1)
    {
      if (v4)
      {
        re::DynamicArray<re::GeomModel>::copy((_QWORD *)a1, (uint64_t)a2);
        ++*(_DWORD *)(a1 + 24);
      }
      else
      {
        re::DynamicArray<re::GeomModel>::clear((_QWORD *)a1);
      }
    }
    else if (v4)
    {
      v5 = a2[2];
      *(_QWORD *)a1 = v4;
      re::DynamicArray<re::GeomModel>::setCapacity((_QWORD *)a1, v5);
      ++*(_DWORD *)(a1 + 24);
      re::DynamicArray<re::GeomModel>::copy((_QWORD *)a1, (uint64_t)a2);
    }
  }
  return a1;
}

uint64_t re::DynamicArray<re::GeomModel>::copy(_QWORD *a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  re::GeomAttribute *v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int v22;
  char v23;
  char v24;

  v4 = *(_QWORD *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<re::GeomModel>::setCapacity(a1, *(_QWORD *)(a2 + 16));
    result = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::GeomModel *,re::GeomModel *,re::GeomModel *>((uint64_t)&v24, *(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 32) + 248 * a1[2], a1[4]);
    v14 = a1[2];
    if (v14 != v4)
    {
      v15 = *(_QWORD *)(a2 + 32);
      v16 = a1[4];
      v17 = 248 * v14;
      v18 = 248 * v4;
      do
      {
        v19 = v15 + v17;
        v20 = v16 + v17;
        re::DynamicString::DynamicString((re::DynamicString *)(v16 + v17), (const re::DynamicString *)(v15 + v17));
        re::DynamicArray<re::GeomMesh>::DynamicArray(v16 + v17 + 32, (uint64_t *)(v15 + v17 + 32));
        re::DynamicArray<float>::DynamicArray(v16 + v17 + 72, (uint64_t *)(v15 + v17 + 72));
        v21 = *(unsigned __int8 *)(v15 + v17 + 112);
        *(_BYTE *)(v16 + v17 + 112) = v21;
        if (v21)
          re::DynamicArray<re::GeomIndexMap>::DynamicArray(v20 + 120, (uint64_t *)(v19 + 120));
        v22 = *(unsigned __int8 *)(v19 + 160);
        *(_BYTE *)(v20 + 160) = v22;
        if (v22)
          re::DynamicArray<re::GeomIndexMap>::DynamicArray(v16 + v17 + 168, (uint64_t *)(v15 + v17 + 168));
        result = re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::DynamicArray(v16 + v17 + 208, (uint64_t *)(v15 + v17 + 208));
        v15 += 248;
        v18 -= 248;
        v16 += 248;
      }
      while (v17 != v18);
    }
  }
  else
  {
    result = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::GeomModel *,re::GeomModel *,re::GeomModel *>((uint64_t)&v23, *(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 32) + 248 * v4, a1[4]);
    v6 = a1[2];
    if (v4 != v6)
    {
      v7 = a1[4];
      v8 = 248 * v4;
      v9 = 248 * v6;
      do
      {
        v10 = v7 + v8;
        re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::deinit(v7 + v8 + 208);
        if (*(_BYTE *)(v7 + v8 + 160))
          re::DynamicArray<re::GeomIndexMap>::deinit(v10 + 168);
        if (*(_BYTE *)(v10 + 112))
          re::DynamicArray<re::GeomIndexMap>::deinit(v7 + v8 + 120);
        v12 = (uint64_t *)(v7 + v8);
        v13 = *(_QWORD *)(v7 + v8 + 72);
        if (v13)
        {
          v11 = (re::GeomAttribute *)v12[13];
          if (v11)
            (*(void (**)(uint64_t))(*(_QWORD *)v13 + 40))(v13);
          v12[13] = 0;
          *(_QWORD *)(v7 + v8 + 80) = 0;
          *(_QWORD *)(v7 + v8 + 88) = 0;
          *(_QWORD *)(v7 + v8 + 72) = 0;
          ++*(_DWORD *)(v7 + v8 + 96);
        }
        re::DynamicArray<re::GeomMesh>::deinit((uint64_t)(v12 + 4), v11);
        result = *v12;
        if (*v12)
        {
          if ((*(_BYTE *)(v7 + v8 + 8) & 1) != 0)
            result = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)result + 40))(result, *(_QWORD *)(v7 + v8 + 16));
          *(_OWORD *)v10 = 0u;
          *(_OWORD *)(v10 + 16) = 0u;
        }
        v7 += 248;
        v9 -= 248;
      }
      while (v8 != v9);
    }
  }
  a1[2] = v4;
  return result;
}

_QWORD *re::DynamicArray<re::GeomModel>::clear(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  re::GeomAttribute *v7;
  uint64_t v8;
  uint64_t v9;

  v1 = result;
  v2 = result[2];
  result[2] = 0;
  if (v2)
  {
    v3 = 0;
    v4 = result[4];
    v5 = 248 * v2;
    do
    {
      v6 = v4 + v3;
      re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::deinit(v4 + v3 + 208);
      if (*(_BYTE *)(v4 + v3 + 160))
        re::DynamicArray<re::GeomIndexMap>::deinit(v6 + 168);
      if (*(_BYTE *)(v6 + 112))
        re::DynamicArray<re::GeomIndexMap>::deinit(v4 + v3 + 120);
      v8 = v4 + v3;
      v9 = *(_QWORD *)(v4 + v3 + 72);
      if (v9)
      {
        v7 = *(re::GeomAttribute **)(v8 + 104);
        if (v7)
          (*(void (**)(uint64_t))(*(_QWORD *)v9 + 40))(v9);
        *(_QWORD *)(v8 + 104) = 0;
        *(_QWORD *)(v4 + v3 + 80) = 0;
        *(_QWORD *)(v4 + v3 + 88) = 0;
        *(_QWORD *)(v4 + v3 + 72) = 0;
        ++*(_DWORD *)(v4 + v3 + 96);
      }
      re::DynamicArray<re::GeomMesh>::deinit(v8 + 32, v7);
      result = *(_QWORD **)v8;
      if (*(_QWORD *)v8)
      {
        if ((*(_BYTE *)(v4 + v3 + 8) & 1) != 0)
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, _QWORD))(*result + 40))(result, *(_QWORD *)(v4 + v3 + 16));
        *(_OWORD *)v6 = 0u;
        *(_OWORD *)(v6 + 16) = 0u;
      }
      v3 += 248;
    }
    while (v5 != v3);
  }
  ++*((_DWORD *)v1 + 6);
  return result;
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::GeomModel *,re::GeomModel *,re::GeomModel *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t v7;

  if (a2 == a3)
    return a2;
  v6 = a3;
  v7 = 0;
  do
  {
    re::DynamicString::operator=((re::DynamicString *)(a4 + v7), (re::DynamicString *)(a2 + v7));
    re::DynamicArray<re::GeomMesh>::operator=((re::GeomMesh *)(a4 + v7 + 32), (re::GeomAttribute *)(a2 + v7 + 32));
    re::DynamicArray<float>::operator=(a4 + v7 + 72, (uint64_t *)(a2 + v7 + 72));
    re::Optional<re::DynamicArray<re::GeomIndexMap>>::operator=((_BYTE *)(a4 + v7 + 112), (uint64_t *)(a2 + v7 + 112));
    re::Optional<re::DynamicArray<re::GeomIndexMap>>::operator=((_BYTE *)(a4 + v7 + 160), (uint64_t *)(a2 + v7 + 160));
    re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::operator=(a4 + v7 + 208, (uint64_t *)(a2 + v7 + 208));
    v7 += 248;
  }
  while (a2 + v7 != v6);
  return v6;
}

re::GeomMesh *re::DynamicArray<re::GeomMesh>::operator=(re::GeomMesh *a1, re::GeomAttribute *a2)
{
  uint64_t v4;
  unint64_t v5;

  if (a1 != a2)
  {
    v4 = *(_QWORD *)a2;
    if (*(_QWORD *)a1)
    {
      if (v4)
      {
        re::DynamicArray<re::GeomMesh>::copy((uint64_t)a1, (uint64_t)a2);
        ++*((_DWORD *)a1 + 6);
      }
      else
      {
        re::DynamicArray<re::GeomMesh>::clear(a1, a2);
      }
    }
    else if (v4)
    {
      v5 = *((_QWORD *)a2 + 2);
      *(_QWORD *)a1 = v4;
      re::DynamicArray<re::GeomMesh>::setCapacity(a1, v5);
      ++*((_DWORD *)a1 + 6);
      re::DynamicArray<re::GeomMesh>::copy((uint64_t)a1, (uint64_t)a2);
    }
  }
  return a1;
}

_BYTE *re::Optional<re::DynamicArray<re::GeomIndexMap>>::operator=(_BYTE *a1, uint64_t *a2)
{
  int v3;
  int v4;
  BOOL v5;
  uint64_t v6;
  BOOL v7;
  BOOL v8;

  v3 = *a1;
  v4 = *(unsigned __int8 *)a2;
  if (*a1)
    v5 = 0;
  else
    v5 = v4 == 0;
  if (!v5)
  {
    v6 = (uint64_t)(a1 + 8);
    if (v3)
      v7 = v4 == 0;
    else
      v7 = 0;
    if (v7)
    {
      re::DynamicArray<re::GeomIndexMap>::deinit(v6);
      *a1 = 0;
    }
    else
    {
      if (v3)
        v8 = 1;
      else
        v8 = v4 == 0;
      if (v8)
      {
        re::DynamicArray<re::GeomIndexMap>::operator=(v6, a2 + 1);
      }
      else
      {
        *a1 = 1;
        re::DynamicArray<re::GeomIndexMap>::DynamicArray(v6, a2 + 1);
      }
    }
  }
  return a1;
}

uint64_t re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::operator=(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  unint64_t v5;

  if ((uint64_t *)a1 != a2)
  {
    v4 = *a2;
    if (*(_QWORD *)a1)
    {
      if (v4)
      {
        re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::copy((_QWORD *)a1, (uint64_t)a2);
        ++*(_DWORD *)(a1 + 24);
      }
      else
      {
        re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::clear(a1);
      }
    }
    else if (v4)
    {
      v5 = a2[2];
      *(_QWORD *)a1 = v4;
      re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::setCapacity((_QWORD *)a1, v5);
      ++*(_DWORD *)(a1 + 24);
      re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::copy((_QWORD *)a1, (uint64_t)a2);
    }
  }
  return a1;
}

re::GeomMesh *re::DynamicArray<re::GeomMesh>::copy(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  re::GeomMesh *result;
  re::GeomAttribute *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  re::GeomMesh *v12;
  uint64_t v13;
  _QWORD *v14;

  v4 = *(_QWORD *)(a2 + 16);
  if (v4 >= *(_QWORD *)(a1 + 16))
  {
    re::DynamicArray<re::GeomMesh>::setCapacity((_QWORD *)a1, *(_QWORD *)(a2 + 16));
    result = std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::GeomMesh *,re::GeomMesh *,re::GeomMesh *,0>(*(re::GeomMesh **)(a2 + 32), (re::GeomMesh *)(*(_QWORD *)(a2 + 32) + 736 * *(_QWORD *)(a1 + 16)), *(re::GeomMesh **)(a1 + 32));
    v10 = *(_QWORD *)(a1 + 16);
    if (v10 != v4)
    {
      v11 = 736 * v10;
      v12 = (re::GeomMesh *)(*(_QWORD *)(a2 + 32) + v11);
      v13 = 736 * v4 - v11;
      v14 = (_QWORD *)(v11 + *(_QWORD *)(a1 + 32) + 16);
      do
      {
        *(v14 - 2) = 0;
        *((_DWORD *)v14 - 2) = 0;
        bzero(v14, 0x2C8uLL);
        re::internal::GeomBaseMesh::GeomBaseMesh((re::internal::GeomBaseMesh *)v14);
        v14[89] = 0;
        result = re::GeomMesh::copy(v12, (re::GeomMesh *)(v14 - 2));
        v12 = (re::GeomMesh *)((char *)v12 + 736);
        v14 += 92;
        v13 -= 736;
      }
      while (v13);
    }
  }
  else
  {
    result = std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::GeomMesh *,re::GeomMesh *,re::GeomMesh *,0>(*(re::GeomMesh **)(a2 + 32), (re::GeomMesh *)(*(_QWORD *)(a2 + 32) + 736 * v4), *(re::GeomMesh **)(a1 + 32));
    v7 = *(_QWORD *)(a1 + 16);
    if (v4 != v7)
    {
      result = (re::GeomMesh *)(*(_QWORD *)(a1 + 32) + 736 * v4);
      v8 = 736 * v7 - 736 * v4;
      do
      {
        re::GeomMesh::~GeomMesh(result, v6);
        result = (re::GeomMesh *)(v9 + 736);
        v8 -= 736;
      }
      while (v8);
    }
  }
  *(_QWORD *)(a1 + 16) = v4;
  return result;
}

re::GeomMesh *re::DynamicArray<re::GeomMesh>::clear(re::GeomMesh *result, re::GeomAttribute *a2)
{
  re::GeomMesh *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = result;
  v3 = *((_QWORD *)result + 2);
  *((_QWORD *)result + 2) = 0;
  if (v3)
  {
    result = (re::GeomMesh *)*((_QWORD *)result + 4);
    v4 = 736 * v3;
    do
    {
      re::GeomMesh::~GeomMesh(result, a2);
      result = (re::GeomMesh *)(v5 + 736);
      v4 -= 736;
    }
    while (v4);
  }
  ++*((_DWORD *)v2 + 6);
  return result;
}

re::GeomMesh *std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::GeomMesh *,re::GeomMesh *,re::GeomMesh *,0>(re::GeomMesh *a1, re::GeomMesh *a2, re::GeomMesh *a3)
{
  re::GeomMesh *v4;

  v4 = a1;
  if (a1 != a2)
  {
    do
    {
      re::GeomMesh::copy(v4, a3);
      v4 = (re::GeomMesh *)((char *)v4 + 736);
      a3 = (re::GeomMesh *)((char *)a3 + 736);
    }
    while (v4 != a2);
    return a2;
  }
  return v4;
}

uint64_t re::DynamicArray<re::GeomIndexMap>::operator=(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  unint64_t v5;

  if ((uint64_t *)a1 != a2)
  {
    v4 = *a2;
    if (*(_QWORD *)a1)
    {
      if (v4)
      {
        re::DynamicArray<re::GeomIndexMap>::copy((_QWORD *)a1, (uint64_t)a2);
        ++*(_DWORD *)(a1 + 24);
      }
      else
      {
        re::DynamicArray<re::GeomIndexMap>::clear(a1, (uint64_t)a2);
      }
    }
    else if (v4)
    {
      v5 = a2[2];
      *(_QWORD *)a1 = v4;
      re::DynamicArray<re::GeomIndexMap>::setCapacity((_QWORD *)a1, v5);
      ++*(_DWORD *)(a1 + 24);
      re::DynamicArray<re::GeomIndexMap>::copy((_QWORD *)a1, (uint64_t)a2);
    }
  }
  return a1;
}

uint64_t re::DynamicArray<re::GeomIndexMap>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  unint64_t v5;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  v3 = *a2;
  if (*a2)
  {
    v5 = a2[2];
    *(_QWORD *)a1 = v3;
    re::DynamicArray<re::GeomIndexMap>::setCapacity((_QWORD *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::GeomIndexMap>::copy((_QWORD *)a1, (uint64_t)a2);
  }
  return a1;
}

void re::DynamicArray<re::GeomIndexMap>::copy(_QWORD *a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _DWORD *v21;
  int v22;

  v4 = *(_QWORD *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<re::GeomIndexMap>::setCapacity(a1, *(_QWORD *)(a2 + 16));
    std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::GeomIndexMap *,re::GeomIndexMap *,re::GeomIndexMap *,0>(*(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 32) + 80 * a1[2], a1[4]);
    v14 = a1[2];
    if (v14 != v4)
    {
      v15 = *(_QWORD *)(a2 + 32);
      v16 = v15 + 80 * v4;
      v17 = a1[4];
      v18 = 80 * v14;
      do
      {
        v19 = v15 + v18;
        v20 = v17 + v18;
        *(_QWORD *)v20 = *(_QWORD *)(v15 + v18);
        *(_DWORD *)(v20 + 8) = *(_DWORD *)(v15 + v18 + 8);
        *(_BYTE *)(v20 + 12) = *(_BYTE *)(v15 + v18 + 12);
        v21 = (_DWORD *)(v17 + v18 + 16);
        v22 = *(unsigned __int8 *)(v15 + v18 + 12);
        if (v22 == 2)
        {
          re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::HashBrown((uint64_t)v21, (uint64_t *)(v19 + 16));
        }
        else if (v22 == 1)
        {
          re::DynamicArray<float>::DynamicArray((uint64_t)v21, (uint64_t *)(v15 + v18 + 16));
        }
        else
        {
          if (*(_BYTE *)(v15 + v18 + 12))
            goto LABEL_26;
          *v21 = *(_DWORD *)(v15 + v18 + 16);
        }
        v15 += 80;
        v17 += 80;
      }
      while (v19 + 80 != v16);
    }
    goto LABEL_24;
  }
  std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::GeomIndexMap *,re::GeomIndexMap *,re::GeomIndexMap *,0>(*(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 32) + 80 * v4, a1[4]);
  v6 = a1[2];
  if (v4 == v6)
  {
LABEL_24:
    a1[2] = v4;
    return;
  }
  v7 = a1[4];
  v8 = 80 * v4;
  v9 = 80 * v6;
  while (1)
  {
    v10 = *(unsigned __int8 *)(v7 + v8 + 12);
    if (v10 == 2)
    {
      re::HashBrown<unsigned long long,re::Pair<void const*,void const*,true>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit(v7 + v8 + 16);
      goto LABEL_13;
    }
    if (v10 == 1)
    {
      v11 = v7 + v8;
      v12 = *(_QWORD *)(v7 + v8 + 16);
      if (v12)
      {
        v5 = *(_QWORD *)(v11 + 48);
        if (v5)
          (*(void (**)(uint64_t))(*(_QWORD *)v12 + 40))(v12);
        *(_QWORD *)(v11 + 48) = 0;
        *(_QWORD *)(v7 + v8 + 24) = 0;
        *(_QWORD *)(v7 + v8 + 32) = 0;
        *(_QWORD *)(v7 + v8 + 16) = 0;
        ++*(_DWORD *)(v7 + v8 + 40);
      }
      goto LABEL_13;
    }
    if (*(_BYTE *)(v7 + v8 + 12))
      break;
    *(_DWORD *)(v7 + v8 + 16) = 0;
LABEL_13:
    v9 -= 80;
    v7 += 80;
    if (v8 == v9)
      goto LABEL_24;
  }
  re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "~GeomIndexMap", 625);
  _os_crash();
  __break(1u);
LABEL_26:
  re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "GeomIndexMap", 433);
  _os_crash();
  __break(1u);
}

_QWORD *re::DynamicArray<re::GeomIndexMap>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::GeomIndexMap>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (!a2)
      {
        v7 = 0;
        if (!v3)
        {
LABEL_25:
          v5[4] = v7;
          v5[1] = a2;
          return result;
        }
LABEL_11:
        v8 = v5[4];
        v9 = v5[2];
        if (v9)
        {
          v10 = 0;
          v11 = 80 * v9;
          do
          {
            re::GeomIndexMap::GeomIndexMap((uint64_t)&v7[v10 / 8], v8 + v10);
            v13 = *(unsigned __int8 *)(v8 + v10 + 12);
            if (v13 == 2)
            {
              re::HashBrown<unsigned long long,re::Pair<void const*,void const*,true>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit(v8 + v10 + 16);
            }
            else if (v13 == 1)
            {
              v14 = v8 + v10;
              v15 = *(_QWORD *)(v8 + v10 + 16);
              if (v15)
              {
                if (*(_QWORD *)(v14 + 48))
                  (*(void (**)(uint64_t))(*(_QWORD *)v15 + 40))(v15);
                *(_QWORD *)(v14 + 48) = 0;
                *(_QWORD *)(v8 + v10 + 24) = 0;
                *(_QWORD *)(v8 + v10 + 32) = 0;
                *(_QWORD *)(v8 + v10 + 16) = 0;
                ++*(_DWORD *)(v8 + v10 + 40);
              }
            }
            else
            {
              if (*(_BYTE *)(v8 + v10 + 12))
                goto LABEL_29;
              *(_DWORD *)(v8 + v10 + 16) = 0;
            }
            v10 += 80;
          }
          while (v11 != v10);
          v8 = v5[4];
        }
        result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 40))(*v5, v8);
        goto LABEL_25;
      }
      if (is_mul_ok(a2, 0x50uLL))
      {
        v2 = 80 * a2;
        result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 80 * a2, 8);
        if (result)
        {
          v7 = result;
          if (!v5[1])
            goto LABEL_25;
          goto LABEL_11;
        }
      }
      else
      {
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 80, a2);
        _os_crash();
        __break(1u);
      }
      re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
      _os_crash();
      __break(1u);
LABEL_29:
      re::internal::assertLog((re::internal *)4, v12, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "~GeomIndexMap", 625);
      result = (_QWORD *)_os_crash();
      __break(1u);
    }
  }
  return result;
}

uint64_t re::GeomIndexMap::GeomIndexMap(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t result;
  unint64_t v14;
  unint64_t v15;
  __int128 v16;
  unint64_t v17;
  unint64_t v18;
  __int128 v19;
  unint64_t v20;
  __int128 v21;

  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(_BYTE *)(a1 + 12) = *(_BYTE *)(a2 + 12);
  v4 = a1 + 16;
  v5 = *(unsigned __int8 *)(a2 + 12);
  if (v5 == 2)
  {
LABEL_8:
    *(_OWORD *)(v4 + 32) = 0u;
    *(_OWORD *)(v4 + 48) = 0u;
    *(_OWORD *)v4 = 0u;
    *(_OWORD *)(v4 + 16) = 0u;
    re::HashBrown<re::WeakStringID,unsigned char,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<unsigned char>,false>::swap((uint64_t *)v4, (uint64_t *)(a2 + 16));
    *(_QWORD *)a2 = 0xFFFFFFFF00000000;
    *(_DWORD *)(a2 + 8) = -1;
    v8 = *(unsigned __int8 *)(a2 + 12);
    if (v8 == 2)
    {
      *(_QWORD *)(a2 + 56) = 0;
      *(_QWORD *)(a2 + 64) = 0;
      v17 = *(_QWORD *)(a2 + 32);
      *(_QWORD *)(a2 + 40) = 0;
      *(_QWORD *)(a2 + 48) = v17;
      if (v17 >= 0x10)
      {
        v18 = 0;
        *(_QWORD *)&v19 = -1;
        *((_QWORD *)&v19 + 1) = -1;
        do
          *(_OWORD *)(*(_QWORD *)(a2 + 16) + 16 * v18++) = v19;
        while (v18 < *(_QWORD *)(a2 + 32) >> 4);
      }
      return a1;
    }
    if (v8 != 1)
    {
      if (!*(_BYTE *)(a2 + 12))
      {
        *(_DWORD *)(a2 + 16) = 0;
        return a1;
      }
      goto LABEL_31;
    }
    goto LABEL_16;
  }
  if (v5 != 1)
  {
    if (*(_BYTE *)(a2 + 12))
    {
      re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "GeomIndexMap", 461);
      _os_crash();
      __break(1u);
LABEL_31:
      re::internal::assertLog((re::internal *)4, v7, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "reset", 398);
      _os_crash();
      __break(1u);
      goto LABEL_32;
    }
    *(_DWORD *)v4 = *(_DWORD *)(a2 + 16);
    *(_QWORD *)a2 = 0xFFFFFFFF00000000;
    *(_DWORD *)(a2 + 8) = -1;
    v6 = *(unsigned __int8 *)(a2 + 12);
    if (v6 == 2)
    {
      *(_QWORD *)(a2 + 56) = 0;
      *(_QWORD *)(a2 + 64) = 0;
      v14 = *(_QWORD *)(a2 + 32);
      *(_QWORD *)(a2 + 40) = 0;
      *(_QWORD *)(a2 + 48) = v14;
      if (v14 >= 0x10)
      {
        v15 = 0;
        *(_QWORD *)&v16 = -1;
        *((_QWORD *)&v16 + 1) = -1;
        do
          *(_OWORD *)(*(_QWORD *)(a2 + 16) + 16 * v15++) = v16;
        while (v15 < *(_QWORD *)(a2 + 32) >> 4);
      }
      return a1;
    }
    if (v6 == 1)
    {
LABEL_16:
      *(_QWORD *)(a2 + 32) = 0;
      ++*(_DWORD *)(a2 + 40);
      return a1;
    }
    if (*(_BYTE *)(a2 + 12))
    {
      re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "reset", 398);
      v4 = _os_crash();
      __break(1u);
      goto LABEL_8;
    }
LABEL_15:
    *(_DWORD *)(a2 + 16) = 0;
    return a1;
  }
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(v4 + 8) = 0;
  *(_QWORD *)(v4 + 16) = 0;
  *(_QWORD *)v4 = 0;
  *(_DWORD *)(v4 + 24) = 0;
  v9 = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 24) = v9;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)(a2 + 24) = 0;
  v10 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 32) = v10;
  v11 = *(_QWORD *)(a1 + 48);
  *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 48) = v11;
  ++*(_DWORD *)(a2 + 40);
  ++*(_DWORD *)(a1 + 40);
  *(_QWORD *)a2 = 0xFFFFFFFF00000000;
  *(_DWORD *)(a2 + 8) = -1;
  v12 = *(unsigned __int8 *)(a2 + 12);
  if (v12 == 2)
  {
    *(_QWORD *)(a2 + 56) = 0;
    *(_QWORD *)(a2 + 64) = 0;
    *(_QWORD *)(a2 + 40) = 0;
    *(_QWORD *)(a2 + 48) = v10;
    if (v10 >= 0x10)
    {
      v20 = 0;
      *(_QWORD *)&v21 = -1;
      *((_QWORD *)&v21 + 1) = -1;
      do
        *(_OWORD *)(*(_QWORD *)(a2 + 16) + 16 * v20++) = v21;
      while (v20 < *(_QWORD *)(a2 + 32) >> 4);
    }
    return a1;
  }
  if (v12 == 1)
    goto LABEL_16;
  if (!*(_BYTE *)(a2 + 12))
    goto LABEL_15;
LABEL_32:
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "reset", 398);
  result = _os_crash();
  __break(1u);
  return result;
}

{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  char v13;
  uint64_t v14;
  int v15;
  uint64_t v17;
  uint64_t v18;

  *(_QWORD *)(a1 + 4) = -1;
  *(_BYTE *)(a1 + 12) = 1;
  v4 = *(_QWORD *)(a2 + 16);
  if (!(_DWORD)v4)
    goto LABEL_20;
  v5 = 0;
  v6 = (_QWORD *)(a1 + 16);
  v7 = *(_QWORD *)(a2 + 32);
  v8 = -1;
  v9 = -1;
  do
  {
    if (v4 == v5)
    {
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    if (*(_DWORD *)(v7 + 4 * v5) != -1)
    {
      *(_DWORD *)(a1 + 8) = v5;
      if (v9 == -1)
      {
        *(_DWORD *)(a1 + 4) = v5;
        v8 = v5;
        v9 = v5;
      }
      else
      {
        v8 = v5;
      }
    }
    ++v5;
  }
  while (v4 != v5);
  if (v8 == -1)
  {
LABEL_20:
    *(_QWORD *)(a2 + 16) = 0;
    ++*(_DWORD *)(a2 + 24);
    goto LABEL_21;
  }
  re::DynamicArray<float>::resize(a2, (v8 + 1));
  v10 = *(_QWORD *)(a2 + 16);
  if (!(_DWORD)v10)
  {
LABEL_21:
    *(_DWORD *)a1 = 0;
    *(_BYTE *)(a1 + 12) = 0;
LABEL_22:
    *(_QWORD *)(a1 + 4) = -1;
    *(_DWORD *)(a1 + 16) = 0;
    return a1;
  }
  v11 = 0;
  v12 = 0;
  v13 = 1;
  do
  {
    v14 = *(unsigned int *)(*(_QWORD *)(a2 + 32) + 4 * v11);
    v13 &= v11 == v14;
    if (v14 == 0xFFFFFFFFLL)
      ++v12;
    ++v11;
  }
  while (*(_QWORD *)(a2 + 16) != v11);
  v15 = v10 - v12;
  if (*(_DWORD *)(a1 + 4) == -1)
    v15 = 0;
  *(_DWORD *)a1 = v15;
  if ((v13 & 1) == 0)
  {
    *(_QWORD *)(a1 + 48) = 0;
    *(_QWORD *)(a1 + 24) = 0;
    *(_QWORD *)(a1 + 32) = 0;
    *v6 = 0;
    *(_DWORD *)(a1 + 40) = 0;
    *(_QWORD *)(a1 + 16) = *(_QWORD *)a2;
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 8);
    *(_QWORD *)(a2 + 8) = 0;
    v17 = *(_QWORD *)(a1 + 32);
    *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 16);
    *(_QWORD *)(a2 + 16) = v17;
    v18 = *(_QWORD *)(a1 + 48);
    *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 32);
    *(_QWORD *)(a2 + 32) = v18;
    ++*(_DWORD *)(a2 + 24);
    ++*(_DWORD *)(a1 + 40);
    return a1;
  }
  *(_BYTE *)(a1 + 12) = 0;
  if (!v15)
    goto LABEL_22;
  *(_DWORD *)v6 = v15;
  return a1;
}

uint64_t std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::GeomIndexMap *,re::GeomIndexMap *,re::GeomIndexMap *,0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a1;
  if (a1 != a2)
  {
    do
    {
      re::GeomIndexMap::operator=(a3, v4);
      v4 += 80;
      a3 += 80;
    }
    while (v4 != a2);
    return a2;
  }
  return v4;
}

uint64_t re::GeomIndexMap::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  int v4;
  uint64_t v5;
  int v6;
  uint64_t result;

  if (a2 == a1)
    return a1;
  v3 = a2;
  v4 = *(unsigned __int8 *)(a1 + 12);
  if (v4 == 2)
  {
    re::HashBrown<unsigned long long,re::Pair<void const*,void const*,true>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit(a1 + 16);
  }
  else if (v4 == 1)
  {
    v5 = *(_QWORD *)(a1 + 16);
    if (v5)
    {
      a2 = *(_QWORD *)(a1 + 48);
      if (a2)
        (*(void (**)(uint64_t))(*(_QWORD *)v5 + 40))(v5);
      *(_QWORD *)(a1 + 48) = 0;
      *(_QWORD *)(a1 + 24) = 0;
      *(_QWORD *)(a1 + 32) = 0;
      *(_QWORD *)(a1 + 16) = 0;
      ++*(_DWORD *)(a1 + 40);
    }
  }
  else
  {
    if (*(_BYTE *)(a1 + 12))
    {
      re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "operator=", 810);
      _os_crash();
      __break(1u);
      goto LABEL_19;
    }
    *(_DWORD *)(a1 + 16) = 0;
  }
  *(_BYTE *)(a1 + 12) = *(_BYTE *)(v3 + 12);
  *(_QWORD *)a1 = *(_QWORD *)v3;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(v3 + 8);
  v6 = *(unsigned __int8 *)(v3 + 12);
  if (v6 == 2)
  {
    re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::HashBrown(a1 + 16, (uint64_t *)(v3 + 16));
    return a1;
  }
  if (v6 == 1)
  {
    re::DynamicArray<float>::DynamicArray(a1 + 16, (uint64_t *)(v3 + 16));
    return a1;
  }
  if (!*(_BYTE *)(v3 + 12))
  {
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(v3 + 16);
    return a1;
  }
LABEL_19:
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "operator=", 833);
  result = _os_crash();
  __break(1u);
  return result;
}

{
  uint64_t v3;
  int v4;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t result;
  unint64_t v15;
  unint64_t v16;
  __int128 v17;
  unint64_t v18;
  unint64_t v19;
  __int128 v20;
  unint64_t v21;
  __int128 v22;

  if (a2 == a1)
    return a1;
  v3 = a2;
  v4 = *(unsigned __int8 *)(a1 + 12);
  if (v4 == 2)
  {
    re::HashBrown<unsigned long long,re::Pair<void const*,void const*,true>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit(a1 + 16);
  }
  else if (v4 == 1)
  {
    v5 = *(_QWORD *)(a1 + 16);
    if (v5)
    {
      a2 = *(_QWORD *)(a1 + 48);
      if (a2)
        (*(void (**)(uint64_t))(*(_QWORD *)v5 + 40))(v5);
      *(_QWORD *)(a1 + 48) = 0;
      *(_QWORD *)(a1 + 24) = 0;
      *(_QWORD *)(a1 + 32) = 0;
      *(_QWORD *)(a1 + 16) = 0;
      ++*(_DWORD *)(a1 + 40);
    }
  }
  else
  {
    if (*(_BYTE *)(a1 + 12))
    {
      re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "operator=", 859);
      _os_crash();
      __break(1u);
      goto LABEL_41;
    }
    *(_DWORD *)(a1 + 16) = 0;
  }
  *(_BYTE *)(a1 + 12) = *(_BYTE *)(v3 + 12);
  *(_QWORD *)a1 = *(_QWORD *)v3;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(v3 + 8);
  v6 = *(unsigned __int8 *)(v3 + 12);
  if (v6 == 2)
    goto LABEL_18;
  if (v6 != 1)
  {
    if (!*(_BYTE *)(v3 + 12))
    {
      *(_DWORD *)(a1 + 16) = *(_DWORD *)(v3 + 16);
      *(_QWORD *)v3 = 0xFFFFFFFF00000000;
      *(_DWORD *)(v3 + 8) = -1;
      v7 = *(unsigned __int8 *)(v3 + 12);
      if (v7 == 2)
      {
        *(_QWORD *)(v3 + 56) = 0;
        *(_QWORD *)(v3 + 64) = 0;
        v15 = *(_QWORD *)(v3 + 32);
        *(_QWORD *)(v3 + 40) = 0;
        *(_QWORD *)(v3 + 48) = v15;
        if (v15 >= 0x10)
        {
          v16 = 0;
          *(_QWORD *)&v17 = -1;
          *((_QWORD *)&v17 + 1) = -1;
          do
            *(_OWORD *)(*(_QWORD *)(v3 + 16) + 16 * v16++) = v17;
          while (v16 < *(_QWORD *)(v3 + 32) >> 4);
        }
        return a1;
      }
      if (v7 == 1)
        goto LABEL_26;
      if (*(_BYTE *)(v3 + 12))
      {
        re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "reset", 398);
        _os_crash();
        __break(1u);
LABEL_18:
        *(_OWORD *)(a1 + 16) = 0u;
        *(_OWORD *)(a1 + 48) = 0u;
        *(_OWORD *)(a1 + 64) = 0u;
        *(_OWORD *)(a1 + 32) = 0u;
        re::HashBrown<re::WeakStringID,unsigned char,re::Hash<re::WeakStringID>,re::EqualTo<re::WeakStringID>,re::Hash<unsigned char>,false>::swap((uint64_t *)(a1 + 16), (uint64_t *)(v3 + 16));
        *(_QWORD *)v3 = 0xFFFFFFFF00000000;
        *(_DWORD *)(v3 + 8) = -1;
        v9 = *(unsigned __int8 *)(v3 + 12);
        if (v9 == 2)
        {
          *(_QWORD *)(v3 + 56) = 0;
          *(_QWORD *)(v3 + 64) = 0;
          v18 = *(_QWORD *)(v3 + 32);
          *(_QWORD *)(v3 + 40) = 0;
          *(_QWORD *)(v3 + 48) = v18;
          if (v18 >= 0x10)
          {
            v19 = 0;
            *(_QWORD *)&v20 = -1;
            *((_QWORD *)&v20 + 1) = -1;
            do
              *(_OWORD *)(*(_QWORD *)(v3 + 16) + 16 * v19++) = v20;
            while (v19 < *(_QWORD *)(v3 + 32) >> 4);
          }
          return a1;
        }
        if (v9 != 1)
        {
          if (!*(_BYTE *)(v3 + 12))
          {
            *(_DWORD *)(v3 + 16) = 0;
            return a1;
          }
          goto LABEL_42;
        }
LABEL_26:
        *(_QWORD *)(v3 + 32) = 0;
        ++*(_DWORD *)(v3 + 40);
        return a1;
      }
LABEL_25:
      *(_DWORD *)(v3 + 16) = 0;
      return a1;
    }
LABEL_41:
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "operator=", 885);
    _os_crash();
    __break(1u);
LABEL_42:
    re::internal::assertLog((re::internal *)4, v8, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "reset", 398);
    _os_crash();
    __break(1u);
    goto LABEL_43;
  }
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  v10 = *(_QWORD *)(v3 + 24);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(v3 + 16);
  *(_QWORD *)(a1 + 24) = v10;
  *(_QWORD *)(v3 + 16) = 0;
  *(_QWORD *)(v3 + 24) = 0;
  v11 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(v3 + 32);
  *(_QWORD *)(v3 + 32) = v11;
  v12 = *(_QWORD *)(a1 + 48);
  *(_QWORD *)(a1 + 48) = *(_QWORD *)(v3 + 48);
  *(_QWORD *)(v3 + 48) = v12;
  ++*(_DWORD *)(v3 + 40);
  ++*(_DWORD *)(a1 + 40);
  *(_QWORD *)v3 = 0xFFFFFFFF00000000;
  *(_DWORD *)(v3 + 8) = -1;
  v13 = *(unsigned __int8 *)(v3 + 12);
  if (v13 == 2)
  {
    *(_QWORD *)(v3 + 56) = 0;
    *(_QWORD *)(v3 + 64) = 0;
    *(_QWORD *)(v3 + 40) = 0;
    *(_QWORD *)(v3 + 48) = v11;
    if (v11 >= 0x10)
    {
      v21 = 0;
      *(_QWORD *)&v22 = -1;
      *((_QWORD *)&v22 + 1) = -1;
      do
        *(_OWORD *)(*(_QWORD *)(v3 + 16) + 16 * v21++) = v22;
      while (v21 < *(_QWORD *)(v3 + 32) >> 4);
    }
    return a1;
  }
  if (v13 == 1)
    goto LABEL_26;
  if (!*(_BYTE *)(v3 + 12))
    goto LABEL_25;
LABEL_43:
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "reset", 398);
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::HashBrown(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;

  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  v4 = a2[7];
  if (v4)
  {
    re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::init((uint64_t *)a1, v4, a2[3]);
    re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::copy((_anonymous_namespace_ *)a1, a2);
  }
  return a1;
}

void re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::init(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __int128 v9;
  void *v10;
  uint64_t v11;

  a1[7] = a2;
  v4 = 151 * a3;
  v5 = ((unint64_t)(151 * a3) >> 7) + 15;
  a1[2] = v5 & 0x3FFFFFFFFFFFFF0;
  if ((v5 & 0x3FFFFFFFFFFFFF0) != 0)
  {
    v6 = v5 >> 4;
    v7 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 9 * (v5 & 0x3FFFFFFFFFFFFF0), 16);
    *a1 = v7;
    if (v4 >= 0x80)
    {
      v8 = 0;
      *(_QWORD *)&v9 = -1;
      *((_QWORD *)&v9 + 1) = -1;
      do
        *(_OWORD *)(*a1 + 16 * v8++) = v9;
      while (v6 != v8);
      v7 = *a1;
    }
    v10 = (void *)(v7 + 16 * v6);
    a1[1] = (uint64_t)v10;
    v11 = a1[2];
    if (v11)
      bzero(v10, 8 * v11);
  }
  else
  {
    v11 = 0;
    *a1 = 0;
    a1[1] = 0;
  }
  a1[5] = 0;
  a1[6] = 0;
  a1[3] = 0;
  a1[4] = v11;
}

_anonymous_namespace_ *re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::copy(_anonymous_namespace_ *result, uint64_t *a2)
{
  _anonymous_namespace_ *v2;
  unint64_t v3;
  unint64_t v4;
  __int128 v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unsigned __int16 v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD v13[2];
  uint64_t i;

  v2 = result;
  *((_QWORD *)result + 5) = 0;
  *((_QWORD *)result + 6) = 0;
  v3 = *((_QWORD *)result + 2);
  *((_QWORD *)result + 3) = 0;
  *((_QWORD *)result + 4) = v3;
  if (v3 >= 0x10)
  {
    v4 = 0;
    *(_QWORD *)&v5 = -1;
    *((_QWORD *)&v5 + 1) = -1;
    do
      *(_OWORD *)(*(_QWORD *)result + 16 * v4++) = v5;
    while (v4 < *((_QWORD *)result + 2) >> 4);
  }
  v13[0] = a2;
  v6 = a2[2];
  if (v6 >= 0x10)
  {
    v7 = 0;
    v8 = *a2;
    v9 = v6 >> 4;
    while (1)
    {
      v10 = vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vcltzq_s8(*(int8x16_t *)(v8 + v7)), (int8x16_t)xmmword_2260EE390)))), (int8x8_t)0x3830282018100800).u16[0];
      v13[1] = (unsigned __int16)~v10;
      if (v10 != 0xFFFF)
        break;
      v7 += 16;
      if (!--v9)
        return result;
    }
    v11 = __clz(__rbit64((unsigned __int16)~v10)) + v7;
    for (i = v11; i != -1; v11 = i)
    {
      v12 = *(_QWORD *)(*(_QWORD *)(v13[0] + 8) + 8 * v11);
      re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::internalAdd(v2, (unsigned int *)&v12, (unsigned int *)&v12 + 1);
      result = (_anonymous_namespace_ *)re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::HashBrownIterator<re::KeyValuePair<unsigned long long const&,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>&>>::operator++(v13);
    }
  }
  return result;
}

_DWORD *re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::internalAdd(_anonymous_namespace_ *a1, unsigned int *a2, unsigned int *a3)
{
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  _BOOL8 v17;
  unint64_t v18;
  uint64_t v19;
  unsigned int *v20;
  _DWORD *result;
  unsigned int v22;
  unint64_t v23;

  if (!*((_QWORD *)a1 + 7))
  {
  }
  v6 = *((_QWORD *)a1 + 4);
  if (!v6 || (v7 = *((_QWORD *)a1 + 2), v7 > 8 * v6))
  {
    re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::resize((uint64_t *)a1, 1);
    v7 = *((_QWORD *)a1 + 2);
  }
  v8 = 0xBF58476D1CE4E5B9;
  v9 = 0x94D049BB133111EBLL;
  v10 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v11 = (0x94D049BB133111EBLL * (v10 ^ (v10 >> 27))) ^ ((0x94D049BB133111EBLL * (v10 ^ (v10 >> 27))) >> 31);
  v12 = v7 >> 4;
  v13 = *(_QWORD *)a1;
  v14 = v11 % v12;
  while (1)
  {
    v15 = __clz(__rbit64(*(_QWORD *)&vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vcltzq_s8(*(int8x16_t *)(v13 + 16 * v14)), (int8x16_t)xmmword_2260EE390)))), (int8x8_t)0x3830282018100800)));
    if (v15 < 0x40)
      break;
    if (v14 + 1 == v12)
      v14 = 0;
    else
      ++v14;
    if (v14 == v11 % v12)
    {
      re::internal::assertLog((re::internal *)4, (uint64_t)a2, -1.79399301e-307, 4.74803907e-38, "assertion failure: '%s' (%s:line %i) Unexpected full hash-table", "blockIndex != h1(key) % blockCount()", "internalAdd", 656);
      _os_crash();
      __break(1u);
      break;
    }
  }
  v16 = v13 + 16 * v14;
  v17 = *(unsigned __int8 *)(v16 + v15) == 255;
  *(_BYTE *)(v16 + v15) = v11 & 0x7F;
  v18 = v15 + 16 * v14;
  *(_QWORD *)(*((_QWORD *)a1 + 1) + 8 * v18) = *a2 | ((unint64_t)*a3 << 32);
  v19 = *((_QWORD *)a1 + 4) - v17;
  ++*((_QWORD *)a1 + 3);
  *((_QWORD *)a1 + 4) = v19;
  v20 = (unsigned int *)(*((_QWORD *)a1 + 1) + 8 * v18);
  v22 = *v20;
  result = v20 + 1;
  v23 = (((v22 ^ ((unint64_t)v22 >> 30)) * v8) ^ (((v22 ^ ((unint64_t)v22 >> 30)) * v8) >> 27)) * v9;
  *((_QWORD *)a1 + 5) ^= (v23 >> 31) ^ v23;
  return result;
}

{
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  _BOOL8 v15;
  unint64_t v16;
  uint64_t v17;
  unsigned int *v18;
  _DWORD *result;
  unsigned int v20;
  unint64_t v21;

  if (!*((_QWORD *)a1 + 7))
  {
  }
  v6 = *((_QWORD *)a1 + 4);
  if (!v6 || (v7 = *((_QWORD *)a1 + 2), v7 > 8 * v6))
  {
    re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::resize(a1, 1);
    v7 = *((_QWORD *)a1 + 2);
  }
  v8 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v9 = (0x94D049BB133111EBLL * (v8 ^ (v8 >> 27))) ^ ((0x94D049BB133111EBLL * (v8 ^ (v8 >> 27))) >> 31);
  v10 = v7 >> 4;
  v11 = v9 % (v7 >> 4);
  v12 = *(_QWORD *)a1;
  v13 = __clz(__rbit64(*(_QWORD *)&vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vcltzq_s8(*(int8x16_t *)(*(_QWORD *)a1 + 16 * v11)), (int8x16_t)xmmword_2260EE390)))), (int8x8_t)0x3830282018100800)));
  if (v13 >= 0x40)
  {
    do
    {
      if (v11 + 1 == v10)
        v11 = 0;
      else
        ++v11;
      v13 = __clz(__rbit64(*(_QWORD *)&vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vcltzq_s8(*(int8x16_t *)(v12 + 16 * v11)), (int8x16_t)xmmword_2260EE390)))), (int8x8_t)0x3830282018100800)));
    }
    while (v13 > 0x3F);
  }
  v14 = v12 + 16 * v11;
  v15 = *(unsigned __int8 *)(v14 + v13) == 255;
  *(_BYTE *)(v14 + v13) = v9 & 0x7F;
  v16 = v13 + 16 * v11;
  *(_QWORD *)(*((_QWORD *)a1 + 1) + 8 * v16) = *a2 | ((unint64_t)*a3 << 32);
  v17 = *((_QWORD *)a1 + 4) - v15;
  ++*((_QWORD *)a1 + 3);
  *((_QWORD *)a1 + 4) = v17;
  v18 = (unsigned int *)(*((_QWORD *)a1 + 1) + 8 * v16);
  v20 = *v18;
  result = v18 + 1;
  v21 = 0x94D049BB133111EBLL
      * ((0xBF58476D1CE4E5B9 * (v20 ^ ((unint64_t)v20 >> 30))) ^ ((0xBF58476D1CE4E5B9
                                                                          * (v20 ^ ((unint64_t)v20 >> 30))) >> 27));
  *((_QWORD *)a1 + 5) ^= (v21 >> 31) ^ v21;
  return result;
}

uint64_t **re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::HashBrownIterator<re::KeyValuePair<unsigned int,unsigned int> const&>::HashBrownIterator(uint64_t **result, uint64_t *a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unsigned __int16 v6;
  unint64_t v7;
  uint64_t v8;

  *result = a2;
  result[1] = 0;
  v2 = a2[2];
  if (v2 < 0x10)
  {
LABEL_5:
    v8 = -1;
  }
  else
  {
    v3 = 0;
    v4 = *a2;
    v5 = v2 >> 4;
    while (1)
    {
      v6 = vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vcltzq_s8(*(int8x16_t *)(v4 + v3)), (int8x16_t)xmmword_2260EE390)))), (int8x8_t)0x3830282018100800).u16[0];
      v7 = (unsigned __int16)~v6;
      result[1] = (uint64_t *)v7;
      if (v6 != 0xFFFF)
        break;
      v3 += 16;
      if (!--v5)
        goto LABEL_5;
    }
    v8 = __clz(__rbit64(v7)) + v3;
  }
  result[2] = (uint64_t *)v8;
  return result;
}

uint64_t re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::resize(uint64_t *a1, int a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;

  v2 = a1[2];
  v3 = a1[3] + a2;
  v4 = (((151 * v3) >> 7) + 15) & 0x3FFFFFFFFFFFFF0;
  if (v4 > v2)
  {
    v5 = 3 * v2;
    v6 = v5 << 6;
    v7 = (v5 >> 1) & 0x1FFFFFFFFFFFFFFLL;
    if (v4 <= v6 >> 7)
      v4 = v7;
    v3 = (v4 << 7) / 0x97;
  }
  return re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::doResize(a1, v3);
}

uint64_t re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::doResize(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unsigned __int16 v9;
  uint64_t v10;
  uint64_t result;
  uint64_t v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  _QWORD v20[2];
  uint64_t v21;
  _OWORD v22[4];

  v4 = a1[7];
  memset(v22, 0, sizeof(v22));
  re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::init((uint64_t *)v22, v4, a2);
  v20[0] = a1;
  v5 = a1[2];
  if (v5 >= 0x10)
  {
    v6 = 0;
    v7 = *a1;
    v8 = v5 >> 4;
    while (1)
    {
      v9 = vqtbl1_s8((int8x16_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vandq_s8(vcltzq_s8(*(int8x16_t *)(v7 + v6)), (int8x16_t)xmmword_2260EE390)))), (int8x8_t)0x3830282018100800).u16[0];
      v20[1] = (unsigned __int16)~v9;
      if (v9 != 0xFFFF)
        break;
      v6 += 16;
      if (!--v8)
        goto LABEL_9;
    }
    v10 = __clz(__rbit64((unsigned __int16)~v9)) + v6;
    v21 = v10;
    if (v10 != -1)
    {
      do
      {
        re::HashBrown<unsigned int,unsigned int,re::Hash<unsigned int>,re::EqualTo<unsigned int>,void,false>::internalAdd((_anonymous_namespace_ *)v22, (unsigned int *)(*(_QWORD *)(v20[0] + 8) + 8 * v10), (unsigned int *)(*(_QWORD *)(v20[0] + 8) + 8 * v10 + 4));
        re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::HashBrownIterator<re::KeyValuePair<unsigned long long const&,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>&>>::operator++(v20);
        v10 = v21;
      }
      while (v21 != -1);
      v5 = a1[2];
    }
  }
LABEL_9:
  v12 = *((_QWORD *)&v22[3] + 1);
  *((_QWORD *)&v22[3] + 1) = a1[7];
  result = *((_QWORD *)&v22[3] + 1);
  v13 = v22[0];
  v14 = v22[1];
  *(_QWORD *)&v22[1] = v5;
  v15 = *a1;
  v16 = a1[1];
  *(_QWORD *)&v22[0] = *a1;
  *((_QWORD *)&v22[0] + 1) = v16;
  v17 = v22[2];
  v18 = *(_OWORD *)(a1 + 5);
  a1[6] = *(_QWORD *)&v22[3];
  a1[7] = v12;
  *(_OWORD *)((char *)&v22[2] + 8) = v18;
  v19 = *(_OWORD *)(a1 + 3);
  *(_OWORD *)a1 = v13;
  *((_OWORD *)a1 + 1) = v14;
  *((_OWORD *)a1 + 2) = v17;
  *(_OWORD *)((char *)&v22[1] + 8) = v19;
  if (result)
  {
    if (v16)
      *((_QWORD *)&v22[0] + 1) = 0;
    if (v15)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
  }
  return result;
}

void re::DynamicArray<re::GeomIndexMap>::clear(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  int v6;
  uint64_t v7;

  v3 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (!v3)
  {
LABEL_13:
    ++*(_DWORD *)(a1 + 24);
    return;
  }
  v4 = 80 * v3;
  v5 = (uint64_t *)(*(_QWORD *)(a1 + 32) + 48);
  while (1)
  {
    v6 = *((unsigned __int8 *)v5 - 36);
    if (v6 == 2)
    {
      re::HashBrown<unsigned long long,re::Pair<void const*,void const*,true>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::deinit((uint64_t)(v5 - 4));
      goto LABEL_12;
    }
    if (v6 == 1)
    {
      v7 = *(v5 - 4);
      if (v7)
      {
        a2 = *v5;
        if (*v5)
          (*(void (**)(uint64_t))(*(_QWORD *)v7 + 40))(v7);
        *v5 = 0;
        *(v5 - 3) = 0;
        *(v5 - 2) = 0;
        *(v5 - 4) = 0;
        ++*((_DWORD *)v5 - 2);
      }
      goto LABEL_12;
    }
    if (*((_BYTE *)v5 - 36))
      break;
    *((_DWORD *)v5 - 8) = 0;
LABEL_12:
    v5 += 10;
    v4 -= 80;
    if (!v4)
      goto LABEL_13;
  }
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Invalid mapping type -- indicative of a use after free or memory corruption", "!\"Unreachable code\"", "~GeomIndexMap", 625);
  _os_crash();
  __break(1u);
}

void re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::copy(_QWORD *a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v4 = *(_QWORD *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::setCapacity(a1, *(_QWORD *)(a2 + 16));
    std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false> *,re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false> *,re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false> *,0>(*(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 32) + 48 * a1[2], a1[4]);
    v8 = a1[2];
    if (v8 != v4)
    {
      v9 = 3 * v8;
      v10 = *(_QWORD *)(a2 + 32) + 16 * v9;
      v11 = a1[4] + 16 * v9;
      v12 = 48 * v4 - 16 * v9;
      do
      {
        v13 = re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::HashTable(v11, v10);
        v10 += 48;
        v11 = v13 + 48;
        v12 -= 48;
      }
      while (v12);
    }
  }
  else
  {
    std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false> *,re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false> *,re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false> *,0>(*(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 32) + 48 * v4, a1[4]);
    v5 = a1[2];
    if (v4 != v5)
    {
      v6 = (uint64_t *)(a1[4] + 48 * v4);
      v7 = 48 * v5 - 48 * v4;
      do
      {
        re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v6);
        v6 += 6;
        v7 -= 48;
      }
      while (v7);
    }
  }
  a1[2] = v4;
}

void re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
  {
    v3 = *(uint64_t **)(a1 + 32);
    v4 = 48 * v2;
    do
    {
      re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v3);
      v3 += 6;
      v4 -= 48;
    }
    while (v4);
  }
  ++*(_DWORD *)(a1 + 24);
}

_QWORD *re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x30uLL))
        {
          v2 = 48 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 48 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_16;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 48, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = (uint64_t *)v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = 48 * v9;
        v11 = v7;
        do
        {
          *((_DWORD *)v11 + 8) = 0;
          *(_OWORD *)v11 = 0u;
          *((_OWORD *)v11 + 1) = 0u;
          *(_QWORD *)((char *)v11 + 36) = 0x7FFFFFFFLL;
          re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap(v11, v8);
          re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v8);
          v8 += 6;
          v11 += 6;
          v10 -= 48;
        }
        while (v10);
        v8 = (uint64_t *)v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t *))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

uint64_t std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false> *,re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false> *,re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false> *,0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a1;
  if (a1 != a2)
  {
    do
    {
      re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(a3, v4);
      v4 += 48;
      a3 += 48;
    }
    while (v4 != a2);
    return a2;
  }
  return v4;
}

uint64_t re::DynamicArray<re::GeomMesh>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  unint64_t v5;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  v3 = *a2;
  if (*a2)
  {
    v5 = a2[2];
    *(_QWORD *)a1 = v3;
    re::DynamicArray<re::GeomMesh>::setCapacity((_QWORD *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::GeomMesh>::copy(a1, (uint64_t)a2);
  }
  return a1;
}

uint64_t re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  unint64_t v5;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  v3 = *a2;
  if (*a2)
  {
    v5 = a2[2];
    *(_QWORD *)a1 = v3;
    re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::setCapacity((_QWORD *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::copy((_QWORD *)a1, (uint64_t)a2);
  }
  return a1;
}

uint64_t re::DynamicArray<re::GeomModel>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  unint64_t v5;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  v3 = *a2;
  if (*a2)
  {
    v5 = a2[2];
    *(_QWORD *)a1 = v3;
    re::DynamicArray<re::GeomModel>::setCapacity((_QWORD *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::GeomModel>::copy((_QWORD *)a1, (uint64_t)a2);
  }
  return a1;
}

uint64_t re::DynamicArray<re::GeomInstance>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  unint64_t v5;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  v3 = *a2;
  if (*a2)
  {
    v5 = a2[2];
    *(_QWORD *)a1 = v3;
    re::DynamicArray<re::RigSplineIKJoint>::setCapacity((_QWORD *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::GeomInstance>::copy((void **)a1, (uint64_t)a2);
  }
  return a1;
}

void **re::DynamicArray<re::GeomInstance>::copy(void **result, uint64_t a2)
{
  void **v3;
  unint64_t v4;
  void *v5;

  v3 = result;
  v4 = *(_QWORD *)(a2 + 16);
  if (v4 >= (unint64_t)result[2])
  {
    re::DynamicArray<re::RigSplineIKJoint>::setCapacity(result, *(_QWORD *)(a2 + 16));
    v5 = v3[2];
    if (v5)
    {
      memmove(v3[4], *(const void **)(a2 + 32), 80 * (_QWORD)v5 - 12);
      v5 = v3[2];
    }
    result = (void **)memcpy((char *)v3[4] + 80 * (_QWORD)v5, (const void *)(*(_QWORD *)(a2 + 32) + 80 * (_QWORD)v5), 80 * v4 - 80 * (_QWORD)v5);
  }
  else if (v4)
  {
    result = (void **)memmove(result[4], *(const void **)(a2 + 32), 80 * v4 - 12);
  }
  v3[2] = (void *)v4;
  return result;
}

uint64_t re::DynamicArray<re::GeomSkeleton>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  unint64_t v5;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  v3 = *a2;
  if (*a2)
  {
    v5 = a2[2];
    *(_QWORD *)a1 = v3;
    re::DynamicArray<re::GeomSkeleton>::setCapacity((_QWORD *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::GeomSkeleton>::copy((_QWORD *)a1, (uint64_t)a2);
  }
  return a1;
}

void re::DynamicArray<re::GeomSkeleton>::copy(_QWORD *a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  __n128 v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char v20;
  char v21;

  v4 = *(_QWORD *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<re::GeomSkeleton>::setCapacity(a1, *(_QWORD *)(a2 + 16));
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::GeomSkeleton *,re::GeomSkeleton *,re::GeomSkeleton *>((uint64_t)&v21, *(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 32) + 160 * a1[2], a1[4]);
    v15 = a1[2];
    if (v15 != v4)
    {
      v16 = *(_QWORD *)(a2 + 32);
      v17 = a1[4];
      v18 = 160 * v15;
      v19 = 160 * v4;
      do
      {
        re::StringID::StringID((re::StringID *)(v17 + v18), (const StringID *)(v16 + v18));
        re::FixedArray<re::StringID>::FixedArray((unint64_t *)(v17 + v18 + 16), v16 + v18 + 16);
        re::FixedArray<unsigned int>::FixedArray((uint64_t *)(v17 + v18 + 40), v16 + v18 + 40);
        re::FixedArray<re::GenericSRT<float>>::FixedArray((_QWORD *)(v17 + v18 + 64), v16 + v18 + 64);
        re::FixedArray<re::Matrix4x4<float>>::FixedArray((uint64_t *)(v17 + v18 + 88), v16 + v18 + 88);
        re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::HashTable(v17 + v18 + 112, v16 + v18 + 112);
        v16 += 160;
        v19 -= 160;
        v17 += 160;
      }
      while (v18 != v19);
    }
  }
  else
  {
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::GeomSkeleton *,re::GeomSkeleton *,re::GeomSkeleton *>((uint64_t)&v20, *(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 32) + 160 * v4, a1[4]);
    v5 = a1[2];
    if (v4 != v5)
    {
      v6 = a1[4];
      v7 = 160 * v4;
      v8 = 160 * v5;
      do
      {
        v9 = (_QWORD *)(v6 + v7);
        v10.n128_f64[0] = re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)(v6 + v7 + 112));
        v11 = *(_QWORD *)(v6 + v7 + 88);
        if (v11)
        {
          if (v9[12])
          {
            (*(void (**)(uint64_t, _QWORD, double))(*(_QWORD *)v11 + 40))(v11, *(_QWORD *)(v6 + v7 + 104), v10.n128_f64[0]);
            v9[12] = 0;
            v9[13] = 0;
          }
          v9[11] = 0;
        }
        v12 = v9[8];
        if (v12)
        {
          if (*(_QWORD *)(v6 + v7 + 72))
          {
            (*(void (**)(uint64_t, _QWORD, __n128))(*(_QWORD *)v12 + 40))(v12, *(_QWORD *)(v6 + v7 + 80), v10);
            *(_QWORD *)(v6 + v7 + 72) = 0;
            *(_QWORD *)(v6 + v7 + 80) = 0;
          }
          v9[8] = 0;
        }
        v13 = (_QWORD *)(v6 + v7);
        v14 = *(_QWORD *)(v6 + v7 + 40);
        if (v14)
        {
          if (v13[6])
          {
            (*(void (**)(uint64_t, _QWORD, __n128))(*(_QWORD *)v14 + 40))(v14, *(_QWORD *)(v6 + v7 + 56), v10);
            v13[6] = 0;
            v13[7] = 0;
          }
          v13[5] = 0;
        }
        re::FixedArray<re::StringID>::deinit(v13 + 2);
        re::StringID::destroyString((re::StringID *)(v6 + v7));
        v6 += 160;
        v8 -= 160;
      }
      while (v7 != v8);
    }
  }
  a1[2] = v4;
}

_QWORD *re::DynamicArray<re::GeomSkeleton>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::GeomSkeleton>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0xA0uLL))
        {
          v2 = 160 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 160 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_16;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 160, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = (_QWORD *)v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = 160 * v9;
        v11 = (uint64_t)v7;
        do
        {
          re::ObjectHelper::move<re::GeomSkeleton>(v8, v11);
          v8 += 20;
          v11 += 160;
          v10 -= 160;
        }
        while (v10);
        v8 = (_QWORD *)v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

void re::ObjectHelper::move<re::GeomSkeleton>(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  __n128 v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  v3 = *a1;
  *(_QWORD *)a2 = *(_QWORD *)a2 & 0xFFFFFFFFFFFFFFFELL | *a1 & 1;
  *(_QWORD *)a2 = *a1 & 0xFFFFFFFFFFFFFFFELL | v3 & 1;
  *(_QWORD *)(a2 + 8) = a1[1];
  *a1 = 0;
  a1[1] = &str_110;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)(a2 + 24) = 0;
  *(_QWORD *)(a2 + 32) = 0;
  v4 = a1 + 2;
  *(_QWORD *)(a2 + 16) = a1[2];
  a1[2] = 0;
  v5 = *(_QWORD *)(a2 + 32);
  v6 = a1[4];
  *(_QWORD *)(a2 + 24) = a1[3];
  *(_QWORD *)(a2 + 32) = v6;
  a1[3] = 0;
  a1[4] = v5;
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  v8 = a1 + 6;
  v7 = a1[6];
  *(_QWORD *)(a2 + 40) = a1[5];
  a1[5] = 0;
  *(_QWORD *)(a2 + 48) = v7;
  a1[6] = 0;
  v9 = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 56) = a1[7];
  a1[7] = v9;
  *(_QWORD *)(a2 + 64) = 0;
  *(_QWORD *)(a2 + 72) = 0;
  *(_QWORD *)(a2 + 80) = 0;
  v11 = a1 + 9;
  v10 = a1[9];
  *(_QWORD *)(a2 + 64) = a1[8];
  a1[8] = 0;
  *(_QWORD *)(a2 + 72) = v10;
  a1[9] = 0;
  v12 = *(_QWORD *)(a2 + 80);
  *(_QWORD *)(a2 + 80) = a1[10];
  a1[10] = v12;
  *(_QWORD *)(a2 + 88) = 0;
  *(_QWORD *)(a2 + 96) = 0;
  *(_QWORD *)(a2 + 104) = 0;
  v14 = a1 + 12;
  v13 = a1[12];
  *(_QWORD *)(a2 + 88) = a1[11];
  a1[11] = 0;
  *(_QWORD *)(a2 + 96) = v13;
  v15 = *(_QWORD *)(a2 + 104);
  *(_QWORD *)(a2 + 104) = a1[13];
  a1[12] = 0;
  a1[13] = v15;
  *(_OWORD *)(a2 + 112) = 0u;
  v16 = a2 + 112;
  v17 = a1 + 14;
  *(_DWORD *)(v16 + 32) = 0;
  *(_OWORD *)(v16 + 16) = 0u;
  *(_QWORD *)(v16 + 36) = 0x7FFFFFFFLL;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)v16, a1 + 14);
  v18.n128_f64[0] = re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit(v17);
  v19 = *(v14 - 1);
  if (v19)
  {
    if (*v14)
    {
      (*(void (**)(uint64_t, _QWORD, double))(*(_QWORD *)v19 + 40))(v19, a1[13], v18.n128_f64[0]);
      *v14 = 0;
      v14[1] = 0;
    }
    a1[11] = 0;
  }
  v20 = a1[8];
  if (v20)
  {
    if (*v11)
    {
      (*(void (**)(uint64_t, _QWORD, __n128))(*(_QWORD *)v20 + 40))(v20, a1[10], v18);
      *v11 = 0;
      v11[1] = 0;
    }
    a1[8] = 0;
  }
  v21 = a1[5];
  if (v21)
  {
    if (*v8)
    {
      (*(void (**)(uint64_t, _QWORD, __n128))(*(_QWORD *)v21 + 40))(v21, a1[7], v18);
      *v8 = 0;
      v8[1] = 0;
    }
    a1[5] = 0;
  }
  re::FixedArray<re::StringID>::deinit(v4);
  re::StringID::destroyString((re::StringID *)a1);
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::GeomSkeleton *,re::GeomSkeleton *,re::GeomSkeleton *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t v7;

  if (a2 == a3)
    return a2;
  v6 = a3;
  v7 = 0;
  do
  {
    re::StringID::operator=((unint64_t *)(a4 + v7), (uint64_t *)(a2 + v7));
    re::FixedArray<re::StringID>::operator=((unint64_t *)(a4 + v7 + 16), a2 + v7 + 16);
    re::FixedArray<unsigned int>::operator=((uint64_t *)(a4 + v7 + 40), a2 + v7 + 40);
    re::FixedArray<re::GenericSRT<float>>::operator=((_QWORD *)(a4 + v7 + 64), a2 + v7 + 64);
    re::FixedArray<re::Matrix4x4<float>>::operator=((uint64_t *)(a4 + v7 + 88), a2 + v7 + 88);
    re::HashTable<re::StringID,unsigned int,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::operator=(a4 + v7 + 112, a2 + v7 + 112);
    v7 += 160;
  }
  while (a2 + v7 != v6);
  return v6;
}

id *re::TextureCompiler::init(uint64_t a1, uint64_t a2, char a3)
{
  id *result;
  __int16 v7;
  int v8;
  BOOL v9;
  BOOL v10;

  re::ObjCObject::operator=((id *)(a1 + 8), (id *)a2);
  result = re::ObjCObject::operator=((id *)(a1 + 16), (id *)(a2 + 8));
  v7 = *(_WORD *)(a2 + 16);
  *(_BYTE *)(a1 + 26) = *(_BYTE *)(a2 + 18);
  *(_WORD *)(a1 + 24) = v7;
  v8 = *(unsigned __int8 *)(a2 + 19);
  if (*(_BYTE *)(a1 + 27))
    v9 = 0;
  else
    v9 = v8 == 0;
  if (!v9)
  {
    if (*(_BYTE *)(a1 + 27))
      v10 = v8 == 0;
    else
      v10 = 0;
    if (v10)
    {
      *(_BYTE *)(a1 + 27) = 0;
    }
    else
    {
      if (!*(_BYTE *)(a1 + 27) && *(_BYTE *)(a2 + 19))
        *(_BYTE *)(a1 + 27) = 1;
      *(_BYTE *)(a1 + 28) = *(_BYTE *)(a2 + 20);
    }
  }
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 24);
  *(_BYTE *)(a1 + 40) = a3;
  return result;
}

re::DynamicString *re::TextureCompiler::getCurrentCompiledAssetInfo@<X0>(re::TextureCompiler *this@<X0>, uint64_t a2@<X8>)
{
  re::TextureAsset *v3;
  const char *v5[2];

  *(_QWORD *)(a2 + 32) = 0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  v3 = (re::TextureAsset *)re::DynamicString::setCapacity((_QWORD *)(a2 + 8), 0);
  *(_QWORD *)a2 = 0x100000001;
  v5[0] = (const char *)*re::TextureAsset::assetType(v3);
  v5[1] = (const char *)strlen(v5[0]);
  return re::DynamicString::operator=((re::DynamicString *)(a2 + 8), (uint64_t)v5);
}

__guard re::TextureCompiler::assetIntrospectionType(re::TextureCompiler *this)
{
  unsigned __int8 v1;
  __guard *v2;
  int v4;

  if ((v1 & 1) == 0)
  {
    if (v4)
    {
      re::introspect<re::TextureAsset>(void)::info = re::introspect_TextureAsset(0);
    }
  }
  return v2[449];
}

_QWORD *re::TextureCompiler::getSupportedExtensions@<X0>(uint64_t a1@<X8>)
{
  uint64_t v3;
  _QWORD *result;

  v3 = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  do
    result = re::DynamicArray<re::TransitionCondition *>::add((_QWORD *)a1, &re::TextureCompiler::getSupportedExtensions(void)const::supportedExtensions[v3++]);
  while (v3 != 12);
  return result;
}

void re::TextureCompiler::compile(id *this@<X0>, char *__s@<X1>, char *a3@<X2>, uint64_t a4@<X8>, uint8x8_t a5@<D0>, int16x8_t a6@<Q1>)
{
  char v10;
  unsigned int v11;
  int v12;
  NSObject *v13;
  _BOOL8 v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  const char *v19;
  char *v20;
  char *v21;
  int v22;
  id v23;
  id v24;
  _anonymous_namespace_ *v25;
  id v26;
  id v27;
  uint64_t TextureAsset;
  int v29;
  uint64_t v30;
  uint64_t v31;
  re::TextureCompiler *v32;
  void *v33;
  unsigned __int32 v34;
  _BYTE v35[32];
  __int16 v36;
  char v37;
  __int16 v38;
  char v39;
  uint64_t *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  id v44;
  __int128 v45;
  _BYTE v46[24];
  uint64_t v47;
  int v48;
  char v49;
  int v50;
  id v51;
  uint64_t v52;
  uint64_t v53;
  id v54[2];
  __int128 v55;
  uint8_t v56[8];
  __int128 v57;
  __int128 v58;
  uint64_t v59;
  uint64_t v60;
  unsigned int v61;
  id v62;
  uint8_t buf[16];
  uint64_t v64;
  __int128 v65;
  uint64_t v66;
  unsigned int v67;
  id v68;
  _QWORD v69[3];

  v69[2] = *MEMORY[0x24BDAC8D0];
  if (!__s)
  {
    v13 = *re::pipelineLogObjects((re *)this);
    v14 = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
    if (v14)
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_224FE9000, v13, OS_LOG_TYPE_DEFAULT, "TextureAssetCompiler: sourceFilePath is null.", buf, 2u);
    }
    v15 = *(_OWORD *)buf;
    v16 = v64;
    v17 = v65;
    *(_BYTE *)a4 = 0;
    *(_QWORD *)(a4 + 8) = 100;
    *(_QWORD *)(a4 + 16) = &re::AssetErrorCategory(void)::instance;
    *(_OWORD *)(a4 + 24) = v15;
    *(_QWORD *)(a4 + 40) = v16;
    *(_QWORD *)(a4 + 48) = v17;
    return;
  }
  v69[0] = 0;
  *(_QWORD *)((char *)v69 + 5) = 0;
  if (a3)
  {
    a5.i32[0] = *(_DWORD *)a3;
    a6 = (int16x8_t)vmovl_u8(a5);
    v10 = a3[4];
    v38 = *(_WORD *)(a3 + 5);
    v39 = a3[7];
    v11 = *((_DWORD *)a3 + 2);
    v69[0] = *(_QWORD *)(a3 + 12);
    *(_QWORD *)((char *)v69 + 5) = *(_QWORD *)(a3 + 17);
    v36 = *(_WORD *)(a3 + 25);
    v37 = a3[27];
    v12 = *((_DWORD *)a3 + 7);
  }
  else
  {
    a6.i64[0] = 0x1000000010001;
    v12 = 0;
    v10 = 1;
    v11 = 1;
  }
  v34 = a6.i32[0];
  *(_DWORD *)v35 = vmovn_s16(a6).u32[0];
  v35[4] = v10;
  *(_WORD *)&v35[5] = v38;
  v35[7] = v39;
  *(_DWORD *)&v35[8] = v11;
  *(_QWORD *)&v35[12] = v69[0];
  *(_QWORD *)&v35[17] = *(_QWORD *)((char *)v69 + 5);
  *(_WORD *)&v35[25] = v36;
  v35[27] = v37;
  *(_DWORD *)&v35[28] = v12;
  v18 = strrchr(__s, 47);
  if (!v18)
  {
    buf[0] = 0;
    *(_QWORD *)&buf[8] = 0;
    v67 = 0;
    v68 = 0;
    goto LABEL_12;
  }
  v19 = v18;
  v20 = strcasestr(v18, "cubemap");
  v21 = strcasestr(v19, "lut");
  buf[0] = 0;
  *(_QWORD *)&buf[8] = 0;
  v67 = 0;
  v68 = 0;
  if (v20)
  {
    *(_OWORD *)v54 = *(_OWORD *)v35;
    v55 = *(_OWORD *)&v35[16];
    re::loadTextureFileAndConvertToCubeMap(this + 1, (uint64_t)__s, (uint64_t)v54, (uint64_t)v56);
    goto LABEL_26;
  }
  if (!v21)
  {
LABEL_12:
    re::createTextureDescriptorFromCompileOptions(this + 1, (uint64_t)v35, v54);
    v45 = 0uLL;
    *(_DWORD *)v46 = 1;
    LODWORD(v47) = 0;
    BYTE4(v47) = 0;
    *(_QWORD *)&v46[12] = 0;
    v46[20] = 0;
    v48 = 0;
    v50 = 6;
    v52 = 0;
    v53 = 0;
    v51 = 0;
    if (v11 >= 2)
    {
      DWORD2(v45) = 1;
      *(_DWORD *)v46 = v11;
    }
    v22 = BYTE2(v34) == 0;
    if (!(_BYTE)v34)
      v22 = 2;
    *(_DWORD *)&v46[4] = v22;
    *(_DWORD *)&v46[8] = *(_DWORD *)&v35[12];
    DWORD1(v45) = 2;
    v49 = *((_BYTE *)this + 40);
    v44 = v54[0];
    re::loadTextureFromFile(this + 1, (uint64_t)__s, &v44, (re::internal *)&v45, (uint64_t)v56);
    buf[0] = v56[0];
    std::__variant_detail::__assignment<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>>::__generic_assign[abi:nn180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>,(std::__variant_detail::_Trait)1>>((uint64_t)&buf[8], (uint64_t)&v57);
    if (&v68 != &v62)
    {
      v23 = v62;
      v62 = 0;
      v24 = v68;
      v68 = v23;

    }
    if (v61 != -1)
      ((void (*)(uint64_t **, __int128 *))*(&off_24ED42D00 + v61))(&v40, &v57);
    v61 = -1;
    if (v44)
    {

      v44 = 0;
    }

    v25 = (_anonymous_namespace_ *)v54[0];
    if (v54[0])

    goto LABEL_28;
  }
  re::loadTextureFileAndConvertTo3DTexture(this + 1, (const re::mtl::Device *)__s, (uint64_t)v56);
LABEL_26:
  buf[0] = v56[0];
  std::__variant_detail::__assignment<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>>::__generic_assign[abi:nn180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>,(std::__variant_detail::_Trait)1>>((uint64_t)&buf[8], (uint64_t)&v57);
  v26 = v62;
  v62 = 0;
  v27 = v68;
  v68 = v26;

  if (v61 != -1)
    v25 = (_anonymous_namespace_ *)((uint64_t (*)(__int128 *, __int128 *))*(&off_24ED42D00 + v61))(&v45, &v57);
  if (v67)
  {
    if (v67 != 1)
    {
      v32 = (re::TextureCompiler *)std::__throw_bad_variant_access[abi:nn180100]();
      re::TextureCompiler::deleteAsset(v32, v33);
      return;
    }
    if (!*((_QWORD *)&v65 + 1))
      goto LABEL_33;
  }
LABEL_28:
  if (*(_QWORD *)&buf[8])
  {
    v45 = *(_OWORD *)v35;
    *(_OWORD *)v46 = *(_OWORD *)&v35[16];
    TextureAsset = re::TextureAsset::makeTextureAsset((uint64_t)buf, 6, &v45);
    v29 = 1;
    v56[0] = 1;
    *(_QWORD *)&v57 = TextureAsset;
  }
  else
  {
LABEL_33:
    v41 = 0;
    v42 = 0;
    v43 = 0;
    re::DynamicString::setCapacity(&v40, 0);
    re::DynamicString::assignf((re::DynamicString *)&v40, "failed to load texture %s", __s);
    *(_QWORD *)&v45 = 100;
    *((_QWORD *)&v45 + 1) = &re::AssetErrorCategory(void)::instance;
    re::DynamicString::DynamicString((re::DynamicString *)v46, (const re::DynamicString *)&v40);
    v56[0] = 0;
    v57 = v45;
    v58 = *(_OWORD *)v46;
    v59 = *(_QWORD *)&v46[16];
    v60 = v47;
    if (v40 && (v41 & 1) != 0)
      (*(void (**)(void))(*v40 + 40))();
    v29 = 0;
  }

  if (v67 != -1)
  {
    ((void (*)(uint64_t **, uint8_t *))*(&off_24ED42D00 + v67))(&v40, &buf[8]);
    v29 = v56[0];
  }
  if (v29)
  {
    v30 = v57;
    *(_BYTE *)a4 = 1;
    *(_QWORD *)(a4 + 8) = v30;
  }
  else
  {
    *(_OWORD *)buf = v57;
    re::DynamicString::DynamicString((re::DynamicString *)&v64, (const re::DynamicString *)&v58);
    *(_BYTE *)a4 = 0;
    *(_OWORD *)(a4 + 8) = *(_OWORD *)buf;
    v31 = v66;
    *(_QWORD *)(a4 + 24) = v64;
    *(_QWORD *)(a4 + 48) = v31;
    *(_OWORD *)(a4 + 32) = v65;
    if ((_QWORD)v58)
    {
      if ((BYTE8(v58) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v58 + 40))();
    }
  }
}

re *re::TextureCompiler::deleteAsset(re *this, void (***a2)(_QWORD))
{
  uint64_t v3;

  if (a2)
  {
    v3 = re::globalAllocators(this)[2];
    (**a2)(a2);
    return (re *)(*(uint64_t (**)(uint64_t, void (***)(_QWORD)))(*(_QWORD *)v3 + 40))(v3, a2);
  }
  return this;
}

re *re::TextureCompiler::deleteAssetCompileOptions(re *this, void *a2)
{
  uint64_t *v3;

  if (a2)
  {
    v3 = re::globalAllocators(this);
    return (re *)(*(uint64_t (**)(uint64_t, void *))(*(_QWORD *)v3[2] + 40))(v3[2], a2);
  }
  return this;
}

void re::TextureCompiler::~TextureCompiler(id *this)
{

}

{

  JUMPOUT(0x2276933B8);
}

re::DynamicString *re::BVHCompiler::getCurrentCompiledAssetInfo@<X0>(re::BVHCompiler *this@<X0>, uint64_t a2@<X8>)
{
  re::TimelineAsset *v3;
  const char *v5[2];

  *(_QWORD *)(a2 + 32) = 0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  v3 = (re::TimelineAsset *)re::DynamicString::setCapacity((_QWORD *)(a2 + 8), 0);
  *(_QWORD *)a2 = 0x100000001;
  v5[0] = (const char *)*re::TimelineAsset::assetType(v3);
  v5[1] = (const char *)strlen(v5[0]);
  return re::DynamicString::operator=((re::DynamicString *)(a2 + 8), (uint64_t)v5);
}

__guard re::BVHCompiler::assetIntrospectionType(re::BVHCompiler *this)
{
  unsigned __int8 v1;
  __guard *v2;
  int v4;

  if ((v1 & 1) == 0)
  {
    if (v4)
    {
      re::introspect<re::TimelineAsset>(void)::info = re::introspect_TimelineAsset(0);
    }
  }
  return v2[65];
}

uint64_t re::BVHCompiler::getSupportedExtensions@<X0>(uint64_t a1@<X8>)
{
  _QWORD v3[2];

  v3[0] = re::BVHCompiler::getSupportedExtensions(void)const::supportedExtensions;
  v3[1] = 1;
  return re::DynamicArray<char const*>::DynamicArray(a1, (uint64_t)v3);
}

uint64_t re::BVHCompiler::compile@<X0>(re::FileStreamReader *a1@<X1>, uint64_t a2@<X8>)
{
  _anonymous_namespace_ *v7;
  uint64_t *v8;
  float v9;
  unint64_t v10;
  _anonymous_namespace_ *v11;
  _anonymous_namespace_ *v12;
  re *v13;
  uint64_t *v14;
  uint64_t v15;
  re *v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t v25;
  __int16 v26;
  re **TimelineAsset;
  unsigned __int128 v29;
  __int128 v30;
  uint64_t v31[2];
  uint64_t v32[2];
  char v33[24];
  __int128 v34;
  __int128 v35;
  unsigned __int128 v36;
  _OWORD v37[8];
  int v38;
  uint64_t v39;
  uint64_t (**v40)();
  uint64_t v41;
  uint64_t v42;
  _QWORD v43[2];
  _QWORD v44[4];
  __int16 v45;
  float v46;
  int v47;
  float v48;
  uint64_t v49;
  unint64_t v50;
  uint64_t *v51;
  __int16 v52;
  char v53;
  float v54;
  unint64_t v55[3];
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t v63;
  uint64_t v64;
  char v65[8];
  float v66;
  uint64_t v67;
  uint64_t v68;
  char v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  _QWORD v76[3];
  char v77[8];
  unsigned __int128 v78;
  uint64_t v79;
  _BYTE v80[18];
  __int16 v81;
  unint64_t v82;
  __int16 v83;
  unint64_t v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  uint64_t v90;

  v90 = *MEMORY[0x24BDAC8D0];
  re::FileStreamReader::open(a1, (uint64_t)v77);
  if (v77[0])
  {
    v7 = (_anonymous_namespace_ *)re::parseAnimationBVH((re *)&v78, (uint64_t)v65);
    if (v65[0])
    {
      v54 = v66;
      re::FixedArray<re::StringID>::FixedArray(v55, (uint64_t)&v67);
      re::FixedArray<unsigned int>::FixedArray(&v56, (uint64_t)&v70);
      re::FixedArray<re::GenericSRT<float>>::FixedArray(&v59, (uint64_t)&v73);
      v8 = re::FixedArray<re::FixedArray<re::GenericSRT<float>>>::FixedArray(&v62, (uint64_t)v76);
      v9 = v54;
      v10 = v63;
      v40 = (uint64_t (**)())off_24ED1F350;
      v41 = 34;
      LOBYTE(v42) = 0;
      v43[0] = 0;
      v43[1] = &str_110;
      v45 = 256;
      v50 = 0;
      v51 = 0;
      v49 = 0;
      v40 = (uint64_t (**)())off_24ED222D0;
      v52 = 257;
      v53 = 1;
      v46 = v9;
      v47 = 0;
      v48 = v54 * (float)(v10 - 1);
      *(_QWORD *)&v36 = 0;
      *((_QWORD *)&v36 + 1) = &str_110;
      memset(v37, 0, sizeof(v37));
      v38 = 0;
      v39 = 0x7FFFFFFFLL;
      *(_QWORD *)&v85 = 0x190FB25473155C2;
      *((_QWORD *)&v85 + 1) = "BVHSkeleton";
      *(_QWORD *)v80 = v55[2];
      *(_QWORD *)&v80[8] = v55[1];
      v32[0] = v58;
      v32[1] = v57;
      v31[0] = v61;
      v31[1] = v60;
      if (!v33[0] && (_QWORD)v34)
      {
        if ((BYTE8(v34) & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v34 + 40))();
        v34 = 0u;
        v35 = 0u;
      }
      re::StringID::destroyString((re::StringID *)&v85);
      v14 = re::globalAllocators(v13);
      v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v14[2] + 32))(v14[2], 256, 8);
      v16 = (re *)re::SkeletalPoseJointDefinition::SkeletalPoseJointDefinition(v15, v55, (const StringID *)&v36);
      v31[0] = (uint64_t)v16;
      if (v50)
      {
        v17 = v51;
        v18 = 88 * v50;
        do
        {
          re::SkeletalPose::init(v17, v31);
          v17 += 11;
          v18 -= 88;
        }
        while (v18);
      }
      if (v10)
      {
        v19 = 0;
        v20 = 0;
        v21 = 2;
        do
        {
          v22 = v63;
          if (v63 <= v20)
          {
            v32[0] = 0;
            v89 = 0u;
            v88 = 0u;
            v87 = 0u;
            v86 = 0u;
            v85 = 0u;
            os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
            *(_DWORD *)v80 = 136315906;
            *(_QWORD *)&v80[4] = "operator[]";
            *(_WORD *)&v80[12] = 1024;
            *(_DWORD *)&v80[14] = 468;
            v81 = 2048;
            v82 = v20;
            v83 = 2048;
            v84 = v22;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_50:
            v32[0] = 0;
            v89 = 0u;
            v88 = 0u;
            v87 = 0u;
            v86 = 0u;
            v85 = 0u;
            os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
            *(_DWORD *)v80 = 136315906;
            *(_QWORD *)&v80[4] = "operator[]";
            *(_WORD *)&v80[12] = 1024;
            *(_DWORD *)&v80[14] = 468;
            v81 = 2048;
            v82 = v20;
            v83 = 2048;
            v84 = v22;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
          }
          v22 = v50;
          if (v50 <= v20)
            goto LABEL_50;
          v16 = (re *)re::FixedArray<float>::operator=(&v51[v21], (uint64_t *)(v64 + v19));
          ++v20;
          v19 += 24;
          v21 += 11;
        }
        while (v10 != v20);
      }
      LODWORD(v87) = 0;
      v86 = 0u;
      v85 = 0u;
      *(_QWORD *)((char *)&v87 + 4) = 0x7FFFFFFFLL;
      v23 = re::globalAllocators(v16);
      v24 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v23[2] + 32))(v23[2], 120, 8);
      re::SampledAnimation<re::SkeletalPose>::SampledAnimation(v24, (uint64_t)&v40);
      *(_QWORD *)v25 = off_24ED222D0;
      v26 = v52;
      *(_BYTE *)(v25 + 114) = v53;
      *(_WORD *)(v25 + 112) = v26;
      TimelineAsset = re::AssetHelper::makeTimelineAsset((re *)v25, (uint64_t)&v85);
      *(_BYTE *)a2 = 1;
      *(_QWORD *)(a2 + 8) = TimelineAsset;
      re::HashTable<unsigned long long,re::internal::PushLoadManager::PushLoadedAsset,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)&v85);
      if (v15)

      re::Skeleton::~Skeleton((re::Skeleton *)&v36);
      v40 = off_24ED22100;
      re::FixedArray<re::SkeletalPose>::deinit(&v49);
      v40 = (uint64_t (**)())off_24ED1F350;
      if (v44[0])
      {
        if ((v44[1] & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v44[0] + 40))();
        memset(v44, 0, sizeof(v44));
      }
      re::StringID::destroyString((re::StringID *)v43);
      re::FixedArray<re::FixedArray<float>>::deinit(&v62);
      if (v59)
      {
        if (v60)
        {
          (*(void (**)(void))(*(_QWORD *)v59 + 40))();
          v60 = 0;
          v61 = 0;
        }
        v59 = 0;
      }
      if (v56)
      {
        if (v57)
        {
          (*(void (**)(void))(*(_QWORD *)v56 + 40))();
          v57 = 0;
          v58 = 0;
        }
        v56 = 0;
      }
      re::FixedArray<re::StringID>::deinit(v55);
    }
    else
    {
      re::DynamicString::operator+((re::DynamicString *)&v40, (const char *)a1, (re::DynamicString *)&v36);
      v29 = v36;
      v36 = 0uLL;
      v30 = v37[0];
      v37[0] = 0uLL;
      *(_BYTE *)a2 = 0;
      *(_QWORD *)(a2 + 8) = 100;
      *(_QWORD *)(a2 + 16) = &re::AssetErrorCategory(void)::instance;
      *(_OWORD *)(a2 + 24) = v29;
      *(_OWORD *)(a2 + 40) = v30;
      if (v40 && (v41 & 1) != 0)
        (*((void (**)(void))*v40 + 5))();
    }
    if (v65[0])
    {
      re::FixedArray<re::FixedArray<float>>::deinit(v76);
      if (v73)
      {
        if (v74)
        {
          (*(void (**)(void))(*(_QWORD *)v73 + 40))();
          v74 = 0;
          v75 = 0;
        }
        v73 = 0;
      }
      if (v70)
      {
        if (v71)
        {
          (*(void (**)(void))(*(_QWORD *)v70 + 40))();
          v71 = 0;
          v72 = 0;
        }
        v70 = 0;
      }
      re::FixedArray<re::StringID>::deinit(&v67);
    }
    else if (v68 && (v69 & 1) != 0)
    {
      (*(void (**)(void))(*(_QWORD *)v68 + 40))();
    }
  }
  else
  {
    v36 = v78;
    re::DynamicString::DynamicString((re::DynamicString *)v37, (const re::DynamicString *)&v79);
    *(_BYTE *)a2 = 0;
    *(_OWORD *)(a2 + 8) = v36;
    *(_QWORD *)(a2 + 24) = *(_QWORD *)&v37[0];
    *(_QWORD *)(a2 + 48) = *((_QWORD *)&v37[1] + 1);
    *(_OWORD *)(a2 + 32) = *(_OWORD *)((char *)v37 + 8);
  }
  return re::Result<re::FileStreamReader,re::DetailedError>::~Result((uint64_t)v77);
}

re *re::BVHCompiler::deleteAsset(re *this, void *a2)
{
  uint64_t *v3;

  if (a2)
  {
    v3 = re::globalAllocators(this);
    return (re *)(*(uint64_t (**)(uint64_t, void *))(*(_QWORD *)v3[2] + 40))(v3[2], a2);
  }
  return this;
}

void re::BVHCompiler::~BVHCompiler(re::BVHCompiler *this)
{
  JUMPOUT(0x2276933B8);
}

uint64_t *re::FixedArray<re::FixedArray<re::GenericSRT<float>>>::FixedArray(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v4 = *(_QWORD *)a2;
  if (v4)
  {
    re::FixedArray<re::FixedArray<unsigned int>>::init<>(a1, v4, *(_QWORD *)(a2 + 8));
    re::FixedArray<re::FixedArray<re::GenericSRT<float>>>::copy((uint64_t)a1, a2);
  }
  return a1;
}

uint64_t re::FixedArray<re::FixedArray<re::GenericSRT<float>>>::copy(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t result;

  v2 = *(_QWORD *)(a1 + 8);
  if (v2 == *(_QWORD *)(a2 + 8))
    return std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::SkeletalPoseAssetData *,re::SkeletalPoseAssetData *,re::SkeletalPoseAssetData *,0>(*(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 16) + 24 * v2, *(_QWORD **)(a1 + 16));
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Cannot copy from a FixedArray of a different size", "m_size == other.m_size", "copy", 388);
  result = _os_crash();
  __break(1u);
  return result;
}

double re::SampledAnimation<re::SkeletalPose>::SampledAnimation(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  double result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  *(_QWORD *)a1 = off_24ED1F350;
  v2 = *(_QWORD *)(a2 + 8);
  *(_BYTE *)(a1 + 16) = *(_BYTE *)(a2 + 16);
  *(_QWORD *)(a1 + 8) = v2;
  v3 = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a1 + 24) & 0xFFFFFFFFFFFFFFFELL | v3 & 1;
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24) & 0xFFFFFFFFFFFFFFFELL | v3 & 1;
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 24) = 0;
  *(_QWORD *)(a2 + 32) = &str_110;
  result = 0.0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
  v5 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  v6 = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 64) = 0;
  v8 = *(_QWORD *)(a1 + 48);
  v7 = *(_QWORD *)(a1 + 56);
  *(_QWORD *)(a1 + 48) = v5;
  *(_QWORD *)(a1 + 56) = v6;
  *(_QWORD *)(a2 + 48) = v8;
  *(_QWORD *)(a2 + 56) = v7;
  *(_BYTE *)(a1 + 72) = *(_BYTE *)(a2 + 72);
  *(_QWORD *)a1 = off_24ED22100;
  v9 = *(_QWORD *)(a2 + 73);
  *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
  *(_QWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 73) = v9;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  v10 = *(_QWORD *)(a2 + 96);
  *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
  *(_QWORD *)(a1 + 96) = v10;
  *(_QWORD *)(a2 + 88) = 0;
  *(_QWORD *)(a2 + 96) = 0;
  v11 = *(_QWORD *)(a1 + 104);
  *(_QWORD *)(a1 + 104) = *(_QWORD *)(a2 + 104);
  *(_QWORD *)(a2 + 104) = v11;
  return result;
}

re::DynamicString *re::TextureDefinitionCompiler::getCurrentCompiledAssetInfo@<X0>(re::TextureDefinitionCompiler *this@<X0>, uint64_t a2@<X8>)
{
  re::TextureAsset *v3;
  const char *v5[2];

  *(_QWORD *)(a2 + 32) = 0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  v3 = (re::TextureAsset *)re::DynamicString::setCapacity((_QWORD *)(a2 + 8), 0);
  *(_QWORD *)a2 = 0x100000001;
  v5[0] = (const char *)*re::TextureAsset::assetType(v3);
  v5[1] = (const char *)strlen(v5[0]);
  return re::DynamicString::operator=((re::DynamicString *)(a2 + 8), (uint64_t)v5);
}

__guard re::TextureDefinitionCompiler::assetIntrospectionType(re::TextureDefinitionCompiler *this)
{
  unsigned __int8 v1;
  __guard *v2;
  int v4;

  if ((v1 & 1) == 0)
  {
    if (v4)
    {
      re::introspect<re::TextureAsset>(void)::info = re::introspect_TextureAsset(0);
    }
  }
  return v2[449];
}

_QWORD *re::TextureDefinitionCompiler::getSupportedExtensions@<X0>(uint64_t a1@<X8>)
{
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  return re::DynamicArray<re::TransitionCondition *>::add((_QWORD *)a1, re::TextureDefinitionCompiler::getSupportedExtensions(void)const::supportedExtensions);
}

re::DynamicString *re::TextureDefinitionCompiler::compile@<X0>(id *this@<X0>, char *a2@<X1>, re::AssetSerializationScheme *a3@<X3>, uint64_t a4@<X8>)
{
  unsigned __int8 v9;
  uint64_t v10;
  re *v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  id v16;
  int v17;
  unint64_t v18;
  NSObject *v19;
  _BOOL8 v20;
  re::DynamicString *result;
  __int128 v22;
  __int128 v23;
  _BYTE *v24;
  __int128 v25;
  __int128 v26;
  re *v27;
  id v28;
  void *v29;
  __int128 v30;
  uint64_t v31;
  uint64_t v32;
  uint8_t buf[16];
  _BYTE v34[24];
  uint64_t v35;
  unsigned int v36;
  id v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  id v42;
  _BYTE v43[24];
  uint64_t v44;
  char v45;
  _BYTE v46[23];
  _BYTE v47[8];
  __int128 v48;
  uint64_t v49;
  _QWORD v50[3];

  if (a2)
  {
    if ((v9 & 1) == 0
    {
      re::introspect<re::TextureAsset>(void)::info = re::introspect_TextureAsset(0);
    }
    v10 = re::introspect<re::TextureAsset>(void)::info;
    memset(v50, 0, sizeof(v50));
    re::FileStreamReader::open((re::FileStreamReader *)a2, (uint64_t)v47);
    if (v47[0])
    {
      v50[0] = a3;
      v12 = re::globalAllocators(v11);
      v13 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v12[2] + 32))(v12[2], 424, 8);
      *(_OWORD *)v13 = 0u;
      *(_OWORD *)(v13 + 16) = 0u;
      *(_OWORD *)(v13 + 32) = 0u;
      *(_OWORD *)(v13 + 48) = 0u;
      *(_OWORD *)(v13 + 64) = 0u;
      *(_OWORD *)(v13 + 80) = 0u;
      *(_OWORD *)(v13 + 96) = 0u;
      *(_OWORD *)(v13 + 112) = 0u;
      *(_OWORD *)(v13 + 128) = 0u;
      *(_OWORD *)(v13 + 144) = 0u;
      *(_OWORD *)(v13 + 160) = 0u;
      *(_OWORD *)(v13 + 176) = 0u;
      *(_OWORD *)(v13 + 192) = 0u;
      *(_OWORD *)(v13 + 208) = 0u;
      *(_OWORD *)(v13 + 224) = 0u;
      *(_OWORD *)(v13 + 240) = 0u;
      *(_OWORD *)(v13 + 256) = 0u;
      *(_OWORD *)(v13 + 272) = 0u;
      *(_OWORD *)(v13 + 288) = 0u;
      *(_OWORD *)(v13 + 304) = 0u;
      *(_OWORD *)(v13 + 320) = 0u;
      *(_OWORD *)(v13 + 336) = 0u;
      *(_OWORD *)(v13 + 352) = 0u;
      *(_OWORD *)(v13 + 368) = 0u;
      *(_OWORD *)(v13 + 384) = 0u;
      *(_OWORD *)(v13 + 400) = 0u;
      *(_QWORD *)(v13 + 416) = 0;
      re::TextureAsset::TextureAsset((re::TextureAsset *)v13);
      if (v43[0])
      {
        v14 = 5;
        if (!*(_BYTE *)(v13 + 10))
          v14 = 0;
        v15 = v14 | *(unsigned __int8 *)(v13 + 11);
        v16 = objc_msgSend(objc_msgSend(MEMORY[0x24BDDD740], sel_alloc), sel_init);
        objc_msgSend(v16, sel_setWidth_, *(int *)(v13 + 360));
        objc_msgSend(v16, sel_setHeight_, *(int *)(v13 + 364));
        objc_msgSend(v16, sel_setDepth_, *(int *)(v13 + 368));
        objc_msgSend(v16, sel_setPixelFormat_, *(int *)(v13 + 376));
        objc_msgSend(v16, sel_setTextureType_, *(int *)(v13 + 380));
        objc_msgSend(v16, sel_setStorageMode_, 0);
        if (*(_BYTE *)(v13 + 8))
        {
          v17 = *(_DWORD *)(v13 + 360);
          if (v17 <= *(_DWORD *)(v13 + 364))
            v17 = *(_DWORD *)(v13 + 364);
          v18 = (unint64_t)(floor(log2((double)v17)) + 1.0);
        }
        else
        {
          v18 = 1;
        }
        objc_msgSend(v16, sel_setMipmapLevelCount_, v18);
        v27 = (re *)objc_msgSend(v16, sel_setSampleCount_, 1);
        if (*(_BYTE *)(v13 + 10))
          objc_msgSend(v16, sel_setProtectionOptions_, re::protectionOptions(v27));
        objc_msgSend(v16, sel_setUsage_, v15);
        re::mtl::Device::makeTexture(v16, this + 1, &v42);
        if (v42)
        {
          buf[0] = 0;
          *(_QWORD *)&buf[8] = v42;
          v36 = 0;
          v37 = 0;
          *(_BYTE *)(v13 + 152) = 0;
          std::__variant_detail::__assignment<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>>::__generic_assign[abi:nn180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>,(std::__variant_detail::_Trait)1>>(v13 + 160, (uint64_t)&buf[8]);
          if ((uint8_t *)(v13 + 152) != buf)
          {
            v28 = v37;
            v37 = 0;
            v29 = *(void **)(v13 + 248);
            *(_QWORD *)(v13 + 248) = v28;

          }
          if (v36 != -1)
            ((void (*)(uint64_t **, uint8_t *))*(&off_24ED42DE8 + v36))(&v38, &buf[8]);
          *(_BYTE *)a4 = 1;
          *(_QWORD *)(a4 + 8) = v13;
        }
        else
        {
          v39 = 0;
          v40 = 0;
          v41 = 0;
          re::DynamicString::setCapacity(&v38, 0);
          re::DynamicString::assignf((re::DynamicString *)&v38, "failed to load texture %s", a2);
          *(_QWORD *)buf = 100;
          *(_QWORD *)&buf[8] = &re::AssetErrorCategory(void)::instance;
          re::DynamicString::DynamicString((re::DynamicString *)v34, (const re::DynamicString *)&v38);
          v30 = *(_OWORD *)v34;
          *(_OWORD *)(a4 + 8) = *(_OWORD *)buf;
          v31 = *(_QWORD *)&v34[16];
          v32 = v35;
          *(_BYTE *)a4 = 0;
          *(_OWORD *)(a4 + 24) = v30;
          *(_QWORD *)(a4 + 40) = v31;
          *(_QWORD *)(a4 + 48) = v32;
          if (v38 && (v39 & 1) != 0)
            (*(void (**)(void))(*v38 + 40))();
        }
        if (v42)

        if (v16)
      }
      else
      {
        if ((v45 & 1) != 0)
          v24 = *(_BYTE **)&v46[7];
        else
          v24 = v46;
        re::DynamicString::format((re::DynamicString *)"Failed to read JSON source asset \"%s\": %s", (re::DynamicString *)buf, a2, v24);
        v25 = *(_OWORD *)buf;
        v26 = *(_OWORD *)v34;
        *(_BYTE *)a4 = 0;
        *(_QWORD *)(a4 + 8) = 100;
        *(_QWORD *)(a4 + 16) = &re::AssetErrorCategory(void)::instance;
        *(_OWORD *)(a4 + 24) = v25;
        *(_OWORD *)(a4 + 40) = v26;
      }
      if (!v43[0] && v44 && (v45 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v44 + 40))();
    }
    else
    {
      *(_OWORD *)buf = v48;
      re::DynamicString::DynamicString((re::DynamicString *)v34, (const re::DynamicString *)&v49);
      *(_BYTE *)a4 = 0;
      *(_OWORD *)(a4 + 8) = *(_OWORD *)buf;
      *(_QWORD *)(a4 + 24) = *(_QWORD *)v34;
      *(_QWORD *)(a4 + 48) = v35;
      *(_OWORD *)(a4 + 32) = *(_OWORD *)&v34[8];
    }
    return (re::DynamicString *)re::Result<re::FileStreamReader,re::DetailedError>::~Result((uint64_t)v47);
  }
  else
  {
    v19 = *re::pipelineLogObjects((re *)this);
    v20 = os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT);
    if (v20)
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_224FE9000, v19, OS_LOG_TYPE_DEFAULT, "TextureAssetCompiler: sourceFilePath is null.", buf, 2u);
    }
    v22 = *(_OWORD *)buf;
    v23 = *(_OWORD *)v34;
    *(_BYTE *)a4 = 0;
    *(_QWORD *)(a4 + 8) = 100;
    *(_QWORD *)(a4 + 16) = &re::AssetErrorCategory(void)::instance;
    *(_OWORD *)(a4 + 24) = v22;
    *(_OWORD *)(a4 + 40) = v23;
  }
  return result;
}

re *re::TextureDefinitionCompiler::deleteAsset(re *this, void (***a2)(_QWORD))
{
  uint64_t v3;

  if (a2)
  {
    v3 = re::globalAllocators(this)[2];
    (**a2)(a2);
    return (re *)(*(uint64_t (**)(uint64_t, void (***)(_QWORD)))(*(_QWORD *)v3 + 40))(v3, a2);
  }
  return this;
}

re *re::TextureDefinitionCompiler::deleteAssetCompileOptions(re *this, void *a2)
{
  uint64_t *v3;

  if (a2)
  {
    v3 = re::globalAllocators(this);
    return (re *)(*(uint64_t (**)(uint64_t, void *))(*(_QWORD *)v3[2] + 40))(v3[2], a2);
  }
  return this;
}

void re::TextureDefinitionCompiler::~TextureDefinitionCompiler(id *this)
{

}

{

  JUMPOUT(0x2276933B8);
}

re::DynamicString *re::KTXTextureCompiler::getCurrentCompiledAssetInfo@<X0>(re::KTXTextureCompiler *this@<X0>, uint64_t a2@<X8>)
{
  re::TextureAsset *v3;
  const char *v5[2];

  *(_QWORD *)(a2 + 32) = 0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  v3 = (re::TextureAsset *)re::DynamicString::setCapacity((_QWORD *)(a2 + 8), 0);
  *(_QWORD *)a2 = 0x100000001;
  v5[0] = (const char *)*re::TextureAsset::assetType(v3);
  v5[1] = (const char *)strlen(v5[0]);
  return re::DynamicString::operator=((re::DynamicString *)(a2 + 8), (uint64_t)v5);
}

__guard re::KTXTextureCompiler::assetIntrospectionType(re::KTXTextureCompiler *this)
{
  unsigned __int8 v1;
  __guard *v2;
  int v4;

  if ((v1 & 1) == 0)
  {
    if (v4)
    {
      re::introspect<re::TextureAsset>(void)::info = re::introspect_TextureAsset(0);
    }
  }
  return v2[449];
}

_QWORD *re::KTXTextureCompiler::getSupportedExtensions@<X0>(uint64_t a1@<X8>)
{
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  return re::DynamicArray<re::TransitionCondition *>::add((_QWORD *)a1, re::KTXTextureCompiler::getSupportedExtensions(void)const::supportedExtensions);
}

void re::KTXTextureCompiler::compile(re::KTXTextureCompiler *this@<X0>, const char *a2@<X1>, char *a3@<X2>, uint64_t a4@<X8>, int16x8_t a5@<Q0>)
{
  char v9;
  unsigned int v10;
  unsigned int v11;
  int v12;
  NSObject *v13;
  _BOOL8 v14;
  __int128 v15;
  __n128 *v16;
  uint64_t v17;
  char v18;
  _anonymous_namespace_ *v19;
  int8x8_t v20;
  int32x2_t v21;
  int v22;
  int v23;
  __n128 *v24;
  unsigned int v25;
  uint64_t *v26;
  _anonymous_namespace_ *v27;
  unsigned int v28;
  uint64_t TextureAsset;
  __n128 *v30;
  char v31;
  const char *v32;
  unint64_t v33;
  unint64_t v34;
  __int16 v35;
  const char *v36;
  uint64_t v37;
  re::KTXTextureCompiler *v38;
  void *v39;
  char v40;
  int16x8_t v41;
  uint64_t v42;
  int v43;
  __int128 v44;
  __n128 *v45;
  __int128 v46;
  uint64_t v47;
  __int16 v48;
  char v49;
  __int16 v50;
  char v51;
  char v52[8];
  uint64_t v53;
  char v54;
  _QWORD v55[2];
  uint64_t v56;
  int v57;
  uint64_t v58;
  uint64_t *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  __int128 v64;
  uint64_t v65;
  int v66;
  int v67;
  uint64_t v68;
  _BOOL4 v69;
  int v70;
  int v71;
  int v72;
  unsigned int v73;
  uint64_t v74;
  char v75;
  int v76;
  char v77;
  int v78;
  char v79;
  int v80;
  id v81;
  uint64_t v82;
  uint64_t v83;
  uint8_t buf[16];
  __n128 *v85;
  __int128 v86;
  uint64_t v87;
  unsigned int v88;
  id v89;
  char v90[8];
  id v91;
  uint64_t v92;
  char v93;
  __int128 v94;
  __n128 *v95;
  __int128 v96;
  uint64_t v97;
  uint64_t v98;

  v98 = *MEMORY[0x24BDAC8D0];
  if (a2)
  {
    v92 = 0;
    v93 = 0;
    if (a3)
    {
      a5.i32[0] = *(_DWORD *)a3;
      v41 = (int16x8_t)vmovl_u8(*(uint8x8_t *)a5.i8);
      v9 = a3[4];
      v50 = *(_WORD *)(a3 + 5);
      v51 = a3[7];
      v11 = *((_DWORD *)a3 + 2);
      v10 = *((_DWORD *)a3 + 3);
      v92 = *((_QWORD *)a3 + 2);
      v93 = a3[24];
      v49 = a3[27];
      v48 = *(_WORD *)(a3 + 25);
      v12 = *((_DWORD *)a3 + 7);
    }
    else
    {
      v10 = 0;
      a5.i64[0] = 0x1000000010001;
      v41 = a5;
      v12 = 0;
      v9 = 1;
      v11 = 1;
    }
    v42 = v92;
    LOBYTE(v43) = v93;
    *(_WORD *)((char *)&v43 + 1) = v48;
    HIBYTE(v43) = v49;
    v18 = *((_BYTE *)this + 40);
    re::Data::makeDataWithContentsOfFile((uint64_t)a2, 0, (uint64_t)v90);
    if (!v90[0])
    {
      *((_QWORD *)&v94 + 1) = 0;
      v95 = 0;
      *(_QWORD *)&v96 = 0;
      re::DynamicString::setCapacity(&v94, 0);
      re::DynamicString::assignf((re::DynamicString *)&v94, "failed to load texture source %s", a2);
      *(_QWORD *)buf = 100;
      *(_QWORD *)&buf[8] = &re::AssetErrorCategory(void)::instance;
      re::DynamicString::DynamicString((re::DynamicString *)&v85, (const re::DynamicString *)&v94);
      TextureAsset = *((_QWORD *)&v86 + 1);
      v30 = v85;
      LOBYTE(v26) = v86;
      v44 = *(_OWORD *)buf;
      v47 = v87;
      v45 = v85;
      v46 = v86;
      if ((_QWORD)v94 && (BYTE8(v94) & 1) != 0)
        (*(void (**)(_QWORD, __n128 *))(*(_QWORD *)v94 + 40))(v94, v95);

LABEL_54:
      *(_OWORD *)buf = v44;
      re::DynamicString::DynamicString((re::DynamicString *)&v85, (const re::DynamicString *)&v45);
      *(_BYTE *)a4 = 0;
      *(_OWORD *)(a4 + 8) = *(_OWORD *)buf;
      v37 = v87;
      *(_QWORD *)(a4 + 24) = v85;
      *(_QWORD *)(a4 + 48) = v37;
      *(_OWORD *)(a4 + 32) = v86;
      if (v30)
      {
        if ((v26 & 1) != 0)
          (*(void (**)(__n128 *, uint64_t))(v30->n128_u64[0] + 40))(v30, TextureAsset);
      }
      return;
    }
    v40 = v9;
    v20.i32[0] = v41.u16[1];
    v20.i32[1] = v41.u16[0];
    v21 = vceqz_s32((int32x2_t)vand_s8(v20, (int8x8_t)0xFF000000FFLL));
    if ((v21.i8[4] & 1) != 0)
      v22 = 2;
    else
      v22 = v21.i8[0] & 1;
    if (v11 <= 1)
      v23 = 1;
    else
      v23 = v11;
    v24 = (__n128 *)objc_msgSend(objc_retainAutorelease(v91), "bytes");
    v68 = 0x200000000;
    v69 = v11 > 1;
    v70 = 0;
    v71 = v23;
    v72 = v22;
    v25 = v10;
    v73 = v10;
    v74 = 0;
    v75 = 0;
    v76 = 0;
    v77 = 0;
    v78 = 0;
    v79 = v18;
    v80 = 6;
    v82 = 0;
    v83 = 0;
    v81 = 0;

    if (v88)
    {
      if (v88 != 1)
      {
        v38 = (re::KTXTextureCompiler *)std::__throw_bad_variant_access[abi:nn180100]();
        re::KTXTextureCompiler::deleteAsset(v38, v39);
        return;
      }
      v28 = v11;
      if (!*((_QWORD *)&v86 + 1) || !*(_QWORD *)&buf[8])
        goto LABEL_19;
    }
    else
    {
      v28 = v11;
      if (!*(_QWORD *)&buf[8])
      {
LABEL_19:
        v60 = 0;
        v61 = 0;
        v62 = 0;
        re::DynamicString::setCapacity(&v59, 0);
        re::DynamicString::assignf((re::DynamicString *)&v59, "failed to load texture %s", a2);
        *(_QWORD *)&v94 = 100;
        *((_QWORD *)&v94 + 1) = &re::AssetErrorCategory(void)::instance;
        re::DynamicString::DynamicString((re::DynamicString *)&v95, (const re::DynamicString *)&v59);
        TextureAsset = *((_QWORD *)&v96 + 1);
        v30 = v95;
        LOBYTE(v26) = v96;
        v44 = v94;
        v47 = v97;
        v45 = v95;
        v46 = v96;
        if (v59 && (v60 & 1) != 0)
          (*(void (**)(void))(*v59 + 40))();
        v31 = 1;
        goto LABEL_51;
      }
    }
    LODWORD(v64) = vmovn_s16(v41).u32[0];
    BYTE4(v64) = v40;
    *(_WORD *)((char *)&v64 + 5) = v50;
    BYTE7(v64) = v51;
    *((_QWORD *)&v64 + 1) = __PAIR64__(v25, v28);
    v65 = v42;
    v66 = v43;
    v67 = v12;
    TextureAsset = re::TextureAsset::makeTextureAsset((uint64_t)buf, 6, &v64);
    v63 = 0;
    v60 = 0;
    v61 = 0;
    v58 = 0;
    v59 = 0;
    LODWORD(v62) = 0;
    v55[1] = 0;
    v56 = 0;
    v55[0] = 0;
    v57 = 0;
    v30 = (__n128 *)objc_msgSend(objc_retainAutorelease(v91), "bytes");
    if (v52[0])
    {
      if (v61)
      {
        v32 = (*(_QWORD *)(v63 + 8) & 1) != 0 ? *(const char **)(v63 + 16) : (const char *)(v63 + 9);
        if (!strcmp(v32, "ToolVersion") && v56)
        {
          v33 = *(_QWORD *)(v58 + 8);
          v34 = v33 >> 1;
          if ((v33 & 1) == 0)
            v34 = v33 >> 1;
          if (v34 < 3)
          {
            if ((v33 & 1) != 0)
              v36 = *(const char **)(v58 + 16);
            else
              v36 = (const char *)(v58 + 9);
            v35 = atoi(v36);
          }
          else
          {
            v35 = 0;
          }
          if (!*(_BYTE *)(TextureAsset + 126))
            *(_BYTE *)(TextureAsset + 126) = 1;
          *(_WORD *)(TextureAsset + 128) = v35;
        }
      }
      *(_QWORD *)&v44 = TextureAsset;
    }
    else
    {
      *(_QWORD *)&v44 = TextureAsset;
      if (v53 && (v54 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v53 + 40))();
    }
    re::DynamicArray<re::DynamicString>::deinit((uint64_t)v55);
    re::DynamicArray<re::DynamicString>::deinit((uint64_t)&v59);
    v31 = 0;
LABEL_51:

    if (v88 != -1)
      ((void (*)(__int128 *, uint8_t *))*(&off_24ED42E60 + v88))(&v94, &buf[8]);

    if ((v31 & 1) == 0)
    {
      *(_BYTE *)a4 = 1;
      *(_QWORD *)(a4 + 8) = v44;
      return;
    }
    goto LABEL_54;
  }
  v13 = *re::pipelineLogObjects(this);
  v14 = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
  if (v14)
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_224FE9000, v13, OS_LOG_TYPE_DEFAULT, "TextureAssetCompiler: sourceFilePath is null.", buf, 2u);
  }
  v15 = *(_OWORD *)buf;
  v16 = v85;
  v17 = v86;
  *(_BYTE *)a4 = 0;
  *(_QWORD *)(a4 + 8) = 100;
  *(_QWORD *)(a4 + 16) = &re::AssetErrorCategory(void)::instance;
  *(_OWORD *)(a4 + 24) = v15;
  *(_QWORD *)(a4 + 40) = v16;
  *(_QWORD *)(a4 + 48) = v17;
}

re *re::KTXTextureCompiler::deleteAsset(re *this, void (***a2)(_QWORD))
{
  uint64_t v3;

  if (a2)
  {
    v3 = re::globalAllocators(this)[2];
    (**a2)(a2);
    return (re *)(*(uint64_t (**)(uint64_t, void (***)(_QWORD)))(*(_QWORD *)v3 + 40))(v3, a2);
  }
  return this;
}

re *re::KTXTextureCompiler::deleteAssetCompileOptions(re *this, void *a2)
{
  uint64_t *v3;

  if (a2)
  {
    v3 = re::globalAllocators(this);
    return (re *)(*(uint64_t (**)(uint64_t, void *))(*(_QWORD *)v3[2] + 40))(v3[2], a2);
  }
  return this;
}

void re::KTXTextureCompiler::~KTXTextureCompiler(id *this)
{

}

{

  JUMPOUT(0x2276933B8);
}

re::DynamicString *re::RenderGraphCompiler::getCurrentCompiledAssetInfo@<X0>(re::RenderGraphCompiler *this@<X0>, uint64_t a2@<X8>)
{
  re::RenderGraphAsset *v3;
  const char *v5[2];

  *(_QWORD *)(a2 + 32) = 0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  v3 = (re::RenderGraphAsset *)re::DynamicString::setCapacity((_QWORD *)(a2 + 8), 0);
  *(_QWORD *)a2 = 0x100000001;
  v5[0] = (const char *)*re::RenderGraphAsset::assetType(v3);
  v5[1] = (const char *)strlen(v5[0]);
  return re::DynamicString::operator=((re::DynamicString *)(a2 + 8), (uint64_t)v5);
}

_QWORD *re::RenderGraphCompiler::getSupportedExtensions@<X0>(uint64_t a1@<X8>)
{
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  re::DynamicArray<re::TransitionCondition *>::add((_QWORD *)a1, re::RenderGraphCompiler::getSupportedExtensions(void)const::supportedExtensions);
  return re::DynamicArray<re::TransitionCondition *>::add((_QWORD *)a1, off_255801748);
}

__guard re::RenderGraphCompiler::assetIntrospectionType(re::RenderGraphCompiler *this)
{
  unsigned __int8 v1;
  __guard *v2;
  int v4;

  if ((v1 & 1) == 0)
  {
    if (v4)
    {
      re::introspect<re::RenderGraphAsset>(void)::info = re::introspect_RenderGraphAsset(0);
    }
  }
  return v2[68];
}

uint64_t re::RenderGraphCompiler::compile@<X0>(re::RenderGraphCompiler *this@<X0>, re::FileStreamReader *a2@<X1>, re::AssetSerializationScheme *a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t *v8;
  void (***v9)(_QWORD);
  unsigned __int8 v10;
  uint64_t v11;
  _anonymous_namespace_ *v12;
  re *v13;
  uint64_t *v14;
  re *v15;
  uint64_t v16;
  char *v17;
  __int128 v18;
  __int128 v19;
  uint64_t v20;
  uint64_t v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v24;
  __int128 v26;
  __int128 v27;
  uint64_t v28;
  uint64_t v29;
  char v30[8];
  uint64_t v31;
  char v32;
  __int128 v33;
  uint64_t v34;
  __int128 v35;
  char *v36;
  char v37[8];
  __int128 v38;
  uint64_t v39;
  _QWORD v40[3];

  v8 = re::globalAllocators(this);
  v9 = (void (***)(_QWORD))(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v8[2] + 32))(v8[2], 872, 8);
  bzero(v9, 0x368uLL);
  re::RenderGraphAsset::RenderGraphAsset((re::RenderGraphAsset *)v9);
  v10 = atomic_load((unsigned __int8 *)&qword_254106130);
  if ((v10 & 1) == 0 && __cxa_guard_acquire(&qword_254106130))
  {
    _MergedGlobals_136 = re::introspect_RenderGraphFile(0);
    __cxa_guard_release(&qword_254106130);
  }
  v11 = _MergedGlobals_136;
  v40[1] = 0;
  v40[2] = 0;
  v40[0] = a3;
  re::FileStreamReader::open(a2, (uint64_t)v37);
  if (!v37[0])
  {
    v33 = v38;
    re::DynamicString::DynamicString((re::DynamicString *)&v34, (const re::DynamicString *)&v39);
    *(_BYTE *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v33;
    *(_QWORD *)(a4 + 24) = v34;
    *(_QWORD *)(a4 + 48) = v36;
    *(_OWORD *)(a4 + 32) = v35;
    return re::Result<re::FileStreamReader,re::DetailedError>::~Result((uint64_t)v37);
  }
  if ((_BYTE)v33)
  {
    v14 = re::RenderGraphFile::calculateValidity((re::RenderGraphFile *)(v9 + 1), (uint64_t)v30);
    if (v30[0])
    {
      re::RenderGraphFile::initRuntimeNodeSettings((re::RenderGraphFile *)(v9 + 1), (uint64_t)&v26);
      v15 = (re *)re::Result<re::Unit,re::DynamicString>::operator=((uint64_t)v30, (uint64_t)&v26);
      if (!(_BYTE)v26)
      {
        v15 = (re *)*((_QWORD *)&v26 + 1);
        if (*((_QWORD *)&v26 + 1))
        {
          if ((v27 & 1) != 0)
            v15 = (re *)(*(uint64_t (**)(void))(**((_QWORD **)&v26 + 1) + 40))();
        }
      }
      if (v30[0])
      {
        *(_BYTE *)a4 = 1;
        *(_QWORD *)(a4 + 8) = v9;
LABEL_19:
        if (!v30[0] && v31 && (v32 & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v31 + 40))();
        goto LABEL_20;
      }
      v21 = re::globalAllocators(v15)[2];
      (**v9)(v9);
      (*(void (**)(uint64_t, void (***)(_QWORD)))(*(_QWORD *)v21 + 40))(v21, v9);
    }
    else
    {
      v20 = re::globalAllocators((re *)v14)[2];
      (**v9)(v9);
      (*(void (**)(uint64_t, void (***)(_QWORD)))(*(_QWORD *)v20 + 40))(v20, v9);
    }
    *(_QWORD *)&v26 = 100;
    *((_QWORD *)&v26 + 1) = &re::AssetErrorCategory(void)::instance;
    re::DynamicString::DynamicString((re::DynamicString *)&v27, (const re::DynamicString *)&v31);
    v22 = v27;
    *(_OWORD *)(a4 + 8) = v26;
    v23 = v28;
    v24 = v29;
    *(_BYTE *)a4 = 0;
    *(_OWORD *)(a4 + 24) = v22;
    *(_QWORD *)(a4 + 40) = v23;
    *(_QWORD *)(a4 + 48) = v24;
    goto LABEL_19;
  }
  v16 = re::globalAllocators(v13)[2];
  (**v9)(v9);
  (*(void (**)(uint64_t, void (***)(_QWORD)))(*(_QWORD *)v16 + 40))(v16, v9);
  if ((BYTE8(v35) & 1) != 0)
    v17 = v36;
  else
    v17 = (char *)&v35 + 9;
  re::DynamicString::format((re::DynamicString *)"Failed to read JSON source asset \"%s\": %s", (re::DynamicString *)&v26, a2, v17);
  v18 = v26;
  v19 = v27;
  *(_BYTE *)a4 = 0;
  *(_QWORD *)(a4 + 8) = 100;
  *(_QWORD *)(a4 + 16) = &re::AssetErrorCategory(void)::instance;
  *(_OWORD *)(a4 + 24) = v18;
  *(_OWORD *)(a4 + 40) = v19;
LABEL_20:
  if (!(_BYTE)v33 && (_QWORD)v35 && (BYTE8(v35) & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v35 + 40))();
  return re::Result<re::FileStreamReader,re::DetailedError>::~Result((uint64_t)v37);
}

re *re::RenderGraphCompiler::deleteAsset(re *this, void (***a2)(_QWORD))
{
  uint64_t v3;

  if (a2)
  {
    v3 = re::globalAllocators(this)[2];
    (**a2)(a2);
    return (re *)(*(uint64_t (**)(uint64_t, void (***)(_QWORD)))(*(_QWORD *)v3 + 40))(v3, a2);
  }
  return this;
}

re::DynamicString *re::RenderGraphEmitterCompiler::getCurrentCompiledAssetInfo@<X0>(re::RenderGraphEmitterCompiler *this@<X0>, uint64_t a2@<X8>)
{
  re::RenderGraphEmitterAsset *v3;
  const char *v5[2];

  *(_QWORD *)(a2 + 32) = 0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  v3 = (re::RenderGraphEmitterAsset *)re::DynamicString::setCapacity((_QWORD *)(a2 + 8), 0);
  *(_QWORD *)a2 = 0x100000001;
  v5[0] = (const char *)*re::RenderGraphEmitterAsset::assetType(v3);
  v5[1] = (const char *)strlen(v5[0]);
  return re::DynamicString::operator=((re::DynamicString *)(a2 + 8), (uint64_t)v5);
}

__guard re::RenderGraphEmitterCompiler::assetIntrospectionType(re::RenderGraphEmitterCompiler *this)
{
  unsigned __int8 v1;
  __guard *v2;
  int v4;

  if ((v1 & 1) == 0)
  {
    if (v4)
    {
      re::introspect<re::RenderGraphEmitterAsset>(void)::info = re::introspect_RenderGraphEmitterAsset(0);
    }
  }
  return v2[281];
}

_QWORD *re::RenderGraphEmitterCompiler::getSupportedExtensions@<X0>(uint64_t a1@<X8>)
{
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  return re::DynamicArray<re::TransitionCondition *>::add((_QWORD *)a1, &re::RenderGraphEmitterCompiler::getSupportedExtensions(void)const::supportedExtensions);
}

re *re::RenderGraphEmitterCompiler::compile@<X0>(re::RenderGraphEmitterCompiler *this@<X0>, re::AssetUtilities *a2@<X1>, re::AssetSerializationScheme *a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t *v8;
  uint64_t v9;
  const char *v10;
  unsigned __int8 v11;
  re *SourceJson;
  re *result;
  uint64_t v14;
  uint64_t v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;
  uint64_t v23;
  _BYTE v24[8];
  re *v25;
  char v26;

  v8 = re::globalAllocators(this);
  v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v8[2] + 32))(v8[2], 32, 8);
  *(_QWORD *)(v9 + 8) = 0;
  v10 = (const char *)(v9 + 8);
  *(_QWORD *)(v9 + 16) = 0;
  *(_QWORD *)(v9 + 24) = 0;
  *(_QWORD *)v9 = &off_24ED30678;
  v11 = atomic_load((unsigned __int8 *)&qword_254106140);
  if ((v11 & 1) == 0)
  {
    v19 = __cxa_guard_acquire(&qword_254106140);
    v10 = (const char *)(v9 + 8);
    if (v19)
    {
      qword_254106138 = re::introspect_RenderGraphEmitterPointer(0);
      __cxa_guard_release(&qword_254106140);
      v10 = (const char *)(v9 + 8);
    }
  }
  SourceJson = (re *)re::AssetUtilities::readSourceJson(a2, v10, qword_254106138, a3, (uint64_t)v24);
  if (!v24[0])
  {
    v14 = re::globalAllocators(SourceJson)[2];
    (**(void (***)(uint64_t))v9)(v9);
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v14 + 40))(v14, v9);
LABEL_11:
    *(_QWORD *)&v20 = 100;
    *((_QWORD *)&v20 + 1) = &re::AssetErrorCategory(void)::instance;
    result = re::DynamicString::DynamicString((re::DynamicString *)&v21, (const re::DynamicString *)&v25);
    v16 = v21;
    *(_OWORD *)(a4 + 8) = v20;
    v17 = v22;
    v18 = v23;
    *(_BYTE *)a4 = 0;
    *(_OWORD *)(a4 + 24) = v16;
    *(_QWORD *)(a4 + 40) = v17;
    *(_QWORD *)(a4 + 48) = v18;
    goto LABEL_12;
  }
  re::RenderGraphEmitterBase::initRuntimeSettings(*(re::RenderGraphEmitterBase **)(v9 + 16), *(_QWORD *)(v9 + 8), (uint64_t)&v20);
  result = (re *)re::Result<re::Unit,re::DynamicString>::operator=((uint64_t)v24, (uint64_t)&v20);
  if (!(_BYTE)v20)
  {
    result = (re *)*((_QWORD *)&v20 + 1);
    if (*((_QWORD *)&v20 + 1))
    {
      if ((v21 & 1) != 0)
        result = (re *)(*(uint64_t (**)(void))(**((_QWORD **)&v20 + 1) + 40))();
    }
  }
  if (!v24[0])
  {
    v15 = re::globalAllocators(result)[2];
    (**(void (***)(uint64_t))v9)(v9);
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v15 + 40))(v15, v9);
    goto LABEL_11;
  }
  *(_BYTE *)a4 = 1;
  *(_QWORD *)(a4 + 8) = v9;
LABEL_12:
  if (!v24[0])
  {
    result = v25;
    if (v25)
    {
      if ((v26 & 1) != 0)
        return (re *)(*(uint64_t (**)(void))(*(_QWORD *)v25 + 40))();
    }
  }
  return result;
}

re *re::RenderGraphEmitterCompiler::deleteAsset(re *this, void (***a2)(_QWORD))
{
  uint64_t v3;

  if (a2)
  {
    v3 = re::globalAllocators(this)[2];
    (**a2)(a2);
    return (re *)(*(uint64_t (**)(uint64_t, void (***)(_QWORD)))(*(_QWORD *)v3 + 40))(v3, a2);
  }
  return this;
}

void re::RenderGraphCompiler::~RenderGraphCompiler(re::RenderGraphCompiler *this)
{
  JUMPOUT(0x2276933B8);
}

void re::RenderGraphEmitterCompiler::~RenderGraphEmitterCompiler(re::RenderGraphEmitterCompiler *this)
{
  JUMPOUT(0x2276933B8);
}

re::TextureImportOperation *re::TextureImportOperation::TextureImportOperation(re::TextureImportOperation *this, re::TextureProvider *a2, char a3, re::AssetManager *a4)
{
  _anonymous_namespace_ *v8;
  _anonymous_namespace_ *v9;
  _anonymous_namespace_ *v10;
  _anonymous_namespace_ *v11;
  _anonymous_namespace_ *v12;
  _anonymous_namespace_ *v13;
  _anonymous_namespace_ *v14;

  ArcSharedObject::ArcSharedObject(this, 0);
  *(_QWORD *)this = &off_24ED42F50;
  *((_QWORD *)this + 3) = a4;
  *((_DWORD *)this + 8) = 0;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  v9 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)this + 5, 0);
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  v10 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)this + 9, 0);
  *((_QWORD *)this + 13) = 0;
  *((_DWORD *)this + 28) = 0;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  v11 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)this + 15, 0);
  *(_OWORD *)((char *)this + 168) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  v12 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)this + 19, 0);
  *(_OWORD *)((char *)this + 200) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  v13 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)this + 23, 0);
  *((_BYTE *)this + 216) &= 0x80u;
  *((_QWORD *)this + 28) = 0;
  *((_DWORD *)this + 76) = 0;
  *((_QWORD *)this + 43) = 0;
  *(_OWORD *)((char *)this + 312) = 0u;
  *(_OWORD *)((char *)this + 328) = 0u;
  v14 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)this + 40, 0);
  *((_DWORD *)this + 94) = 0;
  *((_QWORD *)this + 46) = 0;
  *((_OWORD *)this + 22) = 0u;
  *((_OWORD *)this + 24) = 0u;
  *((_OWORD *)this + 25) = 0u;
  *((_DWORD *)this + 104) = 0;
  *(_OWORD *)((char *)this + 424) = 0u;
  *(_OWORD *)((char *)this + 440) = 0u;
  *((_QWORD *)this + 57) = 0;
  re::DynamicString::setCapacity((_QWORD *)this + 54, 0);
  *((_QWORD *)this + 62) = a2;
  *((_BYTE *)this + 504) = a3;
  *((_OWORD *)this + 29) = 0u;
  *((_OWORD *)this + 30) = 0u;
  return this;
}

void re::TextureImportOperation::~TextureImportOperation(re::TextureImportOperation *this)
{
  re::TextureImportOperation *v1;
  void (***v2)(_QWORD);
  uint64_t v3;
  void (***v4)(_QWORD);
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char v16;

  v1 = this;
  *(_QWORD *)this = &off_24ED42F50;
  if (*((_BYTE *)this + 504))
  {
    v2 = (void (***)(_QWORD))*((_QWORD *)this + 62);
    if (v2)
    {
      v3 = re::globalAllocators(this)[2];
      (**v2)(v2);
      this = (re::TextureImportOperation *)(*(uint64_t (**)(uint64_t, void (***)(_QWORD)))(*(_QWORD *)v3 + 40))(v3, v2);
    }
    *((_QWORD *)v1 + 62) = 0;
  }
  v4 = (void (***)(_QWORD))*((_QWORD *)v1 + 58);
  if (v4)
  {
    v5 = re::globalAllocators(this)[2];
    (**v4)(v4);
    (*(void (**)(uint64_t, void (***)(_QWORD)))(*(_QWORD *)v5 + 40))(v5, v4);
    *((_QWORD *)v1 + 58) = 0;
  }
  re::AssetHandle::~AssetHandle((re::TextureImportOperation *)((char *)v1 + 472));
  v6 = *((_QWORD *)v1 + 54);
  if (v6)
  {
    if ((*((_BYTE *)v1 + 440) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v6 + 40))(v6, *((_QWORD *)v1 + 56));
    *((_OWORD *)v1 + 27) = 0u;
    *((_OWORD *)v1 + 28) = 0u;
  }
  v7 = *((_QWORD *)v1 + 49);
  if (v7)
  {
    if (*((_QWORD *)v1 + 53))
      (*(void (**)(uint64_t))(*(_QWORD *)v7 + 40))(v7);
    *((_QWORD *)v1 + 53) = 0;
    *((_QWORD *)v1 + 50) = 0;
    *((_QWORD *)v1 + 51) = 0;
    *((_QWORD *)v1 + 49) = 0;
    ++*((_DWORD *)v1 + 104);
  }
  v8 = (_QWORD *)((char *)v1 + 320);
  v9 = *((_QWORD *)v1 + 44);
  if (v9)
  {
    if (*((_QWORD *)v1 + 48))
      (*(void (**)(uint64_t))(*(_QWORD *)v9 + 40))(v9);
    *((_QWORD *)v1 + 48) = 0;
    *((_QWORD *)v1 + 45) = 0;
    *((_QWORD *)v1 + 46) = 0;
    *((_QWORD *)v1 + 44) = 0;
    ++*((_DWORD *)v1 + 94);
  }
  if (*v8)
  {
    if ((*((_BYTE *)v1 + 328) & 1) != 0)
      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*v8 + 40))(*v8, *((_QWORD *)v1 + 42));
    *(_OWORD *)v8 = 0u;
    *((_OWORD *)v1 + 21) = 0u;
  }

  v10 = *((unsigned int *)v1 + 76);
  if ((_DWORD)v10 != -1)
    ((void (*)(char *, char *))*(&off_24ED42F88 + v10))(&v16, (char *)v1 + 224);
  v11 = *((_QWORD *)v1 + 23);
  *((_DWORD *)v1 + 76) = -1;
  if (v11)
  {
    if ((*((_BYTE *)v1 + 192) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v11 + 40))(v11, *((_QWORD *)v1 + 25));
    *(_OWORD *)((char *)v1 + 184) = 0u;
    *(_OWORD *)((char *)v1 + 200) = 0u;
  }
  v12 = *((_QWORD *)v1 + 19);
  if (v12)
  {
    if ((*((_BYTE *)v1 + 160) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v12 + 40))(v12, *((_QWORD *)v1 + 21));
    *(_OWORD *)((char *)v1 + 152) = 0u;
    *(_OWORD *)((char *)v1 + 168) = 0u;
  }
  v13 = *((_QWORD *)v1 + 15);
  if (v13)
  {
    if ((*((_BYTE *)v1 + 128) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v13 + 40))(v13, *((_QWORD *)v1 + 17));
    *(_OWORD *)((char *)v1 + 120) = 0u;
    *(_OWORD *)((char *)v1 + 136) = 0u;
  }
  v14 = *((_QWORD *)v1 + 9);
  if (v14)
  {
    if ((*((_BYTE *)v1 + 80) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v14 + 40))(v14, *((_QWORD *)v1 + 11));
    *(_OWORD *)((char *)v1 + 72) = 0u;
    *(_OWORD *)((char *)v1 + 88) = 0u;
  }
  v15 = *((_QWORD *)v1 + 5);
  if (v15)
  {
    if ((*((_BYTE *)v1 + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v15 + 40))(v15, *((_QWORD *)v1 + 7));
    *(_OWORD *)((char *)v1 + 40) = 0u;
    *(_OWORD *)((char *)v1 + 56) = 0u;
  }
  *(_QWORD *)v1 = &off_24ED426B8;
  objc_destructInstance((char *)v1 + 8);
}

{
  re::TextureImportOperation::~TextureImportOperation(this);
  JUMPOUT(0x2276933B8);
}

void re::USDImportContext::init(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int8 *a4, unsigned __int8 *a5, char a6, double a7)
{
  int v9;
  BOOL v10;
  BOOL v11;
  BOOL v12;
  int v13;
  BOOL v14;
  BOOL v15;
  int v16;
  int v17;
  uint64_t *v18;
  _anonymous_namespace_ *v19;
  _anonymous_namespace_ *v20;
  _anonymous_namespace_ *v21;
  _anonymous_namespace_ *v22;
  _anonymous_namespace_ *v23;
  _anonymous_namespace_ *v24;
  _anonymous_namespace_ *v25;
  uint64_t v26;
  _QWORD v27[7];
  _OWORD v28[2];
  uint64_t v29;
  __int128 v30;
  int v31;
  uint64_t v32;
  __int128 v33;
  int v34;
  uint64_t v35;
  int v36;
  char v37;
  int v38;
  __int16 v39;
  int v40;
  int v41;
  char v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  char v46;
  uint64_t v47;
  uint64_t v48;
  __int128 v49;
  uint64_t v50;
  int v51;
  __int128 v52;
  __int128 v53;
  int v54;
  __int128 v55;
  __int128 v56;
  int v57;
  __int128 v58;
  __int128 v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  __int128 v64;
  void (**v65)(re::TimelineAssetData *__hidden);
  uint64_t v66;
  char v67;
  uint64_t v68;
  void *v69;
  _WORD v70[18];
  int v71;
  __int128 v72;
  __int128 v73;
  int v74;
  uint64_t v75;
  _OWORD v76[2];
  uint64_t v77;
  _QWORD v78[8];
  _QWORD v79[4];
  _QWORD v80[4];
  _QWORD v81[4];
  __int128 v82;
  uint64_t v83;
  int v84;
  __int128 v85;
  __int128 v86;
  uint64_t v87;
  __int128 v88;
  int v89;
  uint64_t v90;
  __int128 v91;
  int v92;
  __int128 v93;
  _BYTE v94[96];
  int v95;
  uint64_t v96;
  uint64_t v97;

  v97 = *MEMORY[0x24BDAC8D0];
  *(double *)a1 = a7;
  v9 = *a4;
  if (*(_BYTE *)(a1 + 16))
    v10 = 0;
  else
    v10 = v9 == 0;
  if (!v10)
  {
    if (*(_BYTE *)(a1 + 16))
      v11 = v9 == 0;
    else
      v11 = 0;
    if (v11)
    {
      *(_BYTE *)(a1 + 16) = 0;
    }
    else
    {
      if (*(_BYTE *)(a1 + 16))
        v12 = 1;
      else
        v12 = v9 == 0;
      if (!v12)
        *(_BYTE *)(a1 + 16) = 1;
      *(_DWORD *)(a1 + 20) = *((_DWORD *)a4 + 1);
    }
  }
  v13 = *a5;
  if (*(_BYTE *)(a1 + 24))
    v14 = 0;
  else
    v14 = v13 == 0;
  if (!v14)
  {
    if (*(_BYTE *)(a1 + 24))
      v15 = v13 == 0;
    else
      v15 = 0;
    if (v15)
    {
      *(_BYTE *)(a1 + 24) = 0;
    }
    else
    {
      if (!*(_BYTE *)(a1 + 24) && *a5)
        *(_BYTE *)(a1 + 24) = 1;
      *(_DWORD *)(a1 + 28) = *((_DWORD *)a5 + 1);
    }
  }
  if (*a4)
    v16 = *((_DWORD *)a4 + 1);
  else
    v16 = 2139095040;
  *(_DWORD *)(a1 + 8) = v16;
  if (*a5)
    v17 = *((_DWORD *)a5 + 1);
  else
    v17 = -8388608;
  *(_DWORD *)(a1 + 12) = v17;
  *(_BYTE *)(a1 + 32) = a6;
  *(_QWORD *)(a1 + 40) = a3;
  re::BucketArray<re::USDImportContextSkeletonData,4ul>::init(a1 + 56, a2, 1uLL);
  re::HashTable<re::StringID,unsigned long,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init(a1 + 112, a2, 4);
  re::BucketArray<re::USDImportContextSkeletalAnimationData,8ul>::init(a1 + 160, a2, 1uLL);
  re::HashTable<re::StringID,unsigned long,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init(a1 + 216, a2, 8);
  re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::init(a1 + 624, a2, 1uLL);
  v18 = re::BucketArray<unsigned long,32ul>::init(a1 + 680, a2, 1uLL);
  re::DynamicString::setCapacity((_QWORD *)(a1 + 784), 0x40uLL);
  *(_QWORD *)(a1 + 816) = a2;
  re::DynamicArray<re::EvaluationRegisterId<int>>::setCapacity((_QWORD *)(a1 + 816), 0x20uLL);
  ++*(_DWORD *)(a1 + 840);
  re::HashTable<re::StringID,unsigned long,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init(a1 + 856, a2, 3);
  bzero(v27, 0x430uLL);
  v27[2] = &str_110;
  v27[4] = &str_110;
  v27[6] = &str_110;
  memset(v28, 0, sizeof(v28));
  v29 = 0x7FFFFFFF00000000;
  v30 = 0u;
  v31 = 1;
  v32 = 0;
  v33 = 0u;
  v34 = 0;
  v35 = -1;
  v36 = 16842752;
  v37 = 1;
  v38 = 0;
  v39 = 0;
  v40 = 1036831949;
  v41 = 16843008;
  v42 = 0;
  v44 = 0u;
  v45 = 0u;
  v43 = 0u;
  DWORD1(v45) = 0x7FFFFFFF;
  v46 = -1;
  v47 = 0;
  v48 = 0x3F80000000000000;
  v51 = 0;
  v50 = 0;
  v49 = 0u;
  v52 = 0u;
  v53 = 0u;
  v54 = 0;
  v55 = 0u;
  v56 = 0u;
  v57 = 0;
  v58 = 0u;
  v59 = 0u;
  v60 = 0x3F8000003F800000;
  v61 = 1065353216;
  v62 = 0;
  v63 = 0x3F80000000000000;
  v64 = 0u;
  v65 = off_24ED36578;
  v66 = 33;
  v67 = 0;
  v68 = 0;
  v69 = &str_110;
  v70[16] = 256;
  v71 = 1023969417;
  v75 = 0;
  v72 = 0u;
  v73 = 0u;
  v74 = 0;
  v65 = (void (**)(re::TimelineAssetData *__hidden))off_24ED339F8;
  memset(v76, 0, sizeof(v76));
  v77 = 0;
  v22 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)v76 + 1, 0);
  memset(v78, 0, 32);
  v23 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v78, 0);
  memset(v79, 0, sizeof(v79));
  v24 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v79, 0);
  memset(v80, 0, sizeof(v80));
  v25 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v80, 0);
  memset(v81, 0, sizeof(v81));
  re::DynamicString::setCapacity(v81, 0);
  v82 = 0u;
  v84 = 0;
  v83 = 0;
  v85 = 0u;
  v86 = 0u;
  v87 = -1;
  v88 = 0u;
  v89 = 1;
  v90 = 0;
  v91 = 0u;
  v92 = 0;
  v93 = 0u;
  memset(v94, 0, 28);
  v96 = 0;
  memset(&v94[32], 0, 64);
  v95 = 0;
  v26 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::addUninitialized(a1 + 624);
  re::USDImportContext::NodeStackItem::NodeStackItem(v26, (uint64_t)v27);
  re::USDImportContext::NodeStackItem::~NodeStackItem((re::USDImportContext::NodeStackItem *)v27);
  v27[0] = 0;
  re::DynamicArray<unsigned long>::add((_QWORD *)(a1 + 816), v27);
  re::BucketArray<re::USDImportContextPhysicsColliderData,8ul>::init(a1 + 368, a2, 1uLL);
  re::HashTable<re::StringID,unsigned long,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init(a1 + 424, a2, 8);
  re::HashTable<re::StringID,unsigned long,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init(a1 + 472, a2, 8);
  re::BucketArray<re::USDImportContextPhysicsRigidBodyData,8ul>::init(a1 + 520, a2, 1uLL);
  re::HashTable<re::StringID,unsigned long,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init(a1 + 576, a2, 8);
}

_QWORD *re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  _QWORD *result;

  *(_QWORD *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((_QWORD *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(_QWORD *)(a1 + 40) = 0;
  result = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::setBucketsCapacity((_QWORD *)a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

uint64_t *re::BucketArray<unsigned long,32ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t *result;

  *(_QWORD *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((_QWORD *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(_QWORD *)(a1 + 40) = 0;
  result = re::BucketArray<unsigned long,32ul>::setBucketsCapacity((uint64_t *)a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

double re::USDImportContext::deinit(re::USDImportContext *this)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0xFF7FFFFF7F7FFFFFLL;
  *((_QWORD *)this + 5) = 0;
  re::BucketArray<re::USDImportContextSkeletonData,4ul>::deinit((uint64_t)this + 56);
  re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 14);
  re::BucketArray<re::USDImportContextSkeletalAnimationData,8ul>::deinit((uint64_t)this + 160);
  re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 27);
  re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::deinit((uint64_t)this + 624);
  re::BucketArray<re::ecs2::Entity const*,32ul>::deinit((uint64_t)this + 680);
  v2 = *((_QWORD *)this + 98);
  if (v2)
  {
    if ((*((_BYTE *)this + 792) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *((_QWORD *)this + 100));
    *((_OWORD *)this + 49) = 0u;
    *((_OWORD *)this + 50) = 0u;
  }
  v3 = *((_QWORD *)this + 102);
  if (v3)
  {
    if (*((_QWORD *)this + 106))
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
    *((_QWORD *)this + 106) = 0;
    *((_QWORD *)this + 103) = 0;
    *((_QWORD *)this + 104) = 0;
    *((_QWORD *)this + 102) = 0;
    ++*((_DWORD *)this + 210);
  }
  re::USDImportContext::PhysicsColliderTable::deinit((re::USDImportContext *)((char *)this + 368));
  re::BucketArray<re::USDImportContextPhysicsColliderData,8ul>::deinit((uint64_t)this + 520);
  re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 72);
  return re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 107);
}

uint64_t re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::deinit(uint64_t a1)
{
  uint64_t v2;
  unint64_t i;
  re::USDImportContext::NodeStackItem *v4;
  uint64_t result;

  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    for (i = 0; i != v2; ++i)
    {
      v4 = (re::USDImportContext::NodeStackItem *)re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[](a1, i);
      re::USDImportContext::NodeStackItem::~NodeStackItem(v4);
    }
  }
  while (*(_QWORD *)(a1 + 8))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)a1);
  result = re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1);
  *(_QWORD *)(a1 + 40) = 0;
  ++*(_DWORD *)(a1 + 48);
  return result;
}

double re::USDImportContext::PhysicsColliderTable::deinit(re::USDImportContext::PhysicsColliderTable *this)
{
  uint64_t v2;
  unint64_t i;
  uint64_t v4;
  re *v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  void (***v9)(_QWORD);
  uint64_t v10;
  _OWORD v12[4];
  char v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    for (i = 0; i != v2; ++i)
    {
      v4 = re::BucketArray<re::USDImportContextPhysicsColliderData,8ul>::operator[]((uint64_t)this, i);
      v5 = re::StringID::StringID((re::StringID *)v12, (const StringID *)v4);
      v6 = *(_OWORD *)(v4 + 16);
      v7 = *(_OWORD *)(v4 + 32);
      v8 = *(_OWORD *)(v4 + 48);
      v13 = *(_BYTE *)(v4 + 64);
      v12[2] = v7;
      v12[3] = v8;
      v12[1] = v6;
      v9 = (void (***)(_QWORD))v6;
      if ((_QWORD)v6)
      {
        v10 = re::globalAllocators(v5)[2];
        (**v9)(v9);
        (*(void (**)(uint64_t, void (***)(_QWORD)))(*(_QWORD *)v10 + 40))(v10, v9);
      }
      re::StringID::destroyString((re::StringID *)v12);
    }
  }
  re::BucketArray<re::USDImportContextPhysicsColliderData,8ul>::deinit((uint64_t)this);
  re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 7);
  return re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 13);
}

uint64_t re::USDImportContext::pushNodePath(re::USDImportContext *this, const char *a2, const char *a3, const char *a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t result;
  const char *v10[2];

  v5 = re::USDImportContext::pushNodeLevel(this, a2, a3, a4, 1);
  v7 = *((_QWORD *)this + 83);
  if (v7)
  {
    v8 = v5;
    v10[0] = *(const char **)(re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[]((uint64_t)this + 624, v7 - 1)+ 32);
    v10[1] = (const char *)strlen(v10[0]);
    re::DynamicString::operator=((re::USDImportContext *)((char *)this + 784), (uint64_t)v10);
    return v8;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v6, "assertion failure: '%s' (%s:line %i) Array is empty", "m_size > 0", "last", 768);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::USDImportContext::pushNodeLevel(re::USDImportContext *this, const char *a2, const char *a3, const char *a4, int a5)
{
  unint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _anonymous_namespace_ *v15;
  const char *v16;
  _anonymous_namespace_ *v17;
  char *var1;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  _anonymous_namespace_ *v25;
  const char *v26;
  _anonymous_namespace_ *v27;
  _anonymous_namespace_ *v28;
  _anonymous_namespace_ *v29;
  _anonymous_namespace_ *v30;
  _anonymous_namespace_ *v31;
  _anonymous_namespace_ *v32;
  _anonymous_namespace_ *v33;
  _anonymous_namespace_ *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v38;
  char v39;
  _BYTE v40[23];
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  unint64_t v44;
  StringID v45;
  uint64_t v46;
  uint64_t v47;
  _QWORD v48[2];
  _QWORD v49[2];
  _BYTE v50[32];
  int v51;
  uint64_t v52;
  __int128 v53;
  uint64_t v54;
  uint64_t v55;
  __int128 v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  char v60;
  int v61;
  __int16 v62;
  uint64_t v63;
  char v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  char v68;
  uint64_t v69;
  uint64_t v70;
  __int128 v71;
  uint64_t v72;
  int v73;
  __int128 v74;
  __int128 v75;
  int v76;
  __int128 v77;
  __int128 v78;
  int v79;
  __int128 v80;
  __int128 v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  __int128 v86;
  void (**v87)(re::TimelineAssetData *__hidden);
  uint64_t v88;
  char v89;
  uint64_t v90;
  void *v91;
  _WORD v92[18];
  int v93;
  __int128 v94;
  __int128 v95;
  int v96;
  uint64_t v97;
  _OWORD v98[2];
  uint64_t v99;
  _QWORD v100[8];
  _QWORD v101[4];
  _QWORD v102[4];
  _QWORD v103[4];
  __int128 v104;
  uint64_t v105;
  int v106;
  __int128 v107;
  __int128 v108;
  unint64_t v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  uint64_t v113;
  __int128 v114;
  _BYTE v115[96];
  int v116;
  uint64_t v117;
  uint64_t v118;

  v118 = *MEMORY[0x24BDAC8D0];
  v10 = *(_QWORD *)(*((_QWORD *)this + 106) + 8 * *((_QWORD *)this + 104) - 8);
  v11 = (char *)this + 624;
  v12 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[]((uint64_t)this + 624, v10);
  v13 = v12;
  if (a5)
  {
    re::UniqueNameGenerator::uniqueName((re::UniqueNameGenerator *)(v12 + 56), a2, a3, (re::StringID *)&v45);
  }
  else
  {
    *(_QWORD *)&v45.var0 = 0;
    v45.var1 = (char *)&str_110;
  }
  v14 = *((_QWORD *)this + 83);
  v15 = (_anonymous_namespace_ *)re::BucketArray<unsigned long,8ul>::addUninitialized(v13 + 880);
  *(_QWORD *)v15 = v14;
  v16 = *(const char **)(v13 + 32);
  var1 = v45.var1;
  v19 = v44 & 1;
  v20 = v44 >> 1;
  v21 = v44 >> 1;
  if ((v44 & 1) != 0)
    v22 = v44 >> 1;
  else
    v22 = v44 >> 1;
  if (v22)
  {
    if (v22 != 1 || *(_BYTE *)re::DynamicString::operator[]((uint64_t)&v43, 0) != 47)
    {
LABEL_20:
      re::DynamicString::append((re::DynamicString *)&v43, "/", 1uLL);
      goto LABEL_21;
    }
    v19 = v44 & 1;
    v20 = v44 >> 1;
    v21 = v44 >> 1;
  }
  if (v19)
    v23 = v20;
  else
    v23 = v21;
  if (!v23)
  {
    v24 = (v42 & 1) != 0 ? v42 >> 1 : v42 >> 1;
    if (v24 != 1 || *(_BYTE *)re::DynamicString::operator[]((uint64_t)&v41, 0) != 47)
      goto LABEL_20;
  }
LABEL_21:
  LOBYTE(v46) = 0;
  re::StringID::StringID((re::StringID *)&v47, &v45);
  v25 = (_anonymous_namespace_ *)re::DynamicString::operator+((re::DynamicString *)&v43, v45.var1, (re::DynamicString *)&v38);
  if ((v39 & 1) != 0)
    v26 = *(const char **)&v40[7];
  else
    v26 = v40;
  v48[0] = 0;
  v48[1] = &str_110;
  v49[0] = 0;
  v49[1] = &str_110;
  v51 = 0;
  memset(v50, 0, sizeof(v50));
  v52 = 0x7FFFFFFFLL;
  v54 = 1;
  v53 = 0u;
  v56 = 0u;
  v55 = 0;
  v57 = 0;
  v58 = -1;
  v59 = 16842752;
  v60 = 1;
  v61 = 0;
  v62 = 0;
  v63 = 0x10101003DCCCCCDLL;
  v64 = 0;
  v66 = 0u;
  v67 = 0u;
  v65 = 0u;
  DWORD1(v67) = 0x7FFFFFFF;
  v68 = -1;
  v69 = 0;
  v70 = 0x3F80000000000000;
  v73 = 0;
  v72 = 0;
  v71 = 0u;
  v76 = 0;
  v74 = 0u;
  v75 = 0u;
  v77 = 0u;
  v78 = 0u;
  v79 = 0;
  v80 = 0u;
  v81 = 0u;
  v83 = 1065353216;
  v82 = 0x3F8000003F800000;
  v85 = 0x3F80000000000000;
  v84 = 0;
  v86 = 0u;
  v87 = off_24ED36578;
  v88 = 33;
  v89 = 0;
  v91 = &str_110;
  v90 = 0;
  v92[16] = 256;
  v93 = 1023969417;
  v97 = 0;
  v94 = 0u;
  v95 = 0u;
  v96 = 0;
  v87 = (void (**)(re::TimelineAssetData *__hidden))off_24ED339F8;
  memset(v98, 0, sizeof(v98));
  v99 = 0;
  v31 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)v98 + 1, 0);
  memset(v100, 0, 32);
  v32 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v100, 0);
  memset(&v100[4], 0, 32);
  memset(v101, 0, sizeof(v101));
  v33 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v101, 0);
  memset(v102, 0, sizeof(v102));
  v34 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v102, 0);
  memset(v103, 0, sizeof(v103));
  re::DynamicString::setCapacity(v103, 0);
  v104 = 0u;
  v106 = 0;
  v105 = 0;
  v107 = 0u;
  v108 = 0u;
  v109 = v10;
  v113 = 0;
  v110 = 0u;
  v111 = 1u;
  v112 = 0uLL;
  v114 = 0u;
  memset(v115, 0, 28);
  v117 = 0;
  memset(&v115[32], 0, 64);
  v116 = 0;
  v35 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::addUninitialized((uint64_t)v11);
  re::USDImportContext::NodeStackItem::NodeStackItem(v35, (uint64_t)&v46);
  re::USDImportContext::NodeStackItem::~NodeStackItem((re::USDImportContext::NodeStackItem *)&v46);
  if (v38 && (v39 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v38 + 40))();
  v46 = *((_QWORD *)this + 83) - 1;
  re::DynamicArray<unsigned long>::add((_QWORD *)this + 102, &v46);
  if (!v10)
    re::USDImportContext::setNodeAsEntity(this, *(_QWORD *)(*((_QWORD *)this + 106) + 8 * *((_QWORD *)this + 104) - 8));
  v36 = *((_QWORD *)this + 83);
  if (v41 && (v42 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v41 + 40))();
  if (v43 && (v44 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v43 + 40))();
  re::StringID::destroyString((re::StringID *)&v45);
  return v36 - 1;
}

uint64_t re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1011, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(_QWORD *)(a1 + 8) <= a2 >> 5)
    goto LABEL_8;
  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
    v3 = a1 + 24;
  else
    v3 = *(_QWORD *)(a1 + 32);
  return *(_QWORD *)(v3 + 8 * (a2 >> 5)) + 1072 * (a2 & 0x1F);
}

{
  unint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1018, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(_QWORD *)(a1 + 8) <= a2 >> 5)
    goto LABEL_8;
  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
    v3 = a1 + 24;
  else
    v3 = *(_QWORD *)(a1 + 32);
  return *(_QWORD *)(v3 + 8 * (a2 >> 5)) + 1072 * (a2 & 0x1F);
}

uint64_t re::USDImportContext::popNodePath(re::USDImportContext *this)
{
  _QWORD *v2;
  uint64_t result;
  uint64_t v4;
  _BYTE *v5;
  _BYTE v6[8];
  unint64_t v7;

  v2 = (_QWORD *)((char *)this + 784);
  result = re::DynamicString::rfind((uint64_t)this + 784, 47, v6);
  if (v6[0])
  {
    result = (uint64_t)re::DynamicString::resize(v2, v7, 0);
  }
  else
  {
    v4 = *((_QWORD *)this + 99);
    if ((v4 & 1) != 0)
    {
      *((_QWORD *)this + 99) = 1;
      v5 = (_BYTE *)*((_QWORD *)this + 100);
    }
    else
    {
      *((_BYTE *)this + 792) = v4 & 1;
      v5 = (char *)this + 793;
    }
    *v5 = 0;
  }
  --*((_QWORD *)this + 104);
  ++*((_DWORD *)this + 210);
  return result;
}

uint64_t re::USDImportContext::setNodeAsEntity(re::USDImportContext *this, unint64_t a2)
{
  char *v4;
  uint64_t result;
  uint64_t v6;

  v4 = (char *)this + 624;
  result = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[]((uint64_t)this + 624, a2);
  if (*(_QWORD *)(result + 160) == -1)
  {
    *(_QWORD *)re::BucketArray<unsigned long,32ul>::addUninitialized((uint64_t)this + 680) = a2;
    v6 = *((_QWORD *)this + 90) - 1;
    result = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[]((uint64_t)v4, a2);
    *(_QWORD *)(result + 160) = v6;
  }
  return result;
}

re::DynamicString *re::USDImportContext::setText3D(re::USDImportContext *this, const re::USDImportContext::GeomText3D *a2)
{
  uint64_t v3;
  __int128 v4;

  v3 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[]((uint64_t)this + 624, *(_QWORD *)(*((_QWORD *)this + 106) + 8 * *((_QWORD *)this + 104) - 8));
  re::DynamicString::operator=((re::DynamicString *)(v3 + 616), a2);
  re::DynamicString::operator=((re::DynamicString *)(v3 + 648), (const re::USDImportContext::GeomText3D *)((char *)a2 + 32));
  v4 = *((_OWORD *)a2 + 5);
  *(_OWORD *)(v3 + 680) = *((_OWORD *)a2 + 4);
  *(_OWORD *)(v3 + 696) = v4;
  re::DynamicString::operator=((re::DynamicString *)(v3 + 712), (const re::USDImportContext::GeomText3D *)((char *)a2 + 96));
  re::DynamicString::operator=((re::DynamicString *)(v3 + 744), (const re::USDImportContext::GeomText3D *)((char *)a2 + 128));
  return re::DynamicString::operator=((re::DynamicString *)(v3 + 776), (const re::USDImportContext::GeomText3D *)((char *)a2 + 160));
}

uint64_t re::USDImportContext::setPrimitiveShape(uint64_t a1, _OWORD *a2)
{
  uint64_t v4;
  _OWORD *v5;
  __int128 v6;
  __int128 v7;
  StringID *v8;

  v4 = a1 + 624;
  v5 = (_OWORD *)re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[](a1 + 624, *(_QWORD *)(*(_QWORD *)(a1 + 848) + 8 * *(_QWORD *)(a1 + 832) - 8));
  v7 = a2[1];
  v6 = a2[2];
  v5[15] = *a2;
  v5[16] = v7;
  v5[17] = v6;
  v8 = (StringID *)(re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[](v4, *(_QWORD *)(*(_QWORD *)(a1 + 848) + 8 * *(_QWORD *)(a1 + 832) - 8))+ 40);
  return re::HashTable<re::StringID,unsigned long,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::add(a1 + 856, v8, (_QWORD *)(*(_QWORD *)(a1 + 848) + 8 * *(_QWORD *)(a1 + 832) - 8));
}

uint64_t re::USDImportContext::setModel(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  re *v6;
  uint64_t *v7;
  _anonymous_namespace_ *v8;
  uint64_t v9;
  _anonymous_namespace_ **v10;
  _anonymous_namespace_ *v11;
  uint64_t v12;

  v4 = a1 + 624;
  v5 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[](a1 + 624, *(_QWORD *)(*(_QWORD *)(a1 + 848) + 8 * *(_QWORD *)(a1 + 832) - 8));
  re::DynamicArray<re::SharedPtr<re::Shareable<re::AssetLoadDescriptor>>>::resize(v5 + 288, 1uLL);
  v7 = re::globalAllocators(v6);
  v8 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v7[2] + 32))(v7[2], 240, 8);
  re::ShareableInternal<re::GeomModelDescriptor>::ShareableInternal<re::GeomModelDescriptor>(v8, a2);
  v9 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[](v4, *(_QWORD *)(*(_QWORD *)(a1 + 848) + 8 * *(_QWORD *)(a1 + 832) - 8));
  if (!*(_QWORD *)(v9 + 304))
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  v10 = *(_anonymous_namespace_ ***)(v9 + 320);
  v11 = *v10;
  *v10 = v8;
  if (v11)

  v12 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[](v4, *(_QWORD *)(*(_QWORD *)(a1 + 848) + 8 * *(_QWORD *)(a1 + 832) - 8));
  return re::HashTable<re::StringID,unsigned long,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::add(a1 + 856, (StringID *)(v12 + 40), (_QWORD *)(*(_QWORD *)(a1 + 848) + 8 * *(_QWORD *)(a1 + 832) - 8));
}

uint64_t *re::USDImportContext::setModelsWithLods(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v8;
  re *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  _anonymous_namespace_ *v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  double v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v36;
  unint64_t v39;
  uint64_t v40;
  int v41;
  const char *v42;
  __int16 v43;
  int v44;
  __int16 v45;
  unint64_t v46;
  __int16 v47;
  unint64_t v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  uint64_t v54;

  v54 = *MEMORY[0x24BDAC8D0];
  v39 = *(_QWORD *)(*(_QWORD *)(a1 + 848) + 8 * *(_QWORD *)(a1 + 832) - 8);
  v36 = a1 + 624;
  v8 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[](a1 + 624, v39);
  re::DynamicArray<re::SharedPtr<re::Shareable<re::AssetLoadDescriptor>>>::resize(v8 + 288, *(_QWORD *)(a2 + 16));
  v10 = *(_QWORD *)(v8 + 304);
  if (v10)
  {
    v11 = 0;
    v12 = 0;
    while (1)
    {
      v13 = *(_QWORD *)(a2 + 16);
      if (v13 <= v12)
        break;
      v14 = *(_QWORD *)(a2 + 32) + v11;
      v15 = re::globalAllocators(v9);
      v16 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v15[2] + 32))(v15[2], 240, 8);
      v9 = re::ShareableInternal<re::GeomModelDescriptor>::ShareableInternal<re::GeomModelDescriptor>(v16, v14);
      v13 = *(_QWORD *)(v8 + 304);
      if (v13 <= v12)
        goto LABEL_29;
      v17 = *(_QWORD *)(v8 + 320);
      v18 = *(_QWORD *)(v17 + 8 * v12);
      *(_QWORD *)(v17 + 8 * v12) = v9;
      if (v18)

      v13 = *(_QWORD *)(a4 + 16);
      if (v13 <= v12)
        goto LABEL_30;
      v19 = *(_QWORD *)(*(_QWORD *)(a4 + 32) + 8 * v12);
      if (v19 != -1)
      {
        v20 = re::BucketArray<re::USDImportContextSkeletalAnimationData,8ul>::operator[](a1 + 160, v19);
        v9 = (re *)re::DynamicArray<unsigned long>::add((_QWORD *)(v20 + 240), &v39);
      }
      v13 = *(_QWORD *)(a3 + 16);
      if (v13 <= v12)
        goto LABEL_31;
      v21 = *(_QWORD *)(*(_QWORD *)(a3 + 32) + 8 * v12);
      if (v21 != -1)
      {
        v22 = re::BucketArray<re::USDImportContextSkeletonData,4ul>::operator[](a1 + 56, v21);
        v9 = (re *)re::DynamicArray<unsigned long>::add((_QWORD *)(v22 + 376), &v39);
      }
      ++v12;
      v11 += 216;
      if (v10 == v12)
        goto LABEL_14;
    }
    v40 = 0;
    v52 = 0u;
    v53 = 0u;
    v50 = 0u;
    v51 = 0u;
    v49 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v41 = 136315906;
    v42 = "operator[]";
    v43 = 1024;
    v44 = 789;
    v45 = 2048;
    v46 = v12;
    v47 = 2048;
    v48 = v13;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_29:
    v40 = 0;
    v52 = 0u;
    v53 = 0u;
    v50 = 0u;
    v51 = 0u;
    v49 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v41 = 136315906;
    v42 = "operator[]";
    v43 = 1024;
    v44 = 789;
    v45 = 2048;
    v46 = v12;
    v47 = 2048;
    v48 = v13;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_30:
    v40 = 0;
    v52 = 0u;
    v53 = 0u;
    v50 = 0u;
    v51 = 0u;
    v49 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v41 = 136315906;
    v42 = "operator[]";
    v43 = 1024;
    v44 = 789;
    v45 = 2048;
    v46 = v12;
    v47 = 2048;
    v48 = v13;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_31:
    v40 = 0;
    v52 = 0u;
    v53 = 0u;
    v50 = 0u;
    v51 = 0u;
    v49 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v41 = 136315906;
    v42 = "operator[]";
    v43 = 1024;
    v44 = 789;
    v45 = 2048;
    v46 = v12;
    v47 = 2048;
    v48 = v13;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
LABEL_14:
  v23 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = 0;
  if (v23)
  {
    v24 = 216 * v23;
    v25 = *(_QWORD *)(a2 + 32) + 136;
    do
    {
      v26 = *(_QWORD *)(v25 + 48);
      if (v26)
      {
        if ((*(_BYTE *)(v25 + 56) & 1) != 0)
          (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v26 + 40))(v26, *(_QWORD *)(v25 + 64));
        *(_OWORD *)(v25 + 48) = 0u;
        *(_OWORD *)(v25 + 64) = 0u;
      }
      re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v25);
      re::DynamicArray<re::GeomModelDescriptor::AttributeData>::deinit(v25 - 40);
      re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)(v25 - 88), v27);
      v28 = *(_QWORD *)(v25 - 96);
      if (v28)
      {

        *(_QWORD *)(v25 - 96) = 0;
      }
      v29 = *(_QWORD *)(v25 - 104);
      if (v29)
      {

        *(_QWORD *)(v25 - 104) = 0;
      }
      v30 = *(_QWORD *)(v25 - 128);
      if (v30)
      {

        *(_QWORD *)(v25 - 128) = 0;
      }
      v25 += 216;
      v24 -= 216;
    }
    while (v24);
  }
  ++*(_DWORD *)(a2 + 24);
  v31 = a1;
  v32 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[](v36, *(_QWORD *)(*(_QWORD *)(a1 + 848) + 8 * *(_QWORD *)(a1 + 832) - 8));
  re::DynamicArray<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)>>::operator=(v32 + 328, a3);
  v33 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[](v36, *(_QWORD *)(*(_QWORD *)(v31 + 848) + 8 * *(_QWORD *)(v31 + 832) - 8));
  re::DynamicArray<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)>>::operator=(v33 + 368, a4);
  v34 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[](v36, *(_QWORD *)(*(_QWORD *)(v31 + 848) + 8 * *(_QWORD *)(v31 + 832) - 8));
  return re::FixedArray<float>::operator=((uint64_t *)(v34 + 408), a5);
}

uint64_t re::BucketArray<re::USDImportContextSkeletalAnimationData,8ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1011, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(_QWORD *)(a1 + 8) <= a2 >> 3)
    goto LABEL_8;
  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
    v3 = a1 + 24;
  else
    v3 = *(_QWORD *)(a1 + 32);
  return *(_QWORD *)(v3 + 8 * (a2 >> 3)) + 280 * (a2 & 7);
}

{
  unint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1018, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(_QWORD *)(a1 + 8) <= a2 >> 3)
    goto LABEL_8;
  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
    v3 = a1 + 24;
  else
    v3 = *(_QWORD *)(a1 + 32);
  return *(_QWORD *)(v3 + 8 * (a2 >> 3)) + 280 * (a2 & 7);
}

uint64_t re::BucketArray<re::USDImportContextSkeletonData,4ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1011, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(_QWORD *)(a1 + 8) <= a2 >> 2)
    goto LABEL_8;
  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
    v3 = a1 + 24;
  else
    v3 = *(_QWORD *)(a1 + 32);
  return *(_QWORD *)(v3 + 8 * (a2 >> 2)) + 424 * (a2 & 3);
}

{
  unint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1018, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(_QWORD *)(a1 + 8) <= a2 >> 2)
    goto LABEL_8;
  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
    v3 = a1 + 24;
  else
    v3 = *(_QWORD *)(a1 + 32);
  return *(_QWORD *)(v3 + 8 * (a2 >> 2)) + 424 * (a2 & 3);
}

uint64_t re::USDImportContext::setMeshMaterials(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[](a1 + 624, *(_QWORD *)(*(_QWORD *)(a1 + 848) + 8 * *(_QWORD *)(a1 + 832) - 8))+ 808;
  return re::DynamicArray<re::AssetHandle>::operator=(v3, a2);
}

uint64_t re::DynamicArray<re::AssetHandle>::operator=(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  BOOL v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (result != a2)
  {
    v2 = *(_QWORD *)result;
    v3 = *(_QWORD *)a2;
    if (*(_QWORD *)result)
      v4 = v3 == 0;
    else
      v4 = 1;
    if (v4 || v2 == v3)
    {
      v6 = *(_QWORD *)(result + 8);
      v7 = *(_QWORD *)(a2 + 8);
      *(_QWORD *)result = v3;
      *(_QWORD *)(result + 8) = v7;
      *(_QWORD *)a2 = v2;
      *(_QWORD *)(a2 + 8) = v6;
      v8 = *(_QWORD *)(result + 16);
      *(_QWORD *)(result + 16) = *(_QWORD *)(a2 + 16);
      *(_QWORD *)(a2 + 16) = v8;
      v9 = *(_QWORD *)(result + 32);
      *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
      *(_QWORD *)(a2 + 32) = v9;
      ++*(_DWORD *)(a2 + 24);
      ++*(_DWORD *)(result + 24);
    }
    else
    {
      re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) ", "!isInitialized() || !other.isInitialized() || m_allocator == other.m_allocator", "operator=", 503);
      result = _os_crash();
      __break(1u);
    }
  }
  return result;
}

float32x4_t re::USDImportContext::concatenateLocalTransform(uint64_t a1, float32x4_t *a2)
{
  uint64_t v3;
  float32x4_t v4;
  float32x4_t v7;
  float32x4_t v8;
  int8x16_t v9;
  float32x4_t v10;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  float32x4_t result;

  v3 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[](a1 + 624, *(_QWORD *)(*(_QWORD *)(a1 + 848) + 8 * *(_QWORD *)(a1 + 832) - 8));
  v4 = *(float32x4_t *)(v3 + 432);
  _Q1 = *(float32x4_t *)(v3 + 448);
  _Q3 = a2[1];
  v7 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q1, (int32x4_t)_Q1), (int8x16_t)_Q1, 0xCuLL);
  v8 = vnegq_f32(_Q1);
  v9 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q3, (int32x4_t)_Q3), (int8x16_t)_Q3, 0xCuLL), v8), _Q3, v7);
  v10 = vmlaq_laneq_f32(vmlaq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v9, (int32x4_t)v9), v9, 0xCuLL), _Q3, _Q1, 3), _Q1, _Q3, 3);
  _Q3.i32[0] = _Q3.i32[3];
  __asm { FMLA            S7, S3, V1.S[3] }
  v10.i32[3] = _S7;
  v16 = vmulq_f32(v4, *a2);
  v17 = a2[2];
  v18 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v17, (int32x4_t)v17), (int8x16_t)v17, 0xCuLL), v8), v17, v7);
  v19 = (int8x16_t)vaddq_f32(v18, v18);
  v20 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v19, (int32x4_t)v19), v19, 0xCuLL);
  v21 = vaddq_f32(v17, vmulq_laneq_f32(v20, _Q1, 3));
  v22 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v20, (int32x4_t)v20), (int8x16_t)v20, 0xCuLL), v8), v20, v7);
  result = vaddq_f32(*(float32x4_t *)(v3 + 464), vmulq_f32(v4, vaddq_f32(v21, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v22, (int32x4_t)v22), v22, 0xCuLL))));
  *(float32x4_t *)(v3 + 432) = v16;
  *(float32x4_t *)(v3 + 448) = v10;
  *(float32x4_t *)(v3 + 464) = result;
  return result;
}

uint64_t re::USDImportContext::setTransformAnimation(uint64_t a1, uint64_t a2)
{
  float v4;
  float v5;
  float v6;
  float v7;
  double v8;
  uint64_t v9;
  uint64_t result;

  if (!*(_BYTE *)(a1 + 16))
  {
    v4 = *(float *)(a1 + 8);
    if (v4 > *(float *)(a2 + 80))
      v4 = *(float *)(a2 + 80);
    *(float *)(a1 + 8) = v4;
  }
  if (*(_BYTE *)(a1 + 24))
  {
    v5 = *(float *)(a2 + 84);
  }
  else
  {
    v6 = *(float *)(a1 + 12);
    v5 = *(float *)(a2 + 84);
    if (v6 < v5)
      v6 = *(float *)(a2 + 84);
    *(float *)(a1 + 12) = v6;
  }
  v7 = *(float *)(a2 + 80);
  v8 = v7;
  *(_DWORD *)(a2 + 80) = 0;
  *(float *)(a2 + 84) = v5 - v7;
  v9 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[](a1 + 624, *(_QWORD *)(*(_QWORD *)(a1 + 848) + 8 * *(_QWORD *)(a1 + 832) - 8));
  re::SampledAnimationAssetData<re::GenericSRT<float>>::operator=(v9 + 480, a2);
  result = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[](a1 + 624, *(_QWORD *)(*(_QWORD *)(a1 + 848) + 8 * *(_QWORD *)(a1 + 832) - 8));
  *(double *)(result + 608) = v8;
  return result;
}

void re::USDImportContext::setVertexCacheAnimation(uint64_t a1, _QWORD *a2)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  BOOL v7;
  uint64_t v8;
  uint64_t v9;
  _anonymous_namespace_ *v10;
  uint64_t v11;
  const char *v12;
  unint64_t v13;
  const char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  __int128 v19;
  __int128 v20;
  int v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  uint64_t v36;
  __int128 v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  uint64_t v46;
  __int128 v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;

  v3 = (_QWORD *)re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[](a1 + 624, *(_QWORD *)(*(_QWORD *)(a1 + 848) + 8 * *(_QWORD *)(a1 + 832) - 8));
  v3[124] = *a2;
  if (v3 + 124 != a2)
  {
    v5 = v3[125];
    v6 = a2[1];
    if (v5)
      v7 = v5 == v6;
    else
      v7 = 1;
    if (!v7)
    {
      re::internal::assertLog((re::internal *)4, v4, "assertion failure: '%s' (%s:line %i) ", "!isInitialized() || m_allocator == other.m_allocator", "operator=", 296);
      _os_crash();
      __break(1u);
      return;
    }
    v3[125] = v6;
    a2[1] = v5;
    v8 = v3[126];
    v3[126] = a2[2];
    a2[2] = v8;
    v9 = v3[127];
    v3[127] = a2[3];
    a2[3] = v9;
  }
  v11 = 0xBD8878DBB047AD5ELL;
  v12 = "DefaultVertexCacheDeformer";
  v13 = 0x20889405B90383CLL;
  v14 = "VertexCache";
  v10 = (_anonymous_namespace_ *)(v3 + 128);
  v16 = 0;
  v17 = 0;
  v15 = 0;
  v18 = 0;
  v19 = 0u;
  v20 = 0u;
  v21 = 0;
  v23 = 0u;
  v26 = 0u;
  v22 = 0u;
  DWORD2(v23) = 1;
  v24 = 0;
  v25 = 0;
  *(_QWORD *)&v26 = 0;
  v28 = 1;
  v27 = 0u;
  DWORD2(v26) = 0;
  v29 = 0;
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v36 = 0;
  v33 = 0u;
  v34 = 1uLL;
  v35 = 0uLL;
  v37 = 0u;
  v41 = 0;
  v38 = 1;
  v40 = 0;
  v39 = 0;
  v42 = 0;
  v46 = 0;
  v43 = 0u;
  v44 = 1uLL;
  v45 = 0uLL;
  v47 = 0u;
  v51 = 0;
  v48 = 1;
  v50 = 0;
  v49 = 0;
  v52 = 0;
  re::DynamicArray<re::GeomDeformer>::add((_anonymous_namespace_ *)(v3 + 128), &v11);
  re::GeomDeformer::~GeomDeformer((re::GeomDeformer *)&v11);
  v11 = 0xAE076461BA42A276;
  v12 = "DefaultRenormalizationDeformer";
  v13 = 0xABCEC87F22A13454;
  v14 = "Renormalization";
  v16 = 0;
  v17 = 0;
  v15 = 0;
  v18 = 0;
  v19 = 0u;
  v20 = 0u;
  v21 = 0;
  v23 = 0u;
  v26 = 0u;
  v22 = 0u;
  DWORD2(v23) = 1;
  v24 = 0;
  v25 = 0;
  *(_QWORD *)&v26 = 0;
  v28 = 1;
  v27 = 0u;
  DWORD2(v26) = 0;
  v29 = 0;
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v38 = 1;
  v36 = 0;
  v33 = 0u;
  v34 = 1u;
  v35 = 0uLL;
  v37 = 0u;
  v41 = 0;
  v40 = 0;
  v39 = 0;
  v42 = 0;
  v48 = 1;
  v46 = 0;
  v43 = 0u;
  v44 = 1u;
  v45 = 0uLL;
  v47 = 0u;
  v51 = 0;
  v50 = 0;
  v49 = 0;
  v52 = 0;
  re::DynamicArray<re::GeomDeformer>::add(v10, &v11);
  re::GeomDeformer::~GeomDeformer((re::GeomDeformer *)&v11);
}

uint64_t re::USDImportContext::setSkeletonReference(re::USDImportContext *this, unint64_t a2)
{
  re::USDImportContext *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  unint64_t v7[2];
  int v8;
  const char *v9;
  __int16 v10;
  int v11;
  __int16 v12;
  uint64_t v13;
  __int16 v14;
  uint64_t v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  uint64_t v21;

  v3 = this;
  v21 = *MEMORY[0x24BDAC8D0];
  v7[0] = *(_QWORD *)(*((_QWORD *)this + 106) + 8 * *((_QWORD *)this + 104) - 8);
  v4 = re::BucketArray<re::USDImportContextSkeletonData,4ul>::operator[]((uint64_t)this + 56, a2);
  re::DynamicArray<unsigned long>::add((_QWORD *)(v4 + 376), v7);
  v3 = (re::USDImportContext *)((char *)v3 + 624);
  v5 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[]((uint64_t)v3, v7[0]);
  re::DynamicArray<unsigned long>::resize(v5 + 328, 1uLL);
  result = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[]((uint64_t)v3, v7[0]);
  if (!*(_QWORD *)(result + 344))
  {
    v7[1] = 0;
    v19 = 0u;
    v20 = 0u;
    v17 = 0u;
    v18 = 0u;
    v16 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v8 = 136315906;
    v9 = "operator[]";
    v10 = 1024;
    v11 = 789;
    v12 = 2048;
    v13 = 0;
    v14 = 2048;
    v15 = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  **(_QWORD **)(result + 360) = a2;
  return result;
}

uint64_t re::USDImportContext::setSkeletalAnimationReference(re::USDImportContext *this, unint64_t a2)
{
  re::USDImportContext *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  unint64_t v7[2];
  int v8;
  const char *v9;
  __int16 v10;
  int v11;
  __int16 v12;
  uint64_t v13;
  __int16 v14;
  uint64_t v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  uint64_t v21;

  v3 = this;
  v21 = *MEMORY[0x24BDAC8D0];
  v7[0] = *(_QWORD *)(*((_QWORD *)this + 106) + 8 * *((_QWORD *)this + 104) - 8);
  v4 = re::BucketArray<re::USDImportContextSkeletalAnimationData,8ul>::operator[]((uint64_t)this + 160, a2);
  re::DynamicArray<unsigned long>::add((_QWORD *)(v4 + 240), v7);
  v3 = (re::USDImportContext *)((char *)v3 + 624);
  v5 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[]((uint64_t)v3, v7[0]);
  re::DynamicArray<unsigned long>::resize(v5 + 368, 1uLL);
  result = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[]((uint64_t)v3, v7[0]);
  if (!*(_QWORD *)(result + 384))
  {
    v7[1] = 0;
    v19 = 0u;
    v20 = 0u;
    v17 = 0u;
    v18 = 0u;
    v16 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v8 = 136315906;
    v9 = "operator[]";
    v10 = 1024;
    v11 = 789;
    v12 = 2048;
    v13 = 0;
    v14 = 2048;
    v15 = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  **(_QWORD **)(result + 400) = a2;
  return result;
}

_QWORD *re::USDImportContext::setSpatialAudioData(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;

  v3 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[](a1 + 624, *(_QWORD *)(*(_QWORD *)(a1 + 848) + 8 * *(_QWORD *)(a1 + 832) - 8));
  return std::shared_ptr<std::atomic<re::VideoReturn>>::operator=[abi:nn180100]((_QWORD *)(v3 + 936), a2);
}

_QWORD *re::USDImportContext::setAdditionalAnimation(re::USDImportContext *this, re::Timeline *a2)
{
  uint64_t v2;
  re::Timeline *v4;

  v4 = a2;
  v2 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[]((uint64_t)this + 624, *(_QWORD *)(*((_QWORD *)this + 106) + 8 * *((_QWORD *)this + 104) - 8));
  return re::DynamicArray<re::TransitionCondition *>::add((_QWORD *)(v2 + 952), &v4);
}

_QWORD *re::USDImportContext::setSkeletonEntity(re::USDImportContext *this, unint64_t a2, unint64_t a3)
{
  uint64_t v6;
  _QWORD *result;

  *(_QWORD *)(re::BucketArray<re::USDImportContextSkeletonData,4ul>::operator[]((uint64_t)this + 56, a3) + 416) = a2;
  v6 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[]((uint64_t)this + 624, a2);
  result = (_QWORD *)re::BucketArray<unsigned long,4ul>::addUninitialized(v6 + 104);
  *result = a3;
  return result;
}

uint64_t re::USDImportContext::addBlendShape(uint64_t a1, StringID *a2, uint64_t a3)
{
  _QWORD *v6;
  __int128 v7;
  uint64_t v8;
  uint64_t v10[3];
  __int128 v11;
  uint64_t v12;
  __int128 v13;
  uint64_t v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  __int128 v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;

  v6 = (_QWORD *)(a1 + 264);
  re::StringID::StringID((re::StringID *)v10, a2);
  v10[2] = *(_QWORD *)a3;
  v7 = *(_OWORD *)(a3 + 8);
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = &str_110;
  v11 = v7;
  v12 = *(_QWORD *)(a3 + 24);
  v13 = *(_OWORD *)(a3 + 32);
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  v14 = *(_QWORD *)(a3 + 48);
  *(_QWORD *)(a3 + 48) = 0;
  v15 = *(_OWORD *)(a3 + 56);
  *(_OWORD *)(a3 + 56) = 0u;
  v8 = *(_QWORD *)(a3 + 80);
  v16 = *(_QWORD *)(a3 + 72);
  v17 = v8;
  *(_QWORD *)(a3 + 72) = 0;
  *(_QWORD *)(a3 + 80) = 0;
  v20 = 0;
  v19 = 0;
  v18 = 0u;
  v21 = 0;
  v22 = -1;
  re::BucketArray<re::USDImportContextBlendShapeData,8ul>::add(v6, v10);
  re::USDImportContextBlendShapeData::~USDImportContextBlendShapeData((re::USDImportContextBlendShapeData *)v10);
  v10[0] = *(_QWORD *)(a1 + 304) - 1;
  return re::HashTable<re::StringID,unsigned long,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::add(a1 + 320, a2, v10);
}

_QWORD *re::BucketArray<re::USDImportContextBlendShapeData,8ul>::add(_QWORD *result, uint64_t *a2)
{
  _QWORD *v3;
  unint64_t v4;
  unint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v3 = result;
  v4 = result[5];
  v5 = result[1];
  if (v4 + 1 > 8 * v5)
  {
    result = re::BucketArray<re::USDImportContextBlendShapeData,8ul>::setBucketsCapacity(result, (v4 + 8) >> 3);
    v5 = v3[1];
  }
  if (v5 <= v4 >> 3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if ((v3[2] & 1) != 0)
    v6 = v3 + 3;
  else
    v6 = (_QWORD *)v3[4];
  v7 = v6[v4 >> 3];
  ++v3[5];
  ++*((_DWORD *)v3 + 12);
  v8 = v7 + 152 * (v4 & 7);
  v9 = *a2;
  *(_QWORD *)v8 = *(_QWORD *)v8 & 0xFFFFFFFFFFFFFFFELL | *a2 & 1;
  *(_QWORD *)v8 = *a2 & 0xFFFFFFFFFFFFFFFELL | v9 & 1;
  *(_QWORD *)(v8 + 8) = a2[1];
  *a2 = 0;
  a2[1] = (uint64_t)&str_110;
  v10 = a2[2];
  *(_QWORD *)(v8 + 16) = *(_QWORD *)(v8 + 16) & 0xFFFFFFFFFFFFFFFELL | v10 & 1;
  *(_QWORD *)(v8 + 16) = a2[2] & 0xFFFFFFFFFFFFFFFELL | v10 & 1;
  *(_QWORD *)(v8 + 24) = a2[3];
  a2[2] = 0;
  a2[3] = (uint64_t)&str_110;
  *(_QWORD *)(v8 + 32) = 0;
  *(_QWORD *)(v8 + 40) = 0;
  *(_QWORD *)(v8 + 48) = 0;
  *(_QWORD *)(v8 + 32) = a2[4];
  a2[4] = 0;
  *(_QWORD *)(v8 + 40) = a2[5];
  a2[5] = 0;
  v11 = *(_QWORD *)(v8 + 48);
  *(_QWORD *)(v8 + 48) = a2[6];
  a2[6] = v11;
  *(_QWORD *)(v8 + 56) = 0;
  *(_QWORD *)(v8 + 64) = 0;
  *(_QWORD *)(v8 + 72) = 0;
  *(_QWORD *)(v8 + 56) = a2[7];
  a2[7] = 0;
  *(_QWORD *)(v8 + 64) = a2[8];
  a2[8] = 0;
  v12 = *(_QWORD *)(v8 + 72);
  *(_QWORD *)(v8 + 72) = a2[9];
  a2[9] = v12;
  *(_QWORD *)(v8 + 80) = 0;
  *(_QWORD *)(v8 + 88) = 0;
  *(_QWORD *)(v8 + 96) = 0;
  *(_QWORD *)(v8 + 80) = a2[10];
  a2[10] = 0;
  *(_QWORD *)(v8 + 88) = a2[11];
  a2[11] = 0;
  v13 = *(_QWORD *)(v8 + 96);
  *(_QWORD *)(v8 + 96) = a2[12];
  a2[12] = v13;
  *(_QWORD *)(v8 + 136) = 0;
  *(_DWORD *)(v8 + 128) = 0;
  *(_QWORD *)(v8 + 112) = 0;
  *(_QWORD *)(v8 + 120) = 0;
  *(_QWORD *)(v8 + 104) = 0;
  *(_QWORD *)(v8 + 104) = a2[13];
  a2[13] = 0;
  *(_QWORD *)(v8 + 112) = a2[14];
  a2[14] = 0;
  v14 = *(_QWORD *)(v8 + 120);
  *(_QWORD *)(v8 + 120) = a2[15];
  a2[15] = v14;
  v15 = *(_QWORD *)(v8 + 136);
  *(_QWORD *)(v8 + 136) = a2[17];
  a2[17] = v15;
  ++*((_DWORD *)a2 + 32);
  ++*(_DWORD *)(v8 + 128);
  *(_QWORD *)(v8 + 144) = a2[18];
  return result;
}

uint64_t re::USDImportContext::addSkeleton(uint64_t a1, StringID *a2, uint64_t *a3)
{
  __int128 v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  __int128 v29;
  uint64_t v30;
  __int128 v31;
  uint64_t v32;
  __int128 v33;
  uint64_t v34;
  __int128 v35;
  uint64_t v36;
  __int128 v37;
  uint64_t v38;
  uint64_t v39;
  __int128 v40;
  int v41;
  _BYTE v42[128];
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  uint64_t v50;
  __int16 v51;
  char v52;
  uint64_t v53;
  __int128 v54;
  int v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  const char *v60;
  __int16 v61;
  int v62;
  __int16 v63;
  unint64_t v64;
  __int16 v65;
  unint64_t v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  uint64_t v72;

  v72 = *MEMORY[0x24BDAC8D0];
  re::StringID::StringID((re::StringID *)&v26, a2);
  v28 = *a3;
  v6 = *(_OWORD *)(a3 + 1);
  *a3 = 0;
  a3[1] = (uint64_t)&str_110;
  v29 = v6;
  v30 = a3[3];
  v31 = *((_OWORD *)a3 + 2);
  *((_OWORD *)a3 + 1) = 0u;
  *((_OWORD *)a3 + 2) = 0u;
  v32 = a3[6];
  a3[6] = 0;
  v33 = *(_OWORD *)(a3 + 7);
  *(_OWORD *)(a3 + 7) = 0u;
  v34 = a3[9];
  a3[9] = 0;
  v35 = *((_OWORD *)a3 + 5);
  *((_OWORD *)a3 + 5) = 0u;
  v36 = a3[12];
  a3[12] = 0;
  v41 = 0;
  v37 = *(_OWORD *)(a3 + 13);
  *(_OWORD *)(a3 + 13) = 0u;
  v7 = a3[16];
  v38 = a3[15];
  v39 = v7;
  *(_OWORD *)(a3 + 15) = 0u;
  v40 = *(_OWORD *)(a3 + 17);
  *(_OWORD *)(a3 + 17) = xmmword_2260F5A80;
  re::SkeletalPoseSampledAnimationAssetData::SkeletalPoseSampledAnimationAssetData((re::SkeletalPoseSampledAnimationAssetData *)v42);
  v53 = 0;
  v54 = 0u;
  v55 = 0;
  v56 = 0;
  v57 = -1;
  v8 = *(_QWORD *)(a1 + 96);
  v9 = *(_QWORD *)(a1 + 64);
  if (v8 + 1 > 4 * v9)
  {
    re::BucketArray<re::USDImportContextSkeletonData,4ul>::setBucketsCapacity((_QWORD *)(a1 + 56), (v8 + 4) >> 2);
    v9 = *(_QWORD *)(a1 + 64);
  }
  if (v9 <= v8 >> 2)
  {
    v58 = 0;
    v70 = 0u;
    v71 = 0u;
    v68 = 0u;
    v69 = 0u;
    v67 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v59 = 136315906;
    v60 = "operator[]";
    v61 = 1024;
    v62 = 858;
    v63 = 2048;
    v64 = v8 >> 2;
    v65 = 2048;
    v66 = v9;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if ((*(_BYTE *)(a1 + 72) & 1) != 0)
    v10 = a1 + 80;
  else
    v10 = *(_QWORD *)(a1 + 88);
  v11 = *(_QWORD *)(v10 + 8 * (v8 >> 2));
  ++*(_QWORD *)(a1 + 96);
  ++*(_DWORD *)(a1 + 104);
  v12 = v11 + 424 * (v8 & 3);
  LOBYTE(v11) = v26;
  *(_QWORD *)v12 = *(_QWORD *)v12 & 0xFFFFFFFFFFFFFFFELL | v26 & 1;
  *(_QWORD *)v12 = v26 & 0xFFFFFFFFFFFFFFFELL | v11 & 1;
  *(_QWORD *)(v12 + 8) = v27;
  v26 = 0;
  v27 = &str_110;
  LOBYTE(v11) = v28;
  *(_QWORD *)(v12 + 16) = *(_QWORD *)(v12 + 16) & 0xFFFFFFFFFFFFFFFELL | v28 & 1;
  *(_QWORD *)(v12 + 16) = v28 & 0xFFFFFFFFFFFFFFFELL | v11 & 1;
  *(_QWORD *)(v12 + 24) = v29;
  v28 = 0;
  *(_QWORD *)&v29 = &str_110;
  *(_QWORD *)(v12 + 32) = 0;
  *(_QWORD *)(v12 + 40) = 0;
  *(_QWORD *)(v12 + 48) = 0;
  *(_QWORD *)(v12 + 32) = *((_QWORD *)&v29 + 1);
  *((_QWORD *)&v29 + 1) = 0;
  *(_QWORD *)(v12 + 40) = v30;
  v30 = 0;
  v13 = *(_QWORD *)(v12 + 48);
  *(_QWORD *)(v12 + 48) = v31;
  *(_QWORD *)&v31 = v13;
  *(_QWORD *)(v12 + 56) = 0;
  *(_QWORD *)(v12 + 64) = 0;
  *(_QWORD *)(v12 + 72) = 0;
  *(_QWORD *)(v12 + 56) = *((_QWORD *)&v31 + 1);
  *((_QWORD *)&v31 + 1) = 0;
  *(_QWORD *)(v12 + 64) = v32;
  v32 = 0;
  v14 = *(_QWORD *)(v12 + 72);
  *(_QWORD *)(v12 + 72) = v33;
  *(_QWORD *)&v33 = v14;
  *(_QWORD *)(v12 + 80) = 0;
  *(_QWORD *)(v12 + 88) = 0;
  *(_QWORD *)(v12 + 96) = 0;
  *(_QWORD *)(v12 + 80) = *((_QWORD *)&v33 + 1);
  *((_QWORD *)&v33 + 1) = 0;
  *(_QWORD *)(v12 + 88) = v34;
  v34 = 0;
  v15 = *(_QWORD *)(v12 + 96);
  *(_QWORD *)(v12 + 96) = v35;
  *(_QWORD *)&v35 = v15;
  *(_QWORD *)(v12 + 104) = 0;
  *(_QWORD *)(v12 + 112) = 0;
  *(_QWORD *)(v12 + 120) = 0;
  *(_QWORD *)(v12 + 104) = *((_QWORD *)&v35 + 1);
  *((_QWORD *)&v35 + 1) = 0;
  *(_QWORD *)(v12 + 112) = v36;
  v36 = 0;
  v16 = *(_QWORD *)(v12 + 120);
  *(_QWORD *)(v12 + 120) = v37;
  *(_QWORD *)&v37 = v16;
  *(_DWORD *)(v12 + 160) = 0;
  *(_OWORD *)(v12 + 128) = 0u;
  *(_OWORD *)(v12 + 144) = 0u;
  *(_QWORD *)(v12 + 164) = 0x7FFFFFFFLL;
  *(_QWORD *)(v12 + 128) = *((_QWORD *)&v37 + 1);
  *((_QWORD *)&v37 + 1) = 0;
  v17 = *(_QWORD *)(v12 + 136);
  *(_QWORD *)(v12 + 136) = v38;
  v38 = v17;
  v18 = *(_QWORD *)(v12 + 144);
  *(_QWORD *)(v12 + 144) = v39;
  v39 = v18;
  LODWORD(v18) = *(_DWORD *)(v12 + 152);
  *(_DWORD *)(v12 + 152) = v40;
  LODWORD(v40) = v18;
  LODWORD(v18) = *(_DWORD *)(v12 + 156);
  *(_DWORD *)(v12 + 156) = DWORD1(v40);
  DWORD1(v40) = v18;
  LODWORD(v18) = *(_DWORD *)(v12 + 160);
  *(_DWORD *)(v12 + 160) = DWORD2(v40);
  DWORD2(v40) = v18;
  LODWORD(v18) = *(_DWORD *)(v12 + 164);
  *(_DWORD *)(v12 + 164) = HIDWORD(v40);
  HIDWORD(v40) = v18;
  re::SampledAnimationAssetData<re::SkeletalPoseAssetData>::SampledAnimationAssetData(v12 + 176, (uint64_t)v42);
  *(_QWORD *)(v12 + 176) = off_24ED33AA8;
  *(_QWORD *)(v12 + 312) = 0;
  *(_QWORD *)(v12 + 320) = 0;
  *(_QWORD *)(v12 + 304) = 0;
  *(_QWORD *)(v12 + 312) = v44;
  v44 = 0;
  v19 = *(_QWORD *)(v12 + 304);
  *(_QWORD *)(v12 + 304) = 0;
  *(_QWORD *)(v12 + 304) = v43;
  v43 = v19;
  v20 = *(_QWORD *)(v12 + 320);
  *(_QWORD *)(v12 + 320) = v45;
  v45 = v20;
  *(_QWORD *)(v12 + 360) = 0;
  *(_QWORD *)(v12 + 336) = 0;
  *(_QWORD *)(v12 + 344) = 0;
  *(_QWORD *)(v12 + 328) = 0;
  *(_DWORD *)(v12 + 352) = 0;
  *(_QWORD *)(v12 + 328) = v46;
  v46 = 0;
  *(_QWORD *)(v12 + 336) = v47;
  v47 = 0;
  v21 = *(_QWORD *)(v12 + 344);
  *(_QWORD *)(v12 + 344) = v48;
  v48 = v21;
  v22 = *(_QWORD *)(v12 + 360);
  *(_QWORD *)(v12 + 360) = v50;
  v50 = v22;
  ++v49;
  ++*(_DWORD *)(v12 + 352);
  LOWORD(v22) = v51;
  *(_BYTE *)(v12 + 370) = v52;
  *(_WORD *)(v12 + 368) = v22;
  *(_QWORD *)(v12 + 408) = 0;
  *(_QWORD *)(v12 + 384) = 0;
  *(_QWORD *)(v12 + 392) = 0;
  *(_QWORD *)(v12 + 376) = 0;
  *(_DWORD *)(v12 + 400) = 0;
  *(_QWORD *)(v12 + 376) = v53;
  v53 = 0;
  *(_QWORD *)(v12 + 384) = v54;
  *(_QWORD *)&v54 = 0;
  v23 = *(_QWORD *)(v12 + 392);
  *(_QWORD *)(v12 + 392) = *((_QWORD *)&v54 + 1);
  *((_QWORD *)&v54 + 1) = v23;
  v24 = *(_QWORD *)(v12 + 408);
  *(_QWORD *)(v12 + 408) = v56;
  v56 = v24;
  ++v55;
  ++*(_DWORD *)(v12 + 400);
  *(_QWORD *)(v12 + 416) = v57;
  re::USDImportContextSkeletonData::~USDImportContextSkeletonData((re::USDImportContextSkeletonData *)&v26);
  v26 = *(_QWORD *)(a1 + 96) - 1;
  return re::HashTable<re::StringID,unsigned long,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::add(a1 + 112, a2, &v26);
}

void re::USDImportContext::addSkeletalAnimation(uint64_t a1, StringID *a2, uint64_t *a3, uint64_t a4)
{
  float v8;
  float v9;
  float v10;
  float v11;
  double v12;
  char *var1;
  void *v14;
  uint64_t v15;
  __int128 v16;
  __int128 v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  void *v32;
  _QWORD v33[3];
  uint64_t v34;
  __int128 v35;
  __int128 v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  __int128 v40;
  __int128 v41;
  int v42;
  uint64_t v43;
  __int16 v44;
  char v45;
  double v46;
  __int128 v47;
  uint64_t v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  int v52;
  const char *v53;
  __int16 v54;
  int v55;
  __int16 v56;
  unint64_t v57;
  __int16 v58;
  unint64_t v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  uint64_t v65;

  v65 = *MEMORY[0x24BDAC8D0];
  v8 = *(float *)(a4 + 80);
  v9 = *(float *)(a1 + 8);
  v10 = *(float *)(a1 + 12);
  if (v9 > v8)
    v9 = *(float *)(a4 + 80);
  *(float *)(a1 + 8) = v9;
  v11 = *(float *)(a4 + 84);
  if (v10 < v11)
    v10 = *(float *)(a4 + 84);
  *(float *)(a1 + 12) = v10;
  v12 = v8;
  *(_DWORD *)(a4 + 80) = 0;
  *(float *)(a4 + 84) = v11 - v8;
  re::StringID::operator=((unint64_t *)(a4 + 24), a3);
  v29 = *(_QWORD *)(a1 + 200);
  re::HashTable<re::StringID,unsigned long,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::add(a1 + 216, a2, &v29);
  var1 = a2->var1;
  v29 = *(_QWORD *)&a2->var0;
  v30 = var1;
  *(_QWORD *)&a2->var0 = 0;
  a2->var1 = (char *)&str_110;
  v14 = (void *)a3[1];
  v31 = *a3;
  v32 = v14;
  *a3 = 0;
  a3[1] = (uint64_t)&str_110;
  re::SampledAnimationAssetData<re::SkeletalPoseAssetData>::SampledAnimationAssetData((uint64_t)v33, a4);
  v15 = *(_QWORD *)(a4 + 136);
  v38 = *(_QWORD *)(a4 + 128);
  v39 = v15;
  v33[0] = off_24ED33AA8;
  v16 = *(_OWORD *)(a4 + 144);
  v17 = *(_OWORD *)(a4 + 160);
  *(_OWORD *)(a4 + 128) = 0u;
  *(_OWORD *)(a4 + 144) = 0u;
  v40 = v16;
  v41 = v17;
  *(_OWORD *)(a4 + 160) = 0u;
  v43 = *(_QWORD *)(a4 + 184);
  *(_QWORD *)(a4 + 184) = 0;
  ++*(_DWORD *)(a4 + 176);
  v42 = 1;
  LOWORD(v15) = *(_WORD *)(a4 + 192);
  v45 = *(_BYTE *)(a4 + 194);
  v44 = v15;
  v46 = v12;
  v50 = 0;
  v49 = 0;
  v18 = *(_QWORD *)(a1 + 200);
  v48 = 0;
  v19 = *(_QWORD *)(a1 + 168);
  v47 = 0u;
  if (v18 + 1 > 8 * v19)
  {
    re::BucketArray<re::USDImportContextSkeletalAnimationData,8ul>::setBucketsCapacity((_QWORD *)(a1 + 160), (v18 + 8) >> 3);
    v19 = *(_QWORD *)(a1 + 168);
  }
  if (v19 <= v18 >> 3)
  {
    v51 = 0;
    v63 = 0u;
    v64 = 0u;
    v61 = 0u;
    v62 = 0u;
    v60 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v52 = 136315906;
    v53 = "operator[]";
    v54 = 1024;
    v55 = 858;
    v56 = 2048;
    v57 = v18 >> 3;
    v58 = 2048;
    v59 = v19;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if ((*(_BYTE *)(a1 + 176) & 1) != 0)
    v20 = a1 + 184;
  else
    v20 = *(_QWORD *)(a1 + 192);
  v21 = *(_QWORD *)(v20 + 8 * (v18 >> 3));
  ++*(_QWORD *)(a1 + 200);
  ++*(_DWORD *)(a1 + 208);
  v22 = v21 + 280 * (v18 & 7);
  LOBYTE(v21) = v29;
  *(_QWORD *)v22 = *(_QWORD *)v22 & 0xFFFFFFFFFFFFFFFELL | v29 & 1;
  *(_QWORD *)v22 = v29 & 0xFFFFFFFFFFFFFFFELL | v21 & 1;
  *(_QWORD *)(v22 + 8) = v30;
  v29 = 0;
  v30 = (char *)&str_110;
  LOBYTE(v21) = v31;
  *(_QWORD *)(v22 + 16) = *(_QWORD *)(v22 + 16) & 0xFFFFFFFFFFFFFFFELL | v31 & 1;
  *(_QWORD *)(v22 + 16) = v31 & 0xFFFFFFFFFFFFFFFELL | v21 & 1;
  *(_QWORD *)(v22 + 24) = v32;
  v31 = 0;
  v32 = &str_110;
  re::SampledAnimationAssetData<re::SkeletalPoseAssetData>::SampledAnimationAssetData(v22 + 32, (uint64_t)v33);
  *(_QWORD *)(v22 + 32) = off_24ED33AA8;
  *(_QWORD *)(v22 + 168) = 0;
  *(_QWORD *)(v22 + 176) = 0;
  *(_QWORD *)(v22 + 160) = 0;
  *(_QWORD *)(v22 + 168) = v39;
  v39 = 0;
  v23 = *(_QWORD *)(v22 + 160);
  *(_QWORD *)(v22 + 160) = 0;
  *(_QWORD *)(v22 + 160) = v38;
  v38 = v23;
  v24 = *(_QWORD *)(v22 + 176);
  *(_QWORD *)(v22 + 176) = v40;
  *(_QWORD *)&v40 = v24;
  *(_QWORD *)(v22 + 216) = 0;
  *(_QWORD *)(v22 + 192) = 0;
  *(_QWORD *)(v22 + 200) = 0;
  *(_QWORD *)(v22 + 184) = 0;
  *(_DWORD *)(v22 + 208) = 0;
  *(_QWORD *)(v22 + 184) = *((_QWORD *)&v40 + 1);
  *((_QWORD *)&v40 + 1) = 0;
  *(_QWORD *)(v22 + 192) = v41;
  *(_QWORD *)&v41 = 0;
  v25 = *(_QWORD *)(v22 + 200);
  *(_QWORD *)(v22 + 200) = *((_QWORD *)&v41 + 1);
  *((_QWORD *)&v41 + 1) = v25;
  v26 = *(_QWORD *)(v22 + 216);
  *(_QWORD *)(v22 + 216) = v43;
  v43 = v26;
  ++v42;
  ++*(_DWORD *)(v22 + 208);
  LOWORD(v26) = v44;
  *(_BYTE *)(v22 + 226) = v45;
  *(_WORD *)(v22 + 224) = v26;
  *(double *)(v22 + 232) = v46;
  *(_QWORD *)(v22 + 272) = 0;
  *(_QWORD *)(v22 + 248) = 0;
  *(_QWORD *)(v22 + 256) = 0;
  *(_QWORD *)(v22 + 240) = 0;
  *(_DWORD *)(v22 + 264) = 0;
  *(_QWORD *)(v22 + 240) = v47;
  *(_QWORD *)&v47 = 0;
  *(_QWORD *)(v22 + 248) = *((_QWORD *)&v47 + 1);
  *((_QWORD *)&v47 + 1) = 0;
  v27 = *(_QWORD *)(v22 + 256);
  *(_QWORD *)(v22 + 256) = v48;
  v48 = v27;
  v28 = *(_QWORD *)(v22 + 272);
  *(_QWORD *)(v22 + 272) = v50;
  v50 = v28;
  ++v49;
  ++*(_DWORD *)(v22 + 264);
  if ((_QWORD)v47)
  {
    if (v28)
      (*(void (**)(void))(*(_QWORD *)v47 + 40))();
    v50 = 0;
    v48 = 0;
    v47 = 0uLL;
    ++v49;
  }
  re::DynamicArray<re::StringID>::deinit((uint64_t)&v40 + 8);
  re::AssetHandle::~AssetHandle((re::AssetHandle *)&v38);
  v33[0] = off_24ED33B18;
  re::DynamicArray<re::EvaluationSkeletalPoseInputHandle>::deinit((uint64_t)&v37);
  v33[0] = off_24ED36578;
  if ((_QWORD)v35)
  {
    if ((BYTE8(v35) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v35 + 40))();
    v35 = 0u;
    v36 = 0u;
  }
  re::StringID::destroyString((re::StringID *)&v34);
  re::StringID::destroyString((re::StringID *)&v31);
  re::StringID::destroyString((re::StringID *)&v29);
}

void re::USDImportContext::addPhysicsCollider(uint64_t a1, StringID *a2, uint64_t a3, __int128 *a4, int a5, char a6)
{
  uint64_t v11;
  uint64_t v12;
  char *var1;
  __int128 v14;
  uint64_t v15;
  _QWORD v16[2];
  __int128 v17;
  __int128 v18;
  __int128 v19;
  char v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  if (a5)
  {
    LOBYTE(v16[0]) = 1;
    re::HashTable<re::StringID,unsigned long,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addNew<BOOL>(a1 + 472, a2, (unsigned __int8 *)v16);
  }
  v11 = a1 + 368;
  v16[0] = *(_QWORD *)(a1 + 408);
  re::HashTable<re::StringID,unsigned long,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::add(a1 + 424, a2, v16);
  v12 = *(_QWORD *)&a2->var0;
  var1 = a2->var1;
  *(_QWORD *)&a2->var0 = 0;
  a2->var1 = (char *)&str_110;
  *(_QWORD *)&v17 = a3;
  v14 = a4[1];
  v18 = *a4;
  v19 = v14;
  v20 = a6;
  v15 = re::BucketArray<re::USDImportContextPhysicsColliderData,8ul>::addUninitialized(v11);
  *(_QWORD *)v15 = v12;
  *(_QWORD *)(v15 + 8) = var1;
  v16[0] = 0;
  v16[1] = &str_110;
  *(_OWORD *)(v15 + 16) = v17;
  *(_OWORD *)(v15 + 32) = v18;
  *(_OWORD *)(v15 + 48) = v19;
  *(_BYTE *)(v15 + 64) = v20;
  re::StringID::destroyString((re::StringID *)v16);
}

uint64_t re::HashTable<re::StringID,unsigned long,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addNew<BOOL>(uint64_t a1, StringID *a2, unsigned __int8 *a3)
{
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;

  v6 = 0xBF58476D1CE4E5B9 * ((*(_QWORD *)&a2->var0 >> 31) ^ (*(_QWORD *)&a2->var0 >> 1));
  v7 = (0x94D049BB133111EBLL * (v6 ^ (v6 >> 27))) ^ ((0x94D049BB133111EBLL * (v6 ^ (v6 >> 27))) >> 31);
  if (!*(_QWORD *)a1)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  v8 = v7 % *(unsigned int *)(a1 + 24);
  v9 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v8);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
LABEL_8:
    v12 = re::HashTable<re::StringID,unsigned long,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addEmplace<BOOL>(a1, v8, v7, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    return *(_QWORD *)(a1 + 16) + 32 * v12 + 24;
  }
  v10 = *(_QWORD *)(a1 + 16);
  while (1)
  {
    v11 = v10 + 32 * v9;
    if (re::StringID::operator==((_QWORD *)(v11 + 8), a2))
      return v11 + 24;
    v9 = *(_DWORD *)(v10 + 32 * v9) & 0x7FFFFFFF;
    if (v9 == 0x7FFFFFFF)
      goto LABEL_8;
  }
}

void re::USDImportContext::addPhysicsRigidBody(uint64_t a1, StringID *a2, __int128 *a3)
{
  uint64_t v5;
  uint64_t v6;
  char *var1;
  __int128 v8;
  uint64_t v9;
  _QWORD v10[2];
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v5 = a1 + 520;
  v10[0] = *(_QWORD *)(a1 + 560);
  re::HashTable<re::StringID,unsigned long,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::add(a1 + 576, a2, v10);
  v6 = *(_QWORD *)&a2->var0;
  var1 = a2->var1;
  *(_QWORD *)&a2->var0 = 0;
  a2->var1 = (char *)&str_110;
  v8 = a3[1];
  v11 = *a3;
  v12 = v8;
  v13 = a3[2];
  LODWORD(v14) = *((_DWORD *)a3 + 12);
  v9 = re::BucketArray<re::USDImportContextPhysicsRigidBodyData,8ul>::addUninitialized(v5);
  *(_QWORD *)v9 = v6;
  *(_QWORD *)(v9 + 8) = var1;
  v10[0] = 0;
  v10[1] = &str_110;
  *(_OWORD *)(v9 + 16) = v11;
  *(_OWORD *)(v9 + 32) = v12;
  *(_OWORD *)(v9 + 48) = v13;
  *(_OWORD *)(v9 + 64) = v14;
  re::StringID::destroyString((re::StringID *)v10);
}

uint64_t re::BucketArray<re::USDImportContextBlendShapeData,8ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1018, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(_QWORD *)(a1 + 8) <= a2 >> 3)
    goto LABEL_8;
  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
    v3 = a1 + 24;
  else
    v3 = *(_QWORD *)(a1 + 32);
  return *(_QWORD *)(v3 + 8 * (a2 >> 3)) + 152 * (a2 & 7);
}

{
  unint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1011, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(_QWORD *)(a1 + 8) <= a2 >> 3)
    goto LABEL_8;
  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
    v3 = a1 + 24;
  else
    v3 = *(_QWORD *)(a1 + 32);
  return *(_QWORD *)(v3 + 8 * (a2 >> 3)) + 152 * (a2 & 7);
}

unint64_t *re::USDImportContext::getPhysicsColliderData(re::USDImportContext *this, unint64_t a2)
{
  uint64_t v3;
  unint64_t *result;

  v3 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[]((uint64_t)this + 624, a2);
  result = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)this + 424, (_QWORD *)(v3 + 40));
  if (result)
    return *(unint64_t **)(re::BucketArray<re::USDImportContextPhysicsColliderData,8ul>::operator[]((uint64_t)this + 368, *result)+ 16);
  return result;
}

uint64_t re::BucketArray<re::USDImportContextPhysicsColliderData,8ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1018, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(_QWORD *)(a1 + 8) <= a2 >> 3)
    goto LABEL_8;
  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
    v3 = a1 + 24;
  else
    v3 = *(_QWORD *)(a1 + 32);
  return *(_QWORD *)(v3 + 8 * (a2 >> 3)) + 80 * (a2 & 7);
}

{
  unint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1011, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(_QWORD *)(a1 + 8) <= a2 >> 3)
    goto LABEL_8;
  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
    v3 = a1 + 24;
  else
    v3 = *(_QWORD *)(a1 + 32);
  return *(_QWORD *)(v3 + 8 * (a2 >> 3)) + 80 * (a2 & 7);
}

unint64_t *re::USDImportContext::getPhysicsColliderPose(re::USDImportContext *this, unint64_t a2)
{
  uint64_t v3;
  unint64_t *result;

  v3 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[]((uint64_t)this + 624, a2);
  result = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)this + 424, (_QWORD *)(v3 + 40));
  if (result)
    return (unint64_t *)(re::BucketArray<re::USDImportContextPhysicsColliderData,8ul>::operator[]((uint64_t)this + 368, *result)+ 32);
  return result;
}

unint64_t *re::USDImportContext::getCollidesWithEnvironment(re::USDImportContext *this, unint64_t a2)
{
  uint64_t v3;
  unint64_t *result;

  v3 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[]((uint64_t)this + 624, a2);
  result = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)this + 424, (_QWORD *)(v3 + 40));
  if (result)
    return (unint64_t *)(*(_BYTE *)(re::BucketArray<re::USDImportContextPhysicsColliderData,8ul>::operator[]((uint64_t)this + 368, *result)+ 64) != 0);
  return result;
}

unint64_t *re::USDImportContext::getPhysicsRigidBodyProperties(re::USDImportContext *this, unint64_t a2)
{
  uint64_t v3;
  unint64_t *result;

  v3 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[]((uint64_t)this + 624, a2);
  result = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)this + 576, (_QWORD *)(v3 + 40));
  if (result)
    return (unint64_t *)(re::BucketArray<re::USDImportContextPhysicsColliderData,8ul>::operator[]((uint64_t)this + 520, *result)+ 16);
  return result;
}

uint64_t re::BucketArray<re::USDImportContextBlendShapeData,8ul>::deinit(uint64_t a1)
{
  uint64_t v2;
  unint64_t i;
  re::USDImportContextBlendShapeData *v4;
  uint64_t result;

  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    for (i = 0; i != v2; ++i)
    {
      v4 = (re::USDImportContextBlendShapeData *)re::BucketArray<re::USDImportContextBlendShapeData,8ul>::operator[](a1, i);
      re::USDImportContextBlendShapeData::~USDImportContextBlendShapeData(v4);
    }
  }
  while (*(_QWORD *)(a1 + 8))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)a1);
  result = re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1);
  *(_QWORD *)(a1 + 40) = 0;
  ++*(_DWORD *)(a1 + 48);
  return result;
}

_QWORD *re::BucketArray<re::USDImportContextSkeletonData,4ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  _QWORD *result;

  *(_QWORD *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((_QWORD *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(_QWORD *)(a1 + 40) = 0;
  result = re::BucketArray<re::USDImportContextSkeletonData,4ul>::setBucketsCapacity((_QWORD *)a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

uint64_t re::BucketArray<re::USDImportContextSkeletonData,4ul>::deinit(uint64_t a1)
{
  uint64_t v2;
  unint64_t i;
  re::USDImportContextSkeletonData *v4;
  uint64_t result;

  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    for (i = 0; i != v2; ++i)
    {
      v4 = (re::USDImportContextSkeletonData *)re::BucketArray<re::USDImportContextSkeletonData,4ul>::operator[](a1, i);
      re::USDImportContextSkeletonData::~USDImportContextSkeletonData(v4);
    }
  }
  while (*(_QWORD *)(a1 + 8))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)a1);
  result = re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1);
  *(_QWORD *)(a1 + 40) = 0;
  ++*(_DWORD *)(a1 + 48);
  return result;
}

_QWORD *re::BucketArray<re::USDImportContextSkeletalAnimationData,8ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  _QWORD *result;

  *(_QWORD *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((_QWORD *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(_QWORD *)(a1 + 40) = 0;
  result = re::BucketArray<re::USDImportContextSkeletalAnimationData,8ul>::setBucketsCapacity((_QWORD *)a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

uint64_t re::BucketArray<re::USDImportContextSkeletalAnimationData,8ul>::deinit(uint64_t a1)
{
  uint64_t v2;
  unint64_t i;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t result;

  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    for (i = 0; i != v2; ++i)
    {
      v4 = re::BucketArray<re::USDImportContextSkeletalAnimationData,8ul>::operator[](a1, i);
      v5 = *(_QWORD *)(v4 + 240);
      if (v5)
      {
        if (*(_QWORD *)(v4 + 272))
          (*(void (**)(uint64_t))(*(_QWORD *)v5 + 40))(v5);
        *(_QWORD *)(v4 + 272) = 0;
        *(_QWORD *)(v4 + 248) = 0;
        *(_QWORD *)(v4 + 256) = 0;
        *(_QWORD *)(v4 + 240) = 0;
        ++*(_DWORD *)(v4 + 264);
      }
      re::DynamicArray<re::StringID>::deinit(v4 + 184);
      re::AssetHandle::~AssetHandle((re::AssetHandle *)(v4 + 160));
      *(_QWORD *)(v4 + 32) = off_24ED33B18;
      re::DynamicArray<re::EvaluationSkeletalPoseInputHandle>::deinit(v4 + 120);
      *(_QWORD *)(v4 + 32) = off_24ED36578;
      v6 = *(_QWORD *)(v4 + 72);
      if (v6)
      {
        if ((*(_BYTE *)(v4 + 80) & 1) != 0)
          (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v6 + 40))(v6, *(_QWORD *)(v4 + 88));
        *(_OWORD *)(v4 + 72) = 0u;
        *(_OWORD *)(v4 + 88) = 0u;
      }
      re::StringID::destroyString((re::StringID *)(v4 + 56));
      re::StringID::destroyString((re::StringID *)(v4 + 16));
      re::StringID::destroyString((re::StringID *)v4);
    }
  }
  while (*(_QWORD *)(a1 + 8))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)a1);
  result = re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1);
  *(_QWORD *)(a1 + 40) = 0;
  ++*(_DWORD *)(a1 + 48);
  return result;
}

double re::USDImportContext::generatePerMeshCompileOptions@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  double v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _anonymous_namespace_ *v10;
  const char *v11;
  uint64_t v12;
  uint64_t v14;
  char v15;
  int v16;
  char v17;
  int v18;
  __int16 v19;
  int v20;
  int v21;
  char v22;
  _OWORD v23[2];
  __int128 v24;

  *(_OWORD *)(a3 + 56) = 0u;
  *(_OWORD *)(a3 + 40) = 0u;
  *(_DWORD *)(a3 + 60) = 0x7FFFFFFF;
  *(_OWORD *)(a3 + 88) = 0u;
  *(_DWORD *)(a3 + 104) = 0;
  *(_QWORD *)(a3 + 108) = 0x7FFFFFFFLL;
  *(_OWORD *)a3 = *(_OWORD *)a2;
  *(_QWORD *)(a3 + 13) = *(_QWORD *)(a2 + 13);
  *(_OWORD *)(a3 + 24) = 0u;
  *(_OWORD *)(a3 + 72) = 0u;
  v5 = a3 + 72;
  re::HashTable<re::DynamicString,re::MeshAttributeCompressionOption,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(a3 + 24, a2 + 24);
  v16 = 16842752;
  v17 = 1;
  v18 = 0;
  v19 = 0;
  v20 = 1036831949;
  v21 = 16843008;
  v22 = 0;
  v6 = 0.0;
  v24 = 0u;
  memset(v23, 0, sizeof(v23));
  DWORD1(v24) = 0x7FFFFFFF;
  if (*(_QWORD *)(a1 + 664))
  {
    v7 = 0;
    do
    {
      v8 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[](a1 + 624, v7);
      if ((re::MeshCompileOptions::operator==((unsigned __int8 *)(v8 + 168), (unsigned __int8 *)&v16) & 1) == 0)
      {
        v9 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[](a1 + 624, v7);
        if ((re::MeshCompileOptions::operator==((unsigned __int8 *)(v9 + 168), (unsigned __int8 *)a2) & 1) == 0)
        {
          v10 = (_anonymous_namespace_ *)re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[](a1 + 624, v7);
          v11 = (const char *)*((_QWORD *)v10 + 4);
          v12 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[](a1 + 624, v7);
          re::HashTable<re::DynamicString,re::MeshCompileOptions,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addNew(v5, (re::DynamicString *)&v14, (__int128 *)(v12 + 168));
          if (v14)
          {
            if ((v15 & 1) != 0)
              (*(void (**)(void))(*(_QWORD *)v14 + 40))();
          }
        }
      }
      ++v7;
    }
    while (*(_QWORD *)(a1 + 664) > v7);
  }
  return re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v23, v6);
}

uint64_t re::MeshCompileOptions::operator==(unsigned __int8 *a1, unsigned __int8 *a2)
{
  if (*a1 == *a2
    && a1[1] == a2[1]
    && a1[2] == a2[2]
    && a1[3] == a2[3]
    && a1[5] == a2[5]
    && a1[6] == a2[6]
    && a1[7] == a2[7]
    && a1[9] == a2[9]
    && a1[8] == a2[8]
    && a1[10] == a2[10]
    && *((float *)a1 + 3) == *((float *)a2 + 3)
    && re::MeshModelIOLoadOptions::operator==(a1 + 16, a2 + 16))
  {
    return re::HashTable<re::DynamicString,re::MeshAttributeCompressionOption,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator==((uint64_t)(a1 + 24), (uint64_t)(a2 + 24));
  }
  else
  {
    return 0;
  }
}

uint64_t re::HashTable<re::DynamicString,re::MeshCompileOptions,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addNew(uint64_t a1, re::DynamicString *a2, __int128 *a3)
{
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  char v14;

  v6 = re::Hash<re::DynamicString>::operator()((uint64_t)&v14, (uint64_t)a2);
  v7 = v6;
  if (!*(_QWORD *)a1)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  v8 = v6 % *(unsigned int *)(a1 + 24);
  v9 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v8);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
LABEL_8:
    v11 = re::HashTable<re::DynamicString,re::MeshCompileOptions,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsCopy(a1, v8, v7, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    v12 = *(_QWORD *)(a1 + 16) + 120 * v11;
    return v12 + 48;
  }
  v10 = *(_QWORD *)(a1 + 16);
  while (!re::DynamicString::operator==(v10 + 120 * v9 + 16, (uint64_t)a2))
  {
    v9 = *(_DWORD *)(v10 + 120 * v9 + 8) & 0x7FFFFFFF;
    if (v9 == 0x7FFFFFFF)
      goto LABEL_8;
  }
  v12 = v10 + 120 * v9;
  return v12 + 48;
}

void re::USDImportContext::PhysicsColliderTable::~PhysicsColliderTable(re::USDImportContext::PhysicsColliderTable *this)
{
  re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 13);
  re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 7);
  re::BucketArray<re::USDImportContextPhysicsColliderData,8ul>::deinit((uint64_t)this);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this);
}

_QWORD *re::BucketArray<re::USDImportContextPhysicsColliderData,8ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  _QWORD *result;

  *(_QWORD *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((_QWORD *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(_QWORD *)(a1 + 40) = 0;
  result = re::BucketArray<re::USDImportContextPhysicsColliderData,8ul>::setBucketsCapacity((_QWORD *)a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

uint64_t re::BucketArray<re::USDImportContextPhysicsColliderData,8ul>::deinit(uint64_t a1)
{
  uint64_t v2;
  unint64_t i;
  re::StringID *v4;
  uint64_t result;

  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    for (i = 0; i != v2; ++i)
    {
      v4 = (re::StringID *)re::BucketArray<re::USDImportContextPhysicsColliderData,8ul>::operator[](a1, i);
      re::StringID::destroyString(v4);
    }
  }
  while (*(_QWORD *)(a1 + 8))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)a1);
  result = re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1);
  *(_QWORD *)(a1 + 40) = 0;
  ++*(_DWORD *)(a1 + 48);
  return result;
}

_QWORD *re::BucketArray<re::USDImportContextPhysicsRigidBodyData,8ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  _QWORD *result;

  *(_QWORD *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((_QWORD *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(_QWORD *)(a1 + 40) = 0;
  result = re::BucketArray<re::USDImportContextPhysicsRigidBodyData,8ul>::setBucketsCapacity((_QWORD *)a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

void re::USDImportContext::NodeStackItem::~NodeStackItem(re::USDImportContext::NodeStackItem *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  double v13;
  double v14;

  re::DynamicArray<re::GeomDeformer>::deinit((uint64_t)this + 1024);
  re::FixedArray<re::VertexCacheAnimationData::FrameData>::deinit((_QWORD *)this + 125);
  v2 = *((_QWORD *)this + 119);
  if (v2)
  {
    if (*((_QWORD *)this + 123))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *((_QWORD *)this + 123) = 0;
    *((_QWORD *)this + 120) = 0;
    *((_QWORD *)this + 121) = 0;
    *((_QWORD *)this + 119) = 0;
    ++*((_DWORD *)this + 244);
  }
  std::shared_ptr<re::AssetManager>::~shared_ptr[abi:nn180100]((uint64_t)this + 936);
  re::BucketArray<unsigned long,8ul>::deinit((uint64_t)this + 880);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 880);
  re::AssetHandle::~AssetHandle((re::USDImportContext::NodeStackItem *)((char *)this + 848));
  re::DynamicArray<re::AssetHandle>::deinit((uint64_t)this + 808);
  v3 = *((_QWORD *)this + 97);
  if (v3)
  {
    if ((*((_BYTE *)this + 784) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *((_QWORD *)this + 99));
    *(_OWORD *)((char *)this + 776) = 0u;
    *(_OWORD *)((char *)this + 792) = 0u;
  }
  v4 = *((_QWORD *)this + 93);
  if (v4)
  {
    if ((*((_BYTE *)this + 752) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, *((_QWORD *)this + 95));
    *(_OWORD *)((char *)this + 744) = 0u;
    *(_OWORD *)((char *)this + 760) = 0u;
  }
  v5 = *((_QWORD *)this + 89);
  if (v5)
  {
    if ((*((_BYTE *)this + 720) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v5 + 40))(v5, *((_QWORD *)this + 91));
    *(_OWORD *)((char *)this + 712) = 0u;
    *(_OWORD *)((char *)this + 728) = 0u;
  }
  v6 = (_QWORD *)((char *)this + 616);
  v7 = *((_QWORD *)this + 81);
  if (v7)
  {
    if ((*((_BYTE *)this + 656) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v7 + 40))(v7, *((_QWORD *)this + 83));
    *(_OWORD *)((char *)this + 648) = 0u;
    *(_OWORD *)((char *)this + 664) = 0u;
  }
  if (*v6)
  {
    if ((*((_BYTE *)this + 624) & 1) != 0)
      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*v6 + 40))(*v6, *((_QWORD *)this + 79));
    *(_OWORD *)v6 = 0u;
    *(_OWORD *)((char *)this + 632) = 0u;
  }
  *((_QWORD *)this + 60) = off_24ED33A68;
  v8 = *((_QWORD *)this + 71);
  if (v8)
  {
    if (*((_QWORD *)this + 75))
      (*(void (**)(uint64_t))(*(_QWORD *)v8 + 40))(v8);
    *((_QWORD *)this + 75) = 0;
    *((_QWORD *)this + 72) = 0;
    *((_QWORD *)this + 73) = 0;
    *((_QWORD *)this + 71) = 0;
    ++*((_DWORD *)this + 148);
  }
  *((_QWORD *)this + 60) = off_24ED36578;
  v9 = *((_QWORD *)this + 65);
  if (v9)
  {
    if ((*((_BYTE *)this + 528) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v9 + 40))(v9, *((_QWORD *)this + 67));
    *(_OWORD *)((char *)this + 520) = 0u;
    *(_OWORD *)((char *)this + 536) = 0u;
  }
  re::StringID::destroyString((re::USDImportContext::NodeStackItem *)((char *)this + 504));
  v10 = *((_QWORD *)this + 51);
  if (v10)
  {
    if (*((_QWORD *)this + 52))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v10 + 40))(v10, *((_QWORD *)this + 53));
      *((_QWORD *)this + 52) = 0;
      *((_QWORD *)this + 53) = 0;
    }
    *((_QWORD *)this + 51) = 0;
  }
  v11 = *((_QWORD *)this + 46);
  if (v11)
  {
    if (*((_QWORD *)this + 50))
      (*(void (**)(uint64_t))(*(_QWORD *)v11 + 40))(v11);
    *((_QWORD *)this + 50) = 0;
    *((_QWORD *)this + 47) = 0;
    *((_QWORD *)this + 48) = 0;
    *((_QWORD *)this + 46) = 0;
    ++*((_DWORD *)this + 98);
  }
  v12 = *((_QWORD *)this + 41);
  if (v12)
  {
    if (*((_QWORD *)this + 45))
      (*(void (**)(uint64_t))(*(_QWORD *)v12 + 40))(v12);
    *((_QWORD *)this + 45) = 0;
    *((_QWORD *)this + 42) = 0;
    *((_QWORD *)this + 43) = 0;
    *((_QWORD *)this + 41) = 0;
    ++*((_DWORD *)this + 88);
  }
  re::DynamicArray<re::SharedPtr<re::ecs2::System>>::deinit((uint64_t)this + 288);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 24, v13);
  re::BucketArray<unsigned long,4ul>::deinit((uint64_t)this + 104);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 104);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 7, v14);
  re::StringID::destroyString((re::USDImportContext::NodeStackItem *)((char *)this + 40));
  re::StringID::destroyString((re::USDImportContext::NodeStackItem *)((char *)this + 24));
  re::StringID::destroyString((re::USDImportContext::NodeStackItem *)((char *)this + 8));
}

_QWORD *re::FixedArray<re::VertexCacheAnimationData::FrameData>::deinit(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v5;

  if (*result)
  {
    v1 = result;
    v3 = result + 1;
    v2 = result[1];
    if (v2)
    {
      v4 = v2 << 6;
      v5 = (_QWORD *)(result[2] + 32);
      do
      {
        if (*v5)
        {
          if (v5[1])
          {
            (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*v5 + 40))(*v5, v5[2]);
            v5[1] = 0;
            v5[2] = 0;
          }
          *v5 = 0;
        }
        v5 += 8;
        v4 -= 64;
      }
      while (v4);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v1 + 40))(*v1, v1[2]);
      *v3 = 0;
      v3[1] = 0;
    }
    *v1 = 0;
  }
  return result;
}

uint64_t re::BucketArray<unsigned long,4ul>::deinit(uint64_t a1)
{
  uint64_t v2;
  unint64_t i;
  uint64_t result;

  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    for (i = 0; i != v2; ++i)
      re::BucketArray<unsigned long,4ul>::operator[](a1, i);
  }
  while (*(_QWORD *)(a1 + 8))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)a1);
  result = re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1);
  *(_QWORD *)(a1 + 40) = 0;
  ++*(_DWORD *)(a1 + 48);
  return result;
}

uint64_t re::BucketArray<unsigned long,4ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1011, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(_QWORD *)(a1 + 8) <= a2 >> 2)
    goto LABEL_8;
  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
    v3 = a1 + 24;
  else
    v3 = *(_QWORD *)(a1 + 32);
  return *(_QWORD *)(v3 + 8 * (a2 >> 2)) + 8 * (a2 & 3);
}

uint64_t re::SampledAnimationAssetData<re::GenericSRT<float>>::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v11[2];

  v4 = *(_QWORD *)(a2 + 8);
  *(_BYTE *)(a1 + 16) = *(_BYTE *)(a2 + 16);
  *(_QWORD *)(a1 + 8) = v4;
  v5 = *(_QWORD *)(a2 + 24);
  v6 = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 24) = 0;
  *(_QWORD *)(a2 + 32) = &str_110;
  v7 = *(_QWORD *)(a1 + 24);
  v8 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 24) = v5;
  *(_QWORD *)(a1 + 32) = v6;
  v11[0] = v5 & 0xFFFFFFFFFFFFFFFELL | v7 & 1;
  v11[1] = v8;
  re::StringID::destroyString((re::StringID *)v11);
  re::DynamicString::operator=((re::DynamicString *)(a1 + 40), (re::DynamicString *)(a2 + 40));
  *(_BYTE *)(a1 + 72) = *(_BYTE *)(a2 + 72);
  v9 = *(_QWORD *)(a2 + 73);
  *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
  *(_QWORD *)(a1 + 73) = v9;
  re::DynamicArray<re::AssetHandle>::operator=(a1 + 88, a2 + 88);
  return a1;
}

void re::GeomDeformer::~GeomDeformer(re::GeomDeformer *this)
{
  char *v2;
  char *v3;

  v2 = (char *)this + 112;
  v3 = (char *)this + 392;
  re::BucketArray<re::Matrix4x4<float>,8ul>::deinit((uint64_t)this + 392);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)v3);
  re::BucketArray<re::StringID,8ul>::deinit((uint64_t)this + 336);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 336);
  re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::deinit((uint64_t)this + 280);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 280);
  re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::deinit((uint64_t)this + 224);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 224);
  re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::deinit((uint64_t)this + 168);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 168);
  re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::deinit((uint64_t)v2);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)v2);
  re::DynamicArray<re::GeomDeformer::Affector>::deinit((uint64_t)this + 72);
  re::DynamicArray<re::GeomDeformer::Attribute>::deinit((uint64_t)this + 32);
  re::StringID::destroyString((re::GeomDeformer *)((char *)this + 16));
  re::StringID::destroyString(this);
}

uint64_t re::BucketArray<re::Matrix4x4<float>,8ul>::deinit(uint64_t a1)
{
  uint64_t v2;
  unint64_t i;
  uint64_t result;

  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    for (i = 0; i != v2; ++i)
      re::BucketArray<re::Matrix4x4<float>,8ul>::operator[](a1, i);
  }
  while (*(_QWORD *)(a1 + 8))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)a1);
  result = re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1);
  *(_QWORD *)(a1 + 40) = 0;
  ++*(_DWORD *)(a1 + 48);
  return result;
}

unint64_t re::BucketArray<re::Matrix4x4<float>,8ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1011, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(_QWORD *)(a1 + 8) <= a2 >> 3)
    goto LABEL_8;
  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
    v3 = a1 + 24;
  else
    v3 = *(_QWORD *)(a1 + 32);
  return *(_QWORD *)(v3 + 8 * (a2 >> 3)) + ((a2 & 7) << 6);
}

{
  unint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1018, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(_QWORD *)(a1 + 8) <= a2 >> 3)
    goto LABEL_8;
  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
    v3 = a1 + 24;
  else
    v3 = *(_QWORD *)(a1 + 32);
  return *(_QWORD *)(v3 + 8 * (a2 >> 3)) + ((a2 & 7) << 6);
}

uint64_t re::BucketArray<re::StringID,8ul>::deinit(uint64_t a1)
{
  uint64_t v2;
  unint64_t i;
  re::StringID *v4;
  uint64_t result;

  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    for (i = 0; i != v2; ++i)
    {
      v4 = (re::StringID *)re::BucketArray<RESubscriptionHandle,8ul>::operator[](a1, i);
      re::StringID::destroyString(v4);
    }
  }
  while (*(_QWORD *)(a1 + 8))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)a1);
  result = re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1);
  *(_QWORD *)(a1 + 40) = 0;
  ++*(_DWORD *)(a1 + 48);
  return result;
}

uint64_t re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::deinit(uint64_t a1)
{
  uint64_t v2;
  unint64_t i;
  uint64_t v4;
  uint64_t result;

  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    for (i = 0; i != v2; ++i)
    {
      v4 = re::BucketArray<re::RigDataTypeStructBuilder::RigDataTypeStructMember,8ul>::operator[](a1, i);
      re::StringID::destroyString((re::StringID *)(v4 + 16));
      re::StringID::destroyString((re::StringID *)v4);
    }
  }
  while (*(_QWORD *)(a1 + 8))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)a1);
  result = re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1);
  *(_QWORD *)(a1 + 40) = 0;
  ++*(_DWORD *)(a1 + 48);
  return result;
}

uint64_t re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::deinit(uint64_t a1)
{
  uint64_t v2;
  unint64_t i;
  _QWORD *v4;
  uint64_t result;

  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    for (i = 0; i != v2; ++i)
    {
      v4 = (_QWORD *)re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::operator[](a1, i);
      if (*v4)
      {
        if (v4[1])
        {
          (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*v4 + 40))(*v4, v4[2]);
          v4[1] = 0;
          v4[2] = 0;
        }
        *v4 = 0;
      }
    }
  }
  while (*(_QWORD *)(a1 + 8))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)a1);
  result = re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1);
  *(_QWORD *)(a1 + 40) = 0;
  ++*(_DWORD *)(a1 + 48);
  return result;
}

uint64_t re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1011, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(_QWORD *)(a1 + 8) <= a2 >> 3)
    goto LABEL_8;
  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
    v3 = a1 + 24;
  else
    v3 = *(_QWORD *)(a1 + 32);
  return *(_QWORD *)(v3 + 8 * (a2 >> 3)) + 24 * (a2 & 7);
}

uint64_t re::DynamicArray<re::GeomDeformer::Affector>::deinit(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 40 * v4;
        do
        {
          re::DynamicArray<re::GeomDeformer::Attribute>::deinit(v3);
          v3 += 40;
          v5 -= 40;
        }
        while (v5);
        result = *(_QWORD *)a1;
        v3 = *(_QWORD *)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::DynamicArray<re::GeomDeformer::Attribute>::deinit(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  re::StringID *v6;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 40 * v4;
        v6 = (re::StringID *)(v3 + 8);
        do
        {
          re::StringID::destroyString(v6);
          v6 = (re::StringID *)((char *)v6 + 40);
          v5 -= 40;
        }
        while (v5);
        result = *(_QWORD *)a1;
        v3 = *(_QWORD *)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

void re::USDImportContextBlendShapeData::~USDImportContextBlendShapeData(re::USDImportContextBlendShapeData *this)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v3 = (_QWORD *)((char *)this + 104);
  v2 = *((_QWORD *)this + 13);
  if (v2)
  {
    if (*((_QWORD *)this + 17))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *((_QWORD *)this + 17) = 0;
    v3[1] = 0;
    v3[2] = 0;
    *v3 = 0;
    ++*((_DWORD *)this + 32);
  }
  v4 = *((_QWORD *)this + 10);
  if (v4)
  {
    if (*((_QWORD *)this + 11))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, *((_QWORD *)this + 12));
      *((_QWORD *)this + 11) = 0;
      *((_QWORD *)this + 12) = 0;
    }
    *((_QWORD *)this + 10) = 0;
  }
  v5 = *((_QWORD *)this + 7);
  if (v5)
  {
    if (*((_QWORD *)this + 8))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v5 + 40))(v5, *((_QWORD *)this + 9));
      *((_QWORD *)this + 8) = 0;
      *((_QWORD *)this + 9) = 0;
    }
    *((_QWORD *)this + 7) = 0;
  }
  v6 = *((_QWORD *)this + 4);
  if (v6)
  {
    if (*((_QWORD *)this + 5))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v6 + 40))(v6, *((_QWORD *)this + 6));
      *((_QWORD *)this + 5) = 0;
      *((_QWORD *)this + 6) = 0;
    }
    *((_QWORD *)this + 4) = 0;
  }
  re::StringID::destroyString((re::USDImportContextBlendShapeData *)((char *)this + 16));
  re::StringID::destroyString(this);
}

void re::USDImportContextSkeletonData::~USDImportContextSkeletonData(re::USDImportContextSkeletonData *this)
{
  uint64_t v2;
  uint64_t v3;
  __n128 v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v2 = *((_QWORD *)this + 47);
  if (v2)
  {
    if (*((_QWORD *)this + 51))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *((_QWORD *)this + 51) = 0;
    *((_QWORD *)this + 48) = 0;
    *((_QWORD *)this + 49) = 0;
    *((_QWORD *)this + 47) = 0;
    ++*((_DWORD *)this + 100);
  }
  re::DynamicArray<re::StringID>::deinit((uint64_t)this + 328);
  re::AssetHandle::~AssetHandle((re::USDImportContextSkeletonData *)((char *)this + 304));
  *((_QWORD *)this + 22) = off_24ED33B18;
  re::DynamicArray<re::EvaluationSkeletalPoseInputHandle>::deinit((uint64_t)this + 264);
  *((_QWORD *)this + 22) = off_24ED36578;
  v3 = *((_QWORD *)this + 27);
  if (v3)
  {
    if ((*((_BYTE *)this + 224) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *((_QWORD *)this + 29));
    *(_OWORD *)((char *)this + 216) = 0u;
    *(_OWORD *)((char *)this + 232) = 0u;
  }
  re::StringID::destroyString((re::USDImportContextSkeletonData *)((char *)this + 200));
  v4.n128_f64[0] = re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 16);
  v5 = *((_QWORD *)this + 13);
  if (v5)
  {
    if (*((_QWORD *)this + 14))
    {
      (*(void (**)(uint64_t, _QWORD, double))(*(_QWORD *)v5 + 40))(v5, *((_QWORD *)this + 15), v4.n128_f64[0]);
      *((_QWORD *)this + 14) = 0;
      *((_QWORD *)this + 15) = 0;
    }
    *((_QWORD *)this + 13) = 0;
  }
  v6 = *((_QWORD *)this + 10);
  if (v6)
  {
    if (*((_QWORD *)this + 11))
    {
      (*(void (**)(uint64_t, _QWORD, __n128))(*(_QWORD *)v6 + 40))(v6, *((_QWORD *)this + 12), v4);
      *((_QWORD *)this + 11) = 0;
      *((_QWORD *)this + 12) = 0;
    }
    *((_QWORD *)this + 10) = 0;
  }
  v7 = *((_QWORD *)this + 7);
  if (v7)
  {
    if (*((_QWORD *)this + 8))
    {
      (*(void (**)(uint64_t, _QWORD, __n128))(*(_QWORD *)v7 + 40))(v7, *((_QWORD *)this + 9), v4);
      *((_QWORD *)this + 8) = 0;
      *((_QWORD *)this + 9) = 0;
    }
    *((_QWORD *)this + 7) = 0;
  }
  re::FixedArray<re::StringID>::deinit((_QWORD *)this + 4);
  re::StringID::destroyString((re::USDImportContextSkeletonData *)((char *)this + 16));
  re::StringID::destroyString(this);
}

double re::SampledAnimationAssetData<re::SkeletalPoseAssetData>::SampledAnimationAssetData(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  double result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  *(_QWORD *)a1 = off_24ED36578;
  v2 = *(_QWORD *)(a2 + 8);
  *(_BYTE *)(a1 + 16) = *(_BYTE *)(a2 + 16);
  *(_QWORD *)(a1 + 8) = v2;
  v3 = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a1 + 24) & 0xFFFFFFFFFFFFFFFELL | v3 & 1;
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24) & 0xFFFFFFFFFFFFFFFELL | v3 & 1;
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 24) = 0;
  *(_QWORD *)(a2 + 32) = &str_110;
  result = 0.0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
  v5 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  v6 = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 64) = 0;
  v8 = *(_QWORD *)(a1 + 48);
  v7 = *(_QWORD *)(a1 + 56);
  *(_QWORD *)(a1 + 48) = v5;
  *(_QWORD *)(a1 + 56) = v6;
  *(_QWORD *)(a2 + 48) = v8;
  *(_QWORD *)(a2 + 56) = v7;
  *(_BYTE *)(a1 + 72) = *(_BYTE *)(a2 + 72);
  *(_QWORD *)a1 = off_24ED33B18;
  v9 = *(_QWORD *)(a2 + 73);
  *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
  *(_QWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 73) = v9;
  *(_QWORD *)(a1 + 120) = 0;
  *(_DWORD *)(a1 + 112) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  v10 = *(_QWORD *)(a2 + 96);
  *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
  *(_QWORD *)(a1 + 96) = v10;
  *(_QWORD *)(a2 + 88) = 0;
  *(_QWORD *)(a2 + 96) = 0;
  v11 = *(_QWORD *)(a1 + 104);
  *(_QWORD *)(a1 + 104) = *(_QWORD *)(a2 + 104);
  *(_QWORD *)(a2 + 104) = v11;
  v12 = *(_QWORD *)(a1 + 120);
  *(_QWORD *)(a1 + 120) = *(_QWORD *)(a2 + 120);
  *(_QWORD *)(a2 + 120) = v12;
  ++*(_DWORD *)(a2 + 112);
  ++*(_DWORD *)(a1 + 112);
  return result;
}

BOOL re::MeshModelIOLoadOptions::operator==(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a1 == *a2 && a1[1] == a2[1] && a1[2] == a2[2] && a1[3] == a2[3] && a1[4] == a2[4];
}

uint64_t re::HashTable<re::DynamicString,re::MeshAttributeCompressionOption,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator==(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (*(_DWORD *)(a1 + 28) != *(_DWORD *)(a2 + 28))
    return 0;
  v2 = *(unsigned int *)(a2 + 32);
  if ((_DWORD)v2)
  {
    v4 = 0;
    v5 = *(_QWORD *)(a2 + 16);
    while (1)
    {
      if ((*(_DWORD *)(v5 + 56 * v4 + 8) & 0x80000000) != 0)
      {
        if (!*(_QWORD *)a1)
          break;
        v6 = *(unsigned int *)(*(_QWORD *)(a1 + 8)
                             + 4 * (*(_QWORD *)(v5 + 56 * v4) % (unint64_t)*(unsigned int *)(a1 + 24)));
        if ((_DWORD)v6 == 0x7FFFFFFF)
          break;
        v7 = *(_QWORD *)(a1 + 16);
        while (!re::DynamicString::operator==(v7 + 56 * v6 + 16, v5 + 56 * v4 + 16))
        {
          v6 = *(_DWORD *)(v7 + 56 * v6 + 8) & 0x7FFFFFFF;
          if (v6 == 0x7FFFFFFF)
            return 0;
        }
        if (*(unsigned __int8 *)(v7 + 56 * v6 + 48) != *(unsigned __int8 *)(v5 + 56 * v4 + 48)
          || *(float *)(v7 + 56 * v6 + 52) != *(float *)(v5 + 56 * v4 + 52))
        {
          break;
        }
      }
      if (++v4 == v2)
        return 1;
    }
    return 0;
  }
  return 1;
}

double re::HashTable<re::DynamicString,re::MeshCompileOptions,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(uint64_t *a1, double result)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;

  v3 = *a1;
  if (v3)
  {
    if (*((_DWORD *)a1 + 8))
    {
      v4 = 0;
      v5 = 0;
      do
      {
        result = re::HashTable<re::DynamicString,re::MeshCompileOptions,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::EntryWithHash::free(a1[2] + v4, result);
        ++v5;
        v4 += 120;
      }
      while (v5 < *((unsigned int *)a1 + 8));
      v3 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v3 + 40))(v3, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

double re::HashTable<re::DynamicString,re::MeshCompileOptions,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::EntryWithHash::free(uint64_t a1, double result)
{
  int v2;
  uint64_t v4;
  _OWORD *v5;

  v2 = *(_DWORD *)(a1 + 8);
  if (v2 < 0)
  {
    v5 = (_OWORD *)(a1 + 16);
    v4 = *(_QWORD *)(a1 + 16);
    *((_DWORD *)v5 - 2) = v2 & 0x7FFFFFFF;
    if (v4)
    {
      if ((*(_BYTE *)(a1 + 24) & 1) != 0)
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, *(_QWORD *)(a1 + 32));
      result = 0.0;
      *v5 = 0u;
      v5[1] = 0u;
    }
    return re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)(a1 + 72), result);
  }
  return result;
}

_QWORD *re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::setBucketsCapacity(_QWORD *result, unint64_t a2)
{
  _QWORD *v3;
  unint64_t v4;
  unint64_t *v5;
  _QWORD *v6;
  unint64_t v7;
  int v8;
  unint64_t v9;
  unint64_t v10;
  BOOL v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  _QWORD *v15;
  unint64_t v16;

  v3 = result;
  if (*result)
  {
    if (result[5] < 32 * a2)
    {
      while (1)
      {
        v4 = v3[1];
        if (v4 <= a2)
          break;
        result = (_QWORD *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        v5 = v3 + 3;
        do
        {
          result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(*(_QWORD *)*v3 + 32))(*v3, 34304, 0);
          v6 = result;
          if (*v3)
          {
            v7 = v3[1];
            v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              v9 = *v5;
              v11 = v7 >= *v5;
              v10 = v7 + 1;
              v11 = !v11 || v9 >= v10;
              if (v11)
                goto LABEL_22;
              v12 = 2 * v9;
              goto LABEL_18;
            }
            v10 = v7 + 1;
            if (v10 >= 3)
            {
              v12 = 4;
LABEL_18:
              if (v12 <= v10)
                v14 = v10;
              else
                v14 = v12;
              result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v14);
              v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            v13 = v3[1] + 1;
            result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v13);
            v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + 4) = v8;
          }
LABEL_22:
          v15 = v3 + 3;
          if ((v8 & 1) == 0)
            v15 = (_QWORD *)v3[4];
          v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
  }
  return result;
}

uint64_t *re::BucketArray<unsigned long,32ul>::setBucketsCapacity(uint64_t *result, unint64_t a2)
{
  uint64_t *v3;
  unint64_t v4;
  uint64_t v5;

  v3 = result;
  if (*result)
  {
    if (result[5] < 32 * a2)
    {
      while (1)
      {
        v4 = v3[1];
        if (v4 <= a2)
          break;
        result = (uint64_t *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      while (v4 < a2)
      {
        v5 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)*v3 + 32))(*v3, 256, 0);
        result = (uint64_t *)re::DynamicOverflowArray<RESubscriptionHandle *,2ul>::add((uint64_t)v3, &v5);
        v4 = v3[1];
      }
    }
  }
  else
  {
  }
  return result;
}

uint64_t re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::addUninitialized(uint64_t a1)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = *(_QWORD *)(a1 + 40);
  v3 = *(_QWORD *)(a1 + 8);
  if (v2 + 1 > 32 * v3)
  {
    re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::setBucketsCapacity((_QWORD *)a1, (v2 + 32) >> 5);
    v3 = *(_QWORD *)(a1 + 8);
  }
  if (v3 <= v2 >> 5)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
    v4 = a1 + 24;
  else
    v4 = *(_QWORD *)(a1 + 32);
  v5 = *(_QWORD *)(v4 + 8 * (v2 >> 5));
  ++*(_QWORD *)(a1 + 40);
  ++*(_DWORD *)(a1 + 48);
  return v5 + 1072 * (v2 & 0x1F);
}

uint64_t re::USDImportContext::NodeStackItem::NodeStackItem(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  _QWORD v43[2];
  char v44;

  *(_BYTE *)a1 = *(_BYTE *)a2;
  v4 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFFFFELL | v4 & 1;
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8) & 0xFFFFFFFFFFFFFFFELL | v4 & 1;
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = &str_110;
  v5 = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a1 + 24) & 0xFFFFFFFFFFFFFFFELL | v5 & 1;
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24) & 0xFFFFFFFFFFFFFFFELL | v5 & 1;
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 24) = 0;
  *(_QWORD *)(a2 + 32) = &str_110;
  v6 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a1 + 40) & 0xFFFFFFFFFFFFFFFELL | v6 & 1;
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40) & 0xFFFFFFFFFFFFFFFELL | v6 & 1;
  *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 48) = &str_110;
  *(_DWORD *)(a1 + 88) = 0;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 92) = 0x7FFFFFFFLL;
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 56) = 0;
  v7 = *(_QWORD *)(a1 + 64);
  *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(a2 + 64) = v7;
  v8 = *(_QWORD *)(a1 + 72);
  *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
  *(_QWORD *)(a2 + 72) = v8;
  LODWORD(v8) = *(_DWORD *)(a1 + 80);
  *(_DWORD *)(a1 + 80) = *(_DWORD *)(a2 + 80);
  *(_DWORD *)(a2 + 80) = v8;
  LODWORD(v8) = *(_DWORD *)(a1 + 84);
  *(_DWORD *)(a1 + 84) = *(_DWORD *)(a2 + 84);
  *(_DWORD *)(a2 + 84) = v8;
  LODWORD(v8) = *(_DWORD *)(a1 + 88);
  *(_DWORD *)(a1 + 88) = *(_DWORD *)(a2 + 88);
  *(_DWORD *)(a2 + 88) = v8;
  LODWORD(v8) = *(_DWORD *)(a1 + 92);
  *(_DWORD *)(a1 + 92) = *(_DWORD *)(a2 + 92);
  *(_DWORD *)(a2 + 92) = v8;
  v9 = a2 + 104;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = 0;
  v10 = a1 + 104;
  *(_DWORD *)(a1 + 120) = 1;
  *(_QWORD *)(a1 + 136) = 0;
  *(_QWORD *)(a1 + 144) = 0;
  *(_QWORD *)(a1 + 128) = 0;
  *(_DWORD *)(a1 + 152) = 0;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::DynamicOverflowArray((uint64_t)v43, a1 + 104);
  re::DynamicOverflowArray<RESubscriptionHandle *,2ul>::operator=(v10, v9);
  re::DynamicOverflowArray<RESubscriptionHandle *,2ul>::operator=(v9, (uint64_t)v43);
  if (v43[0] && (v44 & 1) == 0)
    (*(void (**)(void))(*(_QWORD *)v43[0] + 40))();
  v11 = *(_QWORD *)(a1 + 144);
  *(_QWORD *)(a1 + 144) = *(_QWORD *)(a2 + 144);
  *(_QWORD *)(a2 + 144) = v11;
  ++*(_DWORD *)(a1 + 152);
  ++*(_DWORD *)(a2 + 152);
  *(_QWORD *)(a1 + 160) = *(_QWORD *)(a2 + 160);
  v12 = *(_OWORD *)(a2 + 168);
  *(_QWORD *)(a1 + 181) = *(_QWORD *)(a2 + 181);
  *(_OWORD *)(a1 + 168) = v12;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_DWORD *)(a1 + 224) = 0;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_QWORD *)(a1 + 228) = 0x7FFFFFFFLL;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)(a1 + 192), (uint64_t *)(a2 + 192));
  v13 = *(_OWORD *)(a2 + 240);
  v14 = *(_OWORD *)(a2 + 272);
  *(_OWORD *)(a1 + 256) = *(_OWORD *)(a2 + 256);
  *(_OWORD *)(a1 + 272) = v14;
  *(_OWORD *)(a1 + 240) = v13;
  *(_QWORD *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 312) = 0;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_QWORD *)(a1 + 288) = 0;
  *(_QWORD *)(a1 + 288) = *(_QWORD *)(a2 + 288);
  *(_QWORD *)(a2 + 288) = 0;
  *(_QWORD *)(a1 + 296) = *(_QWORD *)(a2 + 296);
  *(_QWORD *)(a2 + 296) = 0;
  v15 = *(_QWORD *)(a1 + 304);
  *(_QWORD *)(a1 + 304) = *(_QWORD *)(a2 + 304);
  *(_QWORD *)(a2 + 304) = v15;
  v16 = *(_QWORD *)(a1 + 320);
  *(_QWORD *)(a1 + 320) = *(_QWORD *)(a2 + 320);
  *(_QWORD *)(a2 + 320) = v16;
  ++*(_DWORD *)(a2 + 312);
  ++*(_DWORD *)(a1 + 312);
  *(_QWORD *)(a1 + 360) = 0;
  *(_QWORD *)(a1 + 328) = 0;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_DWORD *)(a1 + 352) = 0;
  *(_QWORD *)(a1 + 328) = *(_QWORD *)(a2 + 328);
  *(_QWORD *)(a2 + 328) = 0;
  *(_QWORD *)(a1 + 336) = *(_QWORD *)(a2 + 336);
  *(_QWORD *)(a2 + 336) = 0;
  v17 = *(_QWORD *)(a1 + 344);
  *(_QWORD *)(a1 + 344) = *(_QWORD *)(a2 + 344);
  *(_QWORD *)(a2 + 344) = v17;
  v18 = *(_QWORD *)(a1 + 360);
  *(_QWORD *)(a1 + 360) = *(_QWORD *)(a2 + 360);
  *(_QWORD *)(a2 + 360) = v18;
  ++*(_DWORD *)(a2 + 352);
  ++*(_DWORD *)(a1 + 352);
  *(_QWORD *)(a1 + 400) = 0;
  *(_QWORD *)(a1 + 368) = 0;
  *(_OWORD *)(a1 + 376) = 0u;
  *(_DWORD *)(a1 + 392) = 0;
  *(_QWORD *)(a1 + 368) = *(_QWORD *)(a2 + 368);
  *(_QWORD *)(a2 + 368) = 0;
  *(_QWORD *)(a1 + 376) = *(_QWORD *)(a2 + 376);
  *(_QWORD *)(a2 + 376) = 0;
  v19 = *(_QWORD *)(a1 + 384);
  *(_QWORD *)(a1 + 384) = *(_QWORD *)(a2 + 384);
  *(_QWORD *)(a2 + 384) = v19;
  v20 = *(_QWORD *)(a1 + 400);
  *(_QWORD *)(a1 + 400) = *(_QWORD *)(a2 + 400);
  *(_QWORD *)(a2 + 400) = v20;
  ++*(_DWORD *)(a2 + 392);
  ++*(_DWORD *)(a1 + 392);
  *(_QWORD *)(a1 + 408) = 0;
  *(_OWORD *)(a1 + 416) = 0u;
  *(_QWORD *)(a1 + 408) = *(_QWORD *)(a2 + 408);
  *(_QWORD *)(a2 + 408) = 0;
  *(_QWORD *)(a1 + 416) = *(_QWORD *)(a2 + 416);
  *(_QWORD *)(a2 + 416) = 0;
  v21 = *(_QWORD *)(a1 + 424);
  *(_QWORD *)(a1 + 424) = *(_QWORD *)(a2 + 424);
  *(_QWORD *)(a2 + 424) = v21;
  v22 = *(_OWORD *)(a2 + 432);
  v23 = *(_OWORD *)(a2 + 464);
  *(_OWORD *)(a1 + 448) = *(_OWORD *)(a2 + 448);
  *(_OWORD *)(a1 + 464) = v23;
  *(_OWORD *)(a1 + 432) = v22;
  re::SampledAnimationAssetData<re::GenericSRT<float>>::SampledAnimationAssetData(a1 + 480, a2 + 480);
  *(_QWORD *)(a1 + 480) = off_24ED339F8;
  *(_QWORD *)(a1 + 608) = *(_QWORD *)(a2 + 608);
  *(_OWORD *)(a1 + 616) = 0u;
  *(_OWORD *)(a1 + 632) = 0u;
  *(_QWORD *)(a1 + 616) = *(_QWORD *)(a2 + 616);
  *(_QWORD *)(a2 + 616) = 0;
  v24 = *(_QWORD *)(a1 + 632);
  *(_QWORD *)(a1 + 632) = *(_QWORD *)(a2 + 632);
  *(_QWORD *)(a2 + 632) = v24;
  *(_QWORD *)(a1 + 640) = *(_QWORD *)(a2 + 640);
  *(_QWORD *)(a2 + 640) = 0;
  v25 = *(_QWORD *)(a1 + 624);
  *(_QWORD *)(a1 + 624) = *(_QWORD *)(a2 + 624);
  *(_QWORD *)(a2 + 624) = v25;
  *(_OWORD *)(a1 + 648) = 0u;
  *(_OWORD *)(a1 + 664) = 0u;
  *(_QWORD *)(a1 + 648) = *(_QWORD *)(a2 + 648);
  *(_QWORD *)(a2 + 648) = 0;
  v26 = *(_QWORD *)(a1 + 664);
  *(_QWORD *)(a1 + 664) = *(_QWORD *)(a2 + 664);
  *(_QWORD *)(a2 + 664) = v26;
  *(_QWORD *)(a1 + 672) = *(_QWORD *)(a2 + 672);
  *(_QWORD *)(a2 + 672) = 0;
  v27 = *(_QWORD *)(a1 + 656);
  *(_QWORD *)(a1 + 656) = *(_QWORD *)(a2 + 656);
  *(_QWORD *)(a2 + 656) = v27;
  v28 = *(_OWORD *)(a2 + 696);
  *(_OWORD *)(a1 + 680) = *(_OWORD *)(a2 + 680);
  *(_OWORD *)(a1 + 696) = v28;
  *(_OWORD *)(a1 + 712) = 0u;
  *(_OWORD *)(a1 + 728) = 0u;
  *(_QWORD *)(a1 + 712) = *(_QWORD *)(a2 + 712);
  *(_QWORD *)(a2 + 712) = 0;
  v29 = *(_QWORD *)(a1 + 728);
  *(_QWORD *)(a1 + 728) = *(_QWORD *)(a2 + 728);
  *(_QWORD *)(a2 + 728) = v29;
  *(_QWORD *)(a1 + 736) = *(_QWORD *)(a2 + 736);
  *(_QWORD *)(a2 + 736) = 0;
  v30 = *(_QWORD *)(a1 + 720);
  *(_QWORD *)(a1 + 720) = *(_QWORD *)(a2 + 720);
  *(_QWORD *)(a2 + 720) = v30;
  *(_OWORD *)(a1 + 744) = 0u;
  *(_OWORD *)(a1 + 760) = 0u;
  *(_QWORD *)(a1 + 744) = *(_QWORD *)(a2 + 744);
  *(_QWORD *)(a2 + 744) = 0;
  v31 = *(_QWORD *)(a1 + 760);
  *(_QWORD *)(a1 + 760) = *(_QWORD *)(a2 + 760);
  *(_QWORD *)(a2 + 760) = v31;
  *(_QWORD *)(a1 + 768) = *(_QWORD *)(a2 + 768);
  *(_QWORD *)(a2 + 768) = 0;
  v32 = *(_QWORD *)(a1 + 752);
  *(_QWORD *)(a1 + 752) = *(_QWORD *)(a2 + 752);
  *(_QWORD *)(a2 + 752) = v32;
  *(_OWORD *)(a1 + 776) = 0u;
  *(_OWORD *)(a1 + 792) = 0u;
  *(_QWORD *)(a1 + 776) = *(_QWORD *)(a2 + 776);
  *(_QWORD *)(a2 + 776) = 0;
  v33 = *(_QWORD *)(a1 + 792);
  *(_QWORD *)(a1 + 792) = *(_QWORD *)(a2 + 792);
  *(_QWORD *)(a2 + 792) = v33;
  *(_QWORD *)(a1 + 800) = *(_QWORD *)(a2 + 800);
  *(_QWORD *)(a2 + 800) = 0;
  v34 = *(_QWORD *)(a1 + 784);
  *(_QWORD *)(a1 + 784) = *(_QWORD *)(a2 + 784);
  *(_QWORD *)(a2 + 784) = v34;
  *(_QWORD *)(a1 + 840) = 0;
  *(_DWORD *)(a1 + 832) = 0;
  *(_OWORD *)(a1 + 816) = 0u;
  *(_QWORD *)(a1 + 808) = 0;
  *(_QWORD *)(a1 + 808) = *(_QWORD *)(a2 + 808);
  *(_QWORD *)(a2 + 808) = 0;
  *(_QWORD *)(a1 + 816) = *(_QWORD *)(a2 + 816);
  *(_QWORD *)(a2 + 816) = 0;
  v35 = *(_QWORD *)(a1 + 824);
  *(_QWORD *)(a1 + 824) = *(_QWORD *)(a2 + 824);
  *(_QWORD *)(a2 + 824) = v35;
  v36 = *(_QWORD *)(a1 + 840);
  *(_QWORD *)(a1 + 840) = *(_QWORD *)(a2 + 840);
  *(_QWORD *)(a2 + 840) = v36;
  ++*(_DWORD *)(a2 + 832);
  ++*(_DWORD *)(a1 + 832);
  *(_QWORD *)(a1 + 848) = 0;
  *(_OWORD *)(a1 + 856) = 0u;
  *(_QWORD *)(a1 + 856) = *(_QWORD *)(a2 + 856);
  *(_QWORD *)(a2 + 856) = 0;
  v37 = *(_QWORD *)(a1 + 848);
  *(_QWORD *)(a1 + 848) = 0;
  *(_QWORD *)(a1 + 848) = *(_QWORD *)(a2 + 848);
  *(_QWORD *)(a2 + 848) = v37;
  v38 = *(_QWORD *)(a1 + 864);
  *(_QWORD *)(a1 + 864) = *(_QWORD *)(a2 + 864);
  *(_QWORD *)(a2 + 864) = v38;
  *(_QWORD *)(a1 + 872) = *(_QWORD *)(a2 + 872);
  *(_OWORD *)(a1 + 880) = 0u;
  *(_DWORD *)(a1 + 896) = 1;
  *(_DWORD *)(a1 + 928) = 0;
  *(_OWORD *)(a1 + 912) = 0u;
  *(_QWORD *)(a1 + 904) = 0;
  re::BucketArray<RESubscriptionHandle,8ul>::swap(a1 + 880, a2 + 880);
  *(_QWORD *)(a1 + 936) = *(_QWORD *)(a2 + 936);
  *(_QWORD *)(a1 + 944) = *(_QWORD *)(a2 + 944);
  *(_OWORD *)(a2 + 936) = 0u;
  *(_QWORD *)(a1 + 984) = 0;
  *(_DWORD *)(a1 + 976) = 0;
  *(_QWORD *)(a1 + 968) = 0;
  *(_QWORD *)(a1 + 960) = 0;
  *(_QWORD *)(a1 + 952) = 0;
  *(_QWORD *)(a1 + 952) = *(_QWORD *)(a2 + 952);
  *(_QWORD *)(a2 + 952) = 0;
  *(_QWORD *)(a1 + 960) = *(_QWORD *)(a2 + 960);
  *(_QWORD *)(a2 + 960) = 0;
  v39 = *(_QWORD *)(a1 + 968);
  *(_QWORD *)(a1 + 968) = *(_QWORD *)(a2 + 968);
  *(_QWORD *)(a2 + 968) = v39;
  v40 = *(_QWORD *)(a1 + 984);
  *(_QWORD *)(a1 + 984) = *(_QWORD *)(a2 + 984);
  *(_QWORD *)(a2 + 984) = v40;
  ++*(_DWORD *)(a2 + 976);
  ++*(_DWORD *)(a1 + 976);
  *(_QWORD *)(a1 + 992) = *(_QWORD *)(a2 + 992);
  *(_QWORD *)(a1 + 1000) = 0;
  *(_QWORD *)(a1 + 1016) = 0;
  *(_QWORD *)(a1 + 1008) = 0;
  *(_QWORD *)(a1 + 1000) = *(_QWORD *)(a2 + 1000);
  *(_QWORD *)(a2 + 1000) = 0;
  *(_QWORD *)(a1 + 1008) = *(_QWORD *)(a2 + 1008);
  *(_QWORD *)(a2 + 1008) = 0;
  v41 = *(_QWORD *)(a1 + 1016);
  *(_QWORD *)(a1 + 1016) = *(_QWORD *)(a2 + 1016);
  *(_QWORD *)(a2 + 1016) = v41;
  re::DynamicArray<re::GeomDeformer>::DynamicArray(a1 + 1024, (uint64_t *)(a2 + 1024));
  return a1;
}

double re::SampledAnimationAssetData<re::GenericSRT<float>>::SampledAnimationAssetData(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  double result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  *(_QWORD *)a1 = off_24ED36578;
  v2 = *(_QWORD *)(a2 + 8);
  *(_BYTE *)(a1 + 16) = *(_BYTE *)(a2 + 16);
  *(_QWORD *)(a1 + 8) = v2;
  v3 = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a1 + 24) & 0xFFFFFFFFFFFFFFFELL | v3 & 1;
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24) & 0xFFFFFFFFFFFFFFFELL | v3 & 1;
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 24) = 0;
  *(_QWORD *)(a2 + 32) = &str_110;
  result = 0.0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
  v5 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  v6 = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 64) = 0;
  v8 = *(_QWORD *)(a1 + 48);
  v7 = *(_QWORD *)(a1 + 56);
  *(_QWORD *)(a1 + 48) = v5;
  *(_QWORD *)(a1 + 56) = v6;
  *(_QWORD *)(a2 + 48) = v8;
  *(_QWORD *)(a2 + 56) = v7;
  *(_BYTE *)(a1 + 72) = *(_BYTE *)(a2 + 72);
  *(_QWORD *)a1 = off_24ED33A68;
  v9 = *(_QWORD *)(a2 + 73);
  *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
  *(_QWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 73) = v9;
  *(_QWORD *)(a1 + 120) = 0;
  *(_DWORD *)(a1 + 112) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  v10 = *(_QWORD *)(a2 + 96);
  *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
  *(_QWORD *)(a1 + 96) = v10;
  *(_QWORD *)(a2 + 88) = 0;
  *(_QWORD *)(a2 + 96) = 0;
  v11 = *(_QWORD *)(a1 + 104);
  *(_QWORD *)(a1 + 104) = *(_QWORD *)(a2 + 104);
  *(_QWORD *)(a2 + 104) = v11;
  v12 = *(_QWORD *)(a1 + 120);
  *(_QWORD *)(a1 + 120) = *(_QWORD *)(a2 + 120);
  *(_QWORD *)(a2 + 120) = v12;
  ++*(_DWORD *)(a2 + 112);
  ++*(_DWORD *)(a1 + 112);
  return result;
}

uint64_t re::DynamicArray<re::GeomDeformer>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  unint64_t v5;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  v3 = *a2;
  if (*a2)
  {
    v5 = a2[2];
    *(_QWORD *)a1 = v3;
    re::DynamicArray<re::GeomDeformer>::setCapacity((_QWORD *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::GeomDeformer>::copy((_QWORD *)a1, (uint64_t)a2);
  }
  return a1;
}

re::GeomDeformer *re::DynamicArray<re::GeomDeformer>::copy(_QWORD *a1, uint64_t a2)
{
  unint64_t v4;
  re::GeomDeformer *result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  char v10;

  v4 = *(_QWORD *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<re::GeomDeformer>::setCapacity(a1, *(_QWORD *)(a2 + 16));
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::GeomDeformer *,re::GeomDeformer *,re::GeomDeformer *>((uint64_t)&v10, *(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 32) + 448 * a1[2], a1[4]);
    result = (re::GeomDeformer *)re::ObjectHelper::copyConstruct<re::GeomDeformer>(a1[4] + 448 * a1[2], *(_QWORD *)(a2 + 32) + 448 * a1[2], *(_QWORD *)(a2 + 32) + 448 * v4);
  }
  else
  {
    result = (re::GeomDeformer *)std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::GeomDeformer *,re::GeomDeformer *,re::GeomDeformer *>((uint64_t)&v9, *(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 32) + 448 * v4, a1[4]);
    v6 = a1[2];
    if (v4 != v6)
    {
      result = (re::GeomDeformer *)(a1[4] + 448 * v4);
      v7 = -448 * v4 + 448 * v6;
      do
      {
        re::GeomDeformer::~GeomDeformer(result);
        result = (re::GeomDeformer *)(v8 + 448);
        v7 -= 448;
      }
      while (v7);
    }
  }
  a1[2] = v4;
  return result;
}

_QWORD *re::DynamicArray<re::GeomDeformer>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::GeomDeformer>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x1C0uLL))
        {
          v2 = 448 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 448 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_16;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 448, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = (uint64_t *)v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = 448 * v9;
        v11 = (uint64_t)v7;
        do
        {
          re::GeomDeformer::GeomDeformer(v11, v8);
          re::GeomDeformer::~GeomDeformer((re::GeomDeformer *)v8);
          v8 += 56;
          v11 += 448;
          v10 -= 448;
        }
        while (v10);
        v8 = (uint64_t *)v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t *))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

uint64_t re::GeomDeformer::GeomDeformer(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v4 = *a2;
  *(_QWORD *)a1 = *(_QWORD *)a1 & 0xFFFFFFFFFFFFFFFELL | *a2 & 1;
  *(_QWORD *)a1 = *a2 & 0xFFFFFFFFFFFFFFFELL | v4 & 1;
  *(_QWORD *)(a1 + 8) = a2[1];
  *a2 = 0;
  a2[1] = (uint64_t)&str_110;
  v5 = a2[2];
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a1 + 16) & 0xFFFFFFFFFFFFFFFELL | v5 & 1;
  *(_QWORD *)(a1 + 16) = a2[2] & 0xFFFFFFFFFFFFFFFELL | v5 & 1;
  *(_QWORD *)(a1 + 24) = a2[3];
  a2[2] = 0;
  a2[3] = (uint64_t)&str_110;
  *(_QWORD *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  v6 = a2[5];
  *(_QWORD *)(a1 + 32) = a2[4];
  *(_QWORD *)(a1 + 40) = v6;
  a2[4] = 0;
  a2[5] = 0;
  v7 = *(_QWORD *)(a1 + 48);
  *(_QWORD *)(a1 + 48) = a2[6];
  a2[6] = v7;
  v8 = *(_QWORD *)(a1 + 64);
  *(_QWORD *)(a1 + 64) = a2[8];
  a2[8] = v8;
  ++*((_DWORD *)a2 + 14);
  ++*(_DWORD *)(a1 + 56);
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 96) = 0;
  v9 = a2[10];
  *(_QWORD *)(a1 + 72) = a2[9];
  *(_QWORD *)(a1 + 80) = v9;
  a2[9] = 0;
  a2[10] = 0;
  v10 = *(_QWORD *)(a1 + 88);
  *(_QWORD *)(a1 + 88) = a2[11];
  a2[11] = v10;
  v11 = *(_QWORD *)(a1 + 104);
  *(_QWORD *)(a1 + 104) = a2[13];
  a2[13] = v11;
  ++*((_DWORD *)a2 + 24);
  ++*(_DWORD *)(a1 + 96);
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 128) = 1;
  *(_QWORD *)(a1 + 144) = 0;
  *(_QWORD *)(a1 + 152) = 0;
  *(_QWORD *)(a1 + 136) = 0;
  *(_DWORD *)(a1 + 160) = 0;
  re::BucketArray<re::FixedArray<int>,8ul>::swap(a1 + 112, (uint64_t)(a2 + 14));
  *(_QWORD *)(a1 + 168) = 0;
  *(_QWORD *)(a1 + 176) = 0;
  *(_DWORD *)(a1 + 184) = 1;
  *(_QWORD *)(a1 + 200) = 0;
  *(_QWORD *)(a1 + 208) = 0;
  *(_QWORD *)(a1 + 192) = 0;
  *(_DWORD *)(a1 + 216) = 0;
  re::BucketArray<re::FixedArray<int>,8ul>::swap(a1 + 168, (uint64_t)(a2 + 21));
  *(_QWORD *)(a1 + 224) = 0;
  *(_QWORD *)(a1 + 232) = 0;
  *(_DWORD *)(a1 + 240) = 1;
  *(_QWORD *)(a1 + 256) = 0;
  *(_QWORD *)(a1 + 264) = 0;
  *(_QWORD *)(a1 + 248) = 0;
  *(_DWORD *)(a1 + 272) = 0;
  re::BucketArray<re::FixedArray<int>,8ul>::swap(a1 + 224, (uint64_t)(a2 + 28));
  *(_QWORD *)(a1 + 280) = 0;
  *(_QWORD *)(a1 + 288) = 0;
  *(_DWORD *)(a1 + 296) = 1;
  *(_QWORD *)(a1 + 312) = 0;
  *(_QWORD *)(a1 + 320) = 0;
  *(_QWORD *)(a1 + 304) = 0;
  *(_DWORD *)(a1 + 328) = 0;
  re::BucketArray<re::FixedArray<int>,8ul>::swap(a1 + 280, (uint64_t)(a2 + 35));
  *(_QWORD *)(a1 + 336) = 0;
  *(_QWORD *)(a1 + 344) = 0;
  *(_DWORD *)(a1 + 352) = 1;
  *(_QWORD *)(a1 + 368) = 0;
  *(_QWORD *)(a1 + 376) = 0;
  *(_QWORD *)(a1 + 360) = 0;
  *(_DWORD *)(a1 + 384) = 0;
  re::BucketArray<re::FixedArray<int>,8ul>::swap(a1 + 336, (uint64_t)(a2 + 42));
  *(_QWORD *)(a1 + 392) = 0;
  *(_QWORD *)(a1 + 400) = 0;
  *(_DWORD *)(a1 + 408) = 1;
  *(_QWORD *)(a1 + 424) = 0;
  *(_QWORD *)(a1 + 432) = 0;
  *(_QWORD *)(a1 + 416) = 0;
  *(_DWORD *)(a1 + 440) = 0;
  re::BucketArray<re::FixedArray<int>,8ul>::swap(a1 + 392, (uint64_t)(a2 + 49));
  return a1;
}

uint64_t re::BucketArray<re::FixedArray<int>,8ul>::swap(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;
  _QWORD v6[2];
  char v7;

  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::DynamicOverflowArray((uint64_t)v6, a1);
  re::DynamicOverflowArray<re::FixedArray<int> *,2ul>::operator=(a1, a2);
  re::DynamicOverflowArray<re::FixedArray<int> *,2ul>::operator=(a2, (uint64_t)v6);
  result = v6[0];
  if (v6[0] && (v7 & 1) == 0)
    result = (*(uint64_t (**)(void))(*(_QWORD *)v6[0] + 40))();
  v5 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = v5;
  ++*(_DWORD *)(a1 + 48);
  ++*(_DWORD *)(a2 + 48);
  return result;
}

uint64_t re::DynamicOverflowArray<re::FixedArray<int> *,2ul>::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  if (a1 != a2)
  {
    if (*(_QWORD *)a1)
    {
      if (*(_QWORD *)a2 && *(_QWORD *)a1 != *(_QWORD *)a2)
      {
        re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) ", "!isInitialized() || !other.isInitialized() || m_allocator == other.m_allocator", "operator=", 527);
        result = _os_crash();
        __break(1u);
        return result;
      }
    }
    if ((*(_BYTE *)(a2 + 16) & 1) != 0)
    {
      if (*(_QWORD *)(a2 + 8))
      {
        re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::move(a1, a2);
      }
      else
      {
        re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1);
        *(_QWORD *)a1 = *(_QWORD *)a2;
        *(_DWORD *)(a2 + 16) += 2;
        *(_DWORD *)(a1 + 16) += 2;
      }
    }
    else
    {
      *(_QWORD *)(a1 + 8) = 0;
      *(_DWORD *)(a1 + 16) += 2;
      re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::swap((uint64_t *)a1, (uint64_t *)a2);
    }
  }
  return a1;
}

uint64_t re::ObjectHelper::copyConstruct<re::GeomDeformer>(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;

  if (a2 != a3)
  {
    v5 = result;
    v6 = 0;
    do
    {
      re::StringID::StringID((re::StringID *)(v5 + v6), (const StringID *)(a2 + v6));
      re::StringID::StringID((re::StringID *)(v5 + v6 + 16), (const StringID *)(a2 + v6 + 16));
      re::DynamicArray<re::GeomDeformer::Attribute>::DynamicArray(v5 + v6 + 32, (uint64_t *)(a2 + v6 + 32));
      re::DynamicArray<re::GeomDeformer::Affector>::DynamicArray(v5 + v6 + 72, (uint64_t *)(a2 + v6 + 72));
      re::BucketArray<re::FixedArray<int>,8ul>::BucketArray(v5 + v6 + 112, a2 + v6 + 112);
      re::BucketArray<re::FixedArray<float>,8ul>::BucketArray(v5 + v6 + 168, a2 + v6 + 168);
      re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::BucketArray(v5 + v6 + 224, a2 + v6 + 224);
      re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::BucketArray(v5 + v6 + 280, a2 + v6 + 280);
      re::BucketArray<re::StringID,8ul>::BucketArray(v5 + v6 + 336, a2 + v6 + 336);
      result = re::BucketArray<re::Matrix4x4<float>,8ul>::BucketArray(v5 + v6 + 392, a2 + v6 + 392);
      v6 += 448;
    }
    while (a2 + v6 != a3);
  }
  return result;
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::GeomDeformer *,re::GeomDeformer *,re::GeomDeformer *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t v7;

  if (a2 == a3)
    return a2;
  v6 = a3;
  v7 = 0;
  do
  {
    re::StringID::operator=((unint64_t *)(a4 + v7), (uint64_t *)(a2 + v7));
    re::StringID::operator=((unint64_t *)(a4 + v7 + 16), (uint64_t *)(a2 + v7 + 16));
    re::DynamicArray<re::GeomDeformer::Attribute>::operator=(a4 + v7 + 32, (uint64_t *)(a2 + v7 + 32));
    re::DynamicArray<re::GeomDeformer::Affector>::operator=(a4 + v7 + 72, (uint64_t *)(a2 + v7 + 72));
    re::BucketArray<re::FixedArray<int>,8ul>::operator=(a4 + v7 + 112, a2 + v7 + 112);
    re::BucketArray<re::FixedArray<float>,8ul>::operator=(a4 + v7 + 168, a2 + v7 + 168);
    re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::operator=(a4 + v7 + 224, a2 + v7 + 224);
    re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::operator=(a4 + v7 + 280, a2 + v7 + 280);
    re::BucketArray<re::StringID,8ul>::operator=(a4 + v7 + 336, a2 + v7 + 336);
    re::BucketArray<re::Matrix4x4<float>,8ul>::operator=(a4 + v7 + 392, a2 + v7 + 392);
    v7 += 448;
  }
  while (a2 + v7 != v6);
  return v6;
}

uint64_t re::DynamicArray<re::GeomDeformer::Attribute>::operator=(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  unint64_t v5;

  if ((uint64_t *)a1 != a2)
  {
    v4 = *a2;
    if (*(_QWORD *)a1)
    {
      if (v4)
      {
        re::DynamicArray<re::GeomDeformer::Attribute>::copy((_QWORD *)a1, (uint64_t)a2);
        ++*(_DWORD *)(a1 + 24);
      }
      else
      {
        re::DynamicArray<re::GeomDeformer::Attribute>::clear(a1);
      }
    }
    else if (v4)
    {
      v5 = a2[2];
      *(_QWORD *)a1 = v4;
      re::DynamicArray<re::GeomDeformer::Attribute>::setCapacity((_QWORD *)a1, v5);
      ++*(_DWORD *)(a1 + 24);
      re::DynamicArray<re::GeomDeformer::Attribute>::copy((_QWORD *)a1, (uint64_t)a2);
    }
  }
  return a1;
}

uint64_t re::DynamicArray<re::GeomDeformer::Affector>::operator=(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  unint64_t v5;

  if ((uint64_t *)a1 != a2)
  {
    v4 = *a2;
    if (*(_QWORD *)a1)
    {
      if (v4)
      {
        re::DynamicArray<re::GeomDeformer::Affector>::copy((_QWORD *)a1, (uint64_t)a2);
        ++*(_DWORD *)(a1 + 24);
      }
      else
      {
        re::DynamicArray<re::GeomDeformer::Affector>::clear(a1);
      }
    }
    else if (v4)
    {
      v5 = a2[2];
      *(_QWORD *)a1 = v4;
      re::DynamicArray<re::GeomDeformer::Affector>::setCapacity((_QWORD *)a1, v5);
      ++*(_DWORD *)(a1 + 24);
      re::DynamicArray<re::GeomDeformer::Affector>::copy((_QWORD *)a1, (uint64_t)a2);
    }
  }
  return a1;
}

void re::DynamicArray<re::GeomDeformer::Attribute>::copy(_QWORD *a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  re::StringID *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  re::StringID *v13;
  re::StringID *v14;
  uint64_t v15;

  v4 = *(_QWORD *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<re::GeomDeformer::Attribute>::setCapacity(a1, *(_QWORD *)(a2 + 16));
    std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::GeomDeformer::Attribute *,re::GeomDeformer::Attribute *,re::GeomDeformer::Attribute *,0>(*(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 32) + 40 * a1[2], a1[4]);
    v8 = a1[2];
    if (v8 != v4)
    {
      v9 = *(_QWORD *)(a2 + 32);
      v10 = v9 + 40 * v4;
      v11 = 40 * v8 + 8;
      v12 = v9 + v11;
      v13 = (re::StringID *)(a1[4] + v11);
      do
      {
        *((_QWORD *)v13 - 1) = *(_QWORD *)(v12 - 8);
        v14 = re::StringID::StringID(v13, (const StringID *)v12);
        *((_OWORD *)v14 + 1) = *(_OWORD *)(v12 + 16);
        v15 = v12 + 32;
        v12 += 40;
        v13 = (re::StringID *)((char *)v14 + 40);
      }
      while (v15 != v10);
    }
  }
  else
  {
    std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::GeomDeformer::Attribute *,re::GeomDeformer::Attribute *,re::GeomDeformer::Attribute *,0>(*(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 32) + 40 * v4, a1[4]);
    v5 = a1[2];
    if (v4 != v5)
    {
      v6 = 40 * v5 - 40 * v4;
      v7 = (re::StringID *)(a1[4] + 40 * v4 + 8);
      do
      {
        re::StringID::destroyString(v7);
        v7 = (re::StringID *)((char *)v7 + 40);
        v6 -= 40;
      }
      while (v6);
    }
  }
  a1[2] = v4;
}

void re::DynamicArray<re::GeomDeformer::Attribute>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  re::StringID *v4;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
  {
    v3 = 40 * v2;
    v4 = (re::StringID *)(*(_QWORD *)(a1 + 32) + 8);
    do
    {
      re::StringID::destroyString(v4);
      v4 = (re::StringID *)((char *)v4 + 40);
      v3 -= 40;
    }
    while (v3);
  }
  ++*(_DWORD *)(a1 + 24);
}

_QWORD *re::DynamicArray<re::GeomDeformer::Attribute>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::GeomDeformer::Attribute>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x28uLL))
        {
          v2 = 40 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 40 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_16;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 40, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = (_QWORD *)v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = &v8[5 * v9];
        v11 = v7;
        do
        {
          *v11 = *v8;
          v13 = v8[1];
          v12 = v8 + 1;
          v11[1] = v11[1] & 0xFFFFFFFFFFFFFFFELL | v13 & 1;
          v11[1] = *v12 & 0xFFFFFFFFFFFFFFFELL | v13 & 1;
          v11[2] = v12[1];
          *v12 = 0;
          v12[1] = &str_110;
          *(_OWORD *)(v11 + 3) = *((_OWORD *)v12 + 1);
          re::StringID::destroyString((re::StringID *)v12);
          v8 = v12 + 4;
          v11 += 5;
        }
        while (v8 != v10);
        v8 = (_QWORD *)v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

uint64_t std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::GeomDeformer::Attribute *,re::GeomDeformer::Attribute *,re::GeomDeformer::Attribute *,0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  if (a1 == a2)
    return a1;
  v4 = a2;
  v5 = a1 + 8;
  do
  {
    *(_QWORD *)a3 = *(_QWORD *)(v5 - 8);
    re::StringID::operator=((unint64_t *)(a3 + 8), (uint64_t *)v5);
    *(_OWORD *)(a3 + 24) = *(_OWORD *)(v5 + 16);
    a3 += 40;
    v6 = v5 + 32;
    v5 += 40;
  }
  while (v6 != v4);
  return v4;
}

uint64_t re::DynamicArray<re::GeomDeformer::Affector>::copy(_QWORD *a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;

  v4 = *(_QWORD *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<re::GeomDeformer::Affector>::setCapacity(a1, *(_QWORD *)(a2 + 16));
    result = (uint64_t)std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::GeomDeformer::Affector *,re::GeomDeformer::Affector *,re::GeomDeformer::Affector *,0>(*(uint64_t **)(a2 + 32), (uint64_t *)(*(_QWORD *)(a2 + 32) + 40 * a1[2]), a1[4]);
    v9 = a1[2];
    if (v9 != v4)
    {
      v10 = 5 * v9;
      v11 = (uint64_t *)(*(_QWORD *)(a2 + 32) + 8 * v10);
      result = a1[4] + 8 * v10;
      v12 = 40 * v4 - 8 * v10;
      do
      {
        v13 = re::DynamicArray<re::GeomDeformer::Attribute>::DynamicArray(result, v11);
        v11 += 5;
        result = v13 + 40;
        v12 -= 40;
      }
      while (v12);
    }
  }
  else
  {
    result = (uint64_t)std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::GeomDeformer::Affector *,re::GeomDeformer::Affector *,re::GeomDeformer::Affector *,0>(*(uint64_t **)(a2 + 32), (uint64_t *)(*(_QWORD *)(a2 + 32) + 40 * v4), a1[4]);
    v6 = a1[2];
    if (v4 != v6)
    {
      v7 = a1[4] + 40 * v4;
      v8 = 40 * v6 - 40 * v4;
      do
      {
        result = re::DynamicArray<re::GeomDeformer::Attribute>::deinit(v7);
        v7 += 40;
        v8 -= 40;
      }
      while (v8);
    }
  }
  a1[2] = v4;
  return result;
}

uint64_t re::DynamicArray<re::GeomDeformer::Affector>::clear(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v1 = result;
  v2 = *(_QWORD *)(result + 16);
  *(_QWORD *)(result + 16) = 0;
  if (v2)
  {
    v3 = *(_QWORD *)(result + 32);
    v4 = 40 * v2;
    do
    {
      result = re::DynamicArray<re::GeomDeformer::Attribute>::deinit(v3);
      v3 += 40;
      v4 -= 40;
    }
    while (v4);
  }
  ++*(_DWORD *)(v1 + 24);
  return result;
}

_QWORD *re::DynamicArray<re::GeomDeformer::Affector>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::GeomDeformer::Affector>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x28uLL))
        {
          v2 = 40 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 40 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_16;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 40, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = v8 + 40 * v9;
        v11 = v7 + 4;
        do
        {
          *v11 = 0;
          *(v11 - 3) = 0;
          *(v11 - 2) = 0;
          *(v11 - 4) = 0;
          *((_DWORD *)v11 - 2) = 0;
          v12 = *(_QWORD *)(v8 + 8);
          *(v11 - 4) = *(_QWORD *)v8;
          *(v11 - 3) = v12;
          *(_QWORD *)v8 = 0;
          *(_QWORD *)(v8 + 8) = 0;
          v13 = *(v11 - 2);
          *(v11 - 2) = *(_QWORD *)(v8 + 16);
          *(_QWORD *)(v8 + 16) = v13;
          v14 = *v11;
          *v11 = *(_QWORD *)(v8 + 32);
          *(_QWORD *)(v8 + 32) = v14;
          ++*(_DWORD *)(v8 + 24);
          ++*((_DWORD *)v11 - 2);
          re::DynamicArray<re::GeomDeformer::Attribute>::deinit(v8);
          v11 += 5;
          v8 += 40;
        }
        while (v8 != v10);
        v8 = v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

uint64_t *std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::GeomDeformer::Affector *,re::GeomDeformer::Affector *,re::GeomDeformer::Affector *,0>(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t *v4;

  v4 = a1;
  if (a1 != a2)
  {
    do
    {
      re::DynamicArray<re::GeomDeformer::Attribute>::operator=(a3, v4);
      v4 += 5;
      a3 += 40;
    }
    while (v4 != a2);
    return a2;
  }
  return v4;
}

uint64_t re::DynamicArray<re::GeomDeformer::Attribute>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  unint64_t v5;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  v3 = *a2;
  if (*a2)
  {
    v5 = a2[2];
    *(_QWORD *)a1 = v3;
    re::DynamicArray<re::GeomDeformer::Attribute>::setCapacity((_QWORD *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::GeomDeformer::Attribute>::copy((_QWORD *)a1, (uint64_t)a2);
  }
  return a1;
}

uint64_t re::BucketArray<re::FixedArray<int>,8ul>::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  if (a1 != a2)
  {
    v4 = *(_QWORD *)a2;
    if (*(_QWORD *)a1)
    {
      if (v4)
      {
        re::BucketArray<re::FixedArray<int>,8ul>::copy(a1, a2);
        ++*(_DWORD *)(a1 + 48);
      }
      else
      {
        re::BucketArray<re::FixedArray<int>,8ul>::clear((_QWORD *)a1);
      }
    }
    else if (v4)
    {
      re::BucketArray<re::FixedArray<int>,8ul>::init(a1, v4, *(_QWORD *)(a2 + 8));
      re::BucketArray<re::FixedArray<int>,8ul>::copy(a1, a2);
    }
  }
  return a1;
}

uint64_t re::BucketArray<re::FixedArray<float>,8ul>::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  if (a1 != a2)
  {
    v4 = *(_QWORD *)a2;
    if (*(_QWORD *)a1)
    {
      if (v4)
      {
        re::BucketArray<re::FixedArray<float>,8ul>::copy(a1, a2);
        ++*(_DWORD *)(a1 + 48);
      }
      else
      {
        re::BucketArray<re::FixedArray<int>,8ul>::clear((_QWORD *)a1);
      }
    }
    else if (v4)
    {
      re::BucketArray<re::FixedArray<float>,8ul>::init(a1, v4, *(_QWORD *)(a2 + 8));
      re::BucketArray<re::FixedArray<float>,8ul>::copy(a1, a2);
    }
  }
  return a1;
}

uint64_t re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  if (a1 != a2)
  {
    v4 = *(_QWORD *)a2;
    if (*(_QWORD *)a1)
    {
      if (v4)
      {
        re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::copy(a1, a2);
        ++*(_DWORD *)(a1 + 48);
      }
      else
      {
        re::BucketArray<re::FixedArray<int>,8ul>::clear((_QWORD *)a1);
      }
    }
    else if (v4)
    {
      re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::init(a1, v4, *(_QWORD *)(a2 + 8));
      re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::copy(a1, a2);
    }
  }
  return a1;
}

uint64_t re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  if (a1 != a2)
  {
    v4 = *(_QWORD *)a2;
    if (*(_QWORD *)a1)
    {
      if (v4)
      {
        re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::copy(a1, a2);
        ++*(_DWORD *)(a1 + 48);
      }
      else
      {
        re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::clear(a1);
      }
    }
    else if (v4)
    {
      re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::init(a1, v4, *(_QWORD *)(a2 + 8));
      re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::copy(a1, a2);
    }
  }
  return a1;
}

uint64_t re::BucketArray<re::StringID,8ul>::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  if (a1 != a2)
  {
    v4 = *(_QWORD *)a2;
    if (*(_QWORD *)a1)
    {
      if (v4)
      {
        re::BucketArray<re::StringID,8ul>::copy(a1, a2);
        ++*(_DWORD *)(a1 + 48);
      }
      else
      {
        re::BucketArray<re::StringID,8ul>::clear(a1);
      }
    }
    else if (v4)
    {
      re::BucketArray<re::StringID,8ul>::init(a1, v4, *(_QWORD *)(a2 + 8));
      re::BucketArray<re::StringID,8ul>::copy(a1, a2);
    }
  }
  return a1;
}

unint64_t re::BucketArray<re::Matrix4x4<float>,8ul>::operator=(unint64_t a1, uint64_t a2)
{
  uint64_t v4;

  if (a1 != a2)
  {
    v4 = *(_QWORD *)a2;
    if (*(_QWORD *)a1)
    {
      if (v4)
      {
        re::BucketArray<re::Matrix4x4<float>,8ul>::copy(a1, a2);
        ++*(_DWORD *)(a1 + 48);
      }
      else
      {
        re::BucketArray<re::Matrix4x4<float>,8ul>::clear(a1);
      }
    }
    else if (v4)
    {
      re::BucketArray<re::Matrix4x4<float>,8ul>::init(a1, v4, *(_QWORD *)(a2 + 8));
      re::BucketArray<re::Matrix4x4<float>,8ul>::copy(a1, a2);
    }
  }
  return a1;
}

uint64_t *re::BucketArray<re::FixedArray<int>,8ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t *result;

  *(_QWORD *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((_QWORD *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(_QWORD *)(a1 + 40) = 0;
  result = re::BucketArray<re::FixedArray<int>,8ul>::setBucketsCapacity((uint64_t *)a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

void re::BucketArray<re::FixedArray<int>,8ul>::copy(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  _OWORD v14[5];
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(a2 + 40);
  if (v4 >= *(_QWORD *)(a1 + 40))
  {
    re::BucketArray<re::FixedArray<int>,8ul>::setBucketsCapacity((uint64_t *)a1, (v4 + 7) >> 3);
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::BucketArray<re::FixedArray<int>,8ul>::BucketArrayIterator<re::FixedArray<int>,re::FixedArray<int> const&,re::BucketArray<re::FixedArray<int>,8ul> const&,true>,re::BucketArray<re::FixedArray<int>,8ul>::BucketArrayIterator<re::FixedArray<int>,re::FixedArray<int> const&,re::BucketArray<re::FixedArray<int>,8ul> const&,true>,re::BucketArray<re::FixedArray<int>,8ul>::BucketArrayIterator<re::FixedArray<int>,re::FixedArray<int>&,re::BucketArray<re::FixedArray<int>,8ul>&,true>>(a2, 0, a2, *(_QWORD *)(a1 + 40), a1, 0, (uint64_t *)v14);
    v7 = *(_QWORD *)(a1 + 40);
    v8 = v4 - v7;
    if (v4 != v7)
    {
      v9 = 0;
      do
      {
        v10 = v9 + *(_QWORD *)(a1 + 40);
        if (*(_QWORD *)(a1 + 8) <= v10 >> 3)
        {
          memset(v14, 0, sizeof(v14));
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        v11 = a1 + 24;
        if ((*(_BYTE *)(a1 + 16) & 1) == 0)
          v11 = *(_QWORD *)(a1 + 32);
        v12 = (uint64_t *)(*(_QWORD *)(v11 + 8 * (v10 >> 3)) + 24 * (v10 & 7));
        v13 = re::BucketArray<re::FixedArray<int>,8ul>::operator[](a2, v10);
        re::FixedArray<int>::FixedArray(v12, v13);
        ++v9;
      }
      while (v8 != v9);
    }
  }
  else
  {
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::BucketArray<re::FixedArray<int>,8ul>::BucketArrayIterator<re::FixedArray<int>,re::FixedArray<int> const&,re::BucketArray<re::FixedArray<int>,8ul> const&,true>,re::BucketArray<re::FixedArray<int>,8ul>::BucketArrayIterator<re::FixedArray<int>,re::FixedArray<int> const&,re::BucketArray<re::FixedArray<int>,8ul> const&,true>,re::BucketArray<re::FixedArray<int>,8ul>::BucketArrayIterator<re::FixedArray<int>,re::FixedArray<int>&,re::BucketArray<re::FixedArray<int>,8ul>&,true>>(a2, 0, a2, *(_QWORD *)(a2 + 40), a1, 0, (uint64_t *)v14);
    if (v4 != *(_QWORD *)(a1 + 40))
    {
      v5 = v4;
      do
      {
        v6 = (_QWORD *)re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::operator[](a1, v5);
        if (*v6)
        {
          if (v6[1])
          {
            (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*v6 + 40))(*v6, v6[2]);
            v6[1] = 0;
            v6[2] = 0;
          }
          *v6 = 0;
        }
        ++v5;
      }
      while (v5 != *(_QWORD *)(a1 + 40));
    }
  }
  *(_QWORD *)(a1 + 40) = v4;
}

_QWORD *re::BucketArray<re::FixedArray<int>,8ul>::clear(_QWORD *result)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t i;
  uint64_t v4;

  v1 = (uint64_t)result;
  v2 = result[5];
  if (v2)
  {
    for (i = 0; i != v2; ++i)
    {
      v4 = re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::operator[](v1, i);
      result = *(_QWORD **)v4;
      if (*(_QWORD *)v4)
      {
        if (*(_QWORD *)(v4 + 8))
        {
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, _QWORD))(*result + 40))(result, *(_QWORD *)(v4 + 16));
          *(_QWORD *)(v4 + 8) = 0;
          *(_QWORD *)(v4 + 16) = 0;
        }
        *(_QWORD *)v4 = 0;
      }
    }
  }
  *(_QWORD *)(v1 + 40) = 0;
  ++*(_DWORD *)(v1 + 48);
  return result;
}

uint64_t *re::BucketArray<re::FixedArray<int>,8ul>::setBucketsCapacity(uint64_t *result, unint64_t a2)
{
  uint64_t *v3;
  unint64_t v4;
  uint64_t v5;

  v3 = result;
  if (*result)
  {
    if (result[5] < 8 * a2)
    {
      while (1)
      {
        v4 = v3[1];
        if (v4 <= a2)
          break;
        result = (uint64_t *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      while (v4 < a2)
      {
        v5 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)*v3 + 32))(*v3, 192, 0);
        result = (uint64_t *)re::DynamicOverflowArray<RESubscriptionHandle *,2ul>::add((uint64_t)v3, &v5);
        v4 = v3[1];
      }
    }
  }
  else
  {
  }
  return result;
}

uint64_t re::BucketArray<re::FixedArray<int>,8ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1018, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(_QWORD *)(a1 + 8) <= a2 >> 3)
    goto LABEL_8;
  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
    v3 = a1 + 24;
  else
    v3 = *(_QWORD *)(a1 + 32);
  return *(_QWORD *)(v3 + 8 * (a2 >> 3)) + 24 * (a2 & 7);
}

void std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::BucketArray<re::FixedArray<int>,8ul>::BucketArrayIterator<re::FixedArray<int>,re::FixedArray<int> const&,re::BucketArray<re::FixedArray<int>,8ul> const&,true>,re::BucketArray<re::FixedArray<int>,8ul>::BucketArrayIterator<re::FixedArray<int>,re::FixedArray<int> const&,re::BucketArray<re::FixedArray<int>,8ul> const&,true>,re::BucketArray<re::FixedArray<int>,8ul>::BucketArrayIterator<re::FixedArray<int>,re::FixedArray<int>&,re::BucketArray<re::FixedArray<int>,8ul>&,true>>(uint64_t a1@<X1>, unint64_t a2@<X2>, uint64_t a3@<X3>, unint64_t a4@<X4>, uint64_t a5@<X5>, unint64_t a6@<X6>, uint64_t *a7@<X8>)
{
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t *v16;

  if (a1 != a3 || a2 != a4)
  {
    v13 = a4 - 1;
    do
    {
      do
      {
        v14 = a2;
        v15 = re::BucketArray<re::FixedArray<int>,8ul>::operator[](a1, a2);
        v16 = (uint64_t *)re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::operator[](a5, a6);
        re::FixedArray<int>::operator=(v16, v15);
        a2 = v14 + 1;
        ++a6;
      }
      while (a1 != a3);
    }
    while (v13 != v14);
    a2 = a4;
  }
  *a7 = a1;
  a7[1] = a2;
  a7[2] = a5;
  a7[3] = a6;
}

uint64_t *re::BucketArray<re::FixedArray<float>,8ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t *result;

  *(_QWORD *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((_QWORD *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(_QWORD *)(a1 + 40) = 0;
  result = re::BucketArray<re::FixedArray<float>,8ul>::setBucketsCapacity((uint64_t *)a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

void re::BucketArray<re::FixedArray<float>,8ul>::copy(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  _OWORD v14[5];
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(a2 + 40);
  if (v4 >= *(_QWORD *)(a1 + 40))
  {
    re::BucketArray<re::FixedArray<float>,8ul>::setBucketsCapacity((uint64_t *)a1, (v4 + 7) >> 3);
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::BucketArray<re::FixedArray<float>,8ul>::BucketArrayIterator<re::FixedArray<float>,re::FixedArray<float> const&,re::BucketArray<re::FixedArray<float>,8ul> const&,true>,re::BucketArray<re::FixedArray<float>,8ul>::BucketArrayIterator<re::FixedArray<float>,re::FixedArray<float> const&,re::BucketArray<re::FixedArray<float>,8ul> const&,true>,re::BucketArray<re::FixedArray<float>,8ul>::BucketArrayIterator<re::FixedArray<float>,re::FixedArray<float>&,re::BucketArray<re::FixedArray<float>,8ul>&,true>>(a2, 0, a2, *(_QWORD *)(a1 + 40), a1, 0, (uint64_t *)v14);
    v7 = *(_QWORD *)(a1 + 40);
    v8 = v4 - v7;
    if (v4 != v7)
    {
      v9 = 0;
      do
      {
        v10 = v9 + *(_QWORD *)(a1 + 40);
        if (*(_QWORD *)(a1 + 8) <= v10 >> 3)
        {
          memset(v14, 0, sizeof(v14));
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        v11 = a1 + 24;
        if ((*(_BYTE *)(a1 + 16) & 1) == 0)
          v11 = *(_QWORD *)(a1 + 32);
        v12 = (uint64_t *)(*(_QWORD *)(v11 + 8 * (v10 >> 3)) + 24 * (v10 & 7));
        v13 = re::BucketArray<re::FixedArray<int>,8ul>::operator[](a2, v10);
        re::FixedArray<float>::FixedArray(v12, v13);
        ++v9;
      }
      while (v8 != v9);
    }
  }
  else
  {
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::BucketArray<re::FixedArray<float>,8ul>::BucketArrayIterator<re::FixedArray<float>,re::FixedArray<float> const&,re::BucketArray<re::FixedArray<float>,8ul> const&,true>,re::BucketArray<re::FixedArray<float>,8ul>::BucketArrayIterator<re::FixedArray<float>,re::FixedArray<float> const&,re::BucketArray<re::FixedArray<float>,8ul> const&,true>,re::BucketArray<re::FixedArray<float>,8ul>::BucketArrayIterator<re::FixedArray<float>,re::FixedArray<float>&,re::BucketArray<re::FixedArray<float>,8ul>&,true>>(a2, 0, a2, *(_QWORD *)(a2 + 40), a1, 0, (uint64_t *)v14);
    if (v4 != *(_QWORD *)(a1 + 40))
    {
      v5 = v4;
      do
      {
        v6 = (_QWORD *)re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::operator[](a1, v5);
        if (*v6)
        {
          if (v6[1])
          {
            (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*v6 + 40))(*v6, v6[2]);
            v6[1] = 0;
            v6[2] = 0;
          }
          *v6 = 0;
        }
        ++v5;
      }
      while (v5 != *(_QWORD *)(a1 + 40));
    }
  }
  *(_QWORD *)(a1 + 40) = v4;
}

uint64_t *re::BucketArray<re::FixedArray<float>,8ul>::setBucketsCapacity(uint64_t *result, unint64_t a2)
{
  uint64_t *v3;
  unint64_t v4;
  uint64_t v5;

  v3 = result;
  if (*result)
  {
    if (result[5] < 8 * a2)
    {
      while (1)
      {
        v4 = v3[1];
        if (v4 <= a2)
          break;
        result = (uint64_t *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      while (v4 < a2)
      {
        v5 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)*v3 + 32))(*v3, 192, 0);
        result = (uint64_t *)re::DynamicOverflowArray<RESubscriptionHandle *,2ul>::add((uint64_t)v3, &v5);
        v4 = v3[1];
      }
    }
  }
  else
  {
  }
  return result;
}

void std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::BucketArray<re::FixedArray<float>,8ul>::BucketArrayIterator<re::FixedArray<float>,re::FixedArray<float> const&,re::BucketArray<re::FixedArray<float>,8ul> const&,true>,re::BucketArray<re::FixedArray<float>,8ul>::BucketArrayIterator<re::FixedArray<float>,re::FixedArray<float> const&,re::BucketArray<re::FixedArray<float>,8ul> const&,true>,re::BucketArray<re::FixedArray<float>,8ul>::BucketArrayIterator<re::FixedArray<float>,re::FixedArray<float>&,re::BucketArray<re::FixedArray<float>,8ul>&,true>>(uint64_t a1@<X1>, unint64_t a2@<X2>, uint64_t a3@<X3>, unint64_t a4@<X4>, uint64_t a5@<X5>, unint64_t a6@<X6>, uint64_t *a7@<X8>)
{
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t *v16;

  if (a1 != a3 || a2 != a4)
  {
    v13 = a4 - 1;
    do
    {
      do
      {
        v14 = a2;
        v15 = re::BucketArray<re::FixedArray<int>,8ul>::operator[](a1, a2);
        v16 = (uint64_t *)re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::operator[](a5, a6);
        re::FixedArray<float>::operator=(v16, v15);
        a2 = v14 + 1;
        ++a6;
      }
      while (a1 != a3);
    }
    while (v13 != v14);
    a2 = a4;
  }
  *a7 = a1;
  a7[1] = a2;
  a7[2] = a5;
  a7[3] = a6;
}

uint64_t *re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t *result;

  *(_QWORD *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((_QWORD *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(_QWORD *)(a1 + 40) = 0;
  result = re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::setBucketsCapacity((uint64_t *)a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

void re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::copy(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  _OWORD v14[5];
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(a2 + 40);
  if (v4 >= *(_QWORD *)(a1 + 40))
  {
    re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::setBucketsCapacity((uint64_t *)a1, (v4 + 7) >> 3);
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::BucketArrayIterator<re::FixedArray<re::PackedFloat3>,re::FixedArray<re::PackedFloat3> const&,re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul> const&,true>,re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::BucketArrayIterator<re::FixedArray<re::PackedFloat3>,re::FixedArray<re::PackedFloat3> const&,re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul> const&,true>,re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::BucketArrayIterator<re::FixedArray<re::PackedFloat3>,re::FixedArray<re::PackedFloat3>&,re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>&,true>>(a2, 0, a2, *(_QWORD *)(a1 + 40), a1, 0, (uint64_t *)v14);
    v7 = *(_QWORD *)(a1 + 40);
    v8 = v4 - v7;
    if (v4 != v7)
    {
      v9 = 0;
      do
      {
        v10 = v9 + *(_QWORD *)(a1 + 40);
        if (*(_QWORD *)(a1 + 8) <= v10 >> 3)
        {
          memset(v14, 0, sizeof(v14));
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        v11 = a1 + 24;
        if ((*(_BYTE *)(a1 + 16) & 1) == 0)
          v11 = *(_QWORD *)(a1 + 32);
        v12 = (uint64_t *)(*(_QWORD *)(v11 + 8 * (v10 >> 3)) + 24 * (v10 & 7));
        v13 = re::BucketArray<re::FixedArray<int>,8ul>::operator[](a2, v10);
        re::FixedArray<re::PackedFloat3>::FixedArray(v12, v13);
        ++v9;
      }
      while (v8 != v9);
    }
  }
  else
  {
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::BucketArrayIterator<re::FixedArray<re::PackedFloat3>,re::FixedArray<re::PackedFloat3> const&,re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul> const&,true>,re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::BucketArrayIterator<re::FixedArray<re::PackedFloat3>,re::FixedArray<re::PackedFloat3> const&,re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul> const&,true>,re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::BucketArrayIterator<re::FixedArray<re::PackedFloat3>,re::FixedArray<re::PackedFloat3>&,re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>&,true>>(a2, 0, a2, *(_QWORD *)(a2 + 40), a1, 0, (uint64_t *)v14);
    if (v4 != *(_QWORD *)(a1 + 40))
    {
      v5 = v4;
      do
      {
        v6 = (_QWORD *)re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::operator[](a1, v5);
        if (*v6)
        {
          if (v6[1])
          {
            (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*v6 + 40))(*v6, v6[2]);
            v6[1] = 0;
            v6[2] = 0;
          }
          *v6 = 0;
        }
        ++v5;
      }
      while (v5 != *(_QWORD *)(a1 + 40));
    }
  }
  *(_QWORD *)(a1 + 40) = v4;
}

uint64_t *re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::setBucketsCapacity(uint64_t *result, unint64_t a2)
{
  uint64_t *v3;
  unint64_t v4;
  uint64_t v5;

  v3 = result;
  if (*result)
  {
    if (result[5] < 8 * a2)
    {
      while (1)
      {
        v4 = v3[1];
        if (v4 <= a2)
          break;
        result = (uint64_t *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      while (v4 < a2)
      {
        v5 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)*v3 + 32))(*v3, 192, 0);
        result = (uint64_t *)re::DynamicOverflowArray<RESubscriptionHandle *,2ul>::add((uint64_t)v3, &v5);
        v4 = v3[1];
      }
    }
  }
  else
  {
  }
  return result;
}

void std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::BucketArrayIterator<re::FixedArray<re::PackedFloat3>,re::FixedArray<re::PackedFloat3> const&,re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul> const&,true>,re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::BucketArrayIterator<re::FixedArray<re::PackedFloat3>,re::FixedArray<re::PackedFloat3> const&,re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul> const&,true>,re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::BucketArrayIterator<re::FixedArray<re::PackedFloat3>,re::FixedArray<re::PackedFloat3>&,re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>&,true>>(uint64_t a1@<X1>, unint64_t a2@<X2>, uint64_t a3@<X3>, unint64_t a4@<X4>, uint64_t a5@<X5>, unint64_t a6@<X6>, uint64_t *a7@<X8>)
{
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t *v16;

  if (a1 != a3 || a2 != a4)
  {
    v13 = a4 - 1;
    do
    {
      do
      {
        v14 = a2;
        v15 = re::BucketArray<re::FixedArray<int>,8ul>::operator[](a1, a2);
        v16 = (uint64_t *)re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::operator[](a5, a6);
        re::FixedArray<re::PackedFloat3>::operator=(v16, v15);
        a2 = v14 + 1;
        ++a6;
      }
      while (a1 != a3);
    }
    while (v13 != v14);
    a2 = a4;
  }
  *a7 = a1;
  a7[1] = a2;
  a7[2] = a5;
  a7[3] = a6;
}

uint64_t *re::FixedArray<re::PackedFloat3>::operator=(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;

  if (a1 != (uint64_t *)a2)
  {
    v4 = *(_QWORD *)a2;
    if (*a1)
    {
      if (!v4)
        return a1;
      goto LABEL_7;
    }
    if (v4)
    {
      re::FixedArray<re::MeshLodLevelInfo>::init<>(a1, v4, *(_QWORD *)(a2 + 8));
LABEL_7:
      re::FixedArray<re::PackedFloat3>::copy(a1, a2);
    }
  }
  return a1;
}

void *re::FixedArray<re::PackedFloat3>::copy(void *result, uint64_t a2)
{
  uint64_t v2;

  v2 = *((_QWORD *)result + 1);
  if (v2 == *(_QWORD *)(a2 + 8))
  {
    if (v2)
      return memmove(*((void **)result + 2), *(const void **)(a2 + 16), 12 * v2);
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Cannot copy from a FixedArray of a different size", "m_size == other.m_size", "copy", 388);
    result = (void *)_os_crash();
    __break(1u);
  }
  return result;
}

uint64_t *re::FixedArray<re::PackedFloat3>::FixedArray(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v4 = *(_QWORD *)a2;
  if (v4)
  {
    re::FixedArray<re::MeshLodLevelInfo>::init<>(a1, v4, *(_QWORD *)(a2 + 8));
    re::FixedArray<re::PackedFloat3>::copy(a1, a2);
  }
  return a1;
}

uint64_t *re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t *result;

  *(_QWORD *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((_QWORD *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(_QWORD *)(a1 + 40) = 0;
  result = re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::setBucketsCapacity((uint64_t *)a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

void re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::copy(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const StringID *v13;
  _OWORD v14[5];
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(a2 + 40);
  if (v4 >= *(_QWORD *)(a1 + 40))
  {
    re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::setBucketsCapacity((uint64_t *)a1, (v4 + 7) >> 3);
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::BucketArrayIterator<re::GeomDeformer::MeshTarget,re::GeomDeformer::MeshTarget const&,re::BucketArray<re::GeomDeformer::MeshTarget,8ul> const&,true>,re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::BucketArrayIterator<re::GeomDeformer::MeshTarget,re::GeomDeformer::MeshTarget const&,re::BucketArray<re::GeomDeformer::MeshTarget,8ul> const&,true>,re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::BucketArrayIterator<re::GeomDeformer::MeshTarget,re::GeomDeformer::MeshTarget&,re::BucketArray<re::GeomDeformer::MeshTarget,8ul>&,true>>(a2, 0, a2, *(_QWORD *)(a1 + 40), a1, 0, (uint64_t *)v14);
    v7 = *(_QWORD *)(a1 + 40);
    v8 = v4 - v7;
    if (v4 != v7)
    {
      v9 = 0;
      do
      {
        v10 = v9 + *(_QWORD *)(a1 + 40);
        if (*(_QWORD *)(a1 + 8) <= v10 >> 3)
        {
          memset(v14, 0, sizeof(v14));
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        v11 = a1 + 24;
        if ((*(_BYTE *)(a1 + 16) & 1) == 0)
          v11 = *(_QWORD *)(a1 + 32);
        v12 = *(_QWORD *)(v11 + 8 * (v10 >> 3)) + 32 * (v10 & 7);
        v13 = (const StringID *)re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::operator[](a2, v10);
        re::StringID::StringID((re::StringID *)v12, v13);
        re::StringID::StringID((re::StringID *)(v12 + 16), v13 + 1);
        ++v9;
      }
      while (v8 != v9);
    }
  }
  else
  {
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::BucketArrayIterator<re::GeomDeformer::MeshTarget,re::GeomDeformer::MeshTarget const&,re::BucketArray<re::GeomDeformer::MeshTarget,8ul> const&,true>,re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::BucketArrayIterator<re::GeomDeformer::MeshTarget,re::GeomDeformer::MeshTarget const&,re::BucketArray<re::GeomDeformer::MeshTarget,8ul> const&,true>,re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::BucketArrayIterator<re::GeomDeformer::MeshTarget,re::GeomDeformer::MeshTarget&,re::BucketArray<re::GeomDeformer::MeshTarget,8ul>&,true>>(a2, 0, a2, *(_QWORD *)(a2 + 40), a1, 0, (uint64_t *)v14);
    if (v4 != *(_QWORD *)(a1 + 40))
    {
      v5 = v4;
      do
      {
        v6 = re::BucketArray<re::RigDataTypeStructBuilder::RigDataTypeStructMember,8ul>::operator[](a1, v5);
        re::StringID::destroyString((re::StringID *)(v6 + 16));
        re::StringID::destroyString((re::StringID *)v6);
        ++v5;
      }
      while (v5 != *(_QWORD *)(a1 + 40));
    }
  }
  *(_QWORD *)(a1 + 40) = v4;
}

void re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::clear(uint64_t a1)
{
  uint64_t v2;
  unint64_t i;
  uint64_t v4;

  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    for (i = 0; i != v2; ++i)
    {
      v4 = re::BucketArray<re::RigDataTypeStructBuilder::RigDataTypeStructMember,8ul>::operator[](a1, i);
      re::StringID::destroyString((re::StringID *)(v4 + 16));
      re::StringID::destroyString((re::StringID *)v4);
    }
  }
  *(_QWORD *)(a1 + 40) = 0;
  ++*(_DWORD *)(a1 + 48);
}

uint64_t *re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::setBucketsCapacity(uint64_t *result, unint64_t a2)
{
  uint64_t *v3;
  unint64_t v4;
  uint64_t v5;

  v3 = result;
  if (*result)
  {
    if (result[5] < 8 * a2)
    {
      while (1)
      {
        v4 = v3[1];
        if (v4 <= a2)
          break;
        result = (uint64_t *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      while (v4 < a2)
      {
        v5 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)*v3 + 32))(*v3, 256, 0);
        result = (uint64_t *)re::DynamicOverflowArray<RESubscriptionHandle *,2ul>::add((uint64_t)v3, &v5);
        v4 = v3[1];
      }
    }
  }
  else
  {
  }
  return result;
}

uint64_t re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1018, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(_QWORD *)(a1 + 8) <= a2 >> 3)
    goto LABEL_8;
  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
    v3 = a1 + 24;
  else
    v3 = *(_QWORD *)(a1 + 32);
  return *(_QWORD *)(v3 + 8 * (a2 >> 3)) + 32 * (a2 & 7);
}

void std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::BucketArrayIterator<re::GeomDeformer::MeshTarget,re::GeomDeformer::MeshTarget const&,re::BucketArray<re::GeomDeformer::MeshTarget,8ul> const&,true>,re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::BucketArrayIterator<re::GeomDeformer::MeshTarget,re::GeomDeformer::MeshTarget const&,re::BucketArray<re::GeomDeformer::MeshTarget,8ul> const&,true>,re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::BucketArrayIterator<re::GeomDeformer::MeshTarget,re::GeomDeformer::MeshTarget&,re::BucketArray<re::GeomDeformer::MeshTarget,8ul>&,true>>(uint64_t a1@<X1>, unint64_t a2@<X2>, uint64_t a3@<X3>, unint64_t a4@<X4>, uint64_t a5@<X5>, unint64_t a6@<X6>, uint64_t *a7@<X8>)
{
  unint64_t v13;
  unint64_t v14;
  uint64_t *v15;
  unint64_t *v16;
  unint64_t *v17;

  if (a1 != a3 || a2 != a4)
  {
    v13 = a4 - 1;
    do
    {
      do
      {
        v14 = a2;
        v15 = (uint64_t *)re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::operator[](a1, a2);
        v16 = (unint64_t *)re::BucketArray<re::RigDataTypeStructBuilder::RigDataTypeStructMember,8ul>::operator[](a5, a6);
        v17 = re::StringID::operator=(v16, v15);
        re::StringID::operator=(v17 + 2, v15 + 2);
        a2 = v14 + 1;
        ++a6;
      }
      while (a1 != a3);
    }
    while (v13 != v14);
    a2 = a4;
  }
  *a7 = a1;
  a7[1] = a2;
  a7[2] = a5;
  a7[3] = a6;
}

uint64_t *re::BucketArray<re::StringID,8ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t *result;

  *(_QWORD *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((_QWORD *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(_QWORD *)(a1 + 40) = 0;
  result = re::BucketArray<re::StringID,8ul>::setBucketsCapacity((uint64_t *)a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

void re::BucketArray<re::StringID,8ul>::copy(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  re::StringID *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  re::StringID *v12;
  const StringID *v13;
  _OWORD v14[5];
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(a2 + 40);
  if (v4 >= *(_QWORD *)(a1 + 40))
  {
    re::BucketArray<re::StringID,8ul>::setBucketsCapacity((uint64_t *)a1, (v4 + 7) >> 3);
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::BucketArray<re::StringID,8ul>::BucketArrayIterator<re::StringID,re::StringID const&,re::BucketArray<re::StringID,8ul> const&,true>,re::BucketArray<re::StringID,8ul>::BucketArrayIterator<re::StringID,re::StringID const&,re::BucketArray<re::StringID,8ul> const&,true>,re::BucketArray<re::StringID,8ul>::BucketArrayIterator<re::StringID,re::StringID&,re::BucketArray<re::StringID,8ul>&,true>>(a2, 0, a2, *(_QWORD *)(a1 + 40), a1, 0, (uint64_t *)v14);
    v7 = *(_QWORD *)(a1 + 40);
    v8 = v4 - v7;
    if (v4 != v7)
    {
      v9 = 0;
      do
      {
        v10 = v9 + *(_QWORD *)(a1 + 40);
        if (*(_QWORD *)(a1 + 8) <= v10 >> 3)
        {
          memset(v14, 0, sizeof(v14));
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        v11 = a1 + 24;
        if ((*(_BYTE *)(a1 + 16) & 1) == 0)
          v11 = *(_QWORD *)(a1 + 32);
        v12 = (re::StringID *)(*(_QWORD *)(v11 + 8 * (v10 >> 3)) + 16 * (v10 & 7));
        v13 = (const StringID *)re::BucketArray<re::StringID,8ul>::operator[](a2, v10);
        re::StringID::StringID(v12, v13);
        ++v9;
      }
      while (v8 != v9);
    }
  }
  else
  {
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::BucketArray<re::StringID,8ul>::BucketArrayIterator<re::StringID,re::StringID const&,re::BucketArray<re::StringID,8ul> const&,true>,re::BucketArray<re::StringID,8ul>::BucketArrayIterator<re::StringID,re::StringID const&,re::BucketArray<re::StringID,8ul> const&,true>,re::BucketArray<re::StringID,8ul>::BucketArrayIterator<re::StringID,re::StringID&,re::BucketArray<re::StringID,8ul>&,true>>(a2, 0, a2, *(_QWORD *)(a2 + 40), a1, 0, (uint64_t *)v14);
    if (v4 != *(_QWORD *)(a1 + 40))
    {
      v5 = v4;
      do
      {
        v6 = (re::StringID *)re::BucketArray<RESubscriptionHandle,8ul>::operator[](a1, v5);
        re::StringID::destroyString(v6);
        ++v5;
      }
      while (v5 != *(_QWORD *)(a1 + 40));
    }
  }
  *(_QWORD *)(a1 + 40) = v4;
}

void re::BucketArray<re::StringID,8ul>::clear(uint64_t a1)
{
  uint64_t v2;
  unint64_t i;
  re::StringID *v4;

  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    for (i = 0; i != v2; ++i)
    {
      v4 = (re::StringID *)re::BucketArray<RESubscriptionHandle,8ul>::operator[](a1, i);
      re::StringID::destroyString(v4);
    }
  }
  *(_QWORD *)(a1 + 40) = 0;
  ++*(_DWORD *)(a1 + 48);
}

uint64_t *re::BucketArray<re::StringID,8ul>::setBucketsCapacity(uint64_t *result, unint64_t a2)
{
  uint64_t *v3;
  unint64_t v4;
  uint64_t v5;

  v3 = result;
  if (*result)
  {
    if (result[5] < 8 * a2)
    {
      while (1)
      {
        v4 = v3[1];
        if (v4 <= a2)
          break;
        result = (uint64_t *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      while (v4 < a2)
      {
        v5 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)*v3 + 32))(*v3, 128, 0);
        result = (uint64_t *)re::DynamicOverflowArray<RESubscriptionHandle *,2ul>::add((uint64_t)v3, &v5);
        v4 = v3[1];
      }
    }
  }
  else
  {
  }
  return result;
}

uint64_t re::BucketArray<re::StringID,8ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1018, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(_QWORD *)(a1 + 8) <= a2 >> 3)
    goto LABEL_8;
  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
    v3 = a1 + 24;
  else
    v3 = *(_QWORD *)(a1 + 32);
  return *(_QWORD *)(v3 + 8 * (a2 >> 3)) + 16 * (a2 & 7);
}

void std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::BucketArray<re::StringID,8ul>::BucketArrayIterator<re::StringID,re::StringID const&,re::BucketArray<re::StringID,8ul> const&,true>,re::BucketArray<re::StringID,8ul>::BucketArrayIterator<re::StringID,re::StringID const&,re::BucketArray<re::StringID,8ul> const&,true>,re::BucketArray<re::StringID,8ul>::BucketArrayIterator<re::StringID,re::StringID&,re::BucketArray<re::StringID,8ul>&,true>>(uint64_t a1@<X1>, unint64_t a2@<X2>, uint64_t a3@<X3>, unint64_t a4@<X4>, uint64_t a5@<X5>, unint64_t a6@<X6>, uint64_t *a7@<X8>)
{
  unint64_t v13;
  unint64_t v14;
  uint64_t *v15;
  unint64_t *v16;

  if (a1 != a3 || a2 != a4)
  {
    v13 = a4 - 1;
    do
    {
      do
      {
        v14 = a2;
        v15 = (uint64_t *)re::BucketArray<re::StringID,8ul>::operator[](a1, a2);
        v16 = (unint64_t *)re::BucketArray<RESubscriptionHandle,8ul>::operator[](a5, a6);
        re::StringID::operator=(v16, v15);
        a2 = v14 + 1;
        ++a6;
      }
      while (a1 != a3);
    }
    while (v13 != v14);
    a2 = a4;
  }
  *a7 = a1;
  a7[1] = a2;
  a7[2] = a5;
  a7[3] = a6;
}

uint64_t *re::BucketArray<re::Matrix4x4<float>,8ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t *result;

  *(_QWORD *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((_QWORD *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(_QWORD *)(a1 + 40) = 0;
  result = re::BucketArray<re::Matrix4x4<float>,8ul>::setBucketsCapacity((uint64_t *)a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

void re::BucketArray<re::Matrix4x4<float>,8ul>::copy(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  _OWORD *v11;
  __int128 *v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  _OWORD v16[5];
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(a2 + 40);
  if (v4 >= *(_QWORD *)(a1 + 40))
  {
    re::BucketArray<re::Matrix4x4<float>,8ul>::setBucketsCapacity((uint64_t *)a1, (v4 + 7) >> 3);
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::BucketArray<re::Matrix4x4<float>,8ul>::BucketArrayIterator<re::Matrix4x4<float>,re::Matrix4x4<float> const&,re::BucketArray<re::Matrix4x4<float>,8ul> const&,true>,re::BucketArray<re::Matrix4x4<float>,8ul>::BucketArrayIterator<re::Matrix4x4<float>,re::Matrix4x4<float> const&,re::BucketArray<re::Matrix4x4<float>,8ul> const&,true>,re::BucketArray<re::Matrix4x4<float>,8ul>::BucketArrayIterator<re::Matrix4x4<float>,re::Matrix4x4<float>&,re::BucketArray<re::Matrix4x4<float>,8ul>&,true>>(a2, 0, a2, *(_QWORD *)(a1 + 40), a1, 0, (uint64_t *)v16);
    v6 = *(_QWORD *)(a1 + 40);
    v7 = v4 - v6;
    if (v4 != v6)
    {
      v8 = 0;
      do
      {
        v9 = v8 + *(_QWORD *)(a1 + 40);
        if (*(_QWORD *)(a1 + 8) <= v9 >> 3)
        {
          memset(v16, 0, sizeof(v16));
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        v10 = a1 + 24;
        if ((*(_BYTE *)(a1 + 16) & 1) == 0)
          v10 = *(_QWORD *)(a1 + 32);
        v11 = (_OWORD *)(*(_QWORD *)(v10 + 8 * (v9 >> 3)) + ((v9 & 7) << 6));
        v12 = (__int128 *)re::BucketArray<re::Matrix4x4<float>,8ul>::operator[](a2, v9);
        v13 = v12[3];
        v15 = *v12;
        v14 = v12[1];
        v11[2] = v12[2];
        v11[3] = v13;
        *v11 = v15;
        v11[1] = v14;
        ++v8;
      }
      while (v7 != v8);
    }
  }
  else
  {
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::BucketArray<re::Matrix4x4<float>,8ul>::BucketArrayIterator<re::Matrix4x4<float>,re::Matrix4x4<float> const&,re::BucketArray<re::Matrix4x4<float>,8ul> const&,true>,re::BucketArray<re::Matrix4x4<float>,8ul>::BucketArrayIterator<re::Matrix4x4<float>,re::Matrix4x4<float> const&,re::BucketArray<re::Matrix4x4<float>,8ul> const&,true>,re::BucketArray<re::Matrix4x4<float>,8ul>::BucketArrayIterator<re::Matrix4x4<float>,re::Matrix4x4<float>&,re::BucketArray<re::Matrix4x4<float>,8ul>&,true>>(a2, 0, a2, *(_QWORD *)(a2 + 40), a1, 0, (uint64_t *)v16);
    if (v4 != *(_QWORD *)(a1 + 40))
    {
      v5 = v4;
      do
        re::BucketArray<re::Matrix4x4<float>,8ul>::operator[](a1, v5++);
      while (v5 != *(_QWORD *)(a1 + 40));
    }
  }
  *(_QWORD *)(a1 + 40) = v4;
}

unint64_t re::BucketArray<re::Matrix4x4<float>,8ul>::clear(unint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t i;

  v1 = result;
  v2 = *(_QWORD *)(result + 40);
  if (v2)
  {
    for (i = 0; i != v2; ++i)
      result = re::BucketArray<re::Matrix4x4<float>,8ul>::operator[](v1, i);
  }
  *(_QWORD *)(v1 + 40) = 0;
  ++*(_DWORD *)(v1 + 48);
  return result;
}

uint64_t *re::BucketArray<re::Matrix4x4<float>,8ul>::setBucketsCapacity(uint64_t *result, unint64_t a2)
{
  uint64_t *v3;
  unint64_t v4;
  uint64_t v5;

  v3 = result;
  if (*result)
  {
    if (result[5] < 8 * a2)
    {
      while (1)
      {
        v4 = v3[1];
        if (v4 <= a2)
          break;
        result = (uint64_t *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      while (v4 < a2)
      {
        v5 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)*v3 + 32))(*v3, 512, 0);
        result = (uint64_t *)re::DynamicOverflowArray<RESubscriptionHandle *,2ul>::add((uint64_t)v3, &v5);
        v4 = v3[1];
      }
    }
  }
  else
  {
  }
  return result;
}

void std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::BucketArray<re::Matrix4x4<float>,8ul>::BucketArrayIterator<re::Matrix4x4<float>,re::Matrix4x4<float> const&,re::BucketArray<re::Matrix4x4<float>,8ul> const&,true>,re::BucketArray<re::Matrix4x4<float>,8ul>::BucketArrayIterator<re::Matrix4x4<float>,re::Matrix4x4<float> const&,re::BucketArray<re::Matrix4x4<float>,8ul> const&,true>,re::BucketArray<re::Matrix4x4<float>,8ul>::BucketArrayIterator<re::Matrix4x4<float>,re::Matrix4x4<float>&,re::BucketArray<re::Matrix4x4<float>,8ul>&,true>>(uint64_t a1@<X1>, unint64_t a2@<X2>, uint64_t a3@<X3>, unint64_t a4@<X4>, uint64_t a5@<X5>, unint64_t a6@<X6>, uint64_t *a7@<X8>)
{
  unint64_t v13;
  unint64_t v14;
  __int128 *v15;
  _OWORD *v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;

  if (a1 != a3 || a2 != a4)
  {
    v13 = a4 - 1;
    do
    {
      do
      {
        v14 = a2;
        v15 = (__int128 *)re::BucketArray<re::Matrix4x4<float>,8ul>::operator[](a1, a2);
        v16 = (_OWORD *)re::BucketArray<re::Matrix4x4<float>,8ul>::operator[](a5, a6);
        v17 = v15[3];
        v19 = *v15;
        v18 = v15[1];
        v16[2] = v15[2];
        v16[3] = v17;
        *v16 = v19;
        v16[1] = v18;
        a2 = v14 + 1;
        ++a6;
      }
      while (a1 != a3);
    }
    while (v13 != v14);
    a2 = a4;
  }
  *a7 = a1;
  a7[1] = a2;
  a7[2] = a5;
  a7[3] = a6;
}

uint64_t re::DynamicArray<re::GeomDeformer::Affector>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  unint64_t v5;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  v3 = *a2;
  if (*a2)
  {
    v5 = a2[2];
    *(_QWORD *)a1 = v3;
    re::DynamicArray<re::GeomDeformer::Affector>::setCapacity((_QWORD *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::GeomDeformer::Affector>::copy((_QWORD *)a1, (uint64_t)a2);
  }
  return a1;
}

uint64_t re::BucketArray<re::FixedArray<int>,8ul>::BucketArray(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 1;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  v4 = *(_QWORD *)a2;
  if (v4)
  {
    re::BucketArray<re::FixedArray<int>,8ul>::init(a1, v4, *(_QWORD *)(a2 + 8));
    re::BucketArray<re::FixedArray<int>,8ul>::copy(a1, a2);
  }
  return a1;
}

uint64_t re::BucketArray<re::FixedArray<float>,8ul>::BucketArray(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 1;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  v4 = *(_QWORD *)a2;
  if (v4)
  {
    re::BucketArray<re::FixedArray<float>,8ul>::init(a1, v4, *(_QWORD *)(a2 + 8));
    re::BucketArray<re::FixedArray<float>,8ul>::copy(a1, a2);
  }
  return a1;
}

uint64_t re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::BucketArray(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 1;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  v4 = *(_QWORD *)a2;
  if (v4)
  {
    re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::init(a1, v4, *(_QWORD *)(a2 + 8));
    re::BucketArray<re::FixedArray<re::PackedFloat3>,8ul>::copy(a1, a2);
  }
  return a1;
}

uint64_t re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::BucketArray(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 1;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  v4 = *(_QWORD *)a2;
  if (v4)
  {
    re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::init(a1, v4, *(_QWORD *)(a2 + 8));
    re::BucketArray<re::GeomDeformer::MeshTarget,8ul>::copy(a1, a2);
  }
  return a1;
}

uint64_t re::BucketArray<re::StringID,8ul>::BucketArray(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 1;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  v4 = *(_QWORD *)a2;
  if (v4)
  {
    re::BucketArray<re::StringID,8ul>::init(a1, v4, *(_QWORD *)(a2 + 8));
    re::BucketArray<re::StringID,8ul>::copy(a1, a2);
  }
  return a1;
}

uint64_t re::BucketArray<re::Matrix4x4<float>,8ul>::BucketArray(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 1;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  v4 = *(_QWORD *)a2;
  if (v4)
  {
    re::BucketArray<re::Matrix4x4<float>,8ul>::init(a1, v4, *(_QWORD *)(a2 + 8));
    re::BucketArray<re::Matrix4x4<float>,8ul>::copy(a1, a2);
  }
  return a1;
}

_anonymous_namespace_ *re::ShareableInternal<re::GeomModelDescriptor>::ShareableInternal<re::GeomModelDescriptor>(_anonymous_namespace_ *a1, uint64_t a2)
{
  ArcSharedObject::ArcSharedObject(a1, 0);
  *(_QWORD *)a1 = off_24ED42FA8;
  re::GeomModelDescriptor::GeomModelDescriptor((uint64_t)a1 + 24, a2);
  return a1;
}

uint64_t re::ShareableInternal<re::GeomModelDescriptor>::~ShareableInternal(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;
  double v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  *(_QWORD *)a1 = off_24ED42FA8;
  v3 = (_OWORD *)(a1 + 208);
  v2 = *(_QWORD *)(a1 + 208);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 216) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 224));
    *v3 = 0u;
    v3[1] = 0u;
  }
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)(a1 + 160));
  re::DynamicArray<re::GeomModelDescriptor::AttributeData>::deinit(a1 + 120);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)(a1 + 72), v4);
  v5 = *(_QWORD *)(a1 + 64);
  if (v5)
  {

    *(_QWORD *)(a1 + 64) = 0;
  }
  v6 = *(_QWORD *)(a1 + 56);
  if (v6)
  {

    *(_QWORD *)(a1 + 56) = 0;
  }
  v7 = *(_QWORD *)(a1 + 32);
  if (v7)
  {

    *(_QWORD *)(a1 + 32) = 0;
  }
  *(_QWORD *)a1 = &off_24ED426B8;
  objc_destructInstance((id)(a1 + 8));
  return a1;
}

void re::ShareableInternal<re::GeomModelDescriptor>::~ShareableInternal(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;
  double v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  *(_QWORD *)a1 = off_24ED42FA8;
  v3 = (_OWORD *)(a1 + 208);
  v2 = *(_QWORD *)(a1 + 208);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 216) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 224));
    *v3 = 0u;
    v3[1] = 0u;
  }
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)(a1 + 160));
  re::DynamicArray<re::GeomModelDescriptor::AttributeData>::deinit(a1 + 120);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)(a1 + 72), v4);
  v5 = *(_QWORD *)(a1 + 64);
  if (v5)
  {

    *(_QWORD *)(a1 + 64) = 0;
  }
  v6 = *(_QWORD *)(a1 + 56);
  if (v6)
  {

    *(_QWORD *)(a1 + 56) = 0;
  }
  v7 = *(_QWORD *)(a1 + 32);
  if (v7)
  {

    *(_QWORD *)(a1 + 32) = 0;
  }
  *(_QWORD *)a1 = &off_24ED426B8;
  objc_destructInstance((id)(a1 + 8));
  JUMPOUT(0x2276933B8);
}

uint64_t re::GeomModelDescriptor::GeomModelDescriptor(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD v14[2];

  *(_WORD *)a1 = *(_WORD *)a2;
  *(_BYTE *)(a1 + 2) = *(_BYTE *)(a2 + 2);
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a2 + 8) = 0;
  v4 = (_QWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  v5 = a2 + 48;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_DWORD *)(a1 + 80) = 0;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_QWORD *)(a1 + 84) = 0x7FFFFFFFLL;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)(a1 + 48), (uint64_t *)(a2 + 48));
  *(_QWORD *)(a1 + 128) = 0;
  *(_DWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 96) = *(_QWORD *)(a2 + 96);
  *(_QWORD *)(a2 + 96) = 0;
  *(_QWORD *)(a1 + 104) = *(_QWORD *)(a2 + 104);
  *(_QWORD *)(a2 + 104) = 0;
  v6 = *(_QWORD *)(a1 + 112);
  *(_QWORD *)(a1 + 112) = *(_QWORD *)(a2 + 112);
  *(_QWORD *)(a2 + 112) = v6;
  v7 = *(_QWORD *)(a1 + 128);
  *(_QWORD *)(a1 + 128) = *(_QWORD *)(a2 + 128);
  *(_QWORD *)(a2 + 128) = v7;
  ++*(_DWORD *)(a2 + 120);
  ++*(_DWORD *)(a1 + 120);
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_DWORD *)(a1 + 168) = 0;
  *(_QWORD *)(a1 + 172) = 0x7FFFFFFFLL;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)(a1 + 136), (uint64_t *)(a2 + 136));
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_QWORD *)(a1 + 184) = *(_QWORD *)(a2 + 184);
  *(_QWORD *)(a2 + 184) = 0;
  v8 = *(_QWORD *)(a1 + 200);
  *(_QWORD *)(a1 + 200) = *(_QWORD *)(a2 + 200);
  *(_QWORD *)(a2 + 200) = v8;
  *(_QWORD *)(a1 + 208) = *(_QWORD *)(a2 + 208);
  *(_QWORD *)(a2 + 208) = 0;
  v9 = *(_QWORD *)(a1 + 192);
  *(_QWORD *)(a1 + 192) = *(_QWORD *)(a2 + 192);
  *(_QWORD *)(a2 + 192) = v9;
  *(_WORD *)a2 = 0;
  *(_BYTE *)(a2 + 2) = 0;
  *(_DWORD *)(a2 + 4) = 0;
  v10 = *(_QWORD *)(a2 + 8);
  if (v10)
  {

    *(_QWORD *)(a2 + 8) = 0;
  }
  *v4 = 0;
  v4[1] = 0;
  v11 = *(_QWORD *)(a2 + 32);
  if (v11)
  {

    *(_QWORD *)(a2 + 32) = 0;
  }
  v12 = *(_QWORD *)(a2 + 40);
  if (v12)
  {

    *(_QWORD *)(a2 + 40) = 0;
  }
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear(v5);
  re::DynamicArray<re::GeomModelDescriptor::AttributeData>::clear((_QWORD *)(a2 + 96));
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear(a2 + 136);
  v14[0] = "";
  v14[1] = 0;
  re::DynamicString::operator=((re::DynamicString *)(a2 + 184), (uint64_t)v14);
  return a1;
}

_QWORD *re::DynamicArray<re::GeomModelDescriptor::AttributeData>::clear(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD **v5;
  uint64_t v6;

  v1 = result;
  v2 = result[2];
  result[2] = 0;
  if (v2)
  {
    v3 = result[4] + 48;
    v4 = 56 * v2;
    do
    {
      v5 = (_QWORD **)(v3 - 48);
      if (*(_QWORD *)v3)
      {

        *(_QWORD *)v3 = 0;
      }
      v6 = *(_QWORD *)(v3 - 8);
      if (v6)
      {

        *(_QWORD *)(v3 - 8) = 0;
      }
      result = *v5;
      if (*v5)
      {
        if ((*(_BYTE *)(v3 - 40) & 1) != 0)
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, _QWORD))(*result + 40))(result, *(_QWORD *)(v3 - 32));
        *(_OWORD *)v5 = 0u;
        *(_OWORD *)(v3 - 32) = 0u;
      }
      v3 += 56;
      v4 -= 56;
    }
    while (v4);
  }
  ++*((_DWORD *)v1 + 6);
  return result;
}

uint64_t re::DynamicArray<re::GeomModelDescriptor::AttributeData>::deinit(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = v3 + 48;
        v6 = 56 * v4;
        do
        {
          v7 = (_QWORD *)(v5 - 48);
          if (*(_QWORD *)v5)
          {

            *(_QWORD *)v5 = 0;
          }
          v8 = *(_QWORD *)(v5 - 8);
          if (v8)
          {

            *(_QWORD *)(v5 - 8) = 0;
          }
          if (*v7)
          {
            if ((*(_BYTE *)(v5 - 40) & 1) != 0)
              (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*v7 + 40))(*v7, *(_QWORD *)(v5 - 32));
            *(_OWORD *)v7 = 0u;
            *(_OWORD *)(v5 - 32) = 0u;
          }
          v5 += 56;
          v6 -= 56;
        }
        while (v6);
        result = *(_QWORD *)a1;
        v3 = *(_QWORD *)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::BucketArray<unsigned long,4ul>::addUninitialized(uint64_t a1)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = *(_QWORD *)(a1 + 40);
  v3 = *(_QWORD *)(a1 + 8);
  if (v2 + 1 > 4 * v3)
  {
    re::BucketArray<unsigned long,4ul>::setBucketsCapacity((uint64_t *)a1, (v2 + 4) >> 2);
    v3 = *(_QWORD *)(a1 + 8);
  }
  if (v3 <= v2 >> 2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
    v4 = a1 + 24;
  else
    v4 = *(_QWORD *)(a1 + 32);
  v5 = *(_QWORD *)(v4 + 8 * (v2 >> 2));
  ++*(_QWORD *)(a1 + 40);
  ++*(_DWORD *)(a1 + 48);
  return v5 + 8 * (v2 & 3);
}

uint64_t *re::BucketArray<unsigned long,4ul>::setBucketsCapacity(uint64_t *result, unint64_t a2)
{
  uint64_t *v3;
  unint64_t v4;
  uint64_t v5;

  v3 = result;
  if (*result)
  {
    if (result[5] < 4 * a2)
    {
      while (1)
      {
        v4 = v3[1];
        if (v4 <= a2)
          break;
        result = (uint64_t *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      while (v4 < a2)
      {
        v5 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)*v3 + 32))(*v3, 32, 0);
        result = (uint64_t *)re::DynamicOverflowArray<RESubscriptionHandle *,2ul>::add((uint64_t)v3, &v5);
        v4 = v3[1];
      }
    }
  }
  else
  {
    re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, a2);
    *((_DWORD *)v3 + 4) += 2;
    v3[5] = 0;
    result = (uint64_t *)re::BucketArray<unsigned long,4ul>::setBucketsCapacity(v3, a2);
    ++*((_DWORD *)v3 + 12);
  }
  return result;
}

uint64_t re::BucketArray<unsigned long,32ul>::addUninitialized(uint64_t a1)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = *(_QWORD *)(a1 + 40);
  v3 = *(_QWORD *)(a1 + 8);
  if (v2 + 1 > 32 * v3)
  {
    re::BucketArray<unsigned long,32ul>::setBucketsCapacity((uint64_t *)a1, (v2 + 32) >> 5);
    v3 = *(_QWORD *)(a1 + 8);
  }
  if (v3 <= v2 >> 5)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
    v4 = a1 + 24;
  else
    v4 = *(_QWORD *)(a1 + 32);
  v5 = *(_QWORD *)(v4 + 8 * (v2 >> 5));
  ++*(_QWORD *)(a1 + 40);
  ++*(_DWORD *)(a1 + 48);
  return v5 + 8 * (v2 & 0x1F);
}

_QWORD *re::BucketArray<re::USDImportContextBlendShapeData,8ul>::setBucketsCapacity(_QWORD *result, unint64_t a2)
{
  _QWORD *v3;
  unint64_t v4;
  unint64_t *v5;
  _QWORD *v6;
  unint64_t v7;
  int v8;
  unint64_t v9;
  unint64_t v10;
  BOOL v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  _QWORD *v15;
  unint64_t v16;

  v3 = result;
  if (*result)
  {
    if (result[5] < 8 * a2)
    {
      while (1)
      {
        v4 = v3[1];
        if (v4 <= a2)
          break;
        result = (_QWORD *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        v5 = v3 + 3;
        do
        {
          result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(*(_QWORD *)*v3 + 32))(*v3, 1216, 0);
          v6 = result;
          if (*v3)
          {
            v7 = v3[1];
            v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              v9 = *v5;
              v11 = v7 >= *v5;
              v10 = v7 + 1;
              v11 = !v11 || v9 >= v10;
              if (v11)
                goto LABEL_22;
              v12 = 2 * v9;
              goto LABEL_18;
            }
            v10 = v7 + 1;
            if (v10 >= 3)
            {
              v12 = 4;
LABEL_18:
              if (v12 <= v10)
                v14 = v10;
              else
                v14 = v12;
              result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v14);
              v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            v13 = v3[1] + 1;
            result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v13);
            v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + 4) = v8;
          }
LABEL_22:
          v15 = v3 + 3;
          if ((v8 & 1) == 0)
            v15 = (_QWORD *)v3[4];
          v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
    re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, a2);
    *((_DWORD *)v3 + 4) += 2;
    v3[5] = 0;
    result = (_QWORD *)re::BucketArray<re::USDImportContextBlendShapeData,8ul>::setBucketsCapacity(v3, a2);
    ++*((_DWORD *)v3 + 12);
  }
  return result;
}

_QWORD *re::BucketArray<re::USDImportContextSkeletonData,4ul>::setBucketsCapacity(_QWORD *result, unint64_t a2)
{
  _QWORD *v3;
  unint64_t v4;
  unint64_t *v5;
  _QWORD *v6;
  unint64_t v7;
  int v8;
  unint64_t v9;
  unint64_t v10;
  BOOL v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  _QWORD *v15;
  unint64_t v16;

  v3 = result;
  if (*result)
  {
    if (result[5] < 4 * a2)
    {
      while (1)
      {
        v4 = v3[1];
        if (v4 <= a2)
          break;
        result = (_QWORD *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        v5 = v3 + 3;
        do
        {
          result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(*(_QWORD *)*v3 + 32))(*v3, 1696, 0);
          v6 = result;
          if (*v3)
          {
            v7 = v3[1];
            v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              v9 = *v5;
              v11 = v7 >= *v5;
              v10 = v7 + 1;
              v11 = !v11 || v9 >= v10;
              if (v11)
                goto LABEL_22;
              v12 = 2 * v9;
              goto LABEL_18;
            }
            v10 = v7 + 1;
            if (v10 >= 3)
            {
              v12 = 4;
LABEL_18:
              if (v12 <= v10)
                v14 = v10;
              else
                v14 = v12;
              result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v14);
              v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            v13 = v3[1] + 1;
            result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v13);
            v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + 4) = v8;
          }
LABEL_22:
          v15 = v3 + 3;
          if ((v8 & 1) == 0)
            v15 = (_QWORD *)v3[4];
          v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
  }
  return result;
}

_QWORD *re::BucketArray<re::USDImportContextSkeletalAnimationData,8ul>::setBucketsCapacity(_QWORD *result, unint64_t a2)
{
  _QWORD *v3;
  unint64_t v4;
  unint64_t *v5;
  _QWORD *v6;
  unint64_t v7;
  int v8;
  unint64_t v9;
  unint64_t v10;
  BOOL v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  _QWORD *v15;
  unint64_t v16;

  v3 = result;
  if (*result)
  {
    if (result[5] < 8 * a2)
    {
      while (1)
      {
        v4 = v3[1];
        if (v4 <= a2)
          break;
        result = (_QWORD *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        v5 = v3 + 3;
        do
        {
          result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(*(_QWORD *)*v3 + 32))(*v3, 2240, 0);
          v6 = result;
          if (*v3)
          {
            v7 = v3[1];
            v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              v9 = *v5;
              v11 = v7 >= *v5;
              v10 = v7 + 1;
              v11 = !v11 || v9 >= v10;
              if (v11)
                goto LABEL_22;
              v12 = 2 * v9;
              goto LABEL_18;
            }
            v10 = v7 + 1;
            if (v10 >= 3)
            {
              v12 = 4;
LABEL_18:
              if (v12 <= v10)
                v14 = v10;
              else
                v14 = v12;
              result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v14);
              v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            v13 = v3[1] + 1;
            result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v13);
            v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + 4) = v8;
          }
LABEL_22:
          v15 = v3 + 3;
          if ((v8 & 1) == 0)
            v15 = (_QWORD *)v3[4];
          v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
  }
  return result;
}

uint64_t re::HashTable<re::StringID,unsigned long,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addEmplace<BOOL>(uint64_t a1, unsigned int a2, unint64_t a3, StringID *a4, unsigned __int8 *a5)
{
  uint64_t v9;
  int v10;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;

  v9 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
    v9 = *(unsigned int *)(a1 + 32);
    v10 = v9;
    if ((_DWORD)v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::StringID,unsigned long,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 32 * v9);
  }
  else
  {
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 32 * v9);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  v14 = 32 * v9;
  *(_DWORD *)(v12 + v14) = v13 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + v14) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  re::StringID::StringID((re::StringID *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 8), a4);
  v15 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 24) = *a5;
  *(_DWORD *)(v15 + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

uint64_t re::BucketArray<re::USDImportContextPhysicsColliderData,8ul>::addUninitialized(uint64_t a1)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = *(_QWORD *)(a1 + 40);
  v3 = *(_QWORD *)(a1 + 8);
  if (v2 + 1 > 8 * v3)
  {
    re::BucketArray<re::USDImportContextPhysicsColliderData,8ul>::setBucketsCapacity((_QWORD *)a1, (v2 + 8) >> 3);
    v3 = *(_QWORD *)(a1 + 8);
  }
  if (v3 <= v2 >> 3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
    v4 = a1 + 24;
  else
    v4 = *(_QWORD *)(a1 + 32);
  v5 = *(_QWORD *)(v4 + 8 * (v2 >> 3));
  ++*(_QWORD *)(a1 + 40);
  ++*(_DWORD *)(a1 + 48);
  return v5 + 80 * (v2 & 7);
}

_QWORD *re::BucketArray<re::USDImportContextPhysicsColliderData,8ul>::setBucketsCapacity(_QWORD *result, unint64_t a2)
{
  _QWORD *v3;
  unint64_t v4;
  unint64_t *v5;
  _QWORD *v6;
  unint64_t v7;
  int v8;
  unint64_t v9;
  unint64_t v10;
  BOOL v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  _QWORD *v15;
  unint64_t v16;

  v3 = result;
  if (*result)
  {
    if (result[5] < 8 * a2)
    {
      while (1)
      {
        v4 = v3[1];
        if (v4 <= a2)
          break;
        result = (_QWORD *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        v5 = v3 + 3;
        do
        {
          result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(*(_QWORD *)*v3 + 32))(*v3, 640, 0);
          v6 = result;
          if (*v3)
          {
            v7 = v3[1];
            v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              v9 = *v5;
              v11 = v7 >= *v5;
              v10 = v7 + 1;
              v11 = !v11 || v9 >= v10;
              if (v11)
                goto LABEL_22;
              v12 = 2 * v9;
              goto LABEL_18;
            }
            v10 = v7 + 1;
            if (v10 >= 3)
            {
              v12 = 4;
LABEL_18:
              if (v12 <= v10)
                v14 = v10;
              else
                v14 = v12;
              result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v14);
              v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            v13 = v3[1] + 1;
            result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v13);
            v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + 4) = v8;
          }
LABEL_22:
          v15 = v3 + 3;
          if ((v8 & 1) == 0)
            v15 = (_QWORD *)v3[4];
          v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
  }
  return result;
}

uint64_t re::BucketArray<re::USDImportContextPhysicsRigidBodyData,8ul>::addUninitialized(uint64_t a1)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = *(_QWORD *)(a1 + 40);
  v3 = *(_QWORD *)(a1 + 8);
  if (v2 + 1 > 8 * v3)
  {
    re::BucketArray<re::USDImportContextPhysicsRigidBodyData,8ul>::setBucketsCapacity((_QWORD *)a1, (v2 + 8) >> 3);
    v3 = *(_QWORD *)(a1 + 8);
  }
  if (v3 <= v2 >> 3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
    v4 = a1 + 24;
  else
    v4 = *(_QWORD *)(a1 + 32);
  v5 = *(_QWORD *)(v4 + 8 * (v2 >> 3));
  ++*(_QWORD *)(a1 + 40);
  ++*(_DWORD *)(a1 + 48);
  return v5 + 80 * (v2 & 7);
}

_QWORD *re::BucketArray<re::USDImportContextPhysicsRigidBodyData,8ul>::setBucketsCapacity(_QWORD *result, unint64_t a2)
{
  _QWORD *v3;
  unint64_t v4;
  unint64_t *v5;
  _QWORD *v6;
  unint64_t v7;
  int v8;
  unint64_t v9;
  unint64_t v10;
  BOOL v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  _QWORD *v15;
  unint64_t v16;

  v3 = result;
  if (*result)
  {
    if (result[5] < 8 * a2)
    {
      while (1)
      {
        v4 = v3[1];
        if (v4 <= a2)
          break;
        result = (_QWORD *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      if (v4 < a2)
      {
        v5 = v3 + 3;
        do
        {
          result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(*(_QWORD *)*v3 + 32))(*v3, 640, 0);
          v6 = result;
          if (*v3)
          {
            v7 = v3[1];
            v8 = *((_DWORD *)v3 + 4);
            if ((v8 & 1) == 0)
            {
              v9 = *v5;
              v11 = v7 >= *v5;
              v10 = v7 + 1;
              v11 = !v11 || v9 >= v10;
              if (v11)
                goto LABEL_22;
              v12 = 2 * v9;
              goto LABEL_18;
            }
            v10 = v7 + 1;
            if (v10 >= 3)
            {
              v12 = 4;
LABEL_18:
              if (v12 <= v10)
                v14 = v10;
              else
                v14 = v12;
              result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v14);
              v8 = *((_DWORD *)v3 + 4);
            }
          }
          else
          {
            v13 = v3[1] + 1;
            result = re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v3, v13);
            v8 = *((_DWORD *)v3 + 4) + 2;
            *((_DWORD *)v3 + 4) = v8;
          }
LABEL_22:
          v15 = v3 + 3;
          if ((v8 & 1) == 0)
            v15 = (_QWORD *)v3[4];
          v16 = v3[1];
          v15[v16++] = v6;
          v3[1] = v16;
          *((_DWORD *)v3 + 4) += 2;
        }
        while (v16 < a2);
      }
    }
  }
  else
  {
  }
  return result;
}

uint64_t re::HashTable<re::DynamicString,re::MeshCompileOptions,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, re::DynamicString *a4, __int128 *a5)
{
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  __int128 v15;

  v10 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
    v10 = *(unsigned int *)(a1 + 32);
    v11 = v10;
    if ((_DWORD)v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::DynamicString,re::MeshCompileOptions,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 120 * v10 + 8);
  }
  else
  {
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 120 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + 120 * v10 + 8) = v13 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 120 * v10 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 120 * v10 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 120 * v10) = a3;
  re::DynamicString::DynamicString((re::DynamicString *)(*(_QWORD *)(a1 + 16) + 120 * v10 + 16), a4);
  v14 = *(_QWORD *)(a1 + 16) + 120 * v10;
  v15 = *a5;
  *(_QWORD *)(v14 + 61) = *(_QWORD *)((char *)a5 + 13);
  *(_OWORD *)(v14 + 48) = v15;
  re::HashTable<re::DynamicString,re::MeshAttributeCompressionOption,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::HashTable(v14 + 72, (uint64_t)a5 + 24);
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

void re::HashTable<re::DynamicString,re::MeshCompileOptions,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  __int128 v7;
  unsigned int v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t *v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  __int128 v23;
  uint64_t v24;
  signed int v25;
  _BYTE v26[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v26, 0, 36);
      *(_QWORD *)&v26[36] = 0x7FFFFFFFLL;
      re::HashTable<re::DynamicString,re::MeshCompileOptions,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::init((uint64_t)v26, v4, a2);
      v5 = *(_OWORD *)a1;
      *(_QWORD *)a1 = *(_QWORD *)v26;
      v6 = *(_QWORD *)(a1 + 16);
      v7 = *(_OWORD *)&v26[8];
      *(_OWORD *)v26 = v5;
      *(_QWORD *)&v26[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      v9 = *(_OWORD *)&v26[24];
      *(_OWORD *)&v26[24] = *(_OWORD *)(a1 + 24);
      v8 = *(_DWORD *)&v26[32];
      *(_OWORD *)(a1 + 24) = v9;
      v10 = v8;
      if (v8)
      {
        v11 = 0;
        v12 = DWORD1(v9);
        v13 = v7;
        v14 = (uint64_t *)(v6 + 72);
        do
        {
          if ((*(_DWORD *)(v14 - 8) & 0x80000000) != 0)
          {
            v15 = *(v14 - 9);
            v16 = *(unsigned int *)(a1 + 24);
            v17 = v15 % v16;
            v18 = *(unsigned int *)(a1 + 36);
            if ((_DWORD)v18 == 0x7FFFFFFF)
            {
              v18 = *(unsigned int *)(a1 + 32);
              v19 = v18;
              if ((_DWORD)v18 == (_DWORD)v16)
              {
                re::HashTable<re::DynamicString,re::MeshCompileOptions,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, (2 * v12));
                v17 = v15 % *(unsigned int *)(a1 + 24);
                v19 = *(_DWORD *)(a1 + 32);
                v13 = *(_QWORD *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v19 + 1;
              v20 = *(_QWORD *)(a1 + 16);
              v21 = *(_DWORD *)(v20 + 120 * v18 + 8);
            }
            else
            {
              v20 = *(_QWORD *)(a1 + 16);
              v21 = *(_DWORD *)(v20 + 120 * v18 + 8);
              *(_DWORD *)(a1 + 36) = v21 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v20 + 120 * v18 + 8) = v21 | 0x80000000;
            *(_DWORD *)(*(_QWORD *)(a1 + 16) + 120 * v18 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 120 * v18 + 8) & 0x80000000 | *(_DWORD *)(v13 + 4 * v17);
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 120 * v18) = v15;
            re::DynamicString::DynamicString((re::DynamicString *)(*(_QWORD *)(a1 + 16) + 120 * v18 + 16), (const re::DynamicString *)(v14 - 7));
            v22 = *(_QWORD *)(a1 + 16) + 120 * v18;
            v23 = *(_OWORD *)(v14 - 3);
            v24 = *(uint64_t *)((char *)v14 - 11);
            *(_OWORD *)(v22 + 72) = 0u;
            v22 += 72;
            *(_QWORD *)(v22 - 11) = v24;
            *(_OWORD *)(v22 - 24) = v23;
            *(_OWORD *)(v22 + 16) = 0u;
            *(_DWORD *)(v22 + 32) = 0;
            *(_QWORD *)(v22 + 36) = 0x7FFFFFFFLL;
            re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)v22, v14);
            v13 = *(_QWORD *)(a1 + 8);
            *(_DWORD *)(v13 + 4 * v17) = v18;
            v12 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v12;
          }
          ++v11;
          v14 += 15;
        }
        while (v11 < v10);
      }
      re::HashTable<re::DynamicString,re::MeshCompileOptions,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v26, *(double *)&v7);
    }
  }
  else
  {
    if (a2)
      v25 = a2;
    else
      v25 = 3;
  }
}

void re::HashTable<re::DynamicString,re::MeshCompileOptions,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 120 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &unk_2260EB7B0, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

uint64_t re::HashTable<re::DynamicString,re::MeshAttributeCompressionOption,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::HashTable(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  signed int v5;

  *(_DWORD *)(a1 + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_QWORD *)(a1 + 36) = 0x7FFFFFFFLL;
  v4 = *(_QWORD *)a2;
  if (v4)
  {
    if (*(_DWORD *)(a2 + 28) <= 3u)
      v5 = 3;
    else
      v5 = *(_DWORD *)(a2 + 28);
    re::HashTable<re::DynamicString,re::MeshAttributeCompressionOption,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::init(a1, v4, v5);
    re::HashTable<re::DynamicString,re::MeshAttributeCompressionOption,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::copy(a1, a2);
  }
  return a1;
}

BOOL re::nameIsBlendShapeRoot(re *this, const char *a2)
{
  size_t v3;

  v3 = strlen((const char *)this);
  return v3 >= 0xC && strcmp((const char *)this + v3 - 11, "_blendShape") == 0;
}

BOOL re::importModelBlendShapes(unsigned __int16 *a1)
{
  _QWORD *v1;
  unint64_t v2;
  unint64_t v3;
  _BYTE *v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  int *v10;
  uint64_t v11;
  const char *v12;
  size_t v13;
  _anonymous_namespace_ *v14;
  int v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  __int16 v20;
  _anonymous_namespace_ *v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  const char *v28;
  unint64_t v29;
  _QWORD *v30;
  _anonymous_namespace_ *v31;
  size_t v32;
  _anonymous_namespace_ *v33;
  const char *v34;
  uint64_t v35;
  void *v36;
  uint64_t v37;
  unint64_t v38;
  _anonymous_namespace_ *v39;
  _QWORD *v40;
  _anonymous_namespace_ *v41;
  _anonymous_namespace_ *v42;
  _anonymous_namespace_ *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t *v46;
  uint64_t v47;
  _anonymous_namespace_ *v48;
  unint64_t v49;
  unint64_t v50;
  unint64_t v51;
  int *v52;
  _DWORD *v53;
  int v54;
  int v55;
  _anonymous_namespace_ *v57;
  StringID *v58;
  unint64_t v59;
  uint64_t v60;
  void *v61;
  uint64_t *v62;
  unint64_t v63;
  unint64_t v64;
  int v65;
  uint64_t v66;
  int v67;
  const char *v68;
  __int16 v69;
  _BYTE v70[26];
  char v71;
  int v72;
  __int16 v73;
  _BYTE v74[18];
  __int16 v75;
  unint64_t v76;
  __int16 v77;
  _BYTE *v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  uint64_t v84;

  v1 = a1;
  v84 = *MEMORY[0x24BDAC8D0];
  v2 = a1[104];
  re::DynamicArray<re::MeshAssetBlendShapeData>::setCapacity(v1 + 14, v2);
  v57 = (_anonymous_namespace_ *)(v1 + 14);
  ++*((_DWORD *)v1 + 34);
  v59 = v2;
  if (v2)
  {
    v3 = 0;
    v58 = (StringID *)v1;
    while (1)
    {
      v4 = (_BYTE *)v1[26];
      if ((unint64_t)v4 <= v3)
        goto LABEL_54;
      v5 = v1[28] + (v3 << 8);
      v66 = 0;
      v63 = 0;
      v64 = 0;
      v62 = 0;
      v65 = 0;
      v6 = *(_QWORD *)(v5 + 16);
      if (v6)
      {
        v7 = 0;
        v8 = 0;
        v9 = *(_QWORD *)(v5 + 32);
        v10 = (int *)(v5 + 48);
        v11 = 80 * v6;
        do
        {
          if ((*(_BYTE *)(v9 + 8) & 1) != 0)
            v12 = *(const char **)(v9 + 16);
          else
            v12 = (const char *)(v9 + 9);
          v13 = strlen(v12);
          if (v13 >= 0x16)
          {
            v14 = (_anonymous_namespace_ *)strcmp(&v12[v13 - 21], "|blendTargetPosDeltas");
            if (!(_DWORD)v14)
            {
              v15 = *v10;
              if (v8 >= v63)
              {
                v16 = v8 + 1;
                if (v63 < v16)
                {
                  if (v62)
                  {
                    v17 = 8;
                    if (v63)
                      v17 = 2 * v63;
                    if (v17 <= v16)
                      v18 = v16;
                    else
                      v18 = v17;
                    re::DynamicArray<re::BaseBlendShapeChannelData>::setCapacity(&v62, v18);
                  }
                  else
                  {
                    re::DynamicArray<re::BaseBlendShapeChannelData>::setCapacity(&v62, v16);
                    ++v65;
                  }
                }
                v8 = v64;
                v7 = v66;
              }
              v19 = v7 + 56 * v8;
              *(_OWORD *)v19 = 0u;
              *(_OWORD *)(v19 + 16) = 0u;
              *(_QWORD *)(v19 + 32) = v9;
              *(_WORD *)(v19 + 40) = v15;
              v20 = WORD2(v79);
              *(_DWORD *)(v19 + 42) = v79;
              *(_WORD *)(v19 + 46) = v20;
              *(_QWORD *)(v19 + 48) = 16;
              v8 = ++v64;
              ++v65;
            }
          }
          v9 += 80;
          v11 -= 80;
        }
        while (v11);
        v1 = v58;
        if (v8)
        {
          if (*v10)
            break;
        }
      }
LABEL_45:
      if (v62 && v66)
        (*(void (**)(void))(*v62 + 40))();
      if (++v3 == v59)
        return v1[16] != 0;
    }
    v21 = re::StringID::StringID((re::StringID *)&v67, v58);
    memset(&v70[2], 0, 24);
    v22 = 0;
    v71 = 2;
    v72 = *v10;
    v73 = v3;
    v23 = v66;
    while (1)
    {
      v4 = *(_BYTE **)&v70[10];
      if (*(_QWORD *)&v70[10] <= v22)
        goto LABEL_53;
      v24 = v23 + 56 * v22;
      v27 = *(_QWORD *)(v24 + 32);
      v26 = (uint64_t *)(v24 + 32);
      v25 = v27;
      if ((*(_BYTE *)(v27 + 8) & 1) != 0)
        v28 = *(const char **)(v25 + 16);
      else
        v28 = (const char *)(v25 + 9);
      v29 = *(_QWORD *)&v70[18];
      v30 = (_QWORD *)(*(_QWORD *)&v70[18] + 136 * v22);
      v31 = (_anonymous_namespace_ *)strlen(v28);
      v32 = (size_t)v31 - 21;
      if ((BYTE8(v79) & 1) != 0)
        v34 = (const char *)v80;
      else
        v34 = (char *)&v79 + 9;
      v60 = 0;
      v61 = &str_110;
      v35 = v60;
      v36 = v61;
      v60 = 0;
      v61 = &str_110;
      v37 = v30[1];
      v38 = v35 & 0xFFFFFFFFFFFFFFFELL | *v30 & 1;
      v30[1] = v36;
      *(_QWORD *)v74 = v38;
      *(_QWORD *)&v74[8] = v37;
      *v30 = v35;
      re::StringID::destroyString((re::StringID *)v74);
      re::StringID::destroyString((re::StringID *)&v60);
      v39 = (_anonymous_namespace_ *)v79;
      if ((_QWORD)v79 && (BYTE8(v79) & 1) != 0)
        v39 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v79 + 40))();
      v40 = (_QWORD *)(v29 + 136 * v22);
      v40[3] = 0;
      v40[9] = 0;
      v40[12] = 0;
      v40[15] = 0;
      v44 = *v26;
      v45 = *(unsigned __int16 *)(v23 + 56 * v22 + 40);
      v46 = v40 + 5;
      v47 = 3 * v45;
      if (v45)
        break;
LABEL_43:
      if (++v22 == v8)
      {
        re::DynamicArray<re::MeshAssetBlendShapeData>::add(v57, (uint64_t *)&v67);
        re::FixedArray<re::BlendShapeDefinition>::deinit(&v70[2]);
        re::StringID::destroyString((re::StringID *)&v67);
        v1 = v58;
        goto LABEL_45;
      }
    }
    v49 = 0;
    v50 = v29 + 136 * v22;
    v51 = *(_QWORD *)(v50 + 48);
    v52 = (int *)(*(_QWORD *)(v44 + 64) + 8);
    v53 = (_DWORD *)(*(_QWORD *)(v50 + 56) + 4);
    while (v51 > v49)
    {
      v55 = *(v52 - 1);
      v54 = *v52;
      *(v53 - 1) = *(v52 - 2);
      v29 = v49 + 1;
      if (v51 <= v49 + 1)
        goto LABEL_51;
      *v53 = v55;
      v29 = v49 + 2;
      if (v51 <= v49 + 2)
        goto LABEL_52;
      v52 += 3;
      v53[1] = v54;
      v49 += 3;
      v53 += 3;
      if (v47 == v49)
        goto LABEL_43;
    }
    v60 = 0;
    v82 = 0u;
    v83 = 0u;
    v80 = 0u;
    v81 = 0u;
    v79 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v74 = 136315906;
    *(_QWORD *)&v74[4] = "operator[]";
    *(_WORD *)&v74[12] = 1024;
    *(_DWORD *)&v74[14] = 468;
    v75 = 2048;
    v76 = v49;
    v77 = 2048;
    v78 = (_BYTE *)v51;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_51:
    v60 = 0;
    v82 = 0u;
    v83 = 0u;
    v80 = 0u;
    v81 = 0u;
    v79 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v74 = 136315906;
    *(_QWORD *)&v74[4] = "operator[]";
    *(_WORD *)&v74[12] = 1024;
    *(_DWORD *)&v74[14] = 468;
    v75 = 2048;
    v76 = v29;
    v77 = 2048;
    v78 = (_BYTE *)v51;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_52:
    v60 = 0;
    v4 = v74;
    v82 = 0u;
    v83 = 0u;
    v80 = 0u;
    v81 = 0u;
    v79 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v74 = 136315906;
    *(_QWORD *)&v74[4] = "operator[]";
    *(_WORD *)&v74[12] = 1024;
    *(_DWORD *)&v74[14] = 468;
    v75 = 2048;
    v76 = v29;
    v77 = 2048;
    v78 = (_BYTE *)v51;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_53:
    v60 = 0;
    v82 = 0u;
    v83 = 0u;
    v80 = 0u;
    v81 = 0u;
    v79 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v74 = 136315906;
    *(_QWORD *)&v74[4] = "operator[]";
    *(_WORD *)&v74[12] = 1024;
    *(_DWORD *)&v74[14] = 468;
    v75 = 2048;
    v76 = v22;
    v77 = 2048;
    v78 = v4;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_54:
    v62 = 0;
    v82 = 0u;
    v83 = 0u;
    v80 = 0u;
    v81 = 0u;
    v79 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v67 = 136315906;
    v68 = "operator[]";
    v69 = 1024;
    *(_DWORD *)v70 = 789;
    *(_WORD *)&v70[4] = 2048;
    *(_QWORD *)&v70[6] = v3;
    *(_WORD *)&v70[14] = 2048;
    *(_QWORD *)&v70[16] = v4;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return v1[16] != 0;
}

BOOL re::objectIsBlendShapeRoot(re *this, MDLObject *a2)
{
  re *v2;
  char isKindOfClass;
  __CFString *v4;
  re *v5;
  const char *v6;
  _BOOL8 IsBlendShapeRoot;

  v2 = this;
  objc_opt_class();
  isKindOfClass = objc_opt_isKindOfClass();
  -[re name](v2, "name");
  v4 = (__CFString *)objc_claimAutoreleasedReturnValue();

  if (!v4)
    v4 = &stru_24EDA2070;
  if ((isKindOfClass & 1) != 0)
  {
    v5 = (re *)-[__CFString UTF8String](objc_retainAutorelease(v4), "UTF8String");
    IsBlendShapeRoot = re::nameIsBlendShapeRoot(v5, v6);
  }
  else
  {
    IsBlendShapeRoot = 0;
  }

  return IsBlendShapeRoot;
}

BOOL re::uskNodeIsBlendShapeRoot(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  void *v4;
  __CFString *v5;
  _BOOL8 IsBlendShapeRoot;
  re *v7;
  const char *v8;

  v1 = a1;
  objc_msgSend(v1, "type");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v3 = (void *)*MEMORY[0x24BEBEDF8];

  objc_msgSend(v1, "name");
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(v4, "stringValue");
  v5 = (__CFString *)objc_claimAutoreleasedReturnValue();

  if (!v5)
    v5 = &stru_24EDA2070;
  if (v2 == v3)
  {
    v7 = (re *)-[__CFString UTF8String](objc_retainAutorelease(v5), "UTF8String");
    IsBlendShapeRoot = re::nameIsBlendShapeRoot(v7, v8);
  }
  else
  {
    IsBlendShapeRoot = 0;
  }

  return IsBlendShapeRoot;
}

_QWORD *re::DynamicArray<re::BaseBlendShapeChannelData>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  void *v7;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (*v5)
      {
        if (!a2)
        {
          v7 = 0;
          if (!v3)
            goto LABEL_9;
          goto LABEL_8;
        }
        if (is_mul_ok(a2, 0x38uLL))
        {
          v2 = 56 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 56 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
            {
LABEL_9:
              v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            memcpy(v7, (const void *)v5[4], 56 * v5[2]);
            result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 56, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
      }
      else
      {
        result = (_QWORD *)re::DynamicArray<re::BaseBlendShapeChannelData>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

void re::TextureCompatibility::updateLegacyTextureSemantic(re::TextureCompatibility *this, const re::AssetHandle *a2, const re::StringID *a3, const re::AssetManager *a4, os_unfair_lock_s **a5, const re::RenderManager *a6, BOOL *a7, BOOL *a8)
{
  const re::StringID *v14;
  re::TextureAsset *v15;
  uint64_t v16;
  _BOOL4 isLegacyLinearFormatWithSRGBData;
  int v18;
  int v19;
  int v20;
  unint64_t v21;
  unint64_t v22;
  __CFString *CGColorSpaceNameForPixelFormat;
  id v24;
  id v25;
  unsigned __int8 v26;
  int isSupportedPixelFormat;
  id v28;
  void *v29;
  uint64_t v30;
  id *v31;
  __CFString *v32;
  id v33[13];
  id v34;

  *a7 = 0;
  *(_BYTE *)a6 = 0;
  if (!*((_QWORD *)this + 1))
    return;
  if (re::AssetManager::isDeviceAsset((uint64_t)a3, (uint64_t)this, 12))
    return;
  if (!re::MaterialAsset::isColorTextureParameter(a2, v14))
    return;
  v15 = (re::TextureAsset *)re::AssetHandle::asset<re::TextureAsset>(this);
  if (!v15)
    return;
  v16 = (uint64_t)v15;
  isLegacyLinearFormatWithSRGBData = re::TextureAsset::isLegacyLinearFormatWithSRGBData(v15);
  v18 = *(_DWORD *)(v16 + 376);
  if (isLegacyLinearFormatWithSRGBData)
    v18 = re::translateLinearPixelFormatToSRGB(*(unsigned int *)(v16 + 376));
  v19 = *(_DWORD *)(v16 + 388);
  if (v19 == 6)
    goto LABEL_10;
  if (v19 != 3)
  {
    if (v19)
      return;
LABEL_10:
    if (re::StringID::operator==(a2, re::MaterialAsset::isHdrColorTextureParameter(re::StringID const&)::textureEmissive))
    {
      v20 = 4;
    }
    else
    {
      v20 = 3;
    }
    *(_DWORD *)(v16 + 388) = v20;
  }
  v21 = *(_QWORD *)(v16 + 400);
  if ((v21 & 1) != 0)
    v22 = v21 >> 1;
  else
    v22 = v21 >> 1;
  if (!v22)
  {
    CGColorSpaceNameForPixelFormat = (__CFString *)re::ColorHelpers::getCGColorSpaceNameForPixelFormat(v18, 0);
    if (CGColorSpaceNameForPixelFormat)
      re::TextureAsset::updateColorSpaceFromTexture((re::TextureAsset *)v16, a4, CGColorSpaceNameForPixelFormat);
  }
  if (*(_DWORD *)(v16 + 240))
  {
    v30 = std::__throw_bad_variant_access[abi:nn180100]();
    re::TextureData::TextureData(v30, v31, v32);
  }
  else
  {
    v24 = *(id *)(v16 + 160);
    v25 = *(id *)(v16 + 248);
    if (v24)
    {
      LOBYTE(v33[0]) = 0;
      if (re::ColorHelpers::getColorGamutFromCGColorSpaceName(v25, (char *)v33))
      {
        v26 = *((_BYTE *)a4 + 19) ? *((_BYTE *)a4 + 20) : 0;
        if (LOBYTE(v33[0]) != v26)
          *(_BYTE *)a6 = 1;
      }
      if (isLegacyLinearFormatWithSRGBData)
      {
        objc_msgSend(v24, sel_textureType);
        isSupportedPixelFormat = re::isSupportedPixelFormat();
        if ((objc_msgSend(v24, sel_isShareable) & 1) == 0
          && isSupportedPixelFormat
          && (v28 = objc_msgSend(v24, sel_newTextureViewWithPixelFormat_, v18), (v34 = v28) != 0))
        {
          v29 = v28;
          re::TextureData::TextureData((uint64_t)v33, &v34, (__CFString *)*(id *)(v16 + 248));
          LOBYTE(v33[0]) = *(_BYTE *)(v16 + 152);
          re::TextureAsset::setTextureAndSemantic(v16, a4, (uint64_t)v33, *(_DWORD *)(v16 + 388));
          re::TextureData::~TextureData(v33);

        }
        else
        {
          *a7 = 1;
          if (!*(_BYTE *)a6)
            re::TextureAsset::addLegacyLinearFormatWithSRGBDataTexture((os_unfair_lock_s **)v16, a5);
        }
      }

    }
  }
}

uint64_t re::TextureData::TextureData(uint64_t a1, id *a2, __CFString *a3)
{
  *(_BYTE *)a1 &= 0x80u;
  *(_QWORD *)(a1 + 8) = *a2;
  *(_DWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  re::TextureData::setColorSpace((id *)a1, a3);
  return a1;
}

uint64_t re::AssetHandle::asset<re::ImageBasedLightAsset>(re::ImageBasedLightAsset *a1)
{
  uint64_t *v2;
  uint64_t v3;
  NSObject *v4;
  NSObject *v6;
  _QWORD *v7;
  char *v8;
  int v9;
  char *v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v2 = re::ImageBasedLightAsset::assetType(a1);
  v3 = re::AssetHandle::assetWithType(a1, (const re::AssetType *)v2, 0);
  if (!v3)
  {
    v4 = *re::assetsLogObjects(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v6 = v4;
      v7 = re::AssetHandle::assetInfo(a1);
      if ((v7[17] & 1) != 0)
        v8 = (char *)v7[18];
      else
        v8 = (char *)v7 + 137;
      v9 = 136315138;
      v10 = v8;
      _os_log_error_impl(&dword_224FE9000, v6, OS_LOG_TYPE_ERROR, "Invalid asset: '%s'", (uint8_t *)&v9, 0xCu);

    }
  }
  return v3;
}

uint64_t re::TextureCompatibility::postProcessLoadedIBLAsset(re::TextureCompatibility *this, re::ImageBasedLightAsset *a2, const re::ImportGraphicsContext *a3)
{
  re::TextureCompatibility *v4;
  unint64_t v5;
  unint64_t v6;
  const char *v7;
  CFStringRef v8;
  int v9;
  unsigned __int8 v10;
  int v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  NSObject *v16;
  NSObject *v17;
  NSObject *v18;
  char *v19;
  unsigned __int8 v20;
  char *v21;
  unsigned __int8 v23;
  uint8_t buf[4];
  char *v25;
  __int16 v26;
  char *v27;
  uint64_t v28;

  v4 = this;
  v28 = *MEMORY[0x24BDAC8D0];
  v23 = 0;
  v5 = *((_QWORD *)this + 10);
  v6 = v5 >> 1;
  if ((v5 & 1) == 0)
    v6 = v5 >> 1;
  if (v6)
  {
    if ((v5 & 1) != 0)
      v7 = (const char *)*((_QWORD *)this + 11);
    else
      v7 = (char *)this + 81;
    v8 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x24BDBD240], v7, 0x8000100u, (CFAllocatorRef)*MEMORY[0x24BDBD258]);
    re::ColorHelpers::getColorGamutFromCGColorSpaceName(v8, (char *)&v23);
    CFRelease(v8);
    v9 = v23;
  }
  else
  {
    v9 = 0;
  }
  if (*((_BYTE *)a2 + 19))
    v10 = *((_BYTE *)a2 + 20);
  else
    v10 = 0;
  if (v9 != v10)
  {
    if (*((_QWORD *)v4 + 1))
    {
      this = (re::TextureCompatibility *)re::TextureCompatibility::convertTextureAssetColorSpace(v4, (uint64_t)a2, 4, 1, 0);
      v11 = (int)this;
    }
    else
    {
      v11 = 1;
    }
    if (*((_QWORD *)v4 + 4))
    {
      v12 = re::TextureCompatibility::convertTextureAssetColorSpace((re::TextureCompatibility *)((char *)v4 + 24), (uint64_t)a2, 4, 1, 0);
      if (!(_DWORD)v12)
        v11 = 0;
    }
    else
    {
      v13 = *re::assetsLogObjects(this);
      v12 = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
      if ((_DWORD)v12)
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_224FE9000, v13, OS_LOG_TYPE_DEFAULT, "Invalid ImageBasedLight asset: no diffuseTexture", buf, 2u);
      }
    }
    if (*((_QWORD *)v4 + 7))
    {
      v14 = re::TextureCompatibility::convertTextureAssetColorSpace((re::TextureCompatibility *)((char *)v4 + 48), (uint64_t)a2, 4, 1, 0);
      if ((v14 & 1) == 0)
      {
LABEL_27:
        v17 = *re::assetsLogObjects((re *)v14);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          v18 = v17;
          v19 = re::ColorHelpers::getColorGamutSerializationLiteral(re::ColorGamut const&)::kGamutToLiterals[v9];
          if (*((_BYTE *)a2 + 19))
            v20 = *((_BYTE *)a2 + 20);
          else
            v20 = 0;
          v21 = re::ColorHelpers::getColorGamutSerializationLiteral(re::ColorGamut const&)::kGamutToLiterals[v20];
          *(_DWORD *)buf = 136315394;
          v25 = v19;
          v26 = 2080;
          v27 = v21;
          _os_log_impl(&dword_224FE9000, v18, OS_LOG_TYPE_DEFAULT, "Failed to convert ImageBasedLight asset gamut from %s to %s", buf, 0x16u);

        }
        return 1;
      }
      v15 = re::AssetHandle::asset<re::TextureAsset>((re::TextureCompatibility *)((char *)v4 + 48));
      v14 = (uint64_t)re::DynamicString::operator=((re::TextureCompatibility *)((char *)v4 + 72), (re::DynamicString *)(v15 + 392));
    }
    else
    {
      v16 = *re::assetsLogObjects((re *)v12);
      v14 = os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT);
      if ((_DWORD)v14)
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_224FE9000, v16, OS_LOG_TYPE_DEFAULT, "Invalid ImageBasedLight asset: no specularTexture", buf, 2u);
      }
    }
    if (v11)
      return 1;
    goto LABEL_27;
  }
  return 1;
}

uint64_t re::TextureCompatibility::convertTextureAssetColorSpace(re::TextureAsset *a1, uint64_t a2, int a3, int a4, int a5)
{
  void *v10;
  uint64_t v11;
  uint64_t v12;
  id *v13;
  re *isValid;
  id v15;
  int v16;
  NSObject *v17;
  NSObject *v18;
  _QWORD *v19;
  char *v20;
  id v21;
  id v22;
  id v23;
  id v24;
  id v25;
  unsigned __int8 v26;
  id v27;
  id v28;
  re::TextureCompatibility *v30;
  re::ecs2::Scene *v31;
  const re::AssetManager *v32;
  const re::RenderManager *v33;
  BOOL v34;
  uint64_t v35[3];
  id v36;
  _QWORD v37[10];
  unsigned int v38;
  id v39;
  id v40;
  _BYTE v41[8];
  _QWORD v42[10];
  unsigned int v43;
  id v44;
  char v45;
  uint8_t buf[4];
  _BYTE v47[84];
  unsigned int v48;
  id v49;
  uint64_t v50;

  v50 = *MEMORY[0x24BDAC8D0];
  v10 = (void *)MEMORY[0x227694090]();
  v11 = re::AssetHandle::asset<re::TextureAsset>(a1);
  if (!v11
    || (v12 = v11,
        v13 = (id *)(v11 + 152),
        isValid = (re *)re::TextureData::isValid((re::TextureData *)(v11 + 152)),
        !(_DWORD)isValid))
  {
    v16 = 1;
LABEL_50:
    objc_autoreleasePoolPop(v10);
    return v16 == 0;
  }
  v41[0] = 0;
  v42[0] = 0;
  v43 = 0;
  v44 = 0;
  if (a4)
  {
    buf[0] = 0;
    *(_QWORD *)&v47[4] = 0;
    v48 = 0;
    v49 = 0;
    if (!*(_DWORD *)(v12 + 240))
    {
      re::TextureHandle::unsynchronizedMetalTexture((os_unfair_lock_s **)(v12 + 136), &v40);
      v15 = v40;
      if (v40)
        goto LABEL_54;
      if (a5)
      {
        if (*(_DWORD *)(v12 + 240))
          goto LABEL_51;
        re::TextureAsset::createTextureSRGBAdaptor((id *)a2, (id *)(v12 + 160), 0, &v36);
      }
      else
      {
        re::TextureHandle::unsynchronizedMetalTexture((os_unfair_lock_s **)(v12 + 48), &v36);
      }
      NS::SharedPtr<MTL::Texture>::operator=(&v40, &v36);
      if (v36)

      v15 = v40;
      if (v40)
      {
LABEL_54:
        if (*(_DWORD *)(v12 + 240))
          goto LABEL_51;
        if (v15 == *(id *)(v12 + 160))
          goto LABEL_30;
        v23 = *(id *)(v12 + 248);
        LOBYTE(v36) = 0;
        v37[0] = v40;
        v38 = 0;
        v39 = v23;
        buf[0] = 0;
        std::__variant_detail::__assignment<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>>::__generic_assign[abi:nn180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>,(std::__variant_detail::_Trait)1>>((uint64_t)&v47[4], (uint64_t)v37);
        v24 = v39;
        v39 = 0;
        v25 = v49;
        v49 = v24;

        if (v38 != -1)
          ((void (*)(char *, _QWORD *))*(&off_24ED42FE0 + v38))(&v45, v37);
        buf[0] = *(_BYTE *)v13;
        v15 = v40;
        v13 = (id *)buf;
        if (v40)
LABEL_30:

      }
    }
    if (!v13[12])
      re::TextureData::setColorSpace(v13, (__CFString *)*MEMORY[0x24BDBF270]);
    if (*(_BYTE *)(a2 + 19))
      v26 = *(_BYTE *)(a2 + 20);
    else
      v26 = 0;
    re::convertTextureColorSpace(v26, (uint64_t)v13, (uint64_t)&v36);
    v41[0] = (_BYTE)v36;
    std::__variant_detail::__assignment<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>>::__generic_assign[abi:nn180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>,(std::__variant_detail::_Trait)1>>((uint64_t)v42, (uint64_t)v37);
    v27 = v39;
    v39 = 0;
    v28 = v44;
    v44 = v27;

    if (v38 != -1)
      ((void (*)(id *, _QWORD *))*(&off_24ED42FE0 + v38))(&v40, v37);

    if (v48 != -1)
      ((void (*)(id *, _BYTE *))*(&off_24ED42FE0 + v48))(&v36, &v47[4]);
  }
  else
  {
    if (!a5)
      goto LABEL_47;
    if (*(_DWORD *)(v12 + 240))
    {
      v17 = *re::assetsLogObjects(isValid);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        v18 = v17;
        v19 = re::AssetHandle::assetInfo(a1);
        if ((v19[17] & 1) != 0)
          v20 = (char *)v19[18];
        else
          v20 = (char *)v19 + 137;
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)v47 = v20;
        _os_log_impl(&dword_224FE9000, v18, OS_LOG_TYPE_DEFAULT, "Texture %s conversion to sRGB transfer is not supported without Metal.", buf, 0xCu);

      }
    }
    else
    {
      re::TextureAsset::createTextureSRGBAdaptor((id *)a2, (id *)(v12 + 160), 1, &v36);
      buf[0] = 0;
      *(_QWORD *)&v47[4] = v36;
      v48 = 0;
      v49 = 0;
      v41[0] = 0;
      std::__variant_detail::__assignment<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>>::__generic_assign[abi:nn180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>,(std::__variant_detail::_Trait)1>>((uint64_t)v42, (uint64_t)&v47[4]);
      v21 = v49;
      v49 = 0;
      v22 = v44;
      v44 = v21;

      if (v48 != -1)
        ((void (*)(id *, _BYTE *))*(&off_24ED42FE0 + v48))(&v40, &v47[4]);
      v48 = -1;
      if (v36)

    }
  }
  if (!v43)
  {
    if (v42[0])
    {
LABEL_46:
      re::AssetHandle::AssetHandle((re::AssetHandle *)v35, a1);
      re::TextureAsset::setTextureAndSemantic_makeMutable((const re::ImportGraphicsContext *)a2, v35, (uint64_t)v41, a3, (__int128 *)(v12 + 8));
      re::AssetHandle::~AssetHandle((re::AssetHandle *)v35);
      v16 = 0;
      goto LABEL_48;
    }
LABEL_47:
    v16 = 1;
LABEL_48:

    if (v43 != -1)
      ((void (*)(uint8_t *, _QWORD *))*(&off_24ED42FE0 + v43))(buf, v42);
    goto LABEL_50;
  }
  if (v43 == 1)
  {
    v16 = 1;
    if (!v42[3] || !v42[0])
      goto LABEL_48;
    goto LABEL_46;
  }
LABEL_51:
  v30 = (re::TextureCompatibility *)std::__throw_bad_variant_access[abi:nn180100]();
  return re::TextureCompatibility::postProcessLoadedTextures(v30, v31, v32, v33, v34);
}

void re::TextureCompatibility::postProcessLoadedTextures(re::TextureCompatibility *this, re::ecs2::Scene *a2, const re::AssetManager *a3, const re::RenderManager *a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  const re::AssetHandle *v13;
  const re::AssetHandle *v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t i;
  unint64_t v22;
  uint64_t j;
  uint64_t v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int *v34;
  int v35;
  uint64_t v36;
  unsigned int v37;
  uint64_t v38;
  uint64_t v39;
  re::TextureCompatibility *v40;
  BOOL *v41;
  uint8_t v42;
  BOOL v43;
  unsigned int v44;
  unsigned int v45;
  uint64_t v46;
  uint64_t v47;
  int *v48;
  int v49;
  uint64_t v50;
  unsigned int v51;
  uint64_t v52;
  uint64_t v53;
  re::TextureCompatibility *v54;
  BOOL *v55;
  uint8_t v56;
  BOOL v57;
  unsigned int v58;
  unsigned int v59;
  uint64_t v60;
  uint64_t v61;
  _QWORD **v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t *v65;
  uint64_t *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  _DWORD *v70;
  uint64_t v71;
  unsigned int v72;
  uint64_t v73;
  uint64_t v74;
  const re::AssetHandle *v75;
  BOOL *v76;
  uint8_t v77;
  BOOL v78;
  unsigned int v79;
  unsigned int v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  _QWORD *v85;
  re::TextureCompatibility *v86;
  const re::ImportGraphicsContext *v87;
  re::TextureCompatibility *v88;
  const re::ImportGraphicsContext *v89;
  __n128 v90;
  uint64_t v91;
  re::AssetHandle *v92;
  re::AssetHandle *v93;
  re::AssetHandle *v94;
  re::AssetHandle *v95;
  uint64_t v96;
  BOOL v97;
  uint64_t v98;
  __int16 v99;
  id v100;
  id v101;
  __int128 *isValid;
  __int128 *v103;
  uint64_t v104;
  _QWORD *v105;
  re *v106;
  int v107;
  uint64_t v108;
  NSObject *v109;
  uint64_t v110;
  NSObject *v111;
  NSObject *v112;
  _QWORD *v113;
  char *v114;
  char *v115;
  uint64_t v116;
  re::AssetHandle *v117;
  uint64_t v118;
  re::AssetHandle *v119;
  uint64_t v120;
  re::ecs2::SceneComponentTable *v121;
  int v122;
  _QWORD *v123;
  _QWORD *v124;
  uint64_t v125;
  int v126;
  uint64_t v127;
  const re::AssetHandle *v128;
  unsigned int v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  _QWORD **v134;
  __int128 v136;
  _QWORD v137[2];
  uint64_t v138;
  int v139;
  re::AssetHandle *v140;
  id v141[4];
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  __int16 v145;
  uint64_t v146[3];
  char v147;
  BOOL v148[8];
  __int128 v149;
  __int128 v150;
  int v151;
  uint64_t v152;
  uint8_t v153[4];
  char *v154;
  uint8_t buf[16];
  __int128 v156;
  __int128 v157;
  uint64_t v158;
  uint64_t v159;

  v122 = (int)a4;
  v159 = *MEMORY[0x24BDAC8D0];
  re::ImportGraphicsContext::createFromRenderManager(a3, (re::ImportGraphicsContext *)v141);
  v140 = 0;
  v137[1] = 0;
  v138 = 0;
  v137[0] = 0;
  v139 = 0;
  LODWORD(v157) = 0;
  *(_OWORD *)buf = 0u;
  v156 = 0u;
  *(_QWORD *)((char *)&v157 + 4) = 0x7FFFFFFFLL;
  v151 = 0;
  v149 = 0u;
  v150 = 0u;
  v152 = 0x7FFFFFFFLL;
  v121 = (re::TextureCompatibility *)((char *)this + 200);
  v6 = re::ecs2::SceneComponentTable::get((re::TextureCompatibility *)((char *)this + 200), (const re::ecs2::ComponentTypeBase *)re::ecs2::ComponentImpl<re::ecs2::MeshComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType);
  v7 = *(_QWORD *)(v6 + 24);
  if (v7)
  {
    v125 = 0;
    v127 = 0;
    v126 = 0;
    v129 = 0;
    v132 = 0;
    v133 = 0;
    v8 = 0;
    v130 = 0;
    v9 = 0;
    v10 = *(_QWORD **)(v6 + 40);
    v123 = &v10[v7];
    do
    {
      v124 = v10;
      v11 = *v10;
      v12 = *(_QWORD *)(v11 + 72);
      if (v12)
      {
        v13 = *(const re::AssetHandle **)(v11 + 88);
        v14 = (const re::AssetHandle *)((char *)v13 + 24 * v12);
        v128 = v14;
        do
        {
          re::AssetHandle::AssetHandle((re::AssetHandle *)v146, v13);
          if (v146[1])
          {
            v15 = re::AssetHandle::asset<re::MaterialAsset>((re::MaterialAsset *)v146);
            if (v15)
            {
              v16 = v15;
              v17 = 0x94D049BB133111EBLL
                  * ((0xBF58476D1CE4E5B9 * (v15 ^ (v15 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v15 ^ (v15 >> 30))) >> 27));
              v18 = v17 ^ (v17 >> 31);
              v19 = v133;
              if ((_DWORD)v9)
              {
                v20 = v18 % v9;
                for (i = *(unsigned int *)(v130 + 4 * v20);
                      (_DWORD)i != 0x7FFFFFFF;
                      LODWORD(i) = *(_DWORD *)(v8 + 24 * i + 8) & 0x7FFFFFFF)
                {
                  if (*(_QWORD *)(v8 + 24 * i + 16) == v15)
                    goto LABEL_67;
                }
                v22 = v18 % v9;
                for (j = *(unsigned int *)(v132 + 4 * v20);
                      (_DWORD)j != 0x7FFFFFFF;
                      LODWORD(j) = *(_DWORD *)(v133 + 24 * j + 8) & 0x7FFFFFFF)
                {
                  if (*(_QWORD *)(v133 + 24 * j + 16) == v15)
                  {
                    v131 = v9;
                    goto LABEL_23;
                  }
                }
              }
              else
              {
                v22 = 0;
              }
              v24 = DWORD1(v157);
              if (DWORD1(v157) == 0x7FFFFFFF)
              {
                v25 = v129;
                v26 = v129;
                if (v129 == (_DWORD)v9)
                {
                  re::HashSetBase<re::internal::TimelineTree *,re::internal::TimelineTree *,re::internal::ValueAsKey<re::internal::TimelineTree *>,re::Hash<re::internal::TimelineTree *>,re::EqualTo<re::internal::TimelineTree *>,true,false>::setCapacity((uint64_t)buf, 2 * v126);
                  v9 = DWORD2(v156);
                  v26 = v157;
                  v22 = v18 % DWORD2(v156);
                  v19 = v156;
                  v125 = *(_QWORD *)&buf[8];
                }
                v27 = v26 + 1;
                LODWORD(v157) = v27;
                v24 = v129;
                v28 = *(_DWORD *)(v19 + 24 * v129 + 8);
                v29 = v125;
              }
              else
              {
                v28 = *(_DWORD *)(v133 + 24 * DWORD1(v157) + 8);
                DWORD1(v157) = v28 & 0x7FFFFFFF;
                v27 = v129;
                v25 = v24;
                v29 = v127;
              }
              v131 = v9;
              v30 = 3 * v24;
              *(_DWORD *)(v19 + 8 * v30 + 8) = v28 | 0x80000000;
              v132 = v29;
              v133 = v156;
              v31 = v156 + 8 * v30;
              *(_DWORD *)(v31 + 8) = *(_DWORD *)(v31 + 8) & 0x80000000 | *(_DWORD *)(v29 + 4 * v22);
              *(_QWORD *)v31 = v18;
              *(_QWORD *)(v31 + 16) = v16;
              *(_DWORD *)(v29 + 4 * v22) = v25;
              v126 = ++HIDWORD(v156);
              ++DWORD2(v157);
              v129 = v27;
              v127 = v29;
LABEL_23:
              v32 = *(unsigned int *)(v16 + 192);
              if ((_DWORD)v32)
              {
                v33 = 0;
                v34 = (int *)(*(_QWORD *)(v16 + 176) + 8);
                while (1)
                {
                  v35 = *v34;
                  v34 += 22;
                  if (v35 < 0)
                    break;
                  if (v32 == ++v33)
                  {
                    LODWORD(v33) = *(_DWORD *)(v16 + 192);
                    break;
                  }
                }
              }
              else
              {
                LODWORD(v33) = 0;
              }
              if ((_DWORD)v32 != (_DWORD)v33)
              {
                v36 = v33;
                v37 = *(_DWORD *)(v16 + 192);
                do
                {
                  v38 = *(_QWORD *)(v16 + 176);
                  v39 = v38 + 88 * v36;
                  if (*(_DWORD *)(v39 + 80) == 1)
                  {
                    v40 = (re::TextureCompatibility *)(v39 + 48);
                    v153[0] = 0;
                    v148[0] = 0;
                    re::StringID::StringID((re::StringID *)&v142, (const re::DynamicString *)(v38 + 88 * v36 + 16));
                    re::TextureCompatibility::updateLegacyTextureSemantic(v40, (const re::AssetHandle *)&v142, a2, (const re::AssetManager *)v141, (os_unfair_lock_s **)a3, (const re::RenderManager *)v153, v148, v41);
                    re::StringID::destroyString((re::StringID *)&v142);
                    v42 = v153[0];
                    v43 = v148[0];
                    if (v153[0] | v148[0])
                    {
                      *(_QWORD *)&v136 = re::AssetHandle::asset<re::TextureAsset>(v40);
                      if (!re::HashSetBase<re::internal::AssetEntry *,re::internal::AssetEntry *,re::internal::ValueAsKey<re::internal::AssetEntry *>,re::Hash<re::internal::AssetEntry *>,re::EqualTo<re::internal::AssetEntry *>,true,false>::contains((uint64_t)&v149, v136))
                      {
                        re::HashSetBase<re::internal::TimelineTree *,re::internal::TimelineTree *,re::internal::ValueAsKey<re::internal::TimelineTree *>,re::Hash<re::internal::TimelineTree *>,re::EqualTo<re::internal::TimelineTree *>,true,false>::add((uint64_t)&v149, (uint64_t *)&v136);
                        v142 = 0;
                        v143 = 0;
                        v144 = 0;
                        re::AssetHandle::operator=(&v142, (uint64_t *)v40);
                        LOBYTE(v145) = v42;
                        HIBYTE(v145) = v43;
                        re::DynamicArray<re::AssetLoadRequest::Data::LoadingAssetHandle>::add((uint64_t)v137, (re::AssetHandle *)&v142);
                        re::AssetHandle::~AssetHandle((re::AssetHandle *)&v142);
                      }
                    }
                    v37 = *(_DWORD *)(v16 + 192);
                  }
                  if (v37 <= (int)v33 + 1)
                    v44 = v33 + 1;
                  else
                    v44 = v37;
                  while (1)
                  {
                    v36 = (v33 + 1);
                    if (v44 - 1 == (_DWORD)v33)
                      break;
                    LODWORD(v33) = v33 + 1;
                    v45 = v36;
                    if ((*(_DWORD *)(*(_QWORD *)(v16 + 176) + 88 * v36 + 8) & 0x80000000) != 0)
                      goto LABEL_43;
                  }
                  v45 = v44;
LABEL_43:
                  LODWORD(v33) = v45;
                }
                while ((_DWORD)v32 != v45);
              }
              v46 = *(unsigned int *)(v16 + 240);
              if ((_DWORD)v46)
              {
                v47 = 0;
                v48 = (int *)(*(_QWORD *)(v16 + 224) + 8);
                v8 = v133;
                while (1)
                {
                  v49 = *v48;
                  v48 += 40;
                  if (v49 < 0)
                    break;
                  if (v46 == ++v47)
                  {
                    LODWORD(v47) = *(_DWORD *)(v16 + 240);
                    break;
                  }
                }
              }
              else
              {
                LODWORD(v47) = 0;
                v8 = v133;
              }
              if ((_DWORD)v46 != (_DWORD)v47)
              {
                v50 = v47;
                v51 = *(_DWORD *)(v16 + 240);
                do
                {
                  v52 = *(_QWORD *)(v16 + 224);
                  v53 = v52 + 160 * v50;
                  if (*(_DWORD *)(v53 + 80) == 1)
                  {
                    v54 = (re::TextureCompatibility *)(v53 + 48);
                    v153[0] = 0;
                    v148[0] = 0;
                    re::StringID::StringID((re::StringID *)&v142, (const re::DynamicString *)(v52 + 160 * v50 + 16));
                    re::TextureCompatibility::updateLegacyTextureSemantic(v54, (const re::AssetHandle *)&v142, a2, (const re::AssetManager *)v141, (os_unfair_lock_s **)a3, (const re::RenderManager *)v153, v148, v55);
                    re::StringID::destroyString((re::StringID *)&v142);
                    v56 = v153[0];
                    v57 = v148[0];
                    if (v153[0] | v148[0])
                    {
                      *(_QWORD *)&v136 = re::AssetHandle::asset<re::TextureAsset>(v54);
                      if (!re::HashSetBase<re::internal::AssetEntry *,re::internal::AssetEntry *,re::internal::ValueAsKey<re::internal::AssetEntry *>,re::Hash<re::internal::AssetEntry *>,re::EqualTo<re::internal::AssetEntry *>,true,false>::contains((uint64_t)&v149, v136))
                      {
                        re::HashSetBase<re::internal::TimelineTree *,re::internal::TimelineTree *,re::internal::ValueAsKey<re::internal::TimelineTree *>,re::Hash<re::internal::TimelineTree *>,re::EqualTo<re::internal::TimelineTree *>,true,false>::add((uint64_t)&v149, (uint64_t *)&v136);
                        v142 = 0;
                        v143 = 0;
                        v144 = 0;
                        re::AssetHandle::operator=(&v142, (uint64_t *)v54);
                        LOBYTE(v145) = v56;
                        HIBYTE(v145) = v57;
                        re::DynamicArray<re::AssetLoadRequest::Data::LoadingAssetHandle>::add((uint64_t)v137, (re::AssetHandle *)&v142);
                        re::AssetHandle::~AssetHandle((re::AssetHandle *)&v142);
                      }
                    }
                    v51 = *(_DWORD *)(v16 + 240);
                  }
                  if (v51 <= (int)v47 + 1)
                    v58 = v47 + 1;
                  else
                    v58 = v51;
                  while (1)
                  {
                    v50 = (v47 + 1);
                    if (v58 - 1 == (_DWORD)v47)
                      break;
                    LODWORD(v47) = v47 + 1;
                    v59 = v50;
                    if ((*(_DWORD *)(*(_QWORD *)(v16 + 224) + 160 * v50 + 8) & 0x80000000) != 0)
                      goto LABEL_64;
                  }
                  v59 = v58;
LABEL_64:
                  LODWORD(v47) = v59;
                }
                while ((_DWORD)v46 != v59);
                v8 = v133;
              }
              v9 = v131;
              v130 = v132;
LABEL_67:
              v14 = v128;
            }
          }
          re::AssetHandle::~AssetHandle((re::AssetHandle *)v146);
          v13 = (const re::AssetHandle *)((char *)v13 + 24);
        }
        while (v13 != v14);
      }
      v10 = v124 + 1;
    }
    while (v124 + 1 != v123);
  }
  v60 = re::ecs2::SceneComponentTable::get(v121, (const re::ecs2::ComponentTypeBase *)re::ecs2::ComponentImpl<re::ecs2::MaterialParameterBlockArrayComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType);
  v61 = *(_QWORD *)(v60 + 24);
  if (v61)
  {
    v62 = *(_QWORD ***)(v60 + 40);
    v134 = &v62[v61];
    do
    {
      v63 = (uint64_t)*v62;
      re::ecs2::MaterialParameterBlockArrayComponent::upgradeBlocksToBlockHandles(*v62);
      v64 = *(_QWORD *)(v63 + 48);
      if (v64)
      {
        v65 = *(uint64_t **)(v63 + 64);
        v66 = &v65[3 * v64];
        do
        {
          v67 = *v65;
          if (!*v65)
            v67 = v65[1];
          v68 = *(unsigned int *)(v67 + 336);
          if ((_DWORD)v68)
          {
            v69 = 0;
            v70 = *(_DWORD **)(v67 + 320);
            while ((*v70 & 0x80000000) == 0)
            {
              v70 += 80;
              if (v68 == ++v69)
              {
                LODWORD(v69) = *(_DWORD *)(v67 + 336);
                break;
              }
            }
          }
          else
          {
            LODWORD(v69) = 0;
          }
          if ((_DWORD)v68 != (_DWORD)v69)
          {
            v71 = v69;
            v72 = *(_DWORD *)(v67 + 336);
            do
            {
              v73 = *(_QWORD *)(v67 + 320);
              if (*(_BYTE *)(v73 + 320 * v71 + 32) == 64)
              {
                v74 = v73 + 320 * v71;
                v75 = (const re::AssetHandle *)(v74 + 8);
                re::AssetHandle::AssetHandle((re::AssetHandle *)v146, (const re::AssetHandle *)(v74 + 112));
                v153[0] = 0;
                v148[0] = 0;
                re::TextureCompatibility::updateLegacyTextureSemantic((re::TextureCompatibility *)v146, v75, a2, (const re::AssetManager *)v141, (os_unfair_lock_s **)a3, (const re::RenderManager *)v153, v148, v76);
                v77 = v153[0];
                v78 = v148[0];
                if (v153[0] | v148[0])
                {
                  *(_QWORD *)&v136 = re::AssetHandle::asset<re::TextureAsset>((re::TextureAsset *)v146);
                  if (!re::HashSetBase<re::internal::AssetEntry *,re::internal::AssetEntry *,re::internal::ValueAsKey<re::internal::AssetEntry *>,re::Hash<re::internal::AssetEntry *>,re::EqualTo<re::internal::AssetEntry *>,true,false>::contains((uint64_t)&v149, v136))
                  {
                    re::HashSetBase<re::internal::TimelineTree *,re::internal::TimelineTree *,re::internal::ValueAsKey<re::internal::TimelineTree *>,re::Hash<re::internal::TimelineTree *>,re::EqualTo<re::internal::TimelineTree *>,true,false>::add((uint64_t)&v149, (uint64_t *)&v136);
                    v142 = 0;
                    v143 = 0;
                    v144 = 0;
                    re::AssetHandle::operator=(&v142, v146);
                    LOBYTE(v145) = v77;
                    HIBYTE(v145) = v78;
                    re::DynamicArray<re::AssetLoadRequest::Data::LoadingAssetHandle>::add((uint64_t)v137, (re::AssetHandle *)&v142);
                    re::AssetHandle::~AssetHandle((re::AssetHandle *)&v142);
                  }
                }
                re::AssetHandle::~AssetHandle((re::AssetHandle *)v146);
                v72 = *(_DWORD *)(v67 + 336);
              }
              if (v72 <= (int)v69 + 1)
                v79 = v69 + 1;
              else
                v79 = v72;
              while (1)
              {
                v71 = (v69 + 1);
                if (v79 - 1 == (_DWORD)v69)
                  break;
                LODWORD(v69) = v69 + 1;
                v80 = v71;
                if ((*(_DWORD *)(*(_QWORD *)(v67 + 320) + 320 * v71) & 0x80000000) != 0)
                  goto LABEL_98;
              }
              v80 = v79;
LABEL_98:
              LODWORD(v69) = v80;
            }
            while ((_DWORD)v68 != v80);
          }
          v65 += 3;
        }
        while (v65 != v66);
      }
      ++v62;
    }
    while (v62 != v134);
  }
  v81 = re::ecs2::SceneComponentTable::get(v121, (const re::ecs2::ComponentTypeBase *)re::ecs2::ComponentImpl<re::ecs2::ImageBasedLightComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType);
  v82 = *(_QWORD *)(v81 + 24);
  if (v82)
  {
    v83 = *(_QWORD *)(v81 + 40);
    v84 = 8 * v82;
    do
    {
      v85 = *(_QWORD **)v83;
      if (*(_QWORD *)(*(_QWORD *)v83 + 96))
      {
        v86 = (re::TextureCompatibility *)re::AssetHandle::asset<re::ImageBasedLightAsset>((re::ImageBasedLightAsset *)(v85 + 11));
        re::TextureCompatibility::postProcessLoadedIBLAsset(v86, (re::ImageBasedLightAsset *)v141, v87);
      }
      if (v85[15])
      {
        v88 = (re::TextureCompatibility *)re::AssetHandle::asset<re::ImageBasedLightAsset>((re::ImageBasedLightAsset *)(v85 + 14));
        re::TextureCompatibility::postProcessLoadedIBLAsset(v88, (re::ImageBasedLightAsset *)v141, v89);
      }
      v83 += 8;
      v84 -= 8;
    }
    while (v84);
  }
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v149);
  v90.n128_f64[0] = re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)buf);
  v91 = v138;
  if (v138)
  {
    v92 = v140;
    v93 = (re::AssetHandle *)((char *)v140 + 32 * v138);
    v94 = v140;
    do
    {
      v95 = re::AssetHandle::AssetHandle((re::AssetHandle *)buf, v94);
      WORD4(v156) = *((_WORD *)v94 + 12);
      v96 = re::AssetHandle::asset<re::TextureAsset>(v95);
      re::TextureHandle::unsafeReleaseMetalTextures((os_unfair_lock_s **)(v96 + 48));
      if (BYTE8(v156))
        v97 = BYTE9(v156) == 0;
      else
        v97 = 1;
      if (v97)
        re::TextureHandle::unsafeReleaseMetalTextures((os_unfair_lock_s **)(v96 + 136));
      re::AssetHandle::~AssetHandle((re::AssetHandle *)buf);
      v94 = (re::AssetHandle *)((char *)v94 + 32);
    }
    while (v94 != v93);
    do
    {
      re::AssetHandle::AssetHandle((re::AssetHandle *)&v142, v92);
      v145 = *((_WORD *)v92 + 12);
      v98 = re::AssetHandle::asset<re::TextureAsset>((re::TextureAsset *)&v142);
      v158 = 0;
      v156 = 0u;
      v157 = 0u;
      *(_OWORD *)buf = 0u;
      MTLPixelFormatGetInfoForDevice();
      if (*(_DWORD *)(v98 + 240))
LABEL_154:
        std::__throw_bad_variant_access[abi:nn180100]();
      v99 = *(_WORD *)&buf[8];
      v100 = *(id *)(v98 + 160);
      re::TextureCompatibility::convertTextureAssetColorSpace((re::TextureAsset *)&v142, (uint64_t)v141, *(_DWORD *)(v98 + 388), v145, HIBYTE(v145));
      if (v100)

      if ((v99 & 0x400) == 0
        || !v122
        || !re::shouldASTCCompress(v98 + 152, *(unsigned int *)(v98 + 388), *(_DWORD *)(v98 + 20), (_DWORD *)(v98 + 24)))
      {
        goto LABEL_142;
      }
      if (*(_DWORD *)(v98 + 240))
        goto LABEL_154;
      v101 = *(id *)(v98 + 160);
      *(_QWORD *)&v136 = 1;
      BYTE8(v136) = 0;
      HIDWORD(v136) = 0;
      isValid = (__int128 *)re::AssetHandle::asset<re::TextureAsset>((re::TextureAsset *)&v142);
      *(_QWORD *)v148 = isValid;
      if (!isValid
        || (v103 = isValid,
            v104 = (uint64_t)isValid + 152,
            isValid = (__int128 *)re::TextureData::isValid((re::TextureData *)((char *)isValid + 152)),
            !(_DWORD)isValid))
      {
LABEL_135:
        v111 = *re::assetsLogObjects((re *)isValid);
        if (os_log_type_enabled(v111, OS_LOG_TYPE_DEFAULT))
        {
          v112 = v111;
          v113 = re::AssetHandle::assetInfo((re::AssetHandle *)&v142);
          if ((v113[17] & 1) != 0)
            v114 = (char *)v113[18];
          else
            v114 = (char *)v113 + 137;
          *(_DWORD *)buf = 136315138;
          *(_QWORD *)&buf[4] = v114;
          _os_log_impl(&dword_224FE9000, v112, OS_LOG_TYPE_DEFAULT, "Failed to recompress  %s", buf, 0xCu);

        }
        goto LABEL_140;
      }
      v147 = 0;
      v105 = operator new(0x28uLL);
      *v105 = 0x24ED43000;
      v105[1] = a3;
      v105[2] = v148;
      v105[3] = v141;
      v105[4] = &v147;
      *((_QWORD *)&v150 + 1) = v105;
      re::createCompressedTextureData(v104, *((_DWORD *)v103 + 97), &v136, v141, 0, (uint64_t)&v149, (uint64_t)buf);
      v107 = buf[0];
      if (buf[0])
      {
        v108 = *(_QWORD *)v148;
        *(_DWORD *)(*(_QWORD *)v148 + 20) = 4;
        *(_OWORD *)(v108 + 24) = v136;
        re::AssetHandle::AssetHandle((re::AssetHandle *)v146, (const re::AssetHandle *)&v142);
        re::TextureAsset::setTextureAndSemantic_makeMutable((const re::ImportGraphicsContext *)v141, v146, (uint64_t)&buf[8], *(_DWORD *)(*(_QWORD *)v148 + 388), (__int128 *)(*(_QWORD *)v148 + 8));
        re::AssetHandle::~AssetHandle((re::AssetHandle *)v146);
      }
      else
      {
        v109 = *re::assetsLogObjects(v106);
        if (os_log_type_enabled(v109, OS_LOG_TYPE_ERROR))
        {
          v115 = (char *)&v156 + 1;
          if ((v156 & 1) != 0)
            v115 = (char *)*((_QWORD *)&v156 + 1);
          *(_DWORD *)v153 = 136315138;
          v154 = v115;
          _os_log_error_impl(&dword_224FE9000, v109, OS_LOG_TYPE_ERROR, "Failed to compress texture: %s.", v153, 0xCu);
        }
      }
      re::Result<re::TextureData,re::DynamicString>::~Result((uint64_t)buf);
      isValid = (__int128 *)*((_QWORD *)&v150 + 1);
      if (*((__int128 **)&v150 + 1) == &v149)
      {
        isValid = &v149;
        v110 = 4;
      }
      else
      {
        if (!*((_QWORD *)&v150 + 1))
          goto LABEL_134;
        v110 = 5;
      }
      isValid = (__int128 *)(*(uint64_t (**)(void))(*(_QWORD *)isValid + 8 * v110))();
LABEL_134:
      if (!v107)
        goto LABEL_135;
LABEL_140:
      if (v101)

LABEL_142:
      re::AssetHandle::~AssetHandle((re::AssetHandle *)&v142);
      v92 = (re::AssetHandle *)((char *)v92 + 32);
    }
    while (v92 != v93);
  }
  v116 = v137[0];
  if (v137[0])
  {
    v117 = v140;
    if (v140)
    {
      if (v91)
      {
        v118 = 32 * v91;
        v119 = v140;
        do
        {
          re::AssetHandle::~AssetHandle(v119);
          v119 = (re::AssetHandle *)(v120 + 32);
          v118 -= 32;
        }
        while (v118);
      }
      (*(void (**)(uint64_t, re::AssetHandle *, __n128))(*(_QWORD *)v116 + 40))(v116, v117, v90);
    }
  }

}

void std::__function::__func<re::TextureCompatibility::compressTexture(re::AssetHandle &,re::ASTCCompressionOptions const&,re::ImportGraphicsContext const&,re::RenderManager const&)::$_0,std::allocator<re::TextureCompatibility::compressTexture(re::AssetHandle &,re::ASTCCompressionOptions const&,re::ImportGraphicsContext const&,re::RenderManager const&)::$_0>,void ()(void)>::~__func()
{
  JUMPOUT(0x2276933B8);
}

__n128 std::__function::__func<re::TextureCompatibility::compressTexture(re::AssetHandle &,re::ASTCCompressionOptions const&,re::ImportGraphicsContext const&,re::RenderManager const&)::$_0,std::allocator<re::TextureCompatibility::compressTexture(re::AssetHandle &,re::ASTCCompressionOptions const&,re::ImportGraphicsContext const&,re::RenderManager const&)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x28uLL);
  *(_QWORD *)v2 = &off_24ED43000;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 std::__function::__func<re::TextureCompatibility::compressTexture(re::AssetHandle &,re::ASTCCompressionOptions const&,re::ImportGraphicsContext const&,re::RenderManager const&)::$_0,std::allocator<re::TextureCompatibility::compressTexture(re::AssetHandle &,re::ASTCCompressionOptions const&,re::ImportGraphicsContext const&,re::RenderManager const&)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_24ED43000;
  result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<re::TextureCompatibility::compressTexture(re::AssetHandle &,re::ASTCCompressionOptions const&,re::ImportGraphicsContext const&,re::RenderManager const&)::$_0,std::allocator<re::TextureCompatibility::compressTexture(re::AssetHandle &,re::ASTCCompressionOptions const&,re::ImportGraphicsContext const&,re::RenderManager const&)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  void *v2;
  id v3;
  id v4;
  const re::ImportGraphicsContext *v5;
  uint64_t v6;
  _BYTE v7[8];
  id v8[10];
  unsigned int v9;
  id v10;
  char v11;

  v2 = (void *)MEMORY[0x227694090]();
  v3 = *(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 64) + 24);
  v4 = *(id *)(**(_QWORD **)(a1 + 16) + 248);
  v8[0] = v3;
  v9 = 0;
  v10 = v4;
  v5 = *(const re::ImportGraphicsContext **)(a1 + 24);
  v6 = **(_QWORD **)(a1 + 16);
  v7[0] = *(_BYTE *)(v6 + 152);
  re::TextureAsset::setTextureAndSemantic(v6, v5, (uint64_t)v7, *(_DWORD *)(v6 + 388));
  **(_BYTE **)(a1 + 32) = 1;

  if (v9 != -1)
    ((void (*)(char *, id *))*(&off_24ED42FE0 + v9))(&v11, v8);
  if (v3)

  objc_autoreleasePoolPop(v2);
}

uint64_t std::__function::__func<re::TextureCompatibility::compressTexture(re::AssetHandle &,re::ASTCCompressionOptions const&,re::ImportGraphicsContext const&,re::RenderManager const&)::$_0,std::allocator<re::TextureCompatibility::compressTexture(re::AssetHandle &,re::ASTCCompressionOptions const&,re::ImportGraphicsContext const&,re::RenderManager const&)::$_0>,void ()(void)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::TextureCompatibility::compressTexture(re::AssetHandle &,re::ASTCCompressionOptions const&,re::ImportGraphicsContext const&,re::RenderManager const&)::$_0,std::allocator<re::TextureCompatibility::compressTexture(re::AssetHandle &,re::ASTCCompressionOptions const&,re::ImportGraphicsContext const&,re::RenderManager const&)::$_0>,void ()(void)>::target_type()
{
}

re::DynamicString *re::FontCompiler::getCurrentCompiledAssetInfo@<X0>(re::FontCompiler *this@<X0>, uint64_t a2@<X8>)
{
  re::FontAsset *v3;
  const char *v5[2];

  *(_QWORD *)(a2 + 32) = 0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  v3 = (re::FontAsset *)re::DynamicString::setCapacity((_QWORD *)(a2 + 8), 0);
  *(_QWORD *)a2 = 0x100000001;
  v5[0] = (const char *)*re::FontAsset::assetType(v3);
  v5[1] = (const char *)strlen(v5[0]);
  return re::DynamicString::operator=((re::DynamicString *)(a2 + 8), (uint64_t)v5);
}

_QWORD *re::FontCompiler::getSupportedExtensions@<X0>(uint64_t a1@<X8>)
{
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  return re::DynamicArray<re::TransitionCondition *>::add((_QWORD *)a1, &re::FontCompiler::getSupportedExtensions(void)const::supportedExtensions);
}

__guard re::FontCompiler::assetIntrospectionType(re::FontCompiler *this)
{
  unsigned __int8 v1;
  __guard *v2;
  int v4;

  if ((v1 & 1) == 0)
  {
    if (v4)
    {
      re::introspect<re::FontAsset>(void)::info = re::introspect_FontAsset(0);
    }
  }
  return v2[317];
}

uint64_t re::FontCompiler::compile@<X0>(re::FontCompiler *this@<X0>, re::AssetUtilities *a2@<X1>, re::AssetSerializationScheme *a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t *v8;
  _anonymous_namespace_ *v9;
  unsigned __int8 v10;
  uint64_t result;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  _BYTE v19[8];
  uint64_t v20;
  char v21;

  v8 = re::globalAllocators(this);
  v9 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v8[2] + 32))(v8[2], 80, 8);
  *(_OWORD *)v9 = 0u;
  *((_OWORD *)v9 + 1) = 0u;
  *((_OWORD *)v9 + 2) = 0u;
  *((_OWORD *)v9 + 3) = 0u;
  *((_OWORD *)v9 + 4) = 0u;
  re::DynamicString::setCapacity(v9, 0);
  *((_OWORD *)v9 + 3) = 0u;
  *((_OWORD *)v9 + 4) = 0u;
  *((_OWORD *)v9 + 2) = 0u;
  v10 = atomic_load((unsigned __int8 *)&qword_254106150);
  if ((v10 & 1) == 0 && __cxa_guard_acquire(&qword_254106150))
  {
    _MergedGlobals_137 = re::introspect_FontFile(0);
    __cxa_guard_release(&qword_254106150);
  }
  result = re::AssetUtilities::readSourceJson(a2, (const char *)v9, _MergedGlobals_137, a3, (uint64_t)v19);
  if (v19[0])
  {
    *(_BYTE *)a4 = 1;
    *(_QWORD *)(a4 + 8) = v9;
  }
  else
  {
    re::internal::destroyPersistent<re::FontAsset>((re *)"compile", 58, v9);
    *(_QWORD *)&v15 = 100;
    *((_QWORD *)&v15 + 1) = &re::AssetErrorCategory(void)::instance;
    result = (uint64_t)re::DynamicString::DynamicString((re::DynamicString *)&v16, (const re::DynamicString *)&v20);
    v12 = v16;
    *(_OWORD *)(a4 + 8) = v15;
    v13 = v17;
    v14 = v18;
    *(_BYTE *)a4 = 0;
    *(_OWORD *)(a4 + 24) = v12;
    *(_QWORD *)(a4 + 40) = v13;
    *(_QWORD *)(a4 + 48) = v14;
    if (!v19[0])
    {
      result = v20;
      if (v20)
      {
        if ((v21 & 1) != 0)
          return (*(uint64_t (**)(void))(*(_QWORD *)v20 + 40))();
      }
    }
  }
  return result;
}

re *re::FontCompiler::deleteAsset(re::FontCompiler *this, _QWORD *a2)
{
  return re::internal::destroyPersistent<re::FontAsset>((re *)"deleteAsset", 68, a2);
}

re::DynamicString *re::FontLayoutCompiler::getCurrentCompiledAssetInfo@<X0>(re::FontLayoutCompiler *this@<X0>, uint64_t a2@<X8>)
{
  re::FontLayoutAsset *v3;
  const char *v5[2];

  *(_QWORD *)(a2 + 32) = 0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  v3 = (re::FontLayoutAsset *)re::DynamicString::setCapacity((_QWORD *)(a2 + 8), 0);
  *(_QWORD *)a2 = 0x100000001;
  v5[0] = (const char *)*re::FontLayoutAsset::assetType(v3);
  v5[1] = (const char *)strlen(v5[0]);
  return re::DynamicString::operator=((re::DynamicString *)(a2 + 8), (uint64_t)v5);
}

__guard re::FontLayoutCompiler::assetIntrospectionType(re::FontLayoutCompiler *this)
{
  unsigned __int8 v1;
  __guard *v2;
  int v4;

  if ((v1 & 1) == 0)
  {
    if (v4)
    {
      re::introspect<re::FontLayoutAsset>(void)::info = re::introspect_FontLayoutAsset(0);
    }
  }
  return v2[319];
}

_QWORD *re::FontLayoutCompiler::getSupportedExtensions@<X0>(uint64_t a1@<X8>)
{
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  return re::DynamicArray<re::TransitionCondition *>::add((_QWORD *)a1, &re::FontLayoutCompiler::getSupportedExtensions(void)const::supportedExtensions);
}

uint64_t re::FontLayoutCompiler::compile@<X0>(re::FontLayoutCompiler *this@<X0>, re::FileStreamReader *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t *v7;
  _OWORD *v8;
  uint64_t result;
  _BYTE v10[8];
  uint64_t v11;
  char v12;

  v7 = re::globalAllocators(this);
  v8 = (_OWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v7[2] + 32))(v7[2], 128, 8);
  *v8 = 0u;
  v8[1] = 0u;
  v8[2] = 0u;
  v8[3] = 0u;
  v8[4] = 0u;
  v8[5] = 0u;
  v8[6] = 0u;
  v8[7] = 0u;
  result = re::parseFontLayout(a2, (uint64_t)v8, (uint64_t)v10);
  if (!v10[0])
  {
    result = v11;
    if (v11)
    {
      if ((v12 & 1) != 0)
        result = (*(uint64_t (**)(void))(*(_QWORD *)v11 + 40))();
    }
  }
  *(_BYTE *)a3 = 1;
  *(_QWORD *)(a3 + 8) = v8;
  return result;
}

re *re::FontLayoutCompiler::deleteAsset(re::FontLayoutCompiler *this, re::FontLayoutAsset *a2)
{
  return re::internal::destroyPersistent<re::FontLayoutAsset>((re *)"deleteAsset", 115, a2);
}

void re::FontCompiler::~FontCompiler(re::FontCompiler *this)
{
  JUMPOUT(0x2276933B8);
}

void re::FontLayoutCompiler::~FontLayoutCompiler(re::FontLayoutCompiler *this)
{
  JUMPOUT(0x2276933B8);
}

re::DynamicString *re::ShaderLibraryCompiler::getCurrentCompiledAssetInfo@<X0>(re::ShaderLibraryCompiler *this@<X0>, uint64_t a2@<X8>)
{
  re::ShaderLibraryAsset *v3;
  const char *v5[2];

  *(_QWORD *)(a2 + 32) = 0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  v3 = (re::ShaderLibraryAsset *)re::DynamicString::setCapacity((_QWORD *)(a2 + 8), 0);
  *(_QWORD *)a2 = 0x100000001;
  v5[0] = (const char *)*re::ShaderLibraryAsset::assetType(v3);
  v5[1] = (const char *)strlen(v5[0]);
  return re::DynamicString::operator=((re::DynamicString *)(a2 + 8), (uint64_t)v5);
}

__guard re::ShaderLibraryCompiler::assetIntrospectionType(re::ShaderLibraryCompiler *this)
{
  unsigned __int8 v1;
  __guard *v2;
  int v4;

  if ((v1 & 1) == 0)
  {
    if (v4)
    {
      re::introspect<re::ShaderLibraryAsset>(void)::info = re::introspect_ShaderLibraryAsset(0);
    }
  }
  return v2[340];
}

_QWORD *re::ShaderLibraryCompiler::getSupportedExtensions@<X0>(uint64_t a1@<X8>)
{
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  re::DynamicArray<re::TransitionCondition *>::add((_QWORD *)a1, &re::ShaderLibraryCompiler::getSupportedExtensions(void)const::supportedExtensions);
  return re::DynamicArray<re::TransitionCondition *>::add((_QWORD *)a1, &off_255801778);
}

uint64_t *re::ShaderLibraryCompiler::compile@<X0>(re::ShaderLibraryCompiler *this@<X0>, char *a2@<X1>, uint64_t a3@<X8>)
{
  char *v7;
  _anonymous_namespace_ *v8;
  __darwin_ino64_t v9;
  const char *v10;
  re *v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  _anonymous_namespace_ *v17;
  const char *v18;
  __darwin_ino64_t v19;
  uint64_t *result;
  uint64_t *v21;
  uint64_t v22;
  const char *v23;
  uint64_t v24;
  stat v25;

  v22 = 0;
  v23 = 0;
  v24 = 0;
  re::DynamicString::setCapacity(&v21, 0);
  v7 = strrchr(a2, 46);
  v8 = (_anonymous_namespace_ *)strcmp(v7, ".hmshaderlib");
  if ((_DWORD)v8)
  {
    v9 = strlen(a2);
    *(_QWORD *)&v25.st_dev = a2;
    v25.st_ino = v9;
    re::DynamicString::operator=((re::DynamicString *)&v21, (uint64_t)&v25);
    if ((v22 & 1) != 0)
      v10 = v23;
    else
      v10 = (char *)&v22 + 1;
    v11 = (re *)stat(v10, &v25);
    if (!(_DWORD)v11)
    {
      v15 = re::globalAllocators(v11);
      v16 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v15[2] + 32))(v15[2], 88, 8);
      *(_OWORD *)(v16 + 56) = 0u;
      *(_OWORD *)(v16 + 40) = 0u;
      *(_OWORD *)(v16 + 72) = 0u;
      *(_QWORD *)v16 = &off_24ED31898;
      *(_OWORD *)(v16 + 24) = 0u;
      *(_OWORD *)(v16 + 8) = 0u;
      v17 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)(v16 + 8), 0);
      *(_OWORD *)(v16 + 56) = 0u;
      *(_OWORD *)(v16 + 40) = 0u;
      re::DynamicString::setCapacity((_QWORD *)(v16 + 40), 0);
      *(_QWORD *)(v16 + 80) = 0;
      if ((v22 & 1) != 0)
        v18 = v23;
      else
        v18 = (char *)&v22 + 1;
      v19 = strlen(v18);
      *(_QWORD *)&v25.st_dev = v18;
      v25.st_ino = v19;
      re::DynamicString::operator=((re::DynamicString *)(v16 + 40), (uint64_t)&v25);
      *(_BYTE *)a3 = 1;
      *(_QWORD *)(a3 + 8) = v16;
      goto LABEL_13;
    }
    re::DynamicString::format((re::DynamicString *)"failed to load shader library %s", (re::DynamicString *)&v25, a2);
  }
  else
  {
  }
  v12 = *(_OWORD *)&v25.st_dev;
  v13 = *(_QWORD *)&v25.st_uid;
  v14 = *(_QWORD *)&v25.st_rdev;
  *(_BYTE *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 100;
  *(_QWORD *)(a3 + 16) = &re::AssetErrorCategory(void)::instance;
  *(_OWORD *)(a3 + 24) = v12;
  *(_QWORD *)(a3 + 40) = v13;
  *(_QWORD *)(a3 + 48) = v14;
LABEL_13:
  result = v21;
  if (v21)
  {
    if ((v22 & 1) != 0)
      return (uint64_t *)(*(uint64_t (**)(void))(*v21 + 40))();
  }
  return result;
}

re *re::ShaderLibraryCompiler::deleteAsset(re *this, void (***a2)(_QWORD))
{
  uint64_t v3;

  if (a2)
  {
    v3 = re::globalAllocators(this)[2];
    (**a2)(a2);
    return (re *)(*(uint64_t (**)(uint64_t, void (***)(_QWORD)))(*(_QWORD *)v3 + 40))(v3, a2);
  }
  return this;
}

void re::ShaderLibraryCompiler::~ShaderLibraryCompiler(re::ShaderLibraryCompiler *this)
{
  JUMPOUT(0x2276933B8);
}

BOOL re::isPackageRelativePath(char *__s, size_t __n)
{
  char *v4;
  char *v5;

  if (!__n)
    return 0;
  if (__s[__n - 1] != 93)
    return 0;
  v4 = (char *)memchr(__s, 91, __n);
  if (v4)
    v5 = v4;
  else
    v5 = &__s[__n];
  return v5 - __s != __n;
}

uint64_t re::innerPathFromPackageRelativePath(uint64_t result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  _BOOL4 v8;
  int v9;
  BOOL v10;
  _BOOL4 v11;
  int v12;

  if (a2 && *(_BYTE *)(a2 + result - 1) == 93)
  {
    v2 = 0;
    v3 = (a2 - 1);
    v4 = 1;
    while (1)
    {
      v5 = v3 + v2;
      if ((int)v3 + (int)v2 < 1)
        break;
      v6 = v5 - 1;
      if (a2 <= v5 - 1)
      {
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v3 + v2 - 1, a2);
        _os_crash();
        __break(1u);
LABEL_17:
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v6, a2);
        result = _os_crash();
        __break(1u);
        return result;
      }
      v7 = *(unsigned __int8 *)(v3 + result - 1 + v2);
      if (v6)
      {
        v6 = (a2 - 3 + v2);
        if (a2 <= v6)
          goto LABEL_17;
        LODWORD(v6) = *(unsigned __int8 *)(result + v6);
      }
      v8 = v7 == 93;
      v9 = v7 == 91;
      v10 = (_DWORD)v6 == 92;
      v11 = v6 != 92;
      if (v10)
        v9 = 0;
      v12 = v9 << 31 >> 31;
      if (v8 && v11)
        v12 = 1;
      --v2;
      v4 += v12;
      if (!v4)
      {
        result += v3 + v2 + 1;
        return result;
      }
    }
  }
  return result;
}

char *re::fixAssetName@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  char *result;
  uint64_t i;
  unint64_t v5;
  re *v6;
  const char *v7;
  const char *v8;
  const char *v9;
  char *v10;
  char v11;

  re::replaceChar(*(re **)a1, *(const char **)(a1 + 8), 0x2Fu, (_QWORD *)a2);
  if ((*(_BYTE *)(a2 + 8) & 1) != 0)
    result = *(char **)(a2 + 16);
  else
    result = (char *)(a2 + 9);
  if (result)
  {
    result = strpbrk(result, ":<>|\"?*");
    if (result)
    {
      for (i = 0; i != 7; ++i)
      {
        v5 = *(_QWORD *)(a2 + 8);
        if ((v5 & 1) != 0)
          v6 = *(re **)(a2 + 16);
        else
          v6 = (re *)(a2 + 9);
        v7 = (const char *)(v5 >> 1);
        v8 = (const char *)(v5 >> 1);
        if ((*(_QWORD *)(a2 + 8) & 1) != 0)
          v9 = v7;
        else
          v9 = v8;
        re::replaceChar(v6, v9, re::AssetPath::invalidNameChars[i], &v10);
        re::DynamicString::operator=((re::DynamicString *)a2, (re::DynamicString *)&v10);
        result = v10;
        if (v10)
        {
          if ((v11 & 1) != 0)
            result = (char *)(*(uint64_t (**)(void))(*(_QWORD *)v10 + 40))();
        }
      }
    }
  }
  return result;
}

_BYTE *re::replaceChar@<X0>(re *this@<X0>, const char *a2@<X1>, unsigned __int8 a3@<W2>, _QWORD *a4@<X8>)
{
  _BYTE *result;
  const char *v9;
  int v10;
  char v11;

  a4[1] = 0;
  a4[2] = 0;
  a4[3] = 0;
  re::DynamicString::setCapacity(a4, 0);
  result = re::DynamicString::resize(a4, (unint64_t)a2, 0);
  if (a2)
  {
    v9 = 0;
    do
    {
      v10 = v9[(_QWORD)this];
      result = (_BYTE *)re::DynamicString::operator[]((uint64_t)a4, (unint64_t)v9);
      if (v10 == a3)
        v11 = 95;
      else
        v11 = v10;
      *result = v11;
      ++v9;
    }
    while (a2 != v9);
  }
  return result;
}

uint64_t re::ImportAssetTable::compiledAssetPath@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, re **a3@<X2>, re::DynamicString *a4@<X8>)
{
  _BYTE *v5;
  _BYTE *v6;
  uint64_t result;
  uint64_t v8;
  char v9;
  _BYTE v10[23];
  uint64_t v11;
  char v12;
  _BYTE v13[23];
  _QWORD v14[2];

  v14[0] = a1;
  v14[1] = a2;
  re::stringToLowerCase(*a3, (re::DynamicString *)&v11);
  re::fixAssetName((uint64_t)v14, (uint64_t)&v8);
  if ((v9 & 1) != 0)
    v5 = *(_BYTE **)&v10[7];
  else
    v5 = v10;
  if ((v12 & 1) != 0)
    v6 = *(_BYTE **)&v13[7];
  else
    v6 = v13;
  re::DynamicString::format((re::DynamicString *)"%s.compiled%s", a4, v5, v6);
  if (v8 && (v9 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v8 + 40))();
  result = v11;
  if (v11)
  {
    if ((v12 & 1) != 0)
      return (*(uint64_t (**)(void))(*(_QWORD *)v11 + 40))();
  }
  return result;
}

uint64_t re::setFunctionConstantsFromScene(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int *v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  int v11;
  int v12;

  v2 = result;
  v3 = *(unsigned int *)(result + 200);
  if ((_DWORD)v3)
  {
    v4 = 0;
    v5 = (int *)(*(_QWORD *)(result + 184) + 8);
    while (1)
    {
      v6 = *v5;
      v5 += 20;
      if (v6 < 0)
        break;
      if (v3 == ++v4)
      {
        LODWORD(v4) = *(_DWORD *)(result + 200);
        break;
      }
    }
  }
  else
  {
    LODWORD(v4) = 0;
  }
  if ((_DWORD)v3 != (_DWORD)v4)
  {
    v7 = v4;
    v8 = a2 + 296;
    v9 = *(_QWORD *)(result + 184);
    do
    {
      result = re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addInternal<re::DynamicString&>(v8, (re::DynamicString *)(v9 + 80 * v7 + 16), 2, (const re::DynamicString *)(v9 + 80 * v7 + 48));
      v10 = *(_DWORD *)(v2 + 200);
      v9 = *(_QWORD *)(v2 + 184);
      if (v10 <= (int)v4 + 1)
        v11 = v4 + 1;
      else
        v11 = *(_DWORD *)(v2 + 200);
      v12 = v4;
      while (1)
      {
        v7 = (v12 + 1);
        if (v11 - 1 == v12)
          break;
        ++v12;
        LODWORD(v4) = v7;
        if ((*(_DWORD *)(v9 + 80 * v7 + 8) & 0x80000000) != 0)
          goto LABEL_17;
      }
      LODWORD(v4) = v11;
LABEL_17:
      ;
    }
    while (v10 != (_DWORD)v4);
  }
  return result;
}

uint64_t re::setFunctionConstantsFromMaterial(uint64_t a1, int a2)
{
  _anonymous_namespace_ *v4;
  _anonymous_namespace_ *v5;
  _anonymous_namespace_ *v6;
  _anonymous_namespace_ *v7;
  _anonymous_namespace_ *v8;
  _anonymous_namespace_ *v9;
  _anonymous_namespace_ *v10;
  _anonymous_namespace_ *v11;
  _anonymous_namespace_ *v12;
  const char *v13;
  _anonymous_namespace_ *v14;
  uint64_t v15;
  uint64_t v16;
  int *v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  int *v25;
  int v26;
  _BOOL4 v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int v30;
  unsigned int v31;
  const char *v32;
  double v33;
  unsigned int v34;
  uint64_t v35;
  int *v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  const char *v40;
  _anonymous_namespace_ *v41;
  _anonymous_namespace_ *v42;
  _anonymous_namespace_ *v43;
  _anonymous_namespace_ *v44;
  _anonymous_namespace_ *v45;
  _anonymous_namespace_ *v46;
  _anonymous_namespace_ *v47;
  _anonymous_namespace_ *v48;
  _anonymous_namespace_ *v49;
  _anonymous_namespace_ *v50;
  _anonymous_namespace_ *v51;
  const char *v52;
  unsigned int v53;
  unsigned int v54;
  uint64_t v55;
  uint64_t v56;
  int *v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  const char *v64;
  const char *v65;
  const char *v66;
  const char *v67;
  const char *v68;
  _anonymous_namespace_ *v69;
  const char *v70;
  _anonymous_namespace_ *v71;
  unsigned int v72;
  unsigned int v73;
  double v74;
  uint64_t result;
  _anonymous_namespace_ *v76;
  char v77;
  const char *v78;
  char v79;
  _BYTE v80[23];
  __int128 v81;
  __int128 v82;
  unsigned int v83;
  uint64_t v84;
  uint64_t v85;
  char v86;

  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::DynamicString&>(a1 + 296, (re::DynamicString *)&v81, (const re::DynamicString *)&v85);
  v5 = (_anonymous_namespace_ *)v81;
  if ((_QWORD)v81 && (BYTE8(v81) & 1) != 0)
    v5 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v81 + 40))();
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::DynamicString&>(a1 + 296, (re::DynamicString *)&v81, (const re::DynamicString *)&v85);
  v6 = (_anonymous_namespace_ *)v81;
  if ((_QWORD)v81 && (BYTE8(v81) & 1) != 0)
    v6 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v81 + 40))();
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::DynamicString&>(a1 + 296, (re::DynamicString *)&v81, (const re::DynamicString *)&v85);
  v7 = (_anonymous_namespace_ *)v81;
  if ((_QWORD)v81 && (BYTE8(v81) & 1) != 0)
    v7 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v81 + 40))();
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::DynamicString&>(a1 + 296, (re::DynamicString *)&v81, (const re::DynamicString *)&v85);
  v8 = (_anonymous_namespace_ *)v81;
  if ((_QWORD)v81 && (BYTE8(v81) & 1) != 0)
    v8 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v81 + 40))();
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::DynamicString&>(a1 + 296, (re::DynamicString *)&v81, (const re::DynamicString *)&v85);
  v9 = (_anonymous_namespace_ *)v81;
  if ((_QWORD)v81 && (BYTE8(v81) & 1) != 0)
    v9 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v81 + 40))();
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::DynamicString&>(a1 + 296, (re::DynamicString *)&v81, (const re::DynamicString *)&v85);
  v10 = (_anonymous_namespace_ *)v81;
  if ((_QWORD)v81 && (BYTE8(v81) & 1) != 0)
    v10 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v81 + 40))();
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::DynamicString&>(a1 + 296, (re::DynamicString *)&v81, (const re::DynamicString *)&v85);
  v11 = (_anonymous_namespace_ *)v81;
  if ((_QWORD)v81 && (BYTE8(v81) & 1) != 0)
    v11 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v81 + 40))();
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::DynamicString&>(a1 + 296, (re::DynamicString *)&v81, (const re::DynamicString *)&v85);
  v12 = (_anonymous_namespace_ *)v81;
  if ((_QWORD)v81 && (BYTE8(v81) & 1) != 0)
    v12 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v81 + 40))();
  if (a2)
    v13 = "true";
  else
    v13 = "false";
  v78 = v13;
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addNew<char const*>(a1 + 296, (re::DynamicString *)&v81, &v78);
  v14 = (_anonymous_namespace_ *)v81;
  if ((_QWORD)v81 && (BYTE8(v81) & 1) != 0)
    v14 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v81 + 40))();
  v83 = 0;
  v81 = 0u;
  v82 = 0u;
  v84 = 0x7FFFFFFFLL;
  v15 = *(unsigned int *)(a1 + 184);
  if ((_DWORD)v15)
  {
    v16 = 0;
    v17 = (int *)(*(_QWORD *)(a1 + 168) + 8);
    while (1)
    {
      v18 = *v17;
      v17 += 22;
      if (v18 < 0)
        break;
      if (v15 == ++v16)
      {
        LODWORD(v16) = *(_DWORD *)(a1 + 184);
        break;
      }
    }
  }
  else
  {
    LODWORD(v16) = 0;
  }
  if ((_DWORD)v15 != (_DWORD)v16)
  {
    v19 = v16;
    v20 = *(_QWORD *)(a1 + 168);
    do
    {
      v14 = (_anonymous_namespace_ *)re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add((uint64_t)&v81, (re::DynamicString *)(v20 + 88 * v19 + 16));
      v20 = *(_QWORD *)(a1 + 168);
      if (*(_DWORD *)(a1 + 184) <= (v16 + 1))
        v21 = v16 + 1;
      else
        v21 = *(_DWORD *)(a1 + 184);
      v22 = v16;
      while (1)
      {
        v19 = (v22 + 1);
        if (v21 - 1 == v22)
          break;
        ++v22;
        LODWORD(v16) = v19;
        if ((*(_DWORD *)(v20 + 88 * v19 + 8) & 0x80000000) != 0)
          goto LABEL_47;
      }
      LODWORD(v16) = v21;
LABEL_47:
      ;
    }
    while ((_DWORD)v15 != (_DWORD)v16);
  }
  v23 = *(unsigned int *)(a1 + 232);
  if ((_DWORD)v23)
  {
    v24 = 0;
    v25 = (int *)(*(_QWORD *)(a1 + 216) + 8);
    while (1)
    {
      v26 = *v25;
      v25 += 40;
      if (v26 < 0)
        break;
      if (v23 == ++v24)
      {
        LODWORD(v24) = *(_DWORD *)(a1 + 232);
        break;
      }
    }
  }
  else
  {
    LODWORD(v24) = 0;
  }
  if ((_DWORD)v23 == (_DWORD)v24)
  {
    v27 = 0;
  }
  else
  {
    LOBYTE(v27) = 0;
    v28 = v24;
    v29 = *(_QWORD *)(a1 + 216);
    do
    {
      v14 = (_anonymous_namespace_ *)re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add((uint64_t)&v81, (re::DynamicString *)(v29 + 160 * v28 + 16));
      if (v27)
      {
        v27 = 1;
      }
      else if (*(_BYTE *)(v29 + 160 * v28 + 152))
      {
        v27 = *(_DWORD *)(v29 + 160 * v28 + 156) != 0;
      }
      else
      {
        v27 = 0;
      }
      v30 = *(_DWORD *)(a1 + 232);
      v29 = *(_QWORD *)(a1 + 216);
      if (v30 <= (int)v24 + 1)
        v30 = v24 + 1;
      while (1)
      {
        v28 = (v24 + 1);
        if (v30 - 1 == (_DWORD)v24)
          break;
        LODWORD(v24) = v24 + 1;
        v31 = v28;
        if ((*(_DWORD *)(v29 + 160 * v28 + 8) & 0x80000000) != 0)
          goto LABEL_68;
      }
      v31 = v30;
LABEL_68:
      LODWORD(v24) = v31;
    }
    while ((_DWORD)v23 != v31);
  }
  if (v27)
    v32 = "true";
  else
    v32 = "false";
  v76 = (_anonymous_namespace_ *)v32;
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addNew<char const*>(a1 + 296, (re::DynamicString *)&v78, (const char **)&v76);
  if (v78 && (v79 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v78 + 40))();
  v34 = v83;
  if (v83)
  {
    v35 = 0;
    v36 = (int *)(v82 + 8);
    while (1)
    {
      v37 = *v36;
      v36 += 12;
      if (v37 < 0)
        break;
      if (v83 == ++v35)
      {
        LODWORD(v35) = v83;
        break;
      }
    }
  }
  else
  {
    LODWORD(v35) = 0;
  }
  if (v83 != (_DWORD)v35)
  {
    v38 = v35;
    v39 = v82;
    do
    {
      re::DynamicString::DynamicString((re::DynamicString *)&v78, (const re::DynamicString *)(v39 + 48 * v38 + 16));
      if ((v79 & 1) != 0)
        v40 = *(const char **)&v80[7];
      else
        v40 = v80;
      v41 = (_anonymous_namespace_ *)strcmp(v40, "textureBaseColor");
      if ((_DWORD)v41)
      {
        v42 = (_anonymous_namespace_ *)strcmp(v40, "textureNormal");
        if ((_DWORD)v42)
        {
          v43 = (_anonymous_namespace_ *)strcmp(v40, "textureEmissive");
          if ((_DWORD)v43)
          {
            v44 = (_anonymous_namespace_ *)strcmp(v40, "textureRoughness");
            if ((_DWORD)v44)
            {
              v45 = (_anonymous_namespace_ *)strcmp(v40, "textureMetallic");
              if ((_DWORD)v45)
              {
                v46 = (_anonymous_namespace_ *)strcmp(v40, "textureAmbientOcclusion");
                if ((_DWORD)v46)
                {
                  v47 = (_anonymous_namespace_ *)strcmp(v40, "textureSpecular");
                  if ((_DWORD)v47)
                  {
                    v48 = (_anonymous_namespace_ *)strcmp(v40, "textureOpacity");
                    if ((_DWORD)v48)
                    {
                      v49 = (_anonymous_namespace_ *)strcmp(v40, "textureClearcoatRoughness");
                      if ((_DWORD)v49 && (v49 = (_anonymous_namespace_ *)strcmp(v40, "textureClearcoat"), (_DWORD)v49))
                      {
                        v50 = (_anonymous_namespace_ *)strcmp(v40, "textureRMAS");
                        if ((_DWORD)v50)
                          goto LABEL_113;
                        re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addInternal<char const(&)[6]>(a1 + 296, (re::DynamicString *)&v76, 2, "false");
                        v51 = v76;
                        if (v76 && (v77 & 1) != 0)
                          v51 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v76 + 40))();
                        v52 = "EnableSingleRMAS";
                      }
                      else
                      {
                        v52 = "EnableClearcoat";
                      }
                    }
                    else
                    {
                      v52 = "EnableOpacityMap";
                    }
                  }
                  else
                  {
                    v52 = "EnableSpecularMap";
                  }
                }
                else
                {
                  v52 = "EnableAOMap";
                }
              }
              else
              {
                v52 = "EnableMetallicMap";
              }
            }
            else
            {
              v52 = "EnableRoughnessMap";
            }
          }
          else
          {
            v52 = "EnableEmissiveMap";
          }
        }
        else
        {
          v52 = "EnableNormalMap";
        }
      }
      else
      {
        v52 = "EnableBaseColorMap";
      }
      re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addInternal<char const(&)[5]>(a1 + 296, (re::DynamicString *)&v76, 2, "true");
      if (v76 && (v77 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v76 + 40))();
LABEL_113:
      if (v78 && (v79 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v78 + 40))();
      v39 = v82;
      if (v83 <= (int)v35 + 1)
        v53 = v35 + 1;
      else
        v53 = v83;
      while (1)
      {
        v38 = (v35 + 1);
        if (v53 - 1 == (_DWORD)v35)
          break;
        LODWORD(v35) = v35 + 1;
        v54 = v38;
        if ((*(_DWORD *)(v82 + 48 * v38 + 8) & 0x80000000) != 0)
          goto LABEL_123;
      }
      v54 = v53;
LABEL_123:
      LODWORD(v35) = v54;
    }
    while (v34 != v54);
  }
  v55 = *(unsigned int *)(a1 + 88);
  if ((_DWORD)v55)
  {
    v56 = 0;
    v57 = (int *)(*(_QWORD *)(a1 + 72) + 8);
    while (1)
    {
      v58 = *v57;
      v57 += 20;
      if (v58 < 0)
        break;
      if (v55 == ++v56)
      {
        LODWORD(v56) = *(_DWORD *)(a1 + 88);
        break;
      }
    }
  }
  else
  {
    LODWORD(v56) = 0;
  }
  if ((_DWORD)v55 != (_DWORD)v56)
  {
    v59 = v56;
    v60 = *(_QWORD *)(a1 + 72);
    do
    {
      v61 = v60 + 80 * v59;
      v62 = v61 + 48;
      v63 = *(_QWORD *)(v61 + 24);
      v64 = *(const char **)(v61 + 32);
      v65 = (const char *)(v61 + 25);
      if ((v63 & 1) != 0)
        v66 = v64;
      else
        v66 = v65;
      if (!strcmp(v66, "clearcoatScale") || !strcmp(v66, "clearcoatRoughnessScale"))
      {
        if ((*(_BYTE *)(v60 + 80 * v59 + 56) & 1) != 0)
          v68 = *(const char **)(v60 + 80 * v59 + 64);
        else
          v68 = (const char *)(v62 + 9);
        *(float *)&v33 = strtof(v68, 0);
        if (*(float *)&v33 <= 0.0)
          goto LABEL_151;
        v70 = "EnableClearcoat";
      }
      else
      {
        if (strcmp(v66, "opacityThreshold"))
          goto LABEL_151;
        v67 = (*(_BYTE *)(v60 + 80 * v59 + 56) & 1) != 0
            ? *(const char **)(v60 + 80 * v59 + 64)
            : (const char *)(v62 + 9);
        *(float *)&v33 = strtof(v67, 0);
        if (*(float *)&v33 <= 0.0)
          goto LABEL_151;
        v70 = "EnableOpacityThreshold";
      }
      re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addInternal<char const(&)[5]>(a1 + 296, (re::DynamicString *)&v78, 2, "true");
      if (v78 && (v79 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v78 + 40))();
LABEL_151:
      v72 = *(_DWORD *)(a1 + 88);
      v60 = *(_QWORD *)(a1 + 72);
      if (v72 <= (int)v56 + 1)
        v72 = v56 + 1;
      while (1)
      {
        v59 = (v56 + 1);
        if (v72 - 1 == (_DWORD)v56)
          break;
        LODWORD(v56) = v56 + 1;
        v73 = v59;
        if ((*(_DWORD *)(v60 + 80 * v59 + 8) & 0x80000000) != 0)
          goto LABEL_157;
      }
      v73 = v72;
LABEL_157:
      LODWORD(v56) = v73;
    }
    while ((_DWORD)v55 != v73);
  }
  v74 = re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v81, v33);
  result = v85;
  if (v85)
  {
    if ((v86 & 1) != 0)
      return (*(uint64_t (**)(double))(*(_QWORD *)v85 + 40))(v74);
  }
  return result;
}

void re::createMaterialAssetsFromMaterialTable(uint64_t a1, uint64_t a2, _anonymous_namespace_ *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int *v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  _anonymous_namespace_ *v10;
  _anonymous_namespace_ *v11;
  int v12;
  _anonymous_namespace_ *v13;
  uint64_t v14;
  __CFString *v15;
  uint64_t v16;
  __CFString *v17;
  const char *v18;
  size_t v19;
  uint64_t v20;
  MDLMaterial *v21;
  int isMaterialTransparent;
  _anonymous_namespace_ *v23;
  unint64_t v24;
  unint64_t v25;
  re::AssetPath *v26;
  char *v27;
  re::MaterialAsset *v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t *v34;
  uint64_t v35;
  double v36;
  re::MaterialAsset *v37;
  _anonymous_namespace_ *v38;
  char *v39;
  uint64_t v40;
  uint64_t *v41;
  re::AssetPath *v42;
  double v43;
  double v44;
  unsigned int v45;
  unsigned int v46;
  re::AssetPath *v47;
  const char *v51;
  size_t v52;
  uint64_t v53;
  __int128 v54;
  __int128 v55;
  _BYTE v56[60];
  uint64_t v57;
  uint64_t v58[4];
  int v59;
  uint64_t v60;
  uint64_t v61[4];
  int v62;
  uint64_t v63;
  uint64_t v64[4];
  int v65;
  uint64_t v66;
  uint64_t v67[4];
  int v68;
  uint64_t v69;
  uint64_t v70[4];
  int v71;
  uint64_t v72;
  unsigned __int8 v73[24];
  uint64_t v74[3];
  int v75;
  uint64_t v76;

  v3 = a2;
  v4 = *(unsigned int *)(a2 + 32);
  if ((_DWORD)v4)
  {
    v5 = 0;
    v6 = (int *)(*(_QWORD *)(a2 + 16) + 8);
    while (1)
    {
      v7 = *v6;
      v6 += 18;
      if (v7 < 0)
        break;
      if (v4 == ++v5)
      {
        LODWORD(v5) = *(_DWORD *)(a2 + 32);
        break;
      }
    }
  }
  else
  {
    LODWORD(v5) = 0;
  }
  if ((_DWORD)v4 != (_DWORD)v5)
  {
    v8 = v5;
    v47 = (re::AssetPath *)(a1 + 57);
    v9 = *(_QWORD *)(a2 + 16);
    do
    {
      v10 = (_anonymous_namespace_ *)objc_retainAutorelease(*(id *)(v9 + 72 * v8 + 56));
      v11 = v10;
      if (v10)
      {
        v54 = 0u;
        v55 = 0u;
        re::DynamicString::setCapacity(&v54, 0);
        memset(v56, 0, sizeof(v56));
        v57 = 0x7FFFFFFFLL;
        memset(v58, 0, sizeof(v58));
        v59 = 0;
        v60 = 0x7FFFFFFFLL;
        memset(v61, 0, sizeof(v61));
        v62 = 0;
        v63 = 0x7FFFFFFFLL;
        memset(v64, 0, sizeof(v64));
        v65 = 0;
        v66 = 0x7FFFFFFFLL;
        v68 = 0;
        memset(v67, 0, sizeof(v67));
        v69 = 0x7FFFFFFFLL;
        memset(v70, 0, sizeof(v70));
        v71 = 0;
        v72 = 0x7FFFFFFFLL;
        v73[0] = 0;
        v73[2] = 0;
        v73[4] = 0;
        v73[6] = 0;
        v73[8] = 0;
        v73[10] = 0;
        v73[12] = 0;
        v73[14] = 0;
        v73[16] = 0;
        v76 = 0;
        v75 = 0;
        memset(v74, 0, sizeof(v74));
        v12 = *(unsigned __int8 *)(v9 + 72 * v8 + 68);
        v13 = v11;
        -[_anonymous_namespace_ name](v13, "name");
        v14 = objc_claimAutoreleasedReturnValue();
        if (v14)
          v15 = (__CFString *)v14;
        else
          v15 = &stru_24EDA2070;
        if (v12)
        {
          -[__CFString stringByAppendingString:](v15, "stringByAppendingString:", CFSTR("/subd"));
          v16 = objc_claimAutoreleasedReturnValue();

          v15 = (__CFString *)v16;
        }
        v17 = objc_retainAutorelease(v15);
        v18 = (const char *)-[__CFString UTF8String](v17, "UTF8String");
        v19 = strlen(v18);
        v51 = v18;
        v52 = v19;
        re::DynamicString::operator=((re::DynamicString *)&v54, (uint64_t)&v51);
        re::gatherMaterialConstants((uint64_t)&v56[24], v13);
        v20 = a1;
        re::setFunctionConstantsFromScene(a1, (uint64_t)&v54);
        re::setFunctionConstantsFromMaterial((uint64_t)&v54, 0);
        isMaterialTransparent = re::isMaterialTransparent(v13, v21);

        v24 = *(_QWORD *)(a1 + 56);
        if ((v24 & 1) != 0)
          v25 = v24 >> 1;
        else
          v25 = v24 >> 1;
        if (v25)
        {
          if ((*(_QWORD *)(a1 + 56) & 1) != 0)
            v26 = *(re::AssetPath **)(a1 + 64);
          else
            v26 = v47;
        }
        else
        {
          if (v12)
          {
            if (isMaterialTransparent)
              v27 = "engine:transparentPbrOpenSubdiv.rematerialdefinition";
            else
              v27 = "engine:pbrOpenSubdiv.rematerialdefinition";
          }
          else if (isMaterialTransparent)
          {
            v27 = "engine:transparentPbr.rematerialdefinition";
          }
          else
          {
            v27 = "engine:pbr.rematerialdefinition";
          }
          v20 = a1;
        }

        v29 = *(_QWORD *)(v20 + 104);
        if ((BYTE8(v54) & 1) != 0)
          v30 = (char *)v55;
        else
          v30 = (char *)&v54 + 9;
        if ((BYTE8(v54) & 1) != 0)
          v31 = *((_QWORD *)&v54 + 1) >> 1;
        else
          v31 = BYTE8(v54) >> 1;
        v32 = re::MaterialAsset::assetType(v28);
        v33 = re::ImportAssetTable::importedAsset(v29, (uint64_t)v30, v31, (re **)v32);
        if (!v33)
        {
          v34 = re::globalAllocators(0);
          v35 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v34[2] + 32))(v34[2], 1896, 8);
          bzero((void *)v35, 0x768uLL);
          re::MaterialAsset::MaterialAsset((re::MaterialAsset *)v35);
          re::DynamicString::operator=((re::DynamicString *)(v35 + 8), (re::DynamicString *)&v54);
          re::AssetHandle::operator=((uint64_t *)(v35 + 40), (uint64_t *)v56);
          re::MaterialParameterData::operator=(v35 + 64, (uint64_t)&v56[24]);
          re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v35 + 304, (uint64_t)v70);
          re::MaterialRenderFlags::operator=((_BYTE *)(v35 + 352), v73);
          v37 = (re::MaterialAsset *)re::DynamicArray<re::FunctionLink>::operator=(v35 + 376, v74, v36);
          v38 = *(_anonymous_namespace_ **)(v20 + 104);
          if ((BYTE8(v54) & 1) != 0)
            v39 = (char *)v55;
          else
            v39 = (char *)&v54 + 9;
          if ((BYTE8(v54) & 1) != 0)
            v40 = *((_QWORD *)&v54 + 1) >> 1;
          else
            v40 = BYTE8(v54) >> 1;
          v41 = re::MaterialAsset::assetType(v37);
          v33 = re::ImportAssetTable::addAsset(v38, (uint64_t)v39, v40, (void *)v35, (re **)v41);
        }
        v52 = 0;
        v53 = 0;
        v51 = 0;
        if ((*(_BYTE *)(v33 + 8) & 1) != 0)
          v42 = *(re::AssetPath **)(v33 + 16);
        else
          v42 = (re::AssetPath *)(v33 + 9);
        v3 = a2;
        re::DynamicArray<re::AssetHandle>::add(a3, (re::AssetHandle *)&v51);
        re::AssetHandle::~AssetHandle((re::AssetHandle *)&v51);
        re::DynamicArray<re::FunctionLink>::deinit((uint64_t)v74, v43);
        v44 = re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v70);
        re::HashTable<re::DynamicString,re::OptionalMaterialSamplerData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v67, v44);
        re::HashTable<re::DynamicString,re::MaterialTextureBlockData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v64);
        re::HashTable<re::DynamicString,re::MaterialTextureParam,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v61);
        re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v58);
        re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v56[24]);
        re::AssetHandle::~AssetHandle((re::AssetHandle *)v56);
        if ((_QWORD)v54 && (BYTE8(v54) & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v54 + 40))();
      }

      v45 = *(_DWORD *)(v3 + 32);
      v9 = *(_QWORD *)(v3 + 16);
      if (v45 <= (int)v5 + 1)
        v45 = v5 + 1;
      while (1)
      {
        v8 = (v5 + 1);
        if (v45 - 1 == (_DWORD)v5)
          break;
        LODWORD(v5) = v5 + 1;
        v46 = v8;
        if ((*(_DWORD *)(v9 + 72 * v8 + 8) & 0x80000000) != 0)
          goto LABEL_57;
      }
      v46 = v45;
LABEL_57:
      LODWORD(v5) = v46;
    }
    while ((_DWORD)v4 != v46);
  }
}

uint64_t re::ImportAssetTable::importedAsset(uint64_t a1, uint64_t a2, uint64_t a3, re **a4)
{
  uint64_t *v5;
  uint64_t v6;
  uint64_t v8;
  char v9;

  re::ImportAssetTable::compiledAssetPath(a2, a3, a4, (re::DynamicString *)&v8);
  v5 = (uint64_t *)re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet(a1 + 56, (uint64_t)&v8);
  if (v5)
    v6 = *v5;
  else
    v6 = 0;
  if (v8 && (v9 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v8 + 40))();
  return v6;
}

uint64_t re::ImportAssetTable::addAsset(_anonymous_namespace_ *a1, uint64_t a2, uint64_t a3, void *a4, re **a5)
{
  size_t v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const char *v14;
  size_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v20;
  _QWORD v21[3];
  uint64_t *v22;
  unint64_t v23;
  char *v24;
  uint64_t v25;
  _QWORD v26[2];

  v26[0] = a2;
  v26[1] = a3;
  v24 = 0;
  v25 = 0;
  if (a3)
    v9 = a3 + 1;
  else
    v9 = 0;
  v23 = 0;
  re::DynamicString::setCapacity(&v22, v9);
  re::DynamicString::operator=((re::DynamicString *)&v22, (uint64_t)v26);
  if ((v23 & 1) != 0)
    v10 = v24;
  else
    v10 = (char *)&v23 + 1;
  if ((v23 & 1) != 0)
    v11 = v23 >> 1;
  else
    v11 = v23 >> 1;
  re::ImportAssetTable::compiledAssetPath((uint64_t)v10, v11, a5, (re::DynamicString *)&v20);
  re::DynamicString::operator=((re::DynamicString *)&v22, (re::DynamicString *)&v20);
  if (v20 && (v21[0] & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v20 + 40))();
  if (re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)a1 + 56, (uint64_t)&v22))
  {
    v12 = 1;
    do
    {
      re::DynamicString::operator=((re::DynamicString *)&v22, (uint64_t)v26);
      re::DynamicString::format((re::DynamicString *)"_%02d", (re::DynamicString *)&v20, v12);
      v13 = v21[0] & 1;
      if ((v21[0] & 1) != 0)
        v14 = (const char *)v21[1];
      else
        v14 = (char *)v21 + 1;
      if ((v21[0] & 1) != 0)
        v15 = v21[0] >> 1;
      else
        v15 = LOBYTE(v21[0]) >> 1;
      re::DynamicString::append((re::DynamicString *)&v22, v14, v15);
      if (v20 && v13)
        (*(void (**)(void))(*(_QWORD *)v20 + 40))();
      if ((v23 & 1) != 0)
        v16 = v24;
      else
        v16 = (char *)&v23 + 1;
      if ((v23 & 1) != 0)
        v17 = v23 >> 1;
      else
        v17 = v23 >> 1;
      re::ImportAssetTable::compiledAssetPath((uint64_t)v16, v17, a5, (re::DynamicString *)&v20);
      re::DynamicString::operator=((re::DynamicString *)&v22, (re::DynamicString *)&v20);
      if (v20 && (v21[0] & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v20 + 40))();
      v12 = (v12 + 1);
    }
    while (re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)a1 + 56, (uint64_t)&v22));
  }
  v18 = re::ImportAssetTable::addAssetWithPath(a1, (const re::DynamicString *)&v22, a4, (const re::AssetType *)a5);
  if (v22 && (v23 & 1) != 0)
    (*(void (**)(void))(*v22 + 40))();
  return v18;
}

void re::createMaterialAssetsFromMaterialTableUSK(_QWORD *a1, uint64_t a2, _anonymous_namespace_ *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int *v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  id v16;
  void *v17;
  int v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t v22;
  const char *v23;
  size_t v24;
  _anonymous_namespace_ *v25;
  void *v26;
  void *v27;
  const char *v28;
  size_t v29;
  uint64_t v30;
  int *v31;
  uint64_t v32;
  int v33;
  void *v34;
  NSDictionary *v35;
  uint64_t v36;
  float *v37;
  uint64_t isMaterialAlphaCutout;
  int v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  id v44;
  uint64_t ResourcePathAndColorSpaceForTextureProperty;
  void *v46;
  id v47;
  int v48;
  void *v49;
  size_t v50;
  unsigned int v51;
  void **v52;
  void **v53;
  size_t v54;
  uint64_t v55;
  void **v56;
  char **v57;
  uint64_t v58;
  size_t *v59;
  re *v60;
  const char *v61;
  size_t v62;
  NSObject *v63;
  void *v64;
  void *v65;
  int v66;
  void *v67;
  void *v68;
  void *v69;
  void *v70;
  void *v71;
  void *v72;
  int v73;
  void *v74;
  void *v75;
  double v76;
  void *v77;
  float v78;
  double v79;
  void *v80;
  uint64_t v81;
  uint64_t v82;
  float32x4_t v83;
  float v84;
  __float2 v85;
  uint64_t v86;
  unint64_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  uint64_t v91;
  __int128 v92;
  int32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  uint64_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  void *v101;
  void *v102;
  void *v103;
  void *v104;
  void *v105;
  void *v106;
  uint64_t v107;
  __int128 v108;
  void *v109;
  int v110;
  void *v111;
  void *v112;
  void *v113;
  void *v114;
  const char *v115;
  size_t v116;
  uint64_t v117;
  const char *v118;
  const char *v119;
  _anonymous_namespace_ *v120;
  _anonymous_namespace_ *v121;
  void *v122;
  void *v123;
  int v124;
  void *v125;
  void *v126;
  void *v127;
  void *v128;
  void *v129;
  int v130;
  void *v131;
  void *v132;
  void *v133;
  int v134;
  void *v135;
  void *v136;
  void *v137;
  int v138;
  id v139;
  const char *v140;
  re::TextureAsset *v141;
  uint64_t *v142;
  _anonymous_namespace_ *v143;
  uint64_t v144;
  re::TextureAsset *v145;
  uint64_t *v146;
  re::DynamicString *v147;
  uint64_t isPackageRelativePath;
  re::Allocator *v149;
  uint64_t v150;
  re *v151;
  re::TextureAsset *TextureAsset;
  re::ImportAssetTable *v153;
  uint64_t *v154;
  re::DynamicString *v155;
  id v156;
  char *v157;
  size_t v158;
  uint64_t v159;
  NSObject *v160;
  NSObject *v161;
  unint64_t v162;
  unint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  int v170;
  int *v171;
  int v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  int v177;
  uint64_t v178;
  re::DynamicString *v179;
  unint64_t v180;
  unint64_t v181;
  unint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  _anonymous_namespace_ *v186;
  _anonymous_namespace_ *v187;
  unint64_t v188;
  unint64_t v189;
  unint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  _anonymous_namespace_ *v194;
  _anonymous_namespace_ *v195;
  _anonymous_namespace_ *v196;
  const char *v197;
  _anonymous_namespace_ *v198;
  unint64_t v199;
  unint64_t v200;
  unint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  unint64_t v205;
  unint64_t v206;
  unint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  unsigned int v211;
  uint64_t v212;
  int v213;
  unsigned int v214;
  unsigned int v215;
  id v216;
  uint64_t v217;
  uint8_t *v218;
  re *v219;
  int v220;
  _BOOL4 v221;
  NSObject *v222;
  const char *v223;
  re *v224;
  _BOOL4 v225;
  NSObject *v226;
  const char *v227;
  void *v228;
  void *v229;
  char *v230;
  unint64_t v231;
  unint64_t v232;
  char *v233;
  double v234;
  re::MaterialAsset *v235;
  uint64_t v236;
  char *v237;
  uint64_t v238;
  uint64_t *v239;
  uint64_t v240;
  uint64_t *v241;
  uint64_t v242;
  double v243;
  re::MaterialAsset *v244;
  _anonymous_namespace_ *v245;
  char *v246;
  uint64_t v247;
  uint64_t *v248;
  re::AssetPath *v249;
  double v250;
  double v251;
  unsigned int v252;
  int v253;
  unsigned int v254;
  NSObject *v255;
  NSObject *log;
  int loga;
  char *v258;
  int v259;
  int v262;
  int32x4_t v263;
  uint64_t v264;
  void *v265;
  id v266;
  __CFString *v267;
  uint64_t v268;
  void *v269;
  void *v270;
  int v271;
  char v272;
  id v273;
  void *v274;
  int v275;
  void *v276;
  int v277;
  _QWORD *v278;
  char v279;
  uint64_t v280;
  uint64_t v282;
  uint64_t v283;
  void *v284;
  _BOOL4 v285;
  __int128 v286;
  double v287;
  uint64_t v288;
  unsigned int v289;
  id v290;
  id v291;
  __int128 v292;
  __int128 v293;
  _BYTE v294[60];
  uint64_t v295;
  uint64_t v296[4];
  int v297;
  uint64_t v298;
  __int128 v299;
  __int128 v300;
  int v301;
  uint64_t v302;
  __int128 v303;
  __int128 v304;
  int v305;
  uint64_t v306;
  __int128 v307;
  __int128 v308;
  int v309;
  uint64_t v310;
  uint64_t v311[4];
  int v312;
  uint64_t v313;
  unsigned __int8 v314[24];
  uint64_t v315[3];
  int v316;
  uint64_t v317;
  _anonymous_namespace_ *v318;
  char v319;
  _OWORD v320[2];
  _OWORD v321[2];
  __int128 v322[2];
  _OWORD v323[2];
  uint64_t v324;
  char v325;
  void *__p[2];
  __int128 v327;
  __int128 v328;
  char v329;
  char v330;
  char v331;
  char v332;
  char v333;
  char v334;
  __int128 v335;
  __int128 v336;
  uint64_t v337;
  char v338;
  _BYTE v339[23];
  __int128 v340;
  __int128 v341;
  unsigned int v342;
  uint64_t v343;
  uint64_t v344[2];
  uint64_t v345;
  unsigned int v346;
  id v347;
  id v348;
  id v349;
  id v350;
  unsigned __int8 v351;
  _BYTE buf[12];
  __int16 v353;
  uint8_t *v354;
  unsigned int v355;
  unsigned int v356;
  id v357;
  uint8_t v358[32];
  _BYTE v359[24];
  __int128 v360;
  __int128 v361;
  __int128 v362;
  id v363;
  uint64_t v364;

  v3 = a2;
  v364 = *MEMORY[0x24BDAC8D0];
  v4 = *(unsigned int *)(a2 + 32);
  if ((_DWORD)v4)
  {
    v5 = 0;
    v6 = (int *)(*(_QWORD *)(a2 + 16) + 8);
    while (1)
    {
      v7 = *v6;
      v6 += 18;
      if (v7 < 0)
        break;
      if (v4 == ++v5)
      {
        LODWORD(v5) = *(_DWORD *)(a2 + 32);
        break;
      }
    }
  }
  else
  {
    LODWORD(v5) = 0;
  }
  if ((_DWORD)v4 != (_DWORD)v5)
  {
    v8 = v5;
    v282 = *MEMORY[0x24BEBEE60];
    v278 = a1 + 14;
    v258 = (char *)a1 + 57;
    v9 = *(_QWORD *)(a2 + 16);
    __asm
    {
      FMOV            V11.2S, #1.0
      FMOV            V3.4S, #1.0
    }
    v263 = vdupq_lane_s32(0, 0);
    v264 = *((_QWORD *)&_Q3 + 1);
    v259 = *(_DWORD *)(a2 + 32);
    while (1)
    {
      v271 = v5;
      v16 = objc_retainAutorelease(*(id *)(v9 + 72 * v8 + 56));
      if (v16)
        break;
LABEL_332:

      v252 = *(_DWORD *)(v3 + 32);
      v9 = *(_QWORD *)(v3 + 16);
      v253 = v271;
      if (v252 <= v271 + 1)
        v252 = v271 + 1;
      while (1)
      {
        v8 = (v253 + 1);
        if (v252 - 1 == v253)
          break;
        ++v253;
        v254 = v8;
        if ((*(_DWORD *)(v9 + 72 * v8 + 8) & 0x80000000) != 0)
          goto LABEL_338;
      }
      v254 = v252;
LABEL_338:
      LODWORD(v5) = v254;
      if ((_DWORD)v4 == v254)
        return;
    }
    v292 = 0u;
    v293 = 0u;
    v17 = v16;
    re::DynamicString::setCapacity(&v292, 0);
    memset(v294, 0, sizeof(v294));
    v295 = 0x7FFFFFFFLL;
    memset(v296, 0, sizeof(v296));
    v297 = 0;
    v298 = 0x7FFFFFFFLL;
    v299 = 0u;
    v300 = 0u;
    v301 = 0;
    v302 = 0x7FFFFFFFLL;
    v303 = 0u;
    v304 = 0u;
    v305 = 0;
    v306 = 0x7FFFFFFFLL;
    v309 = 0;
    v307 = 0u;
    v308 = 0u;
    v310 = 0x7FFFFFFFLL;
    memset(v311, 0, sizeof(v311));
    v312 = 0;
    v313 = 0x7FFFFFFFLL;
    v314[0] = 0;
    v314[2] = 0;
    v314[4] = 0;
    v314[6] = 0;
    v314[8] = 0;
    v314[10] = 0;
    v314[12] = 0;
    v314[14] = 0;
    v314[16] = 0;
    v317 = 0;
    v316 = 0;
    memset(v315, 0, sizeof(v315));
    v18 = *(unsigned __int8 *)(v9 + 72 * v8 + 68);
    v266 = v17;
    v273 = v17;
    objc_msgSend(v273, "path");
    v19 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v19, "stringValue");
    v20 = objc_claimAutoreleasedReturnValue();

    if (v20)
      v21 = (__CFString *)v20;
    else
      v21 = &stru_24EDA2070;
    v262 = v18;
    if (v18)
    {
      -[__CFString stringByAppendingString:](v21, "stringByAppendingString:", CFSTR("/subd"));
      v22 = objc_claimAutoreleasedReturnValue();

      v21 = (__CFString *)v22;
    }
    v267 = objc_retainAutorelease(v21);
    v23 = (const char *)-[__CFString UTF8String](v267, "UTF8String");
    v24 = strlen(v23);
    *(_QWORD *)v358 = v23;
    *(_QWORD *)&v358[8] = v24;
    re::DynamicString::operator=((re::DynamicString *)&v292, (uint64_t)v358);
    re::gatherMaterialTextureProperties((uint64_t)v273, (uint64_t)v344);
    v342 = 0;
    v341 = 0u;
    v340 = 0u;
    v343 = 0x7FFFFFFFLL;
    objc_msgSend(MEMORY[0x24BEBED10], "firstUVMeshAttributeNameInMaterial:", v273);
    v26 = (void *)objc_claimAutoreleasedReturnValue();
    v27 = v26;
    if (v26)
    {
      v28 = (const char *)objc_msgSend(objc_retainAutorelease(v26), "UTF8String");
      v29 = strlen(v28);
      *(_QWORD *)v358 = v28;
      *(_QWORD *)&v358[8] = v29;
      re::DynamicString::operator=((re::DynamicString *)&v337, (uint64_t)v358);
    }
    v289 = v346;
    v30 = 0;
    if (v346)
    {
      v31 = (int *)(v345 + 8);
      v32 = (uint64_t)a1;
      do
      {
        v33 = *v31;
        v31 += 14;
        if (v33 < 0)
          goto LABEL_23;
        ++v30;
      }
      while (v346 != v30);
      LODWORD(v30) = v346;
    }
    else
    {
      v32 = (uint64_t)a1;
    }
LABEL_23:
    v265 = v27;
    if (v346 == (_DWORD)v30)
    {
      v272 = 0;
      goto LABEL_25;
    }
    v279 = 0;
    v272 = 0;
    v41 = v30;
    v42 = v345;
LABEL_28:
    v43 = v42 + 56 * v41;
    v44 = *(id *)(v43 + 48);
    ResourcePathAndColorSpaceForTextureProperty = (uint64_t)re::getResourcePathAndColorSpaceForTextureProperty(v44);
    if (!ResourcePathAndColorSpaceForTextureProperty)
      goto LABEL_273;
    v290 = (id)ResourcePathAndColorSpaceForTextureProperty;
    v280 = v43;
    if (*(_BYTE *)(v32 + 163))
      goto LABEL_69;
    objc_msgSend((id)ResourcePathAndColorSpaceForTextureProperty, "path");
    v46 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v46, "pathExtension");
    v47 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
    std::string::basic_string[abi:nn180100]<0>(__p, (char *)objc_msgSend(v47, "UTF8String"));

    v48 = SBYTE7(v327);
    v49 = __p[1];
    if ((SBYTE7(v327) & 0x80u) == 0)
      v49 = (void *)BYTE7(v327);
    if (v49)
    {
      v50 = 0;
      v51 = SBYTE7(v327) >> 31;
      do
      {
        if ((v51 & 1) != 0)
          v52 = (void **)__p[0];
        else
          v52 = __p;
        ResourcePathAndColorSpaceForTextureProperty = __tolower(*((char *)v52 + v50));
        if ((SBYTE7(v327) & 0x80u) == 0)
          v53 = __p;
        else
          v53 = (void **)__p[0];
        *((_BYTE *)v53 + v50++) = ResourcePathAndColorSpaceForTextureProperty;
        v48 = SBYTE7(v327);
        v51 = SBYTE7(v327) >> 31;
        if ((SBYTE7(v327) & 0x80u) == 0)
          v54 = BYTE7(v327);
        else
          v54 = (size_t)__p[1];
      }
      while (v54 > v50);
    }
    else
    {
      v54 = 0;
    }
    v55 = 0;
    if (v48 >= 0)
      v56 = __p;
    else
      v56 = (void **)__p[0];
    while (1)
    {
      if ((&re::convertUSKMaterialNodeToMaterialFile(re::SceneImportOperation &,USKNode *,re::MaterialFile &,BOOL)::allowedExtensions)[v55 + 1] == (char *)v54)
      {
        ResourcePathAndColorSpaceForTextureProperty = memcmp((&re::convertUSKMaterialNodeToMaterialFile(re::SceneImportOperation &,USKNode *,re::MaterialFile &,BOOL)::allowedExtensions)[v55], v56, v54);
        if (!(_DWORD)ResourcePathAndColorSpaceForTextureProperty)
          break;
      }
      v55 += 2;
      if (v55 == 8)
      {
        v57 = (char **)&off_24ED43218;
        goto LABEL_54;
      }
    }
    v57 = &(&re::convertUSKMaterialNodeToMaterialFile(re::SceneImportOperation &,USKNode *,re::MaterialFile &,BOOL)::allowedExtensions)[v55];
LABEL_54:
    if ((char *)v57
       - (char *)&re::convertUSKMaterialNodeToMaterialFile(re::SceneImportOperation &,USKNode *,re::MaterialFile &,BOOL)::allowedExtensions != 64)
      goto LABEL_67;
    v58 = 0;
    v59 = (size_t *)&unk_24ED431E0;
    while (1)
    {
      v60 = (re *)re::DynamicString::append((re::DynamicString *)v358, (const char *)*(v59 - 1), *v59);
      if ((_DWORD)v58 == 2)
        break;
      if ((_DWORD)v58 != 3)
      {
        v61 = ", ";
LABEL_60:
        v62 = strlen(v61);
        v60 = (re *)re::DynamicString::append((re::DynamicString *)v358, v61, v62);
      }
      v59 += 2;
      if (++v58 == 4)
      {
        v63 = (id)*re::pipelineLogObjects(v60);
        if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
        {
          objc_msgSend(v290, "path");
          v216 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
          v217 = objc_msgSend(v216, "UTF8String");
          v218 = &v358[9];
          if ((v358[8] & 1) != 0)
            v218 = *(uint8_t **)&v358[16];
          *(_DWORD *)buf = 136315394;
          *(_QWORD *)&buf[4] = v217;
          v353 = 2080;
          v354 = v218;
          _os_log_error_impl(&dword_224FE9000, v63, OS_LOG_TYPE_ERROR, "%s is an invalid USDZ texture format. Only %s textures are supported.", buf, 0x16u);

        }
        ResourcePathAndColorSpaceForTextureProperty = *(_QWORD *)v358;
        if (*(_QWORD *)v358 && (v358[8] & 1) != 0)
          ResourcePathAndColorSpaceForTextureProperty = (*(uint64_t (**)(void))(**(_QWORD **)v358 + 40))();
        v272 = 1;
        LOBYTE(v48) = BYTE7(v327);
LABEL_67:
        if ((v48 & 0x80) != 0)
          operator delete(__p[0]);
LABEL_69:
        v336 = 0u;
        v335 = 0u;
        re::DynamicString::setCapacity(&v335, 0);
        v291 = v44;
        objc_msgSend(v44, "parentNode");
        v64 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(MEMORY[0x24BEBED10], "shaderNodeType:", v64);
        v65 = (void *)objc_claimAutoreleasedReturnValue();
        v66 = objc_msgSend(v65, "isEqualToString:", v282);

        v283 = 0;
        v286 = xmmword_226104350;
        if (v66)
        {
          objc_msgSend(v64, "property:", CFSTR("inputs:st"));
          v67 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(MEMORY[0x24BEBED10], "targetPropertyWithProperty:", v67);
          v68 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v68, "parentNode");
          v69 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v69, "property:", CFSTR("info:id"));
          v70 = (void *)objc_claimAutoreleasedReturnValue();
          v71 = v70;
          if (v70)
          {
            v284 = v67;
            objc_msgSend(v70, "stringValue");
            v72 = (void *)objc_claimAutoreleasedReturnValue();
            v73 = objc_msgSend(v72, "isEqualToString:", CFSTR("UsdTransform2d"));

            if (!v73)
            {
              v283 = 0;
              v286 = xmmword_226104350;
              goto LABEL_93;
            }
            objc_msgSend(v69, "property:", CFSTR("inputs:scale"));
            v74 = (void *)objc_claimAutoreleasedReturnValue();
            v75 = v74;
            v76 = _D11;
            if (v74)
              objc_msgSend(v74, "float2Value", _D11);
            v287 = v76;
            objc_msgSend(v69, "property:", CFSTR("inputs:rotation"));
            v77 = (void *)objc_claimAutoreleasedReturnValue();
            v276 = v77;
            if (v77)
            {
              objc_msgSend(v77, "floatValue");
              v79 = v78;
            }
            else
            {
              v79 = 0.0;
            }
            objc_msgSend(v69, "property:", CFSTR("inputs:translation"));
            v80 = (void *)objc_claimAutoreleasedReturnValue();
            v274 = v80;
            if (v80)
              objc_msgSend(v80, "float2Value");
            else
              v81 = 0;
            v82 = 0;
            v83.i64[1] = v264;
            v83.i32[0] = v81;
            *(_OWORD *)__p = xmmword_2260E5F10;
            v327 = xmmword_2260E5F20;
            v328 = xmmword_226104360;
            do
            {
              v83.f32[1] = -*((float *)&v81 + 1);
              *(float32x4_t *)&v358[v82 * 8] = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_2260E5F10, COERCE_FLOAT(*(_OWORD *)&__p[v82])), (float32x4_t)xmmword_2260E5F20, (float32x2_t)__p[v82], 1), v83, *(float32x4_t *)&__p[v82], 2);
              v82 += 2;
            }
            while (v82 != 6);
            v84 = v79 / 180.0 * 3.14159265;
            v85 = __sincosf_stret(v84);
            v86 = 0;
            *(float *)&v87 = v85.__cosval;
            *((float *)&v87 + 1) = -v85.__sinval;
            v88 = *(float32x4_t *)v358;
            v89 = *(float32x4_t *)&v358[16];
            v90 = *(float32x4_t *)v359;
            *(_OWORD *)__p = v87;
            v327 = (unint64_t)v85;
            v328 = xmmword_2260E5F40;
            do
            {
              *(float32x4_t *)&v358[v86 * 8] = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v88, COERCE_FLOAT(*(_OWORD *)&__p[v86])), v89, (float32x2_t)__p[v86], 1), v90, *(float32x4_t *)&__p[v86], 2);
              v86 += 2;
            }
            while (v86 != 6);
            v91 = 0;
            v92 = (__int128)v263;
            v93 = v263;
            DWORD1(v92) = HIDWORD(v287);
            v93.i32[0] = LODWORD(v287);
            v94 = *(float32x4_t *)v358;
            v95 = *(float32x4_t *)&v358[16];
            v96 = *(float32x4_t *)v359;
            *(int32x4_t *)__p = v93;
            v327 = v92;
            v328 = xmmword_2260E5F40;
            do
            {
              *(float32x4_t *)&v358[v91 * 8] = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v94, COERCE_FLOAT(*(_OWORD *)&__p[v91])), v95, (float32x2_t)__p[v91], 1), v96, *(float32x4_t *)&__p[v91], 2);
              v91 += 2;
            }
            while (v91 != 6);
            v97 = 0;
            v98 = *(float32x4_t *)v358;
            v99 = *(float32x4_t *)&v358[16];
            v100 = *(float32x4_t *)v359;
            *(_OWORD *)__p = xmmword_2260E5F10;
            v327 = xmmword_2260E5F20;
            v328 = xmmword_226104370;
            do
            {
              *(float32x4_t *)&v358[v97 * 8] = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v98, COERCE_FLOAT(*(_OWORD *)&__p[v97])), v99, (float32x2_t)__p[v97], 1), v100, *(float32x4_t *)&__p[v97], 2);
              v97 += 2;
            }
            while (v97 != 6);
            v288 = *(_QWORD *)v358;
            v268 = *(_QWORD *)&v358[16];
            v283 = *(_QWORD *)v359;
            objc_msgSend(v69, "property:", CFSTR("inputs:in"));
            v101 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(MEMORY[0x24BEBED10], "targetPropertyWithProperty:", v101);
            v102 = (void *)objc_claimAutoreleasedReturnValue();
            v103 = v102;
            if (v102)
            {
              objc_msgSend(v102, "parentNode");
              v104 = v68;
              v105 = v75;
              v106 = (void *)objc_claimAutoreleasedReturnValue();

              objc_msgSend(v106, "property:", CFSTR("info:id"));
              v107 = objc_claimAutoreleasedReturnValue();

              v71 = (void *)v107;
              v69 = v106;
              v75 = v105;
              v68 = v104;
            }
            *(_QWORD *)&v108 = v288;
            *((_QWORD *)&v108 + 1) = v268;
            v286 = v108;

            if (v71)
            {
LABEL_93:
              objc_msgSend(v71, "stringValue");
              v109 = (void *)objc_claimAutoreleasedReturnValue();
              v110 = objc_msgSend(v109, "isEqualToString:", CFSTR("UsdPrimvarReader_float2"));

              if (v110)
              {
                objc_msgSend(v69, "property:", CFSTR("inputs:varname"));
                v111 = (void *)objc_claimAutoreleasedReturnValue();
                v112 = v111;
                if (v111)
                {
                  objc_msgSend(v111, "stringValue");
                  v113 = (void *)objc_claimAutoreleasedReturnValue();
                  v114 = v113;
                  if (v113)
                  {
                    v115 = (const char *)objc_msgSend(objc_retainAutorelease(v113), "UTF8String");
                    v116 = strlen(v115);
                    *(_QWORD *)v358 = v115;
                    *(_QWORD *)&v358[8] = v116;
                    re::DynamicString::operator=((re::DynamicString *)&v335, (uint64_t)v358);
                  }

                }
              }
            }
            v67 = v284;
          }
          else
          {
            v283 = 0;
            v286 = xmmword_226104350;
          }

          v32 = (uint64_t)a1;
        }

        v117 = *((_QWORD *)&v335 + 1) >> 1;
        if ((BYTE8(v335) & 1) == 0)
          v117 = BYTE8(v335) >> 1;
        if (v117)
        {
          if ((BYTE8(v335) & 1) != 0)
            v118 = (const char *)v336;
          else
            v118 = (char *)&v335 + 9;
          if ((v338 & 1) != 0)
            v119 = *(const char **)&v339[7];
          else
            v119 = v339;
          v120 = (_anonymous_namespace_ *)strcmp(v118, v119);
          v44 = v291;
          if (((_DWORD)v120 == 0) | v279 & 1)
          {
            v285 = (_DWORD)v120 != 0;
            v279 |= (_DWORD)v120 != 0;
          }
          else
          {
            re::DynamicString::operator+((re::DynamicString *)buf, (uint64_t)&v335, (re::DynamicString *)__p);
            re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addOrReplace((uint64_t)v296, (re::DynamicString *)v358, (re::DynamicString *)__p);
            if (__p[0])
            {
              if (((uint64_t)__p[1] & 1) != 0)
                (*(void (**)(void))(*(_QWORD *)__p[0] + 40))();
              v327 = 0u;
              *(_OWORD *)__p = 0u;
            }
            if (*(_QWORD *)buf && (buf[8] & 1) != 0)
              (*(void (**)(void))(**(_QWORD **)buf + 40))();
            if (*(_QWORD *)v358 && (v358[8] & 1) != 0)
              (*(void (**)(void))(**(_QWORD **)v358 + 40))();
            v285 = 1;
            v279 = 1;
          }
        }
        else
        {
          v285 = 0;
          v44 = v291;
        }
        BYTE3(__p[0]) = 0;
        LOBYTE(__p[1]) = 0;
        LOBYTE(v328) = 0;
        BYTE8(v328) = 0;
        v329 = 0;
        v330 = 0;
        v331 = 0;
        v332 = 0;
        v333 = 0;
        v334 = 0;
        LOWORD(__p[0]) = 2;
        LOBYTE(v327) = 1;
        DWORD1(v327) = 2;
        BYTE8(v327) = 1;
        HIDWORD(v327) = 2;
        objc_msgSend(v44, "parentNode");
        v122 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(MEMORY[0x24BEBED10], "shaderNodeType:", v122);
        v123 = (void *)objc_claimAutoreleasedReturnValue();
        v124 = objc_msgSend(v123, "isEqualToString:", v282);

        if (v124)
        {
          objc_msgSend(v122, "property:", CFSTR("inputs:st"));
          v125 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v125, "parentNode");
          v126 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v126, "property:", CFSTR("info:id"));
          v127 = (void *)objc_claimAutoreleasedReturnValue();
          v128 = v127;
          if (v127)
          {
            objc_msgSend(v127, "stringValue");
            v129 = (void *)objc_claimAutoreleasedReturnValue();
            v130 = objc_msgSend(v129, "isEqualToString:", CFSTR("UsdUVTexture"));

            if (v130)
            {
              v275 = DWORD1(v327);
              v277 = HIDWORD(v327);
              objc_msgSend(v126, "property:", CFSTR("inputs:wrapS"));
              v131 = (void *)objc_claimAutoreleasedReturnValue();
              v132 = v131;
              if (v131)
              {
                objc_msgSend(v131, "stringValue");
                v133 = (void *)objc_claimAutoreleasedReturnValue();
                if ((objc_msgSend(v133, "isEqualToString:", CFSTR("black")) & 1) != 0)
                {
                  v134 = 4;
                  goto LABEL_136;
                }
                if ((objc_msgSend(v133, "isEqualToString:", CFSTR("clamp")) & 1) != 0)
                {
                  v275 = 0;
                  goto LABEL_137;
                }
                if ((objc_msgSend(v133, "isEqualToString:", CFSTR("repeat")) & 1) != 0)
                {
                  v134 = 2;
                  goto LABEL_136;
                }
                if ((objc_msgSend(v133, "isEqualToString:", CFSTR("mirror")) & 1) != 0)
                {
                  v134 = 3;
LABEL_136:
                  v275 = v134;
                }
                else
                {
                  v270 = v132;
                  v219 = (re *)objc_msgSend(v133, "isEqualToString:", CFSTR("useMetadata"));
                  v220 = (int)v219;
                  log = *re::pipelineLogObjects(v219);
                  v221 = os_log_type_enabled(log, OS_LOG_TYPE_DEFAULT);
                  if (v220)
                  {
                    v132 = v270;
                    if (!v221)
                      goto LABEL_137;
                    *(_WORD *)v358 = 0;
                    v222 = log;
                    v223 = "Reading wrap mode from image metadata is currently not supported; defaulting to \"black\"";
                  }
                  else
                  {
                    v132 = v270;
                    if (!v221)
                      goto LABEL_137;
                    *(_WORD *)v358 = 0;
                    v222 = log;
                    v223 = "Wrap mode for imported USD was an invalid option; defaulting to \"black\"";
                  }
                  _os_log_impl(&dword_224FE9000, v222, OS_LOG_TYPE_DEFAULT, v223, v358, 2u);
                }
LABEL_137:

              }
              objc_msgSend(v126, "property:", CFSTR("inputs:wrapT"));
              v135 = (void *)objc_claimAutoreleasedReturnValue();
              v136 = v135;
              if (v135)
              {
                v269 = v132;
                objc_msgSend(v135, "stringValue");
                v137 = (void *)objc_claimAutoreleasedReturnValue();
                if ((objc_msgSend(v137, "isEqualToString:", CFSTR("black")) & 1) != 0)
                {
                  v138 = 4;
                  goto LABEL_147;
                }
                if ((objc_msgSend(v137, "isEqualToString:", CFSTR("clamp")) & 1) != 0)
                {
                  v277 = 0;
                  goto LABEL_148;
                }
                if ((objc_msgSend(v137, "isEqualToString:", CFSTR("repeat")) & 1) != 0)
                {
                  v138 = 2;
                  goto LABEL_147;
                }
                if ((objc_msgSend(v137, "isEqualToString:", CFSTR("mirror")) & 1) != 0)
                {
                  v138 = 3;
LABEL_147:
                  v277 = v138;
                }
                else
                {
                  v224 = (re *)objc_msgSend(v137, "isEqualToString:", CFSTR("useMetadata"));
                  loga = (int)v224;
                  v255 = *re::pipelineLogObjects(v224);
                  v225 = os_log_type_enabled(v255, OS_LOG_TYPE_DEFAULT);
                  if (loga)
                  {
                    if (!v225)
                      goto LABEL_148;
                    *(_WORD *)v358 = 0;
                    v226 = v255;
                    v227 = "Reading wrap mode from image metadata is currently not supported; defaulting to \"black\"";
                  }
                  else
                  {
                    if (!v225)
                      goto LABEL_148;
                    *(_WORD *)v358 = 0;
                    v226 = v255;
                    v227 = "Wrap mode for imported USD was an invalid option; defaulting to \"black\"";
                  }
                  _os_log_impl(&dword_224FE9000, v226, OS_LOG_TYPE_DEFAULT, v227, v358, 2u);
                }
LABEL_148:

                v132 = v269;
              }
              if (!(_BYTE)v327)
                LOBYTE(v327) = 1;
              DWORD1(v327) = v275;
              if (!BYTE8(v327))
                BYTE8(v327) = 1;
              HIDWORD(v327) = v277;

            }
          }

          v32 = (uint64_t)a1;
          v44 = v291;
        }

        objc_msgSend(v290, "path");
        v139 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
        v140 = (const char *)objc_msgSend(v139, "UTF8String");

        v141 = (re::TextureAsset *)strlen(v140);
        v142 = re::TextureAsset::assetType(v141);
        v143 = (_anonymous_namespace_ *)re::ImportAssetTable::compiledAssetPath((uint64_t)v140, (uint64_t)v141, (re **)v142, (re::DynamicString *)&v324);
        memset(v323, 0, sizeof(v323));
        re::DynamicString::setCapacity(v323, 0);
        v144 = *(_QWORD *)(v32 + 104);
        v145 = (re::TextureAsset *)strlen(v140);
        v146 = re::TextureAsset::assetType(v145);
        v147 = (re::DynamicString *)re::ImportAssetTable::importedAsset(v144, (uint64_t)v140, (uint64_t)v145, (re **)v146);
        if (v147)
        {
          re::DynamicString::operator=((re::DynamicString *)v323, v147);
        }
        else
        {
          isPackageRelativePath = re::HashTable<re::DynamicString,re::USKTextureProvider,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)v278, (uint64_t)&v324);
          if (isPackageRelativePath)
          {
            v150 = isPackageRelativePath;
            re::loadTextureDataWithProvider((re *)isPackageRelativePath, *(re::TextureProvider **)v32, v149, (uint64_t)v358);
            if (v358[0])
            {
              buf[0] = v358[8];
              buf[8] = 0;
              v356 = -1;
              std::__variant_detail::__ctor<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>>::__generic_construct[abi:nn180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<NS::SharedPtr<MTL::Texture>,re::CPUTexture>,(std::__variant_detail::_Trait)1> const&>((uint64_t)&buf[8], (uint64_t)&v358[16]);
              v357 = v363;
              re::createTextureCompileOptionsFromTextureImageOptions((re *)(v150 + 48), (uint64_t)v322);
              TextureAsset = (re::TextureAsset *)re::TextureAsset::makeTextureAsset((uint64_t)buf, *(_DWORD *)(v150 + 104), v322);
              v153 = *(re::ImportAssetTable **)(v32 + 104);
              v154 = re::TextureAsset::assetType(TextureAsset);
              v155 = (re::DynamicString *)re::ImportAssetTable::addAssetWithPath(v153, (const re::DynamicString *)&v324, TextureAsset, (const re::AssetType *)v154);
              re::DynamicString::operator=((re::DynamicString *)v323, v155);

              if (v356 != -1)
                ((void (*)(_OWORD *, _BYTE *))*(&off_24ED43218 + v356))(v321, &buf[8]);
            }
            else
            {
              v161 = (id)*re::pipelineLogObjects(v151);
              if (os_log_type_enabled(v161, OS_LOG_TYPE_DEBUG))
              {
                objc_msgSend(v290, "path");
                v228 = (void *)objc_claimAutoreleasedReturnValue();
                *(_DWORD *)buf = 138412546;
                *(_QWORD *)&buf[4] = v228;
                v353 = 2112;
                v354 = (uint8_t *)v267;
                _os_log_debug_impl(&dword_224FE9000, v161, OS_LOG_TYPE_DEBUG, "Texture '%@' failed to load (referenced by material '%@'); removing associated texture provider",
                  buf,
                  0x16u);

              }
              v162 = re::Hash<re::DynamicString>::operator()((uint64_t)buf, (uint64_t)&v324);
              if (*v278)
              {
                v163 = v162 % *(unsigned int *)(v32 + 136);
                v164 = *(_QWORD *)(v32 + 120);
                v165 = *(unsigned int *)(v164 + 4 * v163);
                if ((_DWORD)v165 != 0x7FFFFFFF)
                {
                  v166 = *(_QWORD *)(v32 + 128);
                  if (re::DynamicString::operator==(v166 + 288 * v165 + 16, (uint64_t)&v324))
                  {
                    *(_DWORD *)(v164 + 4 * v163) = *(_DWORD *)(v166 + 288 * v165 + 8) & 0x7FFFFFFF;
                    v44 = v291;
LABEL_181:
                    v168 = *(_QWORD *)(v32 + 128);
                    v169 = v168 + 288 * v165;
                    v172 = *(_DWORD *)(v169 + 8);
                    v171 = (int *)(v169 + 8);
                    v170 = v172;
                    if (v172 < 0)
                    {
                      *v171 = v170 & 0x7FFFFFFF;
                      v173 = v168 + 288 * v165;
                      v176 = *(_QWORD *)(v173 + 16);
                      v175 = v173 + 16;
                      v174 = v176;
                      if (v176)
                      {
                        if ((*(_BYTE *)(v175 + 8) & 1) != 0)
                          (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v174 + 40))(v174, *(_QWORD *)(v175 + 16));
                        *(_OWORD *)v175 = 0u;
                        *(_OWORD *)(v175 + 16) = 0u;
                      }
                      (**(void (***)(uint64_t))(v168 + 288 * v165 + 48))(v168 + 288 * v165 + 48);
                      v168 = *(_QWORD *)(v32 + 128);
                      v170 = *(_DWORD *)(v168 + 288 * v165 + 8);
                    }
                    *(_DWORD *)(v168 + 288 * v165 + 8) = *(_DWORD *)(v32 + 148) | v170 & 0x80000000;
                    --*(_DWORD *)(v32 + 140);
                    v177 = *(_DWORD *)(v32 + 152) + 1;
                    *(_DWORD *)(v32 + 148) = v165;
                    *(_DWORD *)(v32 + 152) = v177;
                  }
                  else
                  {
                    v44 = v291;
                    while (1)
                    {
                      v167 = v165;
                      v165 = *(_DWORD *)(v166 + 288 * v165 + 8) & 0x7FFFFFFF;
                      if (v165 == 0x7FFFFFFF)
                        break;
                      if (re::DynamicString::operator==(v166 + 288 * v165 + 16, (uint64_t)&v324))
                      {
                        *(_DWORD *)(v166 + 288 * v167 + 8) = *(_DWORD *)(v166 + 288 * v167 + 8) & 0x80000000 | *(_DWORD *)(v166 + 288 * v165 + 8) & 0x7FFFFFFF;
                        goto LABEL_181;
                      }
                    }
                  }
                }
              }
            }
            re::Result<re::TextureData,re::DynamicString>::~Result((uint64_t)v358);
          }
          else
          {
            if (*(_BYTE *)(v32 + 82))
            {
              objc_msgSend(v290, "resolvedPath");
              v156 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
              v157 = (char *)objc_msgSend(v156, "UTF8String");

              v158 = strlen(v157);
              isPackageRelativePath = re::isPackageRelativePath(v157, v158);
              if ((isPackageRelativePath & 1) == 0)
                isPackageRelativePath = re::DynamicString::assignf((re::DynamicString *)v323, "sourcepath:%s", v157);
            }
            if ((BYTE8(v323[0]) & 1) != 0)
              v159 = *((_QWORD *)&v323[0] + 1) >> 1;
            else
              v159 = BYTE8(v323[0]) >> 1;
            if (!v159)
            {
              v160 = (id)*re::pipelineLogObjects((re *)isPackageRelativePath);
              if (os_log_type_enabled(v160, OS_LOG_TYPE_DEBUG))
              {
                objc_msgSend(v290, "path");
                v229 = (void *)objc_claimAutoreleasedReturnValue();
                *(_DWORD *)v358 = 138412546;
                *(_QWORD *)&v358[4] = v267;
                *(_WORD *)&v358[12] = 2112;
                *(_QWORD *)&v358[14] = v229;
                _os_log_debug_impl(&dword_224FE9000, v160, OS_LOG_TYPE_DEBUG, "Material '%@' references texture '%@' which could not be found during loading", v358, 0x16u);

              }
            }
          }
        }
        if ((BYTE8(v323[0]) & 1) != 0)
          v178 = *((_QWORD *)&v323[0] + 1) >> 1;
        else
          v178 = BYTE8(v323[0]) >> 1;
        if (!v178)
          goto LABEL_263;
        v179 = (re::DynamicString *)(v280 + 16);
        re::MaterialTextureParam::MaterialTextureParam((re::MaterialTextureParam *)buf, (const re::DynamicString *)v323);
        v180 = re::Hash<re::DynamicString>::operator()((uint64_t)v358, v280 + 16);
        v181 = v180;
        if ((_QWORD)v299)
        {
          v182 = v180 % DWORD2(v300);
          v183 = *(unsigned int *)(*((_QWORD *)&v299 + 1) + 4 * v182);
          if ((_DWORD)v183 != 0x7FFFFFFF)
          {
            v184 = v300;
            while (1)
            {
              v185 = re::DynamicString::operator==(v184 + 88 * v183 + 16, (uint64_t)v179);
              if ((v185 & 1) != 0)
                break;
              v183 = *(_DWORD *)(v184 + 88 * v183 + 8) & 0x7FFFFFFF;
              if (v183 == 0x7FFFFFFF)
                goto LABEL_200;
            }
LABEL_201:
            memset(v358, 0, sizeof(v358));
            v186 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v358, 0);
            *(_DWORD *)v359 = 0;
            *(_OWORD *)&v359[8] = 0u;
            v360 = 0u;
            v187 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v359[8], 0);
            v361 = 0u;
            v362 = 0u;
            re::DynamicString::setCapacity(&v361, 0);
            LOBYTE(v363) = 0;
            re::MaterialTextureParam::setString((re::MaterialTextureParam *)v358, (const re::DynamicString *)v323);
            re::DynamicString::operator=((re::DynamicString *)&v359[8], v179);
            if (!(_BYTE)v363)
              LOBYTE(v363) = 1;
            HIDWORD(v363) = v285;
            v188 = re::Hash<re::DynamicString>::operator()((uint64_t)v321, (uint64_t)v179);
            v189 = v188;
            if ((_QWORD)v303)
            {
              v190 = v188 % DWORD2(v304);
              v191 = *(unsigned int *)(*((_QWORD *)&v303 + 1) + 4 * v190);
              if ((_DWORD)v191 != 0x7FFFFFFF)
              {
                v192 = v304;
                while (1)
                {
                  v193 = re::DynamicString::operator==(v192 + 160 * v191 + 16, (uint64_t)v179);
                  if ((v193 & 1) != 0)
                    break;
                  v191 = *(_DWORD *)(v192 + 160 * v191 + 8) & 0x7FFFFFFF;
                  if (v191 == 0x7FFFFFFF)
                    goto LABEL_210;
                }
LABEL_211:
                memset(v321, 0, sizeof(v321));
                re::DynamicString::setCapacity(v321, 0);
                v194 = (_anonymous_namespace_ *)re::DynamicString::appendf((re::DynamicString *)v321, "%f, %f, %f, %f", *(float *)&v286, *((float *)&v286 + 1), *((float *)&v286 + 2), *((float *)&v286 + 3));
                memset(v320, 0, sizeof(v320));
                re::DynamicString::setCapacity(v320, 0);
                v195 = (_anonymous_namespace_ *)re::DynamicString::appendf((re::DynamicString *)v320, "%f, %f", *(float *)&v283, *((float *)&v283 + 1));
                if (v285)
                {
                  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::DynamicString&>((uint64_t)&v294[24], (re::DynamicString *)&v318, (const re::DynamicString *)v321);
                  v196 = v318;
                  if (v318 && (v319 & 1) != 0)
                    v196 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v318 + 40))();
                  v197 = "uvOffset1";
                }
                else
                {
                  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::DynamicString&>((uint64_t)&v294[24], (re::DynamicString *)&v318, (const re::DynamicString *)v321);
                  v198 = v318;
                  if (v318 && (v319 & 1) != 0)
                    v198 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v318 + 40))();
                  v197 = "uvOffset";
                }
                re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::DynamicString&>((uint64_t)&v294[24], (re::DynamicString *)&v318, (const re::DynamicString *)v320);
                if (v318 && (v319 & 1) != 0)
                  (*(void (**)(void))(*(_QWORD *)v318 + 40))();
                v199 = re::Hash<re::DynamicString>::operator()((uint64_t)&v318, (uint64_t)v179);
                v200 = v199;
                if ((_QWORD)v307)
                {
                  v201 = v199 % DWORD2(v308);
                  v202 = *(unsigned int *)(*((_QWORD *)&v307 + 1) + 4 * v201);
                  if ((_DWORD)v202 != 0x7FFFFFFF)
                  {
                    v203 = v308;
                    while (!re::DynamicString::operator==(v203 + 152 * v202 + 16, (uint64_t)v179))
                    {
                      v202 = *(_DWORD *)(v203 + 152 * v202 + 8) & 0x7FFFFFFF;
                      if (v202 == 0x7FFFFFFF)
                        goto LABEL_230;
                    }
LABEL_231:
                    if (!re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::containsKey((uint64_t)&v340, (uint64_t)v179))
                    {
                      v204 = re::HashTable<re::DynamicString,re::USKTextureProvider,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)v278, (uint64_t)&v324);
                      v205 = re::Hash<re::DynamicString>::operator()((uint64_t)&v318, (uint64_t)v179);
                      v206 = v205;
                      if ((_QWORD)v340)
                      {
                        v207 = v205 % DWORD2(v341);
                        v208 = *(unsigned int *)(*((_QWORD *)&v340 + 1) + 4 * v207);
                        if ((_DWORD)v208 != 0x7FFFFFFF)
                        {
                          v209 = v341;
                          while (!re::DynamicString::operator==(v209 + 56 * v208 + 16, (uint64_t)v179))
                          {
                            v208 = *(_DWORD *)(v209 + 56 * v208 + 8) & 0x7FFFFFFF;
                            if (v208 == 0x7FFFFFFF)
                              goto LABEL_239;
                          }
                          goto LABEL_245;
                        }
                      }
                      else
                      {
                        v207 = 0;
                      }
LABEL_239:
                      v210 = v343;
                      if ((_DWORD)v343 == 0x7FFFFFFF)
                      {
                        v210 = v342;
                        v211 = v342;
                        if (v342 == DWORD2(v341))
                        {
                          re::HashTable<re::DynamicString,re::TextureProvider const*,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity((uint64_t)&v340, 2 * HIDWORD(v341));
                          v211 = v342;
                          v207 = v206 % DWORD2(v341);
                        }
                        v342 = v211 + 1;
                        v212 = v341;
                        v213 = *(_DWORD *)(v341 + 56 * v210 + 8);
                      }
                      else
                      {
                        v212 = v341;
                        v213 = *(_DWORD *)(v341 + 56 * v343 + 8);
                        LODWORD(v343) = v213 & 0x7FFFFFFF;
                      }
                      *(_DWORD *)(v212 + 56 * v210 + 8) = v213 | 0x80000000;
                      *(_DWORD *)(v341 + 56 * v210 + 8) = *(_DWORD *)(v341 + 56 * v210 + 8) & 0x80000000 | *(_DWORD *)(*((_QWORD *)&v340 + 1) + 4 * v207);
                      *(_QWORD *)(v341 + 56 * v210) = v206;
                      re::DynamicString::DynamicString((re::DynamicString *)(v341 + 56 * v210 + 16), v179);
                      *(_QWORD *)(v341 + 56 * v210 + 48) = v204;
                      *(_DWORD *)(*((_QWORD *)&v340 + 1) + 4 * v207) = v210;
                      ++HIDWORD(v341);
                      ++HIDWORD(v343);
                    }
LABEL_245:
                    if (*(_QWORD *)&v320[0] && (BYTE8(v320[0]) & 1) != 0)
                      (*(void (**)(void))(**(_QWORD **)&v320[0] + 40))();
                    v32 = (uint64_t)a1;
                    v44 = v291;
                    if (*(_QWORD *)&v321[0] && (BYTE8(v321[0]) & 1) != 0)
                      (*(void (**)(void))(**(_QWORD **)&v321[0] + 40))();
                    if ((_QWORD)v361)
                    {
                      if ((BYTE8(v361) & 1) != 0)
                        (*(void (**)(void))(*(_QWORD *)v361 + 40))();
                      v361 = 0u;
                      v362 = 0u;
                    }
                    if (*(_QWORD *)&v359[8])
                    {
                      if ((v359[16] & 1) != 0)
                        (*(void (**)(void))(**(_QWORD **)&v359[8] + 40))();
                      *(_OWORD *)&v359[8] = 0u;
                      v360 = 0u;
                    }
                    if (*(_DWORD *)v359 != -1)
                      ((void (*)(_OWORD *, uint8_t *))*(&off_24ED431A8 + *(unsigned int *)v359))(v321, v358);
                    if (v355 != -1)
                      ((void (*)(uint8_t *, _BYTE *))*(&off_24ED431A8 + v355))(v358, buf);
LABEL_263:
                    if (*(_QWORD *)&v323[0] && (BYTE8(v323[0]) & 1) != 0)
                      (*(void (**)(void))(**(_QWORD **)&v323[0] + 40))();
                    if (v324 && (v325 & 1) != 0)
                      (*(void (**)(void))(*(_QWORD *)v324 + 40))();
                    if ((_QWORD)v335 && (BYTE8(v335) & 1) != 0)
                      (*(void (**)(void))(*(_QWORD *)v335 + 40))();
                    ResourcePathAndColorSpaceForTextureProperty = (uint64_t)v290;
LABEL_273:

                    v42 = v345;
                    if (v346 <= (int)v30 + 1)
                      v214 = v30 + 1;
                    else
                      v214 = v346;
                    while (1)
                    {
                      v41 = (v30 + 1);
                      if (v214 - 1 == (_DWORD)v30)
                        break;
                      LODWORD(v30) = v30 + 1;
                      v215 = v41;
                      if ((*(_DWORD *)(v345 + 56 * v41 + 8) & 0x80000000) != 0)
                        goto LABEL_280;
                    }
                    v215 = v214;
LABEL_280:
                    LODWORD(v30) = v215;
                    if (v289 == v215)
                    {
LABEL_25:
                      objc_msgSend(MEMORY[0x24BEBED10], "constantMaterialPropertiesWithMaterial:", v273);
                      v34 = (void *)objc_claimAutoreleasedReturnValue();
                      re::setFunctionConstantsFromScene(v32, (uint64_t)&v292);
                      re::gatherMaterialConstants((uint64_t)&v294[24], v273, v34, (uint64_t)v344, (uint64_t)&v340);
                      re::setFunctionConstantsFromMaterial((uint64_t)&v292, v351);
                      isMaterialAlphaCutout = re::isMaterialAlphaCutout((re *)v34, v35, v36, v37);
                      v39 = isMaterialAlphaCutout;
                      if ((isMaterialAlphaCutout & 1) != 0)
                      {
                        v40 = 1;
                      }
                      else
                      {
                        isMaterialAlphaCutout = re::isMaterialTransparent(v34, (uint64_t)v344, (uint64_t)&v340);
                        v40 = isMaterialAlphaCutout;
                      }
                      LODWORD(v4) = v259;
                      v3 = a2;
                      if ((v272 & 1) != 0)
                      {
                        v230 = "engine:missingMaterial.rematerialdefinition";
                      }
                      else
                      {
                        v231 = a1[7];
                        if ((v231 & 1) != 0)
                          v232 = v231 >> 1;
                        else
                          v232 = v231 >> 1;
                        if (v232)
                        {
                          if ((a1[7] & 1) != 0)
                            v233 = (char *)a1[8];
                          else
                            v233 = v258;
                          v230 = v233;
                        }
                        else
                        {
                          if (v262)
                          {
                            if (v39)
                            {
                              v230 = "engine:alphaCutoutPbrOpenSubdiv.rematerialdefinition";
                            }
                            else if (v40)
                            {
                              v230 = "engine:transparentPbrOpenSubdiv.rematerialdefinition";
                            }
                            else
                            {
                              v230 = "engine:pbrOpenSubdiv.rematerialdefinition";
                            }
                          }
                          else if (v39)
                          {
                            v230 = "engine:alphaCutoutPbr.rematerialdefinition";
                          }
                          else if (v40)
                          {
                            v230 = "engine:transparentPbr.rematerialdefinition";
                          }
                          else
                          {
                            v230 = "engine:pbr.rematerialdefinition";
                          }
                        }
                      }

                      if (v337 && (v338 & 1) != 0)
                        v234 = (*(double (**)(void))(*(_QWORD *)v337 + 40))();
                      re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v340, v234);

                      re::HashTable<re::DynamicString,USKProperty * {__strong},re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v344);
                      v236 = a1[13];
                      if ((BYTE8(v292) & 1) != 0)
                        v237 = (char *)v293;
                      else
                        v237 = (char *)&v292 + 9;
                      if ((BYTE8(v292) & 1) != 0)
                        v238 = *((_QWORD *)&v292 + 1) >> 1;
                      else
                        v238 = BYTE8(v292) >> 1;
                      v239 = re::MaterialAsset::assetType(v235);
                      v240 = re::ImportAssetTable::importedAsset(v236, (uint64_t)v237, v238, (re **)v239);
                      if (!v240)
                      {
                        v241 = re::globalAllocators(0);
                        v242 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v241[2] + 32))(v241[2], 1896, 8);
                        bzero((void *)v242, 0x768uLL);
                        re::MaterialAsset::MaterialAsset((re::MaterialAsset *)v242);
                        re::DynamicString::operator=((re::DynamicString *)(v242 + 8), (re::DynamicString *)&v292);
                        re::AssetHandle::operator=((uint64_t *)(v242 + 40), (uint64_t *)v294);
                        re::MaterialParameterData::operator=(v242 + 64, (uint64_t)&v294[24]);
                        re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(v242 + 304, (uint64_t)v311);
                        re::MaterialRenderFlags::operator=((_BYTE *)(v242 + 352), v314);
                        v244 = (re::MaterialAsset *)re::DynamicArray<re::FunctionLink>::operator=(v242 + 376, v315, v243);
                        v245 = (_anonymous_namespace_ *)a1[13];
                        if ((BYTE8(v292) & 1) != 0)
                          v246 = (char *)v293;
                        else
                          v246 = (char *)&v292 + 9;
                        if ((BYTE8(v292) & 1) != 0)
                          v247 = *((_QWORD *)&v292 + 1) >> 1;
                        else
                          v247 = BYTE8(v292) >> 1;
                        v248 = re::MaterialAsset::assetType(v244);
                        v240 = re::ImportAssetTable::addAsset(v245, (uint64_t)v246, v247, (void *)v242, (re **)v248);
                      }
                      memset(v358, 0, 24);
                      if ((*(_BYTE *)(v240 + 8) & 1) != 0)
                        v249 = *(re::AssetPath **)(v240 + 16);
                      else
                        v249 = (re::AssetPath *)(v240 + 9);
                      re::DynamicArray<re::AssetHandle>::add(a3, (re::AssetHandle *)v358);
                      re::AssetHandle::~AssetHandle((re::AssetHandle *)v358);
                      re::DynamicArray<re::FunctionLink>::deinit((uint64_t)v315, v250);
                      v251 = re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v311);
                      re::HashTable<re::DynamicString,re::OptionalMaterialSamplerData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v307, v251);
                      re::HashTable<re::DynamicString,re::MaterialTextureBlockData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v303);
                      re::HashTable<re::DynamicString,re::MaterialTextureParam,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v299);
                      re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v296);
                      re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v294[24]);
                      re::AssetHandle::~AssetHandle((re::AssetHandle *)v294);
                      if ((_QWORD)v292 && (BYTE8(v292) & 1) != 0)
                        (*(void (**)(void))(*(_QWORD *)v292 + 40))();
                      v16 = v266;
                      goto LABEL_332;
                    }
                    goto LABEL_28;
                  }
                }
                else
                {
                  LODWORD(v201) = 0;
                }
LABEL_230:
                re::HashTable<re::DynamicString,re::OptionalMaterialSamplerData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsCopy((uint64_t)&v307, v201, v200, v179, (uint64_t)__p);
                ++HIDWORD(v310);
                goto LABEL_231;
              }
            }
            else
            {
              LODWORD(v190) = 0;
            }
LABEL_210:
            v193 = re::HashTable<re::DynamicString,re::MaterialTextureBlockData,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsCopy((uint64_t)&v303, v190, v189, v179, (uint64_t)v358);
            ++HIDWORD(v306);
            goto LABEL_211;
          }
        }
        else
        {
          LODWORD(v182) = 0;
        }
LABEL_200:
        v185 = re::HashTable<re::DynamicString,re::MaterialTextureParam,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsCopy((uint64_t)&v299, v182, v181, v179, (unsigned int *)buf);
        ++HIDWORD(v302);
        goto LABEL_201;
      }
    }
    v61 = " and ";
    goto LABEL_60;
  }
}

uint64_t re::usdimport::createFloatKeyframeAnimationFromProperty(id *a1, float a2)
{
  id v3;
  re *v4;
  uint64_t *v5;
  uint64_t v6;
  void *v7;
  _anonymous_namespace_ *v8;
  _anonymous_namespace_ *v9;
  unint64_t v10;
  unint64_t v11;
  int v12;

  v3 = *a1;
  v4 = (re *)objc_msgSend(v3, "isAnimated");
  if ((_DWORD)v4)
  {
    v5 = re::globalAllocators(v4);
    v6 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v5[2] + 32))(v5[2], 128, 8);
    *(_QWORD *)v6 = off_24ED1F350;
    *(_QWORD *)(v6 + 8) = 19;
    *(_BYTE *)(v6 + 16) = 0;
    *(_QWORD *)(v6 + 24) = 0;
    *(_QWORD *)(v6 + 32) = &str_110;
    *(_WORD *)(v6 + 72) = 256;
    *(_OWORD *)(v6 + 96) = 0u;
    *(_OWORD *)(v6 + 112) = 0u;
    *(_OWORD *)(v6 + 80) = 0u;
    *(_QWORD *)v6 = off_24ED34DF0;
    objc_msgSend(v3, "timeSamples");
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    v8 = (_anonymous_namespace_ *)objc_msgSend(v7, "arraySize");
    objc_msgSend(v7, "floatArray:maxCount:", *(_QWORD *)(v6 + 96), v8);
    if (v8)
    {
      v10 = 0;
      v11 = *(_QWORD *)(v6 + 88);
      while (v11 > v10)
      {
        objc_msgSend(v3, "floatValueAtTime:", *(float *)(*(_QWORD *)(v6 + 96) + 4 * v10));
        if (*(_QWORD *)(v6 + 112) <= v10)
          goto LABEL_12;
        *(_DWORD *)(*(_QWORD *)(v6 + 120) + 4 * v10) = v12;
        v11 = *(_QWORD *)(v6 + 88);
        if (v11 <= v10)
          goto LABEL_13;
        *(float *)(*(_QWORD *)(v6 + 96) + 4 * v10) = *(float *)(*(_QWORD *)(v6 + 96) + 4 * v10) * a2;
        if (v8 == (_anonymous_namespace_ *)++v10)
          goto LABEL_8;
      }
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_12:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_13:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
LABEL_8:
    *(_BYTE *)(v6 + 16) = 3;

  }
  else
  {
    v6 = 0;
  }

  return v6;
}

id re::variantNamesInLodVariantSet(void *a1)
{
  id v1;
  void *v2;

  v1 = a1;
  if (objc_msgSend(v1, "hasVariantSets"))
  {
    objc_msgSend(v1, "variantsWithVariantSet:", CFSTR("lodVariant"));
    v2 = (void *)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    v2 = 0;
  }

  return v2;
}

void re::appendUsedMaterialsByMeshNodeToTableForHelper(void *a1, int a2, uint64_t a3)
{
  id v5;
  void *v6;
  char isCatmullClarkSurface;
  void *v8;
  id v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t i;
  void *v14;
  void *v15;
  id v16;
  _anonymous_namespace_ *v17;
  void *v18;
  id v19;
  _anonymous_namespace_ *v20;
  void *v21;
  void *v22;
  id obj;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  char v30[8];
  __int128 v31;
  __int128 v32;
  void *v33;
  int v34;
  char v35;
  _BYTE v36[128];
  uint64_t v37;

  v37 = *MEMORY[0x24BDAC8D0];
  v5 = a1;
  v6 = v5;
  if (a2)
    isCatmullClarkSurface = re::isCatmullClarkSurface(v5);
  else
    isCatmullClarkSurface = 0;
  objc_msgSend(MEMORY[0x24BEBED10], "meshGroupsWithNode:", v6);
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  if (objc_msgSend(v8, "count"))
  {
    v26 = 0u;
    v27 = 0u;
    v24 = 0u;
    v25 = 0u;
    v9 = v8;
    v10 = objc_msgSend(v9, "countByEnumeratingWithState:objects:count:", &v24, v36, 16);
    if (v10)
    {
      v11 = v10;
      v21 = v8;
      v22 = v6;
      v12 = *(_QWORD *)v25;
      obj = v9;
      do
      {
        for (i = 0; i != v11; ++i)
        {
          if (*(_QWORD *)v25 != v12)
            objc_enumerationMutation(obj);
          objc_msgSend(*(id *)(*((_QWORD *)&v24 + 1) + 8 * i), "inheritedMaterialBinding");
          v14 = (void *)objc_claimAutoreleasedReturnValue();
          if (v14)
          {
            v33 = 0;
            v35 = 0;
            re::ObjCObject::operator=(&v33, v14);
            v34 = *(_DWORD *)(a3 + 28);
            v35 = isCatmullClarkSurface;
            objc_msgSend(v14, "path");
            v15 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v15, "stringValue");
            v16 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
            v17 = (_anonymous_namespace_ *)objc_msgSend(v16, "UTF8String");
            v30[0] = isCatmullClarkSurface;
            re::DynamicString::DynamicString((re::DynamicString *)&v31, (const re::DynamicString *)&v28);
            re::HashTable<re::ImportMaterialSignature,re::MaterialInfoUSK,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::add<re::MaterialInfoUSK&>(a3, v30, (uint64_t)&v33);
            if ((_QWORD)v31)
            {
              if ((BYTE8(v31) & 1) != 0)
                (*(void (**)(void))(*(_QWORD *)v31 + 40))();
              v31 = 0u;
              v32 = 0u;
            }
            if ((_QWORD)v28)
            {
              if ((BYTE8(v28) & 1) != 0)
                (*(void (**)(void))(*(_QWORD *)v28 + 40))();
              v28 = 0u;
              v29 = 0u;
            }

          }
        }
        v9 = obj;
        v11 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v24, v36, 16);
      }
      while (v11);
      v8 = v21;
      v6 = v22;
    }
  }
  else
  {
    objc_msgSend(v6, "inheritedMaterialBinding");
    v9 = (id)objc_claimAutoreleasedReturnValue();
    if (v9)
    {
      v33 = 0;
      v35 = 0;
      re::ObjCObject::operator=(&v33, v9);
      v34 = *(_DWORD *)(a3 + 28);
      v35 = isCatmullClarkSurface;
      objc_msgSend(v9, "path");
      v18 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v18, "stringValue");
      v19 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
      v20 = (_anonymous_namespace_ *)objc_msgSend(v19, "UTF8String");
      v30[0] = isCatmullClarkSurface;
      re::DynamicString::DynamicString((re::DynamicString *)&v31, (const re::DynamicString *)&v28);
      re::HashTable<re::ImportMaterialSignature,re::MaterialInfoUSK,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::add<re::MaterialInfoUSK&>(a3, v30, (uint64_t)&v33);
      if ((_QWORD)v31)
      {
        if ((BYTE8(v31) & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v31 + 40))();
        v31 = 0u;
        v32 = 0u;
      }
      if ((_QWORD)v28)
      {
        if ((BYTE8(v28) & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v28 + 40))();
        v28 = 0u;
        v29 = 0u;
      }

    }
  }

}

uint64_t re::HashTable<re::ImportMaterialSignature,re::MaterialInfoUSK,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::add<re::MaterialInfoUSK&>(uint64_t a1, char *a2, uint64_t a3)
{
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  char v15;

  v6 = re::Hash<re::ImportMaterialSignature>::operator()((uint64_t)&v15, a2);
  v7 = v6;
  if (!*(_QWORD *)a1)
  {
    LODWORD(v8) = 0;
    goto LABEL_9;
  }
  v8 = v6 % *(unsigned int *)(a1 + 24);
  v9 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v8);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
LABEL_9:
    v12 = re::HashTable<re::ImportMaterialSignature,re::MaterialInfoUSK,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::addEmplace<re::MaterialInfoUSK&>(a1, v8, v7, (re::DynamicString *)a2, a3);
    ++*(_DWORD *)(a1 + 40);
    v13 = *(_QWORD *)(a1 + 16) + 72 * v12;
    return v13 + 56;
  }
  v10 = *a2;
  v11 = *(_QWORD *)(a1 + 16);
  while (*(unsigned __int8 *)(v11 + 72 * v9 + 16) != v10
       || !re::DynamicString::operator==(v11 + 72 * v9 + 24, (uint64_t)(a2 + 8)))
  {
    v9 = *(_DWORD *)(v11 + 72 * v9 + 8) & 0x7FFFFFFF;
    if (v9 == 0x7FFFFFFF)
      goto LABEL_9;
  }
  v13 = v11 + 72 * v9;
  return v13 + 56;
}

void re::findSkeletonAndSkeletalAnimationIndices(uint64_t a1, void *a2, uint64_t a3)
{
  id v5;
  void *v6;
  void *v7;
  void *v8;
  id v9;
  char *v10;
  uint64_t v11;
  char v12;
  unsigned __int8 *v13;
  int v14;
  uint64_t *v15;
  uint64_t v16;
  void *v17;
  void *v18;
  id v19;
  _anonymous_namespace_ *v20;
  uint64_t *v21;
  int v22;
  NSObject *v23;
  uint64_t v24;
  void *v25;
  void *v26;
  void *v27;
  uint64_t v28;
  NSObject *v29;
  void *v30;
  id v31;
  uint64_t v32;
  void *v33;
  id v34;
  uint64_t v35;
  uint64_t v36;
  char *v37;
  _BYTE buf[22];
  uint64_t v39;

  v39 = *MEMORY[0x24BDAC8D0];
  v5 = a2;
  objc_msgSend(v5, "inheritedSkeletonBinding");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v7 = v6;
  if (!v6)
  {
LABEL_17:
    *(_BYTE *)a1 = 1;
    *(_BYTE *)(a1 + 8) = 0;
    *(_BYTE *)(a1 + 24) = 0;
    goto LABEL_22;
  }
  objc_msgSend(v6, "path");
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v8, "stringValue");
  v9 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
  v10 = (char *)objc_msgSend(v9, "UTF8String");
  if (v10)
  {
    v11 = *v10;
    if (*v10)
    {
      v12 = v10[1];
      if (v12)
      {
        v13 = (unsigned __int8 *)(v10 + 2);
        do
        {
          v11 = 31 * v11 + v12;
          v14 = *v13++;
          v12 = v14;
        }
        while (v14);
      }
    }
  }
  else
  {
    v11 = 0;
  }
  v36 = 2 * v11;
  v37 = v10;

  v15 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(a3 + 112, &v36);
  if (!v15)
  {
    v23 = *re::pipelineLogObjects(0);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      v29 = v23;
      objc_msgSend(v5, "path", v36, v37);
      v30 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v30, "stringValue");
      v31 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
      v32 = objc_msgSend(v31, "UTF8String");
      objc_msgSend(v7, "path");
      v33 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v33, "stringValue");
      v34 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
      v35 = objc_msgSend(v34, "UTF8String");
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = v32;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = v35;
      _os_log_error_impl(&dword_224FE9000, v29, OS_LOG_TYPE_ERROR, "Mesh (%s) could not find to skeleton: %s.", buf, 0x16u);

    }
    re::StringID::destroyString((re::StringID *)&v36);
    goto LABEL_17;
  }
  v16 = *v15;
  objc_msgSend(v5, "inheritedSkeletonAnimationBinding", v36, v37);
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  if (v17
    || (objc_msgSend(v7, "inheritedSkeletonAnimationBinding"), (v17 = (void *)objc_claimAutoreleasedReturnValue()) != 0))
  {
LABEL_12:
    objc_msgSend(v17, "path");
    v18 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v18, "stringValue");
    v19 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
    v20 = (_anonymous_namespace_ *)objc_msgSend(v19, "UTF8String");
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = &str_110;
    v21 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(a3 + 216, buf);
    if (v21)
    {
      a3 = *v21;
      v22 = 1;
    }
    else
    {
      v22 = 0;
    }
    re::StringID::destroyString((re::StringID *)buf);

    goto LABEL_20;
  }
  objc_msgSend(v5, "childIterator");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v17, "nextObject");
  v24 = objc_claimAutoreleasedReturnValue();
  if (v24)
  {
    v25 = (void *)v24;
    v26 = (void *)*MEMORY[0x24BEBEE08];
    while (1)
    {
      objc_msgSend(v25, "type");
      v27 = (void *)objc_claimAutoreleasedReturnValue();

      if (v27 == v26)
        break;
      objc_msgSend(v17, "nextObject");
      v28 = objc_claimAutoreleasedReturnValue();

      v25 = (void *)v28;
      if (!v28)
        goto LABEL_27;
    }

    v17 = v25;
    goto LABEL_12;
  }
LABEL_27:
  v22 = 0;
LABEL_20:

  re::StringID::destroyString((re::StringID *)&v36);
  *(_BYTE *)a1 = 1;
  *(_BYTE *)(a1 + 8) = 1;
  *(_QWORD *)(a1 + 16) = v16;
  *(_BYTE *)(a1 + 24) = v22;
  if (v22)
    *(_QWORD *)(a1 + 32) = a3;
LABEL_22:

}

void re::loadModelFromMeshNode(uint64_t a1, void *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  id v9;
  unsigned __int8 *v10;
  id v11;
  _anonymous_namespace_ *v12;
  _anonymous_namespace_ *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t i;
  id v18;
  uint64_t v19;
  void *v20;
  id v21;
  const char *v22;
  size_t v23;
  const char *v24;
  size_t v25;
  void *v26;
  void *v27;
  void *v28;
  id v29;
  char *v30;
  const char *v31;
  uint64_t v32;
  char v33;
  unsigned __int8 *v34;
  int v35;
  unint64_t v36;
  __int128 v37;
  uint64_t v38;
  uint64_t v39;
  size_t v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  char v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  _QWORD v51[2];
  __int128 v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;

  v55 = *MEMORY[0x24BDAC8D0];
  v9 = a2;
  v44 = a5;
  v10 = *(unsigned __int8 **)(a5 + 40);
  v11 = v9;
  objc_msgSend(MEMORY[0x24BEBED10], "meshGroupsWithNode:", v11);
  v12 = (_anonymous_namespace_ *)objc_claimAutoreleasedReturnValue();
  if (-[_anonymous_namespace_ count](v12, "count"))
  {
    v49 = 0u;
    v50 = 0u;
    v47 = 0u;
    v48 = 0u;
    v13 = v12;
    v14 = -[_anonymous_namespace_ countByEnumeratingWithState:objects:count:](v13, "countByEnumeratingWithState:objects:count:", &v47, &v52, 16);
    if (v14)
    {
      v15 = v14;
      v41 = a4;
      v42 = a3;
      v43 = a1;
      v16 = *(_QWORD *)v48;
      while (2)
      {
        for (i = 0; i != v15; ++i)
        {
          if (*(_QWORD *)v48 != v16)
            objc_enumerationMutation(v13);
          objc_msgSend(*(id *)(*((_QWORD *)&v47 + 1) + 8 * i), "inheritedMaterialBinding", v41, v42, v43);
          v18 = (id)objc_claimAutoreleasedReturnValue();
          objc_msgSend(MEMORY[0x24BEBED10], "firstUVMeshAttributeNameInMaterial:", v18);
          v19 = objc_claimAutoreleasedReturnValue();
          if (v19)
          {
            v20 = (void *)v19;
            v51[0] = "primvars:";
            v51[1] = 9;
            re::DynamicString::operator=((re::DynamicString *)&v45, (uint64_t)v51);
            v21 = objc_retainAutorelease(v20);
            v22 = (const char *)objc_msgSend(v21, "UTF8String");
            v23 = strlen(v22);
            re::DynamicString::append((re::DynamicString *)&v45, v22, v23);

            a3 = v42;
            a1 = v43;
            a4 = v41;
            goto LABEL_14;
          }

        }
        v15 = -[_anonymous_namespace_ countByEnumeratingWithState:objects:count:](v13, "countByEnumeratingWithState:objects:count:", &v47, &v52, 16);
        if (v15)
          continue;
        break;
      }
      a3 = v42;
      a1 = v43;
      a4 = v41;
    }
  }
  else
  {
    objc_msgSend(v11, "inheritedMaterialBinding");
    v13 = (_anonymous_namespace_ *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x24BEBED10], "firstUVMeshAttributeNameInMaterial:", v13);
    v18 = (id)objc_claimAutoreleasedReturnValue();
    if (v18)
    {
      *(_QWORD *)&v52 = "primvars:";
      *((_QWORD *)&v52 + 1) = 9;
      re::DynamicString::operator=((re::DynamicString *)&v45, (uint64_t)&v52);
      v18 = objc_retainAutorelease(v18);
      v24 = (const char *)objc_msgSend(v18, "UTF8String");
      v25 = strlen(v24);
      re::DynamicString::append((re::DynamicString *)&v45, v24, v25);
    }
LABEL_14:

  }
  objc_msgSend(v11, "inheritedSkeletonBinding");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v27 = v26;
  v47 = 0uLL;
  if (!v26)
  {
    v36 = 0;
LABEL_27:
    re::makeGeomModelDescriptorFromUSKNode(v11, (uint64_t)&v45, a3, v10[165], v10[166], v10[164], (uint64_t)&v47, v36, a1);
    goto LABEL_28;
  }
  if (a4 != -1)
  {
    objc_msgSend(v26, "path");
    v28 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v28, "stringValue");
    v29 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
    v30 = (char *)objc_msgSend(v29, "UTF8String");
    v31 = v30;
    if (v30)
    {
      v32 = *v30;
      if (*v30)
      {
        v33 = v30[1];
        if (v33)
        {
          v34 = (unsigned __int8 *)(v30 + 2);
          do
          {
            v32 = 31 * v32 + v33;
            v35 = *v34++;
            v33 = v35;
          }
          while (v35);
        }
      }
    }
    else
    {
      v32 = 0;
    }
    *(_QWORD *)&v52 = 2 * v32;
    *((_QWORD *)&v52 + 1) = v30;

    v36 = re::BucketArray<re::USDImportContextSkeletonData,4ul>::operator[](v44 + 56, a4) + 16;
    v40 = strlen(v31);
    *(_QWORD *)&v47 = v31;
    *((_QWORD *)&v47 + 1) = v40;
    re::StringID::destroyString((re::StringID *)&v52);
    goto LABEL_27;
  }
  v37 = v52;
  v38 = v53;
  v39 = v54;
  *(_BYTE *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 100;
  *(_QWORD *)(a1 + 16) = &re::AssetErrorCategory(void)::instance;
  *(_OWORD *)(a1 + 24) = v37;
  *(_QWORD *)(a1 + 40) = v38;
  *(_QWORD *)(a1 + 48) = v39;
LABEL_28:

  if (v45 && (v46 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v45 + 40))();

}

void re::loadAllLodModelsForModelPathHelper(uint64_t a1, void *a2, void *a3, void *a4, uint64_t a5, uint64_t a6, void *a7, uint64_t a8)
{
  id v8;
  id v13;
  id v14;
  void *v15;
  unsigned int v16;
  void *v17;
  void *v18;
  void *v19;
  id v20;
  id v21;
  const char *v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  unint64_t v26;
  void *v27;
  void *v28;
  unint64_t v29;
  id v30;
  uint64_t v31;
  const char *v32;
  void *v33;
  uint64_t v34;
  const char *v35;
  _anonymous_namespace_ *v36;
  char v37;
  const char *v38;
  void *v39;
  void *v40;
  id v41;
  uint64_t v42;
  const char *v43;
  uint64_t v44;
  uint64_t v45;
  _anonymous_namespace_ *v46;
  char v47;
  const char *v48;
  uint64_t v49;
  uint64_t v50;
  __int128 v51;
  int v53;
  unint64_t v54;
  uint64_t v55;
  id v56;
  id v57;
  void *v58;
  _QWORD *v59;
  void *v60;
  id v61;
  id v64;
  id v65;
  uint64_t v66;
  __int128 v67;
  int v68;
  uint64_t v69;
  _BYTE v70[32];
  uint64_t v71;
  __int128 v72;
  int v73;
  uint64_t v74;
  uint64_t v75;
  _BYTE v76[38];
  __int128 v77;
  _OWORD v78[2];
  __int128 v79;
  __int128 v80;
  uint64_t v81;

  v81 = *MEMORY[0x24BDAC8D0];
  v65 = a2;
  v13 = a3;
  v64 = a4;
  v14 = a7;
  v74 = 0;
  v72 = 0uLL;
  v71 = 0;
  v73 = 0;
  objc_msgSend(v14, "objectAtIndexedSubscript:", 0);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  v53 = objc_msgSend(v15, "isEqualToString:", CFSTR("card"));

  v16 = objc_msgSend(v14, "count");
  if (v16)
    re::DynamicArray<re::GeomModelDescriptor>::setCapacity(&v71, v16);
  objc_msgSend(v13, "selectVariant:variantSet:", CFSTR("default"), CFSTR("lodVariant"));
  objc_msgSend(v65, "nodeAtPath:", v64);
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  if (!*(_QWORD *)(a8 + 16))
  {
LABEL_69:
    v75 = 0;
    v79 = 0u;
    v80 = 0u;
    memset(v78, 0, sizeof(v78));
    v77 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v76 = 136315906;
    *(_QWORD *)&v76[4] = "operator[]";
    *(_WORD *)&v76[12] = 1024;
    *(_DWORD *)&v76[14] = 797;
    *(_WORD *)&v76[18] = 2048;
    *(_QWORD *)&v76[20] = 0;
    *(_WORD *)&v76[28] = 2048;
    *(_QWORD *)&v76[30] = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  v18 = v17;
  re::loadModelFromMeshNode((uint64_t)&v66, v17, a6, **(_QWORD **)(a8 + 32), a5);
  if (!(_BYTE)v66)
  {
    v77 = v67;
    goto LABEL_49;
  }
  v60 = v14;
  objc_msgSend(v18, "name");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v19, "stringValue");
  v20 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
  v21 = (id)objc_msgSend(v20, "UTF8String");
  v61 = v13;
  v59 = (_QWORD *)a8;
  if (v21)
  {
    objc_msgSend(v18, "name");
    v13 = (id)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v13, "stringValue");
    v8 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
    v22 = (const char *)objc_msgSend(v8, "UTF8String");
  }
  else
  {
    v22 = "";
  }
  re::DynamicString::format((re::DynamicString *)"%s-default", (re::DynamicString *)&v77, v22);
  re::DynamicString::operator=((re::DynamicString *)v70, (re::DynamicString *)&v77);
  if ((_QWORD)v77)
  {
    if ((BYTE8(v77) & 1) != 0)
      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)v77 + 40))(v77, *(_QWORD *)&v78[0]);
    v77 = 0u;
    v78[0] = 0u;
  }
  if (v21)
  {

  }
  re::DynamicArray<re::GeomModelDescriptor>::add((uint64_t)&v71, (uint64_t)&v67);
  re::Result<re::GeomModelDescriptor,re::DetailedError>::~Result((uint64_t)&v66);

  if (v53)
    v23 = 2;
  else
    v23 = 1;
  v55 = v23;
  v13 = v61;
  v24 = (_QWORD *)a8;
  if (v23 >= v16)
  {
LABEL_44:
    if (v53)
    {
      objc_msgSend(v13, "selectVariant:variantSet:", CFSTR("card"), CFSTR("lodVariant"));
      objc_msgSend(v65, "nodeAtPath:", v64);
      v39 = (void *)objc_claimAutoreleasedReturnValue();
      re::loadModelFromMeshNode((uint64_t)&v66, v39, a6, *(_QWORD *)(v24[4] + 8 * v24[2] - 8), a5);
      if (!(_BYTE)v66)
      {
        v77 = v67;
        re::DynamicString::DynamicString((re::DynamicString *)v78, (const re::DynamicString *)&v68);
        *(_BYTE *)a1 = 0;
        *(_OWORD *)(a1 + 8) = v77;
        v45 = *((_QWORD *)&v78[1] + 1);
        *(_QWORD *)(a1 + 24) = *(_QWORD *)&v78[0];
        *(_QWORD *)(a1 + 48) = v45;
        *(_OWORD *)(a1 + 32) = *(_OWORD *)((char *)v78 + 8);
        re::Result<re::GeomModelDescriptor,re::DetailedError>::~Result((uint64_t)&v66);

LABEL_66:
        v14 = v60;
        goto LABEL_67;
      }
      objc_msgSend(v39, "name");
      v40 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v40, "stringValue");
      v41 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
      v42 = objc_msgSend(v41, "UTF8String");
      if (v42)
      {
        objc_msgSend(v39, "name");
        v24 = (_QWORD *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v24, "stringValue");
        v21 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
        v43 = (const char *)objc_msgSend(v21, "UTF8String");
      }
      else
      {
        v43 = "";
      }
      v46 = (_anonymous_namespace_ *)re::DynamicString::format((re::DynamicString *)"%s-card", (re::DynamicString *)v76, v43);
      v47 = v76[8];
      if ((v76[8] & 1) != 0)
        v48 = *(const char **)&v76[16];
      else
        v48 = &v76[9];
      re::DynamicString::operator=((re::DynamicString *)v70, (re::DynamicString *)&v77);
      if ((_QWORD)v77)
      {
        if ((BYTE8(v77) & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v77 + 40))();
        v77 = 0u;
        v78[0] = 0u;
      }
      if (*(_QWORD *)v76 && (v47 & 1) != 0)
        (*(void (**)(void))(**(_QWORD **)v76 + 40))();
      if (v42)
      {

      }
      re::DynamicArray<re::GeomModelDescriptor>::add((uint64_t)&v71, (uint64_t)&v67);
      re::Result<re::GeomModelDescriptor,re::DetailedError>::~Result((uint64_t)&v66);

      v13 = v61;
    }
    objc_msgSend(v13, "selectVariant:variantSet:", CFSTR("default"), CFSTR("lodVariant"));
    v49 = v71;
    v71 = 0;
    v50 = v74;
    v74 = 0;
    ++v73;
    *(_BYTE *)a1 = 1;
    *(_QWORD *)(a1 + 8) = v49;
    v66 = 0;
    v51 = v72;
    v72 = 0u;
    *(_OWORD *)(a1 + 16) = v51;
    v67 = 0u;
    *(_QWORD *)(a1 + 40) = v50;
    v69 = 0;
    v68 = 2;
    *(_DWORD *)(a1 + 32) = 1;
    re::DynamicArray<re::GeomModelDescriptor>::deinit((uint64_t)&v66);
    goto LABEL_66;
  }
  v25 = 0;
  v54 = v16 - (unint64_t)v23;
  while (1)
  {
    v26 = (v25 + 1);
    v14 = v60;
    objc_msgSend(v60, "objectAtIndexedSubscript:", v55 + v25);
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v13, "selectVariant:variantSet:", v27, CFSTR("lodVariant"));

    objc_msgSend(v65, "nodeAtPath:", v64);
    v28 = (void *)objc_claimAutoreleasedReturnValue();
    v29 = v24[2];
    if (v29 <= v26)
    {
      v75 = 0;
      v79 = 0u;
      v80 = 0u;
      memset(v78, 0, sizeof(v78));
      v77 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v76 = 136315906;
      *(_QWORD *)&v76[4] = "operator[]";
      *(_WORD *)&v76[12] = 1024;
      *(_DWORD *)&v76[14] = 797;
      *(_WORD *)&v76[18] = 2048;
      *(_QWORD *)&v76[20] = (v25 + 1);
      *(_WORD *)&v76[28] = 2048;
      *(_QWORD *)&v76[30] = v29;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_69;
    }
    v18 = v28;
    re::loadModelFromMeshNode((uint64_t)&v66, v28, a6, *(_QWORD *)(v24[4] + 8 * v26), a5);
    if (!(_BYTE)v66)
      break;
    objc_msgSend(v18, "name");
    v21 = (id)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v21, "stringValue");
    v30 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
    v31 = objc_msgSend(v30, "UTF8String");
    if (v31)
    {
      objc_msgSend(v18, "name");
      v58 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v58, "stringValue");
      v56 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
      v32 = (const char *)objc_msgSend(v56, "UTF8String");
    }
    else
    {
      v32 = "";
    }
    objc_msgSend(v60, "objectAtIndexedSubscript:", (v25 + 1));
    v33 = (void *)objc_claimAutoreleasedReturnValue();
    v34 = objc_msgSend(v33, "length");
    if (v34)
    {
      objc_msgSend(v60, "objectAtIndexedSubscript:", (v25 + 1));
      v57 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
      v35 = (const char *)objc_msgSend(v57, "UTF8String");
    }
    else
    {
      v35 = "";
    }
    v36 = (_anonymous_namespace_ *)re::DynamicString::format((re::DynamicString *)"%s-%s", (re::DynamicString *)v76, v32, v35);
    v37 = v76[8];
    if ((v76[8] & 1) != 0)
      v38 = *(const char **)&v76[16];
    else
      v38 = &v76[9];
    re::DynamicString::operator=((re::DynamicString *)v70, (re::DynamicString *)&v77);
    if ((_QWORD)v77)
    {
      if ((BYTE8(v77) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v77 + 40))();
      v77 = 0u;
      v78[0] = 0u;
    }
    if (*(_QWORD *)v76)
    {
      if ((v37 & 1) != 0)
        (*(void (**)(void))(**(_QWORD **)v76 + 40))();
      memset(v76, 0, 32);
    }
    if (v34)

    if (v31)
    {

    }
    re::DynamicArray<re::GeomModelDescriptor>::add((uint64_t)&v71, (uint64_t)&v67);
    re::Result<re::GeomModelDescriptor,re::DetailedError>::~Result((uint64_t)&v66);

    ++v25;
    v13 = v61;
    v24 = v59;
    if (v54 == v25)
      goto LABEL_44;
  }
  v77 = v67;
LABEL_49:
  re::DynamicString::DynamicString((re::DynamicString *)v78, (const re::DynamicString *)&v68);
  *(_BYTE *)a1 = 0;
  *(_OWORD *)(a1 + 8) = v77;
  v44 = *((_QWORD *)&v78[1] + 1);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)&v78[0];
  *(_QWORD *)(a1 + 48) = v44;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)((char *)v78 + 8);
  re::Result<re::GeomModelDescriptor,re::DetailedError>::~Result((uint64_t)&v66);

LABEL_67:
  re::DynamicArray<re::GeomModelDescriptor>::deinit((uint64_t)&v71);

}

uint64_t re::DynamicArray<re::GeomModelDescriptor>::add(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  BOOL v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t result;

  v4 = *(_QWORD *)(a1 + 8);
  v5 = *(_QWORD *)(a1 + 16);
  if (v5 >= v4)
  {
    v6 = v5 + 1;
    if (v4 < v5 + 1)
    {
      if (*(_QWORD *)a1)
      {
        v7 = 2 * v4;
        v8 = v4 == 0;
        v9 = 8;
        if (!v8)
          v9 = v7;
        if (v9 <= v6)
          v10 = v6;
        else
          v10 = v9;
        re::DynamicArray<re::GeomModelDescriptor>::setCapacity((_QWORD *)a1, v10);
      }
      else
      {
        re::DynamicArray<re::GeomModelDescriptor>::setCapacity((_QWORD *)a1, v6);
        ++*(_DWORD *)(a1 + 24);
      }
    }
    v5 = *(_QWORD *)(a1 + 16);
  }
  result = re::GeomModelDescriptor::GeomModelDescriptor(*(_QWORD *)(a1 + 32) + 216 * v5, a2);
  ++*(_QWORD *)(a1 + 16);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

void re::loadTransformAndMeshNodes(void *a1, void *a2, re::USDImportContext *a3, char a4)
{
  void *v4;
  id v8;
  unint64_t i;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  id v18;
  void *v19;
  void *v20;
  void *v21;
  char v22;
  const char *v23;
  void *v24;
  id v25;
  void *v26;
  void *v27;
  void *v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  __int128 v32;
  float32x4_t v33;
  BOOL v34;
  float v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  int32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  int32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  int32x4_t v54;
  float32x4_t v55;
  uint64_t v56;
  float32x4_t v57;
  unsigned __int8 v58;
  char v59;
  BOOL v60;
  uint64_t v61;
  void *v62;
  _anonymous_namespace_ *v63;
  float v64;
  re *data;
  uint64_t v66;
  void *v67;
  void *v68;
  void *v69;
  int v70;
  void *v71;
  void *v72;
  void *v73;
  uint64_t v74;
  void *v75;
  void *v76;
  id v77;
  _anonymous_namespace_ *v78;
  _anonymous_namespace_ *v79;
  _BYTE *v80;
  unint64_t v81;
  uint64_t v82;
  _anonymous_namespace_ *v83;
  NSObject *v84;
  void *v85;
  void *v86;
  void *v87;
  void *v88;
  void *v89;
  void *v90;
  char v91;
  std::string::value_type isCatmullClarkSurface;
  void *v93;
  id v94;
  _anonymous_namespace_ *v95;
  _anonymous_namespace_ **v96;
  _anonymous_namespace_ **v97;
  void *v98;
  void *v99;
  void *v100;
  id v101;
  _anonymous_namespace_ *v102;
  id v103;
  void *v104;
  void *v105;
  void *v106;
  void *v107;
  void *v108;
  void *v109;
  void *v110;
  void *v111;
  void *v112;
  re *v113;
  NSObject *v114;
  void *v115;
  id v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  void *v120;
  void *v121;
  id v122;
  _anonymous_namespace_ *v123;
  void *v124;
  void *v125;
  id v126;
  _anonymous_namespace_ *v127;
  re *v128;
  void *v129;
  NSObject *v130;
  _anonymous_namespace_ *v131;
  void *v132;
  id v133;
  char *v134;
  uint64_t v135;
  char v136;
  unsigned __int8 *v137;
  int v138;
  unint64_t v139;
  unint64_t *v140;
  unint64_t v141;
  NSObject *v142;
  void *v143;
  void *v144;
  void *v145;
  uint64_t v146;
  re *v147;
  unint64_t v148;
  unint64_t v149;
  NSObject *v150;
  NSObject *v151;
  id v152;
  uint64_t v153;
  void *v154;
  void *v155;
  float v156;
  void *v157;
  float v158;
  re *v159;
  NSObject *v160;
  void *v161;
  float v162;
  void *v163;
  float v164;
  void *v165;
  void *v166;
  float v167;
  void *v168;
  float v169;
  void *v170;
  void *v171;
  void *v172;
  id v173;
  const char *v174;
  size_t v175;
  void *v176;
  float v177;
  void *v178;
  float v179;
  void *v180;
  float v181;
  void *v182;
  float v183;
  void *v184;
  void *v185;
  id v186;
  const char *v187;
  size_t v188;
  void *v189;
  float v190;
  void *v191;
  float v192;
  void *v193;
  double v194;
  void *v195;
  float v196;
  float v197;
  void *v198;
  void *v199;
  id v200;
  const char *v201;
  size_t v202;
  const char *v203;
  int v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  void *v208;
  id v209;
  _anonymous_namespace_ *v210;
  unint64_t *v211;
  unint64_t *v212;
  re *v213;
  NSObject *v214;
  unsigned int v215;
  uint64_t v216;
  int *v217;
  int v218;
  uint64_t v219;
  uint64_t v220;
  void *v221;
  id v222;
  void *v223;
  unsigned int v224;
  unsigned int v225;
  id v226;
  const char *v227;
  size_t v228;
  char v229;
  int v230;
  void *v231;
  void *v232;
  int v233;
  re *v234;
  void *v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  id v240;
  void *v241;
  id v242;
  char *v243;
  uint64_t v244;
  char v245;
  unsigned __int8 *v246;
  int v247;
  unint64_t *v248;
  unint64_t v249;
  uint64_t v250;
  unint64_t v251;
  unint64_t v252;
  id v253;
  id v254;
  uint64_t v255;
  uint64_t v256;
  id v257;
  void *v258;
  uint64_t v259;
  void *v260;
  unint64_t v261;
  id v262;
  id v263;
  re *v264;
  NSObject *v265;
  NSObject *v266;
  NSObject *v267;
  uint64_t v268;
  void *v269;
  id v270;
  uint64_t v271;
  uint64_t v272;
  NSObject *v273;
  _BYTE *v274;
  void *v275;
  id v276;
  uint64_t v277;
  uint64_t v278;
  uint64_t v279;
  NSObject *v280;
  void *v281;
  uint64_t v282;
  id v283;
  id v284;
  void *v285;
  void *v286;
  unsigned int v287;
  void *v288;
  int v289;
  uint64_t v290;
  int v291;
  int v292;
  void *v293;
  void *v294;
  _anonymous_namespace_ *v295;
  unint64_t v296;
  void *v297;
  uint64_t v298;
  void *v299;
  unsigned int v300;
  uint64_t v301;
  void *v302;
  int v303;
  void *v304;
  uint64_t v305;
  uint64_t v306;
  void *v307;
  void *v308;
  void *v309;
  void *v310;
  void *v311;
  char v312;
  re::USDImportContext *v313;
  id v314;
  id v315;
  id v316;
  id v317;
  void *v318;
  void *v319;
  unsigned int v320;
  unsigned int v321;
  unsigned int j;
  void *v323;
  void *v324;
  void *v325;
  void *v326;
  void *v327;
  float32x4_t v328;
  float32x4_t v329;
  float32x4_t v330;
  float32x4_t v331;
  int v332;
  int v333;
  void *v334;
  void *v335;
  void *v336;
  float32x4_t v337;
  float32x4_t v338;
  float32x4_t v339;
  float32x4_t v340;
  unsigned int v341;
  BOOL v342;
  BOOL v343;
  re *v344;
  NSObject *v345;
  void *v346;
  void *v347;
  uint64_t v348;
  void *v349;
  void *v350;
  id v351;
  const char *v352;
  id v353;
  void *v354;
  float32x4_t v355;
  float32x4_t v356;
  float32x4_t v357;
  __int128 v358;
  float32x4_t v359;
  float v360;
  float32x4_t v361;
  float32x4_t v362;
  float32x4_t v363;
  float32x4_t v364;
  float32x4_t v365;
  float32x4_t v366;
  float32x4_t v367;
  int32x4_t v368;
  float32x4_t v369;
  float32x4_t v370;
  float32x4_t v371;
  float32x4_t v372;
  int32x4_t v373;
  float32x4_t v374;
  float32x4_t v375;
  float32x4_t v376;
  float32x4_t v377;
  float32x4_t v378;
  int32x4_t v379;
  float32x4_t v380;
  uint64_t v381;
  float32x4_t v382;
  unsigned __int8 v383;
  uint64_t v384;
  char v385;
  BOOL v386;
  uint64_t v387;
  int v388;
  id v389;
  id v390;
  id v391;
  id v392;
  void *v393;
  int v394;
  unsigned int v395;
  void *v396;
  uint64_t v397;
  _BOOL4 v398;
  void *v399;
  void *v400;
  void *v401;
  void *v402;
  void *v403;
  id v404;
  uint64_t v405;
  uint64_t v406;
  uint64_t v407;
  uint64_t k;
  uint64_t v409;
  void *v410;
  id v411;
  id v412;
  id v413;
  id v414;
  void *v415;
  int v416;
  unsigned int v417;
  unint64_t v418;
  void *v419;
  BOOL v420;
  _QWORD *v421;
  BOOL v422;
  __int16 *v423;
  uint64_t v424;
  void *v425;
  void *v426;
  BOOL v427;
  _QWORD *v428;
  BOOL v429;
  __int16 *v430;
  void *v431;
  BOOL v432;
  _QWORD *v433;
  BOOL v434;
  __int16 *v435;
  re *v436;
  uint64_t v437;
  NSObject *v438;
  void *v439;
  std::string *v440;
  char *v441;
  _BOOL4 IsBlendShapeRoot;
  void *v443;
  void *v444;
  uint64_t v445;
  void *v446;
  void *v447;
  void *v448;
  char v449;
  uint64_t v450;
  void *v451;
  id v452;
  std::string::size_type v453;
  _BYTE *v454;
  void *v455;
  id v456;
  uint64_t v457;
  void *v458;
  id v459;
  uint64_t v460;
  _BYTE *v461;
  _BYTE *v462;
  void *v463;
  float v464;
  void *v465;
  float v466;
  re *v467;
  uint64_t *v468;
  uint64_t v469;
  _QWORD *v470;
  uint64_t v471;
  uint64_t v472;
  uint64_t v473;
  void *v474;
  void *v475;
  int v476;
  _anonymous_namespace_ *v477;
  const char *v478;
  void *v479;
  id v480;
  uint64_t v481;
  void *v482;
  id v483;
  uint64_t v484;
  std::string *v485;
  _BYTE *v486;
  int v487;
  void *v488;
  void *v489;
  id v490;
  _anonymous_namespace_ *v491;
  NSObject *v492;
  id v493;
  void *v494;
  void *v495;
  const char *v496;
  _anonymous_namespace_ *v497;
  const char *v498;
  uint64_t v499;
  double v500;
  double v501;
  uint64_t v502;
  uint64_t v503;
  uint64_t v504;
  uint64_t v505;
  void *v506;
  uint64_t v507;
  __int128 *v508;
  _anonymous_namespace_ *v509;
  _anonymous_namespace_ *v510;
  const char *v511;
  _anonymous_namespace_ *v512;
  _anonymous_namespace_ *v513;
  const char *v514;
  _anonymous_namespace_ *v515;
  _anonymous_namespace_ *v516;
  const char *v517;
  void *v518;
  id v519;
  _anonymous_namespace_ *v520;
  id v521;
  int v522;
  void *v523;
  void *v524;
  std::error_code *v525;
  void *v526;
  void *v527;
  void *v528;
  uint64_t v529;
  void *v530;
  void *v531;
  id v532;
  id v533;
  uint64_t v534;
  id v535;
  id v536;
  void *v537;
  void *v538;
  _QWORD *v539;
  void *v540;
  void *v541;
  void *v542;
  id v543;
  _anonymous_namespace_ *v544;
  uint64_t v545;
  void *v546;
  id v547;
  float32x4_t v548;
  void *v549;
  id v550;
  float32x4_t v551;
  float32x4_t v552;
  __int128 v553;
  void *v554;
  __int128 v555;
  float32x4_t v556;
  __int128 v557;
  char v558;
  void *v559;
  void *v560;
  re::USDImportContext *v561;
  __int128 v562;
  void *v563;
  int v564;
  void *v565;
  char v566;
  char v567;
  _anonymous_namespace_ *v568;
  _anonymous_namespace_ **obj;
  id obja;
  int v571;
  void *v572;
  _anonymous_namespace_ *v573;
  uint64_t v574;
  char v575;
  uint64_t v576;
  size_t v577;
  __int128 v578;
  __int128 v579;
  __int128 v580;
  __int128 v581;
  __int128 v582;
  __int128 v583;
  unsigned int v584[4];
  _OWORD v585[4];
  std::string v586;
  __int128 v587;
  id v588;
  uint64_t v589;
  uint64_t v590;
  __int128 v591;
  _BYTE buf[56];
  __int128 v593;
  uint64_t v594;
  __int128 v595;
  __int128 v596;
  int v597;
  uint64_t v598;
  uint64_t v599;
  _BYTE v600[41];
  _BYTE v601[23];
  _BYTE v602[128];
  uint8_t v603[24];
  int v604;
  uint64_t v605;
  _BYTE v606[12];
  __int16 v607;
  _BYTE *v608;
  __int16 v609;
  uint64_t v610;
  _BYTE __s[48];
  __int128 v612;
  int v613;
  uint64_t v614;
  std::string v615[2];
  __int128 v616;
  _QWORD v617[4];
  __int16 v618;
  _BYTE v619[14];
  uint64_t v620;
  simd_float3x3 v621;
  simd_float3x3 v622;

  v620 = *MEMORY[0x24BDAC8D0];
  v536 = a1;
  v8 = a2;
  i = *((_QWORD *)a3 + 5);
  v571 = *(unsigned __int8 *)(i + 96);
  objc_msgSend(v8, "type");
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  v561 = a3;
  v546 = v8;
  v526 = v10;
  obj = (_anonymous_namespace_ **)i;
  if (!objc_msgSend(MEMORY[0x24BEBED10], "isSceneGraphNode:", v8)
    || (objc_msgSend(MEMORY[0x24BEBED10], "isTransformNode:", v8) & 1) == 0)
  {
    objc_msgSend(v8, "typeName");
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v11, "stringValue");
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    if ((objc_msgSend(v12, "isEqualToString:", CFSTR("Preliminary_Text")) & 1) != 0)
    {
LABEL_8:

      v10 = v526;
      goto LABEL_9;
    }
    objc_msgSend(v8, "typeName");
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v13, "stringValue");
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    if ((objc_msgSend(v14, "isEqualToString:", CFSTR("Preliminary_InfiniteColliderPlane")) & 1) != 0)
    {
LABEL_7:

      v8 = v546;
      goto LABEL_8;
    }
    objc_msgSend(v546, "typeName");
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v15, "stringValue");
    v16 = (void *)objc_claimAutoreleasedReturnValue();
    if ((objc_msgSend(v16, "isEqualToString:", CFSTR("Preliminary_DeformerStack")) & 1) != 0)
    {

      a3 = v561;
      i = (unint64_t)obj;
      goto LABEL_7;
    }
    objc_msgSend(v546, "typeName");
    v67 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v67, "stringValue");
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    v567 = objc_msgSend(v4, "isEqualToString:", CFSTR("DeformerStack"));

    a3 = v561;
    v8 = v546;
    v10 = v526;
    i = (unint64_t)obj;
    if ((v567 & 1) == 0)
    {
      objc_msgSend(v546, "typeName");
      v68 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v68, "stringValue");
      v69 = (void *)objc_claimAutoreleasedReturnValue();
      v70 = objc_msgSend(v69, "isEqualToString:", CFSTR("Preliminary_Action"));

      if (v70)
      {
        objc_msgSend(v546, "property:", CFSTR("audio"));
        v71 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v71, "resourcePath");
        v72 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v546, "property:", CFSTR("affectedObjects"));
        v73 = (void *)objc_claimAutoreleasedReturnValue();

        objc_msgSend(v73, "stringValue");
        v74 = objc_claimAutoreleasedReturnValue();
        v75 = (void *)v74;
        if (v72 && v74)
        {
          re::usdimport::createAudioFileAssetForResourcePath(obj[13], v72, 0, 0, 0, (re::DynamicString *)v617);
          objc_msgSend(v546, "path");
          v76 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v76, "stringValue");
          v77 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
          v78 = (_anonymous_namespace_ *)objc_msgSend(v77, "UTF8String");
          re::AssetHandle::serializationString((re::AssetHandle *)v617, (re::DynamicString *)__s);
          re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add((uint64_t)(obj + 33), (re::DynamicString *)buf, __s);
          if (*(_QWORD *)__s && (__s[8] & 1) != 0)
            (*(void (**)(void))(**(_QWORD **)__s + 40))();
          if (*(_QWORD *)buf)
          {
            if ((buf[8] & 1) != 0)
              (*(void (**)(void))(**(_QWORD **)buf + 40))();
            memset(buf, 0, 32);
          }

          v79 = (_anonymous_namespace_ *)objc_msgSend(objc_retainAutorelease(v75), "UTF8String");
          if ((__s[8] & 1) != 0)
            v80 = *(_BYTE **)&__s[16];
          else
            v80 = &__s[9];
          if ((__s[8] & 1) != 0)
            v81 = *(_QWORD *)&__s[8] >> 1;
          else
            v81 = __s[8] >> 1;
          *(_QWORD *)&v585[0] = re::innerPathFromPackageRelativePath((uint64_t)v80, v81);
          *((_QWORD *)&v585[0] + 1) = v82;
          v83 = (_anonymous_namespace_ *)re::HashTable<re::DynamicString,re::DynamicArray<re::ResourceFetchManager::Request *>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)(obj + 39), (uint64_t)v615);
          if (!v83)
          {
            *(_QWORD *)&buf[32] = 0;
            memset(buf, 0, 28);
            v83 = (_anonymous_namespace_ *)re::HashTable<re::DynamicString,re::DynamicArray<re::AssetHandle>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add((uint64_t)(obj + 39), (const re::DynamicString *)v615, (uint64_t)buf);
            re::DynamicArray<re::AssetHandle>::deinit((uint64_t)buf);
          }
          re::DynamicArray<re::AssetHandle>::add(v83, (re::AssetHandle *)v617);
          if (v615[0].__r_.__value_.__r.__words[0] && (v615[0].__r_.__value_.__s.__data_[8] & 1) != 0)
            (*(void (**)(void))(*(_QWORD *)v615[0].__r_.__value_.__l.__data_ + 40))();
          v8 = v546;
          if (*(_QWORD *)__s && (__s[8] & 1) != 0)
            (*(void (**)(void))(**(_QWORD **)__s + 40))();
          re::AssetHandle::~AssetHandle((re::AssetHandle *)v617);
        }

      }
      else
      {
        v159 = (re *)objc_msgSend(v526, "isEqualToString:", *MEMORY[0x24BEBEE30]);
        if (!(_DWORD)v159)
          goto LABEL_195;
        v160 = *re::pipelineLogObjects(v159);
        if (!os_log_type_enabled(v160, OS_LOG_TYPE_DEBUG))
          goto LABEL_195;
        v492 = v160;
        objc_msgSend(v546, "typeName");
        v73 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v73, "stringValue");
        v493 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)&buf[4] = objc_msgSend(v493, "UTF8String");
        _os_log_debug_impl(&dword_224FE9000, v492, OS_LOG_TYPE_DEBUG, "USD import discovered unknown node, type = %s", buf, 0xCu);

      }
LABEL_195:
      v522 = 0;
      goto LABEL_342;
    }
  }
LABEL_9:
  if ((a4 & 1) != 0)
  {
    v522 = 0;
    goto LABEL_17;
  }
  objc_msgSend(v8, "typeName");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v17, "stringValue");
  v18 = (id)objc_claimAutoreleasedReturnValue();
  if ((objc_msgSend(v18, "isEqualToString:", CFSTR("Preliminary_DeformerStack")) & 1) != 0)
  {
    v522 = 0;
  }
  else
  {
    objc_msgSend(v8, "typeName");
    v19 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v19, "stringValue");
    v20 = (void *)objc_claimAutoreleasedReturnValue();
    v21 = v8;
    v22 = objc_msgSend(v20, "isEqualToString:", CFSTR("DeformerStack"));

    if ((v22 & 1) != 0)
    {
      v522 = 0;
      v8 = v21;
      v10 = v526;
      i = (unint64_t)obj;
      goto LABEL_17;
    }
    objc_msgSend(v21, "name");
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v17, "stringValue");
    v18 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
    v23 = (const char *)objc_msgSend(v18, "UTF8String");
    objc_msgSend(v21, "path");
    v24 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v24, "stringValue");
    v25 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
    re::USDImportContext::pushNodePath(a3, v23, "(default)", (const char *)objc_msgSend(v25, "UTF8String"));

    v522 = 1;
    v8 = v21;
    i = (unint64_t)obj;
  }

  v10 = v526;
LABEL_17:
  objc_msgSend(v8, "property:", CFSTR("purpose"));
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v540 = v26;
  if (v26)
  {
    objc_msgSend(v26, "stringValue");
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    v566 = objc_msgSend(v27, "isEqualToString:", CFSTR("guide"));

  }
  else
  {
    v566 = 0;
  }
  v28 = v617;
  objc_msgSend(v8, "inheritedSkeletonBinding");
  v544 = (_anonymous_namespace_ *)objc_claimAutoreleasedReturnValue();
  if (!v544)
  {
    objc_msgSend(MEMORY[0x24BEBED10], "localTransformWithNode:time:", v8, 0.0);
    v562 = v32;
    v33 = vmulq_f32(v29, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v31, (int8x16_t)v31, 0xCuLL), (int8x16_t)v31, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v30, (int32x4_t)v30), (int8x16_t)v30, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v31, (int32x4_t)v31), (int8x16_t)v31, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v30, (int8x16_t)v30, 0xCuLL), (int8x16_t)v30, 8uLL)));
    v34 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v33, 2), vaddq_f32(v33, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v33.f32, 1))).f32[0] <= 0.0;
    v35 = -1.0;
    if (!v34)
      v35 = 1.0;
    v36 = vmulq_f32(v29, v29);
    v37 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v36, 2), vaddq_f32(v36, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v36.f32, 1)));
    v37.f32[0] = sqrtf(v37.f32[0]);
    v38 = vmulq_f32(v30, v30);
    v39 = vmulq_f32(v31, v31);
    v37.i32[1] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v38, 2), vaddq_f32(v38, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v38.f32, 1))).f32[0]);
    v37.i32[2] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v39, 2), vaddq_f32(v39, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v39.f32, 1))).f32[0]);
    v555 = (__int128)vmulq_n_f32(v37, v35);
    v40 = vdivq_f32(v29, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v555, 0));
    v41 = vdivq_f32(v30, (float32x4_t)vdupq_lane_s32((int32x2_t)(v555 >> 32), 0));
    v42 = vdivq_f32(v31, (float32x4_t)vdupq_laneq_s32((int32x4_t)v555, 2));
    v43 = (int32x4_t)vmulq_f32(v40, v40);
    v43.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v43, 2), vadd_f32(*(float32x2_t *)v43.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v43.i8, 1))).u32[0];
    *(float32x2_t *)v37.f32 = vrsqrte_f32((float32x2_t)v43.u32[0]);
    *(float32x2_t *)v37.f32 = vmul_f32(*(float32x2_t *)v37.f32, vrsqrts_f32((float32x2_t)v43.u32[0], vmul_f32(*(float32x2_t *)v37.f32, *(float32x2_t *)v37.f32)));
    v621.columns[0] = (simd_float3)vmulq_n_f32(v40, vmul_f32(*(float32x2_t *)v37.f32, vrsqrts_f32((float32x2_t)v43.u32[0], vmul_f32(*(float32x2_t *)v37.f32, *(float32x2_t *)v37.f32))).f32[0]);
    v44 = vmulq_f32((float32x4_t)v621.columns[0], v41);
    v45 = vmulq_f32((float32x4_t)v621.columns[0], (float32x4_t)v621.columns[0]);
    v46 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v45, 2), vaddq_f32(v45, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v45.f32, 1)));
    v47 = vsubq_f32(v41, vmulq_n_f32((float32x4_t)v621.columns[0], vdivq_f32(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v44, 2), vaddq_f32(v44, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v44.f32, 1))), v46).f32[0]));
    v48 = (int32x4_t)vmulq_f32(v47, v47);
    v48.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v48, 2), vadd_f32(*(float32x2_t *)v48.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v48.i8, 1))).u32[0];
    *(float32x2_t *)v38.f32 = vrsqrte_f32((float32x2_t)v48.u32[0]);
    *(float32x2_t *)v38.f32 = vmul_f32(*(float32x2_t *)v38.f32, vrsqrts_f32((float32x2_t)v48.u32[0], vmul_f32(*(float32x2_t *)v38.f32, *(float32x2_t *)v38.f32)));
    v48.i32[0] = vmul_f32(*(float32x2_t *)v38.f32, vrsqrts_f32((float32x2_t)v48.u32[0], vmul_f32(*(float32x2_t *)v38.f32, *(float32x2_t *)v38.f32))).u32[0];
    v49 = vmulq_f32((float32x4_t)v621.columns[0], v42);
    v621.columns[1] = (simd_float3)vmulq_n_f32(v47, *(float *)v48.i32);
    v50 = vsubq_f32(v42, vmulq_n_f32((float32x4_t)v621.columns[0], vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v49, 2), vaddq_f32(v49, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v49.f32, 1))).f32[0]/ v46.f32[0]));
    v51 = vmulq_f32(v42, (float32x4_t)v621.columns[1]);
    v52 = vmulq_f32((float32x4_t)v621.columns[1], (float32x4_t)v621.columns[1]);
    v53 = vsubq_f32(v50, vmulq_n_f32((float32x4_t)v621.columns[1], vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v51, 2), vaddq_f32(v51, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v51.f32, 1))).f32[0]/ vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v52, 2), vaddq_f32(v52, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v52.f32, 1))).f32[0]));
    v54 = (int32x4_t)vmulq_f32(v53, v53);
    v54.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v54, 2), vadd_f32(*(float32x2_t *)v54.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v54.i8, 1))).u32[0];
    *(float32x2_t *)v52.f32 = vrsqrte_f32((float32x2_t)v54.u32[0]);
    *(float32x2_t *)v52.f32 = vmul_f32(*(float32x2_t *)v52.f32, vrsqrts_f32((float32x2_t)v54.u32[0], vmul_f32(*(float32x2_t *)v52.f32, *(float32x2_t *)v52.f32)));
    v621.columns[2] = (simd_float3)vmulq_n_f32(v53, vmul_f32(*(float32x2_t *)v52.f32, vrsqrts_f32((float32x2_t)v54.u32[0], vmul_f32(*(float32x2_t *)v52.f32, *(float32x2_t *)v52.f32))).f32[0]);
    *(double *)v55.i64 = simd_quaternion(v621);
    v56 = v55.i64[1];
    v57 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v55.f32, 1);
    v58 = vmovn_s32((int32x4_t)vmvnq_s8(vorrq_s8((int8x16_t)vcgtq_f32(v55, v57), (int8x16_t)vcgeq_f32(v57, v55)))).u8[0];
    *(int32x2_t *)v57.f32 = vrev64_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v55, (int8x16_t)v55, 8uLL));
    *(int8x8_t *)v57.f32 = vmvn_s8(vorr_s8((int8x8_t)vcltz_f32(*(float32x2_t *)v57.f32), (int8x8_t)vcgez_f32(*(float32x2_t *)v57.f32)));
    v59 = v58 | v57.i8[4] | v57.i8[0];
    v60 = (v59 & 1) == 0;
    if ((v59 & 1) != 0)
      v61 = 0;
    else
      v61 = v55.i64[0];
    *(_OWORD *)buf = v555;
    if (!v60)
      v56 = 0x3F80000000000000;
    *(_QWORD *)&buf[24] = v56;
    *(_QWORD *)&buf[16] = v61;
    *(_OWORD *)&buf[32] = v562;
    objc_msgSend(MEMORY[0x24BEBED10], "transformKeyTimesWithNode:", v8, *(double *)re::USDImportContext::concatenateLocalTransform((uint64_t)a3, (float32x4_t *)buf).i64);
    v62 = (void *)objc_claimAutoreleasedReturnValue();
    if ((unint64_t)objc_msgSend(v62, "arraySize") >= 2 && *(_BYTE *)(*((_QWORD *)a3 + 5) + 97))
    {

      if (v571)
      {
        *(_QWORD *)buf = off_24ED36578;
        *(_QWORD *)&buf[8] = 33;
        buf[16] = 0;
        *(_QWORD *)&buf[32] = &str_110;
        *(_QWORD *)&buf[24] = 0;
        LOWORD(v594) = 256;
        v598 = 0;
        v595 = 0u;
        v596 = 0u;
        v597 = 0;
        *(_QWORD *)buf = off_24ED339F8;
        __s[0] = 1;
        v64 = *(double *)a3;
        *((float *)&v594 + 1) = v64;
        if (v64 <= 0.0016667
          || fabsf(v64 + -0.0016667) < (float)((float)((float)(fabsf(v64) + 0.0016667) + 1.0) * 0.00001)
          || !*((_BYTE *)a3 + 32))
        {
          BYTE1(v594) = 0;
        }
        re::importSRTSampledAnimationFromUSKNode(v8, (float *)buf, (uint64_t)v615);
        data = (re *)re::Result<re::Unit,re::DetailedError>::operator=((uint64_t)__s, (uint64_t)v615);
        if (!v615[0].__r_.__value_.__s.__data_[0])
        {
          data = (re *)v615[1].__r_.__value_.__l.__data_;
          if (v615[1].__r_.__value_.__r.__words[0])
          {
            if ((v615[1].__r_.__value_.__s.__data_[8] & 1) != 0)
              data = (re *)(*(uint64_t (**)(void))(*(_QWORD *)v615[1].__r_.__value_.__l.__data_ + 40))();
          }
        }
        if (__s[0])
        {
          if (*(_BYTE *)(*((_QWORD *)a3 + 5) + 160))
          {
            v66 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[]((uint64_t)a3 + 624, *(_QWORD *)(*((_QWORD *)a3 + 106) + 8 * *((_QWORD *)a3 + 104) - 8));
            v617[0] = v598;
            v617[1] = *((_QWORD *)&v596 + 1);
            v615[0].__r_.__value_.__r.__words[0] = v66 + 432;
            v615[0].__r_.__value_.__l.__size_ = 1;
            LOBYTE(v594) = re::AnimationHelper::makeAdditiveForValues<re::GenericSRT<float>>((re *)v617, (uint64_t)v615, v598, *((unint64_t *)&v596 + 1));
          }
          re::USDImportContext::setTransformAnimation((uint64_t)a3, (uint64_t)buf);
        }
        else
        {
          v84 = (id)*re::pipelineLogObjects(data);
          if (os_log_type_enabled(v84, OS_LOG_TYPE_ERROR))
          {
            std::error_code::message(v615, (const std::error_code *)&__s[8]);
            if ((v615[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v485 = v615;
            else
              v485 = (std::string *)v615[0].__r_.__value_.__r.__words[0];
            if ((__s[32] & 1) != 0)
              v486 = *(_BYTE **)&__s[40];
            else
              v486 = &__s[33];
            LODWORD(v617[0]) = 136315394;
            *(_QWORD *)((char *)v617 + 4) = v485;
            WORD2(v617[1]) = 2080;
            *(_QWORD *)((char *)&v617[1] + 6) = v486;
            _os_log_error_impl(&dword_224FE9000, v84, OS_LOG_TYPE_ERROR, "Error: %s\nDetails:\n%s", (uint8_t *)v617, 0x16u);
            if (SHIBYTE(v615[0].__r_.__value_.__r.__words[2]) < 0)
              operator delete(v615[0].__r_.__value_.__l.__data_);
            v8 = v546;
            i = (unint64_t)obj;
          }

        }
        if (!__s[0] && *(_QWORD *)&__s[24] && (__s[32] & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)&__s[24] + 40))();
        *(_QWORD *)buf = off_24ED33A68;
        if (*((_QWORD *)&v595 + 1))
        {
          if (v598)
            (*(void (**)(void))(**((_QWORD **)&v595 + 1) + 40))();
          v598 = 0;
          v596 = 0uLL;
          *((_QWORD *)&v595 + 1) = 0;
          ++v597;
        }
        *(_QWORD *)buf = off_24ED36578;
        if (*(_QWORD *)&buf[40])
        {
          if ((buf[48] & 1) != 0)
            (*(void (**)(void))(**(_QWORD **)&buf[40] + 40))();
          *(_OWORD *)&buf[40] = 0u;
          v593 = 0u;
        }
        re::StringID::destroyString((re::StringID *)&buf[24]);
        v10 = v526;
      }
    }
    else
    {

    }
  }
  if (objc_msgSend(v10, "isEqualToString:", *MEMORY[0x24BEBEDF8]))
  {
    objc_msgSend(v8, "property:", CFSTR("visibility"));
    v85 = (void *)objc_claimAutoreleasedReturnValue();
    v86 = v85;
    if (!v85)
      goto LABEL_88;
    objc_msgSend(v85, "tokenValue");
    v87 = (void *)objc_claimAutoreleasedReturnValue();
    if (!v87)
      goto LABEL_88;
    v88 = v87;
    objc_msgSend(v87, "stringValue");
    v89 = v86;
    v90 = (void *)objc_claimAutoreleasedReturnValue();
    v91 = objc_msgSend(v90, "isEqualToString:", CFSTR("invisible"));

    v86 = v89;
    if ((v91 & 1) == 0)
    {
LABEL_88:
      v538 = v86;
      v605 = 0;
      memset(v603, 0, sizeof(v603));
      v604 = 0;
      v584[0] = 0;
      v582 = 0u;
      v583 = 0u;
      *(_QWORD *)&v584[1] = 0x7FFFFFFFLL;
      if (v571)
      {
        if (*(_BYTE *)(i + 165))
          isCatmullClarkSurface = re::isCatmullClarkSurface(v8);
        else
          isCatmullClarkSurface = 0;
        objc_msgSend(MEMORY[0x24BEBED10], "meshGroupsWithNode:", v8);
        v115 = (void *)objc_claimAutoreleasedReturnValue();
        v563 = v115;
        if (objc_msgSend(v115, "count"))
        {
          v580 = 0u;
          v581 = 0u;
          v578 = 0u;
          v579 = 0u;
          v116 = v115;
          v117 = objc_msgSend(v116, "countByEnumeratingWithState:objects:count:", &v578, v602, 16);
          if (v117)
          {
            v118 = v117;
            v119 = *(_QWORD *)v579;
            do
            {
              for (i = 0; i != v118; ++i)
              {
                if (*(_QWORD *)v579 != v119)
                  objc_enumerationMutation(v116);
                objc_msgSend(*(id *)(*((_QWORD *)&v578 + 1) + 8 * i), "inheritedMaterialBinding");
                v120 = (void *)objc_claimAutoreleasedReturnValue();
                if (v120)
                {
                  v615[0].__r_.__value_.__r.__words[0] = 0;
                  v615[0].__r_.__value_.__s.__data_[12] = 0;
                  re::ObjCObject::operator=((void **)&v615[0].__r_.__value_.__l.__data_, v120);
                  LODWORD(v615[0].__r_.__value_.__r.__words[1]) = HIDWORD(v583);
                  v615[0].__r_.__value_.__s.__data_[12] = isCatmullClarkSurface;
                  objc_msgSend(v120, "path");
                  v121 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_msgSend(v121, "stringValue");
                  v122 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
                  v123 = (_anonymous_namespace_ *)objc_msgSend(v122, "UTF8String");
                  buf[0] = isCatmullClarkSurface;
                  re::DynamicString::DynamicString((re::DynamicString *)&buf[8], (const re::DynamicString *)__s);
                  re::HashTable<re::ImportMaterialSignature,re::MaterialInfoUSK,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::add<re::MaterialInfoUSK&>((uint64_t)&v582, buf, (uint64_t)v615);
                  if (*(_QWORD *)&buf[8])
                  {
                    if ((buf[16] & 1) != 0)
                      (*(void (**)(void))(**(_QWORD **)&buf[8] + 40))();
                    memset(&buf[8], 0, 32);
                  }
                  if (*(_QWORD *)__s)
                  {
                    if ((__s[8] & 1) != 0)
                      (*(void (**)(void))(**(_QWORD **)__s + 40))();
                    memset(__s, 0, 32);
                  }

                }
              }
              v118 = objc_msgSend(v116, "countByEnumeratingWithState:objects:count:", &v578, v602, 16);
            }
            while (v118);
          }

          re::createMaterialAssetsFromMaterialTableUSK(obj, (uint64_t)&v582, (_anonymous_namespace_ *)v603);
          a3 = v561;
          v8 = v546;
        }
        else
        {
          objc_msgSend(v8, "inheritedMaterialBinding");
          v124 = (void *)objc_claimAutoreleasedReturnValue();
          if (v124)
          {
            v615[0].__r_.__value_.__r.__words[0] = 0;
            v615[0].__r_.__value_.__s.__data_[12] = 0;
            re::ObjCObject::operator=((void **)&v615[0].__r_.__value_.__l.__data_, v124);
            LODWORD(v615[0].__r_.__value_.__r.__words[1]) = HIDWORD(v583);
            v615[0].__r_.__value_.__s.__data_[12] = isCatmullClarkSurface;
            objc_msgSend(v124, "path");
            v125 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v125, "stringValue");
            v126 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
            v127 = (_anonymous_namespace_ *)objc_msgSend(v126, "UTF8String");
            buf[0] = isCatmullClarkSurface;
            re::DynamicString::DynamicString((re::DynamicString *)&buf[8], (const re::DynamicString *)__s);
            re::HashTable<re::ImportMaterialSignature,re::MaterialInfoUSK,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::add<re::MaterialInfoUSK&>((uint64_t)&v582, buf, (uint64_t)v615);
            if (*(_QWORD *)&buf[8])
            {
              if ((buf[16] & 1) != 0)
                (*(void (**)(void))(**(_QWORD **)&buf[8] + 40))();
              memset(&buf[8], 0, 32);
            }
            if (*(_QWORD *)__s)
            {
              if ((__s[8] & 1) != 0)
                (*(void (**)(void))(**(_QWORD **)__s + 40))();
              memset(__s, 0, 32);
            }

            v8 = v546;
            i = (unint64_t)obj;
          }
          re::createMaterialAssetsFromMaterialTableUSK((_QWORD *)i, (uint64_t)&v582, (_anonymous_namespace_ *)v603);
          re::addPhysicsMaterialAsset(v124, (uint64_t)a3, i, (uint64_t)&v582);

        }
        memset(__s, 0, 32);
        re::importVertexCacheAnimationFromUSKNode(v8, (float *)__s, (unint64_t)buf, *(double *)a3);
        if (buf[0])
        {
          v129 = v563;
          if (*(_QWORD *)&__s[16])
            re::USDImportContext::setVertexCacheAnimation((uint64_t)a3, __s);
        }
        else
        {
          v130 = (id)*re::pipelineLogObjects(v128);
          if (os_log_type_enabled(v130, OS_LOG_TYPE_ERROR))
          {
            objc_msgSend(v8, "path");
            v451 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v451, "stringValue");
            v452 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
            v453 = objc_msgSend(v452, "UTF8String");
            if ((buf[32] & 1) != 0)
              v454 = *(_BYTE **)&buf[40];
            else
              v454 = &buf[33];
            LODWORD(v615[0].__r_.__value_.__l.__data_) = 136315394;
            *(std::string::size_type *)((char *)v615[0].__r_.__value_.__r.__words + 4) = v453;
            WORD2(v615[0].__r_.__value_.__r.__words[1]) = 2080;
            *(std::string::size_type *)((char *)&v615[0].__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v454;
            _os_log_error_impl(&dword_224FE9000, v130, OS_LOG_TYPE_ERROR, "Mesh (%s) failed to import vertex cache: %s.", (uint8_t *)v615, 0x16u);

          }
          v129 = v563;
        }
        if (!buf[0] && *(_QWORD *)&buf[24] && (buf[32] & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)&buf[24] + 40))();
        re::FixedArray<re::VertexCacheAnimationData::FrameData>::deinit(&__s[8]);

      }
      v576 = 0;
      v577 = 0;
      v131 = v544;
      if (v544)
      {
        -[_anonymous_namespace_ path](v544, "path");
        v132 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v132, "stringValue");
        v133 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
        v134 = (char *)objc_msgSend(v133, "UTF8String");
        if (v134)
        {
          v135 = *v134;
          if (*v134)
          {
            v136 = v134[1];
            if (v136)
            {
              v137 = (unsigned __int8 *)(v134 + 2);
              do
              {
                v135 = 31 * v135 + v136;
                v138 = *v137++;
                v136 = v138;
              }
              while (v138);
            }
          }
        }
        else
        {
          v135 = 0;
        }
        *(_QWORD *)&__s[8] = v134;
        *(_QWORD *)__s = 2 * v135;

        v140 = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a3 + 112, __s);
        if (v140)
        {
          v141 = *v140;
          re::USDImportContext::setSkeletonReference(a3, *v140);
          v139 = re::BucketArray<re::USDImportContextSkeletonData,4ul>::operator[]((uint64_t)a3 + 56, v141) + 16;
          v576 = *(_QWORD *)&__s[8];
          v577 = strlen(*(const char **)&__s[8]);
          objc_msgSend(v8, "inheritedSkeletonAnimationBinding");
          v142 = objc_claimAutoreleasedReturnValue();
          if (!v142)
          {
            -[_anonymous_namespace_ inheritedSkeletonAnimationBinding](v544, "inheritedSkeletonAnimationBinding");
            v142 = objc_claimAutoreleasedReturnValue();
            if (!v142)
            {
              objc_msgSend(v8, "childIterator");
              v143 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v143, "nextObject");
              v142 = objc_claimAutoreleasedReturnValue();
              if (v142)
              {
                v144 = (void *)*MEMORY[0x24BEBEE08];
                while (1)
                {
                  -[NSObject type](v142, "type");
                  v145 = (void *)objc_claimAutoreleasedReturnValue();

                  if (v145 == v144)
                    break;
                  objc_msgSend(v143, "nextObject");
                  v146 = objc_claimAutoreleasedReturnValue();

                  v142 = v146;
                  if (!v146)
                    goto LABEL_240;
                }
                v142 = v142;

              }
LABEL_240:

            }
          }
          if (v571 && v142)
          {
            -[NSObject path](v142, "path");
            v208 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v208, "stringValue");
            v209 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
            v210 = (_anonymous_namespace_ *)objc_msgSend(v209, "UTF8String");
            *(_QWORD *)buf = 0;
            *(_QWORD *)&buf[8] = &str_110;
            v211 = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a3 + 216, buf);
            v212 = v211;
            if (v211)
              i = *v211;
            re::StringID::destroyString((re::StringID *)buf);

            if (v212)
            {
              re::USDImportContext::setSkeletalAnimationReference(a3, i);
            }
            else
            {
              v214 = (id)*re::pipelineLogObjects(v213);
              if (os_log_type_enabled(v214, OS_LOG_TYPE_ERROR))
              {
                objc_msgSend(v546, "path");
                v479 = (void *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(v479, "stringValue");
                v480 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
                v481 = objc_msgSend(v480, "UTF8String");
                -[NSObject path](v142, "path");
                v482 = (void *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(v482, "stringValue");
                v483 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
                v484 = objc_msgSend(v483, "UTF8String");
                *(_DWORD *)buf = 136315394;
                *(_QWORD *)&buf[4] = v481;
                *(_WORD *)&buf[12] = 2080;
                *(_QWORD *)&buf[14] = v484;
                _os_log_error_impl(&dword_224FE9000, v214, OS_LOG_TYPE_ERROR, "Mesh (%s) could not find to skeletal animation: %s.", buf, 0x16u);

                a3 = v561;
              }

            }
          }
        }
        else
        {
          v142 = (id)*re::pipelineLogObjects(0);
          if (os_log_type_enabled(v142, OS_LOG_TYPE_ERROR))
          {
            objc_msgSend(v8, "path");
            v455 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v455, "stringValue");
            v456 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
            v457 = objc_msgSend(v456, "UTF8String");
            -[_anonymous_namespace_ path](v544, "path");
            v458 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v458, "stringValue");
            v459 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
            v460 = objc_msgSend(v459, "UTF8String");
            *(_DWORD *)buf = 136315394;
            *(_QWORD *)&buf[4] = v457;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = v460;
            _os_log_error_impl(&dword_224FE9000, v142, OS_LOG_TYPE_ERROR, "Mesh (%s) could not find to skeleton: %s.", buf, 0x16u);

          }
          v139 = 0;
        }

        re::StringID::destroyString((re::StringID *)__s);
      }
      else
      {
        v139 = 0;
      }
      v215 = v584[0];
      if (v584[0])
      {
        v216 = 0;
        v217 = (int *)(v583 + 8);
        while (1)
        {
          v218 = *v217;
          v217 += 18;
          if (v218 < 0)
            break;
          if (v584[0] == ++v216)
          {
            LODWORD(v216) = v584[0];
            break;
          }
        }
      }
      else
      {
        LODWORD(v216) = 0;
      }
      if (v584[0] != (_DWORD)v216)
      {
        v219 = v216;
        v220 = v583;
        while (1)
        {
          v221 = (void *)MEMORY[0x24BEBED10];
          v222 = *(id *)(v220 + 72 * v219 + 56);
          objc_msgSend(v221, "firstUVMeshAttributeNameInMaterial:", v222);
          v223 = (void *)objc_claimAutoreleasedReturnValue();

          if (v223)
            break;
          v220 = v583;
          if (v584[0] <= (int)v216 + 1)
            v224 = v216 + 1;
          else
            v224 = v584[0];
          while (1)
          {
            v219 = (v216 + 1);
            if (v224 - 1 == (_DWORD)v216)
              break;
            LODWORD(v216) = v216 + 1;
            v225 = v219;
            if ((*(_DWORD *)(v583 + 72 * v219 + 8) & 0x80000000) != 0)
              goto LABEL_267;
          }
          v225 = v224;
LABEL_267:
          LODWORD(v216) = v225;
          if (v215 == v225)
            goto LABEL_270;
        }
        *(_QWORD *)buf = "primvars:";
        *(_QWORD *)&buf[8] = 9;
        re::DynamicString::operator=((re::DynamicString *)&v574, (uint64_t)buf);
        v226 = objc_retainAutorelease(v223);
        v227 = (const char *)objc_msgSend(v226, "UTF8String");
        v228 = strlen(v227);
        re::DynamicString::append((re::DynamicString *)&v574, v227, v228);

      }
LABEL_270:
      if (v571)
        v229 = v566;
      else
        v229 = 1;
      v8 = v546;
      if ((v229 & 1) == 0)
      {
        v230 = *((unsigned __int8 *)obj + 164);
        objc_msgSend(v546, "customMetadataWithKey:", CFSTR("RE:mesh:v1:importAllMeshAttributes"));
        v231 = (void *)objc_claimAutoreleasedReturnValue();
        v232 = v231;
        v233 = v230 != 0;
        if (v231)
          v233 = objc_msgSend(v231, "BOOLValue");
        re::makeGeomModelDescriptorFromUSKNode(v546, (uint64_t)&v574, (uint64_t)&v582, *((unsigned __int8 *)obj + 165), *((unsigned __int8 *)obj + 166), v233, (uint64_t)&v576, v139, (uint64_t)buf);
        if (buf[0])
        {
          v550 = v546;
          objc_msgSend(v550, "property:", CFSTR("skel:blendShapeTargets"));
          v235 = (void *)objc_claimAutoreleasedReturnValue();
          if (v235)
          {
            v528 = v235;
            v531 = v232;
            objc_msgSend(v235, "objectPathArray");
            obja = (id)objc_claimAutoreleasedReturnValue();
            if (obja)
            {
              v616 = 0u;
              memset(v615, 0, sizeof(v615));
              v236 = objc_msgSend(obja, "countByEnumeratingWithState:objects:count:", v615, __s, 16);
              if (v236)
              {
                v237 = v236;
                v238 = *(_QWORD *)v615[0].__r_.__value_.__r.__words[2];
                do
                {
                  v239 = 0;
                  do
                  {
                    if (*(_QWORD *)v615[0].__r_.__value_.__r.__words[2] != v238)
                      objc_enumerationMutation(obja);
                    v240 = *(id *)(v615[0].__r_.__value_.__l.__size_ + 8 * v239);
                    v241 = v240;
                    if (v240)
                    {
                      objc_msgSend(v240, "stringValue");
                      v242 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
                      v243 = (char *)objc_msgSend(v242, "UTF8String");
                      if (v243)
                      {
                        v244 = *v243;
                        if (*v243)
                        {
                          v245 = v243[1];
                          if (v245)
                          {
                            v246 = (unsigned __int8 *)(v243 + 2);
                            do
                            {
                              v244 = 31 * v244 + v245;
                              v247 = *v246++;
                              v245 = v247;
                            }
                            while (v247);
                          }
                        }
                      }
                      else
                      {
                        v244 = 0;
                      }
                      v617[0] = 2 * v244;
                      v617[1] = v243;
                      v248 = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)v561 + 320, v617);
                      if (!v248)
                      {
                        re::StringID::destroyString((re::StringID *)v617);

                        goto LABEL_321;
                      }
                      v249 = *v248;
                      re::StringID::destroyString((re::StringID *)v617);

                      v250 = re::BucketArray<re::USDImportContextBlendShapeData,8ul>::operator[]((uint64_t)v561 + 264, v249);
                      v251 = *(_QWORD *)(v250 + 40);
                      v252 = *(_QWORD *)&buf[24];
                      if (v251 >= *(_QWORD *)&buf[24])
                      {
                        objc_msgSend(MEMORY[0x24BDBCEC8], "dataWithLength:", 12 * v251);
                        v254 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
                        memcpy((void *)objc_msgSend(v254, "mutableBytes"), *(const void **)(v250 + 48), 12 * *(_QWORD *)(v250 + 40));
                        v256 = *(_QWORD *)(v250 + 40);
                      }
                      else
                      {
                        objc_msgSend(MEMORY[0x24BDBCEC8], "dataWithLength:", 12 * v251 + 12);
                        v253 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
                        memcpy((void *)objc_msgSend(v253, "mutableBytes"), *(const void **)(v250 + 48), 12 * v251);
                        v254 = objc_retainAutorelease(v253);
                        v255 = objc_msgSend(v254, "mutableBytes") + 12 * *(_QWORD *)(v250 + 40);
                        *(_QWORD *)v255 = 0;
                        *(_DWORD *)(v255 + 8) = 0;
                        v256 = *(_QWORD *)(v250 + 40) + 1;
                      }
                      v257 = v254;
                      v258 = v257;
                      v588 = v257;
                      LOBYTE(v589) = 11;
                      v590 = v256;
                      v591 = xmmword_226104380;
                      v259 = *(_QWORD *)(v250 + 88);
                      if (v259 == *(_QWORD *)&buf[24])
                      {
                        if (v259)
                        {
                          objc_msgSend(MEMORY[0x24BDBCEC8], "dataWithLength:", 4 * v259);
                          v260 = (void *)objc_claimAutoreleasedReturnValue();
                          if (v251 < v252 && *(_QWORD *)&buf[24])
                          {
                            v261 = 0;
                            do
                              *(_DWORD *)(objc_msgSend(objc_retainAutorelease(v260), "mutableBytes") + 4 * v261++) = v256 - 1;
                            while (v261 < *(_QWORD *)&buf[24]);
                          }
                          v262 = objc_retainAutorelease(v260);
                          memcpy((void *)objc_msgSend(v262, "mutableBytes"), *(const void **)(v250 + 96), 4 * *(_QWORD *)(v250 + 88));
                          v263 = v262;
                          v586.__r_.__value_.__r.__words[0] = (std::string::size_type)v263;
                          v586.__r_.__value_.__s.__data_[8] = 5;
                          v586.__r_.__value_.__r.__words[2] = *(_QWORD *)&buf[24];
                          v587 = xmmword_226104390;
                          re::DynamicString::format((re::DynamicString *)"%s|blendTargetPosDeltas", (re::DynamicString *)v606, *(_QWORD *)(v250 + 24));
                          re::GeomModelDescriptor::setAttribute(&buf[8], (uint64_t)v606, 1, (uint64_t)&v588, (uint64_t)&v586, (uint64_t)v617);
                          v264 = *(re **)v606;
                          if (*(_QWORD *)v606 && (v606[8] & 1) != 0)
                            v264 = (re *)(*(uint64_t (**)(void))(**(_QWORD **)v606 + 40))();
                          if (!LOBYTE(v617[0]))
                          {
                            v265 = *re::pipelineLogObjects(v264);
                            if (os_log_type_enabled(v265, OS_LOG_TYPE_ERROR))
                            {
                              v273 = v265;
                              v534 = *(_QWORD *)(v250 + 24);
                              if ((v600[40] & 1) != 0)
                                v274 = *(_BYTE **)&v601[7];
                              else
                                v274 = v601;
                              objc_msgSend(v550, "name");
                              v275 = (void *)objc_claimAutoreleasedReturnValue();
                              objc_msgSend(v275, "stringValue");
                              v276 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
                              v277 = objc_msgSend(v276, "UTF8String");
                              *(_DWORD *)v606 = 136315650;
                              *(_QWORD *)&v606[4] = v534;
                              v607 = 2080;
                              v608 = v274;
                              v609 = 2080;
                              v610 = v277;
                              _os_log_error_impl(&dword_224FE9000, v273, OS_LOG_TYPE_ERROR, "Could not store blend shape '%s' in geomModel '%s' for node '%s'\n", v606, 0x20u);

                            }
                            if (!LOBYTE(v617[0]) && v617[3] && (v618 & 1) != 0)
                              (*(void (**)(void))(*(_QWORD *)v617[3] + 40))();
                          }

LABEL_320:
                          goto LABEL_321;
                        }
                      }
                      else
                      {
                        v266 = *re::pipelineLogObjects((re *)v257);
                        if (os_log_type_enabled(v266, OS_LOG_TYPE_DEFAULT))
                        {
                          v267 = v266;
                          v268 = *(_QWORD *)(v250 + 24);
                          objc_msgSend(v550, "name");
                          v269 = (void *)objc_claimAutoreleasedReturnValue();
                          objc_msgSend(v269, "stringValue");
                          v270 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
                          v271 = objc_msgSend(v270, "UTF8String");
                          v272 = *(_QWORD *)(v250 + 88);
                          LODWORD(v617[0]) = 136315906;
                          *(_QWORD *)((char *)v617 + 4) = v268;
                          WORD2(v617[1]) = 2080;
                          *(_QWORD *)((char *)&v617[1] + 6) = v271;
                          HIWORD(v617[2]) = 2048;
                          v617[3] = v272;
                          v618 = 2048;
                          *(_QWORD *)v619 = *(_QWORD *)&buf[24];
                          _os_log_impl(&dword_224FE9000, v267, OS_LOG_TYPE_DEFAULT, "Blend shape '%s' in node '%s' has %zu indices but model has %zu vertices. Point indices will be ignored.", (uint8_t *)v617, 0x2Au);

                        }
                      }
                      re::DynamicString::format((re::DynamicString *)"%s|blendTargetPosDeltas", (re::DynamicString *)v617, *(_QWORD *)(v250 + 24));
                      re::GeomModelDescriptor::setAttribute(&buf[8], (uint64_t)v617, 1, (uint64_t)&v588, 0, (uint64_t)v585);
                      if (!LOBYTE(v585[0]) && *((_QWORD *)&v585[1] + 1))
                      {
                        if ((v585[2] & 1) != 0)
                          (*(void (**)(void))(**((_QWORD **)&v585[1] + 1) + 40))();
                        memset((char *)&v585[1] + 8, 0, 32);
                      }
                      if (v617[0] && (v617[1] & 1) != 0)
                        (*(void (**)(void))(*(_QWORD *)v617[0] + 40))();
                      goto LABEL_320;
                    }
LABEL_321:

                    ++v239;
                  }
                  while (v239 != v237);
                  v278 = objc_msgSend(obja, "countByEnumeratingWithState:objects:count:", v615, __s, 16);
                  v237 = v278;
                }
                while (v278);
              }
            }

            a3 = v561;
            v8 = v546;
            v235 = v528;
            v232 = v531;
          }

          re::USDImportContext::setModel((uint64_t)a3, (uint64_t)&buf[8]);
          v279 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[]((uint64_t)a3 + 624, *(_QWORD *)(*((_QWORD *)a3 + 106) + 8 * *((_QWORD *)a3 + 104) - 8));
          re::DynamicArray<re::AssetHandle>::operator=(v279 + 808, (uint64_t)v603);
        }
        else
        {
          v280 = (id)*re::pipelineLogObjects(v234);
          if (os_log_type_enabled(v280, OS_LOG_TYPE_ERROR))
          {
            std::error_code::message((std::string *)__s, (const std::error_code *)&buf[8]);
            v461 = __s[23] >= 0 ? __s : *(_BYTE **)__s;
            v462 = (buf[32] & 1) != 0 ? *(_BYTE **)&buf[40] : &buf[33];
            LODWORD(v615[0].__r_.__value_.__l.__data_) = 136315394;
            *(std::string::size_type *)((char *)v615[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v461;
            WORD2(v615[0].__r_.__value_.__r.__words[1]) = 2080;
            *(std::string::size_type *)((char *)&v615[0].__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v462;
            _os_log_error_impl(&dword_224FE9000, v280, OS_LOG_TYPE_ERROR, "Error: %s\nDetails:\n%s", (uint8_t *)v615, 0x16u);
            if ((__s[23] & 0x80000000) != 0)
              operator delete(*(void **)__s);
          }

        }
        re::updateMeshOverrideCompileOptions(a3, v8);
        re::Result<re::GeomModelDescriptor,re::DetailedError>::~Result((uint64_t)buf);

      }
      if (v574 && (v575 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v574 + 40))();
      re::HashTable<re::ImportMaterialSignature,re::MaterialInfo,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::deinit((uint64_t *)&v582);
      re::DynamicArray<re::AssetHandle>::deinit((uint64_t)v603);
      v86 = v538;
    }
    goto LABEL_340;
  }
  if (!objc_msgSend(v10, "isEqualToString:", *MEMORY[0x24BEBEE10]))
  {
    v98 = (void *)*MEMORY[0x24BEBEDE0];
    if ((objc_msgSend(v10, "isEqualToString:", *MEMORY[0x24BEBEDE0]) & 1) == 0
      && (objc_msgSend(v10, "isEqualToString:", *MEMORY[0x24BEBEDD8]) & 1) == 0
      && (objc_msgSend(v10, "isEqualToString:", *MEMORY[0x24BEBEE20]) & 1) == 0
      && (objc_msgSend(v10, "isEqualToString:", *MEMORY[0x24BEBEDD0]) & 1) == 0
      && (objc_msgSend(v10, "isEqualToString:", *MEMORY[0x24BEBEDE8]) & 1) == 0
      && !re::importPhysicsIsSceneGroundPlane(v8))
    {
      v467 = (re *)objc_msgSend(v10, "isEqualToString:", *MEMORY[0x24BEBEE18]);
      if ((_DWORD)v467)
      {
        v468 = re::globalAllocators(v467);
        v469 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v468[2] + 32))(v468[2], 72, 8);
        *(_OWORD *)v469 = 0u;
        *(_OWORD *)(v469 + 16) = 0u;
        *(_OWORD *)(v469 + 32) = 0u;
        *(_QWORD *)(v469 + 20) = 0x13F800000;
        *(_QWORD *)(v469 + 56) = 0;
        *(_QWORD *)(v469 + 64) = 0;
        *(_QWORD *)(v469 + 48) = 0;
        *(_QWORD *)buf = v469;
        v470 = (_QWORD *)operator new();
        *v470 = &off_24ED434F8;
        v470[1] = 0;
        v470[2] = 0;
        v470[3] = v469;
        *(_QWORD *)&buf[8] = v470;
        re::usdimport::SpatialAudioNodeData::configureFromUSDNode(*(unsigned __int8 **)buf, v8, *(_anonymous_namespace_ **)(i + 104), (double *)a3, v571 != 0);
        re::USDImportContext::setSpatialAudioData((uint64_t)a3, (uint64_t *)buf);
        v471 = *(_QWORD *)buf;
        v472 = *(_QWORD *)(*(_QWORD *)buf + 40);
        if (v472)
        {
          re::DynamicString::operator=((re::DynamicString *)(v472 + 40), "AudioAnimation.animationState");
          re::USDImportContext::setAdditionalAnimation(a3, *(re::Timeline **)(*(_QWORD *)buf + 40));
          v471 = *(_QWORD *)buf;
        }
        v473 = *(_QWORD *)(v471 + 32);
        if (v473)
        {
          re::DynamicString::operator=((re::DynamicString *)(v473 + 40), "AudioAnimation.animationGain");
          re::USDImportContext::setAdditionalAnimation(a3, *(re::Timeline **)(*(_QWORD *)buf + 32));
        }
        std::shared_ptr<re::AssetManager>::~shared_ptr[abi:nn180100]((uint64_t)buf);
        goto LABEL_341;
      }
      objc_msgSend(v8, "typeName");
      v474 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v474, "stringValue");
      v475 = (void *)objc_claimAutoreleasedReturnValue();
      v476 = objc_msgSend(v475, "isEqualToString:", CFSTR("Preliminary_Text"));

      if (v476)
      {
        objc_msgSend(v8, "property:", CFSTR("content"));
        v477 = (_anonymous_namespace_ *)objc_claimAutoreleasedReturnValue();
        v568 = v477;
        if (v477)
        {
          objc_msgSend(v8, "property:", CFSTR("content"));
          v549 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v549, "stringValue");
          v547 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
          v477 = (_anonymous_namespace_ *)objc_msgSend(v547, "UTF8String");
          v478 = (const char *)v477;
        }
        else
        {
          v478 = "";
        }
        objc_msgSend(v8, "property:", CFSTR("font"));
        v497 = (_anonymous_namespace_ *)objc_claimAutoreleasedReturnValue();
        v573 = v497;
        if (v497)
        {
          objc_msgSend(v8, "property:", CFSTR("font"));
          v542 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v542, "stringArray");
          v537 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v537, "objectAtIndex:", 0);
          v533 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
          v497 = (_anonymous_namespace_ *)objc_msgSend(v533, "UTF8String");
          v498 = (const char *)v497;
        }
        else
        {
          v498 = "Helvetica";
        }
        objc_msgSend(v8, "property:", CFSTR("pointSize"));
        v499 = objc_claimAutoreleasedReturnValue();
        if (v499)
        {
          objc_msgSend(v8, "property:", CFSTR("pointSize"));
          v530 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v530, "doubleValue");
          v501 = v500 * 0.00035277723;
        }
        else
        {
          v501 = 0.0507999211;
        }
        *((double *)&v593 + 1) = v501;
        objc_msgSend(v8, "property:", CFSTR("width"));
        v502 = objc_claimAutoreleasedReturnValue();
        if (v502)
        {
          objc_msgSend(v8, "property:", CFSTR("width"));
          v527 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v527, "doubleValue");
        }
        else
        {
          v503 = 0x3FE3333333333333;
        }
        v594 = v503;
        objc_msgSend(v8, "property:", CFSTR("height"));
        v504 = objc_claimAutoreleasedReturnValue();
        if (v504)
        {
          objc_msgSend(v8, "property:", CFSTR("height"));
          v525 = (std::error_code *)objc_claimAutoreleasedReturnValue();
          -[std::error_code doubleValue](v525, "doubleValue");
        }
        else
        {
          v505 = 0x3FC3333333333333;
        }
        *(_QWORD *)&v595 = v505;
        objc_msgSend(v8, "property:", CFSTR("depth"));
        v506 = (void *)objc_claimAutoreleasedReturnValue();
        v560 = (void *)v504;
        if (v506)
        {
          objc_msgSend(v8, "property:", CFSTR("depth"));
          v524 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v524, "doubleValue");
        }
        else
        {
          v507 = 0x3FC999999999999ALL;
        }
        v565 = (void *)v502;
        v554 = (void *)v499;
        *((_QWORD *)&v595 + 1) = v507;
        v508 = &v596;
        objc_msgSend(v8, "property:", CFSTR("wrapMode"));
        v509 = (_anonymous_namespace_ *)objc_claimAutoreleasedReturnValue();
        v510 = v509;
        if (v509)
        {
          objc_msgSend(v8, "property:", CFSTR("wrapMode"));
          v523 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v523, "stringValue");
          v521 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
          v509 = (_anonymous_namespace_ *)objc_msgSend(v521, "UTF8String");
          v511 = (const char *)v509;
        }
        else
        {
          v511 = "flowing";
        }
        objc_msgSend(v8, "property:", CFSTR("horizontalAlignment"));
        v512 = (_anonymous_namespace_ *)objc_claimAutoreleasedReturnValue();
        v513 = v512;
        if (v512)
        {
          objc_msgSend(v8, "property:", CFSTR("horizontalAlignment"));
          v28 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v28, "stringValue");
          v508 = (__int128 *)objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
          v512 = (_anonymous_namespace_ *)objc_msgSend(v508, "UTF8String");
          v514 = (const char *)v512;
        }
        else
        {
          v514 = "center";
        }
        objc_msgSend(v8, "property:", CFSTR("verticalAlignment"));
        v515 = (_anonymous_namespace_ *)objc_claimAutoreleasedReturnValue();
        v516 = v515;
        if (v515)
        {
          objc_msgSend(v8, "property:", CFSTR("verticalAlignment"));
          v4 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v4, "stringValue");
          a3 = (re::USDImportContext *)objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
          v515 = (_anonymous_namespace_ *)-[re::USDImportContext UTF8String](a3, "UTF8String");
          v517 = (const char *)v515;
        }
        else
        {
          v517 = "center";
        }
        re::USDImportContext::setText3D(v561, (const re::USDImportContext::GeomText3D *)buf);
        re::USDImportContext::GeomText3D::~GeomText3D((re::USDImportContext::GeomText3D *)buf);
        if (v516)
        {

        }
        v8 = v546;
        if (v513)
        {

        }
        a3 = v561;
        if (v510)
        {

        }
        if (v506)

        if (v560)
        if (v565)

        if (v554)
        if (v573)
        {

        }
        if (v568)
        {

        }
        objc_msgSend(v546, "inheritedMaterialBinding");
        v488 = (void *)objc_claimAutoreleasedReturnValue();
        if (v488)
        {
          *(_QWORD *)&v585[0] = 0;
          BYTE12(v585[0]) = 0;
          re::ObjCObject::operator=((void **)v585, v488);
          *(_QWORD *)&__s[32] = 0;
          memset(__s, 0, 28);
          memset(buf, 0, 36);
          *(_QWORD *)&buf[36] = 0x7FFFFFFFLL;
          objc_msgSend(v488, "path");
          v518 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v518, "stringValue");
          v519 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
          v520 = (_anonymous_namespace_ *)objc_msgSend(v519, "UTF8String");
          v615[0].__r_.__value_.__s.__data_[0] = 0;
          re::DynamicString::DynamicString((re::DynamicString *)&v615[0].__r_.__value_.__r.__words[1], (const re::DynamicString *)v617);
          re::HashTable<re::ImportMaterialSignature,re::MaterialInfoUSK,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::add<re::MaterialInfoUSK&>((uint64_t)buf, (char *)v615, (uint64_t)v585);
          if (v615[0].__r_.__value_.__l.__size_)
          {
            if ((v615[0].__r_.__value_.__s.__data_[16] & 1) != 0)
              (*(void (**)(void))(*(_QWORD *)v615[0].__r_.__value_.__l.__size_ + 40))();
            memset(&v615[0].__r_.__value_.__r.__words[1], 0, 32);
          }
          if (v617[0])
          {
            if ((v617[1] & 1) != 0)
              (*(void (**)(void))(*(_QWORD *)v617[0] + 40))();
            memset(v617, 0, sizeof(v617));
          }

          re::createMaterialAssetsFromMaterialTableUSK(obj, (uint64_t)buf, (_anonymous_namespace_ *)__s);
          re::USDImportContext::setMeshMaterials((uint64_t)v561, (uint64_t)__s);
          re::addPhysicsMaterialAsset(v488, (uint64_t)v561, (uint64_t)obj, (uint64_t)buf);
          re::HashTable<re::ImportMaterialSignature,re::MaterialInfo,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::deinit((uint64_t *)buf);
          re::DynamicArray<re::AssetHandle>::deinit((uint64_t)__s);

        }
      }
      else
      {
        v487 = objc_msgSend(MEMORY[0x24BEBED10], "isTransformNode:", v8);
        if (!v571 || !v487)
          goto LABEL_341;
        objc_msgSend(v8, "inheritedMaterialBinding");
        v488 = (void *)objc_claimAutoreleasedReturnValue();
        memset(buf, 0, 36);
        *(_QWORD *)&buf[36] = 0x7FFFFFFFLL;
        if (v488)
        {
          v617[0] = 0;
          BYTE4(v617[1]) = 0;
          re::ObjCObject::operator=((void **)v617, v488);
          LODWORD(v617[1]) = *(_DWORD *)&buf[28];
          BYTE4(v617[1]) = 0;
          objc_msgSend(v488, "path");
          v489 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v489, "stringValue");
          v490 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
          v491 = (_anonymous_namespace_ *)objc_msgSend(v490, "UTF8String");
          __s[0] = 0;
          re::DynamicString::DynamicString((re::DynamicString *)&__s[8], (const re::DynamicString *)v615);
          re::HashTable<re::ImportMaterialSignature,re::MaterialInfoUSK,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::add<re::MaterialInfoUSK&>((uint64_t)buf, __s, (uint64_t)v617);
          if (*(_QWORD *)&__s[8])
          {
            if ((__s[16] & 1) != 0)
              (*(void (**)(void))(**(_QWORD **)&__s[8] + 40))();
            memset(&__s[8], 0, 32);
          }
          if (v615[0].__r_.__value_.__r.__words[0])
          {
            if ((v615[0].__r_.__value_.__s.__data_[8] & 1) != 0)
              (*(void (**)(void))(*(_QWORD *)v615[0].__r_.__value_.__l.__data_ + 40))();
            memset(v615, 0, 32);
          }

          re::addPhysicsMaterialAsset(v488, (uint64_t)a3, i, (uint64_t)buf);
        }
        re::HashTable<re::ImportMaterialSignature,re::MaterialInfo,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::deinit((uint64_t *)buf);
      }

      goto LABEL_341;
    }
    if (!v571)
      goto LABEL_341;
    v615[1].__r_.__value_.__l.__size_ = 0;
    memset(v615, 0, 28);
    memset(buf, 0, 36);
    *(_QWORD *)&buf[36] = 0x7FFFFFFFLL;
    objc_msgSend(v8, "inheritedMaterialBinding");
    v99 = (void *)objc_claimAutoreleasedReturnValue();
    if (v99)
    {
      *(_QWORD *)&v585[0] = 0;
      BYTE12(v585[0]) = 0;
      re::ObjCObject::operator=((void **)v585, v99);
      DWORD2(v585[0]) = *(_DWORD *)&buf[28];
      BYTE12(v585[0]) = 0;
      objc_msgSend(v99, "path");
      v100 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v100, "stringValue");
      v101 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
      v102 = (_anonymous_namespace_ *)objc_msgSend(v101, "UTF8String");
      __s[0] = 0;
      re::DynamicString::DynamicString((re::DynamicString *)&__s[8], (const re::DynamicString *)v617);
      re::HashTable<re::ImportMaterialSignature,re::MaterialInfoUSK,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::add<re::MaterialInfoUSK&>((uint64_t)buf, __s, (uint64_t)v585);
      if (*(_QWORD *)&__s[8])
      {
        if ((__s[16] & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)&__s[8] + 40))();
        memset(&__s[8], 0, 32);
      }
      v8 = v546;
      if (v617[0])
      {
        if ((v617[1] & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v617[0] + 40))();
        memset(v617, 0, sizeof(v617));
      }

    }
    re::createMaterialAssetsFromMaterialTableUSK((_QWORD *)i, (uint64_t)buf, (_anonymous_namespace_ *)v615);
    if ((v566 & 1) != 0)
    {
LABEL_238:

      re::HashTable<re::ImportMaterialSignature,re::MaterialInfo,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::deinit((uint64_t *)buf);
      re::DynamicArray<re::AssetHandle>::deinit((uint64_t)v615);
      goto LABEL_341;
    }
    v103 = v8;
    *(_QWORD *)&__s[40] = 0x3F80000000000000;
    *(_QWORD *)&__s[32] = 0;
    objc_msgSend(v103, "type");
    v104 = (void *)objc_claimAutoreleasedReturnValue();

    if (v104 == v98)
    {
      objc_msgSend(v103, "property:", CFSTR("size"));
      v154 = (void *)objc_claimAutoreleasedReturnValue();
      v155 = v154;
      v156 = 2.0;
      if (v154)
      {
        objc_msgSend(v154, "data");
        v157 = (void *)objc_claimAutoreleasedReturnValue();

        if (v157)
        {
          objc_msgSend(v155, "floatValue");
          v156 = v158;
        }
      }
      __s[0] = 0;
      *(_QWORD *)&__s[4] = 0x1000100010001;
      *(_DWORD *)&__s[12] = 0;
      *(float *)&__s[16] = v156;
      *(float *)&__s[20] = v156;
      *(float *)&__s[24] = v156;
      *(_WORD *)&__s[28] = 257;
      __s[30] = 0;
      goto LABEL_237;
    }
    objc_msgSend(v103, "type");
    v105 = (void *)objc_claimAutoreleasedReturnValue();
    v106 = (void *)*MEMORY[0x24BEBEDD8];

    if (v105 == v106)
    {
      objc_msgSend(v103, "property:", CFSTR("radius"));
      v161 = (void *)objc_claimAutoreleasedReturnValue();
      v155 = v161;
      v162 = 1.0;
      if (v161)
      {
        objc_msgSend(v161, "data");
        v163 = (void *)objc_claimAutoreleasedReturnValue();

        if (v163)
        {
          objc_msgSend(v155, "floatValue");
          v162 = v164;
        }
      }
      objc_msgSend(v103, "property:", CFSTR("height"));
      v165 = (void *)objc_claimAutoreleasedReturnValue();
      v166 = v165;
      v167 = 2.0;
      if (v165)
      {
        objc_msgSend(v165, "data");
        v168 = (void *)objc_claimAutoreleasedReturnValue();

        if (v168)
        {
          v165 = (void *)objc_msgSend(v166, "floatValue");
          v167 = v169;
        }
      }
      __s[0] = 1;
      *(_DWORD *)&__s[4] = 65544;
      *(float *)&__s[8] = v167;
      *(float *)&__s[12] = v162;
      *(_DWORD *)&__s[16] = 65793;
      objc_msgSend(v103, "property:", CFSTR("axis"));
      v170 = (void *)objc_claimAutoreleasedReturnValue();
      v171 = v170;
      if (v170)
      {
        objc_msgSend(v170, "data");
        v172 = (void *)objc_claimAutoreleasedReturnValue();

        if (v172)
        {
          objc_msgSend(v171, "stringValue");
          v173 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
          v174 = (const char *)objc_msgSend(v173, "UTF8String");
          v175 = strlen(v174);
          *(_QWORD *)&v585[0] = v174;
          *((_QWORD *)&v585[0] + 1) = v175;
          re::DynamicString::operator=((re::DynamicString *)v617, (uint64_t)v585);

        }
      }
    }
    else
    {
      objc_msgSend(v103, "type");
      v107 = (void *)objc_claimAutoreleasedReturnValue();
      v108 = (void *)*MEMORY[0x24BEBEDE8];

      if (v107 == v108)
      {
        objc_msgSend(v103, "property:", CFSTR("radius"));
        v176 = (void *)objc_claimAutoreleasedReturnValue();
        v155 = v176;
        v177 = 1.0;
        if (v176)
        {
          objc_msgSend(v176, "data");
          v178 = (void *)objc_claimAutoreleasedReturnValue();

          if (v178)
          {
            objc_msgSend(v155, "floatValue");
            v177 = v179;
          }
        }
        objc_msgSend(v103, "property:", CFSTR("height"));
        v180 = (void *)objc_claimAutoreleasedReturnValue();
        v166 = v180;
        v181 = 2.0;
        if (v180)
        {
          objc_msgSend(v180, "data");
          v182 = (void *)objc_claimAutoreleasedReturnValue();

          if (v182)
          {
            v180 = (void *)objc_msgSend(v166, "floatValue");
            v181 = v183;
          }
        }
        objc_msgSend(v103, "property:", CFSTR("axis"));
        v184 = (void *)objc_claimAutoreleasedReturnValue();
        v171 = v184;
        if (v184)
        {
          objc_msgSend(v184, "data");
          v185 = (void *)objc_claimAutoreleasedReturnValue();

          if (v185)
          {
            objc_msgSend(v171, "stringValue");
            v186 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
            v187 = (const char *)objc_msgSend(v186, "UTF8String");
            v188 = strlen(v187);
            *(_QWORD *)&v585[0] = v187;
            *((_QWORD *)&v585[0] + 1) = v188;
            re::DynamicString::operator=((re::DynamicString *)v617, (uint64_t)v585);

          }
        }
        __s[0] = 2;
        *(_DWORD *)&__s[4] = 65544;
        *(float *)&__s[8] = v181;
        *(float *)&__s[12] = v177;
        *(float *)&__s[16] = v177;
        *(_DWORD *)&__s[20] = 16843009;
        __s[24] = 0;
      }
      else
      {
        objc_msgSend(v103, "type");
        v109 = (void *)objc_claimAutoreleasedReturnValue();
        v110 = (void *)*MEMORY[0x24BEBEDD0];

        if (v109 != v110)
        {
          objc_msgSend(v103, "type");
          v111 = (void *)objc_claimAutoreleasedReturnValue();
          v112 = (void *)*MEMORY[0x24BEBEE20];

          if (v111 != v112)
          {

            v114 = (id)*re::pipelineLogObjects(v113);
            if (os_log_type_enabled(v114, OS_LOG_TYPE_ERROR))
            {
              objc_msgSend(v103, "name");
              v494 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v494, "stringValue");
              v495 = (void *)objc_claimAutoreleasedReturnValue();
              if (v495)
              {
                objc_msgSend(v103, "name");
                v103 = (id)objc_claimAutoreleasedReturnValue();
                objc_msgSend(v103, "stringValue");
                i = (unint64_t)objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
                v496 = (const char *)objc_msgSend((id)i, "UTF8String");
              }
              else
              {
                v496 = "unnamed";
              }
              LODWORD(v617[0]) = 136315138;
              *(_QWORD *)((char *)v617 + 4) = v496;
              _os_log_error_impl(&dword_224FE9000, v114, OS_LOG_TYPE_ERROR, "Unsupported primitive for node '%s'", (uint8_t *)v617, 0xCu);
              if (v495)
              {

              }
              v8 = v546;
            }

            goto LABEL_238;
          }
          objc_msgSend(v103, "property:", CFSTR("radius"));
          v463 = (void *)objc_claimAutoreleasedReturnValue();
          v155 = v463;
          v464 = 1.0;
          if (v463)
          {
            objc_msgSend(v463, "data");
            v465 = (void *)objc_claimAutoreleasedReturnValue();

            if (v465)
            {
              objc_msgSend(v155, "floatValue");
              v464 = v466;
            }
          }
          __s[0] = 3;
          *(_WORD *)&__s[4] = 8;
          *(float *)&__s[8] = v464;
          *(_WORD *)&__s[12] = 257;
          __s[14] = 0;
          goto LABEL_237;
        }
        objc_msgSend(v103, "property:", CFSTR("radius"));
        v189 = (void *)objc_claimAutoreleasedReturnValue();
        v155 = v189;
        v190 = 0.5;
        if (v189)
        {
          objc_msgSend(v189, "data");
          v191 = (void *)objc_claimAutoreleasedReturnValue();

          if (v191)
          {
            objc_msgSend(v155, "floatValue");
            v190 = v192;
          }
        }
        objc_msgSend(v103, "property:", CFSTR("height"));
        v193 = (void *)objc_claimAutoreleasedReturnValue();
        v166 = v193;
        v194 = 1.0;
        if (v193)
        {
          objc_msgSend(v193, "data");
          v195 = (void *)objc_claimAutoreleasedReturnValue();

          if (v195)
          {
            v193 = (void *)objc_msgSend(v166, "floatValue");
            v194 = v196;
          }
        }
        v197 = v194 + v190 * 2.0;
        objc_msgSend(v103, "property:", CFSTR("axis"));
        v198 = (void *)objc_claimAutoreleasedReturnValue();
        v171 = v198;
        if (v198)
        {
          objc_msgSend(v198, "data");
          v199 = (void *)objc_claimAutoreleasedReturnValue();

          if (v199)
          {
            objc_msgSend(v171, "stringValue");
            v200 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
            v201 = (const char *)objc_msgSend(v200, "UTF8String");
            v202 = strlen(v201);
            *(_QWORD *)&v585[0] = v201;
            *((_QWORD *)&v585[0] + 1) = v202;
            re::DynamicString::operator=((re::DynamicString *)v617, (uint64_t)v585);

          }
        }
        __s[0] = 4;
        *(_DWORD *)&__s[4] = 65544;
        *(_WORD *)&__s[8] = 4;
        *(float *)&__s[12] = v190;
        *(float *)&__s[16] = v197;
        *(_WORD *)&__s[20] = 257;
        __s[22] = 0;
      }
    }
    if ((v617[1] & 1) != 0)
      v203 = (const char *)v617[2];
    else
      v203 = (char *)&v617[1] + 1;
    if (!strcmp(v203, "X"))
    {
      v206 = 0;
      v205 = 0x3F3504F33F3504F3;
      a3 = v561;
      i = (unint64_t)obj;
    }
    else
    {
      v204 = strcmp(v203, "Z");
      a3 = v561;
      i = (unint64_t)obj;
      if (v204)
        goto LABEL_233;
      v205 = 0x3F3504F300000000;
      v206 = 1060439283;
    }
    *(_QWORD *)&__s[32] = v206;
    *(_QWORD *)&__s[40] = v205;
LABEL_233:

    if (v617[0] && (v617[1] & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v617[0] + 40))();

    v8 = v546;
LABEL_237:

    re::USDImportContext::setPrimitiveShape((uint64_t)a3, __s);
    v207 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[]((uint64_t)a3 + 624, *(_QWORD *)(*((_QWORD *)a3 + 106) + 8 * *((_QWORD *)a3 + 104) - 8));
    re::DynamicArray<re::AssetHandle>::operator=(v207 + 808, (uint64_t)v615);
    re::addPhysicsMaterialAsset(v99, (uint64_t)a3, i, (uint64_t)buf);
    goto LABEL_238;
  }
  objc_msgSend(v8, "path");
  v93 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v93, "stringValue");
  v94 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
  v95 = (_anonymous_namespace_ *)objc_msgSend(v94, "UTF8String");
  *(_QWORD *)buf = 0;
  *(_QWORD *)&buf[8] = &str_110;
  v96 = (_anonymous_namespace_ **)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a3 + 112, buf);
  v97 = v96;
  if (v96)
    v95 = *v96;
  re::StringID::destroyString((re::StringID *)buf);

  if (v97)
  {
    v148 = *(_QWORD *)(*((_QWORD *)a3 + 106) + 8 * *((_QWORD *)a3 + 104) - 8);
    v149 = *(_QWORD *)(re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[]((uint64_t)a3 + 624, v148)
                     + 872);
    if (v149 == -1)
      v149 = v148;
    re::USDImportContext::setSkeletonEntity(a3, v149, (unint64_t)v95);
    goto LABEL_341;
  }
  v150 = *re::pipelineLogObjects(v147);
  if (os_log_type_enabled(v150, OS_LOG_TYPE_ERROR))
  {
    v151 = v150;
    objc_msgSend(v8, "path");
    v86 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v86, "stringValue");
    v152 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
    v153 = objc_msgSend(v152, "UTF8String");
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = v153;
    _os_log_error_impl(&dword_224FE9000, v151, OS_LOG_TYPE_ERROR, "Skeleton entity (%s) does not have a valid skeleton index.", buf, 0xCu);

LABEL_340:
  }
LABEL_341:

LABEL_342:
  re::variantNamesInLodVariantSet(v8);
  v281 = (void *)objc_claimAutoreleasedReturnValue();
  v282 = objc_msgSend(v281, "count");

  if (v282)
  {
    v283 = v536;
    v284 = v8;
    re::variantNamesInLodVariantSet(v284);
    v285 = (void *)objc_claimAutoreleasedReturnValue();
    if (objc_msgSend(v285, "count"))
    {
      objc_msgSend(v285, "objectAtIndexedSubscript:", 0);
      v286 = (void *)objc_claimAutoreleasedReturnValue();
      v287 = objc_msgSend(v286, "isEqualToString:", CFSTR("card"));

      v541 = v285;
      objc_msgSend(v285, "objectAtIndexedSubscript:", v287);
      v288 = (void *)objc_claimAutoreleasedReturnValue();
      v289 = objc_msgSend(v288, "isEqualToString:", CFSTR("default"));

      v290 = *((_QWORD *)a3 + 5);
      v291 = *(unsigned __int8 *)(v290 + 165);
      v539 = (_QWORD *)v290;
      v292 = *(unsigned __int8 *)(v290 + 96);
      v589 = 0;
      v588 = 0;
      v590 = 0;
      objc_msgSend(v284, "dictionaryMetadataWithKey:dictionaryKey:", CFSTR("assetInfo"), CFSTR("lodComplexityThresholds"));
      v293 = (void *)objc_claimAutoreleasedReturnValue();
      v294 = v293;
      if (v293)
      {
        v295 = (_anonymous_namespace_ *)objc_msgSend(v293, "arraySize");
        v296 = v295;
        if ((_DWORD)v295)
        {
          objc_msgSend(v294, "floatArray:maxCount:", v590, v296);
        }
      }

      v543 = objc_alloc_init(MEMORY[0x24BDBCEB8]);
      objc_msgSend(v284, "childIterator");
      v297 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v297, "nextObject");
      v298 = objc_claimAutoreleasedReturnValue();
      if (v298)
      {
        v299 = (void *)v298;
        v564 = v291;
        v300 = 0;
        v301 = *MEMORY[0x24BEBEDF8];
        do
        {
          objc_msgSend(v299, "type");
          v302 = (void *)objc_claimAutoreleasedReturnValue();
          v303 = objc_msgSend(v302, "isEqualToString:", v301);
          if (v292 && (v303 & v289) != 0)
          {
            objc_msgSend(v299, "path");
            v304 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v543, "addObject:", v304);

            ++v300;
          }
          else
          {
            re::loadTransformAndMeshNodes(v283, v299, v561, 0);
          }

          objc_msgSend(v297, "nextObject");
          v305 = objc_claimAutoreleasedReturnValue();

          v299 = (void *)v305;
        }
        while (v305);

        v8 = v546;
        v285 = v541;
        if (v300)
        {
          v306 = 0;
          v529 = v300;
          v532 = v284;
          v535 = v283;
          do
          {
            objc_msgSend(v543, "objectAtIndexedSubscript:", v306);
            v307 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v283, "nodeAtPath:", v307);
            v308 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v308, "property:", CFSTR("purpose"));
            v309 = (void *)objc_claimAutoreleasedReturnValue();
            v310 = v309;
            v545 = v306;
            if (v309)
            {
              objc_msgSend(v309, "stringValue");
              v311 = (void *)objc_claimAutoreleasedReturnValue();
              v312 = objc_msgSend(v311, "isEqualToString:", CFSTR("guide"));

            }
            else
            {
              v312 = 0;
            }
            v313 = v561;

            v314 = v283;
            v315 = v284;
            v316 = v307;
            v317 = v285;
            objc_msgSend(v314, "nodeAtPath:", v316);
            v318 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v318, "inheritedSkeletonBinding");
            v319 = (void *)objc_claimAutoreleasedReturnValue();

            v572 = v316;
            if (v319)
            {
              v320 = objc_msgSend(v317, "count");
              if (v320)
              {
                LOBYTE(v321) = 0;
                for (j = 0; j != v320; LOBYTE(v321) = j >= v320)
                {
                  objc_msgSend(v317, "objectAtIndexedSubscript:", 0);
                  v323 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_msgSend(v315, "selectVariant:variantSet:", v323, CFSTR("lodVariant"));

                  objc_msgSend(v314, "nodeAtPath:", v572);
                  v324 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_msgSend(v324, "inheritedSkeletonBinding");
                  v325 = (void *)objc_claimAutoreleasedReturnValue();

                  if (!v325)
                    break;
                  ++j;
                }
                goto LABEL_377;
              }
            }
            else
            {
              v326 = (void *)MEMORY[0x24BEBED10];
              objc_msgSend(v314, "nodeAtPath:", v316);
              v327 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v326, "localTransformWithNode:time:", v327, 0.0);
              v552 = v329;
              v556 = v328;
              v548 = v331;
              v551 = v330;

              v332 = objc_msgSend(v317, "count");
              if (v332)
              {
                v333 = v332 - 1;
                while (1)
                {
                  objc_msgSend(v317, "objectAtIndexedSubscript:", 0);
                  v334 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_msgSend(v315, "selectVariant:variantSet:", v334, CFSTR("lodVariant"));

                  objc_msgSend(v314, "nodeAtPath:", v572);
                  v335 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_msgSend(MEMORY[0x24BEBED10], "transformKeyTimesWithNode:", v335);
                  v336 = (void *)objc_claimAutoreleasedReturnValue();
                  if ((unint64_t)objc_msgSend(v336, "arraySize") >= 2)
                  {

                    LOBYTE(v321) = 0;
                    goto LABEL_377;
                  }
                  objc_msgSend(MEMORY[0x24BEBED10], "localTransformWithNode:time:", v335, 0.0);
                  v341 = vminvq_u32((uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f32(v556, v337), (int8x16_t)vceqq_f32(v552, v338)), vandq_s8((int8x16_t)vceqq_f32(v551, v339), (int8x16_t)vceqq_f32(v548, v340))));
                  v321 = v341 >> 31;

                  v342 = v333-- != 0;
                  v343 = v342;
                  if ((v341 & 0x80000000) == 0)
                    break;
                  v313 = v561;
                  if (!v343)
                    goto LABEL_377;
                }
                v313 = v561;
                goto LABEL_377;
              }
            }
            LOBYTE(v321) = 1;
LABEL_377:
            objc_msgSend(v315, "selectVariant:variantSet:", CFSTR("default"), CFSTR("lodVariant"));

            if (v312 & 1 | ((v321 & 1) == 0))
            {
              v345 = (id)*re::pipelineLogObjects(v344);
              v8 = v546;
              v284 = v532;
              v283 = v535;
              if (os_log_type_enabled(v345, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)__s = 0;
                _os_log_impl(&dword_224FE9000, v345, OS_LOG_TYPE_DEFAULT, "Lods specified, but leaf level mesh nodes have inconsistent transforms and/or possess animations.  Lods will be ignored.", __s, 2u);
              }
              v285 = v541;

              v346 = v572;
              objc_msgSend(v314, "nodeAtPath:", v572);
              v347 = (void *)objc_claimAutoreleasedReturnValue();
              re::loadTransformAndMeshNodes(v314, v347, v313, v541 != 0);

              v348 = v545;
            }
            else
            {
              objc_msgSend(v314, "nodeAtPath:", v572);
              v349 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v349, "name");
              v350 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v350, "stringValue");
              v351 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
              v352 = (const char *)objc_msgSend(v351, "UTF8String");
              objc_msgSend(v572, "stringValue");
              v353 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
              re::USDImportContext::pushNodePath(v313, v352, "(default)", (const char *)objc_msgSend(v353, "UTF8String"));

              objc_msgSend(v349, "inheritedSkeletonBinding");
              v354 = (void *)objc_claimAutoreleasedReturnValue();

              if (!v354)
              {
                objc_msgSend(MEMORY[0x24BEBED10], "localTransformWithNode:time:", v349, 0.0);
                v557 = v358;
                v359 = vmulq_f32(v355, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v357, (int8x16_t)v357, 0xCuLL), (int8x16_t)v357, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v356, (int32x4_t)v356), (int8x16_t)v356, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v357, (int32x4_t)v357), (int8x16_t)v357, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v356, (int8x16_t)v356, 0xCuLL), (int8x16_t)v356, 8uLL)));
                if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v359, 2), vaddq_f32(v359, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v359.f32, 1))).f32[0] <= 0.0)v360 = -1.0;
                else
                  v360 = 1.0;
                v361 = vmulq_f32(v355, v355);
                v362 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v361, 2), vaddq_f32(v361, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v361.f32, 1)));
                v362.f32[0] = sqrtf(v362.f32[0]);
                v363 = vmulq_f32(v356, v356);
                v364 = vmulq_f32(v357, v357);
                v362.i32[1] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v363, 2), vaddq_f32(v363, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v363.f32, 1))).f32[0]);
                v362.i32[2] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v364, 2), vaddq_f32(v364, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v364.f32, 1))).f32[0]);
                v553 = (__int128)vmulq_n_f32(v362, v360);
                v365 = vdivq_f32(v355, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v553, 0));
                v366 = vdivq_f32(v356, (float32x4_t)vdupq_lane_s32((int32x2_t)(v553 >> 32), 0));
                v367 = vdivq_f32(v357, (float32x4_t)vdupq_laneq_s32((int32x4_t)v553, 2));
                v368 = (int32x4_t)vmulq_f32(v365, v365);
                v368.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v368, 2), vadd_f32(*(float32x2_t *)v368.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v368.i8, 1))).u32[0];
                *(float32x2_t *)v362.f32 = vrsqrte_f32((float32x2_t)v368.u32[0]);
                *(float32x2_t *)v362.f32 = vmul_f32(*(float32x2_t *)v362.f32, vrsqrts_f32((float32x2_t)v368.u32[0], vmul_f32(*(float32x2_t *)v362.f32, *(float32x2_t *)v362.f32)));
                v622.columns[0] = (simd_float3)vmulq_n_f32(v365, vmul_f32(*(float32x2_t *)v362.f32, vrsqrts_f32((float32x2_t)v368.u32[0], vmul_f32(*(float32x2_t *)v362.f32, *(float32x2_t *)v362.f32))).f32[0]);
                v369 = vmulq_f32((float32x4_t)v622.columns[0], v366);
                v370 = vmulq_f32((float32x4_t)v622.columns[0], (float32x4_t)v622.columns[0]);
                v371 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v370, 2), vaddq_f32(v370, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v370.f32, 1)));
                v372 = vsubq_f32(v366, vmulq_n_f32((float32x4_t)v622.columns[0], vdivq_f32(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v369, 2), vaddq_f32(v369, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v369.f32, 1))), v371).f32[0]));
                v373 = (int32x4_t)vmulq_f32(v372, v372);
                v373.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v373, 2), vadd_f32(*(float32x2_t *)v373.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v373.i8, 1))).u32[0];
                *(float32x2_t *)v363.f32 = vrsqrte_f32((float32x2_t)v373.u32[0]);
                *(float32x2_t *)v363.f32 = vmul_f32(*(float32x2_t *)v363.f32, vrsqrts_f32((float32x2_t)v373.u32[0], vmul_f32(*(float32x2_t *)v363.f32, *(float32x2_t *)v363.f32)));
                v373.i32[0] = vmul_f32(*(float32x2_t *)v363.f32, vrsqrts_f32((float32x2_t)v373.u32[0], vmul_f32(*(float32x2_t *)v363.f32, *(float32x2_t *)v363.f32))).u32[0];
                v374 = vmulq_f32((float32x4_t)v622.columns[0], v367);
                v622.columns[1] = (simd_float3)vmulq_n_f32(v372, *(float *)v373.i32);
                v375 = vsubq_f32(v367, vmulq_n_f32((float32x4_t)v622.columns[0], vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v374, 2), vaddq_f32(v374, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v374.f32, 1))).f32[0]/ v371.f32[0]));
                v376 = vmulq_f32(v367, (float32x4_t)v622.columns[1]);
                v377 = vmulq_f32((float32x4_t)v622.columns[1], (float32x4_t)v622.columns[1]);
                v378 = vsubq_f32(v375, vmulq_n_f32((float32x4_t)v622.columns[1], vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v376, 2), vaddq_f32(v376, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v376.f32, 1))).f32[0]/ vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v377, 2), vaddq_f32(v377, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v377.f32, 1))).f32[0]));
                v379 = (int32x4_t)vmulq_f32(v378, v378);
                v379.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v379, 2), vadd_f32(*(float32x2_t *)v379.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v379.i8, 1))).u32[0];
                *(float32x2_t *)v377.f32 = vrsqrte_f32((float32x2_t)v379.u32[0]);
                *(float32x2_t *)v377.f32 = vmul_f32(*(float32x2_t *)v377.f32, vrsqrts_f32((float32x2_t)v379.u32[0], vmul_f32(*(float32x2_t *)v377.f32, *(float32x2_t *)v377.f32)));
                v622.columns[2] = (simd_float3)vmulq_n_f32(v378, vmul_f32(*(float32x2_t *)v377.f32, vrsqrts_f32((float32x2_t)v379.u32[0], vmul_f32(*(float32x2_t *)v377.f32, *(float32x2_t *)v377.f32))).f32[0]);
                *(double *)v380.i64 = simd_quaternion(v622);
                v381 = v380.i64[1];
                v382 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v380.f32, 1);
                v383 = vmovn_s32((int32x4_t)vmvnq_s8(vorrq_s8((int8x16_t)vcgtq_f32(v380, v382), (int8x16_t)vcgeq_f32(v382, v380)))).u8[0];
                v384 = v380.i64[0];
                *(int32x2_t *)v380.f32 = vrev64_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v380, (int8x16_t)v380, 8uLL));
                *(int8x8_t *)v380.f32 = vmvn_s8(vorr_s8((int8x8_t)vcltz_f32(*(float32x2_t *)v380.f32), (int8x8_t)vcgez_f32(*(float32x2_t *)v380.f32)));
                v385 = v383 | v380.i8[4] | v380.i8[0];
                v386 = (v385 & 1) == 0;
                if ((v385 & 1) != 0)
                  v387 = 0;
                else
                  v387 = v384;
                *(_OWORD *)__s = v553;
                if (!v386)
                  v381 = 0x3F80000000000000;
                *(_QWORD *)&__s[24] = v381;
                *(_QWORD *)&__s[16] = v387;
                *(_OWORD *)&__s[32] = v557;
                re::USDImportContext::concatenateLocalTransform((uint64_t)v313, (float32x4_t *)__s);
              }
              v388 = v564;

              v389 = v314;
              v390 = v315;
              v391 = v572;
              v392 = v317;
              memset(v585, 0, 36);
              *(_QWORD *)((char *)&v585[2] + 4) = 0x7FFFFFFFLL;
              objc_msgSend(v392, "objectAtIndexedSubscript:", 0);
              v393 = (void *)objc_claimAutoreleasedReturnValue();
              v394 = objc_msgSend(v393, "isEqualToString:", CFSTR("card"));

              v395 = objc_msgSend(v392, "count");
              objc_msgSend(v390, "selectVariant:variantSet:", CFSTR("default"), CFSTR("lodVariant"));
              objc_msgSend(v389, "nodeAtPath:", v391);
              v396 = (void *)objc_claimAutoreleasedReturnValue();
              re::appendUsedMaterialsByMeshNodeToTableForHelper(v396, v564 != 0, (uint64_t)v585);

              v558 = v394;
              if (v394)
                v397 = 2;
              else
                v397 = 1;
              if (v397 < v395)
              {
                do
                {
                  v398 = v388 != 0;
                  objc_msgSend(v392, "objectAtIndexedSubscript:", v397);
                  v399 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_msgSend(v390, "selectVariant:variantSet:", v399, CFSTR("lodVariant"));

                  objc_msgSend(v389, "nodeAtPath:", v391);
                  v400 = (void *)objc_claimAutoreleasedReturnValue();
                  re::appendUsedMaterialsByMeshNodeToTableForHelper(v400, v398, (uint64_t)v585);

                  v388 = v564;
                  ++v397;
                }
                while (v395 != (_DWORD)v397);
              }
              if ((v558 & 1) != 0)
              {
                objc_msgSend(v390, "selectVariant:variantSet:", CFSTR("card"), CFSTR("lodVariant"));
                objc_msgSend(v389, "nodeAtPath:", v391);
                v401 = (void *)objc_claimAutoreleasedReturnValue();
                re::appendUsedMaterialsByMeshNodeToTableForHelper(v401, v388 != 0, (uint64_t)v585);

              }
              objc_msgSend(v390, "selectVariant:variantSet:", CFSTR("default"), CFSTR("lodVariant"));

              *(_QWORD *)v584 = 0;
              *(_QWORD *)&v583 = 0;
              v582 = 0uLL;
              DWORD2(v583) = 0;
              re::createMaterialAssetsFromMaterialTableUSK(v539, (uint64_t)v585, (_anonymous_namespace_ *)&v582);
              objc_msgSend(v389, "nodeAtPath:", v391);
              v402 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(MEMORY[0x24BEBED10], "meshGroupsWithNode:", v402);
              v403 = (void *)objc_claimAutoreleasedReturnValue();
              if (objc_msgSend(v403, "count"))
              {
                v616 = 0u;
                memset(v615, 0, sizeof(v615));
                v404 = v403;
                v405 = objc_msgSend(v404, "countByEnumeratingWithState:objects:count:", v615, buf, 16);
                if (v405)
                {
                  v406 = v405;
                  v559 = v402;
                  v407 = *(_QWORD *)v615[0].__r_.__value_.__r.__words[2];
                  while (2)
                  {
                    for (k = 0; k != v406; ++k)
                    {
                      if (*(_QWORD *)v615[0].__r_.__value_.__r.__words[2] != v407)
                        objc_enumerationMutation(v404);
                      objc_msgSend(*(id *)(v615[0].__r_.__value_.__l.__size_ + 8 * k), "inheritedMaterialBinding");
                      v409 = objc_claimAutoreleasedReturnValue();
                      if (v409)
                      {
                        v410 = (void *)v409;
                        goto LABEL_409;
                      }
                    }
                    v406 = objc_msgSend(v404, "countByEnumeratingWithState:objects:count:", v615, buf, 16);
                    if (v406)
                      continue;
                    break;
                  }
                  v410 = 0;
LABEL_409:
                  v313 = v561;
                  v402 = v559;
                }
                else
                {
                  v410 = 0;
                }

              }
              else
              {
                objc_msgSend(v402, "inheritedMaterialBinding");
                v410 = (void *)objc_claimAutoreleasedReturnValue();
              }
              re::addPhysicsMaterialAsset(v410, (uint64_t)v313, (uint64_t)v539, (uint64_t)v585);

              v411 = v389;
              v412 = v390;
              v413 = v391;
              v414 = v392;
              objc_msgSend(v414, "objectAtIndexedSubscript:", 0);
              v415 = (void *)objc_claimAutoreleasedReturnValue();
              v416 = objc_msgSend(v415, "isEqualToString:", CFSTR("card"));

              v417 = objc_msgSend(v414, "count");
              memset(__s, 0, 28);
              v614 = 0;
              *(_OWORD *)&__s[32] = 0u;
              v612 = 0u;
              v613 = 0;
              if (v417)
              {
                re::DynamicArray<re::EvaluationRegisterId<int>>::setCapacity(__s, v417);
                v418 = v612;
              }
              else
              {
                v418 = 0;
              }
              if (v418 < v417)
                re::DynamicArray<re::EvaluationRegisterId<int>>::setCapacity(&__s[40], v417);
              objc_msgSend(v412, "selectVariant:variantSet:", CFSTR("default"), CFSTR("lodVariant"));
              objc_msgSend(v411, "nodeAtPath:", v413);
              v419 = (void *)objc_claimAutoreleasedReturnValue();
              re::findSkeletonAndSkeletalAnimationIndices((uint64_t)v617, v419, (uint64_t)v313);
              if (LOBYTE(v617[1]))
                v420 = LOBYTE(v617[0]) == 0;
              else
                v420 = 1;
              if (v420)
                v421 = &re::USDImportContext::NodeStackItem::kInvalidIndex;
              else
                v421 = &v617[2];
              re::DynamicArray<unsigned long>::add(__s, v421);
              if (LOBYTE(v617[3]))
                v422 = LOBYTE(v617[0]) == 0;
              else
                v422 = 1;
              if (v422)
                v423 = (__int16 *)&re::USDImportContext::NodeStackItem::kInvalidIndex;
              else
                v423 = &v618;
              re::DynamicArray<unsigned long>::add(&__s[40], v423);
              if (!LOBYTE(v617[0]) && v617[3] && (v618 & 1) != 0)
                (*(void (**)(void))(*(_QWORD *)v617[3] + 40))();

              if (v416)
                v424 = 2;
              else
                v424 = 1;
              if (v424 < v417)
              {
                do
                {
                  objc_msgSend(v414, "objectAtIndexedSubscript:", v424);
                  v425 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_msgSend(v412, "selectVariant:variantSet:", v425, CFSTR("lodVariant"));

                  objc_msgSend(v411, "nodeAtPath:", v413);
                  v426 = (void *)objc_claimAutoreleasedReturnValue();
                  re::findSkeletonAndSkeletalAnimationIndices((uint64_t)v617, v426, (uint64_t)v313);
                  if (LOBYTE(v617[1]))
                    v427 = LOBYTE(v617[0]) == 0;
                  else
                    v427 = 1;
                  if (v427)
                    v428 = &re::USDImportContext::NodeStackItem::kInvalidIndex;
                  else
                    v428 = &v617[2];
                  re::DynamicArray<unsigned long>::add(__s, v428);
                  if (LOBYTE(v617[3]))
                    v429 = LOBYTE(v617[0]) == 0;
                  else
                    v429 = 1;
                  if (v429)
                    v430 = (__int16 *)&re::USDImportContext::NodeStackItem::kInvalidIndex;
                  else
                    v430 = &v618;
                  re::DynamicArray<unsigned long>::add(&__s[40], v430);
                  if (!LOBYTE(v617[0]) && v617[3] && (v618 & 1) != 0)
                    (*(void (**)(void))(*(_QWORD *)v617[3] + 40))();

                  ++v424;
                }
                while (v417 != (_DWORD)v424);
              }
              v284 = v532;
              v283 = v535;
              if ((v416 & 1) != 0)
              {
                objc_msgSend(v412, "selectVariant:variantSet:", CFSTR("card"), CFSTR("lodVariant"));
                objc_msgSend(v411, "nodeAtPath:", v413);
                v431 = (void *)objc_claimAutoreleasedReturnValue();
                re::findSkeletonAndSkeletalAnimationIndices((uint64_t)v617, v431, (uint64_t)v313);
                if (LOBYTE(v617[1]))
                  v432 = LOBYTE(v617[0]) == 0;
                else
                  v432 = 1;
                if (v432)
                  v433 = &re::USDImportContext::NodeStackItem::kInvalidIndex;
                else
                  v433 = &v617[2];
                re::DynamicArray<unsigned long>::add(__s, v433);
                if (LOBYTE(v617[3]))
                  v434 = LOBYTE(v617[0]) == 0;
                else
                  v434 = 1;
                if (v434)
                  v435 = (__int16 *)&re::USDImportContext::NodeStackItem::kInvalidIndex;
                else
                  v435 = &v618;
                re::DynamicArray<unsigned long>::add(&__s[40], v435);
                if (!LOBYTE(v617[0]) && v617[3] && (v618 & 1) != 0)
                  (*(void (**)(void))(*(_QWORD *)v617[3] + 40))();

              }
              objc_msgSend(v412, "selectVariant:variantSet:", CFSTR("default"), CFSTR("lodVariant"));

              re::loadAllLodModelsForModelPathHelper((uint64_t)v617, v411, v412, v413, (uint64_t)v313, (uint64_t)v585, v414, (uint64_t)__s);
              if (LOBYTE(v617[0]))
              {
                re::FixedArray<float>::FixedArray((uint64_t *)&v586, (uint64_t)&v588);
                re::USDImportContext::setModelsWithLods((uint64_t)v313, (uint64_t)&v617[1], (uint64_t)__s, (uint64_t)&__s[40], (uint64_t *)&v586);
                v437 = re::BucketArray<re::USDImportContext::NodeStackItem,32ul>::operator[]((uint64_t)v561 + 624, *(_QWORD *)(*((_QWORD *)v313 + 106) + 8 * *((_QWORD *)v313 + 104) - 8));
                re::DynamicArray<re::AssetHandle>::operator=(v437 + 808, (uint64_t)&v582);
                v8 = v546;
                v285 = v541;
                if (v586.__r_.__value_.__r.__words[0] && v586.__r_.__value_.__l.__size_)
                  (*(void (**)(void))(*(_QWORD *)v586.__r_.__value_.__l.__data_ + 40))();
              }
              else
              {
                v438 = (id)*re::pipelineLogObjects(v436);
                v8 = v546;
                v285 = v541;
                if (os_log_type_enabled(v438, OS_LOG_TYPE_ERROR))
                {
                  std::error_code::message(&v586, (const std::error_code *)&v617[1]);
                  v440 = &v586;
                  if ((v586.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                    v440 = (std::string *)v586.__r_.__value_.__r.__words[0];
                  v441 = (char *)&v618 + 1;
                  if ((v618 & 1) != 0)
                    v441 = *(char **)&v619[6];
                  *(_DWORD *)v603 = 136315394;
                  *(_QWORD *)&v603[4] = v440;
                  *(_WORD *)&v603[12] = 2080;
                  *(_QWORD *)&v603[14] = v441;
                  _os_log_error_impl(&dword_224FE9000, v438, OS_LOG_TYPE_ERROR, "Error: %s\nDetails:\n%s", v603, 0x16u);
                  if (SHIBYTE(v586.__r_.__value_.__r.__words[2]) < 0)
                    operator delete(v586.__r_.__value_.__l.__data_);
                }

              }
              objc_msgSend(v411, "nodeAtPath:", v413);
              v439 = (void *)objc_claimAutoreleasedReturnValue();
              re::updateMeshOverrideCompileOptions(v313, v439);

              if (LOBYTE(v617[0]))
              {
                re::DynamicArray<re::GeomModelDescriptor>::deinit((uint64_t)&v617[1]);
                v348 = v545;
              }
              else
              {
                v348 = v545;
                if (v617[3] && (v618 & 1) != 0)
                  (*(void (**)(void))(*(_QWORD *)v617[3] + 40))();
              }
              if (*(_QWORD *)&__s[40])
              {
                if (v614)
                  (*(void (**)(void))(**(_QWORD **)&__s[40] + 40))();
                v614 = 0;
                v612 = 0uLL;
                *(_QWORD *)&__s[40] = 0;
                ++v613;
              }
              if (*(_QWORD *)__s && *(_QWORD *)&__s[32])
                (*(void (**)(void))(**(_QWORD **)__s + 40))();
              re::DynamicArray<re::AssetHandle>::deinit((uint64_t)&v582);
              re::HashTable<re::ImportMaterialSignature,re::MaterialInfo,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::deinit((uint64_t *)v585);
              re::USDImportContext::popNodePath(v313);
              v346 = v572;
            }

            v306 = v348 + 1;
          }
          while (v306 != v529);
        }
      }
      else
      {

        v285 = v541;
      }

      if (v588 && v589)
        (*(void (**)(void))(*(_QWORD *)v588 + 40))();
      a3 = v561;
    }

    goto LABEL_515;
  }
  IsBlendShapeRoot = re::uskNodeIsBlendShapeRoot(v8);
  v443 = v526;
  if (!IsBlendShapeRoot || !*(_BYTE *)(*((_QWORD *)a3 + 5) + 166))
  {
    objc_msgSend(v8, "childIterator");
    v444 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v444, "nextObject");
    v445 = objc_claimAutoreleasedReturnValue();
    if (v445)
    {
      v446 = (void *)v445;
      do
      {
        objc_msgSend(v546, "metadataWithKey:", CFSTR("kind"));
        v447 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v447, "stringValue");
        v448 = (void *)objc_claimAutoreleasedReturnValue();
        v449 = objc_msgSend(v448, "isEqual:", CFSTR("sceneLibrary"));

        if ((v449 & 1) == 0)
          re::loadTransformAndMeshNodes(v536, v446, a3, 0);
        objc_msgSend(v444, "nextObject");
        v450 = objc_claimAutoreleasedReturnValue();

        v446 = (void *)v450;
      }
      while (v450);
    }

    v8 = v546;
LABEL_515:
    v443 = v526;
  }

  if (v522)
    re::USDImportContext::popNodePath(a3);

}

