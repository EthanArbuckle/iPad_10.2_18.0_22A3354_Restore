void re::`anonymous namespace'::logFormatConversionInfo(const vImage_CGImageFormat *this, const vImage_CGImageFormat *a2, const vImage_CGImageFormat *a3)
{
  re *IsEqual;
  NSObject *v6;
  CGColorSpaceRef colorSpace;
  uint32_t bitsPerPixel;
  uint32_t bitsPerComponent;
  CGBitmapInfo bitmapInfo;
  CGColorSpaceRef v11;
  uint32_t v12;
  uint32_t v13;
  CGBitmapInfo v14;
  int v15;
  CGColorSpaceRef v16;
  __int16 v17;
  uint32_t v18;
  __int16 v19;
  uint32_t v20;
  __int16 v21;
  CGBitmapInfo v22;
  __int16 v23;
  CGColorSpaceRef v24;
  __int16 v25;
  uint32_t v26;
  __int16 v27;
  uint32_t v28;
  __int16 v29;
  CGBitmapInfo v30;
  uint64_t v31;

  v31 = *MEMORY[0x24BDAC8D0];
  IsEqual = (re *)vImageCGImageFormat_IsEqual(this, a2);
  if (!(_DWORD)IsEqual)
  {
    v6 = *re::pipelineLogObjects(IsEqual);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      colorSpace = this->colorSpace;
      bitsPerComponent = this->bitsPerComponent;
      bitsPerPixel = this->bitsPerPixel;
      bitmapInfo = this->bitmapInfo;
      v11 = a2->colorSpace;
      v13 = a2->bitsPerComponent;
      v12 = a2->bitsPerPixel;
      v14 = a2->bitmapInfo;
      v15 = 138414082;
      v16 = colorSpace;
      v17 = 1024;
      v18 = bitsPerPixel;
      v19 = 1024;
      v20 = bitsPerComponent;
      v21 = 1024;
      v22 = bitmapInfo;
      v23 = 2112;
      v24 = v11;
      v25 = 1024;
      v26 = v12;
      v27 = 1024;
      v28 = v13;
      v29 = 1024;
      v30 = v14;
      _os_log_debug_impl(&dword_224FE9000, v6, OS_LOG_TYPE_DEBUG, "Format conversion required on texture import:\nSource format: %@, %u bpp, %u bpc, 0x%08x info\nDestination format: %@, %u bpp, %u bpc, 0x%08x info", (uint8_t *)&v15, 0x3Au);
    }
  }
}

uint64_t re::`anonymous namespace'::vImageBufferStorage::vImageBufferStorage(uint64_t a1, uint64_t a2, __int128 *a3)
{
  __int128 v5;
  __int128 v6;
  __int128 v7;
  int8x16_t v8;
  CGColorSpace *v9;
  void *v10;

  v5 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v5;
  v6 = *a3;
  v7 = a3[1];
  *(_QWORD *)(a1 + 64) = *((_QWORD *)a3 + 4);
  *(_OWORD *)(a1 + 32) = v6;
  *(_OWORD *)(a1 + 48) = v7;
  v8 = (int8x16_t)vcvtq_f64_u64(*(uint64x2_t *)(a2 + 8));
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(int8x16_t *)(a1 + 88) = vextq_s8(v8, v8, 8uLL);
  *(_QWORD *)(a1 + 152) = 0;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  v9 = CGColorSpaceRetain(*((CGColorSpaceRef *)a3 + 1));
  *(_QWORD *)(a1 + 160) = v9;
  *(_QWORD *)(a1 + 168) = CGColorSpaceGetNumberOfComponents(v9);
  *(_DWORD *)(a1 + 176) = CGColorSpaceGetModel(v9);
  v10 = *(void **)(a1 + 144);
  *(_QWORD *)(a1 + 144) = *(_QWORD *)a2;
  if (v10)
    free(v10);
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  return a1;
}

uint64_t re::`anonymous namespace'::convertBufferToFormat(uint64_t a1, vImage_CGImageFormat *a2, uint64_t a3, _BYTE *a4, _BYTE *a5)
{
  const vImage_CGImageFormat *v10;
  uint64_t result;
  vImageConverter *v12;
  uint64_t v13;
  uint64_t v14;
  re *v15;
  NSObject *v16;
  re *v17;
  re *v18;
  NSObject *v19;
  vImage_Error v20;
  vImage_Error v21;
  NSObject *v22;
  void *v23;
  re *v24;
  NSObject *v25;
  NSObject *v26;
  void *v27;
  vImage_Buffer buf;
  vImage_Error error;
  uint8_t v30[104];
  uint64_t v31;
  id v32;
  void *v33;
  id v34;
  CGColorSpaceRef space;
  uint64_t v36;

  v36 = *MEMORY[0x24BDAC8D0];
  v10 = (const vImage_CGImageFormat *)(a1 + 32);
  *a4 = 0;
  if (vImageCGImageFormat_IsEqual((const vImage_CGImageFormat *)(a1 + 32), a2))
    return 1;
  if (*(_DWORD *)(a1 + 36) != a2->bitsPerPixel
    || *(_DWORD *)(a1 + 48) != a2->bitmapInfo
    || v10->bitsPerComponent != a2->bitsPerComponent)
  {
    *a5 |= 0x40u;
  }
  error = 0;
  v12 = vImageConverter_CreateWithCGImageFormat(v10, a2, 0, 0, &error);
  if (!v12)
  {
    v17 = CGColorConversionInfoCreate(*(CGColorSpaceRef *)(a1 + 40), a2->colorSpace);
    if (!v17
      || (v18 = v17,
          v12 = vImageConverter_CreateWithCGColorConversionInfo(v17, v10, a2, 0, 0, &error),
          CFRelease(v18),
          !v12))
    {
      v19 = *re::pipelineLogObjects(v17);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v30 = 134217984;
        *(_QWORD *)&v30[4] = error;
        _os_log_error_impl(&dword_224FE9000, v19, OS_LOG_TYPE_ERROR, "Failed to create an image converter during texture creation (vImage error: %zd)", v30, 0xCu);
      }
      return 0;
    }
  }
  if (vImageConverter_GetNumberOfSourceBuffers(v12) != 1)
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) ", "vImageConverter_GetNumberOfSourceBuffers(converter) == 1", "convertBufferToFormat", 2765);
    _os_crash();
    __break(1u);
LABEL_38:
    re::internal::assertLog((re::internal *)4, v14, "assertion failure: '%s' (%s:line %i) ", "vImageConverter_GetNumberOfDestinationBuffers(converter) == 1", "convertBufferToFormat", 2766);
    _os_crash();
    __break(1u);
  }
  if (vImageConverter_GetNumberOfDestinationBuffers(v12) != 1)
    goto LABEL_38;
  memset(&buf, 0, sizeof(buf));
  v15 = (re *)vImageBuffer_Init(&buf, *(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16), a2->bitsPerPixel, 0);
  error = (vImage_Error)v15;
  if (v15)
  {
    v16 = *re::pipelineLogObjects(v15);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v30 = 134217984;
      *(_QWORD *)&v30[4] = error;
      _os_log_error_impl(&dword_224FE9000, v16, OS_LOG_TYPE_ERROR, "Failed to allocate an image buffer during texture creation (vImage error: %zd)", v30, 0xCu);
    }
    goto LABEL_28;
  }
  v20 = vImageConvert_AnyToAny(v12, (const vImage_Buffer *)a1, &buf, 0, 0x90u);
  v21 = v20;
  if (v20 < 0)
  {
    v26 = *re::pipelineLogObjects((re *)v20);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v30 = 134217984;
      *(_QWORD *)&v30[4] = v21;
      _os_log_error_impl(&dword_224FE9000, v26, OS_LOG_TYPE_ERROR, "Failed to prepare image converter during texture creation (vImage error: %zd)", v30, 0xCu);
    }
    goto LABEL_27;
  }
  if (v20)
  {
    v22 = *re::pipelineLogObjects((re *)v20);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)v30 = 134217984;
      *(_QWORD *)&v30[4] = v21;
      _os_log_debug_impl(&dword_224FE9000, v22, OS_LOG_TYPE_DEBUG, "Format conversion requires %zd bytes of temp buffer", v30, 0xCu);
    }
  }
  v23 = (void *)(*(uint64_t (**)(uint64_t, vImage_Error, _QWORD))(*(_QWORD *)a3 + 32))(a3, v21, *MEMORY[0x24BDB03C8]);
  v24 = (re *)vImageConvert_AnyToAny(v12, (const vImage_Buffer *)a1, &buf, v23, 0x10u);
  error = (vImage_Error)v24;
  if (v24)
  {
    v25 = *re::pipelineLogObjects(v24);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v30 = 134217984;
      *(_QWORD *)&v30[4] = error;
      _os_log_error_impl(&dword_224FE9000, v25, OS_LOG_TYPE_ERROR, "Failed to convert image during texture creation (vImage error: %zd)", v30, 0xCu);
    }
    (*(void (**)(uint64_t, void *))(*(_QWORD *)a3 + 40))(a3, v23);
LABEL_27:
    free(buf.data);
LABEL_28:
    vImageConverter_Release(v12);
    return 0;
  }
  (*(void (**)(uint64_t, void *))(*(_QWORD *)a3 + 40))(a3, v23);
  vImageConverter_Release(v12);
  CGColorSpaceRelease(space);
  space = 0;
  if (v34)
  {

    v34 = 0;
  }
  v27 = v33;
  v33 = 0;
  if (v27)
    free(v27);

  if (v31)
    CGImageBlockSetRelease();
  result = 1;
  *a4 = 1;
  return result;
}

uint64_t re::internal::createCompressedCPUTextureData@<X0>(id *a1@<X0>, int a2@<W1>, int a3@<W2>, id *a4@<X3>, unsigned int *a5@<X4>, id *a6@<X5>, uint64_t a7@<X8>)
{
  id *v13;
  unsigned int FaceOrArrayLength;
  id *v15;
  _QWORD *v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  vImagePixelCount v20;
  unint64_t v21;
  vImagePixelCount v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  _QWORD *v26;
  id *v27;
  char *v28;
  __int128 v29;
  id v30;
  id v31;
  id *v33;
  unint64_t v34;
  unsigned int *v36;
  _QWORD v37[3];
  vImage_Buffer v38;
  __int128 v39;
  int v40;
  int v41;
  _QWORD v42[3];
  char v43;
  _BYTE v44[12];
  id v45;
  _QWORD v46[2];
  id *v47;
  int v48;
  uint64_t v49;
  uint64_t v50;
  id v51[6];
  _BYTE v52[32];
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  uint64_t v58;

  v58 = *MEMORY[0x24BDAC8D0];
  v49 = 0;
  v46[1] = 0;
  v47 = 0;
  v46[0] = 0;
  v48 = 0;
  v43 = 0;
  memset(v44, 0, sizeof(v44));
  v42[2] = 0;
  v42[0] = 0;
  v42[1] = 8;
  dispatch_get_global_queue(21, 0);
  v45 = (id)objc_claimAutoreleasedReturnValue();
  v36 = a5;
  v39 = *(_OWORD *)a5;
  v40 = a2;
  v41 = a3;
  v13 = (id *)objc_msgSend(*a4, sel_mipmapLevelCount);
  FaceOrArrayLength = re::internal::getFaceOrArrayLength(a4);
  re::DynamicArray<re::DynamicArray<re::Matrix4x4<float>>>::resize(v46, (unint64_t)v13);
  if (v13 <= a6)
  {
LABEL_21:
    re::CPUTexture::CPUTexture((uint64_t)&v53, *a4, (uint64_t)v46);
    v51[0] = (id)v53;
    re::DynamicArray<re::DynamicArray<unsigned char>>::DynamicArray((uint64_t)&v51[1], (uint64_t *)&v53 + 1);
    re::DynamicString::DynamicString((re::DynamicString *)v52, (const re::DynamicString *)&v56);
    *(_BYTE *)a7 = 1;
    *(_QWORD *)(a7 + 8) = v51[0];
    re::DynamicArray<re::DynamicArray<unsigned char>>::DynamicArray(a7 + 16, (uint64_t *)&v51[1]);
    re::DynamicString::DynamicString((re::DynamicString *)(a7 + 56), (const re::DynamicString *)v52);
    re::CPUTexture::~CPUTexture((re::CPUTexture *)v51);
    re::CPUTexture::~CPUTexture((re::CPUTexture *)&v53);
  }
  else
  {
    v33 = a1;
    v34 = FaceOrArrayLength;
LABEL_3:
    v15 = (id *)a1[2];
    if (v15 <= a6)
      goto LABEL_33;
    v16 = a1[4];
    v17 = v34;
    if (objc_msgSend(*a4, sel_textureType) == (id)7)
    {
      v18 = (unint64_t)objc_msgSend(*a4, sel_depth);
      if (v18 >> (char)a6 <= 1)
        v17 = 1;
      else
        v17 = v18 >> (char)a6;
    }
    v19 = v16[5 * (_QWORD)a6 + 2] / v17;
    v20 = (unint64_t)objc_msgSend(*a4, sel_width) >> (char)a6;
    if (v20 <= 1)
      v20 = 1;
    v38.width = v20;
    v21 = (unint64_t)objc_msgSend(*a4, sel_height);
    if (v21 >> (char)a6 <= 1)
      v22 = 1;
    else
      v22 = v21 >> (char)a6;
    v38.height = v22;
    v38.rowBytes = v19 / v22;
    a1 = v47;
    if (v47 <= a6)
      goto LABEL_34;
    v25 = v17 * ((v22 + v24 - 1) / v24) * ((v23 + v38.width - 1) / v23);
    if (*(_QWORD *)(v49 + 40 * (_QWORD)a6 + 8) < 16 * v25)
      re::DynamicArray<BOOL>::setCapacity((_QWORD *)(v49 + 40 * (_QWORD)a6), 16 * v25);
    a1 = 0;
    v26 = &v16[5 * (_QWORD)a6 + 4];
    while (1)
    {
      v38.data = (void *)(*v26 + (_QWORD)a1 * v19);
      v27 = v47;
      if (v47 <= a6)
      {
        v50 = 0;
        v15 = v51;
        v56 = 0u;
        v57 = 0u;
        v54 = 0u;
        v55 = 0u;
        v53 = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        LODWORD(v51[0]) = 136315906;
        *(id *)((char *)v51 + 4) = "operator[]";
        WORD2(v51[1]) = 1024;
        *(_DWORD *)((char *)&v51[1] + 6) = 789;
        WORD1(v51[2]) = 2048;
        *(id *)((char *)&v51[2] + 4) = a6;
        WORD2(v51[3]) = 2048;
        *(id *)((char *)&v51[3] + 6) = v27;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_33:
        v38.data = 0;
        v56 = 0u;
        v57 = 0u;
        v54 = 0u;
        v55 = 0u;
        v53 = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        LODWORD(v51[0]) = 136315906;
        *(id *)((char *)v51 + 4) = "operator[]";
        WORD2(v51[1]) = 1024;
        *(_DWORD *)((char *)&v51[1] + 6) = 797;
        WORD1(v51[2]) = 2048;
        *(id *)((char *)&v51[2] + 4) = a6;
        WORD2(v51[3]) = 2048;
        *(id *)((char *)&v51[3] + 6) = v15;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_34:
        v37[0] = 0;
        v56 = 0u;
        v57 = 0u;
        v54 = 0u;
        v55 = 0u;
        v53 = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        LODWORD(v51[0]) = 136315906;
        *(id *)((char *)v51 + 4) = "operator[]";
        WORD2(v51[1]) = 1024;
        *(_DWORD *)((char *)&v51[1] + 6) = 789;
        WORD1(v51[2]) = 2048;
        *(id *)((char *)&v51[2] + 4) = a6;
        WORD2(v51[3]) = 2048;
        *(id *)((char *)&v51[3] + 6) = a1;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      v37[0] = &off_24ED7D690;
      v37[1] = v49 + 40 * (_QWORD)a6;
      v37[2] = 0;
      if (!(_BYTE)v53)
        break;
      a1 = (id *)((char *)a1 + 1);
      if (!--v17)
      {
        a6 = (id *)((char *)a6 + 1);
        a1 = v33;
        if (a6 == v13)
          goto LABEL_21;
        goto LABEL_3;
      }
    }
    if ((v54 & 1) != 0)
      v28 = (char *)*((_QWORD *)&v54 + 1);
    else
      v28 = (char *)&v54 + 1;
    re::DynamicString::format((re::DynamicString *)"Failed to compress image buffer during texture creation: %s", (re::DynamicString *)v51, v28);
    v29 = *(_OWORD *)v51;
    v30 = v51[2];
    v31 = v51[3];
    *(_BYTE *)a7 = 0;
    *(_OWORD *)(a7 + 8) = v29;
    *(_QWORD *)(a7 + 24) = v30;
    *(_QWORD *)(a7 + 32) = v31;
    if (!(_BYTE)v53 && *((_QWORD *)&v53 + 1) && (v54 & 1) != 0)
      (*(void (**)(void))(**((_QWORD **)&v53 + 1) + 40))();
  }
  if (*(_QWORD *)&v44[4])
  {
    astcenc_context_free(*(uint64_t *)&v44[4]);
    *(_QWORD *)&v44[4] = 0;
  }

  return re::DynamicArray<re::DynamicArray<unsigned char>>::deinit((uint64_t)v46);
}

void re::`anonymous namespace'::compressTextureWithImageBuffer(uint64_t a1, uint64_t a2, const vImage_Buffer *a3, uint64_t a4, re::ASTCCompressor *a5)
{
  re::ASTCCompressor *v10;
  vImagePixelCount width;
  vImagePixelCount height;
  re::ASTCCompressor *v13;
  unint64_t v14;
  unint64_t v15;
  _anonymous_namespace_ *v16;
  unsigned __int8 *v17;
  _BYTE *v18;
  __int128 v19;
  uint64_t v20;
  char *v21;
  char *v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  __int128 v26;
  uint64_t v27;
  uint64_t v28;
  __int128 v29;
  uint64_t v30;
  char *v31;
  char v32[8];
  uint64_t v33;
  char v34;
  _BYTE v35[23];
  _QWORD v36[3];
  char v37;
  _BYTE v38[12];
  id v39;

  v37 = 0;
  memset(v38, 0, sizeof(v38));
  v36[2] = 0;
  v36[0] = 0;
  v36[1] = 8;
  dispatch_get_global_queue(21, 0);
  v39 = (id)objc_claimAutoreleasedReturnValue();
  if (a5)
    v10 = a5;
  else
    v10 = (re::ASTCCompressor *)v36;
  re::ASTCCompressor::initializeContext((uint64_t)v10, a4, *(_DWORD *)(a4 + 16), *(_DWORD *)(a4 + 20), (uint64_t)v32);
  if (!v32[0])
  {
    if ((v34 & 1) != 0)
      v18 = *(_BYTE **)&v35[7];
    else
      v18 = v35;
    re::DynamicString::format((re::DynamicString *)"Encoder failed during texture creation: %s", (re::DynamicString *)&v29, v18);
    goto LABEL_16;
  }
  height = a3->height;
  width = a3->width;
  if (a5)
    v13 = a5;
  else
    v13 = (re::ASTCCompressor *)v36;
  v16 = (_anonymous_namespace_ *)(**(uint64_t (***)(uint64_t, unint64_t, unint64_t, unint64_t, uint64_t))a2)(a2, (height + v15 - 1) / v15 * 16 * ((width + v14 - 1) / v14), 16 * ((width + v14 - 1) / v14), width | ((unint64_t)height << 32), 1);
  if ((v16 & 1) == 0)
  {
LABEL_16:
    v19 = v29;
    v20 = v30;
    v21 = v31;
    *(_BYTE *)a1 = 0;
    *(_OWORD *)(a1 + 8) = v19;
    *(_QWORD *)(a1 + 24) = v20;
    *(_QWORD *)(a1 + 32) = v21;
    goto LABEL_17;
  }
  v17 = (unsigned __int8 *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 8))(a2);
  re::ASTCCompressor::compress(v10, a3, v17, (uint64_t)&v29);
  if ((_BYTE)v29)
  {
    *(_BYTE *)a1 = 1;
  }
  else
  {
    if ((v30 & 1) != 0)
      v22 = v31;
    else
      v22 = (char *)&v30 + 1;
    re::DynamicString::format((re::DynamicString *)"Encoder failed during texture creation: %s", (re::DynamicString *)&v26, v22);
    v23 = v26;
    v24 = v27;
    v25 = v28;
    *(_BYTE *)a1 = 0;
    *(_OWORD *)(a1 + 8) = v23;
    *(_QWORD *)(a1 + 24) = v24;
    *(_QWORD *)(a1 + 32) = v25;
    if (!(_BYTE)v29 && *((_QWORD *)&v29 + 1) && (v30 & 1) != 0)
      (*(void (**)(void))(**((_QWORD **)&v29 + 1) + 40))();
  }
LABEL_17:
  if (!v32[0] && v33 && (v34 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v33 + 40))();
  if (*(_QWORD *)&v38[4])
  {
    astcenc_context_free(*(uint64_t *)&v38[4]);
    *(_QWORD *)&v38[4] = 0;
  }

}

uint64_t re::`anonymous namespace'::createBufferWithImageUsingVImage(uint64_t a1, uint64_t *a2, vImage_CGImageFormat *a3, uint64_t a4, _BYTE *a5, _BYTE *a6)
{
  NSObject *v12;
  _BOOL8 v13;
  uint64_t v14;
  NSObject *v15;
  void *v16;
  uint64_t v17;
  re *Count;
  int BitmapInfo;
  unsigned int ComponentType;
  uint64_t ColorSpace;
  uint64_t PixelSize;
  uint64_t v23;
  uint64_t v24;
  NSObject *v25;
  CGDataProvider *DataProvider;
  void *v27;
  CFDataRef v28;
  CFDataRef v29;
  const __CFData *v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  CGColorSpace *v34;
  uint64_t v35;
  CGColorSpace *v36;
  CGImagePtr *v37;
  NSObject *v38;
  NSObject *v39;
  double v40;
  double v41;
  double v42;
  double v43;
  uint64_t Data;
  uint64_t BytesPerRow;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  CGImagePtr *v50;
  NSObject *v51;
  NSObject *v52;
  re *v53;
  NSObject *v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  uint64_t v58;
  uint64_t v59;
  __int128 v60;
  size_t v61;
  void *v62;
  uint64_t result;
  vImage_CGImageFormat *v64;
  uint64_t v65;
  void *v66;
  uint8_t v67[16];
  __int128 v68;
  __int128 v69;
  _BYTE v70[56];
  __int128 v71;
  __int128 v72;
  __int128 v73;
  id v74[2];
  size_t space_8;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint8_t buf[8];
  CGColorSpaceRef v80;
  uint64_t v81;

  v81 = *MEMORY[0x24BDAC8D0];
  if (*a2)
  {
    *a5 = 0;
  }
  else
  {
    v12 = *re::pipelineLogObjects((re *)a1);
    v13 = os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
    if (v13)
    {
      *(_WORD *)v67 = 0;
      _os_log_error_impl(&dword_224FE9000, v12, OS_LOG_TYPE_ERROR, "Failed to create buffer from image due to invalid image", v67, 2u);
    }
    v14 = *a2;
    *a5 = 0;
    if (!v14)
    {
      v15 = *re::pipelineLogObjects((re *)v13);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_224FE9000, v15, OS_LOG_TYPE_ERROR, "Failed to create buffer from image due to invalid image", buf, 2u);
      }
    }
  }
  v16 = (void *)MEMORY[0x227694090]();
  if (CGImageGetImageProvider())
  {
    v77 = *MEMORY[0x24BDBF390];
    v78 = MEMORY[0x24BDBD1C8];
    objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", &v78, &v77, 1);
    v66 = (void *)objc_claimAutoreleasedReturnValue();
    v17 = CGImageProviderCopyImageBlockSetWithOptions();
    if (v17 || (v17 = CGImageProviderCopyImageBlockSetWithOptions()) != 0)
    {
      Count = (re *)CGImageBlockSetGetCount();
      if (Count == (re *)1)
      {
        v64 = a3;
        v65 = a4;
        BitmapInfo = CGImageProviderGetBitmapInfo();
        ComponentType = CGImageBlockSetGetComponentType();
        ColorSpace = CGImageBlockSetGetColorSpace();
        PixelSize = CGImageBlockSetGetPixelSize();
        *(_OWORD *)v67 = 0u;
        v68 = 0u;
        if (ComponentType >= 7)
        {
          re::internal::assertLog((re::internal *)4, v23, "assertion failure: '%s' (%s:line %i) ", "0 <= componentType && componentType < countOf(kImageProviderComponentTypes)", "imageProviderComponentType", 956);
          _os_crash();
          __break(1u);
        }
        v24 = PixelSize;
        if (ComponentType && ComponentType != 3)
        {
          DWORD1(v69) = 8 * PixelSize;
          *((_QWORD *)&v69 + 1) = ColorSpace;
          *(_DWORD *)v70 = BitmapInfo;
          *(_QWORD *)&v70[12] = 0;
          *(_QWORD *)&v70[4] = 0;
        }
        else
        {
          v25 = *re::pipelineLogObjects((re *)PixelSize);
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 67109120;
            *(_DWORD *)&buf[4] = ComponentType;
            _os_log_error_impl(&dword_224FE9000, v25, OS_LOG_TYPE_ERROR, "Unsupported CGImageComponentType %d during texture creation", buf, 8u);
          }
          *(_OWORD *)v70 = unk_226191960;
          *(_QWORD *)&v70[16] = 0;
        }
        memset(&v70[24], 0, 32);
        *(_QWORD *)&v71 = v17;
        DWORD2(v71) = ComponentType;
        *(_QWORD *)&v72 = ColorSpace;
        *((_QWORD *)&v72 + 1) = v24;
        v73 = 0u;
        *(_OWORD *)v74 = 0u;
        space_8 = 0;
        LODWORD(v76) = -1;
        CGImageBlockSetGetImageBlock();
        CGImageBlockSetGetSize();
        v41 = v40;
        v43 = v42;
        Data = CGImageBlockGetData();
        BytesPerRow = CGImageBlockGetBytesPerRow();
        *(_QWORD *)v67 = Data;
        *(_QWORD *)&v67[8] = (unint64_t)v43;
        *(_QWORD *)&v68 = (unint64_t)v41;
        *((_QWORD *)&v68 + 1) = BytesPerRow;
        CGImageBlockGetRect();
        *(_QWORD *)&v70[24] = v46;
        *(_QWORD *)&v70[32] = v47;
        *(_QWORD *)&v70[40] = v48;
        *(_QWORD *)&v70[48] = v49;
        CGImagePtr::CGImagePtr((CGImagePtr *)buf, 0);
        CGImagePtr::swap(v50, (CGImagePtr *)a2);
        CGImageRelease(*(CGImageRef *)buf);
        *(_QWORD *)buf = 0;
        CGColorSpaceRelease(v80);
        v80 = 0;
        a3 = v64;
        a4 = v65;
        goto LABEL_33;
      }
      v38 = *re::pipelineLogObjects(Count);
      if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_224FE9000, v38, OS_LOG_TYPE_ERROR, "Failed to create a single image block from a CGImageProvider during texture creation", buf, 2u);
      }
      CGImageBlockSetRelease();
      *(_OWORD *)v67 = 0u;
      v68 = 0u;
      *(_OWORD *)v70 = unk_226191960;
      memset(&v70[16], 0, 40);
      space_8 = 0;
      v76 = 0;
      v71 = 0u;
      v72 = 0u;
      v73 = 0u;
      *(_OWORD *)v74 = 0u;
    }
    else
    {
      v51 = *re::pipelineLogObjects(0);
      if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_224FE9000, v51, OS_LOG_TYPE_ERROR, "Failed to create an image from a CGImageProvider during texture creation", buf, 2u);
      }
      *(_OWORD *)v67 = 0u;
      v68 = 0u;
      *(_OWORD *)v70 = unk_226191960;
      memset(&v70[16], 0, 40);
      space_8 = 0;
      v76 = 0;
      *(_OWORD *)v74 = 0u;
      v73 = 0u;
      v72 = 0u;
      v71 = 0u;
    }
    LODWORD(v76) = -1;
LABEL_33:

    goto LABEL_38;
  }
  DataProvider = CGImageGetDataProvider((CGImageRef)*a2);
  if (DataProvider)
  {
    v27 = v16;
    v28 = CGDataProviderCopyData(DataProvider);
    v29 = v28;
    if (v28)
    {
      v30 = objc_retainAutorelease(v28);
      v31 = -[__CFData bytes](v30, "bytes");
      v33 = a2[1];
      v32 = a2[2];
      *(_QWORD *)v67 = v31;
      *(_QWORD *)&v67[8] = v32;
      v35 = a2[5];
      v34 = (CGColorSpace *)a2[6];
      *(_QWORD *)&v68 = v33;
      *((_QWORD *)&v68 + 1) = v35;
      *(int32x2_t *)&v69 = vmovn_s64(*(int64x2_t *)(a2 + 3));
      *((_QWORD *)&v69 + 1) = v34;
      *(_DWORD *)v70 = *((_DWORD *)a2 + 18);
      *(_OWORD *)&v70[4] = 0uLL;
      *(_QWORD *)&v70[24] = 0;
      *(_QWORD *)&v70[32] = 0;
      *(double *)&v70[40] = (double)v33;
      *(double *)&v70[48] = (double)v32;
      v72 = 0u;
      v71 = 0u;
      v74[0] = 0;
      v73 = (unint64_t)v30;
      v36 = CGColorSpaceRetain(v34);
      v74[1] = v36;
      space_8 = CGColorSpaceGetNumberOfComponents(v36);
      LODWORD(v76) = CGColorSpaceGetModel(v36);
      CGImagePtr::CGImagePtr((CGImagePtr *)buf, 0);
      CGImagePtr::swap(v37, (CGImagePtr *)a2);
      CGImageRelease(*(CGImageRef *)buf);
      *(_QWORD *)buf = 0;
      CGColorSpaceRelease(v80);
      v80 = 0;
    }
    else
    {
      v52 = *re::pipelineLogObjects(0);
      if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_224FE9000, v52, OS_LOG_TYPE_ERROR, "Failed to create an image from a CGDataProvider during texture creation", buf, 2u);
      }
      *(_OWORD *)v67 = 0u;
      v68 = 0u;
      *(_OWORD *)v70 = unk_226191960;
      memset(&v70[16], 0, 40);
      space_8 = 0;
      *(_OWORD *)v74 = 0u;
      v73 = 0u;
      v72 = 0u;
      v71 = 0u;
      v76 = 0xFFFFFFFFLL;
    }

    v16 = v27;
  }
  else
  {
    v39 = *re::pipelineLogObjects(0);
    if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_224FE9000, v39, OS_LOG_TYPE_ERROR, "Failed to create a texture because it is not backed by an image or data provider", buf, 2u);
    }
    *(_OWORD *)v67 = 0u;
    v68 = 0u;
    *(_OWORD *)v70 = unk_226191960;
    memset(&v70[16], 0, 40);
    space_8 = 0;
    *(_OWORD *)v74 = 0u;
    v73 = 0u;
    v72 = 0u;
    v71 = 0u;
    v76 = 0xFFFFFFFFLL;
  }
LABEL_38:
  objc_autoreleasePoolPop(v16);
  if (*(_DWORD *)&v70[4])
  {
    v54 = *re::pipelineLogObjects(v53);
    if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_224FE9000, v54, OS_LOG_TYPE_ERROR, "Failed to create buffer from image during texture creation", buf, 2u);
    }
  }
  {
    v55 = *(_OWORD *)&v70[32];
    *(_OWORD *)(a1 + 64) = *(_OWORD *)&v70[16];
    *(_OWORD *)(a1 + 80) = v55;
    v56 = v68;
    *(_OWORD *)a1 = *(_OWORD *)v67;
    *(_OWORD *)(a1 + 16) = v56;
    v57 = *(_OWORD *)v70;
    *(_OWORD *)(a1 + 32) = v69;
    *(_OWORD *)(a1 + 48) = v57;
    v58 = v71;
    *(_QWORD *)(a1 + 96) = *(_QWORD *)&v70[48];
    *(_QWORD *)(a1 + 104) = v58;
    *(_DWORD *)(a1 + 112) = DWORD2(v71);
    v59 = *((_QWORD *)&v72 + 1);
    *(_QWORD *)(a1 + 120) = v72;
    *(_QWORD *)(a1 + 128) = v59;
    *(_QWORD *)&v71 = 0;
    *(_QWORD *)&v72 = 0;
    v60 = v73;
    v73 = 0u;
    *(_OWORD *)(a1 + 136) = v60;
    *(_OWORD *)(a1 + 152) = *(_OWORD *)v74;
    v61 = space_8;
    space_8 = 0;
    *(_QWORD *)(a1 + 168) = v61;
    LODWORD(v61) = v76;
    LODWORD(v76) = -1;
    *(_DWORD *)(a1 + 176) = v61;
    *(_OWORD *)v74 = 0u;
    goto LABEL_44;
  }
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 48) = unk_226191960;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 168) = 0;
  *(_QWORD *)(a1 + 176) = 0;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_DWORD *)(a1 + 176) = -1;
LABEL_44:
  CGColorSpaceRelease((CGColorSpaceRef)v74[1]);
  v74[1] = 0;
  if (v74[0])
  {

    v74[0] = 0;
  }
  v62 = (void *)*((_QWORD *)&v73 + 1);
  *((_QWORD *)&v73 + 1) = 0;
  if (v62)
    free(v62);

  result = v71;
  if ((_QWORD)v71)
    return CGImageBlockSetRelease();
  return result;
}

void re::`anonymous namespace'::compressTextureWithImageBuffer(uint64_t a1, void *a2, const vImage_Buffer *a3, uint64_t a4, re::ASTCCompressor *a5)
{
  id v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;
  _BYTE v16[8];
  uint64_t v17;
  char v18;
  uint64_t (**v19)(re::_anonymous_namespace_::DeviceOutputAllocator *__hidden, unint64_t, unint64_t, at_size_t);
  id v20;
  id v21;
  uint64_t v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;

  v19 = &off_24ED7D4C0;
  v20 = a2;
  v21 = 0;

  if (v16[0])
  {
    v9 = v21;
    v10 = v22;
    v11 = v25;
    *(_BYTE *)a1 = 1;
    *(_QWORD *)(a1 + 8) = v9;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)(a1 + 24) = v10;
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)&v12 = v23;
    *((_QWORD *)&v12 + 1) = v24;
    *(_OWORD *)(a1 + 40) = v12;
    *(_QWORD *)(a1 + 56) = v11;
  }
  else
  {
    re::DynamicString::DynamicString((re::DynamicString *)&v13, (const re::DynamicString *)&v17);
    *(_BYTE *)a1 = 0;
    *(_QWORD *)(a1 + 8) = v13;
    *(_QWORD *)(a1 + 32) = v15;
    *(_OWORD *)(a1 + 16) = v14;
    if (v17 && (v18 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v17 + 40))();
  }
  v19 = &off_24ED7D4C0;
  if (v21)
  {

    v21 = 0;
  }

}

void re::`anonymous namespace'::scaleImageBufferUsingVImage(uint64_t a1, uint64_t a2, vImagePixelCount a3, vImagePixelCount height, vImage_Error a5, uint64_t a6)
{
  re *v10;
  re *v11;
  NSObject *v12;
  vImage_Error v13;
  vImagePixelCount v14;
  NSObject *v15;
  void *v16;
  re *v17;
  re *v18;
  NSObject *v19;
  NSObject *v20;
  vImage_Buffer v21;
  uint8_t buf[4];
  vImagePixelCount width;
  __int16 v24;
  vImagePixelCount v25;
  __int16 v26;
  vImagePixelCount v27;
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  memset(&v21, 0, sizeof(v21));
  v10 = (re *)vImageBuffer_Init(&v21, height, a3, *(_DWORD *)(a2 + 36), 0);
  if (v10)
  {
    v11 = v10;
    v12 = *re::pipelineLogObjects(v10);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 134217984;
      width = (vImagePixelCount)v11;
      _os_log_error_impl(&dword_224FE9000, v12, OS_LOG_TYPE_ERROR, "Failed to allocate an image buffer during texture creation (vImage error: %zd)", buf, 0xCu);
    }
    *(_OWORD *)(a1 + 144) = 0u;
    *(_OWORD *)(a1 + 160) = 0u;
    *(_OWORD *)(a1 + 112) = 0u;
    *(_OWORD *)(a1 + 128) = 0u;
    *(_OWORD *)(a1 + 80) = 0u;
    *(_OWORD *)(a1 + 96) = 0u;
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_OWORD *)(a1 + 48) = unk_226191960;
    *(_OWORD *)(a1 + 64) = 0u;
    *(_QWORD *)(a1 + 64) = 0;
    *(_QWORD *)(a1 + 168) = 0;
    *(_QWORD *)(a1 + 176) = 0;
    *(_OWORD *)(a1 + 152) = 0u;
    *(_OWORD *)(a1 + 136) = 0u;
    *(_OWORD *)(a1 + 120) = 0u;
    *(_OWORD *)(a1 + 104) = 0u;
    *(_OWORD *)(a1 + 88) = 0u;
    *(_OWORD *)(a1 + 72) = 0u;
    goto LABEL_16;
  }
  v14 = v13;
  if (v13 < 0)
  {
    v20 = *re::pipelineLogObjects((re *)v13);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 134217984;
      width = v14;
      _os_log_error_impl(&dword_224FE9000, v20, OS_LOG_TYPE_ERROR, "Failed to get temp buffer size for image scaling during texture creation (vImage error: %zd)", buf, 0xCu);
    }
    goto LABEL_15;
  }
  if (v13)
  {
    v15 = *re::pipelineLogObjects((re *)v13);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 134218496;
      width = v21.width;
      v24 = 2048;
      v25 = v21.height;
      v26 = 2048;
      v27 = v14;
      _os_log_debug_impl(&dword_224FE9000, v15, OS_LOG_TYPE_DEBUG, "Image scaling to %lux%lu requires %zd bytes of temp buffer", buf, 0x20u);
    }
  }
  v16 = (void *)(*(uint64_t (**)(uint64_t, vImagePixelCount, _QWORD))(*(_QWORD *)a6 + 32))(a6, v14, *MEMORY[0x24BDB03C8]);
  if (v17)
  {
    v18 = v17;
    v19 = *re::pipelineLogObjects(v17);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 134217984;
      width = (vImagePixelCount)v18;
      _os_log_error_impl(&dword_224FE9000, v19, OS_LOG_TYPE_ERROR, "Failed to scale image during texture creation (vImage error: %zd)", buf, 0xCu);
    }
    (*(void (**)(uint64_t, void *))(*(_QWORD *)a6 + 40))(a6, v16);
LABEL_15:
    free(v21.data);
    *(_OWORD *)(a1 + 144) = 0u;
    *(_OWORD *)(a1 + 160) = 0u;
    *(_OWORD *)(a1 + 64) = 0u;
    *(_OWORD *)(a1 + 80) = 0u;
    *(_OWORD *)(a1 + 96) = 0u;
    *(_OWORD *)(a1 + 112) = 0u;
    *(_OWORD *)(a1 + 128) = 0u;
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_OWORD *)(a1 + 48) = unk_226191960;
    *(_QWORD *)(a1 + 64) = 0;
    *(_QWORD *)(a1 + 168) = 0;
    *(_QWORD *)(a1 + 176) = 0;
    *(_OWORD *)(a1 + 72) = 0u;
    *(_OWORD *)(a1 + 88) = 0u;
    *(_OWORD *)(a1 + 104) = 0u;
    *(_OWORD *)(a1 + 120) = 0u;
    *(_OWORD *)(a1 + 136) = 0u;
    *(_OWORD *)(a1 + 152) = 0u;
LABEL_16:
    *(_DWORD *)(a1 + 176) = -1;
    return;
  }
  (*(void (**)(uint64_t, void *))(*(_QWORD *)a6 + 40))(a6, v16);
}

unsigned __int8 *re::Result<re::`anonymous namespace'::TextureInMetalBuffer,re::DynamicString>::~Result(unsigned __int8 *a1)
{
  int v2;
  void *v3;
  unsigned __int8 *v4;

  v2 = *a1;
  v4 = a1 + 8;
  v3 = (void *)*((_QWORD *)a1 + 1);
  if (v2)
  {
    if (v3)
    {

      *(_QWORD *)v4 = 0;
    }
  }
  else if (v3)
  {
    if ((a1[16] & 1) != 0)
      (*(void (**)(void *, _QWORD))(*(_QWORD *)v3 + 40))(v3, *((_QWORD *)a1 + 3));
    *(_OWORD *)v4 = 0u;
    *((_OWORD *)v4 + 1) = 0u;
  }
  return a1;
}

void re::`anonymous namespace'::replaceTextureSliceWithBuffer(id *a1, uint64_t a2, uint64_t a3, uint64_t a4, id *a5)
{
  void *v10;
  void **v11;
  id v12;
  uint64_t *v13;
  __int128 *v14;
  __int128 *v15;
  void **v16;
  uint64_t v17;
  _QWORD v18[3];
  __int128 v19;
  uint64_t v20;

  v10 = (void *)MEMORY[0x227694090]();
  if (objc_msgSend(*a1, sel_textureType) == (id)7)
  {
    v19 = *(_OWORD *)(a4 + 32);
    v20 = 1;
    v12 = *a1;
    v13 = (uint64_t *)(a4 + 8);
    v18[0] = 0;
    v18[1] = 0;
    v18[2] = a3;
    v14 = &v19;
    v15 = (__int128 *)v18;
    v16 = (void **)a4;
    v17 = 0;
  }
  else
  {
    v12 = *a1;
    v13 = (uint64_t *)(a4 + 8);
    v14 = (__int128 *)(a4 + 32);
    v19 = 0uLL;
    v20 = 0;
    v15 = &v19;
    v16 = (void **)a4;
    v17 = a3;
  }
  re::mtl::BlitCommandEncoder::copyFromBufferToTexture(v11, v16, v13, v14, (uint64_t)v12, v17, a2, v15);
  objc_autoreleasePoolPop(v10);
}

void re::`anonymous namespace'::TextureUploadQueue::commit(re::_anonymous_namespace_::TextureUploadQueue *this)
{
  re::_anonymous_namespace_::TextureUploadQueue *v1;
  void *v2;
  void *v3;

  if (*(_QWORD *)this)
  {
    v1 = this;
    v2 = (void *)MEMORY[0x227694090]();
    v3 = (void *)*((_QWORD *)v1 + 2);
    v1 = (re::_anonymous_namespace_::TextureUploadQueue *)((char *)v1 + 16);
    objc_msgSend(v3, "endEncoding");
    objc_msgSend(*((id *)v1 - 1), "commit");
    re::ObjCObject::operator=((void **)v1, 0);
    objc_autoreleasePoolPop(v2);
  }
}

void re::`anonymous namespace'::TextureUploadQueue::waitUntilCompleted(re::_anonymous_namespace_::TextureUploadQueue *this, id *a2)
{
  id *v3;
  void *v4;
  id v5;

  if (*a2)
  {
    v3 = a2;
    v4 = (void *)MEMORY[0x227694090]();
    v5 = v3[1];
    ++v3;
    objc_msgSend(v5, "waitUntilCompleted");
    re::internal::getCommandBufferError(v3, (uint64_t)this);
    re::ObjCObject::operator=(v3, 0);
    objc_autoreleasePoolPop(v4);
  }
  else
  {
    *(_BYTE *)this = 1;
  }
}

id *re::`anonymous namespace'::TextureUploadQueue::blitCommandEncoder(id *this)
{
  id *v2;
  id v3;
  id v4;
  void **v5;
  id v6;
  void *v7;
  id v9;

  v2 = this + 1;
  if (!this[1])
  {
    re::mtl::CommandQueue::makeCommandBuffer(this, &v9);
    if (v2 != &v9)
    {
      v3 = v9;
      v9 = 0;
      v4 = *v2;
      *v2 = v3;

    }
    re::mtl::CommandBuffer::makeBlitCommandEncoder(v2, &v9);
    v5 = this + 2;
    if (this + 2 != &v9)
    {
      v6 = v9;
      v9 = 0;
      v7 = *v5;
      *v5 = v6;

    }
  }
  return this + 2;
}

BOOL re::`anonymous namespace'::adjustBufferLinePaddingAndKTXConformance(re *a1)
{
  unint64_t v1;
  unint64_t v2;
  size_t v5;
  char *v6;
  char *v7;
  unint64_t v8;
  _BOOL8 result;
  NSObject *v10;
  __int16 v11[8];

  v1 = *((_QWORD *)a1 + 3);
  v2 = *((_QWORD *)a1 + 2) * *((unsigned int *)a1 + 9) + 7;
  if (v2 >> 3 == v1)
    return 1;
  if (v2 >> 3 < v1)
  {
    if ((v2 & 0x18) == 0 || v2 >= 0x20)
      v5 = v2 >> 3;
    else
      v5 = 4;
    if (*((_QWORD *)a1 + 1) >= 2uLL)
    {
      v6 = *(char **)a1;
      v7 = (char *)(*(_QWORD *)a1 + v1);
      v8 = 1;
      do
      {
        v6 += v5;
        memmove(v6, v7, v5);
        ++v8;
        v7 += v1;
      }
      while (v8 < *((_QWORD *)a1 + 1));
    }
    *((_QWORD *)a1 + 3) = v5;
    return 1;
  }
  v10 = *re::pipelineLogObjects(a1);
  result = os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
  if (result)
  {
    v11[0] = 0;
    _os_log_error_impl(&dword_224FE9000, v10, OS_LOG_TYPE_ERROR, "Failed to adjust buffer to alignment requirements", (uint8_t *)v11, 2u);
    return 0;
  }
  return result;
}

uint64_t re::DynamicArray<re::DynamicArray<unsigned char>>::add(uint64_t a1, uint64_t *a2)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  BOOL v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t result;

  v4 = *(_QWORD *)(a1 + 8);
  v5 = *(_QWORD *)(a1 + 16);
  if (v5 >= v4)
  {
    v6 = v5 + 1;
    if (v4 < v5 + 1)
    {
      if (*(_QWORD *)a1)
      {
        v7 = 2 * v4;
        v8 = v4 == 0;
        v9 = 8;
        if (!v8)
          v9 = v7;
        if (v9 <= v6)
          v10 = v6;
        else
          v10 = v9;
        re::DynamicArray<re::DynamicArray<unsigned char>>::setCapacity((_QWORD *)a1, v10);
      }
      else
      {
        re::DynamicArray<re::DynamicArray<unsigned char>>::setCapacity((_QWORD *)a1, v6);
        ++*(_DWORD *)(a1 + 24);
      }
    }
    v5 = *(_QWORD *)(a1 + 16);
  }
  result = re::DynamicArray<BOOL>::DynamicArray(*(_QWORD *)(a1 + 32) + 40 * v5, a2);
  ++*(_QWORD *)(a1 + 16);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

BOOL re::`anonymous namespace'::generateMipmapLevelOnCPU(uint64_t *a1, uint64_t a2, uint64_t a3, id *a4, uint64_t a5, uint64_t a6)
{
  unint64_t v12;
  vImagePixelCount v13;
  unint64_t v14;
  vImagePixelCount v15;
  uint64_t v16;
  uint64_t v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  re *v21;
  uint64_t v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  void *v26;
  re *v27;
  int v28;
  NSObject *v29;
  uint64_t v31;
  uint8_t buf[16];
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  uint64_t v38;
  re *v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  __int128 v43;
  __int128 v44;
  uint64_t v45;
  int v46;
  uint64_t v47;

  v47 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)objc_msgSend(*a4, sel_width);
  if (v12 >> a6 <= 1)
    v13 = 1;
  else
    v13 = v12 >> a6;
  v14 = (unint64_t)objc_msgSend(*a4, sel_height);
  if (v14 >> a6 <= 1)
    v15 = 1;
  else
    v15 = v14 >> a6;
  if (*a1)
    v16 = *a1;
  else
    v16 = a2;
  v17 = operator new();
  v18 = v37;
  *(_OWORD *)(v17 + 64) = v36;
  *(_OWORD *)(v17 + 80) = v18;
  v19 = v33;
  *(_OWORD *)v17 = *(_OWORD *)buf;
  *(_OWORD *)(v17 + 16) = v19;
  v20 = v35;
  *(_OWORD *)(v17 + 32) = v34;
  *(_OWORD *)(v17 + 48) = v20;
  v21 = v39;
  *(_QWORD *)(v17 + 96) = v38;
  *(_QWORD *)(v17 + 104) = v21;
  *(_DWORD *)(v17 + 112) = v40;
  v22 = v42;
  *(_QWORD *)(v17 + 120) = v41;
  *(_QWORD *)(v17 + 128) = v22;
  v39 = 0;
  v41 = 0;
  v23 = v43;
  v43 = 0u;
  *(_OWORD *)(v17 + 136) = v23;
  v24 = v44;
  v44 = 0u;
  *(_OWORD *)(v17 + 152) = v24;
  v25 = v45;
  v45 = 0;
  *(_QWORD *)(v17 + 168) = v25;
  LODWORD(v25) = v46;
  v46 = -1;
  *(_DWORD *)(v17 + 176) = v25;
  v31 = 0;
  CGColorSpaceRelease(*((CGColorSpaceRef *)&v44 + 1));
  *((_QWORD *)&v44 + 1) = 0;
  if ((_QWORD)v44)
  {

    *(_QWORD *)&v44 = 0;
  }
  v26 = (void *)*((_QWORD *)&v43 + 1);
  *((_QWORD *)&v43 + 1) = 0;
  if (v26)
    free(v26);

  v27 = v39;
  if (v39)
    v27 = (re *)CGImageBlockSetRelease();
  v28 = *(_DWORD *)(*a1 + 52);
  if (v28)
  {
    v29 = *re::pipelineLogObjects(v27);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 134217984;
      *(_QWORD *)&buf[4] = a6;
      _os_log_error_impl(&dword_224FE9000, v29, OS_LOG_TYPE_ERROR, "Failed to scale image for mipmap %zu during texture creation", buf, 0xCu);
    }
  }
  return v28 == 0;
}

__n128 re::DynamicArray<re::`anonymous namespace'::TextureInMetalBuffer>::add(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v8;
  __n128 result;
  __int128 v10;
  uint64_t v11;
  BOOL v12;
  unint64_t v13;
  unint64_t v14;

  v4 = *(_QWORD *)(a1 + 8);
  v5 = *(_QWORD *)(a1 + 16);
  v6 = v5 + 1;
  if (v5 >= v4 && v4 < v6)
  {
    if (*(_QWORD *)a1)
    {
      v11 = 2 * v4;
      v12 = v4 == 0;
      v13 = 8;
      if (!v12)
        v13 = v11;
      if (v13 <= v6)
        v14 = v6;
      else
        v14 = v13;
      re::DynamicArray<re::TextureBuilderKTX::CopyFromBufferToTextureInfo>::setCapacity((_QWORD *)a1, v14);
    }
    else
    {
      re::DynamicArray<re::TextureBuilderKTX::CopyFromBufferToTextureInfo>::setCapacity((_QWORD *)a1, v6);
      ++*(_DWORD *)(a1 + 24);
    }
  }
  v8 = *(_QWORD *)(a1 + 32) + 56 * *(_QWORD *)(a1 + 16);
  *(_QWORD *)v8 = *(_QWORD *)a2;
  *(_QWORD *)a2 = 0;
  result = *(__n128 *)(a2 + 8);
  v10 = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(v8 + 40) = *(_OWORD *)(a2 + 40);
  *(_OWORD *)(v8 + 24) = v10;
  *(__n128 *)(v8 + 8) = result;
  ++*(_QWORD *)(a1 + 16);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

void re::`anonymous namespace'::createMetalBuffer(re::_anonymous_namespace_ *this, const vImage_Buffer *a2, uint64_t a3, id *a4)
{
  size_t rowBytes;
  void *v9;
  uint64_t v10;
  id v11;
  __int128 v12;
  _BYTE v13[32];

  rowBytes = a2->rowBytes;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_QWORD *)this + 6) = 0;
  v9 = (void *)MEMORY[0x227694090]();
  v11 = objc_msgSend(*a4, sel_newBufferWithBytes_length_options_, a2->data, a3, 0);
  *(_QWORD *)&v12 = 0;
  *((_QWORD *)&v12 + 1) = rowBytes;
  *(_QWORD *)v13 = 0;
  *(int8x16_t *)&v13[8] = vextq_s8(*(int8x16_t *)&a2->height, *(int8x16_t *)&a2->height, 8uLL);
  *(_QWORD *)&v13[24] = 1;
  NS::SharedPtr<MTL::Texture>::operator=((void **)this, &v11);
  *(_OWORD *)((char *)this + 8) = v12;
  *(_OWORD *)((char *)this + 24) = *(_OWORD *)v13;
  *(_OWORD *)((char *)this + 40) = *(_OWORD *)&v13[16];
  if (v11)

  objc_autoreleasePoolPop(v9);
  if (!*(_QWORD *)this)
  {
    re::internal::assertLog((re::internal *)4, v10, "assertion failure: '%s' (%s:line %i) Failed to create staging buffer for texture upload", "stagingBuffer.buffer.isValid()", "createMetalBuffer", 3119);
    _os_crash();
    __break(1u);
  }
}

uint64_t re::`anonymous namespace'::vImageBufferStorage::operator=(uint64_t a1, __int128 *a2)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  CGColorSpace *v17;

  v4 = *a2;
  v5 = a2[2];
  *(_OWORD *)(a1 + 16) = a2[1];
  *(_OWORD *)(a1 + 32) = v5;
  *(_OWORD *)a1 = v4;
  v6 = a2[3];
  v7 = a2[4];
  v8 = a2[5];
  *(_QWORD *)(a1 + 96) = *((_QWORD *)a2 + 12);
  *(_OWORD *)(a1 + 64) = v7;
  *(_OWORD *)(a1 + 80) = v8;
  *(_OWORD *)(a1 + 48) = v6;
  if (*(_QWORD *)(a1 + 104))
  {
    CGImageBlockSetRelease();
    *(_QWORD *)(a1 + 104) = 0;
    *(_QWORD *)(a1 + 120) = 0;
  }
  *(_QWORD *)(a1 + 104) = *((_QWORD *)a2 + 13);
  *(_DWORD *)(a1 + 112) = *((_DWORD *)a2 + 28);
  v9 = *((_QWORD *)a2 + 16);
  *(_QWORD *)(a1 + 120) = *((_QWORD *)a2 + 15);
  *(_QWORD *)(a1 + 128) = v9;
  *((_QWORD *)a2 + 13) = 0;
  *((_QWORD *)a2 + 15) = 0;
  v10 = *((_QWORD *)a2 + 17);
  *((_QWORD *)a2 + 17) = 0;
  v11 = *(void **)(a1 + 136);
  *(_QWORD *)(a1 + 136) = v10;

  v12 = *((_QWORD *)a2 + 18);
  *((_QWORD *)a2 + 18) = 0;
  v13 = *(void **)(a1 + 144);
  *(_QWORD *)(a1 + 144) = v12;
  if (v13)
    free(v13);
  NS::SharedPtr<MTL::Texture>::operator=((void **)(a1 + 152), (void **)a2 + 19);
  v14 = *((_QWORD *)a2 + 20);
  v15 = *((_QWORD *)a2 + 21);
  v16 = *((_DWORD *)a2 + 44);
  *((_DWORD *)a2 + 44) = -1;
  *((_QWORD *)a2 + 20) = 0;
  *((_QWORD *)a2 + 21) = 0;
  v17 = *(CGColorSpace **)(a1 + 160);
  *(_QWORD *)(a1 + 160) = v14;
  *(_QWORD *)(a1 + 168) = v15;
  *(_DWORD *)(a1 + 176) = v16;
  CGColorSpaceRelease(v17);
  return a1;
}

void re::`anonymous namespace'::replaceTextureSliceWithBuffer(id *a1, uint64_t a2, uint64_t a3, const vImage_Buffer *a4, id *a5)
{
  vImagePixelCount height;
  uint64_t v11;
  uint64_t rowBytes;
  id v13;
  vImagePixelCount v14;
  vImagePixelCount width;
  id v16;
  uint64_t data;
  uint64_t v18;
  uint64_t v19;
  id v20;
  id v21;
  id v22[2];
  uint64_t v23;
  vImagePixelCount v24;
  vImagePixelCount v25;
  uint64_t v26;

  if (objc_msgSend(*a1, sel_storageMode) == (id)2)
  {
    height = a4->height;
    if (height)
      v11 = a4->rowBytes * (height - 1) + ((a4->width * HIDWORD(a4[1].data) + 7) >> 3);
    else
      v11 = 0;
    v20 = objc_msgSend(*a1, sel_device);
    v21 = v20;

    if (v22[0])

  }
  else
  {
    rowBytes = a4->rowBytes;
    v13 = objc_msgSend(*a1, sel_textureType);
    v14 = a4->height;
    width = a4->width;
    v16 = *a1;
    data = (uint64_t)a4->data;
    v22[0] = 0;
    v22[1] = 0;
    if (v13 == (id)7)
    {
      v23 = a3;
      v24 = width;
      v25 = v14;
      v26 = 1;
      v18 = a2;
      v19 = 0;
    }
    else
    {
      v23 = 0;
      v24 = width;
      v25 = v14;
      v26 = 1;
      v18 = a2;
      v19 = a3;
    }
    objc_msgSend(v16, sel_replaceRegion_mipmapLevel_slice_withBytes_bytesPerRow_bytesPerImage_, v22, v18, v19, data, rowBytes, 0);
  }
}

BOOL re::`anonymous namespace'::DeviceOutputAllocator::outputAllocate(id *this, uint64_t a2, void *a3, at_size_t a4)
{
  uint32_t z;
  void *v5;
  re *v8;
  id v9;
  NSObject *v10;
  uint8_t v12[8];
  id v13;

  z = a4.z;
  v5 = *(void **)&a4.x;
  v13 = objc_msgSend(this[1], sel_newBufferWithLength_options_, a2, 0);
  NS::SharedPtr<MTL::Texture>::operator=(this + 2, &v13);
  v8 = (re *)v13;
  if (v13)

  v9 = this[2];
  if (v9)
  {
    objc_msgSend(this[2], sel_setLabel_, CFSTR("compressTextureWithImageBuffer staging buffer"));
    this[3] = a3;
    this[4] = v5;
    *((_DWORD *)this + 10) = z;
  }
  else
  {
    v10 = *re::pipelineLogObjects(v8);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v12 = 0;
      _os_log_error_impl(&dword_224FE9000, v10, OS_LOG_TYPE_ERROR, "Failed to create Metal staging buffer for texture compression", v12, 2u);
    }
  }
  return v9 != 0;
}

id re::`anonymous namespace'::DeviceOutputAllocator::outputBuffer(id *this)
{
  return objc_msgSend(this[2], sel_contents);
}

vImage_Error re::`anonymous namespace'::doVImageScale(vImage_Error result, vImage_Buffer *src, const vImage_Buffer *a3, void *tempBuffer, uint64_t flags)
{
  uint64_t v5;
  uint64_t v6;

  switch((int)result)
  {
    case 0:
      re::internal::assertLog((re::internal *)4, (uint64_t)src, a3, tempBuffer, flags, "assertion failure: '%s' (%s:line %i) Invalid vImageScale_* variant", "!\"Unreachable code\"", "doVImageScale", 3059, v5, v6);
      _os_crash();
      __break(1u);
      JUMPOUT(0x225B5BFF0);
    case 1:
      result = vImageScale_Planar8(src, a3, tempBuffer, flags);
      break;
    case 2:
      result = vImageScale_Planar16S(src, a3, tempBuffer, flags);
      break;
    case 3:
      result = vImageScale_Planar16U(src, a3, tempBuffer, flags);
      break;
    case 4:
      result = vImageScale_PlanarF(src, a3, tempBuffer, flags);
      break;
    case 5:
      result = vImageScale_ARGB8888(src, a3, tempBuffer, flags);
      break;
    case 6:
      result = vImageScale_ARGB16U(src, a3, tempBuffer, flags);
      break;
    case 7:
      result = vImageScale_ARGB16S(src, a3, tempBuffer, flags);
      break;
    case 8:
      result = vImageScale_ARGBFFFF(src, a3, tempBuffer, flags);
      break;
    case 9:
      result = vImageScale_Planar16F(src, a3, tempBuffer, flags);
      break;
    case 10:
      result = vImageScale_ARGB16F(src, a3, tempBuffer, flags);
      break;
    case 11:
      result = vImageScale_CbCr8(src, a3, tempBuffer, flags);
      break;
    case 12:
      result = vImageScale_CbCr16U(src, a3, tempBuffer, flags);
      break;
    case 13:
      result = vImageScale_XRGB2101010W(src, a3, tempBuffer, flags);
      break;
    default:
      return result;
  }
  return result;
}

uint64_t *std::unique_ptr<re::`anonymous namespace'::vImageBufferStorage>::reset[abi:nn180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2;
  void *v3;
  void *v4;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    CGColorSpaceRelease(*(CGColorSpaceRef *)(v2 + 160));
    *(_QWORD *)(v2 + 160) = 0;
    v3 = *(void **)(v2 + 152);
    if (v3)
    {

      *(_QWORD *)(v2 + 152) = 0;
    }
    v4 = *(void **)(v2 + 144);
    *(_QWORD *)(v2 + 144) = 0;
    if (v4)
      free(v4);

    if (*(_QWORD *)(v2 + 104))
    {
      CGImageBlockSetRelease();
      *(_QWORD *)(v2 + 104) = 0;
      *(_QWORD *)(v2 + 120) = 0;
    }
    JUMPOUT(0x2276933B8);
  }
  return result;
}

BOOL re::`anonymous namespace'::MetalCompression::outputAllocate(id *this, uint64_t a2, void *a3, at_size_t a4)
{
}

id re::`anonymous namespace'::MetalCompression::outputBuffer(id *this)
{
  return objc_msgSend(this[8], sel_contents);
}

void re::`anonymous namespace'::MetalCompression::updateSource(uint64_t a1@<X0>, char **a2@<X1>, _QWORD *a3@<X2>, uint64_t a4@<X8>)
{
  __int128 v5;
  uint64_t v6;
  _anonymous_namespace_ *v10;
  id v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  id v17;
  __int128 v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  char *v22;
  char *v23;
  void *v24;
  id v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  id v31;
  char *v32;
  __int128 v33;
  uint64_t v34;
  uint64_t v35;
  re::_anonymous_namespace_::MetalCompression *v36;
  __int128 v37;
  uint64_t v38;
  uint64_t v39;
  void *v40;
  id v41;
  id v42;
  id v43[2];
  uint64_t v44;
  char *v45;
  char *v46;
  uint64_t v47;

  v5 = *(_OWORD *)a3;
  *(_QWORD *)(a1 + 160) = a3[2];
  *(_OWORD *)(a1 + 144) = v5;
  v6 = *(_QWORD *)(a1 + 16);
  if (*(_DWORD *)(v6 + 88))
    goto LABEL_22;
  v43[0] = objc_msgSend(objc_msgSend(*(id *)(v6 + 8), sel_device), sel_newBufferWithLength_options_, (_QWORD)a2[1] * a3[1], 0);
  NS::SharedPtr<MTL::Texture>::operator=((void **)(a1 + 136), v43);
  v10 = (_anonymous_namespace_ *)v43[0];
  if (v43[0])

  if (!*(_QWORD *)(a1 + 136))
  {
    v18 = *(_OWORD *)v43;
    v19 = v44;
    v20 = v45;
    *(_BYTE *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v18;
    *(_QWORD *)(a4 + 24) = v19;
    *(_QWORD *)(a4 + 32) = v20;
    return;
  }
  v11 = objc_msgSend(*(id *)(v6 + 8), sel_device);
  if (objc_msgSend(*(id *)(v6 + 8), sel_storageMode) != (id)2)
  {
    v21 = *(_QWORD *)(a1 + 40);
    v23 = *a2;
    v22 = a2[1];
    v24 = *(void **)(v6 + 8);
    v25 = objc_msgSend(*(id *)(a1 + 136), sel_contents);
    v26 = a3[1];
    v27 = a3[2];
    v28 = *(_QWORD *)(a1 + 24);
    v29 = *(_QWORD *)(a1 + 32);
    v43[0] = 0;
    v43[1] = 0;
    v44 = v21;
    v45 = v23;
    v46 = v22;
    v47 = 1;
    objc_msgSend(v24, sel_getBytes_bytesPerRow_bytesPerImage_fromRegion_mipmapLevel_slice_, v25, v26, v27, v43, v28, v29);
    v17 = objc_msgSend(*(id *)(a1 + 136), (SEL)&selRef_stringFromDate_);
    goto LABEL_11;
  }
  v12 = *(_QWORD *)(a1 + 96);
  v43[0] = (id)0x4D6518ECB093D0F6;
  v43[1] = "CompressedTextureUploadQueue";
  re::ImportGraphicsContext::getOrCreateCommandQueue(v12, (uint64_t)v43, (const char *)1, &v42);
  re::mtl::CommandQueue::makeCommandBuffer(&v42, &v41);
  re::mtl::CommandBuffer::makeBlitCommandEncoder(&v41, &v40);
  v13 = *(_QWORD *)(a1 + 16);
  if (*(_DWORD *)(v13 + 88))
  {
LABEL_22:
    v36 = (re::_anonymous_namespace_::MetalCompression *)std::__throw_bad_variant_access[abi:nn180100]();
    return;
  }
  v14 = *(_QWORD *)(v13 + 8);
  v16 = *(_QWORD *)(a1 + 24);
  v15 = *(_QWORD *)(a1 + 32);
  v43[0] = 0;
  v43[1] = 0;
  v44 = *(_QWORD *)(a1 + 40);
  re::mtl::BlitCommandEncoder::copyFromTextureToBuffer(&v40, v14, v15, v16, (__int128 *)v43, (__int128 *)a2, (_QWORD *)(a1 + 136), a3);
  objc_msgSend(v40, "endEncoding");
  objc_msgSend(v41, "commit");
  objc_msgSend(v41, "waitUntilCompleted");
  re::internal::getCommandBufferError(&v41, (uint64_t)v43);
  if (!LOBYTE(v43[0]))
  {
    v31 = objc_msgSend(objc_msgSend(*(id *)(v6 + 8), sel_label), sel_UTF8String);
    if ((v44 & 1) != 0)
      v32 = v45;
    else
      v32 = (char *)&v44 + 1;
    v33 = v37;
    v34 = v38;
    v35 = v39;
    *(_BYTE *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v33;
    *(_QWORD *)(a4 + 24) = v34;
    *(_QWORD *)(a4 + 32) = v35;
    if (!LOBYTE(v43[0]) && v43[1] && (v44 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v43[1] + 40))();

    goto LABEL_12;
  }

  v17 = objc_msgSend(*(id *)(a1 + 136), (SEL)&selRef_stringFromDate_);
LABEL_11:
  v30 = *(_QWORD *)(a1 + 152);
  *(_QWORD *)(a1 + 104) = v17;
  *(int8x16_t *)(a1 + 112) = vextq_s8(*(int8x16_t *)a2, *(int8x16_t *)a2, 8uLL);
  *(_QWORD *)(a1 + 128) = v30;
  *(_BYTE *)a4 = 1;
LABEL_12:

}

uint64_t re::`anonymous namespace'::MetalCompression::source(re::_anonymous_namespace_::MetalCompression *this)
{
  return (uint64_t)this + 104;
}

uint64_t re::`anonymous namespace'::BaseCompressionSource::contents(re::_anonymous_namespace_::BaseCompressionSource *this)
{
  return (*(uint64_t (**)(re::_anonymous_namespace_::BaseCompressionSource *))(*(_QWORD *)this + 8))(this);
}

void re::`anonymous namespace'::MetalCompression::backingMetalBuffer(uint64_t a1@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  id v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;

  v8 = *(id *)(a1 + 64);
  v9 = *(_QWORD *)(a1 + 72);
  v10 = *(unsigned int *)(a1 + 88);
  *a2 = 0;
  a2[1] = v9;
  a2[2] = 0;
  v11 = *(_QWORD *)(a1 + 80);
  *(_QWORD *)&v12 = v11;
  *((_QWORD *)&v12 + 1) = HIDWORD(v11);
  *(_OWORD *)a3 = v12;
  *(_QWORD *)(a3 + 16) = v10;
  *a4 = v8;
  if (v8)

}

BOOL re::`anonymous namespace'::MetalCompression::isValid(id *this)
{
  id v1;
  id v2;

  v1 = this[8];
  v2 = v1;
  if (v1)

  return v2 != 0;
}

id re::`anonymous namespace'::MetalCompression::length(id *this)
{
  id v1;
  id v2;

  v1 = this[8];
  v2 = objc_msgSend(v1, sel_length);
  if (v1)

  return v2;
}

BOOL `non-virtual thunk to're::`anonymous namespace'::MetalCompression::isValid(uint64_t a1)
{
}

id `non-virtual thunk to're::`anonymous namespace'::MetalCompression::length(uint64_t a1)
{
}

uint64_t `non-virtual thunk to're::`anonymous namespace'::BaseCompressionSource::contents(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(a1 - 8) + 8))(a1 - 8);
}

void `non-virtual thunk to're::`anonymous namespace'::MetalCompression::backingMetalBuffer(uint64_t a1@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
}

void re::`anonymous namespace'::BaseCompressionSource::backingMetalBuffer(_QWORD *a1@<X8>)
{
  *a1 = 0;
}

void `non-virtual thunk to're::`anonymous namespace'::BaseCompressionSource::backingMetalBuffer(_QWORD *a1@<X8>)
{
  *a1 = 0;
}

uint64_t re::`anonymous namespace'::CPUCompression::outputAllocate(re::_anonymous_namespace_::CPUCompression *this, unint64_t a2, unint64_t a3, at_size_t a4)
{
  re::DynamicArray<BOOL>::resize((uint64_t)this + 48, a2);
  return 1;
}

uint64_t re::`anonymous namespace'::CPUCompression::outputBuffer(re::_anonymous_namespace_::CPUCompression *this)
{
  return *((_QWORD *)this + 10);
}

int8x16_t re::`anonymous namespace'::CPUCompression::updateSource@<Q0>(uint64_t a1@<X0>, int8x16_t *a2@<X1>, __int128 *a3@<X2>, _BYTE *a4@<X8>)
{
  __int128 v5;
  uint64_t v6;
  unint64_t v8;
  uint64_t v10;
  uint64_t v11;
  int8x16_t result;

  v5 = *a3;
  *(_QWORD *)(a1 + 136) = *((_QWORD *)a3 + 2);
  *(_OWORD *)(a1 + 120) = v5;
  v6 = *(_QWORD *)(a1 + 16);
  if (*(_DWORD *)(v6 + 88) != 1)
LABEL_5:
    std::__throw_bad_variant_access[abi:nn180100]();
  v8 = *(_QWORD *)(a1 + 24);
  if (*(_QWORD *)(v6 + 32) <= v8)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_5;
  }
  v10 = *(_QWORD *)(*(_QWORD *)(v6 + 48) + 40 * v8 + 32)
      + a2->i64[1] * *((_QWORD *)a3 + 1) * (*(_QWORD *)(a1 + 32) + *(_QWORD *)(a1 + 40));
  objc_msgSend(*(id *)(v6 + 8), sel_textureType);
  v11 = *(_QWORD *)(a1 + 128);
  *(_QWORD *)(a1 + 88) = v10;
  result = vextq_s8(*a2, *a2, 8uLL);
  *(int8x16_t *)(a1 + 96) = result;
  *(_QWORD *)(a1 + 112) = v11;
  *a4 = 1;
  return result;
}

uint64_t re::`anonymous namespace'::CPUCompression::source(re::_anonymous_namespace_::CPUCompression *this)
{
  return (uint64_t)this + 88;
}

BOOL re::`anonymous namespace'::CPUCompression::isValid(re::_anonymous_namespace_::CPUCompression *this)
{
  return *((_QWORD *)this + 8) != 0;
}

uint64_t re::`anonymous namespace'::CPUCompression::length(re::_anonymous_namespace_::CPUCompression *this)
{
  return *((_QWORD *)this + 8);
}

BOOL `non-virtual thunk to're::`anonymous namespace'::CPUCompression::isValid(uint64_t a1)
{
  return *(_QWORD *)(a1 + 56) != 0;
}

uint64_t `non-virtual thunk to're::`anonymous namespace'::CPUCompression::length(uint64_t a1)
{
  return *(_QWORD *)(a1 + 56);
}

uint64_t re::CPUTexture::CPUTexture(uint64_t a1, id a2, uint64_t a3)
{
  _anonymous_namespace_ *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v5 = (_anonymous_namespace_ *)a2;
  *(_QWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)a1 = v5;
  *(_QWORD *)(a1 + 8) = 0;
  v6 = *(_QWORD *)(a3 + 8);
  *(_QWORD *)(a1 + 8) = *(_QWORD *)a3;
  *(_QWORD *)(a1 + 16) = v6;
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  v7 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a3 + 16);
  *(_QWORD *)(a3 + 16) = v7;
  v8 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a3 + 32);
  *(_QWORD *)(a3 + 32) = v8;
  ++*(_DWORD *)(a3 + 24);
  ++*(_DWORD *)(a1 + 32);
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  re::DynamicString::setCapacity((_QWORD *)(a1 + 48), 0);
  return a1;
}

BOOL re::`anonymous namespace'::BasicAppendingOutputAllocator::outputAllocate(re::_anonymous_namespace_::BasicAppendingOutputAllocator *this, uint64_t a2, unint64_t a3, at_size_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v5 = *((_QWORD *)this + 1);
  v6 = *(_QWORD *)(v5 + 16);
  v7 = v6 + a2;
  re::DynamicArray<BOOL>::resize(v5, v6 + a2);
  v8 = *((_QWORD *)this + 1);
  *((_QWORD *)this + 2) = *(_QWORD *)(v8 + 32) + v6;
  return *(_QWORD *)(v8 + 16) == v7;
}

uint64_t re::`anonymous namespace'::BasicAppendingOutputAllocator::outputBuffer(re::_anonymous_namespace_::BasicAppendingOutputAllocator *this)
{
  return *((_QWORD *)this + 2);
}

void re::addPropertyToGeomModelDescriptor(void *a1@<X0>, void *a2@<X1>, void *a3@<X2>, _QWORD *a4@<X3>, const char *a5@<X4>, char a6@<W5>, uint64_t a7@<X8>)
{
  id v12;
  id v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  _anonymous_namespace_ *v26;
  __int128 v27;
  uint64_t v28;
  uint64_t v29;
  void *v30;
  char v31;
  uint64_t v32;
  void *v33;
  void *v34;
  BOOL v35;
  int v36;
  id v37;
  void *v38;
  void *v39;
  uint64_t v40;
  void *v41;
  void *v42;
  void *v43;
  _anonymous_namespace_ *v44;
  unint64_t v45;
  _anonymous_namespace_ *v46;
  const char *v47;
  __int128 v48;
  uint64_t v49;
  uint64_t v50;
  void *v51;
  void *v52;
  void **v53;
  unint64_t v54;
  _anonymous_namespace_ *v55;
  __int128 v56;
  __int128 v57;
  void *v58;
  const char *v59;
  void **v60;
  id v61;
  void *v62;
  char v63;
  void *v64;
  _QWORD *v65;
  id v67;
  __int128 v68;
  __int128 v69;
  void *v70;
  char v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  __int128 v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;

  v12 = a1;
  v67 = a2;
  v13 = a3;
  objc_msgSend(v12, "type");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  v15 = (void *)*MEMORY[0x24BEBED48];

  v65 = a4;
  if (v14 == v15)
  {
    v31 = 8;
LABEL_9:
    v63 = v31;
    v32 = 8;
    goto LABEL_15;
  }
  objc_msgSend(v12, "type");
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  v17 = (void *)*MEMORY[0x24BEBED58];

  if (v16 == v17)
  {
    v63 = 11;
    v32 = 12;
    goto LABEL_15;
  }
  objc_msgSend(v12, "type");
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  v19 = (void *)*MEMORY[0x24BEBED60];

  if (v18 == v19)
  {
    v63 = 10;
    v32 = 16;
    goto LABEL_15;
  }
  objc_msgSend(v12, "type");
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  v21 = (void *)*MEMORY[0x24BEBED70];

  if (v20 == v21)
  {
    v63 = 6;
    v32 = 4;
    goto LABEL_15;
  }
  objc_msgSend(v12, "type");
  v22 = (void *)objc_claimAutoreleasedReturnValue();
  v23 = (void *)*MEMORY[0x24BEBED38];

  if (v22 == v23)
  {
    v31 = 7;
    goto LABEL_9;
  }
  objc_msgSend(v12, "type");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = (void *)*MEMORY[0x24BEBED80];

  if (v24 == v25)
  {
    v32 = 4;
    v63 = 4;
LABEL_15:
    objc_msgSend(v12, "metadataWithKey:", CFSTR("elementSize"));
    v33 = (void *)objc_claimAutoreleasedReturnValue();
    v34 = v33;
    if (v33)
      v35 = objc_msgSend(v33, "intValue") != 1;
    else
      v35 = 0;
    v36 = 4;
    if ((a6 & 1) == 0 && !v35)
    {
      v37 = v13;
      objc_msgSend(v12, "metadataWithKey:", CFSTR("interpolation"));
      v38 = (void *)objc_claimAutoreleasedReturnValue();
      v39 = v38;
      if (v38)
      {
        objc_msgSend(v38, "stringValue");
        v40 = objc_claimAutoreleasedReturnValue();

        v37 = (id)v40;
      }
      if ((objc_msgSend(v37, "isEqualToString:", CFSTR("vertex")) & 1) != 0
        || (objc_msgSend(v37, "isEqualToString:", CFSTR("varying")) & 1) != 0)
      {
        v36 = 1;
      }
      else if ((objc_msgSend(v37, "isEqualToString:", CFSTR("faceVarying")) & 1) != 0)
      {
        v36 = 3;
      }
      else if ((objc_msgSend(v37, "isEqualToString:", CFSTR("constant")) & 1) != 0)
      {
        v36 = 0;
      }
      else if (objc_msgSend(v37, "isEqualToString:", CFSTR("uniform")))
      {
        v36 = 2;
      }
      else
      {
        v36 = 4;
      }

    }
    objc_msgSend(v12, "data");
    v41 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v41, "dataNoCopy");
    v42 = (void *)objc_claimAutoreleasedReturnValue();
    v43 = (void *)objc_msgSend(v42, "copy");

    if (!v41 || !v43)
    {
      v47 = "No values specified for attribute.";
      goto LABEL_31;
    }
    v45 = objc_msgSend(v43, "length");
    v46 = (_anonymous_namespace_ *)objc_msgSend(v41, "arraySize");
    if (v45 < (uint64_t)v46 * v32)
    {
      v47 = "Skipping attribute because the value buffer is malformed.";
LABEL_31:
      v48 = v75;
      v49 = v76;
      v50 = v77;
      *(_BYTE *)a7 = 0;
      *(_QWORD *)(a7 + 8) = 100;
      *(_QWORD *)(a7 + 16) = &re::AssetErrorCategory(void)::instance;
      *(_OWORD *)(a7 + 24) = v48;
      *(_QWORD *)(a7 + 40) = v49;
      *(_QWORD *)(a7 + 48) = v50;
      v30 = v67;
LABEL_51:

      goto LABEL_52;
    }
    *(_QWORD *)&v75 = v43;
    BYTE8(v75) = v63;
    v76 = objc_msgSend(v41, "arraySize");
    v77 = 0;
    v78 = v32;
    v30 = v67;
    objc_msgSend(v67, "data");
    v51 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v51, "dataNoCopy");
    v52 = (void *)objc_claimAutoreleasedReturnValue();
    v64 = (void *)objc_msgSend(v52, "copy");

    v70 = 0;
    v71 = -1;
    v73 = 0;
    v74 = 0;
    v72 = 0;
    if (v67 && v51)
    {
      v54 = objc_msgSend(v64, "length");
      v55 = (_anonymous_namespace_ *)objc_msgSend(v51, "arraySize");
      if (v54 < 4 * (uint64_t)v55)
      {
        v56 = v68;
        v57 = v69;
        *(_BYTE *)a7 = 0;
        *(_QWORD *)(a7 + 8) = 100;
        *(_QWORD *)(a7 + 16) = &re::AssetErrorCategory(void)::instance;
        *(_OWORD *)(a7 + 24) = v56;
        *(_OWORD *)(a7 + 40) = v57;
        v58 = v64;
LABEL_50:

        goto LABEL_51;
      }
      v72 = objc_msgSend(v51, "arraySize");
      v74 = 4;
      v71 = 5;
      v53 = re::ObjCObject::operator=(&v70, v64);
    }
    v59 = a5;
    if (!a5)
    {
      objc_msgSend(v12, "name");
      v62 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v62, "stringValue");
      v61 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
      v53 = (void **)objc_msgSend(v61, "UTF8String");
      v59 = (const char *)v53;
    }
    if (v51)
      v60 = &v70;
    else
      v60 = 0;
    re::GeomModelDescriptor::setAttribute(v65, (uint64_t)&v68, v36, (uint64_t)&v75, (uint64_t)v60, a7);
    v58 = v64;
    if ((_QWORD)v68)
    {
      if ((BYTE8(v68) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v68 + 40))();
      v68 = 0u;
      v69 = 0u;
    }
    if (!a5)
    {

    }
    goto LABEL_50;
  }
  v27 = v75;
  v28 = v76;
  v29 = v77;
  *(_BYTE *)a7 = 0;
  *(_QWORD *)(a7 + 8) = 100;
  *(_QWORD *)(a7 + 16) = &re::AssetErrorCategory(void)::instance;
  *(_OWORD *)(a7 + 24) = v27;
  *(_QWORD *)(a7 + 40) = v28;
  *(_QWORD *)(a7 + 48) = v29;
  v30 = v67;
LABEL_52:

}

void re::addPropertyToGeomModelDescriptorHelper(uint64_t a1, void *a2, void *a3, void *a4, _QWORD *a5, const char *a6, char a7)
{
  id v13;
  id v14;
  id v15;
  void *v16;
  void *v17;
  void *v18;
  id v19;

  v13 = a4;
  v14 = a3;
  v15 = a2;
  objc_msgSend(v14, "name");
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v16, "stringValue");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v17, "stringByAppendingString:", CFSTR(":indices"));
  v19 = (id)objc_claimAutoreleasedReturnValue();

  objc_msgSend(v15, "property:", v19);
  v18 = (void *)objc_claimAutoreleasedReturnValue();

  re::addPropertyToGeomModelDescriptor(v14, v18, v13, a5, a6, a7, a1);
}

id re::primaryUVSetForMesh(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  void **v4;
  void *v5;
  void *v6;
  id v7;
  uint64_t v8;
  uint64_t v9;
  id v10;
  uint64_t v11;
  void *v12;
  void *v13;
  uint64_t i;
  id v15;
  void *v16;
  void *v17;
  id v18;
  id v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  _BYTE v25[128];
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v1 = a1;
  objc_msgSend(v1, "property:", CFSTR("primvars:st"));
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v3 = v2;
  v4 = (void **)MEMORY[0x24BEBED48];
  if (v2
    && (objc_msgSend(v2, "type"), v5 = (void *)objc_claimAutoreleasedReturnValue(), v6 = *v4, v5, v5 == v6))
  {
    v15 = v3;
  }
  else
  {
    v20 = v1;
    objc_msgSend(v1, "properties");
    v21 = 0u;
    v22 = 0u;
    v23 = 0u;
    v24 = 0u;
    v7 = (id)objc_claimAutoreleasedReturnValue();
    v8 = objc_msgSend(v7, "countByEnumeratingWithState:objects:count:", &v21, v25, 16);
    if (v8)
    {
      v9 = v8;
      v10 = 0;
      v11 = *(_QWORD *)v22;
      v12 = (void *)*MEMORY[0x24BEBEE58];
      v13 = *v4;
      while (2)
      {
        for (i = 0; i != v9; ++i)
        {
          if (*(_QWORD *)v22 != v11)
            objc_enumerationMutation(v7);
          objc_msgSend(v7, "objectForKey:", *(_QWORD *)(*((_QWORD *)&v21 + 1) + 8 * i));
          v15 = (id)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v15, "role");
          v16 = (void *)objc_claimAutoreleasedReturnValue();

          if (v16 == v12)
          {

            goto LABEL_17;
          }
          objc_msgSend(v15, "type");
          v17 = (void *)objc_claimAutoreleasedReturnValue();

          if (v17 == v13)
          {
            v18 = v15;

            v10 = v18;
          }

        }
        v9 = objc_msgSend(v7, "countByEnumeratingWithState:objects:count:", &v21, v25, 16);
        if (v9)
          continue;
        break;
      }
    }
    else
    {
      v10 = 0;
    }

    v10 = v10;
    v15 = v10;
LABEL_17:

    v1 = v20;
  }

  return v15;
}

void re::addSkeletonBindingsAsAttributesToModelDescriptor(_QWORD *a1, void *a2, uint64_t a3, unint64_t a4)
{
  id v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  unint64_t v14;
  int v15;
  unint64_t v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  unint64_t v21;
  void *v22;
  void *v23;
  int v24;
  void *v25;
  void *v26;
  char v27;
  void *v28;
  void *v29;
  char v30;
  void *v31;
  uint64_t v32;
  void *v33;
  uint64_t v34;
  _anonymous_namespace_ *v35;
  _anonymous_namespace_ *v36;
  uint64_t v37;
  unint64_t v38;
  size_t v39;
  _QWORD *v40;
  _anonymous_namespace_ *v41;
  _anonymous_namespace_ *v42;
  uint64_t v43;
  size_t v44;
  _anonymous_namespace_ *v45;
  unint64_t v46;
  _anonymous_namespace_ *v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  int v51;
  _anonymous_namespace_ *v52;
  void *v53;
  float32x4_t *v54;
  _anonymous_namespace_ *v55;
  void *v56;
  void *v57;
  void *v58;
  void *v59;
  _anonymous_namespace_ *v60;
  unint64_t v61;
  _anonymous_namespace_ *v62;
  uint64_t v63;
  id v64;
  const char *v65;
  void *v66;
  _anonymous_namespace_ *v67;
  _DWORD *v68;
  uint64_t v69;
  _anonymous_namespace_ *v70;
  id v71;
  void *v72;
  id v73;
  char v74;
  void *v75;
  uint64_t v76;
  unint64_t v77;
  void *v78;
  _QWORD *v79;
  unint64_t v80;
  int v81;
  _anonymous_namespace_ *v82;
  uint64_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  __int128 v88;
  float32x4_t v89;
  float32x4_t v90;
  void *v91;
  char v92[24];
  __int128 v93;
  __int128 v94;
  uint64_t v95;
  unint64_t v96;
  char v97[24];
  __int128 v98;
  __int128 v99;
  uint64_t v100;
  unint64_t v101;
  uint64_t v102;
  char v103[24];
  __int128 v104;
  __int128 v105;
  char v106[24];
  __int128 v107;
  __int128 v108;
  char v109[24];
  __int128 v110;
  __int128 v111;
  char v112[24];
  __int128 v113;
  __int128 v114;
  char v115[24];
  __int128 v116;
  __int128 v117;
  uint64_t v118;
  _QWORD *v119;
  uint64_t v120;
  char v121[24];
  __int128 v122;
  __int128 v123;
  float64x2_t v124;
  float64x2_t v125;
  float64x2_t v126;
  float64x2_t v127;
  float64x2_t v128;
  float64x2_t v129;
  float64x2_t v130;
  float64x2_t v131;
  _BYTE v132[28];
  __int16 v133;
  _QWORD *v134;
  uint64_t v135;

  v135 = *MEMORY[0x24BDAC8D0];
  v7 = a2;
  objc_msgSend(v7, "inheritedProperty:", CFSTR("primvars:skel:jointWeights"));
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v7, "inheritedProperty:", CFSTR("primvars:skel:jointIndices"));
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  if (v8)
  {
    objc_msgSend(v8, "data");
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    v11 = v10;
    if (v10 && v9)
    {
      objc_msgSend(v9, "data");
      v12 = (void *)objc_claimAutoreleasedReturnValue();

      if (v12)
      {
        objc_msgSend(v8, "metadataWithKey:", CFSTR("elementSize"));
        v13 = (void *)objc_claimAutoreleasedReturnValue();
        v14 = (unint64_t)v13;
        if (v13)
          v15 = objc_msgSend(v13, "intValue");
        else
          v15 = 1;
        v81 = v15;
        v83 = v15;
        v16 = a1[2] * v15;
        objc_msgSend(v8, "data");
        v17 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v17, "dataNoCopy");
        v18 = (void *)objc_claimAutoreleasedReturnValue();
        if (objc_msgSend(v18, "length") < 4 * v16)
        {

LABEL_128:
          goto LABEL_129;
        }
        v76 = a3;
        v77 = a4;
        v79 = a1;
        v80 = v14;
        objc_msgSend(v9, "data");
        v19 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v19, "dataNoCopy");
        v20 = (void *)objc_claimAutoreleasedReturnValue();
        v21 = objc_msgSend(v20, "length");

        if (v21 < 4 * v16)
          goto LABEL_128;
        objc_msgSend(v9, "metadataWithKey:", CFSTR("elementSize"));
        v22 = (void *)objc_claimAutoreleasedReturnValue();
        v23 = v22;
        v24 = v22 ? objc_msgSend(v22, "intValue") : 1;

        if (v24 != v81)
          goto LABEL_128;
        objc_msgSend(v8, "metadataWithKey:", CFSTR("interpolation"));
        v25 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v25, "stringValue");
        v26 = (void *)objc_claimAutoreleasedReturnValue();
        v27 = objc_msgSend(v26, "isEqualToString:", CFSTR("constant"));

        objc_msgSend(v9, "metadataWithKey:", CFSTR("interpolation"));
        v28 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v28, "stringValue");
        v29 = (void *)objc_claimAutoreleasedReturnValue();
        v30 = objc_msgSend(v29, "isEqualToString:", CFSTR("constant"));

        if ((v27 & 1) == 0)
        {
          objc_msgSend(v8, "data");
          v31 = (void *)objc_claimAutoreleasedReturnValue();
          v32 = objc_msgSend(v31, "arraySize");

          if (v32 != v16)
            goto LABEL_128;
        }
        if ((v30 & 1) == 0)
        {
          objc_msgSend(v9, "data");
          v33 = (void *)objc_claimAutoreleasedReturnValue();
          v34 = objc_msgSend(v33, "arraySize");

          if (v34 != v16)
            goto LABEL_128;
        }
        if ((v27 & 1) != 0)
        {
          v74 = v30;
          objc_msgSend(v8, "data");
          v72 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v72, "dataNoCopy");
          v71 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
          v35 = (_anonymous_namespace_ *)objc_msgSend(v71, "bytes");
          v119 = 0;
          v118 = 0;
          v120 = 0;
          if (v16)
          {
            v37 = 0;
            v38 = 0;
            v39 = 4 * v83;
            do
            {
              v40 = v119;
              if ((unint64_t)v119 <= v38)
                goto LABEL_131;
              v36 = (_anonymous_namespace_ *)memcpy((void *)(v120 + v37), v35, v39);
              v38 += v83;
              v37 += v39;
            }
            while (v38 < v16);
          }
          v100 = v120;
          v101 = (unint64_t)v119;
          *(_QWORD *)v132 = 0;
          *(_QWORD *)&v132[8] = 0;
          v40 = v79;
          re::GeomModelDescriptor::setAttribute<float,unsigned int>(v79, (uint64_t)&v124, 4, (re *)&v100, (re *)v132, (uint64_t)v115);
          v38 = v77;
          if (!v115[0] && (_QWORD)v116)
          {
            if ((BYTE8(v116) & 1) != 0)
              (*(void (**)(void))(*(_QWORD *)v116 + 40))();
            v116 = 0u;
            v117 = 0u;
          }
          v30 = v74;
          if (*(_QWORD *)&v124.f64[0] && (LOBYTE(v124.f64[1]) & 1) != 0)
            (*(void (**)(void))(**(_QWORD **)&v124.f64[0] + 40))();
          if (v118 && v119)
            (*(void (**)(void))(*(_QWORD *)v118 + 40))();

        }
        else
        {
          v40 = v79;
          re::addPropertyToGeomModelDescriptorHelper((uint64_t)v121, v7, v8, CFSTR("constant"), v79, "skinnedAnimationWeights", 1);
          v38 = v77;
          if (!v121[0] && (_QWORD)v122)
          {
            if ((BYTE8(v122) & 1) != 0)
              (*(void (**)(void))(*(_QWORD *)v122 + 40))();
            v122 = 0u;
            v123 = 0u;
          }
        }
        if ((v30 & 1) != 0)
        {
          objc_msgSend(v9, "data");
          v75 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v75, "dataNoCopy");
          v73 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
          v41 = (_anonymous_namespace_ *)objc_msgSend(v73, "bytes");
          v119 = 0;
          v118 = 0;
          v120 = 0;
          if (v16)
          {
            v43 = 0;
            v38 = 0;
            v44 = 4 * v83;
            while (1)
            {
              v40 = v119;
              if ((unint64_t)v119 <= v38)
                break;
              v42 = (_anonymous_namespace_ *)memcpy((void *)(v120 + v43), v41, v44);
              v38 += v83;
              v43 += v44;
              if (v38 >= v16)
                goto LABEL_47;
            }
LABEL_132:
            v100 = 0;
            v127 = 0u;
            v128 = 0u;
            v125 = 0u;
            v126 = 0u;
            v124 = 0u;
            os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
            *(_DWORD *)v132 = 136315906;
            *(_QWORD *)&v132[4] = "operator[]";
            *(_WORD *)&v132[12] = 1024;
            *(_DWORD *)&v132[14] = 468;
            *(_WORD *)&v132[18] = 2048;
            *(_QWORD *)&v132[20] = v38;
            v133 = 2048;
            v134 = v40;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_133:
            v95 = 0;
            v127 = 0u;
            v128 = 0u;
            v125 = 0u;
            v126 = 0u;
            v124 = 0u;
            os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
            *(_DWORD *)v132 = 136315906;
            *(_QWORD *)&v132[4] = "operator[]";
            *(_WORD *)&v132[12] = 1024;
            *(_DWORD *)&v132[14] = 468;
            *(_WORD *)&v132[18] = 2048;
            *(_QWORD *)&v132[20] = v14;
            v133 = 2048;
            v134 = (_QWORD *)v38;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_134:
            v95 = 0;
            v127 = 0u;
            v128 = 0u;
            v125 = 0u;
            v126 = 0u;
            v124 = 0u;
            os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
            *(_DWORD *)v132 = 136315906;
            *(_QWORD *)&v132[4] = "operator[]";
            *(_WORD *)&v132[12] = 1024;
            *(_DWORD *)&v132[14] = 468;
            *(_WORD *)&v132[18] = 2048;
            *(_QWORD *)&v132[20] = v14;
            v133 = 2048;
            v134 = (_QWORD *)v38;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
          }
LABEL_47:
          v100 = v120;
          v101 = (unint64_t)v119;
          *(_QWORD *)v132 = 0;
          *(_QWORD *)&v132[8] = 0;
          v40 = v79;
          re::GeomModelDescriptor::setAttribute<int,unsigned int>(v79, (uint64_t)&v124, 4, (re *)&v100, (re *)v132, (uint64_t)v109);
          if (!v109[0] && (_QWORD)v110)
          {
            if ((BYTE8(v110) & 1) != 0)
              (*(void (**)(void))(*(_QWORD *)v110 + 40))();
            v110 = 0u;
            v111 = 0u;
          }
          v38 = v77;
          if (*(_QWORD *)&v124.f64[0] && (LOBYTE(v124.f64[1]) & 1) != 0)
            (*(void (**)(void))(**(_QWORD **)&v124.f64[0] + 40))();
          if (v118 && v119)
            (*(void (**)(void))(*(_QWORD *)v118 + 40))();

        }
        else
        {
          re::addPropertyToGeomModelDescriptorHelper((uint64_t)v112, v7, v9, CFSTR("constant"), v40, "skinnedAnimationJointIndices", 1);
          if (!v112[0])
          {
            v45 = (_anonymous_namespace_ *)v113;
            if ((_QWORD)v113)
            {
              if ((BYTE8(v113) & 1) != 0)
                v45 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v113 + 40))();
              v113 = 0u;
              v114 = 0u;
            }
          }
        }
        v46 = v40[2];
        v119 = 0;
        v118 = 0;
        v120 = 0;
        if (!v46)
        {
LABEL_68:
          v100 = v120;
          v101 = (unint64_t)v119;
          *(_QWORD *)v132 = 0;
          *(_QWORD *)&v132[8] = 0;
          re::GeomModelDescriptor::setAttribute<int,unsigned int>(v40, (uint64_t)&v124, 4, (re *)&v100, (re *)v132, (uint64_t)v106);
          if (!v106[0] && (_QWORD)v107)
          {
            if ((BYTE8(v107) & 1) != 0)
              (*(void (**)(void))(*(_QWORD *)v107 + 40))();
            v107 = 0u;
            v108 = 0u;
          }
          if (*(_QWORD *)&v124.f64[0] && (LOBYTE(v124.f64[1]) & 1) != 0)
            (*(void (**)(void))(**(_QWORD **)&v124.f64[0] + 40))();
          if (v118 && v119)
            (*(void (**)(void))(*(_QWORD *)v118 + 40))();
          objc_msgSend(v7, "inheritedProperty:", CFSTR("primvars:skel:geomBindTransform"));
          v52 = (_anonymous_namespace_ *)objc_claimAutoreleasedReturnValue();
          v119 = 0;
          v118 = 0;
          v120 = 0;
          if (v52
            && (-[_anonymous_namespace_ data](v52, "data"),
                v53 = (void *)objc_claimAutoreleasedReturnValue(),
                v53,
                v53))
          {
            v130 = 0u;
            v131 = 0u;
            v128 = 0u;
            v129 = 0u;
            v126 = 0u;
            v127 = 0u;
            v124 = 0u;
            v125 = 0u;
            -[_anonymous_namespace_ double4x4Value](v52, "double4x4Value");
            v84 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v124), v125);
            *(float32x4_t *)_ZN2re10FixedArrayIDv4_fEixEm((unint64_t)v119, v120, 0) = v84;
            v85 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v126), v127);
            *(float32x4_t *)_ZN2re10FixedArrayIDv4_fEixEm((unint64_t)v119, v120, 1uLL) = v85;
            v86 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v128), v129);
            *(float32x4_t *)_ZN2re10FixedArrayIDv4_fEixEm((unint64_t)v119, v120, 2uLL) = v86;
            v87 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v130), v131);
          }
          else
          {
            v54 = (float32x4_t *)MEMORY[0x24BDAEE00];
            v88 = *MEMORY[0x24BDAEE00];
            *(_OWORD *)_ZN2re10FixedArrayIDv4_fEixEm((unint64_t)v119, v120, 0) = v88;
            v89 = v54[1];
            *(float32x4_t *)_ZN2re10FixedArrayIDv4_fEixEm((unint64_t)v119, v120, 1uLL) = v89;
            v90 = v54[2];
            *(float32x4_t *)_ZN2re10FixedArrayIDv4_fEixEm((unint64_t)v119, v120, 2uLL) = v90;
            v87 = v54[3];
          }
          v55 = (_anonymous_namespace_ *)_ZN2re10FixedArrayIDv4_fEixEm((unint64_t)v119, v120, 3uLL);
          *(float32x4_t *)v55 = v87;
          v100 = v120;
          v101 = (unint64_t)v119;
          *(_QWORD *)v132 = 0;
          *(_QWORD *)&v132[8] = 0;
          _ZN2re19GeomModelDescriptor12setAttributeIDv4_fjEENS_6ResultINS_4UnitENS_13DetailedErrorEEERKNS_13DynamicStringENS_17GeomAttributeRateERKNS_5SliceIT_EERKNSB_IT0_EE(v40, (uint64_t)&v124, 4, (re *)&v100, (re *)v132, (uint64_t)v103);
          if (!v103[0] && (_QWORD)v104)
          {
            if ((BYTE8(v104) & 1) != 0)
              (*(void (**)(void))(*(_QWORD *)v104 + 40))();
            v104 = 0u;
            v105 = 0u;
          }
          if (*(_QWORD *)&v124.f64[0] && (LOBYTE(v124.f64[1]) & 1) != 0)
            (*(void (**)(void))(**(_QWORD **)&v124.f64[0] + 40))();
          objc_msgSend(v7, "property:", CFSTR("skel:joints"));
          v56 = (void *)objc_claimAutoreleasedReturnValue();
          v57 = v56;
          if (v56)
          {
            objc_msgSend(v56, "data");
            v58 = (void *)objc_claimAutoreleasedReturnValue();

            if (v58)
            {
              v82 = v52;
              v78 = v57;
              objc_msgSend(v57, "stringArray");
              v59 = (void *)objc_claimAutoreleasedReturnValue();
              v60 = (_anonymous_namespace_ *)objc_msgSend(v59, "count");
              v100 = 0;
              v101 = 0;
              v102 = 0;
              v61 = v60;
              v91 = (void *)v61;
              if (v61)
              {
                v14 = 0;
                v63 = v38 + 112;
                do
                {
                  objc_msgSend(v59, "objectAtIndexedSubscript:", v14);
                  v64 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
                  v65 = (const char *)objc_msgSend(v64, "UTF8String");
                  objc_msgSend(v59, "objectAtIndexedSubscript:", v14);
                  v66 = (void *)objc_claimAutoreleasedReturnValue();
                  v67 = (_anonymous_namespace_ *)objc_msgSend(v66, "length");
                  v124.f64[0] = 0.0;
                  *(_QWORD *)&v124.f64[1] = &str_110;
                  v68 = (_DWORD *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v63, &v124);
                  re::StringID::destroyString((re::StringID *)&v124);

                  v38 = v101;
                  if (v68)
                  {
                    if (v101 <= v14)
                      goto LABEL_133;
                    *(_DWORD *)(v102 + 4 * v14) = *v68;
                  }
                  else
                  {
                    if (v101 <= v14)
                      goto LABEL_134;
                    *(_DWORD *)(v102 + 4 * v14) = v14;
                  }
                  ++v14;
                }
                while (v91 != (void *)v14);
              }
              v95 = v102;
              v96 = v101;
              *(_QWORD *)v132 = 0;
              *(_QWORD *)&v132[8] = 0;
              v40 = v79;
              re::GeomModelDescriptor::setAttribute<int,unsigned int>(v79, (uint64_t)&v124, 4, (re *)&v95, (re *)v132, (uint64_t)v97);
              if (!v97[0] && (_QWORD)v98)
              {
                if ((BYTE8(v98) & 1) != 0)
                  (*(void (**)(void))(*(_QWORD *)v98 + 40))();
                v98 = 0u;
                v99 = 0u;
              }
              if (*(_QWORD *)&v124.f64[0] && (LOBYTE(v124.f64[1]) & 1) != 0)
                (*(void (**)(void))(**(_QWORD **)&v124.f64[0] + 40))();
              v14 = v80;
              if (v100 && v101)
                (*(void (**)(void))(*(_QWORD *)v100 + 40))();

              v52 = v82;
              v57 = v78;
            }
          }
          memset(v132, 0, 24);
          v69 = (*(_QWORD *)(v76 + 8) >> 1) + 1;
          v70 = (_anonymous_namespace_ *)memcpy(*(void **)&v132[16], *(const void **)v76, *(_QWORD *)(v76 + 8));
          *(_BYTE *)(*(_QWORD *)&v132[16] + *(_QWORD *)(v76 + 8)) = 0;
          v95 = *(_QWORD *)&v132[16];
          v96 = *(_QWORD *)&v132[8];
          v100 = 0;
          v101 = 0;
          re::GeomModelDescriptor::setAttribute<unsigned short,unsigned int>(v40, (uint64_t)&v124, 4, (re *)&v95, (re *)&v100, (uint64_t)v92);
          if (!v92[0] && (_QWORD)v93)
          {
            if ((BYTE8(v93) & 1) != 0)
              (*(void (**)(void))(*(_QWORD *)v93 + 40))();
            v93 = 0u;
            v94 = 0u;
          }
          if (*(_QWORD *)&v124.f64[0] && (LOBYTE(v124.f64[1]) & 1) != 0)
            (*(void (**)(void))(**(_QWORD **)&v124.f64[0] + 40))();
          if (*(_QWORD *)v132 && *(_QWORD *)&v132[8])
            (*(void (**)(void))(**(_QWORD **)v132 + 40))();

          if (v118 && v119)
            (*(void (**)(void))(*(_QWORD *)v118 + 40))();

          goto LABEL_128;
        }
        v48 = 0;
        v49 = (unint64_t)v119;
        v50 = v120;
        v51 = v81;
        while (v49 != v48)
        {
          *(_DWORD *)(v50 + 4 * v48) = v51;
          v51 += v81;
          if (v46 == ++v48)
            goto LABEL_68;
        }
        v100 = 0;
        v127 = 0u;
        v128 = 0u;
        v125 = 0u;
        v126 = 0u;
        v124 = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        *(_DWORD *)v132 = 136315906;
        *(_QWORD *)&v132[4] = "operator[]";
        *(_WORD *)&v132[12] = 1024;
        *(_DWORD *)&v132[14] = 468;
        *(_WORD *)&v132[18] = 2048;
        *(_QWORD *)&v132[20] = v49;
        v133 = 2048;
        v134 = (_QWORD *)v49;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_131:
        v100 = 0;
        v127 = 0u;
        v128 = 0u;
        v125 = 0u;
        v126 = 0u;
        v124 = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        *(_DWORD *)v132 = 136315906;
        *(_QWORD *)&v132[4] = "operator[]";
        *(_WORD *)&v132[12] = 1024;
        *(_DWORD *)&v132[14] = 468;
        *(_WORD *)&v132[18] = 2048;
        *(_QWORD *)&v132[20] = v38;
        v133 = 2048;
        v134 = v40;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_132;
      }
    }
    else
    {

    }
  }
LABEL_129:

}

uint64_t _ZN2re10FixedArrayIDv4_fEixEm(unint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a1 <= a3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return a2 + 16 * a3;
}

void re::attachNewBlendShapeDataIfItExistsToModelDescriptor(_QWORD *a1, void *a2)
{
  id v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  id v7;
  _anonymous_namespace_ *v8;
  re::DynamicString *v9;
  int v10;
  void *v11;
  uint64_t v12;
  void *v13;
  void *v14;
  id v15;
  _anonymous_namespace_ *v16;
  uint64_t v17;
  id v18;
  uint64_t v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  id v28;
  void *v29;
  id v30;
  _anonymous_namespace_ *v31;
  uint64_t v32;
  id v33;
  _OWORD v35[2];
  _OWORD v36[2];
  _BYTE v37[24];
  __int128 v38;
  __int128 v39;
  id v40;
  char v41;
  uint64_t v42;
  __int128 v43;

  v2 = a2;
  v3 = v2;
  if (!v2)
    goto LABEL_15;
  objc_msgSend(v2, "name");
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  if (!v4)
    goto LABEL_15;
  objc_msgSend(v3, "name");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v5, "stringValue");
  v6 = (void *)objc_claimAutoreleasedReturnValue();

  v7 = objc_retainAutorelease(v6);
  v8 = (_anonymous_namespace_ *)objc_msgSend(v7, "UTF8String");
  re::DynamicString::rfind((uint64_t)v9, "_blendShape", v36);
  if (v40 && (v41 & 1) != 0)
    (*(void (**)(id, uint64_t))(*(_QWORD *)v40 + 40))(v40, v42);
  v10 = LOBYTE(v36[0]);

  if (!v10)
  {
LABEL_15:
    v18 = 0;
LABEL_16:

    goto LABEL_17;
  }
  objc_msgSend(v3, "childIterator");
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v11, "nextObject");
  v12 = objc_claimAutoreleasedReturnValue();
  if (v12)
  {
    v13 = (void *)v12;
    while (1)
    {
      objc_msgSend(v13, "name");
      v14 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v14, "stringValue");
      v15 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
      v16 = (_anonymous_namespace_ *)objc_msgSend(v15, "UTF8String");

      re::DynamicString::rfind((uint64_t)&v40, "_blendTargets", v36);
      if (LOBYTE(v36[0]))
        break;
      if (v40 && (v41 & 1) != 0)
        (*(void (**)(id, uint64_t))(*(_QWORD *)v40 + 40))(v40, v42);
      objc_msgSend(v11, "nextObject");
      v17 = objc_claimAutoreleasedReturnValue();

      v13 = (void *)v17;
      if (!v17)
        goto LABEL_14;
    }
    v18 = v13;
    if (v40 && (v41 & 1) != 0)
      (*(void (**)(id, uint64_t))(*(_QWORD *)v40 + 40))(v40, v42);

  }
  else
  {
LABEL_14:
    v18 = 0;
  }

  if (v18)
  {
    objc_msgSend(v18, "childIterator");
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v3, "nextObject");
    v19 = objc_claimAutoreleasedReturnValue();
    if (v19)
    {
      v20 = (void *)v19;
      v33 = v18;
      v21 = (void *)*MEMORY[0x24BEBED58];
      do
      {
        objc_msgSend(v20, "property:", CFSTR("offsets"), v33);
        v22 = (void *)objc_claimAutoreleasedReturnValue();
        v23 = v22;
        if (v22)
        {
          objc_msgSend(v22, "data");
          v24 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v23, "type");
          v25 = (void *)objc_claimAutoreleasedReturnValue();

          if (v25 == v21)
          {
            objc_msgSend(v24, "dataNoCopy");
            v26 = (void *)objc_claimAutoreleasedReturnValue();
            v27 = (void *)objc_msgSend(v26, "copy");

            v28 = v27;
            v40 = v28;
            v41 = 11;
            v42 = objc_msgSend(v24, "arraySize");
            v43 = xmmword_226104380;
            objc_msgSend(v20, "name");
            v29 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v29, "stringValue");
            v30 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
            v31 = (_anonymous_namespace_ *)objc_msgSend(v30, "UTF8String");
            re::DynamicString::operator+((re::DynamicString *)v35, "|blendTargetPosDeltas", (re::DynamicString *)v36);
            re::GeomModelDescriptor::setAttribute(a1, (uint64_t)v36, 1, (uint64_t)&v40, 0, (uint64_t)v37);
            if (!v37[0] && (_QWORD)v38)
            {
              if ((BYTE8(v38) & 1) != 0)
                (*(void (**)(void))(*(_QWORD *)v38 + 40))();
              v38 = 0u;
              v39 = 0u;
            }
            if (*(_QWORD *)&v36[0])
            {
              if ((BYTE8(v36[0]) & 1) != 0)
                (*(void (**)(void))(**(_QWORD **)&v36[0] + 40))();
              memset(v36, 0, sizeof(v36));
            }
            if (*(_QWORD *)&v35[0])
            {
              if ((BYTE8(v35[0]) & 1) != 0)
                (*(void (**)(void))(**(_QWORD **)&v35[0] + 40))();
              memset(v35, 0, sizeof(v35));
            }

          }
        }

        objc_msgSend(v3, "nextObject");
        v32 = objc_claimAutoreleasedReturnValue();

        v20 = (void *)v32;
      }
      while (v32);
      v18 = v33;
    }
    goto LABEL_16;
  }
LABEL_17:

}

void re::attachOpenSubdivDataToModelDescriptor(_BYTE *a1, void *a2)
{
  id v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  uint64_t v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  unsigned int *v19;
  uint64_t v20;
  unsigned int v21;
  unsigned int v22;
  uint64_t v23;
  unint64_t v24;
  _anonymous_namespace_ *v25;
  _anonymous_namespace_ *v26;
  unint64_t v27;
  uint64_t v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  unint64_t v32;
  int v33;
  int v34;
  uint64_t v35;
  unsigned int v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  _anonymous_namespace_ *v40;
  void *v41;
  void *v42;
  void *v43;
  uint64_t v44;
  void *v45;
  void *v46;
  _QWORD *v47;
  void *v48;
  void *v49;
  void *v50;
  void *v51;
  id v52;
  id v53;
  _anonymous_namespace_ *v54;
  void *v55;
  _QWORD *v56;
  uint64_t v57;
  id v58;
  id v59;
  id v60;
  char v61[24];
  __int128 v62;
  __int128 v63;
  _anonymous_namespace_ *v64;
  unint64_t v65;
  uint64_t v66;
  char v67[24];
  __int128 v68;
  __int128 v69;
  char v70[24];
  __int128 v71;
  __int128 v72;
  uint64_t v73;
  unint64_t v74;
  char v75[24];
  __int128 v76;
  __int128 v77;
  uint64_t v78;
  unint64_t v79;
  uint64_t v80;
  _BYTE v81[40];
  __int128 v82;
  _QWORD v83[4];
  __int128 v84;
  __int128 v85;
  uint64_t v86;

  v86 = *MEMORY[0x24BDAC8D0];
  v3 = a2;
  *a1 = 1;
  objc_msgSend(v3, "property:", CFSTR("creaseIndices"));
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "property:", CFSTR("creaseLengths"));
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "property:", CFSTR("creaseSharpnesses"));
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v7 = v6;
  if (v4)
  {
    if (v5)
    {
      if (v6)
      {
        if (objc_msgSend(v6, "arraySize"))
        {
          v8 = objc_msgSend(v7, "arraySize");
          if (v8 == objc_msgSend(v5, "arraySize"))
          {
            objc_msgSend(v4, "data");
            v9 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v9, "dataNoCopy");
            v10 = (void *)objc_claimAutoreleasedReturnValue();

            objc_msgSend(v5, "data");
            v11 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v11, "dataNoCopy");
            v12 = (void *)objc_claimAutoreleasedReturnValue();

            objc_msgSend(v7, "data");
            v13 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v13, "dataNoCopy");
            v59 = (id)objc_claimAutoreleasedReturnValue();

            v58 = objc_retainAutorelease(v12);
            v14 = objc_msgSend(v58, "bytes");
            v15 = objc_msgSend(v7, "arraySize");
            v16 = v15;
            if (v15)
            {
              LODWORD(v17) = 0;
              v18 = 0;
              v19 = (unsigned int *)v14;
              v20 = v15;
              while (1)
              {
                v22 = *v19++;
                v21 = v22;
                if (v22 < 2)
                  break;
                v17 = v21 + v17;
                v18 = v18 + v21 - 1;
                if (!--v20)
                  goto LABEL_12;
              }
            }
            else
            {
              v18 = 0;
              v17 = 0;
LABEL_12:
              if (objc_msgSend(v4, "arraySize") == v17)
              {
                v55 = v10;
                v56 = a1;
                v57 = v14;
                v23 = objc_msgSend(objc_retainAutorelease(v10), "bytes");
                v24 = objc_msgSend(objc_retainAutorelease(v59), "bytes");
                v64 = 0;
                v65 = 0;
                v66 = 0;
                v78 = 0;
                v79 = 0;
                v80 = 0;
                if (v16)
                {
                  v27 = v24;
                  v28 = 0;
                  v29 = 0;
                  v30 = 0;
                  v31 = 0;
                  v32 = v65;
                  do
                  {
                    v33 = *(_DWORD *)(v57 + 4 * v28) - 1;
                    if (*(_DWORD *)(v57 + 4 * v28) != 1)
                    {
                      v34 = *(_DWORD *)(v27 + 4 * v28);
                      v35 = v66;
                      v36 = v33 + v30;
                      v38 = v79;
                      v37 = v80;
                      do
                      {
                        v39 = v29;
                        if (v32 <= v29)
                        {
                          v73 = 0;
                          v84 = 0u;
                          v85 = 0u;
                          memset(v83, 0, sizeof(v83));
                          v82 = 0u;
                          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
                          *(_DWORD *)v81 = 136315906;
                          *(_QWORD *)&v81[4] = "operator[]";
                          *(_WORD *)&v81[12] = 1024;
                          *(_DWORD *)&v81[14] = 468;
                          *(_WORD *)&v81[18] = 2048;
                          *(_QWORD *)&v81[20] = v39;
                          *(_WORD *)&v81[28] = 2048;
                          *(_QWORD *)&v81[30] = v32;
                          _os_log_send_and_compose_impl();
                          _os_crash_msg();
                          __break(1u);
LABEL_69:
                          v73 = 0;
                          v84 = 0u;
                          v85 = 0u;
                          memset(v83, 0, sizeof(v83));
                          v82 = 0u;
                          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
                          *(_DWORD *)v81 = 136315906;
                          *(_QWORD *)&v81[4] = "operator[]";
                          *(_WORD *)&v81[12] = 1024;
                          *(_DWORD *)&v81[14] = 468;
                          *(_WORD *)&v81[18] = 2048;
                          *(_QWORD *)&v81[20] = v24;
                          *(_WORD *)&v81[28] = 2048;
                          *(_QWORD *)&v81[30] = v32;
                          _os_log_send_and_compose_impl();
                          _os_crash_msg();
                          __break(1u);
LABEL_70:
                          v73 = 0;
                          v84 = 0u;
                          v85 = 0u;
                          memset(v83, 0, sizeof(v83));
                          v82 = 0u;
                          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
                          *(_DWORD *)v81 = 136315906;
                          *(_QWORD *)&v81[4] = "operator[]";
                          *(_WORD *)&v81[12] = 1024;
                          *(_DWORD *)&v81[14] = 468;
                          *(_WORD *)&v81[18] = 2048;
                          *(_QWORD *)&v81[20] = v24;
                          *(_WORD *)&v81[28] = 2048;
                          *(_QWORD *)&v81[30] = v38;
                          _os_log_send_and_compose_impl();
                          _os_crash_msg();
                          __break(1u);
                        }
                        *(_DWORD *)(v35 + 4 * v29) = *(_DWORD *)(v23 + 4 * v31);
                        v24 = v29 + 1;
                        if (v32 <= v24)
                          goto LABEL_69;
                        *(_DWORD *)(v35 + 4 * v24) = *(_DWORD *)(v23 + 4 * ++v31);
                        v24 = v30;
                        if (v38 <= v30)
                          goto LABEL_70;
                        *(_DWORD *)(v37 + 4 * v30++) = v34;
                        v29 += 2;
                        --v33;
                      }
                      while (v33);
                      v30 = v36;
                    }
                    ++v31;
                    ++v28;
                  }
                  while (v28 != v16);
                }
                v73 = v66;
                v74 = v65;
                *(_QWORD *)v81 = 0;
                *(_QWORD *)&v81[8] = 0;
                a1 = v56;
                re::GeomModelDescriptor::setAttribute<unsigned int,unsigned int>(v56, (uint64_t)&v82, 4, (re *)&v73, (re *)v81, (uint64_t)v75);
                v10 = v55;
                if (!v75[0] && (_QWORD)v76)
                {
                  if ((BYTE8(v76) & 1) != 0)
                    (*(void (**)(void))(*(_QWORD *)v76 + 40))();
                  v76 = 0u;
                  v77 = 0u;
                }
                v40 = (_anonymous_namespace_ *)v82;
                if ((_QWORD)v82 && (BYTE8(v82) & 1) != 0)
                  v40 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v82 + 40))();
                v73 = v80;
                v74 = v79;
                *(_QWORD *)v81 = 0;
                *(_QWORD *)&v81[8] = 0;
                re::GeomModelDescriptor::setAttribute<float,unsigned int>(v56, (uint64_t)&v82, 4, (re *)&v73, (re *)v81, (uint64_t)v70);
                if (!v70[0] && (_QWORD)v71)
                {
                  if ((BYTE8(v71) & 1) != 0)
                    (*(void (**)(void))(*(_QWORD *)v71 + 40))();
                  v71 = 0u;
                  v72 = 0u;
                }
                if ((_QWORD)v82 && (BYTE8(v82) & 1) != 0)
                  (*(void (**)(void))(*(_QWORD *)v82 + 40))();
                if (v78 && v79)
                  (*(void (**)(void))(*(_QWORD *)v78 + 40))();
                if (v64 && v65)
                  (*(void (**)(void))(*(_QWORD *)v64 + 40))();
              }
            }

          }
        }
      }
    }
  }
  objc_msgSend(v3, "property:", CFSTR("cornerIndices"));
  v41 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "property:", CFSTR("cornerSharpness"));
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  v43 = v42;
  if (v41)
  {
    if (v42)
    {
      if (objc_msgSend(v42, "arraySize"))
      {
        v44 = objc_msgSend(v43, "arraySize");
        if (v44 == objc_msgSend(v41, "arraySize"))
        {
          v60 = v4;
          objc_msgSend(v41, "data");
          v45 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v45, "dataNoCopy");
          v46 = (void *)objc_claimAutoreleasedReturnValue();
          v47 = a1;
          v48 = (void *)objc_msgSend(v46, "copy");

          objc_msgSend(v43, "data");
          v49 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v49, "dataNoCopy");
          v50 = (void *)objc_claimAutoreleasedReturnValue();
          v51 = (void *)objc_msgSend(v50, "copy");

          v52 = v48;
          *(_QWORD *)&v82 = v52;
          BYTE8(v82) = 5;
          v83[0] = objc_msgSend(v41, "arraySize");
          *(_OWORD *)&v83[1] = xmmword_226104390;
          v53 = v51;
          *(_QWORD *)v81 = v53;
          v81[8] = 6;
          *(_QWORD *)&v81[16] = objc_msgSend(v43, "arraySize");
          *(_OWORD *)&v81[24] = xmmword_226104390;
          re::GeomModelDescriptor::setAttribute(v47, (uint64_t)&v64, 4, (uint64_t)&v82, 0, (uint64_t)v67);
          if (!v67[0] && (_QWORD)v68)
          {
            if ((BYTE8(v68) & 1) != 0)
              (*(void (**)(void))(*(_QWORD *)v68 + 40))();
            v68 = 0u;
            v69 = 0u;
          }
          v54 = v64;
          if (v64 && (v65 & 1) != 0)
            v54 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v64 + 40))();
          re::GeomModelDescriptor::setAttribute(v47, (uint64_t)&v64, 4, (uint64_t)v81, 0, (uint64_t)v61);
          v4 = v60;
          if (!v61[0] && (_QWORD)v62)
          {
            if ((BYTE8(v62) & 1) != 0)
              (*(void (**)(void))(*(_QWORD *)v62 + 40))();
            v62 = 0u;
            v63 = 0u;
          }
          if (v64 && (v65 & 1) != 0)
            (*(void (**)(void))(*(_QWORD *)v64 + 40))();

        }
      }
    }
  }

}

void re::makeGeomModelDescriptorFromUSKNode(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, int a4@<W3>, int a5@<W4>, int a6@<W5>, uint64_t a7@<X6>, unint64_t a8@<X7>, uint64_t a9@<X8>)
{
  id v12;
  void *v13;
  void *v14;
  int v15;
  void *v16;
  void *v17;
  void *v18;
  _anonymous_namespace_ *v19;
  _anonymous_namespace_ *v20;
  const char *v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  uint64_t v29;
  void *v30;
  uint64_t v31;
  void *v32;
  _anonymous_namespace_ *v33;
  _anonymous_namespace_ *v34;
  void *v35;
  void *v36;
  id v37;
  _anonymous_namespace_ *v38;
  _anonymous_namespace_ *v39;
  __int128 v40;
  unint64_t v41;
  _anonymous_namespace_ *v42;
  __int128 v43;
  void *v44;
  void *v45;
  double v46;
  _anonymous_namespace_ *v47;
  unint64_t v48;
  __int128 v49;
  __int128 v50;
  _anonymous_namespace_ *v51;
  int v52;
  int v53;
  _BYTE *v54;
  id v55;
  id v56;
  void *v57;
  void *v58;
  _anonymous_namespace_ *v59;
  void *v60;
  id v61;
  _anonymous_namespace_ *v62;
  __n128 v63;
  void *v64;
  void *v65;
  uint64_t v66;
  _anonymous_namespace_ *v67;
  void *v68;
  id v69;
  _anonymous_namespace_ *v70;
  __n128 v71;
  id v72;
  unint64_t v73;
  _anonymous_namespace_ *v74;
  _anonymous_namespace_ *v75;
  void *v76;
  void *v77;
  void *v78;
  _BOOL4 v79;
  void *v80;
  _anonymous_namespace_ *v81;
  void *v82;
  void *v83;
  id v84;
  _anonymous_namespace_ *v85;
  _anonymous_namespace_ *v86;
  uint64_t v87;
  void *v88;
  id v89;
  id v90;
  uint64_t v91;
  uint64_t v92;
  unint64_t v93;
  id v94;
  uint64_t v95;
  int v96;
  unint64_t v97;
  id v98;
  unint64_t v99;
  unint64_t v100;
  unint64_t v101;
  _DWORD *v102;
  unint64_t v103;
  uint64_t v104;
  __int128 v105;
  void *v106;
  id v107;
  uint64_t v108;
  uint64_t v109;
  _anonymous_namespace_ *v110;
  uint64_t v111;
  id v112;
  unint64_t *v113;
  unint64_t v114;
  unint64_t v115;
  unint64_t v116;
  _DWORD *v117;
  unint64_t v118;
  const void *i;
  unint64_t j;
  uint64_t v121;
  const re::DynamicString *v122;
  _anonymous_namespace_ *v123;
  __n128 v124;
  re::DynamicString *v125;
  re *v126;
  uint64_t *v127;
  uint64_t v128;
  uint64_t v129;
  _QWORD *v130;
  uint64_t v131;
  uint64_t v132;
  _BYTE *v133;
  const void **v134;
  re::DynamicString *v135;
  uint64_t v136;
  uint64_t v137;
  void *v138;
  char v139;
  void *v140;
  void *v141;
  void *v142;
  void *v143;
  id v144;
  _anonymous_namespace_ *v145;
  uint64_t v146;
  void *v147;
  unint64_t v148;
  uint64_t v149;
  uint64_t v150;
  __n128 v151;
  void *v152;
  void *v153;
  void *v154;
  id v155;
  _anonymous_namespace_ *v156;
  uint64_t v157;
  void *v158;
  void *v159;
  id v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t k;
  void *v165;
  void *v166;
  void *v167;
  id v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  void *v172;
  uint64_t m;
  void *v174;
  void *v175;
  void *v176;
  double v177;
  _BYTE *v178;
  uint64_t v179;
  uint64_t v180;
  void *v181;
  void *v182;
  void *v183;
  int v184;
  int v185;
  uint64_t v186;
  void *v187;
  void *v188;
  void *v189;
  void *v190;
  void *v191;
  void *v192;
  void *v193;
  _anonymous_namespace_ *v194;
  void *v195;
  _anonymous_namespace_ *v196;
  void *v197;
  void *v198;
  void *v201;
  unint64_t obj;
  unsigned int v203;
  unint64_t v204;
  int isCatmullClarkSurface;
  char v207;
  _BOOL4 v208;
  uint64_t v209;
  re::DynamicString *v210;
  unint64_t v212;
  uint64_t v213;
  void *v214;
  unsigned int v215;
  char v216[24];
  __int128 v217;
  __int128 v218;
  __int128 v219;
  __int128 v220;
  __int128 v221;
  __int128 v222;
  char v223[24];
  __int128 v224;
  __int128 v225;
  __int128 v226;
  __int128 v227;
  __int128 v228;
  __int128 v229;
  char v230[24];
  __int128 v231;
  __int128 v232;
  __int128 v233;
  __int128 v234;
  __int128 v235;
  __int128 v236;
  _BYTE v237[24];
  _QWORD v238[4];
  _BYTE v239[24];
  _QWORD v240[4];
  char v241[9];
  __int128 v242;
  __int128 v243;
  char v244[24];
  __int128 v245;
  __int128 v246;
  _anonymous_namespace_ *v247;
  char v248;
  uint64_t v249;
  __int128 v250;
  id v251;
  char v252;
  uint64_t v253;
  __int128 v254;
  id v255;
  char v256;
  uint64_t v257;
  __int128 v258;
  uint64_t v259;
  char v260;
  _BYTE v261[84];
  uint64_t v262;
  _QWORD v263[2];
  _anonymous_namespace_ *v264;
  int v265;
  _BYTE v266[44];
  uint64_t v267;
  __int128 v268;
  __int128 v269;
  uint64_t v270;
  char v271;
  uint64_t v272;
  unint64_t v273;
  _DWORD *v274;
  uint64_t v275;
  uint64_t v276;
  uint64_t v277;
  __int128 v278;
  __int128 v279;
  __int128 v280;
  uint64_t v281;
  uint64_t v282;
  char v283;
  char v284;
  int v285;
  uint64_t v286;
  _OWORD v287[4];
  __int128 v288;
  uint64_t v289;
  uint64_t v290[6];
  __int128 v291;
  __int128 v292;
  _BYTE v293[128];
  _BYTE v294[128];
  _BYTE v295[128];
  _BYTE v296[38];
  uint64_t v297;
  uint64_t v298;
  _BYTE v299[18];
  __int16 v300;
  const void *v301;
  __int16 v302;
  _anonymous_namespace_ *v303;
  uint64_t v304;

  LODWORD(v210) = a4;
  v304 = *MEMORY[0x24BDAC8D0];
  v12 = a1;
  objc_msgSend(v12, "property:", CFSTR("orientation"));
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v13, "stringValue");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  v15 = objc_msgSend(v14, "isEqualToString:", CFSTR("leftHanded"));

  objc_msgSend(v12, "property:", CFSTR("faceVertexIndices"));
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v12, "property:", CFSTR("faceVertexCounts"));
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v12, "property:", CFSTR("points"));
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v12, "property:", CFSTR("doubleSided"));
  v19 = (_anonymous_namespace_ *)objc_claimAutoreleasedReturnValue();
  v20 = v19;
  if (!v16)
  {
    v21 = "Skiping mesh due to missing face vertex indices property.";
LABEL_9:
    v22 = *(_OWORD *)v261;
    v23 = *(_QWORD *)&v261[16];
    v24 = *(_QWORD *)&v261[24];
    *(_BYTE *)a9 = 0;
    *(_QWORD *)(a9 + 8) = 100;
    *(_QWORD *)(a9 + 16) = &re::AssetErrorCategory(void)::instance;
    *(_OWORD *)(a9 + 24) = v22;
    *(_QWORD *)(a9 + 40) = v23;
    *(_QWORD *)(a9 + 48) = v24;
    goto LABEL_37;
  }
  if (!v17)
  {
    v21 = "Skiping mesh due to missing face vertex counts property.";
    goto LABEL_9;
  }
  if (!v18)
  {
    v21 = "Skiping mesh due to missing points property";
    goto LABEL_9;
  }
  v192 = v13;
  v194 = v19;
  v186 = a9;
  v184 = a6;
  v185 = a5;
  if (v19)
    v207 = -[_anonymous_namespace_ BOOLValue](v19, "BOOLValue");
  else
    v207 = 0;
  objc_msgSend(v16, "data");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v17, "data");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v18, "data");
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  v203 = objc_msgSend(v27, "arraySize");
  v215 = objc_msgSend(v26, "arraySize");
  v197 = v25;
  objc_msgSend(v25, "dataNoCopy");
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  v29 = objc_msgSend(v28, "copy");

  v188 = v26;
  objc_msgSend(v26, "dataNoCopy");
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  v31 = objc_msgSend(v30, "copy");

  v187 = v27;
  objc_msgSend(v27, "dataNoCopy");
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  v33 = (_anonymous_namespace_ *)objc_msgSend(v32, "copy");

  v198 = (void *)v29;
  if (!v29)
  {
    v34 = (_anonymous_namespace_ *)objc_alloc_init(MEMORY[0x24BDBCE50]);
    v198 = v34;
  }
  v189 = v18;
  v190 = v17;
  v191 = v16;
  v35 = (void *)v31;
  if (!v31)
  {
    v34 = (_anonymous_namespace_ *)objc_alloc_init(MEMORY[0x24BDBCE50]);
    v35 = v34;
  }
  if (!v33)
  {
    v34 = (_anonymous_namespace_ *)objc_alloc_init(MEMORY[0x24BDBCE50]);
    v33 = v34;
  }
  v196 = v33;
  *(_WORD *)v261 = 0;
  v261[2] = 0;
  memset(&v261[4], 0, 80);
  v262 = 0x7FFFFFFFLL;
  v264 = 0;
  v263[0] = 0;
  v263[1] = 0;
  v265 = 0;
  memset(v266, 0, sizeof(v266));
  v267 = 0x7FFFFFFFLL;
  *((_QWORD *)&v268 + 1) = 0;
  v269 = 0uLL;
  re::DynamicString::setCapacity(&v268, 0);
  v195 = v12;
  objc_msgSend(v12, "name");
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v36, "stringValue");
  v37 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
  v38 = (_anonymous_namespace_ *)objc_msgSend(v37, "UTF8String");

  re::DynamicString::operator=((re::DynamicString *)&v268, (re::DynamicString *)&v259);
  v261[2] = v207;
  v39 = (_anonymous_namespace_ *)objc_msgSend(v35, "length");
  v193 = v35;
  if ((unint64_t)v39 >= 4 * (unint64_t)v215)
  {
    v41 = objc_msgSend(v198, "length");
    v42 = (_anonymous_namespace_ *)objc_msgSend(v197, "arraySize");
    if (v41 < 4 * (uint64_t)v42)
    {
      v40 = v287[0];
      goto LABEL_21;
    }
    v47 = v33;
    v48 = -[_anonymous_namespace_ length](v33, "length");
    v12 = v195;
    if (v48 < 12 * (unint64_t)v203)
    {
      v49 = v287[0];
      v50 = v287[1];
      *(_BYTE *)v186 = 0;
      *(_QWORD *)(v186 + 8) = 100;
      *(_QWORD *)(v186 + 16) = &re::AssetErrorCategory(void)::instance;
      *(_OWORD *)(v186 + 24) = v49;
      *(_OWORD *)(v186 + 40) = v50;
      goto LABEL_22;
    }
    v255 = v35;
    v256 = 5;
    obj = v215;
    v257 = v215;
    v258 = xmmword_226104390;
    v251 = v198;
    v252 = 5;
    v253 = objc_msgSend(v197, "arraySize");
    v254 = xmmword_226104390;
    v247 = v33;
    v248 = 11;
    v249 = v203;
    v250 = xmmword_226104380;
    if (v15)
      v261[1] = 1;
    re::GeomModelDescriptor::setSurfaceTopology((_anonymous_namespace_ *)v261, v203, (uint64_t)&v255, (uint64_t)&v251, (uint64_t)v244);
    v52 = v184;
    v53 = v185;
    if (!v244[0])
    {
      v51 = (_anonymous_namespace_ *)v245;
      if ((_QWORD)v245)
      {
        if ((BYTE8(v245) & 1) != 0)
          v51 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v245 + 40))();
        v245 = 0u;
        v246 = 0u;
      }
    }
    re::GeomModelDescriptor::setAttribute(v261, (uint64_t)v287, 1, (uint64_t)&v247, 0, (uint64_t)v241);
    if (!v241[0] && (_QWORD)v242)
    {
      if ((BYTE8(v242) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v242 + 40))();
      v242 = 0u;
      v243 = 0u;
    }
    if (*(_QWORD *)&v287[0] && (BYTE8(v287[0]) & 1) != 0)
      (*(void (**)(void))(**(_QWORD **)&v287[0] + 40))();
    if ((*(_BYTE *)(a2 + 8) & 1) != 0)
      v54 = *(_BYTE **)(a2 + 16);
    else
      v54 = (_BYTE *)(a2 + 9);
    if (*v54)
    {
      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:");
      v55 = (id)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v195, "property:", v55);
      v56 = (id)objc_claimAutoreleasedReturnValue();

    }
    else
    {
      re::primaryUVSetForMesh(v195);
      v55 = (id)objc_claimAutoreleasedReturnValue();
      v56 = v55;
    }

    objc_msgSend(v195, "property:", CFSTR("normals"));
    v57 = (void *)objc_claimAutoreleasedReturnValue();
    v183 = v56;
    if (v56)
    {
      v58 = v57;
      re::addPropertyToGeomModelDescriptorHelper((uint64_t)v287, v195, v56, CFSTR("constant"), v261, "vertexUV", 0);
      if (!LOBYTE(v287[0]))
        goto LABEL_77;
      objc_msgSend(v56, "name");
      v60 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v60, "stringValue");
      v61 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
      v62 = (_anonymous_namespace_ *)objc_msgSend(v61, "UTF8String");
      v47 = (_anonymous_namespace_ *)v239;
      v63 = re::GeomModelDescriptor::addAttributeAlias((re::GeomModelDescriptor *)v261, (const re::DynamicString *)&v278, (const re::DynamicString *)v296, (uint64_t)v239);
      if (!v239[0] && v240[0])
      {
        v47 = (_anonymous_namespace_ *)v240;
        if ((v240[1] & 1) != 0)
          (*(void (**)(__n128))(*(_QWORD *)v240[0] + 40))(v63);
        v63 = 0uLL;
        memset(v240, 0, sizeof(v240));
      }
      if (*(_QWORD *)v296)
      {
        if ((v296[8] & 1) != 0)
          (*(void (**)(__n128))(**(_QWORD **)v296 + 40))(v63);
        memset(v296, 0, 32);
      }

      if ((_QWORD)v278 && (BYTE8(v278) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v278 + 40))();
      if (!LOBYTE(v287[0]))
      {
LABEL_77:
        if (*((_QWORD *)&v287[1] + 1) && (v287[2] & 1) != 0)
          (*(void (**)(void))(**((_QWORD **)&v287[1] + 1) + 40))();
      }
      v57 = v58;
    }
    v64 = v57;
    objc_msgSend(v57, "data");
    v65 = (void *)objc_claimAutoreleasedReturnValue();

    if (!v65)
    {
      objc_msgSend(v195, "property:", CFSTR("primvars:normals"));
      v66 = objc_claimAutoreleasedReturnValue();

      v64 = (void *)v66;
    }
    v182 = v64;
    if (v64)
    {
      re::addPropertyToGeomModelDescriptorHelper((uint64_t)v287, v195, v64, CFSTR("vertex"), v261, "vertexNormal", 0);
      if (!LOBYTE(v287[0]))
        goto LABEL_98;
      objc_msgSend(v64, "name");
      v68 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v68, "stringValue");
      v69 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
      v70 = (_anonymous_namespace_ *)objc_msgSend(v69, "UTF8String");
      v47 = (_anonymous_namespace_ *)v237;
      v71 = re::GeomModelDescriptor::addAttributeAlias((re::GeomModelDescriptor *)v261, (const re::DynamicString *)&v278, (const re::DynamicString *)v296, (uint64_t)v237);
      if (!v237[0] && v238[0])
      {
        v47 = (_anonymous_namespace_ *)v238;
        if ((v238[1] & 1) != 0)
          (*(void (**)(__n128))(*(_QWORD *)v238[0] + 40))(v71);
        v71 = 0uLL;
        memset(v238, 0, sizeof(v238));
      }
      if (*(_QWORD *)v296)
      {
        if ((v296[8] & 1) != 0)
          (*(void (**)(__n128))(**(_QWORD **)v296 + 40))(v71);
        memset(v296, 0, 32);
      }

      if ((_QWORD)v278 && (BYTE8(v278) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v278 + 40))();
      if (!LOBYTE(v287[0]))
      {
LABEL_98:
        if (*((_QWORD *)&v287[1] + 1) && (v287[2] & 1) != 0)
          (*(void (**)(void))(**((_QWORD **)&v287[1] + 1) + 40))();
      }
    }
    v72 = v195;
    objc_msgSend(v72, "property:", CFSTR("primvars:displayColor"));
    v73 = objc_claimAutoreleasedReturnValue();
    objc_msgSend(v72, "property:", CFSTR("primvars:displayOpacity"));
    v74 = (_anonymous_namespace_ *)objc_claimAutoreleasedReturnValue();
    v75 = v74;
    v201 = v72;
    if (!v73)
    {
      v79 = 0;
      goto LABEL_112;
    }
    objc_msgSend((id)v73, "type");
    v76 = (void *)objc_claimAutoreleasedReturnValue();
    v77 = (void *)*MEMORY[0x24BEBED60];

    if (v76 != v77)
    {
      objc_msgSend((id)v73, "type");
      v78 = (void *)objc_claimAutoreleasedReturnValue();
      v72 = v201;
      if (v78 == (void *)*MEMORY[0x24BEBED58])
      {
        re::addPropertyToGeomModelDescriptorHelper((uint64_t)v287, v201, (void *)v73, CFSTR("constant"), v261, 0, 0);
        v79 = LOBYTE(v287[0]) != 0;
        if (!LOBYTE(v287[0]) && *((_QWORD *)&v287[1] + 1) && (v287[2] & 1) != 0)
          (*(void (**)(void))(**((_QWORD **)&v287[1] + 1) + 40))();
      }
      else
      {
        v79 = 0;
      }

LABEL_112:
      if (v75)
      {
        -[_anonymous_namespace_ type](v75, "type");
        v80 = (void *)objc_claimAutoreleasedReturnValue();
        if (v80 == (void *)*MEMORY[0x24BEBED70])
        {
          v81 = v75;
          re::addPropertyToGeomModelDescriptorHelper((uint64_t)v287, v72, v75, CFSTR("constant"), v261, 0, 0);
          LODWORD(v75) = LOBYTE(v287[0]) != 0;
          if (!LOBYTE(v287[0]) && *((_QWORD *)&v287[1] + 1) && (v287[2] & 1) != 0)
            (*(void (**)(void))(**((_QWORD **)&v287[1] + 1) + 40))();
        }
        else
        {
          v81 = v75;
          LODWORD(v75) = 0;
        }
        LODWORD(v82) = v184;

      }
      else
      {
        LODWORD(v82) = v184;
        v81 = 0;
      }
      v273 = 0;
      v272 = 0;
      v274 = 0;
      if (v79)
      {
        objc_msgSend((id)v73, "name");
        v83 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v83, "stringValue");
        v84 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
        v85 = (_anonymous_namespace_ *)objc_msgSend(v84, "UTF8String");

        v86 = (_anonymous_namespace_ *)re::GeomModelDescriptor::attributeByName((re::GeomModelDescriptor *)v261, (const re::DynamicString *)&v278);
        v47 = v86;
        v87 = *((_QWORD *)v86 + 5);
        v212 = v73;
        v208 = v79;
        if (v87)
        {
          v88 = (void *)(v87 + 8);
          v89 = (id)(v87 + 8);
          if (*(_BYTE *)(v87 + 32) && (*(unsigned __int8 *)(v87 + 33) | 2) == 0xB)
          {
            v90 = v88;
            v91 = *(_QWORD *)(v87 + 48);
            v92 = *(_QWORD *)(v87 + 24) + *(_QWORD *)(v87 + 56);
            v93 = *(_QWORD *)(v87 + 40);
            v94 = v88;

            v95 = 0;
            v204 = 0;
            v180 = 0;
          }
          else
          {
            re::internal::DataPayload::computeConvertedValues<re::PackedFloat3>(v87, (uint64_t)v287);
            if (LOBYTE(v287[0]))
            {
              v95 = *((_QWORD *)&v287[0] + 1);
              v93 = *(_QWORD *)&v287[1];
              memset((char *)v287 + 8, 0, 24);
              v92 = *((_QWORD *)&v287[1] + 1);
              v91 = 12;
            }
            else
            {
              v91 = 0;
              v93 = 0;
              v95 = 0;
              v92 = 0;
            }
            re::Result<re::FixedArray<unsigned int>,re::DetailedError>::~Result((uint64_t)v287);
            v87 = 0;
            v204 = v93;
            v180 = v92;
          }

        }
        else
        {
          v92 = 0;
          v180 = 0;
          v204 = 0;
          v95 = 0;
          v93 = 0;
          v91 = 0;
        }
        v97 = *((_QWORD *)v47 + 6);
        if (v97)
        {
          *(_QWORD *)v296 = *((_QWORD *)v47 + 6);
          v98 = (id)(v97 + 8);
          re::GeomModelDescriptor::makeConvertedValues<unsigned int>((_anonymous_namespace_ **)v296, v287);
          if (*(_QWORD *)v296)

          v97 = *(_QWORD *)&v287[1];
        }
        else
        {
          memset(v287, 0, 56);
        }
        if (*((_QWORD *)v47 + 6))
          v99 = v97;
        else
          v99 = v93;
        *(_QWORD *)v296 = 0x3F8000003F800000;
        *(_QWORD *)&v296[8] = 0x3F8000003F800000;
        v100 = v273;
        if (v273)
        {
          v101 = 0;
          v102 = v274;
          do
          {
            v103 = v101;
            if (*((_QWORD *)v47 + 6))
              v103 = *(unsigned int *)(*(_QWORD *)&v287[0] + *((_QWORD *)&v287[0] + 1) * v101);
            if (v103 < v93)
            {
              v104 = v92 + v103 * v91;
              *(_QWORD *)&v105 = *(_QWORD *)v104;
              DWORD2(v105) = *(_DWORD *)(v104 + 8);
              HIDWORD(v105) = 1.0;
              *(_OWORD *)&v102[4 * v101] = v105;
            }
            ++v101;
          }
          while (v100 != v101);
        }
        v96 = *((unsigned __int8 *)v47 + 32);
        v12 = v195;
        LODWORD(v82) = v184;
        v73 = v212;
        if (*(_QWORD *)&v287[2])
        {
          if (*((_QWORD *)&v287[2] + 1))
          {
            (*(void (**)(void))(**(_QWORD **)&v287[2] + 40))();
            *((_QWORD *)&v287[2] + 1) = 0;
            *(_QWORD *)&v287[3] = 0;
          }
          *(_QWORD *)&v287[2] = 0;
        }
        if (*((_QWORD *)&v287[1] + 1))

        if (v95 && v204)
          (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v95 + 40))(v95, v180);
        if (v87)

        v74 = (_anonymous_namespace_ *)v278;
        v79 = v208;
        if ((_QWORD)v278 && (BYTE8(v278) & 1) != 0)
          v74 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v278 + 40))();
        v72 = v201;
      }
      else
      {
        v96 = 1;
      }
      if ((_DWORD)v75)
      {
        v75 = v81;
        -[_anonymous_namespace_ name](v81, "name");
        v106 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v106, "stringValue");
        v107 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
        v47 = (_anonymous_namespace_ *)objc_msgSend(v107, "UTF8String");

        v108 = re::GeomModelDescriptor::attributeByName((re::GeomModelDescriptor *)v261, (const re::DynamicString *)v296);
        if (!v79)
          v96 = *(unsigned __int8 *)(v108 + 32);
        if (*(unsigned __int8 *)(v108 + 32) == v96)
        {
          v109 = v108;
          re::GeomModelDescriptor::AttributeData::makeConvertedValues<float>(v108, (uint64_t)v287);
          v111 = *(_QWORD *)(v109 + 48);
          if (v111)
          {
            *(_QWORD *)v299 = *(_QWORD *)(v109 + 48);
            v112 = (id)(v111 + 8);
            re::GeomModelDescriptor::makeConvertedValues<unsigned int>((_anonymous_namespace_ **)v299, &v278);
            if (*(_QWORD *)v299)

          }
          else
          {
            v281 = 0;
            v279 = 0u;
            v280 = 0u;
            v278 = 0u;
          }
          if (!v272)
          {
            if (*(_QWORD *)(v109 + 48))
              v113 = (unint64_t *)&v279;
            else
              v113 = (unint64_t *)&v287[1];
            v114 = *v113;
            *(_QWORD *)v299 = 0x3F8000003F800000;
            *(_QWORD *)&v299[8] = 0x3F8000003F800000;
          }
          v115 = v273;
          if (v273)
          {
            v116 = 0;
            v117 = v274 + 3;
            while (1)
            {
              v118 = v116;
              if (!*(_QWORD *)(v109 + 48))
                goto LABEL_185;
              if (v116 < (unint64_t)v279)
                break;
LABEL_187:
              ++v116;
              v117 += 4;
              if (v115 == v116)
                goto LABEL_188;
            }
            v118 = *(unsigned int *)(v278 + *((_QWORD *)&v278 + 1) * v116);
LABEL_185:
            if (v118 < *(_QWORD *)&v287[1])
              *v117 = *(_DWORD *)(*(_QWORD *)&v287[0] + *((_QWORD *)&v287[0] + 1) * v118);
            goto LABEL_187;
          }
LABEL_188:
          if ((_QWORD)v280)
          {
            if (*((_QWORD *)&v280 + 1))
            {
              (*(void (**)(void))(*(_QWORD *)v280 + 40))();
              *((_QWORD *)&v280 + 1) = 0;
              v281 = 0;
            }
            *(_QWORD *)&v280 = 0;
          }
          if (*((_QWORD *)&v279 + 1))

          if (*(_QWORD *)&v287[2])
          {
            if (*((_QWORD *)&v287[2] + 1))
            {
              (*(void (**)(void))(**(_QWORD **)&v287[2] + 40))();
              *((_QWORD *)&v287[2] + 1) = 0;
              *(_QWORD *)&v287[3] = 0;
            }
            *(_QWORD *)&v287[2] = 0;
          }
          if (*((_QWORD *)&v287[1] + 1))

        }
        v74 = *(_anonymous_namespace_ **)v296;
        v72 = v201;
        if (*(_QWORD *)v296 && (v296[8] & 1) != 0)
          v74 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(**(_QWORD **)v296 + 40))();
      }
      else
      {
        v75 = v81;
      }
      if (!v272)
        goto LABEL_246;
      i = v274;
      j = v273;
      v276 = 0;
      v275 = 0;
      v121 = re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)&v266[8], (uint64_t)&v270);
      if (v121)
        v122 = (const re::DynamicString *)v121;
      else
        v122 = (const re::DynamicString *)&v270;
      re::DynamicString::DynamicString((re::DynamicString *)&v282, v122);
      v124 = re::GeomModelDescriptor::validateIfCoreAttribute((uint64_t)&v282, v96, 10, (uint64_t)&v278);
      if (!(_BYTE)v278)
      {
        LOBYTE(v138) = 0;
        v133 = (_BYTE *)*((_QWORD *)&v279 + 1);
        LOBYTE(j) = v280;
        *((_QWORD *)&v279 + 1) = 0;
        i = (const void *)*((_QWORD *)&v280 + 1);
        v281 = 0;
        v280 = 0uLL;
        goto LABEL_230;
      }
      if (!j)
      {
        LOBYTE(v138) = 0;
        i = *(const void **)&v287[1];
        v133 = *(_BYTE **)&v287[0];
        LOBYTE(j) = BYTE8(v287[0]);
        goto LABEL_230;
      }
      v296[32] = 4;
      v297 = 0;
      v298 = 0;
      v126 = re::DynamicString::operator=(v125, (re::DynamicString *)&v282);
      v296[32] = v96;
      v127 = re::globalAllocators(v126);
      if (j >> 60 || 16 * j >= 0xFFFFFFFFFFFFFFF0)
      {
        re::internal::assertLog((re::internal *)6, v128, "assertion failure: '%s' (%s:line %i) Size overflow in allocateArray. Element size = %zu, count = %zu", "!overflow", "allocateArray", 61, 16, j);
        _os_crash();
        __break(1u);
      }
      else
      {
        v129 = (*(uint64_t (**)(uint64_t, unint64_t, _QWORD))(*(_QWORD *)v127[2] + 32))(v127[2], (16 * j + 16) | 0xF, 0);
        v130 = (_QWORD *)((v129 + 31) & 0xFFFFFFFFFFFFFFF0);
        *(v130 - 2) = j;
        *(v130 - 1) = v129;
        bzero(v130, 16 * j);
        *(_QWORD *)&v287[0] = v130;
        memcpy(v130, i, 16 * j);
        *(_QWORD *)v299 = j;
        v286 = 16;
        v285 = 0;
        v284 = 1;
        re::make::shared::object<re::internal::DataPayload,unsigned char *&,re::GeomModelValueType const&,unsigned long,unsigned long,int,BOOL,unsigned char *&,void (&)(void const*)>((re *)v287, re::ConvertToGeomModelValueType<re::Vector4<float>>::kValueType, (uint64_t *)v299, &v286, &v285, &v284, (uint64_t *)v287, (uint64_t)re::GeomModelDescriptor::freeReNewedArrayData<re::Vector4<float>>, &v277);
        v131 = v297;
        v297 = v277;
        v277 = v131;
        if (v131)

        if (v276)
        {
          re::GeomModelDescriptor::makeSlicePayload<unsigned int>((re *)&v275, (uint64_t *)v287);
          v132 = v298;
          v298 = *(_QWORD *)&v287[0];
          *(_QWORD *)&v287[0] = v132;
          if (v132)

        }
        v133 = &v261[48];
        v134 = (const void **)re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)&v261[48], (uint64_t)&v282);
        if (!v134)
        {
          *(_QWORD *)&v287[0] = v264;
          re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<unsigned long &>((uint64_t)&v261[48], (re::DynamicString *)&v282, v287);
          v124.n128_f64[0] = re::DynamicArray<re::GeomModelDescriptor::AttributeData>::add((_anonymous_namespace_ *)v263, (uint64_t)v296);
          v137 = v298;
          goto LABEL_222;
        }
        i = *v134;
        v47 = v264;
        if (v264 > *v134)
        {
          v135 = re::DynamicString::operator=((re::DynamicString *)(*(_QWORD *)v266 + 56 * (_QWORD)i), (re::DynamicString *)v296);
          *((_BYTE *)v135 + 32) = v296[32];
          v136 = *((_QWORD *)v135 + 5);
          *((_QWORD *)v135 + 5) = v297;
          v297 = v136;
          v137 = *((_QWORD *)v135 + 6);
          *((_QWORD *)v135 + 6) = v298;
          v298 = v137;
LABEL_222:
          if (v137)
          {

            v298 = 0;
          }
          if (v297)
          {

            v297 = 0;
          }
          if (*(_QWORD *)v296 && (v296[8] & 1) != 0)
            (*(void (**)(void))(**(_QWORD **)v296 + 40))();
          LOBYTE(v138) = 1;
LABEL_230:
          if (!(_BYTE)v278)
            goto LABEL_356;
          goto LABEL_231;
        }
      }
      v286 = 0;
      v288 = 0u;
      memset(v287, 0, sizeof(v287));
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v299 = 136315906;
      *(_QWORD *)&v299[4] = "operator[]";
      *(_WORD *)&v299[12] = 1024;
      *(_DWORD *)&v299[14] = 789;
      v300 = 2048;
      v301 = i;
      v302 = 2048;
      v303 = v47;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    v72 = v201;
    re::addPropertyToGeomModelDescriptorHelper((uint64_t)v287, v201, (void *)v73, CFSTR("constant"), v261, "vertexColor", 0);
    if (!LOBYTE(v287[0]) && *((_QWORD *)&v287[1] + 1))
    {
      if ((v287[2] & 1) != 0)
        (*(void (**)(void))(**((_QWORD **)&v287[1] + 1) + 40))();
      memset((char *)&v287[1] + 8, 0, 32);
    }
LABEL_247:

    if ((_DWORD)v210)
      isCatmullClarkSurface = re::isCatmullClarkSurface(v72);
    else
      isCatmullClarkSurface = 0;
    objc_msgSend(MEMORY[0x24BEBED10], "meshGroupsWithNode:", v72, v178, v179);
    v140 = (void *)objc_claimAutoreleasedReturnValue();
    v181 = v140;
    if (objc_msgSend(v140, "count"))
    {
      *(_QWORD *)&v280 = 0;
      *(_QWORD *)&v279 = 0;
      v278 = 0uLL;
      DWORD2(v279) = 0;
      LODWORD(v287[0]) = 0;
      re::DynamicArray<unsigned int>::resize(&v278, obj, v287);
      v233 = 0u;
      v234 = 0u;
      v235 = 0u;
      v236 = 0u;
      obj = v140;
      v213 = objc_msgSend((id)obj, "countByEnumeratingWithState:objects:count:", &v233, v295, 16);
      if (v213)
      {
        v209 = *(_QWORD *)v234;
        v210 = (re::DynamicString *)((char *)v287 + 8);
        while (2)
        {
          for (i = 0; i != (const void *)v213; i = (char *)i + 1)
          {
            if (*(_QWORD *)v234 != v209)
              objc_enumerationMutation((id)obj);
            v141 = *(void **)(*((_QWORD *)&v233 + 1) + 8 * (_QWORD)i);
            objc_msgSend(v141, "inheritedMaterialBinding");
            v142 = (void *)objc_claimAutoreleasedReturnValue();
            v82 = v142;
            if (!v142)
              goto LABEL_267;
            objc_msgSend(v142, "path");
            v143 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v143, "stringValue");
            v144 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
            v145 = (_anonymous_namespace_ *)objc_msgSend(v144, "UTF8String");
            LOBYTE(v287[0]) = isCatmullClarkSurface;
            re::DynamicString::DynamicString((re::DynamicString *)((char *)v287 + 8), (const re::DynamicString *)v296);
            v146 = re::HashTable<re::ImportMaterialSignature,re::MaterialInfoUSK,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::tryGet(a3, (char *)v287);
            if (*((_QWORD *)&v287[0] + 1))
            {
              if ((v287[1] & 1) != 0)
                (*(void (**)(void))(**((_QWORD **)&v287[0] + 1) + 40))();
              memset((char *)v287 + 8, 0, 32);
            }
            if (*(_QWORD *)v296)
            {
              if ((v296[8] & 1) != 0)
                (*(void (**)(void))(**(_QWORD **)v296 + 40))();
              memset(v296, 0, 32);
            }

            if (v146)
              v75 = (_anonymous_namespace_ *)*(unsigned int *)(v146 + 8);
            else
LABEL_267:
              v75 = 0;
            objc_msgSend(v141, "property:", CFSTR("indices"));
            v12 = (id)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v12, "data");
            v147 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v147, "dataNoCopy");
            v138 = (void *)objc_claimAutoreleasedReturnValue();
            v148 = objc_msgSend(v138, "length");
            if (v148 >= 4 * objc_msgSend(v147, "arraySize"))
            {
              v149 = objc_msgSend(objc_retainAutorelease(v138), "bytes");
              if (objc_msgSend(v147, "arraySize"))
              {
                for (j = 0; objc_msgSend(v147, "arraySize") > j; ++j)
                {
                  v73 = *(int *)(v149 + 4 * j);
                  if (v73 < v215)
                  {
                    v150 = v279;
                    if ((unint64_t)v279 <= v73)
                    {
                      *(_QWORD *)v299 = 0;
                      v288 = 0u;
                      memset(v287, 0, sizeof(v287));
                      v133 = (_BYTE *)MEMORY[0x24BDACB70];
                      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
                      *(_DWORD *)v296 = 136315906;
                      *(_QWORD *)&v296[4] = "operator[]";
                      *(_WORD *)&v296[12] = 1024;
                      *(_DWORD *)&v296[14] = 789;
                      *(_WORD *)&v296[18] = 2048;
                      *(_QWORD *)&v296[20] = v73;
                      *(_WORD *)&v296[28] = 2048;
                      *(_QWORD *)&v296[30] = v150;
                      LODWORD(v179) = 38;
                      v178 = v296;
                      _os_log_send_and_compose_impl();
                      _os_crash_msg();
                      __break(1u);
LABEL_356:
                      if (*((_QWORD *)&v279 + 1) && (v280 & 1) != 0)
                        (*(void (**)(__n128))(**((_QWORD **)&v279 + 1) + 40))(v124);
LABEL_231:
                      if (v282 && (v283 & 1) != 0)
                        (*(void (**)(__n128))(*(_QWORD *)v282 + 40))(v124);
                      if (v133)
                        v139 = (char)v138;
                      else
                        v139 = 1;
                      if ((v139 & 1) == 0 && (j & 1) != 0)
                        (*(void (**)(_BYTE *, const void *, __n128))(*(_QWORD *)v133 + 40))(v133, i, v124);
                      if (v270 && (v271 & 1) != 0)
                        (*(void (**)(__n128))(*(_QWORD *)v270 + 40))(v124);
                      v72 = v201;
                      if (v272 && v273)
                        (*(void (**)(__n128))(*(_QWORD *)v272 + 40))(v124);
LABEL_246:
                      v52 = (int)v82;
                      v53 = v185;
                      goto LABEL_247;
                    }
                    *(_DWORD *)(v280 + 4 * v73) = (_DWORD)v75;
                  }
                }
              }
            }

          }
          v213 = objc_msgSend((id)obj, "countByEnumeratingWithState:objects:count:", &v233, v295, 16);
          if (v213)
            continue;
          break;
        }
      }

      v151 = re::GeomModelDescriptor::setMaterialAssignmentsPerFace((_anonymous_namespace_ *)v261, v280, v279, (uint64_t)v230);
      v12 = v195;
      v52 = v184;
      v53 = v185;
      if (!v230[0] && (_QWORD)v231)
      {
        if ((BYTE8(v231) & 1) != 0)
          (*(void (**)(__n128))(*(_QWORD *)v231 + 40))(v151);
        v151 = 0uLL;
        v231 = 0u;
        v232 = 0u;
      }
      if ((_QWORD)v278 && (_QWORD)v280)
        (*(void (**)(__n128))(*(_QWORD *)v278 + 40))(v151);
    }
    else
    {
      objc_msgSend(v72, "inheritedMaterialBinding");
      v152 = (void *)objc_claimAutoreleasedReturnValue();
      v153 = v152;
      if (v152)
      {
        objc_msgSend(v152, "path");
        v154 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v154, "stringValue");
        v155 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
        v156 = (_anonymous_namespace_ *)objc_msgSend(v155, "UTF8String");
        LOBYTE(v287[0]) = isCatmullClarkSurface;
        re::DynamicString::DynamicString((re::DynamicString *)((char *)v287 + 8), (const re::DynamicString *)&v278);
        v157 = re::HashTable<re::ImportMaterialSignature,re::MaterialInfoUSK,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::tryGet(a3, (char *)v287);
        if (*((_QWORD *)&v287[0] + 1))
        {
          if ((v287[1] & 1) != 0)
            (*(void (**)(void))(**((_QWORD **)&v287[0] + 1) + 40))();
          memset((char *)v287 + 8, 0, 32);
        }
        if ((_QWORD)v278)
        {
          if ((BYTE8(v278) & 1) != 0)
            (*(void (**)(void))(*(_QWORD *)v278 + 40))();
          v278 = 0u;
          v279 = 0u;
        }

        if (v157)
          *(_DWORD *)&v261[4] = *(_DWORD *)(v157 + 8);
      }

    }
    if (a8)
      re::addSkeletonBindingsAsAttributesToModelDescriptor(v261, v201, a7, a8);
    if (isCatmullClarkSurface)
      re::attachOpenSubdivDataToModelDescriptor(v261, v201);
    if (v53)
      re::attachNewBlendShapeDataIfItExistsToModelDescriptor(v261, v201);
    objc_msgSend(v201, "properties", v151.n128_f64[0]);
    v158 = (void *)objc_claimAutoreleasedReturnValue();
    v159 = v158;
    if (v52)
    {
      v228 = 0u;
      v229 = 0u;
      v226 = 0u;
      v227 = 0u;
      v160 = v158;
      v161 = objc_msgSend(v160, "countByEnumeratingWithState:objects:count:", &v226, v294, 16);
      if (!v161)
      {
LABEL_344:

        re::GeomModelDescriptor::GeomModelDescriptor((uint64_t)v287, (uint64_t)v261);
        *(_BYTE *)v186 = 1;
        re::GeomModelDescriptor::GeomModelDescriptor(v186 + 8, (uint64_t)v287);
        v17 = v190;
        v16 = v191;
        v44 = v188;
        v18 = v189;
        v45 = v187;
        if ((_QWORD)v291)
        {
          if ((BYTE8(v291) & 1) != 0)
            (*(void (**)(void))(*(_QWORD *)v291 + 40))();
          v291 = 0u;
          v292 = 0u;
        }
        re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v290);
        re::DynamicArray<re::GeomModelDescriptor::AttributeData>::deinit((uint64_t)&v289);
        re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v287[3], v177);
        if (*((_QWORD *)&v287[2] + 1))
        {

          *((_QWORD *)&v287[2] + 1) = 0;
        }
        v13 = v192;
        if (*(_QWORD *)&v287[2])
        {

          *(_QWORD *)&v287[2] = 0;
        }
        if (*((_QWORD *)&v287[0] + 1))

        goto LABEL_23;
      }
      v162 = v161;
      v214 = v159;
      v163 = *(_QWORD *)v227;
      do
      {
        for (k = 0; k != v162; ++k)
        {
          if (*(_QWORD *)v227 != v163)
            objc_enumerationMutation(v160);
          v165 = *(void **)(*((_QWORD *)&v226 + 1) + 8 * k);
          if ((objc_msgSend(v165, "isEqualToString:", CFSTR("orientation")) & 1) == 0
            && (objc_msgSend(v165, "isEqualToString:", CFSTR("faceVertexIndices")) & 1) == 0
            && (objc_msgSend(v165, "isEqualToString:", CFSTR("faceVertexCounts")) & 1) == 0
            && (objc_msgSend(v165, "isEqualToString:", CFSTR("normals")) & 1) == 0
            && (objc_msgSend(v165, "isEqualToString:", CFSTR("primvars:normals")) & 1) == 0
            && (objc_msgSend(v165, "isEqualToString:", CFSTR("primvars:displayColor")) & 1) == 0
            && (objc_msgSend(v165, "isEqualToString:", CFSTR("primvars:skel:jointWeights")) & 1) == 0
            && (objc_msgSend(v165, "isEqualToString:", CFSTR("primvars:skel:jointIndices")) & 1) == 0
            && (objc_msgSend(v165, "isEqualToString:", CFSTR("primvars:skel:geomBindTransform")) & 1) == 0
            && (objc_msgSend(v165, "isEqualToString:", CFSTR("skel:joints")) & 1) == 0)
          {
            objc_msgSend(v160, "objectForKey:", v165);
            v166 = (void *)objc_claimAutoreleasedReturnValue();
            re::addPropertyToGeomModelDescriptorHelper((uint64_t)v223, v201, v166, CFSTR("constant"), v261, 0, 0);
            if (!v223[0] && (_QWORD)v224)
            {
              if ((BYTE8(v224) & 1) != 0)
                (*(void (**)(void))(*(_QWORD *)v224 + 40))();
              v224 = 0u;
              v225 = 0u;
            }

          }
        }
        v162 = objc_msgSend(v160, "countByEnumeratingWithState:objects:count:", &v226, v294, 16);
      }
      while (v162);
    }
    else
    {
      objc_msgSend(v183, "name");
      v167 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v167, "stringValue");
      v160 = (id)objc_claimAutoreleasedReturnValue();

      v221 = 0u;
      v222 = 0u;
      v219 = 0u;
      v220 = 0u;
      v214 = v159;
      v168 = v159;
      v169 = objc_msgSend(v168, "countByEnumeratingWithState:objects:count:", &v219, v293, 16);
      if (v169)
      {
        v170 = v169;
        v171 = *(_QWORD *)v220;
        v172 = (void *)*MEMORY[0x24BEBEE58];
        do
        {
          for (m = 0; m != v170; ++m)
          {
            if (*(_QWORD *)v220 != v171)
              objc_enumerationMutation(v168);
            v174 = *(void **)(*((_QWORD *)&v219 + 1) + 8 * m);
            objc_msgSend(v168, "objectForKey:", v174);
            v175 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v175, "role");
            v176 = (void *)objc_claimAutoreleasedReturnValue();

            if (v176 == v172 && (objc_msgSend(v174, "isEqualToString:", v160) & 1) == 0)
            {
              re::addPropertyToGeomModelDescriptorHelper((uint64_t)v216, v201, v175, CFSTR("constant"), v261, 0, 0);
              if (!v216[0])
              {
                if ((_QWORD)v217)
                {
                  if ((BYTE8(v217) & 1) != 0)
                    (*(void (**)(void))(*(_QWORD *)v217 + 40))();
                  v217 = 0u;
                  v218 = 0u;
                }
              }
            }

          }
          v170 = objc_msgSend(v168, "countByEnumeratingWithState:objects:count:", &v219, v293, 16);
        }
        while (v170);
      }

    }
    v12 = v195;
    v159 = v214;
    goto LABEL_344;
  }
  v40 = v287[0];
LABEL_21:
  v43 = v287[1];
  *(_BYTE *)v186 = 0;
  *(_QWORD *)(v186 + 8) = 100;
  *(_QWORD *)(v186 + 16) = &re::AssetErrorCategory(void)::instance;
  *(_OWORD *)(v186 + 24) = v40;
  *(_OWORD *)(v186 + 40) = v43;
  v12 = v195;
LABEL_22:
  v16 = v191;
  v13 = v192;
  v17 = v190;
  v45 = v187;
  v44 = v188;
LABEL_23:
  if (v259 && (v260 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v259 + 40))();
  if ((_QWORD)v268)
  {
    if ((BYTE8(v268) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v268 + 40))();
    v268 = 0u;
    v269 = 0u;
  }
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v266[8]);
  re::DynamicArray<re::GeomModelDescriptor::AttributeData>::deinit((uint64_t)v263);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v261[48], v46);
  if (*(_QWORD *)&v261[40])
  {

    *(_QWORD *)&v261[40] = 0;
  }
  v20 = v194;
  if (*(_QWORD *)&v261[32])
  {

    *(_QWORD *)&v261[32] = 0;
  }
  if (*(_QWORD *)&v261[8])

LABEL_37:
}

uint64_t re::HashTable<re::ImportMaterialSignature,re::MaterialInfoUSK,re::Hash<re::ImportMaterialSignature>,re::EqualTo<re::ImportMaterialSignature>,true,false>::tryGet(uint64_t a1, char *a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  uint64_t v9;
  char v11;

  v4 = re::Hash<re::ImportMaterialSignature>::operator()((uint64_t)&v11, a2);
  if (!*(_QWORD *)a1)
    return 0;
  v5 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * (v4 % *(unsigned int *)(a1 + 24)));
  if ((_DWORD)v5 == 0x7FFFFFFF)
    return 0;
  v8 = *a2;
  v6 = (uint64_t)(a2 + 8);
  v7 = v8;
  v9 = *(_QWORD *)(a1 + 16);
  while (*(unsigned __int8 *)(v9 + 72 * v5 + 16) != v7 || !re::DynamicString::operator==(v9 + 72 * v5 + 24, v6))
  {
    v5 = *(_DWORD *)(v9 + 72 * v5 + 8) & 0x7FFFFFFF;
    if (v5 == 0x7FFFFFFF)
      return 0;
  }
  return v9 + 72 * v5 + 56;
}

uint64_t re::GeomModelDescriptor::setAttribute<float,unsigned int>@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, re *a4@<X3>, re *a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v12;
  const re::DynamicString *v13;
  _anonymous_namespace_ *v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t v19;
  re::DynamicString *v20;
  uint64_t v21;
  uint64_t v22;
  __int128 v23;
  __int128 v24;
  uint64_t result;
  uint64_t v26;
  char v27;
  char v28;
  uint64_t v29;
  uint64_t v30;
  _BYTE v31[8];
  __int128 v32;
  uint64_t v33;
  __int128 v34;
  uint64_t v35;
  uint64_t v36;
  char v37;
  uint64_t v38;
  int v39;
  const char *v40;
  __int16 v41;
  int v42;
  __int16 v43;
  unint64_t v44;
  __int16 v45;
  unint64_t v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  uint64_t v52;

  v52 = *MEMORY[0x24BDAC8D0];
  v12 = re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)(a1 + 17), a2);
  if (v12)
    v13 = (const re::DynamicString *)v12;
  else
    v13 = (const re::DynamicString *)a2;
  re::DynamicString::DynamicString((re::DynamicString *)&v36, v13);
  re::GeomModelDescriptor::validateIfCoreAttribute((uint64_t)&v36, a3, 6, (uint64_t)v31);
  if (v31[0])
  {
    if (*((_QWORD *)a4 + 1))
    {
      v28 = 4;
      v29 = 0;
      v30 = 0;
      re::DynamicString::operator=((re::DynamicString *)&v26, (re::DynamicString *)&v36);
      v28 = a3;
      re::GeomModelDescriptor::makeSlicePayload<float>(a4, (uint64_t *)&v47);
      v15 = v29;
      v29 = v47;
      *(_QWORD *)&v47 = v15;
      if (v15)

      if (*((_QWORD *)a5 + 1))
      {
        *(_BYTE *)a6 = 1;
        re::GeomModelDescriptor::makeSlicePayload<unsigned int>(a5, (uint64_t *)&v47);
        v16 = v30;
        v30 = v47;
        *(_QWORD *)&v47 = v16;
        if (v16)

      }
      v17 = (unint64_t *)re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)(a1 + 6), (uint64_t)&v36);
      if (v17)
      {
        v18 = *v17;
        v19 = a1[14];
        if (v19 <= *v17)
        {
          v38 = 0;
          v50 = 0u;
          v51 = 0u;
          v48 = 0u;
          v49 = 0u;
          v47 = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          v39 = 136315906;
          v40 = "operator[]";
          v41 = 1024;
          v42 = 789;
          v43 = 2048;
          v44 = v18;
          v45 = 2048;
          v46 = v19;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        v20 = re::DynamicString::operator=((re::DynamicString *)(a1[16] + 56 * v18), (re::DynamicString *)&v26);
        *((_BYTE *)v20 + 32) = v28;
        v21 = *((_QWORD *)v20 + 5);
        *((_QWORD *)v20 + 5) = v29;
        v29 = v21;
        v22 = *((_QWORD *)v20 + 6);
        *((_QWORD *)v20 + 6) = v30;
        v30 = v22;
      }
      else
      {
        *(_QWORD *)&v47 = a1[14];
        re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<unsigned long &>((uint64_t)(a1 + 6), (re::DynamicString *)&v36, &v47);
        re::DynamicArray<re::GeomModelDescriptor::AttributeData>::add((_anonymous_namespace_ *)(a1 + 12), (uint64_t)&v26);
        v22 = v30;
      }
      *(_BYTE *)a6 = 1;
      if (v22)
      {

        v30 = 0;
      }
      if (v29)
      {

        v29 = 0;
      }
      if (v26 && (v27 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v26 + 40))();
    }
    else
    {
      v23 = v47;
      v24 = v48;
      *(_BYTE *)a6 = 0;
      *(_QWORD *)(a6 + 8) = 100;
      *(_QWORD *)(a6 + 16) = &re::AssetErrorCategory(void)::instance;
      *(_OWORD *)(a6 + 24) = v23;
      *(_OWORD *)(a6 + 40) = v24;
    }
  }
  else
  {
    *(_BYTE *)a6 = 0;
    *(_OWORD *)(a6 + 8) = v32;
    *(_QWORD *)(a6 + 24) = v33;
    *(_QWORD *)(a6 + 48) = v35;
    *(_OWORD *)(a6 + 32) = v34;
    v35 = 0;
    v33 = 0;
    v34 = 0uLL;
  }
  if (!v31[0] && v33 && (v34 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v33 + 40))();
  result = v36;
  if (v36)
  {
    if ((v37 & 1) != 0)
      return (*(uint64_t (**)(void))(*(_QWORD *)v36 + 40))();
  }
  return result;
}

uint64_t re::GeomModelDescriptor::makeSlicePayload<float>@<X0>(re *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t *v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  size_t v9;
  uint64_t v10;
  uint64_t result;
  char v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;

  v4 = re::globalAllocators(a1);
  v6 = *((_QWORD *)a1 + 1);
  if (!v6)
  {
    v9 = 0;
    v8 = 0;
    goto LABEL_6;
  }
  if (!(v6 >> 62) && 4 * v6 < 0xFFFFFFFFFFFFFFF0)
  {
    v7 = (*(uint64_t (**)(uint64_t, unint64_t, _QWORD))(*(_QWORD *)v4[2] + 32))(v4[2], (4 * v6 + 16) | 3, 0);
    v8 = (_QWORD *)((v7 + 19) & 0xFFFFFFFFFFFFFFFCLL);
    *(v8 - 2) = v6;
    *(v8 - 1) = v7;
    bzero(v8, 4 * v6);
    v9 = 4 * *((_QWORD *)a1 + 1);
LABEL_6:
    v16 = v8;
    memcpy(v8, *(const void **)a1, v9);
    v10 = *((_QWORD *)a1 + 1);
    v14 = 4;
    v15 = v10;
    v13 = 0;
    v12 = 1;
    return re::make::shared::object<re::internal::DataPayload,unsigned char *&,re::GeomModelValueType const&,unsigned long,unsigned long,int,BOOL,unsigned char *&,void (&)(void const*)>((re *)&v16, (char *)&re::ConvertToGeomModelValueType<float>::kValueType, &v15, &v14, &v13, &v12, (uint64_t *)&v16, (uint64_t)re::GeomModelDescriptor::freeReNewedArrayData<float>, a2);
  }
  re::internal::assertLog((re::internal *)6, v5, "assertion failure: '%s' (%s:line %i) Size overflow in allocateArray. Element size = %zu, count = %zu", "!overflow", "allocateArray", 61, 4, v6);
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t *re::GeomModelDescriptor::freeReNewedArrayData<float>(re *a1)
{
  uint64_t *result;

  result = re::globalAllocators(a1);
  if (a1)
    return (uint64_t *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)result[2] + 40))(result[2], *((_QWORD *)a1 - 1));
  return result;
}

uint64_t re::GeomModelDescriptor::setAttribute<int,unsigned int>@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, re *a4@<X3>, re *a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v12;
  const re::DynamicString *v13;
  _anonymous_namespace_ *v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t v19;
  re::DynamicString *v20;
  uint64_t v21;
  uint64_t v22;
  __int128 v23;
  __int128 v24;
  uint64_t result;
  uint64_t v26;
  char v27;
  char v28;
  uint64_t v29;
  uint64_t v30;
  _BYTE v31[8];
  __int128 v32;
  uint64_t v33;
  __int128 v34;
  uint64_t v35;
  uint64_t v36;
  char v37;
  uint64_t v38;
  int v39;
  const char *v40;
  __int16 v41;
  int v42;
  __int16 v43;
  unint64_t v44;
  __int16 v45;
  unint64_t v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  uint64_t v52;

  v52 = *MEMORY[0x24BDAC8D0];
  v12 = re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)(a1 + 17), a2);
  if (v12)
    v13 = (const re::DynamicString *)v12;
  else
    v13 = (const re::DynamicString *)a2;
  re::DynamicString::DynamicString((re::DynamicString *)&v36, v13);
  re::GeomModelDescriptor::validateIfCoreAttribute((uint64_t)&v36, a3, 4, (uint64_t)v31);
  if (v31[0])
  {
    if (*((_QWORD *)a4 + 1))
    {
      v28 = 4;
      v29 = 0;
      v30 = 0;
      re::DynamicString::operator=((re::DynamicString *)&v26, (re::DynamicString *)&v36);
      v28 = a3;
      re::GeomModelDescriptor::makeSlicePayload<int>(a4, (uint64_t *)&v47);
      v15 = v29;
      v29 = v47;
      *(_QWORD *)&v47 = v15;
      if (v15)

      if (*((_QWORD *)a5 + 1))
      {
        *(_BYTE *)a6 = 1;
        re::GeomModelDescriptor::makeSlicePayload<unsigned int>(a5, (uint64_t *)&v47);
        v16 = v30;
        v30 = v47;
        *(_QWORD *)&v47 = v16;
        if (v16)

      }
      v17 = (unint64_t *)re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)(a1 + 6), (uint64_t)&v36);
      if (v17)
      {
        v18 = *v17;
        v19 = a1[14];
        if (v19 <= *v17)
        {
          v38 = 0;
          v50 = 0u;
          v51 = 0u;
          v48 = 0u;
          v49 = 0u;
          v47 = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          v39 = 136315906;
          v40 = "operator[]";
          v41 = 1024;
          v42 = 789;
          v43 = 2048;
          v44 = v18;
          v45 = 2048;
          v46 = v19;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        v20 = re::DynamicString::operator=((re::DynamicString *)(a1[16] + 56 * v18), (re::DynamicString *)&v26);
        *((_BYTE *)v20 + 32) = v28;
        v21 = *((_QWORD *)v20 + 5);
        *((_QWORD *)v20 + 5) = v29;
        v29 = v21;
        v22 = *((_QWORD *)v20 + 6);
        *((_QWORD *)v20 + 6) = v30;
        v30 = v22;
      }
      else
      {
        *(_QWORD *)&v47 = a1[14];
        re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<unsigned long &>((uint64_t)(a1 + 6), (re::DynamicString *)&v36, &v47);
        re::DynamicArray<re::GeomModelDescriptor::AttributeData>::add((_anonymous_namespace_ *)(a1 + 12), (uint64_t)&v26);
        v22 = v30;
      }
      *(_BYTE *)a6 = 1;
      if (v22)
      {

        v30 = 0;
      }
      if (v29)
      {

        v29 = 0;
      }
      if (v26 && (v27 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v26 + 40))();
    }
    else
    {
      v23 = v47;
      v24 = v48;
      *(_BYTE *)a6 = 0;
      *(_QWORD *)(a6 + 8) = 100;
      *(_QWORD *)(a6 + 16) = &re::AssetErrorCategory(void)::instance;
      *(_OWORD *)(a6 + 24) = v23;
      *(_OWORD *)(a6 + 40) = v24;
    }
  }
  else
  {
    *(_BYTE *)a6 = 0;
    *(_OWORD *)(a6 + 8) = v32;
    *(_QWORD *)(a6 + 24) = v33;
    *(_QWORD *)(a6 + 48) = v35;
    *(_OWORD *)(a6 + 32) = v34;
    v35 = 0;
    v33 = 0;
    v34 = 0uLL;
  }
  if (!v31[0] && v33 && (v34 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v33 + 40))();
  result = v36;
  if (v36)
  {
    if ((v37 & 1) != 0)
      return (*(uint64_t (**)(void))(*(_QWORD *)v36 + 40))();
  }
  return result;
}

uint64_t re::GeomModelDescriptor::makeSlicePayload<int>@<X0>(re *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t *v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  size_t v9;
  uint64_t v10;
  uint64_t result;
  char v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;

  v4 = re::globalAllocators(a1);
  v6 = *((_QWORD *)a1 + 1);
  if (!v6)
  {
    v9 = 0;
    v8 = 0;
    goto LABEL_6;
  }
  if (!(v6 >> 62) && 4 * v6 < 0xFFFFFFFFFFFFFFF0)
  {
    v7 = (*(uint64_t (**)(uint64_t, unint64_t, _QWORD))(*(_QWORD *)v4[2] + 32))(v4[2], (4 * v6 + 16) | 3, 0);
    v8 = (_QWORD *)((v7 + 19) & 0xFFFFFFFFFFFFFFFCLL);
    *(v8 - 2) = v6;
    *(v8 - 1) = v7;
    bzero(v8, 4 * v6);
    v9 = 4 * *((_QWORD *)a1 + 1);
LABEL_6:
    v16 = v8;
    memcpy(v8, *(const void **)a1, v9);
    v10 = *((_QWORD *)a1 + 1);
    v14 = 4;
    v15 = v10;
    v13 = 0;
    v12 = 1;
    return re::make::shared::object<re::internal::DataPayload,unsigned char *&,re::GeomModelValueType const&,unsigned long,unsigned long,int,BOOL,unsigned char *&,void (&)(void const*)>((re *)&v16, (char *)&re::ConvertToGeomModelValueType<int>::kValueType, &v15, &v14, &v13, &v12, (uint64_t *)&v16, (uint64_t)re::GeomModelDescriptor::freeReNewedArrayData<int>, a2);
  }
  re::internal::assertLog((re::internal *)6, v5, "assertion failure: '%s' (%s:line %i) Size overflow in allocateArray. Element size = %zu, count = %zu", "!overflow", "allocateArray", 61, 4, v6);
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t *re::GeomModelDescriptor::freeReNewedArrayData<int>(re *a1)
{
  uint64_t *result;

  result = re::globalAllocators(a1);
  if (a1)
    return (uint64_t *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)result[2] + 40))(result[2], *((_QWORD *)a1 - 1));
  return result;
}

uint64_t _ZN2re19GeomModelDescriptor12setAttributeIDv4_fjEENS_6ResultINS_4UnitENS_13DetailedErrorEEERKNS_13DynamicStringENS_17GeomAttributeRateERKNS_5SliceIT_EERKNSB_IT0_EE@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, re *a4@<X3>, re *a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v12;
  const re::DynamicString *v13;
  _anonymous_namespace_ *v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t v19;
  re::DynamicString *v20;
  uint64_t v21;
  uint64_t v22;
  __int128 v23;
  __int128 v24;
  uint64_t result;
  uint64_t v26;
  char v27;
  char v28;
  uint64_t v29;
  uint64_t v30;
  _BYTE v31[8];
  __int128 v32;
  uint64_t v33;
  __int128 v34;
  uint64_t v35;
  uint64_t v36;
  char v37;
  uint64_t v38;
  int v39;
  const char *v40;
  __int16 v41;
  int v42;
  __int16 v43;
  unint64_t v44;
  __int16 v45;
  unint64_t v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  uint64_t v52;

  v52 = *MEMORY[0x24BDAC8D0];
  v12 = re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)(a1 + 17), a2);
  if (v12)
    v13 = (const re::DynamicString *)v12;
  else
    v13 = (const re::DynamicString *)a2;
  re::DynamicString::DynamicString((re::DynamicString *)&v36, v13);
  re::GeomModelDescriptor::validateIfCoreAttribute((uint64_t)&v36, a3, 10, (uint64_t)v31);
  if (v31[0])
  {
    if (*((_QWORD *)a4 + 1))
    {
      v28 = 4;
      v29 = 0;
      v30 = 0;
      re::DynamicString::operator=((re::DynamicString *)&v26, (re::DynamicString *)&v36);
      v28 = a3;
      _ZN2re19GeomModelDescriptor16makeSlicePayloadIDv4_fEENS_9SharedPtrINS_8internal11DataPayloadEEERKNS_5SliceIT_EE(a4, (uint64_t *)&v47);
      v15 = v29;
      v29 = v47;
      *(_QWORD *)&v47 = v15;
      if (v15)

      if (*((_QWORD *)a5 + 1))
      {
        *(_BYTE *)a6 = 1;
        re::GeomModelDescriptor::makeSlicePayload<unsigned int>(a5, (uint64_t *)&v47);
        v16 = v30;
        v30 = v47;
        *(_QWORD *)&v47 = v16;
        if (v16)

      }
      v17 = (unint64_t *)re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)(a1 + 6), (uint64_t)&v36);
      if (v17)
      {
        v18 = *v17;
        v19 = a1[14];
        if (v19 <= *v17)
        {
          v38 = 0;
          v50 = 0u;
          v51 = 0u;
          v48 = 0u;
          v49 = 0u;
          v47 = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          v39 = 136315906;
          v40 = "operator[]";
          v41 = 1024;
          v42 = 789;
          v43 = 2048;
          v44 = v18;
          v45 = 2048;
          v46 = v19;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        v20 = re::DynamicString::operator=((re::DynamicString *)(a1[16] + 56 * v18), (re::DynamicString *)&v26);
        *((_BYTE *)v20 + 32) = v28;
        v21 = *((_QWORD *)v20 + 5);
        *((_QWORD *)v20 + 5) = v29;
        v29 = v21;
        v22 = *((_QWORD *)v20 + 6);
        *((_QWORD *)v20 + 6) = v30;
        v30 = v22;
      }
      else
      {
        *(_QWORD *)&v47 = a1[14];
        re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<unsigned long &>((uint64_t)(a1 + 6), (re::DynamicString *)&v36, &v47);
        re::DynamicArray<re::GeomModelDescriptor::AttributeData>::add((_anonymous_namespace_ *)(a1 + 12), (uint64_t)&v26);
        v22 = v30;
      }
      *(_BYTE *)a6 = 1;
      if (v22)
      {

        v30 = 0;
      }
      if (v29)
      {

        v29 = 0;
      }
      if (v26 && (v27 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v26 + 40))();
    }
    else
    {
      v23 = v47;
      v24 = v48;
      *(_BYTE *)a6 = 0;
      *(_QWORD *)(a6 + 8) = 100;
      *(_QWORD *)(a6 + 16) = &re::AssetErrorCategory(void)::instance;
      *(_OWORD *)(a6 + 24) = v23;
      *(_OWORD *)(a6 + 40) = v24;
    }
  }
  else
  {
    *(_BYTE *)a6 = 0;
    *(_OWORD *)(a6 + 8) = v32;
    *(_QWORD *)(a6 + 24) = v33;
    *(_QWORD *)(a6 + 48) = v35;
    *(_OWORD *)(a6 + 32) = v34;
    v35 = 0;
    v33 = 0;
    v34 = 0uLL;
  }
  if (!v31[0] && v33 && (v34 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v33 + 40))();
  result = v36;
  if (v36)
  {
    if ((v37 & 1) != 0)
      return (*(uint64_t (**)(void))(*(_QWORD *)v36 + 40))();
  }
  return result;
}

uint64_t _ZN2re19GeomModelDescriptor16makeSlicePayloadIDv4_fEENS_9SharedPtrINS_8internal11DataPayloadEEERKNS_5SliceIT_EE@<X0>(re *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t *v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  size_t v9;
  uint64_t v10;
  uint64_t result;
  char v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;

  v4 = re::globalAllocators(a1);
  v6 = *((_QWORD *)a1 + 1);
  if (!v6)
  {
    v9 = 0;
    v8 = 0;
    goto LABEL_6;
  }
  if (!(v6 >> 60) && 16 * v6 < 0xFFFFFFFFFFFFFFF0)
  {
    v7 = (*(uint64_t (**)(uint64_t, unint64_t, _QWORD))(*(_QWORD *)v4[2] + 32))(v4[2], (16 * v6 + 16) | 0xF, 0);
    v8 = (_QWORD *)((v7 + 31) & 0xFFFFFFFFFFFFFFF0);
    *(v8 - 2) = v6;
    *(v8 - 1) = v7;
    bzero(v8, 16 * v6);
    v9 = 16 * *((_QWORD *)a1 + 1);
LABEL_6:
    v16 = v8;
    memcpy(v8, *(const void **)a1, v9);
    v10 = *((_QWORD *)a1 + 1);
    v14 = 16;
    v15 = v10;
    v13 = 0;
    v12 = 1;
    return re::make::shared::object<re::internal::DataPayload,unsigned char *&,re::GeomModelValueType const&,unsigned long,unsigned long,int,BOOL,unsigned char *&,void (&)(void const*)>((re *)&v16, _ZN2re27ConvertToGeomModelValueTypeIDv4_fE10kValueTypeE, &v15, &v14, &v13, &v12, (uint64_t *)&v16, (uint64_t)_ZN2re19GeomModelDescriptor20freeReNewedArrayDataIDv4_fEEvPKv, a2);
  }
  re::internal::assertLog((re::internal *)6, v5, "assertion failure: '%s' (%s:line %i) Size overflow in allocateArray. Element size = %zu, count = %zu", "!overflow", "allocateArray", 61, 16, v6);
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t *_ZN2re19GeomModelDescriptor20freeReNewedArrayDataIDv4_fEEvPKv(re *a1)
{
  uint64_t *result;

  result = re::globalAllocators(a1);
  if (a1)
    return (uint64_t *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)result[2] + 40))(result[2], *((_QWORD *)a1 - 1));
  return result;
}

uint64_t re::GeomModelDescriptor::setAttribute<unsigned short,unsigned int>@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, re *a4@<X3>, re *a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v12;
  const re::DynamicString *v13;
  _anonymous_namespace_ *v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t v19;
  re::DynamicString *v20;
  uint64_t v21;
  uint64_t v22;
  __int128 v23;
  __int128 v24;
  uint64_t result;
  uint64_t v26;
  char v27;
  char v28;
  uint64_t v29;
  uint64_t v30;
  _BYTE v31[8];
  __int128 v32;
  uint64_t v33;
  __int128 v34;
  uint64_t v35;
  uint64_t v36;
  char v37;
  uint64_t v38;
  int v39;
  const char *v40;
  __int16 v41;
  int v42;
  __int16 v43;
  unint64_t v44;
  __int16 v45;
  unint64_t v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  uint64_t v52;

  v52 = *MEMORY[0x24BDAC8D0];
  v12 = re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)(a1 + 17), a2);
  if (v12)
    v13 = (const re::DynamicString *)v12;
  else
    v13 = (const re::DynamicString *)a2;
  re::DynamicString::DynamicString((re::DynamicString *)&v36, v13);
  re::GeomModelDescriptor::validateIfCoreAttribute((uint64_t)&v36, a3, 3, (uint64_t)v31);
  if (v31[0])
  {
    if (*((_QWORD *)a4 + 1))
    {
      v28 = 4;
      v29 = 0;
      v30 = 0;
      re::DynamicString::operator=((re::DynamicString *)&v26, (re::DynamicString *)&v36);
      v28 = a3;
      re::GeomModelDescriptor::makeSlicePayload<unsigned short>(a4, (uint64_t *)&v47);
      v15 = v29;
      v29 = v47;
      *(_QWORD *)&v47 = v15;
      if (v15)

      if (*((_QWORD *)a5 + 1))
      {
        *(_BYTE *)a6 = 1;
        re::GeomModelDescriptor::makeSlicePayload<unsigned int>(a5, (uint64_t *)&v47);
        v16 = v30;
        v30 = v47;
        *(_QWORD *)&v47 = v16;
        if (v16)

      }
      v17 = (unint64_t *)re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)(a1 + 6), (uint64_t)&v36);
      if (v17)
      {
        v18 = *v17;
        v19 = a1[14];
        if (v19 <= *v17)
        {
          v38 = 0;
          v50 = 0u;
          v51 = 0u;
          v48 = 0u;
          v49 = 0u;
          v47 = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          v39 = 136315906;
          v40 = "operator[]";
          v41 = 1024;
          v42 = 789;
          v43 = 2048;
          v44 = v18;
          v45 = 2048;
          v46 = v19;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        v20 = re::DynamicString::operator=((re::DynamicString *)(a1[16] + 56 * v18), (re::DynamicString *)&v26);
        *((_BYTE *)v20 + 32) = v28;
        v21 = *((_QWORD *)v20 + 5);
        *((_QWORD *)v20 + 5) = v29;
        v29 = v21;
        v22 = *((_QWORD *)v20 + 6);
        *((_QWORD *)v20 + 6) = v30;
        v30 = v22;
      }
      else
      {
        *(_QWORD *)&v47 = a1[14];
        re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<unsigned long &>((uint64_t)(a1 + 6), (re::DynamicString *)&v36, &v47);
        re::DynamicArray<re::GeomModelDescriptor::AttributeData>::add((_anonymous_namespace_ *)(a1 + 12), (uint64_t)&v26);
        v22 = v30;
      }
      *(_BYTE *)a6 = 1;
      if (v22)
      {

        v30 = 0;
      }
      if (v29)
      {

        v29 = 0;
      }
      if (v26 && (v27 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v26 + 40))();
    }
    else
    {
      v23 = v47;
      v24 = v48;
      *(_BYTE *)a6 = 0;
      *(_QWORD *)(a6 + 8) = 100;
      *(_QWORD *)(a6 + 16) = &re::AssetErrorCategory(void)::instance;
      *(_OWORD *)(a6 + 24) = v23;
      *(_OWORD *)(a6 + 40) = v24;
    }
  }
  else
  {
    *(_BYTE *)a6 = 0;
    *(_OWORD *)(a6 + 8) = v32;
    *(_QWORD *)(a6 + 24) = v33;
    *(_QWORD *)(a6 + 48) = v35;
    *(_OWORD *)(a6 + 32) = v34;
    v35 = 0;
    v33 = 0;
    v34 = 0uLL;
  }
  if (!v31[0] && v33 && (v34 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v33 + 40))();
  result = v36;
  if (v36)
  {
    if ((v37 & 1) != 0)
      return (*(uint64_t (**)(void))(*(_QWORD *)v36 + 40))();
  }
  return result;
}

uint64_t re::GeomModelDescriptor::makeSlicePayload<unsigned short>@<X0>(re *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  size_t v9;
  uint64_t v10;
  uint64_t result;
  char v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;

  v4 = re::globalAllocators(a1);
  v6 = *((_QWORD *)a1 + 1);
  if (!v6)
  {
    v9 = 0;
    v8 = 0;
    goto LABEL_6;
  }
  if ((v6 & 0x8000000000000000) == 0 && (unint64_t)(2 * v6) < 0xFFFFFFFFFFFFFFF0)
  {
    v7 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v4[2] + 32))(v4[2], (2 * v6 + 16) | 1, 0);
    v8 = (_QWORD *)((v7 + 17) & 0xFFFFFFFFFFFFFFFELL);
    *(v8 - 2) = v6;
    *(v8 - 1) = v7;
    bzero(v8, 2 * v6);
    v9 = 2 * *((_QWORD *)a1 + 1);
LABEL_6:
    v16 = v8;
    memcpy(v8, *(const void **)a1, v9);
    v10 = *((_QWORD *)a1 + 1);
    v14 = 2;
    v15 = v10;
    v13 = 0;
    v12 = 1;
    return re::make::shared::object<re::internal::DataPayload,unsigned char *&,re::GeomModelValueType const&,unsigned long,unsigned long,int,BOOL,unsigned char *&,void (&)(void const*)>((re *)&v16, (char *)&re::ConvertToGeomModelValueType<unsigned short>::kValueType, &v15, &v14, &v13, &v12, (uint64_t *)&v16, (uint64_t)re::GeomModelDescriptor::freeReNewedArrayData<unsigned short>, a2);
  }
  re::internal::assertLog((re::internal *)6, v5, "assertion failure: '%s' (%s:line %i) Size overflow in allocateArray. Element size = %zu, count = %zu", "!overflow", "allocateArray", 61, 2, v6);
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t *re::GeomModelDescriptor::freeReNewedArrayData<unsigned short>(re *a1)
{
  uint64_t *result;

  result = re::globalAllocators(a1);
  if (a1)
    return (uint64_t *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)result[2] + 40))(result[2], *((_QWORD *)a1 - 1));
  return result;
}

uint64_t re::GeomModelDescriptor::setAttribute<unsigned int,unsigned int>@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, re *a4@<X3>, re *a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v12;
  const re::DynamicString *v13;
  _anonymous_namespace_ *v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t v19;
  re::DynamicString *v20;
  uint64_t v21;
  uint64_t v22;
  __int128 v23;
  __int128 v24;
  uint64_t result;
  uint64_t v26;
  char v27;
  char v28;
  uint64_t v29;
  uint64_t v30;
  _BYTE v31[8];
  __int128 v32;
  uint64_t v33;
  __int128 v34;
  uint64_t v35;
  uint64_t v36;
  char v37;
  uint64_t v38;
  int v39;
  const char *v40;
  __int16 v41;
  int v42;
  __int16 v43;
  unint64_t v44;
  __int16 v45;
  unint64_t v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  uint64_t v52;

  v52 = *MEMORY[0x24BDAC8D0];
  v12 = re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)(a1 + 17), a2);
  if (v12)
    v13 = (const re::DynamicString *)v12;
  else
    v13 = (const re::DynamicString *)a2;
  re::DynamicString::DynamicString((re::DynamicString *)&v36, v13);
  re::GeomModelDescriptor::validateIfCoreAttribute((uint64_t)&v36, a3, 5, (uint64_t)v31);
  if (v31[0])
  {
    if (*((_QWORD *)a4 + 1))
    {
      v28 = 4;
      v29 = 0;
      v30 = 0;
      re::DynamicString::operator=((re::DynamicString *)&v26, (re::DynamicString *)&v36);
      v28 = a3;
      re::GeomModelDescriptor::makeSlicePayload<unsigned int>(a4, (uint64_t *)&v47);
      v15 = v29;
      v29 = v47;
      *(_QWORD *)&v47 = v15;
      if (v15)

      if (*((_QWORD *)a5 + 1))
      {
        *(_BYTE *)a6 = 1;
        re::GeomModelDescriptor::makeSlicePayload<unsigned int>(a5, (uint64_t *)&v47);
        v16 = v30;
        v30 = v47;
        *(_QWORD *)&v47 = v16;
        if (v16)

      }
      v17 = (unint64_t *)re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)(a1 + 6), (uint64_t)&v36);
      if (v17)
      {
        v18 = *v17;
        v19 = a1[14];
        if (v19 <= *v17)
        {
          v38 = 0;
          v50 = 0u;
          v51 = 0u;
          v48 = 0u;
          v49 = 0u;
          v47 = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          v39 = 136315906;
          v40 = "operator[]";
          v41 = 1024;
          v42 = 789;
          v43 = 2048;
          v44 = v18;
          v45 = 2048;
          v46 = v19;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        v20 = re::DynamicString::operator=((re::DynamicString *)(a1[16] + 56 * v18), (re::DynamicString *)&v26);
        *((_BYTE *)v20 + 32) = v28;
        v21 = *((_QWORD *)v20 + 5);
        *((_QWORD *)v20 + 5) = v29;
        v29 = v21;
        v22 = *((_QWORD *)v20 + 6);
        *((_QWORD *)v20 + 6) = v30;
        v30 = v22;
      }
      else
      {
        *(_QWORD *)&v47 = a1[14];
        re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<unsigned long &>((uint64_t)(a1 + 6), (re::DynamicString *)&v36, &v47);
        re::DynamicArray<re::GeomModelDescriptor::AttributeData>::add((_anonymous_namespace_ *)(a1 + 12), (uint64_t)&v26);
        v22 = v30;
      }
      *(_BYTE *)a6 = 1;
      if (v22)
      {

        v30 = 0;
      }
      if (v29)
      {

        v29 = 0;
      }
      if (v26 && (v27 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v26 + 40))();
    }
    else
    {
      v23 = v47;
      v24 = v48;
      *(_BYTE *)a6 = 0;
      *(_QWORD *)(a6 + 8) = 100;
      *(_QWORD *)(a6 + 16) = &re::AssetErrorCategory(void)::instance;
      *(_OWORD *)(a6 + 24) = v23;
      *(_OWORD *)(a6 + 40) = v24;
    }
  }
  else
  {
    *(_BYTE *)a6 = 0;
    *(_OWORD *)(a6 + 8) = v32;
    *(_QWORD *)(a6 + 24) = v33;
    *(_QWORD *)(a6 + 48) = v35;
    *(_OWORD *)(a6 + 32) = v34;
    v35 = 0;
    v33 = 0;
    v34 = 0uLL;
  }
  if (!v31[0] && v33 && (v34 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v33 + 40))();
  result = v36;
  if (v36)
  {
    if ((v37 & 1) != 0)
      return (*(uint64_t (**)(void))(*(_QWORD *)v36 + 40))();
  }
  return result;
}

_QWORD *re::FixedArray<re::Vector4<float>>::init<re::Vector4<float>>(_QWORD *result, uint64_t a2, unint64_t a3, _OWORD *a4)
{
  _QWORD *v6;
  uint64_t v7;
  unint64_t v8;

  *result = a2;
  result[1] = a3;
  if (!a3)
    return result;
  if (a3 >> 60)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 16, a3);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  v6 = result;
  result = (_QWORD *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 16 * a3, 16);
  v6[2] = result;
  if (!result)
  {
LABEL_9:
    re::internal::assertLog((re::internal *)4, v7, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    result = (_QWORD *)_os_crash();
    __break(1u);
    return result;
  }
  v8 = a3 - 1;
  if (a3 != 1)
  {
    do
    {
      *(_OWORD *)result = *a4;
      result += 2;
      --v8;
    }
    while (v8);
  }
  *(_OWORD *)result = *a4;
  return result;
}

uint64_t *re::GeomModelDescriptor::freeReNewedArrayData<re::Vector4<float>>(re *a1)
{
  uint64_t *result;

  result = re::globalAllocators(a1);
  if (a1)
    return (uint64_t *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)result[2] + 40))(result[2], *((_QWORD *)a1 - 1));
  return result;
}

void CGImagePtr::CGImagePtr(CGImagePtr *this, CGImageRef image)
{
  size_t BytesPerRow;
  CGColorSpace *ColorSpace;
  CGColorSpace *v6;
  size_t NumberOfComponents;
  CGColorSpaceModel Model;
  CGColorSpace *v9;

  *(_QWORD *)this = image;
  *((_QWORD *)this + 1) = CGImageGetWidth(image);
  *((_QWORD *)this + 2) = CGImageGetHeight(image);
  *((_QWORD *)this + 3) = CGImageGetBitsPerComponent(image);
  *((_QWORD *)this + 4) = CGImageGetBitsPerPixel(image);
  BytesPerRow = CGImageGetBytesPerRow(image);
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 5) = BytesPerRow;
  *((_DWORD *)this + 16) = -1;
  *((_DWORD *)this + 18) = CGImageGetBitmapInfo(image);
  ColorSpace = CGImageGetColorSpace(image);
  if (ColorSpace)
  {
    v6 = CGColorSpaceRetain(ColorSpace);
    NumberOfComponents = CGColorSpaceGetNumberOfComponents(v6);
    Model = CGColorSpaceGetModel(v6);
    v9 = (CGColorSpace *)*((_QWORD *)this + 6);
    *((_QWORD *)this + 6) = v6;
    *((_QWORD *)this + 7) = NumberOfComponents;
    *((_DWORD *)this + 16) = Model;
    CGColorSpaceRelease(v9);
  }
}

uint64_t CGImagePtr::CGImagePtr(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  CGColorSpace *v13;
  int v14;

  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 64) = -1;
  v4 = *a2;
  v5 = a2[1];
  *a2 = 0;
  a2[1] = 0;
  *(_QWORD *)a1 = v4;
  *(_QWORD *)(a1 + 8) = v5;
  v6 = a2[2];
  a2[2] = 0;
  *(_QWORD *)(a1 + 16) = v6;
  v7 = a2[3];
  a2[3] = 0;
  *(_QWORD *)(a1 + 24) = v7;
  v8 = a2[5];
  v9 = a2[6];
  a2[5] = 0;
  *(_QWORD *)(a1 + 40) = v8;
  v10 = a2[4];
  a2[4] = 0;
  *(_QWORD *)(a1 + 32) = v10;
  v11 = a2[7];
  v12 = *((_DWORD *)a2 + 16);
  a2[6] = 0;
  a2[7] = 0;
  *((_DWORD *)a2 + 16) = -1;
  CGColorSpaceRelease(0);
  v13 = *(CGColorSpace **)(a1 + 48);
  *(_QWORD *)(a1 + 48) = v9;
  *(_QWORD *)(a1 + 56) = v11;
  *(_DWORD *)(a1 + 64) = v12;
  CGColorSpaceRelease(v13);
  CGColorSpaceRelease(0);
  v14 = *((_DWORD *)a2 + 18);
  *((_DWORD *)a2 + 18) = 0;
  *(_DWORD *)(a1 + 72) = v14;
  return a1;
}

void CGImagePtr::swap(CGImagePtr *this, CGImagePtr *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  CGColorSpace *v16;
  CGColorSpace *v17;
  int v18;

  v4 = *(_QWORD *)this;
  v5 = *((_QWORD *)this + 1);
  v6 = *((_QWORD *)a2 + 1);
  *(_QWORD *)this = *(_QWORD *)a2;
  *((_QWORD *)this + 1) = v6;
  *(_QWORD *)a2 = v4;
  *((_QWORD *)a2 + 1) = v5;
  v7 = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = *((_QWORD *)a2 + 2);
  *((_QWORD *)a2 + 2) = v7;
  v8 = *((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = *((_QWORD *)a2 + 3);
  *((_QWORD *)a2 + 3) = v8;
  v9 = *((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = *((_QWORD *)a2 + 4);
  *((_QWORD *)a2 + 4) = v9;
  v10 = *((_QWORD *)this + 5);
  v11 = *((_QWORD *)this + 6);
  *((_QWORD *)this + 6) = 0;
  v12 = *((_QWORD *)a2 + 6);
  *((_QWORD *)this + 5) = *((_QWORD *)a2 + 5);
  *((_QWORD *)a2 + 5) = v10;
  v13 = *((_QWORD *)this + 7);
  *((_QWORD *)this + 7) = 0;
  v14 = *((_DWORD *)this + 16);
  *((_DWORD *)this + 16) = -1;
  v15 = *((_QWORD *)a2 + 7);
  LODWORD(v6) = *((_DWORD *)a2 + 16);
  *((_DWORD *)a2 + 16) = -1;
  *((_QWORD *)a2 + 6) = 0;
  *((_QWORD *)a2 + 7) = 0;
  v16 = (CGColorSpace *)*((_QWORD *)this + 6);
  *((_QWORD *)this + 6) = v12;
  *((_QWORD *)this + 7) = v15;
  *((_DWORD *)this + 16) = v6;
  CGColorSpaceRelease(v16);
  v17 = (CGColorSpace *)*((_QWORD *)a2 + 6);
  *((_QWORD *)a2 + 6) = v11;
  *((_QWORD *)a2 + 7) = v13;
  *((_DWORD *)a2 + 16) = v14;
  CGColorSpaceRelease(v17);
  CGColorSpaceRelease(0);
  v18 = *((_DWORD *)this + 18);
  *((_DWORD *)this + 18) = *((_DWORD *)a2 + 18);
  *((_DWORD *)a2 + 18) = v18;
}

const void *re::CGColorSpaceNameFromOCIOString(re *this, const __CFString *a2)
{
  re *v2;
  unsigned __int8 v3;
  int v5;

  v2 = this;
  v3 = atomic_load((unsigned __int8 *)&qword_25411C598);
  if ((v3 & 1) == 0)
  {
    v5 = __cxa_guard_acquire(&qword_25411C598);
    v2 = this;
    if (v5)
    {
      if (qword_25411C5B8 != -1)
        dispatch_once(&qword_25411C5B8, &__block_literal_global_37);
      _MergedGlobals_412 = qword_25411C5B0;
      __cxa_guard_release(&qword_25411C598);
      v2 = this;
    }
  }
  return CFDictionaryGetValue((CFDictionaryRef)_MergedGlobals_412, v2);
}

const void *re::OCIOStringArrayFromCGColorSpaceName(re *this, const __CFString *a2)
{
  re *v2;
  unsigned __int8 v3;
  int v5;

  v2 = this;
  v3 = atomic_load((unsigned __int8 *)&qword_25411C5A8);
  if ((v3 & 1) == 0)
  {
    v5 = __cxa_guard_acquire(&qword_25411C5A8);
    v2 = this;
    if (v5)
    {
      if (qword_25411C5C8 != -1)
        dispatch_once(&qword_25411C5C8, &__block_literal_global_107);
      qword_25411C5A0 = qword_25411C5C0;
      __cxa_guard_release(&qword_25411C5A8);
      v2 = this;
    }
  }
  return CFDictionaryGetValue((CFDictionaryRef)qword_25411C5A0, v2);
}

void ___ZN2reL30OCIOToCGColorSpaceMappingTableEv_block_invoke()
{
  void *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  _QWORD v15[8];
  _QWORD v16[8];
  _QWORD v17[45];
  _QWORD v18[46];

  v18[45] = *MEMORY[0x24BDAC8D0];
  objc_msgSend(MEMORY[0x24BDBCED8], "dictionary");
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  v1 = *MEMORY[0x24BDBF318];
  v17[0] = CFSTR("Input - Texture - sRGB - sRGB");
  v17[1] = CFSTR("Utility - sRGB - Texture");
  v18[0] = v1;
  v18[1] = v1;
  v17[2] = CFSTR("sRGB");
  v17[3] = CFSTR("srgb_texture");
  v18[2] = v1;
  v18[3] = v1;
  v17[4] = CFSTR("sRGB - Texture");
  v17[5] = CFSTR("Input - Generic - sRGB - Texture");
  v18[4] = v1;
  v18[5] = v1;
  v17[6] = CFSTR("srgb_tx");
  v17[7] = CFSTR("Input - Texture - Linear - sRGB");
  v2 = *MEMORY[0x24BDBF308];
  v18[6] = v1;
  v18[7] = v2;
  v17[8] = CFSTR("Utility - Linear - sRGB");
  v17[9] = CFSTR("Utility - Linear - Rec.709");
  v18[8] = v2;
  v18[9] = v2;
  v17[10] = CFSTR("lin_srgb");
  v17[11] = CFSTR("scene-linear Rec 709/sRGB");
  v18[10] = v2;
  v18[11] = v2;
  v17[12] = CFSTR("lin_rec709");
  v17[13] = CFSTR("Linear Rec.709 (sRGB)");
  v18[12] = v2;
  v18[13] = v2;
  v17[14] = CFSTR("lin_rec709_srgb");
  v17[15] = CFSTR("Linear - sRGB");
  v18[14] = v2;
  v18[15] = v2;
  v3 = *MEMORY[0x24BDBF258];
  v17[16] = CFSTR("Utility - Linear - P3-D65");
  v17[17] = CFSTR("Linear P3-D65");
  v18[16] = v3;
  v18[17] = v3;
  v17[18] = CFSTR("lin_displayp3");
  v17[19] = CFSTR("Linear - Display P3");
  v18[18] = v3;
  v18[19] = v3;
  v4 = *MEMORY[0x24BDBF228];
  v17[20] = CFSTR("Input - Texture - sRGB - Display P3");
  v17[21] = CFSTR("Input - Generic - Display P3 - Texture");
  v18[20] = v4;
  v18[21] = v4;
  v17[22] = CFSTR("sRGB - Display P3 - Texture");
  v17[23] = CFSTR("Role - texture_paint");
  v18[22] = v4;
  v18[23] = v4;
  v17[24] = CFSTR("role_texture_paint");
  v17[25] = CFSTR("Role - matte_paint");
  v18[24] = v4;
  v18[25] = v4;
  v17[26] = CFSTR("role_matte_paint");
  v17[27] = CFSTR("Role - color_picking");
  v18[26] = v4;
  v18[27] = v4;
  v17[28] = CFSTR("role_color_picking");
  v17[29] = CFSTR("srgb_displayp3");
  v18[28] = v4;
  v18[29] = v4;
  v17[30] = CFSTR("srgb_p3d65");
  v17[31] = CFSTR("Display P3");
  v18[30] = v4;
  v18[31] = v4;
  v17[32] = CFSTR("sRGB - Display P3");
  v17[33] = CFSTR("sRGB Encoded P3-D65 - Texture");
  v18[32] = v4;
  v18[33] = v4;
  v17[34] = CFSTR("srgb_encoded_p3d65_tx");
  v17[35] = CFSTR("Utility - sRGB - P3-D65 - Texture");
  v18[34] = v4;
  v18[35] = v4;
  v5 = *MEMORY[0x24BDBF238];
  v17[36] = CFSTR("Input - Texture - PQ - Display P3");
  v17[37] = CFSTR("Utility - Rec.2020 - Camera");
  v6 = *MEMORY[0x24BDBF2B8];
  v18[36] = v5;
  v18[37] = v6;
  v17[38] = CFSTR("srgb_rec2020");
  v17[39] = CFSTR("Utility - Linear - Rec.2020");
  v7 = *MEMORY[0x24BDBF268];
  v18[38] = v6;
  v18[39] = v7;
  v17[40] = CFSTR("Linear Rec.2020");
  v17[41] = CFSTR("acescg");
  v8 = *MEMORY[0x24BDBF210];
  v18[40] = v7;
  v18[41] = v8;
  v17[42] = CFSTR("ACES - ACEScg");
  v17[43] = CFSTR("ACEScg");
  v18[42] = v8;
  v18[43] = v8;
  v17[44] = CFSTR("lin_ap1");
  v18[44] = v8;
  objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v18, v17, 45);
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "addEntriesFromDictionary:", v9);
  v10 = *MEMORY[0x24BDBF2E8];
  v15[0] = CFSTR("Input - Texture - PQ - sRGB");
  v15[1] = CFSTR("Input - Texture - Linear - Display P3");
  v11 = *MEMORY[0x24BDBF2F0];
  v16[0] = v10;
  v16[1] = v11;
  v15[2] = CFSTR("lin_p3d65");
  v15[3] = CFSTR("Input - Texture - sRGB - Rec.2020");
  v12 = *MEMORY[0x24BDBF2C0];
  v16[2] = v11;
  v16[3] = v12;
  v15[4] = CFSTR("Input - Generic - Rec.2020 - Texture");
  v15[5] = CFSTR("sRGB - Rec.2020 - Texture");
  v16[4] = v12;
  v16[5] = v12;
  v13 = *MEMORY[0x24BDBF300];
  v15[6] = CFSTR("Input - Texture - Linear - Rec.2020");
  v15[7] = CFSTR("lin_rec2020");
  v16[6] = v13;
  v16[7] = v13;
  objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v16, v15, 8);
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "addEntriesFromDictionary:", v14);

  qword_25411C5B0 = (uint64_t)v0;
  CFRetain(v0);

}

void ___ZN2reL30CGColorSpaceToOCIOMappingTableEv_block_invoke()
{
  id v0;
  void *v1;
  uint64_t v2;
  void *v3;
  void *v4;
  id v5;
  void *v6;
  void *v7;
  void *cf;

  objc_msgSend(MEMORY[0x24BDBCED8], "dictionary");
  cf = (void *)objc_claimAutoreleasedReturnValue();
  if (qword_25411C5B8 != -1)
    dispatch_once(&qword_25411C5B8, &__block_literal_global_37);
  v0 = (id)qword_25411C5B0;
  objc_msgSend(v0, "keyEnumerator");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "nextObject");
  v2 = objc_claimAutoreleasedReturnValue();
  if (v2)
  {
    v3 = (void *)v2;
    do
    {
      objc_msgSend(v0, "objectForKeyedSubscript:", v3);
      v4 = (void *)objc_claimAutoreleasedReturnValue();
      v5 = v3;
      objc_msgSend(cf, "objectForKey:", v4);
      v6 = (void *)objc_claimAutoreleasedReturnValue();

      if (v6)
      {
        objc_msgSend(cf, "objectForKeyedSubscript:", v4);
        v7 = (void *)objc_claimAutoreleasedReturnValue();
      }
      else
      {
        objc_msgSend(MEMORY[0x24BDBCEB8], "array");
        v7 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(cf, "setObject:forKeyedSubscript:", v7, v4);
      }
      objc_msgSend(v7, "addObject:", v5);

      objc_msgSend(v1, "nextObject");
      v3 = (void *)objc_claimAutoreleasedReturnValue();

    }
    while (v3);
  }
  qword_25411C5C0 = (uint64_t)cf;
  CFRetain(cf);

}

void re::internal::HIDKeyboardFactory::addDeviceMatchingDictionaries(re::internal::HIDKeyboardFactory *this, __CFArray *a2)
{
  __CFDictionary *DeviceMatchingDictionary;

  DeviceMatchingDictionary = re::internal::createDeviceMatchingDictionary((re::internal *)1, 6);
  CFArrayAppendValue(a2, DeviceMatchingDictionary);
  CFRelease(DeviceMatchingDictionary);
}

_QWORD *re::internal::HIDKeyboardFactory::tryCreate@<X0>(IOHIDDeviceRef device@<X1>, _QWORD *a2@<X8>)
{
  uint64_t v5;
  _QWORD *result;

  if (IOHIDDeviceConformsTo(device, 1u, 6u))
  {
    v5 = operator new();
    result = (_QWORD *)re::internal::HIDDevice::HIDDevice(v5, device, (const __CFString *)&_keyboardMap, 1);
    *result = &off_24ED7D708;
  }
  else
  {
    result = 0;
  }
  *a2 = result;
  return result;
}

void re::internal::HIDKeyboard::flush(re::internal::HIDKeyboard *this)
{
  re::InputManager::notify(8, 0, 0, 0);
  *((_BYTE *)this + 40) = 0;
}

void re::internal::HIDKeyboardFactory::~HIDKeyboardFactory(re::internal::HIDKeyboardFactory *this)
{
  JUMPOUT(0x2276933B8);
}

void re::internal::HIDKeyboard::~HIDKeyboard(CFStringRef *this)
{
  re::internal::HIDDevice::~HIDDevice(this);
  JUMPOUT(0x2276933B8);
}

CFIndex HIDKeyboard_FnHandler(uint64_t a1, int a2, IOHIDValueRef value)
{
  CFIndex result;

  result = IOHIDValueGetIntegerValue(value);
  *(_BYTE *)(a1 + 40) = result != 0;
  return result;
}

void HIDKeyboard_KeyHandler(re::internal::HIDDevice *a1, int a2, IOHIDValueRef value, __IOHIDElement *a4)
{
  _BOOL4 v5;

  v5 = IOHIDValueGetIntegerValue(value) != 0;
  re::InputManager::notify(7, a2, v5, 0);
}

uint64_t *re::allocInfo_InputService(re *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&_MergedGlobals_413);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&_MergedGlobals_413))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_25411C5D8, 0);
    *(uint64_t *)((char *)&qword_25411C5E8 + 6) = 0;
    qword_25411C5E8 = 0;
    qword_25411C5F8 = 0;
    qword_25411C600 = 0xFFFFFFFFLL;
    qword_25411C5D8 = (uint64_t)&off_24ED7DAA8;
    qword_25411C608 = (uint64_t)"InputService";
    dword_25411C610 = 0;
    unk_25411C618 = 0u;
    unk_25411C628 = 0u;
    unk_25411C638 = 0u;
    qword_25411C648 = 0;
    __cxa_guard_release(&_MergedGlobals_413);
  }
  return &qword_25411C5D8;
}

void re::initInfo_InputService(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  __int128 v4;
  _QWORD v5[2];
  __int128 v6;

  v5[0] = 0x3611AC2775B3C756;
  v5[1] = "InputService";
  re::StringID::destroyString((re::StringID *)v5);
  *((_OWORD *)this + 2) = v6;
  *((_QWORD *)this + 2) = 0x800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 8) = &re::initInfo_InputService(re::IntrospectionBase *)::structureAttributes;
  re::IntrospectionRegistry::add(this, v3);
  v4 = v6;
}

uint64_t re::introspect_InputService(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"InputService", (uint64_t (*)(re::internal *))re::allocInfo_InputService, (re::IntrospectionBase *(*)(void))re::initInfo_InputService, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::InputService>, this);
}

uint64_t re::internal::HIDDevice::HIDDevice(uint64_t a1, re::internal *this, const __CFString *a3, int a4)
{
  const __CFString *v5;
  const __CFString *v8;
  __IOHIDDevice *DevicePropertyString;
  const char *CStringPtr;
  const char *v11;
  const __CFString *v12;
  int DevicePropertyInt;
  const __CFString *v14;
  int i;

  v5 = a3;
  *(_QWORD *)a1 = &off_24ED7D7A0;
  *(_QWORD *)(a1 + 8) = this;
  *(_QWORD *)(a1 + 16) = re::internal::getDevicePropertyString(this, CFSTR("Manufacturer"), a3);
  DevicePropertyString = re::internal::getDevicePropertyString(this, CFSTR("Product"), v8);
  *(_QWORD *)(a1 + 24) = DevicePropertyString;
  *(_QWORD *)(a1 + 32) = 0;
  CStringPtr = CFStringGetCStringPtr((CFStringRef)DevicePropertyString, 0x8000100u);
  v11 = CFStringGetCStringPtr(*(CFStringRef *)(a1 + 16), 0x8000100u);
  printf("Found \"%s\" by \"%s\"\n", CStringPtr, v11);
  DevicePropertyInt = re::internal::getDevicePropertyInt(this, CFSTR("VendorID"), v12);
  for (i = re::internal::getDevicePropertyInt(this, CFSTR("ProductID"), v14); a4; --a4)
  {
    if (LODWORD(v5->isa) == -1 && HIDWORD(v5->isa) == -1
      || LODWORD(v5->isa) == DevicePropertyInt && HIDWORD(v5->isa) == i)
    {
      *(_QWORD *)(a1 + 32) = v5;
    }
    v5 = (const __CFString *)((char *)v5 + 24);
  }
  return a1;
}

void re::internal::HIDDevice::~HIDDevice(CFStringRef *this)
{
  const char *CStringPtr;
  const char *v3;

  *this = (CFStringRef)&off_24ED7D7A0;
  CStringPtr = CFStringGetCStringPtr(this[3], 0x8000100u);
  v3 = CFStringGetCStringPtr(this[2], 0x8000100u);
  printf("Lost \"%s\" by \"%s\"\n", CStringPtr, v3);
}

{
  re::internal::HIDDevice::~HIDDevice(this);
  JUMPOUT(0x2276933B8);
}

uint64_t re::internal::HIDDevice::handleInput(re::internal::HIDDevice *this, IOHIDValueRef value)
{
  __IOHIDElement *Element;
  uint64_t result;
  uint64_t v6;
  _DWORD *v7;
  uint64_t v8;
  _DWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  _DWORD *v12;
  uint64_t v13;
  uint64_t (*v14)(re::internal::HIDDevice *, _QWORD, IOHIDValueRef, __IOHIDElement *);

  Element = IOHIDValueGetElement(value);
  result = IOHIDElementGetType(Element);
  v6 = *((_QWORD *)this + 4);
  v7 = *(_DWORD **)(v6 + 8);
  v8 = (result - *v7);
  if (v8 < *(_DWORD *)(v6 + 16))
  {
    v9 = &v7[4 * v8];
    v11 = *((_QWORD *)v9 + 1);
    v10 = v9 + 2;
    if (v11)
    {
      result = IOHIDElementGetUsage(Element);
      v12 = (_DWORD *)*v10;
      v13 = (result - *(_DWORD *)*v10);
      if (v13 < v7[4 * v8 + 1])
      {
        v14 = *(uint64_t (**)(re::internal::HIDDevice *, _QWORD, IOHIDValueRef, __IOHIDElement *))&v12[4 * v13 + 2];
        if (v14)
          return v14(this, v12[4 * v13 + 1], value, Element);
      }
    }
  }
  return result;
}

uint64_t re::initInputManagement(re *this)
{
  re *v1;
  uint64_t *v2;
  uint64_t v3;

  inputState();
  os_unfair_lock_lock((os_unfair_lock_t)&unk_25582A230);
  if (!inputState(void)::state)
  {
    v2 = re::globalAllocators(v1);
    v3 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v2[2] + 32))(v2[2], 48, 8);
    *(_OWORD *)(v3 + 16) = 0u;
    *(_OWORD *)(v3 + 32) = 0u;
    *(_OWORD *)v3 = 0u;
    *(_DWORD *)(v3 + 36) = 0x7FFFFFFF;
    inputState(void)::state = v3;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_25582A230);
  if (re::internal::HIDManager::getShared(void)::sharedInstancePredicate != -1)
    dispatch_once(&re::internal::HIDManager::getShared(void)::sharedInstancePredicate, &__block_literal_global_38);
  return re::internal::HIDManager::start(re::internal::HIDManager::getShared(void)::sharedInstance);
}

void inputState(void)
{
  unsigned __int8 v0;

  if ((v0 & 1) == 0)
  {
    {
      InputEventState::InputEventState((InputEventState *)&inputState(void)::state);
    }
  }
}

void re::deinitInputManagement(re *this)
{
  re *v1;
  uint64_t *v2;
  uint64_t v3;
  double v4;

  inputState();
  os_unfair_lock_lock((os_unfair_lock_t)&unk_25582A230);
  v2 = (uint64_t *)inputState(void)::state;
  if (inputState(void)::state)
  {
    v3 = re::globalAllocators(v1)[2];
    v4 = re::HashTable<unsigned long long,void({block_pointer} {__strong})(unsigned long long,REAudioPlaybackState,REAudioPlaybackState),re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit(v2);
    (*(void (**)(uint64_t, uint64_t *, double))(*(_QWORD *)v3 + 40))(v3, v2, v4);
    inputState(void)::state = 0;
    os_unfair_lock_unlock((os_unfair_lock_t)&unk_25582A230);
    if (re::internal::HIDManager::getShared(void)::sharedInstancePredicate != -1)
      dispatch_once(&re::internal::HIDManager::getShared(void)::sharedInstancePredicate, &__block_literal_global_38);
    re::internal::HIDManager::stop((re::internal::HIDManager *)re::internal::HIDManager::getShared(void)::sharedInstance);
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&unk_25582A230);
  }
}

void re::InputManager::notify(int a1, int a2, int a3, int a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int *v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  NSObject *v17;
  int v18;
  int v19;
  _QWORD v20[6];
  int v21;
  int v22;
  int v23;
  int v24;

  inputState();
  os_unfair_lock_lock((os_unfair_lock_t)&unk_25582A230);
  v8 = inputState(void)::state;
  v9 = *(unsigned int *)(inputState(void)::state + 32);
  if ((_DWORD)v9)
  {
    v10 = 0;
    v11 = (int *)(*(_QWORD *)(inputState(void)::state + 16) + 8);
    while (1)
    {
      v12 = *v11;
      v11 += 8;
      if (v12 < 0)
        break;
      if (v9 == ++v10)
      {
        LODWORD(v10) = *(_DWORD *)(inputState(void)::state + 32);
        break;
      }
    }
  }
  else
  {
    LODWORD(v10) = 0;
  }
  if ((_DWORD)v9 != (_DWORD)v10)
  {
    v13 = v10;
    v14 = MEMORY[0x24BDAC760];
    do
    {
      v15 = *(_QWORD *)(v8 + 16);
      v20[0] = v14;
      v16 = v15 + 32 * v13;
      v20[1] = 3221225472;
      v20[2] = ___ZN2re12InputManager6notifyE16REInputEventTypeiii_block_invoke;
      v20[3] = &__block_descriptor_64_e5_v8__0l;
      v17 = *(NSObject **)(v16 + 24);
      v16 += 24;
      v20[4] = v16 - 8;
      v20[5] = v16;
      v21 = a1;
      v22 = a2;
      v23 = a3;
      v24 = a4;
      dispatch_async(v17, v20);
      if (*(_DWORD *)(v8 + 32) <= (v10 + 1))
        v18 = v10 + 1;
      else
        v18 = *(_DWORD *)(v8 + 32);
      v19 = v10;
      while (1)
      {
        v13 = (v19 + 1);
        if (v18 - 1 == v19)
          break;
        ++v19;
        LODWORD(v10) = v13;
        if ((*(_DWORD *)(*(_QWORD *)(v8 + 16) + 32 * v13 + 8) & 0x80000000) != 0)
          goto LABEL_17;
      }
      LODWORD(v10) = v18;
LABEL_17:
      ;
    }
    while (*(_DWORD *)(inputState(void)::state + 32) != (_DWORD)v10);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_25582A230);
}

void ___ZN2re12InputManager6notifyE16REInputEventTypeiii_block_invoke(uint64_t a1)
{
  uint64_t v1;
  unint64_t v2;
  int32x2_t v3;
  int v4;
  __int32 v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __int32 v10;
  uint64_t v11;
  int v12;

  v1 = **(_QWORD **)(a1 + 32);
  v2 = *(unsigned int *)(a1 + 52);
  v3 = *(int32x2_t *)(a1 + 56);
  switch(*(_DWORD *)(a1 + 48))
  {
    case 0:
      if (v3.i32[0])
        goto LABEL_16;
      goto LABEL_7;
    case 1:
      switch((_DWORD)v2)
      {
        case 4:
          *(_DWORD *)(v1 + 120) += v3.i32[0];
          break;
        case 2:
          *(_DWORD *)(v1 + 116) += v3.i32[0];
          break;
        case 1:
          *(_DWORD *)(v1 + 112) += v3.i32[0];
          break;
      }
      return;
    case 2:
      *(_QWORD *)(v1 + 112) = 0;
      *(_QWORD *)(v1 + 120) = 0;
      *(_DWORD *)(v1 + 136) = 0;
      *(_QWORD *)(v1 + 128) = 0;
      return;
    case 3:
      *(_QWORD *)(v1 + 112) = 0;
      goto LABEL_15;
    case 4:
      *(_QWORD *)(v1 + 112) = 0;
      *(int32x2_t *)(v1 + 124) = v3;
LABEL_7:
      v4 = *(_DWORD *)(v1 + 136) & ~(_DWORD)v2;
      goto LABEL_17;
    case 5:
      *(int32x2_t *)(v1 + 112) = vadd_s32(vsub_s32(v3, *(int32x2_t *)(v1 + 124)), *(int32x2_t *)(v1 + 112));
LABEL_15:
      *(int32x2_t *)(v1 + 124) = v3;
LABEL_16:
      v4 = *(_DWORD *)(v1 + 136) | v2;
LABEL_17:
      *(_DWORD *)(v1 + 136) = v4;
      break;
    case 6:
      *(_DWORD *)(v1 + 120) = v2;
      *(_DWORD *)(v1 + 132) += v2;
      break;
    case 7:
      if (v2 >= 0xE8)
        abort();
      v6 = v1 + 16;
      v7 = v2 >> 6;
      v8 = 1 << v2;
      if (v3.i32[0])
        v9 = *(_QWORD *)(v6 + 8 * v7) | v8;
      else
        v9 = *(_QWORD *)(v6 + 8 * v7) & ~v8;
      *(_QWORD *)(v6 + 8 * v7) = v9;
      break;
    case 8:
      v11 = v1 + 16;
      v12 = 0;
      std::__fill_n[abi:nn180100]<false,std::vector<BOOL>>((uint64_t)&v11, 0xE8uLL);
      break;
    case 9:
      *(_DWORD *)(v1 + 200) = 0;
      *(_DWORD *)(v1 + 204) = v2;
      *(_DWORD *)(v1 + 208) = v3.i32[0];
      *(_DWORD *)(v1 + 196) = 0;
      *(_WORD *)(v1 + 212) = 1;
      break;
    case 0xA:
      v10 = v3.i32[0] - *(_DWORD *)(v1 + 208);
      *(_DWORD *)(v1 + 196) = v2 - *(_DWORD *)(v1 + 204);
      *(_DWORD *)(v1 + 200) = v10;
      *(_DWORD *)(v1 + 204) = v2;
      *(_DWORD *)(v1 + 208) = v3.i32[0];
      *(_WORD *)(v1 + 212) = 0;
      break;
    case 0xB:
      v5 = v3.i32[0] - *(_DWORD *)(v1 + 208);
      *(_DWORD *)(v1 + 196) = v2 - *(_DWORD *)(v1 + 204);
      *(_DWORD *)(v1 + 200) = v5;
      *(_DWORD *)(v1 + 204) = v2;
      *(_DWORD *)(v1 + 208) = v3.i32[0];
      *(_BYTE *)(v1 + 213) = 1;
      break;
    default:
      return;
  }
}

void re::InputManager::subscribe(uint64_t a1, id *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;

  v4 = a1;
  inputState();
  os_unfair_lock_lock((os_unfair_lock_t)&unk_25582A230);
  re::HashTable<re::InputManager *,re::dispatch::Queue,re::Hash<re::InputManager *>,re::EqualTo<re::InputManager *>,true,false>::addOrReplace<re::dispatch::Queue&>(inputState(void)::state, &v4, a2);
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_25582A230);
  v5 = v4 + 16;
  v6 = 0;
  std::__fill_n[abi:nn180100]<false,std::vector<BOOL>>((uint64_t)&v5, 0xE8uLL);
  v3 = v4;
  *(_QWORD *)(v4 + 120) = 0;
  *(_QWORD *)(v3 + 128) = 0;
  *(_QWORD *)(v3 + 112) = 0;
  *(_DWORD *)(v3 + 136) = 0;
  *(_QWORD *)(v3 + 204) = 0;
  *(_QWORD *)(v3 + 196) = 0;
  *(_WORD *)(v3 + 212) = 0;
}

uint64_t re::HashTable<re::InputManager *,re::dispatch::Queue,re::Hash<re::InputManager *>,re::EqualTo<re::InputManager *>,true,false>::addOrReplace<re::dispatch::Queue&>(uint64_t a1, uint64_t *a2, id *a3)
{
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;

  v6 = *a2;
  v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (!*(_QWORD *)a1)
  {
    LODWORD(v9) = 0;
    goto LABEL_8;
  }
  v9 = v8 % *(unsigned int *)(a1 + 24);
  v10 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v9);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
LABEL_8:
    v15 = re::HashTable<re::InputManager *,re::dispatch::Queue,re::Hash<re::InputManager *>,re::EqualTo<re::InputManager *>,true,false>::addEmplace<re::dispatch::Queue&>(a1, v9, v8, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    v14 = *(_QWORD *)(a1 + 16) + 32 * v15;
    return v14 + 24;
  }
  v11 = *(_QWORD *)(a1 + 16);
  while (*(_QWORD *)(v11 + 32 * v10 + 16) != v6)
  {
    v12 = *(_DWORD *)(v11 + 32 * v10 + 8);
    v10 = v12 & 0x7FFFFFFF;
    if ((v12 & 0x7FFFFFFF) == 0x7FFFFFFF)
      goto LABEL_8;
  }

  v13 = *(_QWORD *)(a1 + 16) + 32 * v10;
  *(_QWORD *)(v13 + 24) = *a3;
  ++*(_DWORD *)(a1 + 40);
  v14 = *(_QWORD *)(a1 + 16) + 32 * v10;
  return v14 + 24;
}

void re::InputManager::unsubscribe(re::InputManager *this, re::InputManager *a2)
{
  re::InputManager *v2;

  v2 = this;
  inputState();
  os_unfair_lock_lock((os_unfair_lock_t)&unk_25582A230);
  re::HashTable<re::InputManager *,re::dispatch::Queue,re::Hash<re::InputManager *>,re::EqualTo<re::InputManager *>,true,false>::remove(inputState(void)::state, (uint64_t *)&v2);
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_25582A230);
}

uint64_t re::HashTable<re::InputManager *,re::dispatch::Queue,re::Hash<re::InputManager *>,re::EqualTo<re::InputManager *>,true,false>::remove(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int *v17;
  int v18;
  int v19;

  if (!*(_QWORD *)a1)
    return 0;
  v3 = *a2;
  v4 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v5 = ((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) ^ ((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) >> 31))
     % *(unsigned int *)(a1 + 24);
  v6 = *(_QWORD *)(a1 + 8);
  v7 = *(unsigned int *)(v6 + 4 * v5);
  if ((_DWORD)v7 == 0x7FFFFFFF)
    return 0;
  v9 = *(_QWORD *)(a1 + 16);
  v10 = v9 + 32 * v7;
  if (*(_QWORD *)(v10 + 16) != v3)
  {
    while (1)
    {
      v11 = v7;
      v12 = *(_DWORD *)(v9 + 32 * v7 + 8);
      v7 = v12 & 0x7FFFFFFF;
      if ((v12 & 0x7FFFFFFF) == 0x7FFFFFFF)
        return 0;
      v13 = v9 + 32 * v7;
      if (*(_QWORD *)(v13 + 16) == v3)
      {
        *(_DWORD *)(v9 + 32 * v11 + 8) = *(_DWORD *)(v9 + 32 * v11 + 8) & 0x80000000 | *(_DWORD *)(v13 + 8) & 0x7FFFFFFF;
        goto LABEL_9;
      }
    }
  }
  *(_DWORD *)(v6 + 4 * v5) = *(_DWORD *)(v10 + 8) & 0x7FFFFFFF;
LABEL_9:
  v14 = *(_QWORD *)(a1 + 16);
  v15 = v14 + 32 * v7;
  v18 = *(_DWORD *)(v15 + 8);
  v17 = (int *)(v15 + 8);
  v16 = v18;
  if (v18 < 0)
  {
    *v17 = v16 & 0x7FFFFFFF;

    v14 = *(_QWORD *)(a1 + 16);
    v16 = *(_DWORD *)(v14 + 32 * v7 + 8);
  }
  v19 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(v14 + 32 * v7 + 8) = *(_DWORD *)(a1 + 36) | v16 & 0x80000000;
  --*(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 36) = v7;
  *(_DWORD *)(a1 + 40) = v19 + 1;
  return 1;
}

BOOL re::InputManager::isSubscribed(re::InputManager *this, re::InputManager *a2)
{
  _BOOL8 v2;
  re::InputManager *v4;

  v4 = this;
  inputState();
  os_unfair_lock_lock((os_unfair_lock_t)&unk_25582A230);
  v2 = re::HashTable<re::ecs2::Entity const*,unsigned long long,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::containsKey(inputState(void)::state, (uint64_t *)&v4);
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_25582A230);
  return v2;
}

uint64_t re::InputManager::isDown(uint64_t a1, unsigned int a2)
{
  return (*(_QWORD *)(a1 + (((unint64_t)a2 >> 3) & 0x18) + 48) >> a2) & 1;
}

BOOL re::InputManager::isUp(uint64_t a1, unsigned int a2)
{
  return ((*(_QWORD *)(a1 + (((unint64_t)a2 >> 3) & 0x18) + 48) >> a2) & 1) == 0;
}

BOOL re::InputManager::wentDown(uint64_t a1, unsigned int a2)
{
  uint64_t v2;

  v2 = a1 + 8 * ((unint64_t)a2 >> 6);
  return (*(_QWORD *)(v2 + 80) & (1 << a2)) == 0 && (*(_QWORD *)(v2 + 48) & (1 << a2)) != 0;
}

BOOL re::InputManager::wentUp(uint64_t a1, unsigned int a2)
{
  uint64_t v2;

  v2 = a1 + 8 * ((unint64_t)a2 >> 6);
  return (*(_QWORD *)(v2 + 80) & (1 << a2)) != 0 && (*(_QWORD *)(v2 + 48) & (1 << a2)) == 0;
}

BOOL re::InputManager::isDown(uint64_t a1, int a2)
{
  return (*(_DWORD *)(a1 + 164) & a2) != 0;
}

BOOL re::InputManager::isUp(uint64_t a1, int a2)
{
  return (*(_DWORD *)(a1 + 164) & a2) == 0;
}

BOOL re::InputManager::wentDown(uint64_t a1, int a2)
{
  return (*(_DWORD *)(a1 + 192) & a2) == 0 && (*(_DWORD *)(a1 + 164) & a2) != 0;
}

BOOL re::InputManager::wentUp(uint64_t a1, int a2)
{
  return (*(_DWORD *)(a1 + 192) & a2) != 0 && (*(_DWORD *)(a1 + 164) & a2) == 0;
}

uint64_t re::InputManager::isTouching(re::InputManager *this)
{
  return *((unsigned __int8 *)this + 232);
}

BOOL re::InputManager::wentTouching(re::InputManager *this)
{
  return !*((_BYTE *)this + 252) && *((_BYTE *)this + 232) != 0;
}

uint64_t re::InputManager::isTouchMoving(re::InputManager *this)
{
  return *((unsigned __int8 *)this + 233);
}

BOOL re::InputManager::wentTouchMoving(re::InputManager *this)
{
  return !*((_BYTE *)this + 253) && *((_BYTE *)this + 233) != 0;
}

uint64_t re::InputManager::isKeyboardHandled(re::InputManager *this)
{
  return *((unsigned __int8 *)this + 8);
}

uint64_t re::InputManager::setKeyboardHandled(uint64_t this)
{
  *(_BYTE *)(this + 8) = 1;
  return this;
}

uint64_t re::InputManager::isMouseOrTouchHandled(re::InputManager *this)
{
  return *((unsigned __int8 *)this + 9);
}

uint64_t re::InputManager::setMouseOrTouchHandled(uint64_t this)
{
  *(_BYTE *)(this + 9) = 1;
  return this;
}

__n128 re::InputManager::keyboardState@<Q0>(__n128 *this@<X0>, __n128 *a2@<X8>)
{
  __n128 result;
  __n128 v3;

  result = this[3];
  v3 = this[4];
  *a2 = result;
  a2[1] = v3;
  return result;
}

__n128 re::InputManager::mouseState@<Q0>(re::InputManager *this@<X0>, uint64_t a2@<X8>)
{
  __n128 result;

  *(_OWORD *)a2 = *(_OWORD *)((char *)this + 140);
  result = *(__n128 *)((char *)this + 152);
  *(__n128 *)(a2 + 12) = result;
  return result;
}

__n128 re::InputManager::getTouchState@<Q0>(re::InputManager *this@<X0>, __n128 *a2@<X8>)
{
  __n128 result;

  result = *(__n128 *)((char *)this + 216);
  *a2 = result;
  a2[1].n128_u32[0] = *((_DWORD *)this + 58);
  return result;
}

void InputEventState::InputEventState(InputEventState *this)
{
  uint64_t *v2;
  uint64_t v3;

  *((_DWORD *)this + 2) = 0;
  v2 = re::globalAllocators(this);
  v3 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v2[2] + 32))(v2[2], 48, 8);
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_OWORD *)v3 = 0u;
  *(_DWORD *)(v3 + 36) = 0x7FFFFFFF;
  *(_QWORD *)this = v3;
}

uint64_t re::HashTable<re::InputManager *,re::dispatch::Queue,re::Hash<re::InputManager *>,re::EqualTo<re::InputManager *>,true,false>::addEmplace<re::dispatch::Queue&>(uint64_t a1, unsigned int a2, unint64_t a3, _QWORD *a4, id *a5)
{
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;

  v10 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
    v10 = *(unsigned int *)(a1 + 32);
    v11 = v10;
    if ((_DWORD)v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::InputManager *,re::dispatch::Queue,re::Hash<re::InputManager *>,re::EqualTo<re::InputManager *>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 32 * v10 + 8);
  }
  else
  {
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 32 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + 32 * v10 + 8) = v13 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v10 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v10 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v10) = a3;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v10 + 16) = *a4;
  v14 = *(_QWORD *)(a1 + 16) + 32 * v10;
  *(_QWORD *)(v14 + 24) = *a5;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

void re::HashTable<re::InputManager *,re::dispatch::Queue,re::Hash<re::InputManager *>,re::EqualTo<re::InputManager *>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  __int128 v7;
  unsigned int v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t *v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  signed int v24;
  _BYTE v25[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v25, 0, 36);
      *(_QWORD *)&v25[36] = 0x7FFFFFFFLL;
      re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphNode>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init((uint64_t)v25, v4, a2);
      v5 = *(_OWORD *)a1;
      *(_QWORD *)a1 = *(_QWORD *)v25;
      v6 = *(_QWORD *)(a1 + 16);
      v7 = *(_OWORD *)&v25[8];
      *(_OWORD *)v25 = v5;
      *(_QWORD *)&v25[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      v9 = *(_OWORD *)&v25[24];
      *(_OWORD *)&v25[24] = *(_OWORD *)(a1 + 24);
      v8 = *(_DWORD *)&v25[32];
      *(_OWORD *)(a1 + 24) = v9;
      v10 = v8;
      if (v8)
      {
        v11 = 0;
        v12 = DWORD1(v9);
        v13 = v7;
        v14 = (uint64_t *)(v6 + 24);
        do
        {
          if ((*(_DWORD *)(v14 - 2) & 0x80000000) != 0)
          {
            v15 = *(v14 - 3);
            v16 = *(unsigned int *)(a1 + 24);
            v17 = v15 % v16;
            v18 = *(unsigned int *)(a1 + 36);
            if ((_DWORD)v18 == 0x7FFFFFFF)
            {
              v18 = *(unsigned int *)(a1 + 32);
              v19 = v18;
              if ((_DWORD)v18 == (_DWORD)v16)
              {
                re::HashTable<re::InputManager *,re::dispatch::Queue,re::Hash<re::InputManager *>,re::EqualTo<re::InputManager *>,true,false>::setCapacity(a1, (2 * v12));
                v17 = v15 % *(unsigned int *)(a1 + 24);
                v19 = *(_DWORD *)(a1 + 32);
                v13 = *(_QWORD *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v19 + 1;
              v20 = *(_QWORD *)(a1 + 16);
              v21 = *(_DWORD *)(v20 + 32 * v18 + 8);
            }
            else
            {
              v20 = *(_QWORD *)(a1 + 16);
              v21 = *(_DWORD *)(v20 + 32 * v18 + 8);
              *(_DWORD *)(a1 + 36) = v21 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v20 + 32 * v18 + 8) = v21 | 0x80000000;
            *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v18 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v18 + 8) & 0x80000000 | *(_DWORD *)(v13 + 4 * v17);
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v18) = v15;
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v18 + 16) = *(v14 - 1);
            v22 = *(_QWORD *)(a1 + 16) + 32 * v18;
            v23 = *v14;
            *v14 = 0;
            *(_QWORD *)(v22 + 24) = v23;
            v13 = *(_QWORD *)(a1 + 8);
            *(_DWORD *)(v13 + 4 * v17) = v18;
            v12 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v12;
          }
          ++v11;
          v14 += 4;
        }
        while (v11 < v10);
      }
      re::HashTable<unsigned long long,void({block_pointer} {__strong})(unsigned long long,REAudioPlaybackState,REAudioPlaybackState),re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)v25);
    }
  }
  else
  {
    if (a2)
      v24 = a2;
    else
      v24 = 3;
  }
}

void ___ZN2re8internal10HIDManager9getSharedEv_block_invoke()
{
  uint64_t v0;
  IOHIDManagerRef v1;
  _anonymous_namespace_ *v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  char *v10;
  _anonymous_namespace_ **v11;
  _anonymous_namespace_ *v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;

  v0 = operator new();
  *(_OWORD *)v0 = 0u;
  *(_OWORD *)(v0 + 16) = 0u;
  *(_QWORD *)(v0 + 32) = 0;
  v1 = IOHIDManagerCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], 0);
  *(_QWORD *)(v0 + 8) = v1;
  if (v1)
  {
    *(_BYTE *)v0 = 1;
    re::internal::HIDManager::getShared(void)::sharedInstance = v0;
    v2 = (_anonymous_namespace_ *)operator new();
    *(_QWORD *)v2 = &off_24ED7D730;
    v3 = (_QWORD *)qword_25582A258;
    if (qword_25582A258 >= (unint64_t)qword_25582A260)
    {
      v7 = v6 + 1;
      if ((unint64_t)(v6 + 1) >> 61)
        abort();
        v7 = v8 >> 2;
      if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8)
        v9 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v9 = v7;
      if (v9)
      {
        if (v9 >> 61)
          std::__throw_bad_array_new_length[abi:nn180100]();
        v10 = (char *)operator new(8 * v9);
      }
      else
      {
        v10 = 0;
      }
      v11 = (_anonymous_namespace_ **)&v10[8 * v6];
      *v11 = v2;
      v4 = (uint64_t)(v11 + 1);
      if (v3 == (_QWORD *)v5)
      {
        qword_25582A258 = (uint64_t)(v11 + 1);
        qword_25582A260 = (uint64_t)&v10[8 * v9];
      }
      else
      {
        do
        {
          v12 = (_anonymous_namespace_ *)*--v3;
          *v3 = 0;
          *--v11 = v12;
        }
        while (v3 != (_QWORD *)v5);
        v13 = (_QWORD *)qword_25582A258;
        qword_25582A258 = v4;
        qword_25582A260 = (uint64_t)&v10[8 * v9];
        while (v13 != v3)
        {
          v15 = *--v13;
          v14 = v15;
          *v13 = 0;
          if (v15)
            (*(void (**)(uint64_t))(*(_QWORD *)v14 + 8))(v14);
        }
      }
      if (v3)
        operator delete(v3);
    }
    else
    {
      *(_QWORD *)qword_25582A258 = v2;
      v4 = (uint64_t)(v3 + 1);
    }
    qword_25582A258 = v4;
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%s: IOHIDManagerCreate() failed.\n", "BOOL re::internal::HIDManager::init()");
  }
}

void `anonymous namespace'::deviceFactories(_anonymous_namespace_ *this)
{
  unsigned __int8 v1;

  if ((v1 & 1) == 0)
  {
    {
      qword_25582A258 = 0;
      qword_25582A260 = 0;
    }
  }
}

void re::internal::HIDManager::stop(re::internal::HIDManager *this)
{
  int v2;
  int v3;
  __IOHIDManager *v4;
  __CFRunLoop *Current;

  v2 = *((_DWORD *)this + 1);
  if (!v2)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%s: Unbalanced HIDManager.stop() call.\n", "void re::internal::HIDManager::stop()");
    v2 = *((_DWORD *)this + 1);
  }
  v3 = v2 - 1;
  *((_DWORD *)this + 1) = v3;
  if (!v3)
  {
    IOHIDManagerClose(*((IOHIDManagerRef *)this + 1), 0);
    v4 = (__IOHIDManager *)*((_QWORD *)this + 1);
    Current = CFRunLoopGetCurrent();
    IOHIDManagerUnscheduleFromRunLoop(v4, Current, (CFStringRef)*MEMORY[0x24BDBD5A0]);
    IOHIDManagerRegisterDeviceMatchingCallback(*((IOHIDManagerRef *)this + 1), (IOHIDDeviceCallback)re::internal::HIDManager::nullCallback, 0);
    IOHIDManagerRegisterDeviceRemovalCallback(*((IOHIDManagerRef *)this + 1), (IOHIDDeviceCallback)re::internal::HIDManager::nullCallback, 0);
  }
}

uint64_t re::internal::HIDManager::start(uint64_t this)
{
  unsigned int v1;
  IOHIDManagerRef *v2;
  _anonymous_namespace_ *Mutable;
  const __CFArray *v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  __IOHIDManager *v8;
  __CFRunLoop *Current;

  v1 = *(_DWORD *)(this + 4) + 1;
  *(_DWORD *)(this + 4) = v1;
  if (v1 <= 1)
  {
    v2 = (IOHIDManagerRef *)this;
    {
      return fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%s: No HID device factories registered.\n");
    }
    else
    {
      Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD690]);
      if (Mutable)
      {
        v4 = Mutable;
        v5 = qword_25582A258;
        while (v6 != (uint64_t *)v5)
        {
          v7 = *v6++;
          (*(void (**)(uint64_t, const __CFArray *))(*(_QWORD *)v7 + 16))(v7, v4);
        }
        IOHIDManagerSetDeviceMatchingMultiple(v2[1], v4);
        CFRelease(v4);
        IOHIDManagerRegisterDeviceMatchingCallback(v2[1], (IOHIDDeviceCallback)re::internal::HIDManager::deviceMatchingCallback, v2);
        IOHIDManagerRegisterDeviceRemovalCallback(v2[1], (IOHIDDeviceCallback)re::internal::HIDManager::deviceRemovalCallback, v2);
        v8 = v2[1];
        Current = CFRunLoopGetCurrent();
        IOHIDManagerScheduleWithRunLoop(v8, Current, (CFStringRef)*MEMORY[0x24BDBD5A0]);
        this = IOHIDManagerOpen(v2[1], 0);
        if ((_DWORD)this)
        {
          this = fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%s: IOHIDManagerOpen() failed.\n", "void re::internal::HIDManager::start()");
          *(_BYTE *)v2 = 0;
        }
      }
      else
      {
        return fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%s: CFArrayCreateMutable() failed.\n");
      }
    }
  }
  return this;
}

void re::internal::HIDManager::deviceMatchingCallback(re::internal::HIDManager *this, void *a2, int a3, __IOHIDDevice *a4, __IOHIDDevice *a5)
{
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  void *v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  char *v19;
  char *v20;
  void *v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  void *context;

  v8 = qword_25582A258;
  while (v7 != (_QWORD *)v8)
  {
    (*(void (**)(void **__return_ptr, _QWORD, __IOHIDDevice *))(*(_QWORD *)*v7 + 24))(&context, *v7, a4);
    if (context)
    {
      IOHIDDeviceRegisterInputValueCallback(a4, (IOHIDValueCallback)re::internal::HIDManager::inputValueCallback, context);
      v10 = (_QWORD *)*((_QWORD *)this + 3);
      v9 = *((_QWORD *)this + 4);
      if ((unint64_t)v10 >= v9)
      {
        v13 = (_QWORD *)*((_QWORD *)this + 2);
        v14 = v10 - v13;
        v15 = v14 + 1;
        if ((unint64_t)(v14 + 1) >> 61)
          abort();
        v16 = v9 - (_QWORD)v13;
        if (v16 >> 2 > v15)
          v15 = v16 >> 2;
        if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8)
          v17 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v17 = v15;
        if (v17)
        {
          if (v17 >> 61)
            std::__throw_bad_array_new_length[abi:nn180100]();
          v18 = (char *)operator new(8 * v17);
        }
        else
        {
          v18 = 0;
        }
        v19 = &v18[8 * v14];
        v20 = &v18[8 * v17];
        v21 = context;
        context = 0;
        *(_QWORD *)v19 = v21;
        v12 = v19 + 8;
        if (v10 == v13)
        {
          *((_QWORD *)this + 2) = v19;
          *((_QWORD *)this + 3) = v12;
          *((_QWORD *)this + 4) = v20;
        }
        else
        {
          do
          {
            v22 = *--v10;
            *v10 = 0;
            *((_QWORD *)v19 - 1) = v22;
            v19 -= 8;
          }
          while (v10 != v13);
          v10 = (_QWORD *)*((_QWORD *)this + 2);
          v23 = (_QWORD *)*((_QWORD *)this + 3);
          *((_QWORD *)this + 2) = v19;
          *((_QWORD *)this + 3) = v12;
          *((_QWORD *)this + 4) = v20;
          while (v23 != v10)
          {
            v25 = *--v23;
            v24 = v25;
            *v23 = 0;
            if (v25)
              (*(void (**)(uint64_t))(*(_QWORD *)v24 + 8))(v24);
          }
        }
        if (v10)
          operator delete(v10);
      }
      else
      {
        v11 = context;
        context = 0;
        *v10 = v11;
        v12 = v10 + 1;
      }
      *((_QWORD *)this + 3) = v12;
      v26 = context;
      context = 0;
      if (v26)
        (*(void (**)(void *))(*(_QWORD *)v26 + 8))(v26);
      return;
    }
    ++v7;
  }
}

void re::internal::HIDManager::deviceRemovalCallback(re::internal::HIDManager *this, void *a2, int a3, IOHIDDeviceRef device, __IOHIDDevice *a5)
{
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  IOHIDDeviceRegisterInputValueCallback(device, 0, 0);
  v7 = (_QWORD *)*((_QWORD *)this + 2);
  v8 = (_QWORD *)*((_QWORD *)this + 3);
  if (v7 != v8)
  {
    v9 = 0;
    while (*(IOHIDDeviceRef *)(v7[v9] + 8) != device)
    {
      if (&v7[++v9] == v8)
        return;
    }
    v10 = &v7[v9];
    v11 = &v7[v9 + 1];
    if (v11 != v8)
    {
      do
      {
        v12 = *(v11 - 1);
        *(v11 - 1) = *v11;
        *v11 = 0;
        if (v12)
          (*(void (**)(uint64_t))(*(_QWORD *)v12 + 8))(v12);
        ++v11;
      }
      while (v11 != v8);
      v8 = (_QWORD *)*((_QWORD *)this + 3);
      v10 = v11 - 1;
    }
    while (v8 != v10)
    {
      v14 = *--v8;
      v13 = v14;
      *v8 = 0;
      if (v14)
        (*(void (**)(uint64_t))(*(_QWORD *)v13 + 8))(v13);
    }
    *((_QWORD *)this + 3) = v10;
  }
}

uint64_t re::internal::HIDManager::inputValueCallback(re::internal::HIDManager *this, void *a2, int a3, IOHIDValueRef value, __IOHIDValue *a5)
{
  return re::internal::HIDDevice::handleInput(this, value);
}

__CFDictionary *re::internal::createDeviceMatchingDictionary(re::internal *this, int a2)
{
  const __CFAllocator *v2;
  __CFDictionary *Mutable;
  CFNumberRef v4;
  CFNumberRef v5;
  CFNumberRef v6;
  CFNumberRef v7;
  int v9;
  int valuePtr;

  v9 = a2;
  valuePtr = (int)this;
  v2 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x24BDBD240], 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!Mutable)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%s: CFDictionaryCreateMutable failed.\n", "CFMutableDictionaryRef re::internal::createDeviceMatchingDictionary(UInt32, UInt32)");
    return Mutable;
  }
  v4 = CFNumberCreate(v2, kCFNumberIntType, &valuePtr);
  if (!v4)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%s: CFNumberCreate(usage page) failed.\n");
    return 0;
  }
  v5 = v4;
  CFDictionarySetValue(Mutable, CFSTR("PrimaryUsagePage"), v4);
  CFRelease(v5);
  v6 = CFNumberCreate(v2, kCFNumberIntType, &v9);
  if (!v6)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%s: CFNumberCreate(usage) failed.\n");
    return 0;
  }
  v7 = v6;
  CFDictionarySetValue(Mutable, CFSTR("PrimaryUsage"), v6);
  CFRelease(v7);
  return Mutable;
}

uint64_t re::internal::getDevicePropertyInt(re::internal *this, const __CFString *a2, const __CFString *a3)
{
  const __CFNumber *Property;
  const __CFNumber *v4;
  CFTypeID v5;
  CFTypeID TypeID;
  uint64_t result;
  unsigned int valuePtr;

  if (!this)
    return 0xFFFFFFFFLL;
  Property = (const __CFNumber *)IOHIDDeviceGetProperty(this, a2);
  if (!Property)
    return 0xFFFFFFFFLL;
  v4 = Property;
  v5 = CFGetTypeID(Property);
  TypeID = CFNumberGetTypeID();
  result = 0xFFFFFFFFLL;
  if (v5 == TypeID)
  {
    valuePtr = -1;
    if (CFNumberGetValue(v4, kCFNumberSInt32Type, &valuePtr))
      return valuePtr;
    else
      return 0xFFFFFFFFLL;
  }
  return result;
}

__IOHIDDevice *re::internal::getDevicePropertyString(__IOHIDDevice *this, const __CFString *a2, const __CFString *a3)
{
  __IOHIDDevice *v3;
  CFTypeID v4;

  if (this)
  {
    this = (__IOHIDDevice *)IOHIDDeviceGetProperty(this, a2);
    if (this)
    {
      v3 = this;
      v4 = CFGetTypeID(this);
      if (v4 == CFStringGetTypeID())
        return v3;
      else
        return 0;
    }
  }
  return this;
}

re::TypeBuilder *re::TypeBuilder::TypeBuilder(re::TypeBuilder *this, re::Allocator *a2)
{
  *(_BYTE *)this = 0;
  re::StringID::invalid((re::TypeBuilder *)((char *)this + 8));
  *((_DWORD *)this + 6) = -1;
  *((_BYTE *)this + 28) = 0;
  *((_QWORD *)this + 25) = 0;
  *((_QWORD *)this + 26) = 0;
  *((_DWORD *)this + 54) = 0;
  *((_QWORD *)this + 48) = 0;
  *((_BYTE *)this + 392) = 0;
  *(_OWORD *)((char *)this + 440) = 0u;
  *(_OWORD *)((char *)this + 456) = 0u;
  *((_DWORD *)this + 118) = 0;
  *((_OWORD *)this + 14) = 0u;
  *((_OWORD *)this + 15) = 0u;
  *((_DWORD *)this + 64) = 0;
  *(_OWORD *)((char *)this + 264) = 0u;
  *(_OWORD *)((char *)this + 280) = 0u;
  *((_DWORD *)this + 74) = 0;
  *((_OWORD *)this + 19) = 0u;
  *((_OWORD *)this + 20) = 0u;
  *((_DWORD *)this + 84) = 0;
  *((_DWORD *)this + 94) = 0;
  *(_OWORD *)((char *)this + 344) = 0u;
  *(_OWORD *)((char *)this + 360) = 0u;
  *(_QWORD *)((char *)this + 476) = 0x7FFFFFFFLL;
  *((_QWORD *)this + 24) = a2;
  re::DynamicArray<re::Pair<unsigned long,re::StringID,true>>::setCapacity((_QWORD *)this + 24, 0);
  ++*((_DWORD *)this + 54);
  *((_QWORD *)this + 29) = a2;
  re::DynamicArray<re::Pair<unsigned long,re::StringID,true>>::setCapacity((_QWORD *)this + 29, 0);
  ++*((_DWORD *)this + 64);
  *((_QWORD *)this + 34) = a2;
  re::DynamicArray<float *>::setCapacity((_QWORD *)this + 34, 0);
  ++*((_DWORD *)this + 74);
  *((_QWORD *)this + 39) = a2;
  re::DynamicArray<re::internal::ObjectMemberInfo>::setCapacity((_QWORD *)this + 39, 0);
  ++*((_DWORD *)this + 84);
  *((_QWORD *)this + 44) = a2;
  re::DynamicArray<re::BlendParameterInputNode>::setCapacity((_QWORD *)this + 44, 0);
  ++*((_DWORD *)this + 94);
  re::HashTable<re::internal::TypeAttributeKey,re::internal::TypeAttributeData,re::Hash<re::internal::TypeAttributeKey>,re::EqualTo<re::internal::TypeAttributeKey>,true,false>::init((uint64_t)this + 440, (uint64_t)a2, 3);
  return this;
}

void re::HashTable<re::internal::TypeAttributeKey,re::internal::TypeAttributeData,re::Hash<re::internal::TypeAttributeKey>,re::EqualTo<re::internal::TypeAttributeKey>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 56 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &memset_pattern_27, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

void re::TypeBuilder::~TypeBuilder(re::TypeBuilder *this, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;

  re::TypeBuilder::reset(this, a2);
  re::DynamicArray<re::Pair<unsigned long,re::StringID,true>>::deinit((uint64_t)this + 192);
  re::DynamicArray<re::Pair<unsigned long,re::StringID,true>>::deinit((uint64_t)this + 232);
  v3 = (_QWORD *)((char *)this + 272);
  v4 = *((_QWORD *)this + 34);
  if (v4)
  {
    if (*((_QWORD *)this + 38))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *((_QWORD *)this + 38) = 0;
    *((_QWORD *)this + 35) = 0;
    *((_QWORD *)this + 36) = 0;
    *v3 = 0;
    ++*((_DWORD *)this + 74);
  }
  re::DynamicArray<re::GeomDeformer::Attribute>::deinit((uint64_t)this + 312);
  re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)this + 352);
  re::HashTable<re::Pair<re::StringSlice,re::StringSlice,true>,unsigned long,re::Hash<re::Pair<re::StringSlice,re::StringSlice,true>>,re::EqualTo<re::Pair<re::StringSlice,re::StringSlice,true>>,true,false>::deinit((uint64_t *)this + 55);
  re::HashTable<re::Pair<re::StringSlice,re::StringSlice,true>,unsigned long,re::Hash<re::Pair<re::StringSlice,re::StringSlice,true>>,re::EqualTo<re::Pair<re::StringSlice,re::StringSlice,true>>,true,false>::deinit((uint64_t *)this + 55);
  if (*((_BYTE *)this + 392))
    re::StringID::destroyString((re::TypeBuilder *)((char *)this + 408));
  re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)this + 352);
  re::DynamicArray<re::GeomDeformer::Attribute>::deinit((uint64_t)this + 312);
  if (*v3)
  {
    if (*((_QWORD *)this + 38))
      (*(void (**)(_QWORD))(*(_QWORD *)*v3 + 40))(*v3);
    *((_QWORD *)this + 38) = 0;
    *((_QWORD *)this + 35) = 0;
    *((_QWORD *)this + 36) = 0;
    *v3 = 0;
    ++*((_DWORD *)this + 74);
  }
  re::DynamicArray<re::Pair<unsigned long,re::StringID,true>>::deinit((uint64_t)this + 232);
  re::DynamicArray<re::Pair<unsigned long,re::StringID,true>>::deinit((uint64_t)this + 192);
  re::StringID::destroyString((re::TypeBuilder *)((char *)this + 8));
}

void re::TypeBuilder::reset(re::TypeBuilder *this, uint64_t a2)
{
  uint64_t v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  _QWORD v9[2];
  uint64_t v10;

  switch(*(_BYTE *)this)
  {
    case 0:
      return;
    case 1:
    case 3:
    case 4:
    case 5:
    case 6:
    case 9:
      goto LABEL_2;
    case 2:
      re::DynamicArray<re::EnumConstant>::clear((uint64_t)this + 192);
      re::DynamicArray<re::EnumConstant>::clear((uint64_t)this + 232);
      goto LABEL_2;
    case 7:
      *((_QWORD *)this + 36) = 0;
      ++*((_DWORD *)this + 74);
      goto LABEL_2;
    case 8:
      re::StringID::destroyString((re::TypeBuilder *)((char *)this + 136));
      re::DynamicArray<re::GeomDeformer::Attribute>::clear((uint64_t)this + 312);
      re::DynamicArray<re::MeshAssetSmoothDeformerData>::clear((uint64_t)this + 352);
      LOBYTE(v9[0]) = 0;
      re::Optional<re::internal::ObjectMemberInfo>::operator=((uint64_t)this + 392, (unsigned __int8 *)v9);
      if (LOBYTE(v9[0]))
        re::StringID::destroyString((re::StringID *)&v10);
LABEL_2:
      *(_BYTE *)this = 0;
      re::StringID::invalid((re::StringID *)&v7);
      v3 = v7;
      v4 = v8;
      v7 = 0;
      v8 = &str_110;
      v5 = *((_QWORD *)this + 1);
      v6 = *((_QWORD *)this + 2);
      *((_QWORD *)this + 1) = v3;
      *((_QWORD *)this + 2) = v4;
      v9[0] = v3 & 0xFFFFFFFFFFFFFFFELL | v5 & 1;
      v9[1] = v6;
      re::StringID::destroyString((re::StringID *)v9);
      re::StringID::destroyString((re::StringID *)&v7);
      *((_DWORD *)this + 6) = -1;
      if (*((_BYTE *)this + 28))
        *((_BYTE *)this + 28) = 0;
      re::HashTable<re::internal::TypeAttributeKey,re::internal::TypeAttributeData,re::Hash<re::internal::TypeAttributeKey>,re::EqualTo<re::internal::TypeAttributeKey>,true,false>::clear((uint64_t)this + 440);
      return;
    default:
      re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Unknown type category.", "!\"Unreachable code\"", "reset", 77);
      _os_crash();
      __break(1u);
      JUMPOUT(0x225B6538CLL);
  }
}

void re::DynamicArray<re::EnumConstant>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  re::StringID *v4;

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  if (v2)
  {
    v3 = 24 * v2;
    v4 = (re::StringID *)(*(_QWORD *)(a1 + 32) + 8);
    do
    {
      re::StringID::destroyString(v4);
      v4 = (re::StringID *)((char *)v4 + 24);
      v3 -= 24;
    }
    while (v3);
  }
  ++*(_DWORD *)(a1 + 24);
}

uint64_t re::Optional<re::internal::ObjectMemberInfo>::operator=(uint64_t a1, unsigned __int8 *a2)
{
  int v3;
  BOOL v4;
  BOOL v5;
  BOOL v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD v15[2];

  v3 = *a2;
  if (*(_BYTE *)a1)
    v4 = 0;
  else
    v4 = v3 == 0;
  if (!v4)
  {
    if (*(_BYTE *)a1)
      v5 = v3 == 0;
    else
      v5 = 0;
    if (v5)
    {
      re::StringID::destroyString((re::StringID *)(a1 + 16));
      *(_BYTE *)a1 = 0;
    }
    else
    {
      if (*(_BYTE *)a1)
        v7 = 1;
      else
        v7 = v3 == 0;
      if (v7)
      {
        *(_QWORD *)(a1 + 8) = *((_QWORD *)a2 + 1);
        v8 = *((_QWORD *)a2 + 2);
        v9 = *((_QWORD *)a2 + 3);
        *((_QWORD *)a2 + 2) = 0;
        *((_QWORD *)a2 + 3) = &str_110;
        v10 = *(_QWORD *)(a1 + 16);
        v11 = *(_QWORD *)(a1 + 24);
        *(_QWORD *)(a1 + 16) = v8;
        *(_QWORD *)(a1 + 24) = v9;
        v15[0] = v8 & 0xFFFFFFFFFFFFFFFELL | v10 & 1;
        v15[1] = v11;
        re::StringID::destroyString((re::StringID *)v15);
      }
      else
      {
        *(_BYTE *)a1 = 1;
        *(_QWORD *)(a1 + 8) = *((_QWORD *)a2 + 1);
        v12 = *((_QWORD *)a2 + 2);
        *(_QWORD *)(a1 + 16) = *(_QWORD *)(a1 + 16) & 0xFFFFFFFFFFFFFFFELL | v12 & 1;
        *(_QWORD *)(a1 + 16) = *((_QWORD *)a2 + 2) & 0xFFFFFFFFFFFFFFFELL | v12 & 1;
        *(_QWORD *)(a1 + 24) = *((_QWORD *)a2 + 3);
        *((_QWORD *)a2 + 2) = 0;
        *((_QWORD *)a2 + 3) = &str_110;
      }
      v13 = *((_QWORD *)a2 + 4);
      *(_DWORD *)(a1 + 40) = *((_DWORD *)a2 + 10);
      *(_QWORD *)(a1 + 32) = v13;
    }
  }
  return a1;
}

void re::HashTable<re::internal::TypeAttributeKey,re::internal::TypeAttributeData,re::Hash<re::internal::TypeAttributeKey>,re::EqualTo<re::internal::TypeAttributeKey>,true,false>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;

  if (*(_DWORD *)(a1 + 28))
  {
    v2 = *(unsigned int *)(a1 + 24);
    if ((_DWORD)v2)
      memset_pattern16(*(void **)(a1 + 8), &memset_pattern_202, 4 * v2);
    v3 = *(unsigned int *)(a1 + 32);
    if ((_DWORD)v3)
    {
      v4 = 0;
      v5 = 56 * v3;
      do
      {
        v6 = *(_QWORD *)(a1 + 16) + v4;
        v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
        v4 += 56;
      }
      while (v5 != v4);
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    v8 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v8;
  }
}

void re::TypeBuilder::commitTo(re::TypeBuilder *this@<X0>, re::TypeRegistry *a2@<X1>, _QWORD *a3@<X8>)
{
  __int128 v5;

  if (*(_BYTE *)this)
  {
    re::TypeRegistry::declareType((uint64_t)a2, *(unsigned __int8 *)this, (StringID *)((char *)this + 8), *((_DWORD *)this + 6), 0, a3);
    if (*a3)
    {
      v5 = *(_OWORD *)a3;
      re::TypeBuilder::commitTo((unsigned __int8 *)this, (uint64_t *)&v5);
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) beginXxxType() needs to be called before calling this function.", "isBuilding()", "commitTo", 102);
    _os_crash();
    __break(1u);
  }
}

void re::TypeBuilder::commitTo(unsigned __int8 *a1, uint64_t *a2)
{
  unsigned __int8 *v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unsigned __int8 *v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  _anonymous_namespace_ *v13;
  uint64_t v14;
  unsigned int v15;
  unint64_t v16;
  _OWORD *v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  StringID *v29;
  uint64_t v30;
  char *v31;
  char *v32;
  unint64_t v33;
  uint64_t v34;
  StringID *v35;
  uint64_t v36;
  char *v37;
  char *v38;
  unint64_t v39;
  uint64_t v40;
  StringID *v41;
  uint64_t v42;
  char *v43;
  char *var1;
  unint64_t v45;
  uint64_t v46;
  StringID *v47;
  uint64_t v48;
  char *v49;
  char *v50;
  unint64_t v51;
  NSObject *v52;
  uint64_t v53;
  uint64_t v54;
  _QWORD *v55;
  uint64_t v56;
  _QWORD *v57;
  uint64_t v58;
  uint64_t v59;
  _QWORD *v60;
  _anonymous_namespace_ *v61;
  unint64_t *v62;
  uint64_t v63;
  unint64_t v64;
  unint64_t v65;
  unint64_t v66;
  uint64_t v67;
  unint64_t v68;
  unint64_t v69;
  _anonymous_namespace_ *v70;
  unint64_t v71;
  unint64_t v72;
  unint64_t v73;
  uint64_t v74;
  unint64_t v75;
  unint64_t v76;
  char v77;
  uint64_t v78;
  unint64_t v79;
  unint64_t v80;
  unint64_t v81;
  uint64_t v82;
  unint64_t v83;
  unint64_t v84;
  unint64_t v85;
  unint64_t v86;
  unint64_t v87;
  uint64_t v88;
  unint64_t v89;
  unint64_t v90;
  _anonymous_namespace_ *v91;
  uint64_t v92;
  unint64_t v93;
  unint64_t v94;
  unint64_t v95;
  uint64_t v96;
  unint64_t v97;
  unint64_t v98;
  int v99;
  BOOL v100;
  int v101;
  int v102;
  unint64_t v103;
  unint64_t v104;
  unint64_t v105;
  uint64_t v106;
  unint64_t v107;
  unint64_t v108;
  unint64_t v109;
  unint64_t v110;
  unint64_t v111;
  uint64_t v112;
  unint64_t v113;
  unint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  _DWORD *v119;
  uint64_t v120;
  unsigned int v121;
  unsigned int v122;
  int v123;
  unsigned int *v124;
  uint64_t v125;
  uint64_t v126;
  unint64_t v127;
  unint64_t v128;
  unint64_t v129;
  unint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  unint64_t v134;
  unint64_t v135;
  unint64_t *v136;
  unint64_t v137;
  uint64_t v138;
  uint64_t v139;
  re::StringID *v140;
  re::StringID *v141;
  uint64_t v142;
  unint64_t *v143;
  unsigned int v144;
  unint64_t v145;
  unint64_t v146;
  unint64_t v147;
  unsigned __int8 *v148;
  uint64_t v149;
  re::StringID *v150;
  uint64_t v151;
  unint64_t v152;
  unint64_t v153;
  unint64_t *v154;
  _anonymous_namespace_ *v155;
  unint64_t v156;
  uint64_t v157;
  unint64_t *v158;
  re::StringID *v159;
  uint64_t v160;
  re::StringID *v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  __int128 v165;
  unint64_t v166;
  __int128 v167;
  uint64_t v168;
  int v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  __int128 v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  unint64_t v178;
  uint64_t v179;
  __int128 v180;
  __int128 v181;
  __int128 v182;
  __int128 v183;
  int v184;
  _BYTE *v185;
  int v186;
  unint64_t v187;
  uint64_t v188;
  uint64_t v189;
  __int128 v190;
  __int128 v191;
  __int128 v192;
  __int128 v193;
  int v194;
  __int128 v195;
  __int128 v196;
  __int128 v197;
  uint64_t v198;
  __int128 v199;
  int v200;
  _OWORD *v201;
  uint64_t v202;
  __int128 v203;
  __int128 v204;
  __int128 v205;
  _OWORD *v206;
  __int128 v207;
  __int128 v208;
  __int128 v209;
  __int128 v210;
  _OWORD *v211;
  __int128 v212;
  __int128 v213;
  __int128 v214;
  __int128 v215;
  __int128 v216;
  __int128 v217;
  _OWORD *v218;
  __int128 v219;
  __int128 v220;
  __int128 v221;
  __int128 v222;
  __int128 v223;
  __int128 v224;
  __int128 v225;
  uint64_t v226;
  __int128 v227;
  __int128 v228;
  __int128 v229;
  __int128 v230;
  __int128 v231;
  _OWORD *v232;
  __int128 v233;
  __int128 v234;
  __int128 v235;
  __int128 v236;
  _OWORD *v237;
  __int128 v238;
  __int128 v239;
  __int128 v240;
  __int128 v241;
  unint64_t v242;
  uint64_t v243;
  uint64_t v244;
  unint64_t v245;
  BOOL v246;
  unint64_t v247;
  uint64_t v248;
  unint64_t v249;
  uint64_t v250;
  _QWORD *v251;
  uint64_t v252;
  unint64_t v253;
  _OWORD *v254;
  __int128 v255;
  __int128 v256;
  __int128 v257;
  __int128 v258;
  unint64_t v259;
  unint64_t v260;
  uint64_t v261;
  char *v262;
  unint64_t v263;
  uint64_t v264;
  unint64_t v265;
  unint64_t v266;
  uint64_t v267;
  unint64_t v268;
  char *v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t v272;
  int v273;
  uint64_t v274;
  int v275;
  uint64_t v276;
  uint64_t v277;
  int *v278;
  int v279;
  uint64_t v280;
  _QWORD *v281;
  uint64_t v282;
  uint64_t v283;
  unint64_t v284;
  unint64_t v285;
  unint64_t v286;
  unint64_t v287;
  uint64_t v288;
  uint64_t v289;
  int v290;
  int v291;
  uint64_t *v292;
  uint64_t v293;
  _anonymous_namespace_ *v294;
  _anonymous_namespace_ *v295;
  _anonymous_namespace_ *v296;
  _anonymous_namespace_ *v297;
  _QWORD *v298;
  uint64_t v299;
  uint64_t v300;
  uint64_t v301;
  uint64_t v302;
  char *v303;
  char v304;
  uint64_t v305;
  uint64_t v306;
  int v307;
  const char *v308;
  __int16 v309;
  int v310;
  __int16 v311;
  unint64_t v312;
  __int16 v313;
  unint64_t v314;
  uint8_t buf[16];
  __int128 v316;
  __int128 v317;
  __int128 v318;
  __int128 v319;
  uint64_t v320;

  v320 = *MEMORY[0x24BDAC8D0];
  if (!*a1)
  {
LABEL_354:
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) beginXxxType() needs to be called before calling commitTo().", "isBuilding()", "commitTo", 118);
    _os_crash();
    __break(1u);
    goto LABEL_355;
  }
  v4 = (unint64_t)a2;
  if (!*a2)
  {
LABEL_355:
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Invalid type ID.", "typeID.isValid()", "commitTo", 119);
    _os_crash();
    __break(1u);
    goto LABEL_356;
  }
  v2 = a1;
  v3 = *((unsigned int *)a1 + 6);
  v299 = *a2;
  v9 = re::DataArray<re::TextureAtlasTile>::tryGet(*a2 + 96, a2[1]);
  if (v9)
    v11 = *(_DWORD *)(v9 + 16);
  else
    v11 = -1;
  if ((_DWORD)v3 != v11)
  {
LABEL_356:
    re::internal::assertLog((re::internal *)4, v10, "assertion failure: '%s' (%s:line %i) Type version mismatch.", "m_version == registry->typeVersion(typeID)", "commitTo", 124);
    _os_crash();
    __break(1u);
LABEL_357:
    v16 = v299;
    re::TypeRegistry::typeName(v299, *(_QWORD *)(v3 + 152 * v5));
    v292 = re::TypeRegistry::typeName(v299, *(_QWORD *)(v3 + 152 * v5));
    re::internal::assertLog((re::internal *)6, v293, "assertion failure: '%s' (%s:line %i) Duplicate custom class IDs in inheritance tree. Classes \"%s\" and \"%s\".", "objectType.customClassID.value() != m_objectTypeInfo.customClassID.value()", "commitTo", 377, v292[1], *((_QWORD *)v2 + 2));
    _os_crash();
    __break(1u);
    goto LABEL_358;
  }
  v3 = v299;
  v12 = v299 + 32;
  v13 = (_anonymous_namespace_ *)re::DataArray<re::internal::TypeInfoIndex>::get(v299 + 32, *(_QWORD *)(v4 + 8));
  v15 = *v2;
  if (v15 > 9)
    goto LABEL_377;
  v16 = (unint64_t)v13;
  if (((1 << v15) & 0x2FA) == 0)
  {
    if (v15 == 2)
    {
      v40 = *((_QWORD *)v2 + 26);
      if (v40)
      {
        v6 = 24 * v40;
        v41 = (StringID *)(*((_QWORD *)v2 + 28) + 8);
        v7 = (unint64_t)&str_110;
        do
        {
          re::TypeRegistry::makeStringID((re::TypeRegistry *)v299, v41, (re::StringID *)&v302);
          v42 = v302;
          v43 = v303;
          v302 = 0;
          v303 = (char *)&str_110;
          var1 = v41->var1;
          v45 = v42 & 0xFFFFFFFFFFFFFFFELL | *(_QWORD *)&v41->var0 & 1;
          v41->var1 = v43;
          *(_QWORD *)buf = v45;
          *(_QWORD *)&buf[8] = var1;
          *(_QWORD *)&v41->var0 = v42;
          v41 = (StringID *)((char *)v41 + 24);
          re::StringID::destroyString((re::StringID *)buf);
          re::StringID::destroyString((re::StringID *)&v302);
          v6 -= 24;
        }
        while (v6);
      }
      v46 = *((_QWORD *)v2 + 31);
      if (v46)
      {
        v6 = 24 * v46;
        v47 = (StringID *)(*((_QWORD *)v2 + 33) + 8);
        v7 = (unint64_t)&str_110;
        do
        {
          re::TypeRegistry::makeStringID((re::TypeRegistry *)v299, v47, (re::StringID *)&v302);
          v48 = v302;
          v49 = v303;
          v302 = 0;
          v303 = (char *)&str_110;
          v50 = v47->var1;
          v51 = v48 & 0xFFFFFFFFFFFFFFFELL | *(_QWORD *)&v47->var0 & 1;
          v47->var1 = v49;
          *(_QWORD *)buf = v51;
          *(_QWORD *)&buf[8] = v50;
          *(_QWORD *)&v47->var0 = v48;
          v47 = (StringID *)((char *)v47 + 24);
          re::StringID::destroyString((re::StringID *)buf);
          re::StringID::destroyString((re::StringID *)&v302);
          v6 -= 24;
        }
        while (v6);
      }
      goto LABEL_9;
    }
    if (v15 == 8)
    {
      re::TypeRegistry::makeStringID((re::TypeRegistry *)v299, (const StringID *)(v2 + 136), (re::StringID *)&v302);
      v24 = v302;
      v25 = v303;
      v6 = (unint64_t)&str_110;
      v302 = 0;
      v303 = (char *)&str_110;
      v26 = *((_QWORD *)v2 + 17);
      v27 = *((_QWORD *)v2 + 18);
      *((_QWORD *)v2 + 17) = v24;
      *((_QWORD *)v2 + 18) = v25;
      *(_QWORD *)buf = v24 & 0xFFFFFFFFFFFFFFFELL | v26 & 1;
      *(_QWORD *)&buf[8] = v27;
      re::StringID::destroyString((re::StringID *)buf);
      re::StringID::destroyString((re::StringID *)&v302);
      v28 = *((_QWORD *)v2 + 41);
      if (v28)
      {
        v7 = 40 * v28;
        v29 = (StringID *)(*((_QWORD *)v2 + 43) + 8);
        do
        {
          re::TypeRegistry::makeStringID((re::TypeRegistry *)v299, v29, (re::StringID *)&v302);
          v30 = v302;
          v31 = v303;
          v302 = 0;
          v303 = (char *)&str_110;
          v32 = v29->var1;
          v33 = v30 & 0xFFFFFFFFFFFFFFFELL | *(_QWORD *)&v29->var0 & 1;
          v29->var1 = v31;
          *(_QWORD *)buf = v33;
          *(_QWORD *)&buf[8] = v32;
          *(_QWORD *)&v29->var0 = v30;
          v29 = (StringID *)((char *)v29 + 40);
          re::StringID::destroyString((re::StringID *)buf);
          re::StringID::destroyString((re::StringID *)&v302);
          v7 -= 40;
        }
        while (v7);
      }
      v34 = *((_QWORD *)v2 + 46);
      if (v34)
      {
        v35 = (StringID *)*((_QWORD *)v2 + 48);
        v7 = (unint64_t)v35 + 24 * v34;
        do
        {
          re::TypeRegistry::makeStringID((re::TypeRegistry *)v299, v35, (re::StringID *)&v302);
          v36 = v302;
          v37 = v303;
          v302 = 0;
          v303 = (char *)&str_110;
          v38 = v35->var1;
          v39 = v36 & 0xFFFFFFFFFFFFFFFELL | *(_QWORD *)&v35->var0 & 1;
          v35->var1 = v37;
          *(_QWORD *)buf = v39;
          *(_QWORD *)&buf[8] = v38;
          *(_QWORD *)&v35->var0 = v36;
          v35 = (StringID *)((char *)v35 + 24);
          re::StringID::destroyString((re::StringID *)buf);
          re::StringID::destroyString((re::StringID *)&v302);
        }
        while (v35 != (StringID *)v7);
      }
      goto LABEL_9;
    }
LABEL_377:
    re::internal::assertLog((re::internal *)4, v14, "assertion failure: '%s' (%s:line %i) Unexpected type category.", "!\"Unreachable code\"", "internStrings", 1103);
    _os_crash();
    __break(1u);
    JUMPOUT(0x225B67B80);
  }
LABEL_9:
  if (*((_QWORD *)v2 + 6))
    v5 = 0;
  else
    v5 = *((_QWORD *)v2 + 7) == 0;
  *((_QWORD *)v2 + 4) = *(_QWORD *)(v4 + 8);
  v17 = v2 + 32;
  switch(*v2)
  {
    case 1u:
      *((_DWORD *)v2 + 20) |= v5 | 2;
      *(_DWORD *)v16 = *(_DWORD *)(v299 + 264) & 0xFFFFFF | (*(unsigned __int8 *)(v16 + 3) << 24);
      v18 = *(_QWORD *)(v299 + 256);
      v19 = *(_QWORD *)(v299 + 264);
      if (v19 >= v18)
      {
        v20 = v19 + 1;
        if (v18 < v19 + 1)
        {
          if (*(_QWORD *)(v299 + 248))
          {
            v21 = 2 * v18;
            v100 = v18 == 0;
            v22 = 8;
            if (!v100)
              v22 = v21;
            if (v22 <= v20)
              v23 = v20;
            else
              v23 = v22;
            re::DynamicArray<re::PipelineStateCacheKey>::setCapacity((_QWORD *)(v299 + 248), v23);
          }
          else
          {
            re::DynamicArray<re::PipelineStateCacheKey>::setCapacity((_QWORD *)(v299 + 248), v20);
            ++*(_DWORD *)(v299 + 272);
          }
        }
        v19 = *(_QWORD *)(v299 + 264);
      }
      v202 = *(_QWORD *)(v299 + 280) + 72 * v19;
      *(_OWORD *)v202 = *v17;
      v203 = *((_OWORD *)v2 + 3);
      v204 = *((_OWORD *)v2 + 4);
      v205 = *((_OWORD *)v2 + 5);
      *(_QWORD *)(v202 + 64) = *((_QWORD *)v2 + 12);
      *(_OWORD *)(v202 + 32) = v204;
      *(_OWORD *)(v202 + 48) = v205;
      *(_OWORD *)(v202 + 16) = v203;
      ++*(_QWORD *)(v299 + 264);
      ++*(_DWORD *)(v299 + 272);
      goto LABEL_321;
    case 2u:
      if (!*((_QWORD *)v2 + 26))
      {
        v52 = *re::foundationIntrospectionLogObjects(v13);
        if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
        {
          v53 = *((_QWORD *)v2 + 2);
          *(_DWORD *)buf = 136315138;
          *(_QWORD *)&buf[4] = v53;
          _os_log_impl(&dword_224FE9000, v52, OS_LOG_TYPE_DEFAULT, "Creating enum type \"%s\" without values.", buf, 0xCu);
        }
      }
      v54 = *((_QWORD *)v2 + 31);
      if (!v54)
        goto LABEL_49;
      v55 = (_QWORD *)*((_QWORD *)v2 + 33);
      v56 = *((_QWORD *)v2 + 26);
      if (!v56)
        goto LABEL_360;
      v57 = &v55[3 * v54];
      v58 = 24 * v56;
      do
      {
        v59 = v58;
        v60 = (_QWORD *)*((_QWORD *)v2 + 28);
        while (*v55 != *v60)
        {
          v60 += 3;
          v59 -= 24;
          if (!v59)
            goto LABEL_360;
        }
        v55 += 3;
      }
      while (v55 != v57);
LABEL_49:
      v61 = (_anonymous_namespace_ *)re::TypeRegistry::typeInfo((_QWORD *)v299, *((_QWORD *)v2 + 13), buf);
      *((_DWORD *)v2 + 20) |= v5 | 2;
      *(_DWORD *)v16 = *(_DWORD *)(v299 + 304) & 0xFFFFFF | (*(unsigned __int8 *)(v16 + 3) << 24);
      v62 = (unint64_t *)(v299 + 328);
      v63 = *((_QWORD *)v2 + 26);
      *((_DWORD *)v2 + 28) = *(_QWORD *)(v299 + 344);
      *((_DWORD *)v2 + 29) = v63;
      *((_DWORD *)v2 + 30) = *((_QWORD *)v2 + 31);
      v64 = *(_QWORD *)(v299 + 296);
      v65 = *(_QWORD *)(v299 + 304);
      if (v65 >= v64)
      {
        v66 = v65 + 1;
        if (v64 < v65 + 1)
        {
          if (*(_QWORD *)(v299 + 288))
          {
            v67 = 2 * v64;
            v100 = v64 == 0;
            v68 = 8;
            if (!v100)
              v68 = v67;
            if (v68 <= v66)
              v69 = v66;
            else
              v69 = v68;
            re::DynamicArray<re::internal::EnumTypeInfo>::setCapacity((_QWORD *)(v299 + 288), v69);
          }
          else
          {
            re::DynamicArray<re::internal::EnumTypeInfo>::setCapacity((_QWORD *)(v299 + 288), v66);
            ++*(_DWORD *)(v299 + 312);
          }
        }
        v65 = *(_QWORD *)(v299 + 304);
      }
      v237 = (_OWORD *)(*(_QWORD *)(v299 + 320) + 96 * v65);
      v238 = *((_OWORD *)v2 + 3);
      *v237 = *v17;
      v237[1] = v238;
      v239 = *((_OWORD *)v2 + 4);
      v240 = *((_OWORD *)v2 + 5);
      v241 = *((_OWORD *)v2 + 7);
      v237[4] = *((_OWORD *)v2 + 6);
      v237[5] = v241;
      v237[2] = v239;
      v237[3] = v240;
      ++*(_QWORD *)(v299 + 304);
      ++*(_DWORD *)(v299 + 312);
      v242 = *(_QWORD *)(v299 + 344);
      v243 = *((_QWORD *)v2 + 26);
      v244 = *((_QWORD *)v2 + 31);
      v245 = v243 + v242 + v244;
      v246 = v242 > v245;
      if (v242 >= v245)
      {
        v3 = v299;
        if (!v246)
          goto LABEL_277;
        v248 = v299;
        v252 = 24 * v245 + 8;
        v253 = v245;
        do
        {
          re::StringID::destroyString((re::StringID *)(*(_QWORD *)(v299 + 360) + v252));
          ++v253;
          v252 += 24;
        }
        while (v253 < *(_QWORD *)(v299 + 344));
      }
      else
      {
        v247 = *(_QWORD *)(v299 + 344);
        if (*(_QWORD *)(v299 + 336) < v245)
        {
          re::DynamicArray<re::Pair<unsigned long,re::StringID,true>>::setCapacity(v62, v243 + v242 + v244);
          v247 = *(_QWORD *)(v299 + 344);
        }
        v248 = v299;
        if (v247 < v245)
        {
          v249 = v243 + v242 + v244 - v247;
          v250 = 24 * v247;
          do
          {
            v251 = (_QWORD *)(*(_QWORD *)(v299 + 360) + v250);
            *v251 = 0;
            re::StringID::invalid((re::StringID *)(v251 + 1));
            v250 += 24;
            --v249;
          }
          while (v249);
        }
      }
      *(_QWORD *)(v248 + 344) = v245;
      ++*(_DWORD *)(v248 + 352);
      v243 = *((_QWORD *)v2 + 26);
      v3 = v248;
LABEL_277:
      re::DynamicArray<re::EnumConstant>::copy(v62, *((unsigned int *)v2 + 28), *((unint64_t **)v2 + 28), v243);
      re::DynamicArray<re::EnumConstant>::copy(v62, *((_QWORD *)v2 + 26) + *((unsigned int *)v2 + 28), *((unint64_t **)v2 + 33), *((_QWORD *)v2 + 31));
      goto LABEL_321;
    case 3u:
      v70 = (_anonymous_namespace_ *)re::TypeRegistry::typeInfo((_QWORD *)v299, *((_QWORD *)v2 + 13), buf);
      *(_DWORD *)v16 = *(_DWORD *)(v299 + 384) & 0xFFFFFF | (*(unsigned __int8 *)(v16 + 3) << 24);
      v71 = *(_QWORD *)(v299 + 376);
      v72 = *(_QWORD *)(v299 + 384);
      if (v72 >= v71)
      {
        v73 = v72 + 1;
        if (v71 < v72 + 1)
        {
          if (*(_QWORD *)(v299 + 368))
          {
            v74 = 2 * v71;
            v100 = v71 == 0;
            v75 = 8;
            if (!v100)
              v75 = v74;
            if (v75 <= v73)
              v76 = v73;
            else
              v76 = v75;
            re::DynamicArray<re::internal::EnumTypeInfo>::setCapacity((_QWORD *)(v299 + 368), v76);
          }
          else
          {
            re::DynamicArray<re::internal::EnumTypeInfo>::setCapacity((_QWORD *)(v299 + 368), v73);
            ++*(_DWORD *)(v299 + 392);
          }
        }
        v72 = *(_QWORD *)(v299 + 384);
      }
      v206 = (_OWORD *)(*(_QWORD *)(v299 + 400) + 96 * v72);
      v207 = *((_OWORD *)v2 + 3);
      *v206 = *v17;
      v206[1] = v207;
      v208 = *((_OWORD *)v2 + 4);
      v209 = *((_OWORD *)v2 + 5);
      v210 = *((_OWORD *)v2 + 7);
      v206[4] = *((_OWORD *)v2 + 6);
      v206[5] = v210;
      v206[2] = v208;
      v206[3] = v209;
      ++*(_QWORD *)(v299 + 384);
      ++*(_DWORD *)(v299 + 392);
      goto LABEL_321;
    case 4u:
      v77 = v5 ^ 1;
      if ((*((_DWORD *)v2 + 29) & 0xFFFFFF) != 0)
        v77 = 1;
      if ((v77 & 1) != 0)
      {
        if ((*((_DWORD *)v2 + 29) & 0xFFFFFF) != 0)
        {
LABEL_126:
          *(_DWORD *)v16 = *(_DWORD *)(v299 + 424) & 0xFFFFFF | (*(unsigned __int8 *)(v16 + 3) << 24);
          v109 = *(_QWORD *)(v299 + 416);
          v110 = *(_QWORD *)(v299 + 424);
          if (v110 >= v109)
          {
            v111 = v110 + 1;
            if (v109 < v110 + 1)
            {
              if (*(_QWORD *)(v299 + 408))
              {
                v112 = 2 * v109;
                v100 = v109 == 0;
                v113 = 8;
                if (!v100)
                  v113 = v112;
                if (v113 <= v111)
                  v114 = v111;
                else
                  v114 = v113;
                re::DynamicArray<re::internal::EnumTypeInfo>::setCapacity((_QWORD *)(v299 + 408), v114);
              }
              else
              {
                re::DynamicArray<re::internal::EnumTypeInfo>::setCapacity((_QWORD *)(v299 + 408), v111);
                ++*(_DWORD *)(v299 + 432);
              }
            }
            v110 = *(_QWORD *)(v299 + 424);
          }
          v232 = (_OWORD *)(*(_QWORD *)(v299 + 440) + 96 * v110);
          v233 = *((_OWORD *)v2 + 3);
          *v232 = *v17;
          v232[1] = v233;
          v234 = *((_OWORD *)v2 + 4);
          v235 = *((_OWORD *)v2 + 5);
          v236 = *((_OWORD *)v2 + 7);
          v232[4] = *((_OWORD *)v2 + 6);
          v232[5] = v236;
          v232[2] = v234;
          v232[3] = v235;
          ++*(_QWORD *)(v299 + 424);
          ++*(_DWORD *)(v299 + 432);
          goto LABEL_321;
        }
LABEL_124:
        v13 = (_anonymous_namespace_ *)re::TypeRegistry::typeInfo((_QWORD *)v299, *((_QWORD *)v2 + 13), buf);
        if ((*(_BYTE *)(*((_QWORD *)&v316 + 1) + 48) & 3) != 0)
          *((_DWORD *)v2 + 20) |= 2u;
        goto LABEL_126;
      }
      re::TypeRegistry::typeInfo((_QWORD *)v299, *((_QWORD *)v2 + 13), buf);
      if (buf[0])
      {
        if ((*(_DWORD *)(*((_QWORD *)&v316 + 1) + 48) & 1) != 0)
          *((_DWORD *)v2 + 20) |= 1u;
        goto LABEL_124;
      }
      goto LABEL_375;
    case 5u:
      *(_DWORD *)v16 = *(_DWORD *)(v299 + 464) & 0xFFFFFF | (*(unsigned __int8 *)(v16 + 3) << 24);
      v79 = *(_QWORD *)(v299 + 456);
      v80 = *(_QWORD *)(v299 + 464);
      if (v80 >= v79)
      {
        v81 = v80 + 1;
        if (v79 < v80 + 1)
        {
          if (*(_QWORD *)(v299 + 448))
          {
            v82 = 2 * v79;
            v100 = v79 == 0;
            v83 = 8;
            if (!v100)
              v83 = v82;
            if (v83 <= v81)
              v84 = v81;
            else
              v84 = v83;
            re::DynamicArray<re::internal::ListTypeInfo>::setCapacity((_QWORD *)(v299 + 448), v84);
          }
          else
          {
            re::DynamicArray<re::internal::ListTypeInfo>::setCapacity((_QWORD *)(v299 + 448), v81);
            ++*(_DWORD *)(v299 + 472);
          }
        }
        v80 = *(_QWORD *)(v299 + 464);
      }
      v211 = (_OWORD *)(*(_QWORD *)(v299 + 480) + (v80 << 7));
      v212 = *v17;
      v213 = *((_OWORD *)v2 + 3);
      v214 = *((_OWORD *)v2 + 5);
      v211[2] = *((_OWORD *)v2 + 4);
      v211[3] = v214;
      *v211 = v212;
      v211[1] = v213;
      v215 = *((_OWORD *)v2 + 6);
      v216 = *((_OWORD *)v2 + 7);
      v217 = *((_OWORD *)v2 + 9);
      v211[6] = *((_OWORD *)v2 + 8);
      v211[7] = v217;
      v211[4] = v215;
      v211[5] = v216;
      ++*(_QWORD *)(v299 + 464);
      ++*(_DWORD *)(v299 + 472);
      goto LABEL_321;
    case 6u:
      *(_DWORD *)v16 = *(_DWORD *)(v299 + 504) & 0xFFFFFF | (*(unsigned __int8 *)(v16 + 3) << 24);
      v85 = *(_QWORD *)(v299 + 496);
      v86 = *(_QWORD *)(v299 + 504);
      if (v86 >= v85)
      {
        v87 = v86 + 1;
        if (v85 < v86 + 1)
        {
          if (*(_QWORD *)(v299 + 488))
          {
            v88 = 2 * v85;
            v100 = v85 == 0;
            v89 = 8;
            if (!v100)
              v89 = v88;
            if (v89 <= v87)
              v90 = v87;
            else
              v90 = v89;
            re::DynamicArray<re::RigHierarchyJointTransform>::setCapacity((_QWORD *)(v299 + 488), v90);
          }
          else
          {
            re::DynamicArray<re::RigHierarchyJointTransform>::setCapacity((_QWORD *)(v299 + 488), v87);
            ++*(_DWORD *)(v299 + 512);
          }
        }
        v86 = *(_QWORD *)(v299 + 504);
      }
      v218 = (_OWORD *)(*(_QWORD *)(v299 + 520) + 160 * v86);
      v219 = *((_OWORD *)v2 + 3);
      *v218 = *v17;
      v218[1] = v219;
      v220 = *((_OWORD *)v2 + 4);
      v221 = *((_OWORD *)v2 + 5);
      v222 = *((_OWORD *)v2 + 7);
      v218[4] = *((_OWORD *)v2 + 6);
      v218[5] = v222;
      v218[2] = v220;
      v218[3] = v221;
      v223 = *((_OWORD *)v2 + 8);
      v224 = *((_OWORD *)v2 + 9);
      v225 = *((_OWORD *)v2 + 11);
      v218[8] = *((_OWORD *)v2 + 10);
      v218[9] = v225;
      v218[6] = v223;
      v218[7] = v224;
      ++*(_QWORD *)(v299 + 504);
      ++*(_DWORD *)(v299 + 512);
      goto LABEL_321;
    case 7u:
      v91 = (_anonymous_namespace_ *)re::TypeRegistry::typeInfo((_QWORD *)v299, *((_QWORD *)v2 + 13), &v302);
      if (!(_BYTE)v302)
        goto LABEL_361;
      if (v304 != 2)
        goto LABEL_362;
      if (*((_QWORD *)v2 + 6))
        goto LABEL_363;
      if (*((_QWORD *)v2 + 7))
        goto LABEL_364;
      v92 = *((_QWORD *)v2 + 36);
      *((_DWORD *)v2 + 29) = *(_QWORD *)(v299 + 584);
      *((_DWORD *)v2 + 30) = v92;
      *(_DWORD *)v16 = *(_DWORD *)(v299 + 544) & 0xFFFFFF | (*(unsigned __int8 *)(v16 + 3) << 24);
      v93 = *(_QWORD *)(v299 + 544);
      v94 = *(_QWORD *)(v299 + 536);
      if (v93 >= v94)
      {
        v95 = v93 + 1;
        if (v94 < v93 + 1)
        {
          if (*(_QWORD *)(v299 + 528))
          {
            v96 = 2 * v94;
            v100 = v94 == 0;
            v97 = 8;
            if (!v100)
              v97 = v96;
            if (v97 <= v95)
              v98 = v95;
            else
              v98 = v97;
            v91 = (_anonymous_namespace_ *)re::DynamicArray<re::internal::EnumTypeInfo>::setCapacity((_QWORD *)(v299 + 528), v98);
          }
          else
          {
            v91 = (_anonymous_namespace_ *)re::DynamicArray<re::internal::EnumTypeInfo>::setCapacity((_QWORD *)(v299 + 528), v95);
            ++*(_DWORD *)(v299 + 552);
          }
        }
        v93 = *(_QWORD *)(v299 + 544);
      }
      v254 = (_OWORD *)(*(_QWORD *)(v299 + 560) + 96 * v93);
      v255 = *((_OWORD *)v2 + 3);
      *v254 = *v17;
      v254[1] = v255;
      v256 = *((_OWORD *)v2 + 4);
      v257 = *((_OWORD *)v2 + 5);
      v258 = *((_OWORD *)v2 + 7);
      v254[4] = *((_OWORD *)v2 + 6);
      v254[5] = v258;
      v254[2] = v256;
      v254[3] = v257;
      ++*(_QWORD *)(v299 + 544);
      ++*(_DWORD *)(v299 + 552);
      v259 = *(_QWORD *)(v299 + 584);
      v6 = *((_QWORD *)v2 + 36);
      v260 = v6 + v259;
      if (v259 >= v6 + v259)
      {
        if (v259 <= v6 + v259)
          goto LABEL_288;
      }
      else
      {
        if (*(_QWORD *)(v299 + 576) < v260)
        {
          v91 = (_anonymous_namespace_ *)re::DynamicArray<float *>::setCapacity((_QWORD *)(v299 + 568), v6 + v259);
          v259 = *(_QWORD *)(v299 + 584);
        }
        if (v259 < v260)
        {
          v91 = (_anonymous_namespace_ *)(*(_QWORD *)(v299 + 600) + 8 * v259);
          v261 = 8 * v260 - 8 * v259;
          if (v261 >= 1)
            memset_pattern16(v91, &unk_226191C20, 8 * (((unint64_t)v261 >> 3) - ((unint64_t)v261 > 7)) + 8);
        }
      }
      *(_QWORD *)(v299 + 584) = v260;
      ++*(_DWORD *)(v299 + 592);
      v6 = *((_QWORD *)v2 + 36);
      v259 = v260;
LABEL_288:
      if (!v6)
        goto LABEL_321;
      v5 = *((unsigned int *)v2 + 29);
      v16 = v259 + 1;
      if (v259 + 1 <= v5)
        goto LABEL_366;
      v16 = v5 + v6;
      if (__CFADD__(v5, v6))
        goto LABEL_367;
      v262 = (char *)*((_QWORD *)v2 + 38);
      if (v259 >= v16)
      {
        memmove((void *)(*(_QWORD *)(v299 + 600) + 8 * v5), *((const void **)v2 + 38), 8 * v6);
      }
      else
      {
        v263 = *(_QWORD *)(v299 + 576);
        if (v263 < v16)
        {
          if (*(_QWORD *)(v299 + 568))
          {
            v264 = 2 * v263;
            v100 = v263 == 0;
            v265 = 8;
            if (!v100)
              v265 = v264;
            if (v265 <= v16)
              v266 = v5 + v6;
            else
              v266 = v265;
            re::DynamicArray<float *>::setCapacity((_QWORD *)(v299 + 568), v266);
          }
          else
          {
            re::DynamicArray<float *>::setCapacity((_QWORD *)(v299 + 568), v5 + v6);
            ++*(_DWORD *)(v299 + 592);
          }
        }
        v267 = *(_QWORD *)(v299 + 600);
        v268 = *(_QWORD *)(v299 + 584) - v5;
        v269 = &v262[8 * v268];
        if (v268)
        {
          memmove((void *)(v267 + 8 * v5), v262, 8 * v268);
          v5 = *(_QWORD *)(v299 + 584);
          v267 = *(_QWORD *)(v299 + 600);
        }
        memcpy((void *)(v267 + 8 * v5), v269, &v262[8 * v6] - v269);
        *(_QWORD *)(v299 + 584) = v16;
      }
      ++*(_DWORD *)(v299 + 592);
      goto LABEL_321;
    case 8u:
      LOBYTE(v302) = 0;
      v8 = v2 + 104;
      v99 = *((_DWORD *)v2 + 27) & 0xFFFFFF;
      if (v99)
      {
        re::TypeRegistry::typeInfo((_QWORD *)v299, *(_QWORD *)v8, buf);
        re::Optional<re::TypeInfo>::operator=(&v302, buf);
        if (!(_BYTE)v302)
          goto LABEL_365;
      }
      if (*((_QWORD *)v2 + 22))
        v100 = 0;
      else
        v100 = (v2[392] | v2[152]) == 0;
      v101 = v100;
      if (v99)
        v102 = *(_BYTE *)(v305 + 48) & 1;
      else
        v102 = 1;
      if ((v5 & v102 & v101) != 1)
        goto LABEL_143;
      v115 = *((_QWORD *)v2 + 41);
      if (!v115)
        goto LABEL_142;
      v4 = *((_QWORD *)v2 + 43);
      v116 = 40 * v115;
      do
      {
        re::TypeRegistry::typeInfo((_QWORD *)v299, *(_QWORD *)v4, buf);
        if (!buf[0])
          goto LABEL_359;
        if ((*(_DWORD *)(*((_QWORD *)&v316 + 1) + 48) & 1) == 0)
          goto LABEL_143;
        v4 += 40;
        v116 -= 40;
      }
      while (v116);
LABEL_142:
      *((_DWORD *)v2 + 20) |= 1u;
LABEL_143:
      if ((_BYTE)v302 && (*(_BYTE *)(v305 + 48) & 2) == 0 || v2[28] && !v2[29])
        goto LABEL_153;
      v117 = *((_QWORD *)v2 + 41);
      if (v117)
      {
        v4 = *((_QWORD *)v2 + 43);
        v118 = 40 * v117;
        while (1)
        {
          re::TypeRegistry::typeInfo((_QWORD *)v299, *(_QWORD *)v4, buf);
          if (!buf[0])
            break;
          if ((*(_DWORD *)(*((_QWORD *)&v316 + 1) + 48) & 2) == 0)
            goto LABEL_153;
          v4 += 40;
          v118 -= 40;
          if (!v118)
            goto LABEL_152;
        }
LABEL_358:
        re::internal::assertLog((re::internal *)4, v14, "assertion failure: '%s' (%s:line %i) Invalid member type.", "memberType", "commitTo", 347);
        _os_crash();
        __break(1u);
LABEL_359:
        re::internal::assertLog((re::internal *)4, v14, "assertion failure: '%s' (%s:line %i) Invalid member type.", "memberType", "commitTo", 318);
        _os_crash();
        __break(1u);
LABEL_360:
        re::internal::assertLog((re::internal *)5, v14, "assertion failure: '%s' (%s:line %i) New value of renamed enum constant (old name = \"%s\") is missing.", "found", "commitTo", 168, v55[2]);
        _os_crash();
        __break(1u);
LABEL_361:
        re::internal::assertLog((re::internal *)4, v14, "assertion failure: '%s' (%s:line %i) Union tag type must be registered before the union type.", "tagType", "commitTo", 264);
        _os_crash();
        __break(1u);
LABEL_362:
        re::internal::assertLog((re::internal *)4, v14, "assertion failure: '%s' (%s:line %i) Union tag type must be an enum type.", "tagType.value().isEnum()", "commitTo", 265);
        _os_crash();
        __break(1u);
LABEL_363:
        re::internal::assertLog((re::internal *)4, v14, "assertion failure: '%s' (%s:line %i) Tagged unions don't support custom constructors.", "!sharedTypeInfo().constructor", "commitTo", 266);
        _os_crash();
        __break(1u);
LABEL_364:
        re::internal::assertLog((re::internal *)4, v14, "assertion failure: '%s' (%s:line %i) Tagged unions don't support custom destructors.", "!sharedTypeInfo().destructor", "commitTo", 267);
        _os_crash();
        __break(1u);
LABEL_365:
        re::internal::assertLog((re::internal *)4, v14, "assertion failure: '%s' (%s:line %i) Invalid super class type.", "superClass", "commitTo", 305);
        _os_crash();
        __break(1u);
LABEL_366:
        v300 = 0;
        v318 = 0u;
        v319 = 0u;
        v316 = 0u;
        v317 = 0u;
        *(_OWORD *)buf = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        v307 = 136315906;
        v308 = "copy";
        v309 = 1024;
        v310 = 643;
        v311 = 2048;
        v312 = v5;
        v313 = 2048;
        v314 = v16;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_367:
        re::internal::assertLog((re::internal *)7, v14, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::copy(). size = %zu, pos = %zu, count = %zu", "!overflow", "copy", 647, v259, v5, v6);
        _os_crash();
        __break(1u);
        goto LABEL_368;
      }
LABEL_152:
      *((_DWORD *)v2 + 20) |= 2u;
LABEL_153:
      v3 = v299;
      if (v2[152])
      {
        if ((_BYTE)v302)
        {
          re::TypeInfo::rootClass((re::TypeInfo *)&v303, (uint64_t)&v300);
          v119 = (_DWORD *)re::DataArray<re::internal::TypeInfoIndex>::get(v12, *(_QWORD *)v301);
          v120 = *(unsigned int *)(v301 + 80);
          if ((_DWORD)v120)
          {
            v121 = *v119 & 0xFFFFFF;
            v4 = *(_QWORD *)(v299 + 624);
            do
            {
              v5 = v121;
              if (v4 <= v121)
                goto LABEL_352;
              v3 = *(_QWORD *)(v3 + 640);
              if (*(_BYTE *)(v3 + 152 * v121 + 120) && *(_QWORD *)(v3 + 152 * v121 + 128) == *((_QWORD *)v2 + 20))
                goto LABEL_357;
              ++v121;
              --v120;
              v3 = v299;
            }
            while (v120);
          }
        }
      }
      if (v2[392])
      {
        *((_DWORD *)v2 + 42) = *(_QWORD *)(v3 + 664);
        re::DynamicArray<re::internal::ObjectMemberInfo>::add((_anonymous_namespace_ *)(v3 + 648), (uint64_t)(v2 + 400));
      }
      v122 = *(_DWORD *)(v3 + 664);
      v7 = *((_QWORD *)v2 + 41);
      *((_DWORD *)v2 + 29) = v122;
      *((_DWORD *)v2 + 30) = v7;
      if ((v2[80] & 0x10) == 0 && v7)
      {
        v123 = 0;
        v124 = (unsigned int *)(*((_QWORD *)v2 + 43) + 32);
        v125 = 40 * v7;
        while (1)
        {
          v126 = *v124;
          if ((int)v126 <= v123)
            break;
          v124 += 10;
          v123 = v126;
          v125 -= 40;
          if (!v125)
            goto LABEL_168;
        }
LABEL_351:
        re::internal::assertLog((re::internal *)6, v14, "assertion failure: '%s' (%s:line %i) Object member \"%s\" has invalid numeric tag %d. Tags need to be unique and greater than 1. Object members need to be sorted by tag.", "member.serializationTag > tag", "commitTo", 397, *((_QWORD *)v124 - 2), v126);
        _os_crash();
        __break(1u);
LABEL_352:
        v306 = 0;
        v318 = 0u;
        v319 = 0u;
        v316 = 0u;
        v317 = 0u;
        *(_OWORD *)buf = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        v307 = 136315906;
        v308 = "operator[]";
        v309 = 1024;
        v310 = 789;
        v311 = 2048;
        v312 = v5;
        v313 = 2048;
        v314 = v4;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_353:
        v300 = 0;
        v318 = 0u;
        v319 = 0u;
        v316 = 0u;
        v317 = 0u;
        *(_OWORD *)buf = 0u;
        v2 = (unsigned __int8 *)MEMORY[0x24BDACB70];
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        v307 = 136315906;
        v308 = "operator[]";
        v309 = 1024;
        v310 = 789;
        v311 = 2048;
        v312 = v16;
        v313 = 2048;
        v314 = v4;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_354;
      }
LABEL_168:
      v4 = v3 + 648;
      v5 = *(_QWORD *)(v3 + 664);
      v127 = v5 + v7;
      v298 = v2 + 104;
      if (v5 >= v5 + v7)
      {
        if (v5 <= v5 + v7)
          goto LABEL_179;
        v294 = (_anonymous_namespace_ *)(v3 + 648);
        v129 = v3;
        v133 = 40 * v127 + 8;
        v134 = v5 + v7;
        do
        {
          re::StringID::destroyString((re::StringID *)(*(_QWORD *)(v129 + 680) + v133));
          ++v134;
          v133 += 40;
        }
        while (v134 < *(_QWORD *)(v129 + 664));
      }
      else
      {
        v128 = *(_QWORD *)(v3 + 664);
        if (*(_QWORD *)(v3 + 656) < v127)
        {
          re::DynamicArray<re::internal::ObjectMemberInfo>::setCapacity((_QWORD *)(v3 + 648), v5 + v7);
          v128 = *(_QWORD *)(v3 + 664);
        }
        v294 = (_anonymous_namespace_ *)(v3 + 648);
        v129 = v3;
        if (v128 < v127)
        {
          v130 = v5 + v7 - v128;
          v131 = 40 * v128;
          do
          {
            v132 = *(_QWORD *)(v129 + 680) + v131;
            *(_QWORD *)v132 = 0xFFFFFFFFLL;
            re::StringID::invalid((re::StringID *)(v132 + 8));
            *(_DWORD *)(v132 + 24) = 0;
            *(_BYTE *)(v132 + 28) = 1;
            v131 += 40;
            *(_DWORD *)(v132 + 32) = 0;
            --v130;
          }
          while (v130);
        }
      }
      *(_QWORD *)(v129 + 664) = v127;
      ++*(_DWORD *)(v129 + 672);
      v122 = *((_DWORD *)v2 + 29);
      v7 = *((_QWORD *)v2 + 41);
      v5 = v127;
      v3 = v129;
      v4 = (unint64_t)v294;
LABEL_179:
      if (v7)
      {
        v8 = (unsigned __int8 *)v122;
        v6 = v5 + 1;
        if (v5 + 1 <= v122)
        {
LABEL_368:
          v300 = 0;
          v318 = 0u;
          v319 = 0u;
          v316 = 0u;
          v317 = 0u;
          *(_OWORD *)buf = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          v307 = 136315906;
          v308 = "copy";
          v309 = 1024;
          v310 = 643;
          v311 = 2048;
          v312 = (unint64_t)v8;
          v313 = 2048;
          v314 = v6;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
          goto LABEL_369;
        }
        v135 = v122 + v7;
        if (__CFADD__(v122, v7))
        {
LABEL_369:
          re::internal::assertLog((re::internal *)7, v135, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::copy(). size = %zu, pos = %zu, count = %zu", "!overflow", "copy", 647, v5, v8, v7);
          _os_crash();
          __break(1u);
          goto LABEL_370;
        }
        v136 = (unint64_t *)*((_QWORD *)v2 + 43);
        if (v5 >= v135)
        {
          std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::internal::ObjectMemberInfo const*,re::internal::ObjectMemberInfo const*,re::internal::ObjectMemberInfo*,0>(*((unint64_t **)v2 + 43), &v136[5 * v7], *(_QWORD *)(v3 + 680) + 40 * v122);
        }
        else
        {
          v295 = (_anonymous_namespace_ *)(v122 + v7);
          re::DynamicArray<re::internal::ObjectMemberInfo>::growCapacity((_QWORD *)v4, v135);
          v137 = v3;
          v138 = *(_QWORD *)(v3 + 664);
          std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::internal::ObjectMemberInfo const*,re::internal::ObjectMemberInfo const*,re::internal::ObjectMemberInfo*,0>(v136, &v136[5 * (v138 - (_QWORD)v8)], *(_QWORD *)(v137 + 680) + 40 * v8);
          if (v138 - (_QWORD)v8 != v7)
          {
            v139 = (uint64_t)v136 + 40 * v138 - 40 * v8 + 8;
            v140 = (re::StringID *)(*(_QWORD *)(v299 + 680) + 40 * *(_QWORD *)(v299 + 664) + 8);
            do
            {
              *((_QWORD *)v140 - 1) = *(_QWORD *)(v139 - 8);
              v141 = re::StringID::StringID(v140, (const StringID *)v139);
              v142 = *(_QWORD *)(v139 + 16);
              *((_DWORD *)v141 + 6) = *(_DWORD *)(v139 + 24);
              *((_QWORD *)v141 + 2) = v142;
              v143 = (unint64_t *)(v139 + 32);
              v139 += 40;
              v140 = (re::StringID *)((char *)v141 + 40);
            }
            while (v143 != &v136[5 * v7]);
          }
          v3 = v299;
          *(_QWORD *)(v299 + 664) = v295;
        }
        ++*(_DWORD *)(v3 + 672);
      }
      v4 = v3 + 688;
      v144 = *(_DWORD *)(v3 + 704);
      v8 = (unsigned __int8 *)*((_QWORD *)v2 + 46);
      *((_DWORD *)v2 + 31) = v144;
      *((_DWORD *)v2 + 32) = (_DWORD)v8;
      v145 = v3;
      v146 = *(_QWORD *)(v3 + 704);
      v5 = (unint64_t)&v8[v146];
      v296 = (_anonymous_namespace_ *)v4;
      if (v146 < (unint64_t)&v8[v146])
      {
        v147 = v146;
        if (*(_QWORD *)(v145 + 696) < v5)
        {
          re::DynamicArray<re::BlendParameterInputNode>::setCapacity((_QWORD *)v4, (unint64_t)&v8[v146]);
          v147 = *(_QWORD *)(v299 + 704);
        }
        v4 = v299;
        if (v147 < v5)
        {
          v148 = &v8[v146 - v147];
          v149 = 24 * v147;
          do
          {
            v150 = (re::StringID *)(*(_QWORD *)(v299 + 720) + v149);
            re::StringID::invalid(v150);
            *((_DWORD *)v150 + 4) = 0;
            v149 += 24;
            --v148;
          }
          while (v148);
        }
LABEL_199:
        *(_QWORD *)(v4 + 704) = v5;
        ++*(_DWORD *)(v4 + 712);
        v144 = *((_DWORD *)v2 + 31);
        v8 = (unsigned __int8 *)*((_QWORD *)v2 + 46);
        v3 = v4;
        if (!v8)
          goto LABEL_211;
        goto LABEL_202;
      }
      if (v146 > (unint64_t)&v8[v146])
      {
        v151 = 24 * v5;
        v152 = v5;
        v4 = v299;
        do
        {
          re::StringID::destroyString((re::StringID *)(*(_QWORD *)(v299 + 720) + v151));
          ++v152;
          v151 += 24;
        }
        while (v152 < *(_QWORD *)(v299 + 704));
        goto LABEL_199;
      }
      v5 = v146;
      v3 = v299;
      if (!v8)
        goto LABEL_211;
LABEL_202:
      v6 = v144;
      v7 = v5 + 1;
      if (v5 + 1 <= v144)
      {
LABEL_370:
        v300 = 0;
        v318 = 0u;
        v319 = 0u;
        v316 = 0u;
        v317 = 0u;
        *(_OWORD *)buf = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        v307 = 136315906;
        v308 = "copy";
        v309 = 1024;
        v310 = 643;
        v311 = 2048;
        v312 = v6;
        v313 = 2048;
        v314 = v7;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_371;
      }
      v153 = (unint64_t)&v8[v144];
      if (__CFADD__(v144, v8))
      {
LABEL_371:
        re::internal::assertLog((re::internal *)7, v153, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::copy(). size = %zu, pos = %zu, count = %zu", "!overflow", "copy", 647, v5, v6, v8);
        _os_crash();
        __break(1u);
        goto LABEL_372;
      }
      v154 = (unint64_t *)*((_QWORD *)v2 + 48);
      if (v5 >= v153)
      {
        std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::RenamedObjectMember const*,re::RenamedObjectMember const*,re::RenamedObjectMember*,0>(*((unint64_t **)v2 + 48), &v154[3 * (_QWORD)v8], *(_QWORD *)(v3 + 720) + 24 * v144);
      }
      else
      {
        v155 = v296;
        v297 = (_anonymous_namespace_ *)&v8[v144];
        re::DynamicArray<re::AttributeArgument>::growCapacity(v155, v153);
        v156 = v3;
        v157 = *(_QWORD *)(v3 + 704);
        v5 = v157 - v6;
        v158 = &v154[3 * (v157 - v6)];
        std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::RenamedObjectMember const*,re::RenamedObjectMember const*,re::RenamedObjectMember*,0>(v154, v158, *(_QWORD *)(v156 + 720) + 24 * v6);
        if ((unsigned __int8 *)(v157 - v6) != v8)
        {
          v159 = (re::StringID *)(*(_QWORD *)(v299 + 720) + 24 * *(_QWORD *)(v299 + 704));
          v160 = 24 * (_QWORD)v8 + 24 * v6 - 24 * v157;
          do
          {
            v161 = re::StringID::StringID(v159, (const StringID *)v158);
            *((_DWORD *)v161 + 4) = *((_DWORD *)v158 + 4);
            v158 += 3;
            v159 = (re::StringID *)((char *)v161 + 24);
            v160 -= 24;
          }
          while (v160);
        }
        v3 = v299;
        *(_QWORD *)(v299 + 704) = v297;
      }
      ++*(_DWORD *)(v3 + 712);
LABEL_211:
      if ((*((_DWORD *)v2 + 27) & 0xFFFFFF) != 0)
      {
        v8 = v2 + 104;
        v6 = *(_DWORD *)re::DataArray<re::internal::TypeInfoIndex>::get(v12, *v298) & 0xFFFFFFLL;
        v4 = *(_QWORD *)(v3 + 624);
        if (v4 <= v6)
        {
LABEL_372:
          v300 = 0;
          v318 = 0u;
          v319 = 0u;
          v316 = 0u;
          v317 = 0u;
          *(_OWORD *)buf = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          v307 = 136315906;
          v308 = "operator[]";
          v309 = 1024;
          v310 = 789;
          v311 = 2048;
          v312 = v6;
          v313 = 2048;
          v314 = v4;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
          goto LABEL_373;
        }
        v5 = (*(_DWORD *)(*(_QWORD *)(v3 + 640) + 152 * v6 + 80) + v6);
        *(_DWORD *)v16 = (*(_DWORD *)(*(_QWORD *)(v3 + 640) + 152 * v6 + 80) + v6) & 0xFFFFFF | (*(unsigned __int8 *)(v16 + 3) << 24);
        v7 = *(_QWORD *)(v3 + 624);
        v16 = v7 + 1;
        if (v7 + 1 <= v5)
        {
LABEL_373:
          v300 = 0;
          v318 = 0u;
          v319 = 0u;
          v316 = 0u;
          v317 = 0u;
          *(_OWORD *)buf = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          v307 = 136315906;
          v308 = "insert";
          v309 = 1024;
          v310 = 855;
          v311 = 2048;
          v312 = v5;
          v313 = 2048;
          v314 = v16;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_374:
          v300 = 0;
          v318 = 0u;
          v319 = 0u;
          v316 = 0u;
          v317 = 0u;
          *(_OWORD *)buf = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          v307 = 136315906;
          v308 = "operator[]";
          v309 = 1024;
          v310 = 789;
          v311 = 2048;
          v312 = v6;
          v313 = 2048;
          v314 = v4;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_375:
          re::internal::assertLog((re::internal *)4, v78, "assertion failure: '%s' (%s:line %i) Element type must be registered before the array type.", "elementType", "commitTo", 222);
          _os_crash();
          __break(1u);
        }
        if (v7 >= *(_QWORD *)(v3 + 616))
        {
          re::DynamicArray<re::internal::ObjectTypeInfo>::growCapacity((_QWORD *)(v3 + 608), v7 + 1);
          v7 = *(_QWORD *)(v3 + 624);
        }
        v162 = *(_QWORD *)(v3 + 640);
        v163 = v162 + 152 * v7;
        if (v7 <= v5)
        {
          *(_OWORD *)v163 = *v17;
          v195 = *((_OWORD *)v2 + 3);
          v196 = *((_OWORD *)v2 + 4);
          v197 = *((_OWORD *)v2 + 5);
          *(_QWORD *)(v163 + 64) = *((_QWORD *)v2 + 12);
          *(_OWORD *)(v163 + 32) = v196;
          *(_OWORD *)(v163 + 48) = v197;
          *(_OWORD *)(v163 + 16) = v195;
          v198 = v162 + 152 * v7;
          v199 = *(_OWORD *)v298;
          *(_OWORD *)(v198 + 84) = *(_OWORD *)(v2 + 116);
          *(_OWORD *)(v198 + 72) = v199;
          re::StringID::StringID((re::StringID *)(v198 + 104), (const StringID *)(v2 + 136));
          v200 = v2[152];
          *(_BYTE *)(v198 + 120) = v200;
          if (v200)
            *(_QWORD *)(v162 + 152 * v7 + 128) = *((_QWORD *)v2 + 20);
          v201 = (_OWORD *)(v162 + 152 * v7 + 136);
          v3 = v299;
        }
        else
        {
          v164 = v162 + 152 * v7;
          v165 = *(_OWORD *)(v164 - 136);
          v166 = v7 - 1;
          v167 = *(_OWORD *)(v164 - 104);
          *(_OWORD *)(v163 + 32) = *(_OWORD *)(v164 - 120);
          *(_OWORD *)(v163 + 48) = v167;
          *(_QWORD *)(v163 + 64) = *(_QWORD *)(v164 - 88);
          *(_OWORD *)v163 = *(_OWORD *)(v164 - 152);
          *(_OWORD *)(v163 + 16) = v165;
          *(_OWORD *)(v164 + 72) = *(_OWORD *)(v164 - 80);
          *(_OWORD *)(v164 + 84) = *(_OWORD *)(v164 - 68);
          v168 = *(_QWORD *)(v164 - 40);
          *(_QWORD *)(v164 + 104) = *(_QWORD *)(v164 - 48);
          *(_QWORD *)(v164 + 112) = v168;
          *(_QWORD *)(v164 - 48) = 0;
          *(_QWORD *)(v164 - 40) = &str_110;
          v169 = *(unsigned __int8 *)(v164 - 32);
          *(_BYTE *)(v164 + 120) = v169;
          if (v169)
            *(_QWORD *)(v162 + 152 * v7 + 128) = *(_QWORD *)(v162 + 152 * v166 + 128);
          *(_OWORD *)(v162 + 152 * v7 + 136) = *(_OWORD *)(v162 + 152 * v166 + 136);
          v170 = *(_QWORD *)(v3 + 640);
          v171 = *(_QWORD *)(v3 + 624);
          if (v170 + 152 * v171 - 152 != v170 + 152 * v5)
          {
            v7 = 152 * v171;
            v172 = 152 * v5 + 152;
            do
            {
              v173 = v170 + v7;
              *(_OWORD *)(v173 - 104) = *(_OWORD *)(v170 + v7 - 256);
              v174 = *(_OWORD *)(v170 + v7 - 304);
              *(_OWORD *)(v173 - 136) = *(_OWORD *)(v170 + v7 - 288);
              *(_OWORD *)(v173 - 120) = *(_OWORD *)(v170 + v7 - 272);
              *(_DWORD *)(v173 - 88) = *(_DWORD *)(v170 + v7 - 240);
              v175 = *(_QWORD *)(v170 + v7 - 200);
              v176 = *(_QWORD *)(v170 + v7 - 192);
              v177 = *(_QWORD *)(v170 + v7 - 40);
              v178 = v175 & 0xFFFFFFFFFFFFFFFELL | *(_QWORD *)(v170 + v7 - 48) & 1;
              *(_OWORD *)(v173 - 152) = v174;
              *(_OWORD *)(v173 - 80) = *(_OWORD *)(v170 + v7 - 232);
              *(_OWORD *)(v173 - 68) = *(_OWORD *)(v170 + v7 - 220);
              *(_QWORD *)(v173 - 200) = 0;
              *(_QWORD *)(v173 - 192) = &str_110;
              *(_QWORD *)(v173 - 40) = v176;
              *(_QWORD *)buf = v178;
              *(_QWORD *)&buf[8] = v177;
              *(_QWORD *)(v173 - 48) = v175;
              re::StringID::destroyString((re::StringID *)buf);
              if (*(_BYTE *)(v170 + v7 - 32) || *(_BYTE *)(v170 + v7 - 184))
              {
                if (!*(_BYTE *)(v170 + v7 - 32) || *(_BYTE *)(v170 + v7 - 184))
                {
                  if (!*(_BYTE *)(v170 + v7 - 32) && *(_BYTE *)(v170 + v7 - 184))
                    *(_BYTE *)(v173 - 32) = 1;
                  *(_QWORD *)(v170 + v7 - 24) = *(_QWORD *)(v170 + v7 - 176);
                }
                else
                {
                  *(_BYTE *)(v173 - 32) = 0;
                }
              }
              *(_OWORD *)(v170 + v7 - 16) = *(_OWORD *)(v170 + v7 - 168);
              v170 -= 152;
              v172 += 152;
            }
            while (v7 != v172);
            v170 = *(_QWORD *)(v3 + 640);
            v8 = v2 + 104;
          }
          v179 = v170 + 152 * v5;
          *(_OWORD *)v179 = *v17;
          v180 = *((_OWORD *)v2 + 3);
          v181 = *((_OWORD *)v2 + 4);
          v182 = *((_OWORD *)v2 + 5);
          *(_DWORD *)(v179 + 64) = *((_DWORD *)v2 + 24);
          *(_OWORD *)(v179 + 32) = v181;
          *(_OWORD *)(v179 + 48) = v182;
          *(_OWORD *)(v179 + 16) = v180;
          v183 = *(_OWORD *)v8;
          *(_OWORD *)(v179 + 84) = *(_OWORD *)(v8 + 12);
          *(_OWORD *)(v179 + 72) = v183;
          re::StringID::operator=((unint64_t *)(v179 + 104), (uint64_t *)v2 + 17);
          v186 = *(unsigned __int8 *)(v179 + 120);
          v185 = (_BYTE *)(v179 + 120);
          v184 = v186;
          if (v186 || v2[152])
          {
            if (!v184 || v2[152])
            {
              if (v184 || !v2[152])
              {
                *(_QWORD *)(v170 + 152 * v5 + 128) = *((_QWORD *)v2 + 20);
              }
              else
              {
                *v185 = 1;
                *(_QWORD *)(v170 + 152 * v5 + 128) = *((_QWORD *)v2 + 20);
              }
            }
            else
            {
              *v185 = 0;
            }
          }
          v201 = (_OWORD *)(v170 + 152 * v5 + 136);
        }
        *v201 = *(_OWORD *)(v2 + 168);
        v4 = *(_QWORD *)(v3 + 624) + 1;
        *(_QWORD *)(v3 + 624) = v4;
        ++*(_DWORD *)(v3 + 632);
        v16 = (v5 + 1);
        if (v16 < v4)
        {
          v7 = v6;
          v5 = v4;
          v6 = 152 * v16;
          do
          {
            v4 = *(_QWORD *)(v3 + 624);
            if (v4 <= v16)
              goto LABEL_353;
            v270 = re::DataArray<re::internal::TypeInfoIndex>::get(v12, *(_QWORD *)(*(_QWORD *)(v3 + 640) + v6));
            *(_DWORD *)v270 = v16++ & 0xFFFFFF | (*(unsigned __int8 *)(v270 + 3) << 24);
            v6 += 152;
          }
          while (v16 < v5);
          v4 = *(_QWORD *)(v3 + 624);
          v6 = v7;
        }
        if (v4 <= v6)
          goto LABEL_374;
        v271 = *(_QWORD *)(v3 + 640);
        v272 = v271 + 152 * v6;
        v273 = *(_DWORD *)(v272 + 76);
        ++*(_DWORD *)(v272 + 80);
        if ((v273 & 0xFFFFFF) == 0)
          goto LABEL_321;
        v5 = 152;
        v274 = v271 + 152 * v6;
        while (1)
        {
          v16 = *(_DWORD *)re::DataArray<re::internal::TypeInfoIndex>::get(v12, *(_QWORD *)(v274 + 72)) & 0xFFFFFFLL;
          v4 = *(_QWORD *)(v3 + 624);
          if (v4 <= v16)
            break;
          v274 = *(_QWORD *)(v3 + 640) + 152 * v16;
          v275 = *(_DWORD *)(v274 + 76);
          ++*(_DWORD *)(v274 + 80);
          if ((v275 & 0xFFFFFF) == 0)
            goto LABEL_321;
        }
        v300 = 0;
        v318 = 0u;
        v319 = 0u;
        v316 = 0u;
        v317 = 0u;
        *(_OWORD *)buf = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        v307 = 136315906;
        v308 = "operator[]";
        v309 = 1024;
        v310 = 789;
        v311 = 2048;
        v312 = v16;
        v313 = 2048;
        v314 = v4;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_351;
      }
      *(_DWORD *)v16 = *(_DWORD *)(v3 + 624) & 0xFFFFFF | (*(unsigned __int8 *)(v16 + 3) << 24);
      v187 = *(_QWORD *)(v3 + 624);
      if (v187 >= *(_QWORD *)(v3 + 616))
      {
        re::DynamicArray<re::internal::ObjectTypeInfo>::growCapacity((_QWORD *)(v3 + 608), v187 + 1);
        v187 = *(_QWORD *)(v3 + 624);
      }
      v188 = *(_QWORD *)(v3 + 640);
      v189 = v188 + 152 * v187;
      *(_OWORD *)v189 = *v17;
      v190 = *((_OWORD *)v2 + 3);
      v191 = *((_OWORD *)v2 + 4);
      v192 = *((_OWORD *)v2 + 5);
      *(_QWORD *)(v189 + 64) = *((_QWORD *)v2 + 12);
      *(_OWORD *)(v189 + 32) = v191;
      *(_OWORD *)(v189 + 48) = v192;
      *(_OWORD *)(v189 + 16) = v190;
      v193 = *(_OWORD *)v298;
      *(_OWORD *)(v189 + 84) = *(_OWORD *)(v2 + 116);
      *(_OWORD *)(v189 + 72) = v193;
      re::StringID::StringID((re::StringID *)(v189 + 104), (const StringID *)(v2 + 136));
      v194 = v2[152];
      *(_BYTE *)(v189 + 120) = v194;
      if (v194)
        *(_QWORD *)(v188 + 152 * v187 + 128) = *((_QWORD *)v2 + 20);
      *(_OWORD *)(v188 + 152 * v187 + 136) = *(_OWORD *)(v2 + 168);
      v3 = v299;
      ++*(_QWORD *)(v299 + 624);
      ++*(_DWORD *)(v299 + 632);
LABEL_321:
      if (v2[28])
        *((_DWORD *)v2 + 20) = *((_DWORD *)v2 + 20) & 0xFFFFFFFD | (2 * v2[29]);
      v276 = *((unsigned int *)v2 + 118);
      if ((_DWORD)v276)
      {
        v277 = 0;
        v278 = (int *)(*((_QWORD *)v2 + 57) + 8);
        while (1)
        {
          v279 = *v278;
          v278 += 14;
          if (v279 < 0)
            break;
          if (v276 == ++v277)
          {
            LODWORD(v277) = *((_DWORD *)v2 + 118);
            break;
          }
        }
      }
      else
      {
        LODWORD(v277) = 0;
      }
      if ((_DWORD)v276 != (_DWORD)v277)
      {
        v280 = v277;
        v281 = (_QWORD *)(v3 + 768);
        do
        {
          v282 = *((_QWORD *)v2 + 57) + 56 * v280;
          v283 = *(_QWORD *)(v282 + 32);
          *(_OWORD *)buf = *(_OWORD *)(v282 + 16);
          *(_QWORD *)&buf[8] = *((_QWORD *)v2 + 4);
          *(_QWORD *)&v316 = v283;
          v284 = re::Hash<re::internal::TypeAttributeKey>::operator()((uint64_t)&v302, (uint64_t)buf);
          v285 = v284;
          if (*v281)
          {
            v286 = v284 % *(unsigned int *)(v3 + 792);
            v287 = v3;
            v288 = *(unsigned int *)(*(_QWORD *)(v3 + 776) + 4 * v286);
            if ((_DWORD)v288 != 0x7FFFFFFF)
            {
              v289 = *(_QWORD *)(v287 + 784);
              while (!re::internal::TypeAttributeKey::operator==((unsigned __int16 *)(v289 + 56 * v288 + 16), (uint64_t *)buf))
              {
                v289 = *(_QWORD *)(v299 + 784);
                v288 = *(_DWORD *)(v289 + 56 * v288 + 8) & 0x7FFFFFFF;
                if (v288 == 0x7FFFFFFF)
                {
                  v3 = v299;
                  goto LABEL_339;
                }
              }
              goto LABEL_340;
            }
            v3 = v287;
          }
          else
          {
            LODWORD(v286) = 0;
          }
LABEL_339:
          re::HashTable<re::internal::TypeAttributeKey,re::internal::TypeAttributeData,re::Hash<re::internal::TypeAttributeKey>,re::EqualTo<re::internal::TypeAttributeKey>,true,false>::addEmplace<re::internal::TypeAttributeData&>((uint64_t)v281, v286, v285, (__int128 *)buf, (_OWORD *)(v282 + 40));
          ++*(_DWORD *)(v3 + 808);
LABEL_340:
          if (*((_DWORD *)v2 + 118) <= (v277 + 1))
            v290 = v277 + 1;
          else
            v290 = *((_DWORD *)v2 + 118);
          v3 = v299;
          while (1)
          {
            v280 = (v277 + 1);
            if (v290 - 1 == (_DWORD)v277)
              break;
            LODWORD(v277) = v277 + 1;
            v291 = v280;
            if ((*(_DWORD *)(*((_QWORD *)v2 + 57) + 56 * v280 + 8) & 0x80000000) != 0)
              goto LABEL_348;
          }
          v291 = v290;
LABEL_348:
          LODWORD(v277) = v291;
        }
        while ((_DWORD)v276 != v291);
      }
      ++*(_DWORD *)(v3 + 24);
      re::TypeBuilder::reset((re::TypeBuilder *)v2, v14);
      return;
    case 9u:
      *(_DWORD *)v16 = *(_DWORD *)(v299 + 744) & 0xFFFFFF | (*(unsigned __int8 *)(v16 + 3) << 24);
      v103 = *(_QWORD *)(v299 + 744);
      v104 = *(_QWORD *)(v299 + 736);
      if (v103 >= v104)
      {
        v105 = v103 + 1;
        if (v104 < v103 + 1)
        {
          if (*(_QWORD *)(v299 + 728))
          {
            v106 = 2 * v104;
            v100 = v104 == 0;
            v107 = 8;
            if (!v100)
              v107 = v106;
            if (v107 <= v105)
              v108 = v105;
            else
              v108 = v107;
            re::DynamicArray<re::internal::PointerTypeInfo>::setCapacity((_QWORD *)(v299 + 728), v108);
          }
          else
          {
            re::DynamicArray<re::internal::PointerTypeInfo>::setCapacity((_QWORD *)(v299 + 728), v105);
            ++*(_DWORD *)(v299 + 752);
          }
        }
        v103 = *(_QWORD *)(v299 + 744);
      }
      v226 = *(_QWORD *)(v299 + 760) + 104 * v103;
      v227 = *v17;
      v228 = *((_OWORD *)v2 + 4);
      *(_OWORD *)(v226 + 16) = *((_OWORD *)v2 + 3);
      *(_OWORD *)(v226 + 32) = v228;
      *(_OWORD *)v226 = v227;
      v229 = *((_OWORD *)v2 + 5);
      v230 = *((_OWORD *)v2 + 6);
      v231 = *((_OWORD *)v2 + 7);
      *(_QWORD *)(v226 + 96) = *((_QWORD *)v2 + 16);
      *(_OWORD *)(v226 + 64) = v230;
      *(_OWORD *)(v226 + 80) = v231;
      *(_OWORD *)(v226 + 48) = v229;
      ++*(_QWORD *)(v299 + 744);
      ++*(_DWORD *)(v299 + 752);
      goto LABEL_321;
    default:
      re::internal::assertLog((re::internal *)4, v14, "assertion failure: '%s' (%s:line %i) Unknown type category.", "!\"Unreachable code\"", "commitTo", 466);
      _os_crash();
      __break(1u);
      goto LABEL_377;
  }
}

uint64_t re::DataArray<re::internal::TypeInfoIndex>::get(uint64_t a1, int a2)
{
  if (*(_QWORD *)(a1 + 16) <= (unint64_t)HIWORD(a2))
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(*(_QWORD *)(a1 + 32) + 16 * HIWORD(a2)) + 4 * (unsigned __int16)a2;
}

unint64_t *re::DynamicArray<re::EnumConstant>::copy(unint64_t *this, unint64_t a2, unint64_t *a3, uint64_t a4)
{
  uint64_t v4;
  unint64_t *v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v10;
  uint64_t v11;
  const StringID *v12;
  re::StringID *v13;
  uint64_t v14;
  __int128 v15;

  if (!a4)
    return this;
  v6 = this;
  v7 = this[2];
  if (v7 + 1 <= a2)
  {
    v14 = 0;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    LODWORD(v15) = 136315906;
    *(_QWORD *)((char *)&v15 + 4) = "copy";
    WORD6(v15) = 1024;
    HIWORD(v15) = 643;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)7, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::copy(). size = %zu, pos = %zu, count = %zu", "!overflow", "copy", 647, v7, a2, v4, v14, v15);
    _os_crash();
    __break(1u);
  }
  v4 = a4;
  v8 = a2 + a4;
  if (__CFADD__(a2, a4))
    goto LABEL_13;
  if (v7 >= v8)
  {
    this = std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::Pair<unsigned long,re::StringID,true> *,re::Pair<unsigned long,re::StringID,true> *,re::Pair<unsigned long,re::StringID,true> *,0>(a3, &a3[3 * a4], this[4] + 24 * a2);
  }
  else
  {
    re::DynamicArray<re::EnumConstant>::growCapacity(this, a2 + a4);
    v10 = v6[2];
    this = std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::Pair<unsigned long,re::StringID,true> *,re::Pair<unsigned long,re::StringID,true> *,re::Pair<unsigned long,re::StringID,true> *,0>(a3, &a3[3 * (v10 - a2)], v6[4] + 24 * a2);
    if (v10 - a2 != v4)
    {
      v11 = 24 * v4 + 24 * a2 - 24 * v10;
      v12 = (const StringID *)((char *)a3 + 24 * v10 - 24 * a2 + 8);
      this = (unint64_t *)(v6[4] + 24 * v6[2] + 8);
      do
      {
        *(this - 1) = (unint64_t)v12[-1].var1;
        v13 = re::StringID::StringID((re::StringID *)this, v12);
        v12 = (const StringID *)((char *)v12 + 24);
        this = (unint64_t *)((char *)v13 + 24);
        v11 -= 24;
      }
      while (v11);
    }
    v6[2] = v8;
  }
  ++*((_DWORD *)v6 + 6);
  return this;
}

re::StringID *re::DynamicArray<re::internal::ObjectMemberInfo>::add(_anonymous_namespace_ *this, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  re::StringID *result;
  uint64_t v7;

  v4 = *((_QWORD *)this + 2);
  if (v4 >= *((_QWORD *)this + 1))
  {
    re::DynamicArray<re::internal::ObjectMemberInfo>::growCapacity(this, v4 + 1);
    v4 = *((_QWORD *)this + 2);
  }
  v5 = *((_QWORD *)this + 4) + 40 * v4;
  *(_QWORD *)v5 = *(_QWORD *)a2;
  result = re::StringID::StringID((re::StringID *)(v5 + 8), (const StringID *)(a2 + 8));
  v7 = *(_QWORD *)(a2 + 24);
  *(_DWORD *)(v5 + 32) = *(_DWORD *)(a2 + 32);
  *(_QWORD *)(v5 + 24) = v7;
  ++*((_QWORD *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

uint64_t re::TypeBuilder::setSharedInfo(uint64_t a1, uint64_t a2, uint64_t *a3, int a4, int a5, unint64_t a6, unint64_t a7)
{
  uint64_t v7;
  int v8;
  uint64_t result;

  v8 = a6;
  if (HIDWORD(a6))
  {
    re::internal::assertLog((re::internal *)5, a2, "assertion failure: '%s' (%s:line %i) Size (%zu) exceeds limit.", "size <= std::numeric_limits<uint32_t>::max()", "setSharedInfo", 497, a6);
    _os_crash();
    __break(1u);
  }
  else
  {
    v7 = a7;
    if (!HIDWORD(a7))
    {
      *(_BYTE *)a1 = a2;
      result = (uint64_t)re::StringID::operator=((unint64_t *)(a1 + 8), a3);
      *(_DWORD *)(a1 + 24) = a4;
      *(_DWORD *)(a1 + 40) = v8;
      *(_DWORD *)(a1 + 44) = v7;
      *(_QWORD *)(a1 + 72) = 0;
      *(_QWORD *)(a1 + 48) = 0;
      *(_QWORD *)(a1 + 56) = 0;
      *(_DWORD *)(a1 + 96) = a5;
      return result;
    }
  }
  re::internal::assertLog((re::internal *)5, a2, "assertion failure: '%s' (%s:line %i) Alignment (%zu) exceeds limit.", "alignment <= std::numeric_limits<uint32_t>::max()", "setSharedInfo", 498, v7);
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::TypeBuilder::setConstructor(uint64_t result, uint64_t a2)
{
  if (*(_BYTE *)result)
  {
    *(_QWORD *)(result + 48) = a2;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) beginXxxType() needs to be called before calling this function.", "isBuilding()", "setConstructor", 514);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilder::setDestructor(uint64_t result, uint64_t a2)
{
  if (*(_BYTE *)result)
  {
    *(_QWORD *)(result + 56) = a2;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) beginXxxType() needs to be called before calling this function.", "isBuilding()", "setDestructor", 522);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilder::setRetain(uint64_t this, void (*a2)(void *))
{
  if (*(_BYTE *)this)
  {
    *(_QWORD *)(this + 64) = a2;
    if (a2)
      *(_DWORD *)(this + 80) |= 0x200u;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) beginXxxType() needs to be called before calling this function.", "isBuilding()", "setRetain", 530);
    this = _os_crash();
    __break(1u);
  }
  return this;
}

uint64_t re::TypeBuilder::setRelease(uint64_t this, void (*a2)(void *))
{
  if (*(_BYTE *)this)
  {
    *(_QWORD *)(this + 72) = a2;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) beginXxxType() needs to be called before calling this function.", "isBuilding()", "setRelease", 540);
    this = _os_crash();
    __break(1u);
  }
  return this;
}

_BYTE *re::TypeBuilder::setHasKnownSize(_BYTE *this, uint64_t a2)
{
  if (*this)
  {
    if (!this[28])
      this[28] = 1;
    this[29] = a2;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) beginXxxType() needs to be called before calling this function.", "isBuilding()", "setHasKnownSize", 548);
    this = (_BYTE *)_os_crash();
    __break(1u);
  }
  return this;
}

uint64_t re::TypeBuilder::setIsIncomplete(uint64_t this, uint64_t a2)
{
  int v2;

  if (*(_BYTE *)this)
  {
    if ((_DWORD)a2)
      v2 = 16;
    else
      v2 = 0;
    *(_DWORD *)(this + 80) = *(_DWORD *)(this + 80) & 0xFFFFFFEF | v2;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) beginXxxType() needs to be called before calling this function.", "isBuilding()", "setIsIncomplete", 555);
    this = _os_crash();
    __break(1u);
  }
  return this;
}

uint64_t re::TypeBuilder::setPreviousVersion(unsigned __int8 *a1, uint64_t *a2)
{
  int v2;
  uint64_t v4;
  uint64_t v6;
  unsigned int v7;
  uint64_t result;

  if (!*a1)
  {
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) beginXxxType() needs to be called before calling this function.", "isBuilding()", "setPreviousVersion", 562);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  v4 = *a2;
  if (!*a2)
  {
LABEL_9:
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) ", "previousTypeID.isValid()", "setPreviousVersion", 563);
    _os_crash();
    __break(1u);
    goto LABEL_10;
  }
  v2 = *a1;
  if (v2 != *(unsigned __int8 *)(re::DataArray<re::internal::TypeInfoIndex>::tryGet(v4 + 32, a2[1]) + 3))
  {
LABEL_10:
    re::internal::assertLog((re::internal *)4, v6, "assertion failure: '%s' (%s:line %i) Previous version needs to be of the same type category.", "m_category == registry->typeCategory(previousTypeID)", "setPreviousVersion", 567);
    _os_crash();
    __break(1u);
    goto LABEL_11;
  }
  if (*a2)
  {
    v7 = *((_DWORD *)a1 + 6);
    result = re::DataArray<re::TextureAtlasTile>::tryGet(v4 + 96, a2[1]);
    if (result)
    {
      if (v7 > *(_DWORD *)(result + 16))
      {
        *((_QWORD *)a1 + 11) = a2[1];
        return result;
      }
    }
  }
LABEL_11:
  re::internal::assertLog((re::internal *)4, v6, "assertion failure: '%s' (%s:line %i) New version number needs to be greater than previous version number.", "m_version > registry->typeVersion(previousTypeID)", "setPreviousVersion", 568);
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::TypeBuilder::setVersion(uint64_t this, uint64_t a2)
{
  if (*(_BYTE *)this)
  {
    *(_DWORD *)(this + 24) = a2;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) beginXxxType() needs to be called before calling this function.", "isBuilding()", "setVersion", 580);
    this = _os_crash();
    __break(1u);
  }
  return this;
}

uint64_t re::TypeBuilder::setIsCallbackSerializer(uint64_t this, uint64_t a2)
{
  int v2;

  if (*(_BYTE *)this)
  {
    if ((_DWORD)a2)
      v2 = 256;
    else
      v2 = 0;
    *(_DWORD *)(this + 80) = *(_DWORD *)(this + 80) & 0xFFFFFEFF | v2;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) beginXxxType() needs to be called before calling this function.", "isBuilding()", "setIsCallbackSerializer", 587);
    this = _os_crash();
    __break(1u);
  }
  return this;
}

uint64_t re::TypeBuilder::beginEnumType(uint64_t a1, uint64_t *a2, int a3, int a4, uint64_t a5)
{
  uint64_t v10;
  uint64_t result;
  _BYTE v12[24];
  uint64_t v13;

  re::TypeRegistry::typeInfo(*(re **)a5, (re **)a5, v12);
  if (v12[0])
  {
    *(_DWORD *)(a1 + 32) = -1;
    *(_OWORD *)(a1 + 36) = 0u;
    *(_OWORD *)(a1 + 52) = 0u;
    *(_OWORD *)(a1 + 68) = 0u;
    *(_QWORD *)(a1 + 88) = 0xFFFFFFFFLL;
    *(_DWORD *)(a1 + 96) = 1;
    *(_DWORD *)(a1 + 104) = -1;
    *(_QWORD *)(a1 + 116) = 0;
    *(_QWORD *)(a1 + 108) = 0;
    result = re::TypeBuilder::setSharedInfo(a1, 2, a2, a3, a4, *(unsigned int *)(v13 + 8), *(unsigned int *)(v13 + 12));
    *(_QWORD *)(a1 + 104) = *(_QWORD *)(a5 + 8);
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v10, "assertion failure: '%s' (%s:line %i) Type is missing in type registry. Type might have been forward declared, but no type information was provided.", "underlyingTypeInfo", "beginEnumType", 614);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

void re::TypeBuilder::addEnumConstant(re::TypeBuilder *this, uint64_t a2, StringID *a3)
{
  _QWORD *v3;
  uint64_t v4;
  _BYTE v5[16];

  if (*(_BYTE *)this == 2)
  {
    v3 = (_QWORD *)((char *)this + 192);
    v4 = a2;
    re::StringID::StringID((re::StringID *)v5, a3);
    re::DynamicArray<re::EnumConstant>::add(v3, &v4);
    re::StringID::destroyString((re::StringID *)v5);
  }
  else
  {
    if (!*(_BYTE *)this)
    {
      re::internal::assertLog((re::internal *)4, a2, a3, "assertion failure: '%s' (%s:line %i) beginEnumType() needs to be called before addEnumConstant().", "isBuilding()", "addEnumConstant", 625);
      _os_crash();
      __break(1u);
    }
    re::internal::assertLog((re::internal *)4, a2, a3, "assertion failure: '%s' (%s:line %i) Wrong type.", "m_category == TypeCategory::kEnum", "addEnumConstant", 626);
    _os_crash();
    __break(1u);
  }
}

_QWORD *re::DynamicArray<re::EnumConstant>::add(_QWORD *this, _QWORD *a2)
{
  _QWORD *v3;
  unint64_t v4;
  _QWORD *v5;
  uint64_t v6;

  v3 = this;
  v4 = this[2];
  if (v4 >= this[1])
  {
    this = re::DynamicArray<re::EnumConstant>::growCapacity(this, v4 + 1);
    v4 = v3[2];
  }
  v5 = (_QWORD *)(v3[4] + 24 * v4);
  *v5 = *a2;
  v6 = a2[1];
  v5[1] = v5[1] & 0xFFFFFFFFFFFFFFFELL | v6 & 1;
  v5[1] = a2[1] & 0xFFFFFFFFFFFFFFFELL | v6 & 1;
  v5[2] = a2[2];
  a2[1] = 0;
  a2[2] = &str_110;
  ++v3[2];
  ++*((_DWORD *)v3 + 6);
  return this;
}

void re::TypeBuilder::addEnumConstantRenaming(re::TypeBuilder *this, uint64_t a2, StringID *a3)
{
  _QWORD *v3;
  uint64_t v4;
  _BYTE v5[16];

  if (*(_BYTE *)this == 2)
  {
    v3 = (_QWORD *)((char *)this + 232);
    v4 = a2;
    re::StringID::StringID((re::StringID *)v5, a3);
    re::DynamicArray<re::EnumConstant>::add(v3, &v4);
    re::StringID::destroyString((re::StringID *)v5);
  }
  else
  {
    if (!*(_BYTE *)this)
    {
      re::internal::assertLog((re::internal *)4, a2, a3, "assertion failure: '%s' (%s:line %i) beginEnumType() needs to be called before addEnumConstantRenaming().", "isBuilding()", "addEnumConstantRenaming", 633);
      _os_crash();
      __break(1u);
    }
    re::internal::assertLog((re::internal *)4, a2, a3, "assertion failure: '%s' (%s:line %i) Wrong type.", "m_category == TypeCategory::kEnum", "addEnumConstantRenaming", 634);
    _os_crash();
    __break(1u);
  }
}

uint64_t re::TypeBuilder::beginOptionalType(uint64_t a1, uint64_t *a2, unint64_t a3, unint64_t a4, __int128 *a5)
{
  int v10;
  uint64_t result;
  uint64_t v12;
  __int128 v13;
  _BYTE v14[24];
  uint64_t v15;

  v10 = -1;
  *(_DWORD *)(a1 + 32) = -1;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 52) = 0u;
  *(_OWORD *)(a1 + 68) = 0u;
  *(_QWORD *)(a1 + 88) = 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 96) = 1;
  *(_DWORD *)(a1 + 104) = -1;
  *(_QWORD *)(a1 + 116) = 0;
  *(_QWORD *)(a1 + 108) = 0;
  *(_DWORD *)(a1 + 124) = 0;
  v13 = *a5;
  re::TypeRegistry::typeInfo((re *)v13, (re **)&v13, v14);
  if (v14[0])
    v10 = *(_DWORD *)(v15 + 64);
  result = re::TypeBuilder::setSharedInfo(a1, 3, a2, 1, v10, a3, a4);
  v12 = *((_QWORD *)a5 + 1);
  *(_QWORD *)(a1 + 112) = 0;
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 104) = v12;
  return result;
}

uint64_t re::TypeBuilder::setOptionalAccessors(uint64_t this, void *(*a2)(void *), void (*a3)(void *, const void *))
{
  if (*(_BYTE *)this == 3)
  {
    *(_QWORD *)(this + 112) = a2;
    *(_QWORD *)(this + 120) = a3;
  }
  else
  {
    if (!*(_BYTE *)this)
    {
      re::internal::assertLog((re::internal *)4, (uint64_t)a2, a3, "assertion failure: '%s' (%s:line %i) beginOptionalType() needs to be called before setOptionalAccessors().", "isBuilding()", "setOptionalAccessors", 657);
      _os_crash();
      __break(1u);
    }
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, a3, "assertion failure: '%s' (%s:line %i) Wrong type.", "m_category == TypeCategory::kOptional", "setOptionalAccessors", 658);
    this = _os_crash();
    __break(1u);
  }
  return this;
}

uint64_t re::TypeBuilder::beginArrayType(uint64_t a1, uint64_t *a2, re **a3, unint64_t a4)
{
  uint64_t v8;
  int v9;
  __int128 v10;
  unint64_t v11;
  uint64_t result;
  __int128 v13;
  _BYTE v14[24];
  uint64_t v15;
  _BYTE v16[24];
  uint64_t v17;

  if (a4 >= 0x7FFFFFFF)
  {
    re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Invalid array size. Value: %zu, max: %d", "length < std::numeric_limits<int32_t>::max()", "beginArrayType", 674, a4, 0x7FFFFFFFLL);
    _os_crash();
    __break(1u);
    goto LABEL_7;
  }
  re::TypeRegistry::typeInfo(*a3, a3, v14);
  if (!v14[0])
  {
LABEL_7:
    re::internal::assertLog((re::internal *)4, v8, "assertion failure: '%s' (%s:line %i) Type is missing in type registry. Type might have been forward declared, but no type information was provided.", "elementTypeInfo", "beginArrayType", 678);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v9 = -1;
  *(_DWORD *)(a1 + 32) = -1;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 52) = 0u;
  *(_OWORD *)(a1 + 68) = 0u;
  *(_QWORD *)(a1 + 88) = 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 96) = 1;
  *(_QWORD *)&v10 = 0xFFFFFFFFLL;
  *((_QWORD *)&v10 + 1) = 0xFFFFFFFFLL;
  *(_OWORD *)(a1 + 104) = v10;
  *(_DWORD *)(a1 + 120) = 0;
  v13 = *(_OWORD *)a3;
  re::TypeRegistry::typeInfo((re *)v13, (re **)&v13, v16);
  if (v16[0])
    v9 = *(_DWORD *)(v17 + 64);
  v11 = re::internal::checkedArraySize(*(unsigned int *)(v15 + 8), a4);
  result = re::TypeBuilder::setSharedInfo(a1, 4, a2, 1, v9, v11, *(unsigned int *)(v15 + 12));
  *(_DWORD *)(a1 + 80) |= 8u;
  *(_QWORD *)(a1 + 104) = a3[1];
  *(_QWORD *)(a1 + 112) = 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 120) = a4;
  return result;
}

uint64_t re::TypeBuilder::beginArrayType(uint64_t a1, uint64_t *a2, re **a3, uint64_t a4, int a5)
{
  uint64_t v10;
  int v11;
  __int128 v12;
  uint64_t result;
  __int128 v14;
  _BYTE v15[24];
  uint64_t v16;
  _BYTE v17[24];
  uint64_t v18;

  re::TypeRegistry::typeInfo(*a3, a3, v15);
  if (v15[0])
  {
    v11 = -1;
    *(_DWORD *)(a1 + 32) = -1;
    *(_OWORD *)(a1 + 36) = 0u;
    *(_OWORD *)(a1 + 52) = 0u;
    *(_OWORD *)(a1 + 68) = 0u;
    *(_QWORD *)(a1 + 88) = 0xFFFFFFFFLL;
    *(_DWORD *)(a1 + 96) = 1;
    *(_QWORD *)&v12 = 0xFFFFFFFFLL;
    *((_QWORD *)&v12 + 1) = 0xFFFFFFFFLL;
    *(_OWORD *)(a1 + 104) = v12;
    *(_DWORD *)(a1 + 120) = 0;
    v14 = *(_OWORD *)a3;
    re::TypeRegistry::typeInfo((re *)v14, (re **)&v14, v17);
    if (v17[0])
      v11 = *(_DWORD *)(v18 + 64);
    result = re::TypeBuilder::setSharedInfo(a1, 4, a2, 1, v11, 8uLL, *(unsigned int *)(v16 + 12));
    *(_DWORD *)(a1 + 80) |= 8u;
    *(_QWORD *)(a1 + 104) = a3[1];
    *(_QWORD *)(a1 + 112) = *(_QWORD *)(a4 + 8);
    *(_DWORD *)(a1 + 120) = a5;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v10, "assertion failure: '%s' (%s:line %i) Type is missing in type registry. Type might have been forward declared, but no type information was provided.", "elementTypeInfo", "beginArrayType", 697);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

double re::TypeBuilder::beginListType(uint64_t a1, uint64_t *a2, int a3, unint64_t a4, unint64_t a5, __int128 *a6)
{
  int v12;
  double result;
  __int128 v14;
  _BYTE v15[24];
  uint64_t v16;

  v14 = *a6;
  re::TypeRegistry::typeInfo((re *)v14, (re **)&v14, v15);
  if (v15[0])
    v12 = *(_DWORD *)(v16 + 64);
  else
    v12 = -1;
  *(_DWORD *)(a1 + 32) = -1;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 52) = 0u;
  *(_OWORD *)(a1 + 68) = 0u;
  *(_QWORD *)(a1 + 88) = 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 96) = 1;
  *(_DWORD *)(a1 + 104) = -1;
  *(_OWORD *)(a1 + 108) = 0u;
  *(_OWORD *)(a1 + 124) = 0u;
  *(_OWORD *)(a1 + 140) = 0u;
  *(_DWORD *)(a1 + 156) = 0;
  re::TypeBuilder::setSharedInfo(a1, 5, a2, a3, v12, a4, a5);
  *(_QWORD *)(a1 + 104) = *((_QWORD *)a6 + 1);
  result = 0.0;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  return result;
}

uint64_t re::TypeBuilder::setListUsesContiguousStorage(uint64_t this, uint64_t a2)
{
  int v2;

  if (*(_BYTE *)this == 5)
  {
    if ((_DWORD)a2)
      v2 = 8;
    else
      v2 = 0;
    *(_DWORD *)(this + 80) = *(_DWORD *)(this + 80) & 0xFFFFFFF7 | v2;
  }
  else
  {
    if (!*(_BYTE *)this)
    {
      re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) beginListType() needs to be called before setListAccessors().", "isBuilding()", "setListUsesContiguousStorage", 739);
      _os_crash();
      __break(1u);
    }
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Wrong type.", "m_category == TypeCategory::kList", "setListUsesContiguousStorage", 740);
    this = _os_crash();
    __break(1u);
  }
  return this;
}

uint64_t re::TypeBuilder::setListAccessors(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)result == 5)
  {
    *(_QWORD *)(result + 112) = a2;
    *(_QWORD *)(result + 120) = a3;
  }
  else
  {
    if (!*(_BYTE *)result)
    {
      re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) beginListType() needs to be called before setListAccessors().", "isBuilding()", "setListAccessors", 747);
      _os_crash();
      __break(1u);
    }
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Wrong type.", "m_category == TypeCategory::kList", "setListAccessors", 748);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilder::setListIndexer(uint64_t this, void *(*a2)(void *, unint64_t))
{
  if (*(_BYTE *)this == 5)
  {
    *(_QWORD *)(this + 128) = a2;
  }
  else
  {
    if (!*(_BYTE *)this)
    {
      re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) beginListType() needs to be called before setListIndexer().", "isBuilding()", "setListIndexer", 758);
      _os_crash();
      __break(1u);
    }
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Wrong type.", "m_category == TypeCategory::kList", "setListIndexer", 759);
    this = _os_crash();
    __break(1u);
  }
  return this;
}

uint64_t re::TypeBuilder::setListIterator(uint64_t this, void *(*a2)(void *, re::Allocator *), void *(*a3)(void *), void (*a4)(void *, re::Allocator *))
{
  if (*(_BYTE *)this == 5)
  {
    *(_QWORD *)(this + 136) = a2;
    *(_QWORD *)(this + 144) = a3;
    *(_QWORD *)(this + 152) = a4;
  }
  else
  {
    if (!*(_BYTE *)this)
    {
      re::internal::assertLog((re::internal *)4, (uint64_t)a2, a3, a4, "assertion failure: '%s' (%s:line %i) beginListType() needs to be called before setListIterator().", "isBuilding()", "setListIterator", 769);
      _os_crash();
      __break(1u);
    }
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, a3, a4, "assertion failure: '%s' (%s:line %i) Wrong type.", "m_category == TypeCategory::kList", "setListIterator", 770);
    this = _os_crash();
    __break(1u);
  }
  return this;
}

uint64_t re::TypeBuilder::beginDictionaryType(uint64_t a1, uint64_t *a2, int a3, unint64_t a4, unint64_t a5, __int128 *a6, __int128 *a7)
{
  unsigned int v14;
  unsigned int v15;
  int v16;
  uint64_t result;
  __int128 v18;
  __int128 v19;
  _BYTE v20[24];
  uint64_t v21;

  v19 = *a6;
  re::TypeRegistry::typeInfo((re *)v19, (re **)&v19, v20);
  if (v20[0])
    v14 = *(_DWORD *)(v21 + 64);
  else
    v14 = -1;
  v18 = *a7;
  re::TypeRegistry::typeInfo((re *)v18, (re **)&v18, v20);
  if (v20[0])
    v15 = *(_DWORD *)(v21 + 64);
  else
    v15 = -1;
  *(_DWORD *)(a1 + 32) = -1;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 52) = 0u;
  *(_OWORD *)(a1 + 68) = 0u;
  *(_QWORD *)(a1 + 88) = 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 96) = 1;
  *(_QWORD *)(a1 + 104) = 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 112) = -1;
  *(_OWORD *)(a1 + 116) = 0u;
  *(_OWORD *)(a1 + 132) = 0u;
  *(_OWORD *)(a1 + 148) = 0u;
  *(_OWORD *)(a1 + 164) = 0u;
  if (v14 <= v15)
    v16 = v15;
  else
    v16 = v14;
  *(_OWORD *)(a1 + 176) = 0uLL;
  result = re::TypeBuilder::setSharedInfo(a1, 6, a2, a3, v16, a4, a5);
  *(_QWORD *)(a1 + 104) = *((_QWORD *)a6 + 1);
  *(_QWORD *)(a1 + 112) = *((_QWORD *)a7 + 1);
  return result;
}

uint64_t re::TypeBuilder::setDictionaryAccessors(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (*(_BYTE *)result == 6)
  {
    *(_QWORD *)(result + 120) = a2;
    *(_QWORD *)(result + 128) = a3;
    *(_QWORD *)(result + 136) = a4;
    *(_QWORD *)(result + 184) = a5;
  }
  else
  {
    if (!*(_BYTE *)result)
    {
      re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) beginDictionaryType() needs to be called before setDictionaryAccessors().", "isBuilding()", "setDictionaryAccessors", 803);
      _os_crash();
      __break(1u);
    }
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Wrong type.", "m_category == TypeCategory::kDictionary", "setDictionaryAccessors", 804);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilder::setDictionaryIterator(uint64_t this, void *(*a2)(void *, re::Allocator *), BOOL (*a3)(void *), const void *(*a4)(void *), void *(*a5)(void *), void (*a6)(void *, re::Allocator *))
{
  if (*(_BYTE *)this == 6)
  {
    *(_QWORD *)(this + 144) = a2;
    *(_QWORD *)(this + 152) = a3;
    *(_QWORD *)(this + 160) = a4;
    *(_QWORD *)(this + 168) = a5;
    *(_QWORD *)(this + 176) = a6;
  }
  else
  {
    if (!*(_BYTE *)this)
    {
      re::internal::assertLog((re::internal *)4, (uint64_t)a2, a3, a4, a5, a6, "assertion failure: '%s' (%s:line %i) beginDictionaryType() needs to be called before setDictionaryAccessors().", "isBuilding()", "setDictionaryIterator", 820);
      _os_crash();
      __break(1u);
    }
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, a3, a4, a5, a6, "assertion failure: '%s' (%s:line %i) Wrong type.", "m_category == TypeCategory::kDictionary", "setDictionaryIterator", 821);
    this = _os_crash();
    __break(1u);
  }
  return this;
}

uint64_t re::TypeBuilder::beginObjectType(uint64_t a1, uint64_t *a2, int a3, int a4, unint64_t a5, unint64_t a6, uint64_t a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t result;
  _BYTE v17[40];

  if (*(_QWORD *)a7 && (re::TypeRegistry::typeInfo(*(re **)a7, (re **)a7, v17), !v17[0]))
  {
    re::internal::assertLog((re::internal *)4, v14, "assertion failure: '%s' (%s:line %i) Super class type is missing in type registry. Super classes need to be registered before their sub-classes.", "typeRegistry->typeInfo(superClass)", "beginObjectType", 867);
    result = _os_crash();
    __break(1u);
  }
  else
  {
    v15 = 0xFFFFFFFFLL;
    *(_DWORD *)(a1 + 32) = -1;
    *(_OWORD *)(a1 + 36) = 0u;
    *(_OWORD *)(a1 + 52) = 0u;
    *(_OWORD *)(a1 + 68) = 0u;
    *(_QWORD *)(a1 + 88) = 0xFFFFFFFFLL;
    *(_DWORD *)(a1 + 96) = 1;
    *(_QWORD *)(a1 + 112) = 0;
    *(_QWORD *)(a1 + 120) = 0;
    *(_QWORD *)(a1 + 104) = 0;
    *(_DWORD *)(a1 + 128) = 0;
    re::StringID::invalid((re::StringID *)(a1 + 136));
    *(_BYTE *)(a1 + 152) = 0;
    *(_DWORD *)(a1 + 168) = -1;
    *(_QWORD *)(a1 + 176) = 0;
    result = re::TypeBuilder::setSharedInfo(a1, 8, a2, a3, a4, a5, a6);
    if (*(_QWORD *)a7)
      v15 = *(_QWORD *)(a7 + 8);
    *(_QWORD *)(a1 + 104) = v15;
    *(_DWORD *)(a1 + 112) = 1;
  }
  return result;
}

uint64_t re::TypeBuilder::setObjectSuperClass(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  if (*(_BYTE *)result == 8)
  {
    if (*a2)
      v2 = a2[1];
    else
      v2 = 0xFFFFFFFFLL;
    *(_QWORD *)(result + 104) = v2;
  }
  else
  {
    if (!*(_BYTE *)result)
    {
      re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) beginObjectType() needs to be called before addObjectMember().", "isBuilding()", "setObjectSuperClass", 878);
      _os_crash();
      __break(1u);
    }
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Wrong type.", "m_category == TypeCategory::kObject", "setObjectSuperClass", 879);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilder::addObjectMember(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, int a5)
{
  int v8;
  _anonymous_namespace_ *v10;
  uint64_t v11;
  uint64_t result;
  uint64_t v13;
  unint64_t v14[2];
  int v15;
  char v16;
  int v17;

  if (*(_BYTE *)a1 == 8)
  {
    v8 = a2;
    v13 = 0xFFFFFFFFLL;
    re::StringID::invalid((re::StringID *)v14);
    v15 = 0;
    v16 = 1;
    v17 = 0;
    v13 = *(_QWORD *)(a3 + 8);
    re::StringID::operator=(v14, a4);
    v15 = a5;
    v16 = 1;
    v17 = v8;
    v10 = (_anonymous_namespace_ *)(a1 + 312);
    v11 = *(unsigned int *)(a1 + 328);
    re::DynamicArray<re::internal::ObjectMemberInfo>::add(v10, (uint64_t)&v13);
    re::StringID::destroyString((re::StringID *)v14);
    return v11;
  }
  else
  {
    if (!*(_BYTE *)a1)
    {
      re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) beginObjectType() needs to be called before addObjectMember().", "isBuilding()", "addObjectMember", 887);
      _os_crash();
      __break(1u);
    }
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Wrong type.", "m_category == TypeCategory::kObject", "addObjectMember", 888);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

void re::TypeBuilder::addObjectMemberRenaming(re::TypeBuilder *this, const re::StringID *a2, const re::StringID *a3)
{
  const re::StringID *v3;
  unint64_t v5;
  unint64_t v7;
  const re::StringID *v8;
  uint64_t v9;

  if (*(_BYTE *)this == 8)
  {
    v3 = a2;
    v5 = *((_QWORD *)this + 41);
    if (v5)
    {
      v7 = 0;
      v8 = 0;
      v9 = *((_QWORD *)this + 43);
      while (!re::StringID::operator==((_QWORD *)(v9 + 40 * v7 + 8), v3))
      {
        v7 = ((_DWORD)v8 + 1);
        v8 = (const re::StringID *)v7;
        a2 = (const re::StringID *)v7;
        if (v5 <= v7)
          goto LABEL_8;
      }
      a2 = v8;
LABEL_8:
      if (v5 > v7)
      {
        re::TypeBuilder::addObjectMemberRenaming(this, (uint64_t)a2, a3);
        return;
      }
    }
  }
  else
  {
    if (!*(_BYTE *)this)
    {
      re::internal::assertLog((re::internal *)4, (uint64_t)a2, a3, "assertion failure: '%s' (%s:line %i) beginObjectType() needs to be called before addMemberSharedInternal().", "isBuilding()", "addObjectMemberRenaming", 911);
      _os_crash();
      __break(1u);
    }
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, a3, "assertion failure: '%s' (%s:line %i) Wrong type.", "m_category == TypeCategory::kObject", "addObjectMemberRenaming", 912);
    _os_crash();
    __break(1u);
  }
  re::internal::assertLog((re::internal *)5, (uint64_t)a2, a3, "assertion failure: '%s' (%s:line %i) No type member found with name \"%s\". Type members need to be defined before calls addObjectMemberRenaming().", "(size_t)index < m_objectMembers.size()", "addObjectMemberRenaming", 925, *((_QWORD *)v3 + 1));
  _os_crash();
  __break(1u);
}

void re::TypeBuilder::addObjectMemberRenaming(re::TypeBuilder *this, uint64_t a2, const re::StringID *a3)
{
  uint64_t v3;
  StringID v6;
  int v7;

  if (*(_BYTE *)this == 8)
  {
    v3 = a2;
    if (*((_QWORD *)this + 41) > (unint64_t)a2)
    {
      re::StringID::invalid((re::StringID *)&v6);
      v7 = v3;
      re::StringID::operator=((unint64_t *)&v6, (uint64_t *)a3);
      re::DynamicArray<re::RenamedObjectMember>::add((re::TypeBuilder *)((char *)this + 352), &v6);
      re::StringID::destroyString((re::StringID *)&v6);
      return;
    }
    goto LABEL_6;
  }
  if (!*(_BYTE *)this)
  {
    re::internal::assertLog((re::internal *)4, a2, a3, "assertion failure: '%s' (%s:line %i) beginObjectType() needs to be called before addMemberSharedInternal().", "isBuilding()", "addObjectMemberRenaming", 932);
    _os_crash();
    __break(1u);
LABEL_6:
    re::internal::assertLog((re::internal *)5, a2, "assertion failure: '%s' (%s:line %i) Invalid index %d. Type members need to be defined before calling addObjectMemberRenaming().", "memberIndex < m_objectMembers.size()", "addObjectMemberRenaming", 936, v3);
    _os_crash();
    __break(1u);
  }
  re::internal::assertLog((re::internal *)4, a2, a3, "assertion failure: '%s' (%s:line %i) Wrong type.", "m_category == TypeCategory::kObject", "addObjectMemberRenaming", 933);
  _os_crash();
  __break(1u);
}

re::StringID *re::DynamicArray<re::RenamedObjectMember>::add(_anonymous_namespace_ *this, StringID *a2)
{
  unint64_t v4;
  re::StringID *result;

  v4 = *((_QWORD *)this + 2);
  if (v4 >= *((_QWORD *)this + 1))
  {
    re::DynamicArray<re::AttributeArgument>::growCapacity(this, v4 + 1);
    v4 = *((_QWORD *)this + 2);
  }
  result = re::StringID::StringID((re::StringID *)(*((_QWORD *)this + 4) + 24 * v4), a2);
  *((_DWORD *)result + 4) = a2[1].var0;
  ++*((_QWORD *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

uint64_t re::TypeBuilder::addCustomClassID(uint64_t this, uint64_t a2)
{
  if (*(_BYTE *)this == 8)
  {
    if (!*(_BYTE *)(this + 152))
      *(_BYTE *)(this + 152) = 1;
    *(_QWORD *)(this + 160) = a2;
  }
  else
  {
    if (!*(_BYTE *)this)
    {
      re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) beginObjectType() needs to be called before addCustomClassID().", "isBuilding()", "addCustomClassID", 961);
      _os_crash();
      __break(1u);
    }
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Wrong type.", "m_category == TypeCategory::kObject", "addCustomClassID", 962);
    this = _os_crash();
    __break(1u);
  }
  return this;
}

void re::TypeBuilder::addObjectMemberCustomClassID(uint64_t a1, uint64_t a2, uint64_t *a3, int a4)
{
  re::TypeInfo *v4;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  unsigned __int8 v12[8];
  uint64_t v13;
  _QWORD v14[3];
  int v15;
  uint64_t v16;
  StringID v17;
  uint64_t v18;
  int v19;
  _BYTE v20[8];
  _BYTE v21[32];

  if (*(_BYTE *)a1 != 8)
  {
    if (*(_BYTE *)a1)
    {
LABEL_13:
      re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Wrong type.", "m_category == TypeCategory::kObject", "addObjectMemberCustomClassID", 970);
      _os_crash();
      __break(1u);
      return;
    }
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) beginObjectType() needs to be called before addMemberSharedInternal().", "isBuilding()", "addObjectMemberCustomClassID", 969);
    _os_crash();
    __break(1u);
    goto LABEL_10;
  }
  if ((*(_DWORD *)(a1 + 108) & 0xFFFFFF) != 0)
  {
LABEL_10:
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) addObjectMemberCustomClassID() can only be added to root class.", "m_objectTypeInfo.superClass.isNull()", "addObjectMemberCustomClassID", 974);
    _os_crash();
    __break(1u);
    goto LABEL_11;
  }
  v4 = (re::TypeInfo *)v20;
  re::TypeRegistry::typeInfo(*(re **)a2, (re **)a2, v20);
  if (!v20[0])
  {
LABEL_11:
    re::internal::assertLog((re::internal *)4, v9, "assertion failure: '%s' (%s:line %i) Type is missing in type registry. Type might have been forward declared, but no type information was provided.", "memberTypeInfo", "addObjectMemberCustomClassID", 978);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  v4 = (re::TypeInfo *)v21;
  if ((re::TypeInfo::isInteger((re::TypeInfo *)v21) & 1) == 0)
  {
LABEL_12:
    re::TypeInfo::name(v4);
    v10 = re::TypeInfo::name(v4);
    re::internal::assertLog((re::internal *)5, v11, "assertion failure: '%s' (%s:line %i) Custom class identifier expected to be basic or enum type. Type: %s", "memberTypeInfo.value().isInteger()", "addObjectMemberCustomClassID", 981, v10[1]);
    _os_crash();
    __break(1u);
    goto LABEL_13;
  }
  v16 = 0xFFFFFFFFLL;
  re::StringID::invalid((re::StringID *)&v17);
  LODWORD(v18) = 0;
  BYTE4(v18) = 1;
  v19 = 0;
  v16 = *(_QWORD *)(a2 + 8);
  re::StringID::operator=((unint64_t *)&v17, a3);
  LODWORD(v18) = a4;
  BYTE4(v18) = 1;
  v19 = -1;
  v12[0] = 1;
  v13 = v16;
  re::StringID::StringID((re::StringID *)v14, &v17);
  v14[2] = v18;
  v15 = v19;
  re::Optional<re::internal::ObjectMemberInfo>::operator=(a1 + 392, v12);
  if (v12[0])
    re::StringID::destroyString((re::StringID *)v14);
  re::StringID::destroyString((re::StringID *)&v17);
}

uint64_t re::TypeBuilder::setHideObjectWithOneMember(uint64_t this, uint64_t a2)
{
  int v2;

  if (*(_BYTE *)this)
  {
    if ((_DWORD)a2)
      v2 = 4;
    else
      v2 = 0;
    *(_DWORD *)(this + 80) = *(_DWORD *)(this + 80) & 0xFFFFFFFB | v2;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) beginObjectType() needs to be called before calling this function.", "isBuilding()", "setHideObjectWithOneMember", 1007);
    this = _os_crash();
    __break(1u);
  }
  return this;
}

uint64_t re::TypeBuilder::beginPointerType(uint64_t a1, uint64_t *a2, int a3, unint64_t a4, unint64_t a5, uint64_t a6, char a7)
{
  uint64_t result;

  *(_DWORD *)(a1 + 32) = -1;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 52) = 0u;
  *(_OWORD *)(a1 + 68) = 0u;
  *(_QWORD *)(a1 + 88) = 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 96) = 1;
  *(_QWORD *)(a1 + 104) = 0xFFFFFFFFLL;
  *(_BYTE *)(a1 + 112) = 1;
  *(_QWORD *)(a1 + 120) = 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 128) = 0;
  result = re::TypeBuilder::setSharedInfo(a1, 9, a2, a3, -1, a4, a5);
  *(_QWORD *)(a1 + 104) = *(_QWORD *)(a6 + 8);
  *(_BYTE *)(a1 + 112) = a7;
  return result;
}

uint64_t re::TypeBuilder::addCustomClassIDForPointer(uint64_t result, uint64_t a2, int a3)
{
  if (*(_BYTE *)result == 9)
  {
    *(_QWORD *)(result + 120) = *(_QWORD *)(a2 + 8);
    *(_DWORD *)(result + 128) = a3;
  }
  else
  {
    if (!*(_BYTE *)result)
    {
      re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) beginPointerType() needs to be called before setGetActualTypeFunction().", "isBuilding()", "addCustomClassIDForPointer", 1030);
      _os_crash();
      __break(1u);
    }
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Wrong type.", "m_category == TypeCategory::kPointer", "addCustomClassIDForPointer", 1031);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilder::addAttribute(_BYTE *a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  uint64_t v7;
  _BOOL8 v8;
  NSObject *v9;
  uint64_t result;
  uint8_t buf[24];
  __int128 v12;
  int v13;

  if (*a1)
  {
    *(_QWORD *)&v12 = *(_QWORD *)(a2 + 8);
    *((_QWORD *)&v12 + 1) = 0xFFFFFFFFLL;
    v13 = a4;
    v7 = (uint64_t)(a1 + 440);
    v8 = re::HashTable<re::internal::TypeAttributeKey,re::internal::TypeAttributeData,re::Hash<re::internal::TypeAttributeKey>,re::EqualTo<re::internal::TypeAttributeKey>,true,false>::containsKey((uint64_t)(a1 + 440), (uint64_t *)&v12);
    if (v8)
    {
      v9 = *re::foundationIntrospectionLogObjects((re *)v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_224FE9000, v9, OS_LOG_TYPE_DEFAULT, "Same attribute type added multiple times to type. Previous attributes will be overwritten. Only the last attribute will be kept.", buf, 2u);
      }
    }
    *(_QWORD *)buf = a3;
    *(_DWORD *)&buf[8] = a5;
    return re::HashTable<re::internal::TypeAttributeKey,re::internal::TypeAttributeData,re::Hash<re::internal::TypeAttributeKey>,re::EqualTo<re::internal::TypeAttributeKey>,true,false>::addOrReplace<re::internal::TypeAttributeData&>(v7, &v12, buf);
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) beginXxxType() needs to be called before calling addAttribute.", "isBuilding()", "addAttribute", 1043);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

BOOL re::HashTable<re::internal::TypeAttributeKey,re::internal::TypeAttributeData,re::Hash<re::internal::TypeAttributeKey>,re::EqualTo<re::internal::TypeAttributeKey>,true,false>::containsKey(uint64_t a1, uint64_t *a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char v9;

  v4 = re::Hash<re::internal::TypeAttributeKey>::operator()((uint64_t)&v9, (uint64_t)a2);
  v5 = 0x7FFFFFFFLL;
  if (*(_QWORD *)a1)
  {
    v6 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * (v4 % *(unsigned int *)(a1 + 24)));
    if ((_DWORD)v6 != 0x7FFFFFFF)
    {
      v7 = *(_QWORD *)(a1 + 16);
      v5 = 0x7FFFFFFFLL;
      while (!re::internal::TypeAttributeKey::operator==((unsigned __int16 *)(v7 + 56 * v6 + 16), a2))
      {
        v7 = *(_QWORD *)(a1 + 16);
        v6 = *(_DWORD *)(v7 + 56 * v6 + 8) & 0x7FFFFFFF;
        if (v6 == 0x7FFFFFFF)
          return v5 != 0x7FFFFFFF;
      }
      v5 = v6;
    }
  }
  return v5 != 0x7FFFFFFF;
}

uint64_t re::HashTable<re::internal::TypeAttributeKey,re::internal::TypeAttributeData,re::Hash<re::internal::TypeAttributeKey>,re::EqualTo<re::internal::TypeAttributeKey>,true,false>::addOrReplace<re::internal::TypeAttributeData&>(uint64_t a1, __int128 *a2, _OWORD *a3)
{
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  BOOL v11;
  unsigned int v12;
  uint64_t v13;
  char v15;

  v6 = re::Hash<re::internal::TypeAttributeKey>::operator()((uint64_t)&v15, (uint64_t)a2);
  v7 = v6;
  if (!*(_QWORD *)a1)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  v8 = v6 % *(unsigned int *)(a1 + 24);
  v9 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v8);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
LABEL_8:
    v12 = re::HashTable<re::internal::TypeAttributeKey,re::internal::TypeAttributeData,re::Hash<re::internal::TypeAttributeKey>,re::EqualTo<re::internal::TypeAttributeKey>,true,false>::addEmplace<re::internal::TypeAttributeData&>(a1, v8, v7, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    v13 = *(_QWORD *)(a1 + 16) + 56 * v12;
    return v13 + 40;
  }
  v10 = *(_QWORD *)(a1 + 16);
  while (1)
  {
    v11 = re::internal::TypeAttributeKey::operator==((unsigned __int16 *)(v10 + 56 * v9 + 16), (uint64_t *)a2);
    v10 = *(_QWORD *)(a1 + 16);
    if (v11)
      break;
    v9 = *(_DWORD *)(v10 + 56 * v9 + 8) & 0x7FFFFFFF;
    if (v9 == 0x7FFFFFFF)
      goto LABEL_8;
  }
  *(_OWORD *)(v10 + 56 * v9 + 40) = *a3;
  ++*(_DWORD *)(a1 + 40);
  v13 = *(_QWORD *)(a1 + 16) + 56 * v9;
  return v13 + 40;
}

_QWORD *re::DynamicArray<re::internal::ObjectMemberInfo>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::internal::ObjectMemberInfo>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x28uLL))
        {
          v2 = 40 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 40 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_16;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 40, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = (_QWORD *)v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = &v8[5 * v9];
        v11 = v7;
        do
        {
          *v11 = *v8;
          v13 = v8[1];
          v12 = v8 + 1;
          v11[1] = v11[1] & 0xFFFFFFFFFFFFFFFELL | v13 & 1;
          v11[1] = *v12 & 0xFFFFFFFFFFFFFFFELL | v13 & 1;
          v11[2] = v12[1];
          *v12 = 0;
          v12[1] = &str_110;
          v14 = v12[2];
          *((_DWORD *)v11 + 8) = *((_DWORD *)v12 + 6);
          v11[3] = v14;
          re::StringID::destroyString((re::StringID *)v12);
          v8 = v12 + 4;
          v11 += 5;
        }
        while (v8 != v10);
        v8 = (_QWORD *)v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

_QWORD *re::DynamicArray<re::internal::EnumTypeInfo>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  void *v7;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (*v5)
      {
        if (!a2)
        {
          v7 = 0;
          if (!v3)
            goto LABEL_9;
          goto LABEL_8;
        }
        if (is_mul_ok(a2, 0x60uLL))
        {
          v2 = 96 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 96 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
            {
LABEL_9:
              v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            memcpy(v7, (const void *)v5[4], 96 * v5[2]);
            result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 96, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
      }
      else
      {
        result = (_QWORD *)re::DynamicArray<re::internal::EnumTypeInfo>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

_QWORD *re::DynamicArray<re::EnumConstant>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<re::Pair<unsigned long,re::StringID,true>>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::Pair<unsigned long,re::StringID,true>>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

_QWORD *re::DynamicArray<re::internal::ListTypeInfo>::setCapacity(_QWORD *result, unint64_t a2)
{
  unint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  void *v7;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (*v5)
      {
        if (!a2)
        {
          v7 = 0;
          if (!v3)
            goto LABEL_9;
          goto LABEL_8;
        }
        if (a2 >> 57)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 128, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          v2 = a2 << 7;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, a2 << 7, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
            {
LABEL_9:
              v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            memcpy(v7, (const void *)v5[4], v5[2] << 7);
            result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
      }
      else
      {
        result = (_QWORD *)re::DynamicArray<re::internal::ListTypeInfo>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

_QWORD *re::DynamicArray<re::internal::ObjectMemberInfo>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<re::internal::ObjectMemberInfo>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::internal::ObjectMemberInfo>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

unint64_t *std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::internal::ObjectMemberInfo const*,re::internal::ObjectMemberInfo const*,re::internal::ObjectMemberInfo*,0>(unint64_t *result, unint64_t *a2, uint64_t a3)
{
  unint64_t *v4;
  unint64_t *v5;
  unint64_t *v6;
  unint64_t v7;
  unint64_t *v8;

  if (result != a2)
  {
    v4 = result;
    result = (unint64_t *)(a3 + 8);
    v5 = v4 + 1;
    do
    {
      *(result - 1) = *(v5 - 1);
      v6 = re::StringID::operator=(result, (uint64_t *)v5);
      v7 = v5[2];
      *((_DWORD *)v6 + 6) = *((_DWORD *)v5 + 6);
      v6[2] = v7;
      result = v6 + 5;
      v8 = v5 + 4;
      v5 += 5;
    }
    while (v8 != a2);
  }
  return result;
}

unint64_t *std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::RenamedObjectMember const*,re::RenamedObjectMember const*,re::RenamedObjectMember*,0>(unint64_t *result, unint64_t *a2, uint64_t a3)
{
  unint64_t *v5;

  if (result != a2)
  {
    v5 = result;
    do
    {
      result = re::StringID::operator=((unint64_t *)a3, (uint64_t *)v5);
      *(_DWORD *)(a3 + 16) = *((_DWORD *)v5 + 4);
      v5 += 3;
      a3 += 24;
    }
    while (v5 != a2);
  }
  return result;
}

_QWORD *re::DynamicArray<re::internal::ObjectTypeInfo>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<re::internal::ObjectTypeInfo>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::internal::ObjectTypeInfo>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

_QWORD *re::DynamicArray<re::internal::ObjectTypeInfo>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::internal::ObjectTypeInfo>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x98uLL))
        {
          v2 = 152 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 152 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_18;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 152, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_18:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = v8 + 152 * v9;
        v11 = v7 + 16;
        v12 = v8 + 128;
        do
        {
          *((_OWORD *)v11 - 8) = *(_OWORD *)(v12 - 128);
          v13 = *(_OWORD *)(v12 - 112);
          v14 = *(_OWORD *)(v12 - 96);
          v15 = *(_OWORD *)(v12 - 80);
          *(v11 - 8) = *(_QWORD *)(v12 - 64);
          *((_OWORD *)v11 - 6) = v14;
          *((_OWORD *)v11 - 5) = v15;
          *((_OWORD *)v11 - 7) = v13;
          v16 = *(_OWORD *)(v12 - 56);
          *(_OWORD *)((char *)v11 - 44) = *(_OWORD *)(v12 - 44);
          *(_OWORD *)(v11 - 7) = v16;
          v17 = *(_QWORD *)(v12 - 24);
          *(v11 - 3) = *(v11 - 3) & 0xFFFFFFFFFFFFFFFELL | v17 & 1;
          *(v11 - 3) = *(_QWORD *)(v12 - 24) & 0xFFFFFFFFFFFFFFFELL | v17 & 1;
          *(v11 - 2) = *(_QWORD *)(v12 - 16);
          *(_QWORD *)(v12 - 24) = 0;
          *(_QWORD *)(v12 - 16) = &str_110;
          LODWORD(v17) = *(unsigned __int8 *)(v12 - 8);
          *((_BYTE *)v11 - 8) = v17;
          if ((_DWORD)v17)
            *v11 = *(_QWORD *)v12;
          v18 = v12 - 128;
          *(_OWORD *)(v11 + 1) = *(_OWORD *)(v12 + 8);
          re::StringID::destroyString((re::StringID *)(v12 - 24));
          v11 += 19;
          v12 += 152;
        }
        while (v18 + 152 != v10);
        v8 = v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_18;
    }
  }
  return result;
}

_QWORD *re::DynamicArray<re::internal::PointerTypeInfo>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  void *v7;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (*v5)
      {
        if (!a2)
        {
          v7 = 0;
          if (!v3)
            goto LABEL_9;
          goto LABEL_8;
        }
        if (is_mul_ok(a2, 0x68uLL))
        {
          v2 = 104 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 104 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
            {
LABEL_9:
              v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            memcpy(v7, (const void *)v5[4], 104 * v5[2]);
            result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 104, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
      }
      else
      {
        result = (_QWORD *)re::DynamicArray<re::internal::PointerTypeInfo>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

uint64_t re::HashTable<re::internal::TypeAttributeKey,re::internal::TypeAttributeData,re::Hash<re::internal::TypeAttributeKey>,re::EqualTo<re::internal::TypeAttributeKey>,true,false>::addEmplace<re::internal::TypeAttributeData&>(uint64_t a1, unsigned int a2, unint64_t a3, __int128 *a4, _OWORD *a5)
{
  uint64_t v9;
  int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  __int128 v14;

  v9 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
    v9 = *(unsigned int *)(a1 + 32);
    v10 = v9;
    if ((_DWORD)v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::internal::TypeAttributeKey,re::internal::TypeAttributeData,re::Hash<re::internal::TypeAttributeKey>,re::EqualTo<re::internal::TypeAttributeKey>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 56 * v9 + 8);
  }
  else
  {
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 56 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v11 + 56 * v9 + 8) = v12 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 56 * v9 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 56 * v9 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 56 * v9) = a3;
  v13 = *(_QWORD *)(a1 + 16) + 56 * v9;
  v14 = *a4;
  *(_QWORD *)(v13 + 32) = *((_QWORD *)a4 + 2);
  *(_OWORD *)(v13 + 16) = v14;
  *(_OWORD *)(*(_QWORD *)(a1 + 16) + 56 * v9 + 40) = *a5;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

BOOL re::internal::TypeAttributeKey::operator==(unsigned __int16 *a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *a2;
  if (*a1 == (unsigned __int16)*a2
    && a1[1] == WORD1(v2)
    && ((*((_DWORD *)a1 + 1) ^ HIDWORD(v2)) & 0xFFFFFF) == 0
    && (v3 = a2[1], a1[4] == (unsigned __int16)v3)
    && a1[5] == WORD1(v3)
    && ((*((_DWORD *)a1 + 3) ^ HIDWORD(v3)) & 0xFFFFFF) == 0)
  {
    return *((_DWORD *)a1 + 4) == *((_DWORD *)a2 + 4);
  }
  else
  {
    return 0;
  }
}

uint64_t re::Hash<re::internal::TypeAttributeKey>::operator()(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unsigned int v6;

  v2 = 0xBF58476D1CE4E5B9 * (*(_QWORD *)a2 ^ (*(_QWORD *)a2 >> 30));
  v3 = (0x94D049BB133111EBLL * (v2 ^ (v2 >> 27))) ^ ((0x94D049BB133111EBLL * (v2 ^ (v2 >> 27))) >> 31);
  v4 = 0xBF58476D1CE4E5B9 * (*(_QWORD *)(a2 + 8) ^ (*(_QWORD *)(a2 + 8) >> 30));
  v5 = (0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) ^ ((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) >> 31);
  v6 = 73244475 * (*(_DWORD *)(a2 + 16) ^ HIWORD(*(_DWORD *)(a2 + 16)));
  return ((v3 << 6)
        + (v3 >> 2)
        - 0x61C8864680B583E9
        + (((v5 << 6)
          + (v5 >> 2)
          + ((73244475 * (v6 ^ HIWORD(v6))) ^ ((73244475 * (v6 ^ HIWORD(v6))) >> 16))
          - 0x61C8864680B583E9) ^ v5)) ^ v3;
}

void re::HashTable<re::internal::TypeAttributeKey,re::internal::TypeAttributeData,re::Hash<re::internal::TypeAttributeKey>,re::EqualTo<re::internal::TypeAttributeKey>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  unsigned int v7;
  __int128 v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  signed int v12;
  _BYTE v13[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(_QWORD *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::internal::TypeAttributeKey,re::internal::TypeAttributeData,re::Hash<re::internal::TypeAttributeKey>,re::EqualTo<re::internal::TypeAttributeKey>,true,false>::init((uint64_t)v13, v4, a2);
      v5 = *(_OWORD *)v13;
      *(_OWORD *)v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      v6 = *(_QWORD *)&v13[16];
      *(_QWORD *)&v13[16] = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 16) = v6;
      v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      v9 = v7;
      if (v7)
      {
        v10 = 0;
        v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(_QWORD *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<re::internal::TypeAttributeKey,re::internal::TypeAttributeData,re::Hash<re::internal::TypeAttributeKey>,re::EqualTo<re::internal::TypeAttributeKey>,true,false>::addEmplace<re::internal::TypeAttributeData&>(a1, *(_QWORD *)(*(_QWORD *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(*(_QWORD *)&v13[16] + v10), *(_QWORD *)&v13[16] + v10 + 16, *(_QWORD *)&v13[16] + v10 + 40);
            v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 56;
        }
        while (v11 < v9);
      }
      re::HashTable<re::Pair<re::StringSlice,re::StringSlice,true>,unsigned long,re::Hash<re::Pair<re::StringSlice,re::StringSlice,true>>,re::EqualTo<re::Pair<re::StringSlice,re::StringSlice,true>>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2)
      v12 = a2;
    else
      v12 = 3;
  }
}

uint64_t *re::internal::typeRegistryAllocator(re::internal *this)
{
  unsigned __int8 v1;

  {
    byte_25582A280 = 0;
    re::internal::typeRegistryAllocator(void)::allocator = (uint64_t)&off_24ED42648;
    *(_QWORD *)algn_25582A278 = "TypeInfo allocator";
  }
  return &re::internal::typeRegistryAllocator(void)::allocator;
}

void `anonymous namespace'::getOrCreateGlobalTypeRegistry(_anonymous_namespace_ *this, const re::IntrospectionBase *a2, char a3)
{
  int v4;
  char v5;
  unsigned __int8 v6;
  char v7;
  std::__shared_mutex_base *v8;
  const re::IntrospectionBase *v9;
  const re::IntrospectionBase *v10;
  BOOL v11;
  const re::IntrospectionBase *v12;
  const re::IntrospectionBase *v13;
  const re::IntrospectionBase *v14;
  const re::IntrospectionBase *v15;
  const re::IntrospectionBase *v16;
  const re::IntrospectionBase *v17;
  const re::IntrospectionBase *v18;
  const re::IntrospectionBase *v19;
  const re::IntrospectionBase *v20;
  const re::IntrospectionBase *v21;
  _anonymous_namespace_ *v22;
  uint64_t v23;
  std::__shared_mutex_base *v24;
  uint64_t v25;
  _QWORD v26[2];
  uint64_t v27;
  _QWORD v28[2];
  uint64_t v29;
  const char *v30;
  StringID v31;

  v4 = (int)a2;
  v5 = (char)this;
  v6 = atomic_load((unsigned __int8 *)&qword_25411C658);
  if ((v6 & 1) == 0)
    goto LABEL_18;
  while (1)
  {
    if ((v5 & 1) != 0 || v4)
    {
      if ((_MergedGlobals_414 & 1) != 0)
        return;
    }
    else
    {
      re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v29);
      v7 = _MergedGlobals_414;
      re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v29);
      if ((v7 & 1) != 0)
        return;
    }
    if ((a3 & 1) == 0)
    {
      re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Attempting to create the global type registry when it cannot be created.", "canCreateRegistry", "getOrCreateGlobalTypeRegistry", 44);
      _os_crash();
      __break(1u);
      goto LABEL_17;
    }
    if ((v5 & 1) != 0)
      goto LABEL_11;
    if (!v4)
      break;
LABEL_17:
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Attempting to lock introspectionSharedMutex when it is already locked. Forcing a crash because this would hang otherwise.", "!threadOwnsSharedLock", "getOrCreateGlobalTypeRegistry", 49);
    _os_crash();
    __break(1u);
LABEL_18:
    this = (_anonymous_namespace_ *)__cxa_guard_acquire(&qword_25411C658);
    if ((_DWORD)this)
    {
      re::internal::typeRegistryAllocator(this);
      __cxa_guard_release(&qword_25411C658);
    }
  }
  v8 = re::introspectionSharedMutex(this);
  std::__shared_mutex_base::lock(v8);
LABEL_11:
  if ((_MergedGlobals_414 & 1) == 0)
  {
    _MergedGlobals_414 = 1;
    re::introspect_BOOL((re *)1, a2);
    re::introspect_char((re *)1, v9);
    re::introspect_double((re *)1, v10);
    re::introspect_float((re *)1, v11);
    re::introspect_short((re *)1, v12);
    re::introspect_int((re *)1, v13);
    re::introspect_long((re *)1, v14);
    re::introspect_size_t((re *)1, v15);
    re::introspect_int64_t((re *)1, v16);
    re::introspect_uint8_t((re *)1, v17);
    re::introspect_uint16_t((re *)1, v18);
    re::introspect_uint32_t((re *)1, v19);
    re::introspect_uint64_t((re *)1, v20);
    re::IntrospectionInfo<char *>::get(1, v21);
    v29 = 218827000;
    v30 = "short";
    *(_QWORD *)&v31.var0 = 0x2CE93A4A92;
    v31.var1 = "int16_t";
    re::StringID::destroyString((re::StringID *)&v31);
    re::StringID::destroyString((re::StringID *)&v29);
    v29 = 208862;
    v30 = "int";
    *(_QWORD *)&v31.var0 = 0x2CE93BFE06;
    v31.var1 = "int32_t";
    re::StringID::destroyString((re::StringID *)&v31);
    re::StringID::destroyString((re::StringID *)&v29);
    *(_QWORD *)&v31.var0 = 0x258C98EAAF29A10ALL;
    v31.var1 = "CallbackSerializerAttribute";
    v28[0] = 0;
    v28[1] = 0xFFFFFFFFLL;
    re::TypeBuilder::beginObjectType((uint64_t)&v29, (uint64_t *)&v31, 1, 1, 8uLL, 8uLL, (uint64_t)v28);
    re::StringID::destroyString((re::StringID *)&v31);
    *(_QWORD *)&v31.var0 = 0xAE8345F9D646D604;
    v31.var1 = "ComplexVersioningAttribute";
    v26[0] = 0;
    v26[1] = 0xFFFFFFFFLL;
    re::TypeBuilder::beginObjectType((uint64_t)&v29, (uint64_t *)&v31, 1, 1, 8uLL, 8uLL, (uint64_t)v26);
    re::StringID::destroyString((re::StringID *)&v31);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v29, v23);
  }
  if ((v5 & 1) == 0)
  {
    v24 = re::introspectionSharedMutex(this);
    std::__shared_mutex_base::unlock(v24);
  }
}

uint64_t *re::IntrospectionInfo<char *>::get(int a1, const re::IntrospectionBase *a2)
{
  unsigned __int8 v3;
  int v4;
  re *v5;
  std::__shared_mutex_base *v6;
  re *v7;
  _OWORD *v8;
  re::IntrospectionRegistry *v9;
  const re::IntrospectionBase *v10;
  BOOL v11;
  const char *v12;
  __int128 v13;
  std::__shared_mutex_base *v14;
  __int128 v16;
  __int128 v17;
  const char *v18;
  unint64_t v19;
  char *__s1;

  {
    re::IntrospectionPointer::IntrospectionPointer((re::IntrospectionPointer *)&re::IntrospectionInfo<char *>::get(BOOL)::info);
  }
  if (a1)
  {
    if (re::IntrospectionInfo<char *>::get(BOOL)::isInitialized)
      return &re::IntrospectionInfo<char *>::get(BOOL)::info;
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v17);
    v4 = re::IntrospectionInfo<char *>::get(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v17);
    if (v4)
      return &re::IntrospectionInfo<char *>::get(BOOL)::info;
    v6 = re::introspectionSharedMutex(v5);
    std::__shared_mutex_base::lock(v6);
    if (re::IntrospectionInfo<char *>::get(BOOL)::isInitialized)
    {
LABEL_19:
      v14 = re::introspectionSharedMutex(v7);
      std::__shared_mutex_base::unlock(v14);
      return &re::IntrospectionInfo<char *>::get(BOOL)::info;
    }
  }
  re::IntrospectionInfo<char *>::get(BOOL)::isInitialized = 1;
  v8 = re::introspect_char((re *)1, a2);
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)&re::IntrospectionInfo<char *>::get(BOOL)::info, 0);
  qword_255825530 = 0x800000001;
  dword_255825538 = 8;
  word_25582553C = 0;
  *(_QWORD *)&xmmword_255825540 = 0;
  *((_QWORD *)&xmmword_255825540 + 1) = 0xFFFFFFFFLL;
  re::IntrospectionInfo<char *>::get(BOOL)::info = (uint64_t)&off_24ED30800;
  qword_255825550 = (uint64_t)v8;
  unk_255825558 = 0;
  re::IntrospectionRegistry::add(v9, v10);
  re::getPrettyTypeName((re *)&re::IntrospectionInfo<char *>::get(BOOL)::info, (const re::IntrospectionBase *)&v17);
  if ((BYTE8(v17) & 1) != 0)
    v12 = v18;
  else
    v12 = (char *)&v17 + 9;
  if ((_QWORD)v17 && (BYTE8(v17) & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v17 + 40))();
  if (v19 >> 1 == 94623636 && (__s1 == "char*" || !strcmp(__s1, "char*")))
  {
    v13 = v17;
  }
  else
  {
    v17 = v8[2];
    v13 = v16;
  }
  xmmword_255825540 = v13;
  re::StringID::destroyString((re::StringID *)&v19);
  if ((a1 & 1) == 0)
    goto LABEL_19;
  return &re::IntrospectionInfo<char *>::get(BOOL)::info;
}

uint64_t *re::foundationIntrospectionLogObjects(re *this)
{
  unsigned __int8 v1;

  if ((v1 & 1) == 0
  {
    re::foundationIntrospectionLogObjects(void)::logObjects = (uint64_t)os_log_create("com.apple.re", "Foundation.Introspection");
  }
  return &re::foundationIntrospectionLogObjects(void)::logObjects;
}

uint64_t re::TypeInfo::TypeInfo(uint64_t result, uint64_t a2, int a3, uint64_t a4)
{
  *(_QWORD *)result = a2;
  *(_BYTE *)(result + 12) = a3;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 24);
  if ((a3 - 1) >= 9)
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Invalid type category.", "!\"Unreachable code\"", "TypeInfo", 46);
    result = _os_crash();
    __break(1u);
  }
  else
  {
    *(_QWORD *)(result + 16) = a4;
  }
  return result;
}

uint64_t re::TypeInfo::TypeInfo(uint64_t result, uint64_t a2)
{
  int v2;

  *(_QWORD *)result = *(_QWORD *)a2;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  v2 = *(unsigned __int8 *)(a2 + 12);
  *(_BYTE *)(result + 12) = v2;
  if ((v2 - 1) >= 9)
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Invalid type category.", "!\"Unreachable code\"", "TypeInfo", 66);
    result = _os_crash();
    __break(1u);
  }
  else
  {
    *(_QWORD *)(result + 16) = *(_QWORD *)(a2 + 16);
  }
  return result;
}

uint64_t re::TypeInfo::operator=(uint64_t result, uint64_t a2)
{
  int v2;

  if (result != a2)
  {
    *(_QWORD *)result = *(_QWORD *)a2;
    *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
    v2 = *(unsigned __int8 *)(a2 + 12);
    *(_BYTE *)(result + 12) = v2;
    if ((v2 - 1) >= 9)
    {
      re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Invalid type category.", "!\"Unreachable code\"", "operator=", 91);
      result = _os_crash();
      __break(1u);
    }
    else
    {
      *(_QWORD *)(result + 16) = *(_QWORD *)(a2 + 16);
    }
  }
  return result;
}

uint64_t *re::TypeInfo::name(re::TypeInfo *this)
{
  uint64_t *result;

  result = (uint64_t *)re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)this + 96, **((_QWORD **)this + 2));
  if (!result)
  {
  }
  return result;
}

uint64_t re::TypeInfo::atVersion@<X0>(re::TypeInfo *this@<X0>, int a2@<W1>, unsigned __int8 *a3@<X8>)
{
  uint64_t result;
  int v6;
  int v7;
  unsigned __int8 v8[40];
  unsigned __int8 v9[8];
  _QWORD *v10[2];
  uint64_t v11;

  v9[0] = 1;
  for (result = re::TypeInfo::TypeInfo((uint64_t)v10, (uint64_t)this);
        ;
        result = (uint64_t)re::Optional<re::TypeInfo>::operator=(v9, v8))
  {
    if (!v9[0])
    {
      *a3 = 0;
      return result;
    }
    result = re::DataArray<re::TextureAtlasTile>::tryGet((uint64_t)(v10[0] + 12), *(_QWORD *)v11);
    v6 = result ? *(_DWORD *)(result + 16) : -1;
    if (v6 == a2)
      break;
    if ((*(_DWORD *)(v11 + 60) & 0xFFFFFF) != 0)
      re::TypeRegistry::typeInfo(v10[0], *(_QWORD *)(v11 + 56), v8);
    else
      v8[0] = 0;
  }
  v7 = v9[0];
  *a3 = v9[0];
  if (v7)
    return re::TypeInfo::TypeInfo((uint64_t)(a3 + 8), (uint64_t)v10);
  return result;
}

uint64_t re::TypeInfo::nextVersion@<X0>(re::TypeInfo *this@<X0>, const re::TypeInfo *a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result;
  unsigned __int8 v6[40];
  _BYTE v7[8];
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10[2];
  uint64_t v11;

  result = re::TypeInfo::TypeInfo((uint64_t)v10, (uint64_t)a2);
  if ((*(_DWORD *)(v11 + 60) & 0xFFFFFF) != 0
    && (result = (uint64_t)re::TypeRegistry::typeInfo(v10[0], *(_QWORD *)(v11 + 56), v7), v7[0]))
  {
    while (v9 != *((_QWORD *)this + 2))
    {
      re::TypeInfo::operator=((uint64_t)v10, (uint64_t)&v8);
      if ((*(_DWORD *)(v9 + 60) & 0xFFFFFF) != 0)
        re::TypeRegistry::typeInfo(v8, *(_QWORD *)(v9 + 56), v6);
      else
        v6[0] = 0;
      result = (uint64_t)re::Optional<re::TypeInfo>::operator=(v7, v6);
      if (!v7[0])
        goto LABEL_8;
    }
    *a3 = 1;
    return re::TypeInfo::TypeInfo((uint64_t)(a3 + 8), (uint64_t)v10);
  }
  else
  {
LABEL_8:
    *a3 = 0;
  }
  return result;
}

void **re::TypeInfo::createInstance(re::TypeInfo *this, re::Allocator *a2, void *a3)
{
  uint64_t v6;
  size_t v7;
  unsigned int v8;
  uint64_t v9;
  void **v10;
  void *memptr;

  v6 = *((_QWORD *)this + 2);
  LODWORD(v7) = *(_DWORD *)(v6 + 8);
  v8 = *(_DWORD *)(v6 + 12);
  if (v7 <= 8)
    v7 = 8;
  else
    v7 = v7;
  if (v8 <= 0x10)
    v9 = 16;
  else
    v9 = v8;
  if ((*(_BYTE *)(v6 + 48) & 0x20) != 0)
  {
    memptr = 0;
    malloc_type_posix_memalign(&memptr, (v9 + 7) & 0x1FFFFFFF8, v7, 0xC75C8B65uLL);
    v10 = (void **)memptr;
  }
  else
  {
    v10 = (void **)(*(uint64_t (**)(re::Allocator *, size_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v7, v9);
  }
  re::TypeInfo::construct(this, v10, a2, a3);
  return v10;
}

void re::TypeInfo::construct(re::TypeInfo *this, void **a2, re::Allocator *a3, void *a4)
{
  uint64_t v8;
  void (*v9)(void **, re::TypeInfo *, re::Allocator *, void *);
  NSObject *v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t i;
  void *v20;
  _BYTE v21[32];
  _QWORD *v22[2];
  uint64_t v23;
  uint8_t buf[4];
  _DWORD v25[11];

  *(_QWORD *)&v25[9] = *MEMORY[0x24BDAC8D0];
  v8 = *((_QWORD *)this + 2);
  v9 = *(void (**)(void **, re::TypeInfo *, re::Allocator *, void *))(v8 + 16);
  if (v9)
  {
    v9(a2, this, a3, a4);
  }
  else
  {
    switch(*((_BYTE *)this + 12))
    {
      case 1:
      case 3:
      case 8:
      case 9:
        goto LABEL_4;
      case 2:
        v13 = re::TypeInfo::enumConstants(this);
        if (!v14)
          goto LABEL_17;
        v15 = (const void *)v13;
        v16 = 0;
        break;
      case 4:
        re::TypeInfo::TypeInfo((uint64_t)v22, (uint64_t)this);
        re::TypeRegistry::typeInfo(v22[0], *(_QWORD *)(v23 + 72), buf);
        re::TypeInfo::TypeInfo((uint64_t)v21, (uint64_t)&v25[1]);
        if ((*(_DWORD *)(v23 + 84) & 0xFFFFFF) != 0)
        {
          re::ArrayAccessor::reset((re::ArrayAccessor *)v22, a2, a3, 0);
        }
        else
        {
          v17 = re::ArrayAccessor::size((re::ArrayAccessor *)v22, (char *)a2);
          if (v17)
          {
            v18 = v17;
            for (i = 0; i != v18; ++i)
            {
              v20 = (void *)re::ArrayAccessor::elementAtUnchecked((re::ArrayAccessor *)v22, a2, i);
              re::TypeInfo::construct((re::TypeInfo *)v21, v20, a3, a4);
            }
          }
        }
        return;
      case 5:
      case 6:
        v10 = *re::foundationIntrospectionLogObjects(this);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          v11 = (uint64_t *)re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)this + 96, **((_QWORD **)this + 2));
          if (!v11)
          {
          }
          v12 = v11[1];
          *(_DWORD *)buf = 136315138;
          *(_QWORD *)v25 = v12;
          _os_log_impl(&dword_224FE9000, v10, OS_LOG_TYPE_DEFAULT, "No explicit constructor set for %s.", buf, 0xCu);
        }
        bzero(a2, *(unsigned int *)(*((_QWORD *)this + 2) + 8));
        return;
      case 7:
        goto LABEL_23;
      default:
        re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Invalid type category.", "!\"Unreachable code\"", "construct", 371);
        _os_crash();
        __break(1u);
LABEL_23:
        re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Tagged unions can't be created directly. They need to be embedded in a class/struct.", "!\"Unreachable code\"", "construct", 361);
        _os_crash();
        __break(1u);
        JUMPOUT(0x225B6BC98);
    }
    while (*(_QWORD *)(v13 + v16))
    {
      v16 += 24;
      if (24 * v14 == v16)
      {
        re::Slice<re::EnumConstant>::first(v14, v14);
        memcpy(a2, v15, *(unsigned int *)(*((_QWORD *)this + 2) + 8));
        return;
      }
    }
LABEL_17:
    v8 = *((_QWORD *)this + 2);
LABEL_4:
    bzero(a2, *(unsigned int *)(v8 + 8));
  }
}

void re::TypeInfo::releaseInstance(re::TypeInfo *this, void *a2, re::Allocator *a3, void *a4)
{
  uint64_t v5;
  void (*v8)(void *);

  v5 = *((_QWORD *)this + 2);
  if ((*(_BYTE *)(v5 + 49) & 2) != 0)
  {
    v8 = *(void (**)(void *))(v5 + 40);
    if (v8)
      v8(a2);
  }
  else
  {
    re::TypeInfo::destruct(this, a2, a3, a4);
    if ((*(_BYTE *)(*((_QWORD *)this + 2) + 48) & 0x20) != 0)
      free(a2);
    else
      (*(void (**)(re::Allocator *, void *))(*(_QWORD *)a3 + 40))(a3, a2);
  }
}

void re::TypeInfo::destruct(re::TypeInfo *this, void *a2, re::Allocator *a3, void *a4)
{
  void (*v8)(void *, re::TypeInfo *, re::Allocator *, void *);
  NSObject *v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t i;
  void *v15;
  _BYTE v16[32];
  _QWORD *v17[2];
  uint64_t v18;
  uint8_t buf[4];
  _DWORD v20[11];

  *(_QWORD *)&v20[9] = *MEMORY[0x24BDAC8D0];
  v8 = *(void (**)(void *, re::TypeInfo *, re::Allocator *, void *))(*((_QWORD *)this + 2) + 24);
  if (!v8)
  {
    switch(*((_BYTE *)this + 12))
    {
      case 1:
      case 2:
      case 8:
      case 9:
        return;
      case 3:
        re::TypeInfo::TypeInfo((uint64_t)buf, (uint64_t)this);
        (*(void (**)(void *, _QWORD))(*(_QWORD *)&v20[3] + 88))(a2, 0);
        return;
      case 4:
        re::TypeInfo::TypeInfo((uint64_t)v17, (uint64_t)this);
        re::TypeRegistry::typeInfo(v17[0], *(_QWORD *)(v18 + 72), buf);
        re::TypeInfo::TypeInfo((uint64_t)v16, (uint64_t)&v20[1]);
        if ((*(_DWORD *)(v18 + 84) & 0xFFFFFF) != 0)
        {
          re::ArrayAccessor::reset((re::ArrayAccessor *)v17, a2, a3, 0);
        }
        else
        {
          v12 = re::ArrayAccessor::size((re::ArrayAccessor *)v17, (char *)a2);
          if (v12)
          {
            v13 = v12;
            for (i = 0; i != v13; ++i)
            {
              v15 = (void *)re::ArrayAccessor::elementAtUnchecked((re::ArrayAccessor *)v17, (void **)a2, i);
              re::TypeInfo::destruct((re::TypeInfo *)v16, v15, a3, a4);
            }
          }
        }
        return;
      case 5:
      case 6:
        v9 = *re::foundationIntrospectionLogObjects(this);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          v10 = (uint64_t *)re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)this + 96, **((_QWORD **)this + 2));
          if (!v10)
          {
          }
          v11 = v10[1];
          *(_DWORD *)buf = 136315138;
          *(_QWORD *)v20 = v11;
          _os_log_impl(&dword_224FE9000, v9, OS_LOG_TYPE_DEFAULT, "No explicit destructor set for %s.", buf, 0xCu);
        }
        return;
      case 7:
        goto LABEL_16;
      default:
        re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Invalid type category.", "!\"Unreachable code\"", "destruct", 467);
        _os_crash();
        __break(1u);
LABEL_16:
        re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Tagged unions can't be created directly. They need to be embedded in a class/struct.", "!\"Unreachable code\"", "destruct", 457);
        _os_crash();
        __break(1u);
        JUMPOUT(0x225B6BFE8);
    }
  }
  v8(a2, this, a3, a4);
}

uint64_t re::TypeInfo::enumConstants(re::TypeInfo *this)
{
  uint64_t v1;
  unint64_t v2;

  v1 = *((_QWORD *)this + 2);
  if (!*(_DWORD *)(v1 + 84))
    return 0;
  v2 = *(unsigned int *)(v1 + 80);
  if (*(_QWORD *)(*(_QWORD *)this + 344) <= v2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(*(_QWORD *)this + 360) + 24 * v2;
}

uint64_t re::Slice<re::EnumConstant>::first(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  if (!result)
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Array is empty.", "!isEmpty()", "first", 225, v2, v3);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeInfo::copy(re::TypeInfo *this, void **a2, char **a3, re::Allocator *a4, void *a5)
{
  uint64_t v10;
  uint64_t v11;
  const re::TypeInfo *v12;
  unint64_t v13;
  void *v14;
  void *v15;
  uint64_t v16;
  void (*v17)(void **, uint64_t *, re::Allocator *, uint64_t);
  uint64_t v18;
  void *v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  void *v24;
  void *v25;
  const re::TypeInfo *Tag;
  uint64_t result;
  unint64_t v28;
  uint64_t *v29;
  char *v30;
  uint64_t *v31;
  char *v32;
  void *v33;
  uint64_t v34;
  unsigned int v35;
  int v36;
  _BYTE v37[32];
  _QWORD *v38[2];
  uint64_t v39;
  _QWORD *v40;
  char v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v44;
  const char *v45;
  uint64_t v46;

  switch(*((_BYTE *)this + 12))
  {
    case 1:
    case 2:
      memcpy(a2, a3, *(unsigned int *)(*((_QWORD *)this + 2) + 8));
      return 1;
    case 3:
      re::TypeInfo::TypeInfo((uint64_t)&v44, (uint64_t)this);
      if ((*(uint64_t (**)(char **))(v46 + 80))(a3))
      {
        re::TypeInfo::TypeInfo((uint64_t)&v44, (uint64_t)this);
        re::TypeInfo::TypeInfo((uint64_t)&v40, (uint64_t)this);
        v10 = (*(uint64_t (**)(char **))(v42 + 80))(a3);
        (*(void (**)(void **, uint64_t))(v46 + 88))(a2, v10);
      }
      else
      {
        re::TypeInfo::TypeInfo((uint64_t)&v44, (uint64_t)this);
        (*(void (**)(void **, _QWORD))(v46 + 88))(a2, 0);
      }
      return 1;
    case 4:
      re::TypeInfo::TypeInfo((uint64_t)&v40, (uint64_t)this);
      re::TypeRegistry::typeInfo(v40, *(_QWORD *)(v42 + 72), &v44);
      re::TypeInfo::TypeInfo((uint64_t)v38, (uint64_t)&v45);
      v11 = re::ArrayAccessor::size((re::ArrayAccessor *)&v40, (char *)a3);
      v12 = (const re::TypeInfo *)re::ArrayAccessor::size((re::ArrayAccessor *)&v40, (char *)a3);
      re::ArrayAccessor::reset((re::ArrayAccessor *)&v40, a2, a4, v12);
      if (!v11)
        return 1;
      v13 = 0;
      while (1)
      {
        v14 = (void *)re::ArrayAccessor::elementAt((re::ArrayAccessor *)&v40, (char *)a2, v13);
        v15 = (void *)re::ArrayAccessor::elementAt((re::ArrayAccessor *)&v40, (char *)a3, v13);
        if ((re::TypeInfo::copy((re::TypeInfo *)v38, v14, v15, a4, a5) & 1) == 0)
          break;
        if (v11 == ++v13)
          return 1;
      }
      return 0;
    case 5:
      re::TypeInfo::TypeInfo((uint64_t)&v40, (uint64_t)this);
      re::TypeRegistry::typeInfo(v40, *(_QWORD *)(v42 + 72), &v44);
      re::TypeInfo::TypeInfo((uint64_t)v38, (uint64_t)&v45);
      v16 = (*(uint64_t (**)(char **))(v42 + 80))(a3);
      v17 = *(void (**)(void **, uint64_t *, re::Allocator *, uint64_t))(v42 + 88);
      re::TypeInfo::TypeInfo((uint64_t)&v44, (uint64_t)&v40);
      v17(a2, &v44, a4, v16);
      if (!v16)
        return 1;
      v18 = 0;
      while (1)
      {
        v19 = (void *)(*(uint64_t (**)(void **, uint64_t))(v42 + 96))(a2, v18);
        v20 = (void *)(*(uint64_t (**)(char **, uint64_t))(v42 + 96))(a3, v18);
        if ((re::TypeInfo::copy((re::TypeInfo *)v38, v19, v20, a4, a5) & 1) == 0)
          break;
        if (v16 == ++v18)
          return 1;
      }
      return 0;
    case 6:
      re::TypeInfo::TypeInfo((uint64_t)&v40, (uint64_t)this);
      re::TypeRegistry::typeInfo(v40, *(_QWORD *)(v42 + 80), &v44);
      re::TypeInfo::TypeInfo((uint64_t)v38, (uint64_t)&v45);
      v21 = (*(uint64_t (**)(char **, re::Allocator *))(v42 + 112))(a3, a4);
      while ((*(unsigned int (**)(uint64_t))(v42 + 120))(v21))
      {
        v22 = (*(uint64_t (**)(uint64_t))(v42 + 128))(v21);
        v23 = (*(uint64_t (**)(void **, _QWORD **, re::Allocator *, uint64_t))(v42 + 104))(a2, &v40, a4, v22);
        if (v23)
        {
          v24 = (void *)v23;
          v25 = (void *)(*(uint64_t (**)(uint64_t))(v42 + 136))(v21);
          if ((re::TypeInfo::copy((re::TypeInfo *)v38, v24, v25, a4, a5) & 1) != 0)
            continue;
        }
        return 0;
      }
      return 1;
    case 7:
      re::TypeInfo::TypeInfo((uint64_t)&v40, (uint64_t)this);
      re::UnionAccessor::activeMemberType((re::UnionAccessor *)&v40, (char *)a3, &v44);
      if (!(_BYTE)v44)
        return 1;
      Tag = (const re::TypeInfo *)re::UnionAccessor::readTag((re::UnionAccessor *)&v40, (char *)a3);
      re::UnionAccessor::reset((re::UnionAccessor *)&v40, (char *)a2, Tag, a4);
      return re::TypeInfo::copy((re::TypeInfo *)&v45, a2, a3, a4, a5);
    case 8:
      re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), &v44);
      if ((_BYTE)v44)
      {
        re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), &v44);
        re::TypeInfo::TypeInfo((uint64_t)&v40, (uint64_t)&v45);
        if (*(_DWORD *)(v42 + 88) || (re::TypeRegistry::typeInfo(v40, *(_QWORD *)(v42 + 72), &v44), (_BYTE)v44))
        {
          result = re::TypeInfo::copy((re::TypeInfo *)&v40, a2, a3, a4, a5);
          if (!(_DWORD)result)
            return result;
        }
      }
      re::TypeMemberCollection::TypeMemberCollection((uint64_t)&v40, *(_QWORD *)this, *((_QWORD *)this + 2));
      if (!v43)
        goto LABEL_32;
      v28 = 0;
      break;
    case 9:
      v32 = *a3;
      v33 = *a2;
      if (!*a3)
      {
        if (v33)
          re::TypeInfo::releaseInstance(this, v33, a4, 0);
        *a2 = 0;
        return 1;
      }
      if (!v33
        || (re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), &v44),
            re::TypeInfo::TypeInfo((uint64_t)&v40, (uint64_t)&v45),
            v41 != 8)
        || *(_DWORD *)(v42 + 80) < 2u
        || (re::TypeRegistry::typeInfoChecked(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), (uint64_t)v38),
            re::TypeInfo::getActualTypeFromPointer((uint64_t)v38, (char *)a2, &v44),
            re::TypeRegistry::typeInfoChecked(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), (uint64_t)v37),
            re::TypeInfo::getActualType((re::TypeInfo *)v37, v32, &v34),
            v44 == v34)
        && (unsigned __int16)v45 == (unsigned __int16)v35
        && WORD1(v45) == HIWORD(v35)
        && ((HIDWORD(v45) ^ v36) & 0xFFFFFF) == 0)
      {
        if (*a2)
          goto LABEL_52;
      }
      else
      {
        re::TypeRegistry::typeInfoChecked(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), (uint64_t)&v44);
        re::TypeInfo::releaseInstance((re::TypeInfo *)&v44, *a2, a4, 0);
        *a2 = 0;
      }
      re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), &v44);
      re::TypeInfo::TypeInfo((uint64_t)&v40, (uint64_t)&v45);
      *a2 = re::TypeInfo::createInstance((re::TypeInfo *)&v40, a4, 0);
LABEL_52:
      re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), &v44);
      re::TypeInfo::TypeInfo((uint64_t)&v40, (uint64_t)&v45);
      return (re::TypeInfo::copy((re::TypeInfo *)&v40, *a2, v32, a4, a5) & 1) != 0;
    default:
      return 1;
  }
  while (1)
  {
    re::TypeMemberCollection::operator[]((uint64_t *)&v40, v28, (uint64_t)v38);
    if (*(_BYTE *)(v39 + 28))
    {
      re::TypeRegistry::typeInfo(v38[0], *(_QWORD *)v39, &v44);
      re::TypeInfo::TypeInfo((uint64_t)v37, (uint64_t)&v45);
      result = re::TypeInfo::copy((re::TypeInfo *)v37, (char *)a2 + *(unsigned int *)(v39 + 24), (char *)a3 + *(unsigned int *)(v39 + 24), a4, a5);
      if (!(_DWORD)result)
        break;
    }
    if (++v28 >= v43)
    {
      if (!v43)
      {
LABEL_32:
        v29 = (uint64_t *)re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)this + 96, **((_QWORD **)this + 2));
        if (!v29)
        {
        }
        if ((unint64_t)*v29 >> 1 == 0x134375A94D9F7110
          && ((v30 = (char *)v29[1], v30 == "DynamicString") || !strcmp(v30, "DynamicString")))
        {
          re::DynamicString::operator=((re::DynamicString *)a2, (re::DynamicString *)a3);
        }
        else
        {
          v31 = (uint64_t *)re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)this + 96, **((_QWORD **)this + 2));
          if (!v31)
          {
          }
          v44 = 0x22C6ED80D0CLL;
          v45 = "StringID";
          if (re::StringID::operator==(v31, &v44))
            re::StringID::operator=((unint64_t *)a2, (uint64_t *)a3);
        }
      }
      return 1;
    }
  }
  return result;
}

uint64_t re::TypeInfo::referencedType@<X0>(re::TypeInfo *this@<X0>, uint64_t a2@<X8>)
{
  _BYTE v4[8];
  uint64_t v5;

  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), v4);
  return re::TypeInfo::TypeInfo(a2, (uint64_t)&v5);
}

uint64_t re::TypeInfo::getActualTypeFromPointer@<X0>(uint64_t this@<X0>, char *a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v4;
  uint64_t v6;
  const re::TypeInfo *v7;
  uint64_t Unsigned;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _BYTE v16[16];
  uint64_t v17;
  _QWORD v18[5];
  int v19;
  const char *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  uint64_t v24;
  __int16 v25;
  unint64_t v26;
  _BYTE v27[88];
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(this + 16);
  if ((*(_DWORD *)(v4 + 92) & 0xFFFFFF) == 0)
    goto LABEL_9;
  if (!*(_DWORD *)(v4 + 96))
    goto LABEL_9;
  v6 = this;
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(v4 + 88), v27);
  re::TypeInfo::TypeInfo((uint64_t)v18, (uint64_t)&v27[8]);
  Unsigned = re::internal::readUnsigned((re::internal *)&a2[*(int *)(*(_QWORD *)(v6 + 16) + 96)], v18, v7);
  re::TypeRegistry::typeInfo(*(_QWORD **)v6, *(_QWORD *)(*(_QWORD *)(v6 + 16) + 72), v27);
  re::TypeInfo::TypeInfo((uint64_t)&v19, (uint64_t)&v27[8]);
  re::TypeInfo::rootClass((re::TypeInfo *)&v19, (uint64_t)v16);
  this = re::DataArray<re::internal::TypeInfoIndex>::get(*(_QWORD *)v6 + 32, *(_QWORD *)v17);
  v9 = *(unsigned int *)(v17 + 80);
  if ((_DWORD)v9)
  {
    v10 = *(_DWORD *)this & 0xFFFFFF;
    v11 = *(_QWORD *)v6;
    v12 = *(_QWORD *)(*(_QWORD *)v6 + 624);
    while (1)
    {
      v13 = v10;
      if (v12 <= v10)
      {
        v18[4] = 0;
        memset(v27, 0, 80);
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        v19 = 136315906;
        v20 = "operator[]";
        v21 = 1024;
        v22 = 797;
        v23 = 2048;
        v24 = v13;
        v25 = 2048;
        v26 = v12;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      v14 = *(_QWORD *)(v11 + 640);
      if (*(_BYTE *)(v14 + 152 * v13 + 120))
      {
        if (*(_QWORD *)(v14 + 152 * v13 + 128) == Unsigned)
          break;
      }
      v10 = v13 + 1;
      if (!--v9)
        goto LABEL_9;
    }
    v15 = *(_QWORD *)(v14 + 152 * v13);
    *a3 = v11;
    a3[1] = v15;
  }
  else
  {
LABEL_9:
    *a3 = 0;
    a3[1] = 0xFFFFFFFFLL;
  }
  return this;
}

_DWORD *re::TypeInfo::getActualType@<X0>(re::TypeInfo *this@<X0>, char *a2@<X1>, _QWORD *a3@<X8>)
{
  _QWORD *(*v6)(_QWORD *__return_ptr, char *, re::TypeInfo *);
  _DWORD *result;
  uint64_t *v8;
  const re::TypeInfo *v9;
  uint64_t Unsigned;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD v18[4];
  _BYTE v19[8];
  _QWORD *v20;
  uint64_t *v21;
  _QWORD v22[2];
  uint64_t v23;
  uint64_t v24;
  int v25;
  const char *v26;
  __int16 v27;
  int v28;
  __int16 v29;
  uint64_t v30;
  __int16 v31;
  unint64_t v32;
  _OWORD v33[5];
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  v6 = *(_QWORD *(**)(_QWORD *__return_ptr, char *, re::TypeInfo *))(*((_QWORD *)this + 2) + 144);
  if (v6)
    return v6(a3, a2, this);
  re::TypeInfo::rootClass(this, (uint64_t)v22);
  result = re::TypeInfo::customClassIDMember(v22, (uint64_t)v19);
  if (v19[0]
    && (v8 = v21,
        re::TypeRegistry::typeInfo(v20, *v21, v33),
        re::TypeInfo::TypeInfo((uint64_t)v18, (uint64_t)v33 + 8),
        Unsigned = re::internal::readUnsigned((re::internal *)&a2[*((unsigned int *)v8 + 6)], v18, v9),
        result = (_DWORD *)re::DataArray<re::internal::TypeInfoIndex>::get(*(_QWORD *)this + 32, *(_QWORD *)v23),
        v11 = *(unsigned int *)(v23 + 80),
        (_DWORD)v11))
  {
    v12 = *result & 0xFFFFFF;
    v13 = *(_QWORD *)this;
    v14 = *(_QWORD *)(*(_QWORD *)this + 624);
    while (1)
    {
      v15 = v12;
      if (v14 <= v12)
      {
        v24 = 0;
        memset(v33, 0, sizeof(v33));
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        v25 = 136315906;
        v26 = "operator[]";
        v27 = 1024;
        v28 = 797;
        v29 = 2048;
        v30 = v15;
        v31 = 2048;
        v32 = v14;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      v16 = *(_QWORD *)(v13 + 640);
      if (*(_BYTE *)(v16 + 152 * v15 + 120))
      {
        if (*(_QWORD *)(v16 + 152 * v15 + 128) == Unsigned)
          break;
      }
      v12 = v15 + 1;
      if (!--v11)
        goto LABEL_10;
    }
    v17 = *(_QWORD *)(v16 + 152 * v15);
    *a3 = v13;
    a3[1] = v17;
  }
  else
  {
LABEL_10:
    *a3 = 0;
    a3[1] = 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t re::TypeInfo::isInteger(re::TypeInfo *this)
{
  int v1;
  _BYTE v3[32];
  _BYTE v4[8];
  uint64_t v5;

  v1 = *((unsigned __int8 *)this + 12);
  if (v1 == 2)
  {
    re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), v4);
    re::TypeInfo::TypeInfo((uint64_t)v3, (uint64_t)&v5);
    return re::TypeInfo::isInteger((re::TypeInfo *)v3);
  }
  else
  {
    return v1 == 1 && *(unsigned __int8 *)(*((_QWORD *)this + 2) + 68) == 1;
  }
}

uint64_t re::TypeInfo::renamedEnumConstants(re::TypeInfo *this)
{
  _DWORD *v1;
  unint64_t v2;

  v1 = (_DWORD *)*((_QWORD *)this + 2);
  if (!v1[22])
    return 0;
  v2 = (v1[21] + v1[20]);
  if (*(_QWORD *)(*(_QWORD *)this + 344) <= v2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(*(_QWORD *)this + 360) + 24 * v2;
}

uint64_t re::TypeInfo::dictionaryValueType@<X0>(re::TypeInfo *this@<X0>, uint64_t a2@<X8>)
{
  _BYTE v4[8];
  uint64_t v5;

  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), v4);
  return re::TypeInfo::TypeInfo(a2, (uint64_t)&v5);
}

uint64_t re::TypeInfo::unionMember@<X0>(re::TypeInfo *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  _QWORD *v5;
  unint64_t v6;
  _OWORD v8[5];
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v5 = *(_QWORD **)this;
  v6 = *(unsigned int *)(*((_QWORD *)this + 2) + 84) + a2;
  if (v5[73] <= v6)
  {
    memset(v8, 0, sizeof(v8));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  re::TypeRegistry::typeInfo(v5, *(_QWORD *)(v5[75] + 8 * v6), v8);
  return re::TypeInfo::TypeInfo(a3, (uint64_t)v8 + 8);
}

BOOL re::TypeInfo::isSubClassOf(_QWORD **a1, _QWORD *a2)
{
  int v4;
  unint64_t v5;

  if (!*a2)
    return 0;
  v4 = *(_DWORD *)re::DataArray<re::internal::TypeInfoIndex>::get((uint64_t)(*a1 + 4), *a1[2]);
  v5 = *(_DWORD *)re::DataArray<re::internal::TypeInfoIndex>::get((uint64_t)(*a1 + 4), a2[1]) & 0xFFFFFF;
  if ((*a1)[78] <= v5)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return v5 < (v4 & 0xFFFFFFu)
      && (v4 & 0xFFFFFFu) < *(_DWORD *)((*a1)[80] + 152 * v5 + 80) + (int)v5;
}

uint64_t re::TypeInfo::rootClass@<X0>(re::TypeInfo *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  _QWORD *i;
  unint64_t v6;
  _OWORD v8[5];
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v4 = *((_QWORD *)this + 2);
  for (i = *(_QWORD **)this; (*(_DWORD *)(v4 + 76) & 0xFFFFFF) != 0; v4 = i[80] + 152 * v6)
  {
    v6 = *(_DWORD *)re::DataArray<re::internal::TypeInfoIndex>::get((uint64_t)(i + 4), *(_QWORD *)(v4 + 72)) & 0xFFFFFFLL;
    i = *(_QWORD **)this;
    if (*(_QWORD *)(*(_QWORD *)this + 624) <= v6)
    {
      memset(v8, 0, sizeof(v8));
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
  }
  re::TypeRegistry::typeInfo(i, *(_QWORD *)v4, v8);
  return re::TypeInfo::TypeInfo(a2, (uint64_t)v8 + 8);
}

uint64_t re::TypeInfo::subClassCount(re::TypeInfo *this)
{
  _DWORD *v2;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;

  v2 = (_DWORD *)re::DataArray<re::internal::TypeInfoIndex>::get(*(_QWORD *)this + 32, **((_QWORD **)this + 2));
  v3 = *(unsigned int *)(*((_QWORD *)this + 2) + 80);
  if (v3 < 2)
    return 0;
  v4 = 0;
  v5 = *v2 & 0xFFFFFF;
  v6 = v3 - 1;
  v7 = v5 + 1;
  v8 = 152 * v5 + 224;
  do
  {
    if (*(_QWORD *)(*(_QWORD *)this + 624) <= v7)
    {
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    if ((*(_DWORD *)re::DataArray<re::internal::TypeInfoIndex>::get(*(_QWORD *)this + 32, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 640) + v8)) & 0xFFFFFF) == v5)++v4;
    ++v7;
    v8 += 152;
    --v6;
  }
  while (v6);
  return v4;
}

uint64_t re::TypeInfo::subClass@<X0>(re::TypeInfo *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  _DWORD *v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  unint64_t v13;
  int v14;
  _QWORD *v15;
  _OWORD v17[5];
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  v8 = (_DWORD *)re::DataArray<re::internal::TypeInfoIndex>::get(*(_QWORD *)this + 32, **((_QWORD **)this + 2));
  v10 = *(unsigned int *)(*((_QWORD *)this + 2) + 80);
  if (v10 >= 2)
  {
    v11 = *v8 & 0xFFFFFF;
    v12 = v10 - 1;
    v3 = 152 * v11;
    v13 = v11 + 1;
    v14 = a2;
    do
    {
      v15 = *(_QWORD **)this;
      if (*(_QWORD *)(*(_QWORD *)this + 624) <= v13)
      {
        memset(v17, 0, sizeof(v17));
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      v4 = v15[80];
      if ((*(_DWORD *)re::DataArray<re::internal::TypeInfoIndex>::get((uint64_t)(v15 + 4), *(_QWORD *)(v4 + v3 + 224)) & 0xFFFFFF) == v11)
      {
        if (!v14)
          goto LABEL_9;
        --v14;
      }
      v3 += 152;
      ++v13;
      --v12;
    }
    while (v12);
  }
  re::internal::assertLog((re::internal *)5, v9, "assertion failure: '%s' (%s:line %i) Index out of range. Index: %zu", "!\"Unreachable code\"", "subClass", 943, a2);
  _os_crash();
  __break(1u);
LABEL_9:
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(v4 + v3 + 152), v17);
  return re::TypeInfo::TypeInfo(a3, (uint64_t)v17 + 8);
}

uint64_t re::TypeInfo::derivedClass@<X0>(re::TypeInfo *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  _OWORD v7[5];
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v5 = (*(_DWORD *)re::DataArray<re::internal::TypeInfoIndex>::get(*(_QWORD *)this + 32, **((_QWORD **)this + 2)) & 0xFFFFFF)
     + a2;
  if (*(_QWORD *)(*(_QWORD *)this + 624) <= (unint64_t)(v5 + 1))
  {
    memset(v7, 0, sizeof(v7));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 640) + 152 * (v5 + 1)), v7);
  return re::TypeInfo::TypeInfo(a3, (uint64_t)v7 + 8);
}

uint64_t re::TypeInfo::renamedObjectMembers(re::TypeInfo *this)
{
  uint64_t v1;
  unint64_t v2;

  v1 = *((_QWORD *)this + 2);
  if (!*(_DWORD *)(v1 + 96))
    return 0;
  v2 = *(unsigned int *)(v1 + 92);
  if (*(_QWORD *)(*(_QWORD *)this + 704) <= v2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(*(_QWORD *)this + 720) + 24 * v2;
}

_QWORD *re::TypeInfo::customClassIDMember@<X0>(_QWORD *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  char v7;

  v2 = this[2];
  v3 = *(unsigned int *)(v2 + 136);
  if ((v3 & 0x80000000) != 0)
  {
    v7 = 0;
  }
  else
  {
    v4 = *this;
    if (*(_QWORD *)(*this + 664) <= v3)
    {
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    v5 = *(_QWORD *)(v4 + 680) + 40 * v3;
    *(_QWORD *)(a2 + 8) = v4;
    *(_QWORD *)(a2 + 16) = v2;
    *(_QWORD *)(a2 + 24) = v5;
    v6 = *(_DWORD *)(v4 + 24);
    *(_DWORD *)(a2 + 32) = -1;
    *(_DWORD *)(a2 + 36) = v6;
    v7 = 1;
  }
  *(_BYTE *)a2 = v7;
  return this;
}

uint64_t *re::TypeInfo::polymorphicObjectName(re::TypeInfo *this)
{
  uint64_t v2;
  uint64_t *result;
  BOOL v4;

  v2 = *((_QWORD *)this + 2);
  result = (uint64_t *)(v2 + 104);
  v4 = *(_QWORD *)(v2 + 104) >= 0xFFFFFFFFFFFFFFFELL && (*(_QWORD *)(v2 + 104) & 1) == 0;
  if (v4 && !**(_BYTE **)(v2 + 112))
  {
    result = (uint64_t *)re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)this + 96, *(_QWORD *)v2);
    if (!result)
    {
    }
  }
  return result;
}

_DWORD *re::TypeInfo::typeIDForCustomClassID@<X0>(re::TypeInfo *this@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  _DWORD *result;
  uint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  result = (_DWORD *)re::DataArray<re::internal::TypeInfoIndex>::get(*(_QWORD *)this + 32, **((_QWORD **)this + 2));
  v7 = *(unsigned int *)(*((_QWORD *)this + 2) + 80);
  if ((_DWORD)v7)
  {
    v8 = *result & 0xFFFFFF;
    v9 = *(_QWORD **)this;
    v10 = *(_QWORD *)(*(_QWORD *)this + 624);
    if (v10 <= v8)
      v11 = *result & 0xFFFFFF;
    else
      v11 = v10;
    v12 = v11 - v8;
    v13 = 152 * v8;
    while (1)
    {
      if (!v12)
      {
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      v14 = v9[80];
      if (*(_BYTE *)(v14 + v13 + 120))
      {
        if (*(_QWORD *)(v14 + v13 + 128) == a2)
          break;
      }
      --v12;
      v13 += 152;
      if (!--v7)
        goto LABEL_10;
    }
    v15 = *(_QWORD *)(v14 + v13);
    *a3 = v9;
    a3[1] = v15;
  }
  else
  {
LABEL_10:
    *a3 = 0;
    a3[1] = 0xFFFFFFFFLL;
  }
  return result;
}

BOOL re::TypeInfo::isPointerToPolymorphicType(re::TypeInfo *this)
{
  _BYTE v2[16];
  uint64_t v3;
  _BYTE v4[8];
  uint64_t v5;

  if (*((_BYTE *)this + 12) == 9
    && (re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), v4),
        re::TypeInfo::TypeInfo((uint64_t)v2, (uint64_t)&v5),
        v2[12] == 8))
  {
    return *(_DWORD *)(v3 + 80) > 1u;
  }
  else
  {
    return 0;
  }
}

void re::TypeInfo::setActualTypeForPointer(_QWORD **a1, uint64_t a2, re **a3)
{
  _QWORD *v4;
  const re::TypeInfo *v6;
  _QWORD v7[4];
  _BYTE v8[24];
  uint64_t v9;
  _BYTE v10[8];
  uint64_t v11;

  if (*a3)
  {
    if (*((_BYTE *)a1 + 12) == 9)
    {
      v4 = a1[2];
      if ((*((_DWORD *)v4 + 23) & 0xFFFFFF) != 0)
      {
        if (*((_DWORD *)v4 + 24))
        {
          re::TypeRegistry::typeInfo((re *)*a1, a3, v8);
          if (v8[0])
          {
            if (*(_BYTE *)(v9 + 120))
            {
              v6 = *(const re::TypeInfo **)(v9 + 128);
              re::TypeRegistry::typeInfo(*a1, a1[2][11], v10);
              re::TypeInfo::TypeInfo((uint64_t)v7, (uint64_t)&v11);
              re::internal::writeUnsigned((_BYTE *)(a2 + *((int *)a1[2] + 24)), v7, v6);
            }
          }
        }
      }
    }
  }
}

uint64_t re::TypeInfo::isDependentOn(unint64_t *a1, __int128 *a2, uint64_t a3, double a4)
{
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  BOOL v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t result;
  __n128 *v27;
  __int128 *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  _QWORD *v36[4];
  _BYTE v37[32];
  uint64_t v38[4];
  unint64_t v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  _BYTE v48[8];
  _BYTE v49[32];
  __int128 v50;
  __int128 v51;
  __n128 v52[2];

  if (*(_QWORD *)a2)
  {
    v7 = *a1;
    v8 = *(_QWORD *)a1[2];
    if (*a1 != *(_QWORD *)a2
      || (v9 = *((_QWORD *)a2 + 1), (unsigned __int16)*(_QWORD *)a1[2] != (unsigned __int16)v9)
      || ((v11 = WORD1(v8) == WORD1(v9), v10 = (v9 ^ v8) & 0xFFFFFF00000000, v11) ? (v11 = v10 == 0) : (v11 = 0), !v11))
    {
      v12 = 0x94D049BB133111EBLL
          * ((0xBF58476D1CE4E5B9 * (v7 ^ (v7 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v7 ^ (v7 >> 30))) >> 27));
      v13 = 0x94D049BB133111EBLL
          * ((0xBF58476D1CE4E5B9 * (v8 ^ (v8 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v8 ^ (v8 >> 30))) >> 27));
      v14 = ((v13 ^ (v13 >> 31)) + ((v12 ^ (v12 >> 31)) << 6) + ((v12 ^ (v12 >> 31)) >> 2) - 0x61C8864680B583E9) ^ v12 ^ (v12 >> 31);
      v15 = *(unsigned int *)(a3 + 24);
      if ((_DWORD)v15)
      {
        v16 = v14 % v15;
        v17 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (v14 % v15));
        if ((_DWORD)v17 != 0x7FFFFFFF)
        {
          v18 = (unsigned __int16)*(_QWORD *)a1[2];
          v19 = *(_QWORD *)(a3 + 16);
          v20 = v17;
          while (1)
          {
            v21 = v19 + 32 * v20;
            if (*(_QWORD *)(v21 + 16) == v7 && *(unsigned __int16 *)(v21 + 24) == v18)
            {
              v22 = v19 + 32 * v20;
              if (*(unsigned __int16 *)(v22 + 26) == WORD1(v8)
                && ((*(_DWORD *)(v22 + 28) ^ HIDWORD(v8)) & 0xFFFFFF) == 0)
              {
                return 0;
              }
            }
            v20 = *(_DWORD *)(v21 + 8) & 0x7FFFFFFF;
            if (v20 == 0x7FFFFFFF)
            {
              v52[0].n128_u64[0] = *a1;
              v52[0].n128_u64[1] = v8;
              v23 = *(_QWORD *)(a3 + 16);
              while (1)
              {
                v24 = v23 + 32 * v17;
                if (*(_QWORD *)(v24 + 16) == v7 && *(unsigned __int16 *)(v24 + 24) == v18)
                {
                  v25 = v23 + 32 * v17;
                  if (*(unsigned __int16 *)(v25 + 26) == WORD1(v8)
                    && ((*(_DWORD *)(v25 + 28) ^ HIDWORD(v8)) & 0xFFFFFF) == 0)
                  {
                    goto LABEL_26;
                  }
                }
                v17 = *(_DWORD *)(v24 + 8) & 0x7FFFFFFF;
                if (v17 == 0x7FFFFFFF)
                  goto LABEL_25;
              }
            }
          }
        }
      }
      else
      {
        LODWORD(v16) = 0;
      }
      v52[0].n128_u64[0] = *a1;
      v52[0].n128_u64[1] = v8;
LABEL_25:
      *(_QWORD *)&a4 = re::HashSetBase<re::TypeID,re::TypeID,re::internal::ValueAsKey<re::TypeID>,re::Hash<re::TypeID>,re::EqualTo<re::TypeID>,true,false>::addAsMove(a3, v16, v14, v52).n128_u64[0];
      ++*(_DWORD *)(a3 + 40);
LABEL_26:
      result = 0;
      switch(*((_BYTE *)a1 + 12))
      {
        case 0:
          re::internal::assertLog((re::internal *)4, v16, a4, "assertion failure: '%s' (%s:line %i) Invalid type category.", "!\"Unreachable code\"", "isDependentOn", 1262);
          _os_crash();
          __break(1u);
          JUMPOUT(0x225B6E4C8);
        case 2:
          re::TypeRegistry::typeInfo((_QWORD *)*a1, *(_QWORD *)(a1[2] + 72), v52);
          v27 = (__n128 *)re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)&v52[0].n128_i64[1]);
          v51 = *a2;
          v28 = &v51;
          return re::TypeInfo::isDependentOn(v27, v28, a3);
        case 3:
          re::TypeRegistry::typeInfo((_QWORD *)*a1, *(_QWORD *)(a1[2] + 72), v52);
          v27 = (__n128 *)re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)&v52[0].n128_i64[1]);
          v50 = *a2;
          v28 = &v50;
          return re::TypeInfo::isDependentOn(v27, v28, a3);
        case 4:
          re::TypeRegistry::typeInfo((_QWORD *)*a1, *(_QWORD *)(a1[2] + 80), v48);
          re::TypeRegistry::typeInfo((_QWORD *)*a1, *(_QWORD *)(a1[2] + 72), v52);
          re::TypeInfo::TypeInfo((uint64_t)v38, (uint64_t)&v52[0].n128_i64[1]);
          v47 = *a2;
          if ((re::TypeInfo::isDependentOn(v38, &v47, a3) & 1) != 0)
            return 1;
          if (!v48[0])
            return 0;
          v27 = (__n128 *)v49;
          v46 = *a2;
          v28 = &v46;
          return re::TypeInfo::isDependentOn(v27, v28, a3);
        case 5:
          re::TypeRegistry::typeInfo((_QWORD *)*a1, *(_QWORD *)(a1[2] + 72), v52);
          v27 = (__n128 *)re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)&v52[0].n128_i64[1]);
          v45 = *a2;
          v28 = &v45;
          return re::TypeInfo::isDependentOn(v27, v28, a3);
        case 6:
          re::TypeRegistry::typeInfo((_QWORD *)*a1, *(_QWORD *)(a1[2] + 72), v52);
          v29 = re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)&v52[0].n128_i64[1]);
          v44 = *a2;
          if ((re::TypeInfo::isDependentOn(v29, &v44, a3) & 1) != 0)
            return 1;
          re::TypeRegistry::typeInfoChecked((_QWORD *)*a1, *(_QWORD *)(a1[2] + 80), (uint64_t)v52);
          v43 = *a2;
          v27 = v52;
          v28 = &v43;
          return re::TypeInfo::isDependentOn(v27, v28, a3);
        case 7:
          re::TypeRegistry::typeInfo((_QWORD *)*a1, *(_QWORD *)(a1[2] + 72), v52);
          v30 = re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)&v52[0].n128_i64[1]);
          v42 = *a2;
          if ((re::TypeInfo::isDependentOn(v30, &v42, a3) & 1) != 0)
            return 1;
          if (!*(_DWORD *)(a1[2] + 88))
            return 0;
          v31 = 0;
          do
          {
            re::TypeInfo::unionMember((re::TypeInfo *)a1, v31, (uint64_t)v52);
            v41 = *a2;
            result = re::TypeInfo::isDependentOn(v52, &v41, a3);
            if ((result & 1) != 0)
              break;
            ++v31;
          }
          while (v31 < *(unsigned int *)(a1[2] + 88));
          return result;
        case 8:
          re::TypeRegistry::typeInfo((_QWORD *)*a1, *(_QWORD *)(a1[2] + 72), v48);
          if (v48[0])
          {
            v40 = *a2;
            if ((re::TypeInfo::isDependentOn(v49, &v40, a3) & 1) != 0)
              return 1;
          }
          re::TypeMemberCollection::TypeMemberCollection((uint64_t)v38, *a1, a1[2]);
          if (!v39)
            goto LABEL_49;
          v32 = 0;
          break;
        case 9:
          re::TypeRegistry::typeInfo((_QWORD *)*a1, *(_QWORD *)(a1[2] + 72), v52);
          v27 = (__n128 *)re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)&v52[0].n128_i64[1]);
          v33 = *a2;
          v28 = &v33;
          return re::TypeInfo::isDependentOn(v27, v28, a3);
        default:
          return result;
      }
      while (1)
      {
        re::TypeMemberCollection::operator[](v38, v32, (uint64_t)v36);
        re::TypeRegistry::typeInfo(v36[0], *v36[2], v52);
        re::TypeInfo::TypeInfo((uint64_t)v37, (uint64_t)&v52[0].n128_i64[1]);
        v35 = *a2;
        if ((re::TypeInfo::isDependentOn(v37, &v35, a3) & 1) != 0)
          break;
        if (++v32 >= v39)
        {
LABEL_49:
          re::TypeInfo::customClassIDMember(a1, (uint64_t)v52);
          if (!v52[0].n128_u8[0])
            return 0;
          re::TypeMemberInfo::memberType((re::TypeMemberInfo *)&v52[0].n128_i8[8], (uint64_t)v37);
          v34 = *a2;
          v27 = (__n128 *)v37;
          v28 = &v34;
          return re::TypeInfo::isDependentOn(v27, v28, a3);
        }
      }
    }
    return 1;
  }
  return 0;
}

BOOL re::areSameTranslatedVersion(re *this, const re::TypeInfo *a2, const re::TypeInfo *a3)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;
  _QWORD v11[2];

  v4 = *(_QWORD **)(*(_QWORD *)a2 + 856);
  if (v4)
  {
    v5 = **((_QWORD **)a2 + 2);
    v11[0] = *(_QWORD *)a2;
    v11[1] = v5;
    re::internal::TypeTranslationTable::translateType(v4, (uint64_t)v11, &v9);
    v6 = v9;
  }
  else
  {
    v6 = 0;
    v9 = 0;
    v10 = 0xFFFFFFFFLL;
  }
  if (v6 == *(_QWORD *)this
    && (v7 = **((_QWORD **)this + 2), (unsigned __int16)v10 == (unsigned __int16)v7)
    && WORD1(v10) == WORD1(v7))
  {
    return ((HIDWORD(v10) ^ HIDWORD(v7)) & 0xFFFFFF) == 0;
  }
  else
  {
    return 0;
  }
}

__n128 re::HashSetBase<re::TypeID,re::TypeID,re::internal::ValueAsKey<re::TypeID>,re::Hash<re::TypeID>,re::EqualTo<re::TypeID>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, __n128 *a4)
{
  uint64_t v7;
  int v8;
  int v9;
  signed int v10;
  uint64_t v11;
  BOOL v12;
  __int128 v13;
  uint64_t v14;
  unsigned int v15;
  __int128 v16;
  unsigned int v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  int v21;
  signed int v22;
  __n128 result;
  _BYTE v24[44];

  v7 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v7 == 0x7FFFFFFF)
  {
    v7 = *(unsigned int *)(a1 + 32);
    v8 = v7;
    if ((_DWORD)v7 == *(_DWORD *)(a1 + 24))
    {
      v9 = *(_DWORD *)(a1 + 28);
      v10 = 2 * v9;
      v11 = *(_QWORD *)a1;
      if (*(_QWORD *)a1)
      {
        if (v10)
          v12 = (_DWORD)v7 == v10;
        else
          v12 = 1;
        if (!v12 && (v9 & 0x80000000) == 0)
        {
          memset(v24, 0, 36);
          *(_QWORD *)&v24[36] = 0x7FFFFFFFLL;
          re::HashSetBase<re::Pair<re::ecs2::Entity const*,re::ecs2::PortalComponent const*,true>,re::Pair<re::ecs2::Entity const*,re::ecs2::PortalComponent const*,true>,re::internal::ValueAsKey<re::Pair<re::ecs2::Entity const*,re::ecs2::PortalComponent const*,true>>,re::Hash<re::Pair<re::ecs2::Entity const*,re::ecs2::PortalComponent const*,true>>,re::EqualTo<re::Pair<re::ecs2::Entity const*,re::ecs2::PortalComponent const*,true>>,true,false>::init((uint64_t)v24, v11, v10);
          v13 = *(_OWORD *)v24;
          *(_OWORD *)v24 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v13;
          v14 = *(_QWORD *)&v24[16];
          *(_QWORD *)&v24[16] = *(_QWORD *)(a1 + 16);
          *(_QWORD *)(a1 + 16) = v14;
          v16 = *(_OWORD *)&v24[24];
          *(_OWORD *)&v24[24] = *(_OWORD *)(a1 + 24);
          v15 = *(_DWORD *)&v24[32];
          *(_OWORD *)(a1 + 24) = v16;
          v17 = v15;
          if (v15)
          {
            v18 = 0;
            v19 = 0;
            do
            {
              if ((*(_DWORD *)(*(_QWORD *)&v24[16] + v18 + 8) & 0x80000000) != 0)
              {
                re::HashSetBase<re::TypeID,re::TypeID,re::internal::ValueAsKey<re::TypeID>,re::Hash<re::TypeID>,re::EqualTo<re::TypeID>,true,false>::addAsMove(a1, *(_QWORD *)(*(_QWORD *)&v24[16] + v18) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(*(_QWORD *)&v24[16] + v18), *(_QWORD *)&v24[16] + v18 + 16);
                v17 = *(_DWORD *)&v24[32];
              }
              ++v19;
              v18 += 32;
            }
            while (v19 < v17);
          }
          re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)v24);
        }
      }
      else
      {
        if (v10)
          v22 = v10;
        else
          v22 = 3;
      }
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v8 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v8 + 1;
    v20 = *(_QWORD *)(a1 + 16);
    v21 = *(_DWORD *)(v20 + 32 * v7 + 8);
  }
  else
  {
    v20 = *(_QWORD *)(a1 + 16);
    v21 = *(_DWORD *)(v20 + 32 * v7 + 8);
    *(_DWORD *)(a1 + 36) = v21 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v20 + 32 * v7 + 8) = v21 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v7 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v7 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v7) = a3;
  result = *a4;
  *(__n128 *)(*(_QWORD *)(a1 + 16) + 32 * v7 + 16) = *a4;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v7;
  ++*(_DWORD *)(a1 + 28);
  return result;
}

uint64_t re::TypeMemberCollection::TypeMemberCollection(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;

  *(_QWORD *)result = a2;
  *(_QWORD *)(result + 24) = 0;
  *(_QWORD *)(result + 32) = 0;
  *(_QWORD *)(result + 16) = a3;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 24);
  v3 = *(unsigned int *)(a3 + 88);
  if ((_DWORD)v3)
  {
    v4 = *(unsigned int *)(a3 + 84);
    if (*(_QWORD *)(a2 + 664) <= v4)
    {
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    v5 = *(_QWORD *)(a2 + 680) + 40 * v4;
  }
  else
  {
    v5 = 0;
    v3 = 0;
  }
  *(_QWORD *)(result + 24) = v5;
  *(_QWORD *)(result + 32) = v3;
  return result;
}

uint64_t *re::TypeMemberCollection::operator[]@<X0>(uint64_t *result@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v3 = result[4];
  if (v3 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, a2, v3);
    result = (uint64_t *)_os_crash();
    __break(1u);
  }
  else
  {
    v4 = *result;
    v5 = result[2];
    v6 = result[3] + 40 * a2;
    *(_QWORD *)a3 = *result;
    *(_QWORD *)(a3 + 8) = v5;
    *(_QWORD *)(a3 + 16) = v6;
    LODWORD(v4) = *(_DWORD *)(v4 + 24);
    *(_DWORD *)(a3 + 24) = a2;
    *(_DWORD *)(a3 + 28) = v4;
  }
  return result;
}

uint64_t re::internal::TypeTranslationTable::buildTables(re::internal::TypeTranslationTable *this)
{
  re::internal::TypeTranslationTable *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t result;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  _BYTE *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t v18;
  re::TypeRegistry *v19;
  uint64_t *v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  re::TypeInfo *v29;
  _QWORD *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  BOOL v37;
  uint64_t v38;
  uint64_t *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  re::TypeInfo *v47;
  unint64_t v48;
  _BYTE *v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  re::TypeRegistry *v61;
  uint64_t *v62;
  uint64_t v63;
  int v64;
  uint64_t v65;
  unint64_t v66;
  uint64_t v67;
  _QWORD *v68;
  uint64_t v69;
  _QWORD *v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  unint64_t v80;
  uint64_t v81;
  unint64_t v82;
  uint64_t *v83;
  unint64_t v84;
  unint64_t v85;
  unint64_t v86;
  unint64_t v87;
  unint64_t v88;
  unint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t *v92;
  uint64_t v93;
  uint64_t v94;
  re::internal::TypeTranslationTable *v95;
  uint64_t v96;
  uint64_t v97;
  re::TypeInfo *v98;
  uint64_t v99[2];
  uint64_t *v100;
  uint64_t v101;
  unint64_t v102;
  _QWORD v103[2];
  uint64_t v104;
  uint64_t v105[2];
  uint64_t *v106;
  _QWORD v107[2];
  _QWORD v108[2];
  _BYTE v109[12];
  __int16 v110;
  int v111;
  __int16 v112;
  unint64_t v113;
  __int16 v114;
  _BYTE v115[10];
  int v116;
  _BYTE v117[14];
  __int16 v118;
  _BYTE v119[18];
  _BYTE v120[12];
  __int16 v121;
  int v122;
  __int16 v123;
  unint64_t v124;
  __int16 v125;
  unint64_t v126;
  __int128 v127;
  __int128 v128;
  __int128 v129;
  __int128 v130;
  __int128 v131;
  uint64_t v132;

  v1 = this;
  v132 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)this;
  v3 = *((_QWORD *)this + 1);
  *((_DWORD *)this + 4) = *(_DWORD *)(*(_QWORD *)this + 24);
  *((_DWORD *)this + 5) = *(_DWORD *)(v3 + 24);
  v4 = *(_QWORD *)(v2 + 16);
  v108[0] = 0xFFFFFFFFLL;
  v5 = *(_QWORD *)(v2 + 264);
  re::FixedArray<unsigned long>::init<unsigned long const&>((_QWORD *)this + 3, v4, v5, v108);
  v6 = *(_QWORD *)(*(_QWORD *)v1 + 304);
  re::FixedArray<unsigned long>::init<unsigned long const&>((_QWORD *)v1 + 6, v4, v6, v108);
  v7 = *(_QWORD *)(*(_QWORD *)v1 + 344);
  LODWORD(v127) = -1;
  re::FixedArray<unsigned int>::init<unsigned int>((_QWORD *)v1 + 9, v4, v7, &v127);
  v89 = *(_QWORD *)(*(_QWORD *)v1 + 384);
  re::FixedArray<unsigned long>::init<unsigned long const&>((_QWORD *)v1 + 12, v4, v89, v108);
  v88 = *(_QWORD *)(*(_QWORD *)v1 + 424);
  re::FixedArray<unsigned long>::init<unsigned long const&>((_QWORD *)v1 + 15, v4, v88, v108);
  v87 = *(_QWORD *)(*(_QWORD *)v1 + 464);
  re::FixedArray<unsigned long>::init<unsigned long const&>((_QWORD *)v1 + 18, v4, v87, v108);
  v86 = *(_QWORD *)(*(_QWORD *)v1 + 504);
  re::FixedArray<unsigned long>::init<unsigned long const&>((_QWORD *)v1 + 21, v4, v86, v108);
  v85 = *(_QWORD *)(*(_QWORD *)v1 + 544);
  re::FixedArray<unsigned long>::init<unsigned long const&>((_QWORD *)v1 + 24, v4, v85, v108);
  v84 = *(_QWORD *)(*(_QWORD *)v1 + 624);
  re::FixedArray<unsigned long>::init<unsigned long const&>((_QWORD *)v1 + 27, v4, v84, v108);
  v8 = *(_QWORD *)(*(_QWORD *)v1 + 664);
  LODWORD(v127) = -1;
  re::FixedArray<unsigned int>::init<unsigned int>((_QWORD *)v1 + 30, v4, v8, &v127);
  v82 = *(_QWORD *)(*(_QWORD *)v1 + 744);
  result = (uint64_t)re::FixedArray<unsigned long>::init<unsigned long const&>((_QWORD *)v1 + 33, v4, v82, v108);
  if (v5)
  {
    v10 = 0;
    v11 = 0;
    while (1)
    {
      v12 = *(_QWORD *)(*(_QWORD *)v1 + 264);
      if (v12 <= v11)
        goto LABEL_137;
      result = re::internal::TypeTranslationTable::findMatchingType(v1, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v1 + 280) + v10));
      v12 = *((_QWORD *)v1 + 4);
      if (v12 <= v11)
        break;
      *(_QWORD *)(*((_QWORD *)v1 + 5) + 8 * v11++) = result;
      v10 += 72;
      if (v5 == v11)
        goto LABEL_6;
    }
LABEL_138:
    *(_QWORD *)v109 = 0;
    v130 = 0u;
    v131 = 0u;
    v128 = 0u;
    v129 = 0u;
    v127 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v116 = 136315906;
    *(_QWORD *)v117 = "operator[]";
    *(_WORD *)&v117[8] = 1024;
    *(_DWORD *)&v117[10] = 468;
    v118 = 2048;
    *(_QWORD *)v119 = v11;
    *(_WORD *)&v119[8] = 2048;
    *(_QWORD *)&v119[10] = v12;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_139;
  }
LABEL_6:
  v13 = (_BYTE *)v84;
  if (v6)
  {
    v14 = 0;
    v5 = 0;
    while (1)
    {
      v11 = *(_QWORD *)(*(_QWORD *)v1 + 304);
      if (v11 <= v5)
        break;
      result = re::internal::TypeTranslationTable::findMatchingType(v1, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v1 + 320) + v14));
      v11 = *((_QWORD *)v1 + 7);
      if (v11 <= v5)
        goto LABEL_140;
      *(_QWORD *)(*((_QWORD *)v1 + 8) + 8 * v5++) = result;
      v14 += 96;
      if (v6 == v5)
        goto LABEL_11;
    }
LABEL_139:
    *(_QWORD *)v109 = 0;
    v130 = 0u;
    v131 = 0u;
    v128 = 0u;
    v129 = 0u;
    v127 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v116 = 136315906;
    *(_QWORD *)v117 = "operator[]";
    *(_WORD *)&v117[8] = 1024;
    *(_DWORD *)&v117[10] = 797;
    v118 = 2048;
    *(_QWORD *)v119 = v5;
    *(_WORD *)&v119[8] = 2048;
    *(_QWORD *)&v119[10] = v11;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_140:
    *(_QWORD *)v109 = 0;
    v51 = (unint64_t)v109;
    v130 = 0u;
    v131 = 0u;
    v128 = 0u;
    v129 = 0u;
    v127 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v116 = 136315906;
    *(_QWORD *)v117 = "operator[]";
    *(_WORD *)&v117[8] = 1024;
    *(_DWORD *)&v117[10] = 468;
    v118 = 2048;
    *(_QWORD *)v119 = v5;
    *(_WORD *)&v119[8] = 2048;
    *(_QWORD *)&v119[10] = v11;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_141;
  }
LABEL_11:
  v15 = *(_QWORD *)(*(_QWORD *)v1 + 304);
  v95 = v1;
  if (v15)
  {
    v16 = *(uint64_t **)(*(_QWORD *)v1 + 320);
    v17 = &v16[12 * v15];
    v83 = v17;
    do
    {
      re::TypeRegistry::typeInfo(*(_QWORD **)v1, *v16, &v127);
      re::TypeInfo::TypeInfo((uint64_t)v99, (uint64_t)&v127 + 8);
      v18 = *v100;
      v107[0] = v99[0];
      v107[1] = v18;
      result = (uint64_t)re::internal::TypeTranslationTable::translateType(v120, v1, v107);
      if (!*(_QWORD *)v120)
      {
        v19 = (re::TypeRegistry *)*((_QWORD *)v1 + 1);
        v20 = re::TypeInfo::name((re::TypeInfo *)v99);
        result = (uint64_t)re::TypeRegistry::typeInfo(v19, (const re::StringID *)v20, &v116);
        if ((_BYTE)v116)
        {
          v21 = re::DataArray<re::TextureAtlasTile>::tryGet(v99[0] + 96, *v100);
          v22 = v21 ? *(_DWORD *)(v21 + 16) : -1;
          re::TypeInfo::atVersion((re::TypeInfo *)&v117[4], v22, (unsigned __int8 *)&v127);
          result = (uint64_t)re::Optional<re::TypeInfo>::operator=(&v116, (unsigned __int8 *)&v127);
          if ((_BYTE)v116)
          {
            v94 = re::TypeInfo::enumConstants((re::TypeInfo *)v99);
            v24 = v23;
            result = re::TypeInfo::enumConstants((re::TypeInfo *)&v117[4]);
            v90 = result;
            v93 = v24;
            if (v24)
            {
              v12 = v25;
              v26 = 0;
              v27 = -(uint64_t)v25;
              v98 = (re::TypeInfo *)(result + 8);
              v91 = -(uint64_t)v25;
              v92 = v16;
              do
              {
                v96 = v26;
                if (!v12)
                  goto LABEL_27;
                v28 = 0;
                v29 = v98;
                v30 = (_QWORD *)(v94 + 24 * v26 + 8);
                while (1)
                {
                  result = re::StringID::operator==(v29, v30);
                  if ((result & 1) != 0)
                    break;
                  --v28;
                  v29 = (re::TypeInfo *)((char *)v29 + 24);
                  if (v27 == v28)
                    goto LABEL_27;
                }
                if ((_DWORD)v28 != 1)
                {
                  v36 = -v28;
                }
                else
                {
LABEL_27:
                  v31 = re::TypeInfo::renamedEnumConstants((re::TypeInfo *)&v117[4]);
                  if (!v32)
                    goto LABEL_40;
                  v33 = v31;
                  v34 = v32;
                  v35 = 0;
                  LODWORD(v36) = -1;
                  do
                  {
                    result = re::StringID::operator==((_QWORD *)(v33 + 24 * v35 + 8), (_QWORD *)(v94 + 24 * v96 + 8));
                    if ((_DWORD)result)
                      v37 = v12 == 0;
                    else
                      v37 = 1;
                    if (!v37)
                    {
                      v38 = 0;
                      v39 = (uint64_t *)v90;
                      while (1)
                      {
                        v40 = *v39;
                        v39 += 3;
                        if (v40 == *(_QWORD *)(v33 + 24 * v35))
                          break;
                        if (v12 == ++v38)
                          goto LABEL_38;
                      }
                      LODWORD(v36) = v38;
                    }
LABEL_38:
                    ++v35;
                  }
                  while (v35 != v34);
                  if ((_DWORD)v36 == -1)
                  {
LABEL_40:
                    result = re::TypeInfo::renamedEnumConstants((re::TypeInfo *)v99);
                    if (v41)
                    {
                      v42 = result;
                      v43 = v41;
                      v44 = 0;
                      v45 = *(_QWORD *)(v94 + 24 * v96);
                      LODWORD(v36) = -1;
                      do
                      {
                        if (v12 && *(_QWORD *)(v42 + 24 * v44) == v45)
                        {
                          v46 = 0;
                          v47 = v98;
                          while (1)
                          {
                            result = re::StringID::operator==(v47, (_QWORD *)(v42 + 24 * v44 + 8));
                            if ((_DWORD)result)
                              break;
                            ++v46;
                            v47 = (re::TypeInfo *)((char *)v47 + 24);
                            if (v12 == v46)
                              goto LABEL_49;
                          }
                          LODWORD(v36) = v46;
                        }
LABEL_49:
                        ++v44;
                      }
                      while (v44 != v43);
                    }
                    else
                    {
                      LODWORD(v36) = -1;
                    }
                  }
                }
                v16 = v92;
                v1 = v95;
                v48 = v96 + *((unsigned int *)v92 + 20);
                v11 = *((_QWORD *)v95 + 10);
                if (v11 <= v48)
                {
                  v105[0] = 0;
                  v5 = (unint64_t)v109;
                  v130 = 0u;
                  v131 = 0u;
                  v128 = 0u;
                  v129 = 0u;
                  v127 = 0u;
                  os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
                  *(_DWORD *)v109 = 136315906;
                  *(_QWORD *)&v109[4] = "operator[]";
                  v110 = 1024;
                  v111 = 468;
                  v112 = 2048;
                  v113 = v48;
                  v114 = 2048;
                  *(_QWORD *)v115 = v11;
                  _os_log_send_and_compose_impl();
                  _os_crash_msg();
                  __break(1u);
                  goto LABEL_136;
                }
                *(_DWORD *)(*((_QWORD *)v95 + 11) + 4 * v48) = v36;
                v26 = v96 + 1;
                v27 = v91;
              }
              while (v96 + 1 != v93);
            }
          }
        }
        v17 = v83;
        v13 = (_BYTE *)v84;
      }
      v16 += 12;
    }
    while (v16 != v17);
  }
  v49 = (_BYTE *)v82;
  if (v89)
  {
    v50 = 0;
    v51 = 0;
    while (1)
    {
      v5 = *(_QWORD *)(*(_QWORD *)v1 + 384);
      if (v5 <= v51)
        break;
      result = re::internal::TypeTranslationTable::findMatchingType(v1, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v1 + 400) + v50));
      v5 = *((_QWORD *)v1 + 13);
      if (v5 <= v51)
        goto LABEL_142;
      *(_QWORD *)(*((_QWORD *)v1 + 14) + 8 * v51++) = result;
      v50 += 96;
      if (v89 == v51)
        goto LABEL_62;
    }
LABEL_141:
    *(_QWORD *)v109 = 0;
    v130 = 0u;
    v131 = 0u;
    v128 = 0u;
    v129 = 0u;
    v127 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v116 = 136315906;
    *(_QWORD *)v117 = "operator[]";
    *(_WORD *)&v117[8] = 1024;
    *(_DWORD *)&v117[10] = 797;
    v118 = 2048;
    *(_QWORD *)v119 = v51;
    *(_WORD *)&v119[8] = 2048;
    *(_QWORD *)&v119[10] = v5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_142:
    *(_QWORD *)v109 = 0;
    v130 = 0u;
    v131 = 0u;
    v128 = 0u;
    v129 = 0u;
    v127 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v116 = 136315906;
    *(_QWORD *)v117 = "operator[]";
    *(_WORD *)&v117[8] = 1024;
    *(_DWORD *)&v117[10] = 468;
    v118 = 2048;
    *(_QWORD *)v119 = v51;
    *(_WORD *)&v119[8] = 2048;
    *(_QWORD *)&v119[10] = v5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_143;
  }
LABEL_62:
  if (v88)
  {
    v52 = 0;
    v51 = 0;
    while (1)
    {
      v5 = *(_QWORD *)(*(_QWORD *)v1 + 424);
      if (v5 <= v51)
        break;
      result = re::internal::TypeTranslationTable::findMatchingType(v1, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v1 + 440) + v52));
      v5 = *((_QWORD *)v1 + 16);
      if (v5 <= v51)
        goto LABEL_144;
      *(_QWORD *)(*((_QWORD *)v1 + 17) + 8 * v51++) = result;
      v52 += 96;
      if (v88 == v51)
        goto LABEL_67;
    }
LABEL_143:
    *(_QWORD *)v109 = 0;
    v130 = 0u;
    v131 = 0u;
    v128 = 0u;
    v129 = 0u;
    v127 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v116 = 136315906;
    *(_QWORD *)v117 = "operator[]";
    *(_WORD *)&v117[8] = 1024;
    *(_DWORD *)&v117[10] = 797;
    v118 = 2048;
    *(_QWORD *)v119 = v51;
    *(_WORD *)&v119[8] = 2048;
    *(_QWORD *)&v119[10] = v5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_144:
    *(_QWORD *)v109 = 0;
    v130 = 0u;
    v131 = 0u;
    v128 = 0u;
    v129 = 0u;
    v127 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v116 = 136315906;
    *(_QWORD *)v117 = "operator[]";
    *(_WORD *)&v117[8] = 1024;
    *(_DWORD *)&v117[10] = 468;
    v118 = 2048;
    *(_QWORD *)v119 = v51;
    *(_WORD *)&v119[8] = 2048;
    *(_QWORD *)&v119[10] = v5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_145;
  }
LABEL_67:
  if (v87)
  {
    v53 = 0;
    v51 = 0;
    while (1)
    {
      v5 = *(_QWORD *)(*(_QWORD *)v1 + 464);
      if (v5 <= v51)
        break;
      result = re::internal::TypeTranslationTable::findMatchingType(v1, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v1 + 480) + v53));
      v5 = *((_QWORD *)v1 + 19);
      if (v5 <= v51)
        goto LABEL_146;
      *(_QWORD *)(*((_QWORD *)v1 + 20) + 8 * v51++) = result;
      v53 += 128;
      if (v87 == v51)
        goto LABEL_72;
    }
LABEL_145:
    *(_QWORD *)v109 = 0;
    v130 = 0u;
    v131 = 0u;
    v128 = 0u;
    v129 = 0u;
    v127 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v116 = 136315906;
    *(_QWORD *)v117 = "operator[]";
    *(_WORD *)&v117[8] = 1024;
    *(_DWORD *)&v117[10] = 797;
    v118 = 2048;
    *(_QWORD *)v119 = v51;
    *(_WORD *)&v119[8] = 2048;
    *(_QWORD *)&v119[10] = v5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_146:
    *(_QWORD *)v109 = 0;
    v130 = 0u;
    v131 = 0u;
    v128 = 0u;
    v129 = 0u;
    v127 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v116 = 136315906;
    *(_QWORD *)v117 = "operator[]";
    *(_WORD *)&v117[8] = 1024;
    *(_DWORD *)&v117[10] = 468;
    v118 = 2048;
    *(_QWORD *)v119 = v51;
    *(_WORD *)&v119[8] = 2048;
    *(_QWORD *)&v119[10] = v5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_147;
  }
LABEL_72:
  if (v86)
  {
    v54 = 0;
    v51 = 0;
    while (1)
    {
      v5 = *(_QWORD *)(*(_QWORD *)v1 + 504);
      if (v5 <= v51)
        break;
      result = re::internal::TypeTranslationTable::findMatchingType(v1, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v1 + 520) + v54));
      v5 = *((_QWORD *)v1 + 22);
      if (v5 <= v51)
        goto LABEL_148;
      *(_QWORD *)(*((_QWORD *)v1 + 23) + 8 * v51++) = result;
      v54 += 160;
      if (v86 == v51)
        goto LABEL_77;
    }
LABEL_147:
    *(_QWORD *)v109 = 0;
    v130 = 0u;
    v131 = 0u;
    v128 = 0u;
    v129 = 0u;
    v127 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v116 = 136315906;
    *(_QWORD *)v117 = "operator[]";
    *(_WORD *)&v117[8] = 1024;
    *(_DWORD *)&v117[10] = 797;
    v118 = 2048;
    *(_QWORD *)v119 = v51;
    *(_WORD *)&v119[8] = 2048;
    *(_QWORD *)&v119[10] = v5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_148:
    *(_QWORD *)v109 = 0;
    v130 = 0u;
    v131 = 0u;
    v128 = 0u;
    v129 = 0u;
    v127 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v116 = 136315906;
    *(_QWORD *)v117 = "operator[]";
    *(_WORD *)&v117[8] = 1024;
    *(_DWORD *)&v117[10] = 468;
    v118 = 2048;
    *(_QWORD *)v119 = v51;
    *(_WORD *)&v119[8] = 2048;
    *(_QWORD *)&v119[10] = v5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_149;
  }
LABEL_77:
  if (v85)
  {
    v55 = 0;
    v51 = 0;
    while (1)
    {
      v5 = *(_QWORD *)(*(_QWORD *)v1 + 544);
      if (v5 <= v51)
        break;
      result = re::internal::TypeTranslationTable::findMatchingType(v1, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v1 + 560) + v55));
      v5 = *((_QWORD *)v1 + 25);
      if (v5 <= v51)
        goto LABEL_150;
      *(_QWORD *)(*((_QWORD *)v1 + 26) + 8 * v51++) = result;
      v55 += 96;
      if (v85 == v51)
        goto LABEL_82;
    }
LABEL_149:
    *(_QWORD *)v109 = 0;
    v130 = 0u;
    v131 = 0u;
    v128 = 0u;
    v129 = 0u;
    v127 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v116 = 136315906;
    *(_QWORD *)v117 = "operator[]";
    *(_WORD *)&v117[8] = 1024;
    *(_DWORD *)&v117[10] = 797;
    v118 = 2048;
    *(_QWORD *)v119 = v51;
    *(_WORD *)&v119[8] = 2048;
    *(_QWORD *)&v119[10] = v5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_150:
    *(_QWORD *)v109 = 0;
    v130 = 0u;
    v131 = 0u;
    v128 = 0u;
    v129 = 0u;
    v127 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v116 = 136315906;
    *(_QWORD *)v117 = "operator[]";
    *(_WORD *)&v117[8] = 1024;
    *(_DWORD *)&v117[10] = 468;
    v118 = 2048;
    *(_QWORD *)v119 = v51;
    *(_WORD *)&v119[8] = 2048;
    *(_QWORD *)&v119[10] = v5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_151;
  }
LABEL_82:
  if (v13)
  {
    v56 = 0;
    v51 = 0;
    while (1)
    {
      v5 = *(_QWORD *)(*(_QWORD *)v1 + 624);
      if (v5 <= v51)
        break;
      result = re::internal::TypeTranslationTable::findMatchingType(v1, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v1 + 640) + v56));
      v5 = *((_QWORD *)v1 + 28);
      if (v5 <= v51)
        goto LABEL_152;
      *(_QWORD *)(*((_QWORD *)v1 + 29) + 8 * v51++) = result;
      v56 += 152;
      if (v13 == (_BYTE *)v51)
        goto LABEL_87;
    }
LABEL_151:
    *(_QWORD *)v109 = 0;
    v130 = 0u;
    v131 = 0u;
    v128 = 0u;
    v129 = 0u;
    v127 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v116 = 136315906;
    *(_QWORD *)v117 = "operator[]";
    *(_WORD *)&v117[8] = 1024;
    *(_DWORD *)&v117[10] = 797;
    v118 = 2048;
    *(_QWORD *)v119 = v51;
    *(_WORD *)&v119[8] = 2048;
    *(_QWORD *)&v119[10] = v5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_152:
    *(_QWORD *)v109 = 0;
    v130 = 0u;
    v131 = 0u;
    v128 = 0u;
    v129 = 0u;
    v127 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v116 = 136315906;
    *(_QWORD *)v117 = "operator[]";
    *(_WORD *)&v117[8] = 1024;
    *(_DWORD *)&v117[10] = 468;
    v118 = 2048;
    *(_QWORD *)v119 = v51;
    *(_WORD *)&v119[8] = 2048;
    *(_QWORD *)&v119[10] = v5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_153:
    *(_QWORD *)v109 = 0;
    v130 = 0u;
    v131 = 0u;
    v128 = 0u;
    v129 = 0u;
    v127 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v116 = 136315906;
    *(_QWORD *)v117 = "operator[]";
    *(_WORD *)&v117[8] = 1024;
    *(_DWORD *)&v117[10] = 797;
    v118 = 2048;
    *(_QWORD *)v119 = v51;
    *(_WORD *)&v119[8] = 2048;
    *(_QWORD *)&v119[10] = v5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_154:
    *(_QWORD *)v109 = 0;
    v130 = 0u;
    v131 = 0u;
    v128 = 0u;
    v129 = 0u;
    v127 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v116 = 136315906;
    *(_QWORD *)v117 = "operator[]";
    *(_WORD *)&v117[8] = 1024;
    *(_DWORD *)&v117[10] = 468;
    v118 = 2048;
    *(_QWORD *)v119 = v51;
    *(_WORD *)&v119[8] = 2048;
    *(_QWORD *)&v119[10] = v5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
LABEL_87:
  v57 = *(_QWORD *)(*(_QWORD *)v1 + 624);
  if (v57)
  {
    v58 = *(_QWORD *)(*(_QWORD *)v1 + 640);
    v59 = v58 + 152 * v57;
    v97 = v59;
    do
    {
      re::TypeRegistry::typeInfo(*(_QWORD **)v1, *(_QWORD *)v58, &v127);
      re::TypeInfo::TypeInfo((uint64_t)v105, (uint64_t)&v127 + 8);
      v60 = *v106;
      v103[0] = v105[0];
      v103[1] = v60;
      result = (uint64_t)re::internal::TypeTranslationTable::translateType(&v104, v1, v103);
      if (!v104)
      {
        v61 = (re::TypeRegistry *)*((_QWORD *)v1 + 1);
        v62 = re::TypeInfo::name((re::TypeInfo *)v105);
        result = (uint64_t)re::TypeRegistry::typeInfo(v61, (const re::StringID *)v62, &v116);
        if ((_BYTE)v116)
        {
          v63 = re::DataArray<re::TextureAtlasTile>::tryGet(v105[0] + 96, *v106);
          v64 = v63 ? *(_DWORD *)(v63 + 16) : -1;
          re::TypeInfo::atVersion((re::TypeInfo *)&v117[4], v64, (unsigned __int8 *)&v127);
          result = (uint64_t)re::Optional<re::TypeInfo>::operator=(&v116, (unsigned __int8 *)&v127);
          if ((_BYTE)v116)
          {
            re::TypeMemberCollection::TypeMemberCollection((uint64_t)v109, v105[0], (uint64_t)v106);
            result = re::TypeMemberCollection::TypeMemberCollection((uint64_t)v99, *(uint64_t *)&v117[4], *(uint64_t *)&v119[4]);
            v65 = *(_QWORD *)&v115[2];
            if (*(_QWORD *)&v115[2])
            {
              v66 = 0;
              while (1)
              {
                re::TypeMemberCollection::operator[]((uint64_t *)v109, v66, (uint64_t)&v127);
                if (!v102)
                  goto LABEL_157;
                v67 = 0;
                v68 = (_QWORD *)(v128 + 8);
                v69 = -(uint64_t)v102;
                v70 = (_QWORD *)(v101 + 8);
                while (1)
                {
                  result = re::StringID::operator==(v70, v68);
                  if ((result & 1) != 0)
                    break;
                  --v67;
                  v70 += 5;
                  if (v69 == v67)
                    goto LABEL_105;
                }
                if ((_DWORD)v67 != 1)
                {
                  v5 = -v67;
                }
                else
                {
LABEL_157:
                {
LABEL_105:
                  v71 = re::TypeInfo::renamedObjectMembers((re::TypeInfo *)&v117[4]);
                  if (!v72)
                    goto LABEL_111;
                  v73 = v71;
                  v74 = v72;
                  while (1)
                  {
                    re::TypeMemberCollection::operator[]((uint64_t *)v109, v66, (uint64_t)&v127);
                    result = re::StringID::operator==((_QWORD *)v73, (_QWORD *)(v128 + 8));
                    if ((result & 1) != 0)
                      break;
                    v73 += 24;
                    if (!--v74)
                      goto LABEL_111;
                  }
                  v5 = *(unsigned int *)(v73 + 16);
                  if ((_DWORD)v5 == -1)
                  {
LABEL_111:
                    result = re::TypeInfo::renamedObjectMembers((re::TypeInfo *)v105);
                    if (v75)
                    {
                      v76 = result;
                      v77 = v75;
                      v78 = 0;
                      v5 = 0xFFFFFFFFLL;
                      do
                      {
                        if (v66 == *(_DWORD *)(v76 + 24 * v78 + 16) && v102 != 0)
                        {
                          v80 = 0;
                          while (1)
                          {
                            re::TypeMemberCollection::operator[](v99, v80, (uint64_t)&v127);
                            result = re::StringID::operator==((_QWORD *)(v128 + 8), (_QWORD *)(v76 + 24 * v78));
                            if ((_DWORD)result)
                              break;
                            if (++v80 >= v102)
                              goto LABEL_122;
                          }
                          v5 = v80;
                        }
LABEL_122:
                        ++v78;
                      }
                      while (v78 != v77);
                    }
                    else
                    {
                      v5 = 0xFFFFFFFFLL;
                    }
                  }
                }
                }
                v11 = v66 + *(unsigned int *)(v58 + 84);
                v1 = v95;
                v12 = *((_QWORD *)v95 + 31);
                if (v12 <= v11)
                  break;
                *(_DWORD *)(*((_QWORD *)v95 + 32) + 4 * v11) = v5;
                if (++v66 == v65)
                  goto LABEL_128;
              }
LABEL_136:
              v108[1] = 0;
              v130 = 0u;
              v131 = 0u;
              v128 = 0u;
              v129 = 0u;
              v127 = 0u;
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              *(_DWORD *)v120 = 136315906;
              *(_QWORD *)&v120[4] = "operator[]";
              v121 = 1024;
              v122 = 468;
              v123 = 2048;
              v124 = v11;
              v125 = 2048;
              v126 = v12;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
LABEL_137:
              *(_QWORD *)v109 = 0;
              v130 = 0u;
              v131 = 0u;
              v128 = 0u;
              v129 = 0u;
              v127 = 0u;
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              v116 = 136315906;
              *(_QWORD *)v117 = "operator[]";
              *(_WORD *)&v117[8] = 1024;
              *(_DWORD *)&v117[10] = 797;
              v118 = 2048;
              *(_QWORD *)v119 = v11;
              *(_WORD *)&v119[8] = 2048;
              *(_QWORD *)&v119[10] = v12;
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
              goto LABEL_138;
            }
LABEL_128:
            v49 = (_BYTE *)v82;
            v59 = v97;
          }
        }
      }
      v58 += 152;
    }
    while (v58 != v59);
  }
  if (v49)
  {
    v81 = 0;
    v51 = 0;
    while (1)
    {
      v5 = *(_QWORD *)(*(_QWORD *)v1 + 744);
      if (v5 <= v51)
        goto LABEL_153;
      result = re::internal::TypeTranslationTable::findMatchingType(v1, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v1 + 760) + v81));
      v5 = *((_QWORD *)v1 + 34);
      if (v5 <= v51)
        goto LABEL_154;
      *(_QWORD *)(*((_QWORD *)v1 + 35) + 8 * v51++) = result;
      v81 += 104;
      if (v49 == (_BYTE *)v51)
        return result;
    }
  }
  return result;
}

uint64_t re::internal::TypeTranslationTable::rebuildIfNecessary(uint64_t this)
{
  re::internal::TypeTranslationTable *v1;
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint8_t v14[16];

  v1 = (re::internal::TypeTranslationTable *)this;
  if (*(_DWORD *)(*(_QWORD *)this + 24) != *(_DWORD *)(this + 16)
    || *(_DWORD *)(*(_QWORD *)(this + 8) + 24) != *(_DWORD *)(this + 20))
  {
    v2 = *re::foundationIntrospectionLogObjects((re *)this);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v14 = 0;
      _os_log_impl(&dword_224FE9000, v2, OS_LOG_TYPE_DEFAULT, "Type registry was modified. Rebuilding type translation table.", v14, 2u);
    }
    v3 = *((_QWORD *)v1 + 3);
    if (v3)
    {
      if (*((_QWORD *)v1 + 4))
      {
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *((_QWORD *)v1 + 5));
        *((_QWORD *)v1 + 4) = 0;
        *((_QWORD *)v1 + 5) = 0;
      }
      *((_QWORD *)v1 + 3) = 0;
    }
    v4 = *((_QWORD *)v1 + 6);
    if (v4)
    {
      if (*((_QWORD *)v1 + 7))
      {
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, *((_QWORD *)v1 + 8));
        *((_QWORD *)v1 + 7) = 0;
        *((_QWORD *)v1 + 8) = 0;
      }
      *((_QWORD *)v1 + 6) = 0;
    }
    v5 = *((_QWORD *)v1 + 9);
    if (v5)
    {
      if (*((_QWORD *)v1 + 10))
      {
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v5 + 40))(v5, *((_QWORD *)v1 + 11));
        *((_QWORD *)v1 + 10) = 0;
        *((_QWORD *)v1 + 11) = 0;
      }
      *((_QWORD *)v1 + 9) = 0;
    }
    v6 = *((_QWORD *)v1 + 12);
    if (v6)
    {
      if (*((_QWORD *)v1 + 13))
      {
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v6 + 40))(v6, *((_QWORD *)v1 + 14));
        *((_QWORD *)v1 + 13) = 0;
        *((_QWORD *)v1 + 14) = 0;
      }
      *((_QWORD *)v1 + 12) = 0;
    }
    v7 = *((_QWORD *)v1 + 15);
    if (v7)
    {
      if (*((_QWORD *)v1 + 16))
      {
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v7 + 40))(v7, *((_QWORD *)v1 + 17));
        *((_QWORD *)v1 + 16) = 0;
        *((_QWORD *)v1 + 17) = 0;
      }
      *((_QWORD *)v1 + 15) = 0;
    }
    v8 = *((_QWORD *)v1 + 18);
    if (v8)
    {
      if (*((_QWORD *)v1 + 19))
      {
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v8 + 40))(v8, *((_QWORD *)v1 + 20));
        *((_QWORD *)v1 + 19) = 0;
        *((_QWORD *)v1 + 20) = 0;
      }
      *((_QWORD *)v1 + 18) = 0;
    }
    v9 = *((_QWORD *)v1 + 21);
    if (v9)
    {
      if (*((_QWORD *)v1 + 22))
      {
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v9 + 40))(v9, *((_QWORD *)v1 + 23));
        *((_QWORD *)v1 + 22) = 0;
        *((_QWORD *)v1 + 23) = 0;
      }
      *((_QWORD *)v1 + 21) = 0;
    }
    v10 = *((_QWORD *)v1 + 24);
    if (v10)
    {
      if (*((_QWORD *)v1 + 25))
      {
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v10 + 40))(v10, *((_QWORD *)v1 + 26));
        *((_QWORD *)v1 + 25) = 0;
        *((_QWORD *)v1 + 26) = 0;
      }
      *((_QWORD *)v1 + 24) = 0;
    }
    v11 = *((_QWORD *)v1 + 27);
    if (v11)
    {
      if (*((_QWORD *)v1 + 28))
      {
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v11 + 40))(v11, *((_QWORD *)v1 + 29));
        *((_QWORD *)v1 + 28) = 0;
        *((_QWORD *)v1 + 29) = 0;
      }
      *((_QWORD *)v1 + 27) = 0;
    }
    v12 = *((_QWORD *)v1 + 30);
    if (v12)
    {
      if (*((_QWORD *)v1 + 31))
      {
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v12 + 40))(v12, *((_QWORD *)v1 + 32));
        *((_QWORD *)v1 + 31) = 0;
        *((_QWORD *)v1 + 32) = 0;
      }
      *((_QWORD *)v1 + 30) = 0;
    }
    v13 = *((_QWORD *)v1 + 33);
    if (v13)
    {
      if (*((_QWORD *)v1 + 34))
      {
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v13 + 40))(v13, *((_QWORD *)v1 + 35));
        *((_QWORD *)v1 + 34) = 0;
        *((_QWORD *)v1 + 35) = 0;
      }
      *((_QWORD *)v1 + 33) = 0;
    }
    return re::internal::TypeTranslationTable::buildTables(v1);
  }
  return this;
}

double re::internal::TypeTranslationTable::translateType@<D0>(_QWORD *a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  int *v6;
  double result;

  re::internal::TypeTranslationTable::rebuildIfNecessary((uint64_t)a1);
  v6 = (int *)re::DataArray<re::internal::TypeInfoIndex>::tryGet(*a1 + 32, *(_QWORD *)(a2 + 8));
  if (v6)
    return re::internal::TypeTranslationTable::translateType(a1, *v6, a3);
  *a3 = 0;
  *(_QWORD *)&result = 0xFFFFFFFFLL;
  a3[1] = 0xFFFFFFFFLL;
  return result;
}

uint64_t re::DataArray<re::internal::TypeInfoIndex>::tryGet(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unsigned int v3;
  uint64_t v4;
  int v5;
  BOOL v6;

  v2 = *(_QWORD *)(a1 + 16);
  if (WORD1(a2) < v2
    && ((unsigned __int16)(v2 - 1) != WORD1(a2) ? (v3 = *(_DWORD *)(a1 + 44)) : (v3 = *(_DWORD *)(a1 + 48)),
        (unsigned __int16)a2 < v3
     && ((v4 = *(_QWORD *)(a1 + 32),
          (v5 = *(_DWORD *)(*(_QWORD *)(v4 + 16 * WORD1(a2) + 8) + 4 * (unsigned __int16)a2)) != 0)
       ? (v6 = v5 == (HIDWORD(a2) & 0xFFFFFF))
       : (v6 = 0),
         v6)))
  {
    return *(_QWORD *)(v4 + 16 * WORD1(a2)) + 4 * (unsigned __int16)a2;
  }
  else
  {
    return 0;
  }
}

double re::internal::TypeTranslationTable::translateType@<D0>(_QWORD *a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  double result;

  v3 = *(_QWORD *)&a2 & 0xFFFFFFLL;
  if ((*(_QWORD *)&a2 & 0xFFFFFFLL) == 0xFFFFFF)
    goto LABEL_23;
  switch(HIBYTE(a2))
  {
    case 1:
      if (a1[4] <= v3)
      {
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_26:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_27:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_28:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_29:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_30:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_31:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_32:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_33:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      v4 = a1 + 5;
      break;
    case 2:
      if (a1[7] <= v3)
        goto LABEL_26;
      v4 = a1 + 8;
      break;
    case 3:
      if (a1[13] <= v3)
        goto LABEL_27;
      v4 = a1 + 14;
      break;
    case 4:
      if (a1[16] <= v3)
        goto LABEL_28;
      v4 = a1 + 17;
      break;
    case 5:
      if (a1[19] <= v3)
        goto LABEL_29;
      v4 = a1 + 20;
      break;
    case 6:
      if (a1[22] <= v3)
        goto LABEL_30;
      v4 = a1 + 23;
      break;
    case 7:
      if (a1[25] <= v3)
        goto LABEL_31;
      v4 = a1 + 26;
      break;
    case 8:
      if (a1[28] <= v3)
        goto LABEL_32;
      v4 = a1 + 29;
      break;
    case 9:
      if (a1[34] <= v3)
        goto LABEL_33;
      v4 = a1 + 35;
      break;
    default:
      goto LABEL_23;
  }
  v5 = *(_QWORD *)(*v4 + 8 * v3);
  if ((v5 & 0xFFFFFF00000000) == 0)
  {
LABEL_23:
    *a3 = 0;
    *(_QWORD *)&result = 0xFFFFFFFFLL;
    a3[1] = 0xFFFFFFFFLL;
  }
  else
  {
    *a3 = a1[1];
    a3[1] = v5;
  }
  return result;
}

uint64_t re::FixedArray<re::DataArrayHandle<re::internal::TypeInfoIndex>>::operator[](uint64_t a1, unint64_t a2)
{
  if (*(_QWORD *)(a1 + 8) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a1 + 16) + 8 * a2;
}

uint64_t re::internal::TypeTranslationTable::translateMember(re::internal::TypeTranslationTable *this, const re::TypeMemberInfo *a2)
{
  unint64_t v4;

  re::internal::TypeTranslationTable::rebuildIfNecessary((uint64_t)this);
  v4 = (*((_DWORD *)a2 + 6) + *(_DWORD *)(*((_QWORD *)a2 + 1) + 84));
  if (*((_QWORD *)this + 31) <= v4)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(unsigned int *)(*((_QWORD *)this + 32) + 4 * v4);
}

uint64_t re::internal::TypeTranslationTable::translateSerializedEnum(re::internal::TypeTranslationTable *this, const re::TypeInfo *a2, int a3, const re::TypeInfo *a4)
{
  uint64_t *v8;
  uint64_t *v9;
  _BOOL8 v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  NSObject *v15;
  uint64_t v16;
  uint64_t v17;
  _OWORD buf[5];
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  re::internal::TypeTranslationTable::rebuildIfNecessary((uint64_t)this);
  v8 = re::TypeInfo::name(a2);
  v9 = re::TypeInfo::name(a4);
  v10 = re::StringID::operator==(v8, v9);
  if (v10)
  {
    v11 = (*(_DWORD *)(*((_QWORD *)a2 + 2) + 80) + a3);
    if (*((_QWORD *)this + 10) <= v11)
    {
      memset(buf, 0, sizeof(buf));
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_10;
    }
    v11 = *(unsigned int *)(*((_QWORD *)this + 11) + 4 * v11);
    if ((v11 & 0x80000000) == 0)
    {
      v12 = re::TypeInfo::enumConstants(a4);
      if (v13 > v11)
        return v12 + 24 * v11;
LABEL_10:
      re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v11, v13);
      _os_crash();
      __break(1u);
    }
  }
  else
  {
    v15 = *re::foundationIntrospectionLogObjects((re *)v10);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      v16 = re::TypeInfo::name(a2)[1];
      v17 = re::TypeInfo::name(a4)[1];
      LODWORD(buf[0]) = 136315394;
      *(_QWORD *)((char *)buf + 4) = v16;
      WORD6(buf[0]) = 2080;
      *(_QWORD *)((char *)buf + 14) = v17;
      _os_log_error_impl(&dword_224FE9000, v15, OS_LOG_TYPE_ERROR, "Failed to translate enum value. Enum names don't match. Serialized type \"%s\", runtime type \"%s\".", (uint8_t *)buf, 0x16u);
    }
  }
  return 0;
}

uint64_t re::internal::TypeTranslationTable::translateRuntimeEnum(re::internal::TypeTranslationTable *this, const re::TypeInfo *a2, int a3, const re::TypeInfo *a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t result;
  uint64_t v12;
  unint64_t v13;

  re::internal::TypeTranslationTable::rebuildIfNecessary((uint64_t)this);
  v7 = re::FixedArray<unsigned int>::slice((uint64_t)this + 72, *(unsigned int *)(*((_QWORD *)a4 + 2) + 80), *(unsigned int *)(*((_QWORD *)a4 + 2) + 84));
  if (!v8)
    return 0;
  v9 = 0;
  v10 = 0;
  while (*(_DWORD *)(v7 + 4 * v10) != a3)
  {
    ++v10;
    v9 -= 24;
    if (v8 == v10)
      return 0;
  }
  v12 = re::TypeInfo::enumConstants(a4);
  if (v13 > v10)
    return v12 - v9;
  re::internal::assertLog((re::internal *)6, v13, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v10, v13);
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::internal::TypeTranslationTable::findMatchingType(re::internal::TypeTranslationTable *a1, uint64_t a2)
{
  const re::StringID *v4;
  uint64_t v5;
  int v6;
  unsigned __int8 v8[40];
  _BYTE v9[8];
  _QWORD v10[4];
  _QWORD v11[4];

  re::TypeRegistry::typeInfo(*(_QWORD **)a1, a2, v9);
  re::TypeInfo::TypeInfo((uint64_t)v11, (uint64_t)v10);
  v4 = (const re::StringID *)re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)a1 + 96, a2);
  if (!v4)
  {
  }
  re::TypeRegistry::typeInfo(*((re::TypeRegistry **)a1 + 1), v4, v9);
  if (v9[0]
    && ((v5 = re::DataArray<re::TextureAtlasTile>::tryGet(v11[0] + 96, *(_QWORD *)v11[2])) == 0
      ? (v6 = -1)
      : (v6 = *(_DWORD *)(v5 + 16)),
        (re::TypeInfo::atVersion((re::TypeInfo *)v10, v6, v8), re::Optional<re::TypeInfo>::operator=(v9, v8), v9[0])
     && re::internal::TypeTranslationTable::areEquivalent(a1, (const re::TypeInfo *)v11, (const re::TypeInfo *)v10)))
  {
    return *(_QWORD *)v10[2];
  }
  else
  {
    return 0xFFFFFFFFLL;
  }
}

uint64_t re::internal::TypeTranslationTable::areEquivalent(re::internal::TypeTranslationTable *this, const re::TypeInfo *a2, const re::TypeInfo *a3)
{
  int v6;
  uint64_t v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  _QWORD *v21;
  _QWORD *v22;
  uint64_t v23;
  int v24;
  const re::TypeInfo *v25;
  const re::TypeInfo *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _QWORD *v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t *v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t v36;
  char v38[8];
  _QWORD v39[4];
  char v40[8];
  _QWORD v41[4];
  _BYTE v42[32];
  _BYTE v43[32];
  uint64_t v44;
  _QWORD v45[4];
  uint64_t v46;
  unint64_t v47[3];
  unint64_t v48;
  uint64_t v49;
  unsigned __int16 v50;
  unsigned __int16 v51;
  int v52;

  v6 = *(_DWORD *)re::DataArray<re::internal::TypeInfoIndex>::get(*(_QWORD *)this + 32, **((_QWORD **)a2 + 2));
  re::internal::TypeTranslationTable::translateType(this, v6, &v49);
  if (v49)
  {
    if (v49 == *(_QWORD *)a3)
    {
      v7 = **((_QWORD **)a3 + 2);
      if (v50 == (unsigned __int16)v7 && v51 == WORD1(v7))
      {
        v8 = ((v52 ^ HIDWORD(v7)) & 0xFFFFFF) == 0;
LABEL_6:
        LOBYTE(v9) = v8;
        return v9 & 1;
      }
    }
LABEL_63:
    LOBYTE(v9) = 0;
    return v9 & 1;
  }
  if (*((unsigned __int8 *)a2 + 12) != *((unsigned __int8 *)a3 + 12))
    goto LABEL_63;
  v10 = re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)a2 + 96, **((_QWORD **)a2 + 2));
  v11 = v10 ? *(_DWORD *)(v10 + 16) : -1;
  v9 = re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)a3 + 96, **((_QWORD **)a3 + 2));
  v13 = v9 ? *(_DWORD *)(v9 + 16) : -1;
  if (v11 != v13)
    goto LABEL_63;
  v14 = *((_QWORD *)a2 + 2);
  if ((*(_BYTE *)(v14 + 48) & 0x80) != 0)
    goto LABEL_63;
  switch(*((_BYTE *)a2 + 12))
  {
    case 0:
      re::internal::assertLog((re::internal *)4, v12, "assertion failure: '%s' (%s:line %i) Invalid type category.", "!\"Unreachable code\"", "areEquivalent", 573);
      _os_crash();
      __break(1u);
      JUMPOUT(0x225B71A3CLL);
    case 1:
      v15 = *((_QWORD *)a3 + 2);
      if (*(_DWORD *)(v14 + 8) != *(_DWORD *)(v15 + 8) || *(_DWORD *)(v14 + 12) != *(_DWORD *)(v15 + 12))
        goto LABEL_63;
      v8 = *(unsigned __int8 *)(v14 + 68) == *(unsigned __int8 *)(v15 + 68);
      goto LABEL_6;
    case 2:
      if (*(_DWORD *)(v14 + 8) != *(_DWORD *)(*((_QWORD *)a3 + 2) + 8))
        goto LABEL_63;
      v16 = re::TypeInfo::enumConstants(a2);
      v18 = v17;
      v46 = v16;
      v47[0] = v17;
      v44 = re::TypeInfo::enumConstants(a3);
      v45[0] = v19;
      if (v18 != v19)
        goto LABEL_63;
      if (!v18)
        goto LABEL_65;
      v20 = 0;
      while (1)
      {
        v21 = (_QWORD *)re::Slice<re::EnumConstant>::operator[](&v46, v20);
        v22 = (_QWORD *)re::Slice<re::EnumConstant>::operator[](&v44, v20);
        if (*v21 != *v22 || !re::StringID::operator==(v21 + 1, v22 + 1))
          break;
        if (++v20 >= v47[0])
        {
LABEL_65:
          LOBYTE(v9) = 1;
          return v9 & 1;
        }
      }
      goto LABEL_63;
    case 3:
    case 5:
      goto LABEL_59;
    case 4:
      v23 = *((_QWORD *)a3 + 2);
      v24 = *(_DWORD *)(v14 + 84) & 0xFFFFFF;
      if ((*(_DWORD *)(v23 + 84) & 0xFFFFFF) != 0)
      {
        if (!v24)
          goto LABEL_63;
      }
      else if (v24 || *(_DWORD *)(v23 + 88) != *(_DWORD *)(v14 + 88))
      {
        goto LABEL_63;
      }
LABEL_59:
      re::TypeInfo::referencedType(a2, (uint64_t)&v46);
      re::TypeInfo::referencedType(a3, (uint64_t)&v44);
      v25 = (const re::TypeInfo *)&v46;
      v26 = (const re::TypeInfo *)&v44;
LABEL_60:
      LOBYTE(v9) = re::internal::TypeTranslationTable::areEquivalent(this, v25, v26);
      return v9 & 1;
    case 6:
      re::TypeInfo::referencedType(a2, (uint64_t)&v46);
      re::TypeInfo::referencedType(a3, (uint64_t)&v44);
      LODWORD(v9) = re::internal::TypeTranslationTable::areEquivalent(this, (const re::TypeInfo *)&v46, (const re::TypeInfo *)&v44);
      if (!(_DWORD)v9)
        return v9 & 1;
      re::TypeInfo::dictionaryValueType(a2, (uint64_t)v40);
      re::TypeInfo::dictionaryValueType(a3, (uint64_t)v38);
      v25 = (const re::TypeInfo *)v40;
      v26 = (const re::TypeInfo *)v38;
      goto LABEL_60;
    case 7:
      re::TypeInfo::referencedType(a2, (uint64_t)&v46);
      re::TypeInfo::referencedType(a3, (uint64_t)&v44);
      LODWORD(v9) = re::internal::TypeTranslationTable::areEquivalent(this, (const re::TypeInfo *)&v46, (const re::TypeInfo *)&v44);
      if (!(_DWORD)v9)
        return v9 & 1;
      v27 = *(unsigned int *)(*((_QWORD *)a2 + 2) + 88);
      if ((_DWORD)v27 != *(_DWORD *)(*((_QWORD *)a3 + 2) + 88))
        goto LABEL_63;
      if (!(_DWORD)v27)
        goto LABEL_65;
      v28 = 0;
      v29 = v27 - 1;
      do
      {
        re::TypeInfo::unionMember(a2, v28, (uint64_t)&v46);
        re::TypeInfo::unionMember(a3, v28, (uint64_t)&v44);
        LODWORD(v9) = re::internal::TypeTranslationTable::areEquivalent(this, (const re::TypeInfo *)&v46, (const re::TypeInfo *)&v44);
        if (!(_DWORD)v9)
          break;
        v8 = v29 == v28++;
      }
      while (!v8);
      return v9 & 1;
    case 8:
      v30 = (_QWORD *)re::FixedArray<re::DataArrayHandle<re::internal::TypeInfoIndex>>::operator[]((uint64_t)this + 216, *(_QWORD *)&v6 & 0xFFFFFFLL);
      *v30 = **((_QWORD **)a3 + 2);
      v31 = *((_QWORD *)a2 + 2);
      if (((*(_DWORD *)(v31 + 76) & 0xFFFFFF) != 0) != ((*(_DWORD *)(*((_QWORD *)a3 + 2) + 76) & 0xFFFFFF) != 0))
        goto LABEL_71;
      if ((*(_DWORD *)(v31 + 76) & 0xFFFFFF) == 0)
        goto LABEL_47;
      re::TypeRegistry::typeInfo(*(_QWORD **)a2, *(_QWORD *)(v31 + 72), &v46);
      re::TypeRegistry::typeInfo(*(_QWORD **)a3, *(_QWORD *)(*((_QWORD *)a3 + 2) + 72), &v44);
      LODWORD(v9) = re::internal::TypeTranslationTable::areEquivalent(this, (const re::TypeInfo *)v47, (const re::TypeInfo *)v45);
      if (!(_DWORD)v9)
        goto LABEL_72;
      v31 = *((_QWORD *)a2 + 2);
LABEL_47:
      re::TypeMemberCollection::TypeMemberCollection((uint64_t)&v46, *(_QWORD *)a2, v31);
      re::TypeMemberCollection::TypeMemberCollection((uint64_t)&v44, *(_QWORD *)a3, *((_QWORD *)a3 + 2));
      if (v48 != v45[3])
        goto LABEL_71;
      if (!v48)
        goto LABEL_53;
      v32 = 0;
      break;
    case 9:
      if (*(unsigned __int8 *)(v14 + 80) == *(unsigned __int8 *)(*((_QWORD *)a3 + 2) + 80))
        goto LABEL_59;
      goto LABEL_63;
    default:
      return v9 & 1;
  }
  while (1)
  {
    re::TypeMemberCollection::operator[](&v46, v32, (uint64_t)v40);
    re::TypeMemberCollection::operator[](&v44, v32, (uint64_t)v38);
    if (!re::StringID::operator==((_QWORD *)(v41[1] + 8), (_QWORD *)(v39[1] + 8)))
      break;
    re::TypeMemberInfo::memberType((re::TypeMemberInfo *)v40, (uint64_t)v43);
    re::TypeMemberInfo::memberType((re::TypeMemberInfo *)v38, (uint64_t)v42);
    if ((re::internal::TypeTranslationTable::areEquivalent(this, (const re::TypeInfo *)v43, (const re::TypeInfo *)v42) & 1) == 0)
      break;
    if (++v32 >= v48)
    {
LABEL_53:
      v33 = re::TypeInfo::polymorphicObjectName(a2);
      v34 = re::TypeInfo::polymorphicObjectName(a3);
      LODWORD(v9) = re::StringID::operator==(v33, v34);
      if (!(_DWORD)v9)
        goto LABEL_72;
      v35 = *((_QWORD *)a2 + 2);
      v36 = *((_QWORD *)a3 + 2);
      if (*(_BYTE *)(v35 + 120) && *(_BYTE *)(v36 + 120))
      {
        if (*(_QWORD *)(v35 + 128) != *(_QWORD *)(v36 + 128))
          break;
      }
      else if (*(unsigned __int8 *)(v36 + 120) | *(unsigned __int8 *)(v35 + 120))
      {
        break;
      }
      re::TypeInfo::customClassIDMember(a2, (uint64_t)v40);
      re::TypeInfo::customClassIDMember(a3, (uint64_t)v38);
      if ((v40[0] != 0) == (v38[0] != 0))
      {
        if (!v40[0]
          || (re::TypeMemberInfo::memberType((re::TypeMemberInfo *)v41, (uint64_t)v43),
              re::TypeMemberInfo::memberType((re::TypeMemberInfo *)v39, (uint64_t)v42),
              (re::internal::TypeTranslationTable::areEquivalent(this, (const re::TypeInfo *)v43, (const re::TypeInfo *)v42) & 1) != 0))
        {
          LOBYTE(v9) = 1;
          goto LABEL_72;
        }
      }
      break;
    }
  }
LABEL_71:
  LOBYTE(v9) = 0;
LABEL_72:
  *v30 = 0xFFFFFFFFLL;
  return v9 & 1;
}

BOOL re::IntrospectionRegistry::contains(re::IntrospectionRegistry *this, const re::IntrospectionBase *a2)
{
  _BOOL8 v3;
  re::IntrospectionRegistry *v5;

  globalIntrospectionTable();
  os_unfair_lock_lock((os_unfair_lock_t)&dword_25582A660);
  v5 = this;
  v3 = re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::contains((uint64_t)&unk_25582A630, (uint64_t *)&v5);
  os_unfair_lock_unlock((os_unfair_lock_t)&dword_25582A660);
  return v3;
}

void globalIntrospectionTable(void)
{
  unsigned __int8 v0;
  _anonymous_namespace_::IntrospectionRegistryTable *v1;

  if ((v0 & 1) == 0)
  {
    if ((_DWORD)v1)
    {
    }
  }
}

BOOL re::IntrospectionRegistry::add(re::IntrospectionRegistry *this, const re::IntrospectionBase *a2)
{
  re *PrettyTypeName;
  const char *v4;
  uint64_t *v5;
  _BOOL4 v6;
  re::IntrospectionRegistry *v8;
  char v9;
  _BYTE v10[23];
  uint64_t v11;
  char v12;

  globalIntrospectionTable();
  PrettyTypeName = (re *)re::getPrettyTypeName(this, (const re::IntrospectionBase *)&v8);
  if ((v9 & 1) != 0)
    v4 = *(const char **)&v10[7];
  else
    v4 = v10;
  v5 = re::introspectionAllocator(PrettyTypeName);
  re::DynamicString::DynamicString((re::DynamicString *)&v11, v4, (re::Allocator *)v5);
  if (v8 && (v9 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v8 + 40))();
  os_unfair_lock_lock((os_unfair_lock_t)&dword_25582A660);
  v6 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::containsKey((uint64_t)&globalIntrospectionTable(void)::table, (uint64_t)&v11);
  if (!v6)
  {
    v8 = this;
    re::HashTable<re::DynamicString,re::IntrospectionBase const*,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addNew((uint64_t)&globalIntrospectionTable(void)::table, (re::DynamicString *)&v11, &v8);
    v8 = this;
    re::HashSetBase<re::IntrospectionBase const*,re::IntrospectionBase const*,re::internal::ValueAsKey<re::IntrospectionBase const*>,re::Hash<re::IntrospectionBase const*>,re::EqualTo<re::IntrospectionBase const*>,true,false>::add((uint64_t)&unk_25582A630, (uint64_t *)&v8);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&dword_25582A660);
  if (v11 && (v12 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v11 + 40))();
  return !v6;
}

uint64_t re::HashTable<re::DynamicString,re::IntrospectionBase const*,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addNew(uint64_t a1, re::DynamicString *a2, _QWORD *a3)
{
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  char v14;

  v6 = re::Hash<re::DynamicString>::operator()((uint64_t)&v14, (uint64_t)a2);
  v7 = v6;
  if (!*(_QWORD *)a1)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  v8 = v6 % *(unsigned int *)(a1 + 24);
  v9 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v8);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
LABEL_8:
    v11 = re::HashTable<re::DynamicString,re::IntrospectionBase const*,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove(a1, v8, v7, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    v12 = *(_QWORD *)(a1 + 16) + 56 * v11;
    return v12 + 48;
  }
  v10 = *(_QWORD *)(a1 + 16);
  while (!re::DynamicString::operator==(v10 + 56 * v9 + 16, (uint64_t)a2))
  {
    v9 = *(_DWORD *)(v10 + 56 * v9 + 8) & 0x7FFFFFFF;
    if (v9 == 0x7FFFFFFF)
      goto LABEL_8;
  }
  v12 = v10 + 56 * v9;
  return v12 + 48;
}

uint64_t re::HashSetBase<re::IntrospectionBase const*,re::IntrospectionBase const*,re::internal::ValueAsKey<re::IntrospectionBase const*>,re::Hash<re::IntrospectionBase const*>,re::EqualTo<re::IntrospectionBase const*>,true,false>::add(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;

  v4 = *a2;
  v5 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v6 = (0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) ^ ((0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) >> 31);
  v7 = *(unsigned int *)(a1 + 24);
  if (!(_DWORD)v7)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  v8 = v6 % v7;
  v9 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * (v6 % v7));
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
LABEL_8:
    v12 = re::HashSetBase<re::IntrospectionBase const*,re::IntrospectionBase const*,re::internal::ValueAsKey<re::IntrospectionBase const*>,re::Hash<re::IntrospectionBase const*>,re::EqualTo<re::IntrospectionBase const*>,true,false>::addAsMove(a1, v8, v6, (uint64_t)a2, a2);
    ++*(_DWORD *)(a1 + 40);
    v11 = *(_QWORD *)(a1 + 16) + 24 * v12;
    return v11 + 16;
  }
  v10 = *(_QWORD *)(a1 + 16);
  while (*(_QWORD *)(v10 + 24 * v9 + 16) != v4)
  {
    LODWORD(v9) = *(_DWORD *)(v10 + 24 * v9 + 8) & 0x7FFFFFFF;
    if ((_DWORD)v9 == 0x7FFFFFFF)
      goto LABEL_8;
  }
  v11 = v10 + 24 * v9;
  return v11 + 16;
}

uint64_t *re::IntrospectionRegistry::remove(re::IntrospectionRegistry *this, const re::IntrospectionBase *a2)
{
  _anonymous_namespace_ *v3;
  int v4;
  int v5;
  uint64_t v6;
  int *v7;
  int v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int *v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  _OWORD *v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  int *v35;
  int v36;
  double v37;
  uint64_t *result;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  re::IntrospectionRegistry *v46;
  unint64_t v47;
  unint64_t v49;
  re::IntrospectionRegistry **v50;
  int v51;
  int v52;
  unint64_t v53;
  unint64_t v54;
  _QWORD *v55;
  void *__b[2];
  __int128 v57;
  unsigned int v58;
  unint64_t v59;
  uint64_t *v60;
  unint64_t v61;
  unint64_t v62;
  int v63;
  _QWORD *v64;
  char v65;

  globalIntrospectionTable();
  v64 = 0;
  v61 = 0;
  v62 = 0;
  v63 = 0;
  re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v60, 0);
  v4 = ++v63;
  v58 = 0;
  *(_OWORD *)__b = 0u;
  v57 = 0u;
  v59 = 0x7FFFFFFFLL;
  os_unfair_lock_lock((os_unfair_lock_t)&dword_25582A660);
  v5 = dword_25582A620;
  v6 = 0;
  if (dword_25582A620)
  {
    v7 = (int *)(qword_25582A610 + 8);
    while (1)
    {
      v8 = *v7;
      v7 += 14;
      if (v8 < 0)
        break;
      if (dword_25582A620 == ++v6)
      {
        LODWORD(v6) = dword_25582A620;
        break;
      }
    }
  }
  if (dword_25582A620 != (_DWORD)v6)
  {
    v39 = v6;
    v40 = qword_25582A610;
    do
    {
      if (HIDWORD(v57))
      {
        if (DWORD2(v57))
          memset_pattern16(__b[1], &memset_pattern_17, 4 * DWORD2(v57));
        if (v58)
        {
          v41 = 0;
          v42 = 24 * v58;
          do
          {
            v43 = *(_DWORD *)(v57 + v41 + 8);
            if (v43 < 0)
              *(_DWORD *)(v57 + v41 + 8) = v43 & 0x7FFFFFFF;
            v41 += 24;
          }
          while (v42 != v41);
        }
        HIDWORD(v57) = 0;
        v58 = 0;
        v59 = __PAIR64__(HIDWORD(v59), 0x7FFFFFFF) + 0x100000000;
      }
      v44 = v40 + 56 * v39;
      v45 = *(_QWORD *)(v44 + 48);
      v46 = this;
      if ((re::IntrospectionRegistry *)v45 != this)
      {
        v45 = re::IntrospectionBase::references(v45, (uint64_t)this, (uint64_t)__b);
        if (!(_DWORD)v45)
          goto LABEL_57;
        v46 = *(re::IntrospectionRegistry **)(v44 + 48);
      }
      v47 = v62 + 1;
      if (v62 >= v61 && v61 < v47)
      {
        if (v60)
        {
          v53 = 8;
          if (v61)
            v53 = 2 * v61;
          if (v53 <= v47)
            v54 = v62 + 1;
          else
            v54 = v53;
          re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v60, v54);
          v4 = v63;
        }
        else
        {
          re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v60, v47);
          v4 = v63 + 1;
        }
      }
      v49 = v62;
      v50 = (re::IntrospectionRegistry **)&v64[2 * v62];
      *v50 = v46;
      v50[1] = (re::IntrospectionRegistry *)(v44 + 16);
      v62 = v49 + 1;
      v63 = ++v4;
LABEL_57:
      v40 = qword_25582A610;
      if (dword_25582A620 <= (v6 + 1))
        v51 = v6 + 1;
      else
        v51 = dword_25582A620;
      while (1)
      {
        v39 = (v6 + 1);
        if (v51 - 1 == (_DWORD)v6)
          break;
        LODWORD(v6) = v6 + 1;
        v52 = v39;
        if ((*(_DWORD *)(qword_25582A610 + 56 * v39 + 8) & 0x80000000) != 0)
          goto LABEL_64;
      }
      v52 = v51;
LABEL_64:
      LODWORD(v6) = v52;
    }
    while (v5 != v52);
  }
  v55 = v64;
  if (v62)
  {
    v9 = v64;
    v10 = &v64[2 * v62];
    do
    {
      v11 = v9[1];
      v12 = re::Hash<re::DynamicString>::operator()((uint64_t)&v65, v11);
      if ((_QWORD)globalIntrospectionTable(void)::table)
      {
        v13 = v12 % dword_25582A618;
        v14 = *((_QWORD *)&globalIntrospectionTable(void)::table + 1);
        v15 = *(unsigned int *)(*((_QWORD *)&globalIntrospectionTable(void)::table + 1) + 4 * v13);
        if ((_DWORD)v15 != 0x7FFFFFFF)
        {
          v16 = qword_25582A610;
          if (re::DynamicString::operator==(qword_25582A610 + 56 * v15 + 16, v11))
          {
            *(_DWORD *)(v14 + 4 * v13) = *(_DWORD *)(v16 + 56 * v15 + 8) & 0x7FFFFFFF;
LABEL_16:
            v18 = qword_25582A610;
            v19 = qword_25582A610 + 56 * v15;
            v22 = *(_DWORD *)(v19 + 8);
            v21 = (int *)(v19 + 8);
            v20 = v22;
            if (v22 < 0)
            {
              *v21 = v20 & 0x7FFFFFFF;
              v23 = v18 + 56 * v15;
              v26 = *(_QWORD *)(v23 + 16);
              v25 = (_OWORD *)(v23 + 16);
              v24 = v26;
              if (v26)
              {
                if ((*(_BYTE *)(v18 + 56 * v15 + 24) & 1) != 0)
                  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v24 + 40))(v24, *(_QWORD *)(v18 + 56 * v15 + 32));
                *v25 = 0u;
                v25[1] = 0u;
              }
              v18 = qword_25582A610;
              v20 = *(_DWORD *)(qword_25582A610 + 56 * v15 + 8);
            }
            *(_DWORD *)(v18 + 56 * v15 + 8) = dword_25582A624 | v20 & 0x80000000;
            --dword_25582A61C;
            dword_25582A624 = v15;
            ++dword_25582A628;
          }
          else
          {
            while (1)
            {
              v17 = v15;
              v15 = *(_DWORD *)(v16 + 56 * v15 + 8) & 0x7FFFFFFF;
              if (v15 == 0x7FFFFFFF)
                break;
              if (re::DynamicString::operator==(v16 + 56 * v15 + 16, v11))
              {
                *(_DWORD *)(v16 + 56 * v17 + 8) = *(_DWORD *)(v16 + 56 * v17 + 8) & 0x80000000 | *(_DWORD *)(v16 + 56 * v15 + 8) & 0x7FFFFFFF;
                goto LABEL_16;
              }
            }
          }
        }
      }
      if (dword_25582A648)
      {
        v27 = *v9;
        v28 = 0xBF58476D1CE4E5B9 * (*v9 ^ ((unint64_t)*v9 >> 30));
        v29 = ((0x94D049BB133111EBLL * (v28 ^ (v28 >> 27))) ^ ((0x94D049BB133111EBLL * (v28 ^ (v28 >> 27))) >> 31))
            % dword_25582A648;
        v30 = *(unsigned int *)(qword_25582A638 + 4 * v29);
        if ((_DWORD)v30 != 0x7FFFFFFF)
        {
          if (*(_QWORD *)(qword_25582A640 + 24 * v30 + 16) == v27)
          {
            *(_DWORD *)(qword_25582A638 + 4 * v29) = *(_DWORD *)(qword_25582A640 + 24 * v30 + 8) & 0x7FFFFFFF;
LABEL_30:
            v32 = qword_25582A640;
            v33 = qword_25582A640 + 24 * v30;
            v36 = *(_DWORD *)(v33 + 8);
            v35 = (int *)(v33 + 8);
            v34 = v36;
            if (v36 < 0)
            {
              *v35 = v34 & 0x7FFFFFFF;
              v32 = qword_25582A640;
              v34 = *(_DWORD *)(qword_25582A640 + 24 * v30 + 8);
            }
            *(_DWORD *)(v32 + 24 * v30 + 8) = dword_25582A654 | v34 & 0x80000000;
            --dword_25582A64C;
            dword_25582A654 = v30;
            ++dword_25582A658;
          }
          else
          {
            while (1)
            {
              v31 = v30;
              v30 = *(_DWORD *)(qword_25582A640 + 24 * v30 + 8) & 0x7FFFFFFF;
              if (v30 == 0x7FFFFFFF)
                break;
              if (*(_QWORD *)(qword_25582A640 + 24 * v30 + 16) == v27)
              {
                *(_DWORD *)(qword_25582A640 + 24 * v31 + 8) = *(_DWORD *)(qword_25582A640 + 24 * v31 + 8) & 0x80000000 | *(_DWORD *)(qword_25582A640 + 24 * v30 + 8) & 0x7FFFFFFF;
                goto LABEL_30;
              }
            }
          }
        }
      }
      v9 += 2;
    }
    while (v9 != v10);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&dword_25582A660);
  v37 = re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)__b);
  result = v60;
  if (v60)
  {
    if (v55)
      return (uint64_t *)(*(uint64_t (**)(double))(*v60 + 40))(v37);
  }
  return result;
}

void re::HashSetBase<re::IntrospectionBase const*,re::IntrospectionBase const*,re::internal::ValueAsKey<re::IntrospectionBase const*>,re::Hash<re::IntrospectionBase const*>,re::EqualTo<re::IntrospectionBase const*>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 24 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &memset_pattern_17, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 600);
    _os_crash();
    __break(1u);
  }
}

_QWORD *re::IntrospectionRegistry::lookupType(re::IntrospectionRegistry *this, const char *a2)
{
  _anonymous_namespace_ *v3;
  _QWORD *v4;
  uint64_t v6;
  char v7;

  globalIntrospectionTable();
  os_unfair_lock_lock((os_unfair_lock_t)&dword_25582A660);
  v4 = (_QWORD *)re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)&globalIntrospectionTable(void)::table, (uint64_t)&v6);
  if (v6 && (v7 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v6 + 40))();
  if (v4)
    v4 = (_QWORD *)*v4;
  os_unfair_lock_unlock((os_unfair_lock_t)&dword_25582A660);
  return v4;
}

uint64_t re::IntrospectionRegistry::query(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  int *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t v15;
  uint64_t v16;

  v4 = a2[2];
  globalIntrospectionTable();
  os_unfair_lock_lock((os_unfair_lock_t)&dword_25582A660);
  v5 = dword_25582A620;
  v6 = 0;
  if (dword_25582A620)
  {
    v7 = (int *)(qword_25582A610 + 8);
    while (1)
    {
      v8 = *v7;
      v7 += 14;
      if (v8 < 0)
        break;
      if (dword_25582A620 == ++v6)
      {
        LODWORD(v6) = dword_25582A620;
        break;
      }
    }
  }
  if (dword_25582A620 != (_DWORD)v6)
  {
    v9 = v6;
    v10 = qword_25582A610;
    do
    {
      v15 = 0;
      v15 = *(_QWORD *)(v10 + 56 * v9 + 48);
      v16 = v15;
      if ((*(unsigned int (**)(_QWORD, uint64_t *))(**(_QWORD **)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), &v16))
      {
        re::DynamicArray<re::TransitionCondition *>::add(a2, &v15);
      }
      v10 = qword_25582A610;
      if (dword_25582A620 <= (v6 + 1))
        v11 = v6 + 1;
      else
        v11 = dword_25582A620;
      while (1)
      {
        v9 = (v6 + 1);
        if (v11 - 1 == (_DWORD)v6)
          break;
        LODWORD(v6) = v6 + 1;
        v12 = v9;
        if ((*(_DWORD *)(qword_25582A610 + 56 * v9 + 8) & 0x80000000) != 0)
          goto LABEL_17;
      }
      v12 = v11;
LABEL_17:
      LODWORD(v6) = v12;
    }
    while (v5 != v12);
  }
  v13 = a2[2] - v4;
  os_unfair_lock_unlock((os_unfair_lock_t)&dword_25582A660);
  return v13;
}

void `anonymous namespace'::IntrospectionRegistryTable::IntrospectionRegistryTable(_anonymous_namespace_::IntrospectionRegistryTable *this)
{
  uint64_t *v1;
  re *v2;
  uint64_t *v3;

  v1 = re::introspectionAllocator(this);
  globalIntrospectionTable(void)::table = 0u;
  *(_OWORD *)&qword_25582A610 = 0u;
  dword_25582A620 = 0;
  *(_QWORD *)&dword_25582A624 = 0x7FFFFFFFLL;
  re::HashTable<re::DynamicString,re::IntrospectionBase const*,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::init((uint64_t)&globalIntrospectionTable(void)::table, (uint64_t)v1, 3);
  v3 = re::introspectionAllocator(v2);
  unk_25582A630 = 0u;
  *(_OWORD *)&qword_25582A640 = 0u;
  dword_25582A650 = 0;
  *(_QWORD *)&dword_25582A654 = 0x7FFFFFFFLL;
  re::HashSetBase<re::IntrospectionBase const*,re::IntrospectionBase const*,re::internal::ValueAsKey<re::IntrospectionBase const*>,re::Hash<re::IntrospectionBase const*>,re::EqualTo<re::IntrospectionBase const*>,true,false>::init((uint64_t)&unk_25582A630, (uint64_t)v3, 3);
  dword_25582A660 = 0;
}

void re::HashTable<re::DynamicString,re::IntrospectionBase const*,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 56 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &memset_pattern_28, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

uint64_t re::HashTable<re::DynamicString,re::IntrospectionBase const*,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, re::DynamicString *a4, _QWORD *a5)
{
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;

  v10 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
    v10 = *(unsigned int *)(a1 + 32);
    v11 = v10;
    if ((_DWORD)v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::DynamicString,re::IntrospectionBase const*,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 56 * v10 + 8);
  }
  else
  {
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 56 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + 56 * v10 + 8) = v13 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 56 * v10 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 56 * v10 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 56 * v10) = a3;
  re::DynamicString::DynamicString((re::DynamicString *)(*(_QWORD *)(a1 + 16) + 56 * v10 + 16), a4);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 56 * v10 + 48) = *a5;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

void re::HashTable<re::DynamicString,re::IntrospectionBase const*,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  __int128 v7;
  __int128 v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  signed int v12;
  _BYTE v13[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(_QWORD *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::DynamicString,re::IntrospectionBase const*,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::init((uint64_t)v13, v4, a2);
      v5 = *(_OWORD *)v13;
      *(_OWORD *)v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      v6 = *(_QWORD *)&v13[16];
      *(_QWORD *)&v13[16] = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 16) = v6;
      v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      v7 = *(_OWORD *)&v13[24];
      *(_OWORD *)(a1 + 24) = v8;
      v9 = DWORD2(v7);
      if (DWORD2(v7))
      {
        v10 = 0;
        v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(_QWORD *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<re::DynamicString,re::IntrospectionBase const*,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove(a1, *(_QWORD *)(*(_QWORD *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(*(_QWORD *)&v13[16] + v10), (re::DynamicString *)(*(_QWORD *)&v13[16] + v10 + 16));
            v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 56;
        }
        while (v11 < v9);
      }
      re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v13, *(double *)&v7);
    }
  }
  else
  {
    if (a2)
      v12 = a2;
    else
      v12 = 3;
  }
}

uint64_t re::HashSetBase<re::IntrospectionBase const*,re::IntrospectionBase const*,re::internal::ValueAsKey<re::IntrospectionBase const*>,re::Hash<re::IntrospectionBase const*>,re::EqualTo<re::IntrospectionBase const*>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t a4, _QWORD *a5)
{
  uint64_t v8;
  int v9;
  uint64_t v10;
  int v11;

  v8 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v8 == 0x7FFFFFFF)
  {
    v8 = *(unsigned int *)(a1 + 32);
    v9 = v8;
    if ((_DWORD)v8 == *(_DWORD *)(a1 + 24))
    {
      re::HashSetBase<re::IntrospectionBase const*,re::IntrospectionBase const*,re::internal::ValueAsKey<re::IntrospectionBase const*>,re::Hash<re::IntrospectionBase const*>,re::EqualTo<re::IntrospectionBase const*>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v9 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v9 + 1;
    v10 = *(_QWORD *)(a1 + 16);
    v11 = *(_DWORD *)(v10 + 24 * v8 + 8);
  }
  else
  {
    v10 = *(_QWORD *)(a1 + 16);
    v11 = *(_DWORD *)(v10 + 24 * v8 + 8);
    *(_DWORD *)(a1 + 36) = v11 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v10 + 24 * v8 + 8) = v11 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v8 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v8 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v8) = a3;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v8 + 16) = *a5;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v8;
  ++*(_DWORD *)(a1 + 28);
  return v8;
}

void re::HashSetBase<re::IntrospectionBase const*,re::IntrospectionBase const*,re::internal::ValueAsKey<re::IntrospectionBase const*>,re::Hash<re::IntrospectionBase const*>,re::EqualTo<re::IntrospectionBase const*>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  unsigned int v7;
  __int128 v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  signed int v12;
  _BYTE v13[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(_QWORD *)&v13[36] = 0x7FFFFFFFLL;
      re::HashSetBase<re::IntrospectionBase const*,re::IntrospectionBase const*,re::internal::ValueAsKey<re::IntrospectionBase const*>,re::Hash<re::IntrospectionBase const*>,re::EqualTo<re::IntrospectionBase const*>,true,false>::init((uint64_t)v13, v4, a2);
      v5 = *(_OWORD *)v13;
      *(_OWORD *)v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      v6 = *(_QWORD *)&v13[16];
      *(_QWORD *)&v13[16] = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 16) = v6;
      v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      v9 = v7;
      if (v7)
      {
        v10 = 0;
        v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(_QWORD *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashSetBase<re::IntrospectionBase const*,re::IntrospectionBase const*,re::internal::ValueAsKey<re::IntrospectionBase const*>,re::Hash<re::IntrospectionBase const*>,re::EqualTo<re::IntrospectionBase const*>,true,false>::addAsMove(a1, *(_QWORD *)(*(_QWORD *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(*(_QWORD *)&v13[16] + v10), *(_QWORD *)&v13[16] + v10 + 16, *(_QWORD *)&v13[16] + v10 + 16);
            v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 24;
        }
        while (v11 < v9);
      }
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2)
      v12 = a2;
    else
      v12 = 3;
  }
}

BOOL re::IntrospectionBase::references(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  BOOL v11;
  uint64_t v13;

  v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
  if (v6)
  {
    v7 = v6;
    v8 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 40))(a1, 0);
    if (v8 == a2)
    {
      return 1;
    }
    else
    {
      v9 = v8;
      v10 = 1;
      v11 = 1;
      do
      {
        v13 = v9;
        if (!re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::contains(a3, &v13))
        {
          v13 = v9;
          re::HashSetBase<re::IntrospectionBase const*,re::IntrospectionBase const*,re::internal::ValueAsKey<re::IntrospectionBase const*>,re::Hash<re::IntrospectionBase const*>,re::EqualTo<re::IntrospectionBase const*>,true,false>::add(a3, &v13);
          if ((re::IntrospectionBase::references(v9, a2, a3) & 1) != 0)
            break;
        }
        v11 = v10 < v7;
        if (v7 == v10)
          break;
        v9 = (*(uint64_t (**)(uint64_t, unint64_t))(*(_QWORD *)a1 + 40))(a1, v10++);
      }
      while (v9 != a2);
    }
  }
  else
  {
    return 0;
  }
  return v11;
}

re::IntrospectionBasic *re::IntrospectionBasic::IntrospectionBasic(re::IntrospectionBasic *this, const char *a2, int a3, int a4, char a5, char a6)
{
  uint64_t v12;
  int v13;
  int v14;

  ArcSharedObject::ArcSharedObject(this, 0);
  *(_DWORD *)(v12 + 16) = 0;
  *(_DWORD *)(v12 + 20) = a3;
  *(_DWORD *)(v12 + 24) = a4;
  *(_BYTE *)(v12 + 28) = a5;
  *(_BYTE *)(v12 + 29) = a5 & a6;
  *(_QWORD *)(v12 + 32) = 0;
  *(_QWORD *)(v12 + 40) = 0xFFFFFFFFLL;
  *(_QWORD *)v12 = &off_24ED7D8E8;
  *(_QWORD *)(v12 + 48) = a2;
  *(_DWORD *)(v12 + 56) = 0;
  if (!strcmp(a2, "BOOL"))
  {
    v14 = 1;
    goto LABEL_26;
  }
  if (!strcmp(a2, "char"))
  {
    v14 = 2;
    goto LABEL_26;
  }
  if (!strcmp(a2, "short"))
  {
    v14 = 3;
    goto LABEL_26;
  }
  if (!strcmp(a2, "int"))
  {
    v14 = 4;
    goto LABEL_26;
  }
  if (!strcmp(a2, "int64_t"))
  {
    v14 = 5;
    goto LABEL_26;
  }
  if (!strcmp(a2, "uint8_t"))
  {
    v14 = 6;
    goto LABEL_26;
  }
  if (!strcmp(a2, "uint16_t"))
  {
    v14 = 7;
    goto LABEL_26;
  }
  if (!strcmp(a2, "uint32_t"))
  {
    v14 = 8;
    goto LABEL_26;
  }
  if (!strcmp(a2, "uint64_t"))
  {
    v14 = 9;
    goto LABEL_26;
  }
  if (!strcmp(a2, "float"))
  {
    v14 = 10;
    goto LABEL_26;
  }
  if (!strcmp(a2, "double"))
  {
    v14 = 11;
    goto LABEL_26;
  }
  v13 = a3 - 1;
  if ((a3 - 1) <= 7 && ((0x8Bu >> v13) & 1) != 0)
  {
    v14 = dword_226191D6C[v13];
LABEL_26:
    *((_DWORD *)this + 14) = v14;
  }
  return this;
}

void re::IntrospectionCStyleArray::IntrospectionCStyleArray(re::IntrospectionCStyleArray *this, const re::IntrospectionBase *a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v7;
  uint64_t v8;

  v4 = *((unsigned int *)a2 + 5);
  if ((v4 & 0x80000000) != 0)
  {
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Invalid array element size.", "elementSize >= 0", "checkedArraySize", 20);
    _os_crash();
    __break(1u);
    goto LABEL_6;
  }
  v3 = a3;
  if ((a3 & 0x80000000) != 0)
  {
LABEL_6:
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Invalid array element count.", "elementCount >= 0", "checkedArraySize", 21);
    _os_crash();
    __break(1u);
    goto LABEL_7;
  }
  v5 = (int)v4 * (uint64_t)(int)a3;
  if (v5 == (int)v5)
  {
    v7 = *((_DWORD *)a2 + 6);
    ArcSharedObject::ArcSharedObject(this, 0);
    *(_DWORD *)(v8 + 16) = 2;
    *(_DWORD *)(v8 + 20) = v5;
    *(_DWORD *)(v8 + 24) = v7;
    *(_WORD *)(v8 + 28) = 0;
    *(_QWORD *)(v8 + 32) = 0;
    *(_QWORD *)(v8 + 40) = 0xFFFFFFFFLL;
    *(_QWORD *)v8 = &off_24ED23640;
    *(_QWORD *)(v8 + 48) = a2;
    *(_QWORD *)(v8 + 56) = 0;
    *(_DWORD *)(v8 + 64) = v3;
    return;
  }
LABEL_7:
  re::internal::assertLog((re::internal *)6, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Size overflow in array. Element size = %d bytes, count = %d", "!overflow", "checkedArraySize", 27, v4, v3);
  _os_crash();
  __break(1u);
}

double re::IntrospectionDynamicString::IntrospectionDynamicString(re::IntrospectionDynamicString *this)
{
  uint64_t v1;
  double result;

  ArcSharedObject::ArcSharedObject(this, 0);
  *(_QWORD *)(v1 + 16) = 0x2000000006;
  *(_DWORD *)(v1 + 24) = 8;
  *(_WORD *)(v1 + 28) = 0;
  *(_QWORD *)(v1 + 32) = 0;
  *(_QWORD *)&result = 0xFFFFFFFFLL;
  *(_QWORD *)(v1 + 40) = 0xFFFFFFFFLL;
  *(_QWORD *)v1 = &off_24ED7D9A8;
  return result;
}

double re::IntrospectionPointer::IntrospectionPointer(re::IntrospectionPointer *this, const re::IntrospectionBase *a2)
{
  uint64_t v3;
  double result;

  ArcSharedObject::ArcSharedObject(this, 0);
  *(_QWORD *)(v3 + 16) = 0x800000001;
  *(_DWORD *)(v3 + 24) = 8;
  *(_WORD *)(v3 + 28) = 0;
  *(_QWORD *)(v3 + 32) = 0;
  *(_QWORD *)&result = 0xFFFFFFFFLL;
  *(_QWORD *)(v3 + 40) = 0xFFFFFFFFLL;
  *(_QWORD *)v3 = &off_24ED30800;
  *(_QWORD *)(v3 + 48) = a2;
  *(_QWORD *)(v3 + 56) = 0;
  return result;
}

double re::IntrospectionStringID::IntrospectionStringID(re::IntrospectionStringID *this)
{
  uint64_t v1;
  double result;

  ArcSharedObject::ArcSharedObject(this, 0);
  *(_DWORD *)(v1 + 24) = 8;
  *(_WORD *)(v1 + 28) = 0;
  *(_QWORD *)(v1 + 32) = 0;
  *(_QWORD *)(v1 + 40) = 0xFFFFFFFFLL;
  *(_QWORD *)v1 = &off_24ED7DA68;
  *(_QWORD *)&result = 0x100000000ALL;
  *(_QWORD *)(v1 + 16) = 0x100000000ALL;
  return result;
}

uint64_t re::IntrospectionStructure::childInfoCount(re::IntrospectionStructure *this)
{
  uint64_t v1;
  uint64_t result;
  _DWORD **v4;
  _DWORD *v5;

  v1 = *((unsigned int *)this + 14);
  if (!(_DWORD)v1)
    return 0;
  result = 0;
  v4 = (_DWORD **)*((_QWORD *)this + 8);
  do
  {
    v5 = *v4++;
    if (*v5 == 1)
      ++result;
    --v1;
  }
  while (v1);
  return result;
}

uint64_t re::IntrospectionStructure::childInfo(re::IntrospectionStructure *this, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  _DWORD *v5;

  v2 = *((unsigned int *)this + 14);
  if ((_DWORD)v2)
  {
    v3 = 0;
    v4 = (_QWORD *)*((_QWORD *)this + 8);
    do
    {
      v5 = (_DWORD *)*v4;
      if (*(_DWORD *)*v4 == 1)
      {
        if (v3 == a2)
          return *((_QWORD *)v5 + 2);
        ++v3;
      }
      ++v4;
      --v2;
    }
    while (v2);
  }
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Index out of range.", "!\"Unreachable code\"", "childInfo", 501);
  _os_crash();
  __break(1u);
  return *((_QWORD *)v5 + 2);
}

void *re::introspect_BOOL(re *this, const re::IntrospectionBase *a2)
{
  int v2;
  unsigned __int8 v3;
  char v4;
  re *v5;
  re *v6;
  BOOL v7;
  uint64_t v9[2];
  __int128 v10;

  v2 = (int)this;
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&re::introspect_BOOL(BOOL)::info, "BOOL", 1, 1, 1, 1);
  }
  if (v2)
  {
    if ((re::introspect_BOOL(BOOL)::isInitialized & 1) != 0)
      return &re::introspect_BOOL(BOOL)::info;
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v10);
    v4 = re::introspect_BOOL(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v10);
    if ((v4 & 1) != 0)
      return &re::introspect_BOOL(BOOL)::info;
    re::introspectionSharedMutex(v5);
    std::__shared_mutex_base::lock(&re::introspectionSharedMutex(void)::mutex);
    if ((re::introspect_BOOL(BOOL)::isInitialized & 1) != 0)
    {
LABEL_8:
      re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(&re::introspectionSharedMutex(void)::mutex);
      return &re::introspect_BOOL(BOOL)::info;
    }
  }
  re::introspect_BOOL(BOOL)::isInitialized = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&re::introspect_BOOL(BOOL)::info, a2);
  v9[0] = 6059476;
  v9[1] = (uint64_t)"BOOL";
  xmmword_25582A690 = v10;
  re::StringID::destroyString((re::StringID *)v9);
  if ((v2 & 1) == 0)
    goto LABEL_8;
  return &re::introspect_BOOL(BOOL)::info;
}

std::__shared_mutex_base *re::introspectionSharedMutex(re *this)
{
  unsigned __int8 v1;

  {
    std::__shared_mutex_base::__shared_mutex_base(&re::introspectionSharedMutex(void)::mutex);
  }
  return &re::introspectionSharedMutex(void)::mutex;
}

void re::TypeBuilderHelper::registerBasic<BOOL>(re::TypeRegistry *a1@<X0>, uint64_t *a2@<X1>, re::TypeRegistry **a3@<X8>)
{
  _anonymous_namespace_ *v6;
  re::TypeRegistry *v7;
  uint64_t v8;
  char v9[8];
  unint64_t v10;
  int v11;
  int v12;
  _OWORD v13[2];
  __int128 v14;
  uint64_t v15;
  int v16;
  char v17;

  v6 = (_anonymous_namespace_ *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a1 + 200, a2);
  if (a1 && v6)
  {
    v7 = *(re::TypeRegistry **)v6;
    *a3 = a1;
    a3[1] = v7;
  }
  else
  {
    v12 = -1;
    memset(v13, 0, sizeof(v13));
    v14 = 0u;
    v15 = 0xFFFFFFFFLL;
    v16 = 1;
    v17 = 0;
    v9[0] = 1;
    re::StringID::operator=(&v10, a2);
    v11 = 1;
    *(_OWORD *)((char *)v13 + 4) = 0x100000001uLL;
    *(_QWORD *)((char *)&v14 + 4) = 0;
    *(_QWORD *)((char *)&v13[1] + 4) = 0;
    v16 = 1;
    v17 = 1;
    re::TypeBuilder::commitTo((re::TypeBuilder *)v9, a1, a3);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v9, v8);
  }
}

void *re::introspect_char(re *this, const re::IntrospectionBase *a2)
{
  int v2;
  unsigned __int8 v3;
  char v4;
  re *v5;
  re *v6;
  BOOL v7;
  uint64_t v9[2];
  __int128 v10;

  v2 = (int)this;
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&re::introspect_char(BOOL)::info, "char", 1, 1, 1, 1);
  }
  if (v2)
  {
    if ((re::introspect_char(BOOL)::isInitialized & 1) != 0)
      return &re::introspect_char(BOOL)::info;
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v10);
    v4 = re::introspect_char(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v10);
    if ((v4 & 1) != 0)
      return &re::introspect_char(BOOL)::info;
    re::introspectionSharedMutex(v5);
    std::__shared_mutex_base::lock(&re::introspectionSharedMutex(void)::mutex);
    if ((re::introspect_char(BOOL)::isInitialized & 1) != 0)
    {
LABEL_8:
      re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(&re::introspectionSharedMutex(void)::mutex);
      return &re::introspect_char(BOOL)::info;
    }
  }
  re::introspect_char(BOOL)::isInitialized = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&re::introspect_char(BOOL)::info, a2);
  v9[0] = 6104748;
  v9[1] = (uint64_t)"char";
  xmmword_25582A6E0 = v10;
  re::StringID::destroyString((re::StringID *)v9);
  if ((v2 & 1) == 0)
    goto LABEL_8;
  return &re::introspect_char(BOOL)::info;
}

void *re::introspect_float(re *this, const re::IntrospectionBase *a2)
{
  int v2;
  unsigned __int8 v3;
  char v4;
  re *v5;
  re *v6;
  uint64_t v8[2];
  __int128 v9;

  v2 = (int)this;
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&re::introspect_float(BOOL)::info, "float", 4, 4, 1, 1);
  }
  if (v2)
  {
    if ((re::introspect_float(BOOL)::isInitialized & 1) != 0)
      return &re::introspect_float(BOOL)::info;
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v9);
    v4 = re::introspect_float(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v9);
    if ((v4 & 1) != 0)
      return &re::introspect_float(BOOL)::info;
    re::introspectionSharedMutex(v5);
    std::__shared_mutex_base::lock(&re::introspectionSharedMutex(void)::mutex);
    if ((re::introspect_float(BOOL)::isInitialized & 1) != 0)
    {
LABEL_8:
      re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(&re::introspectionSharedMutex(void)::mutex);
      return &re::introspect_float(BOOL)::info;
    }
  }
  re::introspect_float(BOOL)::isInitialized = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&re::introspect_float(BOOL)::info, a2);
  v8[0] = 195052728;
  v8[1] = (uint64_t)"float";
  xmmword_25582A730 = v9;
  re::StringID::destroyString((re::StringID *)v8);
  if ((v2 & 1) == 0)
    goto LABEL_8;
  return &re::introspect_float(BOOL)::info;
}

void re::TypeBuilderHelper::registerBasic<float>(re::TypeRegistry *a1@<X0>, uint64_t *a2@<X1>, re::TypeRegistry **a3@<X8>)
{
  _anonymous_namespace_ *v6;
  re::TypeRegistry *v7;
  uint64_t v8;
  char v9[8];
  unint64_t v10;
  int v11;
  int v12;
  _OWORD v13[2];
  __int128 v14;
  uint64_t v15;
  int v16;
  char v17;

  v6 = (_anonymous_namespace_ *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a1 + 200, a2);
  if (a1 && v6)
  {
    v7 = *(re::TypeRegistry **)v6;
    *a3 = a1;
    a3[1] = v7;
  }
  else
  {
    v12 = -1;
    memset(v13, 0, sizeof(v13));
    v14 = 0u;
    v15 = 0xFFFFFFFFLL;
    v16 = 1;
    v17 = 0;
    v9[0] = 1;
    re::StringID::operator=(&v10, a2);
    v11 = 1;
    *(_OWORD *)((char *)v13 + 4) = 0x400000004uLL;
    *(_QWORD *)((char *)&v14 + 4) = 0;
    *(_QWORD *)((char *)&v13[1] + 4) = 0;
    v16 = 1;
    v17 = 2;
    re::TypeBuilder::commitTo((re::TypeBuilder *)v9, a1, a3);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v9, v8);
  }
}

void *re::introspect_double(re *this, const re::IntrospectionBase *a2)
{
  int v2;
  unsigned __int8 v3;
  char v4;
  re *v5;
  re *v6;
  BOOL v7;
  uint64_t v9[2];
  __int128 v10;

  v2 = (int)this;
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&re::introspect_double(BOOL)::info, "double", 8, 8, 1, 1);
  }
  if (v2)
  {
    if ((re::introspect_double(BOOL)::isInitialized & 1) != 0)
      return &re::introspect_double(BOOL)::info;
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v10);
    v4 = re::introspect_double(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v10);
    if ((v4 & 1) != 0)
      return &re::introspect_double(BOOL)::info;
    re::introspectionSharedMutex(v5);
    std::__shared_mutex_base::lock(&re::introspectionSharedMutex(void)::mutex);
    if ((re::introspect_double(BOOL)::isInitialized & 1) != 0)
    {
LABEL_8:
      re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(&re::introspectionSharedMutex(void)::mutex);
      return &re::introspect_double(BOOL)::info;
    }
  }
  re::introspect_double(BOOL)::isInitialized = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&re::introspect_double(BOOL)::info, a2);
  v9[0] = 0x161EEF7A2;
  v9[1] = (uint64_t)"double";
  xmmword_25582A780 = v10;
  re::StringID::destroyString((re::StringID *)v9);
  if ((v2 & 1) == 0)
    goto LABEL_8;
  return &re::introspect_double(BOOL)::info;
}

void re::TypeBuilderHelper::registerBasic<double>(re::TypeRegistry *a1@<X0>, uint64_t *a2@<X1>, re::TypeRegistry **a3@<X8>)
{
  _anonymous_namespace_ *v6;
  re::TypeRegistry *v7;
  uint64_t v8;
  char v9[8];
  unint64_t v10;
  int v11;
  int v12;
  _OWORD v13[2];
  __int128 v14;
  uint64_t v15;
  int v16;
  char v17;

  v6 = (_anonymous_namespace_ *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a1 + 200, a2);
  if (a1 && v6)
  {
    v7 = *(re::TypeRegistry **)v6;
    *a3 = a1;
    a3[1] = v7;
  }
  else
  {
    v12 = -1;
    memset(v13, 0, sizeof(v13));
    v14 = 0u;
    v15 = 0xFFFFFFFFLL;
    v16 = 1;
    v17 = 0;
    v9[0] = 1;
    re::StringID::operator=(&v10, a2);
    v11 = 1;
    *(_OWORD *)((char *)v13 + 4) = 0x800000008uLL;
    *(_QWORD *)((char *)&v14 + 4) = 0;
    *(_QWORD *)((char *)&v13[1] + 4) = 0;
    v16 = 1;
    v17 = 2;
    re::TypeBuilder::commitTo((re::TypeBuilder *)v9, a1, a3);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v9, v8);
  }
}

void *re::introspect_short(re *this, const re::IntrospectionBase *a2)
{
  int v2;
  unsigned __int8 v3;
  char v4;
  re *v5;
  re *v6;
  BOOL v7;
  uint64_t v9[2];
  __int128 v10;

  v2 = (int)this;
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&re::introspect_short(BOOL)::info, "short", 2, 2, 1, 1);
  }
  if (v2)
  {
    if ((re::introspect_short(BOOL)::isInitialized & 1) != 0)
      return &re::introspect_short(BOOL)::info;
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v10);
    v4 = re::introspect_short(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v10);
    if ((v4 & 1) != 0)
      return &re::introspect_short(BOOL)::info;
    re::introspectionSharedMutex(v5);
    std::__shared_mutex_base::lock(&re::introspectionSharedMutex(void)::mutex);
    if ((re::introspect_short(BOOL)::isInitialized & 1) != 0)
    {
LABEL_8:
      re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(&re::introspectionSharedMutex(void)::mutex);
      return &re::introspect_short(BOOL)::info;
    }
  }
  re::introspect_short(BOOL)::isInitialized = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&re::introspect_short(BOOL)::info, a2);
  v9[0] = 218827000;
  v9[1] = (uint64_t)"short";
  xmmword_25582A7D0 = v10;
  re::StringID::destroyString((re::StringID *)v9);
  if ((v2 & 1) == 0)
    goto LABEL_8;
  return &re::introspect_short(BOOL)::info;
}

void re::TypeBuilderHelper::registerBasic<short>(re::TypeRegistry *a1@<X0>, uint64_t *a2@<X1>, re::TypeRegistry **a3@<X8>)
{
  _anonymous_namespace_ *v6;
  re::TypeRegistry *v7;
  uint64_t v8;
  char v9[8];
  unint64_t v10;
  int v11;
  int v12;
  _OWORD v13[2];
  __int128 v14;
  uint64_t v15;
  int v16;
  char v17;

  v6 = (_anonymous_namespace_ *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a1 + 200, a2);
  if (a1 && v6)
  {
    v7 = *(re::TypeRegistry **)v6;
    *a3 = a1;
    a3[1] = v7;
  }
  else
  {
    v12 = -1;
    memset(v13, 0, sizeof(v13));
    v14 = 0u;
    v15 = 0xFFFFFFFFLL;
    v16 = 1;
    v17 = 0;
    v9[0] = 1;
    re::StringID::operator=(&v10, a2);
    v11 = 1;
    *(_OWORD *)((char *)v13 + 4) = 0x200000002uLL;
    *(_QWORD *)((char *)&v14 + 4) = 0;
    *(_QWORD *)((char *)&v13[1] + 4) = 0;
    v16 = 1;
    v17 = 1;
    re::TypeBuilder::commitTo((re::TypeBuilder *)v9, a1, a3);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v9, v8);
  }
}

void *re::introspect_int(re *this, const re::IntrospectionBase *a2)
{
  int v2;
  unsigned __int8 v3;
  char v4;
  re *v5;
  re *v6;
  BOOL v7;
  uint64_t v9[2];
  __int128 v10;

  v2 = (int)this;
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&re::introspect_int(BOOL)::info, "int", 4, 4, 1, 1);
  }
  if (v2)
  {
    if ((re::introspect_int(BOOL)::isInitialized & 1) != 0)
      return &re::introspect_int(BOOL)::info;
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v10);
    v4 = re::introspect_int(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v10);
    if ((v4 & 1) != 0)
      return &re::introspect_int(BOOL)::info;
    re::introspectionSharedMutex(v5);
    std::__shared_mutex_base::lock(&re::introspectionSharedMutex(void)::mutex);
    if ((re::introspect_int(BOOL)::isInitialized & 1) != 0)
    {
LABEL_8:
      re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(&re::introspectionSharedMutex(void)::mutex);
      return &re::introspect_int(BOOL)::info;
    }
  }
  re::introspect_int(BOOL)::isInitialized = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&re::introspect_int(BOOL)::info, a2);
  v9[0] = 208862;
  v9[1] = (uint64_t)"int";
  xmmword_25582A820 = v10;
  re::StringID::destroyString((re::StringID *)v9);
  if ((v2 & 1) == 0)
    goto LABEL_8;
  return &re::introspect_int(BOOL)::info;
}

void re::TypeBuilderHelper::registerBasic<int>(re::TypeRegistry *a1@<X0>, uint64_t *a2@<X1>, re::TypeRegistry **a3@<X8>)
{
  _anonymous_namespace_ *v6;
  re::TypeRegistry *v7;
  uint64_t v8;
  char v9[8];
  unint64_t v10;
  int v11;
  int v12;
  _OWORD v13[2];
  __int128 v14;
  uint64_t v15;
  int v16;
  char v17;

  v6 = (_anonymous_namespace_ *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a1 + 200, a2);
  if (a1 && v6)
  {
    v7 = *(re::TypeRegistry **)v6;
    *a3 = a1;
    a3[1] = v7;
  }
  else
  {
    v12 = -1;
    memset(v13, 0, sizeof(v13));
    v14 = 0u;
    v15 = 0xFFFFFFFFLL;
    v16 = 1;
    v17 = 0;
    v9[0] = 1;
    re::StringID::operator=(&v10, a2);
    v11 = 1;
    *(_OWORD *)((char *)v13 + 4) = 0x400000004uLL;
    *(_QWORD *)((char *)&v14 + 4) = 0;
    *(_QWORD *)((char *)&v13[1] + 4) = 0;
    v16 = 1;
    v17 = 1;
    re::TypeBuilder::commitTo((re::TypeBuilder *)v9, a1, a3);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v9, v8);
  }
}

void *re::introspect_long(re *this, const re::IntrospectionBase *a2)
{
  int v2;
  unsigned __int8 v3;
  char v4;
  re *v5;
  re *v6;
  BOOL v7;
  uint64_t v9[2];
  __int128 v10;

  v2 = (int)this;
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&re::introspect_long(BOOL)::info, "long", 8, 8, 1, 1);
  }
  if (v2)
  {
    if ((re::introspect_long(BOOL)::isInitialized & 1) != 0)
      return &re::introspect_long(BOOL)::info;
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v10);
    v4 = re::introspect_long(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v10);
    if ((v4 & 1) != 0)
      return &re::introspect_long(BOOL)::info;
    re::introspectionSharedMutex(v5);
    std::__shared_mutex_base::lock(&re::introspectionSharedMutex(void)::mutex);
    if ((re::introspect_long(BOOL)::isInitialized & 1) != 0)
    {
LABEL_8:
      re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(&re::introspectionSharedMutex(void)::mutex);
      return &re::introspect_long(BOOL)::info;
    }
  }
  re::introspect_long(BOOL)::isInitialized = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&re::introspect_long(BOOL)::info, a2);
  v9[0] = 6655224;
  v9[1] = (uint64_t)"long";
  xmmword_25582A870 = v10;
  re::StringID::destroyString((re::StringID *)v9);
  if ((v2 & 1) == 0)
    goto LABEL_8;
  return &re::introspect_long(BOOL)::info;
}

void re::TypeBuilderHelper::registerBasic<long>(re::TypeRegistry *a1@<X0>, uint64_t *a2@<X1>, re::TypeRegistry **a3@<X8>)
{
  _anonymous_namespace_ *v6;
  re::TypeRegistry *v7;
  uint64_t v8;
  char v9[8];
  unint64_t v10;
  int v11;
  int v12;
  _OWORD v13[2];
  __int128 v14;
  uint64_t v15;
  int v16;
  char v17;

  v6 = (_anonymous_namespace_ *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a1 + 200, a2);
  if (a1 && v6)
  {
    v7 = *(re::TypeRegistry **)v6;
    *a3 = a1;
    a3[1] = v7;
  }
  else
  {
    v12 = -1;
    memset(v13, 0, sizeof(v13));
    v14 = 0u;
    v15 = 0xFFFFFFFFLL;
    v16 = 1;
    v17 = 0;
    v9[0] = 1;
    re::StringID::operator=(&v10, a2);
    v11 = 1;
    *(_OWORD *)((char *)v13 + 4) = 0x800000008uLL;
    *(_QWORD *)((char *)&v14 + 4) = 0;
    *(_QWORD *)((char *)&v13[1] + 4) = 0;
    v16 = 1;
    v17 = 1;
    re::TypeBuilder::commitTo((re::TypeBuilder *)v9, a1, a3);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v9, v8);
  }
}

void *re::introspect_size_t(re *this, const re::IntrospectionBase *a2)
{
  int v2;
  unsigned __int8 v3;
  char v4;
  re *v5;
  re *v6;
  BOOL v7;
  uint64_t v9[2];
  __int128 v10;

  v2 = (int)this;
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&re::introspect_size_t(BOOL)::info, "size_t", 8, 8, 1, 1);
  }
  if (v2)
  {
    if ((re::introspect_size_t(BOOL)::isInitialized & 1) != 0)
      return &re::introspect_size_t(BOOL)::info;
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v10);
    v4 = re::introspect_size_t(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v10);
    if ((v4 & 1) != 0)
      return &re::introspect_size_t(BOOL)::info;
    re::introspectionSharedMutex(v5);
    std::__shared_mutex_base::lock(&re::introspectionSharedMutex(void)::mutex);
    if ((re::introspect_size_t(BOOL)::isInitialized & 1) != 0)
    {
LABEL_8:
      re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(&re::introspectionSharedMutex(void)::mutex);
      return &re::introspect_size_t(BOOL)::info;
    }
  }
  re::introspect_size_t(BOOL)::isInitialized = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&re::introspect_size_t(BOOL)::info, a2);
  v9[0] = 0x1947BDF6CLL;
  v9[1] = (uint64_t)"size_t";
  xmmword_25582A8C0 = v10;
  re::StringID::destroyString((re::StringID *)v9);
  if ((v2 & 1) == 0)
    goto LABEL_8;
  return &re::introspect_size_t(BOOL)::info;
}

void *re::introspect_int64_t(re *this, const re::IntrospectionBase *a2)
{
  int v2;
  unsigned __int8 v3;
  char v4;
  re *v5;
  re *v6;
  BOOL v7;
  uint64_t v9[2];
  __int128 v10;

  v2 = (int)this;
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&re::introspect_int64_t(BOOL)::info, "int64_t", 8, 8, 1, 1);
  }
  if (v2)
  {
    if ((re::introspect_int64_t(BOOL)::isInitialized & 1) != 0)
      return &re::introspect_int64_t(BOOL)::info;
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v10);
    v4 = re::introspect_int64_t(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v10);
    if ((v4 & 1) != 0)
      return &re::introspect_int64_t(BOOL)::info;
    re::introspectionSharedMutex(v5);
    std::__shared_mutex_base::lock(&re::introspectionSharedMutex(void)::mutex);
    if ((re::introspect_int64_t(BOOL)::isInitialized & 1) != 0)
    {
LABEL_8:
      re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(&re::introspectionSharedMutex(void)::mutex);
      return &re::introspect_int64_t(BOOL)::info;
    }
  }
  re::introspect_int64_t(BOOL)::isInitialized = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&re::introspect_int64_t(BOOL)::info, a2);
  v9[0] = 0x2CE93EC744;
  v9[1] = (uint64_t)"int64_t";
  xmmword_25582A910 = v10;
  re::StringID::destroyString((re::StringID *)v9);
  if ((v2 & 1) == 0)
    goto LABEL_8;
  return &re::introspect_int64_t(BOOL)::info;
}

void *re::introspect_uint8_t(re *this, const re::IntrospectionBase *a2)
{
  int v2;
  unsigned __int8 v3;
  char v4;
  re *v5;
  re *v6;
  BOOL v7;
  uint64_t v9[2];
  __int128 v10;

  v2 = (int)this;
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&re::introspect_uint8_t(BOOL)::info, "uint8_t", 1, 1, 1, 1);
  }
  if (v2)
  {
    if ((re::introspect_uint8_t(BOOL)::isInitialized & 1) != 0)
      return &re::introspect_uint8_t(BOOL)::info;
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v10);
    v4 = re::introspect_uint8_t(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v10);
    if ((v4 & 1) != 0)
      return &re::introspect_uint8_t(BOOL)::info;
    re::introspectionSharedMutex(v5);
    std::__shared_mutex_base::lock(&re::introspectionSharedMutex(void)::mutex);
    if ((re::introspect_uint8_t(BOOL)::isInitialized & 1) != 0)
    {
LABEL_8:
      re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(&re::introspectionSharedMutex(void)::mutex);
      return &re::introspect_uint8_t(BOOL)::info;
    }
  }
  re::introspect_uint8_t(BOOL)::isInitialized = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&re::introspect_uint8_t(BOOL)::info, a2);
  v9[0] = 0x31CD534126;
  v9[1] = (uint64_t)"uint8_t";
  xmmword_25582A960 = v10;
  re::StringID::destroyString((re::StringID *)v9);
  if ((v2 & 1) == 0)
    goto LABEL_8;
  return &re::introspect_uint8_t(BOOL)::info;
}

void *re::introspect_uint16_t(re *this, const re::IntrospectionBase *a2)
{
  int v2;
  unsigned __int8 v3;
  char v4;
  re *v5;
  re *v6;
  BOOL v7;
  uint64_t v9[2];
  __int128 v10;

  v2 = (int)this;
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&re::introspect_uint16_t(BOOL)::info, "uint16_t", 2, 2, 1, 1);
  }
  if (v2)
  {
    if ((re::introspect_uint16_t(BOOL)::isInitialized & 1) != 0)
      return &re::introspect_uint16_t(BOOL)::info;
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v10);
    v4 = re::introspect_uint16_t(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v10);
    if ((v4 & 1) != 0)
      return &re::introspect_uint16_t(BOOL)::info;
    re::introspectionSharedMutex(v5);
    std::__shared_mutex_base::lock(&re::introspectionSharedMutex(void)::mutex);
    if ((re::introspect_uint16_t(BOOL)::isInitialized & 1) != 0)
    {
LABEL_8:
      re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(&re::introspectionSharedMutex(void)::mutex);
      return &re::introspect_uint16_t(BOOL)::info;
    }
  }
  re::introspect_uint16_t(BOOL)::isInitialized = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&re::introspect_uint16_t(BOOL)::info, a2);
  v9[0] = 0x607DD0D4E68;
  v9[1] = (uint64_t)"uint16_t";
  xmmword_25582A9B0 = v10;
  re::StringID::destroyString((re::StringID *)v9);
  if ((v2 & 1) == 0)
    goto LABEL_8;
  return &re::introspect_uint16_t(BOOL)::info;
}

void *re::introspect_uint32_t(re *this, const re::IntrospectionBase *a2)
{
  int v2;
  unsigned __int8 v3;
  char v4;
  re *v5;
  re *v6;
  BOOL v7;
  uint64_t v9[2];
  __int128 v10;

  v2 = (int)this;
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&re::introspect_uint32_t(BOOL)::info, "uint32_t", 4, 4, 1, 1);
  }
  if (v2)
  {
    if ((re::introspect_uint32_t(BOOL)::isInitialized & 1) != 0)
      return &re::introspect_uint32_t(BOOL)::info;
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v10);
    v4 = re::introspect_uint32_t(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v10);
    if ((v4 & 1) != 0)
      return &re::introspect_uint32_t(BOOL)::info;
    re::introspectionSharedMutex(v5);
    std::__shared_mutex_base::lock(&re::introspectionSharedMutex(void)::mutex);
    if ((re::introspect_uint32_t(BOOL)::isInitialized & 1) != 0)
    {
LABEL_8:
      re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(&re::introspectionSharedMutex(void)::mutex);
      return &re::introspect_uint32_t(BOOL)::info;
    }
  }
  re::introspect_uint32_t(BOOL)::isInitialized = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&re::introspect_uint32_t(BOOL)::info, a2);
  v9[0] = 0x607DD0F01DCLL;
  v9[1] = (uint64_t)"uint32_t";
  xmmword_25582AA00 = v10;
  re::StringID::destroyString((re::StringID *)v9);
  if ((v2 & 1) == 0)
    goto LABEL_8;
  return &re::introspect_uint32_t(BOOL)::info;
}

void *re::introspect_uint64_t(re *this, const re::IntrospectionBase *a2)
{
  int v2;
  unsigned __int8 v3;
  char v4;
  re *v5;
  re *v6;
  BOOL v7;
  uint64_t v9[2];
  __int128 v10;

  v2 = (int)this;
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&re::introspect_uint64_t(BOOL)::info, "uint64_t", 8, 8, 1, 1);
  }
  if (v2)
  {
    if ((re::introspect_uint64_t(BOOL)::isInitialized & 1) != 0)
      return &re::introspect_uint64_t(BOOL)::info;
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v10);
    v4 = re::introspect_uint64_t(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v10);
    if ((v4 & 1) != 0)
      return &re::introspect_uint64_t(BOOL)::info;
    re::introspectionSharedMutex(v5);
    std::__shared_mutex_base::lock(&re::introspectionSharedMutex(void)::mutex);
    if ((re::introspect_uint64_t(BOOL)::isInitialized & 1) != 0)
    {
LABEL_8:
      re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(&re::introspectionSharedMutex(void)::mutex);
      return &re::introspect_uint64_t(BOOL)::info;
    }
  }
  re::introspect_uint64_t(BOOL)::isInitialized = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&re::introspect_uint64_t(BOOL)::info, a2);
  v9[0] = 0x607DD11CB1ALL;
  v9[1] = (uint64_t)"uint64_t";
  xmmword_25582AA50 = v10;
  re::StringID::destroyString((re::StringID *)v9);
  if ((v2 & 1) == 0)
    goto LABEL_8;
  return &re::introspect_uint64_t(BOOL)::info;
}

void *re::appendPrettyTypeName(re *this, const re::IntrospectionBase *a2, re::DynamicString *a3)
{
  const char *v5;
  size_t v6;
  re::DynamicString *v7;
  const char *v8;
  const char *v10;
  re::DynamicString *v11;
  size_t v12;
  re::DynamicString *v13;
  re::DynamicString *v14;
  re *v15;

  switch(*((_DWORD *)this + 4))
  {
    case 0:
    case 8:
    case 9:
    case 0xB:
      v5 = (const char *)*((_QWORD *)this + 6);
      v6 = strlen(v5);
      v7 = a2;
      v8 = v5;
      return re::DynamicString::append(v7, v8, v6);
    case 1:
      re::appendPrettyTypeName(*((re **)this + 6), a2, a3);
      v8 = "*";
      goto LABEL_14;
    case 2:
      re::appendPrettyTypeName(*((re **)this + 6), a2, a3);
      return (void *)re::DynamicString::appendf(a2, "[%d]", *((_DWORD *)this + 16));
    case 3:
      v10 = "DynamicArray<";
      v11 = a2;
      v12 = 13;
      goto LABEL_12;
    case 4:
      v10 = "FixedArray<";
      v11 = a2;
      v12 = 11;
      goto LABEL_12;
    case 5:
      v10 = "DataArray<";
      v11 = a2;
      v12 = 10;
      goto LABEL_12;
    case 6:
      v8 = "DynamicString";
      v7 = a2;
      v6 = 13;
      return re::DynamicString::append(v7, v8, v6);
    case 7:
      re::DynamicString::append(a2, "HashTable<", 0xAuLL);
      re::appendPrettyTypeName(*((re **)this + 6), a2, v13);
      re::DynamicString::append(a2, ",", 1uLL);
      v15 = (re *)*((_QWORD *)this + 8);
      goto LABEL_13;
    case 0xA:
      v8 = "StringID";
      v7 = a2;
      v6 = 8;
      return re::DynamicString::append(v7, v8, v6);
    case 0xD:
      v10 = "Optional<";
      v11 = a2;
      v12 = 9;
LABEL_12:
      re::DynamicString::append(v11, v10, v12);
      v15 = (re *)*((_QWORD *)this + 6);
LABEL_13:
      re::appendPrettyTypeName(v15, a2, v14);
      v8 = ">";
LABEL_14:
      v7 = a2;
      v6 = 1;
      return re::DynamicString::append(v7, v8, v6);
    default:
      re::internal::assertLog((re::internal *)4, (uint64_t)a2, a3, "assertion failure: '%s' (%s:line %i) ", "!\"Unreachable code\"", "appendPrettyTypeName", 612);
      _os_crash();
      __break(1u);
      JUMPOUT(0x225B74A2CLL);
  }
}

void *re::getPrettyTypeName@<X0>(re *this@<X0>, const re::IntrospectionBase *a2@<X8>)
{
  re::DynamicString *v5;

  *((_QWORD *)a2 + 1) = 0;
  *((_QWORD *)a2 + 2) = 0;
  *((_QWORD *)a2 + 3) = 0;
  re::DynamicString::setCapacity(a2, 0);
  return re::appendPrettyTypeName(this, a2, v5);
}

const char **re::getIntrospectionPolymorphicTypeByName(unsigned int *a1, char *__s2)
{
  uint64_t v2;
  const char **i;

  v2 = *a1;
  if (!(_DWORD)v2)
    return 0;
  for (i = (const char **)*((_QWORD *)a1 + 1); strcmp(*i, __s2); i += 5)
  {
    if (!--v2)
      return 0;
  }
  return i;
}

uint64_t re::getIntrospectionPolymorphicTypeByPrettyType(_anonymous_namespace_ *a1, const char *a2)
{
  _anonymous_namespace_ *v3;
  uint64_t v4;
  unint64_t v5;
  re *v6;
  re::DynamicString *v7;
  uint64_t v8;
  const char *v9;
  int v10;
  uint64_t v11;
  __int128 v13;
  __int128 v14;

  if (!*(_DWORD *)a1)
    return 0;
  v3 = a1;
  v4 = 0;
  v5 = 0;
  while (1)
  {
    v6 = *(re **)(*((_QWORD *)v3 + 1) + v4 + 8);
    v13 = 0u;
    v14 = 0u;
    re::DynamicString::setCapacity(&v13, 0);
    re::appendPrettyTypeName(v6, (const re::IntrospectionBase *)&v13, v7);
    v8 = BYTE8(v13) & 1;
    v9 = (BYTE8(v13) & 1) != 0 ? (const char *)v14 : (char *)&v13 + 9;
    v10 = strcmp(v9, a2);
    v11 = *((_QWORD *)v3 + 1);
    a1 = (_anonymous_namespace_ *)v13;
    if ((_QWORD)v13)
    {
      if (v8)
        a1 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v13 + 40))();
    }
    if (!v10)
      break;
    ++v5;
    v4 += 40;
    if (v5 >= *(unsigned int *)v3)
      return 0;
  }
  return v11 + v4;
}

const char **re::getIntrospectionEnumValueByName(unsigned int *a1, char *__s2)
{
  uint64_t v2;
  const char ***i;
  const char **v5;

  v2 = *a1;
  if (!(_DWORD)v2)
    return 0;
  for (i = (const char ***)*((_QWORD *)a1 + 1); ; ++i)
  {
    v5 = *i;
    if (*(_DWORD *)*i == 1 && !strcmp(v5[2], __s2))
      break;
    if (!--v2)
      return 0;
  }
  return v5;
}

const char **re::getIntrospectionEnumValueRename(unsigned int *a1, char *__s2)
{
  uint64_t v2;
  const char ***i;
  const char **v5;

  v2 = *a1;
  if (!(_DWORD)v2)
    return 0;
  for (i = (const char ***)*((_QWORD *)a1 + 1); ; ++i)
  {
    v5 = *i;
    if (*(_DWORD *)*i == 2 && !strcmp(v5[2], __s2))
      break;
    if (!--v2)
      return 0;
  }
  return v5;
}

const char **re::getIntrospectionEnumValueWithVersioning@<X0>(unsigned int *a1@<X0>, char *a2@<X1>, uint64_t a3@<X8>)
{
  const char **result;

  result = re::getIntrospectionEnumValueRename(a1, a2);
  if (result || (result = re::getIntrospectionEnumValueByName(a1, a2)) != 0)
  {
    *(_BYTE *)a3 = 1;
    *(_QWORD *)(a3 + 8) = result[1];
  }
  else
  {
    *(_BYTE *)a3 = 0;
  }
  return result;
}

void *re::makePrettyMemberName@<X0>(re *this@<X0>, re::DynamicString *a2@<X8>)
{
  re *v3;
  size_t v5;
  size_t v6;
  int v7;

  v3 = this;
  *((_QWORD *)a2 + 1) = 0;
  *((_QWORD *)a2 + 2) = 0;
  *((_QWORD *)a2 + 3) = 0;
  re::DynamicString::setCapacity(a2, 0);
  v5 = strlen((const char *)v3);
  v6 = v5;
  if (v5 < 3)
  {
    if (v5 != 2)
      return re::DynamicString::append(a2, (const char *)v3, v6);
    v7 = *(unsigned __int8 *)v3;
  }
  else
  {
    v7 = *(unsigned __int8 *)v3;
    if (v7 == 109)
    {
      if (*((_BYTE *)v3 + 1) == 95)
      {
        v3 = (re *)((char *)v3 + 2);
LABEL_9:
        v6 = strlen((const char *)v3);
        return re::DynamicString::append(a2, (const char *)v3, v6);
      }
      return re::DynamicString::append(a2, (const char *)v3, v6);
    }
  }
  if (v7 == 95)
  {
    v3 = (re *)((char *)v3 + 1);
    goto LABEL_9;
  }
  return re::DynamicString::append(a2, (const char *)v3, v6);
}

BOOL re::introspectionPrettyNameCompare(const char *a1, const char *a2, size_t a3)
{
  const char *v5;
  size_t v6;
  int v7;
  size_t v8;
  int v9;
  BOOL v10;
  _BOOL8 result;

  v5 = a1;
  v6 = strlen(a1);
  v7 = *(unsigned __int8 *)v5;
  v8 = v6 - 2;
  if (v6 >= 2 && v7 == 109)
  {
    v9 = *((unsigned __int8 *)v5 + 1);
    v10 = v9 == 95;
    if (v9 == 95)
      v5 += 2;
  }
  else
  {
    v8 = v6 - 1;
    v10 = v7 == 95;
    if (v7 == 95)
      ++v5;
  }
  if (!v10)
    v8 = v6;
  result = 0;
  if (v8 && v8 == a3)
    return !strncmp(v5, a2, a3) || __toupper(*v5) == *a2 && !strncmp(v5 + 1, a2 + 1, a3 - 1);
  return result;
}

uint64_t re::getIntrospectionMemberByNameRecursive(re *this, const re::IntrospectionStructure *a2, const char *a3, int *a4)
{
  uint64_t v7;
  uint64_t v8;
  size_t v9;
  re *v10;
  uint64_t IntrospectionMemberByNameRecursive;
  size_t v12;
  int *v14;
  const re::IntrospectionStructure *v15;
  uint64_t v16;
  char v17;
  _BYTE v18[23];

  if (!*((_DWORD *)this + 14))
    return 0;
  v7 = 0;
  while (1)
  {
    v8 = *(_QWORD *)(*((_QWORD *)this + 8) + 8 * v7);
    if (*(_DWORD *)v8 != 1)
      break;
    if (*(_DWORD *)(v8 + 40) == 3)
    {
      v10 = *(re **)(v8 + 16);
      *(_DWORD *)a3 = 0;
      IntrospectionMemberByNameRecursive = re::getIntrospectionMemberByNameRecursive(v10, a2, a3, a4);
      if (IntrospectionMemberByNameRecursive)
      {
        *(_DWORD *)a3 += *(_DWORD *)(v8 + 36);
        return IntrospectionMemberByNameRecursive;
      }
    }
    else
    {
      v12 = strlen((const char *)a2);
      if (re::introspectionPrettyNameCompare(*(const char **)(v8 + 8), (const char *)a2, v12))
        return v8;
    }
LABEL_11:
    if (++v7 >= (unint64_t)*((unsigned int *)this + 14))
      return 0;
  }
  if (*(_DWORD *)v8 != 5)
    goto LABEL_11;
  v9 = strlen((const char *)a2);
  if (!re::introspectionPrettyNameCompare(*(const char **)(v8 + 8), (const char *)a2, v9))
    goto LABEL_11;
  re::makePrettyMemberName(*(re **)(v8 + 16), (re::DynamicString *)&v16);
  if ((v17 & 1) != 0)
    v15 = *(const re::IntrospectionStructure **)&v18[7];
  else
    v15 = (const re::IntrospectionStructure *)v18;
  *(_DWORD *)a3 = 0;
  v8 = re::getIntrospectionMemberByNameRecursive(this, v15, a3, v14);
  if (v16 && (v17 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v16 + 40))();
  return v8;
}

re::IntrospectionBase *re::introspectionAllocPointer(re *a1, _anonymous_namespace_ *a2, re::Allocator *a3)
{
  unsigned int v6;
  uint64_t v7;
  re::IntrospectionBase *v8;
  int v9;

  v6 = *((_DWORD *)a3 + 5);
  v7 = *((int *)a3 + 6);
  if (v6 <= 8)
    v6 = 8;
  v8 = (re::IntrospectionBase *)(*(uint64_t (**)(re *, _QWORD, uint64_t))(*(_QWORD *)a1 + 32))(a1, (int)v6, v7);
  re::introspectionCallConstructor(a2, (uint64_t)a3, (uint64_t)v8);
  re::introspectionInitElement(a1, v9, a3, v8);
  return v8;
}

void re::introspectionDestroyAllocatedMemory(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v8;
  uint64_t v9;
  void (*v10)(uint64_t *);
  void (*v11)(uint64_t, uint64_t, uint64_t *);

  switch(*(_DWORD *)(a4 + 16))
  {
    case 1:
      if (*a1)
        re::introspectionReleasePointer();
      break;
    case 2:
      if (*(int *)(a4 + 64) >= 1)
      {
        v8 = 0;
        do
          re::introspectionDestroyAllocatedMemory((char *)a1 + *(int *)(*(_QWORD *)(a4 + 48) + 20) * (uint64_t)v8++, a2, a3);
        while (v8 < *(_DWORD *)(a4 + 64));
      }
      break;
    case 3:
    case 4:
    case 5:
    case 7:
      (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)a4 + 56))(a4, a1);
      break;
    case 6:
      v9 = *a1;
      if (*a1)
      {
        if ((a1[1] & 1) != 0)
          (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v9 + 40))(v9, a1[2]);
        *(_OWORD *)a1 = 0u;
        *((_OWORD *)a1 + 1) = 0u;
      }
      break;
    case 8:
      v10 = *(void (**)(uint64_t *))(a4 + 96);
      if (v10)
      {
        v10(a1);
      }
      else
      {
        v11 = *(void (**)(uint64_t, uint64_t, uint64_t *))(a4 + 80);
        if (v11)
          v11(a4, a3, a1);
      }
      break;
    case 0xA:
      re::StringID::destroyString((re::StringID *)a1);
      break;
    default:
      return;
  }
}

void re::introspectionReleasePointer(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  re::introspectionDestroyAllocatedMemory(a1, a2, a3, a4);
  if (*(_DWORD *)(a4 + 16) != 8 || !*(_QWORD *)(a4 + 96))
    (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)a2 + 40))(a2, a1);
}

re *re::introspectionInitMember(re *this, re::Allocator *a2, const re::IntrospectionBase *a3, void *a4)
{
  re *v5;

  v5 = this;
  switch(*((_DWORD *)a2 + 4))
  {
    case 3:
    case 5:
      this = (re *)(*(uint64_t (**)(re::Allocator *, const re::IntrospectionBase *, re *))(*(_QWORD *)a2 + 64))(a2, a3, this);
      break;
    case 6:
      if (*(_QWORD *)a3)
      {
        if ((*((_BYTE *)a3 + 8) & 1) != 0)
          (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)a3 + 40))(*(_QWORD *)a3, *((_QWORD *)a3 + 2));
        *((_QWORD *)a3 + 1) = 0;
        *((_QWORD *)a3 + 2) = 0;
        *((_QWORD *)a3 + 3) = 0;
      }
      *(_QWORD *)a3 = v5;
      this = (re *)re::DynamicString::setCapacity(a3, 0);
      break;
    case 7:
      this = (re *)(*(uint64_t (**)(re::Allocator *, const re::IntrospectionBase *, re *, uint64_t))(*(_QWORD *)a2 + 64))(a2, a3, this, 3);
      break;
    case 8:
      this = re::introspectionInitStructure(this, a2, a3, a4);
      break;
    default:
      return this;
  }
  return this;
}

re *re::introspectionInitStructure(re *this, re::Allocator *a2, const re::IntrospectionStructure *a3, void *a4)
{
  unint64_t v4;
  re *v7;
  unint64_t i;
  uint64_t v9;

  v4 = *((unsigned int *)a2 + 14);
  if ((_DWORD)v4)
  {
    v7 = this;
    for (i = 0; i < v4; ++i)
    {
      v9 = *(_QWORD *)(*((_QWORD *)a2 + 8) + 8 * i);
      if (*(_DWORD *)v9 == 1)
      {
        this = (re *)re::introspectionInitMember(v7, *(re::Allocator **)(v9 + 16), (const re::IntrospectionStructure *)((char *)a3 + *(int *)(v9 + 36)), a4);
        v4 = *((unsigned int *)a2 + 14);
      }
    }
  }
  return this;
}

void re::introspectionCallConstructor(_anonymous_namespace_ *a1, uint64_t a2, uint64_t a3)
{
  int v6;
  void (*v7)(uint64_t, _anonymous_namespace_ *, uint64_t);

  switch(*(_DWORD *)(a2 + 16))
  {
    case 2:
      if (*(int *)(a2 + 64) >= 1)
      {
        v6 = 0;
        do
        {
          re::introspectionCallConstructor(a1);
          ++v6;
        }
        while (v6 < *(_DWORD *)(a2 + 64));
      }
      break;
    case 3:
    case 4:
    case 5:
    case 7:
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 48))(a2, a3);
      break;
    case 6:
      *(_OWORD *)a3 = 0u;
      *(_OWORD *)(a3 + 16) = 0u;
      re::DynamicString::setCapacity((_QWORD *)a3, 0);
      break;
    case 8:
      v7 = *(void (**)(uint64_t, _anonymous_namespace_ *, uint64_t))(a2 + 72);
      if (v7)
        goto LABEL_12;
      bzero((void *)a3, *(int *)(a2 + 20));
      break;
    case 0xA:
      *(_QWORD *)a3 = 0;
      *(_QWORD *)(a3 + 8) = &str_110;
      break;
    case 0xB:
      v7 = *(void (**)(uint64_t, _anonymous_namespace_ *, uint64_t))(a2 + 64);
      if (v7)
LABEL_12:
        v7(a2, a1, a3);
      break;
    default:
      return;
  }
}

re *re::introspectionInitElement(re *this, int a2, re::Allocator *a3, re::IntrospectionBase *a4)
{
  int v7;

  v7 = *((_DWORD *)a3 + 4);
  if (v7 == 2)
  {
    if (*(_DWORD *)(*((_QWORD *)a3 + 6) + 16) == 1)
      bzero(a4, *((int *)a3 + 5));
  }
  else if (v7 == 1)
  {
    *(_QWORD *)a4 = 0;
  }
  return re::introspectionInitMember(this, a3, a4, a4);
}

unint64_t re::introspectionFindStructureVersion(re *this, const re::IntrospectionStructure *a2)
{
  uint64_t v2;
  _QWORD *v3;
  unint64_t result;
  unint64_t v5;
  _DWORD *v6;
  unint64_t v7;

  v2 = *((unsigned int *)this + 14);
  if (!(_DWORD)v2)
    return 1;
  v3 = (_QWORD *)*((_QWORD *)this + 8);
  result = 1;
  v5 = 1;
  do
  {
    v6 = (_DWORD *)*v3;
    if (*(_DWORD *)*v3 == 6 && !*((_BYTE *)v6 + 40))
    {
      v7 = *((_QWORD *)v6 + 1);
      if (v7 > v5)
      {
        result = v7;
        v5 = v7;
      }
    }
    ++v3;
    --v2;
  }
  while (v2);
  return result;
}

re *re::introspectionFindForVersion(uint64_t **this, const re::IntrospectionStructure *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  unint64_t v6;
  _DWORD *v7;
  uint64_t v9;
  unint64_t v10;
  re *v11;

  v10 = 1;
  v11 = (re *)this;
  v9 = 0;
  v3 = *((unsigned int *)this + 14);
  if ((_DWORD)v3)
  {
    v4 = 0;
    v5 = this[8];
    v6 = 1;
    do
    {
      v7 = (_DWORD *)*v5;
      if (*(_DWORD *)*v5 == 6 && !*((_BYTE *)v7 + 40) && *((_QWORD *)v7 + 1) > v6)
      {
        v4 = *v5;
        v6 = *((_QWORD *)v7 + 1);
      }
      ++v5;
      --v3;
    }
    while (v3);
    v9 = v4;
    v10 = v6;
  }
  while ((const re::IntrospectionStructure *)v10 != a2)
  {
      return 0;
  }
  return v11;
}

BOOL `anonymous namespace'::findPreviousVersion(unint64_t a1, uint64_t a2, uint64_t *a3, unint64_t *a4, _QWORD *a5)
{
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;

  if (a1 != 1)
  {
    *a3 = *(_QWORD *)(a2 + 16);
    *a4 = 1;
    *a5 = 0;
    v5 = *a3;
    if (*(_DWORD *)(*a3 + 56))
    {
      v6 = 0;
      v7 = 1;
      do
      {
        v8 = *(_QWORD *)(*(_QWORD *)(v5 + 64) + 8 * v6);
        if (*(_DWORD *)v8 == 6 && !*(_BYTE *)(v8 + 40))
        {
          v9 = *(_QWORD *)(v8 + 8);
          if (v9 < a1 && v9 > v7)
          {
            *a4 = v9;
            *a5 = v8;
            v5 = *a3;
            v7 = v9;
          }
        }
        ++v6;
      }
      while (v6 < *(unsigned int *)(v5 + 56));
    }
  }
  return a1 != 1;
}

uint64_t re::introspectionRunComplexVersion(re *a1, _anonymous_namespace_ *a2, uint64_t a3, unint64_t a4, uint64_t *a5, uint64_t a6, unint64_t a7, re::IntrospectionBase *a8)
{
  uint64_t v13;
  _DWORD **v14;
  _DWORD *v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  re::Allocator *v19;
  void (*v20)(_anonymous_namespace_ *, uint64_t *, re::IntrospectionBase *);
  re::IntrospectionBase *v21;
  uint64_t v26;
  unint64_t v27;
  re::Allocator *v28;

  v13 = *(unsigned int *)(a6 + 56);
  if ((_DWORD)v13)
  {
    v14 = *(_DWORD ***)(a6 + 64);
    do
    {
      v15 = *v14;
      if (**v14 == 6 && !*((_BYTE *)v15 + 40) && *((_QWORD *)v15 + 1) == a7)
        goto LABEL_8;
      ++v14;
      --v13;
    }
    while (v13);
  }
  v15 = 0;
LABEL_8:
  while (1)
  {
    v27 = 0;
    v28 = 0;
    v26 = 0;
      break;
    v16 = v27;
    v17 = (uint64_t)v15;
    v18 = a7;
    v19 = (re::Allocator *)a6;
    while (v16 != a4)
    {
      v18 = v16;
      v19 = v28;
      v17 = v26;
      v27 = 0;
      v28 = 0;
      v26 = 0;
        goto LABEL_18;
      v16 = v27;
    }
    v20 = *(void (**)(_anonymous_namespace_ *, uint64_t *, re::IntrospectionBase *))(v17 + 32);
    if (!v20)
      break;
    v21 = a8;
    if (v18 != a7)
    {
      v21 = re::introspectionAllocPointer(a1, a2, v19);
      v20 = *(void (**)(_anonymous_namespace_ *, uint64_t *, re::IntrospectionBase *))(v17 + 32);
    }
    v20(a2, a5, v21);
    re::introspectionReleasePointer(a5, (uint64_t)a1, (uint64_t)a2, a3);
    a3 = (uint64_t)v19;
    a4 = v18;
    a5 = (uint64_t *)v21;
    if (v18 >= a7)
      return 1;
  }
LABEL_18:
  re::introspectionReleasePointer(a5, (uint64_t)a1, (uint64_t)a2, a3);
  return 0;
}

void re::getDowngradeFunctions(uint64_t a1@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  unint64_t v4;
  unint64_t i;
  uint64_t v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t *v11;
  BOOL v12;
  __int128 v13;
  uint64_t *v14;
  _QWORD *v15[2];

  *(_QWORD *)(a3 + 32) = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  *(_QWORD *)a3 = 0;
  *(_DWORD *)(a3 + 24) = 0;
  v15[0] = 0;
  v15[1] = 0;
  v14 = (uint64_t *)v15;
  v4 = *(unsigned int *)(a1 + 56);
  if ((_DWORD)v4)
  {
    for (i = 0; i < v4; ++i)
    {
      v8 = *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * i);
      if (*(_DWORD *)v8 == 6 && *(_BYTE *)(v8 + 40) && *(_DWORD *)(v8 + 56) >= a2)
      {
        LODWORD(v13) = *(_DWORD *)(v8 + 56);
        *((_QWORD *)&v13 + 1) = *(_QWORD *)(v8 + 48);
        std::__tree<std::__value_type<re::DowngradeCode,re::Result<re::Unit,re::DynamicString> (*)(void *,void *)>,std::__map_value_compare<re::DowngradeCode,std::__value_type<re::DowngradeCode,re::Result<re::Unit,re::DynamicString> (*)(void *,void *)>,std::greater<re::DowngradeCode>,true>,std::allocator<std::__value_type<re::DowngradeCode,re::Result<re::Unit,re::DynamicString> (*)(void *,void *)>>>::__emplace_multi<std::pair<re::DowngradeCode const,re::Result<re::Unit,re::DynamicString> (*)(void *,void *)>>(&v14, &v13);
        v4 = *(unsigned int *)(a1 + 56);
      }
    }
    v9 = v14;
    if (v14 != (uint64_t *)v15)
    {
      do
      {
        re::DynamicArray<re::TransitionCondition *>::add((_QWORD *)a3, v9 + 5);
        v10 = (uint64_t *)v9[1];
        if (v10)
        {
          do
          {
            v11 = v10;
            v10 = (uint64_t *)*v10;
          }
          while (v10);
        }
        else
        {
          do
          {
            v11 = (uint64_t *)v9[2];
            v12 = *v11 == (_QWORD)v9;
            v9 = v11;
          }
          while (!v12);
        }
        v9 = v11;
      }
      while (v11 != (uint64_t *)v15);
    }
  }
  std::__tree<unsigned long long>::destroy((uint64_t)&v14, v15[0]);
}

_DWORD *re::introspectionFirstStructureMember(re *this, const re::IntrospectionStructure *a2)
{
  uint64_t v2;
  uint64_t *v3;
  _DWORD *result;

  v2 = *((unsigned int *)this + 14);
  if ((_DWORD)v2)
  {
    v3 = (uint64_t *)*((_QWORD *)this + 8);
    while (1)
    {
      result = (_DWORD *)*v3;
      if (*(_DWORD *)*v3 == 1 && result[10] != 3)
        break;
      ++v3;
      if (!--v2)
        goto LABEL_6;
    }
  }
  else
  {
LABEL_6:
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) No member found in type info.", "!\"Unreachable code\"", "introspectionFirstStructureMember", 1237);
    result = (_DWORD *)_os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::PolymorphicData::makeWithPointer@<X0>(uint64_t this@<X0>, const re::IntrospectionBase *a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  _DWORD *v8;
  _DWORD *v9;
  uint64_t v10;
  BOOL v11;
  uint64_t v12;

  if (*(_DWORD *)(this + 16) != 8)
    goto LABEL_19;
  v4 = *(unsigned int *)(this + 56);
  if (!(_DWORD)v4)
    goto LABEL_19;
  v5 = *(_QWORD **)(this + 64);
  v6 = *(unsigned int *)(this + 56);
  v7 = v5;
  do
  {
    v8 = (_DWORD *)*v7;
    if (*(_DWORD *)*v7 == 2)
      goto LABEL_7;
    ++v7;
    --v6;
  }
  while (v6);
  v8 = 0;
LABEL_7:
  while (1)
  {
    v9 = (_DWORD *)*v5;
    if (*(_DWORD *)*v5 == 3)
      break;
    ++v5;
    if (!--v4)
    {
      v9 = 0;
      break;
    }
  }
  if (v8 && ((v10 = *((_QWORD *)v8 + 1), v9) ? (v11 = v10 == 0) : (v11 = 1), !v11 && (v12 = *((_QWORD *)v9 + 1)) != 0))
  {
    *a3 = 0;
    if (a2)
      *a3 = (char *)a2 + (int)v9[6];
    a3[1] = v12;
    a3[2] = v10;
  }
  else
  {
LABEL_19:
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
  }
  return this;
}

uint64_t *re::introspectionAllocator(re *this)
{
  unsigned __int8 v1;
  unsigned __int8 v2;

  {
    byte_25582AA90 = 0;
    re::introspectionAllocator(void)::baseAllocator = (uint64_t)&off_24ED42648;
    *(_QWORD *)algn_25582AA88 = "Introspection allocator";
  }
  {
    byte_25582AAB0 = 0;
    re::introspectionAllocator(void)::autoFreeAllocator = (uint64_t)&off_24ED42590;
    *(_QWORD *)algn_25582AAA8 = "Introspection allocator";
    qword_25582AAB8 = (uint64_t)&re::introspectionAllocator(void)::baseAllocator;
    *(_QWORD *)algn_25582AAE4 = 0x7FFFFFFFLL;
    xmmword_25582AAD0 = 0u;
    dword_25582AAE0 = 0;
    dword_25582AAF0 = 0;
    xmmword_25582AAC0 = 0u;
    re::HashSetBase<void *,void *,re::internal::ValueAsKey<void *>,re::Hash<void *>,re::EqualTo<void *>,true,false>::init((uint64_t)&xmmword_25582AAC0, (uint64_t)&re::introspectionAllocator(void)::baseAllocator, 3);
  }
  return &re::introspectionAllocator(void)::autoFreeAllocator;
}

_QWORD *re::CustomPolymorphicTable::addType(re::CustomPolymorphicTable *this, const char *__s, const re::IntrospectionBase *a3, uint64_t a4, int a5)
{
  re *v10;
  size_t v11;
  uint64_t *v12;
  void *v13;
  _QWORD *result;
  _OWORD *v15;
  uint64_t v16;
  void *v17;
  const re::IntrospectionBase *v18;
  _QWORD *v19;
  uint64_t v20;
  int v21;

  v10 = (re *)strlen(__s);
  v11 = (size_t)v10 + 1;
  v12 = re::globalAllocators(v10);
  v13 = (void *)(*(uint64_t (**)(uint64_t, size_t, _QWORD))(*(_QWORD *)v12[2] + 32))(v12[2], v11, 0);
  memcpy(v13, __s, v11);
  v17 = v13;
  v18 = a3;
  v19 = 0;
  v20 = a4;
  v21 = a5;
  result = re::DynamicArray<re::IntrospectionPolymorphicType>::add(this, (uint64_t)&v17);
  v18 = 0;
  v15 = v19;
  if (v19)
  {
    v16 = *v19;
    if (*v19)
    {
      if ((v19[1] & 1) != 0)
        (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)v16 + 40))(*v19, v19[2]);
      *v15 = 0u;
      v15[1] = 0u;
    }
    result = (_QWORD *)(*(uint64_t (**)(uint64_t, _OWORD *))(*(_QWORD *)v16 + 40))(v16, v15);
  }
  *((_DWORD *)this + 10) = *((_QWORD *)this + 2);
  *((_QWORD *)this + 6) = *((_QWORD *)this + 4);
  return result;
}

_QWORD *re::DynamicArray<re::IntrospectionPolymorphicType>::add(_QWORD *this, uint64_t a2)
{
  _QWORD *v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v3 = this;
  v4 = this[2];
  if (v4 >= this[1])
  {
    this = re::DynamicArray<re::IntrospectionPolymorphicType>::growCapacity(this, v4 + 1);
    v4 = v3[2];
  }
  v5 = v3[4] + 40 * v4;
  *(_QWORD *)v5 = *(_QWORD *)a2;
  *(_QWORD *)(v5 + 16) = 0;
  *(_QWORD *)(v5 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = 0;
  v6 = *(_QWORD *)(v5 + 8);
  *(_QWORD *)(v5 + 8) = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a2 + 8) = v6;
  v7 = *(_QWORD *)(a2 + 24);
  *(_DWORD *)(v5 + 32) = *(_DWORD *)(a2 + 32);
  *(_QWORD *)(v5 + 24) = v7;
  ++v3[2];
  ++*((_DWORD *)v3 + 6);
  return this;
}

re *re::CustomPolymorphicTable::removeType(re *this, const re::IntrospectionBase *a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  const re::IntrospectionBase **i;
  uint64_t v6;
  uint64_t *v7;

  v2 = *((_QWORD *)this + 2);
  if (v2)
  {
    v3 = (uint64_t)this;
    v4 = 0;
    for (i = (const re::IntrospectionBase **)(*((_QWORD *)this + 4) + 8); *i != a2; i += 5)
    {
      if (v2 == ++v4)
        return this;
    }
    v6 = (uint64_t)*(i - 1);
    if (v6)
    {
      v7 = re::globalAllocators(this);
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v7[2] + 40))(v7[2], v6);
    }
    this = (re *)re::DynamicArray<re::IntrospectionPolymorphicType>::removeStableAt(v3, v4);
    *(_DWORD *)(v3 + 40) = *(_QWORD *)(v3 + 16);
    *(_QWORD *)(v3 + 48) = *(_QWORD *)(v3 + 32);
  }
  return this;
}

_QWORD *re::DynamicArray<re::IntrospectionPolymorphicType>::removeStableAt(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *result;

  v2 = *(_QWORD *)(a1 + 16);
  if (v2 <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (v2 - 1 > a2)
  {
    v4 = *(_QWORD *)(a1 + 32);
    v5 = v4 + 40 * a2 + 40;
    if (v5 != v4 + 40 * v2)
    {
      v6 = -40 * a2 + 40 * v2 - 40;
      do
      {
        v7 = *(_QWORD *)(v5 - 32);
        v8 = *(_QWORD *)(v5 - 24);
        *(_OWORD *)(v5 - 40) = *(_OWORD *)v5;
        v9 = *(_QWORD *)(v5 + 16);
        v10 = *(_QWORD *)(v5 + 24);
        *(_QWORD *)(v5 + 8) = v7;
        *(_QWORD *)(v5 + 16) = v8;
        *(_QWORD *)(v5 - 24) = v9;
        *(_QWORD *)(v5 - 16) = v10;
        *(_DWORD *)(v5 - 8) = *(_DWORD *)(v5 + 32);
        v5 += 40;
        v6 -= 40;
      }
      while (v6);
      v2 = *(_QWORD *)(a1 + 16);
    }
  }
  result = re::SerializedReference<re::IntrospectionBase const*>::reset((_QWORD *)(*(_QWORD *)(a1 + 32) + 40 * v2 - 32));
  --*(_QWORD *)(a1 + 16);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

_QWORD *re::CustomPolymorphicTable::clear(_QWORD *this)
{
  _QWORD *v1;
  unint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  _QWORD *v9;

  v1 = this;
  *(_QWORD *)(this[7] + 8) = 0;
  this[6] = 0;
  *((_DWORD *)this + 10) = 0;
  v2 = this[2];
  if (v2)
  {
    v3 = 0;
    v4 = 0;
    v5 = this[4];
    do
    {
      v6 = *(_QWORD *)(v5 + v3);
      if (v6)
      {
        v7 = re::globalAllocators((re *)this);
        this = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v7[2] + 40))(v7[2], v6);
        v2 = v1[2];
      }
      if (v2 <= v4)
      {
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      v5 = v1[4];
      *(_QWORD *)(v5 + v3) = 0;
      ++v4;
      v3 += 40;
    }
    while (v2 > v4);
    v1[2] = 0;
    v8 = 40 * v2;
    v9 = (_QWORD *)(v5 + 8);
    do
    {
      this = re::SerializedReference<re::IntrospectionBase const*>::reset(v9);
      v9 += 5;
      v8 -= 40;
    }
    while (v8);
  }
  else
  {
    this[2] = 0;
  }
  ++*((_DWORD *)v1 + 6);
  v1[7] = 0;
  return this;
}

uint64_t re::internal::getOrCreateInfo(re::internal *this, uint64_t (*a2)(re::internal *), re::IntrospectionBase *(*a3)(void), void (*a4)(re::IntrospectionBase *), re::IntrospectionBase **a5)
{
  char v5;
  uint64_t v9;
  re *v10;
  char v12;

  v5 = (char)a5;
  if ((_DWORD)a5)
  {
    v9 = *(_QWORD *)a4;
    if (*(_QWORD *)a4)
      return v9;
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v12);
    v9 = *(_QWORD *)a4;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v12);
    if (v9)
      return v9;
    re::introspectionSharedMutex(v10);
    std::__shared_mutex_base::lock(&re::introspectionSharedMutex(void)::mutex);
    v9 = *(_QWORD *)a4;
    if (*(_QWORD *)a4)
    {
LABEL_7:
      re::introspectionSharedMutex(this);
      std::__shared_mutex_base::unlock(&re::introspectionSharedMutex(void)::mutex);
      return v9;
    }
  }
  v9 = a2(this);
  *(_QWORD *)a4 = v9;
  this = a3();
  if ((v5 & 1) == 0)
    goto LABEL_7;
  return v9;
}

double re::internal::declareType@<D0>(re::StringID *a1@<X2>, re::TypeRegistry *a2@<X0>, int a3@<W1>, unsigned int a4@<W3>, _QWORD *a5@<X8>)
{
  uint64_t v10;
  double result;
  __int128 v12;

  re::TypeRegistry::typeID(a2, a1, a4, a5);
  if (*a5)
  {
    if (*(unsigned __int8 *)(re::DataArray<re::internal::TypeInfoIndex>::tryGet((uint64_t)a2 + 32, a5[1]) + 3) == a3)
      return result;
    re::internal::assertLog((re::internal *)5, v10, "assertion failure: '%s' (%s:line %i) Type %s has already been declared with different type category.", "registry->typeCategory(typeID) == typeCategory", "declareType", 1483, *((_QWORD *)a1 + 1));
    _os_crash();
    __break(1u);
  }
  re::TypeRegistry::declareType((uint64_t)a2, a3, (StringID *)a1, a4, 0, &v12);
  result = *(double *)&v12;
  *(_OWORD *)a5 = v12;
  return result;
}

void re::internal::registerCallbackSerializerType(re::internal *this@<X0>, re::TypeRegistry *a2@<X1>, const re::IntrospectionBase *a3@<X2>, const re::StringID *a4@<X3>, void (*a5)(void *, const re::TypeInfo *, re::Allocator *, void *)@<X4>, _QWORD *a6@<X8>)
{
  uint64_t *v13;
  uint64_t v14;
  re::internal *v15;
  _anonymous_namespace_ *v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  _QWORD v20[2];
  _QWORD v21[2];
  _QWORD v22[61];

  v22[0] = 0x258C98EAAF29A10ALL;
  v22[1] = "CallbackSerializerAttribute";
  v13 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)this + 200, v22);
  if (v13)
  {
    v14 = *v13;
    v15 = this;
  }
  else
  {
    v15 = 0;
    v14 = 0xFFFFFFFFLL;
  }
  re::StringID::destroyString((re::StringID *)v22);
  v16 = (_anonymous_namespace_ *)(*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**((_QWORD **)this + 2) + 32))(*((_QWORD *)this + 2), 8, 8);
  *(_QWORD *)v16 = a2;
  v17 = *((int *)a2 + 5);
  v18 = *((int *)a2 + 6);
  v21[0] = 0;
  v21[1] = 0xFFFFFFFFLL;
  re::TypeBuilder::beginObjectType((uint64_t)v22, (uint64_t *)a3, 1, 1, v17, v18, (uint64_t)v21);
  re::TypeBuilder::setConstructor((uint64_t)v22, (uint64_t)a4);
  re::TypeBuilder::setDestructor((uint64_t)v22, (uint64_t)a5);
  re::TypeBuilder::setIsCallbackSerializer((uint64_t)v22, 1);
  v20[0] = v15;
  v20[1] = v14;
  re::TypeBuilder::addAttribute(v22, (uint64_t)v20, (uint64_t)v16, -1, 1);
  re::TypeBuilder::commitTo((re::TypeBuilder *)v22, this, a6);
  re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v22, v19);
}

void re::internal::registerStructureType(re *a1, uint64_t a2, unint64_t a3, unsigned int a4)
{
  StringID *v7;
  int var0;
  unsigned int *v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  _DWORD *v14;
  int v15;
  uint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  _DWORD *v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  char v32;
  unsigned __int8 *v33;
  int v34;
  const re::IntrospectionStructure *v35;
  unsigned int StructureVersion;
  char *v37;
  uint64_t v38;
  char v39;
  unsigned __int8 *v40;
  int v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  char *v49;
  uint64_t v50;
  char v51;
  unsigned __int8 *v52;
  int v53;
  char *var1;
  char *v55;
  const char *v56;
  uint64_t v57;
  char *v58;
  uint64_t v59;
  char v60;
  unsigned __int8 *v61;
  int v62;
  uint64_t v63;
  char *v64;
  char *v65;
  const char *v66;
  uint64_t v67;
  char *v68;
  uint64_t v69;
  char v70;
  unsigned __int8 *v71;
  int v72;
  re::StringID *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  char *v77;
  uint64_t v78;
  char v79;
  unsigned __int8 *v80;
  int v81;
  char *v82;
  uint64_t v83;
  char v84;
  unsigned __int8 *v85;
  int v86;
  uint64_t v87;
  BOOL v88;
  _DWORD *v89;
  uint64_t *v90;
  uint64_t v91;
  re *v92;
  _QWORD *v93;
  uint64_t v94;
  __int128 *v95;
  unint64_t v96;
  unint64_t v97;
  unint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  _QWORD *v102;
  uint64_t v103;
  unint64_t v104;
  char *v105;
  char *v106;
  _QWORD *v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  _QWORD *v112;
  _DWORD *v113;
  uint64_t v114;
  unint64_t v115;
  uint64_t v116;
  _QWORD *v117;
  _QWORD *v118;
  unint64_t v119;
  _QWORD *v120;
  _QWORD *v121;
  uint64_t v122;
  uint64_t v123;
  _QWORD *v124;
  _QWORD *v125;
  uint64_t v126;
  unsigned int v127;
  char *v128;
  uint64_t v129;
  char v130;
  unsigned __int8 *v131;
  int v132;
  uint64_t v133;
  uint64_t *v134;
  uint64_t v135;
  unsigned int *v136;
  char v137;
  __int128 *v138;
  unint64_t v139;
  int v140;
  uint64_t v141;
  char v142;
  StringID *v144;
  __int128 v145;
  uint64_t *v146;
  unint64_t v147;
  unint64_t v148;
  int v149;
  _QWORD *v150;
  __int128 v151;
  _QWORD v152[2];
  StringID v153;
  __int128 v154;
  uint64_t v155[2];
  __int128 v156;
  __int128 v157;
  StringID v158;
  __int128 v159;
  StringID v160;
  __int128 v161;
  __int128 v162;
  __int128 v163;
  _QWORD v164[2];
  StringID v165;
  int v166;
  int v167;
  _DWORD v168[8];
  __int128 v169;
  uint64_t v170;
  int v171;
  uint64_t v172;
  char v173;
  uint64_t v174;
  int v175;
  _OWORD v176[30];
  __int128 v177;
  __int128 v178;
  __int128 v179;
  __int128 v180;
  __int16 v181;
  __int16 v182;
  __int128 v183;
  __int128 v184;
  __int128 v185;
  __int128 v186;
  __int128 v187;
  uint64_t v188;

  v188 = *MEMORY[0x24BDAC8D0];
  re::TypeRegistry::typeInfo(a1, (re **)a2, v176);
  if (!LOBYTE(v176[0]))
  {
    v7 = (StringID *)re::TypeRegistry::typeName(a1, (_QWORD *)a2);
    v144 = v7;
    if (*(_QWORD *)a2
      && (v7 = (StringID *)re::DataArray<re::TextureAtlasTile>::tryGet((uint64_t)a1 + 96, *(_QWORD *)(a2 + 8))) != 0)
    {
      var0 = (int)v7[1].var0;
      if (!a3)
        goto LABEL_5;
    }
    else
    {
      var0 = -1;
      if (!a3)
      {
LABEL_5:
        v138 = (__int128 *)a2;
        v9 = 0;
        v10 = 0;
LABEL_30:
        v137 = 1;
LABEL_31:
        v142 = 1;
        goto LABEL_32;
      }
    }
    v9 = 0;
    v10 = 0;
    v11 = a3;
    while (!v9 || !v10)
    {
      v12 = *(unsigned int *)(v11 + 56);
      if (!(_DWORD)v12)
        goto LABEL_23;
      v13 = *(uint64_t **)(v11 + 64);
      v11 = 0;
      do
      {
        v14 = (_DWORD *)*v13;
        v15 = *(_DWORD *)*v13;
        if (v15 == 3)
        {
          v10 = *v13;
        }
        else if (v15 == 2)
        {
          v9 = (unsigned int *)*((_QWORD *)v14 + 1);
        }
        else if (v15 == 1 && v14[10] == 3)
        {
          v11 = *((_QWORD *)v14 + 2);
        }
        ++v13;
        --v12;
      }
      while (v12);
      if (!v11)
      {
LABEL_23:
        if (!v9)
        {
          v138 = (__int128 *)a2;
          goto LABEL_30;
        }
        break;
      }
      if (!*(_DWORD *)(v11 + 16))
        return;
    }
    v138 = (__int128 *)a2;
    v16 = *v9;
    if (!(_DWORD)v16)
    {
LABEL_28:
      v137 = 0;
      goto LABEL_31;
    }
    v17 = (unint64_t *)(*((_QWORD *)v9 + 1) + 24);
    while (*(v17 - 2) != a3)
    {
      v17 += 5;
      if (!--v16)
        goto LABEL_28;
    }
    v137 = 0;
    v142 = 0;
    v139 = *v17;
LABEL_32:
    v18 = *(unsigned int *)(a3 + 56);
    v19 = *(_QWORD *)(a3 + 64);
    v136 = v9;
    if ((_DWORD)v18)
    {
      v140 = var0;
      v20 = 0;
      v21 = 0xFFFFFFFFLL;
      v22 = *(_QWORD **)(a3 + 64);
      v23 = *(unsigned int *)(a3 + 56);
      do
      {
        v24 = (_DWORD *)*v22;
        if (*(_DWORD *)*v22 == 1 && v24[10] == 3)
        {
          v25 = *((_QWORD *)v24 + 2);
          v20 = *(_QWORD *)(v25 + 32);
          v21 = *(_QWORD *)(v25 + 40);
        }
        ++v22;
        --v23;
      }
      while (v23);
      v26 = 0;
      v141 = 0;
      *(_QWORD *)&v179 = 0;
      *((_QWORD *)&v179 + 1) = 0xFFFFFFFFLL;
      v27 = v140 - 1;
      while (1)
      {
        v28 = *(_QWORD *)(v19 + 8 * v26);
        if (*(_DWORD *)v28 == 6 && !*(_BYTE *)(v28 + 40))
        {
          if (*(_QWORD *)(v28 + 8) == v140)
          {
            v141 = *(_QWORD *)(v28 + 32);
            v29 = *(_QWORD *)(v28 + 16);
            if (v29 != a3)
              goto LABEL_52;
            v30 = *(char **)(a3 + 48);
            if (v30)
            {
              v31 = *v30;
              if (*v30)
              {
                v32 = v30[1];
                if (v32)
                {
                  v33 = (unsigned __int8 *)(v30 + 2);
                  do
                  {
                    v31 = 31 * v31 + v32;
                    v34 = *v33++;
                    v32 = v34;
                  }
                  while (v34);
                }
              }
            }
            else
            {
              v31 = 0;
            }
            *(_QWORD *)&v165.var0 = 2 * v31;
            v165.var1 = v30;
            re::TypeRegistry::typeID(a1, (const re::StringID *)&v165, v27, v176);
            v179 = v176[0];
            re::StringID::destroyString((re::StringID *)&v165);
            if (!(_QWORD)v179)
            {
              re::TypeRegistry::declareType((uint64_t)a1, 8, v144, v27, 1, v176);
              v179 = v176[0];
              v178 = v176[0];
              v7 = (StringID *)re::internal::registerStructureType(a1, &v178, a3, a4);
            }
          }
          else
          {
            v29 = *(_QWORD *)(v28 + 16);
            if (v29 != a3)
            {
LABEL_52:
              v179 = *(_OWORD *)(v29 + 32);
              re::TypeRegistry::typeInfo(a1, (re **)&v179, v176);
              if (!LOBYTE(v176[0]))
              {
                if (!(_QWORD)v179)
                {
                  StructureVersion = re::introspectionFindStructureVersion((re *)v29, v35);
                  v37 = *(char **)(v29 + 48);
                  if (v37)
                  {
                    v38 = *v37;
                    if (*v37)
                    {
                      v39 = v37[1];
                      if (v39)
                      {
                        v40 = (unsigned __int8 *)(v37 + 2);
                        do
                        {
                          v38 = 31 * v38 + v39;
                          v41 = *v40++;
                          v39 = v41;
                        }
                        while (v41);
                      }
                    }
                  }
                  else
                  {
                    v38 = 0;
                  }
                  *(_QWORD *)&v165.var0 = 2 * v38;
                  v165.var1 = v37;
                  re::TypeRegistry::declareType((uint64_t)a1, 8, &v165, StructureVersion, 0, v176);
                  v179 = v176[0];
                  re::StringID::destroyString((re::StringID *)&v165);
                  *(_OWORD *)(v29 + 32) = v179;
                }
                v177 = v179;
                v7 = (StringID *)re::internal::registerStructureType(a1, &v177, v29, a4);
              }
            }
          }
        }
        if (++v26 == v18)
        {
          var0 = v140;
          goto LABEL_68;
        }
      }
    }
    v20 = 0;
    v141 = 0;
    *(_QWORD *)&v179 = 0;
    v21 = 0xFFFFFFFFLL;
    *((_QWORD *)&v179 + 1) = 0xFFFFFFFFLL;
LABEL_68:
    v43 = *(int *)(a3 + 20);
    v44 = *(int *)(a3 + 24);
    v164[0] = v20;
    v164[1] = v21;
    re::TypeBuilder::beginObjectType((uint64_t)v176, (uint64_t *)v144, var0, a4, v43, v44, (uint64_t)v164);
    re::TypeBuilder::setConstructor((uint64_t)v176, *(_QWORD *)(a3 + 104));
    re::TypeBuilder::setDestructor((uint64_t)v176, *(_QWORD *)(a3 + 112));
    re::TypeBuilder::setRetain((uint64_t)v176, *(void (**)(void *))(a3 + 88));
    re::TypeBuilder::setRelease((uint64_t)v176, *(void (**)(void *))(a3 + 96));
    if ((_QWORD)v179)
    {
      v163 = v179;
      re::TypeBuilder::setPreviousVersion((unsigned __int8 *)v176, (uint64_t *)&v163);
    }
    if ((v142 & 1) == 0)
      re::TypeBuilder::addCustomClassID((uint64_t)v176, v139);
    if (!v20 && v10)
    {
      v162 = *(_OWORD *)(*(_QWORD *)(v10 + 8) + 32);
      *(_QWORD *)&v183 = 0xC98E91CCDF0B5FC4;
      *((_QWORD *)&v183 + 1) = "customClassID";
      re::TypeBuilder::addObjectMemberCustomClassID((uint64_t)v176, (uint64_t)&v162, (uint64_t *)&v183, *(_DWORD *)(v10 + 24));
      re::StringID::destroyString((re::StringID *)&v183);
    }
    if ((_DWORD)v18)
    {
      v46 = 0;
      a3 = (unint64_t)&v183 + 9;
      do
      {
        v47 = *(_QWORD *)(v19 + 8 * v46);
        if (*(_DWORD *)v47 == 1)
        {
          switch(*(_DWORD *)(v47 + 40))
          {
            case 0:
              v48 = *(unsigned int *)(v47 + 32);
              v49 = *(char **)(v47 + 8);
              v161 = *(_OWORD *)(*(_QWORD *)(v47 + 16) + 32);
              if (v49)
              {
                v50 = *v49;
                if (*v49)
                {
                  v51 = v49[1];
                  if (v51)
                  {
                    v52 = (unsigned __int8 *)(v49 + 2);
                    do
                    {
                      v50 = 31 * v50 + v51;
                      v53 = *v52++;
                      v51 = v53;
                    }
                    while (v53);
                  }
                }
              }
              else
              {
                v50 = 0;
              }
              *(_QWORD *)&v183 = 2 * v50;
              *((_QWORD *)&v183 + 1) = v49;
              re::TypeBuilder::addObjectMember((uint64_t)v176, v48, (uint64_t)&v161, (uint64_t *)&v183, *(_DWORD *)(v47 + 36));
              re::StringID::destroyString((re::StringID *)&v183);
              break;
            case 1:
              v180 = *(_OWORD *)(*(_QWORD *)(*(_QWORD *)(v47 + 16) + 48) + 32);
              v160 = *(StringID *)(*(_QWORD *)(v47 + 48) + 32);
              var1 = v144->var1;
              re::makePrettyMemberName(*(re **)(v47 + 8), (re::DynamicString *)&v146);
              v55 = (char *)&v147 + 1;
              if ((v147 & 1) != 0)
                v55 = (char *)v148;
              re::DynamicString::format((re::DynamicString *)"%s::%s", (re::DynamicString *)&v183, var1, v55);
              if (v146 && (v147 & 1) != 0)
                (*(void (**)(void))(*v146 + 40))();
              if ((BYTE8(v183) & 1) != 0)
                v56 = (const char *)v184;
              else
                v56 = (char *)&v183 + 9;
              re::TypeRegistry::makeStringID(a1, v56, (re::StringID *)&v146);
              v158 = v160;
              v159 = v180;
              re::TypeBuilder::beginArrayType((uint64_t)&v165, (uint64_t *)&v146, (re **)&v159, (uint64_t)&v158, *(_DWORD *)(v47 + 64) - *(_DWORD *)(v47 + 36));
              re::TypeBuilder::commitTo((re::TypeBuilder *)&v165, a1, &v157);
              v57 = *(unsigned int *)(v47 + 32);
              v156 = v157;
              v58 = *(char **)(v47 + 8);
              if (v58)
              {
                v59 = *v58;
                if (*v58)
                {
                  v60 = v58[1];
                  if (v60)
                  {
                    v61 = (unsigned __int8 *)(v58 + 2);
                    do
                    {
                      v59 = 31 * v59 + v60;
                      v62 = *v61++;
                      v60 = v62;
                    }
                    while (v62);
                  }
                }
              }
              else
              {
                v59 = 0;
              }
              v155[0] = 2 * v59;
              v155[1] = (uint64_t)v58;
              re::TypeBuilder::addObjectMember((uint64_t)v176, v57, (uint64_t)&v156, v155, *(_DWORD *)(v47 + 36));
              v73 = (re::StringID *)v155;
              goto LABEL_119;
            case 2:
              v180 = *(_OWORD *)(*(_QWORD *)(v47 + 48) + 32);
              v63 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v47 + 16) + 48) + 40);
              v64 = v144->var1;
              re::makePrettyMemberName(*(re **)(v47 + 8), (re::DynamicString *)&v146);
              v65 = (char *)&v147 + 1;
              if ((v147 & 1) != 0)
                v65 = (char *)v148;
              re::DynamicString::format((re::DynamicString *)"%s::%s", (re::DynamicString *)&v183, v64, v65);
              if (v146 && (v147 & 1) != 0)
                (*(void (**)(void))(*v146 + 40))();
              if ((BYTE8(v183) & 1) != 0)
                v66 = (const char *)v184;
              else
                v66 = (char *)&v183 + 9;
              re::TypeRegistry::makeStringID(a1, v66, (re::StringID *)&v146);
              v10 = 0xFFFFFFFFLL;
              v167 = -1;
              memset(v168, 0, sizeof(v168));
              v169 = 0u;
              v170 = 0xFFFFFFFFLL;
              v171 = 1;
              v172 = 0xFFFFFFFFLL;
              v173 = 1;
              v174 = 0xFFFFFFFFLL;
              v175 = 0;
              *(_BYTE *)&v165.var0 = 9;
              re::StringID::operator=((unint64_t *)&v165.var1, (uint64_t *)&v146);
              v166 = 1;
              *(_QWORD *)&v168[1] = 0x800000008;
              *(_QWORD *)((char *)&v169 + 4) = 0;
              *(_QWORD *)&v168[3] = 0;
              *(_QWORD *)&v168[5] = 0;
              v171 = -1;
              v172 = v63;
              v173 = 1;
              v154 = v180;
              re::TypeBuilder::addCustomClassIDForPointer((uint64_t)&v165, (uint64_t)&v154, *(_DWORD *)(v47 + 64) - *(_DWORD *)(v47 + 36));
              re::TypeBuilder::commitTo((re::TypeBuilder *)&v165, a1, &v160);
              v67 = *(unsigned int *)(v47 + 32);
              v153 = v160;
              v68 = *(char **)(v47 + 8);
              if (v68)
              {
                v69 = *v68;
                if (*v68)
                {
                  v70 = v68[1];
                  if (v70)
                  {
                    v71 = (unsigned __int8 *)(v68 + 2);
                    do
                    {
                      v69 = 31 * v69 + v70;
                      v72 = *v71++;
                      v70 = v72;
                    }
                    while (v72);
                  }
                }
              }
              else
              {
                v69 = 0;
              }
              *(_QWORD *)&v157 = 2 * v69;
              *((_QWORD *)&v157 + 1) = v68;
              re::TypeBuilder::addObjectMember((uint64_t)v176, v67, (uint64_t)&v153, (uint64_t *)&v157, *(_DWORD *)(v47 + 36));
              v73 = (re::StringID *)&v157;
LABEL_119:
              re::StringID::destroyString(v73);
              re::StringID::destroyString((re::StringID *)&v146);
              if ((_QWORD)v183 && (BYTE8(v183) & 1) != 0)
                (*(void (**)(void))(*(_QWORD *)v183 + 40))();
              break;
            case 3:
              break;
            default:
              re::internal::assertLog((re::internal *)4, v45, "assertion failure: '%s' (%s:line %i) Unexpected IntrospectionMemberType.", "!\"Unreachable code\"", "registerStructureType", 1835);
              _os_crash();
              __break(1u);
              JUMPOUT(0x225B77620);
          }
        }
        ++v46;
      }
      while (v46 != v18);
      v74 = 0;
      v75 = v141;
      do
      {
        v76 = *(_QWORD *)(v19 + 8 * v74);
        if (*(_DWORD *)v76 == 5)
        {
          v77 = *(char **)(v76 + 16);
          if (v77)
          {
            v78 = *v77;
            if (*v77)
            {
              v79 = v77[1];
              if (v79)
              {
                v80 = (unsigned __int8 *)(v77 + 2);
                do
                {
                  v78 = 31 * v78 + v79;
                  v81 = *v80++;
                  v79 = v81;
                }
                while (v81);
              }
            }
          }
          else
          {
            v78 = 0;
          }
          *(_QWORD *)&v183 = 2 * v78;
          *((_QWORD *)&v183 + 1) = v77;
          v82 = *(char **)(v76 + 8);
          if (v82)
          {
            v83 = *v82;
            if (*v82)
            {
              v84 = v82[1];
              if (v84)
              {
                v85 = (unsigned __int8 *)(v82 + 2);
                do
                {
                  v83 = 31 * v83 + v84;
                  v86 = *v85++;
                  v84 = v86;
                }
                while (v86);
              }
            }
          }
          else
          {
            v83 = 0;
          }
          v146 = (uint64_t *)(2 * v83);
          v147 = (unint64_t)v82;
          re::TypeBuilder::addObjectMemberRenaming((re::TypeBuilder *)v176, (const re::StringID *)&v183, (const re::StringID *)&v146);
          re::StringID::destroyString((re::StringID *)&v146);
          re::StringID::destroyString((re::StringID *)&v183);
        }
        ++v74;
      }
      while (v74 != v18);
      v87 = 0;
      v88 = 1;
      do
      {
        v89 = *(_DWORD **)(v19 + 8 * v87);
        if (*v89 == 4 && v89[1] == 1)
          break;
        v88 = ++v87 < v18;
      }
      while (v18 != v87);
    }
    else
    {
      v88 = 0;
      v75 = v141;
    }
    re::TypeBuilder::setHideObjectWithOneMember((uint64_t)v176, v88);
    if (v75)
    {
      *(_QWORD *)&v183 = 0xAE8345F9D646D604;
      *((_QWORD *)&v183 + 1) = "ComplexVersioningAttribute";
      v90 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a1 + 200, &v183);
      if (v90)
      {
        v91 = *v90;
        v92 = a1;
      }
      else
      {
        v92 = 0;
        v91 = 0xFFFFFFFFLL;
      }
      re::StringID::destroyString((re::StringID *)&v183);
      v93 = (_QWORD *)(*(uint64_t (**)(_QWORD *, uint64_t, uint64_t))(**((_QWORD **)a1 + 2) + 32))(*((_QWORD **)a1 + 2), 8, 8);
      *v93 = v75;
      v152[0] = v92;
      v152[1] = v91;
      re::TypeBuilder::addAttribute(v176, (uint64_t)v152, (uint64_t)v93, -1, 1);
    }
    v151 = *v138;
    re::TypeBuilder::commitTo((unsigned __int8 *)v176, (uint64_t *)&v151);
    if ((v137 & 1) != 0)
      goto LABEL_235;
    v150 = 0;
    v147 = 0;
    v148 = 0;
    v149 = 0;
    re::DynamicArray<re::IntrospectionStructure const*>::setCapacity(&v146, 0);
    ++v149;
    v95 = (__int128 *)v136;
    v96 = *v136;
    if ((_DWORD)v96)
    {
      v97 = 0;
      v98 = 40;
      do
      {
        v99 = *((_QWORD *)v136 + 1);
        if (*(_DWORD *)(v99 + 40 * v97 + 32))
        {
          re::internal::assertLog((re::internal *)4, v94, "assertion failure: '%s' (%s:line %i) ", "polymorphicType.basePointerOffset == 0", "addPolymorphicLeaveTypes", 1545);
          _os_crash();
          __break(1u);
LABEL_241:
          *(_QWORD *)&v160.var0 = 0;
          v186 = 0u;
          v187 = 0u;
          v184 = 0u;
          v185 = 0u;
          v183 = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          LODWORD(v180) = 136315906;
          *(_QWORD *)((char *)v95 + 4) = "operator[]";
          WORD6(v180) = 1024;
          *(_DWORD *)((char *)v95 + 14) = 789;
          v181 = 2048;
          *(_QWORD *)((char *)v95 + 20) = v98;
          v182 = 2048;
          *(_QWORD *)((char *)v95 + 30) = v42;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_242:
          *(_QWORD *)&v160.var0 = 0;
          v186 = 0u;
          v187 = 0u;
          v184 = 0u;
          v185 = 0u;
          v183 = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          LODWORD(v180) = 136315906;
          *(_QWORD *)((char *)v95 + 4) = "operator[]";
          WORD6(v180) = 1024;
          *(_DWORD *)((char *)v95 + 14) = 789;
          v181 = 2048;
          *(_QWORD *)((char *)v95 + 20) = a3;
          v182 = 2048;
          *(_QWORD *)((char *)v95 + 30) = v42;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_243:
          *(_QWORD *)&v157 = 0;
          v186 = 0u;
          v187 = 0u;
          v184 = 0u;
          v185 = 0u;
          v183 = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          LODWORD(v180) = 136315906;
          *(_QWORD *)((char *)v95 + 4) = "removeStableAt";
          WORD6(v180) = 1024;
          *(_DWORD *)((char *)v95 + 14) = 969;
          v181 = 2048;
          *(_QWORD *)((char *)v95 + 20) = v98;
          v182 = 2048;
          *(_QWORD *)((char *)v95 + 30) = v42;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_244:
          *(_QWORD *)&v160.var0 = 0;
          v186 = 0u;
          v187 = 0u;
          v184 = 0u;
          v185 = 0u;
          v183 = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          LODWORD(v180) = 136315906;
          *(_QWORD *)((char *)v95 + 4) = "insert";
          WORD6(v180) = 1024;
          *(_DWORD *)((char *)v95 + 14) = 855;
          v181 = 2048;
          *(_QWORD *)((char *)v95 + 20) = a3;
          v182 = 2048;
          *(_QWORD *)((char *)v95 + 30) = v98;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        *(_QWORD *)&v183 = 0;
        v100 = *(_QWORD *)(v99 + 40 * v97 + 8);
        *(_QWORD *)&v183 = v100;
        if (v148)
        {
          v101 = 8 * v148;
          v102 = v150;
          while (*v102 != v100)
          {
            ++v102;
            v101 -= 8;
            if (!v101)
            {
              v102 = &v150[v148];
              break;
            }
          }
        }
        else
        {
          v102 = v150;
        }
        if (v148 == v102 - v150)
        {
          re::DynamicArray<re::IntrospectionStructure const*>::add(&v146, &v183);
          v96 = *v136;
        }
        ++v97;
      }
      while (v97 < v96);
    }
    v95 = &v180;
    v42 = v148;
    v98 = v148 - 1;
    if ((uint64_t)(v148 - 1) < 0)
    {
LABEL_177:
      if (v42)
      {
        a3 = 0;
        v108 = v150;
        do
        {
          if (v42 <= a3)
            goto LABEL_242;
          v109 = v108[a3];
          while (1)
          {
            v108 = v150;
            v110 = v150[a3];
            v111 = *(unsigned int *)(v110 + 56);
            if (!(_DWORD)v111)
              goto LABEL_210;
            v112 = *(_QWORD **)(v110 + 64);
            while (1)
            {
              v113 = (_DWORD *)*v112;
              if (*(_DWORD *)*v112 == 1 && v113[10] == 3)
                break;
              ++v112;
              if (!--v111)
                goto LABEL_209;
            }
            v114 = *((_QWORD *)v113 + 2);
            if (!v114)
              break;
            v115 = 0;
            v116 = 8 * v42;
            v117 = &v150[v42];
            while (v150[v115 / 8] != v114)
            {
              v115 += 8;
              if (v116 == v115)
              {
                v118 = &v150[v42];
                goto LABEL_193;
              }
            }
            v118 = &v150[v115 / 8];
LABEL_193:
            if (v42 != v118 - v150)
              break;
            v119 = 0;
            while (v150[v119 / 8] != v114)
            {
              v119 += 8;
              if (v116 == v119)
                goto LABEL_199;
            }
            v117 = &v150[v119 / 8];
LABEL_199:
            if (v42 != v117 - v150)
              break;
            v98 = v42 + 1;
            if (v42 + 1 <= a3)
              goto LABEL_244;
            if (v42 >= v147)
            {
              re::DynamicArray<re::IntrospectionStructure const*>::growCapacity(&v146, v42 + 1);
              v42 = v148;
              v108 = v150;
            }
            v120 = &v108[v42];
            if (v42 > a3)
            {
              *v120 = *(v120 - 1);
              v121 = v150;
              v94 = (uint64_t)&v150[a3];
              v122 = (uint64_t)&v150[v42 - 1];
              if (v122 != v94)
              {
                memmove((void *)(v94 + 8), (const void *)v94, v122 - v94);
                v121 = v150;
                v42 = v148;
              }
              v120 = &v121[a3];
            }
            *v120 = v114;
            v148 = ++v42;
            ++v149;
            if (v42 <= a3)
              goto LABEL_242;
          }
LABEL_209:
          if (!v42)
            goto LABEL_232;
LABEL_210:
          v123 = 0;
          v124 = &v150[v42];
          while (v150[v123] != v109)
          {
            if (v42 == ++v123)
            {
              v125 = &v150[v42];
              goto LABEL_215;
            }
          }
          v125 = &v150[v123];
LABEL_215:
          v126 = v125 - v150;
          if (v126 != v42)
            v10 = v126;
          a3 = v10 + 1;
        }
        while (v10 + 1 < v42);
        do
        {
          v133 = *v108;
          if (!*(_DWORD *)(*v108 + 16))
            break;
          v180 = *(_OWORD *)(v133 + 32);
          re::TypeRegistry::typeInfo(a1, (re **)&v180, &v183);
          if (!(_BYTE)v183)
          {
            if (!(_QWORD)v180)
            {
              v127 = re::introspectionFindStructureVersion((re *)v133, (const re::IntrospectionStructure *)v94);
              v128 = *(char **)(v133 + 48);
              if (v128)
              {
                v129 = *v128;
                if (*v128)
                {
                  v130 = v128[1];
                  if (v130)
                  {
                    v131 = (unsigned __int8 *)(v128 + 2);
                    do
                    {
                      v129 = 31 * v129 + v130;
                      v132 = *v131++;
                      v130 = v132;
                    }
                    while (v132);
                  }
                }
              }
              else
              {
                v129 = 0;
              }
              *(_QWORD *)&v160.var0 = 2 * v129;
              v160.var1 = v128;
              re::TypeRegistry::declareType((uint64_t)a1, 8, &v160, v127, 0, &v183);
              v180 = v183;
              re::StringID::destroyString((re::StringID *)&v160);
              *(_OWORD *)(v133 + 32) = v180;
            }
            v145 = v180;
            re::internal::registerStructureType(a1, &v145, v133, a4);
          }
          ++v108;
        }
        while (v108 != v124);
      }
LABEL_232:
      v134 = v146;
      if (!v146)
        goto LABEL_235;
      v94 = (uint64_t)v150;
      if (!v150)
        goto LABEL_235;
    }
    else
    {
      while (1)
      {
        v42 = v148;
        if (v148 <= v98)
          goto LABEL_241;
        v94 = (uint64_t)v150;
        v103 = v150[v98];
        if (!*(_DWORD *)(v103 + 16))
          break;
        v160 = *(StringID *)(v103 + 32);
        re::TypeRegistry::typeInfo(a1, (re **)&v160, &v183);
        if ((_BYTE)v183)
        {
          v42 = v148;
          if (v148 <= v98)
            goto LABEL_243;
          v104 = v148 - 1;
          if (v148 - 1 > v98)
          {
            v105 = (char *)&v150[v98];
            v94 = (uint64_t)(v105 + 8);
            v106 = (char *)&v150[v148];
            if (v105 + 8 != v106)
            {
              memmove(v105, (const void *)v94, (size_t)&v106[-v94]);
              v104 = v148 - 1;
            }
          }
          v148 = v104;
          ++v149;
        }
        if ((uint64_t)v98-- <= 0)
        {
          v42 = v148;
          goto LABEL_177;
        }
      }
      v134 = v146;
      if (!v146)
        goto LABEL_235;
    }
    (*(void (**)(uint64_t *))(*v134 + 40))(v134);
LABEL_235:
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v165, v94);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v176, v135);
  }
}

void re::IntrospectionStructure::~IntrospectionStructure(re::IntrospectionStructure *this)
{
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

void re::IntrospectionBasic::~IntrospectionBasic(re::IntrospectionBasic *this)
{
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

uint64_t re::IntrospectionBasic::childInfoCount(re::IntrospectionBasic *this)
{
  return 0;
}

void re::IntrospectionBasic::childInfo(re::IntrospectionBasic *this, uint64_t a2)
{
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Type does not have nested types.", "!\"Unreachable code\"", "childInfo", 433);
  _os_crash();
  __break(1u);
}

void re::IntrospectionDataArrayBase::~IntrospectionDataArrayBase(re::IntrospectionDataArrayBase *this)
{
  *(_QWORD *)this = &off_24ED7D928;
  re::SerializedReference<re::IntrospectionBase const*>::reset((_QWORD *)this + 6);
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  *(_QWORD *)this = &off_24ED7D928;
  re::SerializedReference<re::IntrospectionBase const*>::reset((_QWORD *)this + 6);
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

uint64_t re::IntrospectionDataArrayBase::childInfoCount(re::IntrospectionDataArrayBase *this)
{
  return 1;
}

uint64_t re::IntrospectionDataArrayBase::childInfo(re::IntrospectionDataArrayBase *this, uint64_t a2)
{
  uint64_t result;

  if (!a2)
    return *((_QWORD *)this + 6);
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Index out of range.", "index == 0", "childInfo", 712);
  result = _os_crash();
  __break(1u);
  return result;
}

void re::IntrospectionDataArrayBase::init(re::IntrospectionDataArrayBase *this, uint64_t a2, re::Allocator *a3)
{
  re::internal::assertLog((re::internal *)4, a2, a3, "assertion failure: '%s' (%s:line %i) ", "!\"Unreachable code\"", "init", 701);
  _os_crash();
  __break(1u);
}

void re::IntrospectionDataArrayBase::addElement(uint64_t a1, uint64_t a2)
{
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) ", "!\"Unreachable code\"", "addElement", 702);
  _os_crash();
  __break(1u);
}

void re::IntrospectionDataArrayBase::size(re::IntrospectionDataArrayBase *this, uint64_t a2)
{
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) ", "!\"Unreachable code\"", "size", 703);
  _os_crash();
  __break(1u);
}

void re::IntrospectionDataArrayBase::begin(re::IntrospectionDataArrayBase *this, uint64_t a2)
{
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) ", "!\"Unreachable code\"", "begin", 705);
  _os_crash();
  __break(1u);
}

void re::IntrospectionDataArrayBase::end(re::IntrospectionDataArrayBase *this, uint64_t a2)
{
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) ", "!\"Unreachable code\"", "end", 706);
  _os_crash();
  __break(1u);
}

void re::IntrospectionDataArrayBase::elementAt(uint64_t a1, uint64_t a2)
{
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) ", "!\"Unreachable code\"", "elementAt", 707);
  _os_crash();
  __break(1u);
}

void re::IntrospectionDynamicString::~IntrospectionDynamicString(re::IntrospectionDynamicString *this)
{
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

uint64_t re::IntrospectionDynamicString::childInfoCount(re::IntrospectionDynamicString *this)
{
  return 1;
}

uint64_t re::IntrospectionDynamicString::childInfo(re::IntrospectionDynamicString *this, uint64_t a2)
{
  unsigned __int8 v2;
  _QWORD *v3;
  int v5;
  const re::IntrospectionBase *v6;

  if (a2)
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Index out of range.", "index == 0", "childInfo", 827);
    _os_crash();
    __break(1u);
  }
  else
  {
    v3 = &unk_255825000;
    if ((v2 & 1) != 0)
      return v3[174];
  }
  v3 = (_QWORD *)&unk_255825000;
  if (v5)
  {
    re::introspect_char(0, v6);
    re::introspect<char>(void)::info = (uint64_t)&re::introspect_char(BOOL)::info;
    v3 = (_QWORD *)&unk_255825000;
  }
  return v3[174];
}

void re::IntrospectionEnum::~IntrospectionEnum(re::IntrospectionEnum *this)
{
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

void re::IntrospectionCallbackSerializer::~IntrospectionCallbackSerializer(re::IntrospectionCallbackSerializer *this)
{
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

uint64_t re::IntrospectionCallbackSerializer::childInfoCount(re::IntrospectionCallbackSerializer *this)
{
  return 0;
}

void re::IntrospectionCallbackSerializer::childInfo(re::IntrospectionCallbackSerializer *this, uint64_t a2)
{
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Type does not have nested types.", "!\"Unreachable code\"", "childInfo", 1082);
  _os_crash();
  __break(1u);
}

void re::IntrospectionStringID::~IntrospectionStringID(re::IntrospectionStringID *this)
{
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

uint64_t re::IntrospectionStringID::childInfoCount(re::IntrospectionStringID *this)
{
  return 0;
}

void re::IntrospectionStringID::childInfo(re::IntrospectionStringID *this, uint64_t a2)
{
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Type does not have nested types.", "!\"Unreachable code\"", "childInfo", 1094);
  _os_crash();
  __break(1u);
}

_QWORD *re::DynamicArray<re::IntrospectionStructure const*>::add(_QWORD *this, _QWORD *a2)
{
  _QWORD *v3;
  unint64_t v4;

  v3 = this;
  v4 = this[2];
  if (v4 >= this[1])
  {
    this = re::DynamicArray<re::IntrospectionStructure const*>::growCapacity(this, v4 + 1);
    v4 = v3[2];
  }
  *(_QWORD *)(v3[4] + 8 * v4) = *a2;
  v3[2] = v4 + 1;
  ++*((_DWORD *)v3 + 6);
  return this;
}

_QWORD *re::DynamicArray<re::IntrospectionStructure const*>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<re::IntrospectionStructure const*>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::IntrospectionStructure const*>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

_QWORD *re::DynamicArray<re::IntrospectionStructure const*>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  void *v7;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (*v5)
      {
        if (!a2)
        {
          v7 = 0;
          if (!v3)
            goto LABEL_9;
          goto LABEL_8;
        }
        if (a2 >> 61)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 8, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          v2 = 8 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 8 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
            {
LABEL_9:
              v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            memcpy(v7, (const void *)v5[4], 8 * v5[2]);
            result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
      }
      else
      {
        result = (_QWORD *)re::DynamicArray<re::IntrospectionStructure const*>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

_OWORD *std::__tree<std::__value_type<re::DowngradeCode,re::Result<re::Unit,re::DynamicString> (*)(void *,void *)>,std::__map_value_compare<re::DowngradeCode,std::__value_type<re::DowngradeCode,re::Result<re::Unit,re::DynamicString> (*)(void *,void *)>,std::greater<re::DowngradeCode>,true>,std::allocator<std::__value_type<re::DowngradeCode,re::Result<re::Unit,re::DynamicString> (*)(void *,void *)>>>::__emplace_multi<std::pair<re::DowngradeCode const,re::Result<re::Unit,re::DynamicString> (*)(void *,void *)>>(uint64_t **a1, _OWORD *a2)
{
  _OWORD *v4;
  _OWORD *v5;
  uint64_t **v6;
  uint64_t *v7;
  uint64_t **v8;

  v4 = operator new(0x30uLL);
  v5 = v4;
  v4[2] = *a2;
  v6 = a1 + 1;
  v7 = a1[1];
  if (v7)
  {
    do
    {
      while (1)
      {
        v6 = (uint64_t **)v7;
        if (*((_DWORD *)v4 + 8) <= *((_DWORD *)v7 + 8))
          break;
        v7 = (uint64_t *)*v7;
        v8 = v6;
        if (!*v6)
          goto LABEL_8;
      }
      v7 = (uint64_t *)v7[1];
    }
    while (v7);
    v8 = v6 + 1;
  }
  else
  {
    v8 = a1 + 1;
  }
LABEL_8:
  std::__tree<std::__value_type<double,std::string>,std::__map_value_compare<double,std::__value_type<double,std::string>,std::less<double>,true>,std::allocator<std::__value_type<double,std::string>>>::__insert_node_at(a1, (uint64_t)v6, v8, (uint64_t *)v4);
  return v5;
}

_QWORD *re::DynamicArray<re::IntrospectionPolymorphicType>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<re::IntrospectionPolymorphicType>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::IntrospectionPolymorphicType>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

_QWORD *re::DynamicArray<re::IntrospectionPolymorphicType>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::IntrospectionPolymorphicType>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x28uLL))
        {
          v2 = 40 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 40 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_16;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 40, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = (_QWORD *)v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = &v8[5 * v9];
        v11 = v7;
        do
        {
          *v11 = *v8;
          v11[2] = 0;
          v11[2] = v8[2];
          v8[2] = 0;
          v12 = v11[1];
          v14 = v8[1];
          v13 = v8 + 1;
          v11[1] = v14;
          *v13 = v12;
          v15 = v13[2];
          *((_DWORD *)v11 + 8) = *((_DWORD *)v13 + 6);
          v11[3] = v15;
          re::SerializedReference<re::IntrospectionBase const*>::reset(v13);
          v8 = v13 + 4;
          v11 += 5;
        }
        while (v8 != v10);
        v8 = (_QWORD *)v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

re::TypeRegistry *re::TypeRegistry::TypeRegistry(re::TypeRegistry *this, re::Allocator *a2)
{
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;
  _QWORD *v18;
  _QWORD *v19;
  uint64_t v20;
  _QWORD *v21;
  _QWORD *v22;
  _QWORD *v23;
  uint64_t v24;

  ArcSharedObject::ArcSharedObject(this, 0);
  *(_QWORD *)(v4 + 16) = a2;
  *(_QWORD *)v4 = &off_24ED7DB90;
  *(_DWORD *)(v4 + 24) = 0;
  *(_OWORD *)(v4 + 40) = 0u;
  *(_DWORD *)(v4 + 56) = 0;
  *(_OWORD *)(v4 + 64) = 0u;
  *(_DWORD *)(v4 + 80) = 0;
  *(_QWORD *)(v4 + 84) = 0x1FFFFFFFFLL;
  *(_OWORD *)(v4 + 104) = 0u;
  *(_QWORD *)(v4 + 96) = 0;
  v5 = (_QWORD *)(v4 + 96);
  *(_DWORD *)(v4 + 120) = 0;
  *(_OWORD *)(v4 + 128) = 0u;
  *(_DWORD *)(v4 + 144) = 0;
  *(_QWORD *)(v4 + 148) = 0x1FFFFFFFFLL;
  *(_QWORD *)(v4 + 176) = 0;
  *(_DWORD *)(v4 + 184) = 0;
  *(_OWORD *)(v4 + 160) = 0u;
  v6 = (_QWORD *)(v4 + 160);
  v24 = v4 + 200;
  *(_OWORD *)(v4 + 220) = 0u;
  *(_OWORD *)(v4 + 192) = 0u;
  *(_OWORD *)(v4 + 208) = 0u;
  *(_QWORD *)(v4 + 236) = 0x7FFFFFFFLL;
  *(_DWORD *)(v4 + 272) = 0;
  *(_QWORD *)(v4 + 264) = 0;
  *(_OWORD *)(v4 + 248) = 0u;
  v7 = (_QWORD *)(v4 + 248);
  v8 = (_QWORD *)(v4 + 328);
  v13 = (_QWORD *)(v4 + 288);
  v14 = (_QWORD *)(v4 + 368);
  v9 = (_QWORD *)(v4 + 408);
  v16 = (_QWORD *)(v4 + 448);
  v10 = (_QWORD *)(v4 + 488);
  v19 = (_QWORD *)(v4 + 528);
  v21 = (_QWORD *)(v4 + 608);
  v23 = (_QWORD *)(v4 + 688);
  v20 = v4 + 768;
  *(_DWORD *)(v4 + 312) = 0;
  *(_OWORD *)(v4 + 280) = 0u;
  *(_OWORD *)(v4 + 296) = 0u;
  *(_DWORD *)(v4 + 352) = 0;
  *(_OWORD *)(v4 + 320) = 0u;
  *(_OWORD *)(v4 + 336) = 0u;
  *(_DWORD *)(v4 + 392) = 0;
  *(_OWORD *)(v4 + 360) = 0u;
  *(_OWORD *)(v4 + 376) = 0u;
  *(_DWORD *)(v4 + 432) = 0;
  *(_OWORD *)(v4 + 400) = 0u;
  *(_OWORD *)(v4 + 416) = 0u;
  *(_DWORD *)(v4 + 472) = 0;
  *(_OWORD *)(v4 + 440) = 0u;
  *(_OWORD *)(v4 + 456) = 0u;
  *(_DWORD *)(v4 + 512) = 0;
  *(_OWORD *)(v4 + 480) = 0u;
  *(_OWORD *)(v4 + 496) = 0u;
  *(_DWORD *)(v4 + 552) = 0;
  *(_OWORD *)(v4 + 520) = 0u;
  *(_OWORD *)(v4 + 536) = 0u;
  *(_DWORD *)(v4 + 592) = 0;
  *(_OWORD *)(v4 + 560) = 0u;
  *(_OWORD *)(v4 + 576) = 0u;
  *(_DWORD *)(v4 + 632) = 0;
  v15 = (_QWORD *)(v4 + 568);
  *(_OWORD *)(v4 + 600) = 0u;
  *(_OWORD *)(v4 + 616) = 0u;
  *(_DWORD *)(v4 + 672) = 0;
  *(_OWORD *)(v4 + 640) = 0u;
  *(_OWORD *)(v4 + 656) = 0u;
  *(_DWORD *)(v4 + 712) = 0;
  v17 = (_QWORD *)(v4 + 648);
  v18 = (_QWORD *)(v4 + 728);
  *(_OWORD *)(v4 + 680) = 0u;
  *(_OWORD *)(v4 + 696) = 0u;
  *(_DWORD *)(v4 + 752) = 0;
  *(_OWORD *)(v4 + 720) = 0u;
  *(_OWORD *)(v4 + 736) = 0u;
  *(_OWORD *)(v4 + 788) = 0u;
  *(_OWORD *)(v4 + 760) = 0u;
  *(_OWORD *)(v4 + 776) = 0u;
  *(_QWORD *)(v4 + 804) = 0x7FFFFFFFLL;
  v22 = (_QWORD *)(v4 + 816);
  *(_DWORD *)(v4 + 840) = 0;
  *(_QWORD *)(v4 + 832) = 0;
  *(_OWORD *)(v4 + 816) = 0u;
  *(_QWORD *)(v4 + 856) = 0;
  *(_QWORD *)(v4 + 848) = 0;
  *(_QWORD *)(v4 + 32) = a2;
  v11 = (_QWORD *)(v4 + 32);
  re::DynamicArray<re::RigNodeConstraint>::setCapacity((_QWORD *)(v4 + 32), 0);
  ++*((_DWORD *)this + 14);
  *((_DWORD *)this + 19) = 1024;
  re::DataArray<re::internal::TypeInfoIndex>::allocBlock(v11);
  *v5 = a2;
  re::DynamicArray<re::RigNodeConstraint>::setCapacity(v5, 0);
  ++*((_DWORD *)this + 30);
  *((_DWORD *)this + 35) = 1024;
  re::DataArray<MetalHeap::TextureEntry>::allocBlock(v5);
  *v6 = a2;
  re::DynamicArray<re::StringID>::setCapacity(v6, 0);
  ++*((_DWORD *)this + 46);
  *v7 = a2;
  re::DynamicArray<re::PipelineStateCacheKey>::setCapacity(v7, 0);
  ++*((_DWORD *)this + 68);
  *((_QWORD *)this + 36) = a2;
  re::DynamicArray<re::internal::EnumTypeInfo>::setCapacity(v13, 0);
  ++*((_DWORD *)this + 78);
  *((_QWORD *)this + 41) = a2;
  re::DynamicArray<re::Pair<unsigned long,re::StringID,true>>::setCapacity(v8, 0);
  ++*((_DWORD *)this + 88);
  *((_QWORD *)this + 46) = a2;
  re::DynamicArray<re::internal::EnumTypeInfo>::setCapacity(v14, 0);
  ++*((_DWORD *)this + 98);
  *((_QWORD *)this + 51) = a2;
  re::DynamicArray<re::internal::EnumTypeInfo>::setCapacity(v9, 0);
  ++*((_DWORD *)this + 108);
  *((_QWORD *)this + 56) = a2;
  re::DynamicArray<re::internal::ListTypeInfo>::setCapacity(v16, 0);
  ++*((_DWORD *)this + 118);
  *((_QWORD *)this + 61) = a2;
  re::DynamicArray<re::RigHierarchyJointTransform>::setCapacity(v10, 0);
  ++*((_DWORD *)this + 128);
  *((_QWORD *)this + 66) = a2;
  re::DynamicArray<re::internal::EnumTypeInfo>::setCapacity(v19, 0);
  ++*((_DWORD *)this + 138);
  *((_QWORD *)this + 71) = a2;
  re::DynamicArray<float *>::setCapacity(v15, 0);
  ++*((_DWORD *)this + 148);
  *((_QWORD *)this + 76) = a2;
  re::DynamicArray<re::internal::ObjectTypeInfo>::setCapacity(v21, 0);
  ++*((_DWORD *)this + 158);
  *((_QWORD *)this + 81) = a2;
  re::DynamicArray<re::internal::ObjectMemberInfo>::setCapacity(v17, 0);
  ++*((_DWORD *)this + 168);
  *((_QWORD *)this + 86) = a2;
  re::DynamicArray<re::BlendParameterInputNode>::setCapacity(v23, 0);
  ++*((_DWORD *)this + 178);
  *((_QWORD *)this + 91) = a2;
  re::DynamicArray<re::internal::PointerTypeInfo>::setCapacity(v18, 0);
  ++*((_DWORD *)this + 188);
  re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphNode>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init(v24, (uint64_t)a2, 3);
  re::HashTable<re::internal::TypeAttributeKey,re::internal::TypeAttributeData,re::Hash<re::internal::TypeAttributeKey>,re::EqualTo<re::internal::TypeAttributeKey>,true,false>::init(v20, (uint64_t)a2, 3);
  *((_QWORD *)this + 102) = a2;
  re::DynamicArray<float *>::setCapacity(v22, 0);
  ++*((_DWORD *)this + 210);
  return this;
}

void re::TypeRegistry::~TypeRegistry(re::TypeRegistry *this)
{
  uint64_t v2;
  uint64_t v3;
  int *v4;
  int v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  __n128 v25;
  _QWORD *v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  double v34;
  _QWORD *v35;
  _QWORD *v36;
  _QWORD *v37;
  _QWORD *v38;
  _QWORD *v39;
  _QWORD *v40;
  _QWORD *v41;
  uint64_t *v42;
  char v43[8];
  uint64_t v44;

  v2 = *((unsigned int *)this + 200);
  if ((_DWORD)v2)
  {
    v3 = 0;
    v4 = (int *)(*((_QWORD *)this + 98) + 8);
    while (1)
    {
      v5 = *v4;
      v4 += 14;
      if (v5 < 0)
        break;
      if (v2 == ++v3)
      {
        LODWORD(v3) = *((_DWORD *)this + 200);
        break;
      }
    }
  }
  else
  {
    LODWORD(v3) = 0;
  }
  if ((_DWORD)v2 != (_DWORD)v3)
  {
    v6 = v3;
    v7 = *((_DWORD *)this + 200);
    do
    {
      v8 = *((_QWORD *)this + 98);
      if ((*(_BYTE *)(v8 + 56 * v6 + 48) & 1) != 0)
      {
        v9 = v8 + 56 * v6;
        re::TypeRegistry::typeInfo(this, *(_QWORD *)(v9 + 16), v43);
        re::TypeInfo::releaseInstance((re::TypeInfo *)&v44, *(void **)(v9 + 40), *((re::Allocator **)this + 2), 0);
        v7 = *((_DWORD *)this + 200);
      }
      if (v7 <= (int)v3 + 1)
        v10 = v3 + 1;
      else
        v10 = v7;
      while (1)
      {
        v6 = (v3 + 1);
        if (v10 - 1 == (_DWORD)v3)
          break;
        LODWORD(v3) = v3 + 1;
        v11 = v6;
        if ((*(_DWORD *)(*((_QWORD *)this + 98) + 56 * v6 + 8) & 0x80000000) != 0)
          goto LABEL_18;
      }
      v11 = v10;
LABEL_18:
      LODWORD(v3) = v11;
    }
    while ((_DWORD)v2 != v11);
  }
  re::DataArray<re::internal::TypeInfoIndex>::deinit((uint64_t)this + 32);
  re::DataArray<re::TypeRegistry::TypeNameAndVersion>::deinit((uint64_t)this + 96);
  re::DynamicArray<re::StringID>::deinit((uint64_t)this + 160);
  v12 = *((_QWORD *)this + 31);
  if (v12)
  {
    if (*((_QWORD *)this + 35))
      (*(void (**)(uint64_t))(*(_QWORD *)v12 + 40))(v12);
    *((_QWORD *)this + 35) = 0;
    *((_QWORD *)this + 32) = 0;
    *((_QWORD *)this + 33) = 0;
    *((_QWORD *)this + 31) = 0;
    ++*((_DWORD *)this + 68);
  }
  v13 = *((_QWORD *)this + 36);
  if (v13)
  {
    if (*((_QWORD *)this + 40))
      (*(void (**)(uint64_t))(*(_QWORD *)v13 + 40))(v13);
    *((_QWORD *)this + 40) = 0;
    *((_QWORD *)this + 37) = 0;
    *((_QWORD *)this + 38) = 0;
    *((_QWORD *)this + 36) = 0;
    ++*((_DWORD *)this + 78);
  }
  re::DynamicArray<re::Pair<unsigned long,re::StringID,true>>::deinit((uint64_t)this + 328);
  v14 = *((_QWORD *)this + 46);
  if (v14)
  {
    if (*((_QWORD *)this + 50))
      (*(void (**)(uint64_t))(*(_QWORD *)v14 + 40))(v14);
    *((_QWORD *)this + 50) = 0;
    *((_QWORD *)this + 47) = 0;
    *((_QWORD *)this + 48) = 0;
    *((_QWORD *)this + 46) = 0;
    ++*((_DWORD *)this + 98);
  }
  v15 = *((_QWORD *)this + 51);
  if (v15)
  {
    if (*((_QWORD *)this + 55))
      (*(void (**)(uint64_t))(*(_QWORD *)v15 + 40))(v15);
    *((_QWORD *)this + 55) = 0;
    *((_QWORD *)this + 52) = 0;
    *((_QWORD *)this + 53) = 0;
    *((_QWORD *)this + 51) = 0;
    ++*((_DWORD *)this + 108);
  }
  v16 = *((_QWORD *)this + 56);
  if (v16)
  {
    if (*((_QWORD *)this + 60))
      (*(void (**)(uint64_t))(*(_QWORD *)v16 + 40))(v16);
    *((_QWORD *)this + 60) = 0;
    *((_QWORD *)this + 57) = 0;
    *((_QWORD *)this + 58) = 0;
    *((_QWORD *)this + 56) = 0;
    ++*((_DWORD *)this + 118);
  }
  v41 = (_QWORD *)((char *)this + 32);
  v17 = (_QWORD *)((char *)this + 488);
  v18 = *((_QWORD *)this + 61);
  if (v18)
  {
    if (*((_QWORD *)this + 65))
      (*(void (**)(uint64_t))(*(_QWORD *)v18 + 40))(v18);
    *((_QWORD *)this + 65) = 0;
    *((_QWORD *)this + 62) = 0;
    *((_QWORD *)this + 63) = 0;
    *v17 = 0;
    ++*((_DWORD *)this + 128);
  }
  v37 = (_QWORD *)((char *)this + 368);
  v38 = (_QWORD *)((char *)this + 288);
  v19 = (_QWORD *)((char *)this + 528);
  v20 = *((_QWORD *)this + 66);
  if (v20)
  {
    if (*((_QWORD *)this + 70))
      (*(void (**)(uint64_t))(*(_QWORD *)v20 + 40))(v20);
    *((_QWORD *)this + 70) = 0;
    *((_QWORD *)this + 67) = 0;
    *((_QWORD *)this + 68) = 0;
    *v19 = 0;
    ++*((_DWORD *)this + 138);
  }
  v40 = (_QWORD *)((char *)this + 96);
  v42 = (uint64_t *)((char *)this + 768);
  v21 = (_QWORD *)((char *)this + 568);
  v22 = *((_QWORD *)this + 71);
  if (v22)
  {
    if (*((_QWORD *)this + 75))
      (*(void (**)(uint64_t))(*(_QWORD *)v22 + 40))(v22);
    *((_QWORD *)this + 75) = 0;
    *((_QWORD *)this + 72) = 0;
    *((_QWORD *)this + 73) = 0;
    *v21 = 0;
    ++*((_DWORD *)this + 148);
  }
  v36 = (_QWORD *)((char *)this + 408);
  re::DynamicArray<re::internal::ObjectTypeInfo>::deinit((uint64_t)this + 608);
  re::DynamicArray<re::GeomDeformer::Attribute>::deinit((uint64_t)this + 648);
  re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)this + 688);
  v23 = (_QWORD *)((char *)this + 728);
  v24 = *((_QWORD *)this + 91);
  if (v24)
  {
    if (*((_QWORD *)this + 95))
      (*(void (**)(uint64_t))(*(_QWORD *)v24 + 40))(v24);
    *((_QWORD *)this + 95) = 0;
    *((_QWORD *)this + 92) = 0;
    *((_QWORD *)this + 93) = 0;
    *v23 = 0;
    ++*((_DWORD *)this + 188);
  }
  v39 = (_QWORD *)((char *)this + 248);
  v35 = (_QWORD *)((char *)this + 448);
  re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 25);
  v25.n128_f64[0] = re::HashTable<re::Pair<re::StringSlice,re::StringSlice,true>,unsigned long,re::Hash<re::Pair<re::StringSlice,re::StringSlice,true>>,re::EqualTo<re::Pair<re::StringSlice,re::StringSlice,true>>,true,false>::deinit(v42);
  v26 = (_QWORD *)((char *)this + 816);
  v27 = *((_QWORD *)this + 104);
  if (v27)
  {
    v28 = (uint64_t *)*((_QWORD *)this + 106);
    v29 = 8 * v27;
    do
    {
      v30 = *v28++;
      (*(void (**)(_QWORD, uint64_t, __n128))(**((_QWORD **)this + 2) + 40))(*((_QWORD *)this + 2), v30, v25);
      v29 -= 8;
    }
    while (v29);
  }
  if (*v26)
  {
    if (*((_QWORD *)this + 106))
      (*(void (**)(_QWORD, __n128))(*(_QWORD *)*v26 + 40))(*v26, v25);
    *((_QWORD *)this + 106) = 0;
    *((_QWORD *)this + 103) = 0;
    *((_QWORD *)this + 104) = 0;
    *v26 = 0;
    ++*((_DWORD *)this + 210);
  }
  v31 = *((_QWORD *)this + 107);
  if (v31)
  {
    v32 = *((_QWORD *)this + 2);
    re::internal::TypeTranslationTable::~TypeTranslationTable(*((re::internal::TypeTranslationTable **)this + 107));
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v32 + 40))(v32, v31);
    v33 = *((_QWORD *)this + 102);
    if (v33)
    {
      if (*((_QWORD *)this + 106))
        (*(void (**)(uint64_t))(*(_QWORD *)v33 + 40))(v33);
      *((_QWORD *)this + 106) = 0;
      *((_QWORD *)this + 103) = 0;
      *((_QWORD *)this + 104) = 0;
      *v26 = 0;
      ++*((_DWORD *)this + 210);
    }
  }
  v34 = re::HashTable<re::Pair<re::StringSlice,re::StringSlice,true>,unsigned long,re::Hash<re::Pair<re::StringSlice,re::StringSlice,true>>,re::EqualTo<re::Pair<re::StringSlice,re::StringSlice,true>>,true,false>::deinit(v42);
  if (*v23)
  {
    if (*((_QWORD *)this + 95))
      (*(void (**)(_QWORD, double))(*(_QWORD *)*v23 + 40))(*v23, v34);
    *((_QWORD *)this + 95) = 0;
    *((_QWORD *)this + 92) = 0;
    *((_QWORD *)this + 93) = 0;
    *v23 = 0;
    ++*((_DWORD *)this + 188);
  }
  re::DynamicArray<re::Pair<re::StringID,re::RigDataValue *,true>>::deinit((uint64_t)this + 688);
  re::DynamicArray<re::GeomDeformer::Attribute>::deinit((uint64_t)this + 648);
  re::DynamicArray<re::internal::ObjectTypeInfo>::deinit((uint64_t)this + 608);
  if (*v21)
  {
    if (*((_QWORD *)this + 75))
      (*(void (**)(_QWORD))(*(_QWORD *)*v21 + 40))(*v21);
    *((_QWORD *)this + 75) = 0;
    *((_QWORD *)this + 72) = 0;
    *((_QWORD *)this + 73) = 0;
    *v21 = 0;
    ++*((_DWORD *)this + 148);
  }
  if (*v19)
  {
    if (*((_QWORD *)this + 70))
      (*(void (**)(_QWORD))(*(_QWORD *)*v19 + 40))(*v19);
    *((_QWORD *)this + 70) = 0;
    *((_QWORD *)this + 67) = 0;
    *((_QWORD *)this + 68) = 0;
    *v19 = 0;
    ++*((_DWORD *)this + 138);
  }
  if (*v17)
  {
    if (*((_QWORD *)this + 65))
      (*(void (**)(_QWORD))(*(_QWORD *)*v17 + 40))(*v17);
    *((_QWORD *)this + 65) = 0;
    *((_QWORD *)this + 62) = 0;
    *((_QWORD *)this + 63) = 0;
    *v17 = 0;
    ++*((_DWORD *)this + 128);
  }
  if (*v35)
  {
    if (*((_QWORD *)this + 60))
      (*(void (**)(_QWORD))(*(_QWORD *)*v35 + 40))(*v35);
    *((_QWORD *)this + 60) = 0;
    *((_QWORD *)this + 57) = 0;
    *((_QWORD *)this + 58) = 0;
    *v35 = 0;
    ++*((_DWORD *)this + 118);
  }
  if (*v36)
  {
    if (*((_QWORD *)this + 55))
      (*(void (**)(_QWORD))(*(_QWORD *)*v36 + 40))(*v36);
    *((_QWORD *)this + 55) = 0;
    *((_QWORD *)this + 52) = 0;
    *((_QWORD *)this + 53) = 0;
    *v36 = 0;
    ++*((_DWORD *)this + 108);
  }
  if (*v37)
  {
    if (*((_QWORD *)this + 50))
      (*(void (**)(_QWORD))(*(_QWORD *)*v37 + 40))(*v37);
    *((_QWORD *)this + 50) = 0;
    *((_QWORD *)this + 47) = 0;
    *((_QWORD *)this + 48) = 0;
    *v37 = 0;
    ++*((_DWORD *)this + 98);
  }
  re::DynamicArray<re::Pair<unsigned long,re::StringID,true>>::deinit((uint64_t)this + 328);
  if (*v38)
  {
    if (*((_QWORD *)this + 40))
      (*(void (**)(_QWORD))(*(_QWORD *)*v38 + 40))(*v38);
    *((_QWORD *)this + 40) = 0;
    *((_QWORD *)this + 37) = 0;
    *((_QWORD *)this + 38) = 0;
    *v38 = 0;
    ++*((_DWORD *)this + 78);
  }
  if (*v39)
  {
    if (*((_QWORD *)this + 35))
      (*(void (**)(_QWORD))(*(_QWORD *)*v39 + 40))(*v39);
    *((_QWORD *)this + 35) = 0;
    *((_QWORD *)this + 32) = 0;
    *((_QWORD *)this + 33) = 0;
    *v39 = 0;
    ++*((_DWORD *)this + 68);
  }
  re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphOperatorDefinition>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 25);
  re::DynamicArray<re::StringID>::deinit((uint64_t)this + 160);
  re::DataArray<re::TypeRegistry::TypeNameAndVersion>::deinit((uint64_t)v40);
  if (*v40)
  {
    if (*((_QWORD *)this + 16))
      (*(void (**)(_QWORD))(*(_QWORD *)*v40 + 40))(*v40);
    *((_QWORD *)this + 16) = 0;
    *((_QWORD *)this + 13) = 0;
    *((_QWORD *)this + 14) = 0;
    *v40 = 0;
    ++*((_DWORD *)this + 30);
  }
  re::DataArray<re::internal::TypeInfoIndex>::deinit((uint64_t)v41);
  if (*v41)
  {
    if (*((_QWORD *)this + 8))
      (*(void (**)(_QWORD))(*(_QWORD *)*v41 + 40))(*v41);
    *((_QWORD *)this + 8) = 0;
    *((_QWORD *)this + 5) = 0;
    *((_QWORD *)this + 6) = 0;
    *v41 = 0;
    ++*((_DWORD *)this + 14);
  }
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  re::TypeRegistry::~TypeRegistry(this);
  JUMPOUT(0x2276933B8);
}

_DWORD *re::TypeRegistry::typeInfo@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  _DWORD *result;
  uint64_t v6;
  unint64_t v7;
  int v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  unsigned int v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  result = (_DWORD *)re::DataArray<re::internal::TypeInfoIndex>::tryGet((uint64_t)(a1 + 4), a2);
  if (result && (v7 = *result & 0xFFFFFF, (*result & 0xFFFFFF) != 0xFFFFFF))
  {
    v8 = HIBYTE(*result);
    switch(v8)
    {
      case 1:
        if (a1[33] <= v7)
        {
          v16 = 0u;
          v17 = 0u;
          v14 = 0u;
          v15 = 0u;
          v13 = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_28:
          v16 = 0u;
          v17 = 0u;
          v14 = 0u;
          v15 = 0u;
          v13 = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_29:
          v16 = 0u;
          v17 = 0u;
          v14 = 0u;
          v15 = 0u;
          v13 = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_30:
          v16 = 0u;
          v17 = 0u;
          v14 = 0u;
          v15 = 0u;
          v13 = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_31:
          v16 = 0u;
          v17 = 0u;
          v14 = 0u;
          v15 = 0u;
          v13 = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_32:
          v16 = 0u;
          v17 = 0u;
          v14 = 0u;
          v15 = 0u;
          v13 = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_33:
          v16 = 0u;
          v17 = 0u;
          v14 = 0u;
          v15 = 0u;
          v13 = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_34:
          v16 = 0u;
          v17 = 0u;
          v14 = 0u;
          v15 = 0u;
          v13 = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_35:
          v16 = 0u;
          v17 = 0u;
          v14 = 0u;
          v15 = 0u;
          v13 = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        v9 = a1[35] + 72 * v7;
        goto LABEL_25;
      case 2:
        v10 = *result & 0xFFFFFF;
        if (a1[38] <= (unint64_t)v7)
          goto LABEL_28;
        v11 = a1[40];
        goto LABEL_19;
      case 3:
        v10 = *result & 0xFFFFFF;
        if (a1[48] <= (unint64_t)v7)
          goto LABEL_29;
        v11 = a1[50];
        goto LABEL_19;
      case 4:
        v10 = *result & 0xFFFFFF;
        if (a1[53] <= (unint64_t)v7)
          goto LABEL_30;
        v11 = a1[55];
        goto LABEL_19;
      case 5:
        if (a1[58] <= (unint64_t)v7)
          goto LABEL_31;
        v9 = a1[60] + ((unint64_t)v7 << 7);
        goto LABEL_25;
      case 6:
        v10 = *result & 0xFFFFFF;
        if (a1[63] <= (unint64_t)v7)
          goto LABEL_32;
        v11 = a1[65];
        v12 = 160;
        break;
      case 7:
        v10 = *result & 0xFFFFFF;
        if (a1[68] <= (unint64_t)v7)
          goto LABEL_33;
        v11 = a1[70];
LABEL_19:
        v12 = 96;
        break;
      case 8:
        v10 = *result & 0xFFFFFF;
        if (a1[78] <= (unint64_t)v7)
          goto LABEL_34;
        v11 = a1[80];
        v12 = 152;
        break;
      case 9:
        v10 = *result & 0xFFFFFF;
        if (a1[93] <= (unint64_t)v7)
          goto LABEL_35;
        v11 = a1[95];
        v12 = 104;
        break;
      default:
        re::internal::assertLog((re::internal *)4, v6, "assertion failure: '%s' (%s:line %i) Invalid type category.", "!\"Unreachable code\"", "typeInfo", 310);
        _os_crash();
        __break(1u);
        JUMPOUT(0x225B79620);
    }
    v9 = v11 + v10 * (unint64_t)v12;
LABEL_25:
    re::TypeInfo::TypeInfo((uint64_t)&v13, (uint64_t)a1, v8, v9);
    *a3 = 1;
    return (_DWORD *)re::TypeInfo::TypeInfo((uint64_t)(a3 + 8), (uint64_t)&v13);
  }
  else
  {
    *a3 = 0;
  }
  return result;
}

uint64_t re::DataArray<re::internal::TypeInfoIndex>::deinit(uint64_t result)
{
  unint64_t v1;
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  BOOL v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  unint64_t v19;
  __int16 v20;
  unint64_t v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  if (!*(_DWORD *)(result + 44))
    return result;
  v2 = (_QWORD *)result;
  v11 = (_QWORD *)result;
  if (*(_DWORD *)(result + 40))
  {
    LODWORD(v12) = 0;
    if (!*(_QWORD *)(result + 16))
      goto LABEL_36;
    v3 = (_QWORD *)result;
    if (!**(_DWORD **)(*(_QWORD *)(result + 32) + 8))
    {
      re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::increment(&v11);
      v3 = v11;
    }
  }
  else
  {
    LODWORD(v12) = -1;
    v3 = (_QWORD *)result;
  }
  v11 = v3;
  v4 = (unsigned __int16)v12;
  if (v3 != v2 || ((unsigned __int16)v12 == 0xFFFFLL ? (v5 = (v12 & 0xFFFF0000) == 4294901760) : (v5 = 0), !v5))
  {
    v6 = WORD1(v12);
    do
    {
      v7 = v3[2];
      if (v7 <= v6)
        goto LABEL_35;
      re::DataArray<re::internal::TypeInfoIndex>::destroy((uint64_t)v2, ((unint64_t)(*(_DWORD *)(*(_QWORD *)(v3[4] + 16 * v6 + 8) + 4 * v4) & 0xFFFFFF) << 32) | (v6 << 16) | v4);
      re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::increment(&v11);
      v3 = v11;
      v4 = (unsigned __int16)v12;
      v6 = WORD1(v12);
    }
    while (v11 != v2 || (unsigned __int16)v12 != 0xFFFFLL || WORD1(v12) != 0xFFFFLL);
  }
  v8 = v2[2];
  v6 = v8 - 1;
  if (v8 == 1)
    goto LABEL_26;
  v7 = 16 * v8 - 16;
  do
  {
    if (v8 <= v6)
    {
      v11 = 0;
      v26 = 0u;
      v24 = 0u;
      v25 = 0u;
      v22 = 0u;
      v23 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v14 = 136315906;
      v15 = "operator[]";
      v16 = 1024;
      v17 = 789;
      v18 = 2048;
      v19 = v6;
      v20 = 2048;
      v21 = v8;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_34:
      v11 = 0;
      v26 = 0u;
      v24 = 0u;
      v25 = 0u;
      v22 = 0u;
      v23 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v14 = 136315906;
      v15 = "removeAt";
      v16 = 1024;
      v17 = 931;
      v18 = 2048;
      v19 = v6;
      v20 = 2048;
      v21 = v1;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_35:
      v13 = 0;
      v26 = 0u;
      v24 = 0u;
      v25 = 0u;
      v22 = 0u;
      v23 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v14 = 136315906;
      v15 = "operator[]";
      v16 = 1024;
      v17 = 797;
      v18 = 2048;
      v19 = v6;
      v20 = 2048;
      v21 = v7;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_36:
      v13 = 0;
      v26 = 0u;
      v24 = 0u;
      v25 = 0u;
      v22 = 0u;
      v23 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v14 = 136315906;
      v15 = "operator[]";
      v16 = 1024;
      v17 = 797;
      v18 = 2048;
      v19 = 0;
      v20 = 2048;
      v21 = 0;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    v9 = (_QWORD *)(v2[4] + v7);
    (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*v2 + 40))(*v2, *v9);
    (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*v2 + 40))(*v2, v9[1]);
    v1 = v2[2];
    if (v1 <= v6)
      goto LABEL_34;
    v8 = v1 - 1;
    if (v1 - 1 > v6)
    {
      *(_OWORD *)(v2[4] + v7) = *(_OWORD *)(v2[4] + 16 * v1 - 16);
      v8 = v2[2] - 1;
    }
    v2[2] = v8;
    ++*((_DWORD *)v2 + 6);
    v7 -= 16;
    --v6;
  }
  while (v6);
  v2[6] = 0xFFFFFFFF00000000;
  if (!v8)
  {
    v11 = 0;
    v26 = 0u;
    v24 = 0u;
    v25 = 0u;
    v22 = 0u;
    v23 = 0u;
    v2 = (_QWORD *)MEMORY[0x24BDACB70];
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v14 = 136315906;
    v15 = "operator[]";
    v16 = 1024;
    v17 = 789;
    v18 = 2048;
    v19 = 0;
    v20 = 2048;
    v21 = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_26:
    v2[6] = 0xFFFFFFFF00000000;
  }
  v10 = (_QWORD *)v2[4];
  (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*v2 + 40))(*v2, *v10);
  (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*v2 + 40))(*v2, v10[1]);
  result = *v2;
  if (*v2)
  {
    if (v2[4])
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    v2[4] = 0;
    v2[1] = 0;
    v2[2] = 0;
    *v2 = 0;
    ++*((_DWORD *)v2 + 6);
  }
  *((_DWORD *)v2 + 11) = 0;
  return result;
}

uint64_t re::DataArray<re::TypeRegistry::TypeNameAndVersion>::deinit(uint64_t result)
{
  unint64_t v1;
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  BOOL v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  unint64_t v19;
  __int16 v20;
  unint64_t v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  if (!*(_DWORD *)(result + 44))
    return result;
  v2 = (_QWORD *)result;
  v11 = (_QWORD *)result;
  if (*(_DWORD *)(result + 40))
  {
    LODWORD(v12) = 0;
    if (!*(_QWORD *)(result + 16))
      goto LABEL_36;
    v3 = (_QWORD *)result;
    if (!**(_DWORD **)(*(_QWORD *)(result + 32) + 8))
    {
      re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::increment(&v11);
      v3 = v11;
    }
  }
  else
  {
    LODWORD(v12) = -1;
    v3 = (_QWORD *)result;
  }
  v11 = v3;
  v4 = (unsigned __int16)v12;
  if (v3 != v2 || ((unsigned __int16)v12 == 0xFFFFLL ? (v5 = (v12 & 0xFFFF0000) == 4294901760) : (v5 = 0), !v5))
  {
    v6 = WORD1(v12);
    do
    {
      v7 = v3[2];
      if (v7 <= v6)
        goto LABEL_35;
      re::DataArray<re::TypeRegistry::TypeNameAndVersion>::destroy((uint64_t)v2, ((unint64_t)(*(_DWORD *)(*(_QWORD *)(v3[4] + 16 * v6 + 8) + 4 * v4) & 0xFFFFFF) << 32) | (v6 << 16) | v4);
      re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::increment(&v11);
      v3 = v11;
      v4 = (unsigned __int16)v12;
      v6 = WORD1(v12);
    }
    while (v11 != v2 || (unsigned __int16)v12 != 0xFFFFLL || WORD1(v12) != 0xFFFFLL);
  }
  v8 = v2[2];
  v6 = v8 - 1;
  if (v8 == 1)
    goto LABEL_26;
  v7 = 16 * v8 - 16;
  do
  {
    if (v8 <= v6)
    {
      v11 = 0;
      v26 = 0u;
      v24 = 0u;
      v25 = 0u;
      v22 = 0u;
      v23 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v14 = 136315906;
      v15 = "operator[]";
      v16 = 1024;
      v17 = 789;
      v18 = 2048;
      v19 = v6;
      v20 = 2048;
      v21 = v8;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_34:
      v11 = 0;
      v26 = 0u;
      v24 = 0u;
      v25 = 0u;
      v22 = 0u;
      v23 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v14 = 136315906;
      v15 = "removeAt";
      v16 = 1024;
      v17 = 931;
      v18 = 2048;
      v19 = v6;
      v20 = 2048;
      v21 = v1;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_35:
      v13 = 0;
      v26 = 0u;
      v24 = 0u;
      v25 = 0u;
      v22 = 0u;
      v23 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v14 = 136315906;
      v15 = "operator[]";
      v16 = 1024;
      v17 = 797;
      v18 = 2048;
      v19 = v6;
      v20 = 2048;
      v21 = v7;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_36:
      v13 = 0;
      v26 = 0u;
      v24 = 0u;
      v25 = 0u;
      v22 = 0u;
      v23 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v14 = 136315906;
      v15 = "operator[]";
      v16 = 1024;
      v17 = 797;
      v18 = 2048;
      v19 = 0;
      v20 = 2048;
      v21 = 0;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    v9 = (_QWORD *)(v2[4] + v7);
    (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*v2 + 40))(*v2, *v9);
    (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*v2 + 40))(*v2, v9[1]);
    v1 = v2[2];
    if (v1 <= v6)
      goto LABEL_34;
    v8 = v1 - 1;
    if (v1 - 1 > v6)
    {
      *(_OWORD *)(v2[4] + v7) = *(_OWORD *)(v2[4] + 16 * v1 - 16);
      v8 = v2[2] - 1;
    }
    v2[2] = v8;
    ++*((_DWORD *)v2 + 6);
    v7 -= 16;
    --v6;
  }
  while (v6);
  v2[6] = 0xFFFFFFFF00000000;
  if (!v8)
  {
    v11 = 0;
    v26 = 0u;
    v24 = 0u;
    v25 = 0u;
    v22 = 0u;
    v23 = 0u;
    v2 = (_QWORD *)MEMORY[0x24BDACB70];
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v14 = 136315906;
    v15 = "operator[]";
    v16 = 1024;
    v17 = 789;
    v18 = 2048;
    v19 = 0;
    v20 = 2048;
    v21 = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_26:
    v2[6] = 0xFFFFFFFF00000000;
  }
  v10 = (_QWORD *)v2[4];
  (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*v2 + 40))(*v2, *v10);
  (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*v2 + 40))(*v2, v10[1]);
  result = *v2;
  if (*v2)
  {
    if (v2[4])
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    v2[4] = 0;
    v2[1] = 0;
    v2[2] = 0;
    *v2 = 0;
    ++*((_DWORD *)v2 + 6);
  }
  *((_DWORD *)v2 + 11) = 0;
  return result;
}

uint64_t re::DynamicArray<re::internal::ObjectTypeInfo>::deinit(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  re::StringID *v6;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 152 * v4;
        v6 = (re::StringID *)(v3 + 104);
        do
        {
          re::StringID::destroyString(v6);
          v6 = (re::StringID *)((char *)v6 + 152);
          v5 -= 152;
        }
        while (v5);
        result = *(_QWORD *)a1;
        v3 = *(_QWORD *)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

double re::TypeRegistry::declareType@<D0>(uint64_t a1@<X0>, int a2@<W1>, StringID *a3@<X2>, unsigned int a4@<W3>, char a5@<W4>, _QWORD *a6@<X8>)
{
  unint64_t v6;
  _QWORD *v13;
  uint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  re *v17;
  unsigned int v18;
  char v19;
  uint64_t v20;
  int v21;
  int v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  int *v27;
  _QWORD *v28;
  unint64_t v29;
  int v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _QWORD *v35;
  re::StringID *v36;
  _QWORD *v37;
  unint64_t v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;
  uint64_t v46;
  const char *v47;
  double result;
  NSObject *v49;
  char *var1;
  uint64_t v51;
  int v52;
  uint64_t v53;
  re *v54;
  int v55;
  NSObject *v56;
  _QWORD *v57;
  char *v58;
  uint64_t v59;
  int v60;
  unsigned __int8 *v61;
  NSObject *v62;
  char *v63;
  _QWORD *v64;
  unint64_t v65;
  StringID v66;
  uint64_t v67;
  int v68;
  const char *v69;
  __int16 v70;
  int v71;
  __int16 v72;
  unint64_t v73;
  __int16 v74;
  unint64_t v75;
  uint8_t buf[48];
  __int128 v77;
  __int128 v78;
  uint64_t v79;

  v79 = *MEMORY[0x24BDAC8D0];
  v13 = (_QWORD *)(a1 + 200);
  v14 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(a1 + 200, a3);
  v15 = 1;
  if (!v14)
  {
    v16 = 0xFFFFFFFFLL;
    goto LABEL_7;
  }
  v16 = *v14;
  if (!a1)
  {
LABEL_7:
    v19 = 1;
    goto LABEL_8;
  }
  if ((a5 & 1) == 0)
  {
    v6 = a1 + 96;
    v17 = (re *)re::DataArray<re::TextureAtlasTile>::tryGet(a1 + 96, v16);
    v18 = v17 ? *((_DWORD *)v17 + 4) : -1;
    if (v18 > a4)
    {
      v49 = *re::foundationIntrospectionLogObjects(v17);
      if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
      {
        v64 = a6;
        var1 = a3->var1;
        v51 = re::DataArray<re::TextureAtlasTile>::tryGet(a1 + 96, v16);
        if (v51)
          v52 = *(_DWORD *)(v51 + 16);
        else
          v52 = -1;
        *(_DWORD *)buf = 136315906;
        *(_QWORD *)&buf[4] = var1;
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = a4;
        *(_WORD *)&buf[18] = 2080;
        *(_QWORD *)&buf[20] = var1;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = v52;
        _os_log_impl(&dword_224FE9000, v49, OS_LOG_TYPE_DEFAULT, "Type \"%s\" version %u is defined after type \"%s\" version %u.", buf, 0x22u);
        a6 = v64;
      }
    }
  }
  v53 = a1 + 96;
  v54 = (re *)re::DataArray<re::TextureAtlasTile>::tryGet(a1 + 96, v16);
  if (v54)
    v55 = *((_DWORD *)v54 + 4);
  else
    v55 = -1;
  if (v55 != a4)
  {
    v61 = (unsigned __int8 *)re::DataArray<re::internal::TypeInfoIndex>::tryGet(a1 + 32, v16);
    if (v61[3] != a2)
    {
      v62 = *re::foundationIntrospectionLogObjects((re *)v61);
      if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
      {
        v63 = a3->var1;
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)&buf[4] = v63;
        _os_log_error_impl(&dword_224FE9000, v62, OS_LOG_TYPE_ERROR, "An type with the same name (\"%s\") but with a different type category has already been declared.", buf, 0xCu);
      }
      goto LABEL_69;
    }
    v19 = 0;
LABEL_8:
    re::TypeRegistry::makeStringID((re::TypeRegistry *)a1, a3, (re::StringID *)&v66);
    v21 = *(_DWORD *)(a1 + 88);
    if ((v21 + 1) >> 24)
      v22 = 1;
    else
      v22 = v21 + 1;
    *(_DWORD *)(a1 + 88) = v22;
    v23 = *(unsigned __int16 *)(a1 + 84);
    v24 = *(unsigned __int16 *)(a1 + 86);
    if (v23 == 0xFFFF && (_DWORD)v24 == 0xFFFF)
    {
      if (*(_DWORD *)(a1 + 80) >= *(_DWORD *)(a1 + 76))
        re::DataArray<re::internal::TypeInfoIndex>::allocBlock((_QWORD *)(a1 + 32));
      v25 = *(_QWORD *)(a1 + 48);
      v24 = (unsigned __int16)(v25 - 1);
      if (v25)
      {
        v23 = *(unsigned int *)(a1 + 80);
        if (v23 < 0x10000)
        {
          v26 = (_QWORD *)(*(_QWORD *)(a1 + 64) + 16 * v24);
          *(_DWORD *)(a1 + 80) = v23 + 1;
          *(_DWORD *)(v26[1] + 4 * v23) = *(_DWORD *)(a1 + 88);
          v27 = (int *)(*v26 + 4 * v23);
LABEL_20:
          ++*(_DWORD *)(a1 + 72);
          *v27 = (a2 << 24) | 0xFFFFFF;
          v29 = (v24 << 16) | ((unint64_t)(*(_DWORD *)(a1 + 88) & 0xFFFFFF) << 32) | v23;
          v65 = v29;
          v30 = *(_DWORD *)(a1 + 152);
          if ((v30 + 1) >> 24)
            v31 = 1;
          else
            v31 = v30 + 1;
          *(_DWORD *)(a1 + 152) = v31;
          v32 = *(unsigned __int16 *)(a1 + 148);
          v6 = *(unsigned __int16 *)(a1 + 150);
          if (v32 != 0xFFFF || (_DWORD)v6 != 0xFFFF)
          {
            v15 = *(_QWORD *)(a1 + 112);
            if (v15 > v6)
            {
              v37 = (_QWORD *)(*(_QWORD *)(a1 + 128) + 16 * v6);
              *(_DWORD *)(v37[1] + 4 * v32) = v31;
              v36 = (re::StringID *)(*v37 + 24 * v32);
              *(_DWORD *)(a1 + 148) = *(_DWORD *)v36;
              goto LABEL_32;
            }
            goto LABEL_76;
          }
          if (*(_DWORD *)(a1 + 144) >= *(_DWORD *)(a1 + 140))
            re::DataArray<MetalHeap::TextureEntry>::allocBlock((_QWORD *)(a1 + 96));
          v33 = *(_QWORD *)(a1 + 112);
          v6 = (unsigned __int16)(v33 - 1);
          if (v33)
          {
            v34 = *(unsigned int *)(a1 + 144);
            if (v34 < 0x10000)
            {
              v35 = (_QWORD *)(*(_QWORD *)(a1 + 128) + 16 * v6);
              *(_DWORD *)(a1 + 144) = v34 + 1;
              *(_DWORD *)(v35[1] + 4 * v34) = *(_DWORD *)(a1 + 152);
              v36 = (re::StringID *)(*v35 + 24 * v34);
LABEL_32:
              ++*(_DWORD *)(a1 + 136);
              *((_DWORD *)re::StringID::StringID(v36, &v66) + 4) = a4;
              v38 = *(_QWORD *)&v66.var0;
              if (*(_QWORD *)&v66.var0 >= 0xFFFFFFFFFFFFFFFELL && (*(_BYTE *)&v66.var0 & 1) == 0 && !*v66.var1)
                goto LABEL_49;
              if ((v19 & 1) == 0)
              {
                v39 = re::DataArray<re::TextureAtlasTile>::tryGet(a1 + 96, v16);
                if (!v39 || *(_DWORD *)(v39 + 16) >= a4)
                  goto LABEL_49;
                v38 = *(_QWORD *)&v66.var0;
              }
              v40 = 0x94D049BB133111EBLL
                  * ((0xBF58476D1CE4E5B9 * ((v38 >> 31) ^ (v38 >> 1))) ^ ((0xBF58476D1CE4E5B9
                                                                           * ((v38 >> 31) ^ (v38 >> 1))) >> 27));
              v41 = v40 ^ (v40 >> 31);
              if (*v13)
              {
                v42 = v41 % *(unsigned int *)(a1 + 224);
                v43 = *(unsigned int *)(*(_QWORD *)(a1 + 208) + 4 * v42);
                if ((_DWORD)v43 != 0x7FFFFFFF)
                {
                  v44 = *(_QWORD *)(a1 + 216);
                  v45 = v66.var1;
                  while (1)
                  {
                    v46 = v44 + 32 * v43;
                    if ((*(_QWORD *)(v46 + 8) ^ v38) <= 1)
                    {
                      v47 = *(const char **)(v46 + 16);
                      if (v47 == v45 || !strcmp(v47, v45))
                        break;
                    }
                    v43 = *(_DWORD *)(v44 + 32 * v43) & 0x7FFFFFFF;
                    if (v43 == 0x7FFFFFFF)
                      goto LABEL_48;
                  }
                  *(_QWORD *)(v44 + 32 * v43 + 24) = v29;
                  ++*(_DWORD *)(a1 + 240);
                  goto LABEL_49;
                }
              }
              else
              {
                LODWORD(v42) = 0;
              }
LABEL_48:
              re::HashTable<re::StringID,re::DataArrayHandle<re::internal::TypeInfoIndex>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addEmplace<re::DataArrayHandle<re::internal::TypeInfoIndex>&>((uint64_t)v13, v42, v41, &v66, &v65);
              ++*(_DWORD *)(a1 + 240);
              v29 = v65;
LABEL_49:
              ++*(_DWORD *)(a1 + 24);
              *a6 = a1;
              a6[1] = v29;
              re::StringID::destroyString((re::StringID *)&v66);
              return result;
            }
LABEL_77:
            re::internal::assertLog((re::internal *)5, v20, "assertion failure: '%s' (%s:line %i) m_tailBlockLinearAllocationCount (%u) is too large for a 16-bit unsigned integer", "!overflow", "create", 601, v34);
            _os_crash();
            __break(1u);
          }
LABEL_75:
          v67 = 0;
          v77 = 0u;
          v78 = 0u;
          memset(buf, 0, sizeof(buf));
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          v68 = 136315906;
          v69 = "operator[]";
          v70 = 1024;
          v71 = 789;
          v72 = 2048;
          v73 = v6;
          v74 = 2048;
          v75 = 0;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_76:
          v67 = 0;
          v77 = 0u;
          v78 = 0u;
          memset(buf, 0, sizeof(buf));
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          v68 = 136315906;
          v69 = "operator[]";
          v70 = 1024;
          v71 = 789;
          v72 = 2048;
          v73 = v6;
          v74 = 2048;
          v75 = v15;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
          goto LABEL_77;
        }
LABEL_74:
        re::internal::assertLog((re::internal *)5, v20, "assertion failure: '%s' (%s:line %i) m_tailBlockLinearAllocationCount (%u) is too large for a 16-bit unsigned integer", "!overflow", "create", 601, v23);
        _os_crash();
        __break(1u);
        goto LABEL_75;
      }
      v67 = 0;
      v77 = 0u;
      v78 = 0u;
      memset(buf, 0, sizeof(buf));
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v68 = 136315906;
      v69 = "operator[]";
      v70 = 1024;
      v71 = 789;
      v72 = 2048;
      v73 = v24;
      v74 = 2048;
      v75 = 0;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    else
    {
      v6 = *(_QWORD *)(a1 + 48);
      if (v6 > v24)
      {
        v28 = (_QWORD *)(*(_QWORD *)(a1 + 64) + 16 * v24);
        *(_DWORD *)(v28[1] + 4 * v23) = v22;
        v27 = (int *)(*v28 + 4 * v23);
        *(_DWORD *)(a1 + 84) = *v27;
        goto LABEL_20;
      }
    }
    v67 = 0;
    v77 = 0u;
    v78 = 0u;
    memset(buf, 0, sizeof(buf));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v68 = 136315906;
    v69 = "operator[]";
    v70 = 1024;
    v71 = 789;
    v72 = 2048;
    v73 = v24;
    v74 = 2048;
    v75 = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_74;
  }
  v56 = *re::foundationIntrospectionLogObjects(v54);
  if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
  {
    v57 = a6;
    v58 = a3->var1;
    v59 = re::DataArray<re::TextureAtlasTile>::tryGet(v53, v16);
    if (v59)
      v60 = *(_DWORD *)(v59 + 16);
    else
      v60 = -1;
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = v58;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v60;
    _os_log_error_impl(&dword_224FE9000, v56, OS_LOG_TYPE_ERROR, "Duplicate types. A type with the same name (\"%s\") and version (%u) has already been declared.", buf, 0x12u);
    a6 = v57;
  }
LABEL_69:
  *a6 = 0;
  *(_QWORD *)&result = 0xFFFFFFFFLL;
  a6[1] = 0xFFFFFFFFLL;
  return result;
}

re::StringID *re::TypeRegistry::makeStringID@<X0>(re::TypeRegistry *this@<X0>, const StringID *a2@<X1>, re::StringID *a3@<X8>)
{
  if ((*(_BYTE *)&a2->var0 & 1) != 0)
    return re::TypeRegistry::makeStringID(this, a2->var1, a3);
  else
    return re::StringID::StringID(a3, a2);
}

void re::TypeRegistry::declareTypeAlias(re::TypeRegistry *this, uint64_t a2, const StringID *a3)
{
  StringID v5;

  if (*(_QWORD *)a2)
  {
    if (*(re::TypeRegistry **)a2 == this)
    {
      re::TypeRegistry::makeStringID(this, a3, (re::StringID *)&v5);
      re::DynamicArray<re::StringID>::add((re::TypeRegistry *)((char *)this + 160), &v5);
      re::HashTable<re::StringID,re::DataArrayHandle<re::internal::TypeInfoIndex>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addNew<re::DataArrayHandle<re::internal::TypeInfoIndex>&>((uint64_t)this + 200, &v5, (_QWORD *)(a2 + 8));
      ++*((_DWORD *)this + 6);
      re::StringID::destroyString((re::StringID *)&v5);
      return;
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, a3, "assertion failure: '%s' (%s:line %i) Invalid type ID.", "typeID.isValid()", "declareTypeAlias", 144);
    _os_crash();
    __break(1u);
  }
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Wrong type registry.", "typeID.registry() == this", "declareTypeAlias", 145);
  _os_crash();
  __break(1u);
}

uint64_t re::HashTable<re::StringID,re::DataArrayHandle<re::internal::TypeInfoIndex>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addNew<re::DataArrayHandle<re::internal::TypeInfoIndex>&>(uint64_t a1, StringID *a2, _QWORD *a3)
{
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;

  v6 = 0xBF58476D1CE4E5B9 * ((*(_QWORD *)&a2->var0 >> 31) ^ (*(_QWORD *)&a2->var0 >> 1));
  v7 = (0x94D049BB133111EBLL * (v6 ^ (v6 >> 27))) ^ ((0x94D049BB133111EBLL * (v6 ^ (v6 >> 27))) >> 31);
  if (!*(_QWORD *)a1)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  v8 = v7 % *(unsigned int *)(a1 + 24);
  v9 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v8);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
LABEL_8:
    v12 = re::HashTable<re::StringID,re::DataArrayHandle<re::internal::TypeInfoIndex>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addEmplace<re::DataArrayHandle<re::internal::TypeInfoIndex>&>(a1, v8, v7, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    return *(_QWORD *)(a1 + 16) + 32 * v12 + 24;
  }
  v10 = *(_QWORD *)(a1 + 16);
  while (1)
  {
    v11 = v10 + 32 * v9;
    if (re::StringID::operator==((_QWORD *)(v11 + 8), a2))
      return v11 + 24;
    v9 = *(_DWORD *)(v10 + 32 * v9) & 0x7FFFFFFF;
    if (v9 == 0x7FFFFFFF)
      goto LABEL_8;
  }
}

void re::TypeRegistry::declareTypeAlias(re::TypeRegistry *this, const re::StringID *a2, const StringID *a3)
{
  uint64_t *v5;
  re::TypeRegistry *v6;
  re::TypeRegistry *v7;
  uint64_t v8;

  v5 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)this + 200, a2);
  if (v5)
  {
    v8 = *v5;
    v6 = this;
  }
  else
  {
    v6 = 0;
    v8 = 0xFFFFFFFFLL;
  }
  v7 = v6;
  re::TypeRegistry::declareTypeAlias(this, (uint64_t)&v7, a3);
}

BOOL re::HashTable<re::StringID,re::DataArrayHandle<re::internal::TypeInfoIndex>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::containsKey(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v2 = 0x7FFFFFFFLL;
  if (*(_QWORD *)a1)
  {
    v4 = 0xBF58476D1CE4E5B9 * ((*a2 >> 31) ^ (*a2 >> 1));
    v5 = *(unsigned int *)(*(_QWORD *)(a1 + 8)
                         + 4
                         * (((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) ^ ((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) >> 31))
                          % *(unsigned int *)(a1 + 24)));
    if ((_DWORD)v5 != 0x7FFFFFFF)
    {
      v6 = *(_QWORD *)(a1 + 16);
      v2 = 0x7FFFFFFFLL;
      while (!re::StringID::operator==((_QWORD *)(v6 + 32 * v5 + 8), a2))
      {
        v5 = *(_DWORD *)(v6 + 32 * v5) & 0x7FFFFFFF;
        if (v5 == 0x7FFFFFFF)
          return v2 != 0x7FFFFFFF;
      }
      v2 = v5;
    }
  }
  return v2 != 0x7FFFFFFF;
}

double re::TypeRegistry::typeID@<D0>(re::TypeRegistry *this@<X0>, const re::StringID *a2@<X1>, int a3@<W2>, _QWORD *a4@<X8>)
{
  uint64_t *v7;
  unint64_t TypeWithVersion;
  double result;

  v7 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)this + 200, a2);
  if (v7
    && (TypeWithVersion = re::TypeRegistry::findTypeWithVersion((uint64_t)this, *v7, a3),
        (TypeWithVersion & 0xFFFFFF00000000) != 0))
  {
    *a4 = this;
    a4[1] = TypeWithVersion;
  }
  else
  {
    *a4 = 0;
    *(_QWORD *)&result = 0xFFFFFFFFLL;
    a4[1] = 0xFFFFFFFFLL;
  }
  return result;
}

unint64_t re::TypeRegistry::findTypeWithVersion(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4;
  uint64_t v6;
  int v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v19;
  int v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char v27[8];
  _QWORD *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  const char *v34;
  __int16 v35;
  int v36;
  __int16 v37;
  unint64_t v38;
  __int16 v39;
  unint64_t v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  uint64_t v46;

  v4 = a2;
  v46 = *MEMORY[0x24BDAC8D0];
  re::TypeRegistry::typeInfo((_QWORD *)a1, a2, v27);
  if (v27[0])
  {
    LODWORD(v4) = -1;
    while (1)
    {
      v6 = re::DataArray<re::TextureAtlasTile>::tryGet((uint64_t)(v28 + 12), *(_QWORD *)v29);
      v7 = v6 ? *(_DWORD *)(v6 + 16) : -1;
      if (v7 == a3)
        break;
      if ((*(_DWORD *)(v29 + 60) & 0xFFFFFF) != 0)
        re::TypeRegistry::typeInfo(v28, *(_QWORD *)(v29 + 56), &v41);
      else
        LOBYTE(v41) = 0;
      re::Optional<re::TypeInfo>::operator=(v27, (unsigned __int8 *)&v41);
      if (!v27[0])
      {
        v8 = 0;
        return v8 | v4;
      }
    }
    v4 = *(_QWORD *)v29;
    goto LABEL_19;
  }
  v9 = a1 + 96;
  v10 = re::DataArray<re::TextureAtlasTile>::tryGet(a1 + 96, v4);
  if (!v10)
    goto LABEL_33;
  v11 = (_QWORD *)v10;
  if (*(_DWORD *)(v10 + 16) != a3)
  {
    v30 = a1 + 96;
    if (*(_DWORD *)(a1 + 136))
    {
      LODWORD(v31) = 0;
      if (!*(_QWORD *)(a1 + 112))
        goto LABEL_46;
      v12 = a1 + 96;
      if (!**(_DWORD **)(*(_QWORD *)(a1 + 128) + 8))
      {
        re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::increment(&v30);
        v12 = v30;
      }
    }
    else
    {
      LODWORD(v31) = -1;
      v12 = a1 + 96;
    }
    v25 = v12;
    v26 = v31;
    v13 = (unsigned __int16)v31;
    if (v9 != v12 || (unsigned __int16)v31 != 0xFFFFLL || (v31 & 0xFFFF0000) != 0xFFFF0000)
    {
      v14 = WORD1(v31);
      while (1)
      {
        v15 = *(_QWORD *)(v12 + 16);
        if (v15 <= v14)
          goto LABEL_45;
        v14 = *(_QWORD *)(*(_QWORD *)(v12 + 32) + 16 * v14) + 24 * v13;
        if (re::StringID::operator==((_QWORD *)v14, v11) && *(_DWORD *)(v14 + 16) == a3)
          break;
        re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::increment(&v25);
        v12 = v25;
        v13 = (unsigned __int16)v26;
        v14 = WORD1(v26);
        if (v25 == v9 && (unsigned __int16)v26 == 0xFFFFLL && WORD1(v26) == 0xFFFFLL)
          goto LABEL_33;
      }
      v19 = *(_QWORD *)(a1 + 112);
      if (!v19)
      {
LABEL_41:
        re::internal::assertLog((re::internal *)4, v16, "assertion failure: '%s' (%s:line %i) element isn't in data array", "!\"Unreachable code\"", "handle", 707);
        _os_crash();
        __break(1u);
LABEL_42:
        if (v24 < 0x10000)
        {
          LODWORD(v4) = v20 & 0xFFFF0000 | v24;
          v8 = ((unint64_t)(*(_DWORD *)(*v22 + 4 * v24) & 0xFFFFFF) << 32) & 0xFFFFFF00000000 | v24 & 0xFFFFFF00000000;
          return v8 | v4;
        }
LABEL_47:
        re::internal::assertLog((re::internal *)5, v16, "assertion failure: '%s' (%s:line %i) arrayIndex (%zu) is too large for a 16-bit unsigned integer", "!overflow", "handle", 700, v24);
        _os_crash();
        __break(1u);
      }
      v20 = 0;
      v21 = 0;
      v22 = (_QWORD *)(*(_QWORD *)(a1 + 128) + 8);
      while (v21 != 0x10000)
      {
        v23 = v14 - *(v22 - 1);
        if (v23 >= -23)
        {
          v24 = 0xAAAAAAAAAAAAAAABLL * (v23 >> 3);
          if (v24 < *(unsigned int *)(a1 + 140))
            goto LABEL_42;
        }
        ++v21;
        v20 += 0x10000;
        v22 += 2;
        if (v19 == v21)
          goto LABEL_41;
      }
      re::internal::assertLog((re::internal *)5, v16, "assertion failure: '%s' (%s:line %i) blockIndex (%zu) is too large for a 16-bit unsigned integer", "!overflow", "handle", 692, 0x10000);
      _os_crash();
      __break(1u);
LABEL_45:
      v30 = 0;
      v44 = 0u;
      v45 = 0u;
      v42 = 0u;
      v43 = 0u;
      v41 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v33 = 136315906;
      v34 = "operator[]";
      v35 = 1024;
      v36 = 797;
      v37 = 2048;
      v38 = v14;
      v39 = 2048;
      v40 = v15;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_46:
      v32 = 0;
      v44 = 0u;
      v45 = 0u;
      v42 = 0u;
      v43 = 0u;
      v41 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v33 = 136315906;
      v34 = "operator[]";
      v35 = 1024;
      v36 = 797;
      v37 = 2048;
      v38 = 0;
      v39 = 2048;
      v40 = 0;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_47;
    }
LABEL_33:
    v8 = 0;
    LODWORD(v4) = -1;
    return v8 | v4;
  }
LABEL_19:
  v8 = v4 & 0xFFFFFFFF00000000;
  return v8 | v4;
}

void re::TypeRegistry::typeInfo(re *a1@<X0>, re **a2@<X1>, _BYTE *a3@<X8>)
{
  NSObject *v4;
  uint8_t v5[16];

  if (!*a2)
    goto LABEL_5;
  if (*a2 != a1)
  {
    v4 = *re::foundationIntrospectionLogObjects(a1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v5 = 0;
      _os_log_impl(&dword_224FE9000, v4, OS_LOG_TYPE_DEFAULT, "Invalid type ID. Type was registered in a different type registry.", v5, 2u);
    }
LABEL_5:
    *a3 = 0;
    return;
  }
  re::TypeRegistry::typeInfo(a1, (uint64_t)a2[1], a3);
}

uint64_t *re::TypeRegistry::typeInfo@<X0>(re::TypeRegistry *this@<X0>, const re::StringID *a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t *result;

  result = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)this + 200, a2);
  if (result)
    return (uint64_t *)re::TypeRegistry::typeInfo(this, *result, a3);
  *a3 = 0;
  return result;
}

_anonymous_namespace_ *re::TypeRegistry::typeName(_anonymous_namespace_ *result, _QWORD *a2)
{
  if (!*a2
    || (result = (_anonymous_namespace_ *)re::DataArray<re::TextureAtlasTile>::tryGet((uint64_t)result + 96, a2[1])) == 0)
  {
  }
  return result;
}

uint64_t re::TypeRegistry::typeInfoChecked@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  _BYTE v5[8];
  uint64_t v6;

  re::TypeRegistry::typeInfo(a1, a2, v5);
  return re::TypeInfo::TypeInfo(a3, (uint64_t)&v6);
}

uint64_t *re::TypeRegistry::typeName(uint64_t a1, uint64_t a2)
{
  uint64_t *result;

  result = (uint64_t *)re::DataArray<re::TextureAtlasTile>::tryGet(a1 + 96, a2);
  if (!result)
  {
  }
  return result;
}

void `anonymous namespace'::invalidTypeName(_anonymous_namespace_ *this)
{
  unsigned __int8 v1;

  if ((v1 & 1) == 0)
  {
    {
    }
  }
}

void re::TypeRegistry::setGetActualType(re *a1, re **a2, uint64_t a3)
{
  uint64_t v4;
  _BYTE v5[24];
  uint64_t v6;

  re::TypeRegistry::typeInfo(a1, a2, v5);
  if (v5[0])
  {
    *(_QWORD *)(v6 + 144) = a3;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v4, "assertion failure: '%s' (%s:line %i) Type has been forward declared but type information is missing.", "type", "setGetActualType", 399);
    _os_crash();
    __break(1u);
  }
}

void re::TypeRegistry::overridePolymorphicObjectName(uint64_t a1, uint64_t a2, StringID *a3)
{
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  _DWORD *v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  _BYTE v15[16];
  uint64_t v16;
  uint64_t v17[2];
  _BYTE v18[8];
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  int v22;
  const char *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  unint64_t v27;
  __int16 v28;
  unint64_t v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  uint64_t v35;

  v35 = *MEMORY[0x24BDAC8D0];
  if (!*(_QWORD *)a2)
    goto LABEL_14;
  if (*(_QWORD *)a2 != a1)
  {
LABEL_15:
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Wrong type registry.", "typeID.registry() == this", "overridePolymorphicObjectName", 407);
    _os_crash();
    __break(1u);
    goto LABEL_16;
  }
  if (*(_BYTE *)(re::DataArray<re::internal::TypeInfoIndex>::tryGet(a1 + 32, *(_QWORD *)(a2 + 8)) + 3) != 8)
  {
LABEL_16:
    re::internal::assertLog((re::internal *)4, v6, "assertion failure: '%s' (%s:line %i) Type must be struct/class.", "typeCategory(typeID) == TypeCategory::kObject", "overridePolymorphicObjectName", 408);
    _os_crash();
    __break(1u);
LABEL_17:
    re::internal::assertLog((re::internal *)4, v7, "assertion failure: '%s' (%s:line %i) Type has been forward declared but type information is missing.", "typeInfo", "overridePolymorphicObjectName", 411);
    _os_crash();
    __break(1u);
  }
  re::TypeRegistry::typeInfo((re *)a1, (re **)a2, v18);
  if (!v18[0])
    goto LABEL_17;
  re::TypeRegistry::makeStringID((re::TypeRegistry *)a1, a3, (re::StringID *)v17);
  re::StringID::operator=(v20 + 13, v17);
  re::TypeInfo::rootClass((re::TypeInfo *)&v19, (uint64_t)v15);
  v8 = *(_DWORD *)re::DataArray<re::internal::TypeInfoIndex>::get(a1 + 32, *(_QWORD *)v16) & 0xFFFFFF;
  v9 = (_DWORD *)re::DataArray<re::internal::TypeInfoIndex>::get(a1 + 32, *v20);
  v10 = *(_DWORD *)(v16 + 80);
  if (v8 < v10 + (int)v8)
  {
    v11 = *v9 & 0xFFFFFF;
    v12 = 152 * v8 + 104;
    do
    {
      if (v11 != v8)
      {
        v13 = *(_QWORD *)(a1 + 624);
        if (v13 <= v8)
        {
          v21 = 0;
          v33 = 0u;
          v34 = 0u;
          v31 = 0u;
          v32 = 0u;
          v30 = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          v22 = 136315906;
          v23 = "operator[]";
          v24 = 1024;
          v25 = 789;
          v26 = 2048;
          v27 = v8;
          v28 = 2048;
          v29 = v13;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_13:
          re::internal::assertLog((re::internal *)5, v14, "assertion failure: '%s' (%s:line %i) Duplicate polymorphic object name \"%s\".", "m_objectTypes[i].polymorphicObjectName != polymorphicObjectName", "overridePolymorphicObjectName", 429, a3->var1);
          _os_crash();
          __break(1u);
LABEL_14:
          re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Invalid type ID.", "typeID.isValid()", "overridePolymorphicObjectName", 406);
          _os_crash();
          __break(1u);
          goto LABEL_15;
        }
        if (re::StringID::operator==((_QWORD *)(*(_QWORD *)(a1 + 640) + v12), a3))
          goto LABEL_13;
      }
      ++v8;
      v12 += 152;
      --v10;
    }
    while (v10);
  }
  ++*(_DWORD *)(a1 + 24);
  re::StringID::destroyString((re::StringID *)v17);
}

_DWORD *re::TypeRegistry::overrideCustomClassID(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  _DWORD *result;
  int v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  _BYTE v16[16];
  uint64_t v17;
  _BYTE v18[8];
  _BYTE v19[16];
  uint64_t v20;
  uint64_t v21;
  int v22;
  const char *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  unint64_t v27;
  __int16 v28;
  unint64_t v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  uint64_t v35;

  v35 = *MEMORY[0x24BDAC8D0];
  if (!*(_QWORD *)a2)
    goto LABEL_16;
  if (*(_QWORD *)a2 != a1)
  {
LABEL_17:
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Wrong type registry.", "typeID.registry() == this", "overrideCustomClassID", 438);
    _os_crash();
    __break(1u);
LABEL_18:
    re::internal::assertLog((re::internal *)4, v6, "assertion failure: '%s' (%s:line %i) Type must be struct/class.", "typeCategory(typeID) == TypeCategory::kObject", "overrideCustomClassID", 439);
    _os_crash();
    __break(1u);
  }
  if (*(_BYTE *)(re::DataArray<re::internal::TypeInfoIndex>::tryGet(a1 + 32, *(_QWORD *)(a2 + 8)) + 3) != 8)
    goto LABEL_18;
  re::TypeRegistry::typeInfo((re *)a1, (re **)a2, v18);
  v7 = v20;
  if (!*(_BYTE *)(v20 + 120))
    *(_BYTE *)(v20 + 120) = 1;
  *(_QWORD *)(v7 + 128) = a3;
  re::TypeInfo::rootClass((re::TypeInfo *)v19, (uint64_t)v16);
  v8 = *(_DWORD *)re::DataArray<re::internal::TypeInfoIndex>::get(a1 + 32, *(_QWORD *)v17) & 0xFFFFFF;
  result = (_DWORD *)re::DataArray<re::internal::TypeInfoIndex>::get(a1 + 32, *(_QWORD *)v20);
  v10 = *(_DWORD *)(v17 + 80);
  if (v8 < v10 + (int)v8)
  {
    v11 = 152 * v8;
    do
    {
      if ((*result & 0xFFFFFF) != v8)
      {
        v12 = *(_QWORD *)(a1 + 624);
        if (v12 <= v8)
        {
          v21 = 0;
          v33 = 0u;
          v34 = 0u;
          v31 = 0u;
          v32 = 0u;
          v30 = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          v22 = 136315906;
          v23 = "operator[]";
          v24 = 1024;
          v25 = 789;
          v26 = 2048;
          v27 = v8;
          v28 = 2048;
          v29 = v12;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_15:
          re::TypeInfo::name((re::TypeInfo *)v19);
          v14 = re::TypeInfo::name((re::TypeInfo *)v19);
          re::internal::assertLog((re::internal *)5, v15, "assertion failure: '%s' (%s:line %i) Duplicate class ID (type: \"%s\").", "m_objectTypes[i].customClassID != customClassID", "overrideCustomClassID", 457, v14[1]);
          _os_crash();
          __break(1u);
LABEL_16:
          re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Invalid type ID.", "typeID.isValid()", "overrideCustomClassID", 437);
          _os_crash();
          __break(1u);
          goto LABEL_17;
        }
        v13 = *(_QWORD *)(a1 + 640) + v11;
        if (*(_BYTE *)(v13 + 120) && *(_QWORD *)(v13 + 128) == a3)
          goto LABEL_15;
      }
      ++v8;
      v11 += 152;
      --v10;
    }
    while (v10);
  }
  ++*(_DWORD *)(a1 + 24);
  return result;
}

void re::TypeRegistry::clearCustomClassID(re *a1, uint64_t a2)
{
  uint64_t v4;
  _BYTE v5[24];
  uint64_t v6;

  if (!*(_QWORD *)a2)
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Invalid type ID.", "typeID.isValid()", "clearCustomClassID", 465);
    _os_crash();
    __break(1u);
    goto LABEL_10;
  }
  if (*(re **)a2 != a1)
  {
LABEL_10:
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Wrong type registry.", "typeID.registry() == this", "clearCustomClassID", 466);
    _os_crash();
    __break(1u);
    goto LABEL_11;
  }
  if (*(_BYTE *)(re::DataArray<re::internal::TypeInfoIndex>::tryGet((uint64_t)a1 + 32, *(_QWORD *)(a2 + 8)) + 3) != 8)
  {
LABEL_11:
    re::internal::assertLog((re::internal *)4, v4, "assertion failure: '%s' (%s:line %i) Type must be struct/class.", "typeCategory(typeID) == TypeCategory::kObject", "clearCustomClassID", 467);
    _os_crash();
    __break(1u);
    return;
  }
  re::TypeRegistry::typeInfo(a1, (re **)a2, v5);
  if (v5[0])
  {
    if (*(_BYTE *)(v6 + 120))
      *(_BYTE *)(v6 + 120) = 0;
    ++*((_DWORD *)a1 + 6);
  }
}

uint64_t re::TypeRegistry::addAttribute(uint64_t a1, _QWORD *a2, int a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t v10;
  uint64_t result;
  void **v12;
  _OWORD v13[2];
  __int128 v14;
  int v15;

  if (!*a2)
  {
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Invalid type ID.", "typeID.isValid()", "addAttribute", 481);
    _os_crash();
    __break(1u);
    goto LABEL_12;
  }
  if (*a2 != a1)
  {
LABEL_12:
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Wrong type registry.", "typeID.registry() == this", "addAttribute", 482);
    _os_crash();
    __break(1u);
    goto LABEL_13;
  }
  if (!*(_QWORD *)a4)
  {
LABEL_13:
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Invalid attribute type ID.", "attributeTypeID.isValid()", "addAttribute", 483);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v10 = a2[1];
  *(_QWORD *)&v14 = *(_QWORD *)(a4 + 8);
  *((_QWORD *)&v14 + 1) = v10;
  v15 = a3;
  result = re::HashTable<re::internal::TypeAttributeKey,re::internal::TypeAttributeData,re::Hash<re::internal::TypeAttributeKey>,re::EqualTo<re::internal::TypeAttributeKey>,true,false>::tryGet(a1 + 768, (uint64_t *)&v14);
  if (result)
  {
    v12 = (void **)result;
    if (*(_QWORD *)result == a5)
      return result;
    if (*(_QWORD *)result)
    {
      if ((*(_BYTE *)(result + 8) & 1) != 0)
      {
        re::TypeRegistry::typeInfo((re *)a1, (re **)a4, v13);
        re::TypeInfo::releaseInstance((re::TypeInfo *)((char *)v13 + 8), *v12, *(re::Allocator **)(a1 + 16), 0);
      }
    }
  }
  *(_QWORD *)&v13[0] = a5;
  DWORD2(v13[0]) = a6;
  result = re::HashTable<re::internal::TypeAttributeKey,re::internal::TypeAttributeData,re::Hash<re::internal::TypeAttributeKey>,re::EqualTo<re::internal::TypeAttributeKey>,true,false>::addOrReplace<re::internal::TypeAttributeData&>(a1 + 768, &v14, v13);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::HashTable<re::internal::TypeAttributeKey,re::internal::TypeAttributeData,re::Hash<re::internal::TypeAttributeKey>,re::EqualTo<re::internal::TypeAttributeKey>,true,false>::tryGet(uint64_t a1, uint64_t *a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  BOOL v7;
  char v9;

  v4 = re::Hash<re::internal::TypeAttributeKey>::operator()((uint64_t)&v9, (uint64_t)a2);
  if (!*(_QWORD *)a1)
    return 0;
  v5 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * (v4 % *(unsigned int *)(a1 + 24)));
  if ((_DWORD)v5 == 0x7FFFFFFF)
    return 0;
  v6 = *(_QWORD *)(a1 + 16);
  while (1)
  {
    v7 = re::internal::TypeAttributeKey::operator==((unsigned __int16 *)(v6 + 56 * v5 + 16), a2);
    v6 = *(_QWORD *)(a1 + 16);
    if (v7)
      break;
    v5 = *(_DWORD *)(v6 + 56 * v5 + 8) & 0x7FFFFFFF;
    if (v5 == 0x7FFFFFFF)
      return 0;
  }
  return v6 + 56 * v5 + 40;
}

uint64_t re::TypeRegistry::attributesByAttributeType@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  int *v8;
  int v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  int *v20;
  int v21;
  uint64_t v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t *v26;
  int v27;
  uint64_t v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  uint64_t v40;
  unsigned int v41;
  unsigned int v42;
  uint64_t v43;

  if (*(_QWORD *)a2)
  {
    v4 = result;
    if (*(_QWORD *)a2 == result)
    {
      v6 = *(unsigned int *)(result + 800);
      if ((_DWORD)v6)
      {
        v7 = 0;
        v8 = (int *)(*(_QWORD *)(result + 784) + 8);
        while (1)
        {
          v9 = *v8;
          v8 += 14;
          if (v9 < 0)
            break;
          if (v6 == ++v7)
          {
            LODWORD(v7) = *(_DWORD *)(result + 800);
            break;
          }
        }
      }
      else
      {
        LODWORD(v7) = 0;
      }
      if ((_DWORD)v6 == (_DWORD)v7)
      {
        v10 = 0;
      }
      else
      {
        v10 = 0;
        v11 = v7;
        v12 = *(_QWORD *)(result + 784);
        do
        {
          v13 = v12 + 56 * v11;
          v15 = *(unsigned __int16 *)(v13 + 16);
          v14 = v13 + 16;
          if (v15 == (unsigned __int16)*(_DWORD *)(a2 + 8)
            && *(unsigned __int16 *)(v14 + 2) == HIWORD(*(_DWORD *)(a2 + 8))
            && ((*(_DWORD *)(v14 + 4) ^ *(_DWORD *)(a2 + 12)) & 0xFFFFFF) == 0)
          {
            ++v10;
          }
          if (v6 <= (int)v7 + 1)
            v16 = (v7 + 1);
          else
            v16 = v6;
          while (1)
          {
            v11 = (v7 + 1);
            if ((_DWORD)v16 - 1 == (_DWORD)v7)
              break;
            LODWORD(v7) = v7 + 1;
            result = v11;
            if ((*(_DWORD *)(v12 + 56 * v11 + 8) & 0x80000000) != 0)
              goto LABEL_24;
          }
          result = v16;
LABEL_24:
          LODWORD(v7) = result;
        }
        while ((_DWORD)v6 != (_DWORD)result);
      }
      *(_QWORD *)(a3 + 32) = 0;
      *(_QWORD *)(a3 + 8) = 0;
      *(_QWORD *)(a3 + 16) = 0;
      *(_DWORD *)(a3 + 24) = 0;
      result = (uint64_t)re::DynamicArray<re::TypeAttributeEntry>::setCapacity((_QWORD *)a3, v10);
      v17 = *(_DWORD *)(a3 + 24) + 1;
      *(_DWORD *)(a3 + 24) = v17;
      v18 = *(unsigned int *)(v4 + 800);
      if ((_DWORD)v18)
      {
        v19 = 0;
        v20 = (int *)(*(_QWORD *)(v4 + 784) + 8);
        while (1)
        {
          v21 = *v20;
          v20 += 14;
          if (v21 < 0)
            break;
          if (v18 == ++v19)
          {
            LODWORD(v19) = *(_DWORD *)(v4 + 800);
            break;
          }
        }
      }
      else
      {
        LODWORD(v19) = 0;
      }
      if ((_DWORD)v18 != (_DWORD)v19)
      {
        v22 = v19;
        v23 = *(_DWORD *)(v4 + 800);
        do
        {
          v24 = *(_QWORD *)(v4 + 784);
          v25 = v24 + 56 * v22;
          v27 = *(unsigned __int16 *)(v25 + 16);
          v26 = (uint64_t *)(v25 + 16);
          v28 = *(_QWORD *)(a2 + 8);
          if (v27 == (unsigned __int16)v28
            && *((unsigned __int16 *)v26 + 1) == WORD1(v28)
            && ((*((_DWORD *)v26 + 1) ^ HIDWORD(v28)) & 0xFFFFFF) == 0)
          {
            v29 = v26 + 3;
            v30 = *v26;
            v31 = v24 + 56 * v22;
            v32 = *(_QWORD *)(v31 + 24);
            v33 = *(_DWORD *)(v31 + 32);
            v34 = *v29;
            v36 = *(_QWORD *)(a3 + 8);
            v35 = *(_QWORD *)(a3 + 16);
            if (v35 >= v36)
            {
              v37 = v35 + 1;
              if (v36 < v35 + 1)
              {
                v43 = v30;
                if (*(_QWORD *)a3)
                {
                  v38 = 2 * v36;
                  if (!v36)
                    v38 = 8;
                  if (v38 <= v37)
                    v39 = v35 + 1;
                  else
                    v39 = v38;
                  result = (uint64_t)re::DynamicArray<re::TypeAttributeEntry>::setCapacity((_QWORD *)a3, v39);
                  v17 = *(_DWORD *)(a3 + 24);
                }
                else
                {
                  result = (uint64_t)re::DynamicArray<re::TypeAttributeEntry>::setCapacity((_QWORD *)a3, v37);
                  v17 = *(_DWORD *)(a3 + 24) + 1;
                }
                v30 = v43;
              }
              v35 = *(_QWORD *)(a3 + 16);
            }
            v40 = *(_QWORD *)(a3 + 32) + 48 * v35;
            *(_QWORD *)v40 = v4;
            *(_QWORD *)(v40 + 8) = v30;
            *(_QWORD *)(v40 + 16) = v4;
            *(_QWORD *)(v40 + 24) = v32;
            *(_DWORD *)(v40 + 32) = v33;
            *(_QWORD *)(v40 + 40) = v34;
            *(_QWORD *)(a3 + 16) = v35 + 1;
            *(_DWORD *)(a3 + 24) = ++v17;
            v23 = *(_DWORD *)(v4 + 800);
          }
          if (v23 <= (int)v19 + 1)
            v41 = v19 + 1;
          else
            v41 = v23;
          while (1)
          {
            v22 = (v19 + 1);
            if (v41 - 1 == (_DWORD)v19)
              break;
            LODWORD(v19) = v19 + 1;
            v42 = v22;
            if ((*(_DWORD *)(*(_QWORD *)(v4 + 784) + 56 * v22 + 8) & 0x80000000) != 0)
              goto LABEL_56;
          }
          v42 = v41;
LABEL_56:
          LODWORD(v19) = v42;
        }
        while ((_DWORD)v18 != v42);
      }
    }
    else
    {
      re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Wrong type registry.", "attributeID.registry() == this", "attributesByAttributeType", 518);
      result = _os_crash();
      __break(1u);
    }
  }
  else
  {
    *(_QWORD *)(a3 + 32) = 0;
    *(_QWORD *)(a3 + 8) = 0;
    *(_QWORD *)(a3 + 16) = 0;
    *(_QWORD *)a3 = 0;
    *(_DWORD *)(a3 + 24) = 0;
  }
  return result;
}

re::StringID *re::TypeRegistry::makeStringID@<X0>(re::TypeRegistry *this@<X0>, const char *__s@<X1>, re::StringID *a3@<X8>)
{
  re::StringID *result;
  char *v7;
  uint64_t v8;
  char v9;
  char *v10;
  int v11;
  char *v12;

  if (!__s)
    return re::StringID::invalid(a3);
  result = (re::StringID *)strlen(__s);
  if (result)
  {
    v12 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(**((_QWORD **)this + 2) + 32))(*((_QWORD *)this + 2), (uint64_t)result + 1, 0);
    strcpy(v12, __s);
    result = (re::StringID *)re::DynamicArray<re::TransitionCondition *>::add((_QWORD *)this + 102, &v12);
    v7 = v12;
    if (v12)
    {
      v8 = *v12;
      if (*v12)
      {
        v9 = v12[1];
        if (v9)
        {
          v10 = v12 + 2;
          do
          {
            v8 = 31 * v8 + v9;
            v11 = *v10++;
            v9 = v11;
          }
          while (v11);
        }
      }
    }
    else
    {
      v8 = 0;
    }
    *(_QWORD *)a3 = 2 * v8;
    *((_QWORD *)a3 + 1) = v7;
  }
  else
  {
    *(_QWORD *)a3 = 0;
    *((_QWORD *)a3 + 1) = &str_110;
  }
  return result;
}

_anonymous_namespace_ *re::TypeRegistry::removeType(_anonymous_namespace_ *result, _QWORD *a2)
{
  unint64_t v2;
  uint64_t v4;
  unint64_t v5;
  _anonymous_namespace_ *v6;
  unint64_t v7;
  _anonymous_namespace_ *v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  BOOL v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  __int128 *v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  _QWORD *v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  _anonymous_namespace_ *v37;
  uint64_t v38;
  uint64_t v39;
  int *v40;
  int v41;
  uint64_t v42;
  unsigned int v43;
  uint64_t v44;
  __n128 *v45;
  int v46;
  unsigned int v47;
  unsigned int v48;
  uint64_t v49;
  _anonymous_namespace_ *v50;
  uint64_t v51;
  uint64_t v52;
  int *v53;
  int v54;
  uint64_t v55;
  unsigned int v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  int v60;
  unsigned int v61;
  unsigned int v62;
  _DWORD *v63;
  uint64_t v64;
  _anonymous_namespace_ *v65;
  unint64_t v66;
  unint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unsigned int *v71;
  unsigned int v72;
  unsigned int v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  _QWORD *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  unint64_t v83;
  _DWORD *v84;
  unint64_t v85;
  unint64_t v86;
  uint64_t v87;
  uint64_t v88;
  unint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  unint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  unint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  unint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  char *v111;
  char *v112;
  _BYTE *v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  unint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  unint64_t v122;
  unsigned int v123;
  uint64_t v124;
  unsigned int v125;
  _DWORD *v126;
  uint64_t v127;
  unint64_t v128;
  unsigned int v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  unint64_t v137;
  __int128 v138;
  __int128 v139;
  unint64_t v140;
  uint64_t v141;
  uint64_t v142;
  _DWORD *v143;
  unint64_t v144;
  unint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  double v149;
  unint64_t v150;
  uint64_t v151;
  __int128 *v152;
  uint64_t v153;
  __int128 *v154;
  uint64_t v155;
  __int128 v156;
  __int128 v157;
  void *__b[2];
  __int128 v159;
  unsigned int v160;
  unint64_t v161;
  _QWORD v162[2];
  uint64_t v163;
  int v164;
  __int128 *v165;
  uint64_t v166;
  _BYTE v167[28];
  __int16 v168;
  _BYTE v169[10];
  _BYTE v170[18];
  __int16 v171;
  unint64_t v172;
  __int16 v173;
  unint64_t v174;
  __int128 v175;
  __int128 v176;
  __int128 v177;
  __int128 v178;
  __int128 v179;
  uint64_t v180;

  v180 = *MEMORY[0x24BDAC8D0];
  if (*a2)
  {
    v4 = (uint64_t)result;
    v5 = (unint64_t)v167;
    v165 = 0;
    v162[1] = 0;
    v163 = 0;
    v164 = 0;
    v6 = (_anonymous_namespace_ *)re::DynamicArray<std::pair<re::ecs2::Component *,re::ecs2::VFXSceneComponent *>>::setCapacity(v162, 0);
    ++v164;
    v160 = 0;
    *(_OWORD *)__b = 0u;
    v159 = 0u;
    v161 = 0x7FFFFFFFLL;
    v7 = v4 + 32;
    v8 = (_anonymous_namespace_ *)re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::DataArrayIterator((uint64_t)&v175, v4 + 32, 0);
    *(_QWORD *)v167 = v4;
    *(_OWORD *)&v167[8] = v175;
    if (v4 + 32 != (_QWORD)v175 || WORD4(v175) != 0xFFFFLL || (DWORD2(v175) & 0xFFFF0000) != 0xFFFF0000)
    {
      v5 = 0xFFFFLL;
      do
      {
        v9 = re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::handle((unsigned __int16 *)&v167[8]);
        *(_QWORD *)v170 = *(_QWORD *)v167;
        *(_QWORD *)&v170[8] = v9;
        if (*(_QWORD *)v167 == *a2)
        {
          v10 = a2[1];
          v12 = (_DWORD)v9 == (_DWORD)v10;
          v11 = (v9 ^ v10) & 0xFFFFFF00000000;
          v12 = v12 && v11 == 0;
          if (v12)
            goto LABEL_22;
        }
        if (HIDWORD(v159))
        {
          if (DWORD2(v159))
            memset_pattern16(__b[1], &unk_2260EB7B0, 4 * DWORD2(v159));
          if (v160)
          {
            v13 = 0;
            v14 = 32 * v160;
            do
            {
              v15 = *(_DWORD *)(v159 + v13 + 8);
              if (v15 < 0)
                *(_DWORD *)(v159 + v13 + 8) = v15 & 0x7FFFFFFF;
              v13 += 32;
            }
            while (v14 != v13);
          }
          HIDWORD(v159) = 0;
          v160 = 0;
          v161 = __PAIR64__(HIDWORD(v161), 0x7FFFFFFF) + 0x100000000;
        }
        re::TypeRegistry::typeInfo((re *)v4, (re **)v170, &v175);
        if ((_BYTE)v175)
        {
          v157 = *(_OWORD *)a2;
          if (re::TypeInfo::isDependentOn((unint64_t *)&v175 + 1, &v157, (uint64_t)__b, *(double *)&v157))LABEL_22:re::DynamicArray<re::TypeID>::add((_anonymous_namespace_ *)v162, (__n128 *)v170);
        }
        v8 = (_anonymous_namespace_ *)re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::increment(&v167[8]);
      }
      while (*(_QWORD *)&v167[8] != v7
           || *(unsigned __int16 *)&v167[16] != 0xFFFF
           || *(unsigned __int16 *)&v167[18] != 0xFFFF);
    }
    if (v163)
    {
      v16 = v165;
      v151 = v4 + 648;
      v152 = &v165[v163];
      v153 = v4 + 32;
      v155 = v4 + 200;
      while (1)
      {
        v156 = *v16;
        v154 = v16;
        v17 = *((_QWORD *)v16 + 1);
        v18 = *(_QWORD *)(v4 + 176);
        memset(&v167[8], 0, 20);
        *(_QWORD *)&v169[2] = 0;
        re::DynamicArray<re::EvaluationRegisterId<int>>::setCapacity(v167, v18);
        ++*(_DWORD *)&v167[24];
        *(_QWORD *)&v175 = 0;
        v19 = *(_QWORD *)(v4 + 176);
        if (v19)
          break;
LABEL_42:
        v26 = *(_QWORD *)&v167[16] - 1;
        v27 = v4 + 200;
        if (*(_QWORD *)&v167[16] - 1 >= 0)
        {
          v28 = -16 * *(_QWORD *)&v167[16];
          while (v19 > v26)
          {
            re::HashTable<re::StringID,re::DataArrayHandle<re::internal::TypeInfoIndex>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::remove(v155, (_QWORD *)(*(_QWORD *)(v4 + 192) + 16 * v26));
            v19 = *(_QWORD *)(v4 + 176);
            if (v19 <= v26)
              goto LABEL_232;
            v29 = *(_QWORD *)(v4 + 192);
            v5 = v29 + 16 * v26 + 16;
            if (v19 - 1 > v26 && v5 != v29 + 16 * v19)
            {
              v31 = v28 + 16 * v19;
              do
              {
                v32 = *(_QWORD *)v5;
                v33 = *(_QWORD *)(v5 + 8);
                *(_QWORD *)v5 = 0;
                *(_QWORD *)(v5 + 8) = &str_110;
                v34 = *(_QWORD *)(v5 - 8);
                v35 = v32 & 0xFFFFFFFFFFFFFFFELL | *(_QWORD *)(v5 - 16) & 1;
                *(_QWORD *)(v5 - 8) = v33;
                *(_QWORD *)&v175 = v35;
                *((_QWORD *)&v175 + 1) = v34;
                *(_QWORD *)(v5 - 16) = v32;
                re::StringID::destroyString((re::StringID *)&v175);
                v5 += 16;
                v31 -= 16;
              }
              while (v31);
              v19 = *(_QWORD *)(v4 + 176);
              v29 = *(_QWORD *)(v4 + 192);
            }
            re::StringID::destroyString((re::StringID *)(v29 + 16 * v19 - 16));
            v19 = *(_QWORD *)(v4 + 176) - 1;
            *(_QWORD *)(v4 + 176) = v19;
            ++*(_DWORD *)(v4 + 184);
            v28 += 16;
            if ((uint64_t)v26-- <= 0)
              goto LABEL_55;
          }
          v166 = 0;
          v178 = 0u;
          v179 = 0u;
          v176 = 0u;
          v177 = 0u;
          v175 = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          *(_DWORD *)v170 = 136315906;
          *(_QWORD *)&v170[4] = "operator[]";
          *(_WORD *)&v170[12] = 1024;
          *(_DWORD *)&v170[14] = 789;
          v171 = 2048;
          v172 = v26;
          v173 = 2048;
          v174 = v19;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_232:
          v166 = 0;
          v178 = 0u;
          v179 = 0u;
          v176 = 0u;
          v177 = 0u;
          v175 = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          *(_DWORD *)v170 = 136315906;
          *(_QWORD *)&v170[4] = "removeStableAt";
          *(_WORD *)&v170[12] = 1024;
          *(_DWORD *)&v170[14] = 969;
          v171 = 2048;
          v172 = v26;
          v173 = 2048;
          v174 = v19;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_233:
          *(_QWORD *)v170 = 0;
          v178 = 0u;
          v179 = 0u;
          v176 = 0u;
          v177 = 0u;
          v175 = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          *(_DWORD *)v167 = 136315906;
          *(_QWORD *)&v167[4] = "operator[]";
          *(_WORD *)&v167[12] = 1024;
          *(_DWORD *)&v167[14] = 789;
          *(_WORD *)&v167[18] = 2048;
          *(_QWORD *)&v167[20] = v5;
          v168 = 2048;
          *(_QWORD *)v169 = v26;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_234:
          *(_QWORD *)v170 = 0;
          v178 = 0u;
          v179 = 0u;
          v176 = 0u;
          v177 = 0u;
          v175 = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          *(_DWORD *)v167 = 136315906;
          *(_QWORD *)&v167[4] = "removeStableAt";
          *(_WORD *)&v167[12] = 1024;
          *(_DWORD *)&v167[14] = 969;
          *(_WORD *)&v167[18] = 2048;
          *(_QWORD *)&v167[20] = v19;
          v168 = 2048;
          *(_QWORD *)v169 = v27;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_235:
          *(_QWORD *)v170 = 0;
          v178 = 0u;
          v179 = 0u;
          v176 = 0u;
          v177 = 0u;
          v175 = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          *(_DWORD *)v167 = 136315906;
          *(_QWORD *)&v167[4] = "operator[]";
          *(_WORD *)&v167[12] = 1024;
          *(_DWORD *)&v167[14] = 789;
          *(_WORD *)&v167[18] = 2048;
          *(_QWORD *)&v167[20] = v26;
          v168 = 2048;
          *(_QWORD *)v169 = v7;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_236:
          *(_QWORD *)v170 = 0;
          v178 = 0u;
          v179 = 0u;
          v176 = 0u;
          v177 = 0u;
          v175 = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          *(_DWORD *)v167 = 136315906;
          *(_QWORD *)&v167[4] = "removeStableAt";
          *(_WORD *)&v167[12] = 1024;
          *(_DWORD *)&v167[14] = 969;
          *(_WORD *)&v167[18] = 2048;
          *(_QWORD *)&v167[20] = v26;
          v168 = 2048;
          *(_QWORD *)v169 = v27;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_237:
          *(_QWORD *)v170 = 0;
          v178 = 0u;
          v179 = 0u;
          v176 = 0u;
          v177 = 0u;
          v175 = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          *(_DWORD *)v167 = 136315906;
          *(_QWORD *)&v167[4] = "removeStableAt";
          *(_WORD *)&v167[12] = 1024;
          *(_DWORD *)&v167[14] = 969;
          *(_WORD *)&v167[18] = 2048;
          *(_QWORD *)&v167[20] = v26;
          v168 = 2048;
          *(_QWORD *)v169 = v27;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_238:
          *(_QWORD *)v170 = 0;
          v178 = 0u;
          v179 = 0u;
          v176 = 0u;
          v177 = 0u;
          v175 = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          *(_DWORD *)v167 = 136315906;
          *(_QWORD *)&v167[4] = "removeStableAt";
          *(_WORD *)&v167[12] = 1024;
          *(_DWORD *)&v167[14] = 969;
          *(_WORD *)&v167[18] = 2048;
          *(_QWORD *)&v167[20] = v26;
          v168 = 2048;
          *(_QWORD *)v169 = v27;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_239:
          *(_QWORD *)v170 = 0;
          v178 = 0u;
          v179 = 0u;
          v176 = 0u;
          v177 = 0u;
          v175 = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          *(_DWORD *)v167 = 136315906;
          *(_QWORD *)&v167[4] = "removeStableAt";
          *(_WORD *)&v167[12] = 1024;
          *(_DWORD *)&v167[14] = 969;
          *(_WORD *)&v167[18] = 2048;
          *(_QWORD *)&v167[20] = v26;
          v168 = 2048;
          *(_QWORD *)v169 = v27;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_240:
          *(_QWORD *)v170 = 0;
          v178 = 0u;
          v179 = 0u;
          v176 = 0u;
          v177 = 0u;
          v175 = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          *(_DWORD *)v167 = 136315906;
          *(_QWORD *)&v167[4] = "operator[]";
          *(_WORD *)&v167[12] = 1024;
          *(_DWORD *)&v167[14] = 789;
          *(_WORD *)&v167[18] = 2048;
          *(_QWORD *)&v167[20] = v26;
          v168 = 2048;
          *(_QWORD *)v169 = v28;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_241:
          *(_QWORD *)v170 = 0;
          v178 = 0u;
          v179 = 0u;
          v176 = 0u;
          v177 = 0u;
          v175 = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          *(_DWORD *)v167 = 136315906;
          *(_QWORD *)&v167[4] = "operator[]";
          *(_WORD *)&v167[12] = 1024;
          *(_DWORD *)&v167[14] = 789;
          *(_WORD *)&v167[18] = 2048;
          *(_QWORD *)&v167[20] = v2;
          v168 = 2048;
          *(_QWORD *)v169 = v26;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_242:
          *(_QWORD *)v170 = 0;
          v178 = 0u;
          v179 = 0u;
          v176 = 0u;
          v177 = 0u;
          v175 = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          *(_DWORD *)v167 = 136315906;
          *(_QWORD *)&v167[4] = "removeStableAt";
          *(_WORD *)&v167[12] = 1024;
          *(_DWORD *)&v167[14] = 969;
          *(_WORD *)&v167[18] = 2048;
          *(_QWORD *)&v167[20] = v26;
          v168 = 2048;
          *(_QWORD *)v169 = v27;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_243:
          *(_QWORD *)v170 = 0;
          v178 = 0u;
          v179 = 0u;
          v176 = 0u;
          v177 = 0u;
          v175 = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          *(_DWORD *)v167 = 136315906;
          *(_QWORD *)&v167[4] = "removeStableAt";
          *(_WORD *)&v167[12] = 1024;
          *(_DWORD *)&v167[14] = 969;
          *(_WORD *)&v167[18] = 2048;
          *(_QWORD *)&v167[20] = v26;
          v168 = 2048;
          *(_QWORD *)v169 = v7;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_244:
          *(_QWORD *)v170 = 0;
          v178 = 0u;
          v179 = 0u;
          v176 = 0u;
          v177 = 0u;
          v175 = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          *(_DWORD *)v167 = 136315906;
          *(_QWORD *)&v167[4] = "removeStableAt";
          *(_WORD *)&v167[12] = 1024;
          *(_DWORD *)&v167[14] = 969;
          *(_WORD *)&v167[18] = 2048;
          *(_QWORD *)&v167[20] = v26;
          v168 = 2048;
          *(_QWORD *)v169 = v28;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_245:
          *(_QWORD *)v170 = 0;
          v178 = 0u;
          v179 = 0u;
          v176 = 0u;
          v177 = 0u;
          v175 = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          *(_DWORD *)v167 = 136315906;
          *(_QWORD *)&v167[4] = "operator[]";
          *(_WORD *)&v167[12] = 1024;
          *(_DWORD *)&v167[14] = 789;
          *(_WORD *)&v167[18] = 2048;
          *(_QWORD *)&v167[20] = v2;
          v168 = 2048;
          *(_QWORD *)v169 = v26;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_246:
          *(_QWORD *)v170 = 0;
          v178 = 0u;
          v179 = 0u;
          v176 = 0u;
          v177 = 0u;
          v175 = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          *(_DWORD *)v167 = 136315906;
          *(_QWORD *)&v167[4] = "operator[]";
          *(_WORD *)&v167[12] = 1024;
          *(_DWORD *)&v167[14] = 789;
          *(_WORD *)&v167[18] = 2048;
          *(_QWORD *)&v167[20] = v2;
          v168 = 2048;
          *(_QWORD *)v169 = v5;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_247:
          *(_QWORD *)v170 = 0;
          v178 = 0u;
          v179 = 0u;
          v176 = 0u;
          v177 = 0u;
          v175 = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          *(_DWORD *)v167 = 136315906;
          *(_QWORD *)&v167[4] = "removeStableAt";
          *(_WORD *)&v167[12] = 1024;
          *(_DWORD *)&v167[14] = 969;
          *(_WORD *)&v167[18] = 2048;
          *(_QWORD *)&v167[20] = v2;
          v168 = 2048;
          *(_QWORD *)v169 = v27;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_248:
          *(_QWORD *)v170 = 0;
          v178 = 0u;
          v179 = 0u;
          v176 = 0u;
          v177 = 0u;
          v175 = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          *(_DWORD *)v167 = 136315906;
          *(_QWORD *)&v167[4] = "removeManyStableAt";
          *(_WORD *)&v167[12] = 1024;
          *(_DWORD *)&v167[14] = 986;
          *(_WORD *)&v167[18] = 2048;
          *(_QWORD *)&v167[20] = v5;
          v168 = 2048;
          *(_QWORD *)v169 = v2;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_249:
          *(_QWORD *)v170 = 0;
          v178 = 0u;
          v179 = 0u;
          v176 = 0u;
          v177 = 0u;
          v175 = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          *(_DWORD *)v167 = 136315906;
          *(_QWORD *)&v167[4] = "removeManyStableAt";
          *(_WORD *)&v167[12] = 1024;
          *(_DWORD *)&v167[14] = 986;
          *(_WORD *)&v167[18] = 2048;
          *(_QWORD *)&v167[20] = v5;
          v168 = 2048;
          *(_QWORD *)v169 = v27;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
LABEL_55:
        ++*(_DWORD *)(v4 + 24);
        v37 = *(_anonymous_namespace_ **)v167;
        if (*(_QWORD *)v167 && *(_QWORD *)&v169[2])
          v37 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(**(_QWORD **)v167 + 40))();
        v26 = *((_QWORD *)&v156 + 1);
        *((_QWORD *)&v175 + 1) = 0;
        *(_QWORD *)&v176 = 0;
        DWORD2(v176) = 0;
        *(_QWORD *)&v177 = 0;
        re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity(&v175, 0);
        ++DWORD2(v176);
        v38 = *(unsigned int *)(v4 + 800);
        if ((_DWORD)v38)
        {
          v39 = 0;
          v40 = (int *)(*(_QWORD *)(v4 + 784) + 8);
          while (1)
          {
            v41 = *v40;
            v40 += 14;
            if (v41 < 0)
              break;
            if (v38 == ++v39)
            {
              LODWORD(v39) = *(_DWORD *)(v4 + 800);
              break;
            }
          }
        }
        else
        {
          LODWORD(v39) = 0;
        }
        if ((_DWORD)v38 != (_DWORD)v39)
        {
          v42 = v39;
          v43 = *(_DWORD *)(v4 + 800);
          do
          {
            v44 = *(_QWORD *)(v4 + 784) + 56 * v42;
            v46 = *(unsigned __int16 *)(v44 + 16);
            v45 = (__n128 *)(v44 + 16);
            if (v46 == (unsigned __int16)v26
              && v45->n128_u16[1] == WORD1(v26)
              && ((v45->n128_u32[1] ^ HIDWORD(v26)) & 0xFFFFFF) == 0)
            {
              re::DynamicArray<re::internal::TypeAttributeKey>::add((uint64_t)&v175, v45);
              v43 = *(_DWORD *)(v4 + 800);
            }
            if (v43 <= (int)v39 + 1)
              v47 = v39 + 1;
            else
              v47 = v43;
            while (1)
            {
              v42 = (v39 + 1);
              if (v47 - 1 == (_DWORD)v39)
                break;
              LODWORD(v39) = v39 + 1;
              v48 = v42;
              if ((*(_DWORD *)(*(_QWORD *)(v4 + 784) + 56 * v42 + 8) & 0x80000000) != 0)
                goto LABEL_77;
            }
            v48 = v47;
LABEL_77:
            LODWORD(v39) = v48;
          }
          while ((_DWORD)v38 != v48);
        }
        v49 = v177;
        re::TypeRegistry::removeAttributes(v4, (__int128 *)v177, v176);
        ++*(_DWORD *)(v4 + 24);
        v50 = (_anonymous_namespace_ *)v175;
        if ((_QWORD)v175 && v49)
          v50 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v175 + 40))();
        *((_QWORD *)&v175 + 1) = 0;
        *(_QWORD *)&v176 = 0;
        DWORD2(v176) = 0;
        *(_QWORD *)&v177 = 0;
        re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity(&v175, 0);
        ++DWORD2(v176);
        v51 = *(unsigned int *)(v4 + 800);
        if ((_DWORD)v51)
        {
          v52 = 0;
          v53 = (int *)(*(_QWORD *)(v4 + 784) + 8);
          while (1)
          {
            v54 = *v53;
            v53 += 14;
            if (v54 < 0)
              break;
            if (v51 == ++v52)
            {
              LODWORD(v52) = *(_DWORD *)(v4 + 800);
              break;
            }
          }
        }
        else
        {
          LODWORD(v52) = 0;
        }
        if ((_DWORD)v51 != (_DWORD)v52)
        {
          v55 = v52;
          v56 = *(_DWORD *)(v4 + 800);
          do
          {
            v57 = *(_QWORD *)(v4 + 784);
            v58 = v57 + 56 * v55;
            v60 = *(unsigned __int16 *)(v58 + 24);
            v59 = v58 + 24;
            if (v60 == (unsigned __int16)v26
              && *(unsigned __int16 *)(v59 + 2) == WORD1(v26)
              && ((*(_DWORD *)(v57 + 56 * v55 + 28) ^ HIDWORD(v26)) & 0xFFFFFF) == 0)
            {
              re::DynamicArray<re::internal::TypeAttributeKey>::add((uint64_t)&v175, (__n128 *)(v59 - 8));
              v56 = *(_DWORD *)(v4 + 800);
            }
            if (v56 <= (int)v52 + 1)
              v61 = v52 + 1;
            else
              v61 = v56;
            while (1)
            {
              v55 = (v52 + 1);
              if (v61 - 1 == (_DWORD)v52)
                break;
              LODWORD(v52) = v52 + 1;
              v62 = v55;
              if ((*(_DWORD *)(*(_QWORD *)(v4 + 784) + 56 * v55 + 8) & 0x80000000) != 0)
                goto LABEL_100;
            }
            v62 = v61;
LABEL_100:
            LODWORD(v52) = v62;
          }
          while ((_DWORD)v51 != v62);
        }
        v28 = v177;
        re::TypeRegistry::removeAttributes(v4, (__int128 *)v177, v176);
        ++*(_DWORD *)(v4 + 24);
        if ((_QWORD)v175 && v28)
          (*(void (**)(void))(*(_QWORD *)v175 + 40))();
        v7 = v4 + 32;
        v63 = (_DWORD *)re::DataArray<re::internal::TypeInfoIndex>::tryGet(v153, v26);
        v27 = 152;
        if (v63)
        {
          v19 = *v63 & 0xFFFFFF;
          switch(HIBYTE(*v63))
          {
            case 0:
              re::internal::assertLog((re::internal *)4, v64, "assertion failure: '%s' (%s:line %i) Invalid type category.", "!\"Unreachable code\"", "removeType", 706);
              _os_crash();
              __break(1u);
              JUMPOUT(0x225B7E498);
            case 1:
              v27 = *(_QWORD *)(v4 + 264);
              if (v27 <= v19)
                goto LABEL_234;
              v67 = v27 - 1;
              if (v27 - 1 > v19)
              {
                v69 = 72 * v27 - (72 * v19 + 72);
                if (v69)
                {
                  v68 = *(_QWORD *)(v4 + 280) + 72 * v19;
                  memmove((void *)v68, (const void *)(v68 + 72), v69 - 3);
                  v67 = *(_QWORD *)(v4 + 264) - 1;
                }
              }
              *(_QWORD *)(v4 + 264) = v67;
              ++*(_DWORD *)(v4 + 272);
              if (v67 > v19)
              {
                LODWORD(v5) = v19;
                do
                {
                  v70 = re::DataArray<re::internal::TypeInfoIndex>::get(v153, *(_QWORD *)(*(_QWORD *)(v4 + 280) + 72 * v19));
                  v19 = (v5 + 1);
                  *(_DWORD *)v70 = v5 & 0xFFFFFF | (*(unsigned __int8 *)(v70 + 3) << 24);
                  v5 = v19;
                }
                while (*(_QWORD *)(v4 + 264) > v19);
              }
              goto LABEL_106;
            case 2:
              v26 = v19;
              v7 = *(_QWORD *)(v4 + 304);
              if (v7 <= v19)
                goto LABEL_235;
              v71 = (unsigned int *)(*(_QWORD *)(v4 + 320) + 96 * v19);
              v28 = v71[20];
              v72 = v71[21];
              v73 = v71[22];
              v2 = v73 + v72;
              if (!(v73 + v72))
                goto LABEL_127;
              v150 = v73 + v72;
              v5 = v28 + v2 - 1;
              v2 = *(_QWORD *)(v4 + 344);
              if (v5 >= v2)
                goto LABEL_248;
              if (v5 < v2 - 1)
              {
                v74 = *(_QWORD *)(v4 + 360);
                if (v74 + 24 * v28 + 24 * v150 != v74 + 24 * v2)
                {
                  v75 = 24 * v28;
                  v76 = v74 + 24 * v150;
                  v77 = 24 * v2 - 24 * v150;
                  do
                  {
                    v78 = v76 + v75;
                    v79 = (_QWORD *)(v74 + v75);
                    *v79 = *(_QWORD *)(v76 + 24 * v28);
                    v80 = *(_QWORD *)(v76 + v75 + 8);
                    v81 = *(_QWORD *)(v76 + v75 + 16);
                    *(_QWORD *)(v78 + 8) = 0;
                    *(_QWORD *)(v78 + 16) = &str_110;
                    v82 = *(_QWORD *)(v74 + v75 + 16);
                    v83 = v80 & 0xFFFFFFFFFFFFFFFELL | *(_QWORD *)(v74 + v75 + 8) & 1;
                    v79[2] = v81;
                    *(_QWORD *)&v175 = v83;
                    *((_QWORD *)&v175 + 1) = v82;
                    v79[1] = v80;
                    re::StringID::destroyString((re::StringID *)&v175);
                    v74 += 24;
                    v76 += 24;
                    v77 -= 24;
                  }
                  while (v75 != v77);
                }
              }
              v5 = 0;
              v2 = v150;
              v27 = -(uint64_t)v150;
              do
              {
                re::StringID::destroyString((re::StringID *)(*(_QWORD *)(v4 + 360)
                                                           + 24 * (v5 + *(_QWORD *)(v4 + 344))
                                                           - 16));
                --v5;
              }
              while (v27 != v5);
              *(_QWORD *)(v4 + 344) -= v150;
              ++*(_DWORD *)(v4 + 352);
              v7 = *(_QWORD *)(v4 + 304);
              if (v7)
              {
LABEL_127:
                v84 = (_DWORD *)(*(_QWORD *)(v4 + 320) + 80);
                v85 = v7;
                do
                {
                  if (*v84 > v28)
                    *v84 -= v2;
                  v84 += 24;
                  --v85;
                }
                while (v85);
              }
              if (v7 <= v19)
                goto LABEL_243;
              v86 = v7 - 1;
              if (v7 - 1 <= v19)
              {
                v7 = v4 + 32;
              }
              else
              {
                v88 = 96 * v7 - (96 * v19 + 96);
                v7 = v4 + 32;
                if (v88)
                {
                  v87 = *(_QWORD *)(v4 + 320) + 96 * v19;
                  memmove((void *)v87, (const void *)(v87 + 96), v88 - 4);
                  v86 = *(_QWORD *)(v4 + 304) - 1;
                }
              }
              *(_QWORD *)(v4 + 304) = v86;
              ++*(_DWORD *)(v4 + 312);
              while (v86 > v26)
              {
                v142 = re::DataArray<re::internal::TypeInfoIndex>::get(v7, *(_QWORD *)(*(_QWORD *)(v4 + 320) + 96 * v26));
                v26 = (v19 + 1);
                *(_DWORD *)v142 = v19 & 0xFFFFFF | (*(unsigned __int8 *)(v142 + 3) << 24);
                v86 = *(_QWORD *)(v4 + 304);
                LODWORD(v19) = v19 + 1;
              }
              goto LABEL_106;
            case 3:
              v26 = v19;
              v27 = *(_QWORD *)(v4 + 384);
              if (v27 <= v19)
                goto LABEL_236;
              v89 = v27 - 1;
              if (v27 - 1 > v19)
              {
                v90 = *(_QWORD *)(v4 + 400);
                v91 = v90 + 96 * v19;
                v92 = v90 + 96 * v27;
                if (v92 != v91 + 96)
                {
                  memmove((void *)v91, (const void *)(v91 + 96), v92 - (v91 + 96));
                  v89 = *(_QWORD *)(v4 + 384) - 1;
                }
              }
              *(_QWORD *)(v4 + 384) = v89;
              ++*(_DWORD *)(v4 + 392);
              while (v89 > v26)
              {
                v93 = re::DataArray<re::internal::TypeInfoIndex>::get(v153, *(_QWORD *)(*(_QWORD *)(v4 + 400) + 96 * v26));
                v26 = (v19 + 1);
                *(_DWORD *)v93 = v19 & 0xFFFFFF | (*(unsigned __int8 *)(v93 + 3) << 24);
                v89 = *(_QWORD *)(v4 + 384);
                LODWORD(v19) = v19 + 1;
              }
              goto LABEL_106;
            case 4:
              v26 = v19;
              v27 = *(_QWORD *)(v4 + 424);
              if (v27 <= v19)
                goto LABEL_237;
              v94 = v27 - 1;
              if (v27 - 1 > v19)
              {
                v96 = 96 * v27 - (96 * v19 + 96);
                if (v96)
                {
                  v95 = *(_QWORD *)(v4 + 440) + 96 * v19;
                  memmove((void *)v95, (const void *)(v95 + 96), v96 - 4);
                  v94 = *(_QWORD *)(v4 + 424) - 1;
                }
              }
              *(_QWORD *)(v4 + 424) = v94;
              ++*(_DWORD *)(v4 + 432);
              while (v94 > v26)
              {
                v97 = re::DataArray<re::internal::TypeInfoIndex>::get(v153, *(_QWORD *)(*(_QWORD *)(v4 + 440) + 96 * v26));
                v26 = (v19 + 1);
                *(_DWORD *)v97 = v19 & 0xFFFFFF | (*(unsigned __int8 *)(v97 + 3) << 24);
                v94 = *(_QWORD *)(v4 + 424);
                LODWORD(v19) = v19 + 1;
              }
              goto LABEL_106;
            case 5:
              v26 = v19;
              v27 = *(_QWORD *)(v4 + 464);
              if (v27 <= v19)
                goto LABEL_238;
              v98 = v27 - 1;
              if (v27 - 1 > v19)
              {
                v99 = *(_QWORD *)(v4 + 480);
                v100 = v99 + ((unint64_t)v19 << 7);
                v101 = v99 + (v27 << 7);
                if (v101 != v100 + 128)
                {
                  memmove((void *)v100, (const void *)(v100 + 128), v101 - (v100 + 128));
                  v98 = *(_QWORD *)(v4 + 464) - 1;
                }
              }
              *(_QWORD *)(v4 + 464) = v98;
              ++*(_DWORD *)(v4 + 472);
              while (v98 > v26)
              {
                v102 = re::DataArray<re::internal::TypeInfoIndex>::get(v153, *(_QWORD *)(*(_QWORD *)(v4 + 480) + (v26 << 7)));
                v26 = (v19 + 1);
                *(_DWORD *)v102 = v19 & 0xFFFFFF | (*(unsigned __int8 *)(v102 + 3) << 24);
                v98 = *(_QWORD *)(v4 + 464);
                LODWORD(v19) = v19 + 1;
              }
              goto LABEL_106;
            case 6:
              v26 = v19;
              v27 = *(_QWORD *)(v4 + 504);
              if (v27 <= v19)
                goto LABEL_239;
              v103 = v27 - 1;
              if (v27 - 1 > v19)
              {
                v104 = *(_QWORD *)(v4 + 520);
                v105 = v104 + 160 * v19;
                v106 = v104 + 160 * v27;
                if (v106 != v105 + 160)
                {
                  memmove((void *)v105, (const void *)(v105 + 160), v106 - (v105 + 160));
                  v103 = *(_QWORD *)(v4 + 504) - 1;
                }
              }
              *(_QWORD *)(v4 + 504) = v103;
              ++*(_DWORD *)(v4 + 512);
              while (v103 > v26)
              {
                v107 = re::DataArray<re::internal::TypeInfoIndex>::get(v153, *(_QWORD *)(*(_QWORD *)(v4 + 520) + 160 * v26));
                v26 = (v19 + 1);
                *(_DWORD *)v107 = v19 & 0xFFFFFF | (*(unsigned __int8 *)(v107 + 3) << 24);
                v103 = *(_QWORD *)(v4 + 504);
                LODWORD(v19) = v19 + 1;
              }
              goto LABEL_106;
            case 7:
              v26 = v19;
              v28 = *(_QWORD *)(v4 + 544);
              if (v28 <= v19)
                goto LABEL_240;
              v108 = *(_QWORD *)(v4 + 560) + 96 * v19;
              v109 = *(unsigned int *)(v108 + 84);
              v2 = *(unsigned int *)(v108 + 88);
              if (!(_DWORD)v2)
                goto LABEL_216;
              v5 = v109 + v2 - 1;
              v27 = *(_QWORD *)(v4 + 584);
              if (v5 >= v27)
                goto LABEL_249;
              if (v5 >= v27 - 1
                || (v110 = *(_QWORD *)(v4 + 600),
                    v111 = (char *)(v110 + 8 * v109),
                    v112 = &v111[8 * v2],
                    v113 = (_BYTE *)(v110 + 8 * v27),
                    v113 == v112))
              {
                *(_QWORD *)(v4 + 584) = v27 - v2;
                ++*(_DWORD *)(v4 + 592);
              }
              else
              {
                memmove(v111, v112, v113 - v112);
                v28 = *(_QWORD *)(v4 + 544);
                *(_QWORD *)(v4 + 584) -= v2;
                ++*(_DWORD *)(v4 + 592);
                if (!v28)
                  goto LABEL_220;
              }
LABEL_216:
              v143 = (_DWORD *)(*(_QWORD *)(v4 + 560) + 84);
              v144 = v28;
              do
              {
                if (*v143 > v109)
                  *v143 -= v2;
                v143 += 24;
                --v144;
              }
              while (v144);
LABEL_220:
              v7 = v4 + 32;
              if (v28 <= v19)
                goto LABEL_244;
              v145 = v28 - 1;
              if (v28 - 1 > v19)
              {
                v147 = 96 * v28 - (96 * v19 + 96);
                if (v147)
                {
                  v146 = *(_QWORD *)(v4 + 560) + 96 * v19;
                  memmove((void *)v146, (const void *)(v146 + 96), v147 - 4);
                  v145 = *(_QWORD *)(v4 + 544) - 1;
                }
              }
              *(_QWORD *)(v4 + 544) = v145;
              ++*(_DWORD *)(v4 + 552);
              while (v145 > v26)
              {
                v148 = re::DataArray<re::internal::TypeInfoIndex>::get(v153, *(_QWORD *)(*(_QWORD *)(v4 + 560) + 96 * v26));
                v26 = (v19 + 1);
                *(_DWORD *)v148 = v19 & 0xFFFFFF | (*(unsigned __int8 *)(v148 + 3) << 24);
                v145 = *(_QWORD *)(v4 + 544);
                LODWORD(v19) = v19 + 1;
              }
              goto LABEL_106;
            case 8:
              v2 = v19;
              v26 = *(_QWORD *)(v4 + 624);
              if (v26 <= v19)
                goto LABEL_241;
              v114 = *(_QWORD *)(v4 + 640);
              v115 = v114 + 152 * v19;
              break;
            case 9:
              v26 = v19;
              v27 = *(_QWORD *)(v4 + 744);
              if (v27 <= v19)
                goto LABEL_242;
              v117 = v27 - 1;
              if (v27 - 1 > v19)
              {
                v119 = 104 * v27 - (104 * v19 + 104);
                if (v119)
                {
                  v118 = *(_QWORD *)(v4 + 760) + 104 * v19;
                  memmove((void *)v118, (const void *)(v118 + 104), v119 - 4);
                  v117 = *(_QWORD *)(v4 + 744) - 1;
                }
              }
              *(_QWORD *)(v4 + 744) = v117;
              ++*(_DWORD *)(v4 + 752);
              while (v117 > v26)
              {
                v120 = re::DataArray<re::internal::TypeInfoIndex>::get(v153, *(_QWORD *)(*(_QWORD *)(v4 + 760) + 104 * v26));
                v26 = (v19 + 1);
                *(_DWORD *)v120 = v19 & 0xFFFFFF | (*(unsigned __int8 *)(v120 + 3) << 24);
                v117 = *(_QWORD *)(v4 + 744);
                LODWORD(v19) = v19 + 1;
              }
              goto LABEL_106;
            default:
              goto LABEL_106;
          }
          while (1)
          {
            v116 = *(_QWORD *)(v115 + 72);
            if ((v116 & 0xFFFFFF00000000) == 0)
              break;
            v5 = *(_DWORD *)re::DataArray<re::internal::TypeInfoIndex>::get(v153, v116) & 0xFFFFFFLL;
            v26 = *(_QWORD *)(v4 + 624);
            if (v26 <= v5)
              goto LABEL_233;
            v114 = *(_QWORD *)(v4 + 640);
            v115 = v114 + 152 * v5;
            --*(_DWORD *)(v115 + 80);
          }
          if (v26 <= v19)
            goto LABEL_245;
          v121 = v114 + 152 * v19;
          v122 = *(unsigned int *)(v121 + 84);
          v123 = *(_DWORD *)(v121 + 88);
          v27 = v4 + 648;
          re::DynamicArray<re::internal::ObjectMemberInfo>::removeManyStableAt(v151, v122, v123);
          v5 = *(_QWORD *)(v4 + 624);
          if (v5 <= v19)
            goto LABEL_246;
          v124 = *(_QWORD *)(v4 + 640) + 152 * v19;
          v125 = *(_DWORD *)(v124 + 92);
          v5 = *(unsigned int *)(v124 + 96);
          re::DynamicArray<re::internal::ObjectMemberInfo>::removeManyStableAt(v151, v125, v5);
          v27 = *(_QWORD *)(v4 + 624);
          if (v27)
          {
            v126 = (_DWORD *)(*(_QWORD *)(v4 + 640) + 84);
            v127 = *(_QWORD *)(v4 + 624);
            do
            {
              if (*v126 > v122)
                *v126 -= v123;
              v128 = (int)v126[13];
              if (v128 > v122)
                v126[13] = v128 - v123;
              v129 = v126[2];
              if (v129 > v125)
                v126[2] = v129 - v5;
              v126 += 38;
              --v127;
            }
            while (v127);
          }
          v7 = v4 + 32;
          if (v27 <= v19)
            goto LABEL_247;
          v130 = *(_QWORD *)(v4 + 640);
          v5 = 152;
          if (v27 - 1 > v19 && v130 + 152 * v19 + 152 != v130 + 152 * v27)
          {
            v131 = 152 * v19;
            v132 = 152 * v27 - 152;
            do
            {
              v133 = v130 + v131;
              *(_DWORD *)(v133 + 64) = *(_DWORD *)(v130 + v131 + 216);
              v134 = *(_QWORD *)(v130 + v131 + 256);
              v135 = *(_QWORD *)(v130 + v131 + 264);
              v136 = *(_QWORD *)(v130 + v131 + 112);
              v137 = v134 & 0xFFFFFFFFFFFFFFFELL | *(_QWORD *)(v130 + v131 + 104) & 1;
              v138 = *(_OWORD *)(v130 + v131 + 168);
              v139 = *(_OWORD *)(v130 + v131 + 200);
              *(_OWORD *)(v133 + 32) = *(_OWORD *)(v130 + v131 + 184);
              *(_OWORD *)(v133 + 48) = v139;
              *(_OWORD *)v133 = *(_OWORD *)(v130 + v131 + 152);
              *(_OWORD *)(v133 + 16) = v138;
              *(_OWORD *)(v133 + 72) = *(_OWORD *)(v130 + v131 + 224);
              *(_OWORD *)(v133 + 84) = *(_OWORD *)(v130 + v131 + 236);
              *(_QWORD *)(v133 + 256) = 0;
              *(_QWORD *)(v133 + 264) = &str_110;
              *(_QWORD *)(v133 + 112) = v135;
              *(_QWORD *)&v175 = v137;
              *((_QWORD *)&v175 + 1) = v136;
              *(_QWORD *)(v133 + 104) = v134;
              re::StringID::destroyString((re::StringID *)&v175);
              if (*(_BYTE *)(v130 + v131 + 120) || *(_BYTE *)(v130 + v131 + 272))
              {
                if (!*(_BYTE *)(v130 + v131 + 120) || *(_BYTE *)(v130 + v131 + 272))
                {
                  if (!*(_BYTE *)(v130 + v131 + 120) && *(_BYTE *)(v130 + v131 + 272))
                    *(_BYTE *)(v133 + 120) = 1;
                  *(_QWORD *)(v130 + v131 + 128) = *(_QWORD *)(v130 + v131 + 280);
                }
                else
                {
                  *(_BYTE *)(v133 + 120) = 0;
                }
              }
              *(_OWORD *)(v130 + v131 + 136) = *(_OWORD *)(v130 + v131 + 288);
              v130 += 152;
              v132 -= 152;
            }
            while (v131 != v132);
            v27 = *(_QWORD *)(v4 + 624);
            v130 = *(_QWORD *)(v4 + 640);
            v7 = v4 + 32;
            v5 = 152;
          }
          re::StringID::destroyString((re::StringID *)(v130 + 152 * v27 - 48));
          v140 = *(_QWORD *)(v4 + 624) - 1;
          *(_QWORD *)(v4 + 624) = v140;
          ++*(_DWORD *)(v4 + 632);
          while (v140 > v2)
          {
            v141 = re::DataArray<re::internal::TypeInfoIndex>::get(v7, *(_QWORD *)(*(_QWORD *)(v4 + 640) + 152 * v2));
            v2 = (v19 + 1);
            *(_DWORD *)v141 = v19 & 0xFFFFFF | (*(unsigned __int8 *)(v141 + 3) << 24);
            v140 = *(_QWORD *)(v4 + 624);
            LODWORD(v19) = v19 + 1;
          }
        }
LABEL_106:
        v65 = re::TypeRegistry::typeName((_anonymous_namespace_ *)v4, &v156);
        re::HashTable<re::StringID,re::DataArrayHandle<re::internal::TypeInfoIndex>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::remove(v155, v65);
        v66 = *((_QWORD *)&v156 + 1);
        re::DataArray<re::TypeRegistry::TypeNameAndVersion>::destroy(v4 + 96, *((unint64_t *)&v156 + 1));
        v8 = (_anonymous_namespace_ *)re::DataArray<re::internal::TypeInfoIndex>::destroy(v7, v66);
        v16 = v154 + 1;
        if (v154 + 1 == v152)
          goto LABEL_227;
      }
      v2 = 0;
      v7 = HIDWORD(v17);
      while (1)
      {
        if (*(_QWORD *)(v4 + 200))
        {
          v20 = (_QWORD *)(*(_QWORD *)(v4 + 192) + 16 * v2);
          v21 = 0xBF58476D1CE4E5B9 * ((*v20 >> 31) ^ (*v20 >> 1));
          v22 = *(_QWORD *)(v4 + 216);
          v5 = *(unsigned int *)(*(_QWORD *)(v4 + 208)
                               + 4
                               * (((0x94D049BB133111EBLL * (v21 ^ (v21 >> 27))) ^ ((0x94D049BB133111EBLL
                                                                                  * (v21 ^ (v21 >> 27))) >> 31))
                                % *(unsigned int *)(v4 + 224)));
          if ((_DWORD)v5 != 0x7FFFFFFF)
          {
            while (!re::StringID::operator==((_QWORD *)(v22 + 32 * v5 + 8), v20))
            {
              v5 = *(_DWORD *)(v22 + 32 * v5) & 0x7FFFFFFF;
              if (v5 == 0x7FFFFFFF)
                goto LABEL_36;
            }
            goto LABEL_37;
          }
        }
        else
        {
          v22 = *(_QWORD *)(v4 + 216);
        }
LABEL_36:
        v5 = 0x7FFFFFFFLL;
LABEL_37:
        v23 = v22 + 32 * v5;
        v25 = *(unsigned __int16 *)(v23 + 24);
        v24 = v23 + 24;
        if (v25 == (unsigned __int16)v17
          && *(unsigned __int16 *)(v24 + 2) == WORD1(v17)
          && ((*(_DWORD *)(v22 + 32 * v5 + 28) ^ HIDWORD(v17)) & 0xFFFFFF) == 0)
        {
          re::DynamicArray<unsigned long>::add(v167, &v175);
          v2 = v175;
          v19 = *(_QWORD *)(v4 + 176);
        }
        *(_QWORD *)&v175 = ++v2;
        if (v2 >= v19)
          goto LABEL_42;
      }
    }
LABEL_227:
    ++*(_DWORD *)(v4 + 24);
    v149 = re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)__b);
    result = (_anonymous_namespace_ *)v162[0];
    if (v162[0] && v165)
      return (_anonymous_namespace_ *)(*(uint64_t (**)(double))(*(_QWORD *)v162[0] + 40))(v149);
  }
  return result;
}

void re::DynamicArray<re::internal::ObjectMemberInfo>::removeManyStableAt(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  _OWORD v18[5];
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  if (a3)
  {
    v5 = a2 + a3 - 1;
    v6 = *(_QWORD *)(a1 + 16);
    if (v5 >= v6)
    {
      memset(v18, 0, sizeof(v18));
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    if (v5 < v6 - 1)
    {
      v7 = *(_QWORD *)(a1 + 32);
      if (v7 + 40 * a2 + 40 * a3 != v7 + 40 * v6)
      {
        v8 = 40 * a2;
        v9 = v7 + 40 * a3;
        v10 = 40 * v6 - 40 * a3;
        do
        {
          v11 = v9 + v8;
          v12 = v7 + v8;
          *(_QWORD *)v12 = *(_QWORD *)(v9 + v8);
          v13 = *(_QWORD *)(v9 + v8 + 8);
          v14 = *(_QWORD *)(v9 + v8 + 16);
          *(_QWORD *)(v11 + 8) = 0;
          *(_QWORD *)(v11 + 16) = &str_110;
          v15 = *(_QWORD *)(v7 + v8 + 16);
          v16 = v13 & 0xFFFFFFFFFFFFFFFELL | *(_QWORD *)(v7 + v8 + 8) & 1;
          *(_QWORD *)(v12 + 16) = v14;
          *(_QWORD *)&v18[0] = v16;
          *((_QWORD *)&v18[0] + 1) = v15;
          *(_QWORD *)(v12 + 8) = v13;
          re::StringID::destroyString((re::StringID *)v18);
          *(_QWORD *)(v12 + 24) = *(_QWORD *)(v9 + v8 + 24);
          *(_DWORD *)(v12 + 32) = *(_DWORD *)(v9 + v8 + 32);
          v9 += 40;
          v7 += 40;
          v10 -= 40;
        }
        while (v8 != v10);
      }
    }
    v17 = 0;
    do
    {
      re::StringID::destroyString((re::StringID *)(*(_QWORD *)(a1 + 32) + 40 * (v17 + *(_QWORD *)(a1 + 16)) - 32));
      --v17;
    }
    while (-a3 != v17);
    *(_QWORD *)(a1 + 16) -= a3;
    ++*(_DWORD *)(a1 + 24);
  }
}

void re::HashTable<re::StringID,re::DataArrayHandle<re::internal::TypeInfoIndex>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::remove(uint64_t a1, _QWORD *a2)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  int v10;
  uint64_t v11;
  int *v12;
  int v13;
  int v14;

  if (*(_QWORD *)a1)
  {
    v4 = 0xBF58476D1CE4E5B9 * ((*a2 >> 31) ^ (*a2 >> 1));
    v5 = ((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) ^ ((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) >> 31))
       % *(unsigned int *)(a1 + 24);
    v6 = *(_QWORD *)(a1 + 8);
    v7 = *(unsigned int *)(v6 + 4 * v5);
    if ((_DWORD)v7 != 0x7FFFFFFF)
    {
      v8 = *(_QWORD *)(a1 + 16);
      if (re::StringID::operator==((_QWORD *)(v8 + 32 * v7 + 8), a2))
      {
        *(_DWORD *)(v6 + 4 * v5) = *(_DWORD *)(v8 + 32 * v7) & 0x7FFFFFFF;
LABEL_8:
        v11 = *(_QWORD *)(a1 + 16);
        v12 = (int *)(v11 + 32 * v7);
        v13 = *v12;
        if (*v12 < 0)
        {
          *v12 = v13 & 0x7FFFFFFF;
          re::StringID::destroyString((re::StringID *)(v12 + 2));
          v11 = *(_QWORD *)(a1 + 16);
          v13 = *(_DWORD *)(v11 + 32 * v7);
        }
        v14 = *(_DWORD *)(a1 + 40);
        *(_DWORD *)(v11 + 32 * v7) = *(_DWORD *)(a1 + 36) | v13 & 0x80000000;
        --*(_DWORD *)(a1 + 28);
        *(_DWORD *)(a1 + 36) = v7;
        *(_DWORD *)(a1 + 40) = v14 + 1;
      }
      else
      {
        while (1)
        {
          v9 = v7;
          v10 = *(_DWORD *)(v8 + 32 * v7);
          v7 = v10 & 0x7FFFFFFF;
          if ((v10 & 0x7FFFFFFF) == 0x7FFFFFFF)
            break;
          if (re::StringID::operator==((_QWORD *)(v8 + 32 * v7 + 8), a2))
          {
            *(_DWORD *)(v8 + 32 * v9) = *(_DWORD *)(v8 + 32 * v9) & 0x80000000 | *(_DWORD *)(v8 + 32 * v7) & 0x7FFFFFFF;
            goto LABEL_8;
          }
        }
      }
    }
  }
}

void re::DataArray<re::TypeRegistry::TypeNameAndVersion>::destroy(uint64_t a1, unint64_t a2)
{
  int v2;
  unint64_t v4;
  re::StringID *v5;
  re::StringID *v6;

  v2 = a2;
  v4 = a2 >> 16;
  v5 = (re::StringID *)re::DataArray<re::TextureAtlasTile>::tryGet(a1, a2 & 0xFFFFFFFF00000000 | ((unint64_t)WORD1(a2) << 16) | (unsigned __int16)a2);
  if (v5)
  {
    v6 = v5;
    re::StringID::destroyString(v5);
    if (*(_QWORD *)(a1 + 16) <= (unint64_t)HIWORD(v2))
    {
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 16 * HIWORD(v2) + 8) + 4 * (unsigned __int16)v2) = 0;
    *(_DWORD *)v6 = *(_DWORD *)(a1 + 52);
    *(_WORD *)(a1 + 52) = v2;
    *(_WORD *)(a1 + 54) = v4;
    --*(_DWORD *)(a1 + 40);
  }
}

_DWORD *re::DataArray<re::internal::TypeInfoIndex>::destroy(uint64_t a1, unint64_t a2)
{
  int v2;
  unint64_t v4;
  _DWORD *result;

  v2 = a2;
  v4 = a2 >> 16;
  result = (_DWORD *)re::DataArray<re::internal::TypeInfoIndex>::tryGet(a1, a2 & 0xFFFFFFFF00000000 | ((unint64_t)WORD1(a2) << 16) | (unsigned __int16)a2);
  if (result)
  {
    if (*(_QWORD *)(a1 + 16) <= (unint64_t)HIWORD(v2))
    {
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 16 * HIWORD(v2) + 8) + 4 * (unsigned __int16)v2) = 0;
    *result = *(_DWORD *)(a1 + 52);
    *(_WORD *)(a1 + 52) = v2;
    *(_WORD *)(a1 + 54) = v4;
    --*(_DWORD *)(a1 + 40);
  }
  return result;
}

__n128 re::DynamicArray<re::internal::TypeAttributeKey>::add(uint64_t a1, __n128 *a2)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  BOOL v8;
  unint64_t v9;
  unint64_t v10;
  __n128 *v11;
  __n128 result;

  v4 = *(_QWORD *)(a1 + 8);
  v5 = *(_QWORD *)(a1 + 16);
  if (v5 >= v4)
  {
    v6 = v5 + 1;
    if (v4 < v5 + 1)
    {
      if (*(_QWORD *)a1)
      {
        v7 = 2 * v4;
        v8 = v4 == 0;
        v9 = 8;
        if (!v8)
          v9 = v7;
        if (v9 <= v6)
          v10 = v6;
        else
          v10 = v9;
        re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity((_QWORD *)a1, v10);
      }
      else
      {
        re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity((_QWORD *)a1, v6);
        ++*(_DWORD *)(a1 + 24);
      }
    }
    v5 = *(_QWORD *)(a1 + 16);
  }
  v11 = (__n128 *)(*(_QWORD *)(a1 + 32) + 24 * v5);
  result = *a2;
  v11[1].n128_u64[0] = a2[1].n128_u64[0];
  *v11 = result;
  ++*(_QWORD *)(a1 + 16);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

void re::TypeRegistry::removeAttributes(uint64_t a1, __int128 *a2, uint64_t a3)
{
  __int128 *v3;
  __int128 *v5;
  __int128 v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int *v19;
  int v20;
  void **v21;
  uint64_t v22;
  _BYTE v23[8];
  uint64_t v24;
  __int128 v25;
  uint64_t v26;

  if (a3)
  {
    v3 = a2;
    v5 = (__int128 *)((char *)a2 + 24 * a3);
    do
    {
      v6 = *v3;
      v26 = *((_QWORD *)v3 + 2);
      v25 = v6;
      v7 = re::Hash<re::internal::TypeAttributeKey>::operator()((uint64_t)v23, (uint64_t)&v25);
      if (*(_QWORD *)(a1 + 768)
        && (v8 = *(unsigned int *)(*(_QWORD *)(a1 + 776) + 4 * (v7 % *(unsigned int *)(a1 + 792))),
            (_DWORD)v8 != 0x7FFFFFFF))
      {
        v22 = *(_QWORD *)(a1 + 784);
        while (!re::internal::TypeAttributeKey::operator==((unsigned __int16 *)(v22 + 56 * v8 + 16), (uint64_t *)&v25))
        {
          v22 = *(_QWORD *)(a1 + 784);
          v8 = *(_DWORD *)(v22 + 56 * v8 + 8) & 0x7FFFFFFF;
          v9 = 0x7FFFFFFFLL;
          if (v8 == 0x7FFFFFFF)
            goto LABEL_6;
        }
        v9 = v8;
      }
      else
      {
        v9 = 0x7FFFFFFFLL;
      }
LABEL_6:
      v10 = *(_QWORD *)(a1 + 784);
      v11 = re::Hash<re::internal::TypeAttributeKey>::operator()((uint64_t)v23, (uint64_t)&v25);
      if (*(_QWORD *)(a1 + 768))
      {
        v12 = v11 % *(unsigned int *)(a1 + 792);
        v13 = *(unsigned int *)(*(_QWORD *)(a1 + 776) + 4 * v12);
        if ((_DWORD)v13 != 0x7FFFFFFF)
        {
          if (re::internal::TypeAttributeKey::operator==((unsigned __int16 *)(*(_QWORD *)(a1 + 784) + 56 * v13 + 16), (uint64_t *)&v25))
          {
            *(_DWORD *)(*(_QWORD *)(a1 + 776) + 4 * v12) = *(_DWORD *)(*(_QWORD *)(a1 + 784)
                                                                     + 56 * v13
                                                                     + 8) & 0x7FFFFFFF;
LABEL_13:
            v16 = *(_QWORD *)(a1 + 784);
            v17 = v16 + 56 * v13;
            v20 = *(_DWORD *)(v17 + 8);
            v19 = (int *)(v17 + 8);
            v18 = v20;
            if (v20 < 0)
            {
              *v19 = v18 & 0x7FFFFFFF;
              v16 = *(_QWORD *)(a1 + 784);
              v18 = *(_DWORD *)(v16 + 56 * v13 + 8);
            }
            *(_DWORD *)(v16 + 56 * v13 + 8) = *(_DWORD *)(a1 + 804) | v18 & 0x80000000;
            *(_DWORD *)(a1 + 804) = v13;
            --*(_DWORD *)(a1 + 796);
            ++*(_DWORD *)(a1 + 808);
          }
          else
          {
            while (1)
            {
              v14 = v13;
              v15 = *(_QWORD *)(a1 + 784);
              v13 = *(_DWORD *)(v15 + 56 * v13 + 8) & 0x7FFFFFFF;
              if (v13 == 0x7FFFFFFF)
                break;
              if (re::internal::TypeAttributeKey::operator==((unsigned __int16 *)(v15 + 56 * v13 + 16), (uint64_t *)&v25))
              {
                *(_DWORD *)(*(_QWORD *)(a1 + 784) + 56 * v14 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 784) + 56 * v14 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 784) + 56 * v13 + 8) & 0x7FFFFFFF;
                goto LABEL_13;
              }
            }
          }
        }
      }
      v21 = (void **)(v10 + 56 * v9 + 40);
      if (*v21)
      {
        if ((*(_BYTE *)(v10 + 56 * v9 + 48) & 1) != 0)
        {
          re::TypeRegistry::typeInfo((_QWORD *)a1, v25, v23);
          re::TypeInfo::releaseInstance((re::TypeInfo *)&v24, *v21, *(re::Allocator **)(a1 + 16), 0);
        }
      }
      v3 = (__int128 *)((char *)v3 + 24);
    }
    while (v3 != v5);
  }
}

void re::TypeRegistry::overrideAllocator(re *a1, re **a2, int a3)
{
  int v5;
  _BYTE v6[24];
  uint64_t v7;

  if (!*a2)
  {
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Invalid type ID.", "typeID.isValid()", "overrideAllocator", 787);
    _os_crash();
    __break(1u);
    goto LABEL_8;
  }
  if (*a2 != a1)
  {
LABEL_8:
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Wrong type registry.", "typeID.registry() == this", "overrideAllocator", 788);
    _os_crash();
    __break(1u);
    return;
  }
  re::TypeRegistry::typeInfo(a1, a2, v6);
  if (a3)
    v5 = 32;
  else
    v5 = 0;
  *(_DWORD *)(v7 + 48) = *(_DWORD *)(v7 + 48) & 0xFFFFFFDF | v5;
  ++*((_DWORD *)a1 + 6);
}

uint64_t re::TypeRegistry::buildTranslationTable(re::internal::TypeTranslationTable **this, const re::TypeRegistry *a2)
{
  re::internal::TypeTranslationTable *v4;
  re::internal::TypeTranslationTable *v5;
  uint64_t v6;
  uint64_t result;

  if (a2)
  {
    re::TypeRegistry::setContainsPolymorphicFlags((re::TypeRegistry *)this);
    v4 = this[107];
    if (v4)
    {
      v5 = this[2];
      re::internal::TypeTranslationTable::~TypeTranslationTable(this[107]);
      (*(void (**)(re::internal::TypeTranslationTable *, re::internal::TypeTranslationTable *))(*(_QWORD *)v5 + 40))(v5, v4);
      this[107] = 0;
    }
    v6 = (*(uint64_t (**)(re::internal::TypeTranslationTable *, uint64_t, uint64_t))(*(_QWORD *)this[2] + 32))(this[2], 288, 8);
    *(_QWORD *)v6 = this;
    *(_QWORD *)(v6 + 8) = a2;
    *(_OWORD *)(v6 + 40) = 0u;
    *(_OWORD *)(v6 + 56) = 0u;
    *(_OWORD *)(v6 + 72) = 0u;
    *(_OWORD *)(v6 + 88) = 0u;
    *(_OWORD *)(v6 + 104) = 0u;
    *(_OWORD *)(v6 + 120) = 0u;
    *(_OWORD *)(v6 + 136) = 0u;
    *(_OWORD *)(v6 + 152) = 0u;
    *(_OWORD *)(v6 + 168) = 0u;
    *(_OWORD *)(v6 + 184) = 0u;
    *(_OWORD *)(v6 + 200) = 0u;
    *(_OWORD *)(v6 + 216) = 0u;
    *(_OWORD *)(v6 + 232) = 0u;
    *(_OWORD *)(v6 + 248) = 0u;
    *(_QWORD *)(v6 + 280) = 0;
    *(_OWORD *)(v6 + 24) = 0u;
    *(_OWORD *)(v6 + 264) = 0u;
    result = re::internal::TypeTranslationTable::buildTables((re::internal::TypeTranslationTable *)v6);
    this[107] = (re::internal::TypeTranslationTable *)v6;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, 0, "assertion failure: '%s' (%s:line %i) runtimeTypeRegistry must not be null.", "runtimeTypeRegistry", "buildTranslationTable", 801);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeRegistry::setContainsPolymorphicFlags(re::TypeRegistry *this)
{
  char *v2;
  uint64_t result;
  re *v6;
  char *v9;
  _QWORD v10[4];
  re *v11[2];
  re *v12;
  char *v13;
  uint64_t v14;

  v2 = (char *)this + 32;
  result = re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::DataArrayIterator((uint64_t)&v9, (uint64_t)this + 32, 0);
  v12 = this;
  v13 = v9;
  v14 = v10[0];
  if (v2 != v9 || LOWORD(v10[0]) != 0xFFFFLL || (v10[0] & 0xFFFF0000) != 4294901760)
  {
    do
    {
      v6 = (re *)re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::handle((unsigned __int16 *)&v13);
      v11[0] = v12;
      v11[1] = v6;
      re::TypeRegistry::typeInfo(this, v11, &v9);
      if ((_BYTE)v9)
        re::TypeRegistry::setContainsPolymorphicFlag(this, (const re::TypeInfo *)v10);
      result = (uint64_t)re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::increment(&v13);
    }
    while (v13 != v2 || (unsigned __int16)v14 != 0xFFFF || WORD1(v14) != 0xFFFF);
  }
  return result;
}

uint64_t re::TypeRegistry::setContainsPolymorphicFlag(re::TypeRegistry *this, const re::TypeInfo *a2)
{
  uint64_t v2;
  unsigned int v3;
  const re::TypeInfo *v6;
  char v7;
  int v8;
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unsigned int v13;
  _BYTE v14[32];
  _QWORD *v15[4];
  uint64_t v16[4];
  unint64_t v17;
  _BYTE v18[8];
  uint64_t v19;
  _BYTE v20[8];
  _BYTE v21[32];

  v2 = *((_QWORD *)a2 + 2);
  v3 = *(_DWORD *)(v2 + 48);
  if ((v3 & 0x40) != 0)
    return (v3 >> 7) & 1;
  *(_DWORD *)(v2 + 48) = v3 | 0x40;
  switch(*((_BYTE *)a2 + 12))
  {
    case 0:
      re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Invalid type category.", "!\"Unreachable code\"", "setContainsPolymorphicFlag", 940);
      _os_crash();
      __break(1u);
      JUMPOUT(0x225B7F3BCLL);
    case 3:
    case 4:
    case 5:
      re::TypeRegistry::typeInfo(*(_QWORD **)a2, *(_QWORD *)(*((_QWORD *)a2 + 2) + 72), v20);
      re::TypeInfo::TypeInfo((uint64_t)v18, (uint64_t)v21);
      v6 = (const re::TypeInfo *)v18;
      goto LABEL_4;
    case 6:
      re::TypeRegistry::typeInfo(*(_QWORD **)a2, *(_QWORD *)(*((_QWORD *)a2 + 2) + 72), v20);
      re::TypeInfo::TypeInfo((uint64_t)v18, (uint64_t)v21);
      if (re::TypeRegistry::setContainsPolymorphicFlag(this, (const re::TypeInfo *)v18))
        goto LABEL_23;
      re::TypeRegistry::typeInfo(*(_QWORD **)a2, *(_QWORD *)(*((_QWORD *)a2 + 2) + 80), v20);
      re::TypeInfo::TypeInfo((uint64_t)v16, (uint64_t)v21);
      v6 = (const re::TypeInfo *)v16;
LABEL_4:
      v7 = re::TypeRegistry::setContainsPolymorphicFlag(this, v6);
      v8 = *(_DWORD *)(v2 + 48);
      if ((v7 & 1) != 0)
        goto LABEL_24;
      result = 0;
      goto LABEL_26;
    case 7:
      v10 = *(unsigned int *)(*((_QWORD *)a2 + 2) + 88);
      if (!(_DWORD)v10)
        goto LABEL_25;
      v11 = 0;
      while (1)
      {
        re::TypeInfo::unionMember(a2, v11, (uint64_t)v20);
        if ((re::TypeRegistry::setContainsPolymorphicFlag(this, (const re::TypeInfo *)v20) & 1) != 0)
          goto LABEL_23;
        if (v10 == ++v11)
          goto LABEL_25;
      }
    case 8:
      re::TypeRegistry::typeInfo(*(_QWORD **)a2, *(_QWORD *)(*((_QWORD *)a2 + 2) + 72), v18);
      if (v18[0] && re::TypeRegistry::setContainsPolymorphicFlag(this, (const re::TypeInfo *)&v19))
        goto LABEL_23;
      re::TypeMemberCollection::TypeMemberCollection((uint64_t)v16, *(_QWORD *)a2, *((_QWORD *)a2 + 2));
      if (!v17)
        goto LABEL_25;
      v12 = 0;
      break;
    case 9:
      if (re::TypeInfo::isPointerToPolymorphicType(a2))
        goto LABEL_23;
      re::TypeRegistry::typeInfo(*(_QWORD **)a2, *(_QWORD *)(*((_QWORD *)a2 + 2) + 72), v20);
      re::TypeInfo::TypeInfo((uint64_t)v18, (uint64_t)v21);
      if ((re::TypeRegistry::setContainsPolymorphicFlag(this, (const re::TypeInfo *)v18) & 1) != 0)
        goto LABEL_23;
      goto LABEL_25;
    default:
      goto LABEL_25;
  }
  do
  {
    re::TypeMemberCollection::operator[](v16, v12, (uint64_t)v15);
    re::TypeRegistry::typeInfo(v15[0], *v15[2], v20);
    re::TypeInfo::TypeInfo((uint64_t)v14, (uint64_t)v21);
    if ((re::TypeRegistry::setContainsPolymorphicFlag(this, (const re::TypeInfo *)v14) & 1) != 0)
    {
LABEL_23:
      v8 = *(_DWORD *)(v2 + 48);
LABEL_24:
      v13 = v8 | 0x80;
      result = 1;
      goto LABEL_27;
    }
    ++v12;
  }
  while (v12 < v17);
LABEL_25:
  result = 0;
  v8 = *(_DWORD *)(v2 + 48);
LABEL_26:
  v13 = v8 & 0xFFFFFF7F;
LABEL_27:
  *(_DWORD *)(v2 + 48) = v13;
  return result;
}

uint64_t re::TypeRegistry::fixupUndefinedInitialRelease(re::TypeRegistry *this)
{
  char *v2;
  uint64_t result;
  re *v6;
  char *v9;
  _QWORD v10[4];
  re *v11[2];
  re *v12;
  char *v13;
  uint64_t v14;

  v2 = (char *)this + 32;
  result = re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::DataArrayIterator((uint64_t)&v9, (uint64_t)this + 32, 0);
  v12 = this;
  v13 = v9;
  v14 = v10[0];
  if (v2 != v9 || LOWORD(v10[0]) != 0xFFFFLL || (v10[0] & 0xFFFF0000) != 4294901760)
  {
    do
    {
      v6 = (re *)re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::handle((unsigned __int16 *)&v13);
      v11[0] = v12;
      v11[1] = v6;
      re::TypeRegistry::typeInfo(this, v11, &v9);
      if ((_BYTE)v9)
        re::TypeRegistry::fixupUndefinedInitialRelease(this, (const re::TypeInfo *)v10);
      result = (uint64_t)re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::increment(&v13);
    }
    while (v13 != v2 || (unsigned __int16)v14 != 0xFFFF || WORD1(v14) != 0xFFFF);
  }
  return result;
}

_QWORD *re::TypeRegistry::fixupUndefinedInitialRelease(_QWORD *this, const re::TypeInfo *a2)
{
  uint64_t v2;
  _QWORD *v4;
  _DWORD *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  unsigned int v9;
  uint64_t v10;
  unsigned int v11;
  unsigned int v12;
  unint64_t v13;
  int v14;
  const char *v15;
  __int16 v16;
  _BYTE v17[14];
  __int16 v18;
  unint64_t v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  v2 = *((_QWORD *)a2 + 2);
  if (*(_DWORD *)(v2 + 64) == -1)
  {
    v4 = this;
    this = (_QWORD *)re::DataArray<re::internal::TypeInfoIndex>::get((uint64_t)(this + 4), *(_QWORD *)v2);
    v5 = this;
    v6 = *((unsigned __int8 *)a2 + 12);
    if (v6 == 6)
    {
      re::TypeRegistry::typeInfo(*(_QWORD **)a2, *(_QWORD *)(*((_QWORD *)a2 + 2) + 72), &v20);
      this = (_QWORD *)re::TypeInfo::TypeInfo((uint64_t)&v14, (uint64_t)&v20 + 8);
      v12 = *(_DWORD *)(*(_QWORD *)&v17[2] + 64);
      if (v12 == -1)
        return this;
      re::TypeRegistry::typeInfo(*(_QWORD **)a2, *(_QWORD *)(*((_QWORD *)a2 + 2) + 80), &v20);
      this = (_QWORD *)re::TypeInfo::TypeInfo((uint64_t)&v14, (uint64_t)&v20 + 8);
      v7 = *v5 & 0xFFFFFFLL;
      v8 = v4[63];
      if (v8 > v7)
      {
        v9 = *(_DWORD *)(*(_QWORD *)&v17[2] + 64);
        if (v12 > v9)
          v9 = v12;
        v10 = v4[65];
        v11 = 160;
        goto LABEL_12;
      }
    }
    else
    {
      if (v6 == 5)
      {
        re::TypeRegistry::typeInfo(*(_QWORD **)a2, *(_QWORD *)(*((_QWORD *)a2 + 2) + 72), &v20);
        this = (_QWORD *)re::TypeInfo::TypeInfo((uint64_t)&v14, (uint64_t)&v20 + 8);
        v7 = *v5 & 0xFFFFFFLL;
        v8 = v4[58];
        if (v8 > v7)
        {
          v9 = *(_DWORD *)(*(_QWORD *)&v17[2] + 64);
          v13 = v4[60] + (v7 << 7);
          goto LABEL_15;
        }
      }
      else
      {
        if (v6 != 4)
          return this;
        re::TypeRegistry::typeInfo(*(_QWORD **)a2, *(_QWORD *)(*((_QWORD *)a2 + 2) + 72), &v20);
        this = (_QWORD *)re::TypeInfo::TypeInfo((uint64_t)&v14, (uint64_t)&v20 + 8);
        v7 = *v5 & 0xFFFFFFLL;
        v8 = v4[53];
        if (v8 > v7)
        {
          v9 = *(_DWORD *)(*(_QWORD *)&v17[2] + 64);
          v10 = v4[55];
          v11 = 96;
LABEL_12:
          v13 = v10 + v7 * (unint64_t)v11;
LABEL_15:
          *(_DWORD *)(v13 + 64) = v9;
          return this;
        }
        v23 = 0u;
        v24 = 0u;
        v21 = 0u;
        v22 = 0u;
        v20 = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        v14 = 136315906;
        v15 = "operator[]";
        v16 = 1024;
        *(_DWORD *)v17 = 789;
        *(_WORD *)&v17[4] = 2048;
        *(_QWORD *)&v17[6] = v7;
        v18 = 2048;
        v19 = v8;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      v23 = 0u;
      v24 = 0u;
      v21 = 0u;
      v22 = 0u;
      v20 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v14 = 136315906;
      v15 = "operator[]";
      v16 = 1024;
      *(_DWORD *)v17 = 789;
      *(_WORD *)&v17[4] = 2048;
      *(_QWORD *)&v17[6] = v7;
      v18 = 2048;
      v19 = v8;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    v23 = 0u;
    v24 = 0u;
    v21 = 0u;
    v22 = 0u;
    v20 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v14 = 136315906;
    v15 = "operator[]";
    v16 = 1024;
    *(_DWORD *)v17 = 789;
    *(_WORD *)&v17[4] = 2048;
    *(_QWORD *)&v17[6] = v7;
    v18 = 2048;
    v19 = v8;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return this;
}

_anonymous_namespace_ *re::DataArray<re::internal::TypeInfoIndex>::allocBlock(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _anonymous_namespace_ *result;
  uint64_t v8;
  _anonymous_namespace_ *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t *v15;

  v3 = 4 * *((unsigned int *)a1 + 11);
  v4 = (*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(*(_QWORD *)*a1 + 32))(*a1, v3, 0);
  if (!v4)
  {
    re::internal::assertLog((re::internal *)6, v5, "assertion failure: '%s' (%s:line %i) DataArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "block.elements", "allocBlock", 520, v3, *(_QWORD *)(*a1 + 8));
    _os_crash();
    __break(1u);
    goto LABEL_16;
  }
  v6 = v4;
  v1 = 4 * *((unsigned int *)a1 + 11);
  result = (_anonymous_namespace_ *)(*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(*(_QWORD *)*a1 + 32))(*a1, v1, 0);
  if (!result)
  {
LABEL_16:
    re::internal::assertLog((re::internal *)6, v8, "assertion failure: '%s' (%s:line %i) DataArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "block.allocationCounters", "allocBlock", 528, v1, *(_QWORD *)(*a1 + 8));
    result = (_anonymous_namespace_ *)_os_crash();
    __break(1u);
    return result;
  }
  v9 = result;
  v11 = a1[1];
  v10 = a1[2];
  if (v10 >= v11)
  {
    v12 = v10 + 1;
    if (v11 < v10 + 1)
    {
      if (*a1)
      {
        v13 = 2 * v11;
        if (!v11)
          v13 = 8;
        if (v13 <= v12)
          v14 = v12;
        else
          v14 = v13;
        result = (_anonymous_namespace_ *)re::DynamicArray<re::RigNodeConstraint>::setCapacity(a1, v14);
      }
      else
      {
        result = (_anonymous_namespace_ *)re::DynamicArray<re::RigNodeConstraint>::setCapacity(a1, v12);
        ++*((_DWORD *)a1 + 6);
      }
    }
    v10 = a1[2];
  }
  v15 = (uint64_t *)(a1[4] + 16 * v10);
  *v15 = v6;
  v15[1] = (uint64_t)v9;
  a1[2] = v10 + 1;
  ++*((_DWORD *)a1 + 6);
  *((_DWORD *)a1 + 12) = 0;
  return result;
}

void re::internal::TypeTranslationTable::~TypeTranslationTable(re::internal::TypeTranslationTable *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v2 = *((_QWORD *)this + 33);
  if (v2)
  {
    if (*((_QWORD *)this + 34))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *((_QWORD *)this + 35));
      *((_QWORD *)this + 34) = 0;
      *((_QWORD *)this + 35) = 0;
    }
    *((_QWORD *)this + 33) = 0;
  }
  v3 = *((_QWORD *)this + 30);
  if (v3)
  {
    if (*((_QWORD *)this + 31))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *((_QWORD *)this + 32));
      *((_QWORD *)this + 31) = 0;
      *((_QWORD *)this + 32) = 0;
    }
    *((_QWORD *)this + 30) = 0;
  }
  v4 = *((_QWORD *)this + 27);
  if (v4)
  {
    if (*((_QWORD *)this + 28))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, *((_QWORD *)this + 29));
      *((_QWORD *)this + 28) = 0;
      *((_QWORD *)this + 29) = 0;
    }
    *((_QWORD *)this + 27) = 0;
  }
  v5 = *((_QWORD *)this + 24);
  if (v5)
  {
    if (*((_QWORD *)this + 25))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v5 + 40))(v5, *((_QWORD *)this + 26));
      *((_QWORD *)this + 25) = 0;
      *((_QWORD *)this + 26) = 0;
    }
    *((_QWORD *)this + 24) = 0;
  }
  v6 = *((_QWORD *)this + 21);
  if (v6)
  {
    if (*((_QWORD *)this + 22))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v6 + 40))(v6, *((_QWORD *)this + 23));
      *((_QWORD *)this + 22) = 0;
      *((_QWORD *)this + 23) = 0;
    }
    *((_QWORD *)this + 21) = 0;
  }
  v7 = *((_QWORD *)this + 18);
  if (v7)
  {
    if (*((_QWORD *)this + 19))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v7 + 40))(v7, *((_QWORD *)this + 20));
      *((_QWORD *)this + 19) = 0;
      *((_QWORD *)this + 20) = 0;
    }
    *((_QWORD *)this + 18) = 0;
  }
  v8 = *((_QWORD *)this + 15);
  if (v8)
  {
    if (*((_QWORD *)this + 16))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v8 + 40))(v8, *((_QWORD *)this + 17));
      *((_QWORD *)this + 16) = 0;
      *((_QWORD *)this + 17) = 0;
    }
    *((_QWORD *)this + 15) = 0;
  }
  v9 = *((_QWORD *)this + 12);
  if (v9)
  {
    if (*((_QWORD *)this + 13))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v9 + 40))(v9, *((_QWORD *)this + 14));
      *((_QWORD *)this + 13) = 0;
      *((_QWORD *)this + 14) = 0;
    }
    *((_QWORD *)this + 12) = 0;
  }
  v10 = *((_QWORD *)this + 9);
  if (v10)
  {
    if (*((_QWORD *)this + 10))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v10 + 40))(v10, *((_QWORD *)this + 11));
      *((_QWORD *)this + 10) = 0;
      *((_QWORD *)this + 11) = 0;
    }
    *((_QWORD *)this + 9) = 0;
  }
  v11 = *((_QWORD *)this + 6);
  if (v11)
  {
    if (*((_QWORD *)this + 7))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v11 + 40))(v11, *((_QWORD *)this + 8));
      *((_QWORD *)this + 7) = 0;
      *((_QWORD *)this + 8) = 0;
    }
    *((_QWORD *)this + 6) = 0;
  }
  v12 = *((_QWORD *)this + 3);
  if (v12)
  {
    if (*((_QWORD *)this + 4))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v12 + 40))(v12, *((_QWORD *)this + 5));
      *((_QWORD *)this + 4) = 0;
      *((_QWORD *)this + 5) = 0;
    }
    *((_QWORD *)this + 3) = 0;
  }
}

uint64_t re::HashTable<re::StringID,re::DataArrayHandle<re::internal::TypeInfoIndex>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addEmplace<re::DataArrayHandle<re::internal::TypeInfoIndex>&>(uint64_t a1, unsigned int a2, unint64_t a3, StringID *a4, _QWORD *a5)
{
  uint64_t v9;
  int v10;
  uint64_t v12;
  int v13;
  uint64_t v14;

  v9 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
    v9 = *(unsigned int *)(a1 + 32);
    v10 = v9;
    if ((_DWORD)v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::StringID,unsigned long long,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 32 * v9);
  }
  else
  {
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 32 * v9);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  v14 = 32 * v9;
  *(_DWORD *)(v12 + v14) = v13 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + v14) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  re::StringID::StringID((re::StringID *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 8), a4);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 24) = *a5;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

_QWORD *re::DynamicArray<re::TypeAttributeEntry>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _OWORD *v7;
  __int128 *v8;
  uint64_t v9;
  uint64_t v10;
  _OWORD *v11;
  __int128 v12;
  __int128 v13;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::TypeAttributeEntry>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x30uLL))
        {
          v2 = 48 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 48 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_16;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 48, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = (__int128 *)v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = 48 * v9;
        v11 = v7;
        do
        {
          v12 = *v8;
          v13 = v8[2];
          v11[1] = v8[1];
          v11[2] = v13;
          *v11 = v12;
          v11 += 3;
          v8 += 3;
          v10 -= 48;
        }
        while (v10);
        v8 = (__int128 *)v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, __int128 *))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

uint64_t re::TypeMemberInfo::memberType@<X0>(re::TypeMemberInfo *this@<X0>, uint64_t a2@<X8>)
{
  _BYTE v4[8];
  uint64_t v5;

  re::TypeRegistry::typeInfo(*(_QWORD **)this, **((_QWORD **)this + 2), v4);
  return re::TypeInfo::TypeInfo(a2, (uint64_t)&v5);
}

uint64_t re::TypeAttributeCollection::operator[](uint64_t *a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;
  uint64_t v5[2];
  int v6;

  if (!*a2)
    return 0;
  v3 = *a1;
  v2 = a1[1];
  v5[0] = a2[1];
  v5[1] = v2;
  v6 = *((_DWORD *)a1 + 4);
  result = re::HashTable<re::internal::TypeAttributeKey,re::internal::TypeAttributeData,re::Hash<re::internal::TypeAttributeKey>,re::EqualTo<re::internal::TypeAttributeKey>,true,false>::tryGet(v3 + 768, v5);
  if (result)
    return *(_QWORD *)result;
  return result;
}

{
  uint64_t v3;
  uint64_t *v4;
  uint64_t v6;
  uint64_t v7;

  v3 = *a1;
  v4 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(*a1 + 200, a2);
  if (v4)
  {
    v7 = *v4;
  }
  else
  {
    v3 = 0;
    v7 = 0xFFFFFFFFLL;
  }
  v6 = v3;
  return re::TypeAttributeCollection::operator[](a1, &v6);
}

void re::ArrayAccessor::reset(re::ArrayAccessor *this, void **a2, re::Allocator *a3, const re::TypeInfo *a4)
{
  _QWORD *v8;
  unsigned int v9;
  uint64_t v10;
  re::internal *v11;
  const re::TypeInfo *v12;
  uint64_t Unsigned;
  uint64_t v14;
  uint64_t i;
  void *v16;
  uint64_t v17;
  void **v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  uint64_t j;
  void *v23;
  size_t v24;
  _QWORD v25[4];
  _BYTE v26[16];
  unsigned int *v27;
  _BYTE v28[8];
  _BYTE v29[32];

  v8 = *(_QWORD **)this;
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), v28);
  re::TypeInfo::TypeInfo((uint64_t)v26, (uint64_t)v29);
  v9 = v27[12];
  v10 = *((_QWORD *)this + 2);
  if ((*(_DWORD *)(v10 + 84) & 0xFFFFFF) != 0)
  {
    re::TypeRegistry::typeInfo(v8, *(_QWORD *)(v10 + 80), v28);
    re::TypeInfo::TypeInfo((uint64_t)v25, (uint64_t)v29);
    v11 = (re::internal *)((char *)a2 + *(int *)(*((_QWORD *)this + 2) + 88));
    Unsigned = re::internal::readUnsigned(v11, v25, v12);
    if (Unsigned)
    {
      if ((v9 & 1) == 0)
      {
        v14 = Unsigned;
        for (i = 0; i != v14; ++i)
        {
          v16 = (void *)re::ArrayAccessor::elementAtUnchecked(this, a2, i);
          re::TypeInfo::destruct((re::TypeInfo *)v26, v16, a3, 0);
        }
      }
      (*(void (**)(re::Allocator *, void *))(*(_QWORD *)a3 + 40))(a3, *a2);
      re::internal::writeUnsigned(v11, v25, 0);
      *a2 = 0;
    }
    if (a4)
    {
      v17 = re::internal::checkedArraySize(v27[2], (unint64_t)a4);
      re::internal::writeUnsigned(v11, v25, a4);
      v18 = (void **)(*(uint64_t (**)(re::Allocator *, uint64_t, _QWORD))(*(_QWORD *)a3 + 32))(a3, v17, v27[3]);
      *a2 = v18;
      if ((v9 & 1) == 0)
      {
        v19 = 0;
        do
        {
          v20 = (void *)re::ArrayAccessor::elementAtUnchecked(this, a2, v19);
          re::TypeInfo::construct((re::TypeInfo *)v26, v20, a3, 0);
          ++v19;
        }
        while (a4 != (const re::TypeInfo *)v19);
        return;
      }
      v24 = v17;
LABEL_19:
      bzero(v18, v24);
    }
  }
  else
  {
    v21 = *(int *)(v10 + 88);
    if (!(_DWORD)v21)
      return;
    if ((v9 & 1) != 0)
    {
      v24 = re::internal::checkedArraySize(v27[2], (unint64_t)a4);
      v18 = a2;
      goto LABEL_19;
    }
    for (j = 0; j != v21; ++j)
    {
      v23 = (void *)re::ArrayAccessor::elementAtUnchecked(this, a2, j);
      re::TypeInfo::destruct((re::TypeInfo *)v26, v23, a3, 0);
      re::TypeInfo::construct((re::TypeInfo *)v26, v23, a3, 0);
    }
  }
}

uint64_t re::ArrayAccessor::elementAtUnchecked(re::ArrayAccessor *this, void **a2, uint64_t a3)
{
  _BYTE v7[16];
  uint64_t v8;
  _BYTE v9[8];
  uint64_t v10;

  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), v9);
  re::TypeInfo::TypeInfo((uint64_t)v7, (uint64_t)&v10);
  if ((*(_DWORD *)(*((_QWORD *)this + 2) + 84) & 0xFFFFFF) != 0)
    a2 = (void **)*a2;
  return (uint64_t)a2 + *(unsigned int *)(v8 + 8) * a3;
}

uint64_t re::ArrayAccessor::size(re::ArrayAccessor *this, char *a2)
{
  uint64_t v2;
  const re::TypeInfo *v5;
  _QWORD v7[4];
  _BYTE v8[8];
  uint64_t v9;

  v2 = *((_QWORD *)this + 2);
  if ((*(_DWORD *)(v2 + 84) & 0xFFFFFF) == 0)
    return *(int *)(v2 + 88);
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(v2 + 80), v8);
  re::TypeInfo::TypeInfo((uint64_t)v7, (uint64_t)&v9);
  return re::internal::readUnsigned((re::internal *)&a2[*(int *)(*((_QWORD *)this + 2) + 88)], v7, v5);
}

uint64_t re::IntrospectionWalker::walkPolymorphicPointer(uint64_t a1, uint64_t a2, uint64_t a3)
{
  const void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t __dst;

  v6 = *(const void **)a1;
  v7 = *(_QWORD *)(a1 + 8);
  __dst = 0;
  memcpy(&__dst, v6, *(int *)(v7 + 20));
  v8 = 0;
  v9 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
  if (*(_QWORD *)(v9 + 24) != __dst)
  {
    v8 = 0;
    v10 = (uint64_t *)(v9 + 64);
    do
    {
      ++v8;
      v11 = *v10;
      v10 += 5;
    }
    while (v11 != __dst);
  }
  return re::IntrospectionWalker::walk(*(_QWORD *)(v9 + 40 * v8 + 8), a2 + *(int *)(v9 + 40 * v8 + 32), a3);
}

void re::IntrospectionWalker::walk(_QWORD *a1, const re::IntrospectionBase **a2, uint64_t a3)
{
  uint64_t v4;
  re *v7;
  uint64_t v8;
  const re::IntrospectionBase *v9;
  int v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  __int128 *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  re *v29;
  _OWORD *v30;
  uint64_t v31;
  _OWORD *v32;
  uint64_t v33;
  uint64_t v34;
  _QWORD *v35;
  _DWORD *v36;
  _DWORD **v37;
  uint64_t v38;
  _DWORD *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t i;
  uint64_t v44;
  uint64_t v45;
  BOOL v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  NSObject *v50;
  uint64_t v51;
  const char *v52;
  uint64_t v53;
  void (**v54)(re::IntrospectionPointer *__hidden);
  _QWORD v55[2];
  int v56;
  __int16 v57;
  uint64_t v58;
  uint64_t v59;
  __int128 *v60;
  _QWORD *v61;
  unint64_t __dst;
  __int128 buf;
  uint64_t v64;
  __int128 *p_buf;
  uint64_t v66;
  _QWORD *v67;
  uint64_t v68;

  v68 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)&buf = a2;
  v4 = *(_QWORD *)(a3 + 24);
  if (!v4)
    std::__throw_bad_function_call[abi:nn180100]();
  v7 = (re *)(*(uint64_t (**)(uint64_t, _QWORD *, __int128 *))(*(_QWORD *)v4 + 48))(v4, a1, &buf);
  switch(*((_DWORD *)a1 + 4))
  {
    case 0:
    case 6:
    case 9:
    case 0xA:
      return;
    case 1:
      v9 = *a2;
      if (!v9)
        return;
      re::PolymorphicData::makeWithPointer(a1[6], v9, &buf);
      if (v64)
      {
        re::IntrospectionWalker::walkPolymorphicPointer((uint64_t)&buf, (uint64_t)v9, a3);
      }
      else
      {
        v49 = a1[6];
        v48 = (uint64_t)v9;
LABEL_69:
        re::IntrospectionWalker::walk(v49, v48, a3);
      }
      return;
    case 2:
      if (*((int *)a1 + 16) >= 1)
      {
        v10 = 0;
        do
          re::IntrospectionWalker::walk(a1[6], (char *)a2 + *(int *)(a1[6] + 20) * (uint64_t)v10++, a3);
        while (v10 < *((_DWORD *)a1 + 16));
      }
      return;
    case 3:
      if ((*(uint64_t (**)(_QWORD *, const re::IntrospectionBase **))(*a1 + 88))(a1, a2))
      {
        v11 = 0;
        do
        {
          v12 = a1[6];
          v13 = (*(uint64_t (**)(_QWORD *, const re::IntrospectionBase **, unint64_t))(*a1 + 104))(a1, a2, v11);
          re::IntrospectionWalker::walk(v12, v13, a3);
          ++v11;
        }
        while ((*(uint64_t (**)(_QWORD *, const re::IntrospectionBase **))(*a1 + 88))(a1, a2) > v11);
      }
      return;
    case 4:
      if ((*(uint64_t (**)(_QWORD *, const re::IntrospectionBase **))(*a1 + 80))(a1, a2))
      {
        v14 = 0;
        do
        {
          v15 = a1[6];
          v16 = (*(uint64_t (**)(_QWORD *, const re::IntrospectionBase **, unint64_t))(*a1 + 104))(a1, a2, v14);
          re::IntrospectionWalker::walk(v15, v16, a3);
          ++v14;
        }
        while ((*(uint64_t (**)(_QWORD *, const re::IntrospectionBase **))(*a1 + 80))(a1, a2) > v14);
      }
      return;
    case 5:
      *(_QWORD *)&buf = (*(uint64_t (**)(_QWORD *, const re::IntrospectionBase **))(*a1 + 88))(a1, a2);
      *((_QWORD *)&buf + 1) = v17;
      while (1)
      {
        v18 = (*(uint64_t (**)(_QWORD *, const re::IntrospectionBase **))(*a1 + 96))(a1, a2);
        if ((_QWORD)buf == v18 && WORD4(buf) == (unsigned __int16)v19 && WORD5(buf) == HIWORD(v19))
          break;
        v20 = a1[6];
        v21 = (*(uint64_t (**)(_QWORD *, __int128 *))(*a1 + 104))(a1, &buf);
        re::IntrospectionWalker::walk(v20, v21, a3);
        re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::increment(&buf);
      }
      return;
    case 7:
      *(_QWORD *)&buf = &off_24ED7DBD8;
      *((_QWORD *)&buf + 1) = a1;
      v64 = a3;
      p_buf = &buf;
      (*(void (**)(_QWORD *, const re::IntrospectionBase **, __int128 *))(*a1 + 104))(a1, a2, &buf);
      v22 = p_buf;
      if (p_buf == &buf)
      {
        v23 = 4;
        v22 = &buf;
      }
      else
      {
        if (!p_buf)
          return;
        v23 = 5;
      }
      (*(void (**)(void))(*(_QWORD *)v22 + 8 * v23))();
      return;
    case 8:
      if (!*((_DWORD *)a1 + 14))
        return;
      v24 = 0;
      break;
    case 0xB:
      if (a1[13])
      {
        v41 = ((uint64_t (*)(const re::IntrospectionBase **))a1[12])(a2);
        if (v41)
        {
          v42 = v41;
          for (i = 0; i != v42; ++i)
          {
            v44 = ((uint64_t (*)(uint64_t, const re::IntrospectionBase **))a1[13])(i, a2);
            if (v44)
              v46 = v45 == 0;
            else
              v46 = 1;
            if (!v46)
              re::IntrospectionWalker::walk(v44, v45, a3);
          }
        }
      }
      return;
    case 0xD:
      if (!(*(unsigned int (**)(_QWORD *, const re::IntrospectionBase **))(*a1 + 56))(a1, a2))
        return;
      v47 = a1[6];
      v48 = (*(uint64_t (**)(_QWORD *, const re::IntrospectionBase **))(*a1 + 80))(a1, a2);
      v49 = v47;
      goto LABEL_69;
    default:
LABEL_77:
      re::internal::assertLog((re::internal *)4, v8, "assertion failure: '%s' (%s:line %i) ", "!\"Unreachable code\"", "walk", 156);
      _os_crash();
      __break(1u);
      JUMPOUT(0x225B80A94);
  }
  while (2)
  {
    v25 = *(_QWORD *)(a1[8] + 8 * v24);
    if (*(_DWORD *)v25 != 1)
      goto LABEL_52;
    switch(*(_DWORD *)(v25 + 40))
    {
      case 0:
      case 3:
        v7 = (re *)re::IntrospectionWalker::walk(*(_QWORD *)(v25 + 16), (char *)a2 + *(int *)(v25 + 36), a3);
        goto LABEL_52;
      case 1:
        v26 = *(_QWORD *)(v25 + 48);
        if (v26)
        {
          v27 = *(_QWORD *)(v25 + 16);
          v28 = (char *)a2 + *(int *)(v25 + 64);
          __dst = 0;
          v29 = (re *)memcpy(&__dst, v28, *(int *)(v26 + 20));
          if (__dst >> 31)
          {
            v50 = *re::foundationIntrospectionLogObjects(v29);
            if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
            {
              v53 = *(_QWORD *)(v25 + 8);
              LODWORD(buf) = 136315138;
              *(_QWORD *)((char *)&buf + 4) = v53;
              v52 = "Array too big for member '%s'.";
LABEL_74:
              _os_log_impl(&dword_224FE9000, v50, OS_LOG_TYPE_DEFAULT, v52, (uint8_t *)&buf, 0xCu);
            }
            return;
          }
          re::IntrospectionCStyleArray::IntrospectionCStyleArray((re::IntrospectionCStyleArray *)&buf, *(const re::IntrospectionBase **)(v27 + 48), __dst);
          ArcSharedObject::ArcSharedObject((ArcSharedObject *)&v54, 0);
          v55[1] = 0x800000001;
          v56 = 8;
          v57 = 0;
          v58 = 0;
          v59 = 0xFFFFFFFFLL;
          v54 = &off_24ED30800;
          v60 = &buf;
          v61 = 0;
          re::IntrospectionWalker::walk(&v54, (char *)a2 + *(int *)(v25 + 36), a3);
          v54 = &off_24ED30800;
          v60 = 0;
          v30 = v61;
          if (v61)
          {
            v31 = *v61;
            if (*v61)
            {
              if ((v61[1] & 1) != 0)
                (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)v31 + 40))(*v61, v61[2]);
              *v30 = 0u;
              v30[1] = 0u;
            }
            (*(void (**)(uint64_t, _OWORD *))(*(_QWORD *)v31 + 40))(v31, v30);
            v61 = 0;
          }
          v54 = &off_24ED426B8;
          objc_destructInstance(v55);
          *(_QWORD *)&buf = &off_24ED23640;
          v66 = 0;
          v32 = v67;
          if (v67)
          {
            v33 = *v67;
            if (*v67)
            {
              if ((v67[1] & 1) != 0)
                (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)v33 + 40))(*v67, v67[2]);
              *v32 = 0u;
              v32[1] = 0u;
            }
            (*(void (**)(uint64_t, _OWORD *))(*(_QWORD *)v33 + 40))(v33, v32);
            v67 = 0;
          }
          *(_QWORD *)&buf = &off_24ED426B8;
          v7 = (re *)objc_destructInstance((char *)&buf + 8);
LABEL_52:
          if (++v24 >= (unint64_t)*((unsigned int *)a1 + 14))
            return;
          continue;
        }
        v50 = *re::foundationIntrospectionLogObjects(v7);
        if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
        {
          v51 = *(_QWORD *)(v25 + 8);
          LODWORD(buf) = 136315138;
          *(_QWORD *)((char *)&buf + 4) = v51;
          v52 = "Failed to get array length for member '%s'.";
          goto LABEL_74;
        }
        return;
      case 2:
        v8 = *(uint64_t *)((char *)a2 + *(int *)(v25 + 36));
        if (v8)
        {
          v34 = *(_QWORD *)(*(_QWORD *)(v25 + 16) + 48);
          v35 = *(_QWORD **)(v34 + 64);
          v36 = (_DWORD *)*v35;
          if (*(_DWORD *)*v35 != 2)
          {
            v37 = (_DWORD **)(v35 + 1);
            v38 = *(unsigned int *)(v34 + 56) - 1;
            do
            {
              v39 = *v37++;
              v36 = v39;
              --v38;
            }
            while (*v39 != 2);
          }
          v40 = *(_QWORD *)(v25 + 48);
          *(_QWORD *)&buf = (char *)a2 + *(int *)(v25 + 64);
          *((_QWORD *)&buf + 1) = v40;
          v64 = *((_QWORD *)v36 + 1);
          v7 = (re *)re::IntrospectionWalker::walkPolymorphicPointer((uint64_t)&buf, v8, a3);
        }
        goto LABEL_52;
      default:
        re::internal::assertLog((re::internal *)4, v8, "assertion failure: '%s' (%s:line %i) ", "!\"Unreachable code\"", "walkStructure", 63);
        _os_crash();
        __break(1u);
        goto LABEL_77;
    }
  }
}

void std::__function::__func<re::IntrospectionWalker::walk(re::IntrospectionBase const&,void const*,std::function<void ()(re::IntrospectionBase const&,void const*)> const&)::$_0,std::allocator<re::IntrospectionWalker::walk(re::IntrospectionBase const&,void const*,std::function<void ()(re::IntrospectionBase const&,void const*)> const&)::$_0>,BOOL ()(void const*,void *)>::~__func()
{
  JUMPOUT(0x2276933B8);
}

__n128 std::__function::__func<re::IntrospectionWalker::walk(re::IntrospectionBase const&,void const*,std::function<void ()(re::IntrospectionBase const&,void const*)> const&)::$_0,std::allocator<re::IntrospectionWalker::walk(re::IntrospectionBase const&,void const*,std::function<void ()(re::IntrospectionBase const&,void const*)> const&)::$_0>,BOOL ()(void const*,void *)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_24ED7DBD8;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<re::IntrospectionWalker::walk(re::IntrospectionBase const&,void const*,std::function<void ()(re::IntrospectionBase const&,void const*)> const&)::$_0,std::allocator<re::IntrospectionWalker::walk(re::IntrospectionBase const&,void const*,std::function<void ()(re::IntrospectionBase const&,void const*)> const&)::$_0>,BOOL ()(void const*,void *)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_24ED7DBD8;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<re::IntrospectionWalker::walk(re::IntrospectionBase const&,void const*,std::function<void ()(re::IntrospectionBase const&,void const*)> const&)::$_0,std::allocator<re::IntrospectionWalker::walk(re::IntrospectionBase const&,void const*,std::function<void ()(re::IntrospectionBase const&,void const*)> const&)::$_0>,BOOL ()(void const*,void *)>::operator()(uint64_t a1, const re::IntrospectionBase ***a2, const re::IntrospectionBase ***a3)
{
  const re::IntrospectionBase **v4;

  v4 = *a3;
  re::IntrospectionWalker::walk(*(_QWORD **)(*(_QWORD *)(a1 + 8) + 48), *a2, *(_QWORD *)(a1 + 16));
  re::IntrospectionWalker::walk(*(_QWORD **)(*(_QWORD *)(a1 + 8) + 64), v4, *(_QWORD *)(a1 + 16));
  return 1;
}

uint64_t std::__function::__func<re::IntrospectionWalker::walk(re::IntrospectionBase const&,void const*,std::function<void ()(re::IntrospectionBase const&,void const*)> const&)::$_0,std::allocator<re::IntrospectionWalker::walk(re::IntrospectionBase const&,void const*,std::function<void ()(re::IntrospectionBase const&,void const*)> const&)::$_0>,BOOL ()(void const*,void *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::IntrospectionWalker::walk(re::IntrospectionBase const&,void const*,std::function<void ()(re::IntrospectionBase const&,void const*)> const&)::$_0,std::allocator<re::IntrospectionWalker::walk(re::IntrospectionBase const&,void const*,std::function<void ()(re::IntrospectionBase const&,void const*)> const&)::$_0>,BOOL ()(void const*,void *)>::target_type()
{
}

uint64_t re::internal::readUnsigned(re::internal *this, _QWORD *a2, const re::TypeInfo *a3)
{
  uint64_t result;

  switch(*(_DWORD *)(a2[2] + 8))
  {
    case 1:
      result = *(unsigned __int8 *)this;
      break;
    case 2:
      result = *(unsigned __int16 *)this;
      break;
    case 4:
      result = *(unsigned int *)this;
      break;
    case 8:
      result = *(_QWORD *)this;
      break;
    default:
      re::internal::assertLog((re::internal *)5, (uint64_t)a2, a3, "assertion failure: '%s' (%s:line %i) Unsupported integer type. Size of type in bytes: %zu", "!\"Unreachable code\"", "readUnsigned", 29, *(unsigned int *)(a2[2] + 8));
      _os_crash();
      __break(1u);
      JUMPOUT(0x225B80C78);
  }
  return result;
}

_BYTE *re::internal::writeUnsigned(_BYTE *this, _QWORD *a2, const re::TypeInfo *a3)
{
  switch(*(_DWORD *)(a2[2] + 8))
  {
    case 1:
      *this = (_BYTE)a3;
      break;
    case 2:
      *(_WORD *)this = (_WORD)a3;
      break;
    case 4:
      *(_DWORD *)this = (_DWORD)a3;
      break;
    case 8:
      *(_QWORD *)this = a3;
      break;
    default:
      re::internal::assertLog((re::internal *)5, (uint64_t)a2, a3, "assertion failure: '%s' (%s:line %i) Unsupported integer type. Size of type in bytes: %zu", "!\"Unreachable code\"", "writeUnsigned", 55, *(unsigned int *)(a2[2] + 8));
      _os_crash();
      __break(1u);
      JUMPOUT(0x225B80D38);
  }
  return this;
}

uint64_t re::internal::checkedArraySize(unint64_t this, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;

  if (is_mul_ok(this, a2))
    return this * a2;
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in array. Element size = %zu bytes, count = %zu", "!overflow", "checkedArraySize", 65, this, a2, v2, v3);
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::UnionAccessor::memberType@<X0>(re::UnionAccessor *this@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4;
  _QWORD *v5;
  unint64_t v6;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v4 = *((_QWORD *)this + 2);
  if (*(unsigned int *)(v4 + 88) <= a2)
  {
    v11 = 0u;
    v12 = 0u;
    v9 = 0u;
    v10 = 0u;
    v8 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_5:
    v11 = 0u;
    v12 = 0u;
    v9 = 0u;
    v10 = 0u;
    v8 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  v5 = *(_QWORD **)this;
  v6 = *(unsigned int *)(v4 + 84) + a2;
  if (v5[73] <= v6)
    goto LABEL_5;
  re::TypeRegistry::typeInfo(v5, *(_QWORD *)(v5[75] + 8 * v6), &v8);
  return re::TypeInfo::TypeInfo(a3, (uint64_t)&v8 + 8);
}

unint64_t re::UnionAccessor::activeMemberType@<X0>(re::UnionAccessor *this@<X0>, char *a2@<X1>, _BYTE *a3@<X8>)
{
  unint64_t result;
  _BYTE v6[32];

  result = re::UnionAccessor::readTag(this, a2);
  if (result >= *(unsigned int *)(*((_QWORD *)this + 2) + 88))
  {
    *a3 = 0;
  }
  else
  {
    re::UnionAccessor::memberType(this, result, (uint64_t)v6);
    *a3 = 1;
    return re::TypeInfo::TypeInfo((uint64_t)(a3 + 8), (uint64_t)v6);
  }
  return result;
}

uint64_t re::UnionAccessor::readTag(re::UnionAccessor *this, char *a2)
{
  const re::TypeInfo *v4;
  _QWORD v6[4];
  _BYTE v7[8];
  uint64_t v8;

  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), v7);
  re::TypeInfo::TypeInfo((uint64_t)v6, (uint64_t)&v8);
  return re::internal::readUnsigned((re::internal *)&a2[*(int *)(*((_QWORD *)this + 2) + 80)], v6, v4);
}

_BYTE *re::UnionAccessor::reset(re::UnionAccessor *this, char *a2, const re::TypeInfo *a3, re::Allocator *a4)
{
  re::internal *v8;
  const re::TypeInfo *v9;
  unint64_t Unsigned;
  unint64_t v11;
  _QWORD v13[4];
  _BYTE v14[8];
  uint64_t v15;

  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), v14);
  re::TypeInfo::TypeInfo((uint64_t)v13, (uint64_t)&v15);
  v8 = (re::internal *)&a2[*(int *)(*((_QWORD *)this + 2) + 80)];
  Unsigned = re::internal::readUnsigned(v8, v13, v9);
  v11 = *(unsigned int *)(*((_QWORD *)this + 2) + 88);
  if (Unsigned < v11)
  {
    re::UnionAccessor::memberType(this, Unsigned, (uint64_t)v14);
    re::TypeInfo::destruct((re::TypeInfo *)v14, a2, a4, 0);
    v11 = *(unsigned int *)(*((_QWORD *)this + 2) + 88);
  }
  if (v11 > (unint64_t)a3)
  {
    re::UnionAccessor::memberType(this, (unint64_t)a3, (uint64_t)v14);
    re::TypeInfo::construct((re::TypeInfo *)v14, (void **)a2, a4, 0);
  }
  return re::internal::writeUnsigned(v8, v13, a3);
}

void re::TypeBuilderHelper::registerArray(re::TypeRegistry *a1@<X0>, uint64_t *a2@<X1>, __int128 *a3@<X2>, unint64_t a4@<X3>, re::TypeRegistry **a5@<X8>)
{
  _anonymous_namespace_ *v10;
  re::TypeRegistry *v11;
  uint64_t v12;
  __int128 v13;
  _BYTE v14[488];

  v10 = (_anonymous_namespace_ *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a1 + 200, a2);
  if (a1 && v10)
  {
    v11 = *(re::TypeRegistry **)v10;
    *a5 = a1;
    a5[1] = v11;
  }
  else
  {
    v13 = *a3;
    re::TypeBuilder::beginArrayType((uint64_t)v14, a2, (re **)&v13, a4);
    re::TypeBuilder::commitTo((re::TypeBuilder *)v14, a1, a5);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v14, v12);
  }
}

void re::TypeBuilderHelper::registerPointer(re::TypeRegistry *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, char a4@<W3>, re::TypeRegistry **a5@<X8>)
{
  _anonymous_namespace_ *v10;
  re::TypeRegistry *v11;
  uint64_t v12;
  uint64_t v13;
  char v14[8];
  unint64_t v15;
  int v16;
  int v17;
  _OWORD v18[2];
  __int128 v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  char v23;
  uint64_t v24;
  int v25;

  v10 = (_anonymous_namespace_ *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)a1 + 200, a2);
  if (a1 && v10)
  {
    v11 = *(re::TypeRegistry **)v10;
    *a5 = a1;
    a5[1] = v11;
  }
  else
  {
    v12 = *(_QWORD *)(a3 + 8);
    v17 = -1;
    memset(v18, 0, sizeof(v18));
    v19 = 0u;
    v20 = 0xFFFFFFFFLL;
    v21 = 1;
    v22 = 0xFFFFFFFFLL;
    v23 = 1;
    v24 = 0xFFFFFFFFLL;
    v25 = 0;
    v14[0] = 9;
    re::StringID::operator=(&v15, a2);
    v16 = 1;
    *(_OWORD *)((char *)v18 + 4) = 0x800000008uLL;
    *(_QWORD *)((char *)&v19 + 4) = 0;
    *(_QWORD *)((char *)&v18[1] + 4) = 0;
    v21 = -1;
    v22 = v12;
    v23 = a4;
    re::TypeBuilder::commitTo((re::TypeBuilder *)v14, a1, a5);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v14, v13);
  }
}

void re::TypeBuilderHelper::registerCString(re::TypeBuilderHelper *this@<X0>, _QWORD *a2@<X8>)
{
  _anonymous_namespace_ *v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD v8[2];
  _BYTE v9[488];
  uint64_t v10[2];

  v10[0] = 189247272;
  v10[1] = (uint64_t)"char*";
  v5 = (_anonymous_namespace_ *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)this + 200, v10);
  if (this && v5)
  {
    v6 = *(_QWORD *)v5;
    *a2 = this;
    a2[1] = v6;
  }
  else
  {
    v8[0] = 0;
    v8[1] = 0xFFFFFFFFLL;
    re::TypeBuilder::beginObjectType((uint64_t)v9, v10, 1, 1, 8uLL, 8uLL, (uint64_t)v8);
    re::TypeBuilder::setHasKnownSize(v9, 0);
    re::TypeBuilder::commitTo((re::TypeBuilder *)v9, this, a2);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v9, v7);
  }
  re::StringID::destroyString((re::StringID *)v10);
}

void re::TypeBuilderHelper::registerDynamicString(re::TypeBuilderHelper *this@<X0>, _QWORD *a2@<X8>)
{
  _anonymous_namespace_ *v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD v8[2];
  _BYTE v9[488];
  uint64_t v10[2];

  v10[0] = 0x2686EB529B3EE220;
  v10[1] = (uint64_t)"DynamicString";
  v5 = (_anonymous_namespace_ *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)this + 200, v10);
  if (this && v5)
  {
    v6 = *(_QWORD *)v5;
    *a2 = this;
    a2[1] = v6;
  }
  else
  {
    v8[0] = 0;
    v8[1] = 0xFFFFFFFFLL;
    re::TypeBuilder::beginObjectType((uint64_t)v9, v10, 1, 1, 0x20uLL, 8uLL, (uint64_t)v8);
    re::TypeBuilder::setConstructor((uint64_t)v9, (uint64_t)re::TypeBuilderHelper::registerDynamicString(re::TypeRegistry *)::$_0::__invoke);
    re::TypeBuilder::setDestructor((uint64_t)v9, (uint64_t)re::TypeBuilder::setDefaultDestructor<re::DynamicString>(void)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
    re::TypeBuilder::setHasKnownSize(v9, 0);
    re::TypeBuilder::commitTo((re::TypeBuilder *)v9, this, a2);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v9, v7);
  }
  re::StringID::destroyString((re::StringID *)v10);
}

void re::TypeBuilderHelper::registerStringID(re::TypeBuilderHelper *this@<X0>, _QWORD *a2@<X8>)
{
  _anonymous_namespace_ *v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD v8[2];
  _BYTE v9[488];
  uint64_t v10[2];

  v10[0] = 0x458DDB01A18;
  v10[1] = (uint64_t)"StringID";
  v5 = (_anonymous_namespace_ *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)this + 200, v10);
  if (this && v5)
  {
    v6 = *(_QWORD *)v5;
    *a2 = this;
    a2[1] = v6;
  }
  else
  {
    v8[0] = 0;
    v8[1] = 0xFFFFFFFFLL;
    re::TypeBuilder::beginObjectType((uint64_t)v9, v10, 1, 1, 0x10uLL, 8uLL, (uint64_t)v8);
    re::TypeBuilder::setConstructor((uint64_t)v9, (uint64_t)re::TypeBuilder::setDefaultConstructor<re::StringID>(void)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
    re::TypeBuilder::setDestructor((uint64_t)v9, (uint64_t)re::TypeBuilder::setDefaultDestructor<re::StringID>(void)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
    re::TypeBuilder::setHasKnownSize(v9, 0);
    re::TypeBuilder::commitTo((re::TypeBuilder *)v9, this, a2);
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v9, v7);
  }
  re::StringID::destroyString((re::StringID *)v10);
}

_QWORD *re::TypeBuilderHelper::registerDynamicString(re::TypeRegistry *)::$_0::__invoke(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  a1[2] = 0;
  a1[3] = 0;
  *a1 = a3;
  a1[1] = 0;
  return re::DynamicString::setCapacity(a1, 0);
}

double re::TypeBuilder::setDefaultDestructor<re::DynamicString>(void)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t *a1)
{
  uint64_t v2;
  double result;

  v2 = *a1;
  if (v2)
  {
    if ((a1[1] & 1) != 0)
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[2]);
    result = 0.0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
  }
  return result;
}

_QWORD *re::TypeBuilder::setDefaultConstructor<re::StringID>(void)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(_QWORD *result)
{
  *result = 0;
  result[1] = &str_110;
  return result;
}

float32x4_t re::lerp<float>@<Q0>(float32x4_t *a1@<X0>, float32x4_t *a2@<X1>, float32x4_t *a3@<X8>, float a4@<S0>)
{
  float v7;
  float32x4_t v8;
  float32x4_t v9;
  float32x4_t v10;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;
  int8x16_t v14;
  float32x4_t v15;
  int8x16_t v16;
  float v17;
  float v18;
  BOOL v19;
  float v20;
  float v21;
  float32x2_t v22;
  float32x2_t v23;
  float v24;
  float v25;
  float32x4_t v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float32x4_t v31;
  int8x16_t v32;
  float32x2_t v33;
  uint64_t v34;
  uint64_t v35;
  unsigned __int32 v36;
  float32x2_t v37;
  float32x2_t v38;
  float32x4_t v39;
  float32x4_t result;
  float32x4_t v41;
  float32x4_t v42;
  float v43;
  float v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float v50;

  v7 = 1.0;
  v50 = 1.0 - a4;
  v8 = a1[1];
  v47 = *a2;
  v48 = *a1;
  v9 = a2[1];
  v10 = vmulq_f32(v8, v9);
  v11 = (float32x4_t)vextq_s8((int8x16_t)v10, (int8x16_t)v10, 8uLL);
  *(float32x2_t *)v10.f32 = vadd_f32(*(float32x2_t *)v10.f32, *(float32x2_t *)v11.f32);
  v10.f32[0] = vaddv_f32(*(float32x2_t *)v10.f32);
  v11.i32[0] = 0;
  v12 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8((int8x16_t)vcgeq_f32(v10, v11)), 0), (int8x16_t)vnegq_f32(v9), (int8x16_t)v9);
  v13 = vsubq_f32(v8, v12);
  v14 = (int8x16_t)vmulq_f32(v13, v13);
  v45 = v12;
  v46 = v8;
  v15 = vaddq_f32(v8, v12);
  v16 = (int8x16_t)vmulq_f32(v15, v15);
  v17 = atan2f(sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v14.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v14, v14, 8uLL)))), sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v16.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v16, v16, 8uLL)))));
  v18 = v17 + v17;
  v19 = (float)(v17 + v17) == 0.0;
  v20 = 1.0;
  if (!v19)
    v20 = sinf(v18) / v18;
  v21 = v20;
  v22 = vrecpe_f32((float32x2_t)LODWORD(v20));
  v23 = vmul_f32(v22, vrecps_f32((float32x2_t)LODWORD(v21), v22));
  LODWORD(v24) = vmul_f32(v23, vrecps_f32((float32x2_t)LODWORD(v21), v23)).u32[0];
  v25 = v50;
  if ((float)(v50 * v18) != 0.0)
  {
    v43 = v24;
    v23.f32[0] = sinf(v50 * v18);
    v24 = v43;
    v25 = v50;
    v7 = v23.f32[0] / (float)(v50 * v18);
  }
  v23.f32[0] = v25 * (float)(v24 * v7);
  v26 = (float32x4_t)vdupq_lane_s32((int32x2_t)v23, 0);
  v27 = a4;
  v28 = v18 * a4;
  v29 = 1.0;
  if (v28 != 0.0)
  {
    v42 = v26;
    v44 = v24;
    v30 = sinf(v28);
    v26 = v42;
    v24 = v44;
    v25 = v50;
    v27 = a4;
    v29 = v30 / v28;
  }
  v31 = vmlaq_f32(vmulq_n_f32(v45, (float)(v24 * v29) * v27), v46, v26);
  v32 = (int8x16_t)vmulq_f32(v31, v31);
  v33 = vadd_f32(*(float32x2_t *)v32.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v32, v32, 8uLL));
  if (vaddv_f32(v33) == 0.0)
  {
    v34 = 0;
    v35 = 0x3F80000000000000;
  }
  else
  {
    v36 = vadd_f32(v33, (float32x2_t)vdup_lane_s32((int32x2_t)v33, 1)).u32[0];
    v37 = vrsqrte_f32((float32x2_t)v36);
    v38 = vmul_f32(v37, vrsqrts_f32((float32x2_t)v36, vmul_f32(v37, v37)));
    v39 = vmulq_n_f32(v31, vmul_f32(v38, vrsqrts_f32((float32x2_t)v36, vmul_f32(v38, v38))).f32[0]);
    v35 = v39.i64[1];
    v34 = v39.i64[0];
  }
  result = vmlaq_n_f32(vmulq_n_f32(v47, v27), v48, v25);
  v41 = vmlaq_n_f32(vmulq_n_f32(a2[2], v27), a1[2], v25);
  *a3 = result;
  a3[1].i64[0] = v34;
  a3[1].i64[1] = v35;
  a3[2] = v41;
  return result;
}

double re::Projection::makeReverseDepth@<D0>(_OWORD *a1@<X0>, _OWORD *a2@<X8>)
{
  unsigned __int8 v2;
  float32x4_t *v3;
  float32x4_t *v4;
  float32x4_t *v5;
  float32x4_t *v6;
  uint64_t v7;
  float32x4_t v8;
  float32x4_t v9;
  float32x4_t v10;
  float32x4_t v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  double result;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  int v19;
  int v20;
  _OWORD *v21;
  _OWORD *v22;
  _OWORD v23[4];
  _OWORD v24[4];

  v3 = (float32x4_t *)&re::mtl::introspect_SamplerMinMagFilter(BOOL)::info;
  v4 = (float32x4_t *)&re::mtl::introspect_SamplerMinMagFilter(BOOL)::info;
  v5 = (float32x4_t *)&re::mtl::introspect_SamplerMinMagFilter(BOOL)::info;
  v6 = (float32x4_t *)&re::mtl::introspect_SamplerMinMagFilter(BOOL)::info;
  if ((v2 & 1) == 0)
  {
    v21 = a2;
    v22 = a1;
    v6 = (float32x4_t *)&re::mtl::introspect_SamplerMinMagFilter(BOOL)::info;
    v5 = (float32x4_t *)&re::mtl::introspect_SamplerMinMagFilter(BOOL)::info;
    v4 = (float32x4_t *)&re::mtl::introspect_SamplerMinMagFilter(BOOL)::info;
    v3 = (float32x4_t *)&re::mtl::introspect_SamplerMinMagFilter(BOOL)::info;
    v20 = v19;
    a2 = v21;
    a1 = v22;
    if (v20)
    {
      re::Projection::makeReverseDepth(re::Matrix4x4<float> const&)::zFlip = xmmword_2260E5F10;
      re::Projection::makeReverseDepth(re::Matrix4x4<float> const&)::zFlip = xmmword_2260E5F20;
      re::Projection::makeReverseDepth(re::Matrix4x4<float> const&)::zFlip = xmmword_226108EE0;
      re::Projection::makeReverseDepth(re::Matrix4x4<float> const&)::zFlip = xmmword_22610BC10;
      v6 = (float32x4_t *)&re::mtl::introspect_SamplerMinMagFilter(BOOL)::info;
      v5 = (float32x4_t *)&re::mtl::introspect_SamplerMinMagFilter(BOOL)::info;
      v4 = (float32x4_t *)&re::mtl::introspect_SamplerMinMagFilter(BOOL)::info;
      v3 = (float32x4_t *)&re::mtl::introspect_SamplerMinMagFilter(BOOL)::info;
      a2 = v21;
      a1 = v22;
    }
  }
  v7 = 0;
  v8 = v3[189];
  v9 = v4[190];
  v10 = v5[191];
  v11 = v6[192];
  v12 = a1[1];
  v13 = a1[2];
  v14 = a1[3];
  v23[0] = *a1;
  v23[1] = v12;
  v23[2] = v13;
  v23[3] = v14;
  do
  {
    v24[v7] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v8, COERCE_FLOAT(v23[v7])), v9, *(float32x2_t *)&v23[v7], 1), v10, (float32x4_t)v23[v7], 2), v11, (float32x4_t)v23[v7], 3);
    ++v7;
  }
  while (v7 != 4);
  result = *(double *)v24;
  v16 = v24[1];
  v17 = v24[2];
  v18 = v24[3];
  *a2 = v24[0];
  a2[1] = v16;
  a2[2] = v17;
  a2[3] = v18;
  return result;
}

void re::Projection::makePerspectiveFieldOfViewReverseDepth(float a1@<S0>, float a2@<S1>, float a3@<S2>, float a4@<S3>, _OWORD *a5@<X8>)
{
  float v10;
  float v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  _OWORD v16[4];

  v10 = 1.0 / tanf(a1 * 0.5);
  if (a4 == INFINITY)
  {
    v11 = -a3;
    LODWORD(v13) = 0;
    *((_QWORD *)&v13 + 1) = 0;
    DWORD1(v12) = 0;
    *((_QWORD *)&v12 + 1) = 0;
    *(float *)&v12 = v10 / a2;
    *((float *)&v13 + 1) = v10;
    v14 = xmmword_22611B730;
  }
  else
  {
    DWORD1(v12) = 0;
    *((_QWORD *)&v12 + 1) = 0;
    *(float *)&v12 = v10 / a2;
    LODWORD(v13) = 0;
    *((_QWORD *)&v13 + 1) = 0;
    *((float *)&v13 + 1) = v10;
    *(_QWORD *)&v14 = 0;
    v11 = (float)(a3 * a4) / (float)(a3 - a4);
    *((float *)&v14 + 2) = a4 / (float)(a3 - a4);
    HIDWORD(v14) = -1.0;
  }
  *(_QWORD *)&v15 = 0;
  *((_QWORD *)&v15 + 1) = LODWORD(v11);
  v16[0] = v12;
  v16[1] = v13;
  v16[2] = v14;
  v16[3] = v15;
  re::Projection::makeReverseDepth(v16, a5);
}

float32x2_t re::Projection::computeMatrix4x4F@<D0>(re::Projection *this@<X0>, uint64_t a2@<X8>)
{
  int v4;
  int v5;
  __int128 v6;
  float v7;
  float32x2_t v8;
  float v9;
  float32x2_t v10;
  float v11;
  float v12;
  float v13;
  float32x2_t v14;
  __int128 v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  __int128 v21;
  __int128 v22;
  float v23;
  unsigned int v29;
  __int128 v30;
  float32x2_t result;
  float v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  _OWORD v36[4];

  v4 = *(_DWORD *)this;
  v5 = *((_DWORD *)this + 12);
  LODWORD(v6) = 0;
  *((_QWORD *)&v6 + 1) = 0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  v7 = *((float *)this + 2);
  v8.i32[0] = *((_DWORD *)this + 3);
  v9 = *((float *)this + 6);
  v10 = *(float32x2_t *)((char *)this + 16);
  v11 = *((float *)this + 1);
  v12 = v10.f32[1] - v9;
  if (v4)
  {
    v13 = 2.0 / (float)(v10.f32[0] - v8.f32[0]);
    v8.i32[1] = *((_DWORD *)this + 6);
    v14 = vdiv_f32(vadd_f32(v8, v10), vsub_f32(v8, v10));
    *(float32x2_t *)&v15 = v14;
    HIDWORD(v15) = 1.0;
    if (v5 == 1)
    {
      v16 = v7 - v11;
      v17 = v7 / (float)(v7 - v11);
    }
    else
    {
      v16 = v11 - v7;
      v17 = v11 / (float)(v11 - v7);
    }
    *(float *)&v29 = 1.0 / v16;
    *(_QWORD *)&v30 = 0;
    *((_QWORD *)&v30 + 1) = v29;
    *((float *)&v15 + 2) = v17;
    *(_OWORD *)a2 = LODWORD(v13);
    *((float *)&v6 + 1) = 2.0 / v12;
    *(_OWORD *)(a2 + 16) = v6;
    *(_OWORD *)(a2 + 32) = v30;
    *(_OWORD *)(a2 + 48) = v15;
    if (*((_BYTE *)this + 28))
    {
      v14 = *(float32x2_t *)(a2 + 48);
    }
    result = vadd_f32(v14, *(float32x2_t *)((char *)this + 56));
    *(float32x2_t *)(a2 + 48) = result;
  }
  else
  {
    v18 = (float)(v11 + v11) / (float)(v10.f32[0] - v8.f32[0]);
    v19 = (float)(v8.f32[0] + v10.f32[0]) / (float)(v10.f32[0] - v8.f32[0]);
    v10.f32[0] = (float)(v11 + v11) / v12;
    v20 = (float)(v9 + v10.f32[1]) / v12;
    if (v7 == INFINITY)
    {
      LODWORD(v22) = 0;
      *((_QWORD *)&v22 + 1) = 0;
      v21 = LODWORD(v18);
      DWORD1(v22) = v10.i32[0];
      v23 = -v11;
      __asm { FMOV            V5.4S, #-1.0 }
      *(_QWORD *)&_Q5 = __PAIR64__(LODWORD(v20), LODWORD(v19));
    }
    else
    {
      v32 = v7 / (float)(v11 - v7);
      v23 = (float)(v7 * v11) / (float)(v11 - v7);
      LODWORD(v22) = 0;
      *((_QWORD *)&v22 + 1) = 0;
      v21 = LODWORD(v18);
      DWORD1(v22) = v10.i32[0];
      __asm { FMOV            V5.4S, #-1.0 }
      *(_QWORD *)&_Q5 = __PAIR64__(LODWORD(v20), LODWORD(v19));
      *((float *)&_Q5 + 2) = v32;
    }
    *(_QWORD *)&v33 = 0;
    *((_QWORD *)&v33 + 1) = LODWORD(v23);
    *(_OWORD *)a2 = v21;
    *(_OWORD *)(a2 + 16) = v22;
    *(_OWORD *)(a2 + 32) = _Q5;
    *(_OWORD *)(a2 + 48) = v33;
    if (*((_BYTE *)this + 28))
    if (v5 == 1)
    {
      re::Projection::makeReverseDepth((_OWORD *)a2, v36);
      v34 = v36[1];
      *(_OWORD *)a2 = v36[0];
      *(_OWORD *)(a2 + 16) = v34;
      v35 = v36[3];
      *(_OWORD *)(a2 + 32) = v36[2];
      *(_OWORD *)(a2 + 48) = v35;
    }
    result = vadd_f32(*(float32x2_t *)((char *)this + 56), *(float32x2_t *)(a2 + 32));
    *(float32x2_t *)(a2 + 32) = result;
  }
  return result;
}

float re::`anonymous namespace'::applyObliqueClipPlane(uint64_t a1, float32x4_t a2)
{
  float v3;
  float v4;
  float result;
  float v6;
  float v7;
  simd_float4x4 v9;

  if (a2.f32[0] >= 0.0)
    v3 = 1.0;
  else
    v3 = -1.0;
  v7 = v3;
  if (a2.f32[1] >= 0.0)
    v4 = 1.0;
  else
    v4 = -1.0;
  v6 = v4;
  v9 = __invert_f4(*(simd_float4x4 *)a1);
  v9.columns[0] = (simd_float4)vmulq_f32(vaddq_f32((float32x4_t)v9.columns[3], vaddq_f32((float32x4_t)v9.columns[2], vmlaq_n_f32(vmulq_n_f32((float32x4_t)v9.columns[0], v7), (float32x4_t)v9.columns[1], v6))), a2);
  v9.columns[0] = (simd_float4)vmulq_n_f32(a2, 1.0/ vaddv_f32(vadd_f32(*(float32x2_t *)v9.columns[0].f32, (float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v9.columns[0], (int8x16_t)v9.columns[0], 8uLL))));
  *(float *)(a1 + 8) = v9.columns[0].f32[0] - *(float *)(a1 + 12);
  *(float *)(a1 + 24) = v9.columns[0].f32[1] - *(float *)(a1 + 28);
  *(_DWORD *)(a1 + 40) = v9.columns[0].i32[2];
  result = v9.columns[0].f32[3] - *(float *)(a1 + 60);
  *(float *)(a1 + 56) = result;
  return result;
}

float re::Projection::setFromMatrix4x4F(uint64_t a1, uint64_t a2)
{
  float v4;
  float v5;
  BOOL v6;
  _BOOL4 v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float result;
  int32x2_t v15;
  float v16;
  float v17;
  simd_float4x4 v18;

  v4 = *(float *)(a2 + 44);
  *(_DWORD *)a1 = v4 == 0.0;
  v5 = *(float *)(a2 + 40);
  if (v4 != 0.0)
  {
    v15.i32[0] = *(_DWORD *)(a2 + 56);
    if (v5 == -1.0)
    {
      *(_DWORD *)(a1 + 8) = 2139095040;
      *(_DWORD *)(a1 + 48) = 0;
      *(float *)v15.i32 = -*(float *)v15.i32;
    }
    else
    {
      if (v5 != 0.0)
      {
        v18 = __invert_f4(*(simd_float4x4 *)a2);
        v18.columns[0] = (simd_float4)vaddq_f32((float32x4_t)v18.columns[2], vmlaq_f32(vmulq_f32((float32x4_t)v18.columns[0], (float32x4_t)0), (float32x4_t)0, (float32x4_t)v18.columns[1]));
        v18.columns[2].i64[0] = vextq_s8((int8x16_t)v18.columns[0], (int8x16_t)v18.columns[0], 8uLL).u64[0];
        v18.columns[0] = (simd_float4)vmlaq_f32((float32x4_t)v18.columns[0], (float32x4_t)vdupq_n_s32(0x799A130Cu), (float32x4_t)v18.columns[3]);
        *(float32x2_t *)v18.columns[1].f32 = vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v18.columns[3], (int8x16_t)v18.columns[3], 8uLL), *(float32x2_t *)v18.columns[2].f32);
        v18.columns[0].i64[0] = vextq_s8((int8x16_t)v18.columns[0], (int8x16_t)v18.columns[0], 8uLL).u64[0];
        v15 = (int32x2_t)vdiv_f32(vneg_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v18.columns[1].f32, *(int32x2_t *)v18.columns[0].f32)), (float32x2_t)vzip2_s32(*(int32x2_t *)v18.columns[1].f32, *(int32x2_t *)v18.columns[0].f32));
        *(int32x2_t *)(a1 + 4) = vrev64_s32(v15);
        if (*(float *)&v15.i32[1] <= *(float *)v15.i32)
        {
          *(_DWORD *)(a1 + 48) = 0;
          v15.i32[0] = v15.i32[1];
        }
        else
        {
          *(int32x2_t *)(a1 + 4) = v15;
          *(_DWORD *)(a1 + 48) = 1;
        }
        goto LABEL_13;
      }
      *(_DWORD *)(a1 + 8) = 2139095040;
      *(_DWORD *)(a1 + 48) = 1;
    }
    *(_DWORD *)(a1 + 4) = v15.i32[0];
LABEL_13:
    v16 = 1.0 / *(float *)a2;
    *(float *)(a1 + 12) = v16 * (float)(*(float *)v15.i32 * (float)(*(float *)(a2 + 32) + -1.0));
    *(float *)(a1 + 16) = v16 * (float)(*(float *)v15.i32 * (float)(*(float *)(a2 + 32) + 1.0));
    v17 = 1.0 / *(float *)(a2 + 20);
    *(float *)(a1 + 24) = v17 * (float)(*(float *)v15.i32 * (float)(*(float *)(a2 + 36) + -1.0));
    result = v17 * (float)(*(float *)v15.i32 * (float)(*(float *)(a2 + 36) + 1.0));
    *(float *)(a1 + 20) = result;
    return result;
  }
  v6 = v5 < 0.0;
  v7 = v5 >= 0.0;
  v8 = 1.0 / v5;
  v9 = v8 * *(float *)(a2 + 56);
  v10 = v9 - v8;
  if (v6)
    v11 = v9;
  else
    v11 = v10;
  if (!v6)
    v10 = v9;
  *(_DWORD *)(a1 + 48) = v7;
  *(float *)(a1 + 4) = v11;
  *(float *)(a1 + 8) = v10;
  v12 = 1.0 / *(float *)a2;
  *(float *)(a1 + 16) = v12 * (float)(1.0 - *(float *)(a2 + 48));
  *(float *)(a1 + 12) = -(float)((float)(*(float *)(a2 + 48) + 1.0) * v12);
  v13 = 1.0 / *(float *)(a2 + 20);
  *(float *)(a1 + 20) = v13 * (float)(1.0 - *(float *)(a2 + 52));
  result = -(float)((float)(*(float *)(a2 + 52) + 1.0) * v13);
  *(float *)(a1 + 24) = result;
  return result;
}

uint64_t re::Projection::unprojectPoint(float32x2_t *a1, uint64_t a2, int a3)
{
  float v3;
  float32x2_t v4;
  float32x2_t v6;

  v3 = a1[5].f32[1];
  if (v3 == 0.0)
  {
    v6 = *a1;
    v6.i32[1] = a1[2].i32[1];
    return (uint64_t)vdiv_f32(vsub_f32((float32x2_t)a2, a1[6]), v6);
  }
  else
  {
    v4 = *a1;
    v4.i32[1] = a1[2].i32[1];
    return (uint64_t)vdiv_f32(vmul_n_f32(vmla_n_f32(vneg_f32(a1[4]), (float32x2_t)a2, v3), a1[7].f32[0] / (float)-(float)(a1[5].f32[0] - (float)(v3 * *(float *)&a3))), v4);
  }
}

uint64_t re::solveQuadraticRootsD(re *this, double *a2, double *a3)
{
  double v3;
  double v4;
  double v5;
  float v6;
  float v7;
  double v9;
  double v10;
  double v11;
  double v12;

  v3 = *((double *)this + 1);
  v4 = *((double *)this + 2);
  v5 = *(double *)this;
  v6 = v4;
  if (fabsf(v6) < 0.00001)
  {
    v7 = v3;
    if (fabsf(v7) >= 0.00001)
    {
      *a2 = -v5 / v3;
      return 1;
    }
    return 0;
  }
  v9 = v4 * -4.0 * v5 + v3 * v3;
  if (v9 < 0.0)
    return 0;
  v10 = 1.0;
  if (v3 < 0.0)
    v10 = -1.0;
  v11 = (v3 + v10 * sqrt(v9)) * -0.5;
  v12 = v5 / v11;
  *a2 = v11 / v4;
  a2[1] = v12;
  if (v12 < v11 / v4)
  {
    *a2 = v12;
    a2[1] = v11 / v4;
  }
  if (v9 <= 0.0)
    return 1;
  else
    return 2;
}

double re::Matrix4x4<float>::extractScale(uint64_t a1, float32x4_t a2, int32x4_t a3, int8x16_t a4)
{
  float32x4_t v4;
  BOOL v5;
  float v6;
  float32x4_t v7;
  float32x4_t v8;
  float32x4_t v9;
  float32x4_t v10;
  double result;

  a2.i64[0] = *(_QWORD *)a1;
  a3.i64[0] = *(_QWORD *)(a1 + 16);
  a4.i64[0] = *(_QWORD *)(a1 + 32);
  a2.i32[2] = *(_DWORD *)(a1 + 8);
  a3.i32[2] = *(_DWORD *)(a1 + 24);
  a4.i32[2] = *(_DWORD *)(a1 + 40);
  v4 = vmulq_f32(a2, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8(a4, a4, 0xCuLL), a4, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(a3, a3), (int8x16_t)a3, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a4, (int32x4_t)a4), a4, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)a3, (int8x16_t)a3, 0xCuLL), (int8x16_t)a3, 8uLL)));
  v5 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v4, 2), vaddq_f32(v4, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.f32, 1))).f32[0] <= 0.0;
  v6 = -1.0;
  if (!v5)
    v6 = 1.0;
  v7 = vmulq_f32(a2, a2);
  v8 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2), vaddq_f32(v7, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 1)));
  v9 = vmulq_f32((float32x4_t)a3, (float32x4_t)a3);
  v8.f32[0] = sqrtf(v8.f32[0]);
  v10 = vmulq_f32((float32x4_t)a4, (float32x4_t)a4);
  v8.i32[1] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v9, 2), vaddq_f32(v9, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v9.f32, 1))).f32[0]);
  v8.i32[2] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v10, 2), vaddq_f32(v10, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v10.f32, 1))).f32[0]);
  *(_QWORD *)&result = vmulq_n_f32(v8, v6).u64[0];
  return result;
}

double re::Matrix4x4<float>::makeRotation@<D0>(float32x4_t *a1@<X0>, _OWORD *a2@<X8>, float a3@<S0>)
{
  float32x4_t v4;
  float32x4_t v5;
  float v6;
  float v7;
  float32x2_t v8;
  float32x2_t v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  __float2 v15;
  float v16;
  float v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  double result;
  float32x4_t v22;
  float v23;

  v4 = *a1;
  v5 = vmulq_f32(v4, v4);
  LODWORD(v6) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v5, 2), vaddq_f32(v5, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 1))).u32[0];
  if (fabsf(v6) >= 1.0e-10)
  {
    v7 = v6;
    v8 = vrsqrte_f32((float32x2_t)LODWORD(v6));
    v9 = vmul_f32(v8, vrsqrts_f32((float32x2_t)LODWORD(v7), vmul_f32(v8, v8)));
    v4 = vmulq_n_f32(v4, vmul_f32(v9, vrsqrts_f32((float32x2_t)LODWORD(v7), vmul_f32(v9, v9))).f32[0]);
  }
  v22 = v4;
  v23 = vmulq_f32(v4, v4).f32[0];
  v10 = vmuls_lane_f32(v4.f32[1], *(float32x2_t *)v4.f32, 1);
  v11 = vmuls_lane_f32(v4.f32[2], v4, 2);
  v12 = vmuls_lane_f32(v4.f32[0], *(float32x2_t *)v4.f32, 1);
  v13 = vmuls_lane_f32(v4.f32[0], v4, 2);
  v14 = vmuls_lane_f32(v4.f32[1], v4, 2);
  v15 = __sincosf_stret(a3);
  v16 = vmuls_lane_f32(v15.__sinval, *(float32x2_t *)v22.f32, 1);
  v17 = vmuls_lane_f32(v15.__sinval, v22, 2);
  HIDWORD(v18) = 0;
  *(float *)&v18 = v23 + (float)(v15.__cosval * (float)(1.0 - v23));
  HIDWORD(v19) = 0;
  *((float *)&v18 + 1) = v17 + (float)(v12 * (float)(1.0 - v15.__cosval));
  *((float *)&v18 + 2) = -(float)(v16 - (float)(v13 * (float)(1.0 - v15.__cosval)));
  HIDWORD(v20) = 0;
  *(float *)&v20 = -(float)(v17 - (float)(v12 * (float)(1.0 - v15.__cosval)));
  *((float *)&v20 + 1) = v10 + (float)(v15.__cosval * (float)(1.0 - v10));
  *((float *)&v20 + 2) = (float)(v15.__sinval * v22.f32[0]) + (float)(v14 * (float)(1.0 - v15.__cosval));
  *(float *)&v19 = v16 + (float)(v13 * (float)(1.0 - v15.__cosval));
  *((float *)&v19 + 1) = -(float)((float)(v15.__sinval * v22.f32[0]) - (float)(v14 * (float)(1.0 - v15.__cosval)));
  *((float *)&v19 + 2) = v11 + (float)(v15.__cosval * (float)(1.0 - v11));
  *a2 = v18;
  a2[1] = v20;
  result = 0.0;
  a2[2] = v19;
  a2[3] = xmmword_2260E5D70;
  return result;
}

uint64_t re::Quaternion<float>::makeRotation(float32x4_t *a1, float a2)
{
  float32x4_t v2;
  float32x4_t v3;
  float v4;
  float v5;
  float32x2_t v6;
  float32x2_t v7;

  v2 = *a1;
  v3 = vmulq_f32(v2, v2);
  LODWORD(v4) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v3, 2), vaddq_f32(v3, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v3.f32, 1))).u32[0];
  if (fabsf(v4) >= 1.0e-10)
  {
    v5 = v4;
    v6 = vrsqrte_f32((float32x2_t)LODWORD(v4));
    v7 = vmul_f32(v6, vrsqrts_f32((float32x2_t)LODWORD(v5), vmul_f32(v6, v6)));
    v2.i64[0] = vmulq_n_f32(v2, vmul_f32(v7, vrsqrts_f32((float32x2_t)LODWORD(v5), vmul_f32(v7, v7))).f32[0]).u64[0];
  }
  return (uint64_t)vmul_n_f32(*(float32x2_t *)v2.f32, __sincosf_stret(a2 * 0.5).__sinval);
}

unsigned int *re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<1,float [4]>(re::snapshot::EncoderOPACK *this, void *a2)
{
  uint64_t v4;
  uint64_t v5;

  v4 = *((unsigned int *)this + 2);
  if (v4 >= *((_DWORD *)this + 3))
  {
    re::snapshot::EncoderOPACK::writeInteger((unsigned int *)this, 1);
  }
  else
  {
    v5 = *(_QWORD *)this;
    *((_DWORD *)this + 2) = v4 + 1;
    *(_BYTE *)(v5 + v4) = 9;
  }
  re::snapshot::EncoderOPACK::beginData((unsigned int *)this, 0x10uLL, 0x10uLL);
  return re::snapshot::Encoder::writeRaw<true>((unsigned int *)this, a2, 0x10uLL);
}

uint64_t re::snapshot::Reader<re::snapshot::DecoderOPACK>::field<1,re::Vector4<float> [4]>(uint64_t a1, _OWORD *a2)
{
  uint64_t result;
  unsigned __int8 *v5;
  int v6;

  result = re::snapshot::DecoderOPACK::advanceTo<1>(a1);
  if ((_DWORD)result)
  {
    re::snapshot::operator>><re::snapshot::Reader<re::snapshot::DecoderOPACK>,re::Vector4<float>,4ul>(a1, a2);
    v5 = *(unsigned __int8 **)(a1 + 16);
    if ((unint64_t)v5 >= *(_QWORD *)(a1 + 24) || (v6 = *v5, v6 == 3))
    {
      result = 0x7FFFFFFFLL;
    }
    else if ((v6 - 7) > 0x28)
    {
      result = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0x7FFFFFFFLL);
    }
    else
    {
      *(_QWORD *)(a1 + 16) = v5 + 1;
      result = (v6 - 8);
    }
    *(_DWORD *)(a1 + 32) = result;
  }
  return result;
}

unsigned int *re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<1,re::Vector4<float> [4]>(re::snapshot::EncoderOPACK *this, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t i;
  unsigned int *result;

  v4 = *((unsigned int *)this + 2);
  if (v4 >= *((_DWORD *)this + 3))
  {
    re::snapshot::EncoderOPACK::writeInteger((unsigned int *)this, 1);
  }
  else
  {
    v5 = *(_QWORD *)this;
    *((_DWORD *)this + 2) = v4 + 1;
    *(_BYTE *)(v5 + v4) = 9;
  }
  re::snapshot::EncoderOPACK::beginArray((unsigned int *)this, 4uLL);
  for (i = 0; i != 64; i += 16)
  {
    re::snapshot::EncoderOPACK::beginObject((unsigned int *)this);
    re::snapshot::Writer<re::snapshot::EncoderOPACK>::field<1,float [4]>(this, (void *)(a2 + i));
    result = re::snapshot::EncoderOPACK::endObject((unsigned int *)this);
  }
  return result;
}

uint64_t *re::allocInfo_Vector2F(re *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  v1 = atomic_load((unsigned __int8 *)&qword_25411C668);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_25411C668))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_25411CA78, 0);
    *(_QWORD *)(v3 + 22) = 0;
    qword_25411CA88 = 0;
    qword_25411CA98 = 0;
    qword_25411CAA0 = 0xFFFFFFFFLL;
    qword_25411CA78 = (uint64_t)&off_24ED7DAA8;
    qword_25411CAA8 = (uint64_t)"Vector2F";
    dword_25411CAB0 = 0;
    xmmword_25411CAB8 = 0u;
    xmmword_25411CAC8 = 0u;
    xmmword_25411CAD8 = 0u;
    qword_25411CAE8 = 0;
    __cxa_guard_release(&qword_25411C668);
  }
  return &qword_25411CA78;
}

void re::initInfo_Vector2F(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  const re::IntrospectionBase *v7;
  void *v8;
  uint64_t v9;
  uint64_t *v10;
  _QWORD *v11;
  __int128 v12;
  _QWORD v13[2];
  __int128 v14;

  v13[0] = 0x478E8020DEELL;
  v13[1] = "Vector2F";
  re::StringID::destroyString((re::StringID *)v13);
  *((_OWORD *)this + 2) = v14;
  v4 = atomic_load((unsigned __int8 *)&qword_25411C670);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_25411C670);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      v8 = re::IntrospectionInfo<float [2]>::get(1, v7);
      v9 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
      *(_DWORD *)v9 = 1;
      *(_QWORD *)(v9 + 8) = "array";
      *(_QWORD *)(v9 + 16) = v8;
      *(_QWORD *)(v9 + 24) = 0;
      *(_QWORD *)(v9 + 32) = 1;
      *(_DWORD *)(v9 + 40) = 0;
      *(_QWORD *)(v9 + 48) = 0;
      *(_QWORD *)(v9 + 56) = 0;
      *(_DWORD *)(v9 + 64) = 0;
      qword_25411C770 = v9;
      v10 = re::introspectionAllocator((re *)v9);
      v11 = (_QWORD *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v10 + 32))(v10, 8, 4);
      *v11 = 0x100000004;
      qword_25411C778 = (uint64_t)v11;
      __cxa_guard_release(&qword_25411C670);
    }
  }
  *((_QWORD *)this + 2) = 0x800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 2;
  *((_QWORD *)this + 8) = &qword_25411C770;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::Vector2<float>>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::Vector2<float>>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::Vector2<float>>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::Vector2<float>>;
  re::IntrospectionRegistry::add(this, v3);
  v12 = v14;
}

void re::internal::defaultConstruct<re::Vector2<float>>(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  *a3 = 0;
}

_QWORD *re::internal::defaultConstructV2<re::Vector2<float>>(_QWORD *result)
{
  *result = 0;
  return result;
}

uint64_t re::introspect_Vector2F(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"Vector2F", (uint64_t (*)(re::internal *))re::allocInfo_Vector2F, (re::IntrospectionBase *(*)(void))re::initInfo_Vector2F, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::Vector2<float>>, this);
}

uint64_t *re::allocInfo_Vector3F(re *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  v1 = atomic_load((unsigned __int8 *)&qword_25411C678);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_25411C678))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_25411CAF0, 0);
    *(_QWORD *)(v3 + 22) = 0;
    qword_25411CB00 = 0;
    qword_25411CB10 = 0;
    qword_25411CB18 = 0xFFFFFFFFLL;
    qword_25411CAF0 = (uint64_t)&off_24ED7DAA8;
    qword_25411CB20 = (uint64_t)"Vector3F";
    dword_25411CB28 = 0;
    xmmword_25411CB30 = 0u;
    xmmword_25411CB40 = 0u;
    xmmword_25411CB50 = 0u;
    qword_25411CB60 = 0;
    __cxa_guard_release(&qword_25411C678);
  }
  return &qword_25411CAF0;
}

void re::initInfo_Vector3F(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  const re::IntrospectionBase *v7;
  void *v8;
  uint64_t v9;
  uint64_t *v10;
  _QWORD *v11;
  __int128 v12;
  _QWORD v13[2];
  __int128 v14;

  v13[0] = 0x478E8020E2CLL;
  v13[1] = "Vector3F";
  re::StringID::destroyString((re::StringID *)v13);
  *((_OWORD *)this + 2) = v14;
  v4 = atomic_load((unsigned __int8 *)&qword_25411C680);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_25411C680);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      v8 = re::IntrospectionInfo<float [3]>::get(1, v7);
      v9 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
      *(_DWORD *)v9 = 1;
      *(_QWORD *)(v9 + 8) = "array";
      *(_QWORD *)(v9 + 16) = v8;
      *(_QWORD *)(v9 + 24) = 0;
      *(_QWORD *)(v9 + 32) = 1;
      *(_DWORD *)(v9 + 40) = 0;
      *(_QWORD *)(v9 + 48) = 0;
      *(_QWORD *)(v9 + 56) = 0;
      *(_DWORD *)(v9 + 64) = 0;
      qword_25411C780 = v9;
      v10 = re::introspectionAllocator((re *)v9);
      v11 = (_QWORD *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v10 + 32))(v10, 8, 4);
      *v11 = 0x100000004;
      qword_25411C788 = (uint64_t)v11;
      __cxa_guard_release(&qword_25411C680);
    }
  }
  *((_QWORD *)this + 2) = 0x1000000008;
  *((_DWORD *)this + 6) = 16;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 2;
  *((_QWORD *)this + 8) = &qword_25411C780;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::Vector3<float>>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::Vector3<float>>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::Vector3<float>>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::Vector3<float>>;
  re::IntrospectionRegistry::add(this, v3);
  v12 = v14;
}

double re::internal::defaultConstruct<re::Vector3<float>>(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  double result;

  result = 0.0;
  *a3 = 0u;
  return result;
}

double re::internal::defaultConstructV2<re::Vector3<float>>(_OWORD *a1)
{
  double result;

  result = 0.0;
  *a1 = 0u;
  return result;
}

uint64_t re::introspect_Vector3F(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"Vector3F", (uint64_t (*)(re::internal *))re::allocInfo_Vector3F, (re::IntrospectionBase *(*)(void))re::initInfo_Vector3F, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::Vector3<float>>, this);
}

uint64_t *re::allocInfo_Vector4F(re *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  v1 = atomic_load((unsigned __int8 *)&qword_25411C688);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_25411C688))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_25411CB68, 0);
    *(_QWORD *)(v3 + 22) = 0;
    qword_25411CB78 = 0;
    qword_25411CB88 = 0;
    qword_25411CB90 = 0xFFFFFFFFLL;
    qword_25411CB68 = (uint64_t)&off_24ED7DAA8;
    qword_25411CB98 = (uint64_t)"Vector4F";
    dword_25411CBA0 = 0;
    xmmword_25411CBA8 = 0u;
    xmmword_25411CBB8 = 0u;
    xmmword_25411CBC8 = 0u;
    qword_25411CBD8 = 0;
    __cxa_guard_release(&qword_25411C688);
  }
  return &qword_25411CB68;
}

void re::initInfo_Vector4F(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  const re::IntrospectionBase *v7;
  uint64_t v8;
  uint64_t *v9;
  _QWORD *v10;
  __int128 v11;
  _QWORD v12[2];
  __int128 v13;

  v12[0] = 0x478E8020E6ALL;
  v12[1] = "Vector4F";
  re::StringID::destroyString((re::StringID *)v12);
  *((_OWORD *)this + 2) = v13;
  v4 = atomic_load((unsigned __int8 *)&qword_25411C690);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_25411C690);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      re::IntrospectionInfo<float [4]>::get((uint64_t)v6, v7);
      v8 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
      *(_DWORD *)v8 = 1;
      *(_QWORD *)(v8 + 8) = "array";
      *(_QWORD *)(v8 + 16) = &unk_25411C880;
      *(_QWORD *)(v8 + 24) = 0;
      *(_QWORD *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + 40) = 0;
      *(_QWORD *)(v8 + 48) = 0;
      *(_QWORD *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_25411C790 = v8;
      v9 = re::introspectionAllocator((re *)v8);
      v10 = (_QWORD *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v9 + 32))(v9, 8, 4);
      *v10 = 0x100000004;
      qword_25411C798 = (uint64_t)v10;
      __cxa_guard_release(&qword_25411C690);
    }
  }
  *((_QWORD *)this + 2) = 0x1000000008;
  *((_DWORD *)this + 6) = 16;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 2;
  *((_QWORD *)this + 8) = &qword_25411C790;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::Vector4<float>>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::Vector4<float>>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::Vector4<float>>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::Vector4<float>>;
  re::IntrospectionRegistry::add(this, v3);
  v11 = v13;
}

void re::IntrospectionInfo<float [4]>::get(uint64_t a1, const re::IntrospectionBase *a2)
{
  unsigned __int8 v2;
  const re::IntrospectionBase *v3;
  re::IntrospectionRegistry *v4;
  const re::IntrospectionBase *v5;
  const char *v6;
  __int128 v7;
  __int128 v8;
  const char *v9;
  uint64_t v10[2];

  v2 = atomic_load((unsigned __int8 *)&qword_25411C738);
  if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_25411C738))
  {
    re::IntrospectionCStyleArray::IntrospectionCStyleArray((re::IntrospectionCStyleArray *)&unk_25411C880);
    __cxa_guard_release(&qword_25411C738);
  }
  if ((byte_25411C661 & 1) == 0)
  {
    byte_25411C661 = 1;
    v3 = (const re::IntrospectionBase *)re::introspect_float((re *)1, a2);
    re::IntrospectionCStyleArray::IntrospectionCStyleArray((re::IntrospectionCStyleArray *)&unk_25411C880, v3, 4);
    re::IntrospectionRegistry::add(v4, v5);
    re::getPrettyTypeName((re *)&unk_25411C880, (const re::IntrospectionBase *)&v8);
    if ((BYTE8(v8) & 1) != 0)
      v6 = v9;
    else
      v6 = (char *)&v8 + 9;
    if ((_QWORD)v8)
    {
      if ((BYTE8(v8) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v8 + 40))();
    }
    v8 = *((_OWORD *)v3 + 2);
    xmmword_25411C8A0 = v7;
    re::StringID::destroyString((re::StringID *)v10);
  }
}

void re::internal::defaultConstruct<re::Vector4<float>>(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  *a3 = 0;
  a3[1] = 0;
}

_QWORD *re::internal::defaultConstructV2<re::Vector4<float>>(_QWORD *result)
{
  *result = 0;
  result[1] = 0;
  return result;
}

uint64_t re::introspect_Vector4F(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"Vector4F", (uint64_t (*)(re::internal *))re::allocInfo_Vector4F, (re::IntrospectionBase *(*)(void))re::initInfo_Vector4F, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::Vector4<float>>, this);
}

uint64_t *re::allocInfo_Vector2D(re *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  v1 = atomic_load((unsigned __int8 *)&qword_25411C698);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_25411C698))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_25411CBE0, 0);
    *(_QWORD *)(v3 + 22) = 0;
    qword_25411CBF0 = 0;
    qword_25411CC00 = 0;
    qword_25411CC08 = 0xFFFFFFFFLL;
    qword_25411CBE0 = (uint64_t)&off_24ED7DAA8;
    qword_25411CC10 = (uint64_t)"Vector2D";
    dword_25411CC18 = 0;
    xmmword_25411CC20 = 0u;
    xmmword_25411CC30 = 0u;
    xmmword_25411CC40 = 0u;
    qword_25411CC50 = 0;
    __cxa_guard_release(&qword_25411C698);
  }
  return &qword_25411CBE0;
}

void re::initInfo_Vector2D(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  const re::IntrospectionBase *v7;
  uint64_t v8;
  uint64_t *v9;
  _QWORD *v10;
  __int128 v11;
  _QWORD v12[2];
  __int128 v13;

  v12[0] = 0x478E8020DEALL;
  v12[1] = "Vector2D";
  re::StringID::destroyString((re::StringID *)v12);
  *((_OWORD *)this + 2) = v13;
  v4 = atomic_load((unsigned __int8 *)&qword_25411C6A0);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_25411C6A0);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      re::IntrospectionInfo<double [2]>::get((uint64_t)v6, v7);
      v8 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
      *(_DWORD *)v8 = 1;
      *(_QWORD *)(v8 + 8) = "array";
      *(_QWORD *)(v8 + 16) = &unk_25411C8C8;
      *(_QWORD *)(v8 + 24) = 0;
      *(_QWORD *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + 40) = 0;
      *(_QWORD *)(v8 + 48) = 0;
      *(_QWORD *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_25411C7A0 = v8;
      v9 = re::introspectionAllocator((re *)v8);
      v10 = (_QWORD *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v9 + 32))(v9, 8, 4);
      *v10 = 0x100000004;
      qword_25411C7A8 = (uint64_t)v10;
      __cxa_guard_release(&qword_25411C6A0);
    }
  }
  *((_QWORD *)this + 2) = 0x1000000008;
  *((_DWORD *)this + 6) = 16;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 2;
  *((_QWORD *)this + 8) = &qword_25411C7A0;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::Vector2<double>>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::Vector2<double>>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::Vector2<double>>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::Vector2<double>>;
  re::IntrospectionRegistry::add(this, v3);
  v11 = v13;
}

void re::IntrospectionInfo<double [2]>::get(uint64_t a1, const re::IntrospectionBase *a2)
{
  unsigned __int8 v2;
  const re::IntrospectionBase *v3;
  re::IntrospectionRegistry *v4;
  const re::IntrospectionBase *v5;
  const char *v6;
  __int128 v7;
  __int128 v8;
  const char *v9;
  uint64_t v10[2];

  v2 = atomic_load((unsigned __int8 *)&qword_25411C740);
  if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_25411C740))
  {
    re::IntrospectionCStyleArray::IntrospectionCStyleArray((re::IntrospectionCStyleArray *)&unk_25411C8C8);
    __cxa_guard_release(&qword_25411C740);
  }
  if ((byte_25411C662 & 1) == 0)
  {
    byte_25411C662 = 1;
    v3 = (const re::IntrospectionBase *)re::introspect_double((re *)1, a2);
    re::IntrospectionCStyleArray::IntrospectionCStyleArray((re::IntrospectionCStyleArray *)&unk_25411C8C8, v3, 2);
    re::IntrospectionRegistry::add(v4, v5);
    re::getPrettyTypeName((re *)&unk_25411C8C8, (const re::IntrospectionBase *)&v8);
    if ((BYTE8(v8) & 1) != 0)
      v6 = v9;
    else
      v6 = (char *)&v8 + 9;
    if ((_QWORD)v8)
    {
      if ((BYTE8(v8) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v8 + 40))();
    }
    v8 = *((_OWORD *)v3 + 2);
    xmmword_25411C8E8 = v7;
    re::StringID::destroyString((re::StringID *)v10);
  }
}

void re::internal::defaultConstruct<re::Vector2<double>>(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  *a3 = 0;
  a3[1] = 0;
}

_QWORD *re::internal::defaultConstructV2<re::Vector2<double>>(_QWORD *result)
{
  *result = 0;
  result[1] = 0;
  return result;
}

uint64_t re::introspect_Vector2D(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"Vector2D", (uint64_t (*)(re::internal *))re::allocInfo_Vector2D, (re::IntrospectionBase *(*)(void))re::initInfo_Vector2D, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::Vector2<double>>, this);
}

uint64_t *re::allocInfo_Vector3D(re *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  v1 = atomic_load((unsigned __int8 *)&qword_25411C6A8);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_25411C6A8))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_25411CC58, 0);
    *(_QWORD *)(v3 + 22) = 0;
    qword_25411CC68 = 0;
    qword_25411CC78 = 0;
    qword_25411CC80 = 0xFFFFFFFFLL;
    qword_25411CC58 = (uint64_t)&off_24ED7DAA8;
    qword_25411CC88 = (uint64_t)"Vector3D";
    dword_25411CC90 = 0;
    xmmword_25411CC98 = 0u;
    xmmword_25411CCA8 = 0u;
    xmmword_25411CCB8 = 0u;
    qword_25411CCC8 = 0;
    __cxa_guard_release(&qword_25411C6A8);
  }
  return &qword_25411CC58;
}

void re::initInfo_Vector3D(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  const re::IntrospectionBase *v7;
  uint64_t v8;
  uint64_t *v9;
  _QWORD *v10;
  __int128 v11;
  _QWORD v12[2];
  __int128 v13;

  v12[0] = 0x478E8020E28;
  v12[1] = "Vector3D";
  re::StringID::destroyString((re::StringID *)v12);
  *((_OWORD *)this + 2) = v13;
  v4 = atomic_load((unsigned __int8 *)&qword_25411C6B0);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_25411C6B0);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      re::IntrospectionInfo<double [3]>::get((uint64_t)v6, v7);
      v8 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
      *(_DWORD *)v8 = 1;
      *(_QWORD *)(v8 + 8) = "array";
      *(_QWORD *)(v8 + 16) = &unk_25411C910;
      *(_QWORD *)(v8 + 24) = 0;
      *(_QWORD *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + 40) = 0;
      *(_QWORD *)(v8 + 48) = 0;
      *(_QWORD *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_25411C7B0 = v8;
      v9 = re::introspectionAllocator((re *)v8);
      v10 = (_QWORD *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v9 + 32))(v9, 8, 4);
      *v10 = 0x100000004;
      qword_25411C7B8 = (uint64_t)v10;
      __cxa_guard_release(&qword_25411C6B0);
    }
  }
  *((_QWORD *)this + 2) = 0x2000000008;
  *((_DWORD *)this + 6) = 16;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 2;
  *((_QWORD *)this + 8) = &qword_25411C7B0;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::Vector3<double>>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::Vector3<double>>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::Vector3<double>>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::Vector3<double>>;
  re::IntrospectionRegistry::add(this, v3);
  v11 = v13;
}

void re::IntrospectionInfo<double [3]>::get(uint64_t a1, const re::IntrospectionBase *a2)
{
  unsigned __int8 v2;
  const re::IntrospectionBase *v3;
  re::IntrospectionRegistry *v4;
  const re::IntrospectionBase *v5;
  const char *v6;
  __int128 v7;
  __int128 v8;
  const char *v9;
  uint64_t v10[2];

  v2 = atomic_load((unsigned __int8 *)&qword_25411C748);
  if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_25411C748))
  {
    re::IntrospectionCStyleArray::IntrospectionCStyleArray((re::IntrospectionCStyleArray *)&unk_25411C910);
    __cxa_guard_release(&qword_25411C748);
  }
  if ((byte_25411C663 & 1) == 0)
  {
    byte_25411C663 = 1;
    v3 = (const re::IntrospectionBase *)re::introspect_double((re *)1, a2);
    re::IntrospectionCStyleArray::IntrospectionCStyleArray((re::IntrospectionCStyleArray *)&unk_25411C910, v3, 3);
    re::IntrospectionRegistry::add(v4, v5);
    re::getPrettyTypeName((re *)&unk_25411C910, (const re::IntrospectionBase *)&v8);
    if ((BYTE8(v8) & 1) != 0)
      v6 = v9;
    else
      v6 = (char *)&v8 + 9;
    if ((_QWORD)v8)
    {
      if ((BYTE8(v8) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v8 + 40))();
    }
    v8 = *((_OWORD *)v3 + 2);
    xmmword_25411C930 = v7;
    re::StringID::destroyString((re::StringID *)v10);
  }
}

double re::internal::defaultConstruct<re::Vector3<double>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double result;

  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  result = 0.0;
  *(_OWORD *)(a3 + 16) = 0u;
  return result;
}

double re::internal::defaultConstructV2<re::Vector3<double>>(uint64_t a1)
{
  double result;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  return result;
}

uint64_t re::introspect_Vector3D(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"Vector3D", (uint64_t (*)(re::internal *))re::allocInfo_Vector3D, (re::IntrospectionBase *(*)(void))re::initInfo_Vector3D, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::Vector3<double>>, this);
}

uint64_t *re::allocInfo_Vector4D(re *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  v1 = atomic_load((unsigned __int8 *)&qword_25411C6B8);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_25411C6B8))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_25411CCD0, 0);
    *(_QWORD *)(v3 + 22) = 0;
    qword_25411CCE0 = 0;
    qword_25411CCF0 = 0;
    qword_25411CCF8 = 0xFFFFFFFFLL;
    qword_25411CCD0 = (uint64_t)&off_24ED7DAA8;
    qword_25411CD00 = (uint64_t)"Vector4D";
    dword_25411CD08 = 0;
    xmmword_25411CD10 = 0u;
    xmmword_25411CD20 = 0u;
    xmmword_25411CD30 = 0u;
    qword_25411CD40 = 0;
    __cxa_guard_release(&qword_25411C6B8);
  }
  return &qword_25411CCD0;
}

void re::initInfo_Vector4D(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  const re::IntrospectionBase *v7;
  uint64_t v8;
  uint64_t *v9;
  _QWORD *v10;
  __int128 v11;
  _QWORD v12[2];
  __int128 v13;

  v12[0] = 0x478E8020E66;
  v12[1] = "Vector4D";
  re::StringID::destroyString((re::StringID *)v12);
  *((_OWORD *)this + 2) = v13;
  v4 = atomic_load((unsigned __int8 *)&qword_25411C6C0);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_25411C6C0);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      re::IntrospectionInfo<double [4]>::get((uint64_t)v6, v7);
      v8 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
      *(_DWORD *)v8 = 1;
      *(_QWORD *)(v8 + 8) = "array";
      *(_QWORD *)(v8 + 16) = &unk_25411C958;
      *(_QWORD *)(v8 + 24) = 0;
      *(_QWORD *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + 40) = 0;
      *(_QWORD *)(v8 + 48) = 0;
      *(_QWORD *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_25411C7C0 = v8;
      v9 = re::introspectionAllocator((re *)v8);
      v10 = (_QWORD *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v9 + 32))(v9, 8, 4);
      *v10 = 0x100000004;
      qword_25411C7C8 = (uint64_t)v10;
      __cxa_guard_release(&qword_25411C6C0);
    }
  }
  *((_QWORD *)this + 2) = 0x2000000008;
  *((_DWORD *)this + 6) = 16;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 2;
  *((_QWORD *)this + 8) = &qword_25411C7C0;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::Vector4<double>>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::Vector4<double>>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::Vector4<double>>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::Vector4<double>>;
  re::IntrospectionRegistry::add(this, v3);
  v11 = v13;
}

void re::IntrospectionInfo<double [4]>::get(uint64_t a1, const re::IntrospectionBase *a2)
{
  unsigned __int8 v2;
  const re::IntrospectionBase *v3;
  re::IntrospectionRegistry *v4;
  const re::IntrospectionBase *v5;
  const char *v6;
  __int128 v7;
  __int128 v8;
  const char *v9;
  uint64_t v10[2];

  v2 = atomic_load((unsigned __int8 *)&qword_25411C750);
  if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_25411C750))
  {
    re::IntrospectionCStyleArray::IntrospectionCStyleArray((re::IntrospectionCStyleArray *)&unk_25411C958);
    __cxa_guard_release(&qword_25411C750);
  }
  if ((byte_25411C664 & 1) == 0)
  {
    byte_25411C664 = 1;
    v3 = (const re::IntrospectionBase *)re::introspect_double((re *)1, a2);
    re::IntrospectionCStyleArray::IntrospectionCStyleArray((re::IntrospectionCStyleArray *)&unk_25411C958, v3, 4);
    re::IntrospectionRegistry::add(v4, v5);
    re::getPrettyTypeName((re *)&unk_25411C958, (const re::IntrospectionBase *)&v8);
    if ((BYTE8(v8) & 1) != 0)
      v6 = v9;
    else
      v6 = (char *)&v8 + 9;
    if ((_QWORD)v8)
    {
      if ((BYTE8(v8) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v8 + 40))();
    }
    v8 = *((_OWORD *)v3 + 2);
    xmmword_25411C978 = v7;
    re::StringID::destroyString((re::StringID *)v10);
  }
}

double re::internal::defaultConstruct<re::Vector4<double>>(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  double result;

  result = 0.0;
  *a3 = 0u;
  a3[1] = 0u;
  return result;
}

double re::internal::defaultConstructV2<re::Vector4<double>>(_OWORD *a1)
{
  double result;

  result = 0.0;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t re::introspect_Vector4D(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"Vector4D", (uint64_t (*)(re::internal *))re::allocInfo_Vector4D, (re::IntrospectionBase *(*)(void))re::initInfo_Vector4D, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::Vector4<double>>, this);
}

uint64_t *re::allocInfo_QuaternionF(re *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  v1 = atomic_load((unsigned __int8 *)&qword_25411C6C8);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_25411C6C8))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_25411CD48, 0);
    *(_QWORD *)(v3 + 22) = 0;
    qword_25411CD58 = 0;
    qword_25411CD68 = 0;
    qword_25411CD70 = 0xFFFFFFFFLL;
    qword_25411CD48 = (uint64_t)&off_24ED7DAA8;
    qword_25411CD78 = (uint64_t)"QuaternionF";
    dword_25411CD80 = 0;
    xmmword_25411CD88 = 0u;
    xmmword_25411CD98 = 0u;
    xmmword_25411CDA8 = 0u;
    qword_25411CDB8 = 0;
    __cxa_guard_release(&qword_25411C6C8);
  }
  return &qword_25411CD48;
}

void re::initInfo_QuaternionF(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  const re::IntrospectionBase *v7;
  uint64_t v8;
  uint64_t *v9;
  _QWORD *v10;
  __int128 v11;
  _QWORD v12[2];
  __int128 v13;

  v12[0] = 0x1EE51E553020190;
  v12[1] = "QuaternionF";
  re::StringID::destroyString((re::StringID *)v12);
  *((_OWORD *)this + 2) = v13;
  v4 = atomic_load((unsigned __int8 *)&qword_25411C6D0);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_25411C6D0);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      re::IntrospectionInfo<float [4]>::get((uint64_t)v6, v7);
      v8 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
      *(_DWORD *)v8 = 1;
      *(_QWORD *)(v8 + 8) = "array";
      *(_QWORD *)(v8 + 16) = &unk_25411C880;
      *(_QWORD *)(v8 + 24) = 0;
      *(_QWORD *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + 40) = 0;
      *(_QWORD *)(v8 + 48) = 0;
      *(_QWORD *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_25411C7D0 = v8;
      v9 = re::introspectionAllocator((re *)v8);
      v10 = (_QWORD *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v9 + 32))(v9, 8, 4);
      *v10 = 0x100000004;
      qword_25411C7D8 = (uint64_t)v10;
      __cxa_guard_release(&qword_25411C6D0);
    }
  }
  *((_QWORD *)this + 2) = 0x1000000008;
  *((_DWORD *)this + 6) = 16;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 2;
  *((_QWORD *)this + 8) = &qword_25411C7D0;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::Quaternion<float>>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::Quaternion<float>>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::Quaternion<float>>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::Quaternion<float>>;
  re::IntrospectionRegistry::add(this, v3);
  v11 = v13;
}

double re::internal::defaultConstruct<re::Quaternion<float>>(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  double result;

  result = 0.0;
  *a3 = xmmword_2260E5D70;
  return result;
}

double re::internal::defaultConstructV2<re::Quaternion<float>>(_OWORD *a1)
{
  double result;

  result = 0.0;
  *a1 = xmmword_2260E5D70;
  return result;
}

uint64_t re::introspect_QuaternionF(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"QuaternionF", (uint64_t (*)(re::internal *))re::allocInfo_QuaternionF, (re::IntrospectionBase *(*)(void))re::initInfo_QuaternionF, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::Quaternion<float>>, this);
}

uint64_t *re::allocInfo_Matrix2x2F(re *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  v1 = atomic_load((unsigned __int8 *)&qword_25411C6D8);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_25411C6D8))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_25411CDC0, 0);
    *(_QWORD *)(v3 + 22) = 0;
    qword_25411CDD0 = 0;
    qword_25411CDE0 = 0;
    qword_25411CDE8 = 0xFFFFFFFFLL;
    qword_25411CDC0 = (uint64_t)&off_24ED7DAA8;
    qword_25411CDF0 = (uint64_t)"Matrix2x2F";
    dword_25411CDF8 = 0;
    xmmword_25411CE00 = 0u;
    xmmword_25411CE10 = 0u;
    xmmword_25411CE20 = 0u;
    qword_25411CE30 = 0;
    __cxa_guard_release(&qword_25411C6D8);
  }
  return &qword_25411CDC0;
}

void re::initInfo_Matrix2x2F(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t *v8;
  _QWORD *v9;
  __int128 v10;
  _QWORD v11[2];
  __int128 v12;

  v11[0] = 0xF13AC04E85D76;
  v11[1] = "Matrix2x2F";
  re::StringID::destroyString((re::StringID *)v11);
  *((_OWORD *)this + 2) = v12;
  v4 = atomic_load((unsigned __int8 *)&qword_25411C6E0);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_25411C6E0);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      re::IntrospectionInfo<re::Vector2<float> [2]>::get((re *)v6);
      v7 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
      *(_DWORD *)v7 = 1;
      *(_QWORD *)(v7 + 8) = "columns";
      *(_QWORD *)(v7 + 16) = &unk_25411C9A0;
      *(_QWORD *)(v7 + 24) = 0;
      *(_QWORD *)(v7 + 32) = 1;
      *(_DWORD *)(v7 + 40) = 0;
      *(_QWORD *)(v7 + 48) = 0;
      *(_QWORD *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_25411C7E0 = v7;
      v8 = re::introspectionAllocator((re *)v7);
      v9 = (_QWORD *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v8 + 32))(v8, 8, 4);
      *v9 = 0x100000004;
      qword_25411C7E8 = (uint64_t)v9;
      __cxa_guard_release(&qword_25411C6E0);
    }
  }
  *((_QWORD *)this + 2) = 0x1000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 2;
  *((_QWORD *)this + 8) = &qword_25411C7E0;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::Matrix2x2<float>>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::Matrix2x2<float>>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::Matrix2x2<float>>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::Matrix2x2<float>>;
  re::IntrospectionRegistry::add(this, v3);
  v10 = v12;
}

void re::IntrospectionInfo<re::Vector2<float> [2]>::get(re *a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  re::IntrospectionBase *v3;
  re::IntrospectionRegistry *v4;
  const re::IntrospectionBase *v5;
  const char *v6;
  __int128 v7;
  __int128 v8;
  const char *v9;
  uint64_t v10[2];

  v1 = atomic_load((unsigned __int8 *)&qword_25411C758);
  if ((v1 & 1) == 0)
  {
    a1 = (re *)__cxa_guard_acquire(&qword_25411C758);
    if ((_DWORD)a1)
    {
      re::IntrospectionCStyleArray::IntrospectionCStyleArray((re::IntrospectionCStyleArray *)&unk_25411C9A0);
      __cxa_guard_release(&qword_25411C758);
    }
  }
  if ((byte_25411C665 & 1) == 0)
  {
    byte_25411C665 = 1;
    v2 = (uint64_t *)re::internal::introspectionInfoStorage<re::Vector2<float>>;
    if (!re::internal::introspectionInfoStorage<re::Vector2<float>>)
    {
      v2 = re::allocInfo_Vector2F(a1);
      re::internal::introspectionInfoStorage<re::Vector2<float>> = v2;
      re::initInfo_Vector2F((re *)v2, v3);
    }
    re::IntrospectionCStyleArray::IntrospectionCStyleArray((re::IntrospectionCStyleArray *)&unk_25411C9A0, (const re::IntrospectionBase *)v2, 2);
    re::IntrospectionRegistry::add(v4, v5);
    re::getPrettyTypeName((re *)&unk_25411C9A0, (const re::IntrospectionBase *)&v8);
    if ((BYTE8(v8) & 1) != 0)
      v6 = v9;
    else
      v6 = (char *)&v8 + 9;
    if ((_QWORD)v8)
    {
      if ((BYTE8(v8) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v8 + 40))();
    }
    v8 = *((_OWORD *)v2 + 2);
    xmmword_25411C9C0 = v7;
    re::StringID::destroyString((re::StringID *)v10);
  }
}

void re::internal::defaultConstruct<re::Matrix2x2<float>>(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  *a3 = 0;
  a3[1] = 0;
}

_QWORD *re::internal::defaultConstructV2<re::Matrix2x2<float>>(_QWORD *result)
{
  *result = 0;
  result[1] = 0;
  return result;
}

uint64_t re::introspect_Matrix2x2F(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"Matrix2x2F", (uint64_t (*)(re::internal *))re::allocInfo_Matrix2x2F, (re::IntrospectionBase *(*)(void))re::initInfo_Matrix2x2F, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::Matrix2x2<float>>, this);
}

uint64_t *re::allocInfo_Matrix3x3F(re *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  v1 = atomic_load((unsigned __int8 *)&qword_25411C6E8);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_25411C6E8))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_25411CE38, 0);
    *(_QWORD *)(v3 + 22) = 0;
    qword_25411CE48 = 0;
    qword_25411CE58 = 0;
    qword_25411CE60 = 0xFFFFFFFFLL;
    qword_25411CE38 = (uint64_t)&off_24ED7DAA8;
    qword_25411CE68 = (uint64_t)"Matrix3x3F";
    dword_25411CE70 = 0;
    xmmword_25411CE78 = 0u;
    xmmword_25411CE88 = 0u;
    xmmword_25411CE98 = 0u;
    qword_25411CEA8 = 0;
    __cxa_guard_release(&qword_25411C6E8);
  }
  return &qword_25411CE38;
}

void re::initInfo_Matrix3x3F(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t *v8;
  _QWORD *v9;
  __int128 v10;
  _QWORD v11[2];
  __int128 v12;

  v11[0] = 0xF13AC04E94672;
  v11[1] = "Matrix3x3F";
  re::StringID::destroyString((re::StringID *)v11);
  *((_OWORD *)this + 2) = v12;
  v4 = atomic_load((unsigned __int8 *)&qword_25411C6F0);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_25411C6F0);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      re::IntrospectionInfo<re::Vector3<float> [3]>::get((re *)v6);
      v7 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
      *(_DWORD *)v7 = 1;
      *(_QWORD *)(v7 + 8) = "columns";
      *(_QWORD *)(v7 + 16) = &unk_25411C9E8;
      *(_QWORD *)(v7 + 24) = 0;
      *(_QWORD *)(v7 + 32) = 1;
      *(_DWORD *)(v7 + 40) = 0;
      *(_QWORD *)(v7 + 48) = 0;
      *(_QWORD *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_25411C7F0 = v7;
      v8 = re::introspectionAllocator((re *)v7);
      v9 = (_QWORD *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v8 + 32))(v8, 8, 4);
      *v9 = 0x100000004;
      qword_25411C7F8 = (uint64_t)v9;
      __cxa_guard_release(&qword_25411C6F0);
    }
  }
  *((_QWORD *)this + 2) = 0x3000000008;
  *((_DWORD *)this + 6) = 16;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 2;
  *((_QWORD *)this + 8) = &qword_25411C7F0;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::Matrix3x3<float>>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::Matrix3x3<float>>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::Matrix3x3<float>>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::Matrix3x3<float>>;
  re::IntrospectionRegistry::add(this, v3);
  v10 = v12;
}

void re::IntrospectionInfo<re::Vector3<float> [3]>::get(re *a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  re::IntrospectionBase *v3;
  re::IntrospectionRegistry *v4;
  const re::IntrospectionBase *v5;
  const char *v6;
  __int128 v7;
  __int128 v8;
  const char *v9;
  uint64_t v10[2];

  v1 = atomic_load((unsigned __int8 *)&qword_25411C760);
  if ((v1 & 1) == 0)
  {
    a1 = (re *)__cxa_guard_acquire(&qword_25411C760);
    if ((_DWORD)a1)
    {
      re::IntrospectionCStyleArray::IntrospectionCStyleArray((re::IntrospectionCStyleArray *)&unk_25411C9E8);
      __cxa_guard_release(&qword_25411C760);
    }
  }
  if ((byte_25411C666 & 1) == 0)
  {
    byte_25411C666 = 1;
    v2 = (uint64_t *)re::internal::introspectionInfoStorage<re::Vector3<float>>;
    if (!re::internal::introspectionInfoStorage<re::Vector3<float>>)
    {
      v2 = re::allocInfo_Vector3F(a1);
      re::internal::introspectionInfoStorage<re::Vector3<float>> = v2;
      re::initInfo_Vector3F((re *)v2, v3);
    }
    re::IntrospectionCStyleArray::IntrospectionCStyleArray((re::IntrospectionCStyleArray *)&unk_25411C9E8, (const re::IntrospectionBase *)v2, 3);
    re::IntrospectionRegistry::add(v4, v5);
    re::getPrettyTypeName((re *)&unk_25411C9E8, (const re::IntrospectionBase *)&v8);
    if ((BYTE8(v8) & 1) != 0)
      v6 = v9;
    else
      v6 = (char *)&v8 + 9;
    if ((_QWORD)v8)
    {
      if ((BYTE8(v8) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v8 + 40))();
    }
    v8 = *((_OWORD *)v2 + 2);
    xmmword_25411CA08 = v7;
    re::StringID::destroyString((re::StringID *)v10);
  }
}

double re::internal::defaultConstruct<re::Matrix3x3<float>>(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  double result;

  result = 0.0;
  a3[1] = 0u;
  a3[2] = 0u;
  *a3 = 0u;
  return result;
}

double re::internal::defaultConstructV2<re::Matrix3x3<float>>(_OWORD *a1)
{
  double result;

  result = 0.0;
  a1[1] = 0u;
  a1[2] = 0u;
  *a1 = 0u;
  return result;
}

uint64_t re::introspect_Matrix3x3F(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"Matrix3x3F", (uint64_t (*)(re::internal *))re::allocInfo_Matrix3x3F, (re::IntrospectionBase *(*)(void))re::initInfo_Matrix3x3F, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::Matrix3x3<float>>, this);
}

uint64_t *re::allocInfo_Matrix4x4F(re *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  v1 = atomic_load((unsigned __int8 *)&qword_25411C6F8);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_25411C6F8))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_25411CEB0, 0);
    *(_QWORD *)(v3 + 22) = 0;
    qword_25411CEC0 = 0;
    qword_25411CED0 = 0;
    qword_25411CED8 = 0xFFFFFFFFLL;
    qword_25411CEB0 = (uint64_t)&off_24ED7DAA8;
    qword_25411CEE0 = (uint64_t)"Matrix4x4F";
    dword_25411CEE8 = 0;
    xmmword_25411CEF0 = 0u;
    xmmword_25411CF00 = 0u;
    xmmword_25411CF10 = 0u;
    qword_25411CF20 = 0;
    __cxa_guard_release(&qword_25411C6F8);
  }
  return &qword_25411CEB0;
}

void re::initInfo_Matrix4x4F(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t *v8;
  _QWORD *v9;
  __int128 v10;
  _QWORD v11[2];
  __int128 v12;

  v11[0] = 0xF13AC04EA2F6ELL;
  v11[1] = "Matrix4x4F";
  re::StringID::destroyString((re::StringID *)v11);
  *((_OWORD *)this + 2) = v12;
  v4 = atomic_load((unsigned __int8 *)&qword_25411C700);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_25411C700);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      re::IntrospectionInfo<re::Vector4<float> [4]>::get((re *)v6);
      v7 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
      *(_DWORD *)v7 = 1;
      *(_QWORD *)(v7 + 8) = "columns";
      *(_QWORD *)(v7 + 16) = &unk_25411CA30;
      *(_QWORD *)(v7 + 24) = 0;
      *(_QWORD *)(v7 + 32) = 1;
      *(_DWORD *)(v7 + 40) = 0;
      *(_QWORD *)(v7 + 48) = 0;
      *(_QWORD *)(v7 + 56) = 0;
      *(_DWORD *)(v7 + 64) = 0;
      qword_25411C800 = v7;
      v8 = re::introspectionAllocator((re *)v7);
      v9 = (_QWORD *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v8 + 32))(v8, 8, 4);
      *v9 = 0x100000004;
      qword_25411C808 = (uint64_t)v9;
      __cxa_guard_release(&qword_25411C700);
    }
  }
  *((_QWORD *)this + 2) = 0x4000000008;
  *((_DWORD *)this + 6) = 16;
  *((_WORD *)this + 14) = 257;
  *((_DWORD *)this + 14) = 2;
  *((_QWORD *)this + 8) = &qword_25411C800;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::Matrix4x4<float>>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::Matrix4x4<float>>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::Matrix4x4<float>>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::Matrix4x4<float>>;
  re::IntrospectionRegistry::add(this, v3);
  v10 = v12;
}

void re::IntrospectionInfo<re::Vector4<float> [4]>::get(re *a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  re::IntrospectionBase *v3;
  re::IntrospectionRegistry *v4;
  const re::IntrospectionBase *v5;
  const char *v6;
  __int128 v7;
  __int128 v8;
  const char *v9;
  uint64_t v10[2];

  v1 = atomic_load((unsigned __int8 *)&qword_25411C768);
  if ((v1 & 1) == 0)
  {
    a1 = (re *)__cxa_guard_acquire(&qword_25411C768);
    if ((_DWORD)a1)
    {
      re::IntrospectionCStyleArray::IntrospectionCStyleArray((re::IntrospectionCStyleArray *)&unk_25411CA30);
      __cxa_guard_release(&qword_25411C768);
    }
  }
  if ((byte_25411C667 & 1) == 0)
  {
    byte_25411C667 = 1;
    v2 = (uint64_t *)re::internal::introspectionInfoStorage<re::Vector4<float>>;
    if (!re::internal::introspectionInfoStorage<re::Vector4<float>>)
    {
      v2 = re::allocInfo_Vector4F(a1);
      re::internal::introspectionInfoStorage<re::Vector4<float>> = v2;
      re::initInfo_Vector4F((re *)v2, v3);
    }
    re::IntrospectionCStyleArray::IntrospectionCStyleArray((re::IntrospectionCStyleArray *)&unk_25411CA30, (const re::IntrospectionBase *)v2, 4);
    re::IntrospectionRegistry::add(v4, v5);
    re::getPrettyTypeName((re *)&unk_25411CA30, (const re::IntrospectionBase *)&v8);
    if ((BYTE8(v8) & 1) != 0)
      v6 = v9;
    else
      v6 = (char *)&v8 + 9;
    if ((_QWORD)v8)
    {
      if ((BYTE8(v8) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v8 + 40))();
    }
    v8 = *((_OWORD *)v2 + 2);
    xmmword_25411CA50 = v7;
    re::StringID::destroyString((re::StringID *)v10);
  }
}

double re::internal::defaultConstruct<re::Matrix4x4<float>>(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  double result;

  result = 0.0;
  a3[2] = 0u;
  a3[3] = 0u;
  *a3 = 0u;
  a3[1] = 0u;
  return result;
}

double re::internal::defaultConstructV2<re::Matrix4x4<float>>(_OWORD *a1)
{
  double result;

  result = 0.0;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t re::introspect_Matrix4x4F(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"Matrix4x4F", (uint64_t (*)(re::internal *))re::allocInfo_Matrix4x4F, (re::IntrospectionBase *(*)(void))re::initInfo_Matrix4x4F, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::Matrix4x4<float>>, this);
}

uint64_t *re::allocInfo_PoseF(re *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  v1 = atomic_load((unsigned __int8 *)&qword_25411C708);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_25411C708))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_25411CF28, 0);
    *(_QWORD *)(v3 + 22) = 0;
    qword_25411CF38 = 0;
    qword_25411CF48 = 0;
    qword_25411CF50 = 0xFFFFFFFFLL;
    qword_25411CF28 = (uint64_t)&off_24ED7DAA8;
    qword_25411CF58 = (uint64_t)"PoseF";
    dword_25411CF60 = 0;
    xmmword_25411CF68 = 0u;
    xmmword_25411CF78 = 0u;
    xmmword_25411CF88 = 0u;
    qword_25411CF98 = 0;
    __cxa_guard_release(&qword_25411C708);
  }
  return &qword_25411CF28;
}

void re::initInfo_PoseF(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t *v8;
  re::IntrospectionBase *v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t *v12;
  uint64_t *v13;
  re::IntrospectionBase *v14;
  uint64_t v15;
  __int128 v16;
  _QWORD v17[2];
  __int128 v18;

  v17[0] = 154604394;
  v17[1] = "PoseF";
  re::StringID::destroyString((re::StringID *)v17);
  *((_OWORD *)this + 2) = v18;
  v4 = atomic_load((unsigned __int8 *)&qword_25411C710);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_25411C710);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      v7 = v6;
      v8 = (uint64_t *)re::internal::introspectionInfoStorage<re::Vector3<float>>;
      if (!re::internal::introspectionInfoStorage<re::Vector3<float>>)
      {
        v8 = re::allocInfo_Vector3F((re *)v6);
        re::internal::introspectionInfoStorage<re::Vector3<float>> = v8;
        re::initInfo_Vector3F((re *)v8, v9);
      }
      v10 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v7 + 32))(v7, 72, 8);
      *(_DWORD *)v10 = 1;
      *(_QWORD *)(v10 + 8) = "position";
      *(_QWORD *)(v10 + 16) = v8;
      *(_QWORD *)(v10 + 24) = 0;
      *(_QWORD *)(v10 + 32) = 1;
      *(_DWORD *)(v10 + 40) = 0;
      *(_QWORD *)(v10 + 48) = 0;
      *(_QWORD *)(v10 + 56) = 0;
      *(_DWORD *)(v10 + 64) = 0;
      qword_25411C810 = v10;
      v11 = re::introspectionAllocator((re *)v10);
      v12 = v11;
      v13 = (uint64_t *)re::internal::introspectionInfoStorage<re::Quaternion<float>>;
      if (!re::internal::introspectionInfoStorage<re::Quaternion<float>>)
      {
        v13 = re::allocInfo_QuaternionF((re *)v11);
        re::internal::introspectionInfoStorage<re::Quaternion<float>> = (uint64_t)v13;
        re::initInfo_QuaternionF((re *)v13, v14);
      }
      v15 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v12 + 32))(v12, 72, 8);
      *(_DWORD *)v15 = 1;
      *(_QWORD *)(v15 + 8) = "orientation";
      *(_QWORD *)(v15 + 16) = v13;
      *(_QWORD *)(v15 + 24) = 0;
      *(_QWORD *)(v15 + 32) = 0x1000000002;
      *(_DWORD *)(v15 + 40) = 0;
      *(_QWORD *)(v15 + 48) = 0;
      *(_QWORD *)(v15 + 56) = 0;
      *(_DWORD *)(v15 + 64) = 0;
      qword_25411C818 = v15;
      __cxa_guard_release(&qword_25411C710);
    }
  }
  *((_QWORD *)this + 2) = 0x2000000008;
  *((_DWORD *)this + 6) = 16;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 2;
  *((_QWORD *)this + 8) = &qword_25411C810;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::Pose<float>>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::Pose<float>>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::Pose<float>>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::Pose<float>>;
  re::IntrospectionRegistry::add(this, v3);
  v16 = v18;
}

void re::internal::defaultConstruct<re::Pose<float>>(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  a3[3] = 0x3F80000000000000;
}

_QWORD *re::internal::defaultConstructV2<re::Pose<float>>(_QWORD *result)
{
  *result = 0;
  result[1] = 0;
  result[2] = 0;
  result[3] = 0x3F80000000000000;
  return result;
}

uint64_t re::introspect_PoseF(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"PoseF", (uint64_t (*)(re::internal *))re::allocInfo_PoseF, (re::IntrospectionBase *(*)(void))re::initInfo_PoseF, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::Pose<float>>, this);
}

uint64_t *re::allocInfo_SRT(re *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  v1 = atomic_load((unsigned __int8 *)&qword_25411C718);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_25411C718))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_25411CFA0, 0);
    *(_QWORD *)(v3 + 22) = 0;
    qword_25411CFB0 = 0;
    qword_25411CFC0 = 0;
    qword_25411CFC8 = 0xFFFFFFFFLL;
    qword_25411CFA0 = (uint64_t)&off_24ED7DAA8;
    qword_25411CFD0 = (uint64_t)"SRT";
    dword_25411CFD8 = 0;
    xmmword_25411CFE0 = 0u;
    xmmword_25411CFF0 = 0u;
    xmmword_25411D000 = 0u;
    qword_25411D010 = 0;
    __cxa_guard_release(&qword_25411C718);
  }
  return &qword_25411CFA0;
}

void re::initInfo_SRT(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t *v8;
  re::IntrospectionBase *v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t *v12;
  uint64_t *v13;
  re::IntrospectionBase *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t *v18;
  re::IntrospectionBase *v19;
  uint64_t v20;
  __int128 v21;
  _QWORD v22[2];
  __int128 v23;

  v22[0] = 164778;
  v22[1] = "SRT";
  re::StringID::destroyString((re::StringID *)v22);
  *((_OWORD *)this + 2) = v23;
  v4 = atomic_load((unsigned __int8 *)&qword_25411C720);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_25411C720);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      v7 = v6;
      v8 = (uint64_t *)re::internal::introspectionInfoStorage<re::Vector3<float>>;
      if (!re::internal::introspectionInfoStorage<re::Vector3<float>>)
      {
        v8 = re::allocInfo_Vector3F((re *)v6);
        re::internal::introspectionInfoStorage<re::Vector3<float>> = v8;
        re::initInfo_Vector3F((re *)v8, v9);
      }
      v10 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v7 + 32))(v7, 72, 8);
      *(_DWORD *)v10 = 1;
      *(_QWORD *)(v10 + 8) = "scale";
      *(_QWORD *)(v10 + 16) = v8;
      *(_QWORD *)(v10 + 24) = 0;
      *(_QWORD *)(v10 + 32) = 1;
      *(_DWORD *)(v10 + 40) = 0;
      *(_QWORD *)(v10 + 48) = 0;
      *(_QWORD *)(v10 + 56) = 0;
      *(_DWORD *)(v10 + 64) = 0;
      qword_25411C820 = v10;
      v11 = re::introspectionAllocator((re *)v10);
      v12 = v11;
      v13 = (uint64_t *)re::internal::introspectionInfoStorage<re::Quaternion<float>>;
      if (!re::internal::introspectionInfoStorage<re::Quaternion<float>>)
      {
        v13 = re::allocInfo_QuaternionF((re *)v11);
        re::internal::introspectionInfoStorage<re::Quaternion<float>> = (uint64_t)v13;
        re::initInfo_QuaternionF((re *)v13, v14);
      }
      v15 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v12 + 32))(v12, 72, 8);
      *(_DWORD *)v15 = 1;
      *(_QWORD *)(v15 + 8) = "rotation";
      *(_QWORD *)(v15 + 16) = v13;
      *(_QWORD *)(v15 + 24) = 0;
      *(_QWORD *)(v15 + 32) = 0x1000000002;
      *(_DWORD *)(v15 + 40) = 0;
      *(_QWORD *)(v15 + 48) = 0;
      *(_QWORD *)(v15 + 56) = 0;
      *(_DWORD *)(v15 + 64) = 0;
      qword_25411C828 = v15;
      v16 = re::introspectionAllocator((re *)v15);
      v17 = v16;
      v18 = (uint64_t *)re::internal::introspectionInfoStorage<re::Vector3<float>>;
      if (!re::internal::introspectionInfoStorage<re::Vector3<float>>)
      {
        v18 = re::allocInfo_Vector3F((re *)v16);
        re::internal::introspectionInfoStorage<re::Vector3<float>> = v18;
        re::initInfo_Vector3F((re *)v18, v19);
      }
      v20 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v17 + 32))(v17, 72, 8);
      *(_DWORD *)v20 = 1;
      *(_QWORD *)(v20 + 8) = "translation";
      *(_QWORD *)(v20 + 16) = v18;
      *(_QWORD *)(v20 + 24) = 0;
      *(_QWORD *)(v20 + 32) = 0x2000000003;
      *(_DWORD *)(v20 + 40) = 0;
      *(_QWORD *)(v20 + 48) = 0;
      *(_QWORD *)(v20 + 56) = 0;
      *(_DWORD *)(v20 + 64) = 0;
      qword_25411C830 = v20;
      __cxa_guard_release(&qword_25411C720);
    }
  }
  *((_QWORD *)this + 2) = 0x3000000008;
  *((_DWORD *)this + 6) = 16;
  *((_WORD *)this + 14) = 257;
  *((_DWORD *)this + 14) = 3;
  *((_QWORD *)this + 8) = &qword_25411C820;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::GenericSRT<float>>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::GenericSRT<float>>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::GenericSRT<float>>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::GenericSRT<float>>;
  re::IntrospectionRegistry::add(this, v3);
  v21 = v23;
}

void re::internal::defaultConstruct<re::GenericSRT<float>>(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  *a3 = 0x3F8000003F800000;
  a3[1] = 1065353216;
  a3[2] = 0;
  a3[3] = 0x3F80000000000000;
  a3[4] = 0;
  a3[5] = 0;
}

_QWORD *re::internal::defaultConstructV2<re::GenericSRT<float>>(_QWORD *result)
{
  *result = 0x3F8000003F800000;
  result[1] = 1065353216;
  result[2] = 0;
  result[3] = 0x3F80000000000000;
  result[4] = 0;
  result[5] = 0;
  return result;
}

uint64_t re::introspect_SRT(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"SRT", (uint64_t (*)(re::internal *))re::allocInfo_SRT, (re::IntrospectionBase *(*)(void))re::initInfo_SRT, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::GenericSRT<float>>, this);
}

uint64_t *re::introspect_RERotationOrder(re *this, const re::IntrospectionBase *a2)
{
  int v2;
  unsigned __int8 v3;
  unsigned __int8 v4;
  char v5;
  re *v6;
  std::__shared_mutex_base *v7;
  re *v8;
  uint64_t *v9;
  uint64_t v10;
  unsigned int *v11;
  _anonymous_namespace_ *v12;
  unint64_t v13;
  unint64_t i;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  char v18;
  unsigned __int8 *v19;
  int v20;
  uint64_t v21;
  unint64_t j;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  char v26;
  unsigned __int8 *v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  std::__shared_mutex_base *v31;
  uint64_t *result;
  re *v33;
  uint64_t *v34;
  re *v35;
  uint64_t *v36;
  re *v37;
  uint64_t *v38;
  re *v39;
  uint64_t *v40;
  re *v41;
  uint64_t *v42;
  re *v43;
  uint64_t *v44;
  re *v45;
  uint64_t *v46;
  re *v47;
  uint64_t *v48;
  re *v49;
  uint64_t *v50;
  re *v51;
  uint64_t *v52;
  re *v53;
  uint64_t *v54;
  re *v55;
  uint64_t *v56;
  re *v57;
  uint64_t *v58;
  re *v59;
  uint64_t *v60;
  re *v61;
  uint64_t *v62;
  re *v63;
  uint64_t *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  const char *v68;
  StringID v69;
  _QWORD v70[2];
  _QWORD v71[61];

  v2 = (int)this;
  v3 = atomic_load((unsigned __int8 *)&qword_25411C728);
  if ((v3 & 1) == 0)
  {
    v33 = (re *)__cxa_guard_acquire(&qword_25411C728);
    if ((_DWORD)v33)
    {
      v34 = re::introspectionAllocator(v33);
      v35 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v34 + 32))(v34, 24, 8);
      *(_DWORD *)v35 = 1;
      *((_QWORD *)v35 + 1) = 0;
      *((_QWORD *)v35 + 2) = "XYZ";
      qword_25411D018 = (uint64_t)v35;
      v36 = re::introspectionAllocator(v35);
      v37 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v36 + 32))(v36, 24, 8);
      *(_DWORD *)v37 = 1;
      *((_QWORD *)v37 + 1) = 1;
      *((_QWORD *)v37 + 2) = "YZX";
      qword_25411D020 = (uint64_t)v37;
      v38 = re::introspectionAllocator(v37);
      v39 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v38 + 32))(v38, 24, 8);
      *(_DWORD *)v39 = 1;
      *((_QWORD *)v39 + 1) = 2;
      *((_QWORD *)v39 + 2) = "ZXY";
      qword_25411D028 = (uint64_t)v39;
      v40 = re::introspectionAllocator(v39);
      v41 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v40 + 32))(v40, 24, 8);
      *(_DWORD *)v41 = 1;
      *((_QWORD *)v41 + 1) = 3;
      *((_QWORD *)v41 + 2) = "XZY";
      qword_25411D030 = (uint64_t)v41;
      v42 = re::introspectionAllocator(v41);
      v43 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v42 + 32))(v42, 24, 8);
      *(_DWORD *)v43 = 1;
      *((_QWORD *)v43 + 1) = 4;
      *((_QWORD *)v43 + 2) = "YXZ";
      qword_25411D038 = (uint64_t)v43;
      v44 = re::introspectionAllocator(v43);
      v45 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v44 + 32))(v44, 24, 8);
      *(_DWORD *)v45 = 1;
      *((_QWORD *)v45 + 1) = 5;
      *((_QWORD *)v45 + 2) = "ZYX";
      qword_25411D040 = (uint64_t)v45;
      v46 = re::introspectionAllocator(v45);
      v47 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v46 + 32))(v46, 24, 8);
      *(_DWORD *)v47 = 1;
      *((_QWORD *)v47 + 1) = 6;
      *((_QWORD *)v47 + 2) = "Count";
      qword_25411D048 = (uint64_t)v47;
      v48 = re::introspectionAllocator(v47);
      v49 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v48 + 32))(v48, 24, 8);
      *(_DWORD *)v49 = 1;
      *((_QWORD *)v49 + 1) = 7;
      *((_QWORD *)v49 + 2) = "Invalid";
      qword_25411D050 = (uint64_t)v49;
      v50 = re::introspectionAllocator(v49);
      v51 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v50 + 32))(v50, 24, 8);
      *(_DWORD *)v51 = 2;
      *((_QWORD *)v51 + 1) = 0;
      *((_QWORD *)v51 + 2) = "RERotationOrderXYZ";
      qword_25411D058 = (uint64_t)v51;
      v52 = re::introspectionAllocator(v51);
      v53 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v52 + 32))(v52, 24, 8);
      *(_DWORD *)v53 = 2;
      *((_QWORD *)v53 + 1) = 1;
      *((_QWORD *)v53 + 2) = "RERotationOrderYZX";
      qword_25411D060 = (uint64_t)v53;
      v54 = re::introspectionAllocator(v53);
      v55 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v54 + 32))(v54, 24, 8);
      *(_DWORD *)v55 = 2;
      *((_QWORD *)v55 + 1) = 2;
      *((_QWORD *)v55 + 2) = "RERotationOrderZXY";
      qword_25411D068 = (uint64_t)v55;
      v56 = re::introspectionAllocator(v55);
      v57 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v56 + 32))(v56, 24, 8);
      *(_DWORD *)v57 = 2;
      *((_QWORD *)v57 + 1) = 3;
      *((_QWORD *)v57 + 2) = "RERotationOrderXZY";
      qword_25411D070 = (uint64_t)v57;
      v58 = re::introspectionAllocator(v57);
      v59 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v58 + 32))(v58, 24, 8);
      *(_DWORD *)v59 = 2;
      *((_QWORD *)v59 + 1) = 4;
      *((_QWORD *)v59 + 2) = "RERotationOrderYXZ";
      qword_25411D078 = (uint64_t)v59;
      v60 = re::introspectionAllocator(v59);
      v61 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v60 + 32))(v60, 24, 8);
      *(_DWORD *)v61 = 2;
      *((_QWORD *)v61 + 1) = 5;
      *((_QWORD *)v61 + 2) = "RERotationOrderZYX";
      qword_25411D080 = (uint64_t)v61;
      v62 = re::introspectionAllocator(v61);
      v63 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v62 + 32))(v62, 24, 8);
      *(_DWORD *)v63 = 2;
      *((_QWORD *)v63 + 1) = 6;
      *((_QWORD *)v63 + 2) = "RERotationOrderCount";
      qword_25411D088 = (uint64_t)v63;
      v64 = re::introspectionAllocator(v63);
      v65 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v64 + 32))(v64, 24, 8);
      *(_DWORD *)v65 = 2;
      *(_QWORD *)(v65 + 8) = 7;
      *(_QWORD *)(v65 + 16) = "RERotationOrderInvalid";
      qword_25411D090 = v65;
      __cxa_guard_release(&qword_25411C728);
    }
  }
  v4 = atomic_load((unsigned __int8 *)&qword_25411C730);
  if ((v4 & 1) == 0 && __cxa_guard_acquire(&qword_25411C730))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_25411C838, "RERotationOrder", 1, 1, 1, 1);
    qword_25411C838 = (uint64_t)&off_24ED7D9E8;
    qword_25411C878 = (uint64_t)&re::introspect_RERotationOrder(BOOL)::enumTable;
    dword_25411C848 = 9;
    __cxa_guard_release(&qword_25411C730);
  }
  if (v2)
  {
    if ((_MergedGlobals_415 & 1) != 0)
      return &qword_25411C838;
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)v71);
    v5 = _MergedGlobals_415;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)v71);
    if ((v5 & 1) != 0)
      return &qword_25411C838;
    v7 = re::introspectionSharedMutex(v6);
    std::__shared_mutex_base::lock(v7);
    if ((_MergedGlobals_415 & 1) != 0)
    {
LABEL_34:
      v31 = re::introspectionSharedMutex(v8);
      std::__shared_mutex_base::unlock(v31);
      return &qword_25411C838;
    }
  }
  _MergedGlobals_415 = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_25411C838, a2);
  v67 = 0x9091FC13CDF02DFALL;
  v68 = "RERotationOrder";
  v71[0] = 0x31CD534126;
  v71[1] = "uint8_t";
  v9 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v71);
  if (v9)
  {
    v10 = *v9;
    re::StringID::destroyString((re::StringID *)v71);
    v11 = (unsigned int *)qword_25411C878;
    v70[1] = v10;
    re::TypeBuilder::beginEnumType((uint64_t)v71, &v67, 1, 1, (uint64_t)v70);
    v13 = *v11;
    if ((_DWORD)v13)
    {
      for (i = 0; i < v13; ++i)
      {
        v15 = *(_QWORD *)(*((_QWORD *)v11 + 1) + 8 * i);
        if (*(_DWORD *)v15 == 1)
        {
          v16 = *(char **)(v15 + 16);
          if (v16)
          {
            v17 = *v16;
            if (*v16)
            {
              v18 = v16[1];
              if (v18)
              {
                v19 = (unsigned __int8 *)(v16 + 2);
                do
                {
                  v17 = 31 * v17 + v18;
                  v20 = *v19++;
                  v18 = v20;
                }
                while (v20);
              }
            }
          }
          else
          {
            v17 = 0;
          }
          v21 = *(_QWORD *)(v15 + 8);
          *(_QWORD *)&v69.var0 = 2 * v17;
          v69.var1 = v16;
          re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v71, v21, &v69);
          re::StringID::destroyString((re::StringID *)&v69);
          v13 = *v11;
        }
      }
      if (v13)
      {
        for (j = 0; j < v13; ++j)
        {
          v23 = *(_QWORD *)(*((_QWORD *)v11 + 1) + 8 * j);
          if (*(_DWORD *)v23 == 2)
          {
            v24 = *(char **)(v23 + 16);
            if (v24)
            {
              v25 = *v24;
              if (*v24)
              {
                v26 = v24[1];
                if (v26)
                {
                  v27 = (unsigned __int8 *)(v24 + 2);
                  do
                  {
                    v25 = 31 * v25 + v26;
                    v28 = *v27++;
                    v26 = v28;
                  }
                  while (v28);
                }
              }
            }
            else
            {
              v25 = 0;
            }
            v29 = *(_QWORD *)(v23 + 8);
            *(_QWORD *)&v69.var0 = 2 * v25;
            v69.var1 = v24;
            re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v71, v29, &v69);
            re::StringID::destroyString((re::StringID *)&v69);
            v13 = *v11;
          }
        }
      }
    }
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v71, v30);
    xmmword_25411C858 = (__int128)v69;
    re::StringID::destroyString((re::StringID *)&v67);
    if ((v2 & 1) != 0)
      return &qword_25411C838;
    goto LABEL_34;
  }
  re::StringID::destroyString((re::StringID *)v71);
  re::internal::assertLog((re::internal *)5, v66, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "RERotationOrder", v67, v68);
  result = (uint64_t *)_os_crash();
  __break(1u);
  return result;
}

uint64_t *re::snapshot::operator>><re::snapshot::Reader<re::snapshot::DecoderRaw>,float,4ul>(uint64_t *this, _OWORD *a2)
{
  re::snapshot::DecoderRaw *v3;
  _QWORD *v4;
  uint64_t v5;
  _OWORD *v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  unsigned int v10;
  unint64_t v12;

  v3 = (re::snapshot::DecoderRaw *)this;
  v12 = 0;
  v4 = (_QWORD *)this[2];
  v5 = this[3];
  if ((unint64_t)(v5 - (_QWORD)v4) < 8)
  {
    re::snapshot::Decoder::error((const char **)this, "overrun: attempted to read %zu bytes, only %zu remaining", 8uLL, v5 - (_QWORD)v4);
    this = (uint64_t *)re::snapshot::DecoderRaw::beginArray(v3, &v12);
    if ((_DWORD)this)
    {
      if (v12 == 4)
      {
        v8 = 0;
        v9 = -4;
        do
        {
          if (v8 <= 3)
          {
            v10 = v8 + 1;
            this = re::snapshot::DecoderRaw::operator>><float>((uint64_t *)v3, (_DWORD *)a2 + v8);
            v8 = v10;
          }
        }
        while (!__CFADD__(v9++, 1));
        if (v8 != 4)
          return re::snapshot::Decoder::error((const char **)v3, "size mismatch: expected %zu, got %d");
      }
      else
      {
        return re::snapshot::Decoder::error((const char **)v3, "unexpected C Array size: expected %zu, got %zu");
      }
    }
  }
  else
  {
    v7 = *v4;
    v6 = v4 + 1;
    this[2] = (uint64_t)v6;
    if (v7 == 16)
    {
      if ((unint64_t)(v5 - (_QWORD)v6) <= 0xF)
      {
        return re::snapshot::Decoder::error((const char **)this, "overrun: attempted to read %zu bytes, only %zu remaining");
      }
      else
      {
        *a2 = *v6;
        this[2] += 16;
      }
    }
    else
    {
      return re::snapshot::Decoder::error((const char **)this, "C Array size mismatch: expected %zu, got %zu");
    }
  }
  return this;
}

uint64_t *re::snapshot::DecoderRaw::operator>><double>(uint64_t *result, _QWORD *a2)
{
  _QWORD *v2;
  unint64_t v3;

  v2 = (_QWORD *)result[2];
  v3 = result[3] - (_QWORD)v2;
  if (v3 <= 7)
    return re::snapshot::Decoder::error((const char **)result, "overrun: attempted to read %zu bytes, only %zu remaining", 8uLL, v3);
  *a2 = *v2;
  result[2] += 8;
  return result;
}

uint64_t *re::snapshot::operator>><re::snapshot::Reader<re::snapshot::DecoderRaw>,re::Vector4<float>,4ul>(uint64_t *this, _OWORD *a2)
{
  uint64_t *v3;
  _QWORD *v4;
  uint64_t v5;
  __int128 *v6;
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  unsigned int v11;
  uint64_t v12;
  unsigned int v13;
  unint64_t v15;

  v3 = this;
  v15 = 0;
  v4 = (_QWORD *)this[2];
  v5 = this[3];
  if ((unint64_t)(v5 - (_QWORD)v4) < 8)
  {
    re::snapshot::Decoder::error((const char **)this, "overrun: attempted to read %zu bytes, only %zu remaining", 8uLL, v5 - (_QWORD)v4);
    this = (uint64_t *)re::snapshot::DecoderRaw::beginArray((re::snapshot::DecoderRaw *)v3, &v15);
    if ((_DWORD)this)
    {
      if (v15 == 4)
      {
        v11 = 0;
        v12 = -4;
        do
        {
          if (v11 <= 3)
          {
            v13 = v11 + 1;
            this = re::snapshot::operator>><re::snapshot::Reader<re::snapshot::DecoderRaw>,float,4ul>(v3, &a2[v11]);
            *((_DWORD *)v3 + 8) = 0;
            v11 = v13;
          }
        }
        while (!__CFADD__(v12++, 1));
        if (v11 != 4)
          return re::snapshot::Decoder::error((const char **)v3, "size mismatch: expected %zu, got %d");
      }
      else
      {
        return re::snapshot::Decoder::error((const char **)v3, "unexpected C Array size: expected %zu, got %zu");
      }
    }
  }
  else
  {
    v7 = *v4;
    v6 = (__int128 *)(v4 + 1);
    this[2] = (uint64_t)v6;
    if (v7 == 64)
    {
      if ((unint64_t)(v5 - (_QWORD)v6) <= 0x3F)
      {
        return re::snapshot::Decoder::error((const char **)this, "overrun: attempted to read %zu bytes, only %zu remaining");
      }
      else
      {
        v8 = *v6;
        v9 = v6[1];
        v10 = v6[3];
        a2[2] = v6[2];
        a2[3] = v10;
        *a2 = v8;
        a2[1] = v9;
        this[2] += 64;
      }
    }
    else
    {
      return re::snapshot::Decoder::error((const char **)this, "C Array size mismatch: expected %zu, got %zu");
    }
  }
  return this;
}

uint64_t re::snapshot::operator>><re::snapshot::Reader<re::snapshot::DecoderOPACK>,re::Vector4<float>,4ul>(uint64_t a1, _OWORD *a2)
{
  uint64_t result;
  __int128 *v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  unsigned int v9;
  unsigned int v10;
  float *v11;
  _OWORD *v12;
  unsigned int v13;
  unsigned __int8 *v14;
  int v15;
  unsigned __int8 *v16;
  int v17;
  unsigned __int8 *v18;
  int v19;
  int Integer;
  unsigned __int8 *v21;
  int v22;
  unsigned __int8 *v23;
  int v24;
  unint64_t v25;
  unint64_t v26;

  v25 = 0;
  result = re::snapshot::DecoderOPACK::beginData((re::snapshot::DecoderOPACK *)a1, &v25, 1);
  if ((_DWORD)result)
  {
    if (v25 == 64)
    {
      v5 = *(__int128 **)(a1 + 16);
      if (*(_QWORD *)(a1 + 24) - (_QWORD)v5 <= 0x3FuLL)
      {
        return (uint64_t)re::snapshot::Decoder::error((const char **)a1, "overrun: attempted to read %zu bytes, only %zu remaining");
      }
      else
      {
        v6 = *v5;
        v7 = v5[1];
        v8 = v5[3];
        a2[2] = v5[2];
        a2[3] = v8;
        *a2 = v6;
        a2[1] = v7;
        *(_QWORD *)(a1 + 16) += 64;
      }
    }
    else
    {
      return (uint64_t)re::snapshot::Decoder::error((const char **)a1, "C Array size mismatch: expected %zu, got %zu");
    }
  }
  else
  {
    result = re::snapshot::DecoderOPACK::beginArray((re::snapshot::DecoderOPACK *)a1, &v25);
    if ((_DWORD)result)
    {
      if (v25 == 4)
      {
        v9 = 0;
        if (re::snapshot::DecoderOPACK::endArray((re::snapshot::DecoderOPACK *)a1, &v25))
          return (uint64_t)re::snapshot::Decoder::error((const char **)a1, "size mismatch: expected %zu, got %d");
        do
        {
          if (v9 > 3)
          {
            v21 = *(unsigned __int8 **)(a1 + 16);
            if ((unint64_t)v21 >= *(_QWORD *)(a1 + 24))
            {
              v22 = 0;
            }
            else
            {
              *(_QWORD *)(a1 + 16) = v21 + 1;
              v22 = *v21;
            }
            re::snapshot::DecoderOPACK::skip((uint64_t *)a1, v22);
          }
          else
          {
            v10 = v9 + 1;
            if (re::snapshot::DecoderOPACK::beginObject((re::snapshot::DecoderOPACK *)a1, 0))
            {
              if (re::snapshot::DecoderOPACK::advanceTo<1>(a1))
              {
                v11 = (float *)&a2[v9];
                v26 = 0;
                if (re::snapshot::DecoderOPACK::beginData((re::snapshot::DecoderOPACK *)a1, &v26, 1))
                {
                  if (v26 == 16)
                  {
                    v12 = *(_OWORD **)(a1 + 16);
                    if (*(_QWORD *)(a1 + 24) - (_QWORD)v12 <= 0xFuLL)
                    {
                      re::snapshot::Decoder::error((const char **)a1, "overrun: attempted to read %zu bytes, only %zu remaining");
                    }
                    else
                    {
                      *(_OWORD *)v11 = *v12;
                      *(_QWORD *)(a1 + 16) += 16;
                    }
                  }
                  else
                  {
                    re::snapshot::Decoder::error((const char **)a1, "C Array size mismatch: expected %zu, got %zu");
                  }
                }
                else if (re::snapshot::DecoderOPACK::beginArray((re::snapshot::DecoderOPACK *)a1, &v26))
                {
                  if (v26 == 4)
                  {
                    v13 = 0;
                    if (re::snapshot::DecoderOPACK::endArray((re::snapshot::DecoderOPACK *)a1, &v26))
                      goto LABEL_35;
                    do
                    {
                      if (v13 > 3)
                      {
                        v14 = *(unsigned __int8 **)(a1 + 16);
                        if ((unint64_t)v14 >= *(_QWORD *)(a1 + 24))
                        {
                          v15 = 0;
                        }
                        else
                        {
                          *(_QWORD *)(a1 + 16) = v14 + 1;
                          v15 = *v14;
                        }
                        re::snapshot::DecoderOPACK::skip((uint64_t *)a1, v15);
                      }
                      else
                      {
                        re::snapshot::DecoderOPACK::operator>>((uint64_t *)a1, &v11[v13++]);
                      }
                    }
                    while (!re::snapshot::DecoderOPACK::endArray((re::snapshot::DecoderOPACK *)a1, &v26));
                    if (v13 != 4)
LABEL_35:
                      re::snapshot::Decoder::error((const char **)a1, "size mismatch: expected %zu, got %d");
                  }
                  else
                  {
                    re::snapshot::Decoder::error((const char **)a1, "unexpected C Array size: expected %zu, got %zu", 4uLL, v26);
                    while (!re::snapshot::DecoderOPACK::endArray((re::snapshot::DecoderOPACK *)a1, &v26))
                    {
                      v16 = *(unsigned __int8 **)(a1 + 16);
                      if ((unint64_t)v16 >= *(_QWORD *)(a1 + 24))
                      {
                        v17 = 0;
                      }
                      else
                      {
                        *(_QWORD *)(a1 + 16) = v16 + 1;
                        v17 = *v16;
                      }
                      re::snapshot::DecoderOPACK::skip((uint64_t *)a1, v17);
                    }
                  }
                }
                v18 = *(unsigned __int8 **)(a1 + 16);
                if ((unint64_t)v18 >= *(_QWORD *)(a1 + 24) || (v19 = *v18, v19 == 3))
                {
                  Integer = 0x7FFFFFFF;
                }
                else if ((v19 - 7) > 0x28)
                {
                  Integer = re::snapshot::DecoderOPACK::readInteger((re::snapshot::DecoderOPACK *)a1, 0x7FFFFFFFLL);
                }
                else
                {
                  *(_QWORD *)(a1 + 16) = v18 + 1;
                  Integer = v19 - 8;
                }
                *(_DWORD *)(a1 + 32) = Integer;
              }
              re::snapshot::DecoderOPACK::endObject((uint64_t *)a1, 0);
            }
            v9 = v10;
          }
          result = re::snapshot::DecoderOPACK::endArray((re::snapshot::DecoderOPACK *)a1, &v25);
        }
        while (!(_DWORD)result);
        if (v9 != 4)
          return (uint64_t)re::snapshot::Decoder::error((const char **)a1, "size mismatch: expected %zu, got %d");
      }
      else
      {
        re::snapshot::Decoder::error((const char **)a1, "unexpected C Array size: expected %zu, got %zu", 4uLL, v25);
        while (1)
        {
          result = re::snapshot::DecoderOPACK::endArray((re::snapshot::DecoderOPACK *)a1, &v25);
          if ((result & 1) != 0)
            break;
          v23 = *(unsigned __int8 **)(a1 + 16);
          if ((unint64_t)v23 >= *(_QWORD *)(a1 + 24))
          {
            v24 = 0;
          }
          else
          {
            *(_QWORD *)(a1 + 16) = v23 + 1;
            v24 = *v23;
          }
          re::snapshot::DecoderOPACK::skip((uint64_t *)a1, v24);
        }
      }
    }
  }
  return result;
}

_QWORD *re::Pose<float>::Pose(_QWORD *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *result = a2;
  result[1] = a3;
  result[2] = a4;
  result[3] = a5;
  return result;
}

float32x2_t re::Pose<float>::Pose(uint64_t a1, uint64_t a2, uint64_t a3, int32x4_t *a4)
{
  int32x4_t v4;
  int32x4_t v5;
  int32x4_t v6;
  float v7;
  float v8;
  float v9;
  float v11;
  float v12;
  int32x4_t v13;
  float32x2_t v14;
  float32x2_t v15;
  float32x2_t v16;
  float32x2_t v17;
  float32x2_t v18;
  float v20;
  float32_t v21;
  float32x2_t v22;
  float32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  float32x2_t v27;
  float32x2_t v28;
  float32x2_t v29;
  __int128 v34;
  float32x2_t v35;
  float32x2_t result;
  float v37;
  unsigned int v38;
  float32x2_t v39;
  float32x2_t v40;
  float32x2_t v41;
  float32x2_t v42;
  float32x2_t v43;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = a3;
  v4 = *a4;
  v5 = a4[1];
  v6 = a4[2];
  LODWORD(v7) = HIDWORD(a4[1].i64[0]);
  v8 = COERCE_FLOAT(a4[2].i64[1]);
  v9 = v8 + (float)(COERCE_FLOAT(*a4) + v7);
  if (v9 >= 0.0)
  {
    v20 = sqrtf(v9 + 1.0);
    v21 = v20 + v20;
    v22 = vrecpe_f32((float32x2_t)COERCE_UNSIGNED_INT(v20 + v20));
    v23 = vmul_f32(v22, vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT(v20 + v20), v22));
    v23.i32[0] = vmul_f32(v23, vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT(v20 + v20), v23)).u32[0];
    *(float32x2_t *)&v34 = vmul_n_f32(vsub_f32((float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v5, (int8x16_t)v5, 8uLL), *(int32x2_t *)v6.i8), (float32x2_t)vext_s8(*(int8x8_t *)v6.i8, (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v4, (int8x16_t)v4, 8uLL), 4uLL)), v23.f32[0]);
    v24.i32[0] = vsub_f32((float32x2_t)*(_OWORD *)&vdupq_lane_s32(*(int32x2_t *)v4.i8, 1), *(float32x2_t *)v5.i8).u32[0];
    v24.f32[1] = v21;
    v23.i32[1] = 0.25;
    result = vmul_f32(v24, v23);
  }
  else if (*(float *)v4.i32 < v7 || *(float *)v4.i32 < v8)
  {
    v11 = 1.0 - *(float *)v4.i32;
    if (v7 >= v8)
    {
      v37 = sqrtf(v7 + (float)(v11 - v8));
      *(float *)&v38 = v37 + v37;
      v39 = vrecpe_f32((float32x2_t)v38);
      v40 = vmul_f32(v39, vrecps_f32((float32x2_t)v38, v39));
      v41.i32[0] = vmul_f32(v40, vrecps_f32((float32x2_t)v38, v40)).u32[0];
      v40.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_lane_s32(*(int32x2_t *)v4.i8, 1), *(float32x2_t *)v5.i8).u32[0];
      v40.i32[1] = v38;
      v42 = (float32x2_t)vrev64_s32(*(int32x2_t *)v6.i8);
      v43.i32[0] = vadd_f32(v42, (float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v5, (int8x16_t)v5, 8uLL)).u32[0];
      v43.i32[1] = vsub_f32(v42, (float32x2_t)vdup_laneq_s32(v4, 2)).i32[1];
      result = vmul_n_f32(v43, v41.f32[0]);
      v41.i32[1] = 0.25;
      *(float32x2_t *)&v34 = vmul_f32(v40, v41);
    }
    else
    {
      v12 = sqrtf(v8 + (float)(v11 - v7));
      v13 = *a4;
      *(float *)v13.i32 = v12;
      v14 = vadd_f32((float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v4, (int8x16_t)v4, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v5, (int8x16_t)v5, 8uLL)), *(float32x2_t *)v6.i8);
      v15 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)v5.i8, 0);
      v16 = vsub_f32(*(float32x2_t *)v4.i8, v15);
      v15.i32[0] = 2.0;
      v15.i32[0] = vmul_f32(*(float32x2_t *)v13.i8, v15).u32[0];
      v15.i32[1] = v16.i32[1];
      v17 = vrecpe_f32((float32x2_t)v15.u32[0]);
      v18 = vmul_f32(v17, vrecps_f32((float32x2_t)v15.u32[0], v17));
      v16.i32[0] = vmul_f32(v18, vrecps_f32((float32x2_t)v15.u32[0], v18)).u32[0];
      *(float32x2_t *)&v34 = vmul_n_f32(v14, v16.f32[0]);
      __asm { FMOV            V2.2S, #0.25 }
      _D2.i32[1] = v16.i32[0];
      result = vmul_f32(v15, _D2);
    }
  }
  else
  {
    v25 = (float32x2_t)__PAIR64__(v4.u32[1], COERCE_UNSIGNED_INT(sqrtf(*(float *)v4.i32 + (float)((float)(1.0 - v7) - v8))));
    v26 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)v5.i8, 0);
    v27 = vadd_f32(*(float32x2_t *)v4.i8, v26);
    v26.i32[0] = 2.0;
    v26.i32[0] = vmul_f32(v25, v26).u32[0];
    v26.i32[1] = v27.i32[1];
    v28 = vrecpe_f32((float32x2_t)v26.u32[0]);
    v29 = vmul_f32(v28, vrecps_f32((float32x2_t)v26.u32[0], v28));
    v25.i32[0] = vmul_f32(v29, vrecps_f32((float32x2_t)v26.u32[0], v29)).u32[0];
    __asm { FMOV            V5.2S, #0.25 }
    _D5.i32[1] = v25.i32[0];
    *(float32x2_t *)&v34 = vmul_f32(v26, _D5);
    v35.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v4, (int8x16_t)v4, 8uLL), *(float32x2_t *)v6.i8).u32[0];
    v35.i32[1] = vsub_f32((float32x2_t)vdup_laneq_s32(v5, 2), *(float32x2_t *)&v6).i32[1];
    result = vmul_n_f32(v35, v25.f32[0]);
  }
  *((float32x2_t *)&v34 + 1) = result;
  *(_OWORD *)(a1 + 16) = v34;
  return result;
}

BOOL re::DynamicOffsetF::isInSteadyState(re::DynamicOffsetF *this)
{
  float *v2;
  _BOOL8 result;
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;

  v2 = (float *)((char *)this + 48);
  result = re::areAlmostEqual<float>((float *)this, (float *)this + 12);
  if (result)
  {
    v4 = *((float *)this + 8);
    v5 = *((float *)this + 20);
    if (v4 != v5 && vabds_f32(v4, v5) >= (float)((float)((float)(fabsf(v4) + fabsf(v5)) + 1.0) * 0.00001))
      return 0;
    v6 = *((float *)this + 9);
    v7 = *((float *)this + 21);
    if (v6 != v7 && vabds_f32(v6, v7) >= (float)((float)((float)(fabsf(v6) + fabsf(v7)) + 1.0) * 0.00001))
      return 0;
    v8 = *((float *)this + 10);
    v9 = *((float *)this + 22);
    if (v8 != v9 && vabds_f32(v8, v9) >= (float)((float)((float)(fabsf(v8) + fabsf(v9)) + 1.0) * 0.00001))
      return 0;
    result = re::areAlmostEqual<float>(v2, (float *)this + 24);
    if (!result)
      return result;
    if (((v10 = *((float *)this + 20), v11 = *((float *)this + 32), v10 == v11)
       || vabds_f32(v10, v11) < (float)((float)((float)(fabsf(v10) + fabsf(v11)) + 1.0) * 0.00001))
      && ((v12 = *((float *)this + 21), v13 = *((float *)this + 33), v12 == v13)
       || vabds_f32(v12, v13) < (float)((float)((float)(fabsf(v12) + fabsf(v13)) + 1.0) * 0.00001)))
    {
      v14 = *((float *)this + 22);
      v15 = *((float *)this + 34);
      return v14 == v15 || vabds_f32(v14, v15) < (float)((float)((float)(fabsf(v14) + fabsf(v15)) + 1.0) * 0.00001);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

float32x4_t re::DynamicOffsetF::calculateConstrainedPose@<Q0>(float32x4_t *a1@<X0>, float32x4_t *a2@<X1>, float32x4_t *a3@<X8>)
{
  float32x4_t v5;
  float32x4_t v7;
  float32x4_t v8;
  float32x4_t v9;
  float32x4_t v10;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v21;
  float32x4_t v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float32x4_t v27;
  float v28;
  float32x4_t v29;
  float v30;
  float32x2_t v31;
  float32x2_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float v36;
  float v37;
  float32x2_t v38;
  float32x2_t v39;
  __float2 v40;
  int8x16_t v41;
  float32x4_t v42;
  int8x16_t v43;
  float32x4_t v44;
  int8x16_t v45;
  float32x4_t v46;
  float32x4_t v47;
  int8x16_t v48;
  float32x4_t v49;
  float32x4_t v50;
  int8x16_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  int8x16_t v57;
  float32x4_t v58;
  int8x16_t v59;
  float32x4_t v60;
  float32x4_t v62;
  float32x4_t result;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;

  v5 = a1[9];
  _Q5 = a1[10];
  v7 = vnegq_f32(_Q5);
  v9 = *a2;
  v8 = a2[1];
  v10 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v7, (int32x4_t)v7), (int8x16_t)v7, 0xCuLL);
  _S8 = _Q5.i32[3];
  _Q1 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v8, (int32x4_t)v8), (int8x16_t)v8, 0xCuLL), _Q5), v8, v10);
  v13 = vmlaq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q1, (int32x4_t)_Q1), _Q1, 0xCuLL), v8, _Q5, 3);
  _Q1.i32[0] = v8.i32[3];
  v14 = vmlsq_laneq_f32(v13, _Q5, v8, 3);
  __asm { FMLA            S0, S1, V5.S[3] }
  _Q18 = v14;
  _Q18.f32[3] = _S0;
  v22 = a1[14];
  v21 = a1[15];
  v23 = a1[17].f32[0];
  if (v23 != -3.4028e38 || a1[17].f32[1] != 3.4028e38)
  {
    v67 = a1[14];
    v68 = a1[15];
    v69 = *a2;
    v70 = v10;
    v71 = v7;
    v72 = a1[10];
    v73 = a1[9];
    v24 = fabsf(_S0);
    if (v24 <= 1.0 || fabsf(v24 + -1.0) < (float)((float)((float)(v24 + 1.0) + 1.0) * 0.00001))
    {
      if (_S0 > 1.0)
        _S0 = 1.0;
      if (_S0 < -1.0)
        _S0 = -1.0;
      v64 = v14;
      v65 = _Q18;
      v26 = acosf(_S0);
      v14 = v64;
      _Q18 = v65;
      v25 = v26 + v26;
    }
    else
    {
      v25 = NAN;
    }
    v27 = vmulq_f32(_Q18, _Q18);
    LODWORD(v28) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v27, 2), vaddq_f32(v27, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v27.f32, 1))).u32[0];
    v29 = 0uLL;
    if (fabsf(v28) >= 1.0e-10)
    {
      v30 = v28;
      v31 = vrsqrte_f32((float32x2_t)LODWORD(v28));
      v32 = vmul_f32(v31, vrsqrts_f32((float32x2_t)LODWORD(v30), vmul_f32(v31, v31)));
      v29 = vmulq_n_f32(v14, vmul_f32(v32, vrsqrts_f32((float32x2_t)LODWORD(v30), vmul_f32(v32, v32))).f32[0]);
    }
    v33 = a1[16];
    v34 = vmulq_f32(v29, v33);
    if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v34, 2), vaddq_f32(v34, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v34.f32, 1))).f32[0] < 0.0)v25 = -v25;
    if (v25 < v23)
      v25 = v23;
    if (v25 > a1[17].f32[1])
      v25 = a1[17].f32[1];
    v35 = vmulq_f32(v33, v33);
    LODWORD(v36) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v35, 2), vaddq_f32(v35, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v35.f32, 1))).u32[0];
    if (fabsf(v36) >= 1.0e-10)
    {
      v37 = v36;
      v38 = vrsqrte_f32((float32x2_t)LODWORD(v36));
      v39 = vmul_f32(v38, vrsqrts_f32((float32x2_t)LODWORD(v37), vmul_f32(v38, v38)));
      v33 = vmulq_n_f32(v33, vmul_f32(v39, vrsqrts_f32((float32x2_t)LODWORD(v37), vmul_f32(v39, v39))).f32[0]);
    }
    v66 = v33;
    v40 = __sincosf_stret(v25 * 0.5);
    v22 = v67;
    *(float32x2_t *)_Q18.f32 = vmul_n_f32(*(float32x2_t *)v66.f32, v40.__sinval);
    _Q18.i64[1] = __PAIR64__(LODWORD(v40.__cosval), COERCE_UNSIGNED_INT(vmuls_lane_f32(v40.__sinval, v66, 2)));
    _Q5 = v72;
    v5 = v73;
    v7 = v71;
    v9 = v69;
    v10 = v70;
    v21 = v68;
  }
  v41 = (int8x16_t)vnegq_f32(v5);
  v42 = vmlsq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v41, (int32x4_t)v41), v41, 0xCuLL), _Q5), v10, v5);
  v43 = (int8x16_t)vaddq_f32(v42, v42);
  v44 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v43, (int32x4_t)v43), v43, 0xCuLL);
  v45 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v44, (int32x4_t)v44), (int8x16_t)v44, 0xCuLL), _Q5), v44, v10);
  v46 = vaddq_f32(vsubq_f32(vmulq_laneq_f32(v44, _Q5, 3), v5), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v45, (int32x4_t)v45), v45, 0xCuLL));
  v47 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v9, (int32x4_t)v9), (int8x16_t)v9, 0xCuLL), _Q5), v9, v10);
  v48 = (int8x16_t)vaddq_f32(v47, v47);
  v49 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v48, (int32x4_t)v48), v48, 0xCuLL);
  v50 = vaddq_f32(v9, vmulq_laneq_f32(v49, _Q5, 3));
  v51 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v49, (int32x4_t)v49), (int8x16_t)v49, 0xCuLL), _Q5), v49, v10);
  v52 = vaddq_f32(v46, vaddq_f32(v50, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v51, (int32x4_t)v51), v51, 0xCuLL)));
  v52.i32[3] = 0;
  v22.i32[3] = 0;
  v53 = vmaxnmq_f32(v52, v22);
  v53.i32[3] = 0;
  v21.i32[3] = 0;
  v54 = vminnmq_f32(v53, v21);
  v55 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q5, (int32x4_t)_Q5), (int8x16_t)_Q5, 0xCuLL);
  v56 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v54, (int32x4_t)v54), (int8x16_t)v54, 0xCuLL), v7), v54, v55);
  v57 = (int8x16_t)vaddq_f32(v56, v56);
  v58 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v57, (int32x4_t)v57), v57, 0xCuLL);
  v59 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v58, (int32x4_t)v58), (int8x16_t)v58, 0xCuLL), v7), v58, v55);
  v60 = vaddq_f32(vaddq_f32(v54, vmulq_laneq_f32(v58, _Q5, 3)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v59, (int32x4_t)v59), v59, 0xCuLL));
  _Q2 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q18, (int32x4_t)_Q18), (int8x16_t)_Q18, 0xCuLL), v7), _Q18, v55);
  v62 = vmlaq_laneq_f32(vmlaq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q2, (int32x4_t)_Q2), _Q2, 0xCuLL), _Q18, _Q5, 3), _Q5, _Q18, 3);
  __asm { FMLA            S2, S8, V18.S[3] }
  v62.i32[3] = _Q2.i32[0];
  result = vaddq_f32(v5, v60);
  *a3 = result;
  a3[1] = v62;
  return result;
}

void re::DynamicOffsetF::step(float32x4_t *this, float a2, int32x2_t a3)
{
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float v16;
  float32x4_t v17;
  int8x16_t v18;
  float32x4_t v19;
  int8x16_t v20;
  float v21;
  float v22;
  BOOL v23;
  float v24;
  float v25;
  float32x2_t v26;
  float32x2_t v27;
  float v28;
  float32x4_t v29;
  float v30;
  float v31;
  float v32;
  float32x4_t v33;
  int8x16_t v34;
  float32x2_t v35;
  float32x4_t v36;
  unsigned __int32 v37;
  float32x2_t v38;
  float32x2_t v39;
  int8x16_t v40;
  float32x2_t v41;
  float32x2_t v42;
  float32x4_t v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  int8x16_t v54;
  float32x4_t v55;
  int8x16_t v56;
  float v57;
  float v58;
  float v59;
  float v60;
  float32x2_t v61;
  float32x2_t v62;
  float v63;
  float32x4_t v64;
  float v65;
  float v66;
  float v67;
  float32x4_t v68;
  int8x16_t v69;
  float32x2_t v70;
  float32x4_t v71;
  unsigned __int32 v72;
  float32x2_t v73;
  float32x2_t v74;
  int8x16_t v75;
  float32x2_t v76;
  float32x2_t v77;
  float v78;
  float v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float v84;
  float v85;
  float v86;
  float v87;
  float v88;
  float v89;
  float v90;
  float v91;
  float v92;
  float v93;
  float v94;
  float32x4_t v95;
  float v96;
  float v97;
  float v98;
  float v99;
  float v100;
  float32x4_t v101;
  float v102;
  float32x4_t v103;
  float v104;
  float32x2_t v105;
  float32x2_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float v109;
  float v110;
  float v111;
  float v112;
  float v113;
  float32x4_t v114;
  float v115;
  float32x4_t v116;
  float v117;
  float32x2_t v118;
  float32x2_t v119;
  float32x4_t v120;
  float v121;
  float32x4_t v122;
  float v123;
  float v124;
  float32x2_t v125;
  float32x2_t v126;
  __float2 v127;
  float32x4_t v128;
  float v129;
  float v130;
  float32x4_t v131;
  float v132;
  float v133;
  float v134;
  float v135;
  float v136;
  float32x4_t v137;
  int8x16_t v138;
  float v139;
  float v140;
  float v141;
  float v142;
  float32x4_t v143;
  int8x16_t v144;
  float32x4_t v145;
  float32x4_t v146;
  int8x16_t v147;
  float32x2_t v148;
  float32x2_t v149;
  float32x4_t v150;
  float v151;
  float v152;
  float v153;
  float32x4_t v154;
  float32x4_t v155;
  float v156;
  float32x4_t v157;
  float v158;
  float32x2_t v159;
  float32x2_t v160;
  float v161;
  float32x4_t v162;
  float v163;
  float v164;
  float v165;
  float32x4_t v166;
  float32x4_t v167;
  float v168;
  float32x4_t v169;
  float v170;
  float v171;
  float v172;
  float32x4_t v173;
  float v174;
  float32x4_t v175;
  float v176;
  float32x4_t v177;
  float v178;
  float v179;
  float32x4_t v180;
  float32x4_t v181;
  float v182;
  float32x4_t v183;
  float32x4_t v184;
  float v185;
  float32x4_t v186;
  float32x4_t v187;
  float32x4_t v188;
  float32x4_t v189;
  float32x4_t v190;
  float32x4_t v191;
  int32x2_t v192;
  float32x4_t v193;
  float32x4_t v194;
  float32x4_t v195;

  if (this[33].i8[0])
    return;
  *(float *)a3.i32 = a2;
  v187 = *this;
  v177 = this[1];
  v188 = this[2];
  v192 = a3;
  v4 = powf(this[11].f32[0], a2);
  v5 = powf(this[11].f32[1], *(float *)v192.i32);
  v6 = powf(this[11].f32[2], *(float *)v192.i32);
  v7 = powf(this[13].f32[0], *(float *)v192.i32);
  v185 = powf(this[12].f32[0], *(float *)v192.i32);
  v182 = powf(this[12].f32[1], *(float *)v192.i32);
  v179 = powf(this[12].f32[2], *(float *)v192.i32);
  v8 = 1.0;
  v9 = this[3].f32[1];
  v10 = this[6].f32[1];
  v170 = (float)(v4 * this[3].f32[0]) + (float)(this[6].f32[0] * (float)(1.0 - v4));
  this[3].f32[0] = v170;
  this[3].f32[1] = (float)(v5 * v9) + (float)(v10 * (float)(1.0 - v5));
  v174 = (float)(v5 * v9) + (float)(v10 * (float)(1.0 - v5));
  v168 = (float)(v6 * this[3].f32[2]) + (float)(this[6].f32[2] * (float)(1.0 - v6));
  this[3].f32[2] = v168;
  v11 = this[7];
  v12 = this[4];
  v13 = vmulq_f32(v11, v12);
  v14 = (float32x4_t)vextq_s8((int8x16_t)v13, (int8x16_t)v13, 8uLL);
  *(float32x2_t *)v13.f32 = vadd_f32(*(float32x2_t *)v13.f32, *(float32x2_t *)v14.f32);
  v13.f32[0] = vaddv_f32(*(float32x2_t *)v13.f32);
  v14.i32[0] = 0;
  v15 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8((int8x16_t)vcgeq_f32(v13, v14)), 0), (int8x16_t)vnegq_f32(v12), (int8x16_t)v12);
  v16 = 1.0 - v7;
  v17 = vsubq_f32(v11, v15);
  v18 = (int8x16_t)vmulq_f32(v17, v17);
  v166 = v15;
  v167 = v11;
  v19 = vaddq_f32(v11, v15);
  v20 = (int8x16_t)vmulq_f32(v19, v19);
  v21 = atan2f(sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v18.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v18, v18, 8uLL)))), sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v20.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v20, v20, 8uLL)))));
  v22 = v21 + v21;
  v23 = (float)(v21 + v21) == 0.0;
  v24 = 1.0;
  if (!v23)
    v24 = sinf(v22) / v22;
  v25 = v24;
  v26 = vrecpe_f32((float32x2_t)LODWORD(v24));
  v27 = vmul_f32(v26, vrecps_f32((float32x2_t)LODWORD(v25), v26));
  LODWORD(v28) = vmul_f32(v27, vrecps_f32((float32x2_t)LODWORD(v25), v27)).u32[0];
  if ((float)(v16 * v22) != 0.0)
  {
    v163 = v28;
    v27.f32[0] = sinf(v16 * v22);
    v28 = v163;
    v8 = v27.f32[0] / (float)(v16 * v22);
  }
  v27.f32[0] = v16 * (float)(v28 * v8);
  v29 = (float32x4_t)vdupq_lane_s32((int32x2_t)v27, 0);
  v30 = v7 * v22;
  v31 = 1.0;
  if (v30 != 0.0)
  {
    v162 = v29;
    v164 = v28;
    v32 = sinf(v30);
    v29 = v162;
    v28 = v164;
    v31 = v32 / v30;
  }
  v33 = vmlaq_f32(vmulq_n_f32(v166, v7 * (float)(v28 * v31)), v167, v29);
  v34 = (int8x16_t)vmulq_f32(v33, v33);
  v35 = vadd_f32(*(float32x2_t *)v34.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v34, v34, 8uLL));
  if (vaddv_f32(v35) == 0.0)
  {
    v36 = (float32x4_t)xmmword_2260E5D70;
  }
  else
  {
    v37 = vadd_f32(v35, (float32x2_t)vdup_lane_s32((int32x2_t)v35, 1)).u32[0];
    v38 = vrsqrte_f32((float32x2_t)v37);
    v39 = vmul_f32(v38, vrsqrts_f32((float32x2_t)v37, vmul_f32(v38, v38)));
    v36 = vmulq_n_f32(v33, vmul_f32(v39, vrsqrts_f32((float32x2_t)v37, vmul_f32(v39, v39))).f32[0]);
  }
  v40 = (int8x16_t)vmulq_f32(v36, v36);
  *(float32x2_t *)v40.i8 = vadd_f32(*(float32x2_t *)v40.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v40, v40, 8uLL));
  v40.i32[0] = vadd_f32(*(float32x2_t *)v40.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v40.i8, 1)).u32[0];
  v41 = vrsqrte_f32((float32x2_t)v40.u32[0]);
  v42 = vmul_f32(v41, vrsqrts_f32((float32x2_t)v40.u32[0], vmul_f32(v41, v41)));
  v43 = vmulq_n_f32(v36, vmul_f32(v42, vrsqrts_f32((float32x2_t)v40.u32[0], vmul_f32(v42, v42))).f32[0]);
  this[4] = v43;
  v44 = 1.0;
  v45 = (float)(v185 * this[5].f32[0]) + (float)(this[8].f32[0] * (float)(1.0 - v185));
  v46 = (float)(v182 * this[5].f32[1]) + (float)(this[8].f32[1] * (float)(1.0 - v182));
  this[5].f32[0] = v45;
  this[5].f32[1] = v46;
  v165 = v46;
  v161 = v45;
  v47 = (float)(v179 * this[5].f32[2]) + (float)(this[8].f32[2] * (float)(1.0 - v179));
  this[5].f32[2] = v47;
  v48 = (float)(v187.f32[1] * v5) + (float)(v174 * (float)(1.0 - v5));
  v178 = (float)(v187.f32[0] * v4) + (float)(v170 * (float)(1.0 - v4));
  this->f32[0] = v178;
  this->f32[1] = v48;
  v49 = (float)(v187.f32[2] * v6) + (float)(v168 * (float)(1.0 - v6));
  this->f32[2] = v49;
  v50 = vmulq_f32(v177, v43);
  v51 = (float32x4_t)vextq_s8((int8x16_t)v50, (int8x16_t)v50, 8uLL);
  *(float32x2_t *)v50.f32 = vadd_f32(*(float32x2_t *)v50.f32, *(float32x2_t *)v51.f32);
  v50.f32[0] = vaddv_f32(*(float32x2_t *)v50.f32);
  v51.i32[0] = 0;
  v173 = vnegq_f32(v177);
  v52 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8((int8x16_t)vcgeq_f32(v50, v51)), 0), (int8x16_t)v173, (int8x16_t)v177);
  v53 = vsubq_f32(v43, v52);
  v54 = (int8x16_t)vmulq_f32(v53, v53);
  v189 = v43;
  v175 = v52;
  v55 = vaddq_f32(v43, v52);
  v56 = (int8x16_t)vmulq_f32(v55, v55);
  v57 = atan2f(sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v54.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v54, v54, 8uLL)))), sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v56.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v56, v56, 8uLL)))));
  v58 = v57 + v57;
  v23 = (float)(v57 + v57) == 0.0;
  v59 = 1.0;
  if (!v23)
    v59 = sinf(v58) / v58;
  v60 = v59;
  v61 = vrecpe_f32((float32x2_t)LODWORD(v59));
  v62 = vmul_f32(v61, vrecps_f32((float32x2_t)LODWORD(v60), v61));
  LODWORD(v63) = vmul_f32(v62, vrecps_f32((float32x2_t)LODWORD(v60), v62)).u32[0];
  if ((float)(v16 * v58) != 0.0)
  {
    v171 = v63;
    v62.f32[0] = sinf(v16 * v58);
    v63 = v171;
    v44 = v62.f32[0] / (float)(v16 * v58);
  }
  v62.f32[0] = v16 * (float)(v63 * v44);
  v64 = (float32x4_t)vdupq_lane_s32((int32x2_t)v62, 0);
  v65 = v7 * v58;
  v66 = 1.0;
  if (v65 != 0.0)
  {
    v169 = v64;
    v172 = v63;
    v67 = sinf(v65);
    v64 = v169;
    v63 = v172;
    v66 = v67 / v65;
  }
  v68 = vmlaq_f32(vmulq_n_f32(v175, v7 * (float)(v63 * v66)), v189, v64);
  v69 = (int8x16_t)vmulq_f32(v68, v68);
  v70 = vadd_f32(*(float32x2_t *)v69.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v69, v69, 8uLL));
  if (vaddv_f32(v70) == 0.0)
  {
    v71 = (float32x4_t)xmmword_2260E5D70;
  }
  else
  {
    v72 = vadd_f32(v70, (float32x2_t)vdup_lane_s32((int32x2_t)v70, 1)).u32[0];
    v73 = vrsqrte_f32((float32x2_t)v72);
    v74 = vmul_f32(v73, vrsqrts_f32((float32x2_t)v72, vmul_f32(v73, v73)));
    v71 = vmulq_n_f32(v68, vmul_f32(v74, vrsqrts_f32((float32x2_t)v72, vmul_f32(v74, v74))).f32[0]);
  }
  v75 = (int8x16_t)vmulq_f32(v71, v71);
  *(float32x2_t *)v75.i8 = vadd_f32(*(float32x2_t *)v75.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v75, v75, 8uLL));
  v75.i32[0] = vadd_f32(*(float32x2_t *)v75.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v75.i8, 1)).u32[0];
  v76 = vrsqrte_f32((float32x2_t)v75.u32[0]);
  v77 = vmul_f32(v76, vrsqrts_f32((float32x2_t)v75.u32[0], vmul_f32(v76, v76)));
  v190 = vmulq_n_f32(v71, vmul_f32(v77, vrsqrts_f32((float32x2_t)v75.u32[0], vmul_f32(v77, v77))).f32[0]);
  this[1] = v190;
  v78 = (float)(v188.f32[1] * v182) + (float)(v165 * (float)(1.0 - v182));
  this[2].f32[0] = (float)(v188.f32[0] * v185) + (float)(v161 * (float)(1.0 - v185));
  this[2].f32[1] = v78;
  v79 = (float)(v179 * v188.f32[2]) + (float)(v47 * (float)(1.0 - v179));
  this[2].f32[2] = v79;
  re::DynamicOffsetF::calculateConstrainedPose(this, this, &v194);
  v186 = this[2];
  v80 = v186;
  v80.i32[3] = 0;
  v81 = this[18];
  v83 = this[19];
  v81.i32[3] = 0;
  v82 = vmaxnmq_f32(v80, v81);
  v82.i32[3] = 0;
  v83.i32[3] = 0;
  v84 = v194.f32[0];
  if (v178 != v194.f32[0]
    && vabds_f32(v178, v194.f32[0]) >= (float)((float)((float)(fabsf(v178) + fabsf(v194.f32[0])) + 1.0) * 0.00001))
  {
    v85 = v194.f32[1];
LABEL_28:
    v86 = this[22].f32[1];
    v176 = v49;
    v87 = (float)(v188.f32[1] * v182) + (float)(v165 * (float)(1.0 - v182));
    v88 = v79;
    v89 = this[22].f32[2];
    v180 = v82;
    v183 = v83;
    v90 = powf(1.0 - this[22].f32[0], *(float *)v192.i32);
    this[6].f32[0] = (float)(v84 * v90) + (float)(v178 * (float)(1.0 - v90));
    v91 = powf(1.0 - v86, *(float *)v192.i32);
    this[6].f32[1] = (float)(v85 * v91) + (float)(v48 * (float)(1.0 - v91));
    v92 = v194.f32[2];
    v93 = 1.0 - v89;
    v79 = v88;
    v78 = v87;
    v94 = powf(v93, *(float *)v192.i32);
    v82 = v180;
    v83 = v183;
    this[6].f32[2] = (float)(v94 * v92) + (float)(v176 * (float)(1.0 - v94));
    goto LABEL_29;
  }
  v85 = v194.f32[1];
  if (v48 != v194.f32[1]
    && vabds_f32(v48, v194.f32[1]) >= (float)((float)((float)(fabsf(v48) + fabsf(v194.f32[1])) + 1.0) * 0.00001)
    || v49 != v194.f32[2]
    && vabds_f32(v49, v194.f32[2]) >= (float)((float)((float)(fabsf(v49) + fabsf(v194.f32[2])) + 1.0) * 0.00001))
  {
    goto LABEL_28;
  }
LABEL_29:
  v95 = vminnmq_f32(v82, v83);
  v184 = v95;
  if (v190.f32[0] != v195.f32[0]
    && vabds_f32(v190.f32[0], v195.f32[0]) >= (float)((float)((float)(fabsf(v190.f32[0]) + fabsf(v195.f32[0])) + 1.0)
                                                    * 0.00001)
    || v190.f32[1] != v195.f32[1]
    && vabds_f32(v190.f32[1], v195.f32[1]) >= (float)((float)((float)(fabsf(v190.f32[1]) + fabsf(v195.f32[1])) + 1.0)
                                                    * 0.00001)
    || v190.f32[2] != v195.f32[2]
    && vabds_f32(v190.f32[2], v195.f32[2]) >= (float)((float)((float)(fabsf(v190.f32[2]) + fabsf(v195.f32[2])) + 1.0)
                                                    * 0.00001)
    || v190.f32[3] != v195.f32[3]
    && vabds_f32(v190.f32[3], v195.f32[3]) >= (float)((float)((float)(fabsf(v190.f32[3]) + fabsf(v195.f32[3])) + 1.0)
                                                    * 0.00001))
  {
    v96 = powf(1.0 - this[23].f32[2], *(float *)v192.i32);
    v97 = v195.f32[3];
    v98 = fabsf(v195.f32[3]);
    if (v98 <= 1.0 || fabsf(v98 + -1.0) < (float)((float)((float)(v98 + 1.0) + 1.0) * 0.00001))
    {
      if (v195.f32[3] > 1.0)
        v97 = 1.0;
      if (v97 < -1.0)
        v97 = -1.0;
      v100 = acosf(v97);
      v99 = v100 + v100;
    }
    else
    {
      v99 = NAN;
    }
    v101 = vmulq_f32(v195, v195);
    LODWORD(v102) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v101, 2), vaddq_f32(v101, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v101.f32, 1))).u32[0];
    v103 = 0uLL;
    if (fabsf(v102) >= 1.0e-10)
    {
      v104 = v102;
      v105 = vrsqrte_f32((float32x2_t)LODWORD(v102));
      v106 = vmul_f32(v105, vrsqrts_f32((float32x2_t)LODWORD(v104), vmul_f32(v105, v105)));
      v103 = vmulq_n_f32(v195, vmul_f32(v106, vrsqrts_f32((float32x2_t)LODWORD(v104), vmul_f32(v106, v106))).f32[0]);
    }
    v107 = this[16];
    v108 = vmulq_f32(v103, v107);
    if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v108, 2), vaddq_f32(v108, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v108.f32, 1))).f32[0] >= 0.0)v109 = v99;
    else
      v109 = -v99;
    v110 = fabsf(v190.f32[3]);
    v111 = 1.0;
    v181 = this[16];
    if (v110 <= 1.0 || fabsf(v110 + -1.0) < (float)((float)((float)(v110 + 1.0) + 1.0) * 0.00001))
    {
      if (v190.f32[3] <= 1.0)
        v111 = v190.f32[3];
      if (v111 < -1.0)
        v111 = -1.0;
      v113 = acosf(v111);
      v107 = v181;
      v112 = v113 + v113;
    }
    else
    {
      v112 = NAN;
    }
    v114 = vmulq_f32(v190, v190);
    LODWORD(v115) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v114, 2), vaddq_f32(v114, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v114.f32, 1))).u32[0];
    v116 = 0uLL;
    if (fabsf(v115) >= 1.0e-10)
    {
      v117 = v115;
      v118 = vrsqrte_f32((float32x2_t)LODWORD(v115));
      v119 = vmul_f32(v118, vrsqrts_f32((float32x2_t)LODWORD(v117), vmul_f32(v118, v118)));
      v116 = vmulq_n_f32(v190, vmul_f32(v119, vrsqrts_f32((float32x2_t)LODWORD(v117), vmul_f32(v119, v119))).f32[0]);
    }
    v120 = vmulq_f32(v107, v116);
    if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v120, 2), vaddq_f32(v120, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v120.f32, 1))).f32[0] < 0.0)v112 = -v112;
    v121 = (float)(v96 * v109) + (float)(v112 * (float)(1.0 - v96));
    v122 = vmulq_f32(v107, v107);
    LODWORD(v123) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v122, 2), vaddq_f32(v122, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v122.f32, 1))).u32[0];
    if (fabsf(v123) >= 1.0e-10)
    {
      v124 = v123;
      v125 = vrsqrte_f32((float32x2_t)LODWORD(v123));
      v126 = vmul_f32(v125, vrsqrts_f32((float32x2_t)LODWORD(v124), vmul_f32(v125, v125)));
      v181 = vmulq_n_f32(v107, vmul_f32(v126, vrsqrts_f32((float32x2_t)LODWORD(v124), vmul_f32(v126, v126))).f32[0]);
    }
    v127 = __sincosf_stret(v121 * 0.5);
    v95 = v184;
    *(float32x2_t *)v128.f32 = vmul_n_f32(*(float32x2_t *)v181.f32, v127.__sinval);
    v128.i64[1] = __PAIR64__(LODWORD(v127.__cosval), COERCE_UNSIGNED_INT(vmuls_lane_f32(v127.__sinval, v181, 2)));
    this[7] = v128;
  }
  v129 = v95.f32[1];
  v130 = v95.f32[2];
  v131 = v186;
  if ((vmovn_s32(vceqq_f32(v186, v95)).u8[0] & 1) == 0
    && fabsf(vsubq_f32(v186, v95).f32[0]) >= (float)((float)((float)(fabsf(v186.f32[0]) + fabsf(v95.f32[0])) + 1.0)
                                                   * 0.00001)
    || v186.f32[1] != v95.f32[1]
    && vabds_f32(v186.f32[1], v95.f32[1]) >= (float)((float)((float)(fabsf(v186.f32[1]) + fabsf(v95.f32[1])) + 1.0)
                                                   * 0.00001)
    || v186.f32[2] != v95.f32[2]
    && vabds_f32(v186.f32[2], v95.f32[2]) >= (float)((float)((float)(fabsf(v186.f32[2]) + fabsf(v95.f32[2])) + 1.0)
                                                   * 0.00001))
  {
    v132 = this[26].f32[1];
    v133 = this[26].f32[2];
    v134 = powf(1.0 - this[26].f32[0], *(float *)v192.i32);
    this[8].f32[0] = (float)(v184.f32[0] * v134) + (float)(v186.f32[0] * (float)(1.0 - v134));
    v135 = powf(1.0 - v132, *(float *)v192.i32);
    this[8].f32[1] = (float)(v129 * v135) + (float)(v78 * (float)(1.0 - v135));
    v136 = powf(1.0 - v133, *(float *)v192.i32);
    v131 = v186;
    this[8].f32[2] = (float)(v130 * v136) + (float)(v79 * (float)(1.0 - v136));
  }
  if (*(float *)v192.i32 > 0.0)
  {
    v137 = (float32x4_t)vdupq_lane_s32(v192, 0);
    v138 = (int8x16_t)vmulq_f32(v177, v177);
    v139 = vaddv_f32(vadd_f32(*(float32x2_t *)v138.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v138, v138, 8uLL)));
    v140 = 1.0;
    v141 = 1.0 / v139;
    v142 = vmuls_lane_f32(v141, v177, 3);
    v143 = vmulq_n_f32(v173, v141);
    v144 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v190, (int32x4_t)v190), (int8x16_t)v190, 0xCuLL), vnegq_f32(v143)), v190, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v143, (int32x4_t)v143), (int8x16_t)v143, 0xCuLL));
    v145 = vmlaq_laneq_f32(vmlaq_n_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v144, (int32x4_t)v144), v144, 0xCuLL), v190, v142), v143, v190, 3);
    v143.f32[3] = v142;
    v146 = vmulq_f32(v143, v190);
    v145.f32[3] = -(float)(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v146, 2), vaddq_f32(v146, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v146.f32, 1))).f32[0]- (float)(v142 * v190.f32[3]));
    v147 = (int8x16_t)vmulq_f32(v145, v145);
    *(float32x2_t *)v147.i8 = vadd_f32(*(float32x2_t *)v147.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v147, v147, 8uLL));
    v147.i32[0] = vadd_f32(*(float32x2_t *)v147.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v147.i8, 1)).u32[0];
    this[27] = vdivq_f32(vsubq_f32(*this, v187), v137);
    v148 = vrsqrte_f32((float32x2_t)v147.u32[0]);
    v149 = vmul_f32(v148, vrsqrts_f32((float32x2_t)v147.u32[0], vmul_f32(v148, v148)));
    v150 = vmulq_n_f32(v145, vmul_f32(v149, vrsqrts_f32((float32x2_t)v147.u32[0], vmul_f32(v149, v149))).f32[0]);
    v151 = fabsf(v150.f32[3]);
    if (v151 <= 1.0 || fabsf(v151 + -1.0) < (float)((float)((float)(v151 + 1.0) + 1.0) * 0.00001))
    {
      if (v150.f32[3] <= 1.0)
        v140 = v150.f32[3];
      if (v140 < -1.0)
        v140 = -1.0;
      v191 = v150;
      v193 = v137;
      v153 = acosf(v140);
      v150 = v191;
      v137 = v193;
      v131 = v186;
      v152 = v153 + v153;
      v154 = 0uLL;
      if (v152 == 0.0)
        goto LABEL_84;
    }
    else
    {
      v152 = NAN;
    }
    v155 = vmulq_f32(v150, v150);
    LODWORD(v156) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v155, 2), vaddq_f32(v155, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v155.f32, 1))).u32[0];
    v157 = 0uLL;
    if (fabsf(v156) >= 1.0e-10)
    {
      v158 = v156;
      v159 = vrsqrte_f32((float32x2_t)LODWORD(v156));
      v160 = vmul_f32(v159, vrsqrts_f32((float32x2_t)LODWORD(v158), vmul_f32(v159, v159)));
      v157 = vmulq_n_f32(v150, vmul_f32(v160, vrsqrts_f32((float32x2_t)LODWORD(v158), vmul_f32(v160, v160))).f32[0]);
    }
    v154 = vdivq_f32(vmulq_n_f32(v157, v152), v137);
LABEL_84:
    this[28] = v154;
    this[29] = vdivq_f32(vsubq_f32(v131, v188), v137);
  }
}

void re::DynamicOffsetF::updateInteraction(uint64_t a1, uint64_t a2, float32x4_t *a3, double a4)
{
  float32x4_t *v5;
  __int128 v6;
  float32x4_t v7;
  float32x4_t v8;
  float32x4_t v9;
  float32x4_t v10;
  float32x4_t v11;
  float32x4_t v12;
  uint64_t i;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float32x4_t v22;
  float v23;
  float32x4_t v24;
  float v25;
  float32x2_t v26;
  float32x2_t v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float32x4_t v32;
  float32x4_t v33;
  float v34;
  float v35;
  float32x4_t v36;
  float v37;
  float v38;
  float32x2_t v39;
  float32x2_t v40;
  __float2 v41;
  __int128 v42;
  uint64_t j;
  float v44;
  float v45;
  float v46;
  __int128 v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v56;
  int8x16_t v57;
  float v58;
  float v59;
  float v60;
  int8x16_t v64;
  float32x4_t v65;
  int8x16_t v66;
  float32x2_t v67;
  float32x2_t v68;
  float32x4_t v69;
  float v70;
  float v71;
  float v72;
  float32x4_t v73;
  float v74;
  float32x4_t v75;
  float v76;
  float32x2_t v77;
  float32x2_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  __int128 v99;

  v87 = *(float32x4_t *)a1;
  v89 = *(float32x4_t *)(a1 + 16);
  v5 = (float32x4_t *)(a1 + 32);
  v91 = *(float32x4_t *)(a1 + 32);
  v6 = *(_OWORD *)(a2 + 16);
  v98 = *(float32x4_t *)a2;
  v99 = v6;
  v97 = *a3;
  re::DynamicOffsetF::calculateConstrainedPose((float32x4_t *)a1, &v98, &v95);
  v7 = v97;
  v8 = v97;
  v8.i32[3] = 0;
  v9 = *(float32x4_t *)(a1 + 288);
  v10 = *(float32x4_t *)(a1 + 304);
  v9.i32[3] = 0;
  v11 = vmaxnmq_f32(v8, v9);
  v11.i32[3] = 0;
  v10.i32[3] = 0;
  v12 = vminnmq_f32(v11, v10);
  v94 = v12;
  if (v95.f32[0] != v98.f32[0]
    && vabds_f32(v95.f32[0], v98.f32[0]) >= (float)((float)((float)(fabsf(v95.f32[0]) + fabsf(v98.f32[0])) + 1.0)
                                                  * 0.00001)
    || v95.f32[1] != v98.f32[1]
    && vabds_f32(v95.f32[1], v98.f32[1]) >= (float)((float)((float)(fabsf(v95.f32[1]) + fabsf(v98.f32[1])) + 1.0)
                                                  * 0.00001)
    || v95.f32[2] != v98.f32[2]
    && vabds_f32(v95.f32[2], v98.f32[2]) >= (float)((float)((float)(fabsf(v95.f32[2]) + fabsf(v98.f32[2])) + 1.0)
                                                  * 0.00001))
  {
    for (i = 0; i != 3; ++i)
    {
      v14 = *(float *)(a1 + i * 4 + 320);
      if (v14 > 0.0)
      {
        v15 = v95.f32[i];
        v16 = v98.f32[i];
        if (v15 > v16)
          v14 = -v14;
        v98.f32[i] = v16
                   + (float)((float)((float)((float)(-1.0 / (float)((float)((float)(v15 - v16) / v14) + -1.0)) + -1.0)
                                   / *(float *)(a1 + i * 4 + 336))
                           / v14);
      }
    }
  }
  if (v96.f32[0] != *(float *)&v99
    && vabds_f32(v96.f32[0], *(float *)&v99) >= (float)((float)((float)(fabsf(v96.f32[0]) + fabsf(*(float *)&v99)) + 1.0)
                                                      * 0.00001)
    || v96.f32[1] != *((float *)&v99 + 1)
    && vabds_f32(v96.f32[1], *((float *)&v99 + 1)) >= (float)((float)((float)(fabsf(v96.f32[1])
                                                                            + fabsf(*((float *)&v99 + 1)))
                                                                    + 1.0)
                                                            * 0.00001)
    || v96.f32[2] != *((float *)&v99 + 2)
    && vabds_f32(v96.f32[2], *((float *)&v99 + 2)) >= (float)((float)((float)(fabsf(v96.f32[2])
                                                                            + fabsf(*((float *)&v99 + 2)))
                                                                    + 1.0)
                                                            * 0.00001)
    || v96.f32[3] != *((float *)&v99 + 3)
    && vabds_f32(v96.f32[3], *((float *)&v99 + 3)) >= (float)((float)((float)(fabsf(v96.f32[3])
                                                                            + fabsf(*((float *)&v99 + 3)))
                                                                    + 1.0)
                                                            * 0.00001))
  {
    v17 = *(float *)(a1 + 368);
    if (v17 > 0.0)
    {
      v84 = v12;
      v85 = v7;
      v18 = v96.f32[3];
      v19 = fabsf(v96.f32[3]);
      if (v19 <= 1.0 || fabsf(v19 + -1.0) < (float)((float)((float)(v19 + 1.0) + 1.0) * 0.00001))
      {
        if (v96.f32[3] > 1.0)
          v18 = 1.0;
        if (v18 < -1.0)
          v18 = -1.0;
        v21 = acosf(v18);
        v20 = v21 + v21;
      }
      else
      {
        v20 = NAN;
      }
      v22 = vmulq_f32(v96, v96);
      LODWORD(v23) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v22, 2), vaddq_f32(v22, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v22.f32, 1))).u32[0];
      v24 = 0uLL;
      if (fabsf(v23) >= 1.0e-10)
      {
        v25 = v23;
        v26 = vrsqrte_f32((float32x2_t)LODWORD(v23));
        v27 = vmul_f32(v26, vrsqrts_f32((float32x2_t)LODWORD(v25), vmul_f32(v26, v26)));
        v24 = vmulq_n_f32(v96, vmul_f32(v27, vrsqrts_f32((float32x2_t)LODWORD(v25), vmul_f32(v27, v27))).f32[0]);
      }
      v28 = *((float *)&v99 + 3);
      v29 = fabsf(*((float *)&v99 + 3));
      if (v29 <= 1.0 || fabsf(v29 + -1.0) < (float)((float)((float)(v29 + 1.0) + 1.0) * 0.00001))
      {
        if (*((float *)&v99 + 3) > 1.0)
          v28 = 1.0;
        if (v28 < -1.0)
          v28 = -1.0;
        v82 = v24;
        v31 = acosf(v28);
        v24 = v82;
        v30 = v31 + v31;
      }
      else
      {
        v30 = NAN;
      }
      v32 = *(float32x4_t *)(a1 + 256);
      v33 = vmulq_f32(v24, v32);
      if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v33, 2), vaddq_f32(v33, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v33.f32, 1))).f32[0] < 0.0)v30 = -v30;
      v34 = -v17;
      if (v20 <= v30)
        v34 = v17;
      v35 = v30
          + (float)((float)((float)((float)(-1.0 / (float)((float)((float)(v20 - v30) / v34) + -1.0)) + -1.0)
                          / *(float *)(a1 + 372))
                  / v34);
      v36 = vmulq_f32(v32, v32);
      LODWORD(v37) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v36, 2), vaddq_f32(v36, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v36.f32, 1))).u32[0];
      if (fabsf(v37) >= 1.0e-10)
      {
        v38 = v37;
        v39 = vrsqrte_f32((float32x2_t)LODWORD(v37));
        v40 = vmul_f32(v39, vrsqrts_f32((float32x2_t)LODWORD(v38), vmul_f32(v39, v39)));
        v32 = vmulq_n_f32(v32, vmul_f32(v40, vrsqrts_f32((float32x2_t)LODWORD(v38), vmul_f32(v40, v40))).f32[0]);
      }
      v83 = v32;
      v41 = __sincosf_stret(v35 * 0.5);
      v12 = v84;
      *(float32x2_t *)&v42 = vmul_n_f32(*(float32x2_t *)v83.f32, v41.__sinval);
      *((_QWORD *)&v42 + 1) = __PAIR64__(LODWORD(v41.__cosval), COERCE_UNSIGNED_INT(vmuls_lane_f32(v41.__sinval, v83, 2)));
      v99 = v42;
      v7 = v85;
    }
  }
  if ((vmovn_s32(vceqq_f32(v12, v7)).u8[0] & 1) == 0
    && fabsf(vsubq_f32(v12, v7).f32[0]) >= (float)((float)((float)(fabsf(v7.f32[0]) + fabsf(v12.f32[0])) + 1.0) * 0.00001)
    || v12.f32[1] != v7.f32[1]
    && vabds_f32(v12.f32[1], v7.f32[1]) >= (float)((float)((float)(fabsf(v7.f32[1]) + fabsf(v12.f32[1])) + 1.0) * 0.00001)
    || v12.f32[2] != v7.f32[2]
    && vabds_f32(v12.f32[2], v7.f32[2]) >= (float)((float)((float)(fabsf(v7.f32[2]) + fabsf(v12.f32[2])) + 1.0) * 0.00001))
  {
    for (j = 0; j != 3; ++j)
    {
      v44 = *(float *)(a1 + j * 4 + 384);
      if (v44 > 0.0)
      {
        v45 = v94.f32[j];
        v46 = v97.f32[j];
        if (v45 > v46)
          v44 = -v44;
        v97.f32[j] = v46
                   + (float)((float)((float)((float)(-1.0 / (float)((float)((float)(v45 - v46) / v44) + -1.0)) + -1.0)
                                   / *(float *)(a1 + j * 4 + 400))
                           / v44);
      }
    }
  }
  v47 = v99;
  *(float32x4_t *)a1 = v98;
  *(_OWORD *)(a1 + 16) = v47;
  *v5 = v97;
  if (*(float *)&a4 > 0.0)
  {
    v48 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a4, 0);
    v49 = vdivq_f32(vsubq_f32(*(float32x4_t *)a1, v87), v48);
    __asm
    {
      FMOV            V7.4S, #0.25
      FMOV            V2.4S, #0.75
    }
    if (!(_NF ^ _VF | _ZF))
    {
      v56 = vmlaq_f32(vmulq_f32(*(float32x4_t *)(a1 + 432), _Q7), _Q2, v49);
      *(_OWORD *)(a1 + 480) = *(_OWORD *)(a1 + 432);
      *(float32x4_t *)(a1 + 432) = v56;
    }
    v93 = _Q2;
    v57 = (int8x16_t)vmulq_f32(v89, v89);
    v58 = vaddv_f32(vadd_f32(*(float32x2_t *)v57.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v57, v57, 8uLL)));
    v59 = 1.0;
    v60 = 1.0 / v58;
    _S2 = vmuls_lane_f32(v60, v89, 3);
    _Q1 = vmulq_n_f32(vnegq_f32(v89), v60);
    _Q3 = *(float32x4_t *)(a1 + 16);
    v64 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q3, (int32x4_t)_Q3), (int8x16_t)_Q3, 0xCuLL), vnegq_f32(_Q1)), _Q3, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q1, (int32x4_t)_Q1), (int8x16_t)_Q1, 0xCuLL));
    v65 = vmlaq_laneq_f32(vmlaq_n_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v64, (int32x4_t)v64), v64, 0xCuLL), _Q3, _S2), _Q1, _Q3, 3);
    __asm { FMLA            S1, S2, V3.S[3] }
    v65.i32[3] = _Q1.i32[0];
    v66 = (int8x16_t)vmulq_f32(v65, v65);
    *(float32x2_t *)v66.i8 = vadd_f32(*(float32x2_t *)v66.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v66, v66, 8uLL));
    v66.i32[0] = vadd_f32(*(float32x2_t *)v66.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v66.i8, 1)).u32[0];
    v67 = vrsqrte_f32((float32x2_t)v66.u32[0]);
    v68 = vmul_f32(v67, vrsqrts_f32((float32x2_t)v66.u32[0], vmul_f32(v67, v67)));
    v69 = vmulq_n_f32(v65, vmul_f32(v68, vrsqrts_f32((float32x2_t)v66.u32[0], vmul_f32(v68, v68))).f32[0]);
    v70 = fabsf(v69.f32[3]);
    if (v70 <= 1.0 || fabsf(v70 + -1.0) < (float)((float)((float)(v70 + 1.0) + 1.0) * 0.00001))
    {
      if (v69.f32[3] <= 1.0)
        v59 = v69.f32[3];
      if (v59 < -1.0)
        v59 = -1.0;
      v88 = v48;
      v90 = _Q7;
      v86 = v69;
      v72 = acosf(v59);
      v69 = v86;
      v48 = v88;
      _Q7 = v90;
      v71 = v72 + v72;
    }
    else
    {
      v71 = NAN;
    }
    if (v71 > 0.008)
    {
      v73 = vmulq_f32(v69, v69);
      LODWORD(v74) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v73, 2), vaddq_f32(v73, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v73.f32, 1))).u32[0];
      v75 = 0uLL;
      if (fabsf(v74) >= 1.0e-10)
      {
        v76 = v74;
        v77 = vrsqrte_f32((float32x2_t)LODWORD(v74));
        v78 = vmul_f32(v77, vrsqrts_f32((float32x2_t)LODWORD(v76), vmul_f32(v77, v77)));
        v75 = vmulq_n_f32(v69, vmul_f32(v78, vrsqrts_f32((float32x2_t)LODWORD(v76), vmul_f32(v78, v78))).f32[0]);
      }
      *(_OWORD *)(a1 + 496) = *(_OWORD *)(a1 + 448);
      *(float32x4_t *)(a1 + 448) = vdivq_f32(vmulq_n_f32(v75, v71), v48);
    }
    v79 = vdivq_f32(vsubq_f32(*v5, v91), v48);
    v80 = vmulq_f32(v79, v79);
    if (sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v80, 2), vaddq_f32(v80, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v80.f32, 1))).f32[0]) > 0.008)
    {
      v81 = vmlaq_f32(vmulq_f32(*(float32x4_t *)(a1 + 464), _Q7), v93, v79);
      *(_OWORD *)(a1 + 512) = *(_OWORD *)(a1 + 464);
      *(float32x4_t *)(a1 + 464) = v81;
    }
  }
}

__n128 re::DynamicOffsetF::endInteraction(float32x4_t *this, float a2)
{
  float32x4_t *v9;
  float32x4_t v10;
  float32x4_t v11;
  int32x2_t v12;
  float32x4_t v13;
  float v14;
  float32x4_t v15;
  float v16;
  float v17;
  float32x2_t v18;
  float32x2_t v19;
  __float2 v21;
  int8x16_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  __n128 result;
  float32x4_t v29;
  float v30;

  __asm
  {
    FMOV            V1.4S, #0.25
    FMOV            V4.4S, #0.75
  }
  if (!_ZF)
    this[27] = vmlaq_f32(vmulq_f32(this[30], _Q1), _Q4, this[27]);
  if (this[31].f32[0] != 3.4028e38)
    this[28] = vmlaq_f32(vmulq_f32(this[31], _Q1), _Q4, this[28]);
  if (this[32].f32[0] != 3.4028e38)
    this[29] = vmlaq_f32(vmulq_f32(this[32], _Q1), _Q4, this[29]);
  this[3] = vaddq_f32(*this, vmulq_n_f32(this[27], a2));
  v9 = this + 3;
  v10 = this[28];
  v11 = vmulq_f32(v10, v10);
  v12 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2), vaddq_f32(v11, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 1))).u64[0];
  *(float *)v12.i32 = sqrtf(*(float *)v12.i32);
  if (*(float *)v12.i32 == 0.0)
  {
    this[4] = this[1];
  }
  else
  {
    v13 = vdivq_f32(v10, (float32x4_t)vdupq_lane_s32(v12, 0));
    v30 = a2;
    v14 = *(float *)v12.i32 * a2;
    v15 = vmulq_f32(v13, v13);
    LODWORD(v16) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 2), vaddq_f32(v15, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v15.f32, 1))).u32[0];
    if (fabsf(v16) >= 1.0e-10)
    {
      v17 = v16;
      v18 = vrsqrte_f32((float32x2_t)LODWORD(v16));
      v19 = vmul_f32(v18, vrsqrts_f32((float32x2_t)LODWORD(v17), vmul_f32(v18, v18)));
      v13 = vmulq_n_f32(v13, vmul_f32(v19, vrsqrts_f32((float32x2_t)LODWORD(v17), vmul_f32(v19, v19))).f32[0]);
    }
    v29 = v13;
    v21 = __sincosf_stret(v14 * 0.5);
    _S1 = v21.__cosval;
    *(float32x2_t *)_Q2.f32 = vmul_n_f32(*(float32x2_t *)v29.f32, v21.__sinval);
    _Q2.i32[2] = vmuls_lane_f32(v21.__sinval, v29, 2);
    _Q0 = this[1];
    v24 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q0, (int32x4_t)_Q0), (int8x16_t)_Q0, 0xCuLL), vnegq_f32(_Q2)), _Q0, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q2, (int32x4_t)_Q2), (int8x16_t)_Q2, 0xCuLL));
    v25 = vmlaq_laneq_f32(vmlaq_n_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v24, (int32x4_t)v24), v24, 0xCuLL), _Q0, v21.__cosval), _Q2, _Q0, 3);
    __asm { FMLA            S2, S1, V0.S[3] }
    v25.i32[3] = _Q2.i32[0];
    this[4] = v25;
    a2 = v30;
  }
  v26 = *v9;
  v27 = this[4];
  this[5] = vaddq_f32(this[2], vmulq_n_f32(this[29], a2));
  this[6] = v26;
  result = (__n128)this[5];
  this[7] = v27;
  this[8] = (float32x4_t)result;
  this[33].i8[0] = 0;
  return result;
}

float re::computeSVD3x3(float32x2_t *a1, _OWORD *a2, _OWORD *a3, _OWORD *a4, double *a5, double *a6, double *a7)
{
  double v10;
  double v11;
  float result;
  __int128 v13;
  unsigned int v14;
  __int128 v15;
  unsigned int v16;
  __int128 v17;
  unsigned int v18;
  __int128 v19;
  float64x2_t v20;
  double v21;
  float64x2_t v22;
  double v23;
  float64x2_t v24;
  double v25;
  float64x2_t v26;
  double v27;
  __CLPK_doublereal __u[2];
  double v29;
  float64x2_t v30;
  double v31;
  float64x2_t v32;
  double v33;
  __CLPK_doublereal __a[2];
  double v35;
  float64x2_t v36;
  double v37;
  float64x2_t v38;
  double v39;
  uint64_t v40;

  v40 = *MEMORY[0x24BDAC8D0];
  *(float64x2_t *)__a = vcvtq_f64_f32(*a1);
  v10 = a1[1].f32[0];
  v36 = vcvtq_f64_f32(a1[2]);
  v11 = a1[3].f32[0];
  v35 = v10;
  v37 = v11;
  v38 = vcvtq_f64_f32(a1[4]);
  v39 = a1[5].f32[0];
  {
    *(float32x2_t *)&v13 = vcvt_f32_f64(*(float64x2_t *)__u);
    *(float *)&v14 = v29;
    *((_QWORD *)&v13 + 1) = __PAIR64__(HIDWORD(__u[1]), v14);
    *(float32x2_t *)&v15 = vcvt_f32_f64(v30);
    *(float *)&v16 = v31;
    *((_QWORD *)&v15 + 1) = __PAIR64__(HIDWORD(v30.f64[1]), v16);
    *(float32x2_t *)&v17 = vcvt_f32_f64(v32);
    *(float *)&v18 = v33;
    *((_QWORD *)&v17 + 1) = __PAIR64__(HIDWORD(v32.f64[1]), v18);
    *a2 = v13;
    a2[1] = v15;
    a2[2] = v17;
    *(float32x2_t *)&v15 = vcvt_f32_f64(v22);
    *(float *)&v13 = v23;
    *((_QWORD *)&v15 + 1) = __PAIR64__(HIDWORD(v22.f64[1]), v13);
    *(float32x2_t *)&v19 = vcvt_f32_f64(v24);
    *(float *)&v13 = v25;
    *((_QWORD *)&v19 + 1) = __PAIR64__(HIDWORD(v24.f64[1]), v13);
    *a4 = v15;
    a4[1] = v19;
    *(float32x2_t *)&v15 = vcvt_f32_f64(v26);
    *(float *)&v13 = v27;
    *((_QWORD *)&v15 + 1) = __PAIR64__(HIDWORD(v26.f64[1]), v13);
    a4[2] = v15;
    *(float32x2_t *)&v15 = vcvt_f32_f64(v20);
    result = v21;
    *((_QWORD *)&v15 + 1) = __PAIR64__(HIDWORD(v20.f64[1]), LODWORD(result));
    *a3 = v15;
  }
  return result;
}

BOOL re::`anonymous namespace'::computeSVD(__CLPK_doublereal *__a, __CLPK_doublereal *__u, __CLPK_doublereal *__s, double *a4, double *a5, double *a6, double *a7)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t __lwork;
  double v15;
  __CLPK_integer v16;
  __CLPK_integer __ldvt;
  __CLPK_integer __ldu;
  __CLPK_integer __lda;
  __CLPK_integer __n;
  __CLPK_integer __m;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  __n = 3;
  __m = 3;
  __ldu = 3;
  __lda = 3;
  v16 = 0;
  __ldvt = 3;
  v15 = 0.0;
  HIDWORD(__lwork) = -1;
  v11 = dgesvd_("All", "All", &__m, &__n, __a, &__lda, __s, __u, &__ldu, a4, &__ldvt, &v15, (__CLPK_integer *)&__lwork + 1, &v16);
  HIDWORD(__lwork) = (int)v15;
  MEMORY[0x24BDAC7A8](v11);
  dgesvd_("All", "All", &__m, &__n, __a, &__lda, __s, __u, &__ldu, a4, &__ldvt, (__CLPK_doublereal *)((char *)&__lwork - v12), (__CLPK_integer *)&__lwork + 1, &v16);
  return v16 == 0;
}

void re::OPackReader::Buffer::~Buffer(re::OPackReader::Buffer *this)
{
  uint64_t v2;
  uint64_t *v3;

  v2 = *(_QWORD *)this;
  if (*(re::OPackReader::Buffer **)this != (re::OPackReader::Buffer *)((char *)this + 32))
  {
    if (v2)
    {
      v3 = re::globalAllocators(this);
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v3[2] + 40))(v3[2], v2);
    }
    *(_QWORD *)this = 0;
  }
}

uint64_t re::OPackReader::Buffer::resize(re::OPackReader::Buffer *this, unint64_t a2)
{
  uint64_t result;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  re::OPackReader::Buffer *v8;
  uint64_t v9;
  uint64_t *v10;

  if (*((_QWORD *)this + 2) - *(_QWORD *)this > a2)
    return 1;
  if (*((_QWORD *)this + 3) < a2)
    return 0;
  v5 = re::globalAllocators(this);
  result = (*(uint64_t (**)(uint64_t, unint64_t, _QWORD))(*(_QWORD *)v5[2] + 32))(v5[2], a2, 0);
  if (result)
  {
    v6 = result;
    v8 = *(re::OPackReader::Buffer **)this;
    v7 = *((_QWORD *)this + 1);
    v9 = v7 - *(_QWORD *)this;
    if (v7 != *(_QWORD *)this)
      result = (uint64_t)memcpy((void *)result, *(const void **)this, v7 - *(_QWORD *)this);
    if (v8 != (re::OPackReader::Buffer *)((char *)this + 32))
    {
      if (v8)
      {
        v10 = re::globalAllocators((re *)result);
        (*(void (**)(uint64_t, re::OPackReader::Buffer *))(*(_QWORD *)v10[2] + 40))(v10[2], v8);
      }
    }
    *(_QWORD *)this = v6;
    *((_QWORD *)this + 1) = v6 + v9;
    *((_QWORD *)this + 2) = v6 + a2;
    return 1;
  }
  return result;
}

uint64_t re::OPackReader::OPackReader(uint64_t a1, uint64_t a2)
{
  _anonymous_namespace_ *v3;
  __n128 v5;
  uint64_t v6;

  *(_WORD *)a1 = 0;
  *(_BYTE *)(a1 + 2) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 128;
  *(_DWORD *)(a1 + 24) = 0;
  *(_BYTE *)(a1 + 28) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_BYTE *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = &off_24ED7DD60;
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 160) = a1 + 96;
  *(_QWORD *)(a1 + 168) = a1 + 96;
  *(_QWORD *)(a1 + 176) = a1 + 160;
  *(_BYTE *)(a1 + 184) = 0;
  *(_QWORD *)(a1 + 188) = 0;
  *(_QWORD *)(a1 + 200) = 0;
  *(_QWORD *)(a1 + 208) = 0;
  *(_BYTE *)(a1 + 224) = 0;
  *(_QWORD *)(a1 + 216) = 0;
  *(_QWORD *)(a1 + 240) = a1 + 272;
  *(_QWORD *)(a1 + 248) = a1 + 272;
  v3 = (_anonymous_namespace_ *)(a1 + 336);
  *(_QWORD *)(a1 + 256) = a1 + 336;
  *(_QWORD *)(a1 + 264) = -1;
  *(_QWORD *)(a1 + 368) = 0;
  *(_QWORD *)(a1 + 344) = 0;
  *(_QWORD *)(a1 + 352) = 0;
  *(_DWORD *)(a1 + 360) = 0;
  *(_QWORD *)(a1 + 336) = 0;
  *(_BYTE *)(a1 + 196) = 0;
  re::DynamicArray<re::internal::AnimationCompositionChainEntry>::setCapacity((_QWORD *)(a1 + 336), 0x80uLL);
  v5.n128_u16[0] = 0;
  v5.n128_u64[1] = 0;
  v6 = 0;
  re::DynamicArray<re::ecs2::ComponentHandleAssetData>::add(v3, &v5);
  return a1;
}

void re::OPackReader::~OPackReader(re::OPackReader *this)
{
  uint64_t v2;

  v2 = *((_QWORD *)this + 42);
  if (v2)
  {
    if (*((_QWORD *)this + 46))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *((_QWORD *)this + 46) = 0;
    *((_QWORD *)this + 43) = 0;
    *((_QWORD *)this + 44) = 0;
    *((_QWORD *)this + 42) = 0;
    ++*((_DWORD *)this + 90);
  }
  re::OPackReader::Buffer::~Buffer((re::OPackReader *)((char *)this + 240));
  re::zerocopy::BufferedReadStream::~BufferedReadStream((re::OPackReader *)((char *)this + 56));
}

uint64_t re::OPackReader::next(re::OPackReader *this, uint64_t a2)
{
  uint64_t result;
  int Object;

  if (*((_BYTE *)this + 2))
  {
    *((_BYTE *)this + 2) = 0;
    return 1;
  }
  else if (*((_BYTE *)this + 1) || *(_BYTE *)this)
  {
    return 0;
  }
  else
  {
    switch(*(_BYTE *)(*((_QWORD *)this + 46) + 24 * *((_QWORD *)this + 44) - 24))
    {
      case 0:
        Object = re::OPackReader::readObject(this, 0);
        result = 0;
        if (Object)
        {
          result = 1;
          if (*((_QWORD *)this + 44) == 1)
            *(_BYTE *)this = 1;
        }
        break;
      case 1:
        result = re::OPackReader::readArray(this);
        break;
      case 2:
        result = re::OPackReader::readDictionary(this);
        break;
      case 3:
        result = re::OPackReader::readChunkedData(this);
        break;
      case 5:
        result = re::OPackReader::readExtArrayDelta(this);
        break;
      case 6:
        result = 0;
        *((_BYTE *)this + 1) = 1;
        *((_QWORD *)this + 1) = "unimplemented";
        break;
      case 7:
        result = re::OPackReader::readExtDictionaryDelta(this);
        break;
      default:
        re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) ", "!\"Unreachable code\"", "next", 158);
        _os_crash();
        __break(1u);
        JUMPOUT(0x225B880CCLL);
    }
  }
  return result;
}

uint64_t re::OPackReader::readObject(re::OPackReader *this, int a2)
{
  _DWORD *v4;
  _DWORD *v5;
  char v6;
  char v7;
  uint64_t result;
  char v9;
  unint64_t v10;
  const char *v11;
  char v12;
  size_t v13;
  const void *v14;
  size_t v15;
  const void *v16;
  size_t v17;
  uint64_t v18;

  v4 = (_DWORD *)((char *)this + 24);
  v5 = (_DWORD *)((char *)this + 192);
  result = re::zerocopy::OPackTokenizer::readToken((_DWORD *)this + 6, (uint64_t)this + 192);
  if (!(_DWORD)result)
    return result;
  if (!v7 & v6)
  {
    result = 0;
    *((_BYTE *)this + 1) = 1;
    v11 = "unhandled container type";
    goto LABEL_39;
  }
  switch(*((_BYTE *)this + 196))
  {
    case 0xC:
      result = re::OPackReader::beginState((uint64_t)this, 1u, *((_QWORD *)this + 25));
      if ((_DWORD)result)
      {
        v9 = 2;
        goto LABEL_20;
      }
      return result;
    case 0xD:
      result = re::OPackReader::beginState((uint64_t)this, 2u, *((_QWORD *)this + 25));
      if ((_DWORD)result)
      {
        v9 = 4;
        goto LABEL_20;
      }
      return result;
    case 0xE:
      result = re::OPackReader::beginState((uint64_t)this, 3u, *((_QWORD *)this + 25));
      if ((_DWORD)result)
      {
        v9 = 6;
        goto LABEL_20;
      }
      return result;
    case 0xF:
      result = re::OPackReader::beginState((uint64_t)this, 5u, *((_QWORD *)this + 25));
      if ((_DWORD)result)
      {
        v9 = 8;
        goto LABEL_20;
      }
      return result;
    case 0x10:
      result = re::OPackReader::beginState((uint64_t)this, 7u, *((_QWORD *)this + 25));
      if ((_DWORD)result)
      {
        v9 = 10;
LABEL_20:
        *((_BYTE *)this + 184) = v9;
        goto LABEL_21;
      }
      return result;
    case 0x11:
      result = re::OPackReader::beginState((uint64_t)this, 6u, *((_QWORD *)this + 25));
      if ((_DWORD)result)
      {
        *((_BYTE *)this + 184) = 6;
LABEL_21:
        *((_DWORD *)this + 47) = a2;
        return 1;
      }
      return result;
    default:
      if ((*((_BYTE *)this + 196) & 0xFE) != 0xA)
        goto LABEL_9;
      v10 = *((_QWORD *)this + 25);
      if (v10 == *((_QWORD *)this + 27))
        goto LABEL_9;
      if (*((_QWORD *)this + 33) < v10)
        goto LABEL_11;
      *((_QWORD *)this + 31) = *((_QWORD *)this + 30);
      if (v10 == -1 || (re::OPackReader::Buffer::resize((re::OPackReader *)((char *)this + 240), v10) & 1) != 0)
      {
        v12 = 1;
        while (*v5 == 2)
        {
          if ((v12 & 1) != 0
            && (v14 = (const void *)*((_QWORD *)this + 26),
                v13 = *((_QWORD *)this + 27),
                re::OPackReader::Buffer::resize((re::OPackReader *)((char *)this + 240), v13 + *((_QWORD *)this + 31) - *((_QWORD *)this + 30))))
          {
            memcpy(*((void **)this + 31), v14, v13);
            *((_QWORD *)this + 31) += v13;
            v12 = 1;
          }
          else
          {
            v12 = 0;
          }
          if ((re::zerocopy::OPackTokenizer::readToken(v4, (uint64_t)v5) & 1) == 0)
          {
            result = 0;
            *((_BYTE *)this + 1) = 1;
            v11 = "unable to read next chunk";
            goto LABEL_39;
          }
        }
        if (*v5 == 3)
        {
          if ((v12 & 1) != 0)
          {
            v16 = (const void *)*((_QWORD *)this + 26);
            v15 = *((_QWORD *)this + 27);
            if (re::OPackReader::Buffer::resize((re::OPackReader *)((char *)this + 240), v15 + *((_QWORD *)this + 31) - *((_QWORD *)this + 30)))
            {
              memcpy(*((void **)this + 31), v16, v15);
              v17 = *((_QWORD *)this + 31) + v15;
              *((_QWORD *)this + 31) = v17;
              goto LABEL_43;
            }
          }
        }
        else if ((v12 & 1) != 0)
        {
          v17 = *((_QWORD *)this + 31);
LABEL_43:
          v18 = *((_QWORD *)this + 30);
          *((_QWORD *)this + 26) = v18;
          *((_QWORD *)this + 27) = v17 - v18;
LABEL_9:
          result = 1;
          *((_BYTE *)this + 184) = 1;
          *((_DWORD *)this + 47) = a2;
          return result;
        }
LABEL_11:
        result = 0;
        *((_BYTE *)this + 1) = 1;
        v11 = "multipart buffer exceeded maximum data length";
        goto LABEL_39;
      }
      result = 0;
      *((_BYTE *)this + 1) = 1;
      v11 = "out of memory when allocating multipart buffer";
LABEL_39:
      *((_QWORD *)this + 1) = v11;
      return result;
  }
}

uint64_t re::OPackReader::readArray(re::OPackReader *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t result;
  uint64_t v9;

  v2 = *((_QWORD *)this + 46);
  v3 = *((_QWORD *)this + 44) - 1;
  if (*(_BYTE *)(v2 + 24 * v3 + 1))
  {
    v4 = v2 + 24 * v3;
    v7 = *(_QWORD *)(v4 + 8);
    v5 = (_QWORD *)(v4 + 8);
    v6 = v7;
    if (v7)
    {
      *v5 = v6 - 1;
      return re::OPackReader::readObject(this, 1);
    }
    *((_DWORD *)this + 48) = 1;
    *((_BYTE *)this + 196) = 1;
    *((_QWORD *)this + 44) = v3;
    ++*((_DWORD *)this + 90);
    if (v3 == 1)
      *(_BYTE *)this = 1;
    goto LABEL_10;
  }
  result = re::OPackReader::readObject(this, 1);
  if (!(_DWORD)result)
    return result;
  if (*((_BYTE *)this + 196) == 1)
  {
    v9 = *((_QWORD *)this + 44) - 1;
    *((_QWORD *)this + 44) = v9;
    ++*((_DWORD *)this + 90);
    if (v9 == 1)
      *(_BYTE *)this = 1;
LABEL_10:
    *((_BYTE *)this + 184) = 3;
    *((_DWORD *)this + 47) = 0;
  }
  return 1;
}

uint64_t re::OPackReader::readDictionary(re::OPackReader *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t result;

  v2 = *((_QWORD *)this + 46);
  v3 = *((_QWORD *)this + 44) - 1;
  v4 = v2 + 24 * v3;
  v7 = *(_QWORD *)(v4 + 16);
  v5 = (_QWORD *)(v4 + 16);
  v6 = v7;
  if (!*((_BYTE *)v5 - 15))
  {
    if (!v6)
    {
      *v5 = 1;
      return re::OPackReader::readDictionaryEntry((uint64_t)this, 2, 0, 5, 0);
    }
    goto LABEL_6;
  }
  if (v6)
  {
LABEL_6:
    *v5 = 0;
    v12 = 4;
LABEL_7:
    result = re::OPackReader::readObject(this, v12);
    if ((_DWORD)result)
    {
      result = 1;
      if (*((_BYTE *)this + 196) == 1)
      {
        *((_BYTE *)this + 1) = 1;
        *((_QWORD *)this + 1) = "unexpected terminator when reading dictionary entry";
        return 0;
      }
    }
    return result;
  }
  v8 = v2 + 24 * v3;
  v11 = *(_QWORD *)(v8 + 8);
  v9 = (_QWORD *)(v8 + 8);
  v10 = v11;
  if (v11)
  {
    *v9 = v10 - 1;
    *v5 = 1;
    v12 = 2;
    goto LABEL_7;
  }
  *((_DWORD *)this + 48) = 1;
  *((_BYTE *)this + 196) = 1;
  *((_QWORD *)this + 44) = v3;
  ++*((_DWORD *)this + 90);
  if (v3 == 1)
    *(_BYTE *)this = 1;
  *((_BYTE *)this + 184) = 5;
  *((_DWORD *)this + 47) = 0;
  return 1;
}

uint64_t re::OPackReader::readChunkedData(re::OPackReader *this)
{
  uint64_t result;
  int v3;
  uint64_t v4;

  result = re::OPackReader::readObject(this, 8);
  if ((_DWORD)result)
  {
    v3 = *((unsigned __int8 *)this + 196);
    if (v3 == 11)
    {
      result = 1;
      *((_BYTE *)this + 184) = 1;
      *((_DWORD *)this + 47) = 8;
    }
    else if (v3 == 1)
    {
      v4 = *((_QWORD *)this + 44) - 1;
      *((_QWORD *)this + 44) = v4;
      ++*((_DWORD *)this + 90);
      if (v4 == 1)
        *(_BYTE *)this = 1;
      *((_BYTE *)this + 184) = 6;
      *((_DWORD *)this + 47) = 0;
      return 1;
    }
    else
    {
      result = 0;
      *((_BYTE *)this + 1) = 1;
      *((_QWORD *)this + 1) = "unexpected token reading chunked data";
    }
  }
  return result;
}

uint64_t re::OPackReader::readExtArrayDelta(re::OPackReader *this)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t result;
  uint64_t v7;

  v2 = *((_QWORD *)this + 46) + 24 * *((_QWORD *)this + 44);
  v5 = *(_QWORD *)(v2 - 8);
  v4 = (_QWORD *)(v2 - 8);
  v3 = v5;
  if (v5 == 1)
  {
    result = re::OPackReader::readObject(this, 32);
    if ((_DWORD)result)
    {
      if (*((_BYTE *)this + 196) == 1)
      {
        v7 = *((_QWORD *)this + 44) - 1;
        *((_QWORD *)this + 44) = v7;
        ++*((_DWORD *)this + 90);
        if (v7 == 1)
          *(_BYTE *)this = 1;
        *((_BYTE *)this + 184) = 9;
        *((_DWORD *)this + 47) = 0;
      }
      else
      {
        *v4 = 0;
      }
      return 1;
    }
  }
  else
  {
    if (v3)
      return 0;
    result = re::OPackReader::readObject(this, 16);
    if (!(_DWORD)result)
      return result;
    if (*((_BYTE *)this + 196) != 6)
    {
      return 0;
    }
    else
    {
      result = 1;
      *v4 = 1;
    }
  }
  return result;
}

uint64_t re::OPackReader::readExtDictionaryDelta(re::OPackReader *this)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t result;

  v2 = *((_QWORD *)this + 46) + 24 * *((_QWORD *)this + 44);
  v4 = *(_QWORD *)(v2 - 8);
  v3 = (_QWORD *)(v2 - 8);
  if (v4)
  {
    *v3 = 0;
    result = re::OPackReader::readObject(this, 132);
    if ((_DWORD)result)
    {
      result = 1;
      if (*((_BYTE *)this + 196) == 1)
      {
        *((_BYTE *)this + 184) = 1;
        *((_DWORD *)this + 47) = 132;
      }
    }
  }
  else
  {
    *v3 = 1;
    return re::OPackReader::readDictionaryEntry((uint64_t)this, 66, 0, 11, 0);
  }
  return result;
}

BOOL re::OPackReader::beginState(uint64_t a1, unsigned __int8 a2, unint64_t a3)
{
  unint64_t v3;
  unint64_t v4;
  __n128 v6;
  uint64_t v7;

  v3 = *(_QWORD *)(a1 + 352);
  v4 = *(int *)(a1 + 16);
  if (v3 >= v4)
  {
    *(_BYTE *)(a1 + 1) = 1;
    *(_QWORD *)(a1 + 8) = "max depth exceeded";
  }
  else
  {
    v6.n128_u8[0] = a2;
    v6.n128_u8[1] = a3 != -1;
    v6.n128_u64[1] = a3;
    v7 = 0;
    re::DynamicArray<re::ecs2::ComponentHandleAssetData>::add((_anonymous_namespace_ *)(a1 + 336), &v6);
  }
  return v3 < v4;
}

uint64_t re::OPackReader::readDictionaryEntry(uint64_t a1, int a2, uint64_t a3, char a4, int a5)
{
  uint64_t result;
  uint64_t v10;

  result = re::OPackReader::readObject((re::OPackReader *)a1, a2);
  if ((_DWORD)result)
  {
    if (*(_BYTE *)(a1 + 196) == 1)
    {
      if (a5)
      {
        if (a5 == 2)
        {
          result = 1;
          *(_BYTE *)(a1 + 184) = 1;
          *(_DWORD *)(a1 + 188) = a2;
          return result;
        }
        if (a5 == 1)
        {
          result = 0;
          *(_BYTE *)(a1 + 1) = 1;
          *(_QWORD *)(a1 + 8) = "unexpected terminator when reading dictionary entry";
          return result;
        }
      }
      else
      {
        v10 = *(_QWORD *)(a1 + 352) - 1;
        *(_QWORD *)(a1 + 352) = v10;
        ++*(_DWORD *)(a1 + 360);
        if (v10 == 1)
          *(_BYTE *)a1 = 1;
        *(_BYTE *)(a1 + 184) = a4;
        *(_DWORD *)(a1 + 188) = 0;
      }
    }
    return 1;
  }
  return result;
}

uint64_t re::zerocopy::OPackTokenizer::readToken(_DWORD *a1, uint64_t a2)
{
  uint64_t result;

  switch(*a1)
  {
    case 0:
      result = re::zerocopy::OPackTokenizer::readTag((uint64_t)a1, a2);
      break;
    case 1:
      result = re::zerocopy::OPackTokenizer::readPrimitive((uint64_t)a1, a2);
      break;
    case 2:
      result = re::zerocopy::OPackTokenizer::readLengthPrefixed((uint64_t)a1, a2);
      break;
    case 3:
      result = re::zerocopy::OPackTokenizer::readChunks((uint64_t)a1, a2);
      break;
    case 4:
      result = re::zerocopy::OPackTokenizer::readNullTerminated((uint64_t)a1, a2);
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

uint64_t re::zerocopy::OPackTokenizer::readTag(uint64_t a1, uint64_t a2)
{
  int v4;
  uint64_t result;
  char v6;
  unint64_t v7;
  char v8;
  char v9;
  char v10;
  char v11;
  char v12;
  BOOL v13;
  uint64_t v14;
  char v15;
  uint64_t v16;
  char v17;
  char v18;
  char v19;
  uint64_t v20;
  uint64_t v21;
  unsigned __int8 __dst;
  const void *v23[2];

  __dst = 0;
  if ((re::zerocopy::BufferedReadStream::contiguousRead((re::zerocopy::BufferedReadStream *)(a1 + 32), (char *)1, v23) & 1) == 0)
  {
    result = 0;
    *(_DWORD *)a2 = 0;
    goto LABEL_5;
  }
  memcpy(&__dst, v23[0], (size_t)v23[1]);
  v4 = __dst;
  switch(__dst)
  {
    case 0u:
      result = 1;
      *(_DWORD *)a2 = 1;
      *(_BYTE *)(a2 + 4) = 0;
      goto LABEL_14;
    case 1u:
      result = 1;
      *(_BYTE *)(a2 + 32) = 1;
      goto LABEL_10;
    case 2u:
      *(_BYTE *)(a2 + 32) = 0;
      result = 1;
LABEL_10:
      *(_DWORD *)a2 = 1;
      v6 = 2;
      goto LABEL_13;
    case 3u:
      result = 1;
      *(_DWORD *)a2 = 1;
      *(_BYTE *)(a2 + 4) = 1;
      goto LABEL_14;
    case 4u:
      result = 1;
      *(_DWORD *)a2 = 1;
      v6 = 3;
      goto LABEL_13;
    case 5u:
      *(_DWORD *)a1 = 1;
      *(_BYTE *)(a1 + 4) = 4;
      v7 = 16;
      goto LABEL_19;
    case 6u:
      *(_DWORD *)a1 = 1;
      v8 = 5;
LABEL_18:
      *(_BYTE *)(a1 + 4) = v8;
      v7 = 8;
LABEL_19:
      *(int64x2_t *)(a1 + 8) = vdupq_n_s64(v7);
      return re::zerocopy::OPackTokenizer::readPrimitive(a1, a2);
    default:
      if (__dst - 7 > 0x28)
      {
        switch(__dst)
        {
          case '0':
            v7 = 1;
            *(_DWORD *)a1 = 1;
            v9 = 6;
LABEL_22:
            *(_BYTE *)(a1 + 4) = v9;
            goto LABEL_19;
          case '1':
            *(_DWORD *)a1 = 1;
            v10 = 6;
LABEL_24:
            *(_BYTE *)(a1 + 4) = v10;
            v7 = 2;
            goto LABEL_19;
          case '2':
            *(_DWORD *)a1 = 1;
            v11 = 6;
            goto LABEL_32;
          case '3':
            *(_DWORD *)a1 = 1;
            v8 = 6;
            goto LABEL_18;
          case '5':
            *(_DWORD *)a1 = 1;
            v11 = 7;
LABEL_32:
            *(_BYTE *)(a1 + 4) = v11;
            v7 = 4;
            goto LABEL_19;
          case '6':
            *(_DWORD *)a1 = 1;
            v7 = 8;
            *(_BYTE *)(a1 + 4) = 8;
            goto LABEL_19;
          default:
            if (__dst - 64 <= 0x20)
            {
              *(_DWORD *)a1 = 3;
              v12 = 10;
              *(_BYTE *)(a1 + 4) = 10;
              v14 = (v4 - 64);
              v13 = (_DWORD)v14 == 0;
LABEL_29:
              *(_QWORD *)(a1 + 8) = v14;
              *(_QWORD *)(a1 + 16) = v14;
              if (!v13)
                return re::zerocopy::OPackTokenizer::readChunks(a1, a2);
              *(_QWORD *)(a2 + 8) = 0;
              *(_QWORD *)(a2 + 16) = 0;
              *(_QWORD *)(a2 + 24) = 0;
              *(_DWORD *)a2 = 3;
              *(_BYTE *)(a2 + 4) = v12;
              result = 1;
              goto LABEL_14;
            }
            switch(__dst)
            {
              case 'a':
                *(_DWORD *)a1 = 2;
                v15 = 10;
LABEL_36:
                *(_BYTE *)(a1 + 4) = v15;
                v16 = 1;
                goto LABEL_46;
              case 'b':
                v16 = 2;
                *(_DWORD *)a1 = 2;
                v17 = 10;
LABEL_41:
                *(_BYTE *)(a1 + 4) = v17;
                goto LABEL_46;
              case 'c':
                *(_DWORD *)a1 = 2;
                v18 = 10;
LABEL_43:
                *(_BYTE *)(a1 + 4) = v18;
                v16 = 4;
                goto LABEL_46;
              case 'd':
                *(_DWORD *)a1 = 2;
                v19 = 10;
LABEL_45:
                *(_BYTE *)(a1 + 4) = v19;
                v16 = 8;
LABEL_46:
                *(_QWORD *)(a1 + 8) = v16;
                return re::zerocopy::OPackTokenizer::readLengthPrefixed(a1, a2);
              default:
                if (__dst == 111)
                {
                  *(_DWORD *)a1 = 4;
                  *(_BYTE *)(a1 + 4) = 10;
                  *(_QWORD *)(a1 + 8) = 0;
                  *(_QWORD *)(a1 + 16) = 0;
                  return re::zerocopy::OPackTokenizer::readNullTerminated(a1, a2);
                }
                if (__dst - 112 <= 0x20)
                {
                  *(_DWORD *)a1 = 3;
                  v12 = 11;
                  *(_BYTE *)(a1 + 4) = 11;
                  v14 = (v4 - 112);
                  v13 = (_DWORD)v14 == 0;
                  goto LABEL_29;
                }
                switch(__dst)
                {
                  case 0x91u:
                    *(_DWORD *)a1 = 2;
                    v15 = 11;
                    goto LABEL_36;
                  case 0x92u:
                    v16 = 2;
                    *(_DWORD *)a1 = 2;
                    v17 = 11;
                    goto LABEL_41;
                  case 0x93u:
                    *(_DWORD *)a1 = 2;
                    v18 = 11;
                    goto LABEL_43;
                  case 0x94u:
                    *(_DWORD *)a1 = 2;
                    v19 = 11;
                    goto LABEL_45;
                  default:
                    if (__dst == 159)
                    {
                      *(_QWORD *)(a2 + 8) = -1;
                      result = 1;
                      *(_DWORD *)a2 = 1;
                      v6 = 14;
                      goto LABEL_13;
                    }
                    if ((__dst + 96) <= 0x20u)
                    {
                      *(_DWORD *)(a2 + 32) = __dst - 160;
                      result = 1;
                      *(_DWORD *)a2 = 1;
                      v6 = 9;
                      goto LABEL_13;
                    }
                    break;
                }
                break;
            }
            break;
        }
        switch(__dst)
        {
          case 0xC1u:
            v7 = 1;
            *(_DWORD *)a1 = 1;
            v9 = 9;
            goto LABEL_22;
          case 0xC2u:
            *(_DWORD *)a1 = 1;
            v10 = 9;
            goto LABEL_24;
          case 0xC3u:
            *(_DWORD *)a1 = 1;
            *(_BYTE *)(a1 + 4) = 9;
            v7 = 3;
            goto LABEL_19;
          case 0xC4u:
            *(_DWORD *)a1 = 1;
            v11 = 9;
            goto LABEL_32;
          default:
            if ((__dst + 48) <= 0xEu)
            {
              v20 = __dst - 208;
LABEL_67:
              *(_QWORD *)(a2 + 8) = v20;
              result = 1;
              *(_DWORD *)a2 = 1;
              v6 = 12;
              goto LABEL_13;
            }
            if (__dst == 223)
            {
              v20 = -1;
              goto LABEL_67;
            }
            if ((__dst + 32) <= 0xEu)
            {
              v21 = __dst - 224;
LABEL_72:
              *(_QWORD *)(a2 + 8) = v21;
              result = 1;
              *(_DWORD *)a2 = 1;
              v6 = 13;
              goto LABEL_13;
            }
            if (__dst == 239)
            {
              v21 = -1;
              goto LABEL_72;
            }
            if (__dst == 240 && *(_BYTE *)(a1 + 24))
            {
              *(_QWORD *)(a2 + 8) = -1;
              result = 1;
              *(_DWORD *)a2 = 1;
              v6 = 15;
              goto LABEL_13;
            }
            if (__dst == 241 && *(_BYTE *)(a1 + 24))
            {
              *(_QWORD *)(a2 + 8) = -1;
              result = 1;
              *(_DWORD *)a2 = 1;
              v6 = 16;
              goto LABEL_13;
            }
            if (__dst == 242 && *(_BYTE *)(a1 + 24))
            {
              *(_QWORD *)(a2 + 8) = -1;
              result = 1;
              *(_DWORD *)a2 = 1;
              v6 = 17;
              goto LABEL_13;
            }
            if (*(_DWORD *)a1 != 5)
              *(_DWORD *)a1 = 5;
            result = 0;
            *(_DWORD *)a2 = 4;
            break;
        }
LABEL_5:
        *(_BYTE *)(a2 + 4) = 0;
        return result;
      }
      *(_QWORD *)(a2 + 32) = __dst - 8;
      result = 1;
      *(_DWORD *)a2 = 1;
      v6 = 6;
LABEL_13:
      *(_BYTE *)(a2 + 4) = v6;
LABEL_14:
      *(_DWORD *)a1 = 0;
      return result;
  }
}

uint64_t re::zerocopy::OPackTokenizer::readPrimitive(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t *v5[2];

  result = re::zerocopy::BufferedReadStream::contiguousRead((re::zerocopy::BufferedReadStream *)(a1 + 32), *(char **)(a1 + 8), v5);
  if ((_DWORD)result)
    return re::zerocopy::OPackTokenizer::endPrimitive(a1, a2, v5);
  *(_DWORD *)a2 = 0;
  *(_BYTE *)(a2 + 4) = 0;
  return result;
}

uint64_t re::zerocopy::OPackTokenizer::readLengthPrefixed(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  unsigned __int8 *v5[2];

  result = re::zerocopy::BufferedReadStream::contiguousRead((re::zerocopy::BufferedReadStream *)(a1 + 32), *(char **)(a1 + 8), v5);
  if ((_DWORD)result)
    return re::zerocopy::OPackTokenizer::endLengthPrefixed(a1, a2, *(_BYTE *)(a1 + 4), v5);
  *(_DWORD *)a2 = 0;
  *(_BYTE *)(a2 + 4) = 0;
  return result;
}

uint64_t re::zerocopy::OPackTokenizer::readChunks(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v12;
  unint64_t v13;

  v4 = a1 + 32;
  v5 = *(_QWORD *)(a1 + 16);
  v6 = (*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)(a1 + 32) + 16))(a1 + 32, &v12);
  if ((_DWORD)v6)
  {
    if (v13 >= v5)
      v7 = v5;
    else
      v7 = v13;
    v13 = v7;
    (*(void (**)(uint64_t))(*(_QWORD *)(a1 + 32) + 24))(v4);
    v9 = v12;
    v8 = v13;
    v10 = *(_QWORD *)(a1 + 16) - v13;
    *(_QWORD *)(a1 + 16) = v10;
    *(_QWORD *)(a2 + 16) = v9;
    *(_QWORD *)(a2 + 24) = v8;
    *(_QWORD *)(a2 + 8) = *(_QWORD *)(a1 + 8);
    if (v10)
    {
      *(_DWORD *)a2 = 2;
      *(_BYTE *)(a2 + 4) = *(_BYTE *)(a1 + 4);
    }
    else
    {
      *(_DWORD *)a2 = 3;
      *(_BYTE *)(a2 + 4) = *(_BYTE *)(a1 + 4);
      *(_DWORD *)a1 = 0;
    }
  }
  else
  {
    *(_DWORD *)a2 = 0;
    *(_BYTE *)(a2 + 4) = 0;
  }
  return v6;
}

uint64_t re::zerocopy::OPackTokenizer::readNullTerminated(uint64_t a1, uint64_t a2)
{
  re::zerocopy::BufferedReadStream *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;

  v4 = (re::zerocopy::BufferedReadStream *)(a1 + 32);
  v5 = re::zerocopy::BufferedReadStream::nextRead(a1 + 32, &v10);
  if ((_DWORD)v5)
  {
    v7 = v10;
    v6 = v11;
    if (v11 < 1)
    {
LABEL_6:
      *(_QWORD *)(a2 + 16) = v10;
      *(_QWORD *)(a2 + 24) = v6;
      *(_QWORD *)(a2 + 8) = *(_QWORD *)(a1 + 8);
      *(_DWORD *)a2 = 2;
      *(_BYTE *)(a2 + 4) = *(_BYTE *)(a1 + 4);
    }
    else
    {
      v8 = 0;
      while (*(_BYTE *)(v10 + v8))
      {
        ++v8;
        if (v10 + v8 >= (unint64_t)(v10 + v11))
          goto LABEL_6;
      }
      re::zerocopy::BufferedReadStream::advanceRead(v4, v8 + 1);
      *(_QWORD *)(a2 + 16) = v7;
      *(_QWORD *)(a2 + 24) = v8;
      *(_QWORD *)(a2 + 8) = *(_QWORD *)(a1 + 8);
      *(_DWORD *)a2 = 3;
      *(_BYTE *)(a2 + 4) = *(_BYTE *)(a1 + 4);
      *(_DWORD *)a1 = 0;
    }
  }
  else
  {
    *(_DWORD *)a2 = 0;
    *(_BYTE *)(a2 + 4) = 0;
  }
  return v5;
}

uint64_t re::zerocopy::OPackTokenizer::endLengthPrefixed(uint64_t a1, uint64_t a2, char a3, unsigned __int8 **a4)
{
  uint64_t v4;
  uint64_t v6;

  switch((unint64_t)a4[1])
  {
    case 1uLL:
      v4 = **a4;
      goto LABEL_6;
    case 2uLL:
      v4 = *(unsigned __int16 *)*a4;
      goto LABEL_6;
    case 4uLL:
      v4 = *(unsigned int *)*a4;
      goto LABEL_6;
    case 8uLL:
      v4 = *(_QWORD *)*a4;
LABEL_6:
      *(_DWORD *)a1 = 3;
      *(_BYTE *)(a1 + 4) = a3;
      *(_QWORD *)(a1 + 8) = v4;
      *(_QWORD *)(a1 + 16) = v4;
      if (v4)
        return re::zerocopy::OPackTokenizer::readChunks(a1, a2);
      *(_QWORD *)(a2 + 8) = 0;
      *(_QWORD *)(a2 + 16) = 0;
      *(_QWORD *)(a2 + 24) = 0;
      *(_DWORD *)a2 = 3;
      *(_BYTE *)(a2 + 4) = a3;
      v6 = 1;
      *(_DWORD *)a1 = 0;
      return v6;
    default:
      if (*(_DWORD *)a1 != 5)
        *(_DWORD *)a1 = 5;
      v6 = 0;
      *(_DWORD *)a2 = 4;
      *(_BYTE *)(a2 + 4) = 0;
      return v6;
  }
}

uint64_t re::zerocopy::OPackTokenizer::endPrimitive(uint64_t a1, uint64_t a2, uint64_t **a3)
{
  uint64_t v3;
  char v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t *v7;
  unint64_t v8;

  switch(*(_BYTE *)(a1 + 4))
  {
    case 4:
      *(_OWORD *)(a2 + 32) = *(_OWORD *)*a3;
      v3 = 1;
      *(_DWORD *)a2 = 1;
      v4 = 4;
      goto LABEL_21;
    case 5:
      *(_QWORD *)(a2 + 32) = **a3;
      v3 = 1;
      *(_DWORD *)a2 = 1;
      v4 = 5;
      goto LABEL_21;
    case 6:
      v5 = *a3;
      switch((unint64_t)a3[1])
      {
        case 1uLL:
          v6 = *(char *)v5;
          break;
        case 2uLL:
          v6 = *(__int16 *)v5;
          break;
        case 4uLL:
          v6 = *(int *)v5;
          break;
        case 8uLL:
          v6 = *v5;
          break;
        default:
          goto LABEL_10;
      }
      *(_QWORD *)(a2 + 32) = v6;
      v3 = 1;
      *(_DWORD *)a2 = 1;
      v4 = 6;
      goto LABEL_21;
    case 7:
      *(_DWORD *)(a2 + 32) = *(_DWORD *)*a3;
      v3 = 1;
      *(_DWORD *)a2 = 1;
      v4 = 7;
      goto LABEL_21;
    case 8:
      *(_QWORD *)(a2 + 32) = **a3;
      v3 = 1;
      *(_DWORD *)a2 = 1;
      v4 = 8;
      goto LABEL_21;
    case 9:
      v7 = *a3;
      switch((unint64_t)a3[1])
      {
        case 1uLL:
          v8 = *(unsigned __int8 *)v7;
          break;
        case 2uLL:
          v8 = *(unsigned __int16 *)v7;
          break;
        case 3uLL:
          v8 = *(unsigned __int16 *)v7 | ((unint64_t)*((unsigned __int8 *)v7 + 2) << 16);
          break;
        case 4uLL:
          v8 = *(unsigned int *)v7;
          break;
        default:
          goto LABEL_10;
      }
      *(_QWORD *)(a2 + 32) = v8;
      v3 = 1;
      *(_DWORD *)a2 = 1;
      v4 = 9;
LABEL_21:
      *(_BYTE *)(a2 + 4) = v4;
      *(_DWORD *)a1 = 0;
      break;
    default:
LABEL_10:
      if (*(_DWORD *)a1 != 5)
        *(_DWORD *)a1 = 5;
      v3 = 0;
      *(_DWORD *)a2 = 4;
      *(_BYTE *)(a2 + 4) = 0;
      break;
  }
  return v3;
}

void re::zerocopy::DispatchReadStream::~DispatchReadStream(NSObject *this)
{
  NSObject *v1;
  re::zerocopy::DispatchReadStream *isa;
  Class v3;
  uint64_t v4;
  unint64_t i;
  Class v6;
  uint64_t *v7;
  uint64_t j;
  NSObject *v9;

  v1 = this;
  this->isa = (Class)&off_24ED7DC58;
  isa = this[25].isa;
  if (isa != (re::zerocopy::DispatchReadStream *)&this[1])
  {
    v3 = this[26].isa;
    if (v3)
    {
      v4 = 0;
      for (i = 0; i < (unint64_t)v3; ++i)
      {
        v6 = v1[25].isa;
        this = *(NSObject **)((char *)v6 + v4);
        if (this)
        {
          dispatch_release(this);
          *(_QWORD *)((char *)v6 + v4) = 0;
          v3 = v1[26].isa;
        }
        v4 += 24;
      }
      isa = v1[25].isa;
    }
    if (isa)
    {
      v7 = re::globalAllocators((re *)this);
      (*(void (**)(uint64_t, re::zerocopy::DispatchReadStream *))(*(_QWORD *)v7[2] + 40))(v7[2], isa);
    }
    v1[25].isa = 0;
  }
  for (j = 22; j != -2; j -= 3)
  {
    v9 = v1[j].isa;
    if (v9)
    {
      dispatch_release(v9);
      v1[j].isa = 0;
    }
  }
}

{
  re::zerocopy::DispatchReadStream::~DispatchReadStream(this);
  JUMPOUT(0x2276933B8);
}

uint64_t re::zerocopy::DispatchReadStream::nextRead(_QWORD *a1, _QWORD *a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;

  v2 = a1[28];
  v3 = a1[26];
  if (v2 < v3)
  {
    v4 = a1[29];
    v5 = a1[25];
    v6 = *(_QWORD *)(v5 + 24 * v2 + 16);
    if (v4 < v6)
    {
LABEL_5:
      *a2 = *(_QWORD *)(v5 + 24 * v2 + 8) + v4;
      a2[1] = v6 - v4;
      return 1;
    }
    a1[28] = ++v2;
    a1[29] = 0;
    if (v2 < v3)
    {
      v4 = 0;
      v6 = *(_QWORD *)(v5 + 24 * v2 + 16);
      goto LABEL_5;
    }
  }
  return 0;
}

_QWORD *re::zerocopy::DispatchReadStream::advanceRead(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  uint64_t v3;
  unint64_t v4;

  v2 = this[28];
  if (v2 < this[26])
  {
    v3 = this[29];
    v4 = *(_QWORD *)(this[25] + 24 * v2 + 16) - v3;
    if (v4 >= a2)
      v4 = a2;
    this[29] = v4 + v3;
  }
  return this;
}

uint64_t re::zerocopy::DispatchReadStream::DispatchReadStream(void *)::$_0::__invoke(re *a1, dispatch_object_t object, uint64_t a3, objc_class *a4, objc_class *a5)
{
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  NSObject *v13;
  NSObject *v14;
  uint64_t v15;
  unint64_t i;
  NSObject *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  unint64_t j;
  uint64_t v22;
  uint64_t *v23;
  NSObject *v24;

  v9 = *((_QWORD *)a1 + 26);
  if (v9 == *((_QWORD *)a1 + 27))
  {
    v10 = 2 * v9;
    v11 = 48 * v9;
    v12 = re::globalAllocators(a1);
    v13 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v12[2] + 32))(v12[2], v11, 0);
    v14 = v13;
    v9 = *((_QWORD *)a1 + 26);
    if (v9)
    {
      v15 = 0;
      for (i = 0; i < v9; ++i)
      {
        v17 = &v13[v15];
        v18 = *((_QWORD *)a1 + 25) + v15 * 8;
        *(_OWORD *)&v17->isa = *(_OWORD *)v18;
        v17[2].isa = *(Class *)(v18 + 16);
        *(_QWORD *)v18 = 0;
        *(_QWORD *)(v18 + 8) = 0;
        *(_QWORD *)(v18 + 16) = 0;
        v9 = *((_QWORD *)a1 + 26);
        v15 += 3;
      }
      v19 = (_QWORD *)*((_QWORD *)a1 + 25);
      if (v19 != (_QWORD *)((char *)a1 + 8))
      {
        if (v9)
        {
          v20 = 0;
          for (j = 0; j < v9; ++j)
          {
            v22 = *((_QWORD *)a1 + 25);
            v13 = *(NSObject **)(v22 + v20);
            if (v13)
            {
              dispatch_release(v13);
              *(_QWORD *)(v22 + v20) = 0;
              v9 = *((_QWORD *)a1 + 26);
            }
            v20 += 24;
          }
          v19 = (_QWORD *)*((_QWORD *)a1 + 25);
        }
        goto LABEL_14;
      }
    }
    else
    {
      v19 = (_QWORD *)*((_QWORD *)a1 + 25);
      if (v19 != (_QWORD *)((char *)a1 + 8))
      {
LABEL_14:
        if (v19)
        {
          v23 = re::globalAllocators((re *)v13);
          (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v23[2] + 40))(v23[2], v19);
          v9 = *((_QWORD *)a1 + 26);
        }
      }
    }
    *((_QWORD *)a1 + 25) = v14;
    *((_QWORD *)a1 + 27) = v10;
    goto LABEL_17;
  }
  v14 = *((_QWORD *)a1 + 25);
LABEL_17:
  *((_QWORD *)a1 + 26) = v9 + 1;
  v24 = &v14[3 * v9];
  dispatch_retain(object);
  v24->isa = (Class)object;
  v24[1].isa = a4;
  v24[2].isa = a5;
  return 1;
}

void re::zerocopy::FileWriteStream::~FileWriteStream(re::zerocopy::FileWriteStream *this)
{
  FILE *v2;

  *(_QWORD *)this = &off_24ED7DCB0;
  v2 = (FILE *)*((_QWORD *)this + 1);
  if (v2 && *((_BYTE *)this + 16))
    fclose(v2);
  *((_QWORD *)this + 1) = 0;
}

{
  FILE *v2;

  *(_QWORD *)this = &off_24ED7DCB0;
  v2 = (FILE *)*((_QWORD *)this + 1);
  if (v2 && *((_BYTE *)this + 16))
    fclose(v2);
  *((_QWORD *)this + 1) = 0;
  JUMPOUT(0x2276933B8);
}

uint64_t re::zerocopy::FileWriteStream::nextWrite(uint64_t a1, _QWORD *a2)
{
  *a2 = a1 + 17;
  a2[1] = 4096;
  return 1;
}

size_t re::zerocopy::FileWriteStream::advanceWrite(size_t this, unint64_t a2)
{
  FILE *v2;
  size_t v3;

  v2 = *(FILE **)(this + 8);
  if (v2)
  {
    if (a2 >= 0x1000)
      v3 = 4096;
    else
      v3 = a2;
    return fwrite((const void *)(this + 17), 1uLL, v3, v2);
  }
  return this;
}

BOOL re::zerocopy::FileWriteStream::flushWrite(FILE **this)
{
  return fflush(this[1]) == 0;
}

uint64_t re::OPackWriter::writeInteger(re::zerocopy **this, uint64_t a2)
{
  re::zerocopy *v3;
  re::zerocopy::WriteStream *v4;
  uint64_t v5;
  int v7;
  uint64_t v8;
  char v9;

  v8 = a2;
  if ((unint64_t)(a2 + 1) > 0x28)
  {
    if (a2 != (char)a2)
    {
      LOBYTE(v7) = 51;
      re::zerocopy::writeAll(*this, (re::zerocopy::WriteStream *)&v7, (char *)1);
      v3 = *this;
      v4 = (re::zerocopy::WriteStream *)&v8;
      v5 = 8;
      return re::zerocopy::writeAll(v3, v4, (char *)v5);
    }
    v9 = a2;
    LOBYTE(v7) = 48;
    re::zerocopy::writeAll(*this, (re::zerocopy::WriteStream *)&v7, (char *)1);
    v3 = *this;
    v4 = (re::zerocopy::WriteStream *)&v9;
  }
  else
  {
    LOBYTE(v7) = a2 + 8;
    v3 = *this;
    v4 = (re::zerocopy::WriteStream *)&v7;
  }
  v5 = 1;
  return re::zerocopy::writeAll(v3, v4, (char *)v5);
}

uint64_t re::OPackWriter::writeFloat64(re::zerocopy **this, double a2)
{
  double v4;
  char v5;

  v4 = a2;
  v5 = 54;
  re::zerocopy::writeAll(*this, (re::zerocopy::WriteStream *)&v5, (char *)1);
  return re::zerocopy::writeAll(*this, (re::zerocopy::WriteStream *)&v4, (char *)8);
}

uint64_t re::OPackWriter::writeString(re::zerocopy **this, re::zerocopy::WriteStream *a2, unint64_t a3)
{
  uint64_t result;
  re::zerocopy *v7;
  uint64_t v8;
  unint64_t v9;

  if (a3 >= 0x21)
  {
    if (a3 <= 0xFF)
    {
      LOBYTE(v9) = 97;
      re::zerocopy::writeAll(*this, (re::zerocopy::WriteStream *)&v9, (char *)1);
      LOBYTE(v9) = a3;
      v7 = *this;
      v8 = 1;
    }
    else if (a3 >> 16)
    {
      if (HIDWORD(a3))
      {
        LOBYTE(v9) = 100;
        re::zerocopy::writeAll(*this, (re::zerocopy::WriteStream *)&v9, (char *)1);
        v9 = a3;
        v7 = *this;
        v8 = 8;
      }
      else
      {
        LOBYTE(v9) = 99;
        re::zerocopy::writeAll(*this, (re::zerocopy::WriteStream *)&v9, (char *)1);
        LODWORD(v9) = a3;
        v7 = *this;
        v8 = 4;
      }
    }
    else
    {
      LOBYTE(v9) = 98;
      re::zerocopy::writeAll(*this, (re::zerocopy::WriteStream *)&v9, (char *)1);
      LOWORD(v9) = a3;
      v7 = *this;
      v8 = 2;
    }
    re::zerocopy::writeAll(v7, (re::zerocopy::WriteStream *)&v9, (char *)v8);
    return re::zerocopy::writeAll(*this, a2, (char *)a3);
  }
  LOBYTE(v9) = a3 + 64;
  result = re::zerocopy::writeAll(*this, (re::zerocopy::WriteStream *)&v9, (char *)1);
  if (a3)
    return re::zerocopy::writeAll(*this, a2, (char *)a3);
  return result;
}

uint64_t re::OPackWriter::writeData(re::zerocopy **this, re::zerocopy::WriteStream *a2, unint64_t a3)
{
  uint64_t result;
  re::zerocopy *v7;
  uint64_t v8;
  unint64_t v9;

  if (a3 >= 0x21)
  {
    if (a3 <= 0xFF)
    {
      LOBYTE(v9) = -111;
      re::zerocopy::writeAll(*this, (re::zerocopy::WriteStream *)&v9, (char *)1);
      LOBYTE(v9) = a3;
      v7 = *this;
      v8 = 1;
    }
    else if (a3 >> 16)
    {
      if (HIDWORD(a3))
      {
        LOBYTE(v9) = -108;
        re::zerocopy::writeAll(*this, (re::zerocopy::WriteStream *)&v9, (char *)1);
        v9 = a3;
        v7 = *this;
        v8 = 8;
      }
      else
      {
        LOBYTE(v9) = -109;
        re::zerocopy::writeAll(*this, (re::zerocopy::WriteStream *)&v9, (char *)1);
        LODWORD(v9) = a3;
        v7 = *this;
        v8 = 4;
      }
    }
    else
    {
      LOBYTE(v9) = -110;
      re::zerocopy::writeAll(*this, (re::zerocopy::WriteStream *)&v9, (char *)1);
      LOWORD(v9) = a3;
      v7 = *this;
      v8 = 2;
    }
    re::zerocopy::writeAll(v7, (re::zerocopy::WriteStream *)&v9, (char *)v8);
    return re::zerocopy::writeAll(*this, a2, (char *)a3);
  }
  LOBYTE(v9) = a3 + 112;
  result = re::zerocopy::writeAll(*this, (re::zerocopy::WriteStream *)&v9, (char *)1);
  if (a3)
    return re::zerocopy::writeAll(*this, a2, (char *)a3);
  return result;
}

uint64_t re::OPackWriter::writeArrayBegin(re::zerocopy **this, unint64_t a2)
{
  re::zerocopy *v2;
  re::zerocopy::WriteStream *v3;
  char v5;
  char v6;

  if (a2 > 0xE)
  {
    v6 = -33;
    v2 = *this;
    v3 = (re::zerocopy::WriteStream *)&v6;
  }
  else
  {
    v5 = a2 - 48;
    v2 = *this;
    v3 = (re::zerocopy::WriteStream *)&v5;
  }
  return re::zerocopy::writeAll(v2, v3, (char *)1);
}

uint64_t re::OPackWriter::writeDictionaryBegin(re::zerocopy **this, unint64_t a2)
{
  re::zerocopy *v2;
  re::zerocopy::WriteStream *v3;
  char v5;
  char v6;

  if (a2 > 0xE)
  {
    v6 = -17;
    v2 = *this;
    v3 = (re::zerocopy::WriteStream *)&v6;
  }
  else
  {
    v5 = a2 - 32;
    v2 = *this;
    v3 = (re::zerocopy::WriteStream *)&v5;
  }
  return re::zerocopy::writeAll(v2, v3, (char *)1);
}

uint64_t re::zerocopy::DynamicWriteStream::nextWrite(uint64_t a1, _QWORD *a2)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;

  v4 = *(_QWORD **)(a1 + 8);
  v6 = v4[1];
  v5 = v4[2];
  if (v5 == v6)
  {
    v7 = 2 * v5;
    if (v7 <= 0x40)
      v8 = 64;
    else
      v8 = v7;
    re::DynamicArray<BOOL>::setCapacity(v4, v8);
    v4 = *(_QWORD **)(a1 + 8);
    v6 = v4[1];
    v5 = v4[2];
  }
  *a2 = v4[4] + v5;
  a2[1] = v6 - v5;
  return 1;
}

_QWORD *re::zerocopy::DynamicWriteStream::advanceWrite(re::zerocopy::DynamicWriteStream *this, unint64_t a2)
{
  _QWORD *v2;
  uint64_t v3;
  unint64_t v4;

  v2 = (_QWORD *)*((_QWORD *)this + 1);
  v3 = v2[2];
  v4 = v2[1] - v3;
  if (v4 >= a2)
    v4 = a2;
  return re::DynamicArray<unsigned char>::resizeUninitialized(v2, v4 + v3);
}

void re::zerocopy::DynamicWriteStream::~DynamicWriteStream(re::zerocopy::DynamicWriteStream *this)
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::zerocopy::WriteStream::flushWrite(re::zerocopy::WriteStream *this)
{
  return 1;
}

uint64_t re::zerocopy::writeAll(re::zerocopy *this, re::zerocopy::WriteStream *a2, char *a3)
{
  char *v3;
  uint64_t v6;
  size_t v7;
  void *v9;
  char *v10;

  v9 = 0;
  v10 = 0;
  if (!a3)
    return 1;
  v3 = a3;
  do
  {
    v6 = (*(uint64_t (**)(re::zerocopy *, void **))(*(_QWORD *)this + 16))(this, &v9);
    if (!(_DWORD)v6)
      break;
    v7 = (size_t)(v3 >= v10 ? v10 : v3);
    memcpy(v9, a2, v7);
    (*(void (**)(re::zerocopy *, size_t))(*(_QWORD *)this + 24))(this, v7);
    a2 = (re::zerocopy::WriteStream *)((char *)a2 + v7);
    v3 -= v7;
  }
  while (v3);
  return v6;
}

void re::zerocopy::BufferedReadStream::~BufferedReadStream(re::zerocopy::BufferedReadStream *this)
{
  re::zerocopy::BufferedReadStream *v1;
  re::zerocopy::BufferedReadStream *v2;
  uint64_t *v4;

  v1 = this;
  *(_QWORD *)this = &off_24ED7DD60;
  if (*((_QWORD *)this + 4))
  {
    this = (re::zerocopy::BufferedReadStream *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 24))(*((_QWORD *)this + 1));
    *((_QWORD *)v1 + 4) = 0;
  }
  v2 = (re::zerocopy::BufferedReadStream *)*((_QWORD *)v1 + 13);
  if (v2 != (re::zerocopy::BufferedReadStream *)((char *)v1 + 40) && v2 != 0)
  {
    v4 = re::globalAllocators(this);
    (*(void (**)(uint64_t, re::zerocopy::BufferedReadStream *))(*(_QWORD *)v4[2] + 40))(v4[2], v2);
  }
  *((_QWORD *)v1 + 13) = 0;
  *((_QWORD *)v1 + 14) = 0;
  *((_QWORD *)v1 + 15) = 0;
}

{
  re::zerocopy::BufferedReadStream::~BufferedReadStream(this);
  JUMPOUT(0x2276933B8);
}

uint64_t re::zerocopy::BufferedReadStream::contiguousRead(re::zerocopy::BufferedReadStream *this, char *a2, _QWORD *a3)
{
  uint64_t result;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;

  if (*((_QWORD *)this + 13) != *((_QWORD *)this + 14))
    goto LABEL_2;
  v8 = *((_QWORD *)this + 3);
  if (v8)
  {
LABEL_9:
    if (v8 >= (unint64_t)a2)
    {
      a3[1] = a2;
      v9 = *((_QWORD *)this + 3);
      *a3 = *((_QWORD *)this + 2);
      if (v9 >= (unint64_t)a2)
        v10 = (unint64_t)a2;
      else
        v10 = v9;
      *((_QWORD *)this + 2) += v10;
      *((_QWORD *)this + 3) = v9 - v10;
      *((_QWORD *)this + 4) += v10;
      return 1;
    }
LABEL_2:
    result = re::zerocopy::BufferedReadStream::fillInternal(this, a2);
    if (!(_DWORD)result)
      return result;
    v7 = *((_QWORD *)this + 13);
    *a3 = v7;
    a3[1] = a2;
    *((_QWORD *)this + 14) = v7;
    return 1;
  }
  if (*((_QWORD *)this + 4))
  {
    (*(void (**)(_QWORD))(**((_QWORD **)this + 1) + 24))(*((_QWORD *)this + 1));
    *((_QWORD *)this + 4) = 0;
  }
  result = (*(uint64_t (**)(_QWORD, char *))(**((_QWORD **)this + 1) + 16))(*((_QWORD *)this + 1), (char *)this + 16);
  if ((_DWORD)result)
  {
    v8 = *((_QWORD *)this + 3);
    goto LABEL_9;
  }
  return result;
}

uint64_t re::zerocopy::BufferedReadStream::fillInternal(re::zerocopy::BufferedReadStream *this, char *a2)
{
  char *v3;
  uint64_t v4;
  size_t v6;
  uint64_t result;
  size_t v8;
  size_t v9;
  size_t v10;
  size_t v11;

  v3 = (char *)*((_QWORD *)this + 14);
  v4 = *((_QWORD *)this + 13);
  if (&v3[-v4] < a2)
  {
    v6 = *((_QWORD *)this + 3);
    do
    {
      if (!v6)
      {
        if (*((_QWORD *)this + 4))
        {
          (*(void (**)(_QWORD))(**((_QWORD **)this + 1) + 24))(*((_QWORD *)this + 1));
          *((_QWORD *)this + 4) = 0;
        }
        result = (*(uint64_t (**)(_QWORD, char *))(**((_QWORD **)this + 1) + 16))(*((_QWORD *)this + 1), (char *)this + 16);
        if (!(_DWORD)result)
          return result;
        v4 = *((_QWORD *)this + 13);
        v3 = (char *)*((_QWORD *)this + 14);
        v6 = *((_QWORD *)this + 3);
      }
      v8 = &a2[v4] - v3;
      if (v8 >= v6)
        v9 = v6;
      else
        v9 = v8;
      memcpy(v3, *((const void **)this + 2), v9);
      v10 = *((_QWORD *)this + 3);
      if (v10 >= v9)
        v11 = v9;
      else
        v11 = *((_QWORD *)this + 3);
      v6 = v10 - v11;
      *((_QWORD *)this + 2) += v11;
      *((_QWORD *)this + 3) = v6;
      *((_QWORD *)this + 4) += v11;
      v4 = *((_QWORD *)this + 13);
      v3 = (char *)(*((_QWORD *)this + 14) + v9);
      *((_QWORD *)this + 14) = v3;
    }
    while (&v3[-v4] < a2);
  }
  return 1;
}

uint64_t re::zerocopy::BufferedReadStream::nextRead(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;
  uint64_t v4;
  _OWORD *v6;
  uint64_t result;

  v3 = *(_QWORD *)(a1 + 104);
  v4 = *(_QWORD *)(a1 + 112);
  if (v3 != v4)
  {
    *a2 = v3;
    a2[1] = v4 - v3;
    return 1;
  }
  v6 = (_OWORD *)(a1 + 16);
  if (*(_QWORD *)(a1 + 24))
    goto LABEL_7;
  if (*(_QWORD *)(a1 + 32))
  {
    (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 24))(*(_QWORD *)(a1 + 8));
    *(_QWORD *)(a1 + 32) = 0;
  }
  result = (*(uint64_t (**)(_QWORD, _OWORD *))(**(_QWORD **)(a1 + 8) + 16))(*(_QWORD *)(a1 + 8), v6);
  if ((_DWORD)result)
  {
LABEL_7:
    *(_OWORD *)a2 = *v6;
    return 1;
  }
  return result;
}

char *re::zerocopy::BufferedReadStream::advanceRead(re::zerocopy::BufferedReadStream *this, unint64_t a2)
{
  char *result;
  char *v4;
  unint64_t v5;
  size_t v6;
  unint64_t v7;
  unint64_t v8;

  result = (char *)*((_QWORD *)this + 13);
  v4 = (char *)*((_QWORD *)this + 14);
  if (result == v4)
  {
    v7 = *((_QWORD *)this + 3);
    if (v7 >= a2)
      v8 = a2;
    else
      v8 = *((_QWORD *)this + 3);
    *((_QWORD *)this + 2) += v8;
    *((_QWORD *)this + 3) = v7 - v8;
    *((_QWORD *)this + 4) += v8;
  }
  else
  {
    v5 = v4 - result;
    v6 = v5 - a2;
    if (v5 > a2)
    {
      memmove(result, &result[a2], v6);
      result = (char *)(*((_QWORD *)this + 13) + v6);
    }
    *((_QWORD *)this + 14) = result;
  }
  return result;
}

__n128 re::TransferStats::aggregate(__n128 *a1, __n128 *a2)
{
  unsigned __int32 v2;
  int v3;
  unsigned __int32 v4;
  unsigned __int32 v5;
  __n128 result;

  if (a2->n128_u32[0])
  {
    if (a1->n128_u32[0])
    {
      v2 = a1->n128_u32[2];
      v3 = a1->n128_u32[1] + a2->n128_u32[1];
      a1->n128_u32[0] += a2->n128_u32[0];
      a1->n128_u32[1] = v3;
      v4 = a2->n128_u32[2];
      if (v4 >= v2)
        v4 = v2;
      a1->n128_u32[2] = v4;
      v5 = a1->n128_u32[3];
      if (v5 <= a2->n128_u32[3])
        v5 = a2->n128_u32[3];
      a1->n128_u32[3] = v5;
    }
    else
    {
      result = *a2;
      *a1 = *a2;
    }
  }
  return result;
}

_DWORD *re::PeerTransferReport::addEntry(_DWORD *this, unint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v8;
  _DWORD *v9;
  uint64_t v10;
  _DWORD *v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;
  unint64_t v24;

  v24 = a2;
  if (a5)
  {
    v8 = a2;
    v9 = this;
    v10 = (uint64_t)(this + 2);
    v11 = (_DWORD *)re::HashTable<re::ecs2::Entity const*,re::ecs2::ShadowPlaneTrackingState,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::tryGet((uint64_t)(this + 2), a2);
    if (v11)
    {
      if (*v11)
      {
        v12 = v11[2];
        v13 = v11[1] + a5;
        ++*v11;
        v11[1] = v13;
        if (a5 >= v12)
          v14 = v12;
        else
          v14 = a5;
        v15 = v11[3];
        if (v15 <= a5)
          v15 = a5;
        v11[2] = v14;
        v11[3] = v15;
      }
      else
      {
        *v11 = 1;
        v11[1] = a5;
        v11[2] = a5;
        v11[3] = a5;
      }
    }
    else
    {
      LODWORD(v22) = 1;
      DWORD1(v22) = a5;
      DWORD2(v22) = a5;
      HIDWORD(v22) = a5;
      re::HashTable<unsigned long long,re::TransferStats,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew(v10, (uint64_t *)&v24, &v22);
      v8 = v24;
    }
    v16 = (uint64_t)(v9 + 14);
    *(_QWORD *)&v22 = a3;
    *((_QWORD *)&v22 + 1) = a4;
    v23 = v8;
    this = (_DWORD *)re::HashTable<re::InstanceParentTypeTuple,re::TransferStats,re::Hash<re::InstanceParentTypeTuple>,re::EqualTo<re::InstanceParentTypeTuple>,true,false>::tryGet(v16, &v22);
    if (this)
    {
      if (*this)
      {
        v17 = this[2];
        v18 = this[1] + a5;
        ++*this;
        this[1] = v18;
        if (a5 >= v17)
          v19 = v17;
        else
          v19 = a5;
        v20 = this[3];
        if (v20 <= a5)
          v20 = a5;
        this[2] = v19;
        this[3] = v20;
      }
      else
      {
        *this = 1;
        this[1] = a5;
        this[2] = a5;
        this[3] = a5;
      }
    }
    else
    {
      *(_QWORD *)&v22 = a3;
      *((_QWORD *)&v22 + 1) = a4;
      v23 = v8;
      LODWORD(v21) = 1;
      DWORD1(v21) = a5;
      DWORD2(v21) = a5;
      HIDWORD(v21) = a5;
      return (_DWORD *)re::HashTable<re::InstanceParentTypeTuple,re::TransferStats,re::Hash<re::InstanceParentTypeTuple>,re::EqualTo<re::InstanceParentTypeTuple>,true,false>::addNew(v16, &v22, &v21);
    }
  }
  return this;
}

uint64_t re::HashTable<unsigned long long,re::TransferStats,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew(uint64_t a1, uint64_t *a2, _OWORD *a3)
{
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;

  v6 = *a2;
  v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (!*(_QWORD *)a1)
  {
    LODWORD(v9) = 0;
    goto LABEL_8;
  }
  v9 = v8 % *(unsigned int *)(a1 + 24);
  v10 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v9);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
LABEL_8:
    v13 = re::HashTable<unsigned long long,re::TransferStats,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsCopy(a1, v9, v8, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    v12 = *(_QWORD *)(a1 + 16) + 40 * v13;
    return v12 + 24;
  }
  v11 = *(_QWORD *)(a1 + 16);
  while (*(_QWORD *)(v11 + 40 * v10 + 16) != v6)
  {
    LODWORD(v10) = *(_DWORD *)(v11 + 40 * v10 + 8) & 0x7FFFFFFF;
    if ((_DWORD)v10 == 0x7FFFFFFF)
      goto LABEL_8;
  }
  v12 = v11 + 40 * v10;
  return v12 + 24;
}

uint64_t re::HashTable<re::InstanceParentTypeTuple,re::TransferStats,re::Hash<re::InstanceParentTypeTuple>,re::EqualTo<re::InstanceParentTypeTuple>,true,false>::tryGet(uint64_t a1, _QWORD *a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if (!*(_QWORD *)a1)
    return 0;
  v2 = a2[1];
  v3 = a2[2];
  v4 = *(unsigned int *)(*(_QWORD *)(a1 + 8)
                       + 4
                       * ((((*a2 << 6)
                          + (*a2 >> 2)
                          - 0x61C8864680B583E9
                          + ((v3 + (v2 << 6) + (v2 >> 2) - 0x61C8864680B583E9) ^ v2)) ^ *a2)
                        % *(unsigned int *)(a1 + 24)));
  if ((_DWORD)v4 == 0x7FFFFFFF)
    return 0;
  v5 = *(_QWORD *)(a1 + 16);
  while (*(_QWORD *)(v5 + 56 * v4 + 16) != *a2
       || *(_QWORD *)(v5 + 56 * v4 + 24) != v2
       || *(_QWORD *)(v5 + 56 * v4 + 32) != v3)
  {
    v4 = *(_DWORD *)(v5 + 56 * v4 + 8) & 0x7FFFFFFF;
    if (v4 == 0x7FFFFFFF)
      return 0;
  }
  return v5 + 56 * v4 + 40;
}

uint64_t re::HashTable<re::InstanceParentTypeTuple,re::TransferStats,re::Hash<re::InstanceParentTypeTuple>,re::EqualTo<re::InstanceParentTypeTuple>,true,false>::addNew(uint64_t a1, __int128 *a2, _OWORD *a3)
{
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;

  v6 = *(_QWORD *)a2;
  v7 = *((_QWORD *)a2 + 1);
  v8 = *((_QWORD *)a2 + 2);
  v9 = ((*(_QWORD *)a2 << 6)
      + (*(_QWORD *)a2 >> 2)
      - 0x61C8864680B583E9
      + ((v8 + (v7 << 6) + (v7 >> 2) - 0x61C8864680B583E9) ^ v7)) ^ *(_QWORD *)a2;
  if (!*(_QWORD *)a1)
  {
    LODWORD(v10) = 0;
    goto LABEL_10;
  }
  v10 = v9 % *(unsigned int *)(a1 + 24);
  v11 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v10);
  if ((_DWORD)v11 == 0x7FFFFFFF)
  {
LABEL_10:
    v13 = re::HashTable<re::InstanceParentTypeTuple,re::TransferStats,re::Hash<re::InstanceParentTypeTuple>,re::EqualTo<re::InstanceParentTypeTuple>,true,false>::addAsCopy(a1, v10, v9, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    v14 = *(_QWORD *)(a1 + 16) + 56 * v13;
    return v14 + 40;
  }
  v12 = *(_QWORD *)(a1 + 16);
  while (*(_QWORD *)(v12 + 56 * v11 + 16) != v6
       || *(_QWORD *)(v12 + 56 * v11 + 24) != v7
       || *(_QWORD *)(v12 + 56 * v11 + 32) != v8)
  {
    v11 = *(_DWORD *)(v12 + 56 * v11 + 8) & 0x7FFFFFFF;
    if (v11 == 0x7FFFFFFF)
      goto LABEL_10;
  }
  v14 = v12 + 56 * v11;
  return v14 + 40;
}

void re::PeerTransferReport::aggregate(re::PeerTransferReport *this, const re::PeerTransferReport *a2)
{
  uint64_t v4;
  uint64_t v5;
  int *v6;
  int v7;
  uint64_t v8;
  unint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  __n128 *v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  int v24;
  int v25;
  int v26;
  uint64_t v27;
  int *v28;
  int v29;
  uint64_t v30;
  unint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD *v34;
  __n128 *v35;
  __n128 *v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  uint64_t v46;
  int v47;
  uint64_t v48;
  __int128 v49;
  unsigned int v50;
  unsigned int v51;
  unint64_t *v52;
  uint64_t v53;

  v4 = *((unsigned int *)a2 + 10);
  if ((_DWORD)v4)
  {
    v5 = 0;
    v6 = (int *)(*((_QWORD *)a2 + 3) + 8);
    while (1)
    {
      v7 = *v6;
      v6 += 10;
      if (v7 < 0)
        break;
      if (v4 == ++v5)
      {
        LODWORD(v5) = *((_DWORD *)a2 + 10);
        break;
      }
    }
  }
  else
  {
    LODWORD(v5) = 0;
  }
  if ((_DWORD)v4 != (_DWORD)v5)
  {
    v8 = v5;
    v9 = (unint64_t *)((char *)this + 8);
    v10 = *((_QWORD *)a2 + 3);
    v52 = (unint64_t *)((char *)this + 8);
    do
    {
      v11 = v10 + 40 * v8;
      v14 = *(_QWORD *)(v11 + 16);
      v13 = v11 + 16;
      v12 = v14;
      v15 = (__n128 *)re::HashTable<re::ecs2::Entity const*,re::ecs2::ShadowPlaneTrackingState,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::tryGet((uint64_t)v9, v14);
      if (v15)
      {
        re::TransferStats::aggregate(v15, (__n128 *)(v13 + 8));
      }
      else
      {
        v16 = 0x94D049BB133111EBLL
            * ((0xBF58476D1CE4E5B9 * (v12 ^ (v12 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v12 ^ (v12 >> 30))) >> 27));
        v17 = v16 ^ (v16 >> 31);
        v18 = *v9;
        if (!*v9
          || (v18 = v17 % *((unsigned int *)this + 8),
              v19 = *(unsigned int *)(*((_QWORD *)this + 2) + 4 * v18),
              (_DWORD)v19 == 0x7FFFFFFF))
        {
LABEL_16:
          v21 = *((unsigned int *)this + 11);
          if ((_DWORD)v21 == 0x7FFFFFFF)
          {
            v21 = *((unsigned int *)this + 10);
            v22 = v21;
            if ((_DWORD)v21 == *((_DWORD *)this + 8))
            {
              re::HashTable<unsigned long long,re::TransferStats,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity((uint64_t)v52, 2 * *((_DWORD *)this + 9));
              v18 = v17 % *((unsigned int *)this + 8);
              v22 = *((_DWORD *)this + 10);
              v12 = *(_QWORD *)v13;
            }
            *((_DWORD *)this + 10) = v22 + 1;
            v23 = *((_QWORD *)this + 3);
            v24 = *(_DWORD *)(v23 + 40 * v21 + 8);
          }
          else
          {
            v23 = *((_QWORD *)this + 3);
            v24 = *(_DWORD *)(v23 + 40 * v21 + 8);
            *((_DWORD *)this + 11) = v24 & 0x7FFFFFFF;
          }
          *(_DWORD *)(v23 + 40 * v21 + 8) = v24 | 0x80000000;
          *(_DWORD *)(*((_QWORD *)this + 3) + 40 * v21 + 8) = *(_DWORD *)(*((_QWORD *)this + 3) + 40 * v21 + 8) & 0x80000000 | *(_DWORD *)(*((_QWORD *)this + 2) + 4 * v18);
          *(_QWORD *)(*((_QWORD *)this + 3) + 40 * v21) = v17;
          *(_QWORD *)(*((_QWORD *)this + 3) + 40 * v21 + 16) = v12;
          *(_OWORD *)(*((_QWORD *)this + 3) + 40 * v21 + 24) = *(_OWORD *)(v13 + 8);
          *(_DWORD *)(*((_QWORD *)this + 2) + 4 * v18) = v21;
          ++*((_DWORD *)this + 9);
          ++*((_DWORD *)this + 12);
          v9 = v52;
        }
        else
        {
          v20 = *((_QWORD *)this + 3);
          while (*(_QWORD *)(v20 + 40 * v19 + 16) != v12)
          {
            LODWORD(v19) = *(_DWORD *)(v20 + 40 * v19 + 8) & 0x7FFFFFFF;
            if ((_DWORD)v19 == 0x7FFFFFFF)
              goto LABEL_16;
          }
        }
      }
      v10 = *((_QWORD *)a2 + 3);
      if (*((_DWORD *)a2 + 10) <= (v5 + 1))
        v25 = v5 + 1;
      else
        v25 = *((_DWORD *)a2 + 10);
      while (1)
      {
        v8 = (v5 + 1);
        if (v25 - 1 == (_DWORD)v5)
          break;
        LODWORD(v5) = v5 + 1;
        v26 = v8;
        if ((*(_DWORD *)(v10 + 40 * v8 + 8) & 0x80000000) != 0)
          goto LABEL_29;
      }
      v26 = v25;
LABEL_29:
      LODWORD(v5) = v26;
    }
    while ((_DWORD)v4 != v26);
  }
  v53 = *((unsigned int *)a2 + 22);
  v27 = 0;
  if ((_DWORD)v53)
  {
    v28 = (int *)(*((_QWORD *)a2 + 9) + 8);
    while (1)
    {
      v29 = *v28;
      v28 += 14;
      if (v29 < 0)
        break;
      if (v53 == ++v27)
      {
        LODWORD(v27) = *((_DWORD *)a2 + 22);
        break;
      }
    }
  }
  if ((_DWORD)v53 != (_DWORD)v27)
  {
    v30 = v27;
    v31 = (unint64_t *)((char *)this + 56);
    v32 = *((_QWORD *)a2 + 9);
    do
    {
      v33 = v32 + 56 * v30;
      v34 = (_QWORD *)(v33 + 16);
      v35 = (__n128 *)(v33 + 40);
      v36 = (__n128 *)re::HashTable<re::InstanceParentTypeTuple,re::TransferStats,re::Hash<re::InstanceParentTypeTuple>,re::EqualTo<re::InstanceParentTypeTuple>,true,false>::tryGet((uint64_t)this + 56, (_QWORD *)(v33 + 16));
      if (v36)
      {
        re::TransferStats::aggregate(v36, v35);
      }
      else
      {
        v37 = v32 + 56 * v30;
        v38 = *(_QWORD *)(v37 + 24);
        v39 = *(_QWORD *)(v37 + 32);
        v40 = ((*v34 << 6)
             - 0x61C8864680B583E9
             + (*v34 >> 2)
             + ((v39 - 0x61C8864680B583E9 + (v38 << 6) + (v38 >> 2)) ^ v38)) ^ *v34;
        v41 = *v31;
        if (!*v31
          || (v41 = v40 % *((unsigned int *)this + 20),
              v42 = *(unsigned int *)(*((_QWORD *)this + 8) + 4 * v41),
              (_DWORD)v42 == 0x7FFFFFFF))
        {
LABEL_46:
          v44 = *((unsigned int *)this + 23);
          if ((_DWORD)v44 == 0x7FFFFFFF)
          {
            v44 = *((unsigned int *)this + 22);
            v45 = v44;
            if ((_DWORD)v44 == *((_DWORD *)this + 20))
            {
              re::HashTable<re::InstanceParentTypeTuple,re::TransferStats,re::Hash<re::InstanceParentTypeTuple>,re::EqualTo<re::InstanceParentTypeTuple>,true,false>::setCapacity((uint64_t)this + 56, 2 * *((_DWORD *)this + 21));
              v41 = v40 % *((unsigned int *)this + 20);
              v45 = *((_DWORD *)this + 22);
            }
            *((_DWORD *)this + 22) = v45 + 1;
            v46 = *((_QWORD *)this + 9);
            v47 = *(_DWORD *)(v46 + 56 * v44 + 8);
          }
          else
          {
            v46 = *((_QWORD *)this + 9);
            v47 = *(_DWORD *)(v46 + 56 * v44 + 8);
            *((_DWORD *)this + 23) = v47 & 0x7FFFFFFF;
          }
          *(_DWORD *)(v46 + 56 * v44 + 8) = v47 | 0x80000000;
          *(_DWORD *)(*((_QWORD *)this + 9) + 56 * v44 + 8) = *(_DWORD *)(*((_QWORD *)this + 9) + 56 * v44 + 8) & 0x80000000 | *(_DWORD *)(*((_QWORD *)this + 8) + 4 * v41);
          *(_QWORD *)(*((_QWORD *)this + 9) + 56 * v44) = v40;
          v48 = *((_QWORD *)this + 9) + 56 * v44;
          v49 = *(_OWORD *)v34;
          *(_QWORD *)(v48 + 32) = v34[2];
          *(_OWORD *)(v48 + 16) = v49;
          *(__n128 *)(*((_QWORD *)this + 9) + 56 * v44 + 40) = *v35;
          *(_DWORD *)(*((_QWORD *)this + 8) + 4 * v41) = v44;
          ++*((_DWORD *)this + 21);
          ++*((_DWORD *)this + 24);
        }
        else
        {
          v43 = *((_QWORD *)this + 9);
          while (*(_QWORD *)(v43 + 56 * v42 + 16) != *v34
               || *(_QWORD *)(v43 + 56 * v42 + 24) != v38
               || *(_QWORD *)(v43 + 56 * v42 + 32) != v39)
          {
            v42 = *(_DWORD *)(v43 + 56 * v42 + 8) & 0x7FFFFFFF;
            if (v42 == 0x7FFFFFFF)
              goto LABEL_46;
          }
        }
      }
      v50 = *((_DWORD *)a2 + 22);
      v32 = *((_QWORD *)a2 + 9);
      if (v50 <= (int)v27 + 1)
        v50 = v27 + 1;
      while (1)
      {
        v30 = (v27 + 1);
        if (v50 - 1 == (_DWORD)v27)
          break;
        LODWORD(v27) = v27 + 1;
        v51 = v30;
        if ((*(_DWORD *)(v32 + 56 * v30 + 8) & 0x80000000) != 0)
          goto LABEL_58;
      }
      v51 = v50;
LABEL_58:
      LODWORD(v27) = v51;
    }
    while ((_DWORD)v53 != v51);
  }
}

void re::HashTable<unsigned long long,re::TransferStats,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;

  if (*(_DWORD *)(a1 + 28))
  {
    v2 = *(unsigned int *)(a1 + 24);
    if ((_DWORD)v2)
      memset_pattern16(*(void **)(a1 + 8), &memset_pattern_10, 4 * v2);
    v3 = *(unsigned int *)(a1 + 32);
    if ((_DWORD)v3)
    {
      v4 = 0;
      v5 = 40 * v3;
      do
      {
        v6 = *(_QWORD *)(a1 + 16) + v4;
        v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
        v4 += 40;
      }
      while (v5 != v4);
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    v8 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v8;
  }
}

void re::SessionTransferReport::aggregate(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  int *v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  const re::PeerTransferReport *v12;
  re::PeerTransferReport *v13;
  int v14;
  int v15;

  v3 = *(unsigned int *)(a2 + 48);
  if ((_DWORD)v3)
  {
    v4 = 0;
    v5 = (int *)(*(_QWORD *)(a2 + 32) + 8);
    while (1)
    {
      v6 = *v5;
      v5 += 32;
      if (v6 < 0)
        break;
      if (v3 == ++v4)
      {
        LODWORD(v4) = *(_DWORD *)(a2 + 48);
        break;
      }
    }
  }
  else
  {
    LODWORD(v4) = 0;
  }
  if ((_DWORD)v3 != (_DWORD)v4)
  {
    v7 = v4;
    v8 = a1 + 16;
    v9 = *(_QWORD *)(a2 + 32);
    do
    {
      v10 = v9 + (v7 << 7);
      v11 = (uint64_t *)(v10 + 16);
      v12 = (const re::PeerTransferReport *)(v10 + 24);
      v13 = (re::PeerTransferReport *)re::HashTable<unsigned long long,re::PeerTransferReport,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(v8, (uint64_t *)(v10 + 16));
      if (v13)
        re::PeerTransferReport::aggregate(v13, v12);
      else
        re::HashTable<unsigned long long,re::PeerTransferReport,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew<re::PeerTransferReport&>(v8, v11, v12);
      v9 = *(_QWORD *)(a2 + 32);
      if (*(_DWORD *)(a2 + 48) <= (v4 + 1))
        v14 = v4 + 1;
      else
        v14 = *(_DWORD *)(a2 + 48);
      while (1)
      {
        v7 = (v4 + 1);
        if (v14 - 1 == (_DWORD)v4)
          break;
        LODWORD(v4) = v4 + 1;
        v15 = v7;
        if ((*(_DWORD *)(v9 + (v7 << 7) + 8) & 0x80000000) != 0)
          goto LABEL_19;
      }
      v15 = v14;
LABEL_19:
      LODWORD(v4) = v15;
    }
    while ((_DWORD)v3 != v15);
  }
}

uint64_t re::HashTable<unsigned long long,re::PeerTransferReport,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew<re::PeerTransferReport&>(uint64_t a1, uint64_t *a2, _QWORD *a3)
{
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;

  v6 = *a2;
  v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (*(_QWORD *)a1)
  {
    v9 = v8 % *(unsigned int *)(a1 + 24);
    v10 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v9);
    if ((_DWORD)v10 != 0x7FFFFFFF)
    {
      v11 = *(_QWORD *)(a1 + 16);
      if (*(_QWORD *)(v11 + (v10 << 7) + 16) == v6)
      {
LABEL_6:
        v12 = v11 + (v10 << 7);
        return v12 + 24;
      }
      while (1)
      {
        v10 = *(_DWORD *)(v11 + (v10 << 7) + 8) & 0x7FFFFFFF;
        if ((_DWORD)v10 == 0x7FFFFFFF)
          break;
        if (*(_QWORD *)(v11 + (v10 << 7) + 16) == v6)
          goto LABEL_6;
      }
    }
  }
  else
  {
    LODWORD(v9) = 0;
  }
  v13 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v13 == 0x7FFFFFFF)
  {
    v13 = *(unsigned int *)(a1 + 32);
    v14 = v13;
    if ((_DWORD)v13 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<unsigned long long,re::PeerTransferReport,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      LODWORD(v9) = v8 % *(unsigned int *)(a1 + 24);
      v14 = *(_DWORD *)(a1 + 32);
      v6 = *a2;
    }
    *(_DWORD *)(a1 + 32) = v14 + 1;
    v15 = *(_QWORD *)(a1 + 16);
    v16 = *(_DWORD *)(v15 + (v13 << 7) + 8);
  }
  else
  {
    v15 = *(_QWORD *)(a1 + 16);
    v16 = *(_DWORD *)(v15 + (v13 << 7) + 8);
    *(_DWORD *)(a1 + 36) = v16 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v15 + (v13 << 7) + 8) = v16 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + (v13 << 7) + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + (v13 << 7) + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * v9);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + (v13 << 7)) = v8;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + (v13 << 7) + 16) = v6;
  v17 = *(_QWORD *)(a1 + 16) + (v13 << 7);
  *(_QWORD *)(v17 + 24) = *a3;
  re::HashTable<unsigned long long,re::TransferStats,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashTable(v17 + 32, (uint64_t)(a3 + 1));
  re::HashTable<re::InstanceParentTypeTuple,re::TransferStats,re::Hash<re::InstanceParentTypeTuple>,re::EqualTo<re::InstanceParentTypeTuple>,true,false>::HashTable(v17 + 80, (uint64_t)(a3 + 7));
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * v9) = v13;
  ++*(_DWORD *)(a1 + 28);
  ++*(_DWORD *)(a1 + 40);
  v12 = *(_QWORD *)(a1 + 16) + (v13 << 7);
  return v12 + 24;
}

void re::HashTable<unsigned long long,re::PeerTransferReport,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  int v5;

  if (*(_DWORD *)(a1 + 28))
  {
    v2 = *(unsigned int *)(a1 + 24);
    if ((_DWORD)v2)
      memset_pattern16(*(void **)(a1 + 8), &memset_pattern_10, 4 * v2);
    if (*(_DWORD *)(a1 + 32))
    {
      v3 = 0;
      v4 = 0;
      do
      {
        re::HashTable<unsigned long long,re::PeerTransferReport,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::EntryWithHash::free(*(_QWORD *)(a1 + 16) + v3);
        ++v4;
        v3 += 128;
      }
      while (v4 < *(unsigned int *)(a1 + 32));
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    v5 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v5;
  }
}

void re::TransferReport::aggregate(double *a1, uint64_t a2)
{
  double v2;
  double v5;
  double v6;
  double v7;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t v18;
  int v19;
  int v20;

  v2 = *(double *)a2;
  if (*(double *)a2 > 0.0 && v2 < *(double *)(a2 + 8))
  {
    v5 = *a1;
    if (*a1 <= 0.0 || (v6 = a1[1], v5 >= v6))
    {
      *(_OWORD *)a1 = *(_OWORD *)a2;
      re::HashTable<unsigned long,re::SessionTransferReport,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::operator=((uint64_t)(a1 + 2), a2 + 16);
    }
    else
    {
      if (v2 >= v5)
        v2 = *a1;
      *a1 = v2;
      v7 = *(double *)(a2 + 8);
      if (v6 >= v7)
        v7 = v6;
      a1[1] = v7;
      v8 = *(unsigned int *)(a2 + 48);
      if ((_DWORD)v8)
      {
        v9 = 0;
        v10 = (int *)(*(_QWORD *)(a2 + 32) + 8);
        while (1)
        {
          v11 = *v10;
          v10 += 22;
          if (v11 < 0)
            break;
          if (v8 == ++v9)
          {
            LODWORD(v9) = *(_DWORD *)(a2 + 48);
            break;
          }
        }
      }
      else
      {
        LODWORD(v9) = 0;
      }
      if ((_DWORD)v8 != (_DWORD)v9)
      {
        v12 = v9;
        v13 = (uint64_t)(a1 + 2);
        v14 = *(_QWORD *)(a2 + 32);
        do
        {
          v15 = v14 + 88 * v12;
          v16 = (uint64_t *)(v15 + 16);
          v17 = (uint64_t *)(v15 + 24);
          v18 = re::HashTable<re::ecs2::Scene const*,re::DataArray<re::ecs2::PhysicsSimulationData>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::tryGet(v13, (uint64_t *)(v15 + 16));
          if (v18)
            re::SessionTransferReport::aggregate(v18, (uint64_t)v17);
          else
            re::HashTable<unsigned long,re::SessionTransferReport,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::addNew<re::SessionTransferReport&>(v13, v16, v17);
          v14 = *(_QWORD *)(a2 + 32);
          if (*(_DWORD *)(a2 + 48) <= (v9 + 1))
            v19 = v9 + 1;
          else
            v19 = *(_DWORD *)(a2 + 48);
          while (1)
          {
            v12 = (v9 + 1);
            if (v19 - 1 == (_DWORD)v9)
              break;
            LODWORD(v9) = v9 + 1;
            v20 = v12;
            if ((*(_DWORD *)(v14 + 88 * v12 + 8) & 0x80000000) != 0)
              goto LABEL_31;
          }
          v20 = v19;
LABEL_31:
          LODWORD(v9) = v20;
        }
        while ((_DWORD)v8 != v20);
      }
    }
  }
}

uint64_t re::HashTable<unsigned long,re::SessionTransferReport,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::addNew<re::SessionTransferReport&>(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;

  v6 = *a2;
  v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (!*(_QWORD *)a1)
  {
    LODWORD(v9) = 0;
    goto LABEL_8;
  }
  v9 = v8 % *(unsigned int *)(a1 + 24);
  v10 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v9);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
LABEL_8:
    v13 = re::HashTable<unsigned long,re::SessionTransferReport,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::addAsCopy(a1, v9, v8, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    v12 = *(_QWORD *)(a1 + 16) + 88 * v13;
    return v12 + 24;
  }
  v11 = *(_QWORD *)(a1 + 16);
  while (*(_QWORD *)(v11 + 88 * v10 + 16) != v6)
  {
    LODWORD(v10) = *(_DWORD *)(v11 + 88 * v10 + 8) & 0x7FFFFFFF;
    if ((_DWORD)v10 == 0x7FFFFFFF)
      goto LABEL_8;
  }
  v12 = v11 + 88 * v10;
  return v12 + 24;
}

void re::HashTable<unsigned long,re::SessionTransferReport,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::clear(uint64_t a1)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t i;
  uint64_t v6;
  int v7;
  int v8;

  if (*(_DWORD *)(a1 + 28))
  {
    v2 = *(unsigned int *)(a1 + 24);
    if ((_DWORD)v2)
      memset_pattern16(*(void **)(a1 + 8), &memset_pattern_10, 4 * v2);
    v3 = *(unsigned int *)(a1 + 32);
    if ((_DWORD)v3)
    {
      v4 = 0;
      for (i = 0; i < v3; ++i)
      {
        v6 = *(_QWORD *)(a1 + 16) + v4;
        v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
          re::HashTable<unsigned long long,re::PeerTransferReport,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)(v6 + 40));
          v3 = *(unsigned int *)(a1 + 32);
        }
        v4 += 88;
      }
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    v8 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v8;
  }
}

uint64_t re::HashTable<unsigned long,re::SessionTransferReport,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  signed int v5;

  if (a1 != a2)
  {
    v4 = *(_QWORD *)a2;
    if (*(_QWORD *)a1)
    {
      if (v4)
      {
        re::HashTable<unsigned long,re::SessionTransferReport,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::copy(a1, a2);
        ++*(_DWORD *)(a1 + 40);
      }
      else
      {
        re::HashTable<unsigned long,re::SessionTransferReport,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::clear(a1);
      }
    }
    else if (v4)
    {
      if (*(_DWORD *)(a2 + 28) <= 3u)
        v5 = 3;
      else
        v5 = *(_DWORD *)(a2 + 28);
      re::HashTable<unsigned long,re::SessionTransferReport,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::init(a1, v4, v5);
      re::HashTable<unsigned long,re::SessionTransferReport,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::copy(a1, a2);
    }
  }
  return a1;
}

void re::HashTable<unsigned long,re::SessionTransferReport,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::copy(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t i;
  uint64_t v8;

  re::HashTable<unsigned long,re::SessionTransferReport,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::clear(a1);
  v4 = *(_DWORD *)(a2 + 28);
  if (*(_DWORD *)(a1 + 24) < v4)
    re::HashTable<unsigned long,re::SessionTransferReport,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::setCapacity(a1, v4);
  v5 = *(unsigned int *)(a2 + 32);
  if ((_DWORD)v5)
  {
    v6 = 0;
    for (i = 0; i < v5; ++i)
    {
      v8 = *(_QWORD *)(a2 + 16) + v6;
      if ((*(_DWORD *)(v8 + 8) & 0x80000000) != 0)
      {
        re::HashTable<unsigned long,re::SessionTransferReport,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::addAsCopy(a1, *(_QWORD *)v8 % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)v8, (_QWORD *)(v8 + 16), (uint64_t *)(v8 + 24));
        v5 = *(unsigned int *)(a2 + 32);
      }
      v6 += 88;
    }
  }
}

uint64_t re::HashTable<unsigned long,re::SessionTransferReport,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, _QWORD *a4, uint64_t *a5)
{
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v10 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
    v10 = *(unsigned int *)(a1 + 32);
    v11 = v10;
    if ((_DWORD)v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<unsigned long,re::SessionTransferReport,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 88 * v10 + 8);
  }
  else
  {
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 88 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  v14 = 88 * v10;
  *(_DWORD *)(v12 + v14 + 8) = v13 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + v14 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + v14 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + v14) = a3;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + v14 + 16) = *a4;
  v15 = *(_QWORD *)(a1 + 16) + v14;
  v16 = *a5;
  *(_BYTE *)(v15 + 32) = *((_BYTE *)a5 + 8);
  *(_QWORD *)(v15 + 24) = v16;
  re::HashTable<unsigned long long,re::PeerTransferReport,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashTable(v15 + 40, (uint64_t)(a5 + 2));
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

uint64_t re::HashTable<unsigned long long,re::PeerTransferReport,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashTable(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  signed int v5;

  *(_DWORD *)(a1 + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_QWORD *)(a1 + 36) = 0x7FFFFFFFLL;
  v4 = *(_QWORD *)a2;
  if (v4)
  {
    if (*(_DWORD *)(a2 + 28) <= 3u)
      v5 = 3;
    else
      v5 = *(_DWORD *)(a2 + 28);
    re::HashTable<unsigned long long,re::PeerTransferReport,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init(a1, v4, v5);
    re::HashTable<unsigned long long,re::PeerTransferReport,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::copy(a1, a2);
  }
  return a1;
}

void re::HashTable<unsigned long long,re::PeerTransferReport,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::copy(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t i;
  uint64_t v8;

  re::HashTable<unsigned long long,re::PeerTransferReport,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::clear(a1);
  v4 = *(_DWORD *)(a2 + 28);
  if (*(_DWORD *)(a1 + 24) < v4)
    re::HashTable<unsigned long long,re::PeerTransferReport,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, v4);
  v5 = *(unsigned int *)(a2 + 32);
  if ((_DWORD)v5)
  {
    v6 = 0;
    for (i = 0; i < v5; ++i)
    {
      v8 = *(_QWORD *)(a2 + 16) + v6;
      if ((*(_DWORD *)(v8 + 8) & 0x80000000) != 0)
      {
        re::HashTable<unsigned long long,re::PeerTransferReport,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsCopy(a1, *(_QWORD *)v8 % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)v8, (_QWORD *)(v8 + 16), (_QWORD *)(v8 + 24));
        v5 = *(unsigned int *)(a2 + 32);
      }
      v6 += 128;
    }
  }
}

uint64_t re::HashTable<unsigned long long,re::PeerTransferReport,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, _QWORD *a4, _QWORD *a5)
{
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;

  v10 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
    v10 = *(unsigned int *)(a1 + 32);
    v11 = v10;
    if ((_DWORD)v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<unsigned long long,re::PeerTransferReport,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + (v10 << 7) + 8);
  }
  else
  {
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + (v10 << 7) + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + (v10 << 7) + 8) = v13 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + (v10 << 7) + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + (v10 << 7) + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + (v10 << 7)) = a3;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + (v10 << 7) + 16) = *a4;
  v14 = *(_QWORD *)(a1 + 16) + (v10 << 7);
  *(_QWORD *)(v14 + 24) = *a5;
  re::HashTable<unsigned long long,re::TransferStats,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashTable(v14 + 32, (uint64_t)(a5 + 1));
  re::HashTable<re::InstanceParentTypeTuple,re::TransferStats,re::Hash<re::InstanceParentTypeTuple>,re::EqualTo<re::InstanceParentTypeTuple>,true,false>::HashTable(v14 + 80, (uint64_t)(a5 + 7));
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

uint64_t re::HashTable<unsigned long long,re::TransferStats,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashTable(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  signed int v5;

  *(_DWORD *)(a1 + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_QWORD *)(a1 + 36) = 0x7FFFFFFFLL;
  v4 = *(_QWORD *)a2;
  if (v4)
  {
    if (*(_DWORD *)(a2 + 28) <= 3u)
      v5 = 3;
    else
      v5 = *(_DWORD *)(a2 + 28);
    re::HashTable<unsigned long long,re::TransferStats,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init(a1, v4, v5);
    re::HashTable<unsigned long long,re::TransferStats,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::copy(a1, a2);
  }
  return a1;
}

void re::HashTable<unsigned long long,re::TransferStats,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 40 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &memset_pattern_29, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

void re::HashTable<unsigned long long,re::TransferStats,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::copy(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t i;
  uint64_t v8;

  re::HashTable<unsigned long long,re::TransferStats,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::clear(a1);
  v4 = *(_DWORD *)(a2 + 28);
  if (*(_DWORD *)(a1 + 24) < v4)
    re::HashTable<unsigned long long,re::TransferStats,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, v4);
  v5 = *(unsigned int *)(a2 + 32);
  if ((_DWORD)v5)
  {
    v6 = 0;
    for (i = 0; i < v5; ++i)
    {
      v8 = *(_QWORD *)(a2 + 16) + v6;
      if ((*(_DWORD *)(v8 + 8) & 0x80000000) != 0)
      {
        re::HashTable<unsigned long long,re::TransferStats,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsCopy(a1, *(_QWORD *)v8 % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)v8, (_QWORD *)(v8 + 16), (_OWORD *)(v8 + 24));
        v5 = *(unsigned int *)(a2 + 32);
      }
      v6 += 40;
    }
  }
}

void re::HashTable<unsigned long long,re::TransferStats,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  unsigned int v7;
  __int128 v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  signed int v12;
  _BYTE v13[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(_QWORD *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<unsigned long long,re::TransferStats,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init((uint64_t)v13, v4, a2);
      v5 = *(_OWORD *)v13;
      *(_OWORD *)v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      v6 = *(_QWORD *)&v13[16];
      *(_QWORD *)&v13[16] = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 16) = v6;
      v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      v9 = v7;
      if (v7)
      {
        v10 = 0;
        v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(_QWORD *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<unsigned long long,re::TransferStats,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsCopy(a1, *(_QWORD *)(*(_QWORD *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(*(_QWORD *)&v13[16] + v10), *(_QWORD *)&v13[16] + v10 + 16, *(_QWORD *)&v13[16] + v10 + 24);
            v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 40;
        }
        while (v11 < v9);
      }
      re::HashTable<re::AssetType const*,std::pair<unsigned long,unsigned long>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2)
      v12 = a2;
    else
      v12 = 3;
  }
}

uint64_t re::HashTable<unsigned long long,re::TransferStats,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, _QWORD *a4, _OWORD *a5)
{
  uint64_t v9;
  int v10;
  uint64_t v11;
  int v12;

  v9 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
    v9 = *(unsigned int *)(a1 + 32);
    v10 = v9;
    if ((_DWORD)v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<unsigned long long,re::TransferStats,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 40 * v9 + 8);
  }
  else
  {
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 40 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v11 + 40 * v9 + 8) = v12 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 40 * v9 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 40 * v9 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 40 * v9) = a3;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 40 * v9 + 16) = *a4;
  *(_OWORD *)(*(_QWORD *)(a1 + 16) + 40 * v9 + 24) = *a5;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

uint64_t re::HashTable<re::InstanceParentTypeTuple,re::TransferStats,re::Hash<re::InstanceParentTypeTuple>,re::EqualTo<re::InstanceParentTypeTuple>,true,false>::HashTable(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  signed int v5;

  *(_DWORD *)(a1 + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_QWORD *)(a1 + 36) = 0x7FFFFFFFLL;
  v4 = *(_QWORD *)a2;
  if (v4)
  {
    if (*(_DWORD *)(a2 + 28) <= 3u)
      v5 = 3;
    else
      v5 = *(_DWORD *)(a2 + 28);
    re::HashTable<re::InstanceParentTypeTuple,re::TransferStats,re::Hash<re::InstanceParentTypeTuple>,re::EqualTo<re::InstanceParentTypeTuple>,true,false>::init(a1, v4, v5);
    re::HashTable<re::InstanceParentTypeTuple,re::TransferStats,re::Hash<re::InstanceParentTypeTuple>,re::EqualTo<re::InstanceParentTypeTuple>,true,false>::copy(a1, a2);
  }
  return a1;
}

void re::HashTable<re::InstanceParentTypeTuple,re::TransferStats,re::Hash<re::InstanceParentTypeTuple>,re::EqualTo<re::InstanceParentTypeTuple>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 56 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &memset_pattern_10, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

void re::HashTable<re::InstanceParentTypeTuple,re::TransferStats,re::Hash<re::InstanceParentTypeTuple>,re::EqualTo<re::InstanceParentTypeTuple>,true,false>::copy(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t i;
  uint64_t v8;

  re::HashTable<re::InstanceParentTypeTuple,re::TransferStats,re::Hash<re::InstanceParentTypeTuple>,re::EqualTo<re::InstanceParentTypeTuple>,true,false>::clear(a1);
  v4 = *(_DWORD *)(a2 + 28);
  if (*(_DWORD *)(a1 + 24) < v4)
    re::HashTable<re::InstanceParentTypeTuple,re::TransferStats,re::Hash<re::InstanceParentTypeTuple>,re::EqualTo<re::InstanceParentTypeTuple>,true,false>::setCapacity(a1, v4);
  v5 = *(unsigned int *)(a2 + 32);
  if ((_DWORD)v5)
  {
    v6 = 0;
    for (i = 0; i < v5; ++i)
    {
      v8 = *(_QWORD *)(a2 + 16) + v6;
      if ((*(_DWORD *)(v8 + 8) & 0x80000000) != 0)
      {
        re::HashTable<re::InstanceParentTypeTuple,re::TransferStats,re::Hash<re::InstanceParentTypeTuple>,re::EqualTo<re::InstanceParentTypeTuple>,true,false>::addAsCopy(a1, *(_QWORD *)v8 % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)v8, (__int128 *)(v8 + 16), (_OWORD *)(v8 + 40));
        v5 = *(unsigned int *)(a2 + 32);
      }
      v6 += 56;
    }
  }
}

void re::HashTable<re::InstanceParentTypeTuple,re::TransferStats,re::Hash<re::InstanceParentTypeTuple>,re::EqualTo<re::InstanceParentTypeTuple>,true,false>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;

  if (*(_DWORD *)(a1 + 28))
  {
    v2 = *(unsigned int *)(a1 + 24);
    if ((_DWORD)v2)
      memset_pattern16(*(void **)(a1 + 8), &memset_pattern_10, 4 * v2);
    v3 = *(unsigned int *)(a1 + 32);
    if ((_DWORD)v3)
    {
      v4 = 0;
      v5 = 56 * v3;
      do
      {
        v6 = *(_QWORD *)(a1 + 16) + v4;
        v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
        v4 += 56;
      }
      while (v5 != v4);
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    v8 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v8;
  }
}

void re::HashTable<re::InstanceParentTypeTuple,re::TransferStats,re::Hash<re::InstanceParentTypeTuple>,re::EqualTo<re::InstanceParentTypeTuple>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  unsigned int v7;
  __int128 v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  signed int v12;
  _BYTE v13[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(_QWORD *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::InstanceParentTypeTuple,re::TransferStats,re::Hash<re::InstanceParentTypeTuple>,re::EqualTo<re::InstanceParentTypeTuple>,true,false>::init((uint64_t)v13, v4, a2);
      v5 = *(_OWORD *)v13;
      *(_OWORD *)v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      v6 = *(_QWORD *)&v13[16];
      *(_QWORD *)&v13[16] = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 16) = v6;
      v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      v9 = v7;
      if (v7)
      {
        v10 = 0;
        v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(_QWORD *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<re::InstanceParentTypeTuple,re::TransferStats,re::Hash<re::InstanceParentTypeTuple>,re::EqualTo<re::InstanceParentTypeTuple>,true,false>::addAsCopy(a1, *(_QWORD *)(*(_QWORD *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(*(_QWORD *)&v13[16] + v10), *(_QWORD *)&v13[16] + v10 + 16, *(_QWORD *)&v13[16] + v10 + 40);
            v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 56;
        }
        while (v11 < v9);
      }
      re::HashTable<re::Pair<re::StringSlice,re::StringSlice,true>,unsigned long,re::Hash<re::Pair<re::StringSlice,re::StringSlice,true>>,re::EqualTo<re::Pair<re::StringSlice,re::StringSlice,true>>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2)
      v12 = a2;
    else
      v12 = 3;
  }
}

uint64_t re::HashTable<re::InstanceParentTypeTuple,re::TransferStats,re::Hash<re::InstanceParentTypeTuple>,re::EqualTo<re::InstanceParentTypeTuple>,true,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, __int128 *a4, _OWORD *a5)
{
  uint64_t v9;
  int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  __int128 v14;

  v9 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
    v9 = *(unsigned int *)(a1 + 32);
    v10 = v9;
    if ((_DWORD)v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::InstanceParentTypeTuple,re::TransferStats,re::Hash<re::InstanceParentTypeTuple>,re::EqualTo<re::InstanceParentTypeTuple>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 56 * v9 + 8);
  }
  else
  {
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 56 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v11 + 56 * v9 + 8) = v12 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 56 * v9 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 56 * v9 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 56 * v9) = a3;
  v13 = *(_QWORD *)(a1 + 16) + 56 * v9;
  v14 = *a4;
  *(_QWORD *)(v13 + 32) = *((_QWORD *)a4 + 2);
  *(_OWORD *)(v13 + 16) = v14;
  *(_OWORD *)(*(_QWORD *)(a1 + 16) + 56 * v9 + 40) = *a5;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

BOOL re::zerocopy::MemoryReadStream::nextRead(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 16);
  v3 = *(_QWORD *)(a1 + 24) - v2;
  *a2 = v2;
  a2[1] = v3;
  return v3 != 0;
}

uint64_t re::zerocopy::MemoryReadStream::advanceRead(uint64_t this, unint64_t a2)
{
  uint64_t v2;
  unint64_t v3;

  v2 = *(_QWORD *)(this + 16);
  v3 = *(_QWORD *)(this + 24) - v2;
  if (v3 >= a2)
    v3 = a2;
  *(_QWORD *)(this + 16) = v2 + v3;
  return this;
}

void re::zerocopy::MemoryReadStream::~MemoryReadStream(re::zerocopy::MemoryReadStream *this)
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::TransferReportWriter::write(re::zerocopy ***a1, uint64_t a2)
{
  re::zerocopy **v4;
  re::zerocopy **v5;
  re::zerocopy **v6;
  re::zerocopy **v7;
  re::zerocopy **v8;
  uint64_t result;
  uint64_t v10;
  int *v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char v16;
  unsigned int v17;
  uint64_t v18;
  int *v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int *v26;
  uint64_t v27;
  int *v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  unsigned int *v36;
  int v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int *v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t *v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  int v51;
  int v52;
  int v53;
  unsigned int v54;
  int v55;
  unsigned int v56;
  uint64_t v57;
  uint64_t v58;
  _DWORD *v59;
  int v60;
  uint64_t *v61;
  int *v62;
  uint64_t v63;
  _DWORD *v64;
  uint64_t v65;
  char v66;

  v4 = *a1;
  v66 = -30;
  re::zerocopy::writeAll(*v4, (re::zerocopy::WriteStream *)&v66, (char *)1);
  v5 = *a1;
  v66 = 8;
  re::zerocopy::writeAll(*v5, (re::zerocopy::WriteStream *)&v66, (char *)1);
  v6 = *a1;
  v66 = -30;
  re::zerocopy::writeAll(*v6, (re::zerocopy::WriteStream *)&v66, (char *)1);
  v66 = 8;
  re::zerocopy::writeAll(*v6, (re::zerocopy::WriteStream *)&v66, (char *)1);
  re::OPackWriter::writeFloat64(v6, *(double *)a2);
  v66 = 9;
  re::zerocopy::writeAll(*v6, (re::zerocopy::WriteStream *)&v66, (char *)1);
  re::OPackWriter::writeFloat64(v6, *(double *)(a2 + 8));
  v7 = *a1;
  v66 = 9;
  re::zerocopy::writeAll(*v7, (re::zerocopy::WriteStream *)&v66, (char *)1);
  v8 = *a1;
  result = re::OPackWriter::writeDictionaryBegin(v8, *(unsigned int *)(a2 + 44));
  v58 = *(unsigned int *)(a2 + 48);
  v10 = 0;
  if ((_DWORD)v58)
  {
    v11 = (int *)(*(_QWORD *)(a2 + 32) + 8);
    while (1)
    {
      v12 = *v11;
      v11 += 22;
      if (v12 < 0)
        break;
      if (v58 == ++v10)
      {
        LODWORD(v10) = *(_DWORD *)(a2 + 48);
        break;
      }
    }
  }
  if ((_DWORD)v58 != (_DWORD)v10)
  {
    v13 = v10;
    v14 = *(_QWORD *)(a2 + 32);
    v57 = a2;
    do
    {
      v15 = v14 + 88 * v13;
      re::OPackWriter::writeInteger(v8, *(_QWORD *)(v15 + 16));
      v66 = -29;
      re::zerocopy::writeAll(*v8, (re::zerocopy::WriteStream *)&v66, (char *)1);
      v66 = 8;
      re::zerocopy::writeAll(*v8, (re::zerocopy::WriteStream *)&v66, (char *)1);
      re::OPackWriter::writeInteger(v8, *(_QWORD *)(v15 + 24));
      v66 = 9;
      re::zerocopy::writeAll(*v8, (re::zerocopy::WriteStream *)&v66, (char *)1);
      if (*(_BYTE *)(v15 + 32))
        v16 = 1;
      else
        v16 = 2;
      v66 = v16;
      re::zerocopy::writeAll(*v8, (re::zerocopy::WriteStream *)&v66, (char *)1);
      v66 = 10;
      re::zerocopy::writeAll(*v8, (re::zerocopy::WriteStream *)&v66, (char *)1);
      result = re::OPackWriter::writeDictionaryBegin(v8, *(unsigned int *)(v15 + 68));
      v17 = *(_DWORD *)(v15 + 72);
      v62 = (int *)(v15 + 72);
      v63 = v17;
      v59 = (_DWORD *)(v15 + 68);
      v60 = v10;
      if (v17)
      {
        v18 = 0;
        v19 = (int *)(*(_QWORD *)(v14 + 88 * v13 + 56) + 8);
        while (1)
        {
          v20 = *v19;
          v19 += 32;
          if (v20 < 0)
            break;
          if (v63 == ++v18)
          {
            LODWORD(v18) = v63;
            break;
          }
        }
      }
      else
      {
        LODWORD(v18) = 0;
      }
      if ((_DWORD)v63 != (_DWORD)v18)
      {
        v21 = v18;
        v22 = v14 + 88 * v13;
        v23 = *(_QWORD *)(v22 + 56);
        v61 = (uint64_t *)(v22 + 56);
        do
        {
          v24 = v23 + (v21 << 7);
          re::OPackWriter::writeInteger(v8, *(_QWORD *)(v24 + 16));
          v66 = -29;
          re::zerocopy::writeAll(*v8, (re::zerocopy::WriteStream *)&v66, (char *)1);
          v66 = 8;
          re::zerocopy::writeAll(*v8, (re::zerocopy::WriteStream *)&v66, (char *)1);
          re::OPackWriter::writeInteger(v8, *(_QWORD *)(v24 + 24));
          v66 = 9;
          re::zerocopy::writeAll(*v8, (re::zerocopy::WriteStream *)&v66, (char *)1);
          v64 = (_DWORD *)(v24 + 60);
          re::OPackWriter::writeDictionaryBegin(v8, *(unsigned int *)(v24 + 60));
          v26 = (int *)(v24 + 64);
          v25 = *(unsigned int *)(v24 + 64);
          v65 = v23;
          v27 = 0;
          if ((_DWORD)v25)
          {
            v28 = (int *)(*(_QWORD *)(v24 + 48) + 8);
            while (1)
            {
              v29 = *v28;
              v28 += 10;
              if (v29 < 0)
                break;
              if (v25 == ++v27)
              {
                LODWORD(v27) = *(_DWORD *)(v24 + 64);
                break;
              }
            }
          }
          if ((_DWORD)v25 != (_DWORD)v27)
          {
            v30 = v27;
            v31 = v23 + (v21 << 7);
            v34 = *(_QWORD *)(v31 + 48);
            v33 = (uint64_t *)(v31 + 48);
            v32 = v34;
            do
            {
              v35 = v32 + 40 * v30;
              v36 = (unsigned int *)(v35 + 24);
              re::OPackWriter::writeInteger(v8, *(_QWORD *)(v35 + 16));
              v32 = *v33;
              if (*v26 <= (v27 + 1))
                v37 = v27 + 1;
              else
                v37 = *v26;
              v38 = v27;
              while (1)
              {
                v30 = (v38 + 1);
                if (v37 - 1 == v38)
                  break;
                ++v38;
                LODWORD(v27) = v30;
                if ((*(_DWORD *)(v32 + 40 * v30 + 8) & 0x80000000) != 0)
                  goto LABEL_34;
              }
              LODWORD(v27) = v37;
LABEL_34:
              ;
            }
            while ((_DWORD)v25 != (_DWORD)v27);
          }
          if (*v64 >= 0xFu)
          {
            v66 = 3;
            re::zerocopy::writeAll(*v8, (re::zerocopy::WriteStream *)&v66, (char *)1);
          }
          v66 = 10;
          re::zerocopy::writeAll(*v8, (re::zerocopy::WriteStream *)&v66, (char *)1);
          v39 = v65 + (v21 << 7);
          result = re::OPackWriter::writeDictionaryBegin(v8, *(unsigned int *)(v39 + 108));
          v40 = *(unsigned int *)(v39 + 112);
          if ((_DWORD)v40)
          {
            v41 = 0;
            v42 = (int *)(*(_QWORD *)(v39 + 96) + 8);
            while (1)
            {
              v43 = *v42;
              v42 += 14;
              if (v43 < 0)
                break;
              if (v40 == ++v41)
              {
                LODWORD(v41) = *(_DWORD *)(v39 + 112);
                break;
              }
            }
          }
          else
          {
            LODWORD(v41) = 0;
          }
          if ((_DWORD)v40 != (_DWORD)v41)
          {
            v44 = v41;
            v45 = v65 + (v21 << 7);
            v48 = *(_QWORD *)(v45 + 96);
            v47 = (uint64_t *)(v45 + 96);
            v46 = v48;
            do
            {
              v49 = v46 + 56 * v44;
              v66 = -45;
              re::zerocopy::writeAll(*v8, (re::zerocopy::WriteStream *)&v66, (char *)1);
              re::OPackWriter::writeInteger(v8, *(_QWORD *)(v49 + 16));
              re::OPackWriter::writeInteger(v8, *(_QWORD *)(v49 + 24));
              re::OPackWriter::writeInteger(v8, *(_QWORD *)(v49 + 32));
              v46 = *v47;
              if (*(_DWORD *)(v39 + 112) <= (v41 + 1))
                v50 = v41 + 1;
              else
                v50 = *(_DWORD *)(v39 + 112);
              v51 = v41;
              while (1)
              {
                v44 = (v51 + 1);
                if (v50 - 1 == v51)
                  break;
                ++v51;
                LODWORD(v41) = v44;
                if ((*(_DWORD *)(v46 + 56 * v44 + 8) & 0x80000000) != 0)
                  goto LABEL_53;
              }
              LODWORD(v41) = v50;
LABEL_53:
              ;
            }
            while ((_DWORD)v40 != (_DWORD)v41);
          }
          if (*(_DWORD *)(v39 + 108) >= 0xFu)
          {
            v66 = 3;
            result = re::zerocopy::writeAll(*v8, (re::zerocopy::WriteStream *)&v66, (char *)1);
          }
          v52 = *v62;
          v23 = *v61;
          if (*v62 <= (v18 + 1))
            v52 = v18 + 1;
          while (1)
          {
            v21 = (v18 + 1);
            if (v52 - 1 == (_DWORD)v18)
              break;
            LODWORD(v18) = v18 + 1;
            v53 = v21;
            if ((*(_DWORD *)(v23 + (v21 << 7) + 8) & 0x80000000) != 0)
              goto LABEL_62;
          }
          v53 = v52;
LABEL_62:
          LODWORD(v18) = v53;
        }
        while ((_DWORD)v63 != v53);
      }
      if (*v59 >= 0xFu)
      {
        v66 = 3;
        result = re::zerocopy::writeAll(*v8, (re::zerocopy::WriteStream *)&v66, (char *)1);
      }
      a2 = v57;
      v54 = *(_DWORD *)(v57 + 48);
      v14 = *(_QWORD *)(v57 + 32);
      v55 = v60;
      if (v54 <= v60 + 1)
        v54 = v60 + 1;
      while (1)
      {
        v13 = (v55 + 1);
        if (v54 - 1 == v55)
          break;
        ++v55;
        v56 = v13;
        if ((*(_DWORD *)(v14 + 88 * v13 + 8) & 0x80000000) != 0)
          goto LABEL_71;
      }
      v56 = v54;
LABEL_71:
      LODWORD(v10) = v56;
    }
    while ((_DWORD)v58 != v56);
  }
  if (*(_DWORD *)(a2 + 44) >= 0xFu)
  {
    v66 = 3;
    return re::zerocopy::writeAll(*v8, (re::zerocopy::WriteStream *)&v66, (char *)1);
  }
  return result;
}

uint64_t re::TransferReportReader::read(re::OPackReader **a1, _QWORD *a2)
{
  re::OPackReader *v4;
  uint64_t result;
  uint64_t v6;
  re::OPackReader *v7;
  uint64_t v8;
  re::OPackReader *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char v38;
  uint64_t v39[4];
  int v40;
  uint64_t v41;
  _BYTE v42[44];
  uint64_t v43;
  uint64_t v44[4];
  int v45;
  uint64_t v46;
  uint64_t v47;
  __int128 v48;
  __int128 v49;
  uint64_t v50;

  v4 = *a1;
  result = re::OPackReader::next(*a1, (uint64_t)a2);
  if ((_DWORD)result)
  {
    if (*((_BYTE *)v4 + 196) != 13)
      return 0;
    v7 = *a1;
    if (!re::OPackReader::next(*a1, v6))
      return *((unsigned __int8 *)*a1 + 184) == 5;
    while (1)
    {
      if (*((_BYTE *)v7 + 196) != 6)
        return *((unsigned __int8 *)*a1 + 184) == 5;
      if (*((_BYTE *)v7 + 224) == 1)
        break;
      if (!*((_BYTE *)v7 + 224))
      {
        v9 = *a1;
        result = re::OPackReader::next(*a1, v8);
        if (!(_DWORD)result)
          return result;
        if (*((_BYTE *)v9 + 196) != 13)
          return 0;
        if (re::OPackReader::next(v9, v10))
        {
          while (*((_BYTE *)v9 + 196) == 6)
          {
            if (*((_BYTE *)v9 + 224) == 1)
            {
              result = re::OPackReader::next(v9, v11);
              if (!(_DWORD)result)
                return result;
              if (*((_BYTE *)v9 + 196) != 8)
                return 0;
              a2[1] = *((_QWORD *)v9 + 28);
            }
            else if (*((_BYTE *)v9 + 224))
            {
              re::OPackReader::next(v9, v11);
            }
            else
            {
              result = re::OPackReader::next(v9, v11);
              if (!(_DWORD)result)
                return result;
              if (*((_BYTE *)v9 + 196) != 8)
                return 0;
              *a2 = *((_QWORD *)v9 + 28);
            }
            if ((re::OPackReader::next(v9, v12) & 1) == 0)
              break;
          }
        }
LABEL_89:
        if (*((_BYTE *)v9 + 184) != 5)
          return 0;
        goto LABEL_92;
      }
      re::OPackReader::next(*a1, v8);
LABEL_92:
      v7 = *a1;
      if ((re::OPackReader::next(*a1, v11) & 1) == 0)
        return *((unsigned __int8 *)*a1 + 184) == 5;
    }
    v9 = *a1;
    result = re::OPackReader::next(*a1, v8);
    if (!(_DWORD)result)
      return result;
    if (*((_BYTE *)v9 + 196) != 13)
      return 0;
    v14 = re::OPackReader::next(v9, v13);
    if (!(_DWORD)v14)
      goto LABEL_89;
    while (1)
    {
      if (*((_BYTE *)v9 + 196) != 6)
        goto LABEL_89;
      v15 = *((_QWORD *)v9 + 28);
      v37 = 0;
      v38 = 0;
      memset(v39, 0, sizeof(v39));
      v40 = 0;
      v41 = 0x7FFFFFFFLL;
      if (!re::OPackReader::next(v9, v16) || *((_BYTE *)v9 + 196) != 13)
        goto LABEL_95;
      if (re::OPackReader::next(v9, v17))
        break;
LABEL_87:
      if (*((_BYTE *)v9 + 184) != 5)
      {
LABEL_95:
        re::HashTable<unsigned long long,re::PeerTransferReport,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit(v39);
        return 0;
      }
      *(_QWORD *)v42 = v15;
      re::HashTable<unsigned long,re::SessionTransferReport,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::addNew((uint64_t)(a2 + 2), (uint64_t *)v42, &v37);
      re::HashTable<unsigned long long,re::PeerTransferReport,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit(v39);
      v14 = re::OPackReader::next(v9, v36);
      if ((v14 & 1) == 0)
        goto LABEL_89;
    }
    while (1)
    {
      if (*((_BYTE *)v9 + 196) != 6)
        goto LABEL_87;
      v19 = *((unsigned __int8 *)v9 + 224);
      if (v19 == 2)
        break;
      if (v19 == 1)
      {
        if (!re::OPackReader::next(v9, v18) || *((_BYTE *)v9 + 196) != 2)
          goto LABEL_95;
        v38 = *((_BYTE *)v9 + 224);
      }
      else if (*((_BYTE *)v9 + 224))
      {
        re::OPackReader::next(v9, v18);
      }
      else
      {
        if (!re::OPackReader::next(v9, v18) || *((_BYTE *)v9 + 196) != 6)
          goto LABEL_95;
        v37 = *((_QWORD *)v9 + 28);
      }
LABEL_86:
      if ((re::OPackReader::next(v9, v20) & 1) == 0)
        goto LABEL_87;
    }
    if (!re::OPackReader::next(v9, v18) || *((_BYTE *)v9 + 196) != 13)
      goto LABEL_95;
    v47 = 0;
    v22 = re::OPackReader::next(v9, v21);
    if ((_DWORD)v22)
    {
      do
      {
        if (*((_BYTE *)v9 + 196) != 6)
          break;
        v47 = *((_QWORD *)v9 + 28);
        memset(v42, 0, sizeof(v42));
        v43 = 0x7FFFFFFFLL;
        memset(v44, 0, sizeof(v44));
        v45 = 0;
        v46 = 0x7FFFFFFFLL;
        if (!re::OPackReader::next(v9, v23) || *((_BYTE *)v9 + 196) != 13)
          goto LABEL_94;
        if (re::OPackReader::next(v9, v24))
        {
          while (1)
          {
            if (*((_BYTE *)v9 + 196) != 6)
              goto LABEL_78;
            v26 = *((unsigned __int8 *)v9 + 224);
            if (v26 == 2)
              break;
            if (v26 == 1)
            {
              if (!re::OPackReader::next(v9, v25) || *((_BYTE *)v9 + 196) != 13)
                goto LABEL_94;
              *(_QWORD *)&v48 = 0;
              if (re::OPackReader::next(v9, v33))
              {
                do
                {
                  if (*((_BYTE *)v9 + 196) != 6)
                    break;
                  *(_QWORD *)&v48 = *((_QWORD *)v9 + 28);
                  v49 = 0uLL;
                    goto LABEL_94;
                  re::HashTable<unsigned long long,re::TransferStats,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)&v42[8], (uint64_t *)&v48, &v49);
                }
                while ((re::OPackReader::next(v9, v34) & 1) != 0);
              }
LABEL_74:
              if (*((_BYTE *)v9 + 184) != 5)
                goto LABEL_94;
              goto LABEL_77;
            }
            if (*((_BYTE *)v9 + 224))
            {
              re::OPackReader::next(v9, v25);
            }
            else
            {
              if (!re::OPackReader::next(v9, v25) || *((_BYTE *)v9 + 196) != 6)
                goto LABEL_94;
              *(_QWORD *)v42 = *((_QWORD *)v9 + 28);
            }
LABEL_77:
            if ((re::OPackReader::next(v9, v27) & 1) == 0)
              goto LABEL_78;
          }
          if (!re::OPackReader::next(v9, v25) || *((_BYTE *)v9 + 196) != 13)
            goto LABEL_94;
          if (re::OPackReader::next(v9, v28))
          {
            while (*((_BYTE *)v9 + 196) == 12)
            {
              v49 = 0uLL;
              v50 = 0;
              if (re::OPackReader::next(v9, v27) && *((_BYTE *)v9 + 196) == 6)
                *(_QWORD *)&v49 = *((_QWORD *)v9 + 28);
              if (re::OPackReader::next(v9, v29) && *((_BYTE *)v9 + 196) == 6)
                *((_QWORD *)&v49 + 1) = *((_QWORD *)v9 + 28);
              if (re::OPackReader::next(v9, v30) && *((_BYTE *)v9 + 196) == 6)
                v50 = *((_QWORD *)v9 + 28);
              if (!re::OPackReader::next(v9, v31))
                goto LABEL_94;
              if (*((_BYTE *)v9 + 184) != 3)
                goto LABEL_94;
              v48 = 0uLL;
                goto LABEL_94;
              re::HashTable<re::InstanceParentTypeTuple,re::TransferStats,re::Hash<re::InstanceParentTypeTuple>,re::EqualTo<re::InstanceParentTypeTuple>,true,false>::addNew((uint64_t)v44, &v49, &v48);
              if ((re::OPackReader::next(v9, v32) & 1) == 0)
                goto LABEL_74;
            }
          }
          goto LABEL_74;
        }
LABEL_78:
        if (*((_BYTE *)v9 + 184) != 5)
        {
LABEL_94:
          re::HashTable<re::Pair<re::StringSlice,re::StringSlice,true>,unsigned long,re::Hash<re::Pair<re::StringSlice,re::StringSlice,true>>,re::EqualTo<re::Pair<re::StringSlice,re::StringSlice,true>>,true,false>::deinit(v44);
          re::HashTable<re::AssetType const*,std::pair<unsigned long,unsigned long>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::deinit((uint64_t *)&v42[8]);
          goto LABEL_95;
        }
        re::HashTable<unsigned long long,re::PeerTransferReport,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)v39, &v47, v42);
        re::HashTable<re::Pair<re::StringSlice,re::StringSlice,true>,unsigned long,re::Hash<re::Pair<re::StringSlice,re::StringSlice,true>>,re::EqualTo<re::Pair<re::StringSlice,re::StringSlice,true>>,true,false>::deinit(v44);
        re::HashTable<re::AssetType const*,std::pair<unsigned long,unsigned long>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::deinit((uint64_t *)&v42[8]);
        v22 = re::OPackReader::next(v9, v35);
      }
      while ((v22 & 1) != 0);
    }
    if (*((_BYTE *)v9 + 184) != 5)
      goto LABEL_95;
    goto LABEL_86;
  }
  return result;
}

uint64_t re::`anonymous namespace'::writeTransferStats(re::zerocopy **a1, unsigned int *a2)
{
  char v5;
  char v6;
  char v7;
  char v8;
  char v9;

  v5 = -28;
  re::zerocopy::writeAll(*a1, (re::zerocopy::WriteStream *)&v5, (char *)1);
  v6 = 8;
  re::zerocopy::writeAll(*a1, (re::zerocopy::WriteStream *)&v6, (char *)1);
  re::OPackWriter::writeInteger(a1, *a2);
  v7 = 9;
  re::zerocopy::writeAll(*a1, (re::zerocopy::WriteStream *)&v7, (char *)1);
  re::OPackWriter::writeInteger(a1, a2[1]);
  v8 = 10;
  re::zerocopy::writeAll(*a1, (re::zerocopy::WriteStream *)&v8, (char *)1);
  re::OPackWriter::writeInteger(a1, a2[2]);
  v9 = 11;
  re::zerocopy::writeAll(*a1, (re::zerocopy::WriteStream *)&v9, (char *)1);
  return re::OPackWriter::writeInteger(a1, a2[3]);
}

BOOL re::`anonymous namespace'::readTransferStats(uint64_t a1, _DWORD *a2)
{
  uint64_t v4;
  int v5;
  _BOOL8 result;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  int v12;

  v5 = re::OPackReader::next((re::OPackReader *)a1, (uint64_t)a2);
  result = 0;
  if (v5 && *(_BYTE *)(a1 + 196) == 13)
  {
    if (re::OPackReader::next((re::OPackReader *)a1, v4) && *(_BYTE *)(a1 + 196) == 6)
    {
      while (2)
      {
        switch(*(_BYTE *)(a1 + 224))
        {
          case 0:
            v9 = re::OPackReader::next((re::OPackReader *)a1, v7);
            result = 0;
            if (v9 && *(_BYTE *)(a1 + 196) == 6)
            {
              *a2 = *(_QWORD *)(a1 + 224);
              goto LABEL_19;
            }
            break;
          case 1:
            v10 = re::OPackReader::next((re::OPackReader *)a1, v7);
            result = 0;
            if (v10 && *(_BYTE *)(a1 + 196) == 6)
            {
              a2[1] = *(_QWORD *)(a1 + 224);
              goto LABEL_19;
            }
            break;
          case 2:
            v11 = re::OPackReader::next((re::OPackReader *)a1, v7);
            result = 0;
            if (v11 && *(_BYTE *)(a1 + 196) == 6)
            {
              a2[2] = *(_QWORD *)(a1 + 224);
              goto LABEL_19;
            }
            break;
          case 3:
            v12 = re::OPackReader::next((re::OPackReader *)a1, v7);
            result = 0;
            if (v12 && *(_BYTE *)(a1 + 196) == 6)
            {
              a2[3] = *(_QWORD *)(a1 + 224);
              goto LABEL_19;
            }
            break;
          default:
            re::OPackReader::next((re::OPackReader *)a1, v7);
LABEL_19:
            if (!re::OPackReader::next((re::OPackReader *)a1, v8) || *(_BYTE *)(a1 + 196) != 6)
              return *(_BYTE *)(a1 + 184) == 5;
            continue;
        }
        break;
      }
    }
    else
    {
      return *(_BYTE *)(a1 + 184) == 5;
    }
  }
  return result;
}

void re::zerocopy::DispatchWriteStream::clear(re::zerocopy::DispatchWriteStream *this)
{
  NSObject *v2;
  NSObject *v3;

  v2 = *((_QWORD *)this + 1);
  if (v2)
  {
    dispatch_release(v2);
    *((_QWORD *)this + 1) = 0;
  }
  v3 = *((_QWORD *)this + 2);
  if (v3)
  {
    dispatch_release(v3);
    *((_QWORD *)this + 2) = 0;
  }
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
}

void re::zerocopy::DispatchWriteStream::~DispatchWriteStream(re::zerocopy::DispatchWriteStream *this)
{
  *(_QWORD *)this = &off_24ED7DDF0;
  re::zerocopy::DispatchWriteStream::clear(this);
}

{
  *(_QWORD *)this = &off_24ED7DDF0;
  re::zerocopy::DispatchWriteStream::clear(this);
  JUMPOUT(0x2276933B8);
}

void re::zerocopy::DispatchWriteStream::mergeTail(re::zerocopy::DispatchWriteStream *this)
{
  uint64_t v2;
  dispatch_object_t *v3;
  NSObject *subrange;
  NSObject *v5;
  dispatch_data_t concat;

  v2 = *((_QWORD *)this + 4);
  if (v2)
  {
    v3 = (dispatch_object_t *)((char *)this + 16);
    subrange = dispatch_data_create_subrange(*((dispatch_data_t *)this + 2), 0, *((_QWORD *)this + 5) - v2);
    if (!*v3)
      goto LABEL_6;
    dispatch_release(*v3);
  }
  else
  {
    v3 = (dispatch_object_t *)((char *)this + 16);
    subrange = *((_QWORD *)this + 2);
  }
  *v3 = 0;
LABEL_6:
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  v5 = *((_QWORD *)this + 1);
  if (v5)
  {
    concat = dispatch_data_create_concat(v5, subrange);
    dispatch_release(*((dispatch_object_t *)this + 1));
    *((_QWORD *)this + 1) = concat;
    dispatch_release(subrange);
  }
  else
  {
    *((_QWORD *)this + 1) = subrange;
  }
}

uint64_t re::zerocopy::DispatchWriteStream::nextWrite(re::zerocopy::DispatchWriteStream *this, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;

  v4 = *((_QWORD *)this + 4);
  if (!v4)
  {
    re::zerocopy::DispatchWriteStream::mergeTail(this);
    v5 = (unint64_t)(2 * *((_QWORD *)this + 5)) <= 0x1000 ? 4096 : 2 * *((_QWORD *)this + 5);
    *((_QWORD *)this + 4) = v5;
    *((_QWORD *)this + 5) = v5;
    *((_QWORD *)this + 2) = dispatch_data_create_alloc();
    v4 = *((_QWORD *)this + 4);
    if (!v4)
      return 0;
  }
  *a2 = *((_QWORD *)this + 3);
  a2[1] = v4;
  return 1;
}

uint64_t re::zerocopy::DispatchWriteStream::advanceWrite(uint64_t this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;

  v2 = *(_QWORD *)(this + 32);
  if (v2 >= a2)
    v3 = a2;
  else
    v3 = *(_QWORD *)(this + 32);
  *(_QWORD *)(this + 24) += v3;
  *(_QWORD *)(this + 32) = v2 - v3;
  return this;
}

void re::Raft::init(uint64_t a1@<X0>, uint64_t **a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int8x16_t v13;
  uint64_t *v14;
  uint64_t v15;
  __n128 v16;
  uint64_t *v17;
  uint64_t v18;
  __n128 v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t v31;
  _BYTE *v32;
  uint64_t *v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  __int128 v37;
  _OWORD v38[5];
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  char v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  char v46[2];
  uint64_t v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  _QWORD v51[2];
  uint64_t v52;
  int v53;
  uint64_t *v54;
  char v55;
  _BYTE v56[32];
  __int128 v57;
  _BYTE v58[32];
  __int128 v59;
  unint64_t v60;
  uint64_t v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  _BYTE v81[32];
  __int128 v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  int v86;
  __int128 v87;
  __int128 v88;
  int v89;
  _BYTE v90[32];
  __int128 v91;
  uint64_t v92;
  _BYTE v93[40];
  __int128 v94;
  char v95;
  _BYTE v96[8];
  _BYTE v97[304];
  _BYTE v98[161];
  char v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  __int128 v103;
  _OWORD v104[4];
  uint64_t v105[11];
  char v106;
  uint64_t v107;
  __int128 v108;
  unint64_t v109;
  unint64_t v110;
  uint64_t *v111;
  uint64_t v112;
  uint64_t *v113;
  uint64_t v114;
  _BYTE v115[208];
  _BYTE v116[24];
  uint64_t v117;
  char v118;

  re::Config::validate((_anonymous_namespace_ *)a1, (uint64_t)v116);
  if (v116[0])
  {
    (*(void (**)(uint64_t *__return_ptr))(**a2 + 16))(&v114);
    if (!(_BYTE)v114)
    {
      *a3 = 0;
      a3[8] = 1;
      goto LABEL_63;
    }
    v32 = a3;
    RaftState::RaftState((RaftState *)v105, (const RaftState *)v115);
    v82 = 0u;
    v80 = 0u;
    memset(v81, 0, sizeof(v81));
    v78 = 0u;
    v79 = 0u;
    v76 = 0u;
    v77 = 0u;
    v74 = 0u;
    v75 = 0u;
    v72 = 0u;
    v73 = 0u;
    v70 = 0u;
    v71 = 0u;
    v68 = 0u;
    v69 = 0u;
    v66 = 0u;
    v67 = 0u;
    v64 = 0u;
    v65 = 0u;
    v62 = 0u;
    v63 = 0u;
    DWORD1(v82) = 0x7FFFFFFF;
    v85 = 0;
    v83 = 0;
    v84 = 0;
    v86 = 0;
    v87 = 0u;
    v88 = 0u;
    v89 = 0;
    v91 = 0u;
    v92 = 0;
    memset(v90, 0, sizeof(v90));
    v94 = 0u;
    HIDWORD(v91) = 0x7FFFFFFF;
    memset(v93, 0, sizeof(v93));
    v95 = 0;
    v96[0] = 0;
    v98[0] = 0;
    v99 = 0;
    memset(v104, 0, 53);
    v103 = 0u;
    v102 = 0u;
    v101 = 0u;
    v100 = 0u;
    re::HashTable<unsigned long long,BOOL,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity((uint64_t)v81, 0);
    *(_QWORD *)&v101 = *(_QWORD *)(a1 + 8);
    v6 = *a2;
    *a2 = 0;
    *((_QWORD *)&v37 + 1) = 0;
    v33 = v6;
    v34 = 0;
    v35 = 0;
    v36 = 0;
    LODWORD(v37) = 0;
    LOBYTE(v38[0]) = 0;
    v43 = 0;
    (*(void (**)(__int128 *__return_ptr))(*v6 + 32))(&v48);
    v7 = *((_QWORD *)&v48 + 1);
    (*(void (**)(__int128 *__return_ptr))(*v33 + 40))(&v48);
    v44 = v7 - 1;
    v45 = v7 - 1;
    v8 = *((_QWORD *)&v48 + 1) + 1;
    *(_QWORD *)&v50 = 0;
    *(_QWORD *)&v49 = 0;
    v48 = 0uLL;
    DWORD2(v49) = 0;
    BYTE8(v50) = 0;
    *(_QWORD *)&v59 = v8;
    re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=((uint64_t)&v34, (uint64_t)&v48);
    re::Optional<re::Snapshot>::operator=((unsigned __int8 *)v38, (uint64_t *)&v50 + 1);
    v43 = v59;
    re::Unstable::~Unstable((re::Unstable *)&v48);
    re::RaftLog::operator=((unsigned __int8 *)&v62, (uint64_t *)&v33);
    re::Unstable::~Unstable((re::Unstable *)&v34);
    v9 = v33;
    v33 = 0;
    if (v9)
      (*(void (**)(uint64_t *))(*v9 + 8))(v9);
    *(_QWORD *)&v103 = *(_QWORD *)(a1 + 24);
    v10 = v110;
    v11 = v112;
    v48 = 0u;
    v49 = 0u;
    LODWORD(v50) = 0;
    *(_QWORD *)((char *)&v50 + 4) = 0x7FFFFFFFLL;
    v54 = 0;
    v52 = 0;
    v51[0] = 0;
    v51[1] = 0;
    v53 = 0;
    v55 = 0;
    memset(v56, 0, sizeof(v56));
    v57 = 0u;
    memset(v58, 0, sizeof(v58));
    v59 = 0u;
    DWORD1(v57) = 0x7FFFFFFF;
    DWORD1(v59) = 0x7FFFFFFF;
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity((uint64_t)v56, v110);
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity((uint64_t)v58, v11);
    v60 = v10;
    v61 = v11;
    re::DynamicArray<double>::resize((uint64_t)v51, v10);
    LOBYTE(v33) = 1;
    re::ProgressSet::ProgressSet((uint64_t)&v34, (uint64_t)&v48);
    re::Optional<re::ProgressSet>::operator=(v96, (uint64_t *)&v33);
    if ((_BYTE)v33)
      re::ProgressSet::~ProgressSet((re::ProgressSet *)&v34);
    re::ProgressSet::~ProgressSet((re::ProgressSet *)&v48);
    *((_QWORD *)&v102 + 1) = 0;
    v95 = 0;
    LOBYTE(v104[3]) = 0;
    *(_WORD *)((char *)&v104[3] + 1) = *(_WORD *)(a1 + 64);
    re::ReadOnly::ReadOnly((uint64_t)&v33, (_BYTE *)a1);
    re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::operator=((uint64_t)&v90[8], (uint64_t *)&v33);
    re::Queue<re::DynamicArray<unsigned char>>::operator=((uint64_t *)v93, (uint64_t *)v38);
    BYTE8(v94) = v38[3];
    re::Queue<re::DynamicArray<unsigned char>>::deinit((uint64_t *)v38);
    re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::deinit((uint64_t *)&v33);
    *(int8x16_t *)((char *)v104 + 8) = vextq_s8(*(int8x16_t *)(a1 + 48), *(int8x16_t *)(a1 + 48), 8uLL);
    *((_QWORD *)&v101 + 1) = 0;
    if (v99)
      v99 = 0;
    *(_QWORD *)&v100 = 0;
    *((_QWORD *)&v103 + 1) = 0;
    *(_QWORD *)&v102 = 0;
    LOBYTE(v33) = 0;
    re::Optional<re::ConfChange>::operator=(v98, (unsigned __int8 *)&v33);
    if ((_BYTE)v33)
      re::ConfChange::~ConfChange((re::ConfChange *)&v34);
    *((_QWORD *)&v100 + 1) = 0;
    *(_QWORD *)&v104[0] = 0;
    *((_QWORD *)&v104[1] + 1) = 0;
    v13.i64[0] = *(_QWORD *)(a1 + 48);
    v13.i64[1] = 2 * v13.i64[0];
    v104[2] = vbslq_s8((int8x16_t)vceqzq_s64(*(int64x2_t *)(a1 + 32)), v13, *(int8x16_t *)(a1 + 32));
    *(_WORD *)((char *)&v104[3] + 3) = *(_WORD *)(a1 + 66);
    if (v110)
    {
      v14 = v111;
      v15 = 8 * v110;
      do
      {
        v34 = 0;
        v35 = 0;
        v33 = 0;
        LODWORD(v36) = 0;
        *(_QWORD *)&v38[0] = 0;
        v37 = 0uLL;
        *((_QWORD *)&v38[0] + 1) = v103;
        re::DynamicArray<float *>::setCapacity(&v33, v103);
        LOBYTE(v38[1]) = 0;
        *(_OWORD *)((char *)&v38[1] + 8) = xmmword_2260E7EE0;
        *((_QWORD *)&v38[2] + 1) = 0;
        *(_QWORD *)&v38[3] = 0;
        WORD4(v38[3]) = 0;
        v16.n128_f64[0] = re::ProgressSet::insertVoter((re::ProgressSet *)v97, (const re::Progress *)&v33, *v14, (uint64_t)&v48);
        if (!(_BYTE)v48 && *((_QWORD *)&v49 + 1) && (v50 & 1) != 0)
          (*(void (**)(double))(**((_QWORD **)&v49 + 1) + 40))(v16.n128_f64[0]);
        if (v33)
        {
          v12 = v37;
          if ((_QWORD)v37)
            (*(void (**)(__n128))(*v33 + 40))(v16);
        }
        ++v14;
        v15 -= 8;
      }
      while (v15);
    }
    if (v112)
    {
      v17 = v113;
      v18 = 8 * v112;
      do
      {
        v34 = 0;
        v35 = 0;
        v33 = 0;
        LODWORD(v36) = 0;
        *(_QWORD *)&v38[0] = 0;
        v37 = 0uLL;
        *((_QWORD *)&v38[0] + 1) = v103;
        re::DynamicArray<float *>::setCapacity(&v33, v103);
        LOBYTE(v38[1]) = 0;
        *(_OWORD *)((char *)&v38[1] + 8) = xmmword_2260E7EE0;
        *((_QWORD *)&v38[2] + 1) = 0;
        *(_QWORD *)&v38[3] = 0;
        WORD4(v38[3]) = 0;
        v19.n128_f64[0] = re::ProgressSet::insertLearner((re::ProgressSet *)v97, (const re::Progress *)&v33, *v17, (uint64_t)&v48);
        if (*v17 == (_QWORD)v101)
          LOBYTE(v104[3]) = 1;
        if (!(_BYTE)v48 && *((_QWORD *)&v49 + 1) && (v50 & 1) != 0)
          (*(void (**)(__n128))(**((_QWORD **)&v49 + 1) + 40))(v19);
        if (v33)
        {
          v12 = v37;
          if ((_QWORD)v37)
            (*(void (**)(__n128))(*v33 + 40))(v19);
        }
        ++v17;
        v18 -= 8;
      }
      while (v18);
    }
    v20 = v109;
    if ((_QWORD)v108 || __PAIR128__(*((unint64_t *)&v108 + 1), 0) != v109)
    {
      if (v109 < (unint64_t)v80
        || (!*((_QWORD *)&v63 + 1)
          ? (!(_BYTE)v65
           ? ((*(void (**)(uint64_t **__return_ptr))(*(_QWORD *)v62 + 40))(&v33), v21 = v34)
           : (v21 = *((_QWORD *)&v78 + 1)))
          : (v21 = *((_QWORD *)&v63 + 1) + *((_QWORD *)&v79 + 1) - 1),
            v20 > v21))
      {
        re::internal::assertLog((re::internal *)4, v12, "assertion failure: '%s' (%s:line %i) hs.commit is out of range", "!\"Unreachable code\"", "loadState", 149, v115);
        _os_crash();
        __break(1u);
        goto LABEL_69;
      }
      *(_QWORD *)&v80 = v109;
      v100 = v108;
    }
    v22 = *(_QWORD *)(a1 + 16);
    if (v22)
      re::Raft::commitApply((re::Raft *)&v62, v22);
    v23 = *((_QWORD *)&v102 + 1);
    re::Raft::reset((re::Raft *)&v62, v100);
    *((_QWORD *)&v101 + 1) = 0;
    v95 = 0;
    *((_QWORD *)&v102 + 1) = v23;
    re::Optional<re::ConfState>::Optional(&v48, v105);
    if (v106)
    {
      if ((_BYTE)v48)
      {
        v25 = v107;
        v33 = 0;
        v34 = 0;
        LODWORD(v36) = 0;
        v35 = 0;
        v37 = 0u;
        memset(v38, 0, 73);
        v40 = 0;
        v41 = 0;
        v39 = 0;
        v42 = 0;
        if (*((_QWORD *)&v49 + 1))
        {
          v26 = (uint64_t *)*((_QWORD *)&v50 + 1);
          v27 = 8 * *((_QWORD *)&v49 + 1);
          do
          {
            v28 = *v26++;
            v47 = v28;
            re::DynamicArray<re::TransitionCondition *>::add((_QWORD *)&v37 + 1, &v47);
            v27 -= 8;
          }
          while (v27);
        }
        if (v52)
        {
          v29 = v54;
          v30 = 8 * v52;
          do
          {
            v31 = *v29++;
            v47 = v31;
            re::DynamicArray<re::TransitionCondition *>::add(&v38[2], &v47);
            v30 -= 8;
          }
          while (v30);
        }
        v42 = 1;
        BYTE8(v38[4]) = 3;
        v41 = v25;
        re::Raft::beginMembershipChange((uint64_t)&v62, &v33, v46);
        re::ConfChange::~ConfChange((re::ConfChange *)&v33);
        goto LABEL_59;
      }
    }
    else if (!(_BYTE)v48)
    {
LABEL_59:
      re::Raft::Raft((uint64_t)&v33, (uint64_t *)&v62);
      *v32 = 1;
      re::Raft::Raft((uint64_t)(v32 + 8), (uint64_t *)&v33);
      re::Raft::~Raft((re::Raft *)&v33);
      if ((_BYTE)v48)
        re::MeshCollectionHandles::~MeshCollectionHandles((re::MeshCollectionHandles *)((char *)&v48 + 8));
      re::Raft::~Raft((re::Raft *)&v62);
      RaftState::~RaftState((RaftState *)v105);
      if ((_BYTE)v114)
        RaftState::~RaftState((RaftState *)v115);
LABEL_63:
      if (v116[0])
        return;
      goto LABEL_64;
    }
LABEL_69:
    re::internal::assertLog((re::internal *)4, v24, "assertion failure: '%s' (%s:line %i) Should never find pendingConfChange without an index", "!\"Unreachable code\"", "init", 110);
    _os_crash();
    __break(1u);
    return;
  }
  *a3 = 0;
  a3[8] = 5;
LABEL_64:
  if (v117)
  {
    if ((v118 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v117 + 40))();
  }
}

unsigned __int8 *re::RaftLog::operator=(unsigned __int8 *a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;

  v4 = *a2;
  *a2 = 0;
  v5 = *(_QWORD *)a1;
  *(_QWORD *)a1 = v4;
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=((uint64_t)(a1 + 8), (uint64_t)(a2 + 1));
  re::Optional<re::Snapshot>::operator=(a1 + 48, a2 + 6);
  *((_QWORD *)a1 + 35) = a2[35];
  *((_OWORD *)a1 + 18) = *((_OWORD *)a2 + 18);
  return a1;
}

_BYTE *re::Optional<re::ProgressSet>::operator=(_BYTE *a1, uint64_t *a2)
{
  int v3;
  int v4;
  BOOL v5;
  re::ProgressSet *v6;
  BOOL v7;
  BOOL v8;

  v3 = *a1;
  v4 = *(unsigned __int8 *)a2;
  if (*a1)
    v5 = 0;
  else
    v5 = v4 == 0;
  if (!v5)
  {
    v6 = (re::ProgressSet *)(a1 + 8);
    if (v3)
      v7 = v4 == 0;
    else
      v7 = 0;
    if (v7)
    {
      re::ProgressSet::~ProgressSet(v6);
      *a1 = 0;
    }
    else
    {
      if (v3)
        v8 = 1;
      else
        v8 = v4 == 0;
      if (v8)
      {
        re::ProgressSet::operator=((uint64_t)v6, a2 + 1);
      }
      else
      {
        *a1 = 1;
        re::ProgressSet::ProgressSet((uint64_t)v6, (uint64_t)(a2 + 1));
      }
    }
  }
  return a1;
}

_BYTE *re::Optional<re::ConfChange>::operator=(_BYTE *a1, unsigned __int8 *a2)
{
  int v3;
  int v4;
  BOOL v5;
  re::ConfChange *v6;
  BOOL v7;
  BOOL v8;

  v3 = *a1;
  v4 = *a2;
  if (*a1)
    v5 = 0;
  else
    v5 = v4 == 0;
  if (!v5)
  {
    v6 = (re::ConfChange *)(a1 + 8);
    if (v3)
      v7 = v4 == 0;
    else
      v7 = 0;
    if (v7)
    {
      re::ConfChange::~ConfChange(v6);
      *a1 = 0;
    }
    else
    {
      if (v3)
        v8 = 1;
      else
        v8 = v4 == 0;
      if (v8)
      {
        re::ConfChange::operator=((uint64_t)v6, (uint64_t)(a2 + 8));
      }
      else
      {
        *a1 = 1;
        re::ConfChange::ConfChange((uint64_t)v6, (uint64_t)(a2 + 8));
      }
    }
  }
  return a1;
}

void re::Raft::commitApply(re::Raft *this, unint64_t a2)
{
  re::RaftLog::appliedTo((uint64_t)this, a2);
  if (*((_BYTE *)this + 856) && *((_QWORD *)this + 126) <= a2 && *((_BYTE *)this + 536) == 2)
    re::Raft::appendFinalizeConfChangeEntry(this);
}

uint64_t re::Raft::beginMembershipChange@<X0>(uint64_t this@<X0>, uint64_t **a2@<X1>, char *a3@<X8>)
{
  uint64_t v5;
  uint64_t Index;
  unint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  double v17;
  char v18;
  double v19;
  uint64_t v20[3];
  uint64_t v21;
  char v22;
  _OWORD v23[2];
  __int128 v24;
  _OWORD v25[2];
  __int128 v26;
  uint64_t v27;
  _QWORD v28[2];
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  char v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  __int16 v39;

  if (*((_BYTE *)a2 + 120) == 3 && *((_BYTE *)a2 + 152) && a2[18])
  {
    v5 = this;
    LOBYTE(v27) = 1;
    re::ConfChange::ConfChange((re::ConfChange *)v28, (const re::ConfChange *)a2);
    re::Optional<re::ConfChange>::operator=((_BYTE *)(v5 + 856), (unsigned __int8 *)&v27);
    if ((_BYTE)v27)
      re::ConfChange::~ConfChange((re::ConfChange *)v28);
    Index = re::RaftLog::lastIndex((re::RaftLog *)v5);
    v7 = *(_QWORD *)(v5 + 1088);
    v8 = Index + 1;
    v28[0] = 0;
    v28[1] = 0;
    v27 = 0;
    v29 = 0;
    v30 = 0;
    v31 = 0;
    v32 = 0;
    v33 = v7;
    re::DynamicArray<float *>::setCapacity(&v27, v7);
    v34 = 0;
    v35 = 0;
    v36 = v8;
    v37 = 0;
    v38 = 0;
    v39 = 0;
    memset(v23, 0, sizeof(v23));
    v24 = 0u;
    memset(v25, 0, sizeof(v25));
    DWORD1(v24) = 0x7FFFFFFF;
    v26 = 0u;
    DWORD1(v26) = 0x7FFFFFFF;
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity((uint64_t)v23, 0);
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity((uint64_t)v25, 0);
    v9 = a2[7];
    if (v9)
    {
      v10 = a2[9];
      v11 = 8 * (_QWORD)v9;
      do
      {
        v12 = *v10++;
        v20[0] = v12;
        re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)v23, v20);
        v11 -= 8;
      }
      while (v11);
    }
    v13 = a2[12];
    if (v13)
    {
      v14 = a2[14];
      v15 = 8 * (_QWORD)v13;
      do
      {
        v16 = *v14++;
        v20[0] = v16;
        re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)v25, v20);
        v15 -= 8;
      }
      while (v15);
    }
    v17 = re::ProgressSet::beginMembershipChange((re::ProgressSet *)(v5 + 552), (const re::Configuration *)v23, (re::Progress *)&v27, (uint64_t)v20);
    if (LOBYTE(v20[0]))
    {
      v18 = 1;
    }
    else
    {
      a3[1] = 13;
      if (v21 && (v22 & 1) != 0)
        (*(void (**)(double))(*(_QWORD *)v21 + 40))(v17);
      v18 = 0;
    }
    *a3 = v18;
    re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)v25);
    v19 = re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)v23);
    this = v27;
    if (v27)
    {
      if (v30)
        return (*(uint64_t (**)(double))(*(_QWORD *)v27 + 40))(v19);
    }
  }
  else
  {
    *(_WORD *)a3 = 2560;
  }
  return this;
}

void re::Raft::appendFinalizeConfChangeEntry(re::Raft *this)
{
  _QWORD v2[5];
  __int128 v3;
  __int128 v4;
  _OWORD v5[3];
  __int128 v6;
  uint64_t v7;
  _QWORD v8[3];
  int v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char v20;
  re::zerocopy **v21;
  _QWORD v22[5];
  _BYTE v23[56];
  uint64_t v24;
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  memset(v8, 0, sizeof(v8));
  v9 = 0;
  v10 = 0u;
  v11 = 0u;
  v12 = 0u;
  v13 = 0u;
  v14 = 0u;
  v15 = 0;
  v18 = 0;
  v19 = 0;
  v17 = 0;
  v20 = 0;
  v16 = 4;
  v7 = 0;
  v6 = 0u;
  memset(v5, 0, sizeof(v5));
  v3 = 0u;
  v4 = 0u;
  LOBYTE(v6) = 1;
  DWORD2(v4) = 1;
  v22[0] = &off_24ED7DD00;
  v22[1] = &v3;
  v2[0] = v22;
  v21 = (re::zerocopy **)v2;
  re::ConsensusWriter::write(&v21, (const re::ConfChange *)v8);
  re::DynamicArray<BOOL>::DynamicArray((uint64_t)v22, (uint64_t *)&v3);
  re::DynamicArray<BOOL>::DynamicArray((uint64_t)v23, (uint64_t *)v5 + 1);
  *(_OWORD *)&v23[40] = v6;
  v24 = v7;
  re::DynamicArray<re::Entry>::DynamicArray((uint64_t)v2, (uint64_t)v22, 1uLL);
  re::MeshCollectionHandles::~MeshCollectionHandles((re::MeshCollectionHandles *)v22);
  re::Raft::appendEntry((uint64_t)this, (uint64_t)v2);
  re::Raft::broadcastAppend(this);
  re::DynamicArray<re::Entry>::deinit((uint64_t)v2);
  re::MeshCollectionHandles::~MeshCollectionHandles((re::MeshCollectionHandles *)&v3);
  re::ConfChange::~ConfChange((re::ConfChange *)v8);
}

uint64_t re::Raft::appendEntry(uint64_t a1, uint64_t a2)
{
  uint64_t Index;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;

  Index = re::RaftLog::lastIndex((re::RaftLog *)a1);
  v5 = *(_QWORD *)(a2 + 16);
  if (v5)
  {
    v6 = 0;
    v7 = *(_QWORD *)(a1 + 1040);
    v8 = (_QWORD *)(*(_QWORD *)(a2 + 32) + 96);
    do
    {
      *(v8 - 1) = Index + 1 + v6;
      *v8 = v7;
      v6 += 2;
      v8 += 26;
    }
    while (v6 < v5);
  }
  v9 = re::RaftLog::append((re::RaftLog *)a1, a2);
  LODWORD(v10) = 0x7FFFFFFF;
  if (*(_QWORD *)(a1 + 552))
  {
    v11 = *(_QWORD *)(a1 + 1056);
    v12 = 0x94D049BB133111EBLL
        * ((0xBF58476D1CE4E5B9 * (v11 ^ (v11 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v11 ^ (v11 >> 30))) >> 27));
    v13 = *(unsigned int *)(*(_QWORD *)(a1 + 560) + 4 * ((v12 ^ (v12 >> 31)) % *(unsigned int *)(a1 + 576)));
    if ((_DWORD)v13 != 0x7FFFFFFF)
    {
      v14 = *(_QWORD *)(a1 + 568);
      LODWORD(v10) = v13;
      if (*(_QWORD *)(v14 + 136 * v13 + 16) != v11)
      {
        v10 = v13;
        while (1)
        {
          LODWORD(v10) = *(_DWORD *)(v14 + 136 * v10 + 8) & 0x7FFFFFFF;
          if ((_DWORD)v10 == 0x7FFFFFFF)
            break;
          if (*(_QWORD *)(v14 + 136 * v10 + 16) == v11)
            goto LABEL_12;
        }
        LODWORD(v10) = 0x7FFFFFFF;
      }
    }
  }
LABEL_12:
  v15 = *(_QWORD *)(a1 + 568) + 136 * v10;
  if (*(_QWORD *)(v15 + 96) < v9)
  {
    *(_QWORD *)(v15 + 96) = v9;
    *(_BYTE *)(v15 + 128) = 0;
  }
  if (*(_QWORD *)(v15 + 104) < v9 + 1)
    *(_QWORD *)(v15 + 104) = v9 + 1;
  v16 = re::ProgressSet::maximalCommittedIndex((re::ProgressSet *)(a1 + 552));
  return re::RaftLog::maybeCommit((re::RaftLog *)a1, v16, *(_QWORD *)(a1 + 1040));
}

void re::Raft::broadcastAppend(re::Raft *this)
{
  _BYTE *v2;
  uint64_t v3;
  uint64_t v4;
  int *v5;
  int v6;
  const re::ProgressSet *v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unsigned int v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t i;
  uint64_t v19;
  _BYTE v20[312];

  v2 = (char *)this + 544;
  v3 = *((unsigned int *)this + 146);
  if ((_DWORD)v3)
  {
    v4 = 0;
    v5 = (int *)(*((_QWORD *)this + 71) + 8);
    while (1)
    {
      v6 = *v5;
      v5 += 34;
      if (v6 < 0)
        break;
      if (v3 == ++v4)
      {
        LODWORD(v4) = *((_DWORD *)this + 146);
        break;
      }
    }
  }
  else
  {
    LODWORD(v4) = 0;
  }
  v7 = (re::Raft *)((char *)this + 552);
  if ((_DWORD)v3 != (_DWORD)v4)
  {
    v8 = v4;
    v9 = *((_QWORD *)this + 132);
    v10 = *((_DWORD *)this + 146);
    do
    {
      v11 = *((_QWORD *)this + 71);
      v12 = *(_QWORD *)(v11 + 136 * v8 + 16);
      if (v9 != v12)
      {
        if (*(_QWORD *)v7
          && (v13 = 0x94D049BB133111EBLL
                  * ((0xBF58476D1CE4E5B9 * (v12 ^ (v12 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v12 ^ (v12 >> 30))) >> 27)),
              v14 = *(unsigned int *)(*((_QWORD *)this + 70) + 4 * ((v13 ^ (v13 >> 31)) % *((unsigned int *)this + 144))),
              (_DWORD)v14 != 0x7FFFFFFF))
        {
          v17 = *(_QWORD *)(v11 + 136 * v14 + 16);
          for (i = v14; v17 != v12; LODWORD(v14) = i)
          {
            i = *(_DWORD *)(v11 + 136 * i + 8) & 0x7FFFFFFF;
            LODWORD(v14) = 0x7FFFFFFF;
            if (i == 0x7FFFFFFF)
              break;
            v17 = *(_QWORD *)(v11 + 136 * i + 16);
          }
        }
        else
        {
          LODWORD(v14) = 0x7FFFFFFF;
        }
        re::Raft::sendAppend((__n128 **)this, v12, (re::Progress *)(v11 + 136 * v14 + 24));
        v10 = *((_DWORD *)this + 146);
      }
      if (v10 <= (int)v4 + 1)
        v15 = v4 + 1;
      else
        v15 = v10;
      while (1)
      {
        v8 = (v4 + 1);
        if (v15 - 1 == (_DWORD)v4)
          break;
        LODWORD(v4) = v4 + 1;
        v16 = v8;
        if ((*(_DWORD *)(*((_QWORD *)this + 71) + 136 * v8 + 8) & 0x80000000) != 0)
          goto LABEL_24;
      }
      v16 = v15;
LABEL_24:
      LODWORD(v4) = v16;
    }
    while ((_DWORD)v3 != v16);
  }
  LOBYTE(v19) = 1;
  re::ProgressSet::ProgressSet((re::ProgressSet *)v20, v7);
  re::Optional<re::ProgressSet>::operator=(v2, &v19);
  if ((_BYTE)v19)
    re::ProgressSet::~ProgressSet((re::ProgressSet *)v20);
}

uint64_t re::Raft::becomeLeader(re::Raft *this)
{
  unint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _BYTE v9[40];
  _OWORD v10[6];
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  re::Raft::reset(this, *((_QWORD *)this + 130));
  v2 = *((_QWORD *)this + 132);
  *((_QWORD *)this + 133) = v2;
  *((_BYTE *)this + 536) = 2;
  LODWORD(v3) = 0x7FFFFFFF;
  if (*((_QWORD *)this + 69))
  {
    v4 = 0x94D049BB133111EBLL
       * ((0xBF58476D1CE4E5B9 * (v2 ^ (v2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v2 ^ (v2 >> 30))) >> 27));
    v5 = *(unsigned int *)(*((_QWORD *)this + 70) + 4 * ((v4 ^ (v4 >> 31)) % *((unsigned int *)this + 144)));
    if ((_DWORD)v5 != 0x7FFFFFFF)
    {
      v6 = *((_QWORD *)this + 71);
      LODWORD(v3) = v5;
      if (*(_QWORD *)(v6 + 136 * v5 + 16) != v2)
      {
        v3 = v5;
        while (1)
        {
          LODWORD(v3) = *(_DWORD *)(v6 + 136 * v3 + 8) & 0x7FFFFFFF;
          if ((_DWORD)v3 == 0x7FFFFFFF)
            break;
          if (*(_QWORD *)(v6 + 136 * v3 + 16) == v2)
            goto LABEL_9;
        }
        LODWORD(v3) = 0x7FFFFFFF;
      }
    }
  }
LABEL_9:
  v7 = *((_QWORD *)this + 71) + 136 * v3;
  *(_BYTE *)(v7 + 128) = 0;
  *(_BYTE *)(v7 + 88) = 1;
  *(_QWORD *)(v7 + 64) = 0;
  *(_QWORD *)(v7 + 72) = 0;
  *(_QWORD *)(v7 + 104) = *(_QWORD *)(v7 + 96) + 1;
  *(_QWORD *)(v7 + 112) = 0;
  *((_QWORD *)this + 134) = re::RaftLog::lastIndex(this);
  v11 = 0;
  memset(v10, 0, sizeof(v10));
  re::DynamicArray<re::Entry>::DynamicArray((uint64_t)v9, (uint64_t)v10, 1uLL);
  re::MeshCollectionHandles::~MeshCollectionHandles((re::MeshCollectionHandles *)v10);
  re::Raft::appendEntry((uint64_t)this, (uint64_t)v9);
  if (*((_BYTE *)this + 856) && *((_QWORD *)this + 126) <= *((_QWORD *)this + 36))
    re::Raft::appendFinalizeConfChangeEntry(this);
  return re::DynamicArray<re::Entry>::deinit((uint64_t)v9);
}

uint64_t re::Raft::reset(re::Raft *this, uint64_t a2)
{
  uint32_t v3;
  uint64_t i;
  signed int v5;
  int v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unsigned int v12;
  std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type v13;
  uint64_t result;
  uint64_t v15;
  uint64_t v16;
  int *v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t j;
  std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> v30;
  std::random_device v31;

  if (*((_QWORD *)this + 130) != a2)
  {
    *((_QWORD *)this + 130) = a2;
    *((_QWORD *)this + 131) = 0;
  }
  *((_QWORD *)this + 133) = 0;
  std::random_device::random_device[abi:nn180100](&v31);
  v3 = arc4random();
  v30.__x_[0] = v3;
  for (i = 1; i != 624; ++i)
  {
    v3 = i + 1812433253 * (v3 ^ (v3 >> 30));
    v30.__x_[i] = v3;
  }
  v30.__i_ = 0;
  v5 = *((_DWORD *)this + 284);
  v6 = *((_DWORD *)this + 286) - 1 - v5;
  if (v6)
  {
    v7 = *((_DWORD *)this + 286) - v5;
    if (v6 == -1)
    {
      v5 = std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()(&v30);
    }
    else
    {
      v8 = __clz(v7);
      v9 = 31;
      if (((v7 << v8) & 0x7FFFFFFF) != 0)
        v9 = 32;
      v10 = v9 - v8;
      v11 = v10 >> 5;
      if ((v10 & 0x1F) != 0)
        ++v11;
      if (v11 <= v10)
        v12 = 0xFFFFFFFF >> -(v10 / v11);
      else
        v12 = 0;
      do
        v13 = std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()(&v30) & v12;
      while (v13 >= v7);
      v5 += v13;
    }
  }
  *((_QWORD *)this + 141) = v5;
  std::random_device::~random_device(&v31);
  *(_OWORD *)((char *)this + 1096) = 0u;
  if (*((_BYTE *)this + 1024))
    *((_BYTE *)this + 1024) = 0;
  re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::clear((uint64_t)this + 304);
  *((_QWORD *)this + 134) = 0;
  re::ReadOnly::ReadOnly((uint64_t)&v30, (_BYTE *)this + 528);
  re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::operator=((uint64_t)this + 432, (uint64_t *)&v30);
  re::Queue<re::DynamicArray<unsigned char>>::operator=((uint64_t *)this + 60, (uint64_t *)&v30.__x_[12]);
  *((_BYTE *)this + 528) = v30.__x_[24];
  re::Queue<re::DynamicArray<unsigned char>>::deinit((uint64_t *)&v30.__x_[12]);
  re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::deinit((uint64_t *)&v30);
  *((_QWORD *)this + 135) = 0;
  result = re::RaftLog::lastIndex(this);
  v15 = *((unsigned int *)this + 146);
  if ((_DWORD)v15)
  {
    v16 = 0;
    v17 = (int *)(*((_QWORD *)this + 71) + 8);
    while (1)
    {
      v18 = *v17;
      v17 += 34;
      if (v18 < 0)
        break;
      if (v15 == ++v16)
      {
        LODWORD(v16) = *((_DWORD *)this + 146);
        break;
      }
    }
  }
  else
  {
    LODWORD(v16) = 0;
  }
  if ((_DWORD)v15 != (_DWORD)v16)
  {
    v19 = v16;
    v20 = *((_QWORD *)this + 132);
    do
    {
      v21 = *((_QWORD *)this + 71);
      v22 = *(_QWORD *)(v21 + 136 * v19 + 16);
      if (*((_QWORD *)this + 69)
        && (v23 = 0x94D049BB133111EBLL
                * ((0xBF58476D1CE4E5B9 * (v22 ^ (v22 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v22 ^ (v22 >> 30))) >> 27)),
            v24 = *(unsigned int *)(*((_QWORD *)this + 70) + 4 * ((v23 ^ (v23 >> 31)) % *((unsigned int *)this + 144))),
            (_DWORD)v24 != 0x7FFFFFFF))
      {
        v28 = *(_QWORD *)(v21 + 136 * v24 + 16);
        for (j = v24; v28 != v22; LODWORD(v24) = j)
        {
          j = *(_DWORD *)(v21 + 136 * j + 8) & 0x7FFFFFFF;
          LODWORD(v24) = 0x7FFFFFFF;
          if (j == 0x7FFFFFFF)
            break;
          v28 = *(_QWORD *)(v21 + 136 * j + 16);
        }
      }
      else
      {
        LODWORD(v24) = 0x7FFFFFFF;
      }
      v25 = v21 + 136 * v24;
      *(_QWORD *)(v25 + 96) = 0;
      *(_QWORD *)(v25 + 104) = result + 1;
      *(_BYTE *)(v25 + 88) = 0;
      *(_QWORD *)(v25 + 64) = 0;
      *(_QWORD *)(v25 + 72) = 0;
      *(_QWORD *)(v25 + 112) = 0;
      *(_QWORD *)(v25 + 120) = 0;
      *(_WORD *)(v25 + 128) = 0;
      if (v22 == v20)
        *(_QWORD *)(v21 + 136 * v24 + 96) = result;
      v26 = *((_DWORD *)this + 146);
      if (v26 <= (int)v16 + 1)
        v26 = v16 + 1;
      while (1)
      {
        v19 = (v16 + 1);
        if (v26 - 1 == (_DWORD)v16)
          break;
        LODWORD(v16) = v16 + 1;
        v27 = v19;
        if ((*(_DWORD *)(*((_QWORD *)this + 71) + 136 * v19 + 8) & 0x80000000) != 0)
          goto LABEL_38;
      }
      v27 = v26;
LABEL_38:
      LODWORD(v16) = v27;
    }
    while ((_DWORD)v15 != v27);
  }
  return result;
}

void re::Raft::sendAppend(__n128 **this, uint64_t a2, re::Progress *a3)
{
  __n128 *v6;
  __n128 *v7;
  __n128 *v8;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  re::MeshCollectionHandles *v13;
  uint64_t v14;
  uint64_t v15;
  _BYTE v16[384];
  char v17[8];
  __n128 v18;
  uint64_t v19;
  __n128 *v20;
  char v21[8];
  uint64_t v22;
  __n128 v23;
  uint64_t v24;
  int v25;
  re::MeshCollectionHandles *v26[2];
  __int128 v27;
  int v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  _BYTE v42[25];
  uint64_t v43;
  __int128 v44;
  __int128 v45;
  _QWORD v46[4];

  if (!*((_BYTE *)a3 + 64))
  {
    if (*((_BYTE *)a3 + 104))
      return;
LABEL_6:
    v23 = 0uLL;
    v25 = 0;
    v24 = 0;
    *(_OWORD *)v26 = 0u;
    v27 = 0u;
    v28 = 0;
    v41 = 0u;
    memset(v42, 0, sizeof(v42));
    v29 = 0u;
    v30 = 0u;
    v31 = 0u;
    v32 = 0u;
    v33 = 0u;
    v34 = 0u;
    v35 = 0u;
    v36 = 0u;
    v37 = 0u;
    v38 = 0u;
    v39 = 0u;
    v40 = 0u;
    v45 = 0u;
    memset(v46, 0, 25);
    v44 = 0u;
    v43 = a2;
    if (*((_QWORD *)a3 + 12))
    {
      if ((re::Raft::prepareSendSnapshot((re::Raft *)this, (re::Message *)&v23, a3) & 1) == 0)
        goto LABEL_39;
      goto LABEL_38;
    }
    re::RaftLog::getTerm((re::RaftLog *)this, *((_QWORD *)a3 + 10) - 1, (uint64_t)v21);
    re::RaftLog::entries((re::RaftLog *)this, *((_QWORD *)a3 + 10), (uint64_t)v17);
    if (v21[0] && v17[0])
    {
      if (*((_BYTE *)this + 1156))
      {
        v6 = this[51];
        if (v6)
        {
          v7 = v20;
          v8 = this[53];
          while (v8[19].n128_u8[0] != 3 || v8[19].n128_u64[1] != a2)
          {
            v8 += 24;
            v6 = (__n128 *)((char *)v6 - 1);
            if (!v6)
              goto LABEL_31;
          }
          if (!v19)
            goto LABEL_28;
          v10 = v8[1].n128_u64[0];
          if (!v10 || *(_QWORD *)(v8[2].n128_u64[0] + 104 * v10 - 16) + 1 == v20[5].n128_u64[1])
          {
            v11 = 104 * v19;
            do
            {
              re::DynamicArray<re::Entry>::add(v8, v7);
              v7 = (__n128 *)((char *)v7 + 104);
              v11 -= 104;
            }
            while (v11);
            re::Progress::updateState(a3, *(_QWORD *)(v8[2].n128_u64[0] + 104 * v8[1].n128_u64[0] - 16));
LABEL_28:
            v8[22].n128_u64[0] = (unint64_t)this[36];
LABEL_29:
            if (v17[0])
              re::DynamicArray<re::Entry>::deinit((uint64_t)&v18);
            goto LABEL_39;
          }
        }
      }
LABEL_31:
      v42[24] = 3;
      *((_QWORD *)&v45 + 1) = *((_QWORD *)a3 + 10) - 1;
      *(_QWORD *)&v45 = v22;
      v12 = v24;
      v24 = 0;
      if (v12)
      {
        v13 = v26[0];
        v14 = 104 * v12;
        do
        {
          re::MeshCollectionHandles::~MeshCollectionHandles(v13);
          v13 = (re::MeshCollectionHandles *)(v15 + 104);
          v14 -= 104;
        }
        while (v14);
      }
      ++v25;
      re::DynamicArray<re::Entry>::operator=(&v23, &v18);
      v46[0] = this[36];
      if (v24)
        re::Progress::updateState(a3, *((_QWORD *)v26[0] + 13 * v24 - 2));
    }
    else if ((re::Raft::prepareSendSnapshot((re::Raft *)this, (re::Message *)&v23, a3) & 1) == 0)
    {
      goto LABEL_29;
    }
    if (v17[0])
      re::DynamicArray<re::Entry>::deinit((uint64_t)&v18);
LABEL_38:
    re::Message::Message((re::Message *)v16, (const re::Message *)&v23);
    re::Raft::send((uint64_t)this, (uint64_t)v16);
    re::Message::~Message((re::Message *)v16);
LABEL_39:
    re::Message::~Message((re::Message *)&v23);
    return;
  }
  if (*((_BYTE *)a3 + 64) == 1 && *((_QWORD *)a3 + 6) != *((_QWORD *)a3 + 7))
    goto LABEL_6;
}

uint64_t re::Raft::prepareSendSnapshot(re::Raft *this, re::Message *a2, re::Progress *a3)
{
  uint64_t v5;
  _BOOL8 v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t result;
  uint64_t v10[5];
  uint64_t v11[5];
  uint64_t v12[5];
  uint64_t v13[5];
  uint64_t v14[5];
  __int128 v15;
  uint64_t v16;
  _BYTE v17[8];
  uint64_t v18[5];
  uint64_t v19[5];
  uint64_t v20[5];
  uint64_t v21[5];
  uint64_t v22[5];
  __int128 v23;
  uint64_t v24;

  if (!*((_BYTE *)a3 + 105))
    return 0;
  *((_BYTE *)a2 + 304) = 7;
  re::RaftLog::snapshot(this, *((_QWORD *)a3 + 12), (uint64_t)v17);
  v6 = v17[0] != 0;
  if (!v17[0])
  {
    if (LOBYTE(v18[0]) != 3)
      goto LABEL_10;
    return v6;
  }
  re::DynamicArray<BOOL>::DynamicArray((uint64_t)v10, v18);
  re::DynamicArray<char const*>::DynamicArray((uint64_t)v11, v19);
  re::DynamicArray<char const*>::DynamicArray((uint64_t)v12, v20);
  re::DynamicArray<char const*>::DynamicArray((uint64_t)v13, v21);
  re::DynamicArray<char const*>::DynamicArray((uint64_t)v14, v22);
  v15 = v23;
  v16 = v24;
  v8 = *((_QWORD *)&v23 + 1);
  if (*((_QWORD *)&v23 + 1))
  {
    re::DynamicArray<BOOL>::operator=((uint64_t)a2 + 80, v10);
    re::DynamicArray<unsigned long long>::operator=((uint64_t)a2 + 120, v11);
    re::DynamicArray<unsigned long long>::operator=((uint64_t)a2 + 160, v12);
    re::DynamicArray<unsigned long long>::operator=((uint64_t)a2 + 200, v13);
    re::DynamicArray<unsigned long long>::operator=((uint64_t)a2 + 240, v14);
    *(_OWORD *)((char *)a2 + 280) = v15;
    *((_QWORD *)a2 + 37) = v16;
    *((_BYTE *)a3 + 104) = 0;
    *((_BYTE *)a3 + 64) = 2;
    *((_QWORD *)a3 + 5) = 0;
    *((_QWORD *)a3 + 6) = 0;
    *((_QWORD *)a3 + 11) = v8;
    re::Snapshot::~Snapshot((re::Snapshot *)v10);
    if (v17[0])
      re::Snapshot::~Snapshot((re::Snapshot *)v18);
    return v6;
  }
  re::internal::assertLog((re::internal *)4, v7, "assertion failure: '%s' (%s:line %i) Need non-empty snapshot", "!\"Unreachable code\"", "prepareSendSnapshot", 320);
  _os_crash();
  __break(1u);
LABEL_10:
  re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) Unexpected error", "!\"Unreachable code\"", "prepareSendSnapshot", 315);
  result = _os_crash();
  __break(1u);
  return result;
}

re::Message *re::Raft::send(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  re::Message *result;

  *(_QWORD *)(a2 + 320) = *(_QWORD *)(a1 + 1056);
  v2 = *(unsigned __int8 *)(a2 + 304);
  if (v2 > 0x12 || ((1 << v2) & 0x60060) == 0)
  {
    if (!*(_QWORD *)(a2 + 328))
    {
      if (v2 != 2 && v2 != 15)
        *(_QWORD *)(a2 + 328) = *(_QWORD *)(a1 + 1040);
      return re::DynamicArray<re::Message>::add(a1 + 392, (re::Message *)a2);
    }
  }
  else
  {
    if (*(_QWORD *)(a2 + 328))
      return re::DynamicArray<re::Message>::add(a1 + 392, (re::Message *)a2);
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) term should be set when sending", "!\"Unreachable code\"", "send", 350);
    _os_crash();
    __break(1u);
  }
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) term should be set when sending, was", "!\"Unreachable code\"", "send", 354);
  result = (re::Message *)_os_crash();
  __break(1u);
  return result;
}

re::MeshCollectionHandles *re::DynamicArray<re::Entry>::clear(re::MeshCollectionHandles *result)
{
  re::MeshCollectionHandles *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v1 = result;
  v2 = *((_QWORD *)result + 2);
  *((_QWORD *)result + 2) = 0;
  if (v2)
  {
    result = (re::MeshCollectionHandles *)*((_QWORD *)result + 4);
    v3 = 104 * v2;
    do
    {
      re::MeshCollectionHandles::~MeshCollectionHandles(result);
      result = (re::MeshCollectionHandles *)(v4 + 104);
      v3 -= 104;
    }
    while (v3);
  }
  ++*((_DWORD *)v1 + 6);
  return result;
}

__n128 *re::DynamicArray<re::Entry>::operator=(__n128 *a1, __n128 *a2)
{
  unint64_t v4;
  unint64_t v5;

  if (a1 != a2)
  {
    v4 = a2->n128_u64[0];
    if (a1->n128_u64[0])
    {
      if (v4)
      {
        re::DynamicArray<re::Entry>::copy(a1, (uint64_t)a2);
        ++a1[1].n128_u32[2];
      }
      else
      {
        re::DynamicArray<re::Entry>::clear((re::MeshCollectionHandles *)a1);
      }
    }
    else if (v4)
    {
      v5 = a2[1].n128_u64[0];
      a1->n128_u64[0] = v4;
      re::DynamicArray<re::Entry>::setCapacity(a1, v5);
      ++a1[1].n128_u32[2];
      re::DynamicArray<re::Entry>::copy(a1, (uint64_t)a2);
    }
  }
  return a1;
}

re::Message *re::DynamicArray<re::Message>::add(uint64_t a1, re::Message *a2)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  BOOL v8;
  unint64_t v9;
  unint64_t v10;
  re::Message *result;

  v4 = *(_QWORD *)(a1 + 8);
  v5 = *(_QWORD *)(a1 + 16);
  if (v5 >= v4)
  {
    v6 = v5 + 1;
    if (v4 < v5 + 1)
    {
      if (*(_QWORD *)a1)
      {
        v7 = 2 * v4;
        v8 = v4 == 0;
        v9 = 8;
        if (!v8)
          v9 = v7;
        if (v9 <= v6)
          v10 = v6;
        else
          v10 = v9;
        re::DynamicArray<re::Message>::setCapacity((_QWORD *)a1, v10);
      }
      else
      {
        re::DynamicArray<re::Message>::setCapacity((_QWORD *)a1, v6);
        ++*(_DWORD *)(a1 + 24);
      }
    }
    v5 = *(_QWORD *)(a1 + 16);
  }
  result = re::Message::Message((re::Message *)(*(_QWORD *)(a1 + 32) + 384 * v5), a2);
  ++*(_QWORD *)(a1 + 16);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

void re::Raft::broadcastHeartbeat(re::Raft *this)
{
  _BYTE v2[8];
  uint64_t v3;
  uint64_t v4;

  re::ReadOnly::lastPendingRequestCtx((_QWORD *)this + 54, v2);
  re::Raft::broadcastHeatbeatWithCtx((uint64_t)this, v2);
  if (v2[0] && v3)
  {
    if (v4)
      (*(void (**)(void))(*(_QWORD *)v3 + 40))();
  }
}

void re::Raft::broadcastHeatbeatWithCtx(uint64_t a1, _BYTE *a2)
{
  uint64_t v3;
  uint64_t v4;
  int *v5;
  int v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t i;
  _BYTE *v20;
  uint64_t *v21;
  _BYTE v23[384];
  uint64_t v24;
  _QWORD v25[2];
  int v26;
  _BYTE v27[32];
  int v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  uint64_t v43;
  char v44;
  unint64_t v45;
  __int128 v46;
  __int128 v47;
  _QWORD v48[5];

  v3 = *(unsigned int *)(a1 + 584);
  v20 = (_BYTE *)(a1 + 544);
  v4 = 0;
  if ((_DWORD)v3)
  {
    v5 = (int *)(*(_QWORD *)(a1 + 568) + 8);
    while (1)
    {
      v6 = *v5;
      v5 += 34;
      if (v6 < 0)
        break;
      if (v3 == ++v4)
      {
        LODWORD(v4) = *(_DWORD *)(a1 + 584);
        break;
      }
    }
  }
  v7 = (_QWORD *)(a1 + 552);
  if ((_DWORD)v3 != (_DWORD)v4)
  {
    v8 = v4;
    v9 = *(_QWORD *)(a1 + 1056);
    v21 = (uint64_t *)(a2 + 8);
    v10 = *(_DWORD *)(a1 + 584);
    do
    {
      v11 = *(_QWORD *)(a1 + 568);
      v12 = *(_QWORD *)(v11 + 136 * v8 + 16);
      if (v12 != v9)
      {
        if (*v7
          && (v13 = 0x94D049BB133111EBLL
                  * ((0xBF58476D1CE4E5B9 * (v12 ^ (v12 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v12 ^ (v12 >> 30))) >> 27)),
              v14 = *(unsigned int *)(*(_QWORD *)(a1 + 560) + 4 * ((v13 ^ (v13 >> 31)) % *(unsigned int *)(a1 + 576))),
              (_DWORD)v14 != 0x7FFFFFFF))
        {
          v18 = *(_QWORD *)(v11 + 136 * v14 + 16);
          for (i = v14; v18 != v12; LODWORD(v14) = i)
          {
            i = *(_DWORD *)(v11 + 136 * i + 8) & 0x7FFFFFFF;
            LODWORD(v14) = 0x7FFFFFFF;
            if (i == 0x7FFFFFFF)
              break;
            v18 = *(_QWORD *)(v11 + 136 * i + 16);
          }
        }
        else
        {
          LODWORD(v14) = 0x7FFFFFFF;
        }
        v15 = *(_QWORD *)(v11 + 136 * v14 + 96);
        v24 = 0;
        v25[0] = 0;
        v26 = 0;
        v25[1] = 0;
        memset(v27, 0, sizeof(v27));
        v28 = 0;
        v29 = 0u;
        v30 = 0u;
        v31 = 0u;
        v32 = 0u;
        v33 = 0u;
        v34 = 0u;
        v35 = 0u;
        v36 = 0u;
        v37 = 0u;
        v38 = 0u;
        v39 = 0u;
        v40 = 0u;
        v41 = 0u;
        v42 = 0u;
        v43 = 0;
        v47 = 0u;
        memset(v48, 0, 25);
        v46 = 0u;
        v44 = 8;
        if (*(_QWORD *)(a1 + 288) < v15)
          v15 = *(_QWORD *)(a1 + 288);
        v45 = v12;
        v48[0] = v15;
        if (*a2)
          re::DynamicArray<BOOL>::operator=((uint64_t)&v27[8], v21);
        re::Message::Message((re::Message *)v23, (const re::Message *)&v24);
        re::Raft::send(a1, (uint64_t)v23);
        re::Message::~Message((re::Message *)v23);
        re::Message::~Message((re::Message *)&v24);
        v10 = *(_DWORD *)(a1 + 584);
      }
      if (v10 <= (int)v4 + 1)
        v16 = v4 + 1;
      else
        v16 = v10;
      while (1)
      {
        v8 = (v4 + 1);
        if (v16 - 1 == (_DWORD)v4)
          break;
        LODWORD(v4) = v4 + 1;
        v17 = v8;
        if ((*(_DWORD *)(*(_QWORD *)(a1 + 568) + 136 * v8 + 8) & 0x80000000) != 0)
          goto LABEL_27;
      }
      v17 = v16;
LABEL_27:
      LODWORD(v4) = v17;
    }
    while ((_DWORD)v3 != v17);
  }
  LOBYTE(v24) = 1;
  re::ProgressSet::ProgressSet((re::ProgressSet *)v25, (const re::ProgressSet *)(a1 + 552));
  re::Optional<re::ProgressSet>::operator=(v20, &v24);
  if ((_BYTE)v24)
    re::ProgressSet::~ProgressSet((re::ProgressSet *)v25);
}

std::random_device *std::random_device::random_device[abi:nn180100](std::random_device *a1)
{
  std::string __token;

  std::string::basic_string[abi:nn180100]<0>(&__token, "/dev/urandom");
  std::random_device::random_device(a1, &__token);
  if (SHIBYTE(__token.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__token.__r_.__value_.__l.__data_);
  return a1;
}

BOOL re::Raft::tick(re::Raft *this)
{
  unsigned int v1;

  v1 = *((unsigned __int8 *)this + 536);
  if (v1 < 2)
    return re::Raft::tickElection(this);
  if (v1 == 2)
    return re::Raft::tickHeartbeat(this);
  if (v1 == 3)
    return re::Raft::tickElection(this);
  return 0;
}

BOOL re::Raft::tickElection(re::Raft *this)
{
  unint64_t v1;
  _BOOL8 result;
  uint64_t v4;
  _QWORD v5[3];
  int v6;
  __int128 v7;
  __int128 v8;
  int v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  char v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  char v31;
  _BYTE v32[2];

  v1 = *((_QWORD *)this + 137) + 1;
  *((_QWORD *)this + 137) = v1;
  if (v1 < *((_QWORD *)this + 141))
    return 0;
  result = re::Raft::promotable(this);
  if (result)
  {
    *((_QWORD *)this + 137) = 0;
    v4 = *((_QWORD *)this + 132);
    memset(v5, 0, sizeof(v5));
    v6 = 0;
    v7 = 0u;
    v8 = 0u;
    v9 = 0;
    v22 = 0u;
    v23 = 0u;
    v10 = 0u;
    v11 = 0u;
    v12 = 0u;
    v13 = 0u;
    v14 = 0u;
    v15 = 0u;
    v16 = 0u;
    v17 = 0u;
    v18 = 0u;
    v19 = 0u;
    v20 = 0u;
    v21 = 0u;
    v24 = 0;
    v29 = 0u;
    v30 = 0u;
    v26 = 0;
    v28 = 0u;
    v31 = 0;
    v27 = v4;
    v25 = 0;
    re::Raft::step((uint64_t)this, v5, v32);
    re::Message::~Message((re::Message *)v5);
    return 1;
  }
  return result;
}

BOOL re::Raft::tickHeartbeat(re::Raft *this)
{
  int64x2_t v2;
  _BOOL8 v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD v7[48];
  _BYTE v8[2];
  _QWORD v9[48];
  _BYTE v10[2];
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  __int128 v15;
  __int128 v16;
  int v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  uint64_t v32;
  char v33;
  uint64_t v34;
  uint64_t v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  char v39;

  v2 = vaddq_s64(*(int64x2_t *)((char *)this + 1096), vdupq_n_s64(1uLL));
  *(int64x2_t *)((char *)this + 1096) = v2;
  if (v2.i64[0] < *((_QWORD *)this + 140))
  {
    v3 = 0;
    if (*((_BYTE *)this + 536) != 2)
      return v3;
    goto LABEL_9;
  }
  *((_QWORD *)this + 137) = 0;
  v3 = *((_BYTE *)this + 1153) != 0;
  if (*((_BYTE *)this + 1153))
  {
    v4 = *((_QWORD *)this + 132);
    v13 = 0;
    v11 = 0;
    v12 = 0;
    v14 = 0;
    v15 = 0u;
    v16 = 0u;
    v17 = 0;
    v30 = 0u;
    v31 = 0u;
    v18 = 0u;
    v19 = 0u;
    v20 = 0u;
    v21 = 0u;
    v22 = 0u;
    v23 = 0u;
    v24 = 0u;
    v25 = 0u;
    v26 = 0u;
    v27 = 0u;
    v28 = 0u;
    v29 = 0u;
    v32 = 0;
    v37 = 0u;
    v38 = 0u;
    v34 = 0;
    v36 = 0u;
    v39 = 0;
    v35 = v4;
    v33 = 12;
    re::Message::Message((re::Message *)v9, (const re::Message *)&v11);
    re::Raft::step((uint64_t)this, v9, v10);
    re::Message::~Message((re::Message *)v9);
    re::Message::~Message((re::Message *)&v11);
  }
  if (*((_BYTE *)this + 536) == 2)
  {
    if (*((_BYTE *)this + 1024))
      *((_BYTE *)this + 1024) = 0;
LABEL_9:
    if (*((_QWORD *)this + 138) >= *((_QWORD *)this + 139))
    {
      *((_QWORD *)this + 138) = 0;
      v5 = *((_QWORD *)this + 132);
      v13 = 0;
      v11 = 0;
      v12 = 0;
      v14 = 0;
      v15 = 0u;
      v16 = 0u;
      v17 = 0;
      v30 = 0u;
      v31 = 0u;
      v18 = 0u;
      v19 = 0u;
      v20 = 0u;
      v21 = 0u;
      v22 = 0u;
      v23 = 0u;
      v24 = 0u;
      v25 = 0u;
      v26 = 0u;
      v27 = 0u;
      v28 = 0u;
      v29 = 0u;
      v32 = 0;
      v37 = 0u;
      v38 = 0u;
      v34 = 0;
      v36 = 0u;
      v39 = 0;
      v35 = v5;
      v3 = 1;
      v33 = 1;
      re::Message::Message((re::Message *)v7, (const re::Message *)&v11);
      re::Raft::step((uint64_t)this, v7, v8);
      re::Message::~Message((re::Message *)v7);
      re::Message::~Message((re::Message *)&v11);
    }
  }
  return v3;
}

BOOL re::Raft::promotable(re::Raft *this)
{
  _BOOL8 v2;
  uint64_t v4[6];

  re::ProgressSet::voterIds((re::Raft *)((char *)this + 552), (uint64_t)v4);
  v2 = re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains((uint64_t)v4, (uint64_t *)this + 132);
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(v4);
  return v2;
}

void re::Raft::step(uint64_t a1@<X0>, _QWORD *a2@<X1>, _BYTE *a3@<X8>)
{
  _QWORD *v3;
  unint64_t v6;
  unint64_t v7;
  int v8;
  _BOOL4 v10;
  size_t v11;
  int v12;
  uint64_t v13;
  uint64_t v15;
  int v16;
  unint64_t v17;
  re::Message *v18;
  uint64_t v19;
  uint64_t v21;
  unint64_t v22;
  _BOOL4 isUpToDate;
  char v24;
  char v25;
  int v26;
  __n128 *v27;
  uint64_t v28;
  __n128 *v29;
  uint64_t v30;
  _BOOL4 v31;
  unint64_t v32;
  unint64_t v33;
  _QWORD *v34;
  void *v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  _QWORD *v43;
  _BOOL4 hasQuorum;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  unint64_t v57;
  uint64_t *v58;
  uint64_t *v59;
  uint64_t v61;
  unint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  unint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  unint64_t v70;
  uint64_t v71;
  uint64_t v72;
  BOOL v73;
  unint64_t v74;
  uint64_t v75;
  unint64_t v76;
  uint64_t v77;
  uint64_t v78;
  re::Message *v79;
  uint64_t v80;
  unsigned int v81;
  uint64_t v82;
  uint64_t v83;
  __int16 *v84;
  unint64_t v85;
  unint64_t v86;
  uint64_t Index;
  int v88;
  uint64_t v89;
  unsigned int v90;
  uint64_t v91;
  uint64_t v92;
  unint64_t v93;
  uint64_t v95;
  uint64_t v96;
  unint64_t v97;
  uint64_t v98;
  uint64_t *v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  unsigned int v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  unint64_t v108;
  uint64_t v109;
  unint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  re::Message *v114;
  uint64_t v115;
  re::Message *v116;
  uint64_t v117;
  __n128 v118;
  unint64_t v119;
  uint64_t *v120;
  uint64_t v121;
  unsigned __int8 v122;
  unint64_t v123[3];
  unint64_t v124;
  uint64_t v125;
  uint64_t v126;
  char v127;
  _BYTE v128[384];
  _BYTE v129[384];
  _BYTE v130[384];
  _BYTE v131[384];
  uint64_t v132[3];
  int v133;
  uint64_t v134;
  uint64_t v135;
  __int16 v136;
  _BYTE v137[384];
  char v138[384];
  uint64_t v139[2];
  uint64_t v140;
  int v141;
  re::Message *v142;
  __int128 v143;
  __int128 v144;
  __int128 v145;
  __n128 v146;
  uint64_t v147;
  int v148;
  void *__s2[2];
  __int128 v150;
  int v151;
  __int128 v152;
  __int128 v153;
  __int128 v154;
  __int128 v155;
  __int128 v156;
  __int128 v157;
  __int128 v158;
  __int128 v159;
  __int128 v160;
  __int128 v161;
  __int128 v162;
  __int128 v163;
  __int128 v164;
  __int128 v165;
  uint64_t v166;
  char v167;
  unint64_t v168;
  __int128 v169;
  __int128 v170;
  _OWORD v171[3];

  v3 = a2;
  v6 = a2[41];
  if (!v6)
    goto LABEL_38;
  v7 = *(_QWORD *)(a1 + 1040);
  if (v6 <= v7)
  {
    if (v6 < v7)
    {
      if (*(_BYTE *)(a1 + 1153) || *(_BYTE *)(a1 + 1154))
      {
        v16 = *((unsigned __int8 *)a2 + 304);
        if (v16 == 8 || v16 == 3)
        {
          v17 = a2[40];
          v147 = 0;
          v146 = 0uLL;
          v148 = 0;
          *(_OWORD *)__s2 = 0u;
          v150 = 0u;
          v151 = 0;
          v164 = 0u;
          v165 = 0u;
          v152 = 0u;
          v153 = 0u;
          v154 = 0u;
          v155 = 0u;
          v156 = 0u;
          v157 = 0u;
          v158 = 0u;
          v159 = 0u;
          v160 = 0u;
          v161 = 0u;
          v162 = 0u;
          v163 = 0u;
          v166 = 0;
          memset(v171, 0, 25);
          v170 = 0u;
          v169 = 0u;
          v168 = v17;
          v167 = 4;
          re::Message::Message((re::Message *)v131, (const re::Message *)&v146);
          re::Raft::send(a1, (uint64_t)v131);
          v18 = (re::Message *)v131;
LABEL_63:
          re::Message::~Message(v18);
LABEL_64:
          v27 = &v146;
LABEL_65:
          re::Message::~Message((re::Message *)v27);
          goto LABEL_66;
        }
      }
      else
      {
        v16 = *((unsigned __int8 *)a2 + 304);
      }
      if (v16 != 17)
        goto LABEL_66;
      v32 = a2[40];
      v147 = 0;
      v146 = 0uLL;
      v148 = 0;
      *(_OWORD *)__s2 = 0u;
      v150 = 0u;
      v151 = 0;
      v164 = 0u;
      v165 = 0u;
      v152 = 0u;
      v153 = 0u;
      v154 = 0u;
      v155 = 0u;
      v156 = 0u;
      v157 = 0u;
      v158 = 0u;
      v159 = 0u;
      v160 = 0u;
      v161 = 0u;
      v162 = 0u;
      v163 = 0u;
      v166 = 0;
      memset(v171, 0, 24);
      *(_QWORD *)&v169 = 0;
      v170 = 0u;
      v168 = v32;
      v167 = 18;
      *((_QWORD *)&v169 + 1) = v7;
      BYTE8(v171[1]) = 1;
      re::Message::Message((re::Message *)v130, (const re::Message *)&v146);
      re::Raft::send(a1, (uint64_t)v130);
      v18 = (re::Message *)v130;
      goto LABEL_63;
    }
  }
  else
  {
    v8 = *((unsigned __int8 *)a2 + 304);
    if (v8 == 17 || v8 == 5)
    {
      v138[0] = 0;
      re::DynamicArray<unsigned char>::DynamicArray((uint64_t)&v146, v138, 1uLL);
      v10 = 0;
      v11 = v3[7];
      if (v11 == v147)
        v10 = memcmp((const void *)v3[9], __s2[0], v11) == 0;
      if (v146.n128_u64[0])
      {
        a2 = __s2[0];
        if (__s2[0])
          (*(void (**)(void))(*(_QWORD *)v146.n128_u64[0] + 40))();
      }
      if (*(_BYTE *)(a1 + 1153) && *(_QWORD *)(a1 + 1064))
      {
        v12 = *(_QWORD *)(a1 + 1096) >= *(_QWORD *)(a1 + 1120) || v10;
        if (v12 != 1)
          goto LABEL_66;
      }
      v8 = *((unsigned __int8 *)v3 + 304);
    }
    v13 = 0;
    if (v8 <= 16)
    {
      if ((v8 - 7) < 2 || v8 == 3)
        v13 = v3[40];
      goto LABEL_27;
    }
    if (v8 != 17)
    {
      if (v8 != 18)
      {
LABEL_27:
        v15 = *(_QWORD *)(a1 + 1080);
        re::Raft::reset((re::Raft *)a1, v3[41]);
        *(_QWORD *)(a1 + 1064) = v13;
        *(_BYTE *)(a1 + 536) = 0;
        *(_QWORD *)(a1 + 1080) = v15;
        goto LABEL_38;
      }
      if (*((_BYTE *)v3 + 376))
      {
        v13 = 0;
        goto LABEL_27;
      }
    }
  }
LABEL_38:
  v19 = *((unsigned __int8 *)v3 + 304);
  if ((_DWORD)v19 == 17 || (_DWORD)v19 == 5)
  {
    v21 = *(_QWORD *)(a1 + 1048);
    v22 = v3[40];
    if (v21 != v22 && (v21 || *(_QWORD *)(a1 + 1064)))
    {
      if ((_DWORD)v19 != 17)
        goto LABEL_55;
      if (v3[41] <= *(_QWORD *)(a1 + 1040))
        goto LABEL_57;
    }
    isUpToDate = re::RaftLog::isUpToDate((re::RaftLog *)a1, v3[43], v3[42]);
    v22 = v3[40];
    v19 = *((unsigned __int8 *)v3 + 304);
    if (isUpToDate)
    {
      if ((_DWORD)v19 == 5)
      {
        v24 = 6;
LABEL_68:
        v146 = 0uLL;
        v148 = 0;
        v147 = 0;
        *(_OWORD *)__s2 = 0u;
        v150 = 0u;
        v151 = 0;
        v164 = 0u;
        v165 = 0u;
        v152 = 0u;
        v153 = 0u;
        v154 = 0u;
        v155 = 0u;
        v156 = 0u;
        v157 = 0u;
        v158 = 0u;
        v159 = 0u;
        v160 = 0u;
        v161 = 0u;
        v162 = 0u;
        v163 = 0u;
        v166 = 0;
        memset(v171, 0, 25);
        v169 = 0u;
        v170 = 0u;
        v168 = v22;
        v167 = v24;
        *((_QWORD *)&v169 + 1) = v3[41];
        re::Message::Message((re::Message *)v129, (const re::Message *)&v146);
        re::Raft::send(a1, (uint64_t)v129);
        re::Message::~Message((re::Message *)v129);
        if (*((_BYTE *)v3 + 304) == 5)
        {
          *(_QWORD *)(a1 + 1096) = 0;
          *(_QWORD *)(a1 + 1048) = v3[40];
        }
        goto LABEL_64;
      }
      if ((_DWORD)v19 == 17)
      {
        v24 = 18;
        goto LABEL_68;
      }
LABEL_300:
      re::internal::assertLog((re::internal *)5, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Not a vote message %hhu", "!\"Unreachable code\"", "voteRespMsgType", 281, v19);
      _os_crash();
      __break(1u);
      goto LABEL_301;
    }
LABEL_55:
    if ((_DWORD)v19 == 5)
    {
      v25 = 6;
      goto LABEL_62;
    }
    if ((_DWORD)v19 == 17)
    {
LABEL_57:
      v25 = 18;
LABEL_62:
      v146 = 0uLL;
      v148 = 0;
      v147 = 0;
      *(_OWORD *)__s2 = 0u;
      v150 = 0u;
      v151 = 0;
      v164 = 0u;
      v165 = 0u;
      v152 = 0u;
      v153 = 0u;
      v154 = 0u;
      v155 = 0u;
      v156 = 0u;
      v157 = 0u;
      v158 = 0u;
      v159 = 0u;
      v160 = 0u;
      v161 = 0u;
      v162 = 0u;
      v163 = 0u;
      v166 = 0;
      memset(v171, 0, 24);
      v169 = 0u;
      v170 = 0u;
      v168 = v22;
      v167 = v25;
      BYTE8(v171[1]) = 1;
      *((_QWORD *)&v169 + 1) = *(_QWORD *)(a1 + 1040);
      re::Message::Message((re::Message *)v128, (const re::Message *)&v146);
      re::Raft::send(a1, (uint64_t)v128);
      v18 = (re::Message *)v128;
      goto LABEL_63;
    }
    re::internal::assertLog((re::internal *)5, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Not a vote message %hhu", "!\"Unreachable code\"", "voteRespMsgType", 281, v19);
    _os_crash();
    __break(1u);
    goto LABEL_300;
  }
  if (!*((_BYTE *)v3 + 304))
  {
    re::Raft::hup(a1, 0);
LABEL_66:
    *a3 = 1;
    return;
  }
  v26 = *(unsigned __int8 *)(a1 + 536);
  switch(*(_BYTE *)(a1 + 536))
  {
    case 0:
      switch(*((_BYTE *)v3 + 304))
      {
        case 2:
          v28 = *(_QWORD *)(a1 + 1064);
          if (!v28)
            goto LABEL_60;
          v3[39] = v28;
          re::Message::Message((re::Message *)&v146, (const re::Message *)v3);
          re::Raft::send(a1, (uint64_t)&v146);
          v29 = &v146;
          break;
        case 3:
          *(_QWORD *)(a1 + 1096) = 0;
          *(_QWORD *)(a1 + 1064) = v3[40];
          re::Raft::handleAppendEntries((re::Raft *)a1, (const re::Message *)v3);
          goto LABEL_133;
        case 7:
          *(_QWORD *)(a1 + 1096) = 0;
          *(_QWORD *)(a1 + 1064) = v3[40];
          re::Raft::handleSnapshot((re::Raft *)a1, (const re::Message *)v3);
          goto LABEL_133;
        case 8:
          *(_QWORD *)(a1 + 1096) = 0;
          *(_QWORD *)(a1 + 1064) = v3[40];
          re::Raft::handleHeartbeat((re::Raft *)a1, (const re::Message *)v3);
          goto LABEL_133;
        case 0xD:
          v50 = *(_QWORD *)(a1 + 1064);
          if (!v50)
            goto LABEL_133;
          v3[39] = v50;
          re::Message::Message((re::Message *)v138, (const re::Message *)v3);
          re::Raft::send(a1, (uint64_t)v138);
          v29 = (__n128 *)v138;
          break;
        case 0xE:
          if (re::Raft::promotable((re::Raft *)a1))
            re::Raft::hup(a1, 1);
          goto LABEL_133;
        case 0xF:
          v51 = *(_QWORD *)(a1 + 1064);
          if (!v51)
            goto LABEL_133;
          v3[39] = v51;
          re::Message::Message((re::Message *)v137, (const re::Message *)v3);
          re::Raft::send(a1, (uint64_t)v137);
          v29 = (__n128 *)v137;
          break;
        case 0x10:
          if (v3[2] == 1)
          {
            memset(v132, 0, sizeof(v132));
            v133 = 0;
            v52 = v3[43];
            v134 = 0;
            v135 = v52;
            re::DynamicArray<BOOL>::operator=((uint64_t)v132, (uint64_t *)v3[4]);
            re::DynamicArray<re::ReadState>::add(a1 + 352, v132);
            if (v132[0])
            {
              if (v134)
                (*(void (**)(void))(*(_QWORD *)v132[0] + 40))();
            }
          }
          goto LABEL_133;
        default:
          goto LABEL_133;
      }
      re::Message::~Message((re::Message *)v29);
LABEL_133:
      *a3 = 1;
      goto LABEL_66;
    case 1:
    case 3:
      switch(*((_BYTE *)v3 + 304))
      {
        case 2:
LABEL_60:
          *(_WORD *)a3 = 1024;
          return;
        case 3:
          v37 = v3[40];
          v38 = *(_QWORD *)(a1 + 1080);
          re::Raft::reset((re::Raft *)a1, v3[41]);
          *(_QWORD *)(a1 + 1064) = v37;
          *(_BYTE *)(a1 + 536) = 0;
          *(_QWORD *)(a1 + 1080) = v38;
          re::Raft::handleAppendEntries((re::Raft *)a1, (const re::Message *)v3);
          goto LABEL_66;
        case 4:
        case 5:
          goto LABEL_66;
        case 6:
          goto LABEL_94;
        case 7:
          v39 = v3[40];
          v40 = *(_QWORD *)(a1 + 1080);
          re::Raft::reset((re::Raft *)a1, v3[41]);
          *(_QWORD *)(a1 + 1064) = v39;
          *(_BYTE *)(a1 + 536) = 0;
          *(_QWORD *)(a1 + 1080) = v40;
          re::Raft::handleSnapshot((re::Raft *)a1, (const re::Message *)v3);
          goto LABEL_66;
        case 8:
          v41 = v3[40];
          v42 = *(_QWORD *)(a1 + 1080);
          re::Raft::reset((re::Raft *)a1, v3[41]);
          *(_QWORD *)(a1 + 1064) = v41;
          *(_BYTE *)(a1 + 536) = 0;
          *(_QWORD *)(a1 + 1080) = v42;
          re::Raft::handleHeartbeat((re::Raft *)a1, (const re::Message *)v3);
          goto LABEL_66;
        default:
          if ((_DWORD)v19 != 18)
            goto LABEL_66;
LABEL_94:
          if (((_DWORD)v19 == 18 || v26 != 3) && ((_DWORD)v19 == 6 || v26 != 1))
          {
            re::Raft::registerVote((re::Raft *)a1, v3[40], *((_BYTE *)v3 + 376) == 0);
            v36 = re::ProgressSet::candidacyStatus(a1 + 552, a1 + 304);
            if (v36 == 2)
            {
              v54 = *(_QWORD *)(a1 + 1080);
              re::Raft::reset((re::Raft *)a1, *(_QWORD *)(a1 + 1040));
              *(_QWORD *)(a1 + 1064) = 0;
              *(_BYTE *)(a1 + 536) = 0;
              *(_QWORD *)(a1 + 1080) = v54;
            }
            else if (!v36)
            {
              if (*(_BYTE *)(a1 + 536) == 3)
              {
                v138[0] = 2;
                re::DynamicArray<unsigned char>::DynamicArray((uint64_t)&v146, v138, 1uLL);
                re::Raft::campaign(a1, (uint64_t)&v146);
                if (v146.n128_u64[0] && __s2[0])
                  (*(void (**)(void))(*(_QWORD *)v146.n128_u64[0] + 40))();
              }
              else
              {
                re::Raft::becomeLeader((re::Raft *)a1);
                re::Raft::broadcastAppend((re::Raft *)a1);
              }
            }
          }
          break;
      }
      goto LABEL_66;
    case 2:
      re::Message::Message((re::Message *)&v118, (const re::Message *)v3);
      if (v122 > 0xBu)
      {
        if (v122 == 12)
        {
          if (!re::ProgressSet::quorumRecentlyActive((re::ProgressSet *)(a1 + 552), *(_QWORD *)(a1 + 1056)))
          {
            v49 = *(_QWORD *)(a1 + 1080);
            re::Raft::reset((re::Raft *)a1, *(_QWORD *)(a1 + 1040));
            *(_QWORD *)(a1 + 1064) = 0;
            *(_BYTE *)(a1 + 536) = 0;
            *(_QWORD *)(a1 + 1080) = v49;
          }
          goto LABEL_155;
        }
        if (v122 != 15)
        {
LABEL_107:
          v136 = 0;
          v142 = 0;
          v140 = 0;
          v139[0] = 0;
          v139[1] = 0;
          v43 = (_QWORD *)(a1 + 552);
          v141 = 0;
          if (re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::containsKey(a1 + 552, (uint64_t *)v123))
          {
            hasQuorum = 0;
            switch(v122)
            {
              case 4u:
                LODWORD(v45) = 0x7FFFFFFF;
                if (!*v43)
                  goto LABEL_201;
                v46 = 0x94D049BB133111EBLL
                    * ((0xBF58476D1CE4E5B9 * (v123[0] ^ (v123[0] >> 30))) ^ ((0xBF58476D1CE4E5B9
                                                                              * (v123[0] ^ (v123[0] >> 30))) >> 27));
                v47 = *(unsigned int *)(*(_QWORD *)(a1 + 560) + 4 * ((v46 ^ (v46 >> 31)) % *(unsigned int *)(a1 + 576)));
                if ((_DWORD)v47 == 0x7FFFFFFF)
                  goto LABEL_201;
                v48 = *(_QWORD *)(a1 + 568);
                LODWORD(v45) = v47;
                if (*(_QWORD *)(v48 + 136 * v47 + 16) == v123[0])
                  goto LABEL_201;
                v45 = v47;
                while (1)
                {
                  LODWORD(v45) = *(_DWORD *)(v48 + 136 * v45 + 8) & 0x7FFFFFFF;
                  if ((_DWORD)v45 == 0x7FFFFFFF)
                    break;
                  if (*(_QWORD *)(v48 + 136 * v45 + 16) == v123[0])
                    goto LABEL_201;
                }
                LODWORD(v45) = 0x7FFFFFFF;
LABEL_201:
                v80 = *(_QWORD *)(a1 + 568);
                v81 = v45;
                v82 = v80 + 136 * v45;
                v83 = v82 + 24;
                *(_BYTE *)(v82 + 129) = 1;
                if (v127)
                {
                  if (!re::Progress::maybeDecrementTo((re::Progress *)v83, v124, v126, v125))
                    goto LABEL_269;
                  if (*(_BYTE *)(v80 + 136 * v81 + 88) == 1)
                    re::Progress::becomeProbe(v83);
                  hasQuorum = 0;
                  v84 = (__int16 *)((char *)&v136 + 1);
LABEL_264:
                  *(_BYTE *)v84 = 1;
                  goto LABEL_270;
                }
                if (*(_BYTE *)(v82 + 88) == 1)
                {
                  hasQuorum = *(_QWORD *)(v82 + 72) == *(_QWORD *)(v82 + 80);
                }
                else if (*(_BYTE *)(v82 + 88))
                {
                  hasQuorum = 1;
                }
                else
                {
                  hasQuorum = *(_BYTE *)(v82 + 128) != 0;
                }
                v85 = v124;
                v86 = *(_QWORD *)(v83 + 72);
                if (v86 < v124)
                {
                  *(_QWORD *)(v83 + 72) = v124;
                  *(_BYTE *)(v83 + 104) = 0;
                }
                if (*(_QWORD *)(v83 + 80) < v85 + 1)
                  *(_QWORD *)(v83 + 80) = v85 + 1;
                if (v86 < v85)
                {
                  if (*(_BYTE *)(a1 + 1024))
                  {
                    Index = re::RaftLog::lastIndex((re::RaftLog *)a1);
                    if (v123[0] == *(_QWORD *)(a1 + 1032) && *(_QWORD *)(v80 + 136 * v81 + 96) == Index)
                      re::Raft::sendTimeoutNow((re::Raft *)a1, v123[0]);
                  }
                  v88 = *(unsigned __int8 *)(v80 + 136 * v81 + 88);
                  if (v88 == 2)
                  {
                    if (*(_QWORD *)(v80 + 136 * v81 + 96) < *(_QWORD *)(v80 + 136 * v81 + 112))
                      goto LABEL_270;
                    re::Progress::becomeProbe(v83);
                  }
                  else if (v88 == 1)
                  {
                    re::Inflights::freeTo((_QWORD *)v83, v124);
                  }
                  else if (!*(_BYTE *)(v80 + 136 * v81 + 88))
                  {
                    *(_BYTE *)(v83 + 104) = 0;
                    *(_BYTE *)(v83 + 64) = 1;
                    *(_QWORD *)(v83 + 40) = 0;
                    *(_QWORD *)(v83 + 48) = 0;
                    *(_QWORD *)(v83 + 80) = *(_QWORD *)(v83 + 72) + 1;
                    *(_QWORD *)(v83 + 88) = 0;
                  }
                  v84 = &v136;
                  goto LABEL_264;
                }
LABEL_270:
                v146.n128_u8[0] = 1;
                re::ProgressSet::ProgressSet((re::ProgressSet *)&v146.n128_i8[8], (const re::ProgressSet *)(a1 + 552));
                re::Optional<re::ProgressSet>::operator=((_BYTE *)(a1 + 544), (uint64_t *)&v146);
                if (v146.n128_u8[0])
                  re::ProgressSet::~ProgressSet((re::ProgressSet *)&v146.n128_i8[8]);
                if (!(_BYTE)v136)
                  break;
                v108 = re::ProgressSet::maximalCommittedIndex((re::ProgressSet *)(a1 + 552));
                if (!re::RaftLog::maybeCommit((re::RaftLog *)a1, v108, *(_QWORD *)(a1 + 1040)))
                {
                  if (hasQuorum | HIBYTE(v136))
                  {
LABEL_279:
                    LODWORD(v109) = 0x7FFFFFFF;
                    if (*v43)
                    {
                      v110 = 0x94D049BB133111EBLL
                           * ((0xBF58476D1CE4E5B9 * (v123[0] ^ (v123[0] >> 30))) ^ ((0xBF58476D1CE4E5B9
                                                                                     * (v123[0] ^ (v123[0] >> 30))) >> 27));
                      v111 = *(unsigned int *)(*(_QWORD *)(a1 + 560)
                                             + 4 * ((v110 ^ (v110 >> 31)) % *(unsigned int *)(a1 + 576)));
                      if ((_DWORD)v111 != 0x7FFFFFFF)
                      {
                        v112 = *(_QWORD *)(a1 + 568);
                        LODWORD(v109) = v111;
                        if (*(_QWORD *)(v112 + 136 * v111 + 16) != v123[0])
                        {
                          v109 = v111;
                          while (1)
                          {
                            LODWORD(v109) = *(_DWORD *)(v112 + 136 * v109 + 8) & 0x7FFFFFFF;
                            if ((_DWORD)v109 == 0x7FFFFFFF)
                              break;
                            if (*(_QWORD *)(v112 + 136 * v109 + 16) == v123[0])
                              goto LABEL_289;
                          }
                          LODWORD(v109) = 0x7FFFFFFF;
                        }
                      }
                    }
LABEL_289:
                    re::Raft::sendAppend((__n128 **)a1, v123[0], (re::Progress *)(*(_QWORD *)(a1 + 568) + 136 * v109 + 24));
                    v146.n128_u8[0] = 1;
                    re::ProgressSet::ProgressSet((re::ProgressSet *)&v146.n128_i8[8], (const re::ProgressSet *)(a1 + 552));
                    re::Optional<re::ProgressSet>::operator=((_BYTE *)(a1 + 544), (uint64_t *)&v146);
                    if (v146.n128_u8[0])
                      re::ProgressSet::~ProgressSet((re::ProgressSet *)&v146.n128_i8[8]);
                  }
LABEL_291:
                  v113 = v140;
                  if (v140)
                  {
                    v114 = v142;
                    v115 = 384 * v140;
                    v116 = v142;
                    do
                    {
                      re::Message::Message((re::Message *)v132, v116);
                      re::Raft::send(a1, (uint64_t)v132);
                      re::Message::~Message((re::Message *)v132);
                      v116 = (re::Message *)((char *)v116 + 384);
                      v115 -= 384;
                    }
                    while (v115);
                    v140 = 0;
                    v117 = 384 * v113;
                    do
                    {
                      re::Message::~Message(v114);
                      v114 = (re::Message *)((char *)v114 + 384);
                      v117 -= 384;
                    }
                    while (v117);
                    ++v141;
                  }
                  *a3 = 1;
                  re::DynamicArray<re::Message>::deinit((uint64_t)v139);
                  goto LABEL_298;
                }
                if (!*(_BYTE *)(a1 + 1155) || *(_QWORD *)(a1 + 1072) > *(_QWORD *)(a1 + 296) || *(_BYTE *)(a1 + 856))
                  re::Raft::broadcastAppend((re::Raft *)a1);
                break;
              case 9u:
                LODWORD(v61) = 0x7FFFFFFF;
                if (!*v43)
                  goto LABEL_225;
                v62 = 0x94D049BB133111EBLL
                    * ((0xBF58476D1CE4E5B9 * (v123[0] ^ (v123[0] >> 30))) ^ ((0xBF58476D1CE4E5B9
                                                                              * (v123[0] ^ (v123[0] >> 30))) >> 27));
                v63 = *(unsigned int *)(*(_QWORD *)(a1 + 560) + 4 * ((v62 ^ (v62 >> 31)) % *(unsigned int *)(a1 + 576)));
                if ((_DWORD)v63 == 0x7FFFFFFF)
                  goto LABEL_225;
                v64 = *(_QWORD *)(a1 + 568);
                LODWORD(v61) = v63;
                if (*(_QWORD *)(v64 + 136 * v63 + 16) == v123[0])
                  goto LABEL_225;
                v61 = v63;
                while (1)
                {
                  LODWORD(v61) = *(_DWORD *)(v64 + 136 * v61 + 8) & 0x7FFFFFFF;
                  if ((_DWORD)v61 == 0x7FFFFFFF)
                    break;
                  if (*(_QWORD *)(v64 + 136 * v61 + 16) == v123[0])
                    goto LABEL_225;
                }
                LODWORD(v61) = 0x7FFFFFFF;
LABEL_225:
                v89 = *(_QWORD *)(a1 + 568);
                v90 = v61;
                v91 = v89 + 136 * v61;
                *(_WORD *)(v91 + 128) = 256;
                if (*(_BYTE *)(v91 + 88) == 1 && *(_QWORD *)(v91 + 72) == *(_QWORD *)(v91 + 80))
                  re::Inflights::freeFirstOne((re::Inflights *)(v91 + 24));
                v92 = v89 + 136 * v90;
                v93 = *(_QWORD *)(v92 + 96);
                if (v93 < re::RaftLog::lastIndex((re::RaftLog *)a1) || *(_QWORD *)(v92 + 120) != 0)
                  HIBYTE(v136) = 1;
                hasQuorum = 0;
                if (!*(_BYTE *)(a1 + 528))
                {
                  if (v121)
                  {
                    re::ReadOnly::recvAck((re::ReadOnly *)(a1 + 432), (const re::Message *)&v118, (uint64_t)&v146);
                    hasQuorum = re::ProgressSet::hasQuorum(a1 + 552, (uint64_t)&v146);
                    re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v146);
                    if (hasQuorum)
                    {
                      re::ReadOnly::advance((re::ReadOnly *)(a1 + 432), (const re::Message *)&v118, (uint64_t)&v143);
                      if ((_QWORD)v144)
                      {
                        v95 = v145;
                        v96 = 440 * v144;
                        do
                        {
                          v97 = *(_QWORD *)(v95 + 368);
                          if (v97 && v97 != *(_QWORD *)(a1 + 1056))
                          {
                            v146 = 0uLL;
                            v148 = 0;
                            v147 = 0;
                            *(_OWORD *)__s2 = 0u;
                            v150 = 0u;
                            v151 = 0;
                            v152 = 0u;
                            v153 = 0u;
                            v154 = 0u;
                            v155 = 0u;
                            v156 = 0u;
                            v157 = 0u;
                            v158 = 0u;
                            v159 = 0u;
                            v160 = 0u;
                            v161 = 0u;
                            v162 = 0u;
                            v163 = 0u;
                            v164 = 0u;
                            v165 = 0u;
                            v166 = 0;
                            v170 = 0u;
                            memset(v171, 0, 25);
                            v169 = 0u;
                            v167 = 16;
                            v168 = v97;
                            *((_QWORD *)&v170 + 1) = *(_QWORD *)(v95 + 432);
                            re::DynamicArray<re::Entry>::operator=(&v146, (__n128 *)(v95 + 48));
                            re::DynamicArray<re::Message>::add((uint64_t)v139, (re::Message *)&v146);
                            re::Message::~Message((re::Message *)&v146);
                          }
                          else
                          {
                            v146 = 0uLL;
                            v148 = 0;
                            v147 = 0;
                            __s2[0] = 0;
                            __s2[1] = *(void **)(v95 + 432);
                            re::DynamicArray<BOOL>::operator=((uint64_t)&v146, *(uint64_t **)(v95 + 80));
                            re::DynamicArray<re::ReadState>::add(a1 + 352, (uint64_t *)&v146);
                            if (v146.n128_u64[0] && __s2[0])
                              (*(void (**)(void))(*(_QWORD *)v146.n128_u64[0] + 40))();
                          }
                          v95 += 440;
                          v96 -= 440;
                        }
                        while (v96);
                      }
                      v98 = v143;
                      if ((_QWORD)v143)
                      {
                        v99 = (uint64_t *)v145;
                        if ((_QWORD)v145)
                        {
                          if ((_QWORD)v144)
                          {
                            v100 = 440 * v144;
                            do
                            {
                              re::Message::~Message((re::Message *)(v99 + 6));
                              re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(v99);
                              v99 += 55;
                              v100 -= 440;
                            }
                            while (v100);
                            v98 = v143;
                            v99 = (uint64_t *)v145;
                          }
                          (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v98 + 40))(v98, v99);
                        }
                      }
                      goto LABEL_269;
                    }
                  }
                }
                goto LABEL_270;
              case 0xAu:
                LODWORD(v65) = 0x7FFFFFFF;
                if (!*v43)
                  goto LABEL_253;
                v66 = 0x94D049BB133111EBLL
                    * ((0xBF58476D1CE4E5B9 * (v123[0] ^ (v123[0] >> 30))) ^ ((0xBF58476D1CE4E5B9
                                                                              * (v123[0] ^ (v123[0] >> 30))) >> 27));
                v67 = *(unsigned int *)(*(_QWORD *)(a1 + 560) + 4 * ((v66 ^ (v66 >> 31)) % *(unsigned int *)(a1 + 576)));
                if ((_DWORD)v67 == 0x7FFFFFFF)
                  goto LABEL_253;
                v68 = *(_QWORD *)(a1 + 568);
                LODWORD(v65) = v67;
                if (*(_QWORD *)(v68 + 136 * v67 + 16) == v123[0])
                  goto LABEL_253;
                v65 = v67;
                while (1)
                {
                  LODWORD(v65) = *(_DWORD *)(v68 + 136 * v65 + 8) & 0x7FFFFFFF;
                  if ((_DWORD)v65 == 0x7FFFFFFF)
                    break;
                  if (*(_QWORD *)(v68 + 136 * v65 + 16) == v123[0])
                    goto LABEL_253;
                }
                LODWORD(v65) = 0x7FFFFFFF;
LABEL_253:
                v101 = *(_QWORD *)(a1 + 568);
                if (*(_BYTE *)(v101 + 136 * v65 + 88) == 1)
                  re::Progress::becomeProbe(v101 + 136 * v65 + 24);
                goto LABEL_269;
              case 0xBu:
                LODWORD(v69) = 0x7FFFFFFF;
                if (!*v43)
                  goto LABEL_256;
                v70 = 0x94D049BB133111EBLL
                    * ((0xBF58476D1CE4E5B9 * (v123[0] ^ (v123[0] >> 30))) ^ ((0xBF58476D1CE4E5B9
                                                                              * (v123[0] ^ (v123[0] >> 30))) >> 27));
                v71 = *(unsigned int *)(*(_QWORD *)(a1 + 560) + 4 * ((v70 ^ (v70 >> 31)) % *(unsigned int *)(a1 + 576)));
                if ((_DWORD)v71 == 0x7FFFFFFF)
                  goto LABEL_256;
                v72 = *(_QWORD *)(a1 + 568);
                LODWORD(v69) = v71;
                if (*(_QWORD *)(v72 + 136 * v71 + 16) == v123[0])
                  goto LABEL_256;
                v69 = v71;
                while (1)
                {
                  LODWORD(v69) = *(_DWORD *)(v72 + 136 * v69 + 8) & 0x7FFFFFFF;
                  if ((_DWORD)v69 == 0x7FFFFFFF)
                    break;
                  if (*(_QWORD *)(v72 + 136 * v69 + 16) == v123[0])
                    goto LABEL_256;
                }
                LODWORD(v69) = 0x7FFFFFFF;
LABEL_256:
                v102 = *(_QWORD *)(a1 + 568);
                v103 = v102 + 136 * v69;
                if (*(_BYTE *)(v103 + 88) != 2)
                  goto LABEL_269;
                v104 = v69;
                if (v127)
                  *(_QWORD *)(v102 + 136 * v69 + 112) = 0;
                re::Progress::becomeProbe(v103 + 24);
                hasQuorum = 0;
                v105 = v102 + 136 * v104;
                *(_BYTE *)(v105 + 128) = 1;
                *(_QWORD *)(v105 + 120) = 0;
                goto LABEL_270;
              case 0xDu:
                *(_QWORD *)&v143 = v123[0];
                re::ProgressSet::learnerIds((re::ProgressSet *)(a1 + 552), (uint64_t)&v146);
                v73 = re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains((uint64_t)&v146, (uint64_t *)&v143);
                re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v146);
                if (v73)
                  goto LABEL_269;
                v74 = v143;
                if (!*(_BYTE *)(a1 + 1024))
                  goto LABEL_182;
                if (*(_QWORD *)(a1 + 1032) == (_QWORD)v143)
                  goto LABEL_269;
                *(_BYTE *)(a1 + 1024) = 0;
LABEL_182:
                if (v74 == *(_QWORD *)(a1 + 1056))
                  goto LABEL_269;
                *(_QWORD *)(a1 + 1096) = 0;
                *(_BYTE *)(a1 + 1024) = 1;
                *(_QWORD *)(a1 + 1032) = v74;
                LODWORD(v75) = 0x7FFFFFFF;
                if (!*(_QWORD *)(a1 + 552))
                  goto LABEL_266;
                v76 = 0x94D049BB133111EBLL
                    * ((0xBF58476D1CE4E5B9 * (v74 ^ (v74 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v74 ^ (v74 >> 30))) >> 27));
                v77 = *(unsigned int *)(*(_QWORD *)(a1 + 560) + 4 * ((v76 ^ (v76 >> 31)) % *(unsigned int *)(a1 + 576)));
                if ((_DWORD)v77 == 0x7FFFFFFF)
                  goto LABEL_266;
                v78 = *(_QWORD *)(a1 + 568);
                LODWORD(v75) = v77;
                if (*(_QWORD *)(v78 + 136 * v77 + 16) == v74)
                  goto LABEL_266;
                v75 = v77;
                while (1)
                {
                  LODWORD(v75) = *(_DWORD *)(v78 + 136 * v75 + 8) & 0x7FFFFFFF;
                  if ((_DWORD)v75 == 0x7FFFFFFF)
                    break;
                  if (*(_QWORD *)(v78 + 136 * v75 + 16) == v74)
                    goto LABEL_266;
                }
                LODWORD(v75) = 0x7FFFFFFF;
LABEL_266:
                v106 = *(_QWORD *)(a1 + 568);
                v107 = *(_QWORD *)(v106 + 136 * v75 + 96);
                if (v107 == re::RaftLog::lastIndex((re::RaftLog *)a1))
                  re::Raft::sendTimeoutNow((re::Raft *)a1, v74);
                else
                  re::Raft::sendAppend((__n128 **)a1, v74, (re::Progress *)(v106 + 136 * v75 + 24));
LABEL_269:
                hasQuorum = 0;
                goto LABEL_270;
              default:
                goto LABEL_270;
            }
          }
          if (HIBYTE(v136))
            goto LABEL_279;
          goto LABEL_291;
        }
        re::RaftLog::getTerm((re::RaftLog *)a1, *(_QWORD *)(a1 + 288), (uint64_t)&v146);
        if (v146.n128_u8[0])
          v33 = v146.n128_u64[1];
        else
          v33 = 0;
        if (v33 != *(_QWORD *)(a1 + 1040))
        {
LABEL_155:
          *a3 = 1;
LABEL_298:
          v27 = &v118;
          goto LABEL_65;
        }
        v145 = 0u;
        v144 = 0u;
        v143 = 0u;
        DWORD1(v145) = 0x7FFFFFFF;
        v34 = (_QWORD *)(a1 + 1056);
        re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)&v143, (uint64_t *)(a1 + 1056));
        if (re::ProgressSet::hasQuorum(a1 + 552, (uint64_t)&v143))
        {
          if (!v123[0] || v123[0] == *v34)
          {
            v146 = 0uLL;
            v148 = 0;
            v147 = 0;
            v35 = *(void **)(a1 + 288);
LABEL_193:
            __s2[0] = 0;
            __s2[1] = v35;
            re::DynamicArray<BOOL>::operator=((uint64_t)&v146, v120);
            re::DynamicArray<re::ReadState>::add(a1 + 352, (uint64_t *)&v146);
            v53 = v146.n128_u64[0];
            if (!v146.n128_u64[0] || !__s2[0])
              goto LABEL_199;
            goto LABEL_195;
          }
          v146 = 0uLL;
          v148 = 0;
          v147 = 0;
          *(_OWORD *)__s2 = 0u;
          v150 = 0u;
          v151 = 0;
          v164 = 0u;
          v165 = 0u;
          v152 = 0u;
          v153 = 0u;
          v154 = 0u;
          v155 = 0u;
          v156 = 0u;
          v157 = 0u;
          v158 = 0u;
          v159 = 0u;
          v160 = 0u;
          v161 = 0u;
          v162 = 0u;
          v163 = 0u;
          v166 = 0;
          memset(v171, 0, 25);
          v170 = 0u;
          v169 = 0u;
          v167 = 16;
          v168 = v123[0];
          *((_QWORD *)&v170 + 1) = *(_QWORD *)(a1 + 288);
          re::DynamicArray<re::Entry>::operator=(&v146, &v118);
          re::Message::Message((re::Message *)v137, (const re::Message *)&v146);
          re::Raft::send(a1, (uint64_t)v137);
          v79 = (re::Message *)v137;
        }
        else
        {
          if (*(_BYTE *)(a1 + 528) != 1)
          {
            if (*(_BYTE *)(a1 + 528))
              goto LABEL_199;
            re::DynamicArray<BOOL>::DynamicArray((uint64_t)v139, v120);
            re::ReadOnly::addRequest((re::ReadOnly *)(a1 + 432), *(_QWORD *)(a1 + 288), (const re::Message *)&v118);
            v146.n128_u8[0] = 1;
            re::DynamicArray<BOOL>::DynamicArray((uint64_t)&v146.n128_i64[1], v139);
            re::Raft::broadcastHeatbeatWithCtx(a1, &v146);
            if (v146.n128_u8[0] && v146.n128_u64[1] && __s2[1])
              (*(void (**)(void))(*(_QWORD *)v146.n128_u64[1] + 40))();
            v53 = v139[0];
            if (!v139[0] || !v142)
              goto LABEL_199;
LABEL_195:
            (*(void (**)(uint64_t))(*(_QWORD *)v53 + 40))(v53);
LABEL_199:
            *a3 = 1;
            re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v143);
            goto LABEL_298;
          }
          v35 = *(void **)(a1 + 288);
          if (!v123[0] || v123[0] == *v34)
          {
            v147 = 0;
            v146 = 0uLL;
            v148 = 0;
            goto LABEL_193;
          }
          v146 = 0uLL;
          v148 = 0;
          v147 = 0;
          *(_OWORD *)__s2 = 0u;
          v150 = 0u;
          v151 = 0;
          v164 = 0u;
          v165 = 0u;
          v152 = 0u;
          v153 = 0u;
          v154 = 0u;
          v155 = 0u;
          v156 = 0u;
          v157 = 0u;
          v158 = 0u;
          v159 = 0u;
          v160 = 0u;
          v161 = 0u;
          v162 = 0u;
          v163 = 0u;
          v166 = 0;
          memset(v171, 0, 25);
          *(_QWORD *)&v170 = 0;
          v169 = 0u;
          v167 = 16;
          v168 = v123[0];
          *((_QWORD *)&v170 + 1) = v35;
          re::DynamicArray<re::Entry>::operator=(&v146, &v118);
          re::Message::Message((re::Message *)v138, (const re::Message *)&v146);
          re::Raft::send(a1, (uint64_t)v138);
          v79 = (re::Message *)v138;
        }
        re::Message::~Message(v79);
        re::Message::~Message((re::Message *)&v146);
        goto LABEL_199;
      }
      if (v122 == 1)
      {
        re::Raft::broadcastHeartbeat((re::Raft *)a1);
        goto LABEL_155;
      }
      if (v122 != 2)
        goto LABEL_107;
      if (!v119)
      {
LABEL_301:
        re::internal::assertLog((re::internal *)4, v30, "assertion failure: '%s' (%s:line %i) stepped empty msgprop", "!\"Unreachable code\"", "stepLeader", 994);
        _os_crash();
        __break(1u);
        JUMPOUT(0x225B90954);
      }
      re::ProgressSet::voterIds((re::ProgressSet *)(a1 + 552), (uint64_t)&v146);
      v31 = re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains((uint64_t)&v146, (uint64_t *)(a1 + 1056));
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v146);
      if (v31 && !*(_BYTE *)(a1 + 1024))
      {
        v55 = v119;
        if (v119)
        {
          v56 = 0;
          v57 = 1;
          do
          {
            v58 = &v120[v56];
            if (LOBYTE(v120[v56 + 10]) == 1)
            {
              if (*(_QWORD *)(a1 + 1072) > *(_QWORD *)(a1 + 296) || *(_BYTE *)(a1 + 856))
              {
                v59 = &v120[v56];
                v59[7] = 0;
                v59[11] = 0;
                v59[12] = 0;
                ++*((_DWORD *)v59 + 16);
                v59[2] = 0;
                ++*((_DWORD *)v59 + 6);
                *((_BYTE *)v58 + 80) = 0;
              }
              else
              {
                *(_QWORD *)(a1 + 1072) = re::RaftLog::lastIndex((re::RaftLog *)a1) + v57;
                v55 = v119;
              }
            }
            v56 += 13;
          }
          while (v57++ < v55);
        }
        re::Raft::appendEntry(a1, (uint64_t)&v118);
        re::Raft::broadcastAppend((re::Raft *)a1);
        goto LABEL_155;
      }
      *(_WORD *)a3 = 1024;
      re::Message::~Message((re::Message *)&v118);
      return;
    default:
      goto LABEL_66;
  }
}

uint64_t re::Raft::hup(uint64_t this, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned __int8 *v7;
  int v8;
  char v9;
  __n128 v10;
  uint64_t v11;
  __n128 v12;
  uint64_t v13;
  uint64_t v14;

  if (*(_BYTE *)(this + 536) != 2)
  {
    v3 = this;
    v4 = 264;
    if (!*(_BYTE *)(this + 48))
      v4 = 296;
    re::RaftLog::slice((re::RaftLog *)this, *(_QWORD *)(this + v4) + 1, *(_QWORD *)(this + 288) + 1, &v10);
    re::DynamicArray<re::Entry>::DynamicArray(&v12, &v10.n128_u64[1]);
    if (v10.n128_u8[0])
      re::DynamicArray<re::Entry>::deinit((uint64_t)&v10.n128_i64[1]);
    if (!v13)
      goto LABEL_12;
    v5 = 0;
    v6 = 104 * v13;
    v7 = (unsigned __int8 *)(v14 + 80);
    do
    {
      v8 = *v7;
      v7 += 104;
      if (v8 == 1)
        ++v5;
      v6 -= 104;
    }
    while (v6);
    if (!v5)
    {
LABEL_12:
      if (a2)
      {
        v9 = 0;
      }
      else if (*(_BYTE *)(v3 + 1154))
      {
        v9 = 1;
      }
      else
      {
        v9 = 2;
      }
      re::DynamicArray<unsigned char>::DynamicArray((uint64_t)&v10, &v9, 1uLL);
      re::Raft::campaign(v3, (uint64_t)&v10);
      if (v10.n128_u64[0])
      {
        if (v11)
          (*(void (**)(void))(*(_QWORD *)v10.n128_u64[0] + 40))();
      }
    }
    return re::DynamicArray<re::Entry>::deinit((uint64_t)&v12);
  }
  return this;
}

void re::Raft::campaign(uint64_t a1, uint64_t a2)
{
  size_t v4;
  _BOOL4 v5;
  unint64_t v6;
  char v7;
  unsigned int v8;
  uint64_t v9;
  int *v10;
  int v11;
  size_t v12;
  _BOOL4 v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  _BOOL4 v18;
  size_t v19;
  unsigned int v20;
  unsigned int v21;
  char v22;
  uint64_t v23;
  _BYTE v24[391];
  char v25;
  _QWORD v26[4];
  void *v27;
  _QWORD v28[2];
  uint64_t v29;
  int v30;
  _OWORD __s2[2];
  int v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  uint64_t v47;
  char v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  __int128 v52;
  _BYTE v53[25];
  uint64_t v54[2];
  uint64_t v55;
  unsigned int v56;

  LOBYTE(v54[0]) = 1;
  re::DynamicArray<unsigned char>::DynamicArray((uint64_t)v28, (char *)v54, 1uLL);
  v4 = *(_QWORD *)(a2 + 16);
  v5 = v4 == v29 && memcmp(*(const void **)(a2 + 32), *(const void **)&__s2[0], v4) == 0;
  if (v28[0] && *(_QWORD *)&__s2[0])
    (*(void (**)(void))(*(_QWORD *)v28[0] + 40))();
  if (v5)
  {
    *(_BYTE *)(a1 + 536) = 3;
    re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::clear(a1 + 304);
    *(_QWORD *)(a1 + 1064) = 0;
    v23 = *(_QWORD *)(a1 + 1040) + 1;
    v6 = *(_QWORD *)(a1 + 1056);
    v7 = 17;
  }
  else
  {
    re::Raft::reset((re::Raft *)a1, *(_QWORD *)(a1 + 1040) + 1);
    v6 = *(_QWORD *)(a1 + 1056);
    *(_QWORD *)(a1 + 1048) = v6;
    *(_BYTE *)(a1 + 536) = 1;
    v23 = *(_QWORD *)(a1 + 1040);
    v7 = 5;
  }
  v22 = v7;
  re::Raft::registerVote((re::Raft *)a1, v6, 1);
  if (re::ProgressSet::candidacyStatus(a1 + 552, a1 + 304))
  {
    re::ProgressSet::voterIds((re::ProgressSet *)(a1 + 552), (uint64_t)v54);
    v8 = v56;
    if (v56)
    {
      v9 = 0;
      v10 = (int *)(v55 + 8);
      while (1)
      {
        v11 = *v10;
        v10 += 6;
        if (v11 < 0)
          break;
        if (v56 == ++v9)
        {
          LODWORD(v9) = v56;
          break;
        }
      }
    }
    else
    {
      LODWORD(v9) = 0;
    }
    if (v56 != (_DWORD)v9)
    {
      v14 = v9;
      v15 = v55;
      v16 = v56;
      do
      {
        v17 = *(_QWORD *)(v15 + 24 * v14 + 16);
        if (v17 != v6)
        {
          v28[0] = 0;
          v28[1] = 0;
          v30 = 0;
          v29 = 0;
          memset(__s2, 0, sizeof(__s2));
          v32 = 0;
          v33 = 0u;
          v34 = 0u;
          v35 = 0u;
          v36 = 0u;
          v37 = 0u;
          v38 = 0u;
          v39 = 0u;
          v40 = 0u;
          v41 = 0u;
          v42 = 0u;
          v43 = 0u;
          v44 = 0u;
          v45 = 0u;
          v46 = 0u;
          v47 = 0;
          v52 = 0u;
          memset(v53, 0, sizeof(v53));
          v50 = 0;
          v48 = v22;
          v49 = v17;
          v51 = v23;
          *((_QWORD *)&v52 + 1) = re::RaftLog::lastIndex((re::RaftLog *)a1);
          *(_QWORD *)&v52 = re::RaftLog::lastTerm((re::RaftLog *)a1);
          v25 = 0;
          re::DynamicArray<unsigned char>::DynamicArray((uint64_t)v26, &v25, 1uLL);
          v18 = 0;
          v19 = *(_QWORD *)(a2 + 16);
          if (v19 == v26[2])
            v18 = memcmp(*(const void **)(a2 + 32), v27, v19) == 0;
          if (v26[0] && v27)
            (*(void (**)(void))(*(_QWORD *)v26[0] + 40))();
          if (v18)
            re::DynamicArray<BOOL>::operator=((uint64_t)__s2 + 8, (uint64_t *)a2);
          re::Message::Message((re::Message *)v24, (const re::Message *)v28);
          re::Raft::send(a1, (uint64_t)v24);
          re::Message::~Message((re::Message *)v24);
          re::Message::~Message((re::Message *)v28);
          v16 = v56;
          v15 = v55;
        }
        if (v16 <= (int)v9 + 1)
          v20 = v9 + 1;
        else
          v20 = v16;
        while (1)
        {
          v14 = (v9 + 1);
          if (v20 - 1 == (_DWORD)v9)
            break;
          LODWORD(v9) = v9 + 1;
          v21 = v14;
          if ((*(_DWORD *)(v15 + 24 * v14 + 8) & 0x80000000) != 0)
            goto LABEL_37;
        }
        v21 = v20;
LABEL_37:
        LODWORD(v9) = v21;
      }
      while (v8 != v21);
    }
    re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(v54);
  }
  else
  {
    LOBYTE(v54[0]) = 1;
    re::DynamicArray<unsigned char>::DynamicArray((uint64_t)v28, (char *)v54, 1uLL);
    v12 = *(_QWORD *)(a2 + 16);
    v13 = v12 == v29 && memcmp(*(const void **)(a2 + 32), *(const void **)&__s2[0], v12) == 0;
    if (v28[0] && *(_QWORD *)&__s2[0])
      (*(void (**)(void))(*(_QWORD *)v28[0] + 40))();
    if (v13)
    {
      LOBYTE(v54[0]) = 2;
      re::DynamicArray<unsigned char>::DynamicArray((uint64_t)v28, (char *)v54, 1uLL);
      re::Raft::campaign(a1, v28);
      if (v28[0] && *(_QWORD *)&__s2[0])
        (*(void (**)(void))(*(_QWORD *)v28[0] + 40))();
    }
    else
    {
      re::Raft::becomeLeader((re::Raft *)a1);
    }
  }
}

void re::Raft::registerVote(re::Raft *this, unint64_t a2, char a3)
{
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v6 = *((_QWORD *)this + 38);
  v7 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
  v8 = v7 ^ (v7 >> 31);
  if (!v6)
    goto LABEL_4;
  v9 = *(unsigned int *)(*((_QWORD *)this + 39) + 4 * (v8 % *((unsigned int *)this + 82)));
  if ((_DWORD)v9 != 0x7FFFFFFF)
  {
    v15 = *((_QWORD *)this + 40);
    if (*(_QWORD *)(v15 + 32 * v9 + 16) == a2)
      return;
    while (1)
    {
      v9 = *(_DWORD *)(v15 + 32 * v9 + 8) & 0x7FFFFFFF;
      if ((_DWORD)v9 == 0x7FFFFFFF)
        break;
      if (*(_QWORD *)(v15 + 32 * v9 + 16) == a2)
        return;
    }
  }
  v6 = v8 % *((unsigned int *)this + 82);
  v10 = *(unsigned int *)(*((_QWORD *)this + 39) + 4 * v6);
  if ((_DWORD)v10 == 0x7FFFFFFF)
    goto LABEL_4;
  v17 = *((_QWORD *)this + 40);
  if (*(_QWORD *)(v17 + 32 * v10 + 16) != a2)
  {
    while (1)
    {
      v10 = *(_DWORD *)(v17 + 32 * v10 + 8) & 0x7FFFFFFF;
      if ((_DWORD)v10 == 0x7FFFFFFF)
        break;
      if (*(_QWORD *)(v17 + 32 * v10 + 16) == a2)
        goto LABEL_19;
    }
LABEL_4:
    v11 = *((unsigned int *)this + 85);
    if ((_DWORD)v11 == 0x7FFFFFFF)
    {
      v11 = *((unsigned int *)this + 84);
      v12 = v11;
      if ((_DWORD)v11 == *((_DWORD *)this + 82))
      {
        re::HashTable<unsigned long long,BOOL,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity((uint64_t)this + 304, 2 * *((_DWORD *)this + 83));
        LODWORD(v6) = v8 % *((unsigned int *)this + 82);
        v12 = *((_DWORD *)this + 84);
      }
      *((_DWORD *)this + 84) = v12 + 1;
      v13 = *((_QWORD *)this + 40);
      v14 = *(_DWORD *)(v13 + 32 * v11 + 8);
    }
    else
    {
      v13 = *((_QWORD *)this + 40);
      v14 = *(_DWORD *)(v13 + 32 * v11 + 8);
      *((_DWORD *)this + 85) = v14 & 0x7FFFFFFF;
    }
    *(_DWORD *)(v13 + 32 * v11 + 8) = v14 | 0x80000000;
    v16 = *((_QWORD *)this + 39);
    *(_DWORD *)(*((_QWORD *)this + 40) + 32 * v11 + 8) = *(_DWORD *)(*((_QWORD *)this + 40) + 32 * v11 + 8) & 0x80000000 | *(_DWORD *)(v16 + 4 * v6);
    *(_QWORD *)(*((_QWORD *)this + 40) + 32 * v11) = v8;
    *(_QWORD *)(*((_QWORD *)this + 40) + 32 * v11 + 16) = a2;
    *(_BYTE *)(*((_QWORD *)this + 40) + 32 * v11 + 24) = a3;
    *(_DWORD *)(v16 + 4 * v6) = v11;
    ++*((_DWORD *)this + 83);
    goto LABEL_14;
  }
LABEL_19:
  *(_BYTE *)(v17 + 32 * v10 + 24) = a3;
LABEL_14:
  ++*((_DWORD *)this + 86);
}

void re::Raft::finalizeMembershipChange(re::Raft *this@<X0>, const re::ConfChange *a2@<X1>, __int16 *a3@<X8>)
{
  __int16 v4;
  uint64_t Term;
  uint64_t v7;
  unsigned __int8 v8[8];
  uint64_t v9;
  _BYTE v10[24];
  uint64_t v11;
  char v12;

  if (*((_BYTE *)a2 + 120) != 4 || *((_BYTE *)a2 + 152))
  {
    v4 = 2560;
LABEL_4:
    *a3 = v4;
    return;
  }
  if (!*((_BYTE *)this + 640))
  {
    v4 = 3584;
    goto LABEL_4;
  }
  if (!re::Configuration::contains((re::Raft *)((char *)this + 648), *((_QWORD *)this + 133)))
  {
    Term = re::RaftLog::lastTerm(this);
    if (*((_BYTE *)this + 536) == 2)
    {
      v7 = *((_QWORD *)this + 135);
      re::Raft::reset(this, Term);
      *((_QWORD *)this + 133) = 0;
      *((_BYTE *)this + 536) = 0;
      *((_QWORD *)this + 135) = v7;
    }
    else
    {
      *((_QWORD *)this + 133) = 0;
    }
  }
  re::ProgressSet::finalizeMembershipChange((re::Raft *)((char *)this + 552), (uint64_t)v10);
  if (!v10[0])
  {
    *a3 = 3584;
LABEL_18:
    if (v11)
    {
      if ((v12 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v11 + 40))();
    }
    return;
  }
  v8[0] = 0;
  re::Optional<re::ConfChange>::operator=((_BYTE *)this + 856, v8);
  if (v8[0])
    re::ConfChange::~ConfChange((re::ConfChange *)&v9);
  *(_BYTE *)a3 = 1;
  if (!v10[0])
    goto LABEL_18;
}

BOOL re::Configuration::contains(re::Configuration *this, uint64_t a2)
{
  uint64_t v4;

  v4 = a2;
  return re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains((uint64_t)this, &v4)|| re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains((uint64_t)this + 48, &v4);
}

void re::Raft::sendTimeoutNow(re::Raft *this, uint64_t a2)
{
  _BYTE v3[384];
  _QWORD v4[3];
  int v5;
  __int128 v6;
  __int128 v7;
  int v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;
  char v24;
  uint64_t v25;
  __int128 v26;
  __int128 v27;
  _BYTE v28[25];

  memset(v4, 0, sizeof(v4));
  v5 = 0;
  v6 = 0u;
  v7 = 0u;
  v8 = 0;
  v21 = 0u;
  v22 = 0u;
  v9 = 0u;
  v10 = 0u;
  v11 = 0u;
  v12 = 0u;
  v13 = 0u;
  v14 = 0u;
  v15 = 0u;
  v16 = 0u;
  v17 = 0u;
  v18 = 0u;
  v19 = 0u;
  v20 = 0u;
  v23 = 0;
  v27 = 0u;
  memset(v28, 0, sizeof(v28));
  v26 = 0u;
  v25 = a2;
  v24 = 14;
  re::Message::Message((re::Message *)v3, (const re::Message *)v4);
  re::Raft::send((uint64_t)this, (uint64_t)v3);
  re::Message::~Message((re::Message *)v3);
  re::Message::~Message((re::Message *)v4);
}

uint64_t re::DynamicArray<re::ReadState>::add(uint64_t a1, uint64_t *a2)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  BOOL v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t result;

  v4 = *(_QWORD *)(a1 + 8);
  v5 = *(_QWORD *)(a1 + 16);
  if (v5 >= v4)
  {
    v6 = v5 + 1;
    if (v4 < v5 + 1)
    {
      if (*(_QWORD *)a1)
      {
        v7 = 2 * v4;
        v8 = v4 == 0;
        v9 = 8;
        if (!v8)
          v9 = v7;
        if (v9 <= v6)
          v10 = v6;
        else
          v10 = v9;
        re::DynamicArray<re::ReadState>::setCapacity((_QWORD *)a1, v10);
      }
      else
      {
        re::DynamicArray<re::ReadState>::setCapacity((_QWORD *)a1, v6);
        ++*(_DWORD *)(a1 + 24);
      }
    }
    v5 = *(_QWORD *)(a1 + 16);
  }
  result = re::DynamicArray<BOOL>::DynamicArray(*(_QWORD *)(a1 + 32) + 48 * v5, a2);
  *(_QWORD *)(result + 40) = a2[5];
  ++*(_QWORD *)(a1 + 16);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

BOOL re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::containsKey(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  _BOOL8 result;
  uint64_t v6;

  if (!*(_QWORD *)a1)
    return 0;
  v2 = *a2;
  v3 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v4 = *(unsigned int *)(*(_QWORD *)(a1 + 8)
                       + 4
                       * (((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) ^ ((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) >> 31))
                        % *(unsigned int *)(a1 + 24)));
  if ((_DWORD)v4 == 0x7FFFFFFF)
    return 0;
  v6 = *(_QWORD *)(a1 + 16);
  if (*(_QWORD *)(v6 + 136 * v4 + 16) == v2)
    return 1;
  do
  {
    LODWORD(v4) = *(_DWORD *)(v6 + 136 * v4 + 8) & 0x7FFFFFFF;
    result = (_DWORD)v4 != 0x7FFFFFFF;
  }
  while ((_DWORD)v4 != 0x7FFFFFFF && *(_QWORD *)(v6 + 136 * v4 + 16) != v2);
  return result;
}

void re::Raft::handleAppendEntries(re::Raft *this, const re::Message *a2)
{
  unint64_t v4;
  unint64_t v5;
  re::Message *v6;
  re::Message *v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  _BYTE v11[8];
  uint64_t v12;
  _BYTE v13[384];
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  __int128 v18;
  __int128 v19;
  int v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  uint64_t v35;
  char v36;
  uint64_t v37;
  __int128 v38;
  __int128 v39;
  _OWORD v40[2];

  if (*((_QWORD *)this + 135))
  {
    re::Raft::sendRequestSnapshot(this);
  }
  else
  {
    v4 = *((_QWORD *)a2 + 43);
    v5 = *((_QWORD *)this + 36);
    if (v4 >= v5)
    {
      v15 = 0;
      v14 = 0;
      v17 = 0;
      v16 = 0;
      v18 = 0u;
      v19 = 0u;
      v20 = 0;
      v33 = 0u;
      v34 = 0u;
      v21 = 0u;
      v22 = 0u;
      v23 = 0u;
      v24 = 0u;
      v25 = 0u;
      v26 = 0u;
      v27 = 0u;
      v28 = 0u;
      v29 = 0u;
      v30 = 0u;
      v31 = 0u;
      v32 = 0u;
      v35 = 0;
      memset(v40, 0, 25);
      v39 = 0u;
      v38 = 0u;
      v37 = *((_QWORD *)a2 + 40);
      v36 = 4;
      re::RaftLog::maybeAppend(this, v4, *((_QWORD *)a2 + 42), *((_QWORD *)a2 + 44), (uint64_t)a2, (uint64_t)v11);
      if (v11[0])
      {
        v7 = (re::Message *)&v10;
        v8 = v12;
      }
      else
      {
        v8 = *((_QWORD *)a2 + 43);
        BYTE8(v40[1]) = 1;
        *(_QWORD *)&v40[1] = re::RaftLog::lastIndex(this);
        v7 = (re::Message *)&v9;
      }
      *((_QWORD *)&v39 + 1) = v8;
      re::Message::Message(v7, (const re::Message *)&v14);
      re::Raft::send((uint64_t)this, (uint64_t)v7);
      v6 = v7;
    }
    else
    {
      v15 = 0;
      v14 = 0;
      v17 = 0;
      v16 = 0;
      v18 = 0u;
      v19 = 0u;
      v20 = 0;
      v33 = 0u;
      v34 = 0u;
      v21 = 0u;
      v22 = 0u;
      v23 = 0u;
      v24 = 0u;
      v25 = 0u;
      v26 = 0u;
      v27 = 0u;
      v28 = 0u;
      v29 = 0u;
      v30 = 0u;
      v31 = 0u;
      v32 = 0u;
      v35 = 0;
      memset(v40, 0, 25);
      v39 = 0u;
      v38 = 0u;
      v36 = 4;
      v37 = *((_QWORD *)a2 + 40);
      *((_QWORD *)&v39 + 1) = v5;
      re::Message::Message((re::Message *)v13, (const re::Message *)&v14);
      re::Raft::send((uint64_t)this, (uint64_t)v13);
      v6 = (re::Message *)v13;
    }
    re::Message::~Message(v6);
    re::Message::~Message((re::Message *)&v14);
  }
}

void re::Raft::handleHeartbeat(re::Raft *this, const re::Message *a2)
{
  _BYTE v4[384];
  _QWORD v5[3];
  int v6;
  _OWORD v7[2];
  int v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;
  char v24;
  uint64_t v25;
  __int128 v26;
  __int128 v27;
  _BYTE v28[25];

  re::RaftLog::commitTo(this, *((_QWORD *)a2 + 44));
  if (*((_QWORD *)this + 135))
  {
    re::Raft::sendRequestSnapshot(this);
  }
  else
  {
    memset(v5, 0, sizeof(v5));
    v6 = 0;
    memset(v7, 0, sizeof(v7));
    v8 = 0;
    v21 = 0u;
    v22 = 0u;
    v9 = 0u;
    v10 = 0u;
    v11 = 0u;
    v12 = 0u;
    v13 = 0u;
    v14 = 0u;
    v15 = 0u;
    v16 = 0u;
    v17 = 0u;
    v18 = 0u;
    v19 = 0u;
    v20 = 0u;
    v23 = 0;
    v27 = 0u;
    memset(v28, 0, sizeof(v28));
    v26 = 0u;
    v24 = 9;
    v25 = *((_QWORD *)a2 + 40);
    re::DynamicArray<BOOL>::operator=((uint64_t)v7 + 8, (uint64_t *)a2 + 5);
    re::Message::Message((re::Message *)v4, (const re::Message *)v5);
    re::Raft::send((uint64_t)this, (uint64_t)v4);
    re::Message::~Message((re::Message *)v4);
    re::Message::~Message((re::Message *)v5);
  }
}

void re::Raft::handleSnapshot(re::Raft *this, const re::Message *a2)
{
  unint64_t v4;
  re::Message *v5;
  uint64_t Index;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  _QWORD *v14;
  uint64_t v15;
  char v16;
  _BYTE v17[384];
  _BYTE v18[384];
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  __int128 v23;
  __int128 v24;
  int v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  uint64_t v40;
  char v41;
  uint64_t v42;
  __int128 v43;
  __int128 v44;
  _BYTE v45[25];
  char v46;
  char v47;
  uint64_t v48[5];
  uint64_t v49[5];
  _QWORD v50[3];
  int v51;
  _BYTE v52[48];
  _BYTE v53[32];
  uint64_t v54;
  char v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  char v59;
  _QWORD v60[5];
  uint64_t v61;
  uint64_t v62;
  _QWORD *v63;
  uint64_t v64[5];
  uint64_t v65[5];
  __int128 v66;
  uint64_t v67;

  v4 = *((_QWORD *)this + 36);
  if (*((_QWORD *)a2 + 36) < v4)
    goto LABEL_2;
  re::DynamicArray<char const*>::DynamicArray((uint64_t)v60, (uint64_t *)a2 + 15);
  re::DynamicArray<char const*>::DynamicArray((uint64_t)&v61, (uint64_t *)a2 + 20);
  re::DynamicArray<char const*>::DynamicArray((uint64_t)v64, (uint64_t *)a2 + 25);
  re::DynamicArray<char const*>::DynamicArray((uint64_t)v65, (uint64_t *)a2 + 30);
  v66 = *(_OWORD *)((char *)a2 + 280);
  v67 = *((_QWORD *)a2 + 37);
  if (!*((_QWORD *)this + 135))
  {
    v12 = v67;
    re::RaftLog::getTerm(this, *((unint64_t *)&v66 + 1), (uint64_t)&v19);
    if ((_BYTE)v19)
    {
      if (v20 == v12)
      {
        re::RaftLog::commitTo(this, *((unint64_t *)&v66 + 1));
LABEL_18:
        v47 = 1;
        v13 = &v46;
        goto LABEL_35;
      }
    }
  }
  if (*((_DWORD *)this + 145) && !*((_BYTE *)this + 1152) && v62)
  {
    v14 = v63;
    v15 = 8 * v62;
    while (*v14 != *((_QWORD *)this + 132))
    {
      ++v14;
      v15 -= 8;
      if (!v15)
        goto LABEL_6;
    }
    goto LABEL_18;
  }
LABEL_6:
  Index = re::RaftLog::lastIndex(this);
  re::ProgressSet::restoreSnapshotMeta(v60, Index + 1, *((_QWORD *)this + 136), (uint64_t)v50);
  LOBYTE(v19) = 1;
  re::ProgressSet::ProgressSet((uint64_t)&v20, (uint64_t)v50);
  re::Optional<re::ProgressSet>::operator=((_BYTE *)this + 544, &v19);
  if ((_BYTE)v19)
    re::ProgressSet::~ProgressSet((re::ProgressSet *)&v20);
  re::ProgressSet::~ProgressSet((re::ProgressSet *)v50);
  LODWORD(v7) = 0x7FFFFFFF;
  if (*((_QWORD *)this + 69))
  {
    v8 = *((_QWORD *)this + 132);
    v9 = 0x94D049BB133111EBLL
       * ((0xBF58476D1CE4E5B9 * (v8 ^ (v8 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v8 ^ (v8 >> 30))) >> 27));
    v10 = *(unsigned int *)(*((_QWORD *)this + 70) + 4 * ((v9 ^ (v9 >> 31)) % *((unsigned int *)this + 144)));
    if ((_DWORD)v10 != 0x7FFFFFFF)
    {
      v11 = *((_QWORD *)this + 71);
      LODWORD(v7) = v10;
      if (*(_QWORD *)(v11 + 136 * v10 + 16) != v8)
      {
        v7 = v10;
        while (1)
        {
          LODWORD(v7) = *(_DWORD *)(v11 + 136 * v7 + 8) & 0x7FFFFFFF;
          if ((_DWORD)v7 == 0x7FFFFFFF)
            break;
          if (*(_QWORD *)(v11 + 136 * v7 + 16) == v8)
            goto LABEL_25;
        }
        LODWORD(v7) = 0x7FFFFFFF;
      }
    }
  }
LABEL_25:
  *(_QWORD *)(*((_QWORD *)this + 71) + 136 * v7 + 96) = Index;
  if (re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains((uint64_t)this + 792, (uint64_t *)this + 132))
  {
    v16 = 1;
LABEL_29:
    *((_BYTE *)this + 1152) = v16;
    goto LABEL_30;
  }
  if (re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains((uint64_t)this + 744, (uint64_t *)this + 132))
  {
    v16 = 0;
    goto LABEL_29;
  }
LABEL_30:
  if ((_QWORD)v66)
  {
    re::DynamicArray<char const*>::DynamicArray((uint64_t)v48, v64);
    re::DynamicArray<char const*>::DynamicArray((uint64_t)v49, v65);
    memset(v50, 0, sizeof(v50));
    v51 = 0;
    memset(v52, 0, sizeof(v52));
    memset(v53, 0, sizeof(v53));
    v54 = 0;
    v58 = 0;
    v56 = 0;
    v57 = 0;
    v59 = 0;
    v55 = 3;
    re::DynamicArray<unsigned long long>::operator=((uint64_t)&v52[8], v48);
    re::DynamicArray<unsigned long long>::operator=((uint64_t)v53, v49);
    v59 = 1;
    v58 = v66;
    LOBYTE(v19) = 1;
    re::ConfChange::ConfChange((re::ConfChange *)&v20, (const re::ConfChange *)v50);
    re::Optional<re::ConfChange>::operator=((_BYTE *)this + 856, (unsigned __int8 *)&v19);
    if ((_BYTE)v19)
      re::ConfChange::~ConfChange((re::ConfChange *)&v20);
    re::ConfChange::~ConfChange((re::ConfChange *)v50);
    re::MeshCollectionHandles::~MeshCollectionHandles((re::MeshCollectionHandles *)v48);
  }
  *((_QWORD *)this + 135) = 0;
  v13 = &v47;
LABEL_35:
  *v13 = 0;
  re::MeshCollectionHandles::~MeshCollectionHandles((re::MeshCollectionHandles *)v64);
  re::MeshCollectionHandles::~MeshCollectionHandles((re::MeshCollectionHandles *)v60);
  if (!v47)
  {
    *((_QWORD *)this + 36) = *((_QWORD *)a2 + 36);
    re::Unstable::restore((re::Raft *)((char *)this + 8), (const re::Message *)((char *)a2 + 80));
    goto LABEL_39;
  }
  if (v46)
  {
LABEL_39:
    v20 = 0;
    v19 = 0;
    v22 = 0;
    v21 = 0;
    v23 = 0u;
    v24 = 0u;
    v25 = 0;
    v38 = 0u;
    v39 = 0u;
    v26 = 0u;
    v27 = 0u;
    v28 = 0u;
    v29 = 0u;
    v30 = 0u;
    v31 = 0u;
    v32 = 0u;
    v33 = 0u;
    v34 = 0u;
    v35 = 0u;
    v36 = 0u;
    v37 = 0u;
    v40 = 0;
    memset(v45, 0, sizeof(v45));
    v44 = 0u;
    v43 = 0u;
    v41 = 4;
    v42 = *((_QWORD *)a2 + 40);
    *((_QWORD *)&v44 + 1) = re::RaftLog::lastIndex(this);
    re::Message::Message((re::Message *)v18, (const re::Message *)&v19);
    re::Raft::send((uint64_t)this, (uint64_t)v18);
    v5 = (re::Message *)v18;
    goto LABEL_40;
  }
  v4 = *((_QWORD *)this + 36);
LABEL_2:
  v20 = 0;
  v19 = 0;
  v22 = 0;
  v21 = 0;
  v23 = 0u;
  v24 = 0u;
  v25 = 0;
  v38 = 0u;
  v39 = 0u;
  v26 = 0u;
  v27 = 0u;
  v28 = 0u;
  v29 = 0u;
  v30 = 0u;
  v31 = 0u;
  v32 = 0u;
  v33 = 0u;
  v34 = 0u;
  v35 = 0u;
  v36 = 0u;
  v37 = 0u;
  v40 = 0;
  memset(v45, 0, sizeof(v45));
  v44 = 0u;
  v43 = 0u;
  v41 = 4;
  v42 = *((_QWORD *)a2 + 40);
  *((_QWORD *)&v44 + 1) = v4;
  re::Message::Message((re::Message *)v17, (const re::Message *)&v19);
  re::Raft::send((uint64_t)this, (uint64_t)v17);
  v5 = (re::Message *)v17;
LABEL_40:
  re::Message::~Message(v5);
  re::Message::~Message((re::Message *)&v19);
}

void re::Raft::sendRequestSnapshot(re::Raft *this)
{
  uint64_t v2;
  uint64_t v3;
  _BYTE v4[384];
  _QWORD v5[3];
  int v6;
  __int128 v7;
  __int128 v8;
  int v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  char v25;
  uint64_t v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t Index;
  char v32;

  memset(v5, 0, sizeof(v5));
  v6 = 0;
  v7 = 0u;
  v8 = 0u;
  v9 = 0;
  v22 = 0u;
  v23 = 0u;
  v10 = 0u;
  v11 = 0u;
  v12 = 0u;
  v13 = 0u;
  v14 = 0u;
  v15 = 0u;
  v16 = 0u;
  v17 = 0u;
  v18 = 0u;
  v19 = 0u;
  v20 = 0u;
  v21 = 0u;
  v24 = 0;
  v27 = 0u;
  v28 = 0u;
  v25 = 4;
  v2 = *((_QWORD *)this + 36);
  v29 = 0;
  *((_QWORD *)&v28 + 1) = v2;
  v32 = 1;
  Index = re::RaftLog::lastIndex(this);
  v3 = *((_QWORD *)this + 135);
  v26 = *((_QWORD *)this + 133);
  v30 = v3;
  re::Message::Message((re::Message *)v4, (const re::Message *)v5);
  re::Raft::send((uint64_t)this, (uint64_t)v4);
  re::Message::~Message((re::Message *)v4);
  re::Message::~Message((re::Message *)v5);
}

__n128 re::DynamicArray<re::Entry>::add(__n128 *this, __n128 *a2)
{
  unint64_t v4;
  __n128 *v5;
  __n128 result;

  v4 = this[1].n128_u64[0];
  if (v4 >= this->n128_u64[1])
  {
    re::DynamicArray<re::Entry>::growCapacity(this, v4 + 1);
    v4 = this[1].n128_u64[0];
  }
  v5 = (__n128 *)(this[2].n128_u64[0] + 104 * v4);
  re::DynamicArray<BOOL>::DynamicArray((uint64_t)v5, (uint64_t *)a2);
  re::DynamicArray<BOOL>::DynamicArray((uint64_t)&v5[2].n128_i64[1], &a2[2].n128_i64[1]);
  result = a2[5];
  v5[6].n128_u64[0] = a2[6].n128_u64[0];
  v5[5] = result;
  ++this[1].n128_u64[0];
  ++this[1].n128_u32[2];
  return result;
}

void re::Raft::addVoterOrLearner(re::Raft *this@<X0>, uint64_t a2@<X1>, int a3@<W2>, _BYTE *a4@<X8>)
{
  char v4;
  uint64_t Index;
  unint64_t v9;
  uint64_t v10;
  _BOOL4 v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char v20[24];
  __int128 v21;
  __int128 v22;
  _BYTE v23[24];
  uint64_t v24;
  char v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  char v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  __int16 v39;
  uint64_t v40;

  v4 = a3;
  v40 = a2;
  *a4 = 1;
  if (a3)
  {
    Index = re::RaftLog::lastIndex(this);
    v9 = *((_QWORD *)this + 136);
    v10 = Index + 1;
    v27 = 0;
    v28 = 0;
    v26 = 0;
    v29 = 0;
    v30 = 0;
    v31 = 0;
    v32 = 0;
    v33 = v9;
    re::DynamicArray<float *>::setCapacity(&v26, v9);
    v34 = 0;
    v35 = 0;
    v36 = v10;
    v37 = 0;
    v38 = 0;
    v39 = 0;
    re::ProgressSet::insertLearner((re::Raft *)((char *)this + 552), (const re::Progress *)&v26, a2, (uint64_t)v23);
    goto LABEL_10;
  }
  re::ProgressSet::learnerIds((re::Raft *)((char *)this + 552), (uint64_t)&v26);
  v11 = re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains((uint64_t)&v26, &v40);
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(&v26);
  if (!v11)
  {
    v12 = re::RaftLog::lastIndex(this);
    v13 = *((_QWORD *)this + 136);
    v14 = v12 + 1;
    v27 = 0;
    v28 = 0;
    v26 = 0;
    v29 = 0;
    v30 = 0;
    v31 = 0;
    v32 = 0;
    v33 = v13;
    re::DynamicArray<float *>::setCapacity(&v26, v13);
    v34 = 0;
    v35 = 0;
    v36 = v14;
    v37 = 0;
    v38 = 0;
    v39 = 0;
    re::ProgressSet::insertVoter((re::Raft *)((char *)this + 552), (const re::Progress *)&v26, v40, (uint64_t)v23);
LABEL_10:
    re::Result<re::Unit,re::DetailedError>::operator=((uint64_t)a4, (uint64_t)v23);
    if (!v23[0] && v24 && (v25 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v24 + 40))();
    if (v26 && v30)
      (*(void (**)(void))(*(_QWORD *)v26 + 40))();
    goto LABEL_14;
  }
  re::ProgressSet::promoteLearner((re::Raft *)((char *)this + 552), v40, (uint64_t)v20);
  if (!v20[0] && (_QWORD)v21)
  {
    if ((BYTE8(v21) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v21 + 40))();
    v21 = 0u;
    v22 = 0u;
  }
LABEL_14:
  if (*a4)
  {
    v15 = v40;
    if (*((_QWORD *)this + 132) == v40)
      *((_BYTE *)this + 1152) = v4;
    LODWORD(v16) = 0x7FFFFFFF;
    if (*((_QWORD *)this + 69))
    {
      v17 = 0x94D049BB133111EBLL
          * ((0xBF58476D1CE4E5B9 * (v15 ^ (v15 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v15 ^ (v15 >> 30))) >> 27));
      v18 = *(unsigned int *)(*((_QWORD *)this + 70) + 4 * ((v17 ^ (v17 >> 31)) % *((unsigned int *)this + 144)));
      if ((_DWORD)v18 != 0x7FFFFFFF)
      {
        v19 = *((_QWORD *)this + 71);
        LODWORD(v16) = v18;
        if (*(_QWORD *)(v19 + 136 * v18 + 16) != v15)
        {
          v16 = v18;
          while (1)
          {
            LODWORD(v16) = *(_DWORD *)(v19 + 136 * v16 + 8) & 0x7FFFFFFF;
            if ((_DWORD)v16 == 0x7FFFFFFF)
              break;
            if (*(_QWORD *)(v19 + 136 * v16 + 16) == v15)
              goto LABEL_28;
          }
          LODWORD(v16) = 0x7FFFFFFF;
        }
      }
    }
LABEL_28:
    *(_BYTE *)(*((_QWORD *)this + 71) + 136 * v16 + 129) = 1;
  }
}

uint64_t re::Raft::removeNode@<X0>(re::Raft *this@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  re::ProgressSet *v6;
  int v7;
  unint64_t v8;
  uint64_t v10[3];
  int v11;
  __int128 v12;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;
  _BYTE v16[8];
  __int128 v17;
  _QWORD v18[14];

  v18[13] = *MEMORY[0x24BDAC8D0];
  v6 = (re::Raft *)((char *)this + 552);
  re::ProgressSet::remove((re::Raft *)((char *)this + 552), a2, (uint64_t)v16);
  if (v16[0])
  {
    re::ProgressSet::voterIds(v6, (uint64_t)&v12);
    if (DWORD1(v14))
    {
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v12);
    }
    else
    {
      re::ProgressSet::learnerIds(v6, (uint64_t)v10);
      v7 = v11;
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(v10);
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v12);
      if (!v7)
      {
LABEL_12:
        *(_BYTE *)a3 = 1;
        return re::Result<re::Optional<re::Progress>,re::DetailedError>::~Result((uint64_t)v16);
      }
    }
    v8 = re::ProgressSet::maximalCommittedIndex(v6);
    if (re::RaftLog::maybeCommit(this, v8, *((_QWORD *)this + 130)))
      re::Raft::broadcastAppend(this);
    if (*((_BYTE *)this + 536) == 2 && *((_BYTE *)this + 1024) && *((_QWORD *)this + 129) == a2)
      *((_BYTE *)this + 1024) = 0;
    goto LABEL_12;
  }
  v12 = v17;
  re::DynamicString::DynamicString((re::DynamicString *)&v13, (const re::DynamicString *)v18);
  *(_BYTE *)a3 = 0;
  *(_OWORD *)(a3 + 8) = v12;
  *(_QWORD *)(a3 + 24) = v13;
  *(_QWORD *)(a3 + 48) = v15;
  *(_OWORD *)(a3 + 32) = v14;
  return re::Result<re::Optional<re::Progress>,re::DetailedError>::~Result((uint64_t)v16);
}

void RaftState::RaftState(RaftState *this, const RaftState *a2)
{
  _BYTE *v4;
  int v5;
  __int128 v6;

  v4 = re::Optional<re::ConfState>::Optional(this, (uint64_t *)a2);
  v5 = *((unsigned __int8 *)a2 + 88);
  v4[88] = v5;
  if (v5)
    *((_QWORD *)this + 12) = *((_QWORD *)a2 + 12);
  v6 = *(_OWORD *)((char *)a2 + 104);
  *((_QWORD *)this + 15) = *((_QWORD *)a2 + 15);
  *(_OWORD *)((char *)this + 104) = v6;
  re::DynamicArray<char const*>::DynamicArray((uint64_t)this + 128, (uint64_t *)a2 + 16);
  re::DynamicArray<char const*>::DynamicArray((uint64_t)this + 168, (uint64_t *)a2 + 21);
}

unsigned __int8 *re::Optional<re::Snapshot>::operator=(unsigned __int8 *a1, uint64_t *a2)
{
  int v3;
  int v4;
  BOOL v5;
  BOOL v6;
  uint64_t v8;
  BOOL v9;
  uint64_t v10;
  __int128 v11;

  v3 = *a1;
  v4 = *(unsigned __int8 *)a2;
  if (*a1)
    v5 = 0;
  else
    v5 = v4 == 0;
  if (!v5)
  {
    if (*a1)
      v6 = v4 == 0;
    else
      v6 = 0;
    if (v6)
    {
      re::Snapshot::~Snapshot((re::Snapshot *)(a1 + 8));
      *a1 = 0;
    }
    else
    {
      v8 = (uint64_t)(a1 + 8);
      if (v3)
        v9 = 1;
      else
        v9 = v4 == 0;
      if (v9)
      {
        re::DynamicArray<BOOL>::operator=(v8, a2 + 1);
        re::DynamicArray<unsigned long long>::operator=((uint64_t)(a1 + 48), a2 + 6);
        re::DynamicArray<unsigned long long>::operator=((uint64_t)(a1 + 88), a2 + 11);
        re::DynamicArray<unsigned long long>::operator=((uint64_t)(a1 + 128), a2 + 16);
        re::DynamicArray<unsigned long long>::operator=((uint64_t)(a1 + 168), a2 + 21);
        v10 = a2[28];
        *((_OWORD *)a1 + 13) = *((_OWORD *)a2 + 13);
        *((_QWORD *)a1 + 28) = v10;
      }
      else
      {
        *a1 = 1;
        re::DynamicArray<BOOL>::DynamicArray(v8, a2 + 1);
        re::DynamicArray<char const*>::DynamicArray((uint64_t)(a1 + 48), a2 + 6);
        re::DynamicArray<char const*>::DynamicArray((uint64_t)(a1 + 88), a2 + 11);
        re::DynamicArray<char const*>::DynamicArray((uint64_t)(a1 + 128), a2 + 16);
        re::DynamicArray<char const*>::DynamicArray((uint64_t)(a1 + 168), a2 + 21);
        v11 = *((_OWORD *)a2 + 13);
        *((_QWORD *)a1 + 28) = a2[28];
        *((_OWORD *)a1 + 13) = v11;
      }
    }
  }
  return a1;
}

void re::Unstable::~Unstable(re::Unstable *this)
{
  if (*((_BYTE *)this + 40))
    re::Snapshot::~Snapshot((re::Unstable *)((char *)this + 48));
  re::DynamicArray<re::Entry>::deinit((uint64_t)this);
}

uint64_t re::ProgressSet::ProgressSet(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  *(_DWORD *)(a1 + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_QWORD *)(a1 + 36) = 0x7FFFFFFFLL;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)a1, (uint64_t *)a2);
  *(_QWORD *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  v4 = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a1 + 56) = v4;
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  v5 = *(_QWORD *)(a1 + 64);
  *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(a2 + 64) = v5;
  v6 = *(_QWORD *)(a1 + 80);
  *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
  *(_QWORD *)(a2 + 80) = v6;
  ++*(_DWORD *)(a2 + 72);
  ++*(_DWORD *)(a1 + 72);
  re::Optional<re::Configuration>::Optional(a1 + 88, (uint64_t *)(a2 + 88));
  *(_DWORD *)(a1 + 224) = 0;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_QWORD *)(a1 + 228) = 0x7FFFFFFFLL;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)(a1 + 192), (uint64_t *)(a2 + 192));
  *(_OWORD *)(a1 + 256) = 0u;
  *(_QWORD *)(a1 + 272) = 0x7FFFFFFF00000000;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_DWORD *)(a1 + 280) = 0;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)(a1 + 240), (uint64_t *)(a2 + 240));
  *(_OWORD *)(a1 + 288) = *(_OWORD *)(a2 + 288);
  return a1;
}

uint64_t re::Optional<re::Configuration>::Optional(uint64_t a1, uint64_t *a2)
{
  int v3;

  v3 = *(unsigned __int8 *)a2;
  *(_BYTE *)a1 = v3;
  if (v3)
  {
    *(_DWORD *)(a1 + 40) = 0;
    *(_OWORD *)(a1 + 24) = 0u;
    *(_OWORD *)(a1 + 8) = 0u;
    *(_QWORD *)(a1 + 44) = 0x7FFFFFFFLL;
    re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)(a1 + 8), a2 + 1);
    *(_OWORD *)(a1 + 56) = 0u;
    *(_DWORD *)(a1 + 88) = 0;
    *(_OWORD *)(a1 + 72) = 0u;
    *(_QWORD *)(a1 + 92) = 0x7FFFFFFFLL;
    re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)(a1 + 56), a2 + 7);
  }
  return a1;
}

void re::ProgressSet::~ProgressSet(re::ProgressSet *this)
{
  uint64_t *v2;
  uint64_t v3;

  v2 = (uint64_t *)((char *)this + 192);
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)this + 30);
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(v2);
  re::Optional<re::Configuration>::~Optional((uint64_t)this + 88);
  v3 = *((_QWORD *)this + 6);
  if (v3)
  {
    if (*((_QWORD *)this + 10))
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
    *((_QWORD *)this + 10) = 0;
    *((_QWORD *)this + 7) = 0;
    *((_QWORD *)this + 8) = 0;
    *((_QWORD *)this + 6) = 0;
    ++*((_DWORD *)this + 18);
  }
  re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)this);
}

uint64_t re::Optional<re::Configuration>::~Optional(uint64_t a1)
{
  if (*(_BYTE *)a1)
  {
    re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)(a1 + 56));
    re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)(a1 + 8));
  }
  return a1;
}

double re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  double result;

  v2 = *a1;
  if (v2)
  {
    if (*((_DWORD *)a1 + 8))
    {
      v3 = 0;
      v4 = 0;
      do
      {
        re::HashTable<re::ecs2::Scene *,re::DynamicArray<RESubscriptionHandle>,re::Hash<re::ecs2::Scene *>,re::EqualTo<re::ecs2::Scene *>,true,false>::EntryWithHash::free(a1[2] + v3);
        ++v4;
        v3 += 136;
      }
      while (v4 < *((unsigned int *)a1 + 8));
      v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

uint64_t re::ReadOnly::ReadOnly(uint64_t a1, _BYTE *a2)
{
  _QWORD *v3;
  _anonymous_namespace_ *v4;

  *(_DWORD *)(a1 + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_QWORD *)(a1 + 36) = 0x7FFFFFFFLL;
  *(_QWORD *)(a1 + 88) = 0;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_DWORD *)(a1 + 80) = 0;
  *(_OWORD *)(a1 + 48) = 0u;
  v3 = (_QWORD *)(a1 + 48);
  *(_BYTE *)(a1 + 96) = *a2;
  re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::setCapacity(a1, 0);
  re::Queue<re::DynamicArray<unsigned char>>::setCapacity(v3, 0);
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 80) = 0;
  return a1;
}

void re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  unsigned int v7;
  __int128 v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  signed int v12;
  _BYTE v13[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(_QWORD *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::init((uint64_t)v13, v4, a2);
      v5 = *(_OWORD *)v13;
      *(_OWORD *)v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      v6 = *(_QWORD *)&v13[16];
      *(_QWORD *)&v13[16] = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 16) = v6;
      v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      v9 = v7;
      if (v7)
      {
        v10 = 0;
        v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(_QWORD *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::addAsMove(a1, *(_QWORD *)(*(_QWORD *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(*(_QWORD *)&v13[16] + v10), (uint64_t *)(*(_QWORD *)&v13[16] + v10 + 16), (uint64_t *)(*(_QWORD *)&v13[16] + v10 + 56));
            v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 496;
        }
        while (v11 < v9);
      }
      re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2)
      v12 = a2;
    else
      v12 = 3;
  }
}

uint64_t re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;

  v10 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
    v10 = *(unsigned int *)(a1 + 32);
    v11 = v10;
    if ((_DWORD)v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::setCapacity(a1, (2 * *(_DWORD *)(a1 + 28)));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 496 * v10 + 8);
  }
  else
  {
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 496 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + 496 * v10 + 8) = v13 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 496 * v10 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 496 * v10 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 496 * v10) = a3;
  re::DynamicArray<BOOL>::DynamicArray(*(_QWORD *)(a1 + 16) + 496 * v10 + 16, a4);
  v14 = *(_QWORD *)(a1 + 16) + 496 * v10;
  *(_OWORD *)(v14 + 56) = 0u;
  v14 += 56;
  *(_DWORD *)(v14 + 32) = 0;
  *(_OWORD *)(v14 + 16) = 0u;
  *(_QWORD *)(v14 + 36) = 0x7FFFFFFFLL;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)v14, a5);
  re::Message::Message(v14 + 48, (uint64_t)(a5 + 6));
  *(_QWORD *)(v14 + 432) = a5[54];
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

void re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 496 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &unk_2260EB7B0, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

uint64_t re::Message::Message(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  v4 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)(a1 + 8) = v4;
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  v5 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v5;
  v6 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 32) = v6;
  ++*(_DWORD *)(a2 + 24);
  ++*(_DWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  v7 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 48) = v7;
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  v8 = *(_QWORD *)(a1 + 56);
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 56) = v8;
  v9 = *(_QWORD *)(a1 + 72);
  *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
  *(_QWORD *)(a2 + 72) = v9;
  ++*(_DWORD *)(a2 + 64);
  ++*(_DWORD *)(a1 + 64);
  v10 = a1 + 80;
  v11 = a2 + 80;
  re::DynamicArray<BOOL>::DynamicArray(a1 + 80, (uint64_t *)(a2 + 80));
  re::DynamicArray<char const*>::DynamicArray(a1 + 120, (uint64_t *)(a2 + 120));
  re::DynamicArray<char const*>::DynamicArray(a1 + 160, (uint64_t *)(a2 + 160));
  re::DynamicArray<char const*>::DynamicArray(a1 + 200, (uint64_t *)(a2 + 200));
  re::DynamicArray<char const*>::DynamicArray(a1 + 240, (uint64_t *)(a2 + 240));
  v12 = *(_OWORD *)(v11 + 200);
  *(_QWORD *)(a1 + 296) = *(_QWORD *)(a2 + 296);
  *(_OWORD *)(v10 + 200) = v12;
  v14 = *(_OWORD *)(a2 + 336);
  v13 = *(_OWORD *)(a2 + 352);
  v15 = *(_OWORD *)(a2 + 320);
  *(_OWORD *)(a1 + 361) = *(_OWORD *)(a2 + 361);
  *(_OWORD *)(a1 + 336) = v14;
  *(_OWORD *)(a1 + 352) = v13;
  *(_OWORD *)(a1 + 320) = v15;
  *(_OWORD *)(a1 + 304) = *(_OWORD *)(a2 + 304);
  return a1;
}

double re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  double result;

  v2 = *a1;
  if (v2)
  {
    if (*((_DWORD *)a1 + 8))
    {
      v3 = 0;
      v4 = 0;
      do
      {
        re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::EntryWithHash::free(a1[2] + v3);
        ++v4;
        v3 += 496;
      }
      while (v4 < *((unsigned int *)a1 + 8));
      v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

double re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::EntryWithHash::free(uint64_t a1)
{
  int v1;
  uint64_t v3;
  _QWORD *v4;
  double result;

  v1 = *(_DWORD *)(a1 + 8);
  if (v1 < 0)
  {
    v4 = (_QWORD *)(a1 + 16);
    v3 = *(_QWORD *)(a1 + 16);
    *((_DWORD *)v4 - 2) = v1 & 0x7FFFFFFF;
    if (v3)
    {
      if (*(_QWORD *)(a1 + 48))
        (*(void (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
      *(_QWORD *)(a1 + 48) = 0;
      v4[1] = 0;
      v4[2] = 0;
      *v4 = 0;
      ++*(_DWORD *)(a1 + 40);
    }
    re::Message::~Message((re::Message *)(a1 + 104));
    return re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)(a1 + 56));
  }
  return result;
}

_QWORD *re::Queue<re::DynamicArray<unsigned char>>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    v6 = result + 2;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::Queue<re::DynamicArray<unsigned char>>::setCapacity(v5, a2);
        *v6 = 0;
        v6[1] = 0;
        *((_DWORD *)v6 + 4) = 0;
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x28uLL))
        {
          v2 = 40 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 40 * a2, 8);
          if (result)
          {
            v8 = result;
            if (!v5[1])
              goto LABEL_22;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in Queue<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 440, 40, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v7, "assertion failure: '%s' (%s:line %i) Queue<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 444, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v8 = 0;
      if (!v3)
      {
LABEL_22:
        v5[5] = v8;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      if (v5[2])
      {
        v9 = 0;
        v10 = v5[3];
        do
        {
          v11 = (_QWORD *)(v5[5] + 40 * ((unint64_t)(v9 + v5[3]) % v5[1]));
          v12 = &v8[5 * v10];
          v12[4] = 0;
          *((_DWORD *)v12 + 6) = 0;
          v12[1] = 0;
          v12[2] = 0;
          *v12 = 0;
          v13 = v11[1];
          *v12 = *v11;
          v12[1] = v13;
          *v11 = 0;
          v11[1] = 0;
          v14 = v12[2];
          v12[2] = v11[2];
          v11[2] = v14;
          v15 = v12[4];
          v12[4] = v11[4];
          v11[4] = v15;
          ++*((_DWORD *)v11 + 6);
          ++*((_DWORD *)v12 + 6);
          if (*v11)
          {
            if (v15)
              (*(void (**)(_QWORD))(*(_QWORD *)*v11 + 40))(*v11);
            v11[4] = 0;
            v11[1] = 0;
            v11[2] = 0;
            *v11 = 0;
            ++*((_DWORD *)v11 + 6);
          }
          if (v10 + 1 < a2)
            ++v10;
          else
            v10 = 0;
          ++v9;
        }
        while (v9 != *v6);
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v5 + 40))(*v5, v5[5]);
      goto LABEL_22;
    }
  }
  return result;
}

uint64_t re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::operator=(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    if (!*(_QWORD *)a1 || *(_QWORD *)a1 == *a2)
    {
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)a1, a2);
    }
    else if (*a2)
    {
      re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::copy(a1, (uint64_t)a2);
      ++*(_DWORD *)(a1 + 40);
    }
    else
    {
      re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::clear(a1);
    }
  }
  return a1;
}

uint64_t *re::Queue<re::DynamicArray<unsigned char>>::operator=(uint64_t *a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  BOOL v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  if (a1 != a2)
  {
    v3 = *a1;
    v4 = *a2;
    if (*a1)
      v5 = v3 == v4;
    else
      v5 = 1;
    if (v5)
    {
      v6 = a1[1];
      v7 = a2[1];
      *a1 = v4;
      a1[1] = v7;
      *a2 = v3;
      a2[1] = v6;
      v8 = a1[2];
      a1[2] = a2[2];
      a2[2] = v8;
      v9 = a1[5];
      a1[5] = a2[5];
      a2[5] = v9;
      v10 = a1[3];
      a1[3] = a2[3];
      a2[3] = v10;
    }
    else if (v4)
    {
      re::Queue<re::DynamicArray<unsigned char>>::copy(a1, a2);
      ++*((_DWORD *)a1 + 8);
    }
    else
    {
      re::Queue<re::DynamicArray<unsigned char>>::clear(a1);
    }
  }
  return a1;
}

void re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  int v5;

  if (*(_DWORD *)(a1 + 28))
  {
    v2 = *(unsigned int *)(a1 + 24);
    if ((_DWORD)v2)
      memset_pattern16(*(void **)(a1 + 8), &unk_2260EB7B0, 4 * v2);
    if (*(_DWORD *)(a1 + 32))
    {
      v3 = 0;
      v4 = 0;
      do
      {
        re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::EntryWithHash::free(*(_QWORD *)(a1 + 16) + v3);
        ++v4;
        v3 += 496;
      }
      while (v4 < *(unsigned int *)(a1 + 32));
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    v5 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v5;
  }
}

void re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::copy(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t i;
  uint64_t v8;

  re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::clear(a1);
  v4 = *(_DWORD *)(a2 + 28);
  if (*(_DWORD *)(a1 + 24) < v4)
    re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::setCapacity(a1, v4);
  v5 = *(unsigned int *)(a2 + 32);
  if ((_DWORD)v5)
  {
    v6 = 0;
    for (i = 0; i < v5; ++i)
    {
      v8 = *(_QWORD *)(a2 + 16) + v6;
      if ((*(_DWORD *)(v8 + 8) & 0x80000000) != 0)
      {
        re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::addAsCopy(a1, *(_QWORD *)v8 % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)v8, (uint64_t *)(v8 + 16), v8 + 56);
        v5 = *(unsigned int *)(a2 + 32);
      }
      v6 += 496;
    }
  }
}

uint64_t re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;

  v10 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
    v10 = *(unsigned int *)(a1 + 32);
    v11 = v10;
    if ((_DWORD)v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 496 * v10 + 8);
  }
  else
  {
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 496 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + 496 * v10 + 8) = v13 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 496 * v10 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 496 * v10 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 496 * v10) = a3;
  re::DynamicArray<BOOL>::DynamicArray(*(_QWORD *)(a1 + 16) + 496 * v10 + 16, a4);
  v14 = *(_QWORD *)(a1 + 16) + 496 * v10;
  re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashSetBase(v14 + 56, a5);
  re::Message::Message((re::Message *)(v14 + 104), (const re::Message *)(a5 + 48));
  *(_QWORD *)(v14 + 488) = *(_QWORD *)(a5 + 432);
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

_QWORD *re::Queue<re::DynamicArray<unsigned char>>::clear(_QWORD *result)
{
  _QWORD *v1;
  unint64_t v2;
  unint64_t i;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;

  v1 = result;
  v2 = result[2];
  if (v2)
  {
    for (i = 0; i < v2; ++i)
    {
      v4 = v1[5];
      v5 = (i + v1[3]) % v1[1];
      v6 = v4 + 40 * v5;
      result = *(_QWORD **)v6;
      if (*(_QWORD *)v6)
      {
        v7 = v4 + 40 * v5;
        v9 = *(_QWORD *)(v7 + 32);
        v8 = (_QWORD *)(v7 + 32);
        if (v9)
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 40))(result);
        *v8 = 0;
        *(_QWORD *)(v6 + 8) = 0;
        *(_QWORD *)(v6 + 16) = 0;
        *(_QWORD *)v6 = 0;
        ++*(_DWORD *)(v4 + 40 * v5 + 24);
        v2 = v1[2];
      }
    }
  }
  v1[2] = 0;
  ++*((_DWORD *)v1 + 8);
  return result;
}

uint64_t re::Queue<re::DynamicArray<unsigned char>>::copy(_QWORD *a1, _QWORD *a2)
{
  unint64_t v4;
  uint64_t result;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD v15[4];

  v4 = a2[2];
  if (v4 >= a1[2])
  {
    re::Queue<re::DynamicArray<unsigned char>>::setCapacity(a1, a2[2]);
    result = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::Queue<re::DynamicArray<unsigned char>>::QueueIterator<re::DynamicArray<unsigned char>,re::DynamicArray<unsigned char> const&>,re::Queue<re::DynamicArray<unsigned char>>::QueueIterator<re::DynamicArray<unsigned char>,re::DynamicArray<unsigned char> const&>,re::Queue<re::DynamicArray<unsigned char>>::QueueIterator<re::DynamicArray<unsigned char>,re::DynamicArray<unsigned char>&>>(a2, 0, a2, a1[2], a1, 0, v15);
    v14 = a1[2];
    for (a1[2] = v4; v14 != a2[2]; ++v14)
      result = re::DynamicArray<BOOL>::DynamicArray(a1[5] + 40 * ((unint64_t)(v14 + a1[3]) % a1[1]), (uint64_t *)(a2[5] + 40 * ((unint64_t)(v14 + a2[3]) % a2[1])));
  }
  else
  {
    result = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::Queue<re::DynamicArray<unsigned char>>::QueueIterator<re::DynamicArray<unsigned char>,re::DynamicArray<unsigned char> const&>,re::Queue<re::DynamicArray<unsigned char>>::QueueIterator<re::DynamicArray<unsigned char>,re::DynamicArray<unsigned char> const&>,re::Queue<re::DynamicArray<unsigned char>>::QueueIterator<re::DynamicArray<unsigned char>,re::DynamicArray<unsigned char>&>>(a2, 0, a2, a2[2], a1, 0, v15);
    v6 = a1[2];
    if (v4 != v6)
    {
      v7 = v4;
      do
      {
        v8 = (v7 + a1[3]) % a1[1];
        v9 = a1[5];
        v10 = (uint64_t *)(v9 + 40 * v8);
        result = *v10;
        if (*v10)
        {
          v11 = v9 + 40 * v8;
          v13 = *(_QWORD *)(v11 + 32);
          v12 = (_QWORD *)(v11 + 32);
          if (v13)
            result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
          *v12 = 0;
          v10[1] = 0;
          v10[2] = 0;
          *v10 = 0;
          ++*(_DWORD *)(v9 + 40 * v8 + 24);
          v6 = a1[2];
        }
        ++v7;
      }
      while (v7 != v6);
    }
    a1[2] = v4;
  }
  return result;
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::Queue<re::DynamicArray<unsigned char>>::QueueIterator<re::DynamicArray<unsigned char>,re::DynamicArray<unsigned char> const&>,re::Queue<re::DynamicArray<unsigned char>>::QueueIterator<re::DynamicArray<unsigned char>,re::DynamicArray<unsigned char> const&>,re::Queue<re::DynamicArray<unsigned char>>::QueueIterator<re::DynamicArray<unsigned char>,re::DynamicArray<unsigned char>&>>@<X0>(_QWORD *a1@<X1>, uint64_t a2@<X2>, _QWORD *a3@<X3>, uint64_t a4@<X4>, _QWORD *a5@<X5>, uint64_t a6@<X6>, _QWORD *a7@<X8>)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t result;

  if (a1 != a3 || a2 != a4)
  {
    v13 = a4 - 1;
    do
    {
      do
      {
        v14 = a2;
        result = re::DynamicArray<BOOL>::operator=(a5[5] + 40 * ((unint64_t)(a6 + a5[3]) % a5[1]), (uint64_t *)(a1[5] + 40 * ((unint64_t)(a2 + a1[3]) % a1[1])));
        a2 = v14 + 1;
        ++a6;
      }
      while (a1 != a3);
    }
    while (v13 != v14);
    a2 = a4;
  }
  *a7 = a1;
  a7[1] = a2;
  a7[2] = a5;
  a7[3] = a6;
  return result;
}

double re::Queue<re::DynamicArray<unsigned char>>::deinit(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t i;
  unint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  double result;

  v2 = *a1;
  if (v2)
  {
    v3 = a1[5];
    if (v3)
    {
      v4 = a1[2];
      if (v4)
      {
        for (i = 0; i != v4; ++i)
        {
          v6 = (i + a1[3]) % (unint64_t)a1[1];
          v7 = a1[5];
          v8 = (_QWORD *)(v7 + 40 * v6);
          if (*v8)
          {
            v9 = v7 + 40 * v6;
            v11 = *(_QWORD *)(v9 + 32);
            v10 = (_QWORD *)(v9 + 32);
            if (v11)
              (*(void (**)(_QWORD))(*(_QWORD *)*v8 + 40))(*v8);
            *v10 = 0;
            v8[1] = 0;
            v8[2] = 0;
            *v8 = 0;
            ++*(_DWORD *)(v7 + 40 * v6 + 24);
            v4 = a1[2];
          }
        }
        v2 = *a1;
        v3 = a1[5];
      }
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, v3);
    }
    a1[5] = 0;
    result = 0.0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *((_DWORD *)a1 + 8) = 0;
  }
  return result;
}

void re::ConfChange::~ConfChange(re::ConfChange *this)
{
  re::MeshCollectionHandles::~MeshCollectionHandles((re::ConfChange *)((char *)this + 40));
  if (*(_QWORD *)this)
  {
    if (*((_QWORD *)this + 4))
      (*(void (**)(_QWORD))(**(_QWORD **)this + 40))(*(_QWORD *)this);
    *((_QWORD *)this + 4) = 0;
    *((_QWORD *)this + 1) = 0;
    *((_QWORD *)this + 2) = 0;
    *(_QWORD *)this = 0;
    ++*((_DWORD *)this + 6);
  }
}

void re::Raft::~Raft(re::Raft *this)
{
  uint64_t v2;

  if (*((_BYTE *)this + 856))
    re::ConfChange::~ConfChange((re::Raft *)((char *)this + 864));
  if (*((_BYTE *)this + 544))
    re::ProgressSet::~ProgressSet((re::Raft *)((char *)this + 552));
  re::Queue<re::DynamicArray<unsigned char>>::deinit((uint64_t *)this + 60);
  re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::deinit((uint64_t *)this + 54);
  re::DynamicArray<re::Message>::deinit((uint64_t)this + 392);
  re::DynamicArray<re::ReadState>::deinit((uint64_t)this + 352);
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)this + 38);
  re::Unstable::~Unstable((re::Raft *)((char *)this + 8));
  v2 = *(_QWORD *)this;
  *(_QWORD *)this = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
}

uint64_t re::DynamicArray<re::ReadState>::deinit(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 48 * v4;
        v6 = (_QWORD *)(v3 + 32);
        do
        {
          v7 = *(v6 - 4);
          if (v7)
          {
            if (*v6)
              (*(void (**)(uint64_t))(*(_QWORD *)v7 + 40))(v7);
            *v6 = 0;
            *(v6 - 3) = 0;
            *(v6 - 2) = 0;
            *(v6 - 4) = 0;
            ++*((_DWORD *)v6 - 2);
          }
          v6 += 6;
          v5 -= 48;
        }
        while (v5);
        result = *(_QWORD *)a1;
        v3 = *(_QWORD *)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

void RaftState::~RaftState(RaftState *this)
{
  re::MeshCollectionHandles::~MeshCollectionHandles((RaftState *)((char *)this + 128));
  if (*(_BYTE *)this)
    re::MeshCollectionHandles::~MeshCollectionHandles((RaftState *)((char *)this + 8));
}

re::ProgressSet *re::ProgressSet::ProgressSet(re::ProgressSet *this, const re::ProgressSet *a2)
{
  uint64_t v4;

  v4 = re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashTable((uint64_t)this, (uint64_t)a2);
  re::DynamicArray<char const*>::DynamicArray(v4 + 48, (uint64_t *)a2 + 6);
  re::Optional<re::Configuration>::Optional((_BYTE *)this + 88, (unsigned __int8 *)a2 + 88);
  re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashSetBase((uint64_t)this + 192, (uint64_t)a2 + 192);
  re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashSetBase((uint64_t)this + 240, (uint64_t)a2 + 240);
  *((_OWORD *)this + 18) = *((_OWORD *)a2 + 18);
  return this;
}

uint64_t re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashTable(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  signed int v5;

  *(_DWORD *)(a1 + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_QWORD *)(a1 + 36) = 0x7FFFFFFFLL;
  v4 = *(_QWORD *)a2;
  if (v4)
  {
    if (*(_DWORD *)(a2 + 28) <= 3u)
      v5 = 3;
    else
      v5 = *(_DWORD *)(a2 + 28);
    re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init(a1, v4, v5);
    re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::copy(a1, a2);
  }
  return a1;
}

void re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 136 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &unk_2260EB7B0, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

void re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::copy(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t i;
  uint64_t v8;

  re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::clear(a1);
  v4 = *(_DWORD *)(a2 + 28);
  if (*(_DWORD *)(a1 + 24) < v4)
    re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, v4);
  v5 = *(unsigned int *)(a2 + 32);
  if ((_DWORD)v5)
  {
    v6 = 0;
    for (i = 0; i < v5; ++i)
    {
      v8 = *(_QWORD *)(a2 + 16) + v6;
      if ((*(_DWORD *)(v8 + 8) & 0x80000000) != 0)
      {
        re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsCopy(a1, *(_QWORD *)v8 % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)v8, (_QWORD *)(v8 + 16), (re::Progress *)(v8 + 24));
        v5 = *(unsigned int *)(a2 + 32);
      }
      v6 += 136;
    }
  }
}

void re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  int v5;

  if (*(_DWORD *)(a1 + 28))
  {
    v2 = *(unsigned int *)(a1 + 24);
    if ((_DWORD)v2)
      memset_pattern16(*(void **)(a1 + 8), &unk_2260EB7B0, 4 * v2);
    if (*(_DWORD *)(a1 + 32))
    {
      v3 = 0;
      v4 = 0;
      do
      {
        re::HashTable<re::ecs2::Scene *,re::DynamicArray<RESubscriptionHandle>,re::Hash<re::ecs2::Scene *>,re::EqualTo<re::ecs2::Scene *>,true,false>::EntryWithHash::free(*(_QWORD *)(a1 + 16) + v3);
        ++v4;
        v3 += 136;
      }
      while (v4 < *(unsigned int *)(a1 + 32));
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    v5 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v5;
  }
}

void re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  unsigned int v7;
  __int128 v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  signed int v12;
  _BYTE v13[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(_QWORD *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init((uint64_t)v13, v4, a2);
      v5 = *(_OWORD *)v13;
      *(_OWORD *)v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      v6 = *(_QWORD *)&v13[16];
      *(_QWORD *)&v13[16] = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 16) = v6;
      v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      v9 = v7;
      if (v7)
      {
        v10 = 0;
        v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(_QWORD *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(a1, *(_QWORD *)(*(_QWORD *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(*(_QWORD *)&v13[16] + v10), (_QWORD *)(*(_QWORD *)&v13[16] + v10 + 16), (_OWORD *)(*(_QWORD *)&v13[16] + v10 + 24));
            v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 136;
        }
        while (v11 < v9);
      }
      re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2)
      v12 = a2;
    else
      v12 = 3;
  }
}

uint64_t re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, _QWORD *a4, re::Progress *a5)
{
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;

  v10 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
    v10 = *(unsigned int *)(a1 + 32);
    v11 = v10;
    if ((_DWORD)v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 136 * v10 + 8);
  }
  else
  {
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 136 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + 136 * v10 + 8) = v13 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 136 * v10 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 136 * v10 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 136 * v10) = a3;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 136 * v10 + 16) = *a4;
  re::Progress::Progress((re::Progress *)(*(_QWORD *)(a1 + 16) + 136 * v10 + 24), a5);
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

uint64_t re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, _QWORD *a4, _OWORD *a5)
{
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  __int128 v15;
  __int128 v16;

  v10 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
    v10 = *(unsigned int *)(a1 + 32);
    v11 = v10;
    if ((_DWORD)v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, (2 * *(_DWORD *)(a1 + 28)));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 136 * v10 + 8);
  }
  else
  {
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 136 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + 136 * v10 + 8) = v13 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 136 * v10 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 136 * v10 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 136 * v10) = a3;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 136 * v10 + 16) = *a4;
  v14 = *(_QWORD *)(a1 + 16) + 136 * v10;
  re::Inflights::Inflights(v14 + 24, (uint64_t)a5);
  v15 = a5[4];
  v16 = a5[5];
  *(_OWORD *)(v14 + 114) = *(_OWORD *)((char *)a5 + 90);
  *(_OWORD *)(v14 + 104) = v16;
  *(_OWORD *)(v14 + 88) = v15;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

__n128 re::Inflights::Inflights(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  __n128 result;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  v2 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)(a1 + 8) = v2;
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  v3 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v3;
  v4 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 32) = v4;
  ++*(_DWORD *)(a2 + 24);
  ++*(_DWORD *)(a1 + 24);
  result = *(__n128 *)(a2 + 40);
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
  *(__n128 *)(a1 + 40) = result;
  return result;
}

__n128 re::Progress::Progress(re::Progress *this, const re::Progress *a2)
{
  uint64_t v3;
  __int128 v4;
  __n128 result;

  v3 = re::DynamicArray<char const*>::DynamicArray((uint64_t)this, (uint64_t *)a2);
  v4 = *(_OWORD *)((char *)a2 + 40);
  *(_QWORD *)(v3 + 56) = *((_QWORD *)a2 + 7);
  *(_OWORD *)(v3 + 40) = v4;
  *(_BYTE *)(v3 + 64) = *((_BYTE *)a2 + 64);
  *(_OWORD *)(v3 + 72) = *(_OWORD *)((char *)a2 + 72);
  result = *(__n128 *)((char *)a2 + 88);
  *(__n128 *)(v3 + 88) = result;
  *(_BYTE *)(v3 + 104) = *((_BYTE *)a2 + 104);
  *(_BYTE *)(v3 + 105) = *((_BYTE *)a2 + 105);
  return result;
}

_BYTE *re::Optional<re::Configuration>::Optional(_BYTE *a1, unsigned __int8 *a2)
{
  int v3;

  v3 = *a2;
  *a1 = v3;
  if (v3)
  {
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashSetBase((uint64_t)(a1 + 8), (uint64_t)(a2 + 8));
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashSetBase((uint64_t)(a1 + 56), (uint64_t)(a2 + 56));
  }
  return a1;
}

re::Message *re::Message::Message(re::Message *this, const re::Message *a2)
{
  __n128 *v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;

  v4 = re::DynamicArray<re::Entry>::DynamicArray((__n128 *)this, (unint64_t *)a2);
  re::DynamicArray<BOOL>::DynamicArray((uint64_t)&v4[2].n128_i64[1], (uint64_t *)a2 + 5);
  re::DynamicArray<BOOL>::DynamicArray((uint64_t)this + 80, (uint64_t *)a2 + 10);
  re::DynamicArray<char const*>::DynamicArray((uint64_t)this + 120, (uint64_t *)a2 + 15);
  re::DynamicArray<char const*>::DynamicArray((uint64_t)this + 160, (uint64_t *)a2 + 20);
  re::DynamicArray<char const*>::DynamicArray((uint64_t)this + 200, (uint64_t *)a2 + 25);
  re::DynamicArray<char const*>::DynamicArray((uint64_t)this + 240, (uint64_t *)a2 + 30);
  v5 = *(_OWORD *)((char *)a2 + 280);
  *((_QWORD *)this + 37) = *((_QWORD *)a2 + 37);
  *(_OWORD *)((char *)this + 280) = v5;
  v7 = *((_OWORD *)a2 + 21);
  v6 = *((_OWORD *)a2 + 22);
  v8 = *((_OWORD *)a2 + 20);
  *(_OWORD *)((char *)this + 361) = *(_OWORD *)((char *)a2 + 361);
  *((_OWORD *)this + 21) = v7;
  *((_OWORD *)this + 22) = v6;
  *((_OWORD *)this + 20) = v8;
  *((_OWORD *)this + 19) = *((_OWORD *)a2 + 19);
  return this;
}

void re::Message::~Message(re::Message *this)
{
  uint64_t v2;

  re::Snapshot::~Snapshot((re::Message *)((char *)this + 80));
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    if (*((_QWORD *)this + 9))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *((_QWORD *)this + 9) = 0;
    *((_QWORD *)this + 6) = 0;
    *((_QWORD *)this + 7) = 0;
    *((_QWORD *)this + 5) = 0;
    ++*((_DWORD *)this + 16);
  }
  re::DynamicArray<re::Entry>::deinit((uint64_t)this);
}

void re::Snapshot::~Snapshot(re::Snapshot *this)
{
  re::MeshCollectionHandles *v2;

  v2 = (re::Snapshot *)((char *)this + 40);
  re::MeshCollectionHandles::~MeshCollectionHandles((re::Snapshot *)((char *)this + 120));
  re::MeshCollectionHandles::~MeshCollectionHandles(v2);
  if (*(_QWORD *)this)
  {
    if (*((_QWORD *)this + 4))
      (*(void (**)(_QWORD))(**(_QWORD **)this + 40))(*(_QWORD *)this);
    *((_QWORD *)this + 4) = 0;
    *((_QWORD *)this + 1) = 0;
    *((_QWORD *)this + 2) = 0;
    *(_QWORD *)this = 0;
    ++*((_DWORD *)this + 6);
  }
}

re::ConfChange *re::ConfChange::ConfChange(re::ConfChange *this, const re::ConfChange *a2)
{
  uint64_t v4;
  __int128 v5;
  __int128 v6;

  v4 = re::DynamicArray<BOOL>::DynamicArray((uint64_t)this, (uint64_t *)a2);
  re::DynamicArray<char const*>::DynamicArray(v4 + 40, (uint64_t *)a2 + 5);
  re::DynamicArray<char const*>::DynamicArray((uint64_t)this + 80, (uint64_t *)a2 + 10);
  v5 = *(_OWORD *)((char *)a2 + 120);
  v6 = *(_OWORD *)((char *)a2 + 136);
  *((_BYTE *)this + 152) = *((_BYTE *)a2 + 152);
  *(_OWORD *)((char *)this + 136) = v6;
  *(_OWORD *)((char *)this + 120) = v5;
  return this;
}

uint64_t re::Optional<re::Snapshot>::Optional(uint64_t a1, uint64_t *a2)
{
  int v3;
  __int128 v5;

  v3 = *(unsigned __int8 *)a2;
  *(_BYTE *)a1 = v3;
  if (v3)
  {
    re::DynamicArray<BOOL>::DynamicArray(a1 + 8, a2 + 1);
    re::DynamicArray<char const*>::DynamicArray(a1 + 48, a2 + 6);
    re::DynamicArray<char const*>::DynamicArray(a1 + 88, a2 + 11);
    re::DynamicArray<char const*>::DynamicArray(a1 + 128, a2 + 16);
    re::DynamicArray<char const*>::DynamicArray(a1 + 168, a2 + 21);
    v5 = *((_OWORD *)a2 + 13);
    *(_QWORD *)(a1 + 224) = a2[28];
    *(_OWORD *)(a1 + 208) = v5;
  }
  return a1;
}

uint64_t re::DynamicArray<re::Entry>::deinit(uint64_t a1)
{
  uint64_t result;
  re::MeshCollectionHandles *v3;
  uint64_t v4;
  uint64_t v5;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(re::MeshCollectionHandles **)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 104 * v4;
        do
        {
          re::MeshCollectionHandles::~MeshCollectionHandles(v3);
          v3 = (re::MeshCollectionHandles *)((char *)v3 + 104);
          v5 -= 104;
        }
        while (v5);
        result = *(_QWORD *)a1;
        v3 = *(re::MeshCollectionHandles **)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, re::MeshCollectionHandles *))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

_BYTE *re::Optional<re::ConfState>::Optional(_BYTE *a1, uint64_t *a2)
{
  int v3;

  v3 = *(unsigned __int8 *)a2;
  *a1 = v3;
  if (v3)
  {
    re::DynamicArray<char const*>::DynamicArray((uint64_t)(a1 + 8), a2 + 1);
    re::DynamicArray<char const*>::DynamicArray((uint64_t)(a1 + 48), a2 + 6);
  }
  return a1;
}

uint64_t re::DynamicArray<re::Message>::deinit(uint64_t a1)
{
  uint64_t result;
  re::Message *v3;
  uint64_t v4;
  uint64_t v5;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(re::Message **)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 384 * v4;
        do
        {
          re::Message::~Message(v3);
          v3 = (re::Message *)((char *)v3 + 384);
          v5 -= 384;
        }
        while (v5);
        result = *(_QWORD *)a1;
        v3 = *(re::Message **)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, re::Message *))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::ProgressSet::operator=(uint64_t a1, uint64_t *a2)
{
  re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::operator=(a1, a2);
  re::DynamicArray<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)>>::operator=(a1 + 48, (uint64_t)(a2 + 6));
  re::Optional<re::Configuration>::operator=((unsigned __int8 *)(a1 + 88), a2 + 11);
  re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::operator=(a1 + 192, a2 + 24);
  re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::operator=(a1 + 240, a2 + 30);
  *(_QWORD *)(a1 + 288) = a2[36];
  *(_QWORD *)(a1 + 296) = a2[37];
  return a1;
}

uint64_t re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::operator=(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    if (!*(_QWORD *)a1 || *(_QWORD *)a1 == *a2)
    {
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)a1, a2);
    }
    else if (*a2)
    {
      re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::copy(a1, (uint64_t)a2);
      ++*(_DWORD *)(a1 + 40);
    }
    else
    {
      re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::clear(a1);
    }
  }
  return a1;
}

unsigned __int8 *re::Optional<re::Configuration>::operator=(unsigned __int8 *a1, uint64_t *a2)
{
  int v3;
  int v4;
  BOOL v5;
  BOOL v6;
  uint64_t *v8;
  BOOL v9;

  v3 = *a1;
  v4 = *(unsigned __int8 *)a2;
  if (*a1)
    v5 = 0;
  else
    v5 = v4 == 0;
  if (!v5)
  {
    if (*a1)
      v6 = v4 == 0;
    else
      v6 = 0;
    if (v6)
    {
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)a1 + 7);
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)a1 + 1);
      *a1 = 0;
    }
    else
    {
      v8 = (uint64_t *)(a1 + 8);
      if (v3)
        v9 = 1;
      else
        v9 = v4 == 0;
      if (v9)
      {
        re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::operator=((uint64_t)v8, a2 + 1);
        re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::operator=((uint64_t)(a1 + 56), a2 + 7);
      }
      else
      {
        *a1 = 1;
        *(_OWORD *)v8 = 0u;
        *(_OWORD *)(a1 + 24) = 0u;
        *((_DWORD *)a1 + 10) = 0;
        *(_QWORD *)(a1 + 44) = 0x7FFFFFFFLL;
        re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap(v8, a2 + 1);
        *(_OWORD *)(a1 + 56) = 0u;
        *((_DWORD *)a1 + 22) = 0;
        *(_OWORD *)(a1 + 72) = 0u;
        *(_QWORD *)(a1 + 92) = 0x7FFFFFFFLL;
        re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)a1 + 7, a2 + 7);
      }
    }
  }
  return a1;
}

uint64_t re::ConfChange::operator=(uint64_t a1, uint64_t a2)
{
  char v4;
  __int128 v5;

  re::DynamicArray<re::internal::DeferredUnregister *>::operator=(a1, a2);
  re::DynamicArray<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)>>::operator=(a1 + 40, a2 + 40);
  re::DynamicArray<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)>>::operator=(a1 + 80, a2 + 80);
  v4 = *(_BYTE *)(a2 + 152);
  v5 = *(_OWORD *)(a2 + 136);
  *(_OWORD *)(a1 + 120) = *(_OWORD *)(a2 + 120);
  *(_OWORD *)(a1 + 136) = v5;
  *(_BYTE *)(a1 + 152) = v4;
  return a1;
}

uint64_t re::ConfChange::ConfChange(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __int128 v7;
  __int128 v8;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  v4 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)(a1 + 8) = v4;
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  v5 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v5;
  v6 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 32) = v6;
  ++*(_DWORD *)(a2 + 24);
  ++*(_DWORD *)(a1 + 24);
  re::ConfState::ConfState(a1 + 40, a2 + 40);
  v7 = *(_OWORD *)(a2 + 120);
  v8 = *(_OWORD *)(a2 + 136);
  *(_BYTE *)(a1 + 152) = *(_BYTE *)(a2 + 152);
  *(_OWORD *)(a1 + 136) = v8;
  *(_OWORD *)(a1 + 120) = v7;
  return a1;
}

uint64_t re::ConfState::ConfState(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  *(_QWORD *)(result + 32) = 0;
  *(_QWORD *)(result + 8) = 0;
  *(_QWORD *)(result + 16) = 0;
  *(_QWORD *)result = 0;
  *(_DWORD *)(result + 24) = 0;
  v2 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)result = *(_QWORD *)a2;
  *(_QWORD *)(result + 8) = v2;
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  v3 = *(_QWORD *)(result + 16);
  *(_QWORD *)(result + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v3;
  v4 = *(_QWORD *)(result + 32);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 32) = v4;
  ++*(_DWORD *)(a2 + 24);
  ++*(_DWORD *)(result + 24);
  *(_QWORD *)(result + 72) = 0;
  *(_QWORD *)(result + 48) = 0;
  *(_QWORD *)(result + 56) = 0;
  *(_QWORD *)(result + 40) = 0;
  *(_DWORD *)(result + 64) = 0;
  v5 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 48) = v5;
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  v6 = *(_QWORD *)(result + 56);
  *(_QWORD *)(result + 56) = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 56) = v6;
  v7 = *(_QWORD *)(result + 72);
  *(_QWORD *)(result + 72) = *(_QWORD *)(a2 + 72);
  *(_QWORD *)(a2 + 72) = v7;
  ++*(_DWORD *)(a2 + 64);
  ++*(_DWORD *)(result + 64);
  return result;
}

uint64_t re::Raft::Raft(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;

  v4 = *a2;
  *a2 = 0;
  *(_QWORD *)a1 = v4;
  re::Unstable::Unstable(a1 + 8, (uint64_t)(a2 + 1));
  *(_OWORD *)(a1 + 288) = *((_OWORD *)a2 + 18);
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_DWORD *)(a1 + 336) = 0;
  *(_QWORD *)(a1 + 340) = 0x7FFFFFFFLL;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)(a1 + 304), a2 + 38);
  *(_QWORD *)(a1 + 384) = 0;
  *(_DWORD *)(a1 + 376) = 0;
  *(_QWORD *)(a1 + 360) = 0;
  *(_QWORD *)(a1 + 368) = 0;
  *(_QWORD *)(a1 + 352) = 0;
  v5 = a2[45];
  *(_QWORD *)(a1 + 352) = a2[44];
  *(_QWORD *)(a1 + 360) = v5;
  a2[44] = 0;
  a2[45] = 0;
  v6 = *(_QWORD *)(a1 + 368);
  *(_QWORD *)(a1 + 368) = a2[46];
  a2[46] = v6;
  v7 = *(_QWORD *)(a1 + 384);
  *(_QWORD *)(a1 + 384) = a2[48];
  a2[48] = v7;
  ++*((_DWORD *)a2 + 94);
  ++*(_DWORD *)(a1 + 376);
  *(_QWORD *)(a1 + 424) = 0;
  *(_QWORD *)(a1 + 400) = 0;
  *(_QWORD *)(a1 + 408) = 0;
  *(_QWORD *)(a1 + 392) = 0;
  *(_DWORD *)(a1 + 416) = 0;
  v8 = a2[50];
  *(_QWORD *)(a1 + 392) = a2[49];
  *(_QWORD *)(a1 + 400) = v8;
  a2[49] = 0;
  a2[50] = 0;
  v9 = *(_QWORD *)(a1 + 408);
  *(_QWORD *)(a1 + 408) = a2[51];
  a2[51] = v9;
  v10 = *(_QWORD *)(a1 + 424);
  *(_QWORD *)(a1 + 424) = a2[53];
  a2[53] = v10;
  ++*((_DWORD *)a2 + 104);
  ++*(_DWORD *)(a1 + 416);
  re::ReadOnly::ReadOnly(a1 + 432, (uint64_t)(a2 + 54));
  *(_BYTE *)(a1 + 536) = *((_BYTE *)a2 + 536);
  v11 = *((unsigned __int8 *)a2 + 544);
  *(_BYTE *)(a1 + 544) = v11;
  if (v11)
    re::ProgressSet::ProgressSet(a1 + 552, (uint64_t)(a2 + 69));
  v12 = *((unsigned __int8 *)a2 + 856);
  *(_BYTE *)(a1 + 856) = v12;
  if (v12)
    re::ConfChange::ConfChange(a1 + 864, (uint64_t)(a2 + 108));
  v13 = *((unsigned __int8 *)a2 + 1024);
  *(_BYTE *)(a1 + 1024) = v13;
  if (v13)
    *(_QWORD *)(a1 + 1032) = a2[129];
  v14 = *((_OWORD *)a2 + 65);
  v15 = *((_OWORD *)a2 + 66);
  v16 = *((_OWORD *)a2 + 67);
  *(_OWORD *)(a1 + 1088) = *((_OWORD *)a2 + 68);
  *(_OWORD *)(a1 + 1072) = v16;
  *(_OWORD *)(a1 + 1056) = v15;
  *(_OWORD *)(a1 + 1040) = v14;
  v17 = *((_OWORD *)a2 + 69);
  v18 = *((_OWORD *)a2 + 70);
  v19 = *((_OWORD *)a2 + 71);
  *(_QWORD *)(a1 + 1149) = *(uint64_t *)((char *)a2 + 1149);
  *(_OWORD *)(a1 + 1136) = v19;
  *(_OWORD *)(a1 + 1120) = v18;
  *(_OWORD *)(a1 + 1104) = v17;
  return a1;
}

uint64_t re::Unstable::Unstable(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  v4 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)(a1 + 8) = v4;
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  v5 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v5;
  v6 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 32) = v6;
  ++*(_DWORD *)(a2 + 24);
  ++*(_DWORD *)(a1 + 24);
  re::Optional<re::Snapshot>::Optional(a1 + 40, (uint64_t *)(a2 + 40));
  *(_QWORD *)(a1 + 272) = *(_QWORD *)(a2 + 272);
  return a1;
}

uint64_t re::ReadOnly::ReadOnly(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  *(_DWORD *)(a1 + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_QWORD *)(a1 + 36) = 0x7FFFFFFFLL;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)a1, (uint64_t *)a2);
  *(_QWORD *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 80) = 0;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  v4 = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a1 + 56) = v4;
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  v5 = *(_QWORD *)(a1 + 64);
  *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(a2 + 64) = v5;
  v6 = *(_QWORD *)(a1 + 88);
  *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
  *(_QWORD *)(a2 + 88) = v6;
  v7 = *(_QWORD *)(a1 + 72);
  *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
  *(_QWORD *)(a2 + 72) = v7;
  *(_BYTE *)(a1 + 96) = *(_BYTE *)(a2 + 96);
  return a1;
}

uint64_t re::DynamicArray<re::Entry>::DynamicArray(uint64_t a1, uint64_t a2, unint64_t a3)
{
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  if (a3)
  {
    re::DynamicArray<re::Entry>::setCapacity((__n128 *)a1, a3);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::Entry>::copy((__n128 *)a1, 0, a2, a3);
  }
  return a1;
}

__n128 *re::DynamicArray<re::Entry>::setCapacity(__n128 *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  __n128 *v5;
  uint64_t v6;
  __n128 *v7;
  __n128 *v8;
  uint64_t v9;
  uint64_t v10;
  __n128 *v11;

  v3 = result->n128_i64[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[1].n128_u64[0] <= a2)
    {
      result = (__n128 *)result->n128_u64[0];
      if (!v5->n128_u64[0])
      {
        result = (__n128 *)re::DynamicArray<re::Entry>::setCapacity(v5, a2);
        ++v5[1].n128_u32[2];
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x68uLL))
        {
          v2 = 104 * a2;
          result = (__n128 *)(*(uint64_t (**)(__n128 *, unint64_t, uint64_t))(result->n128_u64[0] + 32))(result, 104 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5->n128_u64[1])
              goto LABEL_16;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 104, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(v5->n128_u64[0] + 8));
        result = (__n128 *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[2].n128_u64[0] = (unint64_t)v7;
        v5->n128_u64[1] = a2;
        return result;
      }
LABEL_11:
      v8 = (__n128 *)v5[2].n128_u64[0];
      v9 = v5[1].n128_i64[0];
      if (v9)
      {
        v10 = 104 * v9;
        v11 = v7;
        do
        {
          re::Entry::Entry(v11, v8);
          re::MeshCollectionHandles::~MeshCollectionHandles((re::MeshCollectionHandles *)v8);
          v8 = (__n128 *)((char *)v8 + 104);
          v11 = (__n128 *)((char *)v11 + 104);
          v10 -= 104;
        }
        while (v10);
        v8 = (__n128 *)v5[2].n128_u64[0];
      }
      result = (__n128 *)(*(uint64_t (**)(unint64_t, __n128 *))(*(_QWORD *)v5->n128_u64[0] + 40))(v5->n128_u64[0], v8);
      goto LABEL_16;
    }
  }
  return result;
}

__n128 re::Entry::Entry(__n128 *a1, __n128 *a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  __n128 result;

  a1[2].n128_u64[0] = 0;
  a1->n128_u64[1] = 0;
  a1[1].n128_u64[0] = 0;
  a1->n128_u64[0] = 0;
  a1[1].n128_u32[2] = 0;
  v2 = a2->n128_u64[1];
  a1->n128_u64[0] = a2->n128_u64[0];
  a1->n128_u64[1] = v2;
  a2->n128_u64[0] = 0;
  a2->n128_u64[1] = 0;
  v3 = a1[1].n128_u64[0];
  a1[1].n128_u64[0] = a2[1].n128_u64[0];
  a2[1].n128_u64[0] = v3;
  v4 = a1[2].n128_u64[0];
  a1[2].n128_u64[0] = a2[2].n128_u64[0];
  a2[2].n128_u64[0] = v4;
  ++a2[1].n128_u32[2];
  ++a1[1].n128_u32[2];
  a1[4].n128_u64[1] = 0;
  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[2].n128_u64[1] = 0;
  a1[4].n128_u32[0] = 0;
  v5 = a2[3].n128_u64[0];
  a1[2].n128_u64[1] = a2[2].n128_u64[1];
  a1[3].n128_u64[0] = v5;
  a2[2].n128_u64[1] = 0;
  a2[3].n128_u64[0] = 0;
  v6 = a1[3].n128_u64[1];
  a1[3].n128_u64[1] = a2[3].n128_u64[1];
  a2[3].n128_u64[1] = v6;
  v7 = a1[4].n128_u64[1];
  a1[4].n128_u64[1] = a2[4].n128_u64[1];
  a2[4].n128_u64[1] = v7;
  ++a2[4].n128_u32[0];
  ++a1[4].n128_u32[0];
  result = a2[5];
  a1[6].n128_u64[0] = a2[6].n128_u64[0];
  a1[5] = result;
  return result;
}

__n128 *re::DynamicArray<re::Entry>::copy(__n128 *this, unint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  __n128 *v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  __int128 v16;
  uint64_t v17;
  __int128 v18;
  _OWORD v19[5];
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  if (!a4)
    return this;
  v6 = this;
  v7 = this[1].n128_u64[0];
  if (v7 + 1 <= a2)
  {
    v17 = 0;
    memset(v19, 0, sizeof(v19));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    LODWORD(v18) = 136315906;
    *(_QWORD *)((char *)&v18 + 4) = "copy";
    WORD6(v18) = 1024;
    HIWORD(v18) = 643;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)7, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::copy(). size = %zu, pos = %zu, count = %zu", "!overflow", "copy", 647, v7, a2, v4, v17, v18);
    _os_crash();
    __break(1u);
  }
  v4 = a4;
  v8 = a2 + a4;
  if (__CFADD__(a2, a4))
    goto LABEL_13;
  if (v7 >= v8)
  {
    this = (__n128 *)std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::Entry const*,re::Entry const*,re::Entry*>((uint64_t)v19, a3, a3 + 104 * a4, this[2].n128_u64[0] + 104 * a2);
  }
  else
  {
    re::DynamicArray<re::Entry>::growCapacity(this, a2 + a4);
    v10 = v6[1].n128_u64[0];
    v11 = a3 + 104 * (v10 - a2);
    this = (__n128 *)std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::Entry const*,re::Entry const*,re::Entry*>((uint64_t)v19, a3, v11, v6[2].n128_u64[0] + 104 * a2);
    if (v10 - a2 != v4)
    {
      v12 = 0;
      v13 = v6[2].n128_u64[0] + 104 * v6[1].n128_u64[0];
      v14 = 104 * a2 + 104 * v4 - 104 * v10;
      do
      {
        v15 = v13 + v12;
        re::DynamicArray<BOOL>::DynamicArray(v13 + v12, (uint64_t *)(v11 + v12));
        this = (__n128 *)re::DynamicArray<BOOL>::DynamicArray(v13 + v12 + 40, (uint64_t *)(v11 + v12 + 40));
        v16 = *(_OWORD *)(v11 + v12 + 80);
        *(_QWORD *)(v15 + 96) = *(_QWORD *)(v11 + v12 + 96);
        *(_OWORD *)(v15 + 80) = v16;
        v12 += 104;
      }
      while (v14 != v12);
    }
    v6[1].n128_u64[0] = v8;
  }
  ++v6[1].n128_u32[2];
  return this;
}

__n128 *re::DynamicArray<re::Entry>::growCapacity(__n128 *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  __n128 *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this->n128_u64[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (this->n128_u64[0])
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<re::Entry>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::Entry>::setCapacity(v4, v3);
      ++v4[1].n128_u32[2];
    }
  }
  return this;
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::Entry const*,re::Entry const*,re::Entry*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v5 = a2;
  if (a2 == a3)
    return a2;
  v6 = a3;
  do
  {
    re::DynamicArray<BOOL>::operator=(a4, (uint64_t *)v5);
    re::DynamicArray<BOOL>::operator=(a4 + 40, (uint64_t *)(v5 + 40));
    v7 = *(_QWORD *)(v5 + 96);
    *(_OWORD *)(a4 + 80) = *(_OWORD *)(v5 + 80);
    *(_QWORD *)(a4 + 96) = v7;
    a4 += 104;
    v5 += 104;
  }
  while (v5 != v6);
  return v6;
}

__n128 *re::DynamicArray<re::Entry>::DynamicArray(__n128 *a1, unint64_t *a2)
{
  unint64_t v3;
  unint64_t v5;

  a1[2].n128_u64[0] = 0;
  a1->n128_u64[1] = 0;
  a1[1].n128_u64[0] = 0;
  a1->n128_u64[0] = 0;
  a1[1].n128_u32[2] = 0;
  v3 = *a2;
  if (*a2)
  {
    v5 = a2[2];
    a1->n128_u64[0] = v3;
    re::DynamicArray<re::Entry>::setCapacity(a1, v5);
    ++a1[1].n128_u32[2];
    re::DynamicArray<re::Entry>::copy(a1, (uint64_t)a2);
  }
  return a1;
}

re::MeshCollectionHandles *re::DynamicArray<re::Entry>::copy(__n128 *a1, uint64_t a2)
{
  unint64_t v4;
  re::MeshCollectionHandles *result;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  __int128 v15;
  char v16;
  char v17;

  v4 = *(_QWORD *)(a2 + 16);
  if (v4 >= a1[1].n128_u64[0])
  {
    re::DynamicArray<re::Entry>::setCapacity(a1, *(_QWORD *)(a2 + 16));
    result = (re::MeshCollectionHandles *)std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::Entry const*,re::Entry const*,re::Entry*>((uint64_t)&v17, *(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 32) + 104 * a1[1].n128_u64[0], a1[2].n128_i64[0]);
    v9 = a1[1].n128_u64[0];
    if (v9 != v4)
    {
      v10 = *(_QWORD *)(a2 + 32);
      v11 = a1[2].n128_u64[0];
      v12 = 104 * v9;
      v13 = 104 * v4;
      do
      {
        v14 = v11 + v12;
        re::DynamicArray<BOOL>::DynamicArray(v11 + v12, (uint64_t *)(v10 + v12));
        result = (re::MeshCollectionHandles *)re::DynamicArray<BOOL>::DynamicArray(v11 + v12 + 40, (uint64_t *)(v10 + v12 + 40));
        v15 = *(_OWORD *)(v10 + v12 + 80);
        *(_QWORD *)(v14 + 96) = *(_QWORD *)(v10 + v12 + 96);
        *(_OWORD *)(v14 + 80) = v15;
        v13 -= 104;
        v10 += 104;
        v11 += 104;
      }
      while (v12 != v13);
    }
  }
  else
  {
    result = (re::MeshCollectionHandles *)std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::Entry const*,re::Entry const*,re::Entry*>((uint64_t)&v16, *(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 32) + 104 * v4, a1[2].n128_i64[0]);
    v6 = a1[1].n128_u64[0];
    if (v4 != v6)
    {
      result = (re::MeshCollectionHandles *)(a1[2].n128_u64[0] + 104 * v4);
      v7 = 104 * v6 - 104 * v4;
      do
      {
        re::MeshCollectionHandles::~MeshCollectionHandles(result);
        result = (re::MeshCollectionHandles *)(v8 + 104);
        v7 -= 104;
      }
      while (v7);
    }
  }
  a1[1].n128_u64[0] = v4;
  return result;
}

_QWORD *re::DynamicArray<re::Message>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  re::Message *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::Message>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x180uLL))
        {
          v2 = 384 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 384 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_16;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 384, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = (re::Message *)v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = 384 * v9;
        v11 = (uint64_t)v7;
        do
        {
          re::Message::Message(v11, (uint64_t)v8);
          re::Message::~Message(v8);
          v8 = (re::Message *)((char *)v8 + 384);
          v11 += 384;
          v10 -= 384;
        }
        while (v10);
        v8 = (re::Message *)v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, re::Message *))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

uint64_t re::DynamicArray<unsigned char>::DynamicArray(uint64_t a1, char *a2, unint64_t a3)
{
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  if (a3)
  {
    re::DynamicArray<BOOL>::setCapacity((_QWORD *)a1, a3);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<REFrameAnalysisBottleneck>::copy((_QWORD *)a1, 0, a2, a3);
  }
  return a1;
}

_QWORD *re::DynamicArray<re::ReadState>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::ReadState>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x30uLL))
        {
          v2 = 48 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 48 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_20;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 48, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_20:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = (_QWORD *)v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = 48 * v9;
        v11 = (uint64_t)v7;
        do
        {
          re::ReadState::ReadState(v11, (uint64_t)v8);
          if (*v8)
          {
            if (v8[4])
              (*(void (**)(_QWORD))(*(_QWORD *)*v8 + 40))(*v8);
            v8[4] = 0;
            v8[1] = 0;
            v8[2] = 0;
            *v8 = 0;
            ++*((_DWORD *)v8 + 6);
          }
          v8 += 6;
          v11 += 48;
          v10 -= 48;
        }
        while (v10);
        v8 = (_QWORD *)v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_20;
    }
  }
  return result;
}

uint64_t re::ReadState::ReadState(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *(_QWORD *)(result + 32) = 0;
  *(_QWORD *)(result + 8) = 0;
  *(_QWORD *)(result + 16) = 0;
  *(_QWORD *)result = 0;
  *(_DWORD *)(result + 24) = 0;
  v2 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)result = *(_QWORD *)a2;
  *(_QWORD *)(result + 8) = v2;
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  v3 = *(_QWORD *)(result + 16);
  *(_QWORD *)(result + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v3;
  v4 = *(_QWORD *)(result + 32);
  v5 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 32) = v4;
  ++*(_DWORD *)(a2 + 24);
  ++*(_DWORD *)(result + 24);
  *(_QWORD *)(result + 40) = v5;
  return result;
}

uint64_t re::Result<re::Optional<re::Progress>,re::DetailedError>::~Result(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;

  if (*(_BYTE *)a1)
  {
    re::Optional<re::Progress>::~Optional(a1 + 8);
  }
  else
  {
    v3 = (_OWORD *)(a1 + 24);
    v2 = *(_QWORD *)(a1 + 24);
    if (v2)
    {
      if ((*(_BYTE *)(a1 + 32) & 1) != 0)
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 40));
      *v3 = 0u;
      *(_OWORD *)(a1 + 40) = 0u;
    }
  }
  return a1;
}

uint64_t re::Optional<re::Progress>::~Optional(uint64_t a1)
{
  uint64_t v2;

  if (*(_BYTE *)a1)
  {
    v2 = *(_QWORD *)(a1 + 8);
    if (v2)
    {
      if (*(_QWORD *)(a1 + 40))
        (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
      *(_QWORD *)(a1 + 40) = 0;
      *(_QWORD *)(a1 + 16) = 0;
      *(_QWORD *)(a1 + 24) = 0;
      *(_QWORD *)(a1 + 8) = 0;
      ++*(_DWORD *)(a1 + 32);
    }
  }
  return a1;
}

uint64_t re::Progress::becomeProbe(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;

  if (*(_BYTE *)(this + 64) == 2)
  {
    v1 = *(_QWORD *)(this + 88);
    *(_BYTE *)(this + 104) = 0;
    *(_QWORD *)(this + 88) = 0;
    *(_QWORD *)(this + 40) = 0;
    *(_QWORD *)(this + 48) = 0;
    if (*(_QWORD *)(this + 72) + 1 <= (unint64_t)(v1 + 1))
      v2 = v1 + 1;
    else
      v2 = *(_QWORD *)(this + 72) + 1;
  }
  else
  {
    *(_BYTE *)(this + 104) = 0;
    *(_QWORD *)(this + 88) = 0;
    *(_QWORD *)(this + 40) = 0;
    *(_QWORD *)(this + 48) = 0;
    v2 = *(_QWORD *)(this + 72) + 1;
  }
  *(_BYTE *)(this + 64) = 0;
  *(_QWORD *)(this + 80) = v2;
  return this;
}

uint64_t re::Progress::maybeDecrementTo(re::Progress *this, unint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;

  if (*((_BYTE *)this + 64) != 1)
  {
    v5 = *((_QWORD *)this + 10);
    if (v5)
    {
      if (!a4 && v5 - 1 != a2)
        return 0;
      if (!a4)
      {
        if (a3 + 1 < a2)
          v6 = a3 + 1;
        else
          v6 = a2;
        if (v6 <= 1)
          v6 = 1;
        *((_QWORD *)this + 10) = v6;
LABEL_20:
        *((_BYTE *)this + 104) = 0;
        return 1;
      }
    }
    else if (!a4)
    {
      return 0;
    }
    if (!*((_QWORD *)this + 12))
      *((_QWORD *)this + 12) = a4;
    goto LABEL_20;
  }
  v4 = *((_QWORD *)this + 9);
  if (v4 <= a2 && (a4 || v4 != a2))
  {
    if (a4)
      *((_QWORD *)this + 12) = a4;
    else
      *((_QWORD *)this + 10) = v4 + 1;
    return 1;
  }
  return 0;
}

_QWORD *re::Progress::updateState(_QWORD *this, uint64_t a2)
{
  int v2;

  v2 = *((unsigned __int8 *)this + 64);
  if (!*((_BYTE *)this + 64))
    goto LABEL_5;
  if (v2 == 1)
  {
    this[10] = a2 + 1;
    return re::Inflights::add(this, a2);
  }
  if (v2 == 2)
  {
    re::internal::assertLog((re::internal *)5, a2, "assertion failure: '%s' (%s:line %i) updating progress state in unhandled state: %hhu", "!\"Unreachable code\"", "updateState", 116, 2);
    this = (_QWORD *)_os_crash();
    __break(1u);
LABEL_5:
    *((_BYTE *)this + 104) = 1;
  }
  return this;
}

_anonymous_namespace_ *re::Config::validate@<X0>(_anonymous_namespace_ *this@<X0>, uint64_t a2@<X8>)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  const char *v7;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;

  if (!*((_QWORD *)this + 1))
  {
    v7 = "Invalid node ID";
LABEL_13:
    goto LABEL_14;
  }
  v3 = *((_QWORD *)this + 7);
  if (!v3)
  {
    v7 = "Heartbeat must be greater than 0";
    goto LABEL_13;
  }
  v4 = *((_QWORD *)this + 6);
  if (v4 <= v3)
  {
    v7 = "Election tick must be greater than heartbeat tick";
    goto LABEL_13;
  }
  v5 = *((_QWORD *)this + 4);
  v6 = *((_QWORD *)this + 5);
  if (!v5)
    v5 = *((_QWORD *)this + 6);
  if (!v6)
    v6 = 2 * v4;
  if (v5 >= v4)
  {
    if (v5 >= v6)
    {
      this = (_anonymous_namespace_ *)re::DynamicString::format((re::DynamicString *)"Min election tick %zu should be less than max election tick %zu", (re::DynamicString *)&v11, v5, v6);
      goto LABEL_14;
    }
    if (*((_QWORD *)this + 3))
    {
      *(_BYTE *)a2 = 1;
      return this;
    }
    v7 = "Max inflight messages must be greater than 0";
    goto LABEL_13;
  }
  this = (_anonymous_namespace_ *)re::DynamicString::format((re::DynamicString *)"Election tick %zu must be greater than heartbeat tick %zu", (re::DynamicString *)&v11, v5, v4);
LABEL_14:
  v8 = v11;
  v9 = v12;
  v10 = v13;
  *(_BYTE *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 5;
  *(_QWORD *)(a2 + 16) = &re::ConsensusErrorCategory(void)::instance;
  *(_OWORD *)(a2 + 24) = v8;
  *(_QWORD *)(a2 + 40) = v9;
  *(_QWORD *)(a2 + 48) = v10;
  return this;
}

uint64_t MemStorageCore::lastIndex(MemStorageCore *this)
{
  uint64_t v1;
  char *v2;

  v1 = *((_QWORD *)this + 28);
  if (v1)
    v2 = (char *)(*((_QWORD *)this + 30) + 104 * v1 - 16);
  else
    v2 = (char *)this + 416;
  return *(_QWORD *)v2;
}

unsigned __int8 *re::Optional<re::ConfState>::operator=(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v3;
  int v4;
  BOOL v5;
  BOOL v6;
  uint64_t v8;
  BOOL v9;

  v3 = *a1;
  v4 = *a2;
  if (*a1)
    v5 = 0;
  else
    v5 = v4 == 0;
  if (!v5)
  {
    if (*a1)
      v6 = v4 == 0;
    else
      v6 = 0;
    if (v6)
    {
      re::MeshCollectionHandles::~MeshCollectionHandles((re::MeshCollectionHandles *)(a1 + 8));
      *a1 = 0;
    }
    else
    {
      v8 = (uint64_t)(a1 + 8);
      if (v3)
        v9 = 1;
      else
        v9 = v4 == 0;
      if (v9)
      {
        re::DynamicArray<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)>>::operator=(v8, (uint64_t)(a2 + 8));
        re::DynamicArray<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)>>::operator=((uint64_t)(a1 + 48), (uint64_t)(a2 + 48));
      }
      else
      {
        *a1 = 1;
        re::ConfState::ConfState(v8, (uint64_t)(a2 + 8));
      }
    }
  }
  return a1;
}

void re::DynamicArray<re::Entry>::removeManyStableAt(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  _OWORD v8[5];
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  if (a3)
  {
    v5 = a2 + a3 - 1;
    v6 = *(_QWORD *)(a1 + 16);
    if (v5 >= v6)
    {
      memset(v8, 0, sizeof(v8));
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    if (v5 < v6 - 1)
      std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::Entry *,re::Entry *,re::Entry *>((uint64_t)v8, *(_QWORD *)(a1 + 32) + 104 * a2 + 104 * a3, *(_QWORD *)(a1 + 32) + 104 * v6, *(_QWORD *)(a1 + 32) + 104 * a2);
    v7 = 0;
    do
    {
      re::MeshCollectionHandles::~MeshCollectionHandles((re::MeshCollectionHandles *)(*(_QWORD *)(a1 + 32)
                                                                                    + 104 * (v7 + *(_QWORD *)(a1 + 16))
                                                                                    - 104));
      --v7;
    }
    while (-a3 != v7);
    *(_QWORD *)(a1 + 16) -= a3;
    ++*(_DWORD *)(a1 + 24);
  }
}

void MemStorageCore::setConfState(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v6;
  unsigned __int8 v7[8];
  _BYTE v8[40];
  uint64_t v9;

  re::DynamicArray<unsigned long long>::operator=(a1 + 128, a2);
  re::DynamicArray<unsigned long long>::operator=(a1 + 168, a2 + 5);
  if (*(_BYTE *)a3)
  {
    v7[0] = 1;
    re::DynamicArray<char const*>::DynamicArray((uint64_t)v8, (uint64_t *)(a3 + 8));
    re::DynamicArray<char const*>::DynamicArray((uint64_t)&v9, (uint64_t *)(a3 + 48));
    re::Optional<re::ConfState>::operator=((unsigned __int8 *)a1, v7);
    if (v7[0])
      re::MeshCollectionHandles::~MeshCollectionHandles((re::MeshCollectionHandles *)v8);
    v6 = *(_QWORD *)(a3 + 88);
    if (!*(_BYTE *)(a1 + 88))
      *(_BYTE *)(a1 + 88) = 1;
    *(_QWORD *)(a1 + 96) = v6;
  }
}

void MemStorage::initialState(MemStorage *this@<X0>, uint64_t a2@<X8>)
{
  int v3;
  int v4;
  _BYTE v5[8];
  uint64_t v6;
  unsigned __int8 v7;
  uint64_t v8;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;

  RaftState::RaftState((RaftState *)v5, (MemStorage *)((char *)this + 8));
  *(_BYTE *)a2 = 1;
  v3 = v5[0];
  *(_BYTE *)(a2 + 8) = v5[0];
  if (v3)
    re::ConfState::ConfState(a2 + 16, (uint64_t)&v6);
  v4 = v7;
  *(_BYTE *)(a2 + 96) = v7;
  if (v4)
    *(_QWORD *)(a2 + 104) = v8;
  *(_OWORD *)(a2 + 112) = v9;
  *(_QWORD *)(a2 + 128) = v10;
  re::ConfState::ConfState(a2 + 136, (uint64_t)&v11);
  RaftState::~RaftState((RaftState *)v5);
}

_QWORD *MemStorage::firstIndex@<X0>(_QWORD *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;

  if (this[29])
    v2 = *(_QWORD *)(this[31] + 88);
  else
    v2 = this[53] + 1;
  *(_BYTE *)a2 = 1;
  *(_QWORD *)(a2 + 8) = v2;
  return this;
}

_QWORD *MemStorage::lastIndex@<X0>(_QWORD *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;

  v2 = this[29];
  if (v2)
    v3 = (uint64_t *)(this[31] + 104 * v2 - 16);
  else
    v3 = this + 53;
  v4 = *v3;
  *(_BYTE *)a2 = 1;
  *(_QWORD *)(a2 + 8) = v4;
  return this;
}

_QWORD *MemStorage::entries@<X0>(_QWORD *this@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  __int128 v14;
  uint64_t Index;
  uint64_t v17;
  uint64_t v18[2];
  _BYTE v19[28];
  __int16 v20;
  _BYTE v21[10];
  _OWORD v22[2];
  __int128 v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v5 = this[29];
  if (v5)
  {
    v6 = this[31];
    if (*(_QWORD *)(v6 + 88) <= a2)
    {
      v7 = *(_QWORD *)(v6 + 104 * v5 - 16) + 1;
      goto LABEL_6;
    }
LABEL_5:
    *(_BYTE *)a4 = 0;
    *(_BYTE *)(a4 + 8) = 0;
    return this;
  }
  v7 = this[53] + 1;
  if (v7 > a2)
    goto LABEL_5;
LABEL_6:
  if (v7 < a3)
  {
    Index = MemStorageCore::lastIndex((MemStorageCore *)(this + 1));
    re::internal::assertLog((re::internal *)6, v17, "assertion failure: '%s' (%s:line %i) Index out of bound (last: %llu, high: %llu)", "!\"Unreachable code\"", "entries", 202, Index + 1, a3);
    this = (_QWORD *)_os_crash();
    __break(1u);
    return this;
  }
  v8 = this[31];
  v9 = a2 - *(_QWORD *)(v8 + 88);
  v10 = v5 + 1;
  if (v5 + 1 <= v9)
  {
    v18[0] = 0;
    v24 = 0u;
    v25 = 0u;
    v23 = 0u;
    memset(v22, 0, sizeof(v22));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v19 = 136315906;
    *(_QWORD *)&v19[4] = "slice";
    *(_WORD *)&v19[12] = 1024;
    *(_DWORD *)&v19[14] = 1119;
    *(_WORD *)&v19[18] = 2048;
    *(_QWORD *)&v19[20] = v9;
    v20 = 2048;
    *(_QWORD *)v21 = v10;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_13;
  }
  v11 = a3 - a2;
  if (__CFADD__(v9, a3 - a2))
  {
LABEL_13:
    re::internal::assertLog((re::internal *)7, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::slice(size_t,size_t). index, %zu, count = %zu, array size = %zu", "!overflow", "slice", 1125, v9, v11, v5);
    _os_crash();
    __break(1u);
LABEL_14:
    re::internal::assertLog((re::internal *)7, a2, "assertion failure: '%s' (%s:line %i) Invalid count. index = %zu, count = %zu, array size = %zu", "endIndexExclusive <= m_size", "slice", 1129, v9, v11, v5);
    _os_crash();
    __break(1u);
  }
  if (a3 - *(_QWORD *)(v8 + 88) > v5)
    goto LABEL_14;
  v18[0] = v8 + 104 * v9;
  v18[1] = a3 - a2;
  re::DynamicArray<re::Entry>::DynamicArray((uint64_t)v19, v18);
  v12 = *(_QWORD *)v19;
  *(_QWORD *)v19 = 0;
  v13 = *(_QWORD *)&v21[2];
  *(_QWORD *)&v21[2] = 0;
  ++*(_DWORD *)&v19[24];
  *(_BYTE *)a4 = 1;
  *(_QWORD *)(a4 + 8) = v12;
  *(_QWORD *)&v22[0] = 0;
  v14 = *(_OWORD *)&v19[8];
  *(_OWORD *)&v19[8] = 0u;
  *(_OWORD *)(a4 + 16) = v14;
  *(_OWORD *)((char *)v22 + 8) = 0u;
  *(_QWORD *)(a4 + 40) = v13;
  *(_QWORD *)&v23 = 0;
  DWORD2(v22[1]) = 2;
  *(_DWORD *)(a4 + 32) = 1;
  re::DynamicArray<re::Entry>::deinit((uint64_t)v22);
  return (_QWORD *)re::DynamicArray<re::Entry>::deinit((uint64_t)v19);
}

uint64_t MemStorage::initializeWithConfState(_QWORD *a1, uint64_t *a2)
{
  a1[53] = 1;
  a1[54] = 1;
  a1[16] = 1;
  a1[14] = 1;
  re::DynamicArray<unsigned long long>::operator=((uint64_t)(a1 + 17), a2);
  return re::DynamicArray<unsigned long long>::operator=((uint64_t)(a1 + 22), a2 + 5);
}

_QWORD *MemStorage::term@<X0>(_QWORD *this@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;

  v3 = this[53];
  if (v3 == a2)
  {
    v4 = this[54];
LABEL_10:
    *(_BYTE *)a3 = 1;
    *(_QWORD *)(a3 + 8) = v4;
    return this;
  }
  v5 = this[29];
  if (v5)
    v6 = *(_QWORD *)(this[31] + 88);
  else
    v6 = v3 + 1;
  if (v6 > a2)
  {
    *(_BYTE *)a3 = 0;
    *(_BYTE *)(a3 + 8) = 0;
    return this;
  }
  v7 = this[31];
  v8 = a2 - *(_QWORD *)(v7 + 88);
  if (v8 < v5)
  {
    v4 = *(_QWORD *)(v7 + 104 * v8 + 96);
    goto LABEL_10;
  }
  *(_BYTE *)a3 = 0;
  *(_BYTE *)(a3 + 8) = 1;
  return this;
}

void MemStorage::snapshot(MemStorage *this@<X0>, unint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t v6;
  uint64_t v7;
  _BYTE v8[224];
  _OWORD v9[5];
  _OWORD v10[5];
  _OWORD v11[2];
  __int128 v12;
  unint64_t v13;
  uint64_t v14;

  if (*((_BYTE *)this + 440))
  {
    *((_BYTE *)this + 440) = 0;
    *a3 = 0;
    a3[8] = 3;
  }
  else
  {
    v12 = 0u;
    memset(v11, 0, sizeof(v11));
    memset(v10, 0, sizeof(v10));
    memset(v9, 0, sizeof(v9));
    v6 = *((_QWORD *)this + 14);
    v13 = *((_QWORD *)this + 16);
    v14 = v6;
    re::DynamicArray<unsigned long long>::operator=((uint64_t)&v9[2] + 8, (uint64_t *)this + 17);
    re::DynamicArray<unsigned long long>::operator=((uint64_t)v10, (uint64_t *)this + 22);
    if (*((_BYTE *)this + 8))
    {
      v7 = *((_QWORD *)this + 13);
      re::DynamicArray<unsigned long long>::operator=((uint64_t)&v10[2] + 8, (uint64_t *)this + 2);
      re::DynamicArray<unsigned long long>::operator=((uint64_t)v11, (uint64_t *)this + 7);
      *((_QWORD *)&v12 + 1) = v7;
    }
    if (v13 < a2)
      v13 = a2;
    re::types::Ok<re::Snapshot>::Ok((uint64_t)v8, (uint64_t)v9);
    re::Result<re::Snapshot,re::StorageError>::Result((uint64_t)a3, (uint64_t)v8);
    re::Snapshot::~Snapshot((re::Snapshot *)v8);
    re::Snapshot::~Snapshot((re::Snapshot *)v9);
  }
}

void MemStorage::append(_QWORD *a1@<X0>, uint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  __n128 *v12;
  uint64_t v13;
  __n128 *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  if (!*(_QWORD *)(a2 + 16))
    goto LABEL_15;
  v5 = *(_QWORD *)(a2 + 32);
  v6 = a1[29];
  if (v6)
  {
    v7 = a1[31];
    v8 = *(_QWORD *)(v7 + 88);
    v9 = *(_QWORD *)(v5 + 88);
    if (v8 <= v9)
    {
      v10 = *(_QWORD *)(v7 + 104 * v6 - 16);
      v11 = v10 + 1;
      goto LABEL_7;
    }
LABEL_6:
    re::DynamicString::format((re::DynamicString *)"Overwrite compacted logs, compacted: %llu, append: %llu", (re::DynamicString *)&v16, v8 - 1, v9);
LABEL_9:
    if (v16 && (v17 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v16 + 40))();
    goto LABEL_15;
  }
  v10 = a1[53];
  v8 = v10 + 1;
  v9 = *(_QWORD *)(v5 + 88);
  v11 = v10 + 1;
  if (v10 + 1 > v9)
    goto LABEL_6;
LABEL_7:
  if (v11 < v9)
  {
    re::DynamicString::format((re::DynamicString *)"Raft logs should be continuous. Last index: %llu, newly appended: %llu", (re::DynamicString *)&v16, v10, v9);
    goto LABEL_9;
  }
  v12 = (__n128 *)(a1 + 27);
  re::DynamicArray<re::Entry>::removeManyStableAt((uint64_t)(a1 + 27), v9 - v8, v6 - (v9 - v8));
  v13 = *(_QWORD *)(a2 + 16);
  if (v13)
  {
    v14 = *(__n128 **)(a2 + 32);
    v15 = 104 * v13;
    do
    {
      re::DynamicArray<re::Entry>::add(v12, v14);
      v14 = (__n128 *)((char *)v14 + 104);
      v15 -= 104;
    }
    while (v15);
  }
LABEL_15:
  *a3 = 1;
}

void MemStorage::compact(MemStorage *this@<X0>, unint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v4 = *((_QWORD *)this + 29);
  if (v4)
  {
    v5 = *((_QWORD *)this + 31);
    v6 = *(_QWORD *)(v5 + 88);
    if (a2 <= v6)
      goto LABEL_9;
    v7 = *(_QWORD *)(v5 + 104 * v4 - 16);
    if (v7 + 1 >= a2)
    {
      re::DynamicArray<re::Entry>::removeManyStableAt((uint64_t)this + 216, 0, a2 - v6);
      goto LABEL_9;
    }
  }
  else
  {
    v7 = *((_QWORD *)this + 53);
    if (v7 + 1 >= a2)
      goto LABEL_9;
  }
  re::DynamicString::format((re::DynamicString *)"Compact not received raft logs: %llu, last index: %llu", (re::DynamicString *)&v8, a2, v7);
  if (v8 && (v9 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v8 + 40))();
LABEL_9:
  *a3 = 1;
}

uint64_t MemStorage::triggerSnapUnavailable(uint64_t this)
{
  *(_BYTE *)(this + 440) = 1;
  return this;
}

void MemStorage::applySnapshot(MemStorage *this@<X0>, const re::Snapshot *a2@<X1>, _BYTE *a3@<X8>)
{
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned __int8 v11[8];
  _BYTE v12[40];
  uint64_t v13;
  uint64_t v14[5];
  uint64_t v15[5];

  v6 = *((_QWORD *)a2 + 26);
  if (*((_QWORD *)this + 29))
    v7 = *(_QWORD *)(*((_QWORD *)this + 31) + 88);
  else
    v7 = *((_QWORD *)this + 53) + 1;
  if (v7 <= v6)
  {
    v8 = *((_QWORD *)a2 + 27);
    re::DynamicArray<unsigned long long>::operator=((uint64_t)this + 256, (uint64_t *)a2 + 5);
    re::DynamicArray<unsigned long long>::operator=((uint64_t)this + 296, (uint64_t *)a2 + 10);
    re::DynamicArray<unsigned long long>::operator=((uint64_t)this + 336, (uint64_t *)a2 + 15);
    re::DynamicArray<unsigned long long>::operator=((uint64_t)this + 376, (uint64_t *)a2 + 20);
    v9 = *((_QWORD *)a2 + 27);
    *((_OWORD *)this + 26) = *(_OWORD *)((char *)a2 + 200);
    *((_QWORD *)this + 54) = v9;
    *((_QWORD *)this + 14) = v8;
    *((_QWORD *)this + 16) = v6;
    re::DynamicArray<re::Entry>::clear((MemStorage *)((char *)this + 216));
    re::DynamicArray<unsigned long long>::operator=((uint64_t)this + 136, (uint64_t *)a2 + 5);
    re::DynamicArray<unsigned long long>::operator=((uint64_t)this + 176, (uint64_t *)a2 + 10);
    if (*((_QWORD *)a2 + 25))
    {
      re::DynamicArray<char const*>::DynamicArray((uint64_t)v14, (uint64_t *)a2 + 15);
      re::DynamicArray<char const*>::DynamicArray((uint64_t)v15, (uint64_t *)a2 + 20);
      v10 = *((_QWORD *)a2 + 25);
      v11[0] = 1;
      re::DynamicArray<char const*>::DynamicArray((uint64_t)v12, v14);
      re::DynamicArray<char const*>::DynamicArray((uint64_t)&v13, v15);
      re::Optional<re::ConfState>::operator=((unsigned __int8 *)this + 8, v11);
      if (v11[0])
        re::MeshCollectionHandles::~MeshCollectionHandles((re::MeshCollectionHandles *)v12);
      if (!*((_BYTE *)this + 96))
        *((_BYTE *)this + 96) = 1;
      *((_QWORD *)this + 13) = v10;
      re::MeshCollectionHandles::~MeshCollectionHandles((re::MeshCollectionHandles *)v14);
    }
    *a3 = 1;
  }
  else
  {
    *(_WORD *)a3 = 512;
  }
}

void MemStorage::~MemStorage(MemStorage *this)
{
  *(_QWORD *)this = &off_24ED7DE40;
  MemStorageCore::~MemStorageCore((MemStorage *)((char *)this + 8));
}

{
  *(_QWORD *)this = &off_24ED7DE40;
  MemStorageCore::~MemStorageCore((MemStorage *)((char *)this + 8));
  JUMPOUT(0x2276933B8);
}

void MemStorageCore::~MemStorageCore(MemStorageCore *this)
{
  re::MeshCollectionHandles *v2;

  v2 = (MemStorageCore *)((char *)this + 248);
  re::MeshCollectionHandles::~MeshCollectionHandles((MemStorageCore *)((char *)this + 328));
  re::MeshCollectionHandles::~MeshCollectionHandles(v2);
  re::DynamicArray<re::Entry>::deinit((uint64_t)this + 208);
  RaftState::~RaftState(this);
}

uint64_t std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::Entry *,re::Entry *,re::Entry *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v5 = a2;
  if (a2 == a3)
    return a2;
  v6 = a3;
  do
  {
    re::DynamicArray<re::internal::DeferredUnregister *>::operator=(a4, v5);
    re::DynamicArray<re::internal::DeferredUnregister *>::operator=(a4 + 40, v5 + 40);
    v7 = *(_QWORD *)(v5 + 96);
    *(_OWORD *)(a4 + 80) = *(_OWORD *)(v5 + 80);
    *(_QWORD *)(a4 + 96) = v7;
    a4 += 104;
    v5 += 104;
  }
  while (v5 != v6);
  return v6;
}

uint64_t re::DynamicArray<re::Entry>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  unint64_t v3;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  v3 = a2[1];
  if (v3)
  {
    re::DynamicArray<re::Entry>::setCapacity((__n128 *)a1, v3);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::Entry>::copy((__n128 *)a1, 0, *a2, a2[1]);
  }
  return a1;
}

uint64_t re::types::Ok<re::Snapshot>::Ok(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  __int128 v5;

  v4 = re::DynamicArray<BOOL>::DynamicArray(a1, (uint64_t *)a2);
  re::DynamicArray<char const*>::DynamicArray(v4 + 40, (uint64_t *)(a2 + 40));
  re::DynamicArray<char const*>::DynamicArray(a1 + 80, (uint64_t *)(a2 + 80));
  re::DynamicArray<char const*>::DynamicArray(a1 + 120, (uint64_t *)(a2 + 120));
  re::DynamicArray<char const*>::DynamicArray(a1 + 160, (uint64_t *)(a2 + 160));
  v5 = *(_OWORD *)(a2 + 200);
  *(_QWORD *)(a1 + 216) = *(_QWORD *)(a2 + 216);
  *(_OWORD *)(a1 + 200) = v5;
  return a1;
}

uint64_t re::Result<re::Snapshot,re::StorageError>::Result(uint64_t a1, uint64_t a2)
{
  __int128 v4;

  *(_BYTE *)a1 = 1;
  re::DynamicArray<BOOL>::DynamicArray(a1 + 8, (uint64_t *)a2);
  re::DynamicArray<char const*>::DynamicArray(a1 + 48, (uint64_t *)(a2 + 40));
  re::DynamicArray<char const*>::DynamicArray(a1 + 88, (uint64_t *)(a2 + 80));
  re::DynamicArray<char const*>::DynamicArray(a1 + 128, (uint64_t *)(a2 + 120));
  re::DynamicArray<char const*>::DynamicArray(a1 + 168, (uint64_t *)(a2 + 160));
  v4 = *(_OWORD *)(a2 + 200);
  *(_QWORD *)(a1 + 224) = *(_QWORD *)(a2 + 216);
  *(_OWORD *)(a1 + 208) = v4;
  return a1;
}

uint64_t re::ReadOnly::addRequest(re::ReadOnly *this, uint64_t a2, const re::Message *a3)
{
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  size_t v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  double v20;
  uint64_t result;
  uint64_t v22[4];
  void *__s2;
  char v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  _OWORD v28[24];
  uint64_t v29;
  _BYTE v30[12];
  __int16 v31;
  int v32;
  __int16 v33;
  uint64_t v34;
  __int16 v35;
  _BYTE v36[10];
  uint64_t v37;

  v37 = *MEMORY[0x24BDAC8D0];
  if (!*((_QWORD *)a3 + 2))
  {
    v22[0] = 0;
    memset(v28, 0, 32);
    v26 = 0u;
    v27 = 0u;
    v25 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v30 = 136315906;
    *(_QWORD *)&v30[4] = "operator[]";
    v31 = 1024;
    v32 = 797;
    v33 = 2048;
    v34 = 0;
    v35 = 2048;
    *(_QWORD *)v36 = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  re::DynamicArray<BOOL>::DynamicArray((uint64_t)v30, *((uint64_t **)a3 + 4));
  if (!re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::containsKey((uint64_t)this, (uint64_t)v30))
  {
    re::DynamicArray<BOOL>::DynamicArray((uint64_t)v22, (uint64_t *)v30);
    v26 = 0u;
    v27 = 0u;
    v25 = 0u;
    DWORD1(v27) = 0x7FFFFFFF;
    re::Message::Message((re::Message *)v28, a3);
    v29 = a2;
    v6 = re::Hash<re::DynamicArray<unsigned char>>::operator()((uint64_t)&v24, (uint64_t)v22);
    v7 = v6;
    if (*(_QWORD *)this)
    {
      v8 = v6 % *((unsigned int *)this + 6);
      v9 = *(unsigned int *)(*((_QWORD *)this + 1) + 4 * v8);
      if ((_DWORD)v9 != 0x7FFFFFFF)
      {
        v10 = *((_QWORD *)this + 2);
        v11 = v22[2];
        v12 = __s2;
        do
        {
          if (*(_QWORD *)(v10 + 496 * v9 + 32) == v11)
          {
            v13 = memcmp(*(const void **)(v10 + 496 * v9 + 48), v12, v11);
            if (!(_DWORD)v13)
              goto LABEL_12;
          }
          v9 = *(_DWORD *)(v10 + 496 * v9 + 8) & 0x7FFFFFFF;
        }
        while (v9 != 0x7FFFFFFF);
      }
    }
    else
    {
      LODWORD(v8) = 0;
    }
    v13 = re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::addAsMove((uint64_t)this, v8, v7, v22, (uint64_t *)&v25);
    ++*((_DWORD *)this + 10);
LABEL_12:
    v15 = (uint64_t *)((char *)this + 64);
    v14 = *((_QWORD *)this + 8);
    v16 = v14 + 1;
    v17 = *((_QWORD *)this + 7);
    if (v14 + 1 >= v17)
    {
      if (v17 < v16)
      {
        if (*((_QWORD *)this + 6))
        {
          v18 = 2 * v17;
          if (!v17)
            v18 = 8;
          if (v18 <= v16)
            v19 = v16;
          else
            v19 = v18;
          re::Queue<re::DynamicArray<unsigned char>>::setCapacity((_QWORD *)this + 6, v19);
          v14 = *v15;
        }
        else
        {
          re::Queue<re::DynamicArray<unsigned char>>::setCapacity((_QWORD *)this + 6, v16);
          v14 = 0;
          *v15 = 0;
          *((_QWORD *)this + 9) = 0;
          *((_DWORD *)this + 20) = 0;
        }
      }
      v17 = *((_QWORD *)this + 7);
    }
    re::DynamicArray<BOOL>::DynamicArray(*((_QWORD *)this + 11) + 40 * ((*((_QWORD *)this + 9) + v14) % v17), v22);
    ++*((_QWORD *)this + 8);
    ++*((_DWORD *)this + 20);
    re::Message::~Message((re::Message *)v28);
    v20 = re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v25);
    if (v22[0] && __s2)
      (*(void (**)(double))(*(_QWORD *)v22[0] + 40))(v20);
  }
  result = *(_QWORD *)v30;
  if (*(_QWORD *)v30)
  {
    if (*(_QWORD *)&v36[2])
      return (*(uint64_t (**)(_QWORD))(**(_QWORD **)v30 + 40))(*(_QWORD *)v30);
  }
  return result;
}

BOOL re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::containsKey(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  size_t v8;
  const void *v9;
  char v11;

  v4 = re::Hash<re::DynamicArray<unsigned char>>::operator()((uint64_t)&v11, a2);
  v5 = 0x7FFFFFFFLL;
  if (*(_QWORD *)a1)
  {
    v6 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * (v4 % *(unsigned int *)(a1 + 24)));
    if ((_DWORD)v6 != 0x7FFFFFFF)
    {
      v7 = *(_QWORD *)(a1 + 16);
      v8 = *(_QWORD *)(a2 + 16);
      v5 = 0x7FFFFFFFLL;
      v9 = *(const void **)(a2 + 32);
      while (*(_QWORD *)(v7 + 496 * v6 + 32) != v8 || memcmp(*(const void **)(v7 + 496 * v6 + 48), v9, v8))
      {
        v6 = *(_DWORD *)(v7 + 496 * v6 + 8) & 0x7FFFFFFF;
        if (v6 == 0x7FFFFFFF)
          return v5 != 0x7FFFFFFF;
      }
      v5 = v6;
    }
  }
  return v5 != 0x7FFFFFFF;
}

double re::ReadOnly::recvAck@<D0>(re::ReadOnly *this@<X0>, const re::Message *a2@<X1>, uint64_t a3@<X8>)
{
  char *v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  double result;
  uint64_t v11;
  size_t v12;
  const void *v13;
  uint64_t v14;
  _OWORD v15[2];
  __int128 v16;

  v6 = (char *)a2 + 40;
  if (re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::containsKey((uint64_t)this, (uint64_t)a2 + 40))
  {
    v7 = re::Hash<re::DynamicArray<unsigned char>>::operator()((uint64_t)v15, (uint64_t)v6);
    if (*(_QWORD *)this
      && (v8 = *(unsigned int *)(*((_QWORD *)this + 1) + 4 * (v7 % *((unsigned int *)this + 6))),
          (_DWORD)v8 != 0x7FFFFFFF))
    {
      v11 = *((_QWORD *)this + 2);
      v12 = *((_QWORD *)a2 + 7);
      v9 = 0x7FFFFFFFLL;
      v13 = (const void *)*((_QWORD *)a2 + 9);
      while (*(_QWORD *)(v11 + 496 * v8 + 32) != v12 || memcmp(*(const void **)(v11 + 496 * v8 + 48), v13, v12))
      {
        v8 = *(_DWORD *)(v11 + 496 * v8 + 8) & 0x7FFFFFFF;
        if (v8 == 0x7FFFFFFF)
          goto LABEL_12;
      }
      v9 = v8;
    }
    else
    {
      v9 = 0x7FFFFFFFLL;
    }
LABEL_12:
    v14 = *((_QWORD *)this + 2) + 496 * v9 + 56;
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew(v14, (uint64_t *)a2 + 40);
    v16 = 0u;
    memset(v15, 0, sizeof(v15));
    DWORD1(v16) = 0x7FFFFFFF;
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)v15, (uint64_t *)a2 + 39);
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)a3 = 0u;
    *(_DWORD *)(a3 + 36) = 0x7FFFFFFF;
    re::HashSet<unsigned long long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::unionSet(v14, (uint64_t)v15, a3);
    return re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)v15);
  }
  else
  {
    result = 0.0;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)a3 = 0u;
    *(_DWORD *)(a3 + 36) = 0x7FFFFFFF;
  }
  return result;
}

uint64_t re::ReadOnly::advance@<X0>(re::ReadOnly *this@<X0>, const re::Message *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  size_t v10;
  const void *v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  size_t v25;
  const re::Message *v26;
  uint64_t v27;
  _anonymous_namespace_ *v28;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;
  BOOL v32;
  unint64_t v33;
  unint64_t v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  size_t v41;
  const re::Message *v42;
  int v43;
  int v44;
  double v45;
  uint64_t result;
  unint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50[6];
  _BYTE v51[384];
  uint64_t v52;
  uint64_t v53;
  __int128 v54;
  int v55;
  const re::Message *v56;
  _BYTE v57[9];

  *(_QWORD *)(a3 + 32) = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  *(_QWORD *)a3 = 0;
  *(_DWORD *)(a3 + 24) = 0;
  v5 = *((_QWORD *)this + 8);
  if (v5)
  {
    v6 = 0;
    v7 = *((_QWORD *)this + 9);
    v8 = *((_QWORD *)this + 7);
    v9 = *((_QWORD *)this + 11);
    v10 = *((_QWORD *)a2 + 7);
    v11 = (const void *)*((_QWORD *)a2 + 9);
    while (1)
    {
      v12 = (v7 + v6) % v8;
      if (*(_QWORD *)(v9 + 40 * v12 + 16) == v10 && !memcmp(*(const void **)(v9 + 40 * v12 + 32), v11, v10))
        break;
      if (v5 == ++v6)
      {
        v48 = v5;
        goto LABEL_9;
      }
    }
    v48 = v6;
  }
  else
  {
    v48 = 0;
  }
LABEL_9:
  v13 = 0;
  while (*((_QWORD *)this + 8))
  {
    v14 = *((_QWORD *)this + 11) + 40 * *((_QWORD *)this + 9);
    v53 = *(_QWORD *)v14;
    *(_QWORD *)v14 = 0;
    v54 = *(_OWORD *)(v14 + 8);
    *(_QWORD *)(v14 + 8) = 0;
    *(_QWORD *)(v14 + 16) = 0;
    v56 = *(const re::Message **)(v14 + 32);
    *(_QWORD *)(v14 + 32) = 0;
    ++*(_DWORD *)(v14 + 24);
    v55 = 1;
    v15 = *((_QWORD *)this + 11);
    v16 = *((_QWORD *)this + 9);
    v17 = (_QWORD *)(v15 + 40 * v16);
    if (*v17)
    {
      v18 = v15 + 40 * v16;
      v20 = *(_QWORD *)(v18 + 32);
      v19 = (_QWORD *)(v18 + 32);
      if (v20)
        (*(void (**)(_QWORD))(*(_QWORD *)*v17 + 40))(*v17);
      *v19 = 0;
      v17[1] = 0;
      v17[2] = 0;
      *v17 = 0;
      ++*(_DWORD *)(v15 + 40 * v16 + 24);
      v16 = *((_QWORD *)this + 9);
    }
    if ((unint64_t)(v16 + 1) < *((_QWORD *)this + 7))
      v21 = v16 + 1;
    else
      v21 = 0;
    --*((_QWORD *)this + 8);
    *((_QWORD *)this + 9) = v21;
    ++*((_DWORD *)this + 20);
    v22 = re::Hash<re::DynamicArray<unsigned char>>::operator()((uint64_t)v57, (uint64_t)&v53);
    v49 = v13;
    if (*(_QWORD *)this)
    {
      v23 = *((_QWORD *)this + 2);
      v24 = *(unsigned int *)(*((_QWORD *)this + 1) + 4 * (v22 % *((unsigned int *)this + 6)));
      if ((_DWORD)v24 != 0x7FFFFFFF)
      {
        v25 = *((_QWORD *)&v54 + 1);
        v26 = v56;
        while (*(_QWORD *)(v23 + 496 * v24 + 32) != v25 || memcmp(*(const void **)(v23 + 496 * v24 + 48), v26, v25))
        {
          v24 = *(_DWORD *)(v23 + 496 * v24 + 8) & 0x7FFFFFFF;
          if (v24 == 0x7FFFFFFF)
            goto LABEL_26;
        }
        goto LABEL_27;
      }
    }
    else
    {
      v23 = *((_QWORD *)this + 2);
    }
LABEL_26:
    v24 = 0x7FFFFFFFLL;
LABEL_27:
    v27 = v23 + 496 * v24;
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashSetBase((uint64_t)v50, v27 + 56);
    v28 = re::Message::Message((re::Message *)v51, (const re::Message *)(v27 + 104));
    v52 = *(_QWORD *)(v27 + 488);
    v29 = *(_QWORD *)(a3 + 8);
    v30 = *(_QWORD *)(a3 + 16);
    if (v30 >= v29)
    {
      if (v29 < v30 + 1)
      {
        if (*(_QWORD *)a3)
        {
          v31 = 2 * v29;
          v32 = v29 == 0;
          v33 = 8;
          if (!v32)
            v33 = v31;
          if (v33 <= v30 + 1)
            v34 = v30 + 1;
          else
            v34 = v33;
          re::DynamicArray<re::ReadIndexStatus>::setCapacity((_QWORD *)a3, v34);
        }
        else
        {
          re::DynamicArray<re::ReadIndexStatus>::setCapacity((_QWORD *)a3, v30 + 1);
          ++*(_DWORD *)(a3 + 24);
        }
      }
      v30 = *(_QWORD *)(a3 + 16);
    }
    v35 = *(_QWORD *)(a3 + 32) + 440 * v30;
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashSetBase(v35, (uint64_t)v50);
    re::Message::Message((re::Message *)(v35 + 48), (const re::Message *)v51);
    *(_QWORD *)(v35 + 432) = v52;
    *(_QWORD *)(a3 + 16) = v30 + 1;
    ++*(_DWORD *)(a3 + 24);
    v36 = re::Hash<re::DynamicArray<unsigned char>>::operator()((uint64_t)v57, (uint64_t)&v53);
    if (*(_QWORD *)this)
    {
      v37 = *((_QWORD *)this + 1);
      v47 = v36 % *((unsigned int *)this + 6);
      v38 = *(unsigned int *)(v37 + 4 * v47);
      if ((_DWORD)v38 != 0x7FFFFFFF)
      {
        v39 = *((_QWORD *)this + 2);
        v40 = 0x7FFFFFFFLL;
        v41 = *((_QWORD *)&v54 + 1);
        v42 = v56;
        while (*(_QWORD *)(v39 + 496 * v38 + 32) != v41 || memcmp(*(const void **)(v39 + 496 * v38 + 48), v42, v41))
        {
          v40 = v38;
          v38 = *(_DWORD *)(v39 + 496 * v38 + 8) & 0x7FFFFFFF;
          if (v38 == 0x7FFFFFFF)
            goto LABEL_49;
        }
        v43 = *(_DWORD *)(v39 + 496 * v38 + 8) & 0x7FFFFFFF;
        if (v40 == 0x7FFFFFFF)
          *(_DWORD *)(v37 + 4 * v47) = v43;
        else
          *(_DWORD *)(v39 + 496 * v40 + 8) = *(_DWORD *)(v39 + 496 * v40 + 8) & 0x80000000 | v43;
        re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::EntryWithHash::free(*((_QWORD *)this + 2) + 496 * v38);
        *(_DWORD *)(*((_QWORD *)this + 2) + 496 * v38 + 8) = *(_DWORD *)(*((_QWORD *)this + 2) + 496 * v38 + 8) & 0x80000000 | *((_DWORD *)this + 9);
        --*((_DWORD *)this + 7);
        v44 = *((_DWORD *)this + 10) + 1;
        *((_DWORD *)this + 9) = v38;
        *((_DWORD *)this + 10) = v44;
      }
    }
LABEL_49:
    re::Message::~Message((re::Message *)v51);
    v45 = re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(v50);
    result = v53;
    if (v53)
    {
      a2 = v56;
      if (v56)
        result = (*(uint64_t (**)(double))(*(_QWORD *)v53 + 40))(v45);
    }
    v13 = v49 + 1;
    if (v49 == v48)
      return result;
  }
  re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Queue<T> is empty", "m_size > 0", "dequeue", 569);
  result = _os_crash();
  __break(1u);
  return result;
}

_QWORD *re::ReadOnly::lastPendingRequestCtx@<X0>(_QWORD *this@<X0>, _BYTE *a2@<X8>)
{
  uint64_t v2;
  uint64_t *v3;

  v2 = this[8];
  if (v2)
  {
    v3 = (uint64_t *)(this[11] + 40 * ((unint64_t)(this[9] + v2) % this[7]));
    *a2 = 1;
    return (_QWORD *)re::DynamicArray<BOOL>::DynamicArray((uint64_t)(a2 + 8), v3);
  }
  else
  {
    *a2 = 0;
  }
  return this;
}

unint64_t re::Hash<re::DynamicArray<unsigned char>>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v5[3];

  v5[2] = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a2 + 16);
  if (!v3)
    return 0;
  MurmurHash3_x64_128(*(_QWORD *)(a2 + 32), v3, 0, v5);
  return (v5[1] + (v5[0] << 6) + (v5[0] >> 2) - 0x61C8864680B583E9) ^ v5[0];
}

_QWORD *re::DynamicArray<re::ReadIndexStatus>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::ReadIndexStatus>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x1B8uLL))
        {
          v2 = 440 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 440 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_16;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 440, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = (uint64_t *)v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = &v8[55 * v9];
        v11 = (uint64_t)(v7 + 6);
        do
        {
          *(_DWORD *)(v11 - 16) = 0;
          *(_OWORD *)(v11 - 32) = 0u;
          *(_OWORD *)(v11 - 48) = 0u;
          *(_QWORD *)(v11 - 12) = 0x7FFFFFFFLL;
          re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)(v11 - 48), v8);
          re::Message::Message(v11, (uint64_t)(v8 + 6));
          *(_QWORD *)(v11 + 384) = v8[54];
          re::Message::~Message((re::Message *)(v8 + 6));
          re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(v8);
          v11 += 440;
          v8 += 55;
        }
        while (v8 != v10);
        v8 = (uint64_t *)v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t *))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

double re::Configuration::validate@<D0>(re::Configuration *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  int v12;
  int v13;
  uint64_t v14;
  int *v15;
  int v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  __int128 v22;
  uint64_t v23;
  uint64_t v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;

  v26 = 0u;
  v27 = 0u;
  v25 = 0u;
  DWORD1(v27) = 0x7FFFFFFF;
  re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::clear((uint64_t)&v25);
  v5 = *((unsigned int *)this + 8);
  if ((_DWORD)v5)
  {
    v6 = 0;
    v7 = (int *)(*((_QWORD *)this + 2) + 8);
    while (1)
    {
      v8 = *v7;
      v7 += 6;
      if (v8 < 0)
        break;
      if (v5 == ++v6)
      {
        LODWORD(v6) = *((_DWORD *)this + 8);
        break;
      }
    }
  }
  else
  {
    LODWORD(v6) = 0;
  }
  if ((_DWORD)v5 != (_DWORD)v6)
  {
    v9 = v6;
    v10 = *((_QWORD *)this + 2);
    do
    {
      v4 = re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains((uint64_t)this + 48, (uint64_t *)(v10 + 24 * v9 + 16));
      if ((_DWORD)v4)
        v4 = re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)&v25, (uint64_t *)(*((_QWORD *)this + 2) + 24 * v9 + 16));
      v11 = *((_DWORD *)this + 8);
      v10 = *((_QWORD *)this + 2);
      if (v11 <= (int)v6 + 1)
        v12 = v6 + 1;
      else
        v12 = *((_DWORD *)this + 8);
      while (1)
      {
        v9 = (v6 + 1);
        if (v12 - 1 == (_DWORD)v6)
          break;
        LODWORD(v6) = v6 + 1;
        v13 = v9;
        if ((*(_DWORD *)(v10 + 24 * v9 + 8) & 0x80000000) != 0)
          goto LABEL_18;
      }
      v13 = v12;
LABEL_18:
      LODWORD(v6) = v13;
    }
    while (v11 != v13);
  }
  if (HIDWORD(v26))
  {
    v14 = 0;
    if ((_DWORD)v27)
    {
      v15 = (int *)(v26 + 8);
      while (1)
      {
        v16 = *v15;
        v15 += 6;
        if (v16 < 0)
          break;
        if (v27 == ++v14)
        {
          LODWORD(v14) = v27;
          break;
        }
      }
    }
    re::DynamicString::format((re::DynamicString *)"There can be no overlap of voters and learners: %llu", (re::DynamicString *)&v22, *(_QWORD *)(v26 + 24 * v14 + 16));
    v17 = v22;
    v18 = v23;
    v19 = v24;
    *(_BYTE *)a2 = 0;
    v20 = 6;
  }
  else
  {
    if (*((_DWORD *)this + 7))
    {
      *(_BYTE *)a2 = 1;
      return re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v25);
    }
    v17 = v22;
    v18 = v23;
    v19 = v24;
    *(_BYTE *)a2 = 0;
    v20 = 5;
  }
  *(_QWORD *)(a2 + 8) = v20;
  *(_QWORD *)(a2 + 16) = &re::ConsensusErrorCategory(void)::instance;
  *(_OWORD *)(a2 + 24) = v17;
  *(_QWORD *)(a2 + 40) = v18;
  *(_QWORD *)(a2 + 48) = v19;
  return re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v25);
}

BOOL re::Configuration::hasQuorum(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  int *v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  int v11;
  int v12;
  _BOOL8 v13;
  __int128 v15;
  __int128 v16;
  __int128 v17;

  v16 = 0u;
  v17 = 0u;
  v15 = 0u;
  DWORD1(v17) = 0x7FFFFFFF;
  re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::clear((uint64_t)&v15);
  v4 = *(unsigned int *)(a1 + 32);
  if ((_DWORD)v4)
  {
    v5 = 0;
    v6 = (int *)(*(_QWORD *)(a1 + 16) + 8);
    while (1)
    {
      v7 = *v6;
      v6 += 6;
      if (v7 < 0)
        break;
      if (v4 == ++v5)
      {
        LODWORD(v5) = *(_DWORD *)(a1 + 32);
        break;
      }
    }
  }
  else
  {
    LODWORD(v5) = 0;
  }
  if ((_DWORD)v4 != (_DWORD)v5)
  {
    v8 = v5;
    v9 = *(_QWORD *)(a1 + 16);
    do
    {
      if (re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains(a2, (uint64_t *)(v9 + 24 * v8 + 16)))
      {
        re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)&v15, (uint64_t *)(*(_QWORD *)(a1 + 16) + 24 * v8 + 16));
      }
      v10 = *(_DWORD *)(a1 + 32);
      v9 = *(_QWORD *)(a1 + 16);
      if (v10 <= (int)v5 + 1)
        v11 = v5 + 1;
      else
        v11 = *(_DWORD *)(a1 + 32);
      while (1)
      {
        v8 = (v5 + 1);
        if (v11 - 1 == (_DWORD)v5)
          break;
        LODWORD(v5) = v5 + 1;
        v12 = v8;
        if ((*(_DWORD *)(v9 + 24 * v8 + 8) & 0x80000000) != 0)
          goto LABEL_18;
      }
      v12 = v11;
LABEL_18:
      LODWORD(v5) = v12;
    }
    while (v10 != v12);
  }
  v13 = HIDWORD(v16) > *(_DWORD *)(a1 + 28) >> 1;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v15);
  return v13;
}

void re::ProgressSet::voterIds(re::ProgressSet *this@<X0>, uint64_t a2@<X8>)
{
  if (*((_BYTE *)this + 88))
  {
    *(_OWORD *)(a2 + 16) = 0u;
    *(_OWORD *)(a2 + 32) = 0u;
    *(_OWORD *)a2 = 0u;
    *(_DWORD *)(a2 + 36) = 0x7FFFFFFF;
    re::HashSet<unsigned long long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::unionSet((uint64_t)this + 192, (uint64_t)this + 96, a2);
  }
  else
  {
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashSetBase(a2, (uint64_t)this + 192);
  }
}

void re::ProgressSet::learnerIds(re::ProgressSet *this@<X0>, uint64_t a2@<X8>)
{
  if (*((_BYTE *)this + 88))
  {
    *(_OWORD *)(a2 + 16) = 0u;
    *(_OWORD *)(a2 + 32) = 0u;
    *(_OWORD *)a2 = 0u;
    *(_DWORD *)(a2 + 36) = 0x7FFFFFFF;
    re::HashSet<unsigned long long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::unionSet((uint64_t)this + 240, (uint64_t)this + 144, a2);
  }
  else
  {
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashSetBase(a2, (uint64_t)this + 240);
  }
}

double re::ProgressSet::assertProgressAndConfigurationConsistent(re::ProgressSet *this)
{
  uint64_t v2;
  int *v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  int *v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  uint64_t v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;

  v17 = 0u;
  v18 = 0u;
  v16 = 0u;
  DWORD1(v18) = 0x7FFFFFFF;
  re::HashSet<unsigned long long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::unionSet((uint64_t)this + 192, (uint64_t)this + 240, (uint64_t)&v16);
  if ((_DWORD)v18)
  {
    v2 = 0;
    v3 = (int *)(v17 + 8);
    while (1)
    {
      v4 = *v3;
      v3 += 6;
      if (v4 < 0)
        break;
      if (v18 == ++v2)
      {
        LODWORD(v2) = v18;
        break;
      }
    }
  }
  else
  {
    LODWORD(v2) = 0;
  }
  while ((_DWORD)v18 != (_DWORD)v2)
  {
    if (v18 <= (int)v2 + 1)
      v5 = v2 + 1;
    else
      v5 = v18;
    while (v5 - 1 != (_DWORD)v2)
    {
      LODWORD(v2) = v2 + 1;
      if ((*(_DWORD *)(v17 + 24 * v2 + 8) & 0x80000000) != 0)
        goto LABEL_15;
    }
    LODWORD(v2) = v5;
LABEL_15:
    ;
  }
  v6 = *((unsigned int *)this + 8);
  if ((_DWORD)v6)
  {
    v7 = 0;
    v8 = (int *)(*((_QWORD *)this + 2) + 8);
    while (1)
    {
      v9 = *v8;
      v8 += 34;
      if (v9 < 0)
        break;
      if (v6 == ++v7)
      {
        LODWORD(v7) = *((_DWORD *)this + 8);
        break;
      }
    }
  }
  else
  {
    LODWORD(v7) = 0;
  }
  if ((_DWORD)v6 != (_DWORD)v7)
  {
    v10 = v7;
    do
    {
      v11 = *((_QWORD *)this + 2);
      v15 = 0;
      v15 = *(_QWORD *)(v11 + 136 * v10 + 16);
      if (*((_BYTE *)this + 88)
        && !re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains((uint64_t)this + 144, &v15))
      {
        re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains((uint64_t)this + 96, &v15);
      }
      if (*((_DWORD *)this + 8) <= (v7 + 1))
        v12 = v7 + 1;
      else
        v12 = *((_DWORD *)this + 8);
      while (1)
      {
        v10 = (v7 + 1);
        if (v12 - 1 == (_DWORD)v7)
          break;
        LODWORD(v7) = v7 + 1;
        v13 = v10;
        if ((*(_DWORD *)(*((_QWORD *)this + 2) + 136 * v10 + 8) & 0x80000000) != 0)
          goto LABEL_34;
      }
      v13 = v12;
LABEL_34:
      LODWORD(v7) = v13;
    }
    while ((_DWORD)v6 != v13);
  }
  return re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v16);
}

uint64_t re::HashTable<unsigned long long,std::shared_ptr<re::Progress>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew(uint64_t result, uint64_t *a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v5 = result;
  v6 = *a2;
  v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (*(_QWORD *)result)
  {
    v9 = v8 % *(unsigned int *)(result + 24);
    v10 = *(unsigned int *)(*(_QWORD *)(result + 8) + 4 * v9);
    if ((_DWORD)v10 != 0x7FFFFFFF)
    {
      v11 = *(_QWORD *)(result + 16);
      if (*(_QWORD *)(v11 + 40 * v10 + 16) == v6)
        return result;
      while (1)
      {
        LODWORD(v10) = *(_DWORD *)(v11 + 40 * v10 + 8) & 0x7FFFFFFF;
        if ((_DWORD)v10 == 0x7FFFFFFF)
          break;
        if (*(_QWORD *)(v11 + 40 * v10 + 16) == v6)
          return result;
      }
    }
  }
  else
  {
    LODWORD(v9) = 0;
  }
  result = re::HashTable<unsigned long long,std::shared_ptr<re::Progress>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(result, v9, v8, a2, a3);
  ++*(_DWORD *)(v5 + 40);
  return result;
}

uint64_t re::ProgressSet::restoreSnapshotMeta@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t v25;
  double v26;
  uint64_t result;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _OWORD v31[2];
  __int128 v32;
  uint64_t v33[4];
  __int128 v34;
  _QWORD v35[3];
  int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  char v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  __int16 v46;

  *(_OWORD *)(a4 + 272) = 0u;
  *(_OWORD *)(a4 + 288) = 0u;
  *(_OWORD *)(a4 + 256) = 0u;
  *(_OWORD *)(a4 + 208) = 0u;
  *(_OWORD *)(a4 + 224) = 0u;
  *(_OWORD *)(a4 + 160) = 0u;
  *(_OWORD *)(a4 + 176) = 0u;
  *(_OWORD *)(a4 + 128) = 0u;
  *(_OWORD *)(a4 + 144) = 0u;
  *(_OWORD *)(a4 + 96) = 0u;
  *(_OWORD *)(a4 + 112) = 0u;
  *(_OWORD *)(a4 + 64) = 0u;
  *(_OWORD *)(a4 + 80) = 0u;
  *(_OWORD *)(a4 + 32) = 0u;
  *(_OWORD *)(a4 + 48) = 0u;
  *(_OWORD *)a4 = 0u;
  *(_OWORD *)(a4 + 16) = 0u;
  *(_OWORD *)(a4 + 240) = 0u;
  v8 = a4 + 240;
  *(_OWORD *)(a4 + 192) = 0u;
  v9 = a4 + 192;
  *(_DWORD *)(a4 + 36) = 0x7FFFFFFF;
  *(_QWORD *)(a4 + 80) = 0;
  *(_QWORD *)(a4 + 56) = 0;
  *(_QWORD *)(a4 + 64) = 0;
  *(_QWORD *)(a4 + 48) = 0;
  *(_DWORD *)(a4 + 72) = 0;
  *(_OWORD *)(a4 + 192) = 0u;
  *(_OWORD *)(a4 + 208) = 0u;
  *(_OWORD *)(a4 + 224) = 0u;
  *(_DWORD *)(a4 + 228) = 0x7FFFFFFF;
  *(_OWORD *)(a4 + 240) = 0u;
  *(_OWORD *)(a4 + 256) = 0u;
  *(_OWORD *)(a4 + 272) = 0u;
  *(_DWORD *)(a4 + 276) = 0x7FFFFFFF;
  re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a4 + 192, 0);
  re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(v8, 0);
  *(_QWORD *)(a4 + 288) = 0;
  *(_QWORD *)(a4 + 296) = 0;
  memset(v35, 0, sizeof(v35));
  v36 = 0;
  v37 = 0;
  v38 = 0;
  v39 = 0;
  v40 = a3;
  re::DynamicArray<float *>::setCapacity(v35, a3);
  v41 = 0;
  v42 = 0;
  v43 = a2;
  v44 = 0;
  v45 = 0;
  v46 = 0;
  v10 = a1[2];
  if (v10)
  {
    v11 = (uint64_t *)a1[4];
    v12 = 8 * v10;
    do
    {
      v13 = *v11++;
      v28 = v13;
      re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew<re::Progress&>(a4, &v28, (re::Progress *)v35);
      re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew(v9, &v28);
      v12 -= 8;
    }
    while (v12);
  }
  v14 = a1[7];
  if (v14)
  {
    v15 = (uint64_t *)a1[9];
    v16 = 8 * v14;
    do
    {
      v17 = *v15++;
      v28 = v17;
      re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew<re::Progress&>(a4, &v28, (re::Progress *)v35);
      re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew(v8, &v28);
      v16 -= 8;
    }
    while (v16);
  }
  if (a1[20])
  {
    memset(v31, 0, sizeof(v31));
    v32 = 0u;
    memset(v33, 0, sizeof(v33));
    v34 = 0u;
    DWORD1(v32) = 0x7FFFFFFF;
    DWORD1(v34) = 0x7FFFFFFF;
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity((uint64_t)v31, 0);
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity((uint64_t)v33, 0);
    v18 = a1[12];
    if (v18)
    {
      v19 = (uint64_t *)a1[14];
      v20 = 8 * v18;
      do
      {
        v21 = *v19++;
        v28 = v21;
        re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addInternal<re::Progress&>(a4, &v28, (re::Progress *)v35);
        re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)v31, &v28);
        v20 -= 8;
      }
      while (v20);
    }
    v22 = a1[17];
    if (v22)
    {
      v23 = (uint64_t *)a1[19];
      v24 = 8 * v22;
      do
      {
        v25 = *v23++;
        v28 = v25;
        re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addInternal<re::Progress&>(a4, &v28, (re::Progress *)v35);
        re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)v33, &v28);
        v24 -= 8;
      }
      while (v24);
    }
    LOBYTE(v28) = 1;
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashSetBase((uint64_t)&v29, (uint64_t)v31);
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashSetBase((uint64_t)&v30, (uint64_t)v33);
    re::Optional<re::Configuration>::operator=((unsigned __int8 *)(a4 + 88), &v28);
    re::Optional<re::Configuration>::~Optional((uint64_t)&v28);
    re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(v33);
    re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)v31);
  }
  v26 = re::ProgressSet::assertProgressAndConfigurationConsistent((re::ProgressSet *)a4);
  result = v35[0];
  if (v35[0])
  {
    if (v37)
      return (*(uint64_t (**)(double))(*(_QWORD *)v35[0] + 40))(v26);
  }
  return result;
}

uint64_t re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew<re::Progress&>(uint64_t result, uint64_t *a2, re::Progress *a3)
{
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v5 = result;
  v6 = *a2;
  v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (*(_QWORD *)result)
  {
    v9 = v8 % *(unsigned int *)(result + 24);
    v10 = *(unsigned int *)(*(_QWORD *)(result + 8) + 4 * v9);
    if ((_DWORD)v10 != 0x7FFFFFFF)
    {
      v11 = *(_QWORD *)(result + 16);
      if (*(_QWORD *)(v11 + 136 * v10 + 16) == v6)
        return result;
      while (1)
      {
        LODWORD(v10) = *(_DWORD *)(v11 + 136 * v10 + 8) & 0x7FFFFFFF;
        if ((_DWORD)v10 == 0x7FFFFFFF)
          break;
        if (*(_QWORD *)(v11 + 136 * v10 + 16) == v6)
          return result;
      }
    }
  }
  else
  {
    LODWORD(v9) = 0;
  }
  result = re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsCopy(result, v9, v8, a2, a3);
  ++*(_DWORD *)(v5 + 40);
  return result;
}

double re::ProgressSet::insertVoter@<D0>(re::ProgressSet *this@<X0>, const re::Progress *a2@<X2>, uint64_t a3@<X1>, uint64_t a4@<X8>)
{
  __int128 v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  __int128 v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21[6];
  uint64_t v22;

  v22 = a3;
  re::ProgressSet::learnerIds(this, (uint64_t)v21);
  if (!re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains((uint64_t)v21, &v22))
  {
    re::ProgressSet::voterIds(this, (uint64_t)&v18);
    if (re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains((uint64_t)&v18, &v22))
    {
      re::DynamicString::format((re::DynamicString *)"voters", (re::DynamicString *)&v15);
      v10 = v15;
      v11 = v16;
      v12 = v17;
      *(_BYTE *)a4 = 0;
      v13 = 6;
    }
    else
    {
      if (!*((_BYTE *)this + 88))
      {
        re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)this + 192, &v22);
        re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addOrReplace((uint64_t)this, &v22, a2);
        re::ProgressSet::assertProgressAndConfigurationConsistent(this);
        *(_BYTE *)a4 = 1;
        goto LABEL_9;
      }
      re::DynamicString::format((re::DynamicString *)"There is a pending membership change", (re::DynamicString *)&v15);
      v10 = v15;
      v11 = v16;
      v12 = v17;
      *(_BYTE *)a4 = 0;
      v13 = 10;
    }
    *(_QWORD *)(a4 + 8) = v13;
    *(_QWORD *)(a4 + 16) = &re::ConsensusErrorCategory(void)::instance;
    *(_OWORD *)(a4 + 24) = v10;
    *(_QWORD *)(a4 + 40) = v11;
    *(_QWORD *)(a4 + 48) = v12;
LABEL_9:
    re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v18);
    return re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(v21);
  }
  re::DynamicString::format((re::DynamicString *)"learners", (re::DynamicString *)&v18);
  v7 = v18;
  v8 = v19;
  v9 = v20;
  *(_BYTE *)a4 = 0;
  *(_QWORD *)(a4 + 8) = 6;
  *(_QWORD *)(a4 + 16) = &re::ConsensusErrorCategory(void)::instance;
  *(_OWORD *)(a4 + 24) = v7;
  *(_QWORD *)(a4 + 40) = v8;
  *(_QWORD *)(a4 + 48) = v9;
  return re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(v21);
}

uint64_t re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addOrReplace(uint64_t a1, uint64_t *a2, re::Progress *a3)
{
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t result;
  __int128 v14;
  __int128 v15;
  __int128 v16;

  v6 = *a2;
  v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (!*(_QWORD *)a1)
  {
    LODWORD(v9) = 0;
    goto LABEL_8;
  }
  v9 = v8 % *(unsigned int *)(a1 + 24);
  v10 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v9);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
LABEL_8:
    result = re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsCopy(a1, v9, v8, a2, a3);
    goto LABEL_9;
  }
  v11 = *(_QWORD *)(a1 + 16);
  while (*(_QWORD *)(v11 + 136 * v10 + 16) != v6)
  {
    LODWORD(v10) = *(_DWORD *)(v11 + 136 * v10 + 8) & 0x7FFFFFFF;
    if ((_DWORD)v10 == 0x7FFFFFFF)
      goto LABEL_8;
  }
  v12 = v11 + 136 * v10;
  result = re::DynamicArray<unsigned long long>::operator=(v12 + 24, (uint64_t *)a3);
  v14 = *(_OWORD *)((char *)a3 + 40);
  *(_QWORD *)(v12 + 80) = *((_QWORD *)a3 + 7);
  *(_OWORD *)(v12 + 64) = v14;
  v15 = *(_OWORD *)((char *)a3 + 90);
  v16 = *((_OWORD *)a3 + 5);
  *(_OWORD *)(v12 + 88) = *((_OWORD *)a3 + 4);
  *(_OWORD *)(v12 + 104) = v16;
  *(_OWORD *)(v12 + 114) = v15;
LABEL_9:
  ++*(_DWORD *)(a1 + 40);
  return result;
}

double re::ProgressSet::insertLearner@<D0>(re::ProgressSet *this@<X0>, const re::Progress *a2@<X2>, uint64_t a3@<X1>, uint64_t a4@<X8>)
{
  __int128 v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  __int128 v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21[6];
  uint64_t v22;

  v22 = a3;
  re::ProgressSet::learnerIds(this, (uint64_t)v21);
  if (!re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains((uint64_t)v21, &v22))
  {
    re::ProgressSet::voterIds(this, (uint64_t)&v18);
    if (re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains((uint64_t)&v18, &v22))
    {
      re::DynamicString::format((re::DynamicString *)"voters", (re::DynamicString *)&v15);
      v10 = v15;
      v11 = v16;
      v12 = v17;
      *(_BYTE *)a4 = 0;
      v13 = 6;
    }
    else
    {
      if (!*((_BYTE *)this + 88))
      {
        re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)this + 240, &v22);
        re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addOrReplace((uint64_t)this, &v22, a2);
        re::ProgressSet::assertProgressAndConfigurationConsistent(this);
        *(_BYTE *)a4 = 1;
        goto LABEL_9;
      }
      re::DynamicString::format((re::DynamicString *)"There is a pending membership change", (re::DynamicString *)&v15);
      v10 = v15;
      v11 = v16;
      v12 = v17;
      *(_BYTE *)a4 = 0;
      v13 = 10;
    }
    *(_QWORD *)(a4 + 8) = v13;
    *(_QWORD *)(a4 + 16) = &re::ConsensusErrorCategory(void)::instance;
    *(_OWORD *)(a4 + 24) = v10;
    *(_QWORD *)(a4 + 40) = v11;
    *(_QWORD *)(a4 + 48) = v12;
LABEL_9:
    re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v18);
    return re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(v21);
  }
  re::DynamicString::format((re::DynamicString *)"learners", (re::DynamicString *)&v18);
  v7 = v18;
  v8 = v19;
  v9 = v20;
  *(_BYTE *)a4 = 0;
  *(_QWORD *)(a4 + 8) = 6;
  *(_QWORD *)(a4 + 16) = &re::ConsensusErrorCategory(void)::instance;
  *(_OWORD *)(a4 + 24) = v7;
  *(_QWORD *)(a4 + 40) = v8;
  *(_QWORD *)(a4 + 48) = v9;
  return re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(v21);
}

void re::ProgressSet::remove(re::ProgressSet *this@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  __int128 v4;
  __int128 v5;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const re::Progress *v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  __int128 v19;
  uint64_t v20;
  __int128 v21;
  _OWORD v22[2];
  unint64_t v23;

  v23 = a2;
  if (*((_BYTE *)this + 88))
  {
    re::DynamicString::format((re::DynamicString *)"There is a pending membership change", (re::DynamicString *)&v16);
    v4 = v16;
    v5 = v17;
    *(_BYTE *)a3 = 0;
    *(_QWORD *)(a3 + 8) = 10;
    *(_QWORD *)(a3 + 16) = &re::ConsensusErrorCategory(void)::instance;
    *(_OWORD *)(a3 + 24) = v4;
    *(_OWORD *)(a3 + 40) = v5;
  }
  else
  {
    v7 = (char *)this + 192;
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove((uint64_t)this + 240, (uint64_t *)&v23);
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove((uint64_t)v7, (uint64_t *)&v23);
    LODWORD(v8) = 0x7FFFFFFF;
    if (*(_QWORD *)this)
    {
      v9 = 0x94D049BB133111EBLL
         * ((0xBF58476D1CE4E5B9 * (v23 ^ (v23 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v23 ^ (v23 >> 30))) >> 27));
      v10 = *(unsigned int *)(*((_QWORD *)this + 1) + 4 * ((v9 ^ (v9 >> 31)) % *((unsigned int *)this + 6)));
      if ((_DWORD)v10 != 0x7FFFFFFF)
      {
        v11 = *((_QWORD *)this + 2);
        LODWORD(v8) = v10;
        if (*(_QWORD *)(v11 + 136 * v10 + 16) != v23)
        {
          v8 = v10;
          while (1)
          {
            LODWORD(v8) = *(_DWORD *)(v11 + 136 * v8 + 8) & 0x7FFFFFFF;
            if ((_DWORD)v8 == 0x7FFFFFFF)
              break;
            if (*(_QWORD *)(v11 + 136 * v8 + 16) == v23)
              goto LABEL_11;
          }
          LODWORD(v8) = 0x7FFFFFFF;
        }
      }
    }
LABEL_11:
    v12 = (const re::Progress *)(*((_QWORD *)this + 2) + 136 * v8 + 24);
    re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove((uint64_t)this, v23);
    re::ProgressSet::assertProgressAndConfigurationConsistent(this);
    re::Progress::Progress((re::Progress *)((char *)&v16 + 8), v12);
    v13 = *((_QWORD *)&v16 + 1);
    v14 = v18;
    *(_OWORD *)(a3 + 56) = v19;
    *(_QWORD *)(a3 + 72) = v20;
    v15 = v22[0];
    *(_OWORD *)(a3 + 80) = v21;
    *(_OWORD *)(a3 + 96) = v15;
    *(_OWORD *)(a3 + 106) = *(_OWORD *)((char *)v22 + 10);
    *(_QWORD *)(a3 + 16) = v13;
    *(_OWORD *)(a3 + 24) = v17;
    *(_QWORD *)(a3 + 48) = v14;
    *(_DWORD *)(a3 + 40) = 1;
    *(_BYTE *)a3 = 1;
    *(_BYTE *)(a3 + 8) = 1;
  }
}

uint64_t re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove(uint64_t result, unint64_t a2)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  int v9;
  int v10;

  if (*(_QWORD *)result)
  {
    v2 = result;
    v3 = 0x94D049BB133111EBLL
       * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
    v4 = (v3 ^ (v3 >> 31)) % *(unsigned int *)(result + 24);
    v5 = *(_QWORD *)(result + 8);
    v6 = *(unsigned int *)(v5 + 4 * v4);
    if ((_DWORD)v6 != 0x7FFFFFFF)
    {
      v7 = *(_QWORD *)(result + 16);
      if (*(_QWORD *)(v7 + 136 * v6 + 16) == a2)
      {
        *(_DWORD *)(v5 + 4 * v4) = *(_DWORD *)(v7 + 136 * v6 + 8) & 0x7FFFFFFF;
LABEL_8:
        result = re::HashTable<re::ecs2::Scene *,re::DynamicArray<RESubscriptionHandle>,re::Hash<re::ecs2::Scene *>,re::EqualTo<re::ecs2::Scene *>,true,false>::EntryWithHash::free(*(_QWORD *)(result + 16) + 136 * v6);
        v10 = *(_DWORD *)(v2 + 40);
        *(_DWORD *)(*(_QWORD *)(v2 + 16) + 136 * v6 + 8) = *(_DWORD *)(*(_QWORD *)(v2 + 16) + 136 * v6 + 8) & 0x80000000 | *(_DWORD *)(v2 + 36);
        --*(_DWORD *)(v2 + 28);
        *(_DWORD *)(v2 + 36) = v6;
        *(_DWORD *)(v2 + 40) = v10 + 1;
      }
      else
      {
        while (1)
        {
          v8 = v6;
          v9 = *(_DWORD *)(v7 + 136 * v6 + 8);
          v6 = v9 & 0x7FFFFFFF;
          if ((v9 & 0x7FFFFFFF) == 0x7FFFFFFF)
            break;
          if (*(_QWORD *)(v7 + 136 * v6 + 16) == a2)
          {
            *(_DWORD *)(v7 + 136 * v8 + 8) = *(_DWORD *)(v7 + 136 * v8 + 8) & 0x80000000 | *(_DWORD *)(v7 + 136 * v6 + 8) & 0x7FFFFFFF;
            goto LABEL_8;
          }
        }
      }
    }
  }
  return result;
}

void re::ProgressSet::promoteLearner(re::ProgressSet *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  __int128 v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v13 = a2;
  if (*((_BYTE *)this + 88))
  {
    re::DynamicString::format((re::DynamicString *)"There is a pending membership change", (re::DynamicString *)&v10);
    v4 = v10;
    v5 = v11;
    v6 = v12;
    *(_BYTE *)a3 = 0;
    v7 = 10;
  }
  else
  {
    v9 = (char *)this + 240;
    if (re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains((uint64_t)this + 240, &v13))
    {
      re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove((uint64_t)v9, &v13);
      if (!re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains((uint64_t)this + 192, &v13))
      {
        re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)this + 192, &v13);
        re::ProgressSet::assertProgressAndConfigurationConsistent(this);
        *(_BYTE *)a3 = 1;
        return;
      }
      re::DynamicString::format((re::DynamicString *)"Already exists as voter, caller should know this was noop.", (re::DynamicString *)&v10);
      v4 = v10;
      v5 = v11;
      v6 = v12;
      *(_BYTE *)a3 = 0;
      v7 = 6;
    }
    else
    {
      re::DynamicString::format((re::DynamicString *)"Can't promote a learner which doesn't exist", (re::DynamicString *)&v10);
      v4 = v10;
      v5 = v11;
      v6 = v12;
      *(_BYTE *)a3 = 0;
      v7 = 7;
    }
  }
  *(_QWORD *)(a3 + 8) = v7;
  *(_QWORD *)(a3 + 16) = &re::ConsensusErrorCategory(void)::instance;
  *(_OWORD *)(a3 + 24) = v4;
  *(_QWORD *)(a3 + 40) = v5;
  *(_QWORD *)(a3 + 48) = v6;
}

unint64_t re::ProgressSet::maximalCommittedIndex(re::ProgressSet *this)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  int *v5;
  int v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int *v24;
  int v25;
  unint64_t v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  int v35;
  unint64_t v36;
  uint64_t v37;
  unint64_t v38;
  unint64_t v39;

  v2 = (_QWORD *)((char *)this + 48);
  *((_QWORD *)this + 8) = 0;
  ++*((_DWORD *)this + 18);
  v3 = *((unsigned int *)this + 56);
  if ((_DWORD)v3)
  {
    v4 = 0;
    v5 = (int *)(*((_QWORD *)this + 26) + 8);
    while (1)
    {
      v6 = *v5;
      v5 += 6;
      if (v6 < 0)
        break;
      if (v3 == ++v4)
      {
        LODWORD(v4) = *((_DWORD *)this + 56);
        break;
      }
    }
  }
  else
  {
    LODWORD(v4) = 0;
  }
  if ((_DWORD)v3 == (_DWORD)v4)
  {
    v7 = 0;
    goto LABEL_26;
  }
  v8 = v4;
  do
  {
    if (!*(_QWORD *)this)
    {
      v12 = *((_QWORD *)this + 2);
LABEL_16:
      LODWORD(v13) = 0x7FFFFFFF;
      goto LABEL_17;
    }
    v9 = *(_QWORD *)(*((_QWORD *)this + 26) + 24 * v8 + 16);
    v10 = 0x94D049BB133111EBLL
        * ((0xBF58476D1CE4E5B9 * (v9 ^ (v9 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v9 ^ (v9 >> 30))) >> 27));
    v11 = (v10 ^ (v10 >> 31)) % *((unsigned int *)this + 6);
    v12 = *((_QWORD *)this + 2);
    v13 = *(unsigned int *)(*((_QWORD *)this + 1) + 4 * v11);
    if ((_DWORD)v13 == 0x7FFFFFFF)
      goto LABEL_16;
    while (*(_QWORD *)(v12 + 136 * v13 + 16) != v9)
    {
      v13 = *(_DWORD *)(v12 + 136 * v13 + 8) & 0x7FFFFFFF;
      if (v13 == 0x7FFFFFFF)
        goto LABEL_16;
    }
LABEL_17:
    re::DynamicArray<re::TransitionCondition *>::add(v2, (_QWORD *)(v12 + 136 * v13 + 96));
    if (*((_DWORD *)this + 56) <= (v4 + 1))
      v14 = v4 + 1;
    else
      v14 = *((_DWORD *)this + 56);
    while (1)
    {
      v8 = (v4 + 1);
      if (v14 - 1 == (_DWORD)v4)
        break;
      LODWORD(v4) = v4 + 1;
      v15 = v8;
      if ((*(_DWORD *)(*((_QWORD *)this + 26) + 24 * v8 + 8) & 0x80000000) != 0)
        goto LABEL_24;
    }
    v15 = v14;
LABEL_24:
    LODWORD(v4) = v15;
  }
  while ((_DWORD)v3 != v15);
  v7 = *((_QWORD *)this + 8);
LABEL_26:
  v16 = 126 - 2 * __clz(v7);
  if (v7)
    v17 = v16;
  else
    v17 = 0;
  std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::reverse_iterator<unsigned long long *>,false>(*((_QWORD *)this + 10) + 8 * v7, (char *)(*((_QWORD *)this + 10) + 8 * v7), *((_QWORD *)this + 10), *((unint64_t **)this + 10), v17, 1);
  v18 = *((_QWORD *)this + 8);
  v19 = v18 >> 1;
  if (v18 <= v18 >> 1)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_65;
  }
  v20 = (unint64_t *)*((_QWORD *)this + 10);
  v21 = v20[v19];
  if (!*((_BYTE *)this + 88))
    return v20[v19];
  *((_QWORD *)this + 8) = 0;
  ++*((_DWORD *)this + 18);
  v22 = *((unsigned int *)this + 32);
  if ((_DWORD)v22)
  {
    v23 = 0;
    v24 = (int *)(*((_QWORD *)this + 14) + 8);
    while (1)
    {
      v25 = *v24;
      v24 += 6;
      if (v25 < 0)
        break;
      if (v22 == ++v23)
      {
        LODWORD(v23) = *((_DWORD *)this + 32);
        break;
      }
    }
  }
  else
  {
    LODWORD(v23) = 0;
  }
  if ((_DWORD)v22 == (_DWORD)v23)
  {
    v27 = 0;
    goto LABEL_57;
  }
  v28 = v23;
  while (2)
  {
    if (!*(_QWORD *)this)
    {
      v32 = *((_QWORD *)this + 2);
      goto LABEL_47;
    }
    v29 = *(_QWORD *)(*((_QWORD *)this + 14) + 24 * v28 + 16);
    v30 = 0x94D049BB133111EBLL
        * ((0xBF58476D1CE4E5B9 * (v29 ^ (v29 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v29 ^ (v29 >> 30))) >> 27));
    v31 = (v30 ^ (v30 >> 31)) % *((unsigned int *)this + 6);
    v32 = *((_QWORD *)this + 2);
    v33 = *(unsigned int *)(*((_QWORD *)this + 1) + 4 * v31);
    if ((_DWORD)v33 == 0x7FFFFFFF)
    {
LABEL_47:
      LODWORD(v33) = 0x7FFFFFFF;
      goto LABEL_48;
    }
    while (*(_QWORD *)(v32 + 136 * v33 + 16) != v29)
    {
      v33 = *(_DWORD *)(v32 + 136 * v33 + 8) & 0x7FFFFFFF;
      if (v33 == 0x7FFFFFFF)
        goto LABEL_47;
    }
LABEL_48:
    re::DynamicArray<re::TransitionCondition *>::add(v2, (_QWORD *)(v32 + 136 * v33 + 96));
    if (*((_DWORD *)this + 32) <= (v23 + 1))
      v34 = v23 + 1;
    else
      v34 = *((_DWORD *)this + 32);
    while (1)
    {
      v28 = (v23 + 1);
      if (v34 - 1 == (_DWORD)v23)
        break;
      LODWORD(v23) = v23 + 1;
      v35 = v28;
      if ((*(_DWORD *)(*((_QWORD *)this + 14) + 24 * v28 + 8) & 0x80000000) != 0)
        goto LABEL_55;
    }
    v35 = v34;
LABEL_55:
    LODWORD(v23) = v35;
    if ((_DWORD)v22 != v35)
      continue;
    break;
  }
  v20 = (unint64_t *)*((_QWORD *)this + 10);
  v27 = *((_QWORD *)this + 8);
LABEL_57:
  v36 = 126 - 2 * __clz(v27);
  if (v27)
    v37 = v36;
  else
    v37 = 0;
  std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::reverse_iterator<unsigned long long *>,false>((uint64_t)&v20[v27], (char *)&v20[v27], (uint64_t)v20, v20, v37, 1);
  v38 = *((_QWORD *)this + 8);
  v39 = v38 >> 1;
  if (v38 <= v38 >> 1)
  {
LABEL_65:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(_QWORD *)(*((_QWORD *)this + 10) + 8 * v39) >= v21)
    return v21;
  else
    return *(_QWORD *)(*((_QWORD *)this + 10) + 8 * v39);
}

uint64_t re::ProgressSet::candidacyStatus(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  int *v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _OWORD *v11;
  int v12;
  int v13;
  uint64_t v14;
  BOOL v15;
  uint64_t v16;
  uint64_t v18[6];
  uint64_t v19[6];
  _OWORD v20[2];
  __int128 v21;
  _OWORD v22[2];
  __int128 v23;

  v23 = 0u;
  memset(v22, 0, sizeof(v22));
  DWORD1(v23) = 0x7FFFFFFF;
  v21 = 0u;
  memset(v20, 0, sizeof(v20));
  DWORD1(v21) = 0x7FFFFFFF;
  v4 = *(unsigned int *)(a2 + 32);
  if ((_DWORD)v4)
  {
    v5 = 0;
    v6 = (int *)(*(_QWORD *)(a2 + 16) + 8);
    while (1)
    {
      v7 = *v6;
      v6 += 8;
      if (v7 < 0)
        break;
      if (v4 == ++v5)
      {
        LODWORD(v5) = *(_DWORD *)(a2 + 32);
        break;
      }
    }
  }
  else
  {
    LODWORD(v5) = 0;
  }
  if ((_DWORD)v4 != (_DWORD)v5)
  {
    v8 = v5;
    v9 = *(_QWORD *)(a2 + 16);
    do
    {
      v10 = v9 + 32 * v8;
      if (*(_BYTE *)(v10 + 24))
        v11 = v22;
      else
        v11 = v20;
      re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)v11, (uint64_t *)(v10 + 16));
      v9 = *(_QWORD *)(a2 + 16);
      if (*(_DWORD *)(a2 + 32) <= (v5 + 1))
        v12 = v5 + 1;
      else
        v12 = *(_DWORD *)(a2 + 32);
      v13 = v5;
      while (1)
      {
        v8 = (v13 + 1);
        if (v12 - 1 == v13)
          break;
        ++v13;
        LODWORD(v5) = v8;
        if ((*(_DWORD *)(v9 + 32 * v8 + 8) & 0x80000000) != 0)
          goto LABEL_20;
      }
      LODWORD(v5) = v12;
LABEL_20:
      ;
    }
    while ((_DWORD)v4 != (_DWORD)v5);
  }
  if (!*(_BYTE *)(a1 + 88))
  {
    v16 = a1 + 192;
    if (re::Configuration::hasQuorum(v16, (uint64_t)v22))
    {
      v14 = 0;
      goto LABEL_36;
    }
    if (re::Configuration::hasQuorum(v16, (uint64_t)v20))
    {
      v14 = 2;
      goto LABEL_36;
    }
LABEL_35:
    v14 = 1;
    goto LABEL_36;
  }
  re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashSetBase((uint64_t)v18, a1 + 96);
  re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashSetBase((uint64_t)v19, a1 + 144);
  if (re::Configuration::hasQuorum((uint64_t)v18, (uint64_t)v22) && re::Configuration::hasQuorum(a1 + 192, (uint64_t)v22))
  {
    v14 = 0;
    v15 = 0;
  }
  else
  {
    v15 = !re::Configuration::hasQuorum((uint64_t)v18, (uint64_t)v20)
       && !re::Configuration::hasQuorum(a1 + 192, (uint64_t)v20);
    v14 = 2;
  }
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(v19);
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(v18);
  if (v15)
    goto LABEL_35;
LABEL_36:
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)v20);
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)v22);
  return v14;
}

BOOL re::ProgressSet::quorumRecentlyActive(re::ProgressSet *this, uint64_t a2)
{
  unsigned int v4;
  uint64_t v5;
  int *v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const re::Progress *v16;
  std::__shared_weak_count *v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *p_shared_owners;
  unint64_t v21;
  unsigned int v22;
  unsigned int v23;
  uint64_t v24;
  int *v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t *v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  int v43;
  unsigned int v44;
  uint64_t v45;
  int *v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t v55;
  const re::Progress *v56;
  std::__shared_weak_count *v57;
  uint64_t v58;
  std::__shared_weak_count *v59;
  unint64_t *v60;
  unint64_t v61;
  unsigned int v62;
  unsigned int v63;
  uint64_t v64;
  int *v65;
  int v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  unint64_t v70;
  unint64_t v71;
  unint64_t v72;
  uint64_t v73;
  uint64_t v74;
  int v75;
  int v76;
  _BOOL8 hasQuorum;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  _OWORD v82[2];
  __int128 v83;
  uint64_t v84;
  std::__shared_weak_count *v85;
  unint64_t v86;
  uint64_t v87[2];
  uint64_t v88;
  unsigned int v89;

  v83 = 0u;
  memset(v82, 0, sizeof(v82));
  DWORD1(v83) = 0x7FFFFFFF;
  re::ProgressSet::voterIds(this, (uint64_t)v87);
  v80 = 0u;
  v81 = 0u;
  v79 = 0u;
  DWORD1(v81) = 0x7FFFFFFF;
  v4 = v89;
  if (v89)
  {
    v5 = 0;
    v6 = (int *)(v88 + 8);
    while (1)
    {
      v7 = *v6;
      v6 += 6;
      if (v7 < 0)
        break;
      if (v89 == ++v5)
      {
        LODWORD(v5) = v89;
        break;
      }
    }
  }
  else
  {
    LODWORD(v5) = 0;
  }
  if (v89 == (_DWORD)v5)
  {
    re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(v87);
    LODWORD(v8) = 0;
LABEL_35:
    LODWORD(v24) = 0;
    goto LABEL_36;
  }
  v9 = v5;
  v10 = v88;
  do
  {
    v11 = *(_QWORD *)(v10 + 24 * v9 + 16);
    v86 = v11;
    if (!*(_QWORD *)this)
    {
      v14 = *((_QWORD *)this + 2);
LABEL_16:
      LODWORD(v15) = 0x7FFFFFFF;
      goto LABEL_17;
    }
    v12 = 0x94D049BB133111EBLL
        * ((0xBF58476D1CE4E5B9 * (v11 ^ (v11 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v11 ^ (v11 >> 30))) >> 27));
    v13 = (v12 ^ (v12 >> 31)) % *((unsigned int *)this + 6);
    v14 = *((_QWORD *)this + 2);
    v15 = *(unsigned int *)(*((_QWORD *)this + 1) + 4 * v13);
    if ((_DWORD)v15 == 0x7FFFFFFF)
      goto LABEL_16;
    while (*(_QWORD *)(v14 + 136 * v15 + 16) != v11)
    {
      v15 = *(_DWORD *)(v14 + 136 * v15 + 8) & 0x7FFFFFFF;
      if (v15 == 0x7FFFFFFF)
        goto LABEL_16;
    }
LABEL_17:
    v16 = (const re::Progress *)(v14 + 136 * v15 + 24);
    v17 = (std::__shared_weak_count *)operator new(0x88uLL);
    v17->__shared_owners_ = 0;
    v17->__shared_weak_owners_ = 0;
    v17->__vftable = (std::__shared_weak_count_vtbl *)&off_24ED7DEE0;
    re::Progress::Progress((re::Progress *)&v17[1], v16);
    v84 = v18;
    v85 = v17;
    re::HashTable<unsigned long long,std::shared_ptr<re::Progress>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)&v79, (uint64_t *)&v86, (uint64_t)&v84);
    v19 = v85;
    if (v85)
    {
      p_shared_owners = (unint64_t *)&v85->__shared_owners_;
      do
        v21 = __ldaxr(p_shared_owners);
      while (__stlxr(v21 - 1, p_shared_owners));
      if (!v21)
      {
        ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
        std::__shared_weak_count::__release_weak(v19);
      }
    }
    v10 = v88;
    if (v89 <= (int)v5 + 1)
      v22 = v5 + 1;
    else
      v22 = v89;
    while (1)
    {
      v9 = (v5 + 1);
      if (v22 - 1 == (_DWORD)v5)
        break;
      LODWORD(v5) = v5 + 1;
      v23 = v9;
      if ((*(_DWORD *)(v88 + 24 * v9 + 8) & 0x80000000) != 0)
        goto LABEL_29;
    }
    v23 = v22;
LABEL_29:
    LODWORD(v5) = v23;
  }
  while (v4 != v23);
  v8 = v81;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(v87);
  if (!(_DWORD)v8)
    goto LABEL_35;
  v24 = 0;
  v25 = (int *)(v80 + 8);
  while (1)
  {
    v26 = *v25;
    v25 += 10;
    if (v26 < 0)
      break;
    if (v8 == ++v24)
    {
      LODWORD(v24) = v8;
      break;
    }
  }
LABEL_36:
  if ((_DWORD)v8 != (_DWORD)v24)
  {
    v27 = v24;
    v28 = v80;
    while (1)
    {
      v29 = v28 + 40 * v27;
      v32 = *(_QWORD *)(v29 + 16);
      v31 = (uint64_t *)(v29 + 16);
      v30 = v32;
      if (v32 != a2)
        break;
      re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)v82, v31);
LABEL_57:
      v28 = v80;
      if (v81 <= (int)v24 + 1)
        v42 = v24 + 1;
      else
        v42 = v81;
      while (1)
      {
        v27 = (v24 + 1);
        if (v42 - 1 == (_DWORD)v24)
          break;
        LODWORD(v24) = v24 + 1;
        v43 = v27;
        if ((*(_DWORD *)(v80 + 40 * v27 + 8) & 0x80000000) != 0)
          goto LABEL_64;
      }
      v43 = v42;
LABEL_64:
      LODWORD(v24) = v43;
      if ((_DWORD)v8 == v43)
        goto LABEL_65;
    }
    v33 = *(_QWORD *)this;
    if (*(_QWORD *)this)
    {
      v34 = 0x94D049BB133111EBLL
          * ((0xBF58476D1CE4E5B9 * (v30 ^ (v30 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v30 ^ (v30 >> 30))) >> 27));
      v35 = (v34 ^ (v34 >> 31)) % *((unsigned int *)this + 6);
      v36 = *((_QWORD *)this + 2);
      v37 = *(unsigned int *)(*((_QWORD *)this + 1) + 4 * v35);
      if ((_DWORD)v37 != 0x7FFFFFFF)
      {
        while (*(_QWORD *)(v36 + 136 * v37 + 16) != v30)
        {
          v37 = *(_DWORD *)(v36 + 136 * v37 + 8) & 0x7FFFFFFF;
          if (v37 == 0x7FFFFFFF)
            goto LABEL_46;
        }
LABEL_47:
        if (*(_BYTE *)(v36 + 136 * v37 + 129))
        {
          re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)v82, v31);
          v30 = *v31;
          v33 = *(_QWORD *)this;
        }
        if (v33)
        {
          v38 = 0x94D049BB133111EBLL
              * ((0xBF58476D1CE4E5B9 * (v30 ^ (v30 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v30 ^ (v30 >> 30))) >> 27));
          v39 = (v38 ^ (v38 >> 31)) % *((unsigned int *)this + 6);
          v40 = *((_QWORD *)this + 2);
          v41 = *(unsigned int *)(*((_QWORD *)this + 1) + 4 * v39);
          if ((_DWORD)v41 != 0x7FFFFFFF)
          {
            while (*(_QWORD *)(v40 + 136 * v41 + 16) != v30)
            {
              v41 = *(_DWORD *)(v40 + 136 * v41 + 8) & 0x7FFFFFFF;
              if (v41 == 0x7FFFFFFF)
                goto LABEL_55;
            }
            goto LABEL_56;
          }
        }
        else
        {
          v40 = *((_QWORD *)this + 2);
        }
LABEL_55:
        LODWORD(v41) = 0x7FFFFFFF;
LABEL_56:
        *(_BYTE *)(v40 + 136 * v41 + 129) = 0;
        goto LABEL_57;
      }
    }
    else
    {
      v36 = *((_QWORD *)this + 2);
    }
LABEL_46:
    LODWORD(v37) = 0x7FFFFFFF;
    goto LABEL_47;
  }
LABEL_65:
  re::HashTable<unsigned long long,std::shared_ptr<re::Progress>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)&v79);
  re::ProgressSet::learnerIds(this, (uint64_t)v87);
  v80 = 0u;
  v81 = 0u;
  v79 = 0u;
  DWORD1(v81) = 0x7FFFFFFF;
  v44 = v89;
  if (v89)
  {
    v45 = 0;
    v46 = (int *)(v88 + 8);
    while (1)
    {
      v47 = *v46;
      v46 += 6;
      if (v47 < 0)
        break;
      if (v89 == ++v45)
      {
        LODWORD(v45) = v89;
        break;
      }
    }
  }
  else
  {
    LODWORD(v45) = 0;
  }
  if (v89 == (_DWORD)v45)
  {
    re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(v87);
    LODWORD(v48) = 0;
LABEL_99:
    LODWORD(v64) = 0;
    goto LABEL_100;
  }
  v49 = v45;
  v50 = v88;
  while (2)
  {
    v51 = *(_QWORD *)(v50 + 24 * v49 + 16);
    v86 = v51;
    if (!*(_QWORD *)this)
    {
      v54 = *((_QWORD *)this + 2);
      goto LABEL_80;
    }
    v52 = 0x94D049BB133111EBLL
        * ((0xBF58476D1CE4E5B9 * (v51 ^ (v51 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v51 ^ (v51 >> 30))) >> 27));
    v53 = (v52 ^ (v52 >> 31)) % *((unsigned int *)this + 6);
    v54 = *((_QWORD *)this + 2);
    v55 = *(unsigned int *)(*((_QWORD *)this + 1) + 4 * v53);
    if ((_DWORD)v55 == 0x7FFFFFFF)
    {
LABEL_80:
      LODWORD(v55) = 0x7FFFFFFF;
      goto LABEL_81;
    }
    while (*(_QWORD *)(v54 + 136 * v55 + 16) != v51)
    {
      v55 = *(_DWORD *)(v54 + 136 * v55 + 8) & 0x7FFFFFFF;
      if (v55 == 0x7FFFFFFF)
        goto LABEL_80;
    }
LABEL_81:
    v56 = (const re::Progress *)(v54 + 136 * v55 + 24);
    v57 = (std::__shared_weak_count *)operator new(0x88uLL);
    v57->__shared_owners_ = 0;
    v57->__shared_weak_owners_ = 0;
    v57->__vftable = (std::__shared_weak_count_vtbl *)&off_24ED7DEE0;
    re::Progress::Progress((re::Progress *)&v57[1], v56);
    v84 = v58;
    v85 = v57;
    re::HashTable<unsigned long long,std::shared_ptr<re::Progress>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)&v79, (uint64_t *)&v86, (uint64_t)&v84);
    v59 = v85;
    if (v85)
    {
      v60 = (unint64_t *)&v85->__shared_owners_;
      do
        v61 = __ldaxr(v60);
      while (__stlxr(v61 - 1, v60));
      if (!v61)
      {
        ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
        std::__shared_weak_count::__release_weak(v59);
      }
    }
    v50 = v88;
    if (v89 <= (int)v45 + 1)
      v62 = v45 + 1;
    else
      v62 = v89;
    while (1)
    {
      v49 = (v45 + 1);
      if (v62 - 1 == (_DWORD)v45)
        break;
      LODWORD(v45) = v45 + 1;
      v63 = v49;
      if ((*(_DWORD *)(v88 + 24 * v49 + 8) & 0x80000000) != 0)
        goto LABEL_93;
    }
    v63 = v62;
LABEL_93:
    LODWORD(v45) = v63;
    if (v44 != v63)
      continue;
    break;
  }
  v48 = v81;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(v87);
  if (!(_DWORD)v48)
    goto LABEL_99;
  v64 = 0;
  v65 = (int *)(v80 + 8);
  while (1)
  {
    v66 = *v65;
    v65 += 10;
    if (v66 < 0)
      break;
    if (v48 == ++v64)
    {
      LODWORD(v64) = v48;
      break;
    }
  }
LABEL_100:
  if ((_DWORD)v48 != (_DWORD)v64)
  {
    v67 = v64;
    v68 = *(_QWORD *)this;
    v69 = v80;
    do
    {
      if (v68)
      {
        v70 = *(_QWORD *)(v69 + 40 * v67 + 16);
        v71 = 0x94D049BB133111EBLL
            * ((0xBF58476D1CE4E5B9 * (v70 ^ (v70 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v70 ^ (v70 >> 30))) >> 27));
        v72 = (v71 ^ (v71 >> 31)) % *((unsigned int *)this + 6);
        v73 = *((_QWORD *)this + 2);
        v74 = *(unsigned int *)(*((_QWORD *)this + 1) + 4 * v72);
        if ((_DWORD)v74 != 0x7FFFFFFF)
        {
          while (*(_QWORD *)(v73 + 136 * v74 + 16) != v70)
          {
            v74 = *(_DWORD *)(v73 + 136 * v74 + 8) & 0x7FFFFFFF;
            if (v74 == 0x7FFFFFFF)
              goto LABEL_108;
          }
          goto LABEL_109;
        }
      }
      else
      {
        v73 = *((_QWORD *)this + 2);
      }
LABEL_108:
      LODWORD(v74) = 0x7FFFFFFF;
LABEL_109:
      *(_BYTE *)(v73 + 136 * v74 + 129) = 0;
      if (v48 <= (int)v64 + 1)
        v75 = v64 + 1;
      else
        v75 = v48;
      while (1)
      {
        v67 = (v64 + 1);
        if (v75 - 1 == (_DWORD)v64)
          break;
        LODWORD(v64) = v64 + 1;
        v76 = v67;
        if ((*(_DWORD *)(v69 + 40 * v67 + 8) & 0x80000000) != 0)
          goto LABEL_116;
      }
      v76 = v75;
LABEL_116:
      LODWORD(v64) = v76;
    }
    while ((_DWORD)v48 != v76);
  }
  re::HashTable<unsigned long long,std::shared_ptr<re::Progress>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)&v79);
  if (re::Configuration::hasQuorum((uint64_t)this + 192, (uint64_t)v82))
  {
    if (*((_BYTE *)this + 88))
      hasQuorum = re::Configuration::hasQuorum((uint64_t)this + 96, (uint64_t)v82);
    else
      hasQuorum = 1;
  }
  else
  {
    hasQuorum = 0;
  }
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)v82);
  return hasQuorum;
}

double re::ProgressSet::beginMembershipChange@<D0>(re::ProgressSet *this@<X0>, const re::Configuration *a2@<X1>, re::Progress *a3@<X2>, uint64_t a4@<X8>)
{
  double v8;
  uint64_t v9;
  uint64_t v10;
  int *v11;
  int v12;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  int v19;
  int v20;
  uint64_t v21;
  int *v22;
  int v23;
  __int128 v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int *v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  unsigned int v33;
  unsigned int v34;
  unsigned int v35;
  uint64_t v36;
  uint64_t v37;
  int *v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  unsigned int v42;
  unsigned int v43;
  unsigned int v44;
  __int128 v46;
  uint64_t v47;
  uint64_t v48;
  char v49;
  uint64_t v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;

  v8 = re::Configuration::validate(a2, (uint64_t)&v46);
  if ((_BYTE)v46)
  {
    v52 = 0u;
    v53 = 0u;
    v51 = 0u;
    DWORD1(v53) = 0x7FFFFFFF;
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::clear((uint64_t)&v51);
    v9 = *((unsigned int *)this + 56);
    if ((_DWORD)v9)
    {
      v10 = 0;
      v11 = (int *)(*((_QWORD *)this + 26) + 8);
      while (1)
      {
        v12 = *v11;
        v11 += 6;
        if (v12 < 0)
          break;
        if (v9 == ++v10)
        {
          LODWORD(v10) = *((_DWORD *)this + 56);
          break;
        }
      }
    }
    else
    {
      LODWORD(v10) = 0;
    }
    if ((_DWORD)v9 != (_DWORD)v10)
    {
      v16 = v10;
      v17 = *((_QWORD *)this + 26);
      do
      {
        if (re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains((uint64_t)a2 + 48, (uint64_t *)(v17 + 24 * v16 + 16)))
        {
          re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)&v51, (uint64_t *)(*((_QWORD *)this + 26) + 24 * v16 + 16));
        }
        v18 = *((_DWORD *)this + 56);
        v17 = *((_QWORD *)this + 26);
        if (v18 <= (int)v10 + 1)
          v19 = v10 + 1;
        else
          v19 = *((_DWORD *)this + 56);
        while (1)
        {
          v16 = (v10 + 1);
          if (v19 - 1 == (_DWORD)v10)
            break;
          LODWORD(v10) = v10 + 1;
          v20 = v16;
          if ((*(_DWORD *)(v17 + 24 * v16 + 8) & 0x80000000) != 0)
            goto LABEL_23;
        }
        v20 = v19;
LABEL_23:
        LODWORD(v10) = v20;
      }
      while (v18 != v20);
    }
    if (HIDWORD(v52))
    {
      v21 = 0;
      if ((_DWORD)v53)
      {
        v22 = (int *)(v52 + 8);
        while (1)
        {
          v23 = *v22;
          v22 += 6;
          if (v23 < 0)
            break;
          if (v53 == ++v21)
          {
            LODWORD(v21) = v53;
            break;
          }
        }
      }
      re::DynamicString::format((re::DynamicString *)"Learners: %llu", (re::DynamicString *)&v46, *(_QWORD *)(v52 + 24 * v21 + 16));
      v24 = v46;
      v25 = v47;
      v26 = v48;
      *(_BYTE *)a4 = 0;
      *(_QWORD *)(a4 + 8) = 6;
      *(_QWORD *)(a4 + 16) = &re::ConsensusErrorCategory(void)::instance;
      *(_OWORD *)(a4 + 24) = v24;
      *(_QWORD *)(a4 + 40) = v25;
      *(_QWORD *)(a4 + 48) = v26;
    }
    else
    {
      *((_WORD *)a3 + 52) = 256;
      v27 = *((unsigned int *)a2 + 8);
      if ((_DWORD)v27)
      {
        v28 = 0;
        v29 = (int *)(*((_QWORD *)a2 + 2) + 8);
        while (1)
        {
          v30 = *v29;
          v29 += 6;
          if (v30 < 0)
            break;
          if (v27 == ++v28)
          {
            LODWORD(v28) = *((_DWORD *)a2 + 8);
            break;
          }
        }
      }
      else
      {
        LODWORD(v28) = 0;
      }
      if ((_DWORD)v27 != (_DWORD)v28)
      {
        v31 = v28;
        v32 = *((_QWORD *)a2 + 2);
        v33 = *((_DWORD *)a2 + 8);
        do
        {
          *(_QWORD *)&v46 = 0;
          *(_QWORD *)&v46 = *(_QWORD *)(v32 + 24 * v31 + 16);
          if (!re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)this, v46))
          {
            re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew<re::Progress&>((uint64_t)this, (uint64_t *)&v46, a3);
            v33 = *((_DWORD *)a2 + 8);
            v32 = *((_QWORD *)a2 + 2);
          }
          if (v33 <= (int)v28 + 1)
            v34 = v28 + 1;
          else
            v34 = v33;
          while (1)
          {
            v31 = (v28 + 1);
            if (v34 - 1 == (_DWORD)v28)
              break;
            LODWORD(v28) = v28 + 1;
            v35 = v31;
            if ((*(_DWORD *)(v32 + 24 * v31 + 8) & 0x80000000) != 0)
              goto LABEL_48;
          }
          v35 = v34;
LABEL_48:
          LODWORD(v28) = v35;
        }
        while ((_DWORD)v27 != v35);
      }
      v36 = *((unsigned int *)a2 + 20);
      if ((_DWORD)v36)
      {
        v37 = 0;
        v38 = (int *)(*((_QWORD *)a2 + 8) + 8);
        while (1)
        {
          v39 = *v38;
          v38 += 6;
          if (v39 < 0)
            break;
          if (v36 == ++v37)
          {
            LODWORD(v37) = *((_DWORD *)a2 + 20);
            break;
          }
        }
      }
      else
      {
        LODWORD(v37) = 0;
      }
      if ((_DWORD)v36 != (_DWORD)v37)
      {
        v40 = v37;
        v41 = *((_QWORD *)a2 + 8);
        v42 = *((_DWORD *)a2 + 20);
        do
        {
          *(_QWORD *)&v46 = 0;
          *(_QWORD *)&v46 = *(_QWORD *)(v41 + 24 * v40 + 16);
          if (!re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)this, v46))
          {
            re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew<re::Progress&>((uint64_t)this, (uint64_t *)&v46, a3);
            v42 = *((_DWORD *)a2 + 20);
            v41 = *((_QWORD *)a2 + 8);
          }
          if (v42 <= (int)v37 + 1)
            v43 = v37 + 1;
          else
            v43 = v42;
          while (1)
          {
            v40 = (v37 + 1);
            if (v43 - 1 == (_DWORD)v37)
              break;
            LODWORD(v37) = v37 + 1;
            v44 = v40;
            if ((*(_DWORD *)(v41 + 24 * v40 + 8) & 0x80000000) != 0)
              goto LABEL_66;
          }
          v44 = v43;
LABEL_66:
          LODWORD(v37) = v44;
        }
        while ((_DWORD)v36 != v44);
      }
      LOBYTE(v46) = 1;
      re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashSetBase((uint64_t)&v46 + 8, (uint64_t)a2);
      re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashSetBase((uint64_t)&v50, (uint64_t)a2 + 48);
      re::Optional<re::Configuration>::operator=((unsigned __int8 *)this + 88, (uint64_t *)&v46);
      re::Optional<re::Configuration>::~Optional((uint64_t)&v46);
      *(_BYTE *)a4 = 1;
    }
    *(double *)&v13 = re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v51);
  }
  else
  {
    if (v48 && (v49 & 1) != 0)
      (*(void (**)(double))(*(_QWORD *)v48 + 40))(v8);
    re::DynamicString::format((re::DynamicString *)"Invalid Configuration", (re::DynamicString *)&v46);
    v13 = v46;
    v14 = v47;
    v15 = v48;
    *(_BYTE *)a4 = 0;
    *(_QWORD *)(a4 + 8) = 5;
    *(_QWORD *)(a4 + 16) = &re::ConsensusErrorCategory(void)::instance;
    *(_OWORD *)(a4 + 24) = v13;
    *(_QWORD *)(a4 + 40) = v14;
    *(_QWORD *)(a4 + 48) = v15;
  }
  return *(double *)&v13;
}

uint64_t re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v5;

  if (!*(_QWORD *)a1)
    return 0;
  v2 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
  v3 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * ((v2 ^ (v2 >> 31)) % *(unsigned int *)(a1 + 24)));
  if ((_DWORD)v3 == 0x7FFFFFFF)
    return 0;
  v5 = *(_QWORD *)(a1 + 16);
  if (*(_QWORD *)(v5 + 136 * v3 + 16) != a2)
  {
    while (1)
    {
      LODWORD(v3) = *(_DWORD *)(v5 + 136 * v3 + 8) & 0x7FFFFFFF;
      if ((_DWORD)v3 == 0x7FFFFFFF)
        break;
      if (*(_QWORD *)(v5 + 136 * v3 + 16) == a2)
        return v5 + 136 * v3 + 24;
    }
    return 0;
  }
  return v5 + 136 * v3 + 24;
}

double re::ProgressSet::finalizeMembershipChange@<D0>(re::ProgressSet *this@<X0>, uint64_t a2@<X8>)
{
  unsigned __int8 *v3;
  uint64_t v5;
  uint64_t v6;
  int *v7;
  int v8;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  int *v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int v23;
  int v24;
  int v25;
  int v26;
  uint64_t v27;
  int *v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  int v33;
  int v34;
  uint64_t v35;
  int *v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  int v41;
  __int128 v43;
  uint64_t v44;
  uint64_t v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  uint64_t v52[6];
  uint64_t v53[6];

  v3 = (unsigned __int8 *)this + 88;
  if (*((_BYTE *)this + 88))
  {
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashSetBase((uint64_t)v52, (uint64_t)this + 96);
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashSetBase((uint64_t)v53, (uint64_t)this + 144);
    v50 = 0u;
    v51 = 0u;
    v49 = 0u;
    DWORD1(v51) = 0x7FFFFFFF;
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::clear((uint64_t)&v49);
    v5 = *((unsigned int *)this + 56);
    if ((_DWORD)v5)
    {
      v6 = 0;
      v7 = (int *)(*((_QWORD *)this + 26) + 8);
      while (1)
      {
        v8 = *v7;
        v7 += 6;
        if (v8 < 0)
          break;
        if (v5 == ++v6)
        {
          LODWORD(v6) = *((_DWORD *)this + 56);
          break;
        }
      }
    }
    else
    {
      LODWORD(v6) = 0;
    }
    if ((_DWORD)v5 != (_DWORD)v6)
    {
      v12 = v6;
      v13 = *((_QWORD *)this + 26);
      do
      {
        if (!re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains((uint64_t)v52, (uint64_t *)(v13 + 24 * v12 + 16)))re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)&v49, (uint64_t *)(*((_QWORD *)this + 26) + 24 * v12 + 16));
        v14 = *((_DWORD *)this + 56);
        v13 = *((_QWORD *)this + 26);
        if (v14 <= (int)v6 + 1)
          v15 = v6 + 1;
        else
          v15 = *((_DWORD *)this + 56);
        while (1)
        {
          v12 = (v6 + 1);
          if (v15 - 1 == (_DWORD)v6)
            break;
          LODWORD(v6) = v6 + 1;
          v16 = v12;
          if ((*(_DWORD *)(v13 + 24 * v12 + 8) & 0x80000000) != 0)
            goto LABEL_20;
        }
        v16 = v15;
LABEL_20:
        LODWORD(v6) = v16;
      }
      while (v14 != v16);
    }
    v48 = 0u;
    v46 = 0u;
    v47 = 0u;
    DWORD1(v48) = 0x7FFFFFFF;
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::clear((uint64_t)&v46);
    v17 = *((unsigned int *)this + 68);
    if ((_DWORD)v17)
    {
      v18 = 0;
      v19 = (int *)(*((_QWORD *)this + 32) + 8);
      while (1)
      {
        v20 = *v19;
        v19 += 6;
        if (v20 < 0)
          break;
        if (v17 == ++v18)
        {
          LODWORD(v18) = *((_DWORD *)this + 68);
          break;
        }
      }
    }
    else
    {
      LODWORD(v18) = 0;
    }
    if ((_DWORD)v17 != (_DWORD)v18)
    {
      v21 = v18;
      v22 = *((_QWORD *)this + 32);
      do
      {
        if (!re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains((uint64_t)v53, (uint64_t *)(v22 + 24 * v21 + 16)))re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)&v46, (uint64_t *)(*((_QWORD *)this + 32) + 24 * v21 + 16));
        v23 = *((_DWORD *)this + 68);
        v22 = *((_QWORD *)this + 32);
        if (v23 <= (int)v18 + 1)
          v24 = v18 + 1;
        else
          v24 = *((_DWORD *)this + 68);
        while (1)
        {
          v21 = (v18 + 1);
          if (v24 - 1 == (_DWORD)v18)
            break;
          LODWORD(v18) = v18 + 1;
          v25 = v21;
          if ((*(_DWORD *)(v22 + 24 * v21 + 8) & 0x80000000) != 0)
            goto LABEL_38;
        }
        v25 = v24;
LABEL_38:
        LODWORD(v18) = v25;
      }
      while (v23 != v25);
    }
    v26 = v51;
    if ((_DWORD)v51)
    {
      v27 = 0;
      v28 = (int *)(v50 + 8);
      while (1)
      {
        v29 = *v28;
        v28 += 6;
        if (v29 < 0)
          break;
        if (v51 == ++v27)
        {
          LODWORD(v27) = v51;
          break;
        }
      }
    }
    else
    {
      LODWORD(v27) = 0;
    }
    if ((_DWORD)v51 != (_DWORD)v27)
    {
      v30 = v27;
      v31 = v50;
      do
      {
        re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove((uint64_t)this, *(_QWORD *)(v31 + 24 * v30 + 16));
        v31 = v50;
        if (v51 <= (int)v27 + 1)
          v32 = v27 + 1;
        else
          v32 = v51;
        v33 = v27;
        while (1)
        {
          v30 = (v33 + 1);
          if (v32 - 1 == v33)
            break;
          ++v33;
          LODWORD(v27) = v30;
          if ((*(_DWORD *)(v50 + 24 * v30 + 8) & 0x80000000) != 0)
            goto LABEL_55;
        }
        LODWORD(v27) = v32;
LABEL_55:
        ;
      }
      while (v26 != (_DWORD)v27);
    }
    v34 = v48;
    if ((_DWORD)v48)
    {
      v35 = 0;
      v36 = (int *)(v47 + 8);
      while (1)
      {
        v37 = *v36;
        v36 += 6;
        if (v37 < 0)
          break;
        if (v48 == ++v35)
        {
          LODWORD(v35) = v48;
          break;
        }
      }
    }
    else
    {
      LODWORD(v35) = 0;
    }
    if ((_DWORD)v48 != (_DWORD)v35)
    {
      v38 = v35;
      v39 = v47;
      do
      {
        re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove((uint64_t)this, *(_QWORD *)(v39 + 24 * v38 + 16));
        v39 = v47;
        if (v48 <= (int)v35 + 1)
          v40 = v35 + 1;
        else
          v40 = v48;
        v41 = v35;
        while (1)
        {
          v38 = (v41 + 1);
          if (v40 - 1 == v41)
            break;
          ++v41;
          LODWORD(v35) = v38;
          if ((*(_DWORD *)(v47 + 24 * v38 + 8) & 0x80000000) != 0)
            goto LABEL_72;
        }
        LODWORD(v35) = v40;
LABEL_72:
        ;
      }
      while (v34 != (_DWORD)v35);
    }
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::operator=((uint64_t)this + 192, (uint64_t)v52);
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::operator=((uint64_t)this + 240, (uint64_t)v53);
    LOBYTE(v43) = 0;
    re::Optional<re::Configuration>::operator=(v3, (uint64_t *)&v43);
    re::Optional<re::Configuration>::~Optional((uint64_t)&v43);
    *(_BYTE *)a2 = 1;
    re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v46);
    re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v49);
    re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(v53);
    *(double *)&v9 = re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(v52);
  }
  else
  {
    v9 = v43;
    v10 = v44;
    v11 = v45;
    *(_BYTE *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 9;
    *(_QWORD *)(a2 + 16) = &re::ConsensusErrorCategory(void)::instance;
    *(_OWORD *)(a2 + 24) = v9;
    *(_QWORD *)(a2 + 40) = v10;
    *(_QWORD *)(a2 + 48) = v11;
  }
  return *(double *)&v9;
}

BOOL re::ProgressSet::hasQuorum(uint64_t a1, uint64_t a2)
{
  _BOOL8 result;

  result = re::Configuration::hasQuorum(a1 + 192, a2);
  if (result)
    return !*(_BYTE *)(a1 + 88) || re::Configuration::hasQuorum(a1 + 96, a2);
  return result;
}

double re::HashTable<unsigned long long,std::shared_ptr<re::Progress>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t i;
  uint64_t v5;
  uint64_t v6;
  int *v7;
  int v8;
  int v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  double result;

  v2 = *a1;
  if (v2)
  {
    v3 = *((unsigned int *)a1 + 8);
    if ((_DWORD)v3)
    {
      for (i = 0; i < v3; ++i)
      {
        v5 = a1[2];
        v6 = v5 + 40 * i;
        v9 = *(_DWORD *)(v6 + 8);
        v7 = (int *)(v6 + 8);
        v8 = v9;
        if (v9 < 0)
        {
          *v7 = v8 & 0x7FFFFFFF;
          v10 = *(std::__shared_weak_count **)(v5 + 40 * i + 32);
          if (v10)
          {
            p_shared_owners = (unint64_t *)&v10->__shared_owners_;
            do
              v12 = __ldaxr(p_shared_owners);
            while (__stlxr(v12 - 1, p_shared_owners));
            if (!v12)
            {
              ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
              std::__shared_weak_count::__release_weak(v10);
            }
          }
          v3 = *((unsigned int *)a1 + 8);
        }
      }
      v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

void std::__shared_ptr_emplace<re::Progress>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24ED7DEE0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<re::Progress>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24ED7DEE0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2276933B8);
}

uint64_t std::__shared_ptr_emplace<re::Progress>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;
  _QWORD *v3;

  v3 = (_QWORD *)(a1 + 24);
  result = *(_QWORD *)(a1 + 24);
  if (result)
  {
    if (*(_QWORD *)(a1 + 56))
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
    *(_QWORD *)(a1 + 56) = 0;
    v3[1] = 0;
    v3[2] = 0;
    *v3 = 0;
    ++*(_DWORD *)(a1 + 48);
  }
  return result;
}

uint64_t re::HashTable<unsigned long long,std::shared_ptr<re::Progress>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, _QWORD *a4, uint64_t a5)
{
  uint64_t v9;
  int v10;
  int v11;
  signed int v12;
  uint64_t v13;
  BOOL v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  __int128 v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  signed int v24;
  _BYTE v26[44];

  v9 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
    v9 = *(unsigned int *)(a1 + 32);
    v10 = v9;
    if ((_DWORD)v9 == *(_DWORD *)(a1 + 24))
    {
      v11 = *(_DWORD *)(a1 + 28);
      v12 = 2 * v11;
      v13 = *(_QWORD *)a1;
      if (*(_QWORD *)a1)
      {
        if (v12)
          v14 = (_DWORD)v9 == v12;
        else
          v14 = 1;
        if (!v14 && (v11 & 0x80000000) == 0)
        {
          memset(v26, 0, 36);
          *(_QWORD *)&v26[36] = 0x7FFFFFFFLL;
          re::HashTable<re::StringID,re::TimelineEventParameterDescription,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init((uint64_t)v26, v13, v12);
          v15 = *(_OWORD *)v26;
          *(_OWORD *)v26 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v15;
          v16 = *(_QWORD *)&v26[16];
          v17 = *(_QWORD *)(a1 + 16);
          *(_QWORD *)&v26[16] = v17;
          *(_QWORD *)(a1 + 16) = v16;
          v19 = *(_OWORD *)&v26[24];
          *(_OWORD *)&v26[24] = *(_OWORD *)(a1 + 24);
          v18 = *(_DWORD *)&v26[32];
          *(_OWORD *)(a1 + 24) = v19;
          v20 = v18;
          if (v18)
          {
            v21 = v17 + 16;
            do
            {
              if ((*(_DWORD *)(v21 - 8) & 0x80000000) != 0)
                re::HashTable<unsigned long long,std::shared_ptr<re::Progress>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(a1, *(_QWORD *)(v21 - 16) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(v21 - 16), v21, v21 + 8);
              v21 += 40;
              --v20;
            }
            while (v20);
          }
          re::HashTable<unsigned long long,std::shared_ptr<re::Progress>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)v26);
        }
      }
      else
      {
        if (v12)
          v24 = 2 * v11;
        else
          v24 = 3;
      }
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    v22 = *(_QWORD *)(a1 + 16);
    v23 = *(_DWORD *)(v22 + 40 * v9 + 8);
  }
  else
  {
    v22 = *(_QWORD *)(a1 + 16);
    v23 = *(_DWORD *)(v22 + 40 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v23 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v22 + 40 * v9 + 8) = v23 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 40 * v9 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 40 * v9 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 40 * v9) = a3;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 40 * v9 + 16) = *a4;
  *(_OWORD *)(*(_QWORD *)(a1 + 16) + 40 * v9 + 24) = *(_OWORD *)a5;
  *(_QWORD *)a5 = 0;
  *(_QWORD *)(a5 + 8) = 0;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

void re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addInternal<re::Progress&>(uint64_t a1, uint64_t *a2, re::Progress *a3)
{
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v6 = *a2;
  v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (!*(_QWORD *)a1)
  {
    LODWORD(v9) = 0;
    goto LABEL_12;
  }
  v9 = v8 % *(unsigned int *)(a1 + 24);
  v10 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v9);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
LABEL_12:
    re::HashTable<unsigned long long,re::Progress,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsCopy(a1, v9, v8, a2, a3);
    goto LABEL_13;
  }
  v11 = *(_QWORD *)(a1 + 16);
  while (*(_QWORD *)(v11 + 136 * v10 + 16) != v6)
  {
    v12 = *(_DWORD *)(v11 + 136 * v10 + 8);
    v10 = v12 & 0x7FFFFFFF;
    if ((v12 & 0x7FFFFFFF) == 0x7FFFFFFF)
      goto LABEL_12;
  }
  v13 = v11 + 136 * v10;
  v16 = *(_QWORD *)(v13 + 24);
  v15 = v13 + 24;
  v14 = v16;
  if (v16)
  {
    if (*(_QWORD *)(v15 + 32))
      (*(void (**)(uint64_t))(*(_QWORD *)v14 + 40))(v14);
    *(_QWORD *)(v15 + 32) = 0;
    *(_QWORD *)(v15 + 8) = 0;
    *(_QWORD *)(v15 + 16) = 0;
    *(_QWORD *)v15 = 0;
    ++*(_DWORD *)(v15 + 24);
    v11 = *(_QWORD *)(a1 + 16);
  }
  re::Progress::Progress((re::Progress *)(v11 + 136 * v10 + 24), a3);
LABEL_13:
  ++*(_DWORD *)(a1 + 40);
}

void std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::reverse_iterator<unsigned long long *>,false>(uint64_t a1, char *a2, uint64_t a3, unint64_t *a4, uint64_t a5, char a6)
{
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t *v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t *v25;
  unint64_t *v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t *v29;
  unint64_t *v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  char v34;
  unint64_t *v35;
  char *v36;
  unint64_t *v37;
  unint64_t v38;
  unint64_t *v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t *v45;
  BOOL v47;
  uint64_t v48;
  unint64_t *v49;
  unint64_t v50;
  unint64_t v51;
  unint64_t v52;
  uint64_t v53;
  char *v54;
  int64_t v55;
  int64_t v56;
  int64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  char *v61;
  uint64_t v62;
  char *v63;
  unint64_t v64;
  unint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  unint64_t v70;
  char *v71;
  unint64_t *v72;
  uint64_t v73;
  uint64_t v74;
  unint64_t *v75;
  unint64_t v76;
  unint64_t *v77;
  unint64_t v78;
  unint64_t v79;
  char *v81;
  unint64_t *v82;
  unint64_t v83;
  unint64_t v84;
  unint64_t v85;
  _QWORD *v86;

  while (2)
  {
    v11 = a2 - (char *)a4;
    v12 = (a2 - (char *)a4) >> 3;
    switch(v12)
    {
      case 0uLL:
      case 1uLL:
        return;
      case 2uLL:
        v44 = *((_QWORD *)a2 - 1);
        if (*a4 < v44)
        {
          *((_QWORD *)a2 - 1) = *a4;
          *a4 = v44;
        }
        return;
      case 3uLL:
        std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::reverse_iterator<unsigned long long *>>(a1, (uint64_t)a2, (uint64_t)(a2 - 8), (uint64_t)(a2 - 8), a3, (uint64_t)(a4 + 1));
        return;
      case 4uLL:
        std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::reverse_iterator<unsigned long long *>>(a1, (uint64_t)a2, (uint64_t)(a2 - 8), (uint64_t)(a2 - 8), (uint64_t)(a2 - 16), (uint64_t)(a2 - 16), a3, (uint64_t)(a4 + 1));
        return;
      case 5uLL:
        std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::reverse_iterator<unsigned long long *>>(a1, (uint64_t)a2, (uint64_t)(a2 - 8), (uint64_t)(a2 - 8), (uint64_t)(a2 - 16), (uint64_t)(a2 - 16), (uint64_t)(a2 - 24), (uint64_t)(a2 - 24), a3, (uint64_t)(a4 + 1));
        return;
      default:
        if (v11 > 191)
        {
          if (!a5)
          {
            if (a2 != (char *)a4)
            {
              v55 = (v12 - 2) >> 1;
              v56 = v55;
              do
              {
                v57 = v56;
                v58 = 8 * v56;
                if (v55 >= v58 >> 3)
                {
                  v59 = v58 >> 2;
                  v60 = (v58 >> 2) | 1;
                  v61 = &a2[-8 * v60];
                  v62 = v59 + 2;
                  if (v62 < (uint64_t)v12 && *((_QWORD *)v61 - 1) < *((_QWORD *)v61 - 2))
                  {
                    v61 -= 8;
                    v60 = v62;
                  }
                  v63 = &a2[-8 * v57];
                  v64 = *((_QWORD *)v61 - 1);
                  v65 = *((_QWORD *)v63 - 1);
                  if (v64 >= v65)
                  {
                    do
                    {
                      *((_QWORD *)v63 - 1) = v64;
                      v63 = v61;
                      if (v55 < v60)
                        break;
                      v66 = (2 * v60) | 1;
                      v61 = &a2[-8 * v66];
                      v67 = 2 * v60 + 2;
                      if (v67 < (uint64_t)v12 && *((_QWORD *)v61 - 1) < *((_QWORD *)v61 - 2))
                      {
                        v61 -= 8;
                        v66 = v67;
                      }
                      v64 = *((_QWORD *)v61 - 1);
                      v60 = v66;
                    }
                    while (v64 >= v65);
                    *((_QWORD *)v63 - 1) = v65;
                  }
                }
                v56 = v57 - 1;
              }
              while (v57);
              v68 = (unint64_t)v11 >> 3;
              do
              {
                v69 = 0;
                v70 = *((_QWORD *)a2 - 1);
                v71 = a2;
                do
                {
                  v72 = (unint64_t *)&v71[8 * ~v69];
                  v73 = (2 * v69) | 1;
                  v74 = 2 * v69 + 2;
                  if (v74 < v68 && *(v72 - 1) < *(v72 - 2))
                  {
                    --v72;
                    v73 = v74;
                  }
                  *((_QWORD *)v71 - 1) = *(v72 - 1);
                  v71 = (char *)v72;
                  v69 = v73;
                }
                while (v73 <= (uint64_t)((unint64_t)(v68 - 2) >> 1));
                v75 = v72 - 1;
                if (v72 == a4 + 1)
                {
                  *v75 = v70;
                }
                else
                {
                  *v75 = *a4;
                  *a4 = v70;
                  if (a2 - (char *)v75 >= 9)
                  {
                    v76 = (((unint64_t)(a2 - (char *)v75) >> 3) - 2) >> 1;
                    v77 = (unint64_t *)&a2[-8 * v76];
                    v78 = *(v77 - 1);
                    v79 = *v75;
                    if (v78 < v79)
                    {
                      do
                      {
                        *(v72 - 1) = v78;
                        v72 = v77;
                        if (!v76)
                          break;
                        v76 = (v76 - 1) >> 1;
                        v77 = (unint64_t *)&a2[-8 * v76];
                        v78 = *(v77 - 1);
                      }
                      while (v78 < v79);
                      *(v72 - 1) = v79;
                    }
                  }
                }
                ++a4;
              }
              while (v68-- > 2);
            }
            return;
          }
          v13 = v12 >> 1;
          v14 = (uint64_t)&a2[-8 * (v12 >> 1)];
          v15 = (uint64_t)(a4 + 1);
          v16 = a2;
          v17 = a1;
          if ((unint64_t)v11 < 0x401)
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::reverse_iterator<unsigned long long *>>((uint64_t)&a2[-8 * (v12 >> 1)], (uint64_t)&a2[-8 * (v12 >> 1)], a1, (uint64_t)a2, v15, (uint64_t)(a4 + 1));
          }
          else
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::reverse_iterator<unsigned long long *>>(a1, (uint64_t)a2, (uint64_t)&a2[-8 * (v12 >> 1)], (uint64_t)&a2[-8 * (v12 >> 1)], v15, (uint64_t)(a4 + 1));
            v18 = (uint64_t)&a2[8 * (1 - v13)];
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::reverse_iterator<unsigned long long *>>((uint64_t)(a2 - 8), (uint64_t)(a2 - 8), v18, v18, (uint64_t)(a4 + 2), (uint64_t)(a4 + 2));
            v19 = (uint64_t)&a2[8 * ~v13];
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::reverse_iterator<unsigned long long *>>((uint64_t)(a2 - 16), (uint64_t)(a2 - 16), v19, v19, (uint64_t)(a4 + 3), (uint64_t)(a4 + 3));
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::reverse_iterator<unsigned long long *>>(v18, v18, v14, v14, v19, v19);
            v20 = *((_QWORD *)a2 - 1);
            *((_QWORD *)a2 - 1) = *(_QWORD *)(v14 - 8);
            *(_QWORD *)(v14 - 8) = v20;
          }
          --a5;
          v21 = (unint64_t *)(a2 - 8);
          if ((a6 & 1) != 0)
          {
            v22 = *v21;
LABEL_10:
            v23 = 0;
            do
            {
              v24 = *(_QWORD *)&a2[v23 - 16];
              v23 -= 8;
            }
            while (v24 < v22);
            v25 = (unint64_t *)&a2[v23];
            v26 = a4;
            if (v23 == -8)
            {
              v26 = a4;
              do
              {
                if (v25 <= v26)
                  break;
                v28 = *v26++;
              }
              while (v28 >= v22);
            }
            else
            {
              do
                v27 = *v26++;
              while (v27 >= v22);
            }
            v29 = (unint64_t *)&a2[v23];
            if (v25 > v26)
            {
              v30 = v26;
              do
              {
                v31 = *(v29 - 1);
                *(v29 - 1) = *(v30 - 1);
                *(v30 - 1) = v31;
                do
                {
                  v32 = *(v29 - 2);
                  --v29;
                }
                while (v32 < v22);
                do
                  v33 = *v30++;
                while (v33 >= v22);
              }
              while (v29 > v30);
            }
            if (v29 + 1 != (unint64_t *)a2)
              *v21 = *v29;
            *v29 = v22;
            if (v25 > v26)
            {
LABEL_27:
              std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::reverse_iterator<unsigned long long *>,false>(v17, v16, v29 + 1, v29 + 1, a5, a6 & 1);
              a6 = 0;
              a1 = (uint64_t)(v29 + 1);
              a2 = (char *)v29;
              continue;
            }
            v34 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::reverse_iterator<unsigned long long *>>(a1, (uint64_t)a2, (uint64_t)(v29 + 1), v29 + 1);
            if (std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::reverse_iterator<unsigned long long *>>((uint64_t)v29, (uint64_t)v29, a3, a4))
            {
              a3 = (uint64_t)(v29 + 1);
              a4 = v29 + 1;
              if ((v34 & 1) != 0)
                return;
            }
            else
            {
              a1 = (uint64_t)(v29 + 1);
              a2 = (char *)v29;
              if ((v34 & 1) == 0)
                goto LABEL_27;
            }
          }
          else
          {
            v22 = *((_QWORD *)a2 - 1);
            if (*(_QWORD *)a2 < v22)
              goto LABEL_10;
            v35 = (unint64_t *)(a2 - 8);
            if (v22 >= *a4)
            {
              do
              {
                v37 = v35;
                if (v35 <= a4)
                  break;
                --v35;
              }
              while (v22 >= *(v37 - 1));
            }
            else
            {
              v36 = a2;
              do
              {
                v37 = (unint64_t *)(v36 - 8);
                v38 = *((_QWORD *)v36 - 2);
                v36 -= 8;
              }
              while (v22 >= v38);
            }
            v39 = a4;
            if (v37 > a4)
            {
              v39 = a4;
              do
                v40 = *v39++;
              while (v22 < v40);
            }
            while (v37 > v39)
            {
              v41 = *(v37 - 1);
              *(v37 - 1) = *(v39 - 1);
              *(v39 - 1) = v41;
              do
              {
                v42 = *(v37 - 2);
                --v37;
              }
              while (v22 >= v42);
              do
                v43 = *v39++;
              while (v22 < v43);
            }
            if (v37 + 1 != (unint64_t *)a2)
              *v21 = *v37;
            a6 = 0;
            *v37 = v22;
            a2 = (char *)v37;
          }
          continue;
        }
        v45 = (unint64_t *)(a2 - 8);
        v47 = a2 == (char *)a4 || v45 == a4;
        if ((a6 & 1) != 0)
        {
          if (!v47)
          {
            v48 = 0;
            v49 = (unint64_t *)(a2 - 8);
            do
            {
              v51 = *--v49;
              v50 = v51;
              v52 = *v45;
              if (v51 < v52)
              {
                v53 = v48;
                do
                {
                  v54 = &a2[v53];
                  *(_QWORD *)&a2[v53 - 16] = v52;
                  if (!v53)
                    break;
                  v52 = *(_QWORD *)&a2[v53];
                  v53 += 8;
                }
                while (v50 < v52);
                *((_QWORD *)v54 - 1) = v50;
              }
              v48 -= 8;
              v45 = v49;
            }
            while (v49 != a4);
          }
        }
        else if (!v47)
        {
          v81 = a2 - 16;
          v82 = (unint64_t *)(a2 - 8);
          do
          {
            v84 = *--v82;
            v83 = v84;
            v85 = *v45;
            if (v84 < v85)
            {
              v86 = v81;
              do
              {
                *v86 = v85;
                v85 = v86[2];
                ++v86;
              }
              while (v83 < v85);
              *v86 = v83;
            }
            v81 -= 8;
            v45 = v82;
          }
          while (v82 != a4);
        }
        return;
    }
  }
}

void std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::reverse_iterator<unsigned long long *>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;

  v6 = *(_QWORD *)(a4 - 8);
  v7 = *(_QWORD *)(a2 - 8);
  v8 = *(_QWORD *)(a6 - 8);
  if (v6 >= v7)
  {
    if (v8 < v6)
    {
      *(_QWORD *)(a4 - 8) = v8;
      *(_QWORD *)(a6 - 8) = v6;
      v9 = *(_QWORD *)(a4 - 8);
      v10 = *(_QWORD *)(a2 - 8);
      if (v9 < v10)
      {
        *(_QWORD *)(a2 - 8) = v9;
        *(_QWORD *)(a4 - 8) = v10;
      }
    }
  }
  else
  {
    if (v8 >= v6)
    {
      *(_QWORD *)(a2 - 8) = v6;
      *(_QWORD *)(a4 - 8) = v7;
      v11 = *(_QWORD *)(a6 - 8);
      if (v11 >= v7)
        return;
      *(_QWORD *)(a4 - 8) = v11;
    }
    else
    {
      *(_QWORD *)(a2 - 8) = v8;
    }
    *(_QWORD *)(a6 - 8) = v7;
  }
}

uint64_t std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::reverse_iterator<unsigned long long *>>(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t *a4)
{
  char v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  int v11;
  unint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  unint64_t v16;
  char v17;

  v6 = 1;
  switch((a2 - (uint64_t)a4) >> 3)
  {
    case 0:
    case 1:
      return v6 & 1;
    case 2:
      v7 = *(_QWORD *)(a2 - 8);
      if (*a4 < v7)
      {
        *(_QWORD *)(a2 - 8) = *a4;
        *a4 = v7;
      }
      goto LABEL_18;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::reverse_iterator<unsigned long long *>>(a1, a2, a2 - 8, a2 - 8, a3, (uint64_t)(a4 + 1));
      goto LABEL_18;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::reverse_iterator<unsigned long long *>>(a1, a2, a2 - 8, a2 - 8, a2 - 16, a2 - 16, a3, (uint64_t)(a4 + 1));
      goto LABEL_18;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::reverse_iterator<unsigned long long *>>(a1, a2, a2 - 8, a2 - 8, a2 - 16, a2 - 16, a2 - 24, a2 - 24, a3, (uint64_t)(a4 + 1));
LABEL_18:
      v6 = 1;
      return v6 & 1;
    default:
      v8 = a2 - 16;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::reverse_iterator<unsigned long long *>>(a1, a2, a2 - 8, a2 - 8, a2 - 16, a2 - 16);
      v10 = (_QWORD *)(a2 - 24);
      if ((unint64_t *)(a2 - 24) == a4)
        goto LABEL_14;
      v11 = 0;
      v9 = a2 - 24;
      break;
  }
  while (1)
  {
    v13 = *(_QWORD *)(v9 - 8);
    v9 -= 8;
    v12 = v13;
    if (v13 < *(_QWORD *)(v8 - 8))
    {
      v14 = v10;
      while (1)
      {
        *(v14 - 1) = *v14;
        if (v14 + 1 == (_QWORD *)a2)
          break;
        v15 = v14 + 1;
        v16 = v14[1];
        ++v14;
        if (v12 >= v16)
          goto LABEL_12;
      }
      v15 = (_QWORD *)a2;
LABEL_12:
      *(v15 - 1) = v12;
      if (++v11 == 8)
        break;
    }
    v8 = (uint64_t)v10;
    v10 = (_QWORD *)v9;
    if ((unint64_t *)v9 == a4)
    {
LABEL_14:
      v17 = 1;
      goto LABEL_20;
    }
  }
  v17 = 0;
  LOBYTE(v9) = v9 == (_QWORD)a4;
LABEL_20:
  v6 = v17 | v9;
  return v6 & 1;
}

void std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::reverse_iterator<unsigned long long *>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;

  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::reverse_iterator<unsigned long long *>>(a1, a2, a3, a4, a5, a6);
  v12 = *(_QWORD *)(a8 - 8);
  v13 = *(_QWORD *)(a6 - 8);
  if (v12 < v13)
  {
    *(_QWORD *)(a6 - 8) = v12;
    *(_QWORD *)(a8 - 8) = v13;
    v14 = *(_QWORD *)(a6 - 8);
    v15 = *(_QWORD *)(a4 - 8);
    if (v14 < v15)
    {
      *(_QWORD *)(a4 - 8) = v14;
      *(_QWORD *)(a6 - 8) = v15;
      v16 = *(_QWORD *)(a4 - 8);
      v17 = *(_QWORD *)(a2 - 8);
      if (v16 < v17)
      {
        *(_QWORD *)(a2 - 8) = v16;
        *(_QWORD *)(a4 - 8) = v17;
      }
    }
  }
}

void std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::reverse_iterator<unsigned long long *>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;

  std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::reverse_iterator<unsigned long long *>>(a1, a2, a3, a4, a5, a6, a7, a8);
  v14 = *(_QWORD *)(a10 - 8);
  v15 = *(_QWORD *)(a8 - 8);
  if (v14 < v15)
  {
    *(_QWORD *)(a8 - 8) = v14;
    *(_QWORD *)(a10 - 8) = v15;
    v16 = *(_QWORD *)(a8 - 8);
    v17 = *(_QWORD *)(a6 - 8);
    if (v16 < v17)
    {
      *(_QWORD *)(a6 - 8) = v16;
      *(_QWORD *)(a8 - 8) = v17;
      v18 = *(_QWORD *)(a6 - 8);
      v19 = *(_QWORD *)(a4 - 8);
      if (v18 < v19)
      {
        *(_QWORD *)(a4 - 8) = v18;
        *(_QWORD *)(a6 - 8) = v19;
        v20 = *(_QWORD *)(a4 - 8);
        v21 = *(_QWORD *)(a2 - 8);
        if (v20 < v21)
        {
          *(_QWORD *)(a2 - 8) = v20;
          *(_QWORD *)(a4 - 8) = v21;
        }
      }
    }
  }
}

_QWORD *re::Inflights::add(_QWORD *this, uint64_t a2)
{
  unint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _BYTE v12[18];
  __int16 v13;
  unint64_t v14;
  __int16 v15;
  unint64_t v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  v10 = a2;
  v4 = this[6];
  v3 = this[7];
  if (v4 == v3)
    goto LABEL_13;
  v5 = this;
  if (this[1] != v3)
  {
    this = re::DynamicArray<float *>::setCapacity(this, v3);
    v4 = v5[6];
    v3 = v5[7];
  }
  v6 = v5[5] + v4;
  if (v6 >= v3)
    v7 = v3;
  else
    v7 = 0;
  v8 = v6 - v7;
  v9 = v5[2];
  if (v6 - v7 != v9)
  {
    if (v9 > v8)
    {
      *(_QWORD *)(v5[4] + 8 * v8) = a2;
      goto LABEL_11;
    }
    v11 = 0;
    v20 = 0u;
    v21 = 0u;
    v18 = 0u;
    v19 = 0u;
    v17 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v12 = 136315906;
    *(_QWORD *)&v12[4] = "operator[]";
    *(_WORD *)&v12[12] = 1024;
    *(_DWORD *)&v12[14] = 789;
    v13 = 2048;
    v14 = v8;
    v15 = 2048;
    v16 = v9;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_13:
    re::internal::assertLog((re::internal *)4, v3, "assertion failure: '%s' (%s:line %i) Cannot add into a full inflights", "!\"Unreachable code\"", "add", 8, v10, v11, *(_OWORD *)v12);
    _os_crash();
    __break(1u);
  }
  this = re::DynamicArray<re::TransitionCondition *>::add(v5, &v10);
  v4 = v5[6];
LABEL_11:
  v5[6] = v4 + 1;
  return this;
}

_QWORD *re::Inflights::freeTo(_QWORD *this, unint64_t a2)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t i;
  unint64_t v7;

  v2 = this[6];
  if (!v2)
    return this;
  v3 = this[5];
  v4 = this[2];
  if (v4 <= v3)
  {
LABEL_14:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  v5 = this[4];
  if (*(_QWORD *)(v5 + 8 * v3) > a2)
    return this;
  for (i = 0; i != v2; ++i)
  {
    if (v4 <= v3)
    {
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_14;
    }
    if (*(_QWORD *)(v5 + 8 * v3) > a2)
      goto LABEL_11;
    v7 = this[7];
    if (v3 + 1 < v7)
      v7 = 0;
    v3 = v3 + 1 - v7;
  }
  i = this[6];
LABEL_11:
  this[5] = v3;
  this[6] = v2 - i;
  return this;
}

_QWORD *re::Inflights::freeFirstOne(re::Inflights *this)
{
  unint64_t v1;

  v1 = *((_QWORD *)this + 5);
  if (*((_QWORD *)this + 2) <= v1)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return re::Inflights::freeTo(this, *(_QWORD *)(*((_QWORD *)this + 4) + 8 * v1));
}

void re::RaftLog::getTerm(re::RaftLog *this@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  if (*((_BYTE *)this + 48))
  {
    v6 = *((_QWORD *)this + 33);
  }
  else
  {
    (*(void (**)(uint64_t *__return_ptr))(**(_QWORD **)this + 32))(&v9);
    v6 = v10 - 1;
  }
  if (v6 <= a2 && re::RaftLog::lastIndex(this) >= a2)
  {
    re::Unstable::maybeTerm((re::RaftLog *)((char *)this + 8), a2, (uint64_t)&v9);
    if ((_BYTE)v9)
    {
      v7 = v10;
      *(_BYTE *)a3 = 1;
      *(_QWORD *)(a3 + 8) = v7;
    }
    else
    {
      (*(void (**)(_QWORD, unint64_t))(**(_QWORD **)this + 56))(*(_QWORD *)this, a2);
      if (!*(_BYTE *)a3 && *(unsigned __int8 *)(a3 + 8) >= 2u)
      {
        re::internal::assertLog((re::internal *)4, v8, "assertion failure: '%s' (%s:line %i) unexpected error", "!\"Unreachable code\"", "getTerm", 25);
        _os_crash();
        __break(1u);
      }
    }
  }
  else
  {
    *(_BYTE *)a3 = 1;
    *(_QWORD *)(a3 + 8) = 0;
  }
}

uint64_t re::RaftLog::lastIndex(re::RaftLog *this)
{
  uint64_t v1;
  _QWORD v3[2];

  v1 = *((_QWORD *)this + 3);
  if (v1)
    return v1 + *((_QWORD *)this + 35) - 1;
  if (*((_BYTE *)this + 48))
    return *((_QWORD *)this + 33);
  (*(void (**)(_QWORD *__return_ptr))(**(_QWORD **)this + 40))(v3);
  return v3[1];
}

unint64_t re::RaftLog::findConflict(re::RaftLog *this, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v4;
  uint64_t v5;
  unint64_t v6;
  _BYTE v9[8];
  uint64_t v10;

  v2 = *(_QWORD *)(a2 + 16);
  if (!v2)
    return 0;
  v4 = (unint64_t *)(*(_QWORD *)(a2 + 32) + 88);
  v5 = 104 * v2;
  while (1)
  {
    v6 = v4[1];
    re::RaftLog::getTerm(this, *v4, (uint64_t)v9);
    if (!v9[0] || v10 != v6)
      break;
    v4 += 13;
    v5 -= 104;
    if (!v5)
      return 0;
  }
  re::RaftLog::lastIndex(this);
  return *v4;
}

void re::RaftLog::maybeAppend(re::RaftLog *a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v12;
  BOOL v13;
  unint64_t Conflict;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19[2];
  _BYTE v20[8];
  uint64_t v21;

  v12 = *(_QWORD *)(a5 + 16);
  re::RaftLog::getTerm(a1, a2, (uint64_t)v20);
  if (v20[0])
    v13 = v21 == a3;
  else
    v13 = 0;
  if (!v13)
  {
    *(_BYTE *)a6 = 0;
    return;
  }
  Conflict = re::RaftLog::findConflict(a1, a5);
  if (Conflict)
  {
    if (Conflict <= *((_QWORD *)a1 + 36))
    {
      re::internal::assertLog((re::internal *)6, v15, "assertion failure: '%s' (%s:line %i) %llu conflicts with committed entry %llu", "!\"Unreachable code\"", "maybeAppend", 80, Conflict, a4);
      _os_crash();
      __break(1u);
      return;
    }
    v19[0] = re::DynamicArray<re::Entry>::sliceRange(a5, Conflict + ~a2, *(_QWORD *)(a5 + 16));
    v19[1] = v16;
    re::DynamicArray<re::Entry>::DynamicArray((uint64_t)v20, v19);
    re::RaftLog::append(a1, (uint64_t)v20);
    re::DynamicArray<re::Entry>::deinit((uint64_t)v20);
  }
  v17 = v12 + a2;
  if (v17 >= a4)
    v18 = a4;
  else
    v18 = v17;
  re::RaftLog::commitTo(a1, v18);
  *(_BYTE *)a6 = 1;
  *(_QWORD *)(a6 + 8) = v17;
}

uint64_t re::RaftLog::append(re::RaftLog *this, uint64_t a2)
{
  unint64_t v3;
  uint64_t result;

  if (!*(_QWORD *)(a2 + 16))
    return re::RaftLog::lastIndex(this);
  v3 = *((_QWORD *)this + 36);
  if (*(_QWORD *)(*(_QWORD *)(a2 + 32) + 88) - 1 >= v3)
  {
    re::Unstable::truncateAndAppend((__n128 *)((char *)this + 8), a2);
    return re::RaftLog::lastIndex(this);
  }
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) after %llu is out of range [committed %lli]", "!\"Unreachable code\"", "append", 110, *(_QWORD *)(*(_QWORD *)(a2 + 32) + 88) - 1, v3);
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::DynamicArray<re::Entry>::sliceRange(uint64_t a1, unint64_t a2, unint64_t a3)
{
  unint64_t v3;

  v3 = *(_QWORD *)(a1 + 16) + 1;
  if (v3 <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_6;
  }
  if (a3 + 1 <= a2)
  {
LABEL_6:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_7:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (v3 <= a3)
    goto LABEL_7;
  return *(_QWORD *)(a1 + 32) + 104 * a2;
}

_QWORD *re::RaftLog::commitTo(_QWORD *this, unint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;

  if (this[36] < a2)
  {
    v3 = this;
    this = (_QWORD *)re::RaftLog::lastIndex((re::RaftLog *)this);
    if ((unint64_t)this < a2)
    {
      re::internal::assertLog((re::internal *)4, v4, "assertion failure: '%s' (%s:line %i) is out of range", "!\"Unreachable code\"", "commitTo", 123);
      this = (_QWORD *)_os_crash();
      __break(1u);
    }
    else
    {
      v3[36] = a2;
    }
  }
  return this;
}

uint64_t re::RaftLog::maybeCommit(re::RaftLog *this, unint64_t a2, uint64_t a3)
{
  uint64_t v6;
  _BYTE v8[8];
  uint64_t v9;

  if (*((_QWORD *)this + 36) >= a2)
    return 0;
  re::RaftLog::getTerm(this, a2, (uint64_t)v8);
  v6 = v8[0] ? v9 : 0;
  if (v6 != a3)
    return 0;
  re::RaftLog::commitTo(this, a2);
  return 1;
}

uint64_t re::RaftLog::appliedTo(uint64_t this, unint64_t a2)
{
  unint64_t v2;

  if (a2)
  {
    v2 = *(_QWORD *)(this + 288);
    if (v2 < a2 || *(_QWORD *)(this + 296) > a2)
    {
      re::internal::assertLog((re::internal *)7, a2, "assertion failure: '%s' (%s:line %i) applied(%llu) is out of range [prevApplied(%llu), committed(%llu)]", "!\"Unreachable code\"", "appliedTo", 137, a2, *(_QWORD *)(this + 296), v2);
      this = _os_crash();
      __break(1u);
    }
    else
    {
      *(_QWORD *)(this + 296) = a2;
    }
  }
  return this;
}

re::RaftLog *re::RaftLog::entries@<X0>(re::RaftLog *this@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t Index;
  uint64_t v8;
  __int128 v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  __int128 v13;
  int v14;
  uint64_t v15;

  Index = re::RaftLog::lastIndex(this);
  if (Index >= a2)
    return re::RaftLog::slice(this, a2, Index + 1, (__n128 *)a3);
  v11 = 0;
  v12 = 0;
  v8 = 0;
  v9 = 0u;
  v10 = 1;
  *(_BYTE *)a3 = 1;
  *(_OWORD *)(a3 + 8) = 0u;
  *(_QWORD *)(a3 + 24) = 0;
  v13 = 0u;
  *(_QWORD *)(a3 + 40) = 0;
  v15 = 0;
  v14 = 2;
  *(_DWORD *)(a3 + 32) = 1;
  re::DynamicArray<re::Entry>::deinit((uint64_t)&v12);
  return (re::RaftLog *)re::DynamicArray<re::Entry>::deinit((uint64_t)&v8);
}

re::RaftLog *re::RaftLog::slice@<X0>(re::RaftLog *this@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, __n128 *a4@<X8>)
{
  unint64_t v4;
  re::RaftLog *v5;
  unint64_t v6;
  unint64_t v8;
  char *v9;
  uint64_t v10;
  unsigned __int8 v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  __n128 *v16;
  __n128 *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  __int128 v22;
  unint64_t v23;
  unint64_t v24;
  __n128 v25;
  int v26;
  unint64_t v27;
  _BYTE v28[56];
  uint64_t v29;
  unint64_t v30;
  __n128 v31;
  int v32;
  unint64_t v33;
  __n128 v34;
  unint64_t v35;
  int v36;
  uint64_t v37;
  unsigned __int8 v38;
  char v39;

  if (a2 > a3)
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Invalid slice", "!\"Unreachable code\"", "mustCheckOutOfBounds", 244);
    _os_crash();
    __break(1u);
    goto LABEL_38;
  }
  v4 = a3;
  v6 = a2;
  v5 = this;
  if (*((_BYTE *)this + 48))
  {
    v8 = *((_QWORD *)this + 33) + 1;
  }
  else
  {
    this = (re::RaftLog *)(*(_QWORD *(**)(unint64_t *__return_ptr))(**(_QWORD **)this + 32))(&v24);
    v8 = v25.n128_u64[0];
  }
  if (v8 > v6)
  {
    v39 = 1;
    v9 = (char *)&v38;
    goto LABEL_9;
  }
  this = (re::RaftLog *)re::RaftLog::lastIndex(v5);
  if ((unint64_t)this + 1 < v4)
  {
LABEL_38:
    re::internal::assertLog((re::internal *)4, v10, "assertion failure: '%s' (%s:line %i) Slice out of bound", "!\"Unreachable code\"", "mustCheckOutOfBounds", 253);
    _os_crash();
    __break(1u);
LABEL_39:
    v23 = *((_QWORD *)v5 + 35);
    if (v23 >= v4)
      v23 = v4;
    re::internal::assertLog((re::internal *)6, v14, "assertion failure: '%s' (%s:line %i) entries[%llu:%llu] is unavailable from storage", "!\"Unreachable code\"", "slice", 209, v6, v23);
    _os_crash();
    __break(1u);
LABEL_42:
    re::internal::assertLog((re::internal *)5, v14, "assertion failure: '%s' (%s:line %i) Unexpected error %hhu", "!\"Unreachable code\"", "slice", 213, 2);
    _os_crash();
    __break(1u);
LABEL_43:
    re::internal::assertLog((re::internal *)5, v14, "assertion failure: '%s' (%s:line %i) Unexpected error %hhu", "!\"Unreachable code\"", "slice", 216, 3);
    _os_crash();
    __break(1u);
LABEL_44:
    re::internal::assertLog((re::internal *)5, v14, "assertion failure: '%s' (%s:line %i) Unexpected error %hhu", "!\"Unreachable code\"", "slice", 219, 4);
    _os_crash();
    __break(1u);
    JUMPOUT(0x225B9BE48);
  }
  v9 = &v39;
LABEL_9:
  *v9 = 0;
  if (v39)
  {
    v11 = v38;
    a4->n128_u8[0] = 0;
    a4->n128_u8[8] = v11;
    return this;
  }
  v37 = 0;
  v35 = 0;
  v34 = 0uLL;
  v36 = 0;
  if (v6 == v4)
    goto LABEL_33;
  v12 = *((_QWORD *)v5 + 35);
  if (v12 <= v6)
  {
LABEL_27:
    if (v12 < v4)
    {
      if (v12 > v6)
        v6 = v12;
      re::Unstable::mustCheckOutOfBounds((uint64_t)v5 + 8, v6, v4);
      v18 = re::DynamicArray<re::Entry>::sliceRange((uint64_t)v5 + 8, v6 - *((_QWORD *)v5 + 35), v4 - *((_QWORD *)v5 + 35));
      if (v19)
      {
        v20 = v18;
        v21 = v18 + 104 * v19;
        do
        {
          re::DynamicArray<BOOL>::DynamicArray((uint64_t)&v24, (uint64_t *)v20);
          re::DynamicArray<BOOL>::DynamicArray((uint64_t)v28, (uint64_t *)(v20 + 40));
          v22 = *(_OWORD *)(v20 + 80);
          v29 = *(_QWORD *)(v20 + 96);
          *(_OWORD *)&v28[40] = v22;
          re::DynamicArray<re::Entry>::add(&v34, (__n128 *)&v24);
          re::MeshCollectionHandles::~MeshCollectionHandles((re::MeshCollectionHandles *)&v24);
          v20 += 104;
        }
        while (v20 != v21);
      }
    }
LABEL_33:
    re::DynamicArray<re::Entry>::DynamicArray((__n128 *)&v24, v34.n128_u64);
    a4->n128_u8[0] = 1;
    a4->n128_u64[1] = v24;
    a4[1] = v25;
    v24 = 0;
    v25 = 0uLL;
    a4[2].n128_u64[1] = v27;
    v27 = 0;
    ++v26;
    a4[2].n128_u32[0] = 1;
    v17 = (__n128 *)&v24;
    goto LABEL_34;
  }
  if (v12 >= v4)
    v13 = v4;
  else
    v13 = *((_QWORD *)v5 + 35);
  (*(void (**)(unint64_t *__return_ptr, _QWORD, unint64_t, unint64_t))(**(_QWORD **)v5 + 24))(&v24, *(_QWORD *)v5, v6, v13);
  if (!(_BYTE)v24)
  {
    switch(v25.n128_u8[0])
    {
      case 0u:
        a4->n128_u8[0] = 0;
        a4->n128_u8[8] = 0;
        return (re::RaftLog *)re::DynamicArray<re::Entry>::deinit((uint64_t)&v34);
      case 1u:
        goto LABEL_39;
      case 2u:
        goto LABEL_42;
      case 3u:
        goto LABEL_43;
      case 4u:
        goto LABEL_44;
      default:
        break;
    }
  }
  re::DynamicArray<re::Entry>::operator=(&v34, &v25);
  v12 = *((_QWORD *)v5 + 35);
  if (v12 >= v4)
    v15 = v4;
  else
    v15 = *((_QWORD *)v5 + 35);
  if (v35 >= v15 - v6)
  {
    if ((_BYTE)v24)
    {
      re::DynamicArray<re::Entry>::deinit((uint64_t)&v25);
      v12 = *((_QWORD *)v5 + 35);
    }
    goto LABEL_27;
  }
  v16 = re::DynamicArray<re::Entry>::DynamicArray((__n128 *)&v30, v34.n128_u64);
  a4->n128_u8[0] = 1;
  a4->n128_u64[1] = v30;
  a4[1] = v31;
  v30 = 0;
  v31 = 0uLL;
  a4[2].n128_u64[1] = v33;
  v33 = 0;
  ++v32;
  a4[2].n128_u32[0] = 1;
  re::DynamicArray<re::Entry>::deinit((uint64_t)v16);
  if ((_BYTE)v24)
  {
    v17 = &v25;
LABEL_34:
    re::DynamicArray<re::Entry>::deinit((uint64_t)v17);
  }
  return (re::RaftLog *)re::DynamicArray<re::Entry>::deinit((uint64_t)&v34);
}

uint64_t re::RaftLog::lastTerm(re::RaftLog *this)
{
  unint64_t Index;
  uint64_t v3;
  uint64_t result;
  _BYTE v5[8];
  uint64_t v6;

  Index = re::RaftLog::lastIndex(this);
  re::RaftLog::getTerm(this, Index, (uint64_t)v5);
  if (v5[0])
    return v6;
  re::internal::assertLog((re::internal *)5, v3, "assertion failure: '%s' (%s:line %i) Unexpected error getting last term: %hhu", "!\"Unreachable code\"", "lastTerm", 271, v6);
  result = _os_crash();
  __break(1u);
  return result;
}

BOOL re::RaftLog::isUpToDate(re::RaftLog *this, unint64_t a2, unint64_t a3)
{
  if (re::RaftLog::lastTerm(this) < a3)
    return 1;
  if (re::RaftLog::lastTerm(this) == a3)
    return re::RaftLog::lastIndex(this) <= a2;
  return 0;
}

re::RaftLog *re::RaftLog::nextEntriesSince@<X0>(re::RaftLog *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  re::RaftLog *v3;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  __n128 v10[3];

  v3 = this;
  v5 = a2 + 1;
  if (*((_BYTE *)this + 48))
  {
    v6 = *((_QWORD *)this + 33) + 1;
  }
  else
  {
    this = (re::RaftLog *)(*(_QWORD *(**)(__n128 *__return_ptr))(**(_QWORD **)this + 32))(v10);
    v6 = v10[0].n128_u64[1];
  }
  if (v5 <= v6)
    v7 = v6;
  else
    v7 = v5;
  v8 = *((_QWORD *)v3 + 36) + 1;
  if (v8 <= v7)
  {
    *(_BYTE *)a3 = 0;
  }
  else
  {
    re::RaftLog::slice(v3, v7, v8, v10);
    if (v10[0].n128_u8[0])
    {
      *(_BYTE *)a3 = 1;
      this = (re::RaftLog *)re::DynamicArray<re::Entry>::DynamicArray((__n128 *)(a3 + 8), &v10[0].n128_u64[1]);
      if (v10[0].n128_u8[0])
        return (re::RaftLog *)re::DynamicArray<re::Entry>::deinit((uint64_t)&v10[0].n128_i64[1]);
    }
    else
    {
      re::internal::assertLog((re::internal *)5, v9, "assertion failure: '%s' (%s:line %i) %hhu", "!\"Unreachable code\"", "nextEntriesSince", 303, v10[0].n128_u8[8]);
      this = (re::RaftLog *)_os_crash();
      __break(1u);
    }
  }
  return this;
}

BOOL re::RaftLog::hasNextEntries(re::RaftLog *this)
{
  uint64_t v2;
  unint64_t v3;
  _QWORD v5[2];

  v2 = *((_QWORD *)this + 37);
  if (*((_BYTE *)this + 48))
  {
    v3 = *((_QWORD *)this + 33) + 1;
  }
  else
  {
    (*(void (**)(_QWORD *__return_ptr))(**(_QWORD **)this + 32))(v5);
    v3 = v5[1];
  }
  if (v2 + 1 > v3)
    v3 = v2 + 1;
  return *((_QWORD *)this + 36) + 1 > v3;
}

BOOL re::RaftLog::hasNextEntriesSince(re::RaftLog *this, uint64_t a2)
{
  unint64_t v4;
  _QWORD v6[2];

  if (*((_BYTE *)this + 48))
  {
    v4 = *((_QWORD *)this + 33) + 1;
  }
  else
  {
    (*(void (**)(_QWORD *__return_ptr))(**(_QWORD **)this + 32))(v6);
    v4 = v6[1];
  }
  if (a2 + 1 > v4)
    v4 = a2 + 1;
  return *((_QWORD *)this + 36) + 1 > v4;
}

void re::RaftLog::snapshot(re::RaftLog *this@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  _BYTE v6[169];
  _BYTE v7[40];
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _BYTE v11[56];
  uint64_t v12;
  _BYTE v13[8];
  uint64_t v14[5];
  uint64_t v15[5];
  uint64_t v16[5];
  uint64_t v17[5];
  uint64_t v18[5];
  __int128 v19;
  uint64_t v20;

  re::Optional<re::Snapshot>::Optional((uint64_t)v13, (uint64_t *)this + 6);
  if (!v13[0])
    goto LABEL_4;
  re::DynamicArray<BOOL>::DynamicArray((uint64_t)v7, v14);
  re::DynamicArray<char const*>::DynamicArray((uint64_t)&v8, v15);
  re::DynamicArray<char const*>::DynamicArray((uint64_t)&v9, v16);
  re::DynamicArray<char const*>::DynamicArray((uint64_t)&v10, v17);
  re::DynamicArray<char const*>::DynamicArray((uint64_t)v11, v18);
  *(_OWORD *)&v11[40] = v19;
  v12 = v20;
  if (*((_QWORD *)&v19 + 1) < a2)
  {
    re::Snapshot::~Snapshot((re::Snapshot *)v7);
LABEL_4:
    (*(void (**)(_QWORD, unint64_t))(**(_QWORD **)this + 48))(*(_QWORD *)this, a2);
    goto LABEL_6;
  }
  re::types::Ok<re::Snapshot>::Ok((uint64_t)v6, (uint64_t)v7);
  re::Result<re::Snapshot,re::StorageError>::Result(a3, (uint64_t)v6);
  re::Snapshot::~Snapshot((re::Snapshot *)v6);
  re::Snapshot::~Snapshot((re::Snapshot *)v7);
LABEL_6:
  if (v13[0])
    re::Snapshot::~Snapshot((re::Snapshot *)v14);
}

void re::RawNode::init(uint64_t a1@<X0>, uint64_t **a2@<X1>, uint64_t a3@<X8>)
{
  __int128 v4;
  char v5;
  uint64_t v6[145];
  __int128 v7;
  __int128 v8;
  uint64_t v9;
  _OWORD v10[18];
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  __int128 v19;
  __int128 v20;
  int v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  __int128 v26;
  __int128 v27;
  int v28;
  int v29;
  __int128 v30;
  char v31;
  char v32;
  char v33;
  char v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  _BYTE v41[21];
  __int128 v42;
  __int128 v43;
  uint64_t v44;
  _BYTE v45[8];
  _BYTE v46[1160];

  re::Raft::init(a1, a2, v45);
  if (v45[0])
  {
    v14 = 0u;
    v13 = 0u;
    v12 = 0u;
    v11 = 0u;
    memset(v10, 0, sizeof(v10));
    DWORD1(v14) = 0x7FFFFFFF;
    v17 = 0;
    v15 = 0;
    v16 = 0;
    v18 = 0;
    v19 = 0u;
    v20 = 0u;
    v21 = 0;
    v29 = 0;
    v24 = 0u;
    v25 = 0;
    v22 = 0u;
    v23 = 0u;
    v30 = 0u;
    HIDWORD(v24) = 0x7FFFFFFF;
    v28 = 0;
    v27 = 0u;
    v26 = 0u;
    v31 = 0;
    v32 = 0;
    v33 = 0;
    v34 = 0;
    memset(v41, 0, sizeof(v41));
    v40 = 0u;
    v39 = 0u;
    v38 = 0u;
    v37 = 0u;
    v36 = 0u;
    v35 = 0u;
    v42 = 0u;
    v43 = 0u;
    v44 = 0;
    re::Raft::operator=((uint64_t)v10, (uint64_t)v46);
    v43 = v35;
    v44 = v11;
    *(_QWORD *)&v42 = *((_QWORD *)&v36 + 1);
    BYTE8(v42) = v31;
    re::Raft::Raft((uint64_t)v6, (uint64_t *)v10);
    v7 = v42;
    v8 = v43;
    v9 = v44;
    *(_BYTE *)a3 = 1;
    re::Raft::Raft(a3 + 8, v6);
    v4 = v8;
    *(_OWORD *)(a3 + 1168) = v7;
    *(_OWORD *)(a3 + 1184) = v4;
    *(_QWORD *)(a3 + 1200) = v9;
    re::Raft::~Raft((re::Raft *)v6);
    re::Raft::~Raft((re::Raft *)v10);
    if (v45[0])
      re::Raft::~Raft((re::Raft *)v46);
  }
  else
  {
    v5 = v46[0];
    *(_BYTE *)a3 = 0;
    *(_BYTE *)(a3 + 8) = v5;
  }
}

uint64_t re::Raft::operator=(uint64_t a1, uint64_t a2)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;

  re::RaftLog::operator=((unsigned __int8 *)a1, (uint64_t *)a2);
  re::HashTable<unsigned long long,BOOL,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::operator=(a1 + 304, (uint64_t *)(a2 + 304));
  re::DynamicArray<re::ReadState>::operator=(a1 + 352, a2 + 352);
  re::DynamicArray<re::ReadState>::operator=(a1 + 392, a2 + 392);
  re::HashTable<re::DynamicArray<unsigned char>,re::ReadIndexStatus,re::Hash<re::DynamicArray<unsigned char>>,re::EqualTo<re::DynamicArray<unsigned char>>,true,false>::operator=(a1 + 432, (uint64_t *)(a2 + 432));
  re::Queue<re::DynamicArray<unsigned char>>::operator=((uint64_t *)(a1 + 480), (uint64_t *)(a2 + 480));
  *(_BYTE *)(a1 + 528) = *(_BYTE *)(a2 + 528);
  *(_BYTE *)(a1 + 536) = *(_BYTE *)(a2 + 536);
  re::Optional<re::ProgressSet>::operator=((_BYTE *)(a1 + 544), (uint64_t *)(a2 + 544));
  re::Optional<re::ConfChange>::operator=((_BYTE *)(a1 + 856), (unsigned __int8 *)(a2 + 856));
  if (*(_BYTE *)(a1 + 1024) || *(_BYTE *)(a2 + 1024))
  {
    if (!*(_BYTE *)(a1 + 1024) || *(_BYTE *)(a2 + 1024))
    {
      if (!*(_BYTE *)(a1 + 1024) && *(_BYTE *)(a2 + 1024))
        *(_BYTE *)(a1 + 1024) = 1;
      *(_QWORD *)(a1 + 1032) = *(_QWORD *)(a2 + 1032);
    }
    else
    {
      *(_BYTE *)(a1 + 1024) = 0;
    }
  }
  v4 = *(_OWORD *)(a2 + 1040);
  v5 = *(_OWORD *)(a2 + 1056);
  v6 = *(_OWORD *)(a2 + 1072);
  *(_OWORD *)(a1 + 1088) = *(_OWORD *)(a2 + 1088);
  *(_OWORD *)(a1 + 1072) = v6;
  *(_OWORD *)(a1 + 1056) = v5;
  *(_OWORD *)(a1 + 1040) = v4;
  v7 = *(_OWORD *)(a2 + 1104);
  v8 = *(_OWORD *)(a2 + 1120);
  v9 = *(_OWORD *)(a2 + 1136);
  *(_QWORD *)(a1 + 1149) = *(_QWORD *)(a2 + 1149);
  *(_OWORD *)(a1 + 1136) = v9;
  *(_OWORD *)(a1 + 1120) = v8;
  *(_OWORD *)(a1 + 1104) = v7;
  return a1;
}

void re::RawNode::commitReady(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  BOOL v5;
  __int128 v7;
  uint64_t v8;
  BOOL v9;
  _OWORD v10[14];

  if (*(_BYTE *)(a2 + 392))
  {
    v4 = *(_QWORD *)(a2 + 400);
    *(_BYTE *)(a1 + 1168) = *(_BYTE *)(a2 + 408);
    *(_QWORD *)(a1 + 1160) = v4;
  }
  if (*(_BYTE *)(a2 + 416))
  {
    v5 = !*(_QWORD *)(a2 + 424) && *(_QWORD *)(a2 + 432) == 0;
    if (!v5 || *(_QWORD *)(a2 + 440) != 0)
    {
      v7 = *(_OWORD *)(a2 + 424);
      *(_QWORD *)(a1 + 1192) = *(_QWORD *)(a2 + 440);
      *(_OWORD *)(a1 + 1176) = v7;
    }
  }
  v8 = *(_QWORD *)(a2 + 56);
  if (v8)
    re::Unstable::stableTo((re::Unstable *)(a1 + 8), *(_QWORD *)(*(_QWORD *)(a2 + 72) + 104 * v8 - 16), *(_QWORD *)(*(_QWORD *)(a2 + 72) + 104 * v8 - 8));
  memset(v10, 0, sizeof(v10));
  if (*(_QWORD *)(a2 + 136))
  {
    re::Snapshot::~Snapshot((re::Snapshot *)v10);
  }
  else
  {
    v9 = re::SnapshotMetadata::operator==((_QWORD *)(a2 + 160), (_QWORD *)&v10[2] + 1);
    re::Snapshot::~Snapshot((re::Snapshot *)v10);
    if (v9)
      goto LABEL_18;
  }
  re::Unstable::stableSnapTo((re::Unstable *)(a1 + 8), *(_QWORD *)(a2 + 328));
LABEL_18:
  if (*(_QWORD *)(a2 + 96))
    re::DynamicArray<re::ReadState>::clear((_QWORD *)(a1 + 352));
}

_QWORD *re::DynamicArray<re::ReadState>::clear(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;

  v1 = result;
  v2 = result[2];
  result[2] = 0;
  if (v2)
  {
    v3 = 48 * v2;
    v4 = (_QWORD *)(result[4] + 32);
    do
    {
      result = (_QWORD *)*(v4 - 4);
      if (result)
      {
        if (*v4)
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 40))(result);
        *v4 = 0;
        *(v4 - 3) = 0;
        *(v4 - 2) = 0;
        *(v4 - 4) = 0;
        ++*((_DWORD *)v4 - 2);
      }
      v4 += 6;
      v3 -= 48;
    }
    while (v3);
  }
  ++*((_DWORD *)v1 + 6);
  return result;
}

void re::DynamicArray<re::Entry>::add(__n128 *this, __n128 *a2)
{
  unint64_t v4;

  v4 = this[1].n128_u64[0];
  if (v4 >= this->n128_u64[1])
  {
    re::DynamicArray<re::Entry>::growCapacity(this, v4 + 1);
    v4 = this[1].n128_u64[0];
  }
  re::Entry::Entry((__n128 *)(this[2].n128_u64[0] + 104 * v4), a2);
  ++this[1].n128_u64[0];
  ++this[1].n128_u32[2];
}

uint64_t re::RawNode::hasReadySince(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  __n128 *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _BYTE v11[40];
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _BYTE v15[56];
  uint64_t v16;
  char v17[8];
  __n128 v18[2];
  uint64_t v19[5];
  uint64_t v20[5];
  uint64_t v21[5];
  uint64_t v22[5];
  __int128 v23;
  uint64_t v24;

  if (*(_QWORD *)(a1 + 408))
    return 1;
  if (*(_QWORD *)(a1 + 24))
  {
    v17[0] = 1;
    v6 = re::DynamicArray<re::Entry>::DynamicArray(v18, (unint64_t *)(a1 + 8));
    re::DynamicArray<re::Entry>::deinit((uint64_t)v6);
    return 1;
  }
  if (*(_QWORD *)(a1 + 368))
    return 1;
  re::Optional<re::Snapshot>::Optional((uint64_t)v17, (uint64_t *)(a1 + 48));
  if (v17[0])
  {
    re::DynamicArray<BOOL>::DynamicArray((uint64_t)v11, (uint64_t *)v18);
    re::DynamicArray<char const*>::DynamicArray((uint64_t)&v12, v19);
    re::DynamicArray<char const*>::DynamicArray((uint64_t)&v13, v20);
    re::DynamicArray<char const*>::DynamicArray((uint64_t)&v14, v21);
    re::DynamicArray<char const*>::DynamicArray((uint64_t)v15, v22);
    *(_OWORD *)&v15[40] = v23;
    v16 = v24;
    v7 = *((_QWORD *)&v23 + 1);
    re::Snapshot::~Snapshot((re::Snapshot *)v11);
    if (v7)
      goto LABEL_23;
  }
  if (*(_BYTE *)a2)
  {
    if (re::RaftLog::hasNextEntriesSince((re::RaftLog *)a1, *(_QWORD *)(a2 + 8)))
      goto LABEL_23;
  }
  else if (re::RaftLog::hasNextEntries((re::RaftLog *)a1))
  {
    goto LABEL_23;
  }
  if (*(_QWORD *)(a1 + 1064) == *(_QWORD *)(a1 + 1160)
    && *(unsigned __int8 *)(a1 + 536) == *(unsigned __int8 *)(a1 + 1168))
  {
    if ((v8 = *(_QWORD *)(a1 + 1040), v9 = *(_QWORD *)(a1 + 1048), v10 = *(_QWORD *)(a1 + 288), !v8) && !v9 && !v10
      || v8 == *(_QWORD *)(a1 + 1176) && v9 == *(_QWORD *)(a1 + 1184) && v10 == *(_QWORD *)(a1 + 1192))
    {
      v2 = 0;
      goto LABEL_24;
    }
  }
LABEL_23:
  v2 = 1;
LABEL_24:
  if (v17[0])
    re::Snapshot::~Snapshot((re::Snapshot *)v18);
  return v2;
}

void re::RawNode::advance(re::Raft *a1, uint64_t a2)
{
  unint64_t v3;

  re::RawNode::commitReady((uint64_t)a1, a2);
  v3 = *((_QWORD *)a1 + 149);
  if (v3)
    re::Raft::commitApply(a1, v3);
}

uint64_t re::HashTable<unsigned long long,BOOL,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::operator=(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    if (!*(_QWORD *)a1 || *(_QWORD *)a1 == *a2)
    {
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)a1, a2);
    }
    else if (*a2)
    {
      re::HashTable<unsigned long long,BOOL,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::copy(a1, (uint64_t)a2);
      ++*(_DWORD *)(a1 + 40);
    }
    else
    {
      re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::clear(a1);
    }
  }
  return a1;
}

uint64_t re::DynamicArray<re::ReadState>::operator=(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  BOOL v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (result != a2)
  {
    v2 = *(_QWORD *)result;
    v3 = *(_QWORD *)a2;
    if (*(_QWORD *)result)
      v4 = v3 == 0;
    else
      v4 = 1;
    if (v4 || v2 == v3)
    {
      v6 = *(_QWORD *)(result + 8);
      v7 = *(_QWORD *)(a2 + 8);
      *(_QWORD *)result = v3;
      *(_QWORD *)(result + 8) = v7;
      *(_QWORD *)a2 = v2;
      *(_QWORD *)(a2 + 8) = v6;
      v8 = *(_QWORD *)(result + 16);
      *(_QWORD *)(result + 16) = *(_QWORD *)(a2 + 16);
      *(_QWORD *)(a2 + 16) = v8;
      v9 = *(_QWORD *)(result + 32);
      *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
      *(_QWORD *)(a2 + 32) = v9;
      ++*(_DWORD *)(a2 + 24);
      ++*(_DWORD *)(result + 24);
    }
    else
    {
      re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) ", "!isInitialized() || !other.isInitialized() || m_allocator == other.m_allocator", "operator=", 503);
      result = _os_crash();
      __break(1u);
    }
  }
  return result;
}

void re::HashTable<unsigned long long,BOOL,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::copy(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t i;
  uint64_t *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;

  re::HashTable<unsigned long long,unsigned long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::clear(a1);
  v4 = *(_DWORD *)(a2 + 28);
  if (*(_DWORD *)(a1 + 24) < v4)
    re::HashTable<unsigned long long,BOOL,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, v4);
  v5 = *(unsigned int *)(a2 + 32);
  if ((_DWORD)v5)
  {
    v6 = 0;
    for (i = 0; i < v5; ++i)
    {
      v8 = (uint64_t *)(*(_QWORD *)(a2 + 16) + v6);
      if ((v8[1] & 0x80000000) != 0)
      {
        v9 = *v8;
        v10 = *(unsigned int *)(a1 + 24);
        v11 = *v8 % v10;
        v12 = *(unsigned int *)(a1 + 36);
        if ((_DWORD)v12 == 0x7FFFFFFF)
        {
          v12 = *(unsigned int *)(a1 + 32);
          v13 = v12;
          if ((_DWORD)v12 == (_DWORD)v10)
          {
            re::HashTable<unsigned long long,BOOL,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
            v11 = v9 % *(unsigned int *)(a1 + 24);
            v13 = *(_DWORD *)(a1 + 32);
          }
          *(_DWORD *)(a1 + 32) = v13 + 1;
          v14 = *(_QWORD *)(a1 + 16);
          v15 = *(_DWORD *)(v14 + 32 * v12 + 8);
        }
        else
        {
          v14 = *(_QWORD *)(a1 + 16);
          v15 = *(_DWORD *)(v14 + 32 * v12 + 8);
          *(_DWORD *)(a1 + 36) = v15 & 0x7FFFFFFF;
        }
        *(_DWORD *)(v14 + 32 * v12 + 8) = v15 | 0x80000000;
        v16 = *(_QWORD *)(a1 + 8);
        *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v12 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v12 + 8) & 0x80000000 | *(_DWORD *)(v16 + 4 * v11);
        *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v12) = v9;
        *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v12 + 16) = v8[2];
        *(_BYTE *)(*(_QWORD *)(a1 + 16) + 32 * v12 + 24) = *((_BYTE *)v8 + 24);
        *(_DWORD *)(v16 + 4 * v11) = v12;
        ++*(_DWORD *)(a1 + 28);
        v5 = *(unsigned int *)(a2 + 32);
      }
      v6 += 32;
    }
  }
}

BOOL re::SnapshotMetadata::operator==(_QWORD *a1, _QWORD *a2)
{
  _BOOL8 result;

  result = re::ConfState::operator==((uint64_t)a1, (uint64_t)a2);
  if (result)
  {
    result = re::ConfState::operator==((uint64_t)(a1 + 10), (uint64_t)(a2 + 10));
    if (result)
      return a1[20] == a2[20] && a1[21] == a2[21] && a1[22] == a2[22];
  }
  return result;
}

BOOL re::ConfState::operator==(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v5;

  v2 = *(_QWORD *)(a1 + 16);
  if (v2 == *(_QWORD *)(a2 + 16)
    && !memcmp(*(const void **)(a1 + 32), *(const void **)(a2 + 32), 8 * v2)
    && (v5 = *(_QWORD *)(a1 + 56), v5 == *(_QWORD *)(a2 + 56)))
  {
    return memcmp(*(const void **)(a1 + 72), *(const void **)(a2 + 72), 8 * v5) == 0;
  }
  else
  {
    return 0;
  }
}

_anonymous_namespace_ *re::ConfState::ConfState(_anonymous_namespace_ *this, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  int *v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  int *v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int v21;
  uint64_t v23;

  *((_DWORD *)this + 6) = 0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 9) = 0;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_DWORD *)this + 16) = 0;
  v6 = *(unsigned int *)(a2 + 32);
  if ((_DWORD)v6)
  {
    v7 = 0;
    v8 = (int *)(*(_QWORD *)(a2 + 16) + 8);
    while (1)
    {
      v9 = *v8;
      v8 += 6;
      if (v9 < 0)
        break;
      if (v6 == ++v7)
      {
        LODWORD(v7) = *(_DWORD *)(a2 + 32);
        break;
      }
    }
  }
  else
  {
    LODWORD(v7) = 0;
  }
  if ((_DWORD)v6 != (_DWORD)v7)
  {
    v10 = v7;
    v11 = *(_QWORD *)(a2 + 16);
    do
    {
      v23 = 0;
      v23 = *(_QWORD *)(v11 + 24 * v10 + 16);
      re::DynamicArray<re::TransitionCondition *>::add(this, &v23);
      v11 = *(_QWORD *)(a2 + 16);
      if (*(_DWORD *)(a2 + 32) <= (v7 + 1))
        v12 = v7 + 1;
      else
        v12 = *(_DWORD *)(a2 + 32);
      v13 = v7;
      while (1)
      {
        v10 = (v13 + 1);
        if (v12 - 1 == v13)
          break;
        ++v13;
        LODWORD(v7) = v10;
        if ((*(_DWORD *)(v11 + 24 * v10 + 8) & 0x80000000) != 0)
          goto LABEL_17;
      }
      LODWORD(v7) = v12;
LABEL_17:
      ;
    }
    while ((_DWORD)v6 != (_DWORD)v7);
  }
  v14 = *(unsigned int *)(a3 + 32);
  if ((_DWORD)v14)
  {
    v15 = 0;
    v16 = (int *)(*(_QWORD *)(a3 + 16) + 8);
    while (1)
    {
      v17 = *v16;
      v16 += 6;
      if (v17 < 0)
        break;
      if (v14 == ++v15)
      {
        LODWORD(v15) = *(_DWORD *)(a3 + 32);
        break;
      }
    }
  }
  else
  {
    LODWORD(v15) = 0;
  }
  if ((_DWORD)v14 != (_DWORD)v15)
  {
    v18 = v15;
    v19 = *(_QWORD *)(a3 + 16);
    do
    {
      v23 = 0;
      v23 = *(_QWORD *)(v19 + 24 * v18 + 16);
      re::DynamicArray<re::TransitionCondition *>::add((_QWORD *)this + 5, &v23);
      v19 = *(_QWORD *)(a3 + 16);
      if (*(_DWORD *)(a3 + 32) <= (v15 + 1))
        v20 = v15 + 1;
      else
        v20 = *(_DWORD *)(a3 + 32);
      v21 = v15;
      while (1)
      {
        v18 = (v21 + 1);
        if (v20 - 1 == v21)
          break;
        ++v21;
        LODWORD(v15) = v18;
        if ((*(_DWORD *)(v19 + 24 * v18 + 8) & 0x80000000) != 0)
          goto LABEL_34;
      }
      LODWORD(v15) = v20;
LABEL_34:
      ;
    }
    while ((_DWORD)v14 != (_DWORD)v15);
  }
  return this;
}

uint64_t re::Ready::Ready(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4, uint64_t a5)
{
  __n128 *v10;
  uint64_t v11;
  __n128 *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  _QWORD *v28;
  _QWORD v30[3];
  int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  unsigned __int8 v38[8];
  __n128 v39[2];

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  v10 = (__n128 *)(a1 + 40);
  v11 = a1 + 120;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_DWORD *)(a1 + 224) = 0;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_DWORD *)(a1 + 304) = 0;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_DWORD *)(a1 + 264) = 0;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_DWORD *)(a1 + 184) = 0;
  *(_BYTE *)(a1 + 392) = 0;
  *(_BYTE *)(a1 + 416) = 0;
  *(_BYTE *)(a1 + 448) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_DWORD *)(a1 + 104) = 0;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_DWORD *)(a1 + 144) = 0;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_OWORD *)(a1 + 328) = 0u;
  *(_BYTE *)(a1 + 344) = 0;
  if (*(_QWORD *)(a2 + 24))
  {
    v38[0] = 1;
    re::DynamicArray<re::Entry>::DynamicArray(v39, (unint64_t *)(a2 + 8));
    v37 = 0;
    v34 = 0;
    v35 = 0;
    v33 = 0;
    v12 = v39;
    v36 = 0;
  }
  else
  {
    v38[0] = 0;
    v37 = 0;
    v34 = 0;
    v35 = 0;
    v33 = 0;
    v36 = 0;
    v12 = (__n128 *)&v33;
  }
  re::DynamicArray<re::Entry>::operator=(v10, v12);
  re::DynamicArray<re::Entry>::deinit((uint64_t)&v33);
  if (v38[0])
    re::DynamicArray<re::Entry>::deinit((uint64_t)v39);
  if (*(_QWORD *)(a2 + 408))
  {
    v13 = *(_QWORD *)(a2 + 392);
    *(_QWORD *)(a2 + 392) = *(_QWORD *)a1;
    *(_QWORD *)a1 = v13;
    v14 = *(_QWORD *)(a2 + 400);
    *(_QWORD *)(a2 + 400) = *(_QWORD *)(a1 + 8);
    *(_QWORD *)(a1 + 8) = v14;
    v15 = *(_QWORD *)(a2 + 408);
    *(_QWORD *)(a2 + 408) = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v15;
    v16 = *(_QWORD *)(a2 + 424);
    *(_QWORD *)(a2 + 424) = *(_QWORD *)(a1 + 32);
    *(_QWORD *)(a1 + 32) = v16;
    ++*(_DWORD *)(a1 + 24);
    ++*(_DWORD *)(a2 + 416);
  }
  if (*(_BYTE *)a5)
    v17 = *(_QWORD *)(a5 + 8);
  else
    v17 = *(_QWORD *)(a2 + 296);
  re::RaftLog::nextEntriesSince((re::RaftLog *)a2, v17, (uint64_t)&v33);
  v32 = 0;
  memset(v30, 0, sizeof(v30));
  v31 = 0;
  if ((_BYTE)v33)
    v18 = (unint64_t *)&v34;
  else
    v18 = v30;
  v38[0] = 1;
  re::DynamicArray<re::Entry>::DynamicArray(v39, v18);
  re::Optional<re::DynamicArray<re::Entry>>::operator=((unsigned __int8 *)(a1 + 344), v38);
  if (v38[0])
    re::DynamicArray<re::Entry>::deinit((uint64_t)v39);
  re::DynamicArray<re::Entry>::deinit((uint64_t)v30);
  if ((_BYTE)v33)
    re::DynamicArray<re::Entry>::deinit((uint64_t)&v34);
  v19 = *(_QWORD *)(a2 + 1064);
  v20 = *(unsigned __int8 *)(a2 + 536);
  if (*(_QWORD *)a3 != v19 || *(unsigned __int8 *)(a3 + 8) != (_DWORD)v20)
  {
    if (*(_BYTE *)(a1 + 392))
    {
      *(_QWORD *)(a1 + 400) = v19;
      *(_BYTE *)(a1 + 408) = v20;
    }
    else
    {
      *(_BYTE *)(a1 + 392) = 1;
      *(_QWORD *)(a1 + 400) = v19;
      *(_QWORD *)(a1 + 408) = v20;
    }
  }
  v21 = *(_QWORD *)(a2 + 1040);
  v22 = *(_QWORD *)(a2 + 1048);
  v23 = *(_QWORD *)(a2 + 288);
  if (*a4 == v21 && a4[1] == v22)
  {
    if (a4[2] == v23)
      goto LABEL_31;
  }
  else
  {
    *(_BYTE *)(a1 + 448) = 1;
  }
  if (!*(_BYTE *)(a1 + 416))
    *(_BYTE *)(a1 + 416) = 1;
  *(_QWORD *)(a1 + 424) = v21;
  *(_QWORD *)(a1 + 432) = v22;
  *(_QWORD *)(a1 + 440) = v23;
LABEL_31:
  if (*(_BYTE *)(a2 + 48))
  {
    re::DynamicArray<BOOL>::operator=(v11, (uint64_t *)(a2 + 56));
    re::DynamicArray<unsigned long long>::operator=(a1 + 160, (uint64_t *)(a2 + 96));
    re::DynamicArray<unsigned long long>::operator=(a1 + 200, (uint64_t *)(a2 + 136));
    re::DynamicArray<unsigned long long>::operator=(a1 + 240, (uint64_t *)(a2 + 176));
    re::DynamicArray<unsigned long long>::operator=(a1 + 280, (uint64_t *)(a2 + 216));
    v24 = *(_QWORD *)(a2 + 272);
    *(_OWORD *)(a1 + 320) = *(_OWORD *)(a2 + 256);
    *(_QWORD *)(a1 + 336) = v24;
  }
  v25 = *(_QWORD *)(a2 + 368);
  if (v25)
  {
    v26 = (uint64_t *)(a2 + 352);
    if ((uint64_t *)(a1 + 80) != v26)
    {
      v27 = *v26;
      if (*(_QWORD *)(a1 + 80))
      {
        v28 = (_QWORD *)(a1 + 80);
        if (v27)
        {
          re::DynamicArray<re::ReadState>::copy(v28, (uint64_t)v26);
          ++*(_DWORD *)(a1 + 104);
        }
        else
        {
          re::DynamicArray<re::ReadState>::clear(v28);
        }
      }
      else if (v27)
      {
        *(_QWORD *)(a1 + 80) = v27;
        re::DynamicArray<re::ReadState>::setCapacity((_QWORD *)(a1 + 80), v25);
        ++*(_DWORD *)(a1 + 104);
        re::DynamicArray<re::ReadState>::copy((_QWORD *)(a1 + 80), (uint64_t)v26);
      }
    }
  }
  return a1;
}

unsigned __int8 *re::Optional<re::DynamicArray<re::Entry>>::operator=(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v3;
  int v4;
  BOOL v5;
  _QWORD *v6;
  BOOL v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v3 = *a1;
  v4 = *a2;
  if (*a1)
    v5 = 0;
  else
    v5 = v4 == 0;
  if (!v5)
  {
    v6 = a1 + 8;
    if (v3)
      v7 = v4 == 0;
    else
      v7 = 0;
    if (v7)
    {
      re::DynamicArray<re::Entry>::deinit((uint64_t)v6);
      *a1 = 0;
    }
    else
    {
      if (v3)
        v8 = 1;
      else
        v8 = v4 == 0;
      if (v8)
      {
        re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=((uint64_t)v6, (uint64_t)(a2 + 8));
      }
      else
      {
        *a1 = 1;
        *((_QWORD *)a1 + 5) = 0;
        *((_QWORD *)a1 + 2) = 0;
        *((_QWORD *)a1 + 3) = 0;
        *v6 = 0;
        *((_DWORD *)a1 + 8) = 0;
        v9 = *((_QWORD *)a2 + 2);
        *((_QWORD *)a1 + 1) = *((_QWORD *)a2 + 1);
        *((_QWORD *)a1 + 2) = v9;
        *((_QWORD *)a2 + 1) = 0;
        *((_QWORD *)a2 + 2) = 0;
        v10 = *((_QWORD *)a1 + 3);
        *((_QWORD *)a1 + 3) = *((_QWORD *)a2 + 3);
        *((_QWORD *)a2 + 3) = v10;
        v11 = *((_QWORD *)a1 + 5);
        *((_QWORD *)a1 + 5) = *((_QWORD *)a2 + 5);
        *((_QWORD *)a2 + 5) = v11;
        ++*((_DWORD *)a2 + 8);
        ++*((_DWORD *)a1 + 8);
      }
    }
  }
  return a1;
}

uint64_t re::DynamicArray<re::ReadState>::copy(_QWORD *a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;

  v4 = *(_QWORD *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<re::ReadState>::setCapacity(a1, *(_QWORD *)(a2 + 16));
    result = std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::ReadState *,re::ReadState *,re::ReadState *,0>(*(_QWORD *)(a2 + 32), (uint64_t *)(*(_QWORD *)(a2 + 32) + 48 * a1[2]), a1[4]);
    v9 = a1[2];
    if (v9 != v4)
    {
      v10 = 3 * v9;
      v11 = (uint64_t *)(*(_QWORD *)(a2 + 32) + 16 * v10);
      result = a1[4] + 16 * v10;
      v12 = 48 * v4 - 16 * v10;
      do
      {
        v13 = re::DynamicArray<BOOL>::DynamicArray(result, v11);
        *(_QWORD *)(v13 + 40) = v11[5];
        v11 += 6;
        result = v13 + 48;
        v12 -= 48;
      }
      while (v12);
    }
  }
  else
  {
    result = std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::ReadState *,re::ReadState *,re::ReadState *,0>(*(_QWORD *)(a2 + 32), (uint64_t *)(*(_QWORD *)(a2 + 32) + 48 * v4), a1[4]);
    v6 = a1[2];
    if (v4 != v6)
    {
      v7 = 48 * v6 - 48 * v4;
      v8 = (_QWORD *)(a1[4] + 48 * v4 + 32);
      do
      {
        result = *(v8 - 4);
        if (result)
        {
          if (*v8)
            result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
          *v8 = 0;
          *(v8 - 3) = 0;
          *(v8 - 2) = 0;
          *(v8 - 4) = 0;
          ++*((_DWORD *)v8 - 2);
        }
        v8 += 6;
        v7 -= 48;
      }
      while (v7);
    }
  }
  a1[2] = v4;
  return result;
}

uint64_t std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::ReadState *,re::ReadState *,re::ReadState *,0>(uint64_t result, uint64_t *a2, uint64_t a3)
{
  uint64_t *v5;

  if ((uint64_t *)result != a2)
  {
    v5 = (uint64_t *)result;
    do
    {
      result = re::DynamicArray<BOOL>::operator=(a3, v5);
      *(_QWORD *)(a3 + 40) = v5[5];
      v5 += 6;
      a3 += 48;
    }
    while (v5 != a2);
  }
  return result;
}

void re::ConsensusErrorCategoryImpl::~ConsensusErrorCategoryImpl(std::error_category *this)
{
  std::error_category::~error_category(this);
  JUMPOUT(0x2276933B8);
}

const char *re::ConsensusErrorCategoryImpl::name(re::ConsensusErrorCategoryImpl *this)
{
  return "Consensus error";
}

_QWORD *re::ConsensusErrorCategoryImpl::message@<X0>(unsigned __int8 a1@<W1>, _QWORD *a2@<X8>)
{
  char *v3;

  if (a1 > 0xFu)
    v3 = "Unknown ConsensusError error";
  else
    v3 = off_24ED7DF80[(char)a1];
  return std::string::basic_string[abi:nn180100]<0>(a2, v3);
}

void re::Unstable::maybeTerm(re::Unstable *this@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v6;
  unint64_t v7;
  char v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  _OWORD v13[5];
  _BYTE v14[40];
  uint64_t v15;
  __int128 v16;
  uint64_t v17;
  int v18;
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  unint64_t v23;
  __int16 v24;
  unint64_t v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v6 = *((_QWORD *)this + 34);
  v7 = a2 - v6;
  if (a2 < v6)
  {
    if (*((_BYTE *)this + 40))
    {
      re::DynamicArray<char const*>::DynamicArray((uint64_t)v13, (uint64_t *)this + 11);
      re::DynamicArray<char const*>::DynamicArray((uint64_t)&v13[2] + 8, (uint64_t *)this + 16);
      re::DynamicArray<char const*>::DynamicArray((uint64_t)v14, (uint64_t *)this + 21);
      re::DynamicArray<char const*>::DynamicArray((uint64_t)&v15, (uint64_t *)this + 26);
      v16 = *(_OWORD *)((char *)this + 248);
      v17 = *((_QWORD *)this + 33);
      if (*((_QWORD *)&v16 + 1) == a2)
      {
        *(_QWORD *)(a3 + 8) = v17;
        v8 = 1;
      }
      else
      {
        v8 = 0;
      }
      *(_BYTE *)a3 = v8;
      re::MeshCollectionHandles::~MeshCollectionHandles((re::MeshCollectionHandles *)v14);
      re::MeshCollectionHandles::~MeshCollectionHandles((re::MeshCollectionHandles *)v13);
      return;
    }
LABEL_10:
    *(_BYTE *)a3 = 0;
    return;
  }
  v9 = *((_QWORD *)this + 2);
  if (v9)
  {
    v10 = v6 + v9 - 1;
  }
  else
  {
    if (!*((_BYTE *)this + 40))
      goto LABEL_10;
    v10 = *((_QWORD *)this + 32);
  }
  if (v10 < a2)
    goto LABEL_10;
  if (v9 <= v7)
  {
    memset(v13, 0, sizeof(v13));
    v12 = v9;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v18 = 136315906;
    v19 = "operator[]";
    v20 = 1024;
    v21 = 797;
    v22 = 2048;
    v23 = v7;
    v24 = 2048;
    v25 = v12;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  v11 = *((_QWORD *)this + 4) + 104 * v7;
  *(_BYTE *)a3 = 1;
  *(_QWORD *)(a3 + 8) = *(_QWORD *)(v11 + 96);
}

void re::Unstable::stableTo(re::Unstable *this, unint64_t a2, uint64_t a3)
{
  BOOL v6;
  unint64_t v7;
  unint64_t v8;
  _BYTE v9[8];
  uint64_t v10;

  re::Unstable::maybeTerm(this, a2, (uint64_t)v9);
  if (v9[0])
    v6 = v10 == a3;
  else
    v6 = 0;
  if (v6)
  {
    v7 = *((_QWORD *)this + 34);
    if (v7 <= a2)
    {
      v8 = a2 + 1;
      re::DynamicArray<re::Entry>::removeManyStableAt((uint64_t)this, 0, v8 - v7);
      *((_QWORD *)this + 34) = v8;
    }
  }
}

void re::Unstable::stableSnapTo(re::Unstable *this, uint64_t a2)
{
  unsigned __int8 *v3;
  int v4;
  uint64_t v5;
  uint64_t v6;

  v4 = *((unsigned __int8 *)this + 40);
  v3 = (unsigned __int8 *)this + 40;
  if (v4 && *((_QWORD *)this + 32) == a2)
  {
    LOBYTE(v5) = 0;
    re::Optional<re::Snapshot>::operator=(v3, &v5);
    if ((_BYTE)v5)
      re::Snapshot::~Snapshot((re::Snapshot *)&v6);
  }
}

void re::Unstable::restore(re::Unstable *this, const re::Snapshot *a2)
{
  uint64_t v4;
  uint64_t v5;

  re::DynamicArray<re::Entry>::clear(this);
  *((_QWORD *)this + 34) = *((_QWORD *)a2 + 26) + 1;
  re::Result<re::Snapshot,re::StorageError>::Result((uint64_t)&v4, (uint64_t)a2);
  re::Optional<re::Snapshot>::operator=((unsigned __int8 *)this + 40, &v4);
  if ((_BYTE)v4)
    re::Snapshot::~Snapshot((re::Snapshot *)&v5);
}

uint64_t re::Unstable::mustCheckOutOfBounds(uint64_t this, unint64_t a2, unint64_t a3)
{
  unint64_t v3;
  unint64_t v4;

  if (a2 > a3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Invalid unstable.slice %llu > %llu", "!\"Unreachable code\"", "mustCheckOutOfBounds", 90, a2, a3);
    _os_crash();
    __break(1u);
LABEL_9:
    re::internal::assertLog((re::internal *)8, a2, "assertion failure: '%s' (%s:line %i) unstable.slice[%llu, %llu] out of bound[%llu, %llu]", "!\"Unreachable code\"", "mustCheckOutOfBounds", 96, a2, a3, v3, v4);
    this = _os_crash();
    __break(1u);
    return this;
  }
  v3 = *(_QWORD *)(this + 272);
  v4 = *(_QWORD *)(this + 16) + v3;
  if (v3 > a2 || v4 < a3)
    goto LABEL_9;
  return this;
}

__n128 *re::Unstable::truncateAndAppend(__n128 *this, uint64_t a2)
{
  re::Unstable *v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;

  v3 = (re::Unstable *)this;
  v4 = *(_QWORD *)(a2 + 32);
  v5 = *(_QWORD *)(v4 + 88);
  v6 = this[17].n128_u64[0];
  if (v5 == this[1].n128_u64[0] + v6)
  {
    v7 = *(_QWORD *)(a2 + 16);
    v8 = this[1].n128_u64[0];
    v9 = v4;
  }
  else
  {
    v10 = v5 - v6;
    if (v5 <= v6)
    {
      this[17].n128_u64[0] = v5;
      re::DynamicArray<re::Entry>::clear((re::MeshCollectionHandles *)this);
      v9 = *(_QWORD *)(a2 + 32);
      v7 = *(_QWORD *)(a2 + 16);
      this = (__n128 *)v3;
      v8 = 0;
    }
    else
    {
      re::Unstable::mustCheckOutOfBounds((uint64_t)this, v6, v5);
      re::DynamicArray<re::Entry>::resize((__n128 *)v3, v10);
      v8 = *((_QWORD *)v3 + 2);
      v9 = *(_QWORD *)(a2 + 32);
      v7 = *(_QWORD *)(a2 + 16);
      this = (__n128 *)v3;
    }
  }
  return re::DynamicArray<re::Entry>::copy(this, v8, v9, v7);
}

void re::DynamicArray<re::Entry>::resize(__n128 *a1, unint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;

  v4 = a1[1].n128_u64[0];
  if (v4 >= a2)
  {
    if (v4 <= a2)
      return;
    v8 = 104 * a2;
    v9 = a2;
    do
    {
      re::MeshCollectionHandles::~MeshCollectionHandles((re::MeshCollectionHandles *)(a1[2].n128_u64[0] + v8));
      ++v9;
      v8 += 104;
    }
    while (v9 < a1[1].n128_u64[0]);
  }
  else
  {
    if (a1->n128_u64[1] < a2)
    {
      re::DynamicArray<re::Entry>::setCapacity(a1, a2);
      v4 = a1[1].n128_u64[0];
    }
    v5 = a2 - v4;
    if (a2 > v4)
    {
      v6 = 104 * v4;
      do
      {
        v7 = a1[2].n128_u64[0] + v6;
        *(_QWORD *)(v7 + 96) = 0;
        *(_OWORD *)(v7 + 64) = 0uLL;
        *(_OWORD *)(v7 + 80) = 0uLL;
        *(_OWORD *)(v7 + 32) = 0uLL;
        *(_OWORD *)(v7 + 48) = 0uLL;
        *(_OWORD *)v7 = 0uLL;
        *(_OWORD *)(v7 + 16) = 0uLL;
        v6 += 104;
        --v5;
      }
      while (v5);
    }
  }
  a1[1].n128_u64[0] = a2;
  ++a1[1].n128_u32[2];
}

uint64_t re::ConsensusWriter::write(re::zerocopy ***a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;
  const Entry *v6;
  uint64_t v7;
  re::zerocopy **v8;
  char v9;

  result = re::OPackWriter::writeArrayBegin(*a1, *(_QWORD *)(a2 + 16));
  v5 = *(_QWORD *)(a2 + 16);
  if (v5)
  {
    v6 = *(const Entry **)(a2 + 32);
    v7 = 104 * v5;
    do
    {
      result = re::ConsensusWriter::write(a1, v6);
      v6 += 13;
      v7 -= 104;
    }
    while (v7);
    if (*(_QWORD *)(a2 + 16) >= 0xFuLL)
    {
      v8 = *a1;
      v9 = 3;
      return re::zerocopy::writeAll(*v8, (re::zerocopy::WriteStream *)&v9, (char *)1);
    }
  }
  return result;
}

{
  re::zerocopy **v4;
  re::zerocopy **v5;
  re::zerocopy **v6;
  re::zerocopy **v7;
  re::zerocopy **v8;
  re::zerocopy **v9;
  char v11;
  char v12;
  char v13;
  char v14;
  char v15;
  char v16;

  v4 = *a1;
  v11 = -27;
  re::zerocopy::writeAll(*v4, (re::zerocopy::WriteStream *)&v11, (char *)1);
  v5 = *a1;
  v12 = 8;
  re::zerocopy::writeAll(*v5, (re::zerocopy::WriteStream *)&v12, (char *)1);
  re::ConsensusWriter::write(a1, (unint64_t *)a2);
  v6 = *a1;
  v13 = 9;
  re::zerocopy::writeAll(*v6, (re::zerocopy::WriteStream *)&v13, (char *)1);
  re::ConsensusWriter::write(a1, (unint64_t *)(a2 + 80));
  v7 = *a1;
  v14 = 10;
  re::zerocopy::writeAll(*v7, (re::zerocopy::WriteStream *)&v14, (char *)1);
  re::OPackWriter::writeInteger(*a1, *(_QWORD *)(a2 + 160));
  v8 = *a1;
  v15 = 11;
  re::zerocopy::writeAll(*v8, (re::zerocopy::WriteStream *)&v15, (char *)1);
  re::OPackWriter::writeInteger(*a1, *(_QWORD *)(a2 + 168));
  v9 = *a1;
  v16 = 12;
  re::zerocopy::writeAll(*v9, (re::zerocopy::WriteStream *)&v16, (char *)1);
  return re::OPackWriter::writeInteger(*a1, *(_QWORD *)(a2 + 176));
}

uint64_t re::ConsensusWriter::write(re::zerocopy ***this, const Entry *a2)
{
  re::zerocopy **v4;
  re::zerocopy **v5;
  re::zerocopy **v6;
  re::zerocopy **v7;
  re::zerocopy **v8;
  re::zerocopy **v9;
  char v11;
  char v12;
  char v13;
  char v14;
  char v15;
  char v16;

  v4 = *this;
  v11 = -27;
  re::zerocopy::writeAll(*v4, (re::zerocopy::WriteStream *)&v11, (char *)1);
  v5 = *this;
  v12 = 8;
  re::zerocopy::writeAll(*v5, (re::zerocopy::WriteStream *)&v12, (char *)1);
  re::OPackWriter::writeData(*this, (re::zerocopy::WriteStream *)a2[4].withoutHash, (unint64_t)a2[2].withoutHash);
  v6 = *this;
  v13 = 9;
  re::zerocopy::writeAll(*v6, (re::zerocopy::WriteStream *)&v13, (char *)1);
  re::OPackWriter::writeData(*this, (re::zerocopy::WriteStream *)a2[9].withoutHash, (unint64_t)a2[7].withoutHash);
  v7 = *this;
  v14 = 10;
  re::zerocopy::writeAll(*v7, (re::zerocopy::WriteStream *)&v14, (char *)1);
  re::OPackWriter::writeInteger(*this, LOBYTE(a2[10].withoutHash));
  v8 = *this;
  v15 = 11;
  re::zerocopy::writeAll(*v8, (re::zerocopy::WriteStream *)&v15, (char *)1);
  re::OPackWriter::writeInteger(*this, (uint64_t)a2[11].withoutHash);
  v9 = *this;
  v16 = 12;
  re::zerocopy::writeAll(*v9, (re::zerocopy::WriteStream *)&v16, (char *)1);
  return re::OPackWriter::writeInteger(*this, (uint64_t)a2[12].withoutHash);
}

uint64_t re::ConsensusWriter::write(re::zerocopy ***a1, unint64_t *a2)
{
  re::zerocopy **v4;
  re::zerocopy **v5;
  unint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  re::zerocopy **v10;
  re::zerocopy **v11;
  uint64_t result;
  unint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  re::zerocopy **v17;
  char v18;
  char v19;
  char v20;
  char v21;
  char v22;

  v4 = *a1;
  v18 = -30;
  re::zerocopy::writeAll(*v4, (re::zerocopy::WriteStream *)&v18, (char *)1);
  v5 = *a1;
  v19 = 8;
  re::zerocopy::writeAll(*v5, (re::zerocopy::WriteStream *)&v19, (char *)1);
  re::OPackWriter::writeArrayBegin(*a1, a2[2]);
  v6 = a2[2];
  if (v6)
  {
    v7 = (uint64_t *)a2[4];
    v8 = 8 * v6;
    do
    {
      v9 = *v7++;
      re::OPackWriter::writeInteger(*a1, v9);
      v8 -= 8;
    }
    while (v8);
    if (a2[2] >= 0xF)
    {
      v10 = *a1;
      v20 = 3;
      re::zerocopy::writeAll(*v10, (re::zerocopy::WriteStream *)&v20, (char *)1);
    }
  }
  v11 = *a1;
  v21 = 9;
  re::zerocopy::writeAll(*v11, (re::zerocopy::WriteStream *)&v21, (char *)1);
  result = re::OPackWriter::writeArrayBegin(*a1, a2[7]);
  v13 = a2[7];
  if (v13)
  {
    v14 = (uint64_t *)a2[9];
    v15 = 8 * v13;
    do
    {
      v16 = *v14++;
      result = re::OPackWriter::writeInteger(*a1, v16);
      v15 -= 8;
    }
    while (v15);
    if (a2[7] >= 0xF)
    {
      v17 = *a1;
      v22 = 3;
      return re::zerocopy::writeAll(*v17, (re::zerocopy::WriteStream *)&v22, (char *)1);
    }
  }
  return result;
}

uint64_t re::ConsensusReader::read(re::OPackReader **a1, _QWORD *a2)
{
  re::OPackReader *v4;
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  int v8;
  re::OPackReader *v9;
  uint64_t v10;
  uint64_t v11;
  re::OPackReader *v12;
  uint64_t v13;
  uint64_t v14;
  re::OPackReader *v15;
  uint64_t v16;
  char v17;
  uint64_t v18;

  v4 = *a1;
  result = re::OPackReader::next(*a1, (uint64_t)a2);
  if ((_DWORD)result)
  {
    if (*((_BYTE *)v4 + 196) == 13)
    {
      v8 = re::OPackReader::next(*a1, v6);
      result = 1;
      if (v8)
      {
        while (1)
        {
          v9 = *a1;
          if (*((_BYTE *)*a1 + 184) == 5)
            break;
          if (*((_BYTE *)v9 + 196) != 6)
            return 0;
          if (*((_BYTE *)v9 + 224) == 1)
          {
            result = re::OPackReader::next(*a1, v7);
            if (!(_DWORD)result)
              return result;
            if (*((_BYTE *)v9 + 196) != 12)
              return 0;
            if (re::OPackReader::next(*a1, v14))
            {
              do
              {
                v15 = *a1;
                if (*((_BYTE *)*a1 + 184) == 3)
                  break;
                v18 = 0;
                *((_BYTE *)v15 + 2) = 1;
                if (re::OPackReader::next(v15, v11) && *((_BYTE *)v15 + 196) == 6)
                  v18 = *((_QWORD *)v15 + 28);
                re::DynamicArray<re::TransitionCondition *>::add(a2 + 5, &v18);
              }
              while ((re::OPackReader::next(*a1, v16) & 1) != 0);
            }
          }
          else
          {
            if (*((_BYTE *)v9 + 224))
              return 0;
            result = re::OPackReader::next(*a1, v7);
            if (!(_DWORD)result)
              return result;
            if (*((_BYTE *)v9 + 196) != 12)
              return 0;
            if (re::OPackReader::next(*a1, v10))
            {
              do
              {
                v12 = *a1;
                if (*((_BYTE *)*a1 + 184) == 3)
                  break;
                *((_BYTE *)v12 + 2) = 1;
                v18 = 0;
                if (re::OPackReader::next(v12, v11))
                {
                  if (*((_BYTE *)v12 + 196) == 6)
                    v18 = *((_QWORD *)v12 + 28);
                }
                re::DynamicArray<re::TransitionCondition *>::add(a2, &v18);
              }
              while ((re::OPackReader::next(*a1, v13) & 1) != 0);
            }
          }
          v17 = re::OPackReader::next(*a1, v11);
          result = 1;
          if ((v17 & 1) == 0)
            return result;
        }
        return 1;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t re::ConsensusWriter::write(re::zerocopy ***this, const re::Message *a2)
{
  re::zerocopy **v4;
  re::zerocopy **v5;
  re::zerocopy **v6;
  re::zerocopy **v7;
  re::zerocopy **v8;
  re::zerocopy **v9;
  re::zerocopy **v10;
  re::zerocopy **v11;
  re::zerocopy **v12;
  re::zerocopy **v13;
  re::zerocopy **v14;
  re::zerocopy **v15;
  re::zerocopy **v16;
  re::zerocopy **v17;
  re::zerocopy **v18;
  char v19;
  char v21;
  char v22;
  char v23;
  char v24;
  char v25;
  char v26;
  char v27;
  char v28;
  char v29;
  char v30;
  char v31;
  char v32;
  char v33;
  char v34;
  char v35;

  v4 = *this;
  v21 = -19;
  re::zerocopy::writeAll(*v4, (re::zerocopy::WriteStream *)&v21, (char *)1);
  v5 = *this;
  v22 = 8;
  re::zerocopy::writeAll(*v5, (re::zerocopy::WriteStream *)&v22, (char *)1);
  re::ConsensusWriter::write(this, (uint64_t)a2);
  v6 = *this;
  v23 = 9;
  re::zerocopy::writeAll(*v6, (re::zerocopy::WriteStream *)&v23, (char *)1);
  re::OPackWriter::writeData(*this, *((re::zerocopy::WriteStream **)a2 + 9), *((_QWORD *)a2 + 7));
  v7 = *this;
  v24 = 10;
  re::zerocopy::writeAll(*v7, (re::zerocopy::WriteStream *)&v24, (char *)1);
  re::ConsensusWriter::write(this, (const re::Message *)((char *)a2 + 80));
  v8 = *this;
  v25 = 11;
  re::zerocopy::writeAll(*v8, (re::zerocopy::WriteStream *)&v25, (char *)1);
  re::OPackWriter::writeInteger(*this, *((unsigned __int8 *)a2 + 304));
  v9 = *this;
  v26 = 12;
  re::zerocopy::writeAll(*v9, (re::zerocopy::WriteStream *)&v26, (char *)1);
  re::OPackWriter::writeInteger(*this, *((_QWORD *)a2 + 39));
  v10 = *this;
  v27 = 13;
  re::zerocopy::writeAll(*v10, (re::zerocopy::WriteStream *)&v27, (char *)1);
  re::OPackWriter::writeInteger(*this, *((_QWORD *)a2 + 40));
  v11 = *this;
  v28 = 14;
  re::zerocopy::writeAll(*v11, (re::zerocopy::WriteStream *)&v28, (char *)1);
  re::OPackWriter::writeInteger(*this, *((_QWORD *)a2 + 41));
  v12 = *this;
  v29 = 15;
  re::zerocopy::writeAll(*v12, (re::zerocopy::WriteStream *)&v29, (char *)1);
  re::OPackWriter::writeInteger(*this, *((_QWORD *)a2 + 42));
  v13 = *this;
  v30 = 16;
  re::zerocopy::writeAll(*v13, (re::zerocopy::WriteStream *)&v30, (char *)1);
  re::OPackWriter::writeInteger(*this, *((_QWORD *)a2 + 43));
  v14 = *this;
  v31 = 17;
  re::zerocopy::writeAll(*v14, (re::zerocopy::WriteStream *)&v31, (char *)1);
  re::OPackWriter::writeInteger(*this, *((_QWORD *)a2 + 44));
  v15 = *this;
  v32 = 18;
  re::zerocopy::writeAll(*v15, (re::zerocopy::WriteStream *)&v32, (char *)1);
  re::OPackWriter::writeInteger(*this, *((_QWORD *)a2 + 45));
  v16 = *this;
  v33 = 19;
  re::zerocopy::writeAll(*v16, (re::zerocopy::WriteStream *)&v33, (char *)1);
  re::OPackWriter::writeInteger(*this, *((_QWORD *)a2 + 46));
  v17 = *this;
  v34 = 20;
  re::zerocopy::writeAll(*v17, (re::zerocopy::WriteStream *)&v34, (char *)1);
  v18 = *this;
  if (*((_BYTE *)a2 + 376))
    v19 = 1;
  else
    v19 = 2;
  v35 = v19;
  return re::zerocopy::writeAll(*v18, (re::zerocopy::WriteStream *)&v35, (char *)1);
}

uint64_t re::ConsensusWriter::write(re::zerocopy ***this, const re::Snapshot *a2)
{
  re::zerocopy **v4;
  re::zerocopy **v5;
  re::zerocopy **v6;
  char v8;
  char v9;
  char v10;

  v4 = *this;
  v8 = -30;
  re::zerocopy::writeAll(*v4, (re::zerocopy::WriteStream *)&v8, (char *)1);
  v5 = *this;
  v9 = 8;
  re::zerocopy::writeAll(*v5, (re::zerocopy::WriteStream *)&v9, (char *)1);
  re::OPackWriter::writeData(*this, *((re::zerocopy::WriteStream **)a2 + 4), *((_QWORD *)a2 + 2));
  v6 = *this;
  v10 = 9;
  re::zerocopy::writeAll(*v6, (re::zerocopy::WriteStream *)&v10, (char *)1);
  return re::ConsensusWriter::write(this, (uint64_t)a2 + 40);
}

uint64_t re::ConsensusReader::read(re::OPackReader **this, __n128 *a2)
{
  uint64_t v2;
  re::OPackReader *v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  int v9;
  unint64_t *v10;
  __n128 *v11;
  __int8 *v12;
  __int8 *v13;
  re::OPackReader *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  __int8 *v18;
  __int8 *v19;
  __n128 *v20;
  re::OPackReader *v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  re::OPackReader *v28;
  char *v29;
  size_t v30;
  _QWORD *v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD *v34;
  uint64_t v35;
  re::OPackReader *v36;
  uint64_t v37;
  uint64_t v38;
  re::OPackReader *v39;
  re::OPackReader **v40;
  unint64_t *v41;
  uint64_t v42;
  int v43;
  unint64_t *v44;
  char v45;
  unint64_t *v46;
  __n128 *v47;
  __n128 v48[6];
  uint64_t v49;

  v5 = *this;
  result = re::OPackReader::next(*this, (uint64_t)a2);
  if ((_DWORD)result)
  {
    if (*((_BYTE *)v5 + 196) == 13)
    {
      v9 = re::OPackReader::next(*this, v7);
      result = 1;
      if (v9)
      {
        v10 = &a2[2].n128_u64[1];
        v47 = a2 + 5;
        v11 = a2 + 18;
        v12 = &a2[17].n128_i8[8];
        v13 = &a2[12].n128_i8[8];
        while (1)
        {
          v14 = *this;
          if (*((_BYTE *)*this + 184) == 5)
            return 1;
          if (*((_BYTE *)v14 + 196) != 6)
            return 0;
          switch(*((_BYTE *)v14 + 224))
          {
            case 0:
              result = re::OPackReader::next(*this, v8);
              if (!(_DWORD)result)
                return result;
              if (*((_BYTE *)v14 + 196) != 12)
                return 0;
              if (!re::OPackReader::next(*this, v15))
                goto LABEL_104;
              v46 = v10;
              while (2)
              {
                if (*((_BYTE *)*this + 184) == 3)
                  goto LABEL_104;
                v17 = v2;
                v18 = v13;
                v19 = v12;
                v20 = v11;
                v49 = 0;
                memset(v48, 0, sizeof(v48));
                re::DynamicArray<re::Entry>::add(a2, v48);
                re::MeshCollectionHandles::~MeshCollectionHandles((re::MeshCollectionHandles *)v48);
                v21 = *this;
                *((_BYTE *)v21 + 2) = 1;
                v22 = a2[2].n128_u64[0];
                v23 = a2[1].n128_u64[0];
                result = re::OPackReader::next(v21, v24);
                if (!(_DWORD)result)
                  return result;
                if (*((_BYTE *)v21 + 196) == 13)
                {
                  if (!re::OPackReader::next(*this, v25))
                    goto LABEL_38;
                  v27 = v22 + 104 * (v23 - 1);
LABEL_17:
                  v28 = *this;
                  if (*((_BYTE *)*this + 184) == 5)
                  {
LABEL_38:
                    v10 = v46;
                    v11 = v20;
                    v12 = v19;
                    v13 = v18;
                    v2 = v17;
                    if ((re::OPackReader::next(*this, v26) & 1) == 0)
                      goto LABEL_104;
                    continue;
                  }
                  if (*((_BYTE *)v28 + 196) == 6)
                  {
                    switch(*((_BYTE *)v28 + 224))
                    {
                      case 0:
                        result = re::OPackReader::next(*this, v26);
                        if (!(_DWORD)result)
                          return result;
                        if (*((_BYTE *)v28 + 196) != 11)
                          return 0;
                        re::DynamicArray<BOOL>::resize(v27, *((_QWORD *)*this + 27));
                        v29 = (char *)*((_QWORD *)*this + 26);
                        v30 = *((_QWORD *)*this + 27);
                        v31 = (_QWORD *)v27;
                        goto LABEL_26;
                      case 1:
                        result = re::OPackReader::next(*this, v26);
                        if (!(_DWORD)result)
                          return result;
                        if (*((_BYTE *)v28 + 196) != 11)
                          return 0;
                        re::DynamicArray<BOOL>::resize(v27 + 40, *((_QWORD *)*this + 27));
                        v29 = (char *)*((_QWORD *)*this + 26);
                        v30 = *((_QWORD *)*this + 27);
                        v31 = (_QWORD *)(v27 + 40);
LABEL_26:
                        re::DynamicArray<REFrameAnalysisBottleneck>::copy(v31, 0, v29, v30);
                        goto LABEL_37;
                      case 2:
                        result = re::OPackReader::next(*this, v26);
                        if (!(_DWORD)result)
                          return result;
                        if (*((_BYTE *)v28 + 196) != 6)
                          return 0;
                        *(_BYTE *)(v27 + 80) = *((_QWORD *)v28 + 28);
                        goto LABEL_37;
                      case 3:
                        result = re::OPackReader::next(*this, v26);
                        if (!(_DWORD)result)
                          return result;
                        if (*((_BYTE *)v28 + 196) != 6)
                          return 0;
                        v33 = *((_QWORD *)v28 + 28);
                        v34 = (_QWORD *)(v27 + 88);
                        goto LABEL_36;
                      case 4:
                        result = re::OPackReader::next(*this, v26);
                        if (!(_DWORD)result)
                          return result;
                        if (*((_BYTE *)v28 + 196) != 6)
                          return 0;
                        v33 = *((_QWORD *)v28 + 28);
                        v34 = (_QWORD *)(v27 + 96);
LABEL_36:
                        *v34 = v33;
LABEL_37:
                        if ((re::OPackReader::next(*this, v32) & 1) == 0)
                          goto LABEL_38;
                        goto LABEL_17;
                      default:
                        return 0;
                    }
                  }
                }
                return 0;
              }
            case 1:
              result = re::OPackReader::next(*this, v8);
              if (!(_DWORD)result)
                return result;
              if (*((_BYTE *)v14 + 196) != 11)
                return 0;
              re::DynamicArray<BOOL>::resize((uint64_t)v10, *((_QWORD *)*this + 27));
              re::DynamicArray<REFrameAnalysisBottleneck>::copy(v10, 0, *((char **)*this + 26), *((_QWORD *)*this + 27));
              goto LABEL_104;
            case 2:
              result = re::OPackReader::next(*this, v8);
              if (!(_DWORD)result)
                return result;
              if (*((_BYTE *)v14 + 196) != 13)
                return 0;
              if (!re::OPackReader::next(*this, v35))
                goto LABEL_104;
              break;
            case 3:
              result = re::OPackReader::next(*this, v8);
              if (!(_DWORD)result)
                return result;
              if (*((_BYTE *)v14 + 196) != 6)
                return 0;
              a2[19].n128_u8[0] = *((_QWORD *)v14 + 28);
              goto LABEL_104;
            case 4:
              result = re::OPackReader::next(*this, v8);
              if (!(_DWORD)result)
                return result;
              if (*((_BYTE *)v14 + 196) != 6)
                return 0;
              a2[19].n128_u64[1] = *((_QWORD *)v14 + 28);
              goto LABEL_104;
            case 5:
              result = re::OPackReader::next(*this, v8);
              if (!(_DWORD)result)
                return result;
              if (*((_BYTE *)v14 + 196) != 6)
                return 0;
              a2[20].n128_u64[0] = *((_QWORD *)v14 + 28);
              goto LABEL_104;
            case 6:
              result = re::OPackReader::next(*this, v8);
              if (!(_DWORD)result)
                return result;
              if (*((_BYTE *)v14 + 196) != 6)
                return 0;
              a2[20].n128_u64[1] = *((_QWORD *)v14 + 28);
              goto LABEL_104;
            case 7:
              result = re::OPackReader::next(*this, v8);
              if (!(_DWORD)result)
                return result;
              if (*((_BYTE *)v14 + 196) != 6)
                return 0;
              a2[21].n128_u64[0] = *((_QWORD *)v14 + 28);
              goto LABEL_104;
            case 8:
              result = re::OPackReader::next(*this, v8);
              if (!(_DWORD)result)
                return result;
              if (*((_BYTE *)v14 + 196) != 6)
                return 0;
              a2[21].n128_u64[1] = *((_QWORD *)v14 + 28);
              goto LABEL_104;
            case 9:
              result = re::OPackReader::next(*this, v8);
              if (!(_DWORD)result)
                return result;
              if (*((_BYTE *)v14 + 196) != 6)
                return 0;
              a2[22].n128_u64[0] = *((_QWORD *)v14 + 28);
              goto LABEL_104;
            case 0xA:
              result = re::OPackReader::next(*this, v8);
              if (!(_DWORD)result)
                return result;
              if (*((_BYTE *)v14 + 196) != 6)
                return 0;
              a2[22].n128_u64[1] = *((_QWORD *)v14 + 28);
              goto LABEL_104;
            case 0xB:
              result = re::OPackReader::next(*this, v8);
              if (!(_DWORD)result)
                return result;
              if (*((_BYTE *)v14 + 196) != 6)
                return 0;
              a2[23].n128_u64[0] = *((_QWORD *)v14 + 28);
              goto LABEL_104;
            case 0xC:
              result = re::OPackReader::next(*this, v8);
              if (!(_DWORD)result)
                return result;
              if (*((_BYTE *)v14 + 196) != 2)
                return 0;
              a2[23].n128_u8[8] = *((_BYTE *)*this + 224);
              goto LABEL_104;
            default:
              return 0;
          }
          do
          {
            v36 = *this;
            if (*((_BYTE *)*this + 184) == 5)
              break;
            if (*((_BYTE *)v36 + 196) != 6)
              return 0;
            if (*((_BYTE *)v36 + 224) == 1)
            {
              result = re::OPackReader::next(*this, v16);
              if (!(_DWORD)result)
                return result;
              if (*((_BYTE *)v36 + 196) != 13)
                return 0;
              if (re::OPackReader::next(*this, v38))
              {
                do
                {
                  v39 = *this;
                  if (*((_BYTE *)*this + 184) == 5)
                    break;
                  if (*((_BYTE *)v39 + 196) != 6)
                    return 0;
                  switch(*((_BYTE *)v39 + 224))
                  {
                    case 0:
                      v40 = this;
                      v41 = &a2[7].n128_u64[1];
                      goto LABEL_61;
                    case 1:
                      v40 = this;
                      v41 = (unint64_t *)v13;
LABEL_61:
                      if ((re::ConsensusReader::read(v40, v41) & 1) == 0)
                        return 0;
                      continue;
                    case 2:
                      result = re::OPackReader::next(*this, v37);
                      if (!(_DWORD)result)
                        return result;
                      v43 = *((unsigned __int8 *)v39 + 196);
                      v44 = (unint64_t *)v12;
                      break;
                    case 3:
                      result = re::OPackReader::next(*this, v37);
                      if (!(_DWORD)result)
                        return result;
                      v43 = *((unsigned __int8 *)v39 + 196);
                      v44 = (unint64_t *)v11;
                      break;
                    case 4:
                      result = re::OPackReader::next(*this, v37);
                      if (!(_DWORD)result)
                        return result;
                      v43 = *((unsigned __int8 *)v39 + 196);
                      v44 = &a2[18].n128_u64[1];
                      break;
                    default:
                      return 0;
                  }
                  if (v43 != 6)
                    return 0;
                  *v44 = *((_QWORD *)v39 + 28);
                }
                while ((re::OPackReader::next(*this, v42) & 1) != 0);
              }
            }
            else
            {
              if (*((_BYTE *)v36 + 224))
                return 0;
              result = re::OPackReader::next(*this, v16);
              if (!(_DWORD)result)
                return result;
              if (*((_BYTE *)v36 + 196) != 11)
                return 0;
              re::DynamicArray<BOOL>::resize((uint64_t)v47, *((_QWORD *)*this + 27));
              re::DynamicArray<REFrameAnalysisBottleneck>::copy(v47, 0, *((char **)*this + 26), *((_QWORD *)*this + 27));
            }
          }
          while ((re::OPackReader::next(*this, v37) & 1) != 0);
LABEL_104:
          v45 = re::OPackReader::next(*this, v16);
          result = 1;
          if ((v45 & 1) == 0)
            return result;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t re::ConsensusWriter::write(re::zerocopy ***this, const re::ConfChange *a2)
{
  re::zerocopy **v4;
  re::zerocopy **v5;
  re::zerocopy **v6;
  re::zerocopy **v7;
  re::zerocopy **v8;
  re::zerocopy **v9;
  re::zerocopy **v10;
  re::zerocopy **v11;
  re::zerocopy **v12;
  char v13;
  char v15;
  char v16;
  char v17;
  char v18;
  char v19;
  char v20;
  char v21;
  char v22;
  char v23;

  v4 = *this;
  v15 = -25;
  re::zerocopy::writeAll(*v4, (re::zerocopy::WriteStream *)&v15, (char *)1);
  v5 = *this;
  v16 = 8;
  re::zerocopy::writeAll(*v5, (re::zerocopy::WriteStream *)&v16, (char *)1);
  re::OPackWriter::writeData(*this, *((re::zerocopy::WriteStream **)a2 + 4), *((_QWORD *)a2 + 2));
  v6 = *this;
  v17 = 9;
  re::zerocopy::writeAll(*v6, (re::zerocopy::WriteStream *)&v17, (char *)1);
  re::ConsensusWriter::write(this, (unint64_t *)a2 + 5);
  v7 = *this;
  v18 = 10;
  re::zerocopy::writeAll(*v7, (re::zerocopy::WriteStream *)&v18, (char *)1);
  re::OPackWriter::writeInteger(*this, *((unsigned __int8 *)a2 + 120));
  v8 = *this;
  v19 = 11;
  re::zerocopy::writeAll(*v8, (re::zerocopy::WriteStream *)&v19, (char *)1);
  re::OPackWriter::writeInteger(*this, *((_QWORD *)a2 + 16));
  v9 = *this;
  v20 = 12;
  re::zerocopy::writeAll(*v9, (re::zerocopy::WriteStream *)&v20, (char *)1);
  re::OPackWriter::writeInteger(*this, *((_QWORD *)a2 + 17));
  v10 = *this;
  v21 = 13;
  re::zerocopy::writeAll(*v10, (re::zerocopy::WriteStream *)&v21, (char *)1);
  re::OPackWriter::writeInteger(*this, *((_QWORD *)a2 + 18));
  v11 = *this;
  v22 = 14;
  re::zerocopy::writeAll(*v11, (re::zerocopy::WriteStream *)&v22, (char *)1);
  v12 = *this;
  if (*((_BYTE *)a2 + 152))
    v13 = 1;
  else
    v13 = 2;
  v23 = v13;
  return re::zerocopy::writeAll(*v12, (re::zerocopy::WriteStream *)&v23, (char *)1);
}

uint64_t re::ConsensusReader::read(re::OPackReader **this, re::ConfChange *a2)
{
  re::OPackReader *v4;
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  re::OPackReader *v8;
  uint64_t v9;
  char v10;

  v4 = *this;
  result = re::OPackReader::next(*this, (uint64_t)a2);
  if ((_DWORD)result)
  {
    if (*((_BYTE *)v4 + 196) == 13)
    {
      if (re::OPackReader::next(*this, v6))
      {
        while (1)
        {
          v8 = *this;
          if (*((_BYTE *)*this + 184) == 5)
            break;
          if (*((_BYTE *)v8 + 196) != 6)
            return 0;
          switch(*((_BYTE *)v8 + 224))
          {
            case 0:
              result = re::OPackReader::next(*this, v7);
              if (!(_DWORD)result)
                return result;
              if (*((_BYTE *)v8 + 196) != 11)
                return 0;
              re::DynamicArray<BOOL>::resize((uint64_t)a2, *((_QWORD *)*this + 27));
              re::DynamicArray<REFrameAnalysisBottleneck>::copy(a2, 0, *((char **)*this + 26), *((_QWORD *)*this + 27));
              break;
            case 1:
              if ((re::ConsensusReader::read(this, (_QWORD *)a2 + 5) & 1) == 0)
                return 0;
              break;
            case 2:
              result = re::OPackReader::next(*this, v7);
              if (!(_DWORD)result)
                return result;
              if (*((_BYTE *)v8 + 196) != 6)
                return 0;
              *((_BYTE *)a2 + 120) = *((_QWORD *)v8 + 28);
              break;
            case 3:
              result = re::OPackReader::next(*this, v7);
              if (!(_DWORD)result)
                return result;
              if (*((_BYTE *)v8 + 196) != 6)
                return 0;
              *((_QWORD *)a2 + 16) = *((_QWORD *)v8 + 28);
              break;
            case 4:
              result = re::OPackReader::next(*this, v7);
              if (!(_DWORD)result)
                return result;
              if (*((_BYTE *)v8 + 196) != 6)
                return 0;
              *((_QWORD *)a2 + 17) = *((_QWORD *)v8 + 28);
              break;
            case 5:
              result = re::OPackReader::next(*this, v7);
              if (!(_DWORD)result)
                return result;
              if (*((_BYTE *)v8 + 196) != 6)
                return 0;
              *((_QWORD *)a2 + 18) = *((_QWORD *)v8 + 28);
              break;
            case 6:
              result = re::OPackReader::next(*this, v7);
              if (!(_DWORD)result)
                return result;
              if (*((_BYTE *)v8 + 196) != 2)
                return 0;
              *((_BYTE *)a2 + 152) = *((_BYTE *)*this + 224);
              break;
            default:
              return 0;
          }
          v10 = re::OPackReader::next(*this, v9);
          result = 1;
          if ((v10 & 1) == 0)
            return result;
        }
      }
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

_anonymous_namespace_ *re::Generic6DOFConstraint::Generic6DOFConstraint(_anonymous_namespace_ *a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t i;
  _QWORD *v7;
  uint64_t j;
  char *v9;
  uint64_t k;
  char *v11;

  ArcSharedObject::ArcSharedObject(a1, 0);
  v4 = 0;
  *((_QWORD *)a1 + 3) = 0;
  *((_QWORD *)a1 + 4) = &str_110;
  *((_QWORD *)a1 + 5) = a2;
  *((_QWORD *)a1 + 6) = 0;
  *(_QWORD *)a1 = off_24ED7E010;
  *((_QWORD *)a1 + 7) = 0xBF8000003F800000;
  *((_QWORD *)a1 + 8) = 0xBF8000003F800000;
  *((_QWORD *)a1 + 9) = 0xBF8000003F800000;
  *((_QWORD *)a1 + 10) = 0xBF8000003F800000;
  *((_QWORD *)a1 + 11) = 0xBF8000003F800000;
  *((_QWORD *)a1 + 12) = 0xBF8000003F800000;
  do
  {
    v5 = (_QWORD *)((char *)a1 + v4);
    *((_BYTE *)v5 + 128) = 0;
    v5[17] = 0;
    *((_DWORD *)v5 + 33) = 0;
    v4 += 16;
  }
  while (v4 != 48);
  for (i = 0; i != 48; i += 16)
  {
    v7 = (_QWORD *)((char *)a1 + i);
    *((_BYTE *)v7 + 176) = 0;
    v7[23] = 0;
    *((_DWORD *)v7 + 45) = 0;
  }
  for (j = 0; j != 60; j += 20)
  {
    v9 = (char *)a1 + j;
    v9[224] = 0;
    *((_DWORD *)v9 + 60) = 0;
    *(_QWORD *)(v9 + 228) = 0;
    v9[236] = 0;
  }
  for (k = 0; k != 60; k += 20)
  {
    v11 = (char *)a1 + k;
    v11[284] = 0;
    *((_DWORD *)v11 + 75) = 0;
    *((_QWORD *)v11 + 36) = 0;
    v11[296] = 0;
  }
  *((_QWORD *)a1 + 13) = 0;
  *((_QWORD *)a1 + 14) = 0;
  *((_QWORD *)a1 + 15) = 0;
  return a1;
}

uint64_t re::Generic6DOFConstraint::setLinearLimit(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t result;

  if (a2 >= 3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < N", "operator[]", 234, (int)a2, 3);
    result = _os_crash();
    __break(1u);
  }
  else
  {
    *(_QWORD *)(a1 + 8 * (int)a2 + 56) = *a3;
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
  }
  return result;
}

uint64_t re::Generic6DOFConstraint::setAngularLimit(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t result;

  if (a2 >= 3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < N", "operator[]", 234, (int)a2, 3);
    result = _os_crash();
    __break(1u);
  }
  else
  {
    *(_QWORD *)(a1 + 8 * (int)a2 + 80) = *a3;
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
  }
  return result;
}

uint64_t re::Generic6DOFConstraint::setLinearRestitution(uint64_t a1, uint64_t a2, float a3)
{
  uint64_t result;

  if (a2 >= 3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < N", "operator[]", 234, (int)a2, 3);
    result = _os_crash();
    __break(1u);
  }
  else
  {
    *(float *)(a1 + 4 * (int)a2 + 104) = a3;
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
  }
  return result;
}

uint64_t re::Generic6DOFConstraint::setAngularRestitution(uint64_t a1, uint64_t a2, float a3)
{
  uint64_t result;

  if (a2 >= 3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < N", "operator[]", 234, (int)a2, 3);
    result = _os_crash();
    __break(1u);
  }
  else
  {
    *(float *)(a1 + 4 * (int)a2 + 116) = a3;
    return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 64))(a1, (a2 + 3));
  }
  return result;
}

uint64_t re::Generic6DOFConstraint::setLinearSpring(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  uint64_t result;

  if (a2 >= 3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < N", "operator[]", 234, (int)a2, 3);
    result = _os_crash();
    __break(1u);
  }
  else
  {
    *(_OWORD *)(a1 + 16 * (int)a2 + 128) = *a3;
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 72))(a1);
  }
  return result;
}

uint64_t re::Generic6DOFConstraint::setAngularSpring(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  uint64_t result;

  if (a2 >= 3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < N", "operator[]", 234, (int)a2, 3);
    result = _os_crash();
    __break(1u);
  }
  else
  {
    *(_OWORD *)(a1 + 16 * (int)a2 + 176) = *a3;
    return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 72))(a1, (a2 + 3));
  }
  return result;
}

uint64_t re::Generic6DOFConstraint::setLinearMotor(uint64_t a1, uint64_t a2, __int128 *a3)
{
  uint64_t v3;
  __int128 v4;
  uint64_t result;

  if (a2 >= 3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < N", "operator[]", 234, (int)a2, 3);
    result = _os_crash();
    __break(1u);
  }
  else
  {
    v3 = a1 + 20 * (int)a2;
    v4 = *a3;
    *(_DWORD *)(v3 + 240) = *((_DWORD *)a3 + 4);
    *(_OWORD *)(v3 + 224) = v4;
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 80))(a1);
  }
  return result;
}

uint64_t re::Generic6DOFConstraint::setAngularMotor(uint64_t a1, uint64_t a2, __int128 *a3)
{
  uint64_t v3;
  __int128 v4;
  uint64_t result;

  if (a2 >= 3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < N", "operator[]", 234, (int)a2, 3);
    result = _os_crash();
    __break(1u);
  }
  else
  {
    v3 = a1 + 20 * (int)a2;
    v4 = *a3;
    *(_DWORD *)(v3 + 300) = *((_DWORD *)a3 + 4);
    *(_OWORD *)(v3 + 284) = v4;
    return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 80))(a1, (a2 + 3));
  }
  return result;
}

uint64_t re::Generic6DOFConstraint::type(re::Generic6DOFConstraint *this)
{
  return 6;
}

uint64_t re::Constraint::localAnchorPoseA(re::Constraint *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 5) + 32))(*((_QWORD *)this + 5));
}

uint64_t re::Constraint::localAnchorPoseB(re::Constraint *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 5) + 40))(*((_QWORD *)this + 5));
}

uint64_t re::HingeJoint::setAngularLimit(uint64_t a1, double a2, float a3)
{
  float32x2_t v3;
  float32x2_t v4;
  float32x2_t v5;

  *(_DWORD *)(a1 + 56) = LODWORD(a2);
  *(float *)(a1 + 60) = a3;
  if (*(float *)&a2 <= a3)
  {
    *((float *)&a2 + 1) = a3;
    v3 = (float32x2_t)vdup_n_s32(0x40C90FDBu);
    v4 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(*(float32x2_t *)&a2, v3), (int8x8_t)v3, *(int8x8_t *)&a2);
    v5 = (float32x2_t)vdup_n_s32(0xC0C90FDB);
    *(int8x8_t *)(a1 + 56) = vbsl_s8((int8x8_t)vcgt_f32(v5, v4), (int8x8_t)v5, (int8x8_t)v4);
  }
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t re::HingeJoint::type(re::HingeJoint *this)
{
  return 3;
}

uint64_t re::Gravity::didEnable(float32x4_t *this)
{
  uint64_t result;
  float32x4_t v3;
  uint64_t v4;
  float32x4_t v5;

  result = this->i64[1];
  if (result)
  {
    v3.i64[0] = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 72))(result);
    v3.i64[1] = v4;
    v5 = vaddq_f32(this[2], v3);
    return (*(uint64_t (**)(uint64_t, float32x4_t *))(*(_QWORD *)this->i64[1] + 80))(this->i64[1], &v5);
  }
  return result;
}

uint64_t re::Gravity::didDisable(float32x4_t *this)
{
  uint64_t result;
  float32x4_t v3;
  uint64_t v4;
  float32x4_t v5;

  result = this->i64[1];
  if (result)
  {
    v3.i64[0] = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 72))(result);
    v3.i64[1] = v4;
    v5 = vsubq_f32(v3, this[2]);
    return (*(uint64_t (**)(uint64_t, float32x4_t *))(*(_QWORD *)this->i64[1] + 80))(this->i64[1], &v5);
  }
  return result;
}

uint64_t re::Gravity::didAddToSimulation(uint64_t this)
{
  uint64_t v1;
  float32x4_t v2;
  uint64_t v3;
  float32x4_t v4;

  if (*(_BYTE *)(this + 16))
  {
    v1 = this;
    v2.i64[0] = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(this + 8) + 72))(*(_QWORD *)(this + 8));
    v2.i64[1] = v3;
    v4 = vaddq_f32(*(float32x4_t *)(v1 + 32), v2);
    return (*(uint64_t (**)(_QWORD, float32x4_t *))(**(_QWORD **)(v1 + 8) + 80))(*(_QWORD *)(v1 + 8), &v4);
  }
  return this;
}

uint64_t re::Gravity::willRemoveFromSimulation(uint64_t this)
{
  uint64_t v1;
  float32x4_t v2;
  uint64_t v3;
  float32x4_t v4;

  if (*(_BYTE *)(this + 16))
  {
    v1 = this;
    v2.i64[0] = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(this + 8) + 72))(*(_QWORD *)(this + 8));
    v2.i64[1] = v3;
    v4 = vsubq_f32(v2, *(float32x4_t *)(v1 + 32));
    return (*(uint64_t (**)(_QWORD, float32x4_t *))(**(_QWORD **)(v1 + 8) + 80))(*(_QWORD *)(v1 + 8), &v4);
  }
  return this;
}

void re::Gravity::~Gravity(re::Gravity *this)
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::Gravity::type(re::Gravity *this)
{
  return 1;
}

re::PhysXFixedJoint *re::PhysXFixedJoint::PhysXFixedJoint(re::PhysXFixedJoint *this, physx::PxFixedJoint *a2, uint64_t a3)
{
  *(_QWORD *)this = &off_24ED7E108;
  ArcSharedObject::ArcSharedObject(this, 0);
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 7) = &off_24ED7EED0;
  *((_QWORD *)this + 4) = &str_110;
  *((_QWORD *)this + 5) = (char *)this + 56;
  *((_QWORD *)this + 6) = 0;
  *(_QWORD *)this = &off_24ED7E108;
  *((_QWORD *)this + 8) = a2;
  *((_QWORD *)a2 + 2) = this;
  (*(void (**)(physx::PxFixedJoint *, uint64_t, uint64_t))(*(_QWORD *)a2 + 128))(a2, 16, 1);
  (*(void (**)(_QWORD, uint64_t, uint64_t))(**((_QWORD **)this + 8) + 128))(*((_QWORD *)this + 8), 8, a3);
  return this;
}

void re::PhysXFixedJoint::~PhysXFixedJoint(re::PhysXFixedJoint *this)
{
  void (***v2)(_QWORD);

  *(_QWORD *)this = &off_24ED7E108;
  v2 = (void (***)(_QWORD))*((_QWORD *)this + 8);
  if (v2)
    (**v2)(v2);
  *(_QWORD *)this = &off_24ED7E818;
  re::StringID::destroyString((re::PhysXFixedJoint *)((char *)this + 24));
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  void (***v2)(_QWORD);

  *(_QWORD *)this = &off_24ED7E108;
  v2 = (void (***)(_QWORD))*((_QWORD *)this + 8);
  if (v2)
    (**v2)(v2);
  *(_QWORD *)this = &off_24ED7E818;
  re::StringID::destroyString((re::PhysXFixedJoint *)((char *)this + 24));
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

uint64_t re::FixedJoint::type(re::FixedJoint *this)
{
  return 1;
}

_anonymous_namespace_ *re::PhysXSliderJoint::PhysXSliderJoint(_anonymous_namespace_ *a1, _QWORD *a2, uint64_t a3, uint64_t a4)
{
  *(_QWORD *)a1 = &off_24ED7E168;
  ArcSharedObject::ArcSharedObject(a1, 0);
  *((_QWORD *)a1 + 8) = &off_24ED7EED0;
  *((_QWORD *)a1 + 3) = 0;
  *((_QWORD *)a1 + 4) = &str_110;
  *((_QWORD *)a1 + 5) = (char *)a1 + 64;
  *((_QWORD *)a1 + 6) = 0;
  *((_QWORD *)a1 + 7) = 0xBF8000003F800000;
  *(_QWORD *)a1 = &off_24ED7E168;
  *((_QWORD *)a1 + 9) = a2;
  a2[2] = a1;
  (*(void (**)(_QWORD *, uint64_t, uint64_t))(*a2 + 128))(a2, 16, 1);
  (*(void (**)(_QWORD, uint64_t, uint64_t))(**((_QWORD **)a1 + 9) + 128))(*((_QWORD *)a1 + 9), 8, a4);
  *((_QWORD *)a1 + 10) = a3;
  return a1;
}

uint64_t re::PhysXSliderJoint::updateLimits(re::PhysXSliderJoint *this)
{
  uint64_t v2;
  uint64_t result;
  float v4;
  float v5;
  float *v6;
  float v7;
  float v8;
  _QWORD v9[2];
  float v10;
  float v11;
  float v12;

  v2 = *((_QWORD *)this + 9);
  result = (*(uint64_t (**)(uint64_t, uint64_t, BOOL))(*(_QWORD *)v2 + 280))(v2, 2, *((float *)this + 14) <= *((float *)this + 15));
  v5 = *((float *)this + 14);
  v4 = *((float *)this + 15);
  if (v5 <= v4)
  {
    v6 = (float *)*((_QWORD *)this + 10);
    v9[0] = 0;
    v9[1] = 0;
    v11 = v4;
    v12 = v5;
    v7 = *v6;
    v8 = (float)(v5 * -0.49) + (float)(v4 * 0.49);
    if ((float)(*v6 * 0.01) < v8)
      v8 = *v6 * 0.01;
    v10 = v8;
    *((float *)v9 + 1) = v7 + v7;
    return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v2 + 256))(v2, v9);
  }
  return result;
}

void re::PhysXSliderJoint::~PhysXSliderJoint(re::PhysXSliderJoint *this)
{
  void (***v2)(_QWORD);

  v2 = (void (***)(_QWORD))*((_QWORD *)this + 9);
  if (v2)
    (**v2)(v2);
  *(_QWORD *)this = &off_24ED7E818;
  re::StringID::destroyString((re::PhysXSliderJoint *)((char *)this + 24));
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  void (***v2)(_QWORD);

  v2 = (void (***)(_QWORD))*((_QWORD *)this + 9);
  if (v2)
    (**v2)(v2);
  *(_QWORD *)this = &off_24ED7E818;
  re::StringID::destroyString((re::PhysXSliderJoint *)((char *)this + 24));
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

uint64_t re::SliderJoint::type(re::SliderJoint *this)
{
  return 4;
}

void re::PhysicsJointCollection::~PhysicsJointCollection(_BOOL8 this)
{
  uint64_t v1;
  NSObject *v2;
  uint64_t v3;
  _QWORD *v4;
  NSObject *v5;
  int v6;
  double v7;
  int v8;
  int v9;
  uint64_t v10;

  v1 = this;
  v10 = *MEMORY[0x24BDAC8D0];
  if (*(_QWORD *)(this + 32))
  {
    v2 = *re::physicsLogObjects((re *)this);
    this = os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
    if (this)
    {
      v3 = *(_QWORD *)(v1 + 32);
      v8 = 67109120;
      v9 = v3;
      _os_log_impl(&dword_224FE9000, v2, OS_LOG_TYPE_DEFAULT, "~PhysicsJointCollection(): %d joints left in the collection", (uint8_t *)&v8, 8u);
    }
  }
  v4 = (_QWORD *)(v1 + 16);
  if (*(_DWORD *)(v1 + 84))
  {
    v5 = *re::physicsLogObjects((re *)this);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(v1 + 84);
      v8 = 67109120;
      v9 = v6;
      _os_log_impl(&dword_224FE9000, v5, OS_LOG_TYPE_DEFAULT, "~PhysicsJointCollection(): %d deferred to be deleted joints left in the collection", (uint8_t *)&v8, 8u);
    }
  }
  v7 = re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)(v1 + 56));
  if (*v4)
  {
    if (*(_QWORD *)(v1 + 48))
      (*(void (**)(_QWORD, double))(*(_QWORD *)*v4 + 40))(*v4, v7);
    *(_QWORD *)(v1 + 48) = 0;
    *(_QWORD *)(v1 + 24) = 0;
    *(_QWORD *)(v1 + 32) = 0;
    *v4 = 0;
    ++*(_DWORD *)(v1 + 40);
  }
}

void re::PhysicsJointCollection::~PhysicsJointCollection(re::PhysicsJointCollection *this)
{
  re::PhysicsJointCollection::~PhysicsJointCollection((_BOOL8)this);
  JUMPOUT(0x2276933B8);
}

uint64_t re::PhysicsJointCollection::operator[](uint64_t a1, unint64_t a2)
{
  if (*(_QWORD *)(a1 + 32) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8 * a2);
}

void re::PhysicsJointCollection::add(re::PhysicsJointCollection *this, re::Constraint *a2)
{
  re::Constraint *v3;
  int v4;
  re::RigidBody *v5;
  re::RigidBody *v6;
  re::Constraint *v7;

  v7 = a2;
  re::DynamicArray<re::TransitionCondition *>::add((_QWORD *)this + 2, &v7);
  v3 = v7;
  *((_QWORD *)v7 + 6) = *((_QWORD *)this + 1);
  if (physx::shdfnd::g_isLockingEnabled)
    v4 = 1;
  else
    v4 = physx::shdfnd::g_alwaysUseLocking;
  if ((physx::shdfnd::g_alwaysUseLocking & 1) == 0 && physx::shdfnd::g_isLockingEnabled)
    physx::shdfnd::g_isLockingEnabled = 0;
  (*(void (**)(_QWORD))(**((_QWORD **)v3 + 5) + 64))(*((_QWORD *)v3 + 5));
  v5 = (re::RigidBody *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)v7 + 5) + 16))(*((_QWORD *)v7 + 5));
  if (v5)
    re::RigidBody::setAttachedJointCount(v5, *((_DWORD *)v5 + 77) + 1);
  v6 = (re::RigidBody *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)v7 + 5) + 24))(*((_QWORD *)v7 + 5));
  if (v6)
    re::RigidBody::setAttachedJointCount(v6, *((_DWORD *)v6 + 77) + 1);
  if (physx::shdfnd::g_isLockingEnabled != v4)
    physx::shdfnd::g_isLockingEnabled = v4;
}

uint64_t re::PhysicsJointCollection::deleteJoint(uint64_t this, re::Constraint *a2, int a3)
{
  uint64_t v3;
  int v5;
  re::RigidBody *v6;
  re::RigidBody *v7;
  uint64_t v8;
  re::Constraint *v9;
  re::Constraint *v10;

  v9 = a2;
  if (a2)
  {
    v3 = this;
    if (a3)
    {
      re::DynamicArray<unsigned long long>::remove(this + 16, &v9);
      return re::HashSetBase<re::Constraint *,re::Constraint *,re::internal::ValueAsKey<re::Constraint *>,re::Hash<re::Constraint *>,re::EqualTo<re::Constraint *>,true,false>::add(v3 + 56, (uint64_t *)&v9);
    }
    else
    {
      if (*((_QWORD *)a2 + 6))
      {
        v10 = a2;
        re::DynamicArray<re::Allocator const*>::removeStable((_QWORD *)(this + 16), &v10);
      }
      if (physx::shdfnd::g_isLockingEnabled)
        v5 = 1;
      else
        v5 = physx::shdfnd::g_alwaysUseLocking;
      if ((physx::shdfnd::g_alwaysUseLocking & 1) == 0 && physx::shdfnd::g_isLockingEnabled)
        physx::shdfnd::g_isLockingEnabled = 0;
      (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)a2 + 5) + 72))(*((_QWORD *)a2 + 5), *(_QWORD *)(v3 + 8));
      v6 = (re::RigidBody *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)a2 + 5) + 16))(*((_QWORD *)a2 + 5));
      if (v6)
        re::RigidBody::setAttachedJointCount(v6, *((_DWORD *)v6 + 77) - 1);
      v7 = (re::RigidBody *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)a2 + 5) + 24))(*((_QWORD *)a2 + 5));
      if (v7)
        re::RigidBody::setAttachedJointCount(v7, *((_DWORD *)v7 + 77) - 1);
      v8 = re::globalAllocators(v7)[2];
      (**(void (***)(re::Constraint *))a2)(a2);
      this = (*(uint64_t (**)(uint64_t, re::Constraint *))(*(_QWORD *)v8 + 40))(v8, a2);
      if (physx::shdfnd::g_isLockingEnabled != v5)
        physx::shdfnd::g_isLockingEnabled = v5;
    }
  }
  return this;
}

uint64_t re::HashSetBase<re::Constraint *,re::Constraint *,re::internal::ValueAsKey<re::Constraint *>,re::Hash<re::Constraint *>,re::EqualTo<re::Constraint *>,true,false>::add(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;

  v4 = *a2;
  v5 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v6 = (0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) ^ ((0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) >> 31);
  v7 = *(unsigned int *)(a1 + 24);
  if (!(_DWORD)v7)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  v8 = v6 % v7;
  v9 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * (v6 % v7));
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
LABEL_8:
    v12 = re::HashSetBase<re::Constraint *,re::Constraint *,re::internal::ValueAsKey<re::Constraint *>,re::Hash<re::Constraint *>,re::EqualTo<re::Constraint *>,true,false>::addAsCopy(a1, v8, v6, (uint64_t)a2, a2);
    ++*(_DWORD *)(a1 + 40);
    v11 = *(_QWORD *)(a1 + 16) + 24 * v12;
    return v11 + 16;
  }
  v10 = *(_QWORD *)(a1 + 16);
  while (*(_QWORD *)(v10 + 24 * v9 + 16) != v4)
  {
    LODWORD(v9) = *(_DWORD *)(v10 + 24 * v9 + 8) & 0x7FFFFFFF;
    if ((_DWORD)v9 == 0x7FFFFFFF)
      goto LABEL_8;
  }
  v11 = v10 + 24 * v9;
  return v11 + 16;
}

void re::PhysicsJointCollection::deleteDeferredDeletedJoints(re::PhysicsJointCollection *this)
{
  uint64_t v2;
  uint64_t v3;
  int *v4;
  int v5;
  uint64_t v6;
  unsigned int v7;
  int v8;
  int v9;

  v2 = *((unsigned int *)this + 22);
  if ((_DWORD)v2)
  {
    v3 = 0;
    v4 = (int *)(*((_QWORD *)this + 9) + 8);
    while (1)
    {
      v5 = *v4;
      v4 += 6;
      if (v5 < 0)
        break;
      if (v2 == ++v3)
      {
        LODWORD(v3) = *((_DWORD *)this + 22);
        break;
      }
    }
  }
  else
  {
    LODWORD(v3) = 0;
  }
  if ((_DWORD)v2 != (_DWORD)v3)
  {
    v6 = v3;
    do
    {
      re::PhysicsJointCollection::deleteJoint((uint64_t)this, *(re::Constraint **)(*((_QWORD *)this + 9) + 24 * v6 + 16), 0);
      v7 = *((_DWORD *)this + 22);
      if (v7 <= (int)v3 + 1)
        v8 = v3 + 1;
      else
        v8 = *((_DWORD *)this + 22);
      v9 = v3;
      while (1)
      {
        v6 = (v9 + 1);
        if (v8 - 1 == v9)
          break;
        ++v9;
        LODWORD(v3) = v6;
        if ((*(_DWORD *)(*((_QWORD *)this + 9) + 24 * v6 + 8) & 0x80000000) != 0)
          goto LABEL_17;
      }
      LODWORD(v3) = v8;
LABEL_17:
      ;
    }
    while (v7 != (_DWORD)v3);
  }
  re::HashSetBase<re::Constraint *,re::Constraint *,re::internal::ValueAsKey<re::Constraint *>,re::Hash<re::Constraint *>,re::EqualTo<re::Constraint *>,true,false>::clear((uint64_t)this + 56);
}

void re::HashSetBase<re::Constraint *,re::Constraint *,re::internal::ValueAsKey<re::Constraint *>,re::Hash<re::Constraint *>,re::EqualTo<re::Constraint *>,true,false>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;

  if (*(_DWORD *)(a1 + 28))
  {
    v2 = *(unsigned int *)(a1 + 24);
    if ((_DWORD)v2)
      memset_pattern16(*(void **)(a1 + 8), &memset_pattern_12, 4 * v2);
    v3 = *(unsigned int *)(a1 + 32);
    if ((_DWORD)v3)
    {
      v4 = 0;
      v5 = 24 * v3;
      do
      {
        v6 = *(_QWORD *)(a1 + 16) + v4;
        v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
        v4 += 24;
      }
      while (v5 != v4);
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    v8 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v8;
  }
}

const re::RigidBody *re::PhysicsJointCollection::deleteJointsReferencingRigidBody(const re::RigidBody *this, const re::RigidBody *a2)
{
  uint64_t v2;
  unint64_t v4;
  unint64_t v5;
  re::Constraint *v6;
  uint64_t v7;

  if (*((int *)a2 + 77) >= 1)
  {
    v2 = (uint64_t)this;
    if ((int)*((_QWORD *)this + 4) >= 1)
    {
      v4 = *((_QWORD *)this + 4) + 1;
      do
      {
        v5 = (v4 - 2);
        if (*(_QWORD *)(v2 + 32) <= v5)
        {
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_12:
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        v6 = *(re::Constraint **)(*(_QWORD *)(v2 + 48) + 8 * v5);
        if ((const re::RigidBody *)(*(uint64_t (**)(_QWORD *))(**((_QWORD **)v6 + 5) + 16))(*((_QWORD **)v6 + 5)) == a2)
          goto LABEL_8;
        if (*(_QWORD *)(v2 + 32) <= v5)
          goto LABEL_12;
        v7 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v2 + 48) + 8 * v5) + 40);
        this = (const re::RigidBody *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 24))(v7);
        if (this == a2)
LABEL_8:
          this = (const re::RigidBody *)re::PhysicsJointCollection::deleteJoint(v2, v6, 0);
        --v4;
      }
      while (v4 > 1);
    }
  }
  return this;
}

uint64_t re::HashSetBase<re::Constraint *,re::Constraint *,re::internal::ValueAsKey<re::Constraint *>,re::Hash<re::Constraint *>,re::EqualTo<re::Constraint *>,true,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t a4, _QWORD *a5)
{
  uint64_t v8;
  int v9;
  uint64_t v10;
  int v11;

  v8 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v8 == 0x7FFFFFFF)
  {
    v8 = *(unsigned int *)(a1 + 32);
    v9 = v8;
    if ((_DWORD)v8 == *(_DWORD *)(a1 + 24))
    {
      re::HashSetBase<re::Constraint *,re::Constraint *,re::internal::ValueAsKey<re::Constraint *>,re::Hash<re::Constraint *>,re::EqualTo<re::Constraint *>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v9 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v9 + 1;
    v10 = *(_QWORD *)(a1 + 16);
    v11 = *(_DWORD *)(v10 + 24 * v8 + 8);
  }
  else
  {
    v10 = *(_QWORD *)(a1 + 16);
    v11 = *(_DWORD *)(v10 + 24 * v8 + 8);
    *(_DWORD *)(a1 + 36) = v11 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v10 + 24 * v8 + 8) = v11 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v8 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v8 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v8) = a3;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v8 + 16) = *a5;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v8;
  ++*(_DWORD *)(a1 + 28);
  return v8;
}

void re::HashSetBase<re::Constraint *,re::Constraint *,re::internal::ValueAsKey<re::Constraint *>,re::Hash<re::Constraint *>,re::EqualTo<re::Constraint *>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  __int128 v7;
  unsigned int v8;
  __int128 v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  _QWORD *v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  signed int v21;
  _BYTE v22[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v22, 0, 36);
      *(_QWORD *)&v22[36] = 0x7FFFFFFFLL;
      re::HashSetBase<re::Constraint *,re::Constraint *,re::internal::ValueAsKey<re::Constraint *>,re::Hash<re::Constraint *>,re::EqualTo<re::Constraint *>,true,false>::init((uint64_t)v22, v4, a2);
      v5 = *(_OWORD *)a1;
      *(_QWORD *)a1 = *(_QWORD *)v22;
      v6 = *(_QWORD *)(a1 + 16);
      v7 = *(_OWORD *)&v22[8];
      *(_OWORD *)v22 = v5;
      *(_QWORD *)&v22[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      v9 = *(_OWORD *)&v22[24];
      *(_OWORD *)&v22[24] = *(_OWORD *)(a1 + 24);
      v8 = *(_DWORD *)&v22[32];
      *(_OWORD *)(a1 + 24) = v9;
      v10 = v8;
      if (v8)
      {
        v11 = DWORD1(v9);
        v12 = v7;
        v13 = (_QWORD *)(v6 + 16);
        do
        {
          if ((*(_DWORD *)(v13 - 1) & 0x80000000) != 0)
          {
            v14 = *(v13 - 2);
            v15 = *(unsigned int *)(a1 + 24);
            v16 = v14 % v15;
            v17 = *(unsigned int *)(a1 + 36);
            if ((_DWORD)v17 == 0x7FFFFFFF)
            {
              v17 = *(unsigned int *)(a1 + 32);
              v18 = v17;
              if ((_DWORD)v17 == (_DWORD)v15)
              {
                re::HashSetBase<re::Constraint *,re::Constraint *,re::internal::ValueAsKey<re::Constraint *>,re::Hash<re::Constraint *>,re::EqualTo<re::Constraint *>,true,false>::setCapacity(a1, (2 * v11));
                v16 = v14 % *(unsigned int *)(a1 + 24);
                v18 = *(_DWORD *)(a1 + 32);
                v12 = *(_QWORD *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v18 + 1;
              v19 = *(_QWORD *)(a1 + 16);
              v20 = *(_DWORD *)(v19 + 24 * v17 + 8);
            }
            else
            {
              v19 = *(_QWORD *)(a1 + 16);
              v20 = *(_DWORD *)(v19 + 24 * v17 + 8);
              *(_DWORD *)(a1 + 36) = v20 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v19 + 24 * v17 + 8) = v20 | 0x80000000;
            *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v17 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v17 + 8) & 0x80000000 | *(_DWORD *)(v12 + 4 * v16);
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v17) = v14;
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v17 + 16) = *v13;
            v12 = *(_QWORD *)(a1 + 8);
            *(_DWORD *)(v12 + 4 * v16) = v17;
            v11 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v11;
          }
          v13 += 3;
          --v10;
        }
        while (v10);
      }
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)v22);
    }
  }
  else
  {
    if (a2)
      v21 = a2;
    else
      v21 = 3;
  }
}

void re::HashSetBase<re::Constraint *,re::Constraint *,re::internal::ValueAsKey<re::Constraint *>,re::Hash<re::Constraint *>,re::EqualTo<re::Constraint *>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 24 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &memset_pattern_12, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 600);
    _os_crash();
    __break(1u);
  }
}

uint64_t *re::allocInfo_PhysicsMaterial(re *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&qword_25411D0A0);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_25411D0A0))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_25411D0C8, 0);
    *(uint64_t *)((char *)&qword_25411D0D8 + 6) = 0;
    qword_25411D0D8 = 0;
    qword_25411D0E8 = 0;
    qword_25411D0F0 = 0xFFFFFFFFLL;
    qword_25411D0C8 = (uint64_t)&off_24ED7DAA8;
    qword_25411D0F8 = (uint64_t)"PhysicsMaterial";
    dword_25411D100 = 0;
    unk_25411D108 = 0u;
    unk_25411D118 = 0u;
    unk_25411D128 = 0u;
    qword_25411D138 = 0;
    __cxa_guard_release(&qword_25411D0A0);
  }
  return &qword_25411D0C8;
}

void re::initInfo_PhysicsMaterial(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  const re::IntrospectionBase *v7;
  void *v8;
  uint64_t v9;
  uint64_t *v10;
  const re::IntrospectionBase *v11;
  void *v12;
  uint64_t v13;
  uint64_t *v14;
  re *v15;
  uint64_t *v16;
  const re::IntrospectionBase *v17;
  void *v18;
  uint64_t v19;
  __int128 v20;
  _QWORD v21[2];
  __int128 v22;

  v21[0] = 0x6D3D3F22840C60DCLL;
  v21[1] = "PhysicsMaterial";
  re::StringID::destroyString((re::StringID *)v21);
  *((_OWORD *)this + 2) = v22;
  v4 = atomic_load((unsigned __int8 *)&_MergedGlobals_416);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&_MergedGlobals_416);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      v8 = re::introspect_float((re *)1, v7);
      v9 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
      *(_DWORD *)v9 = 1;
      *(_QWORD *)(v9 + 8) = "m_restitution";
      *(_QWORD *)(v9 + 16) = v8;
      *(_QWORD *)(v9 + 24) = 0;
      *(_QWORD *)(v9 + 32) = 0x800000001;
      *(_DWORD *)(v9 + 40) = 0;
      *(_QWORD *)(v9 + 48) = 0;
      *(_QWORD *)(v9 + 56) = 0;
      *(_DWORD *)(v9 + 64) = 0;
      qword_25411D0A8 = v9;
      v10 = re::introspectionAllocator((re *)v9);
      v12 = re::introspect_float((re *)1, v11);
      v13 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v10 + 32))(v10, 72, 8);
      *(_DWORD *)v13 = 1;
      *(_QWORD *)(v13 + 8) = "m_staticFriction";
      *(_QWORD *)(v13 + 16) = v12;
      *(_QWORD *)(v13 + 24) = 0;
      *(_QWORD *)(v13 + 32) = 0xC00000002;
      *(_DWORD *)(v13 + 40) = 0;
      *(_QWORD *)(v13 + 48) = 0;
      *(_QWORD *)(v13 + 56) = 0;
      *(_DWORD *)(v13 + 64) = 0;
      qword_25411D0B0 = v13;
      v14 = re::introspectionAllocator((re *)v13);
      v15 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v14 + 32))(v14, 24, 8);
      *(_DWORD *)v15 = 5;
      *((_QWORD *)v15 + 1) = "m_friction";
      *((_QWORD *)v15 + 2) = "m_staticFriction";
      qword_25411D0B8 = (uint64_t)v15;
      v16 = re::introspectionAllocator(v15);
      v18 = re::introspect_float((re *)1, v17);
      v19 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v16 + 32))(v16, 72, 8);
      *(_DWORD *)v19 = 1;
      *(_QWORD *)(v19 + 8) = "m_dynamicFriction";
      *(_QWORD *)(v19 + 16) = v18;
      *(_QWORD *)(v19 + 24) = 0;
      *(_QWORD *)(v19 + 32) = 0x1000000003;
      *(_DWORD *)(v19 + 40) = 0;
      *(_QWORD *)(v19 + 48) = 0;
      *(_QWORD *)(v19 + 56) = 0;
      *(_DWORD *)(v19 + 64) = 0;
      qword_25411D0C0 = v19;
      __cxa_guard_release(&_MergedGlobals_416);
    }
  }
  *((_QWORD *)this + 2) = 0x1800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 4;
  *((_QWORD *)this + 8) = &qword_25411D0A8;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::PhysicsMaterial>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::PhysicsMaterial>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::PhysicsMaterial>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::PhysicsMaterial>;
  re::IntrospectionRegistry::add(this, v3);
  v20 = v22;
}

double re::internal::defaultConstruct<re::PhysicsMaterial>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double result;

  *(_QWORD *)a3 = &off_24ED7E200;
  result = 0.0000305175852;
  *(_QWORD *)(a3 + 8) = 0x3F0000003DCCCCCDLL;
  *(_DWORD *)(a3 + 16) = -1082130432;
  return result;
}

uint64_t re::internal::defaultDestruct<re::PhysicsMaterial>(uint64_t a1, uint64_t a2, uint64_t (***a3)(_QWORD))
{
  return (**a3)(a3);
}

double re::internal::defaultConstructV2<re::PhysicsMaterial>(uint64_t a1)
{
  double result;

  *(_QWORD *)a1 = &off_24ED7E200;
  result = 0.0000305175852;
  *(_QWORD *)(a1 + 8) = 0x3F0000003DCCCCCDLL;
  *(_DWORD *)(a1 + 16) = -1082130432;
  return result;
}

uint64_t re::internal::defaultDestructV2<re::PhysicsMaterial>(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t re::introspect_PhysicsMaterial(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"PhysicsMaterial", (uint64_t (*)(re::internal *))re::allocInfo_PhysicsMaterial, (re::IntrospectionBase *(*)(void))re::initInfo_PhysicsMaterial, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::PhysicsMaterial>, this);
}

void re::PhysicsMaterial::~PhysicsMaterial(re::PhysicsMaterial *this)
{
  JUMPOUT(0x2276933B8);
}

uint64_t *re::physicsLogObjects(re *this)
{
  unsigned __int8 v1;

  {
    re::physicsLogObjects(void)::logObjects = (uint64_t)os_log_create("com.apple.re", "Physics");
  }
  return &re::physicsLogObjects(void)::logObjects;
}

_QWORD *re::LinearSpring::onApply(re::LinearSpring *this)
{
  float32x4_t v2;
  float32x4_t v3;
  float32x4_t v4;
  float32x4_t v5;
  int32x4_t v6;
  float32x4_t v7;
  int32x4_t v8;
  _QWORD *result;
  float32x4_t v10;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;
  int32x4_t v14;
  float32x4_t v15;
  int32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int32x2_t v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  int v25;
  float v26;
  uint64_t v27;
  int v28;
  float v29;
  float v30;
  BOOL v31;
  float v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  int32x4_t v39;
  float32x4_t v40;

  (*(void (**)(float32x4_t *__return_ptr))(**((_QWORD **)this + 3) + 40))(&v38);
  v2 = *((float32x4_t *)this + 3);
  v3 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v39, v39), (int8x16_t)v39, 0xCuLL);
  v4 = vnegq_f32((float32x4_t)v39);
  v5 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v2, (int32x4_t)v2), (int8x16_t)v2, 0xCuLL), v4), v2, v3);
  v6 = (int32x4_t)vaddq_f32(v5, v5);
  v7 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v6, v6), (int8x16_t)v6, 0xCuLL);
  v8 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v7, (int32x4_t)v7), (int8x16_t)v7, 0xCuLL), v4), v7, v3);
  v35 = vaddq_f32(v38, vaddq_f32(vaddq_f32(v2, vmulq_laneq_f32(v7, (float32x4_t)v39, 3)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v8, v8), (int8x16_t)v8, 0xCuLL)));
  v40 = v35;
  result = (*(_QWORD *(**)(float32x4_t *__return_ptr))(**((_QWORD **)this + 4) + 40))(&v38);
  v10 = *((float32x4_t *)this + 4);
  v11 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v39, v39), (int8x16_t)v39, 0xCuLL);
  v12 = vnegq_f32((float32x4_t)v39);
  v13 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v10, (int32x4_t)v10), (int8x16_t)v10, 0xCuLL), v12), v10, v11);
  v14 = (int32x4_t)vaddq_f32(v13, v13);
  v15 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v14, v14), (int8x16_t)v14, 0xCuLL);
  v16 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v15, (int32x4_t)v15), (int8x16_t)v15, 0xCuLL), v12), v15, v11);
  v37 = vaddq_f32(v38, vaddq_f32(vaddq_f32(v10, vmulq_laneq_f32(v15, (float32x4_t)v39, 3)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v16, v16), (int8x16_t)v16, 0xCuLL)));
  v17 = vsubq_f32(v35, v37);
  v18 = vmulq_f32(v17, v17);
  v19 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v18, 2), vaddq_f32(v18, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v18.f32, 1))).u64[0];
  *(float *)v19.i32 = sqrtf(*(float *)v19.i32);
  if (*(float *)v19.i32 < 0.000001)
    return result;
  v20 = *((float *)this + 20);
  v21 = *(float *)v19.i32 - v20;
  *((_DWORD *)this + 22) = 0;
  if (*(float *)v19.i32 > v20)
  {
    v22 = *((float *)this + 25);
    if (v22 > 0.000001)
    {
      v23 = v21 / v22;
      goto LABEL_9;
    }
  }
  if (*(float *)v19.i32 < v20)
  {
    v24 = *((float *)this + 24);
    if (v24 > 0.000001)
    {
      v23 = (float)(v20 - *(float *)v19.i32) / v24;
LABEL_9:
      *((float *)this + 22) = v23;
      if (v23 > 1.0)
      {
        if (*((_BYTE *)this + 16))
        {
          *((_BYTE *)this + 16) = 0;
          return (_QWORD *)(*(uint64_t (**)(re::LinearSpring *))(*(_QWORD *)this + 32))(this);
        }
        return result;
      }
    }
  }
  result = (_QWORD *)*((_QWORD *)this + 3);
  v25 = *((_DWORD *)result + 52);
  v26 = 0.0;
  if (v25 == 2)
    v26 = *((float *)result + 48);
  v27 = *((_QWORD *)this + 4);
  v28 = *(_DWORD *)(v27 + 208);
  if (v28 == 2)
  {
    v29 = *(float *)(v27 + 192);
    v30 = v26 + v29;
    if ((float)(v26 + v29) == 0.0)
      return result;
    v31 = v29 == 0.0;
    v32 = v29 / v30;
    if (v31)
      v32 = 1.0;
  }
  else
  {
    v30 = v26 + 0.0;
    if ((float)(v26 + 0.0) == 0.0)
      return result;
    v32 = 1.0;
  }
  v33 = vmulq_n_f32(vdivq_f32(vmulq_n_f32(v17, v21), (float32x4_t)vdupq_lane_s32(v19, 0)), -*((float *)this + 21));
  v34 = vmulq_n_f32(v33, v32);
  v38 = v34;
  v34.f32[0] = v26 / v30;
  if (v26 == 0.0)
    v34.f32[0] = 1.0;
  v36 = vmulq_f32(v33, vnegq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v34.f32, 0)));
  if (v25 == 2)
  {
    result = (_QWORD *)(*(uint64_t (**)(_QWORD *, float32x4_t *, float32x4_t *, _QWORD))(*result + 376))(result, &v38, &v40, 0);
    v27 = *((_QWORD *)this + 4);
    v28 = *(_DWORD *)(v27 + 208);
  }
  if (v28 == 2)
    return (_QWORD *)(*(uint64_t (**)(uint64_t, float32x4_t *, float32x4_t *, _QWORD))(*(_QWORD *)v27 + 376))(v27, &v36, &v37, 0);
  return result;
}

void re::LinearSpring::~LinearSpring(re::LinearSpring *this)
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::LinearSpring::type(re::LinearSpring *this)
{
  return 5;
}

uint64_t re::PhysXRigidBody::updateUnderlyingRigidBody(uint64_t this, __n128 a2)
{
  _WORD *v2;
  float *v3;
  __n128 v4;

  v2 = *(_WORD **)(*(_QWORD *)(this + 72) + 24);
  if (v2 && v2[4] == 5)
  {
    v3 = (float *)this;
    a2.n128_u32[0] = *(_DWORD *)(this + 324);
    if (a2.n128_f32[0] < 0.0)
      a2.n128_f32[0] = 0.0;
    (*(void (**)(_QWORD, __n128))(*(_QWORD *)v2 + 280))(*(_QWORD *)(*(_QWORD *)(this + 72) + 24), a2);
    v4.n128_f32[0] = v3[82] * 5.0;
    if (v4.n128_f32[0] < 0.0)
      v4.n128_f32[0] = 0.0;
    (*(void (**)(_WORD *, __n128))(*(_QWORD *)v2 + 296))(v2, v4);
    re::PhysXRigidBody::updateSleepThreshold((re::PhysXRigidBody *)v3);
    return re::PhysXRigidBody::updateCCDSettings((uint64_t)v3);
  }
  return this;
}

_WORD *re::PhysXRigidBody::updateSleepThreshold(re::PhysXRigidBody *this)
{
  _WORD *result;
  float v3;

  result = *(_WORD **)(*((_QWORD *)this + 9) + 24);
  if (result && result[4] == 5 && *((_BYTE *)this + 320))
  {
    v3 = *((float *)this + 82);
    if (v3 > *((float *)this + 81))
      v3 = *((float *)this + 81);
    if (v3 > 1.0)
      v3 = 1.0;
    if (v3 < 0.0)
      v3 = 0.0;
    return (_WORD *)(*(uint64_t (**)(_WORD *, float))(*(_QWORD *)result + 520))(result, (float)(*((float *)this + 78) * *((float *)this + 79)) * v3);
  }
  return result;
}

uint64_t re::PhysXRigidBody::updateCCDSettings(uint64_t this)
{
  _WORD *v1;
  void (*v2)(_QWORD, uint64_t, uint64_t);

  v1 = *(_WORD **)(*(_QWORD *)(this + 72) + 24);
  if (v1 && v1[4] == 5)
  {
    v2 = *(void (**)(_QWORD, uint64_t, uint64_t))(*(_QWORD *)v1 + 416);
    if (*(_BYTE *)(this + 304))
    {
      v2(*(_QWORD *)(*(_QWORD *)(this + 72) + 24), 4, 1);
      return (*(uint64_t (**)(_WORD *, float))(*(_QWORD *)v1 + 440))(v1, 0.15);
    }
    else
    {
      return ((uint64_t (*)(_QWORD, uint64_t, _QWORD))v2)(*(_QWORD *)(*(_QWORD *)(this + 72) + 24), 4, 0);
    }
  }
  return this;
}

uint64_t re::PhysXRigidBody::setCollisionObject(re::PhysXRigidBody *this, re::CollisionObject *a2)
{
  __n128 v3;

  *((_QWORD *)this + 9) = a2;
  v3.n128_f64[0] = (*(double (**)(re::PhysXRigidBody *))(*(_QWORD *)this + 432))(this);
  return re::PhysXRigidBody::updateUnderlyingRigidBody((uint64_t)this, v3);
}

void re::PhysXRigidBody::~PhysXRigidBody(re::PhysXRigidBody *this)
{
  void (***v2)(_QWORD);
  uint64_t v3;
  void (***v4)(_QWORD);
  uint64_t v5;

  v2 = (void (***)(_QWORD))*((_QWORD *)this + 9);
  if (v2)
  {
    v3 = *((_QWORD *)this + 54);
    (**v2)(*((_QWORD *)this + 9));
    (*(void (**)(uint64_t, void (***)(_QWORD)))(*(_QWORD *)v3 + 40))(v3, v2);
  }
  v4 = (void (***)(_QWORD))*((_QWORD *)this + 8);
  if (v4)
  {
    v5 = *((_QWORD *)this + 54);
    (**v4)(*((_QWORD *)this + 8));
    (*(void (**)(uint64_t, void (***)(_QWORD)))(*(_QWORD *)v5 + 40))(v5, v4);
  }
  *(_QWORD *)this = off_24ED7EC78;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 9) = 0;
}

{
  re::PhysXRigidBody::~PhysXRigidBody(this);
  JUMPOUT(0x2276933B8);
}

uint64_t re::RigidBody::shape(re::RigidBody *this)
{
  return *((_QWORD *)this + 8);
}

{
  return *((_QWORD *)this + 8);
}

uint64_t re::PhysXRigidBody::changeUnderlyingType(re::PhysXRigidBody *this)
{
  uint64_t v2;
  _BOOL4 v3;
  uint64_t UnderlyingRigidBody;
  _QWORD v6[3];

  v2 = *(_QWORD *)(*((_QWORD *)this + 9) + 24);
  v3 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2) == 0;
  (*(void (**)(_QWORD *__return_ptr, uint64_t))(*(_QWORD *)v2 + 152))(v6, v2);
  UnderlyingRigidBody = re::PhysXPhysicsFactory::createUnderlyingRigidBody(re::PhysicsFactory::m_defaultFactory, re::PhysicsFactory::m_defaultAllocator, v2, (uint64_t *)this + 18, v3);
  (**(void (***)(uint64_t))v2)(v2);
  (*(void (**)(_QWORD, uint64_t))(**((_QWORD **)this + 9) + 40))(*((_QWORD *)this + 9), UnderlyingRigidBody);
  (*(void (**)(_QWORD, _QWORD *, uint64_t))(**(_QWORD **)(*((_QWORD *)this + 9) + 24) + 160))(*(_QWORD *)(*((_QWORD *)this + 9) + 24), v6, 1);
  return re::PhysXRigidBody::setSolverIterations((uint64_t)this, (unsigned int *)this + 53);
}

uint64_t re::PhysXRigidBody::setSolverIterations(uint64_t result, unsigned int *a2)
{
  if (*(_DWORD *)(result + 212) != *a2 || *(_DWORD *)(result + 216) != a2[1])
  {
    *(_QWORD *)(result + 212) = *(_QWORD *)a2;
    result = *(_QWORD *)(*(_QWORD *)(result + 72) + 24);
    if (result)
    {
      if (*(_WORD *)(result + 8) == 5)
        return (*(uint64_t (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)result + 608))(result, *a2, a2[1]);
    }
  }
  return result;
}

uint64_t re::PhysXRigidBody::logRigidBodyState(re::PhysXRigidBody *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 9) + 24))(*((_QWORD *)this + 9));
}

__n128 re::PhysXRigidBody::onMotionTypeChanged(__n128 *this, int a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void (*v7)(uint64_t, uint64_t, _QWORD);
  __n128 v8;
  __n128 result;

  v4 = *(_QWORD *)(this[4].n128_u64[1] + 24);
  if (v4)
  {
    if (*(_WORD *)(v4 + 8) == 5)
      v5 = *(_QWORD *)(this[4].n128_u64[1] + 24);
    else
      v5 = 0;
  }
  else
  {
    v5 = 0;
  }
  if ((a2 - 1) >= 2)
  {
    if (a2)
      return result;
    if (v5)
      re::PhysXRigidBody::changeUnderlyingType((re::PhysXRigidBody *)this);
  }
  else
  {
    if (!v5)
    {
      re::PhysXRigidBody::changeUnderlyingType((re::PhysXRigidBody *)this);
      v6 = *(_QWORD *)(this[4].n128_u64[1] + 24);
      if (v6)
      {
        if (*(_WORD *)(v6 + 8) == 5)
          v5 = *(_QWORD *)(this[4].n128_u64[1] + 24);
        else
          v5 = 0;
      }
      else
      {
        v5 = 0;
      }
    }
    v7 = *(void (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v5 + 416);
    if (a2 == 2)
    {
      v7(v5, 1, 0);
      (*(void (**)(uint64_t, __n128 *, uint64_t))(*(_QWORD *)v5 + 320))(v5, this + 21, 1);
      v8.n128_f64[0] = (*(double (**)(uint64_t, __n128 *, uint64_t))(*(_QWORD *)v5 + 336))(v5, this + 22, 1);
      re::PhysXRigidBody::updateUnderlyingRigidBody((uint64_t)this, v8);
    }
    else
    {
      v7(v5, 4, 0);
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v5 + 416))(v5, 1, 1);
    }
  }
  this[21].n128_u64[0] = 0;
  this[21].n128_u64[1] = 0;
  result = this[21];
  this[22] = result;
  return result;
}

_WORD *re::PhysXRigidBody::lockTranslationX(re::PhysXRigidBody *this)
{
  _WORD *result;
  uint64_t var1;

  result = *(_WORD **)(*((_QWORD *)this + 9) + 24);
  if (result)
  {
    if (result[4] == 5)
    {
      (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)result + 552))(&var1);
      return (_WORD *)(var1 & 1);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

_WORD *re::PhysXRigidBody::lockTranslationY(re::PhysXRigidBody *this)
{
  _WORD *result;
  uint64_t var1;

  result = *(_WORD **)(*((_QWORD *)this + 9) + 24);
  if (result)
  {
    if (result[4] == 5)
    {
      (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)result + 552))(&var1);
      return (_WORD *)((var1 >> 1) & 1);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

_WORD *re::PhysXRigidBody::lockTranslationZ(re::PhysXRigidBody *this)
{
  _WORD *result;
  uint64_t var1;

  result = *(_WORD **)(*((_QWORD *)this + 9) + 24);
  if (result)
  {
    if (result[4] == 5)
    {
      (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)result + 552))(&var1);
      return (_WORD *)((var1 >> 2) & 1);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

_QWORD *re::PhysXRigidBody::setLockTranslationX(_QWORD *this, uint64_t a2)
{
  _WORD *v2;
  _QWORD *v4;
  uint64_t v5;

  v2 = *(_WORD **)(this[9] + 24);
  if (v2)
  {
    if (v2[4] == 5)
    {
      v4 = this;
      this = (*(_QWORD *(**)(uint64_t *__return_ptr, _QWORD))(*(_QWORD *)v2 + 552))(&v5, *(_QWORD *)(this[9] + 24));
      if ((v5 & 1) != (_DWORD)a2)
      {
        this = (_QWORD *)(*(uint64_t (**)(_WORD *, uint64_t, uint64_t))(*(_QWORD *)v2 + 560))(v2, 1, a2);
        if ((a2 & 1) == 0)
          return re::PhysXRigidBody::wakeUp(v4);
      }
    }
  }
  return this;
}

_QWORD *re::PhysXRigidBody::wakeUp(_QWORD *this)
{
  _WORD *v1;
  uint64_t v2;

  v1 = *(_WORD **)(this[9] + 24);
  if (v1 && v1[4] == 5)
  {
    this = (*(_QWORD *(**)(uint64_t *__return_ptr, _QWORD))(*(_QWORD *)v1 + 432))(&v2, *(_QWORD *)(this[9] + 24));
    if ((v2 & 1) == 0)
      return (_QWORD *)(*(uint64_t (**)(_WORD *))(*(_QWORD *)v1 + 592))(v1);
  }
  return this;
}

_QWORD *re::PhysXRigidBody::setLockTranslationY(_QWORD *this, uint64_t a2)
{
  _WORD *v2;
  _QWORD *v4;
  uint64_t v5;

  v2 = *(_WORD **)(this[9] + 24);
  if (v2)
  {
    if (v2[4] == 5)
    {
      v4 = this;
      this = (*(_QWORD *(**)(uint64_t *__return_ptr, _QWORD))(*(_QWORD *)v2 + 552))(&v5, *(_QWORD *)(this[9] + 24));
      if ((_DWORD)a2 != (v5 & 2) >> 1)
      {
        this = (_QWORD *)(*(uint64_t (**)(_WORD *, uint64_t, uint64_t))(*(_QWORD *)v2 + 560))(v2, 2, a2);
        if ((a2 & 1) == 0)
          return re::PhysXRigidBody::wakeUp(v4);
      }
    }
  }
  return this;
}

_QWORD *re::PhysXRigidBody::setLockTranslationZ(_QWORD *this, uint64_t a2)
{
  _WORD *v2;
  _QWORD *v4;
  uint64_t v5;

  v2 = *(_WORD **)(this[9] + 24);
  if (v2)
  {
    if (v2[4] == 5)
    {
      v4 = this;
      this = (*(_QWORD *(**)(uint64_t *__return_ptr, _QWORD))(*(_QWORD *)v2 + 552))(&v5, *(_QWORD *)(this[9] + 24));
      if ((_DWORD)a2 != (v5 & 4) >> 2)
      {
        this = (_QWORD *)(*(uint64_t (**)(_WORD *, uint64_t, uint64_t))(*(_QWORD *)v2 + 560))(v2, 4, a2);
        if ((a2 & 1) == 0)
          return re::PhysXRigidBody::wakeUp(v4);
      }
    }
  }
  return this;
}

_WORD *re::PhysXRigidBody::lockRotationX(re::PhysXRigidBody *this)
{
  _WORD *result;
  uint64_t var1;

  result = *(_WORD **)(*((_QWORD *)this + 9) + 24);
  if (result)
  {
    if (result[4] == 5)
    {
      (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)result + 552))(&var1);
      return (_WORD *)((var1 >> 3) & 1);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

_WORD *re::PhysXRigidBody::lockRotationY(re::PhysXRigidBody *this)
{
  _WORD *result;
  uint64_t var1;

  result = *(_WORD **)(*((_QWORD *)this + 9) + 24);
  if (result)
  {
    if (result[4] == 5)
    {
      (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)result + 552))(&var1);
      return (_WORD *)((var1 >> 4) & 1);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

_WORD *re::PhysXRigidBody::lockRotationZ(re::PhysXRigidBody *this)
{
  _WORD *result;
  uint64_t var1;

  result = *(_WORD **)(*((_QWORD *)this + 9) + 24);
  if (result)
  {
    if (result[4] == 5)
    {
      (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)result + 552))(&var1);
      return (_WORD *)((var1 >> 5) & 1);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

_QWORD *re::PhysXRigidBody::setLockRotationX(_QWORD *this, uint64_t a2)
{
  _WORD *v2;
  uint64_t v4;

  v2 = *(_WORD **)(this[9] + 24);
  if (v2 && v2[4] == 5)
  {
    this = (*(_QWORD *(**)(uint64_t *__return_ptr, _QWORD))(*(_QWORD *)v2 + 552))(&v4, *(_QWORD *)(this[9] + 24));
    if ((_DWORD)a2 != (v4 & 8) >> 3)
      return (_QWORD *)(*(uint64_t (**)(_WORD *, uint64_t, uint64_t))(*(_QWORD *)v2 + 560))(v2, 8, a2);
  }
  return this;
}

_QWORD *re::PhysXRigidBody::setLockRotationY(_QWORD *this, uint64_t a2)
{
  _WORD *v2;
  uint64_t v4;

  v2 = *(_WORD **)(this[9] + 24);
  if (v2 && v2[4] == 5)
  {
    this = (*(_QWORD *(**)(uint64_t *__return_ptr, _QWORD))(*(_QWORD *)v2 + 552))(&v4, *(_QWORD *)(this[9] + 24));
    if ((_DWORD)a2 != (v4 & 0x10) >> 4)
      return (_QWORD *)(*(uint64_t (**)(_WORD *, uint64_t, uint64_t))(*(_QWORD *)v2 + 560))(v2, 16, a2);
  }
  return this;
}

_QWORD *re::PhysXRigidBody::setLockRotationZ(_QWORD *this, uint64_t a2)
{
  _WORD *v2;
  uint64_t v4;

  v2 = *(_WORD **)(this[9] + 24);
  if (v2 && v2[4] == 5)
  {
    this = (*(_QWORD *(**)(uint64_t *__return_ptr, _QWORD))(*(_QWORD *)v2 + 552))(&v4, *(_QWORD *)(this[9] + 24));
    if ((_DWORD)a2 != (v4 & 0x20) >> 5)
      return (_QWORD *)(*(uint64_t (**)(_WORD *, uint64_t, uint64_t))(*(_QWORD *)v2 + 560))(v2, 32, a2);
  }
  return this;
}

uint64_t re::PhysXRigidBody::setPoseInternal(uint64_t a1, float32x4_t *a2)
{
  __int32 v3;
  uint64_t result;
  int v13;
  _WORD *v14;
  float v15[8];
  float v16[8];
  float32x4_t v17;
  uint64_t v18;
  __int32 v19;

  v3 = a2->i32[2];
  _Q1 = a2[1];
  _Q2 = vmulq_f32(_Q1, _Q1);
  _S3 = a2[1].i64[1];
  __asm { FMLA            S2, S3, V1.S[2] }
  _S3 = _Q1.i32[3];
  __asm { FMLA            S2, S3, V1.S[3] }
  _Q2.f32[0] = sqrtf(_Q2.f32[0]);
  v17 = vdivq_f32(_Q1, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)_Q2.f32, 0));
  v18 = a2->i64[0];
  v19 = v3;
  (*(void (**)(float *__return_ptr))(**(_QWORD **)(*(_QWORD *)(a1 + 72) + 24) + 152))(v15);
  re::internal::nvphysx::fromPhysX((uint64_t)v15, v16);
  re::internal::nvphysx::fromPhysX((uint64_t)&v17, v15);
  result = re::areAlmostEqual<float>(v15, v16);
  v13 = result;
  v14 = *(_WORD **)(*(_QWORD *)(a1 + 72) + 24);
  if (v14
    && v14[4] == 5
    && (result = (uint64_t)(*(_QWORD *(**)(float *__return_ptr, _WORD *))(*(_QWORD *)v14 + 432))(v15, v14),
        (LOBYTE(v15[0]) & 1) != 0))
  {
    if (!v13
      || (result = (*(uint64_t (**)(_WORD *, float *))(*(_QWORD *)v14 + 504))(v14, v15),
          (result | v13 ^ 1) == 1))
    {
      result = (*(uint64_t (**)(_WORD *, float32x4_t *))(*(_QWORD *)v14 + 496))(v14, &v17);
    }
    *(_BYTE *)(a1 + 440) = 1;
  }
  else if ((v13 & 1) == 0)
  {
    return (*(uint64_t (**)(_QWORD, float32x4_t *, uint64_t))(**(_QWORD **)(*(_QWORD *)(a1 + 72) + 24) + 160))(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 24), &v17, 1);
  }
  return result;
}

_QWORD *re::PhysXRigidBody::pose@<X0>(re::PhysXRigidBody *this@<X0>, _QWORD *a2@<X8>)
{
  _QWORD v4[3];

  (*(void (**)(_QWORD *__return_ptr))(**(_QWORD **)(*((_QWORD *)this + 9) + 24) + 152))(v4);
  return re::internal::nvphysx::fromPhysX((uint64_t)v4, a2);
}

_QWORD *re::PhysXRigidBody::poseCenterOfMass@<X0>(re::PhysXRigidBody *this@<X0>, _QWORD *a2@<X8>)
{
  float v4[7];

  worldSpaceCenterOfMassPose(v4, *(_QWORD *)(*((_QWORD *)this + 9) + 24));
  return re::internal::nvphysx::fromPhysX((uint64_t)v4, a2);
}

float worldSpaceCenterOfMassPose(float *a1, uint64_t a2)
{
  float result;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  uint64_t v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;

  (*(void (**)(uint64_t))(*(_QWORD *)a2 + 152))(a2);
  if ((*(unsigned int (**)(uint64_t, const char *))(*(_QWORD *)a2 + 40))(a2, "PxRigidBody"))
  {
    (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(_QWORD *)a2 + 224))(&v17, a2);
    v6 = a1[2];
    v5 = a1[3];
    v7 = (float)(v5 * v5) + -0.5;
    v8 = a1[1];
    v9 = (float)((float)((float)(v21 + v21) * v8) + (float)(*a1 * (float)(v20 + v20)))
       + (float)(v6 * (float)(v22 + v22));
    v10 = (float)((float)(v5 * (float)((float)(*a1 * (float)(v21 + v21)) - (float)(v8 * (float)(v20 + v20))))
                + (float)((float)(v22 + v22) * v7))
        + (float)(v6 * v9);
    v11 = a1[4]
        + (float)((float)((float)(v5 * (float)((float)(v8 * (float)(v22 + v22)) - (float)(v6 * (float)(v21 + v21))))
                        + (float)((float)(v20 + v20) * v7))
                + (float)(*a1 * v9));
    v12 = a1[5]
        + (float)((float)((float)(v5 * (float)((float)(v6 * (float)(v20 + v20)) - (float)(*a1 * (float)(v22 + v22))))
                        + (float)((float)(v21 + v21) * v7))
                + (float)(v8 * v9));
    v13 = (float)((float)((float)(v8 * v19) + (float)(v5 * *((float *)&v17 + 1))) + (float)(v6 * *(float *)&v17))
        - (float)(v18 * *a1);
    v14 = (float)((float)((float)(v6 * v19) + (float)(v5 * v18)) + (float)(*a1 * *((float *)&v17 + 1)))
        - (float)(*(float *)&v17 * v8);
    v15 = a1[6];
    v16 = (float)((float)((float)(v5 * v19) - (float)(*a1 * *(float *)&v17)) - (float)(v8 * *((float *)&v17 + 1)))
        - (float)(v6 * v18);
    *a1 = (float)((float)((float)(*a1 * v19) + (float)(v5 * *(float *)&v17)) + (float)(v8 * v18))
        - (float)(*((float *)&v17 + 1) * v6);
    a1[1] = v13;
    a1[2] = v14;
    a1[3] = v16;
    result = v15 + v10;
    a1[4] = v11;
    a1[5] = v12;
    a1[6] = result;
  }
  return result;
}

uint64_t re::PhysXRigidBody::linearVelocity(re::PhysXRigidBody *this)
{
  _WORD *v1;
  uint64_t v4;
  uint64_t v5;

  v1 = *(_WORD **)(*((_QWORD *)this + 9) + 24);
  if (!v1 || v1[4] != 5)
    return 0;
  (*(void (**)(uint64_t *__return_ptr, _QWORD))(*(_QWORD *)v1 + 432))(&v5, *(_QWORD *)(*((_QWORD *)this + 9) + 24));
  if ((v5 & 1) == 0)
  {
    (*(void (**)(uint64_t *__return_ptr, _WORD *))(*(_QWORD *)v1 + 312))(&v4, v1);
    return v4;
  }
  if (!*((_BYTE *)this + 440))
    return *((_QWORD *)this + 42);
  else
    return 0;
}

float32x4_t *re::PhysXRigidBody::setLinearVelocity(float32x4_t *result, float32x4_t *a2)
{
  _WORD *v2;
  float32x4_t *v4;
  float32x4_t v5;
  uint32x4_t v6;
  float32x4_t v7;
  uint64_t v8;
  __int32 v9;
  uint64_t v10;

  v2 = *(_WORD **)(result[4].i64[1] + 24);
  if (v2 && v2[4] == 5)
  {
    v4 = result;
    result = (float32x4_t *)(*(_QWORD *(**)(uint64_t *__return_ptr, _QWORD))(*(_QWORD *)v2 + 432))(&v10, *(_QWORD *)(result[4].i64[1] + 24));
    if ((v10 & 1) != 0)
    {
      v4[21] = *a2;
      v7 = vmulq_f32(*a2, *a2);
      if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2), vaddq_f32(v7, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 1))).f32[0]) >= 0.00001)v4[27].i8[8] = 0;
    }
    else
    {
      result = (float32x4_t *)(*(_QWORD *(**)(uint64_t *__return_ptr, _WORD *))(*(_QWORD *)v2 + 312))(&v8, v2);
      v5.i64[0] = v8;
      v5.i32[2] = v9;
      v6 = (uint32x4_t)vmvnq_s8((int8x16_t)vceqq_f32(*a2, v5));
      v6.i32[3] = v6.i32[2];
      if ((vmaxvq_u32(v6) & 0x80000000) != 0)
        return (float32x4_t *)(*(uint64_t (**)(_WORD *, float32x4_t *, uint64_t))(*(_QWORD *)v2 + 320))(v2, a2, 1);
    }
  }
  return result;
}

uint64_t re::PhysXRigidBody::angularVelocity(re::PhysXRigidBody *this)
{
  _WORD *v1;
  uint64_t v4;
  uint64_t v5;

  v1 = *(_WORD **)(*((_QWORD *)this + 9) + 24);
  if (!v1 || v1[4] != 5)
    return 0;
  (*(void (**)(uint64_t *__return_ptr, _QWORD))(*(_QWORD *)v1 + 432))(&v5, *(_QWORD *)(*((_QWORD *)this + 9) + 24));
  if ((v5 & 1) == 0)
  {
    (*(void (**)(uint64_t *__return_ptr, _WORD *))(*(_QWORD *)v1 + 328))(&v4, v1);
    return v4;
  }
  if (!*((_BYTE *)this + 440))
    return *((_QWORD *)this + 44);
  else
    return 0;
}

float32x4_t *re::PhysXRigidBody::setAngularVelocity(float32x4_t *result, float32x4_t *a2)
{
  _WORD *v2;
  float32x4_t *v4;
  float32x4_t v5;
  uint32x4_t v6;
  float32x4_t v7;
  uint64_t v8;
  __int32 v9;
  uint64_t v10;

  v2 = *(_WORD **)(result[4].i64[1] + 24);
  if (v2 && v2[4] == 5)
  {
    v4 = result;
    result = (float32x4_t *)(*(_QWORD *(**)(uint64_t *__return_ptr, _QWORD))(*(_QWORD *)v2 + 432))(&v10, *(_QWORD *)(result[4].i64[1] + 24));
    if ((v10 & 1) != 0)
    {
      v4[22] = *a2;
      v7 = vmulq_f32(*a2, *a2);
      if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2), vaddq_f32(v7, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 1))).f32[0]) >= 0.00001)v4[27].i8[8] = 0;
    }
    else
    {
      result = (float32x4_t *)(*(_QWORD *(**)(uint64_t *__return_ptr, _WORD *))(*(_QWORD *)v2 + 328))(&v8, v2);
      v5.i64[0] = v8;
      v5.i32[2] = v9;
      v6 = (uint32x4_t)vmvnq_s8((int8x16_t)vceqq_f32(*a2, v5));
      v6.i32[3] = v6.i32[2];
      if ((vmaxvq_u32(v6) & 0x80000000) != 0)
        return (float32x4_t *)(*(uint64_t (**)(_WORD *, float32x4_t *, uint64_t))(*(_QWORD *)v2 + 336))(v2, a2, 1);
    }
  }
  return result;
}

_QWORD *re::PhysXRigidBody::applyLinearImpulse(_QWORD *result, float32x4_t *a2)
{
  _WORD *v2;
  float32x4_t v4;
  uint64_t v5;

  v2 = *(_WORD **)(result[9] + 24);
  if (v2)
  {
    if (v2[4] == 5)
    {
      result = (*(_QWORD *(**)(uint64_t *__return_ptr, _QWORD))(*(_QWORD *)v2 + 432))(&v5, *(_QWORD *)(result[9] + 24));
      if ((v5 & 1) == 0)
      {
        v4 = vmulq_f32(*a2, *a2);
        if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v4, 2), vaddq_f32(v4, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.f32, 1))).f32[0] >= 0.00000011921)return (_QWORD *)(*(uint64_t (**)(_WORD *, float32x4_t *, uint64_t, uint64_t))(*(_QWORD *)v2 + 376))(v2, a2, 1, 1);
      }
    }
  }
  return result;
}

_QWORD *re::PhysXRigidBody::applyForce(_QWORD *result, float32x4_t *a2, int a3)
{
  _WORD *v3;
  float32x4_t v6;
  uint64_t v7;
  uint64_t v8;

  v3 = *(_WORD **)(result[9] + 24);
  if (v3)
  {
    if (v3[4] == 5)
    {
      result = (*(_QWORD *(**)(uint64_t *__return_ptr, _QWORD))(*(_QWORD *)v3 + 432))(&v8, *(_QWORD *)(result[9] + 24));
      if ((v8 & 1) == 0)
      {
        v6 = vmulq_f32(*a2, *a2);
        if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v6, 2), vaddq_f32(v6, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v6.f32, 1))).f32[0] >= 0.00000011921)
        {
          if ((a3 - 1) < 3)
            v7 = (a3 - 1) + 1;
          else
            v7 = 0;
          return (_QWORD *)(*(uint64_t (**)(_WORD *, float32x4_t *, uint64_t, uint64_t))(*(_QWORD *)v3 + 376))(v3, a2, v7, 1);
        }
      }
    }
  }
  return result;
}

_QWORD *re::PhysXRigidBody::applyTorque(_QWORD *result, float32x4_t *a2, int a3)
{
  _WORD *v3;
  float32x4_t v6;
  uint64_t v7;
  uint64_t v8;

  v3 = *(_WORD **)(result[9] + 24);
  if (v3)
  {
    if (v3[4] == 5)
    {
      result = (*(_QWORD *(**)(uint64_t *__return_ptr, _QWORD))(*(_QWORD *)v3 + 432))(&v8, *(_QWORD *)(result[9] + 24));
      if ((v8 & 1) == 0)
      {
        v6 = vmulq_f32(*a2, *a2);
        if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v6, 2), vaddq_f32(v6, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v6.f32, 1))).f32[0] >= 0.00000011921)
        {
          if ((a3 - 1) < 3)
            v7 = (a3 - 1) + 1;
          else
            v7 = 0;
          return (_QWORD *)(*(uint64_t (**)(_WORD *, float32x4_t *, uint64_t, uint64_t))(*(_QWORD *)v3 + 384))(v3, a2, v7, 1);
        }
      }
    }
  }
  return result;
}

_QWORD *re::PhysXRigidBody::applyAngularImpulse(_QWORD *result, float32x4_t *a2)
{
  _WORD *v2;
  float32x4_t v4;
  uint64_t v5;

  v2 = *(_WORD **)(result[9] + 24);
  if (v2)
  {
    if (v2[4] == 5)
    {
      result = (*(_QWORD *(**)(uint64_t *__return_ptr, _QWORD))(*(_QWORD *)v2 + 432))(&v5, *(_QWORD *)(result[9] + 24));
      if ((v5 & 1) == 0)
      {
        v4 = vmulq_f32(*a2, *a2);
        if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v4, 2), vaddq_f32(v4, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.f32, 1))).f32[0] >= 0.00000011921)return (_QWORD *)(*(uint64_t (**)(_WORD *, float32x4_t *, uint64_t, uint64_t))(*(_QWORD *)v2 + 384))(v2, a2, 1, 1);
      }
    }
  }
  return result;
}

_QWORD *re::PhysXRigidBody::applyImpulse(_QWORD *result, float32x4_t *a2, uint64_t a3)
{
  _WORD *v3;
  uint64_t v6;

  v3 = *(_WORD **)(result[9] + 24);
  if (v3 && v3[4] == 5)
  {
    result = (*(_QWORD *(**)(uint64_t *__return_ptr, _QWORD))(*(_QWORD *)v3 + 432))(&v6, *(_QWORD *)(result[9] + 24));
    if ((v6 & 1) == 0)
      return (_QWORD *)addForce((uint64_t)v3, 1, a3, 1, *a2);
  }
  return result;
}

uint64_t addForce(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, float32x4_t a5)
{
  uint64_t v5;
  uint64_t v6;
  float32x4_t v7;
  uint64_t v11;
  float32x2_t v14;
  float32x2_t v16;
  float32x2_t v17;
  float32x2_t v23;
  __int32 v24;
  float v25;
  float32x2_t v26;
  unint64_t v27;
  unsigned __int32 v28;
  uint64_t v29;
  uint64_t v30;

  v7 = vmulq_f32(a5, a5);
  if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2), vaddq_f32(v7, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 1))).f32[0] >= 0.00000011921)
  {
    v29 = v5;
    v30 = v6;
    v11 = result;
    v27 = a5.i64[0];
    v28 = a5.u32[2];
    worldSpaceCenterOfMassPose((float *)&v23, result);
    _S0 = *(float *)a3 - v25;
    _D1 = vsub_f32(*(float32x2_t *)(a3 + 4), v26);
    v14.i32[0] = vdup_lane_s32((int32x2_t)_D1, 1).u32[0];
    v14.f32[1] = _S0;
    _Q4 = (int8x16_t)a5;
    v16.i32[0] = vextq_s8(_Q4, _Q4, 8uLL).u32[0];
    v16.i32[1] = a5.i32[0];
    v17 = vmla_f32(vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(_Q4, _Q4, 4uLL), vneg_f32(v14)), v16, _D1);
    __asm { FMLA            S1, S0, V4.S[1] }
    v23 = v17;
    v24 = _D1.i32[0];
    (*(void (**)(uint64_t, float32x2_t *, uint64_t, uint64_t))(*(_QWORD *)v11 + 384))(v11, &v23, a2, a4);
    return (*(uint64_t (**)(uint64_t, unint64_t *, uint64_t, uint64_t))(*(_QWORD *)v11 + 376))(v11, &v27, a2, a4);
  }
  return result;
}

_QWORD *re::PhysXRigidBody::applyForce(_QWORD *result, float32x4_t *a2, uint64_t a3, uint64_t a4)
{
  _WORD *v4;
  uint64_t v8;

  v4 = *(_WORD **)(result[9] + 24);
  if (v4 && v4[4] == 5)
  {
    result = (*(_QWORD *(**)(uint64_t *__return_ptr, _QWORD))(*(_QWORD *)v4 + 432))(&v8, *(_QWORD *)(result[9] + 24));
    if ((v8 & 1) == 0)
      return (_QWORD *)addForce((uint64_t)v4, 0, a3, a4, *a2);
  }
  return result;
}

_QWORD *re::PhysXRigidBody::applyForce(_QWORD *result, float32x4_t *a2, uint64_t a3)
{
  _WORD *v3;
  float32x4_t v6;
  uint64_t v7;

  v3 = *(_WORD **)(result[9] + 24);
  if (v3)
  {
    if (v3[4] == 5)
    {
      result = (*(_QWORD *(**)(uint64_t *__return_ptr, _QWORD))(*(_QWORD *)v3 + 432))(&v7, *(_QWORD *)(result[9] + 24));
      if ((v7 & 1) == 0)
      {
        v6 = vmulq_f32(*a2, *a2);
        if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v6, 2), vaddq_f32(v6, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v6.f32, 1))).f32[0] >= 0.00000011921)return (_QWORD *)(*(uint64_t (**)(_WORD *, float32x4_t *, _QWORD, uint64_t))(*(_QWORD *)v3 + 376))(v3, a2, 0, a3);
      }
    }
  }
  return result;
}

_QWORD *re::PhysXRigidBody::applyTorque(_QWORD *result, float32x4_t *a2, uint64_t a3)
{
  _WORD *v3;
  float32x4_t v6;
  uint64_t v7;

  v3 = *(_WORD **)(result[9] + 24);
  if (v3)
  {
    if (v3[4] == 5)
    {
      result = (*(_QWORD *(**)(uint64_t *__return_ptr, _QWORD))(*(_QWORD *)v3 + 432))(&v7, *(_QWORD *)(result[9] + 24));
      if ((v7 & 1) == 0)
      {
        v6 = vmulq_f32(*a2, *a2);
        if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v6, 2), vaddq_f32(v6, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v6.f32, 1))).f32[0] >= 0.00000011921)return (_QWORD *)(*(uint64_t (**)(_WORD *, float32x4_t *, _QWORD, uint64_t))(*(_QWORD *)v3 + 384))(v3, a2, 0, a3);
      }
    }
  }
  return result;
}

_QWORD *re::PhysXRigidBody::applyUserForces(float32x4_t *this)
{
  float32x4_t v3;

  v3 = vaddq_f32(this[15], this[23]);
  re::PhysXRigidBody::applyForce(this, &v3, 1);
  v3 = vaddq_f32(this[16], this[24]);
  re::PhysXRigidBody::applyTorque(this, &v3, 1);
  v3 = vaddq_f32(this[17], this[25]);
  re::PhysXRigidBody::applyLinearImpulse(this, &v3);
  v3 = vaddq_f32(this[18], this[26]);
  return re::PhysXRigidBody::applyAngularImpulse(this, &v3);
}

uint64_t re::PhysXRigidBody::canSleep(re::PhysXRigidBody *this)
{
  return *((unsigned __int8 *)this + 320);
}

_WORD *re::PhysXRigidBody::setCanSleep(_WORD *this, int a2)
{
  if ((*((_BYTE *)this + 320) != 0) != a2)
  {
    *((_BYTE *)this + 320) = a2;
    if ((a2 & 1) != 0)
    {
      return re::PhysXRigidBody::updateSleepThreshold((re::PhysXRigidBody *)this);
    }
    else
    {
      this = *(_WORD **)(*((_QWORD *)this + 9) + 24);
      if (this)
      {
        if (this[4] == 5)
          return (_WORD *)(*(uint64_t (**)(_WORD *, float))(*(_QWORD *)this + 520))(this, 0.0);
      }
    }
  }
  return this;
}

uint64_t re::PhysXRigidBody::isSleeping(re::PhysXRigidBody *this)
{
  _WORD *v1;
  uint64_t v3;

  v1 = *(_WORD **)(*((_QWORD *)this + 9) + 24);
  if (v1
    && v1[4] == 5
    && ((*(void (**)(uint64_t *__return_ptr, _QWORD))(*(_QWORD *)v1 + 432))(&v3, *(_QWORD *)(*((_QWORD *)this + 9) + 24)), (v3 & 1) == 0))
  {
    return (*(uint64_t (**)(_WORD *))(*(_QWORD *)v1 + 512))(v1);
  }
  else
  {
    return 0;
  }
}

_QWORD *re::PhysXRigidBody::sleep(_QWORD *this)
{
  _WORD *v1;
  uint64_t v2;

  v1 = *(_WORD **)(this[9] + 24);
  if (v1 && v1[4] == 5)
  {
    this = (*(_QWORD *(**)(uint64_t *__return_ptr, _QWORD))(*(_QWORD *)v1 + 432))(&v2, *(_QWORD *)(this[9] + 24));
    if ((v2 & 1) == 0)
      return (_QWORD *)(*(uint64_t (**)(_WORD *))(*(_QWORD *)v1 + 600))(v1);
  }
  return this;
}

double re::PhysXRigidBody::clearForces(re::PhysXRigidBody *this)
{
  _WORD *v2;
  double result;
  uint64_t v4;

  v2 = *(_WORD **)(*((_QWORD *)this + 9) + 24);
  if (v2)
  {
    if (v2[4] == 5)
    {
      (*(void (**)(uint64_t *__return_ptr, _QWORD))(*(_QWORD *)v2 + 432))(&v4, *(_QWORD *)(*((_QWORD *)this + 9) + 24));
      if ((v4 & 1) == 0)
      {
        (*(void (**)(_WORD *, _QWORD))(*(_QWORD *)v2 + 392))(v2, 0);
        (*(void (**)(_WORD *, _QWORD))(*(_QWORD *)v2 + 400))(v2, 0);
      }
    }
  }
  result = 0.0;
  *((_OWORD *)this + 17) = 0u;
  *((_OWORD *)this + 18) = 0u;
  *((_OWORD *)this + 15) = 0u;
  *((_OWORD *)this + 16) = 0u;
  return result;
}

void re::PhysXRigidBody::onScaleChanged(uint64_t a1, uint64_t a2, float32x4_t *a3)
{
  double v5;
  __int128 v6;
  __int128 v7;
  _WORD *v8;
  __int128 v9;
  uint64_t v10;
  int v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  int v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  re::GeometricObjectBase::scalePose((float32x4_t *)a1, a3, 1);
  re::MassFrame::makeScaledFrame(a1 + 80, a3, (uint64_t)&v12, v5);
  *(_DWORD *)(a1 + 192) = v15;
  v6 = v14;
  v7 = v12;
  *(_OWORD *)(a1 + 160) = v13;
  *(_OWORD *)(a1 + 176) = v6;
  *(_OWORD *)(a1 + 144) = v7;
  v8 = *(_WORD **)(*(_QWORD *)(a1 + 72) + 24);
  if (v8 && v8[4] == 5)
  {
    (*(void (**)(_WORD *))(*(_QWORD *)v8 + 232))(v8);
    (*(void (**)(_WORD *, __int128 *))(*(_QWORD *)v8 + 256))(v8, &v14);
    v9 = v13;
    v10 = v12;
    v11 = DWORD2(v12);
    (*(void (**)(_WORD *, __int128 *))(*(_QWORD *)v8 + 216))(v8, &v9);
    if ((*(uint64_t (**)(_WORD *))(*(_QWORD *)v8 + 56))(v8))
      (*(void (**)(_WORD *))(*(_QWORD *)v8 + 592))(v8);
  }
}

float32x4_t *re::PhysXRigidBody::updateKinematicTargetFromVelocity(float32x4_t *this, float a2)
{
  uint64_t v2;
  float32x4_t *v3;
  uint64_t v4;
  float32x2_t v6;
  float v7;
  float v8;
  float32x4_t v9;
  float32x4_t v10;
  float v11;
  float32x4_t v12;
  float v13;
  double v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float32x4_t v19;
  int8x16_t v20;
  float32x4_t v21;
  int8x16_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  int8x16_t v26;
  float32x4_t v27;
  float32x4_t v35;
  int8x16_t v37;
  int32x4_t v38;
  float32x2_t v39;
  float v40;
  int32x4_t v41;
  float32x2_t v42;
  float v43;

  v2 = *(_QWORD *)(this[4].i64[1] + 24);
  if (v2)
  {
    v3 = this;
    v4 = *(_WORD *)(v2 + 8) == 5 ? *(_QWORD *)(this[4].i64[1] + 24) : 0;
    if (!this[27].i8[8] && v4 != 0)
    {
      this = (float32x4_t *)(*(_QWORD *(**)(int32x4_t *__return_ptr, uint64_t))(*(_QWORD *)v4 + 432))(&v41, v4);
      if ((v41.i8[0] & 1) != 0)
      {
        if ((*(unsigned int (**)(uint64_t, int32x4_t *))(*(_QWORD *)v4 + 504))(v4, &v41))
        {
          v6 = v42;
          v7 = v43;
        }
        else
        {
          (*(void (**)(int32x4_t *__return_ptr, uint64_t))(*(_QWORD *)v4 + 152))(&v38, v4);
          v41 = v38;
          v6 = v39;
          v7 = v40;
        }
        v8 = a2;
        v9 = v3[22];
        v10 = vmulq_n_f32(v3[21], a2);
        v42 = vadd_f32(v6, *(float32x2_t *)v10.f32);
        v11 = v7 + v10.f32[2];
        v12 = vmulq_f32(v9, v9);
        v43 = v11;
        v13 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 2), vaddq_f32(v12, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 1))).f32[0]);
        v14 = a2;
        if ((float)(v13 * a2) > 0.785398163)
          v13 = 0.785398163 / v14;
        if (v13 >= 0.001)
        {
          v16 = v13 * 0.5 * v14;
          v35 = v9;
          v17 = sinf(v16);
          v9 = v35;
          v8 = a2;
          v15 = v17 / v13;
        }
        else
        {
          v15 = (float)((float)(a2 * a2) * a2) * -0.0208333333 * v13 * v13 + v14 * 0.5;
        }
        v37 = (int8x16_t)vmulq_n_f32(v9, v15);
        v18 = cosf((float)(v13 * v8) * 0.5);
        v19 = (float32x4_t)v37;
        v20 = v37;
        v19.i32[3] = v37.i32[2];
        v21 = (float32x4_t)vzip1q_s32(v41, v41);
        v21.i32[0] = v41.i32[2];
        v22 = vextq_s8((int8x16_t)v19, (int8x16_t)v21, 0xCuLL);
        v19.f32[3] = -*(float *)v37.i32;
        v23 = vmlaq_n_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vdupq_laneq_s32(v41, 3), (int8x16_t)v41, 4uLL), v19), (float32x4_t)v41, v18);
        v24 = (float32x4_t)vextq_s8(vextq_s8(v20, v20, 0xCuLL), v37, 8uLL);
        v24.f32[3] = -*(float *)&v37.i32[1];
        v25 = vmlaq_f32(v23, v21, v24);
        v26 = vextq_s8(v22, (int8x16_t)vrev64q_s32((int32x4_t)v22), 8uLL);
        v27 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v20, (int32x4_t)v20), v37, 0xCuLL);
        v27.i32[3] = v41.i32[2];
        _Q1 = vmlsq_f32(v25, v27, (float32x4_t)vzip2q_s32(vzip1q_s32((int32x4_t)v26, (int32x4_t)vextq_s8(v26, v26, 0xCuLL)), (int32x4_t)v26));
        _Q0 = vmulq_f32(_Q1, _Q1);
        _S2 = _Q1.i32[2];
        __asm { FMLA            S0, S2, V1.S[2] }
        _S2 = _Q1.i32[3];
        __asm { FMLA            S0, S2, V1.S[3] }
        _Q0.f32[0] = sqrtf(_Q0.f32[0]);
        if (_Q0.f32[0] != 0.0)
          _Q1 = vdivq_f32(_Q1, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)_Q0.f32, 0));
        v41 = (int32x4_t)_Q1;
        return (float32x4_t *)(*(uint64_t (**)(uint64_t, int32x4_t *))(*(_QWORD *)v4 + 496))(v4, &v41);
      }
    }
  }
  return this;
}

float re::PhysXRigidBody::linearDamping(re::PhysXRigidBody *this)
{
  return *((float *)this + 81);
}

float re::PhysXRigidBody::angularDamping(re::PhysXRigidBody *this)
{
  return *((float *)this + 82);
}

void re::PhysXRigidBody::setDamping(re::PhysXRigidBody *this, float a2, float a3)
{
  _WORD *v3;
  __n128 v7;
  float v8;
  __n128 v9;

  *((float *)this + 81) = a2;
  *((float *)this + 82) = a3;
  v3 = *(_WORD **)(*((_QWORD *)this + 9) + 24);
  if (v3 && v3[4] == 5)
  {
    if ((*(float (**)(_QWORD))(*(_QWORD *)v3 + 288))(*(_QWORD *)(*((_QWORD *)this + 9) + 24)) != a2)
    {
      v7.n128_u32[0] = 0;
      if (a2 >= 0.0)
        v7.n128_f32[0] = a2;
      (*(void (**)(_WORD *, __n128))(*(_QWORD *)v3 + 280))(v3, v7);
      re::PhysXRigidBody::updateSleepThreshold(this);
    }
    v8 = a3 * 5.0;
    if (v8 != (*(float (**)(_WORD *))(*(_QWORD *)v3 + 304))(v3))
    {
      v9.n128_u32[0] = 0;
      if (v8 >= 0.0)
        v9.n128_f32[0] = v8;
      (*(void (**)(_WORD *, __n128))(*(_QWORD *)v3 + 296))(v3, v9);
      re::PhysXRigidBody::updateSleepThreshold(this);
    }
  }
}

uint64_t re::PhysXRigidBody::material(re::PhysXRigidBody *this, uint64_t a2)
{
  uint64_t v3;
  uint64_t result;
  uint64_t v5;
  uint64_t v6;

  v3 = *(_QWORD *)(*((_QWORD *)this + 9) + 24);
  v6 = 0;
  (*(void (**)(uint64_t, uint64_t *, uint64_t, _QWORD))(*(_QWORD *)v3 + 192))(v3, &v6, 1, 0);
  result = v6;
  if (v6)
  {
    v5 = 0;
    (*(void (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(*(_QWORD *)v6 + 216))(v6, &v5, 1, a2);
    if (v5)
      return *(_QWORD *)(v5 + 16);
    else
      return 0;
  }
  return result;
}

uint64_t re::PhysXRigidBody::materialCount(re::PhysXRigidBody *this)
{
  uint64_t v1;
  uint64_t result;
  uint64_t v3;

  v1 = *(_QWORD *)(*((_QWORD *)this + 9) + 24);
  v3 = 0;
  (*(void (**)(uint64_t, uint64_t *, uint64_t, _QWORD))(*(_QWORD *)v1 + 192))(v1, &v3, 1, 0);
  result = v3;
  if (v3)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 208))(v3);
  return result;
}

BOOL re::PhysXRigidBody::shouldRemoveFromWorld(uint64_t a1, int a2, int a3)
{
  return !a2 || a3 == 0;
}

_QWORD *re::PhysXRigidBody::setGravityEnabled(re::PhysXRigidBody *this, int a2)
{
  uint64_t v4;
  _QWORD *result;
  uint64_t v6;
  uint64_t v7;

  v4 = *(_QWORD *)(*((_QWORD *)this + 9) + 24);
  result = (*(_QWORD *(**)(uint64_t *__return_ptr, uint64_t))(*(_QWORD *)v4 + 104))(&v7, v4);
  if (((v7 & 2) == 0) != a2)
  {
    v6 = a2 ^ 1u;
    result = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v4 + 88))(v4, 2, v6);
    if ((v6 & 1) == 0)
      return re::PhysXRigidBody::wakeUp(this);
  }
  return result;
}

BOOL re::PhysXRigidBody::gravityEnabled(re::PhysXRigidBody *this)
{
  uint64_t var1;

  (*(void (**)(uint64_t *__return_ptr))(**(_QWORD **)(*((_QWORD *)this + 9) + 24) + 104))(&var1);
  return (var1 & 2) == 0;
}

void re::PhysXRigidBody::poseDidChange(re::PhysXRigidBody *this, uint64_t a2)
{
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Not supported.", "!\"Unreachable code\"", "poseDidChange", 101);
  _os_crash();
  __break(1u);
}

uint64_t re::RigidBody::type(re::RigidBody *this)
{
  return 2;
}

re::PhysXHingeJoint *re::PhysXHingeJoint::PhysXHingeJoint(re::PhysXHingeJoint *this, physx::PxRevoluteJoint *a2, uint64_t a3)
{
  *(_QWORD *)this = &off_24ED7E488;
  ArcSharedObject::ArcSharedObject(this, 0);
  *((_QWORD *)this + 8) = &off_24ED7EED0;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = &str_110;
  *((_QWORD *)this + 5) = (char *)this + 64;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = 0xBF8000003F800000;
  *(_QWORD *)this = &off_24ED7E488;
  *((_QWORD *)this + 9) = a2;
  *((_QWORD *)a2 + 2) = this;
  (*(void (**)(physx::PxRevoluteJoint *, uint64_t, uint64_t))(*(_QWORD *)a2 + 128))(a2, 16, 1);
  (*(void (**)(_QWORD, uint64_t, uint64_t))(**((_QWORD **)this + 9) + 128))(*((_QWORD *)this + 9), 8, a3);
  return this;
}

uint64_t re::PhysXHingeJoint::updateLimits(re::PhysXHingeJoint *this)
{
  uint64_t v2;
  uint64_t result;
  float v4;
  float v5;
  float v6;
  _QWORD v7[2];
  float v8;
  int v9;
  float v10;

  v2 = *((_QWORD *)this + 9);
  result = (*(uint64_t (**)(uint64_t, uint64_t, BOOL))(*(_QWORD *)v2 + 328))(v2, 1, *((float *)this + 14) <= *((float *)this + 15));
  v5 = *((float *)this + 14);
  v4 = *((float *)this + 15);
  if (v5 <= v4)
  {
    v9 = *((_DWORD *)this + 15);
    v10 = v5;
    v6 = (float)(v4 - v5) * 0.49;
    if (v6 > 0.1)
      v6 = 0.1;
    v7[0] = 0x3F00000000000000;
    v7[1] = 0;
    v8 = v6;
    return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v2 + 256))(v2, v7);
  }
  return result;
}

void re::PhysXHingeJoint::~PhysXHingeJoint(re::PhysXHingeJoint *this)
{
  void (***v2)(_QWORD);

  *(_QWORD *)this = &off_24ED7E488;
  v2 = (void (***)(_QWORD))*((_QWORD *)this + 9);
  if (v2)
    (**v2)(v2);
  *(_QWORD *)this = &off_24ED7E818;
  re::StringID::destroyString((re::PhysXHingeJoint *)((char *)this + 24));
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  void (***v2)(_QWORD);

  *(_QWORD *)this = &off_24ED7E488;
  v2 = (void (***)(_QWORD))*((_QWORD *)this + 9);
  if (v2)
    (**v2)(v2);
  *(_QWORD *)this = &off_24ED7E818;
  re::StringID::destroyString((re::PhysXHingeJoint *)((char *)this + 24));
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

void re::PhysXPhysicsMaterial::~PhysXPhysicsMaterial(re::PhysXPhysicsMaterial *this)
{
  (***((void (****)(_QWORD))this + 3))(*((_QWORD *)this + 3));
}

{
  (***((void (****)(_QWORD))this + 3))(*((_QWORD *)this + 3));
  JUMPOUT(0x2276933B8);
}

double re::Explosion::didAddToSimulation(re::Explosion *this)
{
  double result;

  result = *(double *)(*((_QWORD *)this + 1) + 24) + *((float *)this + 13);
  *((double *)this + 8) = result;
  return result;
}

float32x4_t *re::Explosion::onApply(float32x4_t *this)
{
  float32x4_t *v1;
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  float32x4_t v7;
  float32x4_t v8;
  float v9;
  float v10;
  float32x4_t v11;
  float32x2_t v12;
  float32x2_t v13;
  float32x4_t v14[2];

  v1 = this;
  v2 = this->i64[1];
  if (*(double *)this[4].i64 <= *(double *)(v2 + 24))
    return (float32x4_t *)re::ForceEffectCollection::remove((re::ForceEffectCollection *)(v2 + 248), (re::ForceEffect *)this);
  v3 = *(_QWORD *)(v2 + 104);
  if (v3)
  {
    v4 = 0;
    v5 = v2 + 80;
    do
    {
      v6 = re::ecs2::ComponentTypeRegistry::operator[](v5, v4);
      this = (float32x4_t *)(*(_QWORD *(**)(float32x4_t *__return_ptr))(*(_QWORD *)v6 + 208))(v14);
      v7 = vsubq_f32(v14[0], v1[2]);
      v8 = vmulq_f32(v7, v7);
      v9 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v8, 2), vaddq_f32(v8, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.f32, 1))).f32[0];
      v10 = v1[3].f32[0] * v1[3].f32[0];
      if (v9 <= v10)
      {
        v11 = (float32x4_t)xmmword_2260E5F20;
        if (fabsf(v9) >= 1.0e-10)
        {
          v12 = vrsqrte_f32((float32x2_t)LODWORD(v9));
          v13 = vmul_f32(v12, vrsqrts_f32((float32x2_t)LODWORD(v9), vmul_f32(v12, v12)));
          v11 = vmulq_n_f32(v7, vmul_f32(v13, vrsqrts_f32((float32x2_t)LODWORD(v9), vmul_f32(v13, v13))).f32[0]);
        }
        v14[0] = vmulq_n_f32(v11, (float)(1.0 - (float)(v9 / v10)) * v1[3].f32[2]);
        this = (float32x4_t *)(*(uint64_t (**)(uint64_t, float32x4_t *, _QWORD))(*(_QWORD *)v6 + 384))(v6, v14, 0);
      }
      ++v4;
    }
    while (v3 != v4);
  }
  return this;
}

void re::Explosion::~Explosion(re::Explosion *this)
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::Explosion::type(re::Explosion *this)
{
  return 3;
}

_QWORD *re::ForceEffectCollection::add(re::ForceEffectCollection *this, re::ForceEffect *a2)
{
  _QWORD *result;
  re::ForceEffect *v4;
  uint64_t v5;
  uint64_t v6;
  re::ForceEffect *v7;

  v7 = a2;
  result = re::DynamicArray<re::TransitionCondition *>::add((_QWORD *)this + 1, &v7);
  v4 = v7;
  v5 = *(_QWORD *)this;
  v6 = *((_QWORD *)v7 + 1);
  if (v6 != v5)
  {
    if (v6)
      result = (_QWORD *)(*(uint64_t (**)(re::ForceEffect *))(*(_QWORD *)v7 + 48))(v7);
    *((_QWORD *)v4 + 1) = v5;
    if (v5)
      return (_QWORD *)(*(uint64_t (**)(re::ForceEffect *))(*(_QWORD *)v4 + 40))(v4);
  }
  return result;
}

BOOL re::ForceEffectCollection::remove(re::ForceEffectCollection *this, re::ForceEffect *a2)
{
  re::ForceEffect *v5;

  v5 = a2;
  if (*((_QWORD *)a2 + 1))
  {
    (*(void (**)(re::ForceEffect *))(*(_QWORD *)a2 + 48))(a2);
    *((_QWORD *)a2 + 1) = 0;
  }
  return re::DynamicArray<unsigned long long>::remove((uint64_t)this + 8, &v5);
}

BOOL re::MassFrame::operator==(float32x4_t *a1, float32x4_t *a2)
{
  uint32x4_t v2;
  uint32x4_t v3;

  v2 = (uint32x4_t)vceqq_f32(*a1, *a2);
  v2.i32[3] = v2.i32[2];
  if ((vminvq_u32(v2) & 0x80000000) != 0
    && (vminvq_u32((uint32x4_t)vceqq_f32(a1[1], a2[1])) & 0x80000000) != 0
    && (v3 = (uint32x4_t)vceqq_f32(a1[2], a2[2]), v3.i32[3] = v3.i32[2], (vminvq_u32(v3) & 0x80000000) != 0))
  {
    return a1[3].f32[0] == a2[3].f32[0];
  }
  else
  {
    return 0;
  }
}

unint64_t re::MassFrame::makeFromShapeAndDensity@<X0>(re::MassFrame *this@<X0>, const re::CollisionShape *a2@<X1>, float a3@<S0>, float32x4_t *a4@<X8>)
{
  unint64_t result;
  uint64_t v7;
  uint64_t v8;
  float v9;
  float32x4_t v10;
  float v11;
  __int128 v12;
  float32x4_t v13;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  float v19;
  int v20;
  __int128 v21;
  int v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  __int32 v26;

  result = (*(uint64_t (**)(re::MassFrame *, const re::CollisionShape *))(*(_QWORD *)this + 56))(this, a2);
  if ((_DWORD)result)
  {
    v7 = 0;
    v8 = 0;
    a4[1].i64[0] = 0;
    a4[1].i64[1] = 0x3F80000000000000;
    v9 = 0.0;
    v10 = 0uLL;
  }
  else
  {
    v19 = 0.0;
    v17 = 0u;
    v18 = 0u;
    v15 = 0u;
    v16 = 0u;
    (*(void (**)(re::MassFrame *, float *, __int128 *, __int128 *))(*(_QWORD *)this + 32))(this, &v19, &v18, &v15);
    v11 = v19;
    v20 = v15;
    *(_QWORD *)&v12 = *(_QWORD *)((char *)&v15 + 4);
    *((_QWORD *)&v12 + 1) = v16;
    v21 = v12;
    v22 = DWORD2(v16);
    v23 = v17;
    v24 = DWORD2(v17);
    result = physx::PxDiagonalize((float *)&v20, a4[1].f32, (float *)&v25);
    v9 = v11 * a3;
    v13.i64[0] = v25;
    v13.i32[2] = v26;
    v10 = vmulq_n_f32(v13, a3);
    v8 = *((_QWORD *)&v18 + 1);
    v7 = v18;
  }
  a4->i64[0] = v7;
  a4->i64[1] = v8;
  a4[2] = v10;
  a4[3].f32[0] = v9;
  return result;
}

unint64_t re::MassFrame::makeFromShapeAndMass@<X0>(re::MassFrame *this@<X0>, const re::CollisionShape *a2@<X1>, float a3@<S0>, float32x4_t *a4@<X8>)
{
  unint64_t result;
  uint64_t v8;
  uint64_t v9;
  float v10;
  float32x4_t v11;
  float v12;
  __int128 v13;
  float32x4_t v14;
  float v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  float v20;
  int v21;
  __int128 v22;
  int v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  __int32 v27;

  result = (*(uint64_t (**)(re::MassFrame *, const re::CollisionShape *))(*(_QWORD *)this + 56))(this, a2);
  if ((_DWORD)result)
  {
    v8 = 0;
    v9 = 0;
    a4[1].i64[0] = 0;
    a4[1].i64[1] = 0x3F80000000000000;
    v10 = 0.0;
    v11 = 0uLL;
  }
  else
  {
    v20 = 0.0;
    v18 = 0u;
    v19 = 0u;
    v16 = 0u;
    v17 = 0u;
    (*(void (**)(re::MassFrame *, float *, __int128 *, __int128 *))(*(_QWORD *)this + 32))(this, &v20, &v19, &v16);
    v12 = v20;
    v15 = a3 / v20;
    v21 = v16;
    *(_QWORD *)&v13 = *(_QWORD *)((char *)&v16 + 4);
    *((_QWORD *)&v13 + 1) = v17;
    v22 = v13;
    v23 = DWORD2(v17);
    v24 = v18;
    v25 = DWORD2(v18);
    result = physx::PxDiagonalize((float *)&v21, a4[1].f32, (float *)&v26);
    v10 = v12 * v15;
    v14.i64[0] = v26;
    v14.i32[2] = v27;
    v11 = vmulq_n_f32(v14, v15);
    v9 = *((_QWORD *)&v19 + 1);
    v8 = v19;
  }
  a4->i64[0] = v8;
  a4->i64[1] = v9;
  a4[2] = v11;
  a4[3].f32[0] = v10;
  return result;
}

float32x4_t re::MassFrame::makeScaledFrame@<Q0>(uint64_t a1@<X0>, float32x4_t *a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  float v4;
  float32x4_t v5;
  float32x4_t v6;
  float32x4_t v7;
  float32x4_t v8;
  float32x4_t v9;
  int32x4_t v10;
  float32x4_t v11;
  float v12;
  float v13;
  float32x4_t v14;
  __int128 v15;
  float32x4_t result;

  v4 = (float)(a2->f32[0] * a2->f32[1]) * a2->f32[2];
  v5 = *(float32x4_t *)(a1 + 32);
  v6.i64[0] = 0x3F0000003F000000;
  v6.i64[1] = 0x3F0000003F000000;
  v7 = vmulq_f32(v5, v6);
  v11 = vaddq_f32(v7, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 1));
  v8 = vsubq_f32((float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2), v11), 0), v5);
  v9 = *a2;
  v10 = (int32x4_t)vmulq_n_f32(vmulq_f32(*a2, vmulq_f32(*a2, v8)), v4);
  *(float32x2_t *)v11.f32 = vadd_f32((float32x2_t)vdup_laneq_s32(v10, 2), (float32x2_t)vrev64_s32(*(int32x2_t *)v10.i8));
  v12 = vaddv_f32(*(float32x2_t *)v10.i8);
  *(float *)&a4 = v4 * *(float *)(a1 + 48);
  v13 = 5000.0;
  if (*(float *)&a4 <= 5000.0)
    v13 = *(float *)&a4;
  if (v13 < 0.0002)
    v13 = 0.0002;
  if (*(float *)&a4 <= 0.0)
    v13 = 0.0;
  *(float *)(a3 + 48) = v13;
  v11.f32[2] = v12;
  v14 = vdivq_f32(vmulq_n_f32(v11, v13), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a4, 0));
  v15 = *(_OWORD *)(a1 + 16);
  result = vmulq_f32(v9, *(float32x4_t *)a1);
  *(float32x4_t *)a3 = result;
  *(_OWORD *)(a3 + 16) = v15;
  *(float32x4_t *)(a3 + 32) = v14;
  return result;
}

uint64_t *re::allocInfo_MassFrame(re *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&qword_25411D148);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_25411D148))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_25411D168, 0);
    *(uint64_t *)((char *)&qword_25411D178 + 6) = 0;
    qword_25411D178 = 0;
    qword_25411D188 = 0;
    qword_25411D190 = 0xFFFFFFFFLL;
    qword_25411D168 = (uint64_t)&off_24ED7DAA8;
    qword_25411D198 = (uint64_t)"MassFrame";
    dword_25411D1A0 = 0;
    xmmword_25411D1A8 = 0u;
    unk_25411D1B8 = 0u;
    xmmword_25411D1C8 = 0u;
    qword_25411D1D8 = 0;
    __cxa_guard_release(&qword_25411D148);
  }
  return &qword_25411D168;
}

void re::initInfo_MassFrame(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  const re::IntrospectionBase *v13;
  void *v14;
  uint64_t v15;
  __int128 v16;
  _QWORD v17[2];
  __int128 v18;

  v17[0] = 0x7C8101421572;
  v17[1] = "MassFrame";
  re::StringID::destroyString((re::StringID *)v17);
  *((_OWORD *)this + 2) = v18;
  v4 = atomic_load((unsigned __int8 *)&_MergedGlobals_417);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&_MergedGlobals_417);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      v7 = re::introspect_PoseF((re::IntrospectionBase **)1);
      v8 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
      *(_DWORD *)v8 = 1;
      *(_QWORD *)(v8 + 8) = "m_pose";
      *(_QWORD *)(v8 + 16) = v7;
      *(_QWORD *)(v8 + 24) = 0;
      *(_QWORD *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + 40) = 0;
      *(_QWORD *)(v8 + 48) = 0;
      *(_QWORD *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_25411D150 = v8;
      v9 = re::introspectionAllocator((re *)v8);
      v10 = re::introspect_Vector3F((re::IntrospectionBase **)1);
      v11 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v9 + 32))(v9, 72, 8);
      *(_DWORD *)v11 = 1;
      *(_QWORD *)(v11 + 8) = "m_inertia";
      *(_QWORD *)(v11 + 16) = v10;
      *(_QWORD *)(v11 + 24) = 0;
      *(_QWORD *)(v11 + 32) = 0x2000000002;
      *(_DWORD *)(v11 + 40) = 0;
      *(_QWORD *)(v11 + 48) = 0;
      *(_QWORD *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = 0;
      qword_25411D158 = v11;
      v12 = re::introspectionAllocator((re *)v11);
      v14 = re::introspect_float((re *)1, v13);
      v15 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v12 + 32))(v12, 72, 8);
      *(_DWORD *)v15 = 1;
      *(_QWORD *)(v15 + 8) = "m_mass";
      *(_QWORD *)(v15 + 16) = v14;
      *(_QWORD *)(v15 + 24) = 0;
      *(_QWORD *)(v15 + 32) = 0x3000000003;
      *(_DWORD *)(v15 + 40) = 0;
      *(_QWORD *)(v15 + 48) = 0;
      *(_QWORD *)(v15 + 56) = 0;
      *(_DWORD *)(v15 + 64) = 0;
      qword_25411D160 = v15;
      __cxa_guard_release(&_MergedGlobals_417);
    }
  }
  *((_QWORD *)this + 2) = 0x4000000008;
  *((_DWORD *)this + 6) = 16;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 3;
  *((_QWORD *)this + 8) = &qword_25411D150;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::MassFrame>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::MassFrame>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::MassFrame>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::MassFrame>;
  re::IntrospectionRegistry::add(this, v3);
  v16 = v18;
}

int32x4_t re::internal::defaultConstruct<re::MassFrame>(uint64_t a1, uint64_t a2, int32x4_t *a3)
{
  int32x4_t result;

  a3->i64[0] = 0;
  a3->i64[1] = 0;
  a3[1].i64[0] = 0;
  a3[1].i64[1] = 0x3F80000000000000;
  result = vdupq_n_s32(0x3DCCCCCDu);
  a3[2] = result;
  a3[3].i32[0] = 1065353216;
  return result;
}

int32x4_t re::internal::defaultConstructV2<re::MassFrame>(int32x4_t *a1)
{
  int32x4_t result;

  a1->i64[0] = 0;
  a1->i64[1] = 0;
  a1[1].i64[0] = 0;
  a1[1].i64[1] = 0x3F80000000000000;
  result = vdupq_n_s32(0x3DCCCCCDu);
  a1[2] = result;
  a1[3].i32[0] = 1065353216;
  return result;
}

uint64_t re::introspect_MassFrame(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"MassFrame", (uint64_t (*)(re::internal *))re::allocInfo_MassFrame, (re::IntrospectionBase *(*)(void))re::initInfo_MassFrame, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::MassFrame>, this);
}

uint64_t re::RigidBodyCollection::add(re::RigidBodyCollection *this, re::RigidBody *a2)
{
  uint64_t result;
  re::RigidBody *v4;

  v4 = a2;
  re::DynamicArray<re::TransitionCondition *>::add((_QWORD *)this + 1, &v4);
  (*(void (**)(re::RigidBody *, uint64_t))(*(_QWORD *)v4 + 96))(v4, *(_QWORD *)this + 128);
  result = (*(uint64_t (**)(_QWORD, re::RigidBody *))(**(_QWORD **)this + 120))(*(_QWORD *)this, v4);
  *(_BYTE *)(*(_QWORD *)this + 240) = 1;
  return result;
}

BOOL re::RigidBodyCollection::remove(re::RigidBodyCollection *this, re::RigidBody *a2)
{
  uint64_t v4;
  uint64_t *i;
  uint64_t v6;
  re::RigidBody *v7;
  int v8;
  BOOL v9;
  uint64_t v10;
  _BOOL8 result;
  re::RigidBody *v12;

  v12 = a2;
  v4 = *((_QWORD *)a2 + 9);
  if (((*(uint64_t (**)(re::RigidBody *))(*(_QWORD *)a2 + 296))(a2) & 1) != 0 || *((_DWORD *)a2 + 52) != 2)
  {
    for (i = *(uint64_t **)(v4 + 80); i; i = (uint64_t *)i[v10])
    {
      v6 = *i;
      if (*i == v4)
        v6 = i[1];
      v7 = *(re::RigidBody **)(v6 + 16);
      v8 = (*(uint64_t (**)(re::RigidBody *))(*(_QWORD *)v7 + 56))(v7);
      v9 = v7 != a2 && v8 == 2;
      if (v9
        && (*(unsigned int (**)(re::RigidBody *))(*(_QWORD *)v7 + 296))(v7)
        && *((_DWORD *)v7 + 52) == 2)
      {
        (*(void (**)(re::RigidBody *))(*(_QWORD *)v7 + 312))(v7);
      }
      if (*i == v4)
        v10 = 14;
      else
        v10 = 15;
    }
  }
  (*(void (**)(_QWORD, re::RigidBody *))(**(_QWORD **)this + 128))(*(_QWORD *)this, a2);
  result = re::DynamicArray<unsigned long long>::remove((uint64_t)this + 8, &v12);
  *(_BYTE *)(*(_QWORD *)this + 240) = 1;
  return result;
}

uint64_t re::RigidBodyCollection::setSolverIterations(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;

  v2 = result + 48;
  if (*(_DWORD *)(result + 48) != *(_DWORD *)a2 || *(_DWORD *)(result + 52) != *(_DWORD *)(a2 + 4))
  {
    *(_QWORD *)(result + 48) = *(_QWORD *)a2;
    v3 = *(_QWORD *)(result + 24);
    if (v3)
    {
      v4 = *(uint64_t **)(result + 40);
      v5 = 8 * v3;
      do
      {
        v6 = *v4++;
        result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v6 + 96))(v6, v2);
        v5 -= 8;
      }
      while (v5);
    }
  }
  return result;
}

uint64_t re::PhysXPhysicsFactory::PhysXPhysicsFactory(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  float v4;
  float v5;
  float v6;

  *(_QWORD *)a1 = &off_24ED7E5A0;
  *(_QWORD *)(a1 + 8) = a2;
  v3 = (_QWORD *)(*(uint64_t (**)(_QWORD, float, float, float))(**(_QWORD **)(a2 + 16) + 240))(*(_QWORD *)(a2 + 16), 0.5, 0.5, 0.1);
  (*(void (**)(_QWORD *, uint64_t, uint64_t))(*v3 + 112))(v3, 4, 1);
  (*(void (**)(_QWORD *, uint64_t))(*v3 + 136))(v3, 2);
  v4 = (*(float (**)(_QWORD *))(*v3 + 104))(v3);
  v5 = (*(float (**)(_QWORD *))(*v3 + 88))(v3);
  v6 = (*(float (**)(_QWORD *))(*v3 + 72))(v3);
  *(float *)(a1 + 24) = v4;
  *(float *)(a1 + 28) = v5;
  *(float *)(a1 + 32) = v6;
  *(_QWORD *)(a1 + 16) = &off_24ED7E4F0;
  *(_QWORD *)(a1 + 40) = v3;
  v3[2] = a1 + 16;
  return a1;
}

void re::PhysXPhysicsFactory::~PhysXPhysicsFactory(re::PhysXPhysicsFactory *this)
{
  *(_QWORD *)this = &off_24ED7E5A0;
  (***((void (****)(_QWORD))this + 5))(*((_QWORD *)this + 5));
}

{
  *(_QWORD *)this = &off_24ED7E5A0;
  (***((void (****)(_QWORD))this + 5))(*((_QWORD *)this + 5));
  JUMPOUT(0x2276933B8);
}

double re::PhysXPhysicsFactory::createPhysicsSimulation(re::PhysXPhysicsFactory *this, re::Allocator *a2)
{
  re::PhysicsSimulation *v2;
  re::PhysicsSimulation *v3;
  double result;

  v2 = (re::PhysicsSimulation *)(*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 984, 8);
  v3 = re::PhysicsSimulation::PhysicsSimulation(v2);
  *(_QWORD *)v3 = &off_24ED7F0F8;
  result = 0.0;
  *((_OWORD *)v3 + 59) = 0u;
  return result;
}

uint64_t re::PhysXPhysicsFactory::createPhysicsMaterial(re::PhysXPhysicsFactory *this, re::Allocator *a2, __n128 a3, __n128 a4, float a5)
{
  uint64_t v6;
  float v7;
  _QWORD *v8;
  uint64_t v9;
  float v10;
  float v11;
  float v12;

  v6 = *(_QWORD *)(*((_QWORD *)this + 1) + 16);
  v7 = 1.0;
  if (a3.n128_f32[0] <= 1.0)
    v7 = a3.n128_f32[0];
  if (a3.n128_f32[0] < 0.0)
    v7 = 0.0;
  if (a5 < 0.0)
    a5 = a4.n128_f32[0];
  if (a4.n128_f32[0] >= 0.0)
    a3.n128_f32[0] = a4.n128_f32[0];
  else
    a3.n128_f32[0] = 0.0;
  if (a5 >= 0.0)
    a4.n128_f32[0] = a5;
  else
    a4.n128_f32[0] = 0.0;
  v8 = (_QWORD *)(*(uint64_t (**)(uint64_t, __n128, __n128, float))(*(_QWORD *)v6 + 240))(v6, a3, a4, v7);
  (*(void (**)(_QWORD *, uint64_t, uint64_t))(*v8 + 112))(v8, 4, 1);
  (*(void (**)(_QWORD *, uint64_t))(*v8 + 136))(v8, 2);
  v9 = (*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 32, 8);
  v10 = (*(float (**)(_QWORD *))(*v8 + 104))(v8);
  v11 = (*(float (**)(_QWORD *))(*v8 + 88))(v8);
  v12 = (*(float (**)(_QWORD *))(*v8 + 72))(v8);
  *(float *)(v9 + 8) = v10;
  *(float *)(v9 + 12) = v11;
  *(float *)(v9 + 16) = v12;
  *(_QWORD *)v9 = &off_24ED7E4F0;
  *(_QWORD *)(v9 + 24) = v8;
  v8[2] = v9;
  return v9;
}

uint64_t re::PhysXPhysicsFactory::defaultMaterial(re::PhysXPhysicsFactory *this)
{
  return (uint64_t)this + 16;
}

uint64_t re::PhysXPhysicsFactory::createUnderlyingRigidBody(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, int a5)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  size_t v13;
  void (***v14)(_QWORD);
  __int128 v16;
  uint64_t v17;
  int v18;
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  v6 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 16);
  if (a5)
  {
    v16 = xmmword_2260E5D70;
    v17 = 0;
    v18 = 0;
    v8 = (*(uint64_t (**)(uint64_t, __int128 *))(*(_QWORD *)v6 + 176))(v6, &v16);
    (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v8 + 256))(v8, a4 + 4);
    (*(void (**)(uint64_t, float))(*(_QWORD *)v8 + 232))(v8, *((float *)a4 + 12));
    v16 = *((_OWORD *)a4 + 1);
    v17 = *a4;
    v18 = *((_DWORD *)a4 + 2);
    (*(void (**)(uint64_t, __int128 *))(*(_QWORD *)v8 + 216))(v8, &v16);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v8 + 608))(v8, 6, 1);
  }
  else
  {
    v16 = xmmword_2260E5D70;
    v17 = 0;
    v18 = 0;
    v8 = (*(uint64_t (**)(uint64_t, __int128 *))(*(_QWORD *)v6 + 168))(v6, &v16);
  }
  v9 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a3 + 184))(a3);
  MEMORY[0x24BDAC7A8](v9);
  v12 = (_QWORD *)((char *)&v16 - v11);
  if (v10 >= 0x200)
    v13 = 512;
  else
    v13 = v10;
  bzero((char *)&v16 - v11, v13);
  (*(void (**)(uint64_t, _QWORD *, uint64_t, _QWORD))(*(_QWORD *)a3 + 192))(a3, v12, v9, 0);
  if ((_DWORD)v9)
  {
    v9 = v9;
    do
    {
      (*(void (**)(_QWORD))(*(_QWORD *)*v12 + 56))(*v12);
      (*(void (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)a3 + 176))(a3, *v12, 1);
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v8 + 168))(v8, *v12);
      v14 = (void (***)(_QWORD))*v12++;
      (**v14)(v14);
      --v9;
    }
    while (v9);
  }
  return v8;
}

uint64_t re::PhysXPhysicsFactory::createRigidBody(re::CollisionFactory **this, re::Allocator *a2, const re::CollisionShape *a3, const re::MassFrame *a4, const re::PhysicsMaterial *const *a5, uint64_t a6)
{
  uint64_t v11;
  uint64_t v12;
  float v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  unint64_t v24;
  uint64_t v25;
  char *v26;
  size_t v27;
  uint64_t v28;
  char *v29;
  uint64_t v30;
  uint64_t v31;
  __int128 v33;
  uint64_t v34;
  int v35;
  uint64_t v36;

  v36 = *MEMORY[0x24BDAC8D0];
  v11 = re::CollisionFactory::deepCopyShape(this[1], a2, a3);
  v12 = *((_QWORD *)this[1] + 2);
  if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)v11 + 56))(v11) & 1) != 0
    || (v13 = fabsf(*((float *)a4 + 12)), v13 == INFINITY)
    || v13 < 0.00001)
  {
    v33 = xmmword_2260E5D70;
    v34 = 0;
    v35 = 0;
    v14 = (*(uint64_t (**)(uint64_t, __int128 *))(*(_QWORD *)v12 + 168))(v12, &v33);
  }
  else
  {
    v33 = xmmword_2260E5D70;
    v34 = 0;
    v35 = 0;
    v14 = (*(uint64_t (**)(uint64_t, __int128 *))(*(_QWORD *)v12 + 176))(v12, &v33);
    (*(void (**)(uint64_t, char *))(*(_QWORD *)v14 + 256))(v14, (char *)a4 + 32);
    (*(void (**)(uint64_t, float))(*(_QWORD *)v14 + 232))(v14, *((float *)a4 + 12));
    v33 = *((_OWORD *)a4 + 1);
    v34 = *(_QWORD *)a4;
    v35 = *((_DWORD *)a4 + 2);
    (*(void (**)(uint64_t, __int128 *))(*(_QWORD *)v14 + 216))(v14, &v33);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v14 + 608))(v14, 6, 1);
  }
  v15 = 2 * ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v14 + 48))(v14) == 1);
  v16 = (*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 448, 16);
  *(_QWORD *)v16 = off_24ED40A00;
  v17 = *((_OWORD *)a4 + 1);
  *(_OWORD *)(v16 + 16) = *(_OWORD *)a4;
  *(_OWORD *)(v16 + 32) = v17;
  *(_QWORD *)(v16 + 48) = 0;
  *(_QWORD *)(v16 + 56) = 0;
  *(_QWORD *)v16 = off_24ED7EC78;
  *(_QWORD *)(v16 + 64) = v11;
  *(_QWORD *)(v16 + 72) = 0;
  v18 = *((_OWORD *)a4 + 3);
  v20 = *(_OWORD *)a4;
  v19 = *((_OWORD *)a4 + 1);
  *(_OWORD *)(v16 + 112) = *((_OWORD *)a4 + 2);
  *(_OWORD *)(v16 + 128) = v18;
  *(_OWORD *)(v16 + 80) = v20;
  *(_OWORD *)(v16 + 96) = v19;
  v22 = *((_OWORD *)a4 + 2);
  v21 = *((_OWORD *)a4 + 3);
  v23 = *((_OWORD *)a4 + 1);
  *(_OWORD *)(v16 + 144) = *(_OWORD *)a4;
  *(_OWORD *)(v16 + 160) = v23;
  *(_OWORD *)(v16 + 176) = v22;
  *(_OWORD *)(v16 + 192) = v21;
  *(_DWORD *)(v16 + 208) = v15;
  *(_QWORD *)(v16 + 212) = 0x100000006;
  *(_DWORD *)(v16 + 308) = 0;
  *(_OWORD *)(v16 + 252) = 0u;
  *(_OWORD *)(v16 + 236) = 0u;
  *(_OWORD *)(v16 + 220) = 0u;
  *(_QWORD *)(v16 + 297) = 0;
  *(_OWORD *)(v16 + 268) = 0u;
  *(_OWORD *)(v16 + 284) = 0u;
  *(_QWORD *)v16 = &off_24ED7E2A8;
  *(_QWORD *)(v16 + 312) = 0x3B23D70A3F800000;
  *(_BYTE *)(v16 + 320) = 1;
  *(_QWORD *)(v16 + 324) = 0x3D4CCCCD3CA3D70ALL;
  *(_OWORD *)(v16 + 400) = 0u;
  *(_OWORD *)(v16 + 416) = 0u;
  *(_OWORD *)(v16 + 368) = 0u;
  *(_OWORD *)(v16 + 384) = 0u;
  *(_OWORD *)(v16 + 336) = 0u;
  *(_OWORD *)(v16 + 352) = 0u;
  *(_QWORD *)(v16 + 432) = a2;
  *(_BYTE *)(v16 + 440) = 0;
  MEMORY[0x24BDAC7A8](v16);
  v26 = (char *)&v33 - v25;
  if (v24 >= 0x200)
    v27 = 512;
  else
    v27 = v24;
  bzero((char *)&v33 - v25, v27);
  if ((_DWORD)a6)
  {
    v28 = a6;
    v29 = v26;
    do
    {
      v30 = (uint64_t)*a5++;
      *(_QWORD *)v29 = *(_QWORD *)(v30 + 24);
      v29 += 8;
      --v28;
    }
    while (v28);
  }
  v31 = (*(uint64_t (**)(re::CollisionFactory *, re::Allocator *, uint64_t, uint64_t, char *, uint64_t))(*(_QWORD *)this[1] + 184))(this[1], a2, v16, v14, v26, a6);
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v16 + 360))(v16, v31);
  return v16;
}

re::PhysXHingeJoint *re::PhysXPhysicsFactory::createHingeJoint(uint64_t a1, uint64_t a2, uint64_t a3, float32x4_t *a4, uint64_t a5, float32x4_t *a6, uint64_t a7)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  physx::PxRevoluteJoint *v12;
  re::PhysXHingeJoint *v13;
  float32x4_t v15;
  uint64_t v16;
  __int32 v17;
  float32x4_t v18;
  uint64_t v19;
  __int32 v20;

  if (!a3)
  {
    v9 = 0;
    if (a5)
      goto LABEL_3;
LABEL_5:
    v10 = 0;
    goto LABEL_6;
  }
  v9 = *(_QWORD *)(*(_QWORD *)(a3 + 72) + 24);
  if (!a5)
    goto LABEL_5;
LABEL_3:
  v10 = *(_QWORD *)(*(_QWORD *)(a5 + 72) + 24);
LABEL_6:
  v11 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 16);
  v18 = a4[1];
  v19 = a4->i64[0];
  v20 = a4->i32[2];
  v15 = a6[1];
  v16 = a6->i64[0];
  v17 = a6->i32[2];
  v12 = (physx::PxRevoluteJoint *)physx::PxRevoluteJointCreate(v11, v9, &v18, v10, &v15);
  v13 = (re::PhysXHingeJoint *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 80, 8);
  return re::PhysXHingeJoint::PhysXHingeJoint(v13, v12, a7);
}

re::PhysXFixedJoint *re::PhysXPhysicsFactory::createFixedJoint(uint64_t a1, uint64_t a2, uint64_t a3, float32x4_t *a4, uint64_t a5, float32x4_t *a6, uint64_t a7)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  physx::PxFixedJoint *v12;
  re::PhysXFixedJoint *v13;
  float32x4_t v15;
  uint64_t v16;
  __int32 v17;
  float32x4_t v18;
  uint64_t v19;
  __int32 v20;

  if (!a3)
  {
    v9 = 0;
    if (a5)
      goto LABEL_3;
LABEL_5:
    v10 = 0;
    goto LABEL_6;
  }
  v9 = *(_QWORD *)(*(_QWORD *)(a3 + 72) + 24);
  if (!a5)
    goto LABEL_5;
LABEL_3:
  v10 = *(_QWORD *)(*(_QWORD *)(a5 + 72) + 24);
LABEL_6:
  v11 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 16);
  v18 = a4[1];
  v19 = a4->i64[0];
  v20 = a4->i32[2];
  v15 = a6[1];
  v16 = a6->i64[0];
  v17 = a6->i32[2];
  v12 = (physx::PxFixedJoint *)physx::PxFixedJointCreate(v11, v9, &v18, v10, &v15);
  v13 = (re::PhysXFixedJoint *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 72, 8);
  return re::PhysXFixedJoint::PhysXFixedJoint(v13, v12, a7);
}

_anonymous_namespace_ *re::PhysXPhysicsFactory::createSliderJoint(uint64_t a1, uint64_t a2, uint64_t a3, float32x4_t *a4, uint64_t a5, float32x4_t *a6, uint64_t a7)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  _anonymous_namespace_ *v15;
  float32x4_t v17;
  uint64_t v18;
  __int32 v19;
  float32x4_t v20;
  uint64_t v21;
  __int32 v22;

  if (!a3)
  {
    v10 = 0;
    if (a5)
      goto LABEL_3;
LABEL_5:
    v11 = 0;
    goto LABEL_6;
  }
  v10 = *(_QWORD *)(*(_QWORD *)(a3 + 72) + 24);
  if (!a5)
    goto LABEL_5;
LABEL_3:
  v11 = *(_QWORD *)(*(_QWORD *)(a5 + 72) + 24);
LABEL_6:
  v12 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 16);
  v20 = a4[1];
  v21 = a4->i64[0];
  v22 = a4->i32[2];
  v17 = a6[1];
  v18 = a6->i64[0];
  v19 = a6->i32[2];
  v13 = physx::PxPrismaticJointCreate(v12, v10, &v20, v11, &v17);
  v14 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 8) + 16) + 40))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 16));
  v15 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 88, 8);
  return re::PhysXSliderJoint::PhysXSliderJoint(v15, v13, v14, a7);
}

re::PhysXBallSocketJoint *re::PhysXPhysicsFactory::createBallSocketJoint(uint64_t a1, uint64_t a2, uint64_t a3, float32x4_t *a4, uint64_t a5, float32x4_t *a6, uint64_t a7)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  physx::PxSphericalJoint *v12;
  re::PhysXBallSocketJoint *v13;
  float32x4_t v15;
  uint64_t v16;
  __int32 v17;
  float32x4_t v18;
  uint64_t v19;
  __int32 v20;

  if (!a3)
  {
    v9 = 0;
    if (a5)
      goto LABEL_3;
LABEL_5:
    v10 = 0;
    goto LABEL_6;
  }
  v9 = *(_QWORD *)(*(_QWORD *)(a3 + 72) + 24);
  if (!a5)
    goto LABEL_5;
LABEL_3:
  v10 = *(_QWORD *)(*(_QWORD *)(a5 + 72) + 24);
LABEL_6:
  v11 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 16);
  v18 = a4[1];
  v19 = a4->i64[0];
  v20 = a4->i32[2];
  v15 = a6[1];
  v16 = a6->i64[0];
  v17 = a6->i32[2];
  v12 = (physx::PxSphericalJoint *)physx::PxSphericalJointCreate(v11, v9, &v18, v10, &v15);
  v13 = (re::PhysXBallSocketJoint *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 80, 8);
  return re::PhysXBallSocketJoint::PhysXBallSocketJoint(v13, v12, a7);
}

re::PhysXDistanceJoint *re::PhysXPhysicsFactory::createDistanceJoint(uint64_t a1, uint64_t a2, uint64_t a3, float32x4_t *a4, uint64_t a5, float32x4_t *a6, uint64_t a7)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  physx::PxDistanceJoint *v12;
  re::PhysXDistanceJoint *v13;
  float32x4_t v15;
  uint64_t v16;
  __int32 v17;
  float32x4_t v18;
  uint64_t v19;
  __int32 v20;

  if (!a3)
  {
    v9 = 0;
    if (a5)
      goto LABEL_3;
LABEL_5:
    v10 = 0;
    goto LABEL_6;
  }
  v9 = *(_QWORD *)(*(_QWORD *)(a3 + 72) + 24);
  if (!a5)
    goto LABEL_5;
LABEL_3:
  v10 = *(_QWORD *)(*(_QWORD *)(a5 + 72) + 24);
LABEL_6:
  v11 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 16);
  v18 = a4[1];
  v19 = a4->i64[0];
  v20 = a4->i32[2];
  v15 = a6[1];
  v16 = a6->i64[0];
  v17 = a6->i32[2];
  v12 = (physx::PxDistanceJoint *)physx::PxDistanceJointCreate(v11, v9, &v18, v10, &v15);
  v13 = (re::PhysXDistanceJoint *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 88, 8);
  return re::PhysXDistanceJoint::PhysXDistanceJoint(v13, v12, a7);
}

uint64_t re::PhysXPhysicsFactory::createGeneric6DOFConstraint(uint64_t a1, uint64_t a2, uint64_t a3, float32x4_t *a4, uint64_t a5, float32x4_t *a6, uint64_t a7)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  float32x4_t v17;
  uint64_t v18;
  __int32 v19;
  float32x4_t v20;
  uint64_t v21;
  __int32 v22;

  if (!a3)
  {
    v10 = 0;
    if (a5)
      goto LABEL_3;
LABEL_5:
    v11 = 0;
    goto LABEL_6;
  }
  v10 = *(_QWORD *)(*(_QWORD *)(a3 + 72) + 24);
  if (!a5)
    goto LABEL_5;
LABEL_3:
  v11 = *(_QWORD *)(*(_QWORD *)(a5 + 72) + 24);
LABEL_6:
  v12 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 16);
  v20 = a4[1];
  v21 = a4->i64[0];
  v22 = a4->i32[2];
  v17 = a6[1];
  v18 = a6->i64[0];
  v19 = a6->i32[2];
  v13 = physx::PxD6JointCreate(v12, v10, &v20, v11, &v17);
  v14 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(a1 + 8) + 16) + 40))(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 16));
  v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 368, 8);
  return re::PhysXGeneric6DOFConstraint::PhysXGeneric6DOFConstraint(v15, v13, v14, a7);
}

re::PhysXTwistSwingJoint *re::PhysXPhysicsFactory::createTwistSwingJoint(uint64_t a1, uint64_t a2, uint64_t a3, float32x4_t *a4, uint64_t a5, float32x4_t *a6, uint64_t a7)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  physx::PxD6Joint *v12;
  re::PhysXTwistSwingJoint *v13;
  float32x4_t v15;
  uint64_t v16;
  __int32 v17;
  float32x4_t v18;
  uint64_t v19;
  __int32 v20;

  if (!a3)
  {
    v9 = 0;
    if (a5)
      goto LABEL_3;
LABEL_5:
    v10 = 0;
    goto LABEL_6;
  }
  v9 = *(_QWORD *)(*(_QWORD *)(a3 + 72) + 24);
  if (!a5)
    goto LABEL_5;
LABEL_3:
  v10 = *(_QWORD *)(*(_QWORD *)(a5 + 72) + 24);
LABEL_6:
  v11 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 16);
  v18 = a4[1];
  v19 = a4->i64[0];
  v20 = a4->i32[2];
  v15 = a6[1];
  v16 = a6->i64[0];
  v17 = a6->i32[2];
  v12 = (physx::PxD6Joint *)physx::PxD6JointCreate(v11, v9, &v18, v10, &v15);
  v13 = (re::PhysXTwistSwingJoint *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 120, 8);
  return re::PhysXTwistSwingJoint::PhysXTwistSwingJoint(v13, v12, a7);
}

void re::WiggleForce::onApply(float32x4_t *this, uint64_t a2)
{
  uint64_t v3;
  float32x4_t *v4;
  float32x4_t v5;
  float32x4_t v6;
  float32x4_t v7;
  float32x4_t v8;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  __int128 v16;
  float32x4_t v17[6];
  _OWORD v18[2];

  v3 = this[1].i64[1];
  if (v3)
  {
    v4 = (float32x4_t *)v18;
    (*(void (**)(_OWORD *__return_ptr))(*(_QWORD *)v3 + 208))(v18);
  }
  else
  {
    v4 = this + 8;
  }
  v5 = *v4;
  v6 = this[5];
  v17[2] = this[4];
  v17[3] = v6;
  v7 = this[7];
  v17[4] = this[6];
  v17[5] = v7;
  v8 = this[3];
  v17[0] = this[2];
  v17[1] = v8;
  *(double *)&v9 = WGLForceComputeLinearForce(v17, a2, v5);
  v16 = v9;
  v10 = this->i64[1];
  v11 = *(_QWORD *)(v10 + 104);
  if (v11)
  {
    v12 = 0;
    v13 = v10 + 80;
    do
    {
      v14 = re::ecs2::ComponentTypeRegistry::operator[](v13, v12);
      if (v14 != this[1].i64[1])
      {
        v15 = v14;
        v18[0] = v16;
        (*(void (**)(uint64_t, _OWORD *, _QWORD))(*(_QWORD *)v14 + 384))(v14, v18, 0);
        if (this[7].i8[5])
        {
          v18[0] = v16;
          (*(void (**)(uint64_t, _OWORD *, _QWORD))(*(_QWORD *)v15 + 392))(v15, v18, 0);
        }
      }
      ++v12;
    }
    while (v11 != v12);
  }
}

void re::WiggleForce::~WiggleForce(re::WiggleForce *this)
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::WiggleForce::type(re::WiggleForce *this)
{
  return 7;
}

_DWORD *re::Goal::onApply(float32x4_t *this)
{
  _DWORD *result;
  float32x4_t v3;
  const float *v4;
  float32x4_t v5;
  float32x4_t v6;
  float32x4_t v7;
  float32x4_t v8;
  uint64_t v9;
  float32x4_t v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  uint64_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20[6];
  float32x4_t v21;
  _OWORD v22[6];
  float32x4_t v23;
  float32x4_t v24;

  result = (_DWORD *)this[1].i64[1];
  if (result[52] == 2 && this[7].f32[0] >= 0.0)
  {
    (*(void (**)(float32x4_t *__return_ptr))(*(_QWORD *)result + 40))(&v23);
    v3 = v23;
    v3.i32[3] = 0;
    v17 = v3;
    v18 = v24;
    v4 = (const float *)(this[1].i64[1] + 192);
    v5 = this[7];
    v22[2] = this[6];
    v22[3] = v5;
    v6 = this[9];
    v22[4] = this[8];
    v22[5] = v6;
    v7 = this[5];
    v22[0] = this[4];
    v22[1] = v7;
    v8 = vld1q_dup_f32(v4);
    v19 = v8;
    *(double *)v10.i64 = WGLGoalComputeLinearForce((float32x2_t *)v22, v9, v3, *(double *)v24.i64, (float32x4_t)_PromotedConst_0, unk_226192280);
    v11 = this[1].i64[1];
    v21 = vdivq_f32(v10, v19);
    (*(void (**)(uint64_t, float32x4_t *, _QWORD))(*(_QWORD *)v11 + 384))(v11, &v21, 0);
    v12 = this[7];
    v20[2] = this[6];
    v20[3] = v12;
    v13 = this[9];
    v20[4] = this[8];
    v20[5] = v13;
    v14 = this[5];
    v20[0] = this[4];
    v20[1] = v14;
    *(double *)v15.i64 = WGLGoalComputeAngularTorque(v20, v17, v18, (float32x4_t)_PromotedConst_0, unk_226192280);
    v16 = this[1].i64[1];
    v21 = vdivq_f32(v15, v19);
    return (_DWORD *)(*(uint64_t (**)(uint64_t, float32x4_t *, _QWORD))(*(_QWORD *)v16 + 392))(v16, &v21, 0);
  }
  return result;
}

void re::Goal::~Goal(re::Goal *this)
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::Goal::type(re::Goal *this)
{
  return 9;
}

void re::PhysicsErrorCategoryImpl::~PhysicsErrorCategoryImpl(std::error_category *this)
{
  std::error_category::~error_category(this);
  JUMPOUT(0x2276933B8);
}

const char *re::PhysicsErrorCategoryImpl::name(re::PhysicsErrorCategoryImpl *this)
{
  return "REPhysics error";
}

_QWORD *re::PhysicsErrorCategoryImpl::message@<X0>(int a1@<W1>, _QWORD *a2@<X8>)
{
  char *v4;
  int v5;

  if (a1 <= 2999)
  {
    v5 = a1 - 1000;
    v4 = "Invalid physics material";
    switch(v5)
    {
      case 0:
        return std::string::basic_string[abi:nn180100]<0>(a2, v4);
      case 1:
        v4 = "Missing physics material restitution";
        break;
      case 2:
        v4 = "Missing physics material static friction.";
        break;
      case 3:
        v4 = "Missing physics material dynamic friction.";
        break;
      default:
        if ("Invalid physics material" == 2000)
          v4 = "Invialid physics gravitational force.";
        else
LABEL_24:
          v4 = "Unknown REPhysics error";
        break;
    }
  }
  else
  {
    switch(a1)
    {
      case 3000:
        v4 = "Invalid physics collider.";
        break;
      case 3001:
        v4 = "Missing physics collider relation.";
        break;
      case 3002:
        v4 = "Missing physics collision shape type.";
        break;
      case 3003:
        v4 = "Invalid physics collider relation.";
        break;
      case 3004:
        v4 = "Unsupported physics collision shape type.";
        break;
      case 3005:
        v4 = "Missing physics collision capsule height.";
        break;
      case 3006:
        v4 = "Missing physics collision capsule radius.";
        break;
      case 3007:
        v4 = "Missing physics collision sphere radius.";
        break;
      case 3008:
        v4 = "Missing physics collision cube size.";
        break;
      case 3009:
        v4 = "Missing physics collision shape extent.";
        break;
      default:
        if (a1 == 4000)
        {
          v4 = "Invalid physics rigid body.";
        }
        else
        {
          if (a1 != 4001)
            goto LABEL_24;
          v4 = "Missing mass on physics rigid body.";
        }
        break;
    }
  }
  return std::string::basic_string[abi:nn180100]<0>(a2, v4);
}

re::PhysXDistanceJoint *re::PhysXDistanceJoint::PhysXDistanceJoint(re::PhysXDistanceJoint *this, physx::PxDistanceJoint *a2, uint64_t a3)
{
  double v6;
  _QWORD *v7;

  *(_QWORD *)this = &off_24ED7E790;
  v6 = re::DistanceJoint::DistanceJoint((uint64_t)this, (uint64_t)this + 72);
  *v7 = &off_24ED7E790;
  v7[9] = &off_24ED7EED0;
  v7[10] = a2;
  *((_QWORD *)a2 + 2) = v7;
  (*(void (**)(physx::PxDistanceJoint *, uint64_t, uint64_t, double))(*(_QWORD *)a2 + 128))(a2, 16, 1, v6);
  (*(void (**)(_QWORD, uint64_t, uint64_t))(**((_QWORD **)this + 10) + 128))(*((_QWORD *)this + 10), 8, a3);
  return this;
}

uint64_t re::PhysXDistanceJoint::updateLimits(re::PhysXDistanceJoint *this)
{
  uint64_t v2;

  v2 = *((_QWORD *)this + 10);
  (*(void (**)(uint64_t, float))(*(_QWORD *)v2 + 248))(v2, *((float *)this + 14));
  return (*(uint64_t (**)(uint64_t, float))(*(_QWORD *)v2 + 264))(v2, *((float *)this + 15));
}

uint64_t re::PhysXDistanceJoint::updateTolerance(re::PhysXDistanceJoint *this)
{
  return (*(uint64_t (**)(_QWORD, float))(**((_QWORD **)this + 10) + 280))(*((_QWORD *)this + 10), (float)(*((float *)this + 15) - *((float *)this + 14)) * *((float *)this + 16));
}

void re::PhysXDistanceJoint::~PhysXDistanceJoint(re::PhysXDistanceJoint *this)
{
  void (***v2)(_QWORD);

  v2 = (void (***)(_QWORD))*((_QWORD *)this + 10);
  if (v2)
    (**v2)(v2);
  *(_QWORD *)this = &off_24ED7E818;
  re::StringID::destroyString((re::PhysXDistanceJoint *)((char *)this + 24));
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  void (***v2)(_QWORD);

  v2 = (void (***)(_QWORD))*((_QWORD *)this + 10);
  if (v2)
    (**v2)(v2);
  *(_QWORD *)this = &off_24ED7E818;
  re::StringID::destroyString((re::PhysXDistanceJoint *)((char *)this + 24));
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

uint64_t re::DistanceJoint::type(re::DistanceJoint *this)
{
  return 5;
}

void re::Constraint::~Constraint(re::Constraint *this)
{
  *(_QWORD *)this = &off_24ED7E818;
  re::StringID::destroyString((re::Constraint *)((char *)this + 24));
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  *(_QWORD *)this = &off_24ED7E818;
  re::StringID::destroyString((re::Constraint *)((char *)this + 24));
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

uint64_t re::ConstraintKernelBase::onAddConstraint(uint64_t a1)
{
  uint64_t v2;
  uint64_t result;
  uint64_t v4;

  if (*(_DWORD *)((*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1) + 208) == 2)
  {
    v2 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 312))(v2);
  }
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
  if (*(_DWORD *)(result + 208) == 2)
  {
    v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 312))(v4);
  }
  return result;
}

uint64_t re::ConstraintKernelBase::onRemoveConstraint(uint64_t a1)
{
  uint64_t v2;
  uint64_t result;
  uint64_t v4;

  if (*(_DWORD *)((*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1) + 208) == 2)
  {
    v2 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 312))(v2);
  }
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
  if (*(_DWORD *)(result + 208) == 2)
  {
    v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 312))(v4);
  }
  return result;
}

uint64_t re::Constraint::type(re::Constraint *this)
{
  return 0;
}

re::PhysicsSimulation *re::PhysicsSimulation::PhysicsSimulation(re::PhysicsSimulation *this)
{
  uint64_t v2;
  char *v3;
  uint64_t i;
  char *v5;
  uint64_t j;
  char *v7;

  ArcSharedObject::ArcSharedObject(this, 0);
  v2 = 0;
  *(_QWORD *)this = off_24ED7E888;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *((_QWORD *)this + 8) = 0x3C88888900000004;
  *((_BYTE *)this + 72) = 0;
  *((_QWORD *)this + 15) = 0;
  *((_QWORD *)this + 10) = this;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = 0;
  *((_DWORD *)this + 28) = 0;
  *((_QWORD *)this + 16) = 0x100000006;
  *((_QWORD *)this + 17) = &off_24ED7E1D0;
  *((_QWORD *)this + 18) = this;
  *((_QWORD *)this + 20) = 0;
  *((_QWORD *)this + 21) = 0;
  *((_QWORD *)this + 19) = 0;
  *((_DWORD *)this + 44) = 0;
  *(_OWORD *)((char *)this + 212) = 0u;
  *(_OWORD *)((char *)this + 200) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  *(_QWORD *)((char *)this + 228) = 0x7FFFFFFFLL;
  *((_BYTE *)this + 240) = 0;
  *((_DWORD *)this + 70) = 0;
  *((_QWORD *)this + 31) = this;
  *((_QWORD *)this + 32) = 0;
  *((_QWORD *)this + 33) = 0;
  *((_QWORD *)this + 34) = 0;
  *((_OWORD *)this + 18) = 0u;
  *((_OWORD *)this + 19) = 0u;
  *((_DWORD *)this + 80) = 0;
  *((_QWORD *)this + 41) = 0;
  *((_QWORD *)this + 42) = this;
  *((_QWORD *)this + 47) = 0;
  *((_QWORD *)this + 44) = 0;
  *((_QWORD *)this + 45) = 0;
  *((_DWORD *)this + 92) = 0;
  *((_QWORD *)this + 43) = 0;
  do
  {
    v3 = (char *)this + v2;
    *((_QWORD *)v3 + 52) = 0;
    *((_QWORD *)v3 + 49) = 0;
    *((_QWORD *)v3 + 50) = 0;
    *((_QWORD *)v3 + 48) = 0;
    v2 += 40;
    *((_DWORD *)v3 + 102) = 0;
  }
  while (v2 != 320);
  for (i = 0; i != 80; i += 40)
  {
    v5 = (char *)this + i;
    *((_QWORD *)v5 + 92) = 0;
    *((_QWORD *)v5 + 88) = 0;
    *((_QWORD *)v5 + 90) = 0;
    *((_QWORD *)v5 + 89) = 0;
    *((_DWORD *)v5 + 182) = 0;
  }
  for (j = 0; j != 80; j += 40)
  {
    v7 = (char *)this + j;
    *((_QWORD *)v7 + 102) = 0;
    *((_QWORD *)v7 + 98) = 0;
    *((_QWORD *)v7 + 100) = 0;
    *((_QWORD *)v7 + 99) = 0;
    *((_DWORD *)v7 + 202) = 0;
  }
  *((_QWORD *)this + 116) = 0;
  *((_DWORD *)this + 234) = 0;
  *((_OWORD *)this + 54) = 0u;
  *((_OWORD *)this + 55) = 0u;
  *((_OWORD *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 908) = 0u;
  return this;
}

void re::PhysicsSimulation::~PhysicsSimulation(re::PhysicsSimulation *this)
{
  const void *v2;
  uint64_t v3;
  uint64_t i;
  _QWORD *v5;
  uint64_t v6;
  uint64_t j;
  _QWORD *v8;
  uint64_t v9;
  uint64_t k;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  *(_QWORD *)this = off_24ED7E888;
  v2 = (const void *)*((_QWORD *)this + 109);
  if (v2)
  {
    CFRelease(v2);
    *((_QWORD *)this + 109) = 0;
  }
  v3 = *((_QWORD *)this + 112);
  if (v3)
  {
    if (*((_QWORD *)this + 116))
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
    *((_QWORD *)this + 116) = 0;
    *((_QWORD *)this + 113) = 0;
    *((_QWORD *)this + 114) = 0;
    *((_QWORD *)this + 112) = 0;
    ++*((_DWORD *)this + 230);
  }
  for (i = 0; i != -80; i -= 40)
  {
    v5 = (_QWORD *)((char *)this + i);
    v6 = *(_QWORD *)((char *)this + i + 824);
    if (v6)
    {
      if (v5[107])
        (*(void (**)(uint64_t))(*(_QWORD *)v6 + 40))(v6);
      v5[107] = 0;
      v5[104] = 0;
      v5[105] = 0;
      v5[103] = 0;
      ++*(_DWORD *)((char *)this + i + 848);
    }
  }
  for (j = 0; j != -80; j -= 40)
  {
    v8 = (_QWORD *)((char *)this + j);
    v9 = *(_QWORD *)((char *)this + j + 744);
    if (v9)
    {
      if (v8[97])
        (*(void (**)(uint64_t))(*(_QWORD *)v9 + 40))(v9);
      v8[97] = 0;
      v8[94] = 0;
      v8[95] = 0;
      v8[93] = 0;
      ++*(_DWORD *)((char *)this + j + 768);
    }
  }
  for (k = 0; k != -320; k -= 40)
  {
    v11 = (_QWORD *)((char *)this + k);
    v12 = *(_QWORD *)((char *)this + k + 664);
    if (v12)
    {
      if (v11[87])
        (*(void (**)(uint64_t))(*(_QWORD *)v12 + 40))(v12);
      v11[87] = 0;
      v11[84] = 0;
      v11[85] = 0;
      v11[83] = 0;
      ++*(_DWORD *)((char *)this + k + 688);
    }
  }
  v13 = *((_QWORD *)this + 43);
  if (v13)
  {
    if (*((_QWORD *)this + 47))
      (*(void (**)(uint64_t))(*(_QWORD *)v13 + 40))(v13);
    *((_QWORD *)this + 47) = 0;
    *((_QWORD *)this + 44) = 0;
    *((_QWORD *)this + 45) = 0;
    *((_QWORD *)this + 43) = 0;
    ++*((_DWORD *)this + 92);
  }
  v14 = *((_QWORD *)this + 37);
  if (v14)
  {
    if (*((_QWORD *)this + 41))
      (*(void (**)(uint64_t))(*(_QWORD *)v14 + 40))(v14);
    *((_QWORD *)this + 41) = 0;
    *((_QWORD *)this + 38) = 0;
    *((_QWORD *)this + 39) = 0;
    *((_QWORD *)this + 37) = 0;
    ++*((_DWORD *)this + 80);
  }
  v15 = *((_QWORD *)this + 32);
  if (v15)
  {
    if (*((_QWORD *)this + 36))
      (*(void (**)(uint64_t))(*(_QWORD *)v15 + 40))(v15);
    *((_QWORD *)this + 36) = 0;
    *((_QWORD *)this + 33) = 0;
    *((_QWORD *)this + 34) = 0;
    *((_QWORD *)this + 32) = 0;
    ++*((_DWORD *)this + 70);
  }
  re::PhysicsJointCollection::~PhysicsJointCollection((_BOOL8)this + 136);
  v16 = *((_QWORD *)this + 11);
  if (v16)
  {
    if (*((_QWORD *)this + 15))
      (*(void (**)(uint64_t))(*(_QWORD *)v16 + 40))(v16);
    *((_QWORD *)this + 15) = 0;
    *((_QWORD *)this + 12) = 0;
    *((_QWORD *)this + 13) = 0;
    *((_QWORD *)this + 11) = 0;
    ++*((_DWORD *)this + 28);
  }
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

void re::PhysicsSimulation::setParentClockOrTimebase(re::PhysicsSimulation *this, void *cf)
{
  CMTimebaseRef *v2;
  const void *v3;
  const __CFAllocator *v5;
  OpaqueCMClock *HostTimeClock;
  CFTypeID v7;
  CFTypeID TypeID;
  OpaqueCMTimebase *v9;

  v2 = (CMTimebaseRef *)((char *)this + 872);
  v3 = (const void *)*((_QWORD *)this + 109);
  if (cf)
  {
    if (!v3)
    {
      v5 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
      HostTimeClock = CMClockGetHostTimeClock();
      CMTimebaseCreateWithSourceClock(v5, HostTimeClock, v2);
      CMTimebaseSetRate(*v2, 1.0);
    }
    v7 = CFGetTypeID(cf);
    TypeID = CMClockGetTypeID();
    v9 = *v2;
    if (v7 == TypeID)
      CMTimebaseSetSourceClock(v9, (CMClockRef)cf);
    else
      CMTimebaseSetSourceTimebase(v9, (CMTimebaseRef)cf);
  }
  else if (v3)
  {
    CFRelease(v3);
    *v2 = 0;
  }
}

void re::PhysicsSimulation::update(re::PhysicsSimulation *this, float a2)
{
  __n128 v4;
  int v5;
  OpaqueCMTimebase *v6;
  int v7;
  double v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  float v13;
  float v14;
  CMTime time;
  uint64_t v16[2];
  _BYTE v17[16];

  if (((*(uint64_t (**)(re::PhysicsSimulation *))(*(_QWORD *)this + 96))(this) & 1) != 0)
  {
    re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v17, 7000, (uint64_t)this);
    re::ProfilerTimeGuard<(re::ProfilerStatistic)20>::ProfilerTimeGuard(v16);
    if (physx::shdfnd::g_isLockingEnabled)
      v5 = 1;
    else
      v5 = physx::shdfnd::g_alwaysUseLocking;
    if ((physx::shdfnd::g_alwaysUseLocking & 1) == 0 && physx::shdfnd::g_isLockingEnabled)
      physx::shdfnd::g_isLockingEnabled = 0;
    v6 = (OpaqueCMTimebase *)*((_QWORD *)this + 109);
    if (v6)
    {
      CMTimebaseGetTime(&time, v6);
      v4.n128_f64[0] = CMTimeGetSeconds(&time);
      a2 = v4.n128_f64[0] - *((double *)this + 110);
      *((_QWORD *)this + 110) = v4.n128_u64[0];
    }
    v4.n128_f64[0] = *((double *)this + 111) + a2;
    *((_QWORD *)this + 111) = v4.n128_u64[0];
    if (*((_DWORD *)this + 234) != 1)
    {
      v4.n128_f64[0] = *((float *)this + 17);
      *((_QWORD *)this + 111) = v4.n128_u64[0];
      *((_DWORD *)this + 234) = 1;
    }
    v7 = 0;
    while (1)
    {
      v8 = *((double *)this + 111);
      v4.n128_u32[0] = *((_DWORD *)this + 17);
      if (v8 < (float)(v4.n128_f32[0] * 0.95))
        break;
      *((double *)this + 111) = v8 - v4.n128_f32[0];
      v9 = *((_QWORD *)this + 4);
      if (v9)
      {
        (*(void (**)(uint64_t, BOOL, re::PhysicsSimulation *))(*(_QWORD *)v9 + 16))(v9, v7 == 0, this);
        v4.n128_u32[0] = *((_DWORD *)this + 17);
      }
      (*(void (**)(re::PhysicsSimulation *, __n128))(*(_QWORD *)this + 64))(this, v4);
      (*(void (**)(_QWORD))(**((_QWORD **)this + 7) + 224))(*((_QWORD *)this + 7));
      v10 = *((_QWORD *)this + 4);
      if (v10)
        (*(void (**)(uint64_t, re::PhysicsSimulation *, float))(*(_QWORD *)v10 + 24))(v10, this, *((float *)this + 17));
      else
        (*(void (**)(_QWORD))(**((_QWORD **)this + 7) + 208))(*((_QWORD *)this + 7));
      (*(void (**)(_QWORD))(**((_QWORD **)this + 7) + 136))(*((_QWORD *)this + 7));
      if (++v7 >= *((_DWORD *)this + 16))
      {
        *((_QWORD *)this + 111) = 0;
        goto LABEL_26;
      }
    }
    if (!v7)
    {
      v12 = *((_QWORD *)this + 4);
      if (v12)
        (*(void (**)(uint64_t, re::PhysicsSimulation *, float))(*(_QWORD *)v12 + 24))(v12, this, 0.0);
    }
LABEL_26:
    v13 = *((float *)this + 17) * 0.05;
    if (a2 > v13)
    {
      v14 = *((double *)this + 111);
      if (fabsf(v14) < v13)
        *((_QWORD *)this + 111) = 0;
    }
    (*(void (**)(re::PhysicsSimulation *))(*(_QWORD *)this + 88))(this);
    if (physx::shdfnd::g_isLockingEnabled != v5)
      physx::shdfnd::g_isLockingEnabled = v5;
    re::ProfilerTimeGuard<(re::ProfilerStatistic)19>::end((uint64_t)v16);
    re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v17);
  }
  else
  {
    *((_DWORD *)this + 234) = 0;
    v11 = *((_QWORD *)this + 4);
    if (v11)
      (*(void (**)(uint64_t, re::PhysicsSimulation *))(*(_QWORD *)v11 + 32))(v11, this);
  }
}

_anonymous_namespace_ *re::PhysicsSimulation::applyForceEffects(re::PhysicsSimulation *this)
{
  uint64_t v2;
  _anonymous_namespace_ *result;
  uint64_t v4;
  _anonymous_namespace_ **v5;
  uint64_t v6;
  _QWORD v7[2];

  v2 = *((_QWORD *)this + 34);
  v7[0] = *((_QWORD *)this + 36);
  v7[1] = v2;
  result = re::DynamicArray<re::ForceEffect *>::operator=((re::PhysicsSimulation *)((char *)this + 296), (uint64_t)v7);
  v4 = *((_QWORD *)this + 39);
  if (v4)
  {
    v5 = (_anonymous_namespace_ **)*((_QWORD *)this + 41);
    v6 = 8 * v4;
    do
    {
      result = *v5;
      if (*((_BYTE *)*v5 + 16))
        result = (_anonymous_namespace_ *)(*(uint64_t (**)(_anonymous_namespace_ *))(*(_QWORD *)result + 56))(result);
      ++v5;
      v6 -= 8;
    }
    while (v6);
  }
  return result;
}

_anonymous_namespace_ *re::DynamicArray<re::ForceEffect *>::operator=(_anonymous_namespace_ *this, uint64_t a2)
{
  unint64_t v4;

  v4 = *(_QWORD *)(a2 + 8);
  if (*(_QWORD *)this)
  {
    if (v4)
    {
      re::DynamicArray<char const*>::copy(this, 0, *(char **)a2, v4);
      re::DynamicArray<double>::resize((uint64_t)this, *(_QWORD *)(a2 + 8));
    }
    else
    {
      *((_QWORD *)this + 2) = 0;
      ++*((_DWORD *)this + 6);
    }
  }
  else if (v4)
  {
    re::DynamicArray<float *>::setCapacity(this, v4);
    ++*((_DWORD *)this + 6);
    re::DynamicArray<char const*>::copy(this, 0, *(char **)a2, *(_QWORD *)(a2 + 8));
  }
  return this;
}

uint64_t re::PhysicsSimulation::onRigidBodyAdded(re::PhysicsSimulation *this, re::RigidBody *a2)
{
  uint64_t v4;
  uint64_t result;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;

  v4 = *(_QWORD *)(*((_QWORD *)this + 7) + 128);
  *(_QWORD *)(*((_QWORD *)a2 + 9) + 56) = v4;
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 192))(v4);
  v6 = *((_QWORD *)this + 34);
  if (v6)
  {
    v7 = (uint64_t *)*((_QWORD *)this + 36);
    v8 = 8 * v6;
    do
    {
      v9 = *v7++;
      result = (*(uint64_t (**)(uint64_t, re::RigidBody *))(*(_QWORD *)v9 + 64))(v9, a2);
      v8 -= 8;
    }
    while (v8);
  }
  return result;
}

uint64_t re::PhysicsSimulation::onRigidBodyRemoved(re::PhysicsSimulation *this, re::RigidBody *a2)
{
  int v4;
  uint64_t v5;
  re::CollisionObject *v6;
  uint64_t result;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;

  if (physx::shdfnd::g_isLockingEnabled)
    v4 = 1;
  else
    v4 = physx::shdfnd::g_alwaysUseLocking;
  if ((physx::shdfnd::g_alwaysUseLocking & 1) == 0 && physx::shdfnd::g_isLockingEnabled)
    physx::shdfnd::g_isLockingEnabled = 0;
  v5 = *((_QWORD *)this + 7);
  v6 = (re::CollisionObject *)*((_QWORD *)a2 + 9);
  re::ContactSetCollection::remove(*(_QWORD *)(v5 + 128) + 72, v6);
  result = (*(uint64_t (**)(_QWORD, re::CollisionObject *))(**(_QWORD **)(v5 + 128) + 200))(*(_QWORD *)(v5 + 128), v6);
  *((_QWORD *)v6 + 7) = 0;
  v8 = *((_QWORD *)this + 34);
  if (v8)
  {
    v9 = (uint64_t *)*((_QWORD *)this + 36);
    v10 = 8 * v8;
    do
    {
      v11 = *v9++;
      result = (*(uint64_t (**)(uint64_t, re::RigidBody *))(*(_QWORD *)v11 + 72))(v11, a2);
      v10 -= 8;
    }
    while (v10);
  }
  if (physx::shdfnd::g_isLockingEnabled != v4)
    physx::shdfnd::g_isLockingEnabled = v4;
  return result;
}

_QWORD *re::PhysicsSimulation::addConstraintToDelete(_QWORD *this, re::Constraint *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  re::Constraint **v5;
  re::Constraint *v6;

  v6 = a2;
  if (a2)
  {
    v2 = this[116];
    v3 = this[114];
    if (v3)
    {
      v4 = 8 * v3;
      v5 = (re::Constraint **)this[116];
      while (*v5 != a2)
      {
        ++v5;
        v4 -= 8;
        if (!v4)
        {
          v5 = (re::Constraint **)(v2 + 8 * v3);
          break;
        }
      }
    }
    else
    {
      v5 = (re::Constraint **)this[116];
    }
    if (v3 == ((uint64_t)v5 - v2) >> 3)
      return re::DynamicArray<re::TransitionCondition *>::add(this + 112, &v6);
  }
  return this;
}

uint64_t re::PhysicsSimulation::deleteConstraintsMarkedForDeletion(uint64_t this)
{
  uint64_t v1;
  unint64_t v2;
  void (***v3)(_QWORD);
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _OWORD v10[5];
  uint64_t v11;

  v1 = this;
  v11 = *MEMORY[0x24BDAC8D0];
  if ((int)*(_QWORD *)(this + 912) >= 1)
  {
    v2 = *(_QWORD *)(this + 912);
    do
    {
      if (*(_QWORD *)(v1 + 912) <= (unint64_t)(v2 - 1))
      {
        memset(v10, 0, sizeof(v10));
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      v3 = *(void (****)(_QWORD))(*(_QWORD *)(v1 + 928) + 8 * (v2 - 1));
      v4 = *(_QWORD *)(v1 + 184);
      v5 = *(_QWORD *)(v1 + 168);
      if (v5)
      {
        v6 = 8 * v5;
        v7 = *(_QWORD **)(v1 + 184);
        while ((void (***)(_QWORD))*v7 != v3)
        {
          ++v7;
          v6 -= 8;
          if (!v6)
          {
            v7 = (_QWORD *)(v4 + 8 * v5);
            break;
          }
        }
      }
      else
      {
        v7 = *(_QWORD **)(v1 + 184);
      }
      if (v5 != ((uint64_t)v7 - v4) >> 3)
      {
        *(_QWORD *)&v10[0] = *(_QWORD *)(*(_QWORD *)(v1 + 928) + 8 * (v2 - 1));
        this = re::DynamicArray<re::Allocator const*>::removeStable((_QWORD *)(v1 + 152), v10);
        if (v3)
        {
          v8 = re::globalAllocators((re *)this)[2];
          (**v3)(v3);
          this = (*(uint64_t (**)(uint64_t, void (***)(_QWORD)))(*(_QWORD *)v8 + 40))(v8, v3);
        }
      }
    }
    while (v2-- > 1);
  }
  *(_QWORD *)(v1 + 912) = 0;
  ++*(_DWORD *)(v1 + 920);
  return this;
}

uint64_t re::PhysXGeneric6DOFConstraint::PhysXGeneric6DOFConstraint(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4)
{
  _anonymous_namespace_ *v8;

  *(_QWORD *)a1 = &off_24ED7E938;
  v8 = re::Generic6DOFConstraint::Generic6DOFConstraint((_anonymous_namespace_ *)a1, a1 + 344);
  *(_QWORD *)v8 = &off_24ED7E938;
  *((_QWORD *)v8 + 43) = &off_24ED7EED0;
  *((_QWORD *)v8 + 44) = a2;
  a2[2] = v8;
  (*(void (**)(_QWORD *, uint64_t, uint64_t))(*a2 + 128))(a2, 16, 1);
  (*(void (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(a1 + 352) + 128))(*(_QWORD *)(a1 + 352), 8, a4);
  *(_QWORD *)(a1 + 360) = a3;
  return a1;
}

uint64_t re::PhysXGeneric6DOFConstraint::updateLimits(re::PhysXGeneric6DOFConstraint *this)
{
  uint64_t v2;
  uint64_t v3;
  char *v4;
  char *v5;
  int v6;
  float *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  float v12;
  float v13;
  float v14;
  int v15;
  int v16;
  float *v17;
  float v18;
  float v19;
  float *v20;
  uint64_t v21;
  __int128 v22;
  uint64_t result;
  uint64_t v24;
  __int128 v25;
  uint64_t v26;
  __int128 v27;
  uint64_t v28;
  uint64_t v29;
  __int128 v30;
  float v31;
  float v32;
  float v33;

  v2 = 0;
  v3 = *((_QWORD *)this + 44);
  v4 = (char *)this + 128;
  v5 = (char *)this + 104;
  while (1)
  {
    v6 = dword_226192334[v2];
    v7 = (float *)re::Generic6DOFConstraint::linearLimit((uint64_t)this, v6);
    v9 = v6;
    if (v6 >= 3)
      break;
    v10 = dword_226192334[v6];
    if (v4[16 * v9])
    {
      (*(void (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)v3 + 240))(v3, dword_226192334[v9], 1);
      v11 = &v4[16 * v9];
      v12 = fabsf(*((float *)v11 + 3));
      v30 = 0uLL;
      v31 = 0.0;
      v32 = v12;
      v33 = 0.0;
      *((_QWORD *)&v30 + 1) = *(_QWORD *)(v11 + 4);
    }
    else
    {
      v13 = *v7;
      v14 = v7[1];
      if (*v7 == v14)
        v15 = 2;
      else
        v15 = 1;
      if (*v7 > v14)
        v15 = 0;
      if (!v15)
      {
        (*(void (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)v3 + 240))(v3, dword_226192334[v9], 2);
        goto LABEL_15;
      }
      v16 = *(_DWORD *)&v5[4 * v9];
      v17 = (float *)*((_QWORD *)this + 45);
      (*(void (**)(uint64_t, uint64_t, BOOL))(*(_QWORD *)v3 + 240))(v3, v10, v15 != 2);
      *((_QWORD *)&v30 + 1) = 0;
      v32 = v14;
      v33 = v13;
      v18 = *v17;
      v19 = *v17 * 0.01;
      if (v19 >= (float)((float)(v13 * -0.49) + (float)(v14 * 0.49)))
        v19 = (float)(v13 * -0.49) + (float)(v14 * 0.49);
      v31 = v19;
      LODWORD(v30) = v16;
      *((float *)&v30 + 1) = v18 + v18;
    }
    (*(void (**)(uint64_t, uint64_t, __int128 *))(*(_QWORD *)v3 + 296))(v3, v10, &v30);
LABEL_15:
    if (++v2 == 3)
    {
      v29 = *((_QWORD *)this + 10);
      v30 = *((_OWORD *)this + 11);
      re::setPxD6JointTwistLimit(v3, (re *)&v29, (uint64_t)&v30, v20, *((float *)this + 29));
      v21 = *((_QWORD *)this + 12);
      v28 = *((_QWORD *)this + 11);
      v22 = *((_OWORD *)this + 13);
      v27 = *((_OWORD *)this + 12);
      v26 = v21;
      v25 = v22;
      return re::setPxD6JointSwingLimit(v3, (re *)&v28, (uint64_t)&v27, (float *)&v26, (uint64_t)&v25, *((float *)this + 30), *((float *)this + 31));
    }
  }
  re::internal::assertLog((re::internal *)6, v8, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < N", "operator[]", 242, v6, 3);
  _os_crash();
  __break(1u);
  re::internal::assertLog((re::internal *)4, v24, "assertion failure: '%s' (%s:line %i) Unexpected limit type.", "!\"Unreachable code\"", "convertLimit", 120);
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::Generic6DOFConstraint::linearLimit(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;

  if (a2 < 3)
    return a1 + 8 * (int)a2 + 56;
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < N", "operator[]", 242, (int)a2, 3, v2, v3);
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::setPxD6JointTwistLimit(uint64_t a1, re *this, uint64_t a3, float *a4, float a5)
{
  unsigned int v7;
  uint64_t v9;
  uint64_t result;
  float v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  float v15;
  uint64_t v16;

  if (*(_BYTE *)a3)
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 240))(a1, 3, 1);
    v7 = *(_DWORD *)(a3 + 12);
    v13 = 0;
    v15 = 0.0;
    v16 = v7;
    v14 = *(_QWORD *)(a3 + 4);
  }
  else
  {
    v12 = 0;
    v9 = re::convertLimit(this, (const re::AngularLimit *)((char *)&v12 + 4), (float *)&v12, a4);
    result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 240))(a1, 3, v9);
    if ((_DWORD)v9 == 2)
      return result;
    v16 = v12;
    v11 = (float)(*(float *)&v12 - *((float *)&v12 + 1)) * 0.49;
    if (v11 > 0.1)
      v11 = 0.1;
    v14 = 0;
    v15 = v11;
    v13 = LODWORD(a5) | 0x3F00000000000000;
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 312))(a1, &v13);
}

uint64_t re::setPxD6JointSwingLimit(uint64_t a1, re *this, uint64_t a3, float *a4, uint64_t a5, float a6, float a7)
{
  BOOL v12;
  unsigned int v13;
  uint64_t v14;
  float v15;
  float v16;
  float v17;
  __int32 v18;
  uint64_t v19;
  float *v20;
  uint64_t v21;
  uint64_t result;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float *v28;
  int8x8_t v29;
  float v30;
  float v31;
  float v32;
  __int128 v33;
  __int128 v34;
  __int32 v35;
  float32x2_t v36;
  _QWORD v37[2];
  float32x2x2_t v38;

  v37[1] = *MEMORY[0x24BDAC8D0];
  if (*(_BYTE *)a3)
    v12 = *(_BYTE *)a5 == 0;
  else
    v12 = 1;
  if (v12)
  {
    if (*(_BYTE *)a3)
    {
      v13 = *(_DWORD *)(a3 + 12);
      *(_QWORD *)&v33 = 0;
      *(_QWORD *)&v34 = 0;
      *((_QWORD *)&v34 + 1) = v13;
      v35 = 0;
      v14 = *(_QWORD *)(a3 + 4);
    }
    else
    {
      if (!*(_BYTE *)a5)
        goto LABEL_16;
      v18 = *(_DWORD *)(a5 + 12);
      v33 = 0u;
      v34 = 0u;
      v35 = v18;
      v14 = *(_QWORD *)(a5 + 4);
    }
    *((_QWORD *)&v33 + 1) = v14;
    (*(void (**)(uint64_t, __int128 *))(*(_QWORD *)a1 + 344))(a1, &v33);
    goto LABEL_16;
  }
  v15 = *(float *)(a3 + 12);
  v16 = *(float *)(a5 + 12);
  *(_QWORD *)((char *)&v34 + 4) = __PAIR64__(LODWORD(v16), LODWORD(v15));
  if (v15 < v16)
    v16 = v15;
  v17 = v16 * 0.49;
  if (v17 > 0.1)
    v17 = 0.1;
  v33 = 0x3F00000000000000uLL;
  *(float *)&v34 = v17;
  (*(void (**)(uint64_t, __int128 *))(*(_QWORD *)a1 + 328))(a1, &v33);
LABEL_16:
  v19 = re::convertLimit(this, (const re::AngularLimit *)v37, (float *)&v36, a4);
  v21 = re::convertLimit((re *)a4, (const re::AngularLimit *)((char *)v37 + 4), (float *)&v36 + 1, v20);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 240))(a1, 4, v19);
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 240))(a1, 5, v21);
  if ((_DWORD)v19 == 2 || (_DWORD)v21 == 2)
  {
    if ((_DWORD)v19 != 2)
    {
      v26 = (float)(v36.f32[0] - *(float *)v37) * 0.49;
      if (v26 > 0.1)
        v26 = 0.1;
      *((_QWORD *)&v33 + 1) = 0;
      DWORD1(v34) = v37[0];
      *((_QWORD *)&v34 + 1) = v36.u32[0];
      v35 = 0;
      v27 = 1.0;
      if (fminf(v26, 0.0) != -1.0)
        v27 = 0.0;
      *(float *)&v34 = v27;
      goto LABEL_47;
    }
    if ((_DWORD)v21 == 2)
      return result;
    *((_QWORD *)&v33 + 1) = 0;
    *(_QWORD *)((char *)&v34 + 4) = 0;
    HIDWORD(v34) = HIDWORD(v37[0]);
    v35 = v36.i32[1];
    v31 = (float)(v36.f32[1] - *((float *)v37 + 1)) * 0.49;
    if (v31 > 0.1)
      v31 = 0.1;
    if (v31 > 0.0)
      v31 = 0.0;
    v12 = v31 == -1.0;
    v30 = 1.0;
    if (!v12)
      v30 = 0.0;
LABEL_46:
    *(float *)&v34 = v30;
LABEL_47:
    DWORD1(v33) = 1056964608;
    if (a6 >= a7)
      v32 = a6;
    else
      v32 = a7;
    *(float *)&v33 = v32;
    return (*(uint64_t (**)(uint64_t, __int128 *))(*(_QWORD *)a1 + 344))(a1, &v33);
  }
  if (!(_DWORD)v19 || !(_DWORD)v21)
  {
    v38.val[1] = v36;
    v38.val[0] = (float32x2_t)v37[0];
    *((_QWORD *)&v33 + 1) = 0;
    v28 = (float *)&v34 + 1;
    vst2_f32(v28, v38);
    v38.val[0] = vmul_f32(vsub_f32(v38.val[1], v38.val[0]), (float32x2_t)vdup_n_s32(0x3EFAE148u));
    v38.val[1] = (float32x2_t)vdup_n_s32(0x3DCCCCCDu);
    v29 = vbsl_s8((int8x8_t)vcgt_f32(v38.val[0], v38.val[1]), (int8x8_t)v38.val[1], (int8x8_t)v38.val[0]);
    if (*(float *)v29.i32 >= *(float *)&v29.i32[1])
      v29.i32[0] = v29.i32[1];
    v12 = *(float *)v29.i32 == -1.0;
    v30 = 0.0;
    if (v12)
      v30 = 1.0;
    goto LABEL_46;
  }
  v23 = v36.f32[1];
  *(float32x2_t *)((char *)&v34 + 4) = v36;
  if (v36.f32[0] < v36.f32[1])
    v23 = v36.f32[0];
  v24 = v23 * 0.49;
  if (v24 > 0.1)
    v24 = 0.1;
  *((_QWORD *)&v33 + 1) = 0;
  *(float *)&v34 = v24;
  DWORD1(v33) = 1056964608;
  if (a6 >= a7)
    v25 = a6;
  else
    v25 = a7;
  *(float *)&v33 = v25;
  return (*(uint64_t (**)(uint64_t, __int128 *))(*(_QWORD *)a1 + 328))(a1, &v33);
}

uint64_t re::PhysXGeneric6DOFConstraint::updateMotor(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  int v4;
  __n128 v6;
  float v7;
  float v8;
  __float2 v9;
  float v10;
  __float2 v11;
  float v12;
  __float2 v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  uint64_t result;
  float v20[7];
  __n128 v21;
  __n128 v22;
  uint64_t v23;
  int v24;
  int v25;

  v3 = *(_QWORD *)(a1 + 352);
  v4 = *(_DWORD *)(a3 + 8);
  v23 = 0x3F80000000000000;
  v24 = v4;
  v25 = 0;
  if (a2 >= 6)
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Unsupported drive axis!", "!\"Unreachable code\"", "physxDriveAxis", 66);
    result = _os_crash();
    __break(1u);
  }
  else
  {
    v6 = ((__n128 (*)(uint64_t, _QWORD, uint64_t *))*(_QWORD *)(*(_QWORD *)v3 + 360))(v3, dword_226192364[(int)a2], &v23);
    v6.n128_u32[0] = *(_DWORD *)(a1 + 228);
    v6.n128_u32[1] = *(_DWORD *)(a1 + 248);
    v6.n128_u32[2] = *(_DWORD *)(a1 + 268);
    v22 = v6;
    v6.n128_u32[0] = *(_DWORD *)(a1 + 288);
    v6.n128_u32[1] = *(_DWORD *)(a1 + 308);
    v6.n128_u32[2] = *(_DWORD *)(a1 + 328);
    v21 = v6;
    (*(void (**)(uint64_t, __n128 *, __n128 *, uint64_t))(*(_QWORD *)v3 + 392))(v3, &v22, &v21, 1);
    v7 = *(float *)(a1 + 260);
    v8 = *(float *)(a1 + 280);
    v20[4] = *(float *)(a1 + 240);
    v20[5] = v7;
    v20[6] = v8;
    v9 = __sincosf_stret(*(float *)(a1 + 300) * 0.5);
    v10 = v9.__sinval * 0.0;
    v11 = __sincosf_stret(*(float *)(a1 + 320) * 0.5);
    v12 = v11.__sinval * 0.0;
    v13 = __sincosf_stret(*(float *)(a1 + 340) * 0.5);
    v14 = v11.__cosval * (float)(v13.__sinval * 0.0);
    v15 = (float)((float)(v14 + (float)(v13.__cosval * v12)) + (float)((float)(v13.__sinval * 0.0) * v12))
        - (float)(v11.__sinval * v13.__sinval);
    v16 = (float)((float)(v14 + (float)(v13.__cosval * v11.__sinval)) + (float)(v13.__sinval * v12))
        - (float)(v12 * (float)(v13.__sinval * 0.0));
    v17 = (float)((float)((float)(v11.__cosval * v13.__sinval) + (float)(v13.__cosval * v12))
                + (float)((float)(v13.__sinval * 0.0) * v11.__sinval))
        - (float)(v12 * (float)(v13.__sinval * 0.0));
    v18 = (float)((float)((float)(v13.__cosval * v11.__cosval) - (float)((float)(v13.__sinval * 0.0) * v12))
                - (float)((float)(v13.__sinval * 0.0) * v11.__sinval))
        - (float)(v13.__sinval * v12);
    v20[0] = (float)((float)((float)(v9.__cosval * v15) + (float)(v18 * v9.__sinval)) + (float)(v16 * v10))
           - (float)(v10 * v17);
    v20[1] = (float)((float)((float)(v9.__cosval * v16) + (float)(v18 * v10)) + (float)(v17 * v9.__sinval))
           - (float)(v10 * v15);
    v20[2] = (float)((float)((float)(v9.__cosval * v17) + (float)(v18 * v10)) + (float)(v15 * v10))
           - (float)(v9.__sinval * v16);
    v20[3] = (float)((float)((float)(v18 * v9.__cosval) - (float)(v15 * v9.__sinval)) - (float)(v16 * v10))
           - (float)(v17 * v10);
    return (*(uint64_t (**)(uint64_t, float *, uint64_t))(*(_QWORD *)v3 + 376))(v3, v20, 1);
  }
  return result;
}

uint64_t re::convertLimit(re *this, const re::AngularLimit *a2, float *a3, float *a4)
{
  float v4;
  float v5;
  int v6;
  int v7;
  uint64_t v8;

  v4 = *(float *)this;
  v5 = *((float *)this + 1);
  if (*(float *)this == v5)
    v6 = 2;
  else
    v6 = 1;
  if (*(float *)this > v5)
    v6 = 0;
  if (v6 != 2)
  {
    if (v6 == 1)
    {
      if (a2)
        *(float *)a2 = v4;
      if (!a3)
        return 1;
      v7 = *((_DWORD *)this + 1);
      v8 = 1;
    }
    else
    {
      if (a2)
        *(_DWORD *)a2 = 0;
      v7 = 0;
      v8 = 2;
      if (!a3)
        return v8;
    }
LABEL_20:
    *(_DWORD *)a3 = v7;
    return v8;
  }
  if (a2)
    *(float *)a2 = v4;
  v8 = 0;
  if (a3)
  {
    v7 = *((_DWORD *)this + 1);
    goto LABEL_20;
  }
  return v8;
}

void re::PhysXGeneric6DOFConstraint::~PhysXGeneric6DOFConstraint(re::PhysXGeneric6DOFConstraint *this)
{
  void (***v2)(_QWORD);

  v2 = (void (***)(_QWORD))*((_QWORD *)this + 44);
  if (v2)
    (**v2)(v2);
  *(_QWORD *)this = &off_24ED7E818;
  re::StringID::destroyString((re::PhysXGeneric6DOFConstraint *)((char *)this + 24));
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  void (***v2)(_QWORD);

  v2 = (void (***)(_QWORD))*((_QWORD *)this + 44);
  if (v2)
    (**v2)(v2);
  *(_QWORD *)this = &off_24ED7E818;
  re::StringID::destroyString((re::PhysXGeneric6DOFConstraint *)((char *)this + 24));
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

float re::AngularLimit::range(re::AngularLimit *this, float a2, float a3)
{
  float v5;
  NSObject *v6;
  int v8;
  double v9;
  __int16 v10;
  double v11;
  __int16 v12;
  double v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v5 = a3 - a2;
  if ((float)(a3 - a2) >= 6.2657)
  {
    v6 = *re::physicsLogObjects(this);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      v8 = 134218496;
      v9 = (float)((float)(a2 * 180.0) * 0.31831);
      v10 = 2048;
      v11 = (float)((float)(a3 * 180.0) * 0.31831);
      v12 = 2048;
      v13 = (float)((float)(v5 * 180.0) * 0.31831);
      _os_log_impl(&dword_224FE9000, v6, OS_LOG_TYPE_DEFAULT, "Warning: Range of angular limit is too large (min = %f°, max = %f°, range = %f°). The range needs to be significantly less than 360°. Otherwise, the angular limit might be ineffective.", (uint8_t *)&v8, 0x20u);
    }
  }
  return a2;
}

float re::AngularLimit::symmetricRange(re::AngularLimit *this, float a2)
{
  return re::AngularLimit::range(this, a2 * -0.5, a2 * 0.5);
}

float re::AngularLimit::free(re::AngularLimit *this)
{
  return 1.0;
}

uint64_t *re::allocInfo_LinearLimit(re *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&qword_25411D1E8);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_25411D1E8))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_25411D220, 0);
    *(uint64_t *)((char *)&qword_25411D230 + 6) = 0;
    qword_25411D230 = 0;
    qword_25411D240 = 0;
    qword_25411D248 = 0xFFFFFFFFLL;
    qword_25411D220 = (uint64_t)&off_24ED7DAA8;
    qword_25411D250 = (uint64_t)"LinearLimit";
    dword_25411D258 = 0;
    unk_25411D260 = 0u;
    unk_25411D270 = 0u;
    unk_25411D280 = 0u;
    qword_25411D290 = 0;
    __cxa_guard_release(&qword_25411D1E8);
  }
  return &qword_25411D220;
}

void re::initInfo_LinearLimit(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  const re::IntrospectionBase *v7;
  void *v8;
  uint64_t v9;
  uint64_t *v10;
  const re::IntrospectionBase *v11;
  void *v12;
  uint64_t v13;
  __int128 v14;
  _QWORD v15[2];
  __int128 v16;

  v15[0] = 0x1CF05B5D2D046ECLL;
  v15[1] = "LinearLimit";
  re::StringID::destroyString((re::StringID *)v15);
  *((_OWORD *)this + 2) = v16;
  v4 = atomic_load((unsigned __int8 *)&_MergedGlobals_418);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&_MergedGlobals_418);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      v8 = re::introspect_float((re *)1, v7);
      v9 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
      *(_DWORD *)v9 = 1;
      *(_QWORD *)(v9 + 8) = "m_min";
      *(_QWORD *)(v9 + 16) = v8;
      *(_QWORD *)(v9 + 24) = 0;
      *(_QWORD *)(v9 + 32) = 1;
      *(_DWORD *)(v9 + 40) = 0;
      *(_QWORD *)(v9 + 48) = 0;
      *(_QWORD *)(v9 + 56) = 0;
      *(_DWORD *)(v9 + 64) = 0;
      qword_25411D200 = v9;
      v10 = re::introspectionAllocator((re *)v9);
      v12 = re::introspect_float((re *)1, v11);
      v13 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v10 + 32))(v10, 72, 8);
      *(_DWORD *)v13 = 1;
      *(_QWORD *)(v13 + 8) = "m_max";
      *(_QWORD *)(v13 + 16) = v12;
      *(_QWORD *)(v13 + 24) = 0;
      *(_QWORD *)(v13 + 32) = 0x400000002;
      *(_DWORD *)(v13 + 40) = 0;
      *(_QWORD *)(v13 + 48) = 0;
      *(_QWORD *)(v13 + 56) = 0;
      *(_DWORD *)(v13 + 64) = 0;
      qword_25411D208 = v13;
      __cxa_guard_release(&_MergedGlobals_418);
    }
  }
  *((_QWORD *)this + 2) = 0x800000008;
  *((_DWORD *)this + 6) = 4;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 2;
  *((_QWORD *)this + 8) = &qword_25411D200;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::LinearLimit>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::LinearLimit>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::LinearLimit>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::LinearLimit>;
  re::IntrospectionRegistry::add(this, v3);
  v14 = v16;
}

double re::internal::defaultConstruct<re::LinearLimit>(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  double result;

  result = -0.00781250185;
  *a3 = 0xBF8000003F800000;
  return result;
}

double re::internal::defaultConstructV2<re::LinearLimit>(_QWORD *a1)
{
  double result;

  result = -0.00781250185;
  *a1 = 0xBF8000003F800000;
  return result;
}

uint64_t re::introspect_LinearLimit(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"LinearLimit", (uint64_t (*)(re::internal *))re::allocInfo_LinearLimit, (re::IntrospectionBase *(*)(void))re::initInfo_LinearLimit, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::LinearLimit>, this);
}

uint64_t *re::allocInfo_AngularLimit(re *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&qword_25411D1F8);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_25411D1F8))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_25411D298, 0);
    *(uint64_t *)((char *)&qword_25411D2A8 + 6) = 0;
    qword_25411D2A8 = 0;
    qword_25411D2B8 = 0;
    qword_25411D2C0 = 0xFFFFFFFFLL;
    qword_25411D298 = (uint64_t)&off_24ED7DAA8;
    qword_25411D2C8 = (uint64_t)"AngularLimit";
    dword_25411D2D0 = 0;
    xmmword_25411D2D8 = 0u;
    unk_25411D2E8 = 0u;
    xmmword_25411D2F8 = 0u;
    qword_25411D308 = 0;
    __cxa_guard_release(&qword_25411D1F8);
  }
  return &qword_25411D298;
}

void re::initInfo_AngularLimit(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  const re::IntrospectionBase *v7;
  void *v8;
  uint64_t v9;
  uint64_t *v10;
  const re::IntrospectionBase *v11;
  void *v12;
  uint64_t v13;
  __int128 v14;
  _QWORD v15[2];
  __int128 v16;

  v15[0] = 0x306BACEF40AE7E32;
  v15[1] = "AngularLimit";
  re::StringID::destroyString((re::StringID *)v15);
  *((_OWORD *)this + 2) = v16;
  v4 = atomic_load((unsigned __int8 *)&qword_25411D1F0);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_25411D1F0);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      v8 = re::introspect_float((re *)1, v7);
      v9 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
      *(_DWORD *)v9 = 1;
      *(_QWORD *)(v9 + 8) = "m_min";
      *(_QWORD *)(v9 + 16) = v8;
      *(_QWORD *)(v9 + 24) = 0;
      *(_QWORD *)(v9 + 32) = 1;
      *(_DWORD *)(v9 + 40) = 0;
      *(_QWORD *)(v9 + 48) = 0;
      *(_QWORD *)(v9 + 56) = 0;
      *(_DWORD *)(v9 + 64) = 0;
      qword_25411D210 = v9;
      v10 = re::introspectionAllocator((re *)v9);
      v12 = re::introspect_float((re *)1, v11);
      v13 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v10 + 32))(v10, 72, 8);
      *(_DWORD *)v13 = 1;
      *(_QWORD *)(v13 + 8) = "m_max";
      *(_QWORD *)(v13 + 16) = v12;
      *(_QWORD *)(v13 + 24) = 0;
      *(_QWORD *)(v13 + 32) = 0x400000002;
      *(_DWORD *)(v13 + 40) = 0;
      *(_QWORD *)(v13 + 48) = 0;
      *(_QWORD *)(v13 + 56) = 0;
      *(_DWORD *)(v13 + 64) = 0;
      qword_25411D218 = v13;
      __cxa_guard_release(&qword_25411D1F0);
    }
  }
  *((_QWORD *)this + 2) = 0x800000008;
  *((_DWORD *)this + 6) = 4;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 2;
  *((_QWORD *)this + 8) = &qword_25411D210;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::AngularLimit>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::AngularLimit>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::AngularLimit>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::AngularLimit>;
  re::IntrospectionRegistry::add(this, v3);
  v14 = v16;
}

double re::internal::defaultConstruct<re::AngularLimit>(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  double result;

  result = -0.00781250185;
  *a3 = 0xBF8000003F800000;
  return result;
}

double re::internal::defaultConstructV2<re::AngularLimit>(_QWORD *a1)
{
  double result;

  result = -0.00781250185;
  *a1 = 0xBF8000003F800000;
  return result;
}

uint64_t re::introspect_AngularLimit(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"AngularLimit", (uint64_t (*)(re::internal *))re::allocInfo_AngularLimit, (re::IntrospectionBase *(*)(void))re::initInfo_AngularLimit, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::AngularLimit>, this);
}

_DWORD *re::DampedSpring::onApply(float32x4_t *this)
{
  uint64_t v2;
  float32x4_t v3;
  float32x4_t v4;
  float32x4_t v5;
  float32x4_t v6;
  int32x4_t v7;
  float32x4_t v8;
  int32x4_t v9;
  float32x4_t v10;
  uint64_t v11;
  float32x4_t v12;
  uint64_t v13;
  float32x4_t v14;
  uint64_t v15;
  float32x4_t v16;
  int32x4_t v17;
  float32x4_t v18;
  uint64_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  int32x4_t v24;
  float32x4_t v25;
  int32x4_t v26;
  float32x4_t v27;
  uint64_t v28;
  float32x4_t v29;
  uint64_t v30;
  float32x4_t v31;
  uint64_t v32;
  float32x4_t v33;
  int32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float v38;
  float v39;
  float v40;
  float32x2_t v41;
  float32x2_t v42;
  float32x4_t v43;
  float32x4_t v44;
  _DWORD *v45;
  _DWORD *result;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  int32x4_t v58;

  v2 = this[1].i64[1];
  if (v2)
  {
    (*(void (**)(float32x4_t *__return_ptr))(*(_QWORD *)v2 + 40))(&v57);
    v3 = this[3];
    v4 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v58, v58), (int8x16_t)v58, 0xCuLL);
    v5 = vnegq_f32((float32x4_t)v58);
    v6 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v3, (int32x4_t)v3), (int8x16_t)v3, 0xCuLL), v5), v3, v4);
    v7 = (int32x4_t)vaddq_f32(v6, v6);
    v8 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v7, v7), (int8x16_t)v7, 0xCuLL);
    v9 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v8, (int32x4_t)v8), (int8x16_t)v8, 0xCuLL), v5), v8, v4);
    v10 = vaddq_f32(v57, vaddq_f32(vaddq_f32(v3, vmulq_laneq_f32(v8, (float32x4_t)v58, 3)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v9, v9), (int8x16_t)v9, 0xCuLL)));
    v56 = v10;
    v11 = this[1].i64[1];
    if (v11)
    {
      v50 = v10;
      v12.i64[0] = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v11 + 216))(this[1].i64[1]);
      v12.i64[1] = v13;
      v52 = v12;
      v14.i64[0] = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v11 + 232))(v11);
      v14.i64[1] = v15;
      v48 = v14;
      (*(void (**)(float32x4_t *__return_ptr, uint64_t))(*(_QWORD *)v11 + 208))(&v57, v11);
      v16 = vsubq_f32(v50, v57);
      v17 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v16, (int32x4_t)v16), (int8x16_t)v16, 0xCuLL), vnegq_f32(v48)), v16, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v48, (int32x4_t)v48), (int8x16_t)v48, 0xCuLL));
      v18 = vaddq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v17, v17), (int8x16_t)v17, 0xCuLL), v52);
      goto LABEL_6;
    }
  }
  else
  {
    v56 = this[3];
  }
  v18 = 0uLL;
LABEL_6:
  v19 = this[2].i64[0];
  if (v19)
  {
    v53 = v18;
    (*(void (**)(float32x4_t *__return_ptr))(*(_QWORD *)v19 + 40))(&v57);
    v20 = this[4];
    v21 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v58, v58), (int8x16_t)v58, 0xCuLL);
    v22 = vnegq_f32((float32x4_t)v58);
    v23 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v20, (int32x4_t)v20), (int8x16_t)v20, 0xCuLL), v22), v20, v21);
    v24 = (int32x4_t)vaddq_f32(v23, v23);
    v25 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v24, v24), (int8x16_t)v24, 0xCuLL);
    v26 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v25, (int32x4_t)v25), (int8x16_t)v25, 0xCuLL), v22), v25, v21);
    v27 = vaddq_f32(v57, vaddq_f32(vaddq_f32(v20, vmulq_laneq_f32(v25, (float32x4_t)v58, 3)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v26, v26), (int8x16_t)v26, 0xCuLL)));
    v55 = v27;
    v28 = this[2].i64[0];
    if (v28)
    {
      v51 = v27;
      v29.i64[0] = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v28 + 216))(this[2].i64[0]);
      v29.i64[1] = v30;
      v49 = v29;
      v31.i64[0] = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v28 + 232))(v28);
      v31.i64[1] = v32;
      v47 = v31;
      (*(void (**)(float32x4_t *__return_ptr, uint64_t))(*(_QWORD *)v28 + 208))(&v57, v28);
      v27 = v51;
      v33 = vsubq_f32(v51, v57);
      v34 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v33, (int32x4_t)v33), (int8x16_t)v33, 0xCuLL), vnegq_f32(v47)), v33, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v47, (int32x4_t)v47), (int8x16_t)v47, 0xCuLL));
      v35 = vaddq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v34, v34), (int8x16_t)v34, 0xCuLL), v49);
    }
    else
    {
      v35 = 0uLL;
    }
    v18 = v53;
  }
  else
  {
    v55 = this[4];
    v35 = 0uLL;
    v27 = v55;
  }
  v36 = vsubq_f32(v27, v56);
  v37 = vmulq_f32(v36, v36);
  LODWORD(v38) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v37, 2), vaddq_f32(v37, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v37.f32, 1))).u32[0];
  v39 = sqrtf(v38);
  if (fabsf(v38) < 1.0e-10)
  {
    v43 = (float32x4_t)xmmword_2260E5F20;
  }
  else
  {
    v40 = v38;
    v41 = vrsqrte_f32((float32x2_t)LODWORD(v38));
    v42 = vmul_f32(v41, vrsqrts_f32((float32x2_t)LODWORD(v40), vmul_f32(v41, v41)));
    v43 = vmulq_n_f32(v36, vmul_f32(v42, vrsqrts_f32((float32x2_t)LODWORD(v40), vmul_f32(v42, v42))).f32[0]);
  }
  v44 = vmulq_f32(vsubq_f32(v18, v35), v43);
  v57 = vaddq_f32(vmulq_n_f32(v43, this[5].f32[1] * (float)(v39 - this[5].f32[0])), vmulq_n_f32(v43, (float)-this[5].f32[2]* vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v44, 2), vaddq_f32(v44, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v44.f32, 1))).f32[0]));
  v45 = (_DWORD *)this[1].i64[1];
  if (v45 && v45[52] == 2)
    (*(void (**)(_DWORD *, float32x4_t *, float32x4_t *, _QWORD))(*(_QWORD *)v45 + 376))(v45, &v57, &v56, 0);
  result = (_DWORD *)this[2].i64[0];
  if (result)
  {
    if (result[52] == 2)
    {
      v54 = vnegq_f32(v57);
      return (_DWORD *)(*(uint64_t (**)(_DWORD *, float32x4_t *, float32x4_t *, _QWORD))(*(_QWORD *)result
                                                                                                 + 376))(result, &v54, &v55, 0);
    }
  }
  return result;
}

void re::DampedSpring::~DampedSpring(re::DampedSpring *this)
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::DampedSpring::type(re::DampedSpring *this)
{
  return 4;
}

void re::AngularSpring::onApply(re::AngularSpring *this)
{
  float32x4_t v2;
  float32x4_t v3;
  float32x4_t v4;
  float32x4_t v5;
  int8x16_t v6;
  float32x4_t v7;
  float32x4_t v8;
  int8x16_t v9;
  float32x4_t v10;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;
  int8x16_t v14;
  float32x4_t v15;
  int8x16_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int32x4_t v19;
  float32x2_t v20;
  float32x2_t v21;
  int32x4_t v22;
  float32x2_t v23;
  float32x2_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float v27;
  float v28;
  float32x2_t v29;
  float32x2_t v30;
  float32x4_t v31;
  float32x4_t v32;
  int32x4_t v33;
  float32x2_t v34;
  float32x2_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  int32x4_t v40;
  float32x4_t v41;
  int8x16_t v42;
  float32x4_t v43;
  float32x4_t v44;
  int8x16_t v45;
  int8x16_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  int32x4_t v50;
  float32x2_t v51;
  float32x2_t v52;
  float32x4_t v53;
  int8x16_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float v57;
  float v58;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  int32x4_t v65;
  float32x2_t v66;
  float32x2_t v67;
  float v68;
  float v69;
  float v70;
  float v71;
  int32x2_t v72;
  float v73;
  float v74;
  float v75;
  uint64_t v76;
  int v77;
  float v78;
  float v79;
  uint64_t v80;
  int v81;
  float v82;
  float v83;
  float32x4_t v84;
  float v85;
  float32x4_t v86;
  float v87;
  float32x2_t v88;
  float32x2_t v89;
  float32x4_t v90;
  float v91;
  float32x4_t v92;
  float v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  int32x4_t v98;

  (*(void (**)(float32x4_t *__return_ptr))(**((_QWORD **)this + 3) + 40))(&v97);
  v2 = *((float32x4_t *)this + 3);
  v3 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v98, v98), (int8x16_t)v98, 0xCuLL);
  v4 = vnegq_f32((float32x4_t)v98);
  v5 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v2, (int32x4_t)v2), (int8x16_t)v2, 0xCuLL), v4), v2, v3);
  v6 = (int8x16_t)vaddq_f32(v5, v5);
  v7 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v6, (int32x4_t)v6), v6, 0xCuLL);
  v8 = vaddq_f32(v2, vmulq_laneq_f32(v7, (float32x4_t)v98, 3));
  v9 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v7, (int32x4_t)v7), (int8x16_t)v7, 0xCuLL), v4), v7, v3);
  v94 = vaddq_f32(v8, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v9, (int32x4_t)v9), v9, 0xCuLL));
  (*(void (**)(float32x4_t *__return_ptr))(**((_QWORD **)this + 4) + 40))(&v97);
  v10 = *((float32x4_t *)this + 4);
  v11 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v98, v98), (int8x16_t)v98, 0xCuLL);
  v12 = vnegq_f32((float32x4_t)v98);
  v13 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v10, (int32x4_t)v10), (int8x16_t)v10, 0xCuLL), v12), v10, v11);
  v14 = (int8x16_t)vaddq_f32(v13, v13);
  v15 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v14, (int32x4_t)v14), v14, 0xCuLL);
  v16 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v15, (int32x4_t)v15), (int8x16_t)v15, 0xCuLL), v12), v15, v11);
  v17 = vaddq_f32(v97, vaddq_f32(vaddq_f32(v10, vmulq_laneq_f32(v15, (float32x4_t)v98, 3)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v16, (int32x4_t)v16), v16, 0xCuLL)));
  v18 = vmulq_f32(v94, v17);
  if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v18, 2), vaddq_f32(v18, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v18.f32, 1))).f32[0] >= 0.0)
  {
    v49 = vaddq_f32(v94, v17);
    v50 = (int32x4_t)vmulq_f32(v49, v49);
    v50.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v50, 2), vadd_f32(*(float32x2_t *)v50.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v50.i8, 1))).u32[0];
    v51 = vrsqrte_f32((float32x2_t)v50.u32[0]);
    v52 = vmul_f32(v51, vrsqrts_f32((float32x2_t)v50.u32[0], vmul_f32(v51, v51)));
    v53 = vmulq_n_f32(v49, vmul_f32(v52, vrsqrts_f32((float32x2_t)v50.u32[0], vmul_f32(v52, v52))).f32[0]);
    v54 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v53, (int32x4_t)v53), (int8x16_t)v53, 0xCuLL), vnegq_f32(v94)), v53, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v94, (int32x4_t)v94), (int8x16_t)v94, 0xCuLL));
    v48 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v54, (int32x4_t)v54), v54, 0xCuLL);
    v55 = vmulq_f32(v94, v53);
    v48.i32[3] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v55, 2), vaddq_f32(v55, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v55.f32, 1))).u32[0];
  }
  else
  {
    v19 = (int32x4_t)vmulq_f32(v94, v94);
    v19.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v19, 2), vadd_f32(*(float32x2_t *)v19.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v19.i8, 1))).u32[0];
    v20 = vrsqrte_f32((float32x2_t)v19.u32[0]);
    v21 = vmul_f32(v20, vrsqrts_f32((float32x2_t)v19.u32[0], vmul_f32(v20, v20)));
    v19.i32[0] = vmul_f32(v21, vrsqrts_f32((float32x2_t)v19.u32[0], vmul_f32(v21, v21))).u32[0];
    v22 = (int32x4_t)vmulq_f32(v17, v17);
    v22.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v22, 2), vadd_f32(*(float32x2_t *)v22.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v22.i8, 1))).u32[0];
    v23 = vrsqrte_f32((float32x2_t)v22.u32[0]);
    v24 = vmul_f32(v23, vrsqrts_f32((float32x2_t)v22.u32[0], vmul_f32(v23, v23)));
    v25 = vaddq_f32(vmulq_n_f32(v94, *(float *)v19.i32), vmulq_n_f32(v17, vmul_f32(v24, vrsqrts_f32((float32x2_t)v22.u32[0], vmul_f32(v24, v24))).f32[0]));
    v26 = vmulq_f32(v25, v25);
    v27 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v26, 2), vaddq_f32(v26, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v26.f32, 1))).f32[0];
    if (v27 <= 1.4211e-14)
    {
      v56 = vabsq_f32(v94);
      v57 = v56.f32[1];
      v58 = v56.f32[2];
      if (v56.f32[0] > v56.f32[1] || v56.f32[0] > v56.f32[2])
      {
        v60 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v94, (int32x4_t)v94), (int8x16_t)v94, 0xCuLL);
        if (v57 <= v58)
        {
          v61 = vmulq_f32(v94, (float32x4_t)xmmword_2261027C0);
          v62 = (float32x4_t)xmmword_2260E5F20;
        }
        else
        {
          v61 = vmulq_f32(v94, (float32x4_t)xmmword_2261027D0);
          v62 = (float32x4_t)xmmword_2260E5F40;
        }
      }
      else
      {
        v60 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v94, (int32x4_t)v94), (int8x16_t)v94, 0xCuLL);
        v61 = vmulq_f32(v94, (float32x4_t)xmmword_2261027B0);
        v62 = (float32x4_t)xmmword_2260E5F10;
      }
      v63 = vmlaq_f32(v61, v62, v60);
      v64 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v63, (int32x4_t)v63), (int8x16_t)v63, 0xCuLL);
      v65 = (int32x4_t)vmulq_f32(v63, v63);
      v65.i32[0] = vadd_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v65.i8, 1), vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v65, 2), *(float32x2_t *)v65.i8)).u32[0];
      v66 = vrsqrte_f32((float32x2_t)v65.u32[0]);
      v67 = vmul_f32(v66, vrsqrts_f32((float32x2_t)v65.u32[0], vmul_f32(v66, v66)));
      v48 = vmulq_n_f32(v64, vmul_f32(v67, vrsqrts_f32((float32x2_t)v65.u32[0], vmul_f32(v67, v67))).f32[0]);
      v48.i32[3] = 0;
    }
    else
    {
      v28 = v27;
      v29 = vrsqrte_f32((float32x2_t)LODWORD(v27));
      v30 = vmul_f32(v29, vrsqrts_f32((float32x2_t)LODWORD(v28), vmul_f32(v29, v29)));
      v31 = vmulq_n_f32(v25, vmul_f32(v30, vrsqrts_f32((float32x2_t)LODWORD(v28), vmul_f32(v30, v30))).f32[0]);
      v32 = vaddq_f32(v94, v31);
      v33 = (int32x4_t)vmulq_f32(v32, v32);
      v33.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v33, 2), vadd_f32(*(float32x2_t *)v33.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v33.i8, 1))).u32[0];
      v34 = vrsqrte_f32((float32x2_t)v33.u32[0]);
      v35 = vmul_f32(v34, vrsqrts_f32((float32x2_t)v33.u32[0], vmul_f32(v34, v34)));
      v36 = vmulq_n_f32(v32, vmul_f32(v35, vrsqrts_f32((float32x2_t)v33.u32[0], vmul_f32(v35, v35))).f32[0]);
      v37 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v36, (int32x4_t)v36), (int8x16_t)v36, 0xCuLL), vnegq_f32(v94)), v36, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v94, (int32x4_t)v94), (int8x16_t)v94, 0xCuLL));
      v38 = vmulq_f32(v94, v36);
      v39 = vaddq_f32(v17, v31);
      v40 = (int32x4_t)vmulq_f32(v39, v39);
      v40.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v40, 2), vadd_f32(*(float32x2_t *)v40.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v40.i8, 1))).u32[0];
      *(float32x2_t *)v33.i8 = vrsqrte_f32((float32x2_t)v40.u32[0]);
      *(float32x2_t *)v33.i8 = vmul_f32(*(float32x2_t *)v33.i8, vrsqrts_f32((float32x2_t)v40.u32[0], vmul_f32(*(float32x2_t *)v33.i8, *(float32x2_t *)v33.i8)));
      v41 = vmulq_n_f32(v39, vmul_f32(*(float32x2_t *)v33.i8, vrsqrts_f32((float32x2_t)v40.u32[0], vmul_f32(*(float32x2_t *)v33.i8, *(float32x2_t *)v33.i8))).f32[0]);
      v42 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v41, (int32x4_t)v41), (int8x16_t)v41, 0xCuLL), vnegq_f32(v31)), v41, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v31, (int32x4_t)v31), (int8x16_t)v31, 0xCuLL));
      v43 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v42, (int32x4_t)v42), v42, 0xCuLL);
      v44 = vmulq_f32(v31, v41);
      v43.i32[3] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v44, 2), vaddq_f32(v44, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v44.f32, 1))).u32[0];
      v45 = (int8x16_t)vnegq_f32(v43);
      v46 = (int8x16_t)vtrn2q_s32((int32x4_t)v43, vtrn1q_s32((int32x4_t)v43, (int32x4_t)v45));
      v47 = (float32x4_t)vrev64q_s32((int32x4_t)v43);
      v47.i32[0] = v45.i32[1];
      v47.i32[3] = v45.i32[2];
      v48 = vaddq_f32(vmlaq_lane_f32(vmulq_n_f32(v43, vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v38, 2), vaddq_f32(v38, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v38.f32, 1))).f32[0]), v47, *(float32x2_t *)v37.f32, 1), vmlaq_laneq_f32(vmulq_n_f32((float32x4_t)vextq_s8((int8x16_t)v43, v45, 8uLL), v37.f32[0]), (float32x4_t)vextq_s8(v46, v46, 8uLL), v37, 2));
    }
  }
  v95 = v48;
  v68 = v48.f32[3];
  v69 = fabsf(v48.f32[3]);
  if (v69 <= 1.0 || fabsf(v69 + -1.0) < (float)((float)((float)(v69 + 1.0) + 1.0) * 0.00001))
  {
    if (v48.f32[3] > 1.0)
      v68 = 1.0;
    if (v68 < -1.0)
      v68 = -1.0;
    v71 = acosf(v68);
    v70 = v71 + v71;
  }
  else
  {
    v70 = NAN;
  }
  v72.i32[1] = 1051772663;
  if (fabsf(v70) >= 0.000001)
  {
    *((_DWORD *)this + 22) = 0;
    v73 = *((float *)this + 20);
    if (v70 <= v73
      || (v74 = *((float *)this + 23), v74 <= 0.000001)
      || (v75 = (float)(v70 - v73) / v74, *((float *)this + 22) = v75, v75 <= 1.0))
    {
      v76 = *((_QWORD *)this + 3);
      v77 = *(_DWORD *)(v76 + 208);
      v78 = 0.0;
      v79 = 0.0;
      if (v77 == 2)
        v79 = *(float *)(v76 + 192);
      v80 = *((_QWORD *)this + 4);
      v81 = *(_DWORD *)(v80 + 208);
      if (v81 == 2)
        v78 = *(float *)(v80 + 192);
      v82 = v79 + v78;
      if ((float)(v79 + v78) != 0.0)
      {
        v83 = -(float)(*((float *)this + 21) * (float)(v70 - v73));
        v84 = vmulq_f32(v95, v95);
        LODWORD(v85) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v84, 2), vaddq_f32(v84, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v84.f32, 1))).u32[0];
        v86 = 0uLL;
        if (fabsf(v85) >= 1.0e-10)
        {
          v87 = v85;
          v88 = vrsqrte_f32((float32x2_t)LODWORD(v85));
          v89 = vmul_f32(v88, vrsqrts_f32((float32x2_t)LODWORD(v87), vmul_f32(v88, v88)));
          v86 = vmulq_n_f32(v95, vmul_f32(v89, vrsqrts_f32((float32x2_t)LODWORD(v87), vmul_f32(v89, v89))).f32[0]);
        }
        v90 = vmulq_n_f32(v86, v83);
        v91 = v78 / v82;
        if (v78 == 0.0)
          v91 = 1.0;
        v92 = vmulq_n_f32(v90, v91);
        v93 = v79 / v82;
        if (v79 == 0.0)
          *(float *)v72.i32 = 1.0;
        else
          *(float *)v72.i32 = v93;
        v96 = vmulq_f32(v90, vnegq_f32((float32x4_t)vdupq_lane_s32(v72, 0)));
        v97 = v92;
        if (v77 == 2)
        {
          (*(void (**)(uint64_t, float32x4_t *, _QWORD))(*(_QWORD *)v76 + 392))(v76, &v97, 0);
          v80 = *((_QWORD *)this + 4);
          v81 = *(_DWORD *)(v80 + 208);
        }
        if (v81 == 2)
          (*(void (**)(uint64_t, float32x4_t *, _QWORD))(*(_QWORD *)v80 + 392))(v80, &v96, 0);
      }
    }
    else if (*((_BYTE *)this + 16))
    {
      *((_BYTE *)this + 16) = 0;
      (*(void (**)(re::AngularSpring *))(*(_QWORD *)this + 32))(this);
    }
  }
}

void re::AngularSpring::~AngularSpring(re::AngularSpring *this)
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::AngularSpring::type(re::AngularSpring *this)
{
  return 6;
}

float WGLComputeFalloff(int a1, uint64_t a2, double a3, double a4)
{
  uint64_t v4;
  uint64_t v5;
  float v6;
  float v7;
  float v8;

  v6 = *(float *)&a3;
  LODWORD(a3) = 1.0;
  if (v6 > 0.0)
  {
    LODWORD(a3) = 1.0;
    *(float *)&a4 = 1.0 - fminf(fmaxf(*(float *)&a4 / v6, 0.0), 1.0);
    switch(a1)
    {
      case 0:
        return *(float *)&a3;
      case 1:
        LODWORD(a3) = LODWORD(a4);
        return *(float *)&a3;
      case 2:
        *(float *)&a3 = *(float *)&a4 * *(float *)&a4;
        return *(float *)&a3;
      case 3:
        v7 = *(float *)&a4 * *(float *)&a4;
        goto LABEL_10;
      case 4:
        v8 = *(float *)&a4 * *(float *)&a4;
        goto LABEL_9;
      case 5:
        v8 = *(float *)&a4 * (float)(*(float *)&a4 * *(float *)&a4);
LABEL_9:
        v7 = *(float *)&a4 * v8;
LABEL_10:
        *(float *)&a3 = *(float *)&a4 * v7;
        break;
      default:
        re::internal::assertLog((re::internal *)4, a2, a3, a4, "assertion failure: '%s' (%s:line %i) Unexpected falloff type.", "!\"Unreachable code\"", "WGLComputeFalloff", 32, v4, v5);
        _os_crash();
        __break(1u);
        JUMPOUT(0x225BA7640);
    }
  }
  return *(float *)&a3;
}

uint64_t re::PhysicsFactory::init(re::PhysicsFactory *this, re::CollisionFactory *a2)
{
  uint64_t *v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t result;

  v3 = re::globalAllocators(this);
  re::PhysicsFactory::m_defaultAllocator = v3[2];
  v4 = re::globalAllocators((re *)v3);
  v5 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v4[2] + 32))(v4[2], 48, 8);
  result = re::PhysXPhysicsFactory::PhysXPhysicsFactory(v5, (uint64_t)this);
  re::PhysicsFactory::m_defaultFactory = result;
  return result;
}

re *re::PhysicsFactory::deinit(re *this)
{
  void (***v1)(_QWORD);
  uint64_t v2;

  v1 = (void (***)(_QWORD))re::PhysicsFactory::m_defaultFactory;
  if (re::PhysicsFactory::m_defaultFactory)
  {
    v2 = re::globalAllocators(this)[2];
    (**v1)(v1);
    this = (re *)(*(uint64_t (**)(uint64_t, void (***)(_QWORD)))(*(_QWORD *)v2 + 40))(v2, v1);
  }
  re::PhysicsFactory::m_defaultFactory = 0;
  return this;
}

double WGLGoalComputeLinearForce(float32x2_t *a1, uint64_t a2, float32x4_t a3, double a4, float32x4_t a5, float32x4_t a6)
{
  float v6;
  double v7;
  float32x4_t v8;
  int8x16_t v9;
  int8x16_t v10;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;
  int8x16_t v14;
  int8x16_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v19;

  v6 = a1[6].f32[0];
  v7 = 0.0;
  if (v6 > 0.0)
  {
    v8 = vmulq_f32(a6, (float32x4_t)xmmword_2261923B0);
    v9 = (int8x16_t)vnegq_f32(v8);
    v10 = (int8x16_t)vtrn2q_s32((int32x4_t)v8, vtrn1q_s32((int32x4_t)v8, (int32x4_t)v9));
    v11 = vmlaq_n_f32(vmulq_lane_f32((float32x4_t)vextq_s8((int8x16_t)v8, v9, 8uLL), *a1, 1), (float32x4_t)vextq_s8(v10, v10, 8uLL), COERCE_FLOAT(*(_OWORD *)a1->f32));
    v12 = (float32x4_t)vrev64q_s32((int32x4_t)v8);
    v12.i32[0] = v9.i32[1];
    v12.i32[3] = v9.i32[2];
    v13 = vmlaq_laneq_f32(v11, v12, *(float32x4_t *)a1->f32, 2);
    v14 = (int8x16_t)vnegq_f32(v13);
    v15 = (int8x16_t)vtrn2q_s32((int32x4_t)v13, vtrn1q_s32((int32x4_t)v13, (int32x4_t)v14));
    v16 = (float32x4_t)vrev64q_s32((int32x4_t)v13);
    v16.i32[0] = v14.i32[1];
    v16.i32[3] = v14.i32[2];
    v19 = vsubq_f32(vaddq_f32(a5, vaddq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(v13, a6, 3), v16, a6, 2), vmlaq_n_f32(vmulq_lane_f32((float32x4_t)vextq_s8((int8x16_t)v13, v14, 8uLL), *(float32x2_t *)a6.f32, 1), (float32x4_t)vextq_s8(v15, v15, 8uLL), a6.f32[0]))), a3);
    a3.i32[0] = a1[7].i32[1];
    v17 = vmulq_f32(v19, v19);
    v17.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v17, 2), vaddq_f32(v17, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v17.f32, 1))).u64[0];
    v17.f32[0] = sqrtf(v17.f32[0]);
    *(_QWORD *)&v7 = vmulq_n_f32(v19, v6 * WGLComputeFalloff(a1[10].i32[1], a2, *(double *)a3.i64, *(double *)v17.i64)).u64[0];
  }
  return v7;
}

double WGLGoalComputeAngularTorque(float32x4_t *a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5)
{
  float v6;
  double v7;
  float32x4_t v9;
  int8x16_t v10;
  int8x16_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  float32x4_t v16;
  int8x16_t v17;
  int8x16_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  float32x2_t v23;
  float32x4_t v24;
  unsigned __int32 v25;
  float32x2_t v26;
  float32x2_t v27;
  float32x4_t v28;
  uint64_t v29;
  double v30;
  float32x4_t v31;
  int8x16_t v32;
  int8x16_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  int8x16_t v37;
  float32x4_t v38;
  int8x16_t v39;
  float32x4_t v40;
  float v41;
  float32x4_t v42;
  float32x4_t v44;
  float v45;
  float32x4_t v46;
  float32x4_t v47;
  float v49;
  float32x4_t v51;

  v6 = a1[3].f32[1];
  v7 = 0.0;
  if (v6 > 0.0)
  {
    v9 = a1[1];
    v10 = (int8x16_t)vnegq_f32(v9);
    v11 = (int8x16_t)vtrn2q_s32((int32x4_t)v9, vtrn1q_s32((int32x4_t)v9, (int32x4_t)v10));
    v12 = vmlaq_n_f32(vmulq_lane_f32((float32x4_t)vextq_s8((int8x16_t)v9, v10, 8uLL), *(float32x2_t *)a5.f32, 1), (float32x4_t)vextq_s8(v11, v11, 8uLL), a5.f32[0]);
    v13 = (float32x4_t)vrev64q_s32((int32x4_t)v9);
    v13.i32[0] = v10.i32[1];
    v13.i32[3] = v10.i32[2];
    v14 = vaddq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(v9, a5, 3), v13, a5, 2), v12);
    v15 = (int8x16_t)vmulq_f32(v14, v14);
    *(float32x2_t *)v15.i8 = vadd_f32(*(float32x2_t *)v15.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v15, v15, 8uLL));
    v15.i32[0] = vadd_f32(*(float32x2_t *)v15.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v15.i8, 1)).u32[0];
    *(float32x2_t *)v13.f32 = vrecpe_f32((float32x2_t)v15.u32[0]);
    *(float32x2_t *)v13.f32 = vmul_f32(*(float32x2_t *)v13.f32, vrecps_f32((float32x2_t)v15.u32[0], *(float32x2_t *)v13.f32));
    v16 = vmulq_n_f32(vmulq_f32(v14, (float32x4_t)xmmword_2261923B0), vmul_f32(*(float32x2_t *)v13.f32, vrecps_f32((float32x2_t)v15.u32[0], *(float32x2_t *)v13.f32)).f32[0]);
    v17 = (int8x16_t)vnegq_f32(v16);
    v18 = (int8x16_t)vtrn2q_s32((int32x4_t)v16, vtrn1q_s32((int32x4_t)v16, (int32x4_t)v17));
    v19 = vmlaq_n_f32(vmulq_lane_f32((float32x4_t)vextq_s8((int8x16_t)v16, v17, 8uLL), *(float32x2_t *)a3.f32, 1), (float32x4_t)vextq_s8(v18, v18, 8uLL), a3.f32[0]);
    v20 = (float32x4_t)vrev64q_s32((int32x4_t)v16);
    v20.i32[0] = v17.i32[1];
    v20.i32[3] = v17.i32[2];
    v21 = vaddq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(v16, a3, 3), v20, a3, 2), v19);
    v22 = (int8x16_t)vmulq_f32(v21, v21);
    v23 = vadd_f32(*(float32x2_t *)v22.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v22, v22, 8uLL));
    v47 = a5;
    if (vaddv_f32(v23) == 0.0)
    {
      v24 = (float32x4_t)xmmword_2260E5D70;
    }
    else
    {
      v25 = vadd_f32(v23, (float32x2_t)vdup_lane_s32((int32x2_t)v23, 1)).u32[0];
      v26 = vrsqrte_f32((float32x2_t)v25);
      v27 = vmul_f32(v26, vrsqrts_f32((float32x2_t)v25, vmul_f32(v26, v26)));
      v24 = vmulq_n_f32(v21, vmul_f32(v27, vrsqrts_f32((float32x2_t)v25, vmul_f32(v27, v27))).f32[0]);
    }
    v28 = vmulq_f32(v24, v24);
    v44 = *a1;
    LODWORD(v45) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v28, 2), vaddq_f32(v28, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v28.f32, 1))).u32[0];
    v46 = v24;
    *(float *)&v30 = atan2f(sqrtf(v45), v24.f32[3]);
    *(float *)&v30 = *(float *)&v30 + *(float *)&v30;
    v7 = 0.0;
    if (*(float *)&v30 != 0.0)
    {
      v31 = vmulq_f32(v47, (float32x4_t)xmmword_2261923B0);
      v32 = (int8x16_t)vnegq_f32(v31);
      v33 = (int8x16_t)vtrn2q_s32((int32x4_t)v31, vtrn1q_s32((int32x4_t)v31, (int32x4_t)v32));
      v34 = (float32x4_t)vextq_s8((int8x16_t)v31, v32, 8uLL);
      v35 = (float32x4_t)vrev64q_s32((int32x4_t)v31);
      v35.i32[0] = v32.i32[1];
      v35.i32[3] = v32.i32[2];
      v36 = vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v34, *(float32x2_t *)v44.f32, 1), (float32x4_t)vextq_s8(v33, v33, 8uLL), v44.f32[0]), v35, v44, 2);
      v37 = (int8x16_t)vnegq_f32(v36);
      v38 = (float32x4_t)vrev64q_s32((int32x4_t)v36);
      v39 = (int8x16_t)vtrn2q_s32((int32x4_t)v36, vtrn1q_s32((int32x4_t)v36, (int32x4_t)v37));
      v38.i32[0] = v37.i32[1];
      v38.i32[3] = v37.i32[2];
      v40 = vsubq_f32(vaddq_f32(a4, vaddq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(v36, v47, 3), v38, v47, 2), vmlaq_n_f32(vmulq_lane_f32((float32x4_t)vextq_s8((int8x16_t)v36, v37, 8uLL), *(float32x2_t *)v47.f32, 1), (float32x4_t)vextq_s8(v39, v39, 8uLL), v47.f32[0]))), a2);
      *(float32x2_t *)v36.f32 = vrsqrte_f32((float32x2_t)LODWORD(v45));
      *(float32x2_t *)v36.f32 = vmul_f32(*(float32x2_t *)v36.f32, vrsqrts_f32((float32x2_t)LODWORD(v45), vmul_f32(*(float32x2_t *)v36.f32, *(float32x2_t *)v36.f32)));
      v51 = vmulq_n_f32(v46, vmul_f32(*(float32x2_t *)v36.f32, vrsqrts_f32((float32x2_t)LODWORD(v45), vmul_f32(*(float32x2_t *)v36.f32, *(float32x2_t *)v36.f32))).f32[0]);
      v38.f32[0] = 6.28318531 - *(float *)&v30;
      v41 = -v38.f32[0];
      if (*(float *)&v30 > 3.14159265)
        *(float *)&v30 = v41;
      v49 = *(float *)&v30;
      LODWORD(v30) = a1[3].i32[3];
      v42 = vmulq_f32(v40, v40);
      v42.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v42, 2), vaddq_f32(v42, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v42.f32, 1))).u64[0];
      v42.f32[0] = sqrtf(v42.f32[0]);
      *(_QWORD *)&v7 = vmulq_n_f32(vmulq_n_f32(v51, v49), v6 * WGLComputeFalloff(a1[5].i32[1], v29, v30, *(double *)v42.i64)).u64[0];
    }
  }
  return v7;
}

void *re::introspect_MotionType(re *this, const re::IntrospectionBase *a2)
{
  int v2;
  unsigned __int8 v3;
  unsigned __int8 v4;
  char v5;
  re *v6;
  std::__shared_mutex_base *v7;
  re *v8;
  std::__shared_mutex_base *v9;
  re *v11;
  uint64_t *v12;
  re *v13;
  uint64_t *v14;
  re *v15;
  uint64_t *v16;
  uint64_t v17;
  re::IntrospectionBasic *v18;
  uint64_t v19[2];
  __int128 v20;

  v2 = (int)this;
  if ((v3 & 1) == 0)
  {
    if ((_DWORD)v11)
    {
      v12 = re::introspectionAllocator(v11);
      v13 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v12 + 32))(v12, 24, 8);
      *(_DWORD *)v13 = 1;
      *((_QWORD *)v13 + 1) = 0;
      *((_QWORD *)v13 + 2) = "Static";
      re::introspect_MotionType(BOOL)::enumAttributes = (uint64_t)v13;
      v14 = re::introspectionAllocator(v13);
      v15 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v14 + 32))(v14, 24, 8);
      *(_DWORD *)v15 = 1;
      *((_QWORD *)v15 + 1) = 1;
      *((_QWORD *)v15 + 2) = "Kinematic";
      qword_25582AC40 = (uint64_t)v15;
      v16 = re::introspectionAllocator(v15);
      v17 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v16 + 32))(v16, 24, 8);
      *(_DWORD *)v17 = 1;
      *(_QWORD *)(v17 + 8) = 2;
      *(_QWORD *)(v17 + 16) = "Dynamic";
      qword_25582AC48 = v17;
    }
  }
  {
    v18 = re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&re::introspect_MotionType(BOOL)::info, "MotionType", 4, 4, 1, 1);
    *(_QWORD *)v18 = &off_24ED7D9E8;
    *((_QWORD *)v18 + 8) = &re::introspect_MotionType(BOOL)::enumTable;
    *((_DWORD *)v18 + 4) = 9;
  }
  if (v2)
  {
    if ((re::introspect_MotionType(BOOL)::isInitialized & 1) != 0)
      return &re::introspect_MotionType(BOOL)::info;
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v20);
    v5 = re::introspect_MotionType(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v20);
    if ((v5 & 1) != 0)
      return &re::introspect_MotionType(BOOL)::info;
    v7 = re::introspectionSharedMutex(v6);
    std::__shared_mutex_base::lock(v7);
    if ((re::introspect_MotionType(BOOL)::isInitialized & 1) != 0)
    {
LABEL_9:
      v9 = re::introspectionSharedMutex(v8);
      std::__shared_mutex_base::unlock(v9);
      return &re::introspect_MotionType(BOOL)::info;
    }
  }
  re::introspect_MotionType(BOOL)::isInitialized = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&re::introspect_MotionType(BOOL)::info, a2);
  v19[0] = 0xF296097B3A860;
  v19[1] = (uint64_t)"MotionType";
  xmmword_25582AC78 = v20;
  re::StringID::destroyString((re::StringID *)v19);
  if ((v2 & 1) == 0)
    goto LABEL_9;
  return &re::introspect_MotionType(BOOL)::info;
}

uint64_t *re::introspect_PhysicsJointType(re *this, const re::IntrospectionBase *a2)
{
  int v2;
  unsigned __int8 v3;
  unsigned __int8 v4;
  char v5;
  re *v6;
  std::__shared_mutex_base *v7;
  re *v8;
  uint64_t *v9;
  uint64_t v10;
  unsigned int *v11;
  _anonymous_namespace_ *v12;
  unint64_t v13;
  unint64_t i;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  char v18;
  unsigned __int8 *v19;
  int v20;
  uint64_t v21;
  unint64_t j;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  char v26;
  unsigned __int8 *v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  std::__shared_mutex_base *v31;
  uint64_t *result;
  re *v33;
  uint64_t *v34;
  re *v35;
  uint64_t *v36;
  re *v37;
  uint64_t *v38;
  re *v39;
  uint64_t *v40;
  re *v41;
  uint64_t *v42;
  re *v43;
  uint64_t *v44;
  re *v45;
  uint64_t *v46;
  re *v47;
  uint64_t *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  const char *v52;
  StringID v53;
  _QWORD v54[2];
  _QWORD v55[61];

  v2 = (int)this;
  v3 = atomic_load((unsigned __int8 *)&qword_25411D318);
  if ((v3 & 1) == 0)
  {
    v33 = (re *)__cxa_guard_acquire(&qword_25411D318);
    if ((_DWORD)v33)
    {
      v34 = re::introspectionAllocator(v33);
      v35 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v34 + 32))(v34, 24, 8);
      *(_DWORD *)v35 = 1;
      *((_QWORD *)v35 + 1) = 0;
      *((_QWORD *)v35 + 2) = "Unknown";
      qword_25411D328 = (uint64_t)v35;
      v36 = re::introspectionAllocator(v35);
      v37 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v36 + 32))(v36, 24, 8);
      *(_DWORD *)v37 = 1;
      *((_QWORD *)v37 + 1) = 1;
      *((_QWORD *)v37 + 2) = "FixedJoint";
      qword_25411D330 = (uint64_t)v37;
      v38 = re::introspectionAllocator(v37);
      v39 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v38 + 32))(v38, 24, 8);
      *(_DWORD *)v39 = 1;
      *((_QWORD *)v39 + 1) = 2;
      *((_QWORD *)v39 + 2) = "SphericalJoint";
      qword_25411D338 = (uint64_t)v39;
      v40 = re::introspectionAllocator(v39);
      v41 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v40 + 32))(v40, 24, 8);
      *(_DWORD *)v41 = 1;
      *((_QWORD *)v41 + 1) = 3;
      *((_QWORD *)v41 + 2) = "RevoluteJoint";
      qword_25411D340 = (uint64_t)v41;
      v42 = re::introspectionAllocator(v41);
      v43 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v42 + 32))(v42, 24, 8);
      *(_DWORD *)v43 = 1;
      *((_QWORD *)v43 + 1) = 4;
      *((_QWORD *)v43 + 2) = "PrismaticJoint";
      qword_25411D348 = (uint64_t)v43;
      v44 = re::introspectionAllocator(v43);
      v45 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v44 + 32))(v44, 24, 8);
      *(_DWORD *)v45 = 1;
      *((_QWORD *)v45 + 1) = 5;
      *((_QWORD *)v45 + 2) = "DistanceJoint";
      qword_25411D350 = (uint64_t)v45;
      v46 = re::introspectionAllocator(v45);
      v47 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v46 + 32))(v46, 24, 8);
      *(_DWORD *)v47 = 1;
      *((_QWORD *)v47 + 1) = 6;
      *((_QWORD *)v47 + 2) = "CustomJoint";
      qword_25411D358 = (uint64_t)v47;
      v48 = re::introspectionAllocator(v47);
      v49 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v48 + 32))(v48, 24, 8);
      *(_DWORD *)v49 = 1;
      *(_QWORD *)(v49 + 8) = 7;
      *(_QWORD *)(v49 + 16) = "TwistSwingJoint";
      qword_25411D360 = v49;
      __cxa_guard_release(&qword_25411D318);
    }
  }
  v4 = atomic_load((unsigned __int8 *)&qword_25411D320);
  if ((v4 & 1) == 0 && __cxa_guard_acquire(&qword_25411D320))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_25411D368, "PhysicsJointType", 4, 4, 1, 1);
    qword_25411D368 = (uint64_t)&off_24ED7D9E8;
    qword_25411D3A8 = (uint64_t)&re::introspect_PhysicsJointType(BOOL)::enumTable;
    dword_25411D378 = 9;
    __cxa_guard_release(&qword_25411D320);
  }
  if (v2)
  {
    if ((_MergedGlobals_419 & 1) != 0)
      return &qword_25411D368;
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)v55);
    v5 = _MergedGlobals_419;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)v55);
    if ((v5 & 1) != 0)
      return &qword_25411D368;
    v7 = re::introspectionSharedMutex(v6);
    std::__shared_mutex_base::lock(v7);
    if ((_MergedGlobals_419 & 1) != 0)
    {
LABEL_34:
      v31 = re::introspectionSharedMutex(v8);
      std::__shared_mutex_base::unlock(v31);
      return &qword_25411D368;
    }
  }
  _MergedGlobals_419 = 1;
  re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_25411D368, a2);
  v51 = 0x3A6AA135739A28FALL;
  v52 = "PhysicsJointType";
  v55[0] = 0x607DD0F01DCLL;
  v55[1] = "uint32_t";
  v9 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v55);
  if (v9)
  {
    v10 = *v9;
    re::StringID::destroyString((re::StringID *)v55);
    v11 = (unsigned int *)qword_25411D3A8;
    v54[1] = v10;
    re::TypeBuilder::beginEnumType((uint64_t)v55, &v51, 1, 1, (uint64_t)v54);
    v13 = *v11;
    if ((_DWORD)v13)
    {
      for (i = 0; i < v13; ++i)
      {
        v15 = *(_QWORD *)(*((_QWORD *)v11 + 1) + 8 * i);
        if (*(_DWORD *)v15 == 1)
        {
          v16 = *(char **)(v15 + 16);
          if (v16)
          {
            v17 = *v16;
            if (*v16)
            {
              v18 = v16[1];
              if (v18)
              {
                v19 = (unsigned __int8 *)(v16 + 2);
                do
                {
                  v17 = 31 * v17 + v18;
                  v20 = *v19++;
                  v18 = v20;
                }
                while (v20);
              }
            }
          }
          else
          {
            v17 = 0;
          }
          v21 = *(_QWORD *)(v15 + 8);
          *(_QWORD *)&v53.var0 = 2 * v17;
          v53.var1 = v16;
          re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v55, v21, &v53);
          re::StringID::destroyString((re::StringID *)&v53);
          v13 = *v11;
        }
      }
      if (v13)
      {
        for (j = 0; j < v13; ++j)
        {
          v23 = *(_QWORD *)(*((_QWORD *)v11 + 1) + 8 * j);
          if (*(_DWORD *)v23 == 2)
          {
            v24 = *(char **)(v23 + 16);
            if (v24)
            {
              v25 = *v24;
              if (*v24)
              {
                v26 = v24[1];
                if (v26)
                {
                  v27 = (unsigned __int8 *)(v24 + 2);
                  do
                  {
                    v25 = 31 * v25 + v26;
                    v28 = *v27++;
                    v26 = v28;
                  }
                  while (v28);
                }
              }
            }
            else
            {
              v25 = 0;
            }
            v29 = *(_QWORD *)(v23 + 8);
            *(_QWORD *)&v53.var0 = 2 * v25;
            v53.var1 = v24;
            re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v55, v29, &v53);
            re::StringID::destroyString((re::StringID *)&v53);
            v13 = *v11;
          }
        }
      }
    }
    re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v55, v30);
    xmmword_25411D388 = (__int128)v53;
    re::StringID::destroyString((re::StringID *)&v51);
    if ((v2 & 1) != 0)
      return &qword_25411D368;
    goto LABEL_34;
  }
  re::StringID::destroyString((re::StringID *)v55);
  re::internal::assertLog((re::internal *)5, v50, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "PhysicsJointType", v51, v52);
  result = (uint64_t *)_os_crash();
  __break(1u);
  return result;
}

double re::DistanceJoint::DistanceJoint(uint64_t a1, uint64_t a2)
{
  double result;

  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = &str_110;
  *(_QWORD *)(a1 + 40) = a2;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)a1 = off_24ED7EAA8;
  result = 6.08244611e77;
  *(_QWORD *)(a1 + 56) = 0x501502F900000000;
  *(_DWORD *)(a1 + 64) = 1008981770;
  return result;
}

uint64_t re::DistanceJoint::setDistanceRange(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  float v4;
  float v5;

  v3 = *a2;
  *(_QWORD *)(a1 + 56) = *a2;
  v5 = *((float *)&v3 + 1);
  v4 = *(float *)&v3;
  if (*(float *)&v3 <= *((float *)&v3 + 1))
  {
    if (*(float *)&v3 > 1.0e10)
      v4 = 1.0e10;
    if (v4 < 0.0)
      v4 = 0.0;
    if (*((float *)&v3 + 1) > 1.0e10)
      v5 = 1.0e10;
    if (v5 < 0.0)
      v5 = 0.0;
    *(float *)(a1 + 56) = v4;
    *(float *)(a1 + 60) = v5;
  }
  if (v4 > v5)
  {
    *(float *)(a1 + 56) = v5;
    *(float *)(a1 + 60) = v4;
  }
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

void re::introspect_REPhysicsForceMode(re *this, const re::IntrospectionBase *a2)
{
  unsigned __int8 v2;
  unsigned __int8 v3;
  uint64_t *v4;
  uint64_t v5;
  unsigned int *v6;
  _anonymous_namespace_ *v7;
  unint64_t v8;
  unint64_t i;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  char v13;
  unsigned __int8 *v14;
  int v15;
  uint64_t v16;
  unint64_t j;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  char v21;
  unsigned __int8 *v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  re *v26;
  uint64_t *v27;
  re *v28;
  uint64_t *v29;
  re *v30;
  uint64_t *v31;
  re *v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  const char *v37;
  StringID v38;
  _QWORD v39[2];
  _QWORD v40[61];

  v2 = atomic_load((unsigned __int8 *)&qword_25411D3B8);
  if ((v2 & 1) == 0)
  {
    v26 = (re *)__cxa_guard_acquire(&qword_25411D3B8);
    if ((_DWORD)v26)
    {
      v27 = re::introspectionAllocator(v26);
      v28 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v27 + 32))(v27, 24, 8);
      *(_DWORD *)v28 = 1;
      *((_QWORD *)v28 + 1) = 0;
      *((_QWORD *)v28 + 2) = "REPhysicsForceModeForce";
      qword_25411D440 = (uint64_t)v28;
      v29 = re::introspectionAllocator(v28);
      v30 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v29 + 32))(v29, 24, 8);
      *(_DWORD *)v30 = 1;
      *((_QWORD *)v30 + 1) = 1;
      *((_QWORD *)v30 + 2) = "REPhysicsForceModeImpulse";
      qword_25411D448 = (uint64_t)v30;
      v31 = re::introspectionAllocator(v30);
      v32 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v31 + 32))(v31, 24, 8);
      *(_DWORD *)v32 = 1;
      *((_QWORD *)v32 + 1) = 2;
      *((_QWORD *)v32 + 2) = "REPhysicsForceModeVelocity";
      qword_25411D450 = (uint64_t)v32;
      v33 = re::introspectionAllocator(v32);
      v34 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v33 + 32))(v33, 24, 8);
      *(_DWORD *)v34 = 1;
      *(_QWORD *)(v34 + 8) = 3;
      *(_QWORD *)(v34 + 16) = "REPhysicsForceModeAcceleration";
      qword_25411D458 = v34;
      __cxa_guard_release(&qword_25411D3B8);
    }
  }
  v3 = atomic_load((unsigned __int8 *)&qword_25411D3C0);
  if ((v3 & 1) == 0 && __cxa_guard_acquire(&qword_25411D3C0))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_25411D510, "REPhysicsForceMode", 1, 1, 1, 1);
    qword_25411D510 = (uint64_t)&off_24ED7D9E8;
    qword_25411D550 = (uint64_t)&re::introspect_REPhysicsForceMode(BOOL)::enumTable;
    dword_25411D520 = 9;
    __cxa_guard_release(&qword_25411D3C0);
  }
  if ((_MergedGlobals_420 & 1) == 0)
  {
    _MergedGlobals_420 = 1;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_25411D510, a2);
    v36 = 0xD906E491CB7559F4;
    v37 = "REPhysicsForceMode";
    v40[0] = 0x31CD534126;
    v40[1] = "uint8_t";
    v4 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v40);
    if (v4)
    {
      v5 = *v4;
      re::StringID::destroyString((re::StringID *)v40);
      v6 = (unsigned int *)qword_25411D550;
      v39[1] = v5;
      re::TypeBuilder::beginEnumType((uint64_t)v40, &v36, 1, 1, (uint64_t)v39);
      v8 = *v6;
      if ((_DWORD)v8)
      {
        for (i = 0; i < v8; ++i)
        {
          v10 = *(_QWORD *)(*((_QWORD *)v6 + 1) + 8 * i);
          if (*(_DWORD *)v10 == 1)
          {
            v11 = *(char **)(v10 + 16);
            if (v11)
            {
              v12 = *v11;
              if (*v11)
              {
                v13 = v11[1];
                if (v13)
                {
                  v14 = (unsigned __int8 *)(v11 + 2);
                  do
                  {
                    v12 = 31 * v12 + v13;
                    v15 = *v14++;
                    v13 = v15;
                  }
                  while (v15);
                }
              }
            }
            else
            {
              v12 = 0;
            }
            v16 = *(_QWORD *)(v10 + 8);
            *(_QWORD *)&v38.var0 = 2 * v12;
            v38.var1 = v11;
            re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v40, v16, &v38);
            re::StringID::destroyString((re::StringID *)&v38);
            v8 = *v6;
          }
        }
        if (v8)
        {
          for (j = 0; j < v8; ++j)
          {
            v18 = *(_QWORD *)(*((_QWORD *)v6 + 1) + 8 * j);
            if (*(_DWORD *)v18 == 2)
            {
              v19 = *(char **)(v18 + 16);
              if (v19)
              {
                v20 = *v19;
                if (*v19)
                {
                  v21 = v19[1];
                  if (v21)
                  {
                    v22 = (unsigned __int8 *)(v19 + 2);
                    do
                    {
                      v20 = 31 * v20 + v21;
                      v23 = *v22++;
                      v21 = v23;
                    }
                    while (v23);
                  }
                }
              }
              else
              {
                v20 = 0;
              }
              v24 = *(_QWORD *)(v18 + 8);
              *(_QWORD *)&v38.var0 = 2 * v20;
              v38.var1 = v19;
              re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v40, v24, &v38);
              re::StringID::destroyString((re::StringID *)&v38);
              v8 = *v6;
            }
          }
        }
      }
      re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v40, v25);
      xmmword_25411D530 = (__int128)v38;
      re::StringID::destroyString((re::StringID *)&v36);
    }
    else
    {
      re::StringID::destroyString((re::StringID *)v40);
      re::internal::assertLog((re::internal *)5, v35, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "REPhysicsForceMode", v36, v37);
      _os_crash();
      __break(1u);
    }
  }
}

void re::internal::defaultConstruct<re::TimedForceFalloff>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)a3 = 0x3FF0000000000000;
  *(_DWORD *)(a3 + 8) = 1065353216;
}

uint64_t re::internal::defaultConstructV2<re::TimedForceFalloff>(uint64_t result)
{
  *(_QWORD *)result = 0x3FF0000000000000;
  *(_DWORD *)(result + 8) = 1065353216;
  return result;
}

double re::internal::defaultConstruct<re::SpatialForceFalloff>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double result;

  *(_QWORD *)&result = 1065353216;
  *(_QWORD *)a3 = 1065353216;
  *(_DWORD *)(a3 + 8) = 1065353216;
  return result;
}

double re::internal::defaultConstructV2<re::SpatialForceFalloff>(uint64_t a1)
{
  double result;

  *(_QWORD *)&result = 1065353216;
  *(_QWORD *)a1 = 1065353216;
  *(_DWORD *)(a1 + 8) = 1065353216;
  return result;
}

uint64_t *re::allocInfo_ForceEffectDefinition(re *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  v1 = atomic_load((unsigned __int8 *)&qword_25411D3F8);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_25411D3F8))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_25411D648, 0);
    *(_QWORD *)(v3 + 22) = 0;
    qword_25411D658 = 0;
    qword_25411D668 = 0;
    qword_25411D670 = 0xFFFFFFFFLL;
    qword_25411D648 = (uint64_t)&off_24ED7DAA8;
    qword_25411D678 = (uint64_t)"ForceEffectDefinition";
    dword_25411D680 = 0;
    xmmword_25411D688 = 0u;
    unk_25411D698 = 0u;
    xmmword_25411D6A8 = 0u;
    qword_25411D6B8 = 0;
    __cxa_guard_release(&qword_25411D3F8);
  }
  return &qword_25411D648;
}

void re::initInfo_ForceEffectDefinition(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  const re::IntrospectionBase *v10;
  void *v11;
  uint64_t v12;
  uint64_t *v13;
  const re::IntrospectionBase *v14;
  void *v15;
  uint64_t v16;
  uint64_t *v17;
  const re::IntrospectionBase *v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  __int128 v24;
  _QWORD v25[2];
  __int128 v26;

  v25[0] = 0xDC17E0035793655ELL;
  v25[1] = "ForceEffectDefinition";
  re::StringID::destroyString((re::StringID *)v25);
  *((_OWORD *)this + 2) = v26;
  v4 = atomic_load((unsigned __int8 *)&qword_25411D400);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_25411D400);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      v7 = re::introspect_PoseF((re::IntrospectionBase **)1);
      v8 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
      *(_DWORD *)v8 = 1;
      *(_QWORD *)(v8 + 8) = "pose";
      *(_QWORD *)(v8 + 16) = v7;
      *(_QWORD *)(v8 + 24) = 0;
      *(_QWORD *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + 40) = 0;
      *(_QWORD *)(v8 + 48) = 0;
      *(_QWORD *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_25411D460 = v8;
      v9 = re::introspectionAllocator((re *)v8);
      v11 = re::introspect_float((re *)1, v10);
      v12 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v9 + 32))(v9, 72, 8);
      *(_DWORD *)v12 = 1;
      *(_QWORD *)(v12 + 8) = "strength";
      *(_QWORD *)(v12 + 16) = v11;
      *(_QWORD *)(v12 + 24) = 0;
      *(_QWORD *)(v12 + 32) = 0x2000000002;
      *(_DWORD *)(v12 + 40) = 0;
      *(_QWORD *)(v12 + 48) = 0;
      *(_QWORD *)(v12 + 56) = 0;
      *(_DWORD *)(v12 + 64) = 0;
      qword_25411D468 = v12;
      v13 = re::introspectionAllocator((re *)v12);
      v15 = re::introspect_uint32_t((re *)1, v14);
      v16 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v13 + 32))(v13, 72, 8);
      *(_DWORD *)v16 = 1;
      *(_QWORD *)(v16 + 8) = "mask";
      *(_QWORD *)(v16 + 16) = v15;
      *(_QWORD *)(v16 + 24) = 0;
      *(_QWORD *)(v16 + 32) = 0x2400000003;
      *(_DWORD *)(v16 + 40) = 0;
      *(_QWORD *)(v16 + 48) = 0;
      *(_QWORD *)(v16 + 56) = 0;
      *(_DWORD *)(v16 + 64) = 0;
      qword_25411D470 = v16;
      v17 = re::introspectionAllocator((re *)v16);
      re::introspect_REPhysicsForceMode((re *)v17, v18);
      v19 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v17 + 32))(v17, 72, 8);
      *(_DWORD *)v19 = 1;
      *(_QWORD *)(v19 + 8) = "forceMode";
      *(_QWORD *)(v19 + 16) = &qword_25411D510;
      *(_QWORD *)(v19 + 24) = 0;
      *(_QWORD *)(v19 + 32) = 0x2800000004;
      *(_DWORD *)(v19 + 40) = 0;
      *(_QWORD *)(v19 + 48) = 0;
      *(_QWORD *)(v19 + 56) = 0;
      *(_DWORD *)(v19 + 64) = 0;
      qword_25411D478 = v19;
      v20 = re::introspectionAllocator((re *)v19);
      re::IntrospectionInfo<re::Optional<re::SpatialForceFalloff>>::get();
      v21 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v20 + 32))(v20, 72, 8);
      *(_DWORD *)v21 = 1;
      *(_QWORD *)(v21 + 8) = "spatialForceFalloff";
      *(_QWORD *)(v21 + 16) = qword_25411D490;
      *(_QWORD *)(v21 + 24) = 0;
      *(_QWORD *)(v21 + 32) = 0x2C00000005;
      *(_DWORD *)(v21 + 40) = 0;
      *(_QWORD *)(v21 + 48) = 0;
      *(_QWORD *)(v21 + 56) = 0;
      *(_DWORD *)(v21 + 64) = 0;
      qword_25411D480 = v21;
      v22 = re::introspectionAllocator((re *)v21);
      re::IntrospectionInfo<re::Optional<re::TimedForceFalloff>>::get();
      v23 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v22 + 32))(v22, 72, 8);
      *(_DWORD *)v23 = 1;
      *(_QWORD *)(v23 + 8) = "timedForceFalloff";
      *(_QWORD *)(v23 + 16) = &qword_25411D4D0;
      *(_QWORD *)(v23 + 24) = 0;
      *(_QWORD *)(v23 + 32) = 0x4000000006;
      *(_DWORD *)(v23 + 40) = 0;
      *(_QWORD *)(v23 + 48) = 0;
      *(_QWORD *)(v23 + 56) = 0;
      *(_DWORD *)(v23 + 64) = 0;
      qword_25411D488 = v23;
      __cxa_guard_release(&qword_25411D400);
    }
  }
  *((_QWORD *)this + 2) = 0xB000000008;
  *((_DWORD *)this + 6) = 16;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 6;
  *((_QWORD *)this + 8) = &qword_25411D460;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::ForceEffectDefinition>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::ForceEffectDefinition>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::ForceEffectDefinition>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::ForceEffectDefinition>;
  re::IntrospectionRegistry::add(this, v3);
  v24 = v26;
}

void re::IntrospectionInfo<re::Optional<re::SpatialForceFalloff>>::get()
{
  unsigned __int8 v0;
  uint64_t *v1;
  unsigned __int8 v2;
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  int v5;
  re::IntrospectionRegistry *v6;
  const re::IntrospectionBase *v7;
  const char *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  re *v13;
  uint64_t *v14;
  const re::IntrospectionBase *v15;
  void *v16;
  uint64_t v17;
  uint64_t *v18;
  const re::IntrospectionBase *v19;
  void *v20;
  uint64_t v21;
  uint64_t *v22;
  const re::IntrospectionBase *v23;
  void *v24;
  uint64_t v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28[2];
  __int128 v29;
  const char *v30;
  __int128 v31;

  v0 = atomic_load((unsigned __int8 *)&qword_25411D408);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_25411D408))
  {
    re::IntrospectionOptionalBase::IntrospectionOptionalBase((re::IntrospectionOptionalBase *)qword_25411D490);
    qword_25411D490[0] = (uint64_t)&off_24ED7EB78;
    __cxa_guard_release(&qword_25411D408);
  }
  if ((byte_25411D3B1 & 1) == 0)
  {
    v1 = (uint64_t *)qword_25411D3F0;
    if (qword_25411D3F0)
      goto LABEL_7;
    v2 = atomic_load((unsigned __int8 *)&qword_25411D3E0);
    if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_25411D3E0))
    {
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_25411D5D0, 0);
      *(_QWORD *)(v12 + 22) = 0;
      qword_25411D5E0 = 0;
      *(_QWORD *)&xmmword_25411D5F0 = 0;
      *((_QWORD *)&xmmword_25411D5F0 + 1) = 0xFFFFFFFFLL;
      qword_25411D5D0 = (uint64_t)&off_24ED7DAA8;
      qword_25411D600 = (uint64_t)"SpatialForceFalloff";
      dword_25411D608 = 0;
      xmmword_25411D610 = 0u;
      *(_OWORD *)&qword_25411D620 = 0u;
      xmmword_25411D630 = 0u;
      qword_25411D640 = 0;
      __cxa_guard_release(&qword_25411D3E0);
    }
    qword_25411D3F0 = (uint64_t)&qword_25411D5D0;
    *(_QWORD *)&v31 = 0xC60D12D4D665635ALL;
    *((_QWORD *)&v31 + 1) = "SpatialForceFalloff";
    re::StringID::destroyString((re::StringID *)&v31);
    xmmword_25411D5F0 = v29;
    v4 = atomic_load((unsigned __int8 *)&qword_25411D3E8);
    if ((v4 & 1) == 0)
    {
      v13 = (re *)__cxa_guard_acquire(&qword_25411D3E8);
      if ((_DWORD)v13)
      {
        v14 = re::introspectionAllocator(v13);
        v16 = re::introspect_float((re *)1, v15);
        v17 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v14 + 32))(v14, 72, 8);
        *(_DWORD *)v17 = 1;
        *(_QWORD *)(v17 + 8) = "radius";
        *(_QWORD *)(v17 + 16) = v16;
        *(_QWORD *)(v17 + 24) = 0;
        *(_QWORD *)(v17 + 32) = 1;
        *(_DWORD *)(v17 + 40) = 0;
        *(_QWORD *)(v17 + 48) = 0;
        *(_QWORD *)(v17 + 56) = 0;
        *(_DWORD *)(v17 + 64) = 0;
        qword_25411D428 = v17;
        v18 = re::introspectionAllocator((re *)v17);
        v20 = re::introspect_float((re *)1, v19);
        v21 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v18 + 32))(v18, 72, 8);
        *(_DWORD *)v21 = 1;
        *(_QWORD *)(v21 + 8) = "distanceOffset";
        *(_QWORD *)(v21 + 16) = v20;
        *(_QWORD *)(v21 + 24) = 0;
        *(_QWORD *)(v21 + 32) = 0x400000002;
        *(_DWORD *)(v21 + 40) = 0;
        *(_QWORD *)(v21 + 48) = 0;
        *(_QWORD *)(v21 + 56) = 0;
        *(_DWORD *)(v21 + 64) = 0;
        qword_25411D430 = v21;
        v22 = re::introspectionAllocator((re *)v21);
        v24 = re::introspect_float((re *)1, v23);
        v25 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v22 + 32))(v22, 72, 8);
        *(_DWORD *)v25 = 1;
        *(_QWORD *)(v25 + 8) = "rate";
        *(_QWORD *)(v25 + 16) = v24;
        *(_QWORD *)(v25 + 24) = 0;
        *(_QWORD *)(v25 + 32) = 0x800000003;
        *(_DWORD *)(v25 + 40) = 0;
        *(_QWORD *)(v25 + 48) = 0;
        *(_QWORD *)(v25 + 56) = 0;
        *(_DWORD *)(v25 + 64) = 0;
        qword_25411D438 = v25;
        __cxa_guard_release(&qword_25411D3E8);
      }
    }
    qword_25411D5E0 = 0xC00000008;
    v1 = &qword_25411D5D0;
    dword_25411D5E8 = 4;
    word_25411D5EC = 1;
    dword_25411D608 = 3;
    *(_QWORD *)&xmmword_25411D610 = &qword_25411D428;
    *((_QWORD *)&xmmword_25411D610 + 1) = re::internal::defaultConstruct<re::SpatialForceFalloff>;
    qword_25411D620 = (uint64_t)re::internal::defaultDestruct<re::SpatialForceFalloff>;
    *(_QWORD *)&xmmword_25411D630 = 0;
    qword_25411D628 = 0;
    *((_QWORD *)&xmmword_25411D630 + 1) = re::internal::defaultConstructV2<re::SpatialForceFalloff>;
    qword_25411D640 = (uint64_t)re::internal::defaultDestructV2<re::SpatialForceFalloff>;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_25411D5D0, v3);
    v31 = v29;
    if ((byte_25411D3B1 & 1) == 0)
    {
LABEL_7:
      byte_25411D3B1 = 1;
      v5 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)qword_25411D490, 0);
      unk_25411D4A0 = 0x100000000DLL;
      unk_25411D4A8 = v5;
      unk_25411D4AC = 0;
      unk_25411D4B0 = 0;
      qword_25411D4B8 = 0xFFFFFFFFLL;
      qword_25411D4C0 = (uint64_t)v1;
      unk_25411D4C8 = 0;
      qword_25411D490[0] = (uint64_t)&off_24ED7EB78;
      re::IntrospectionRegistry::add(v6, v7);
      re::getPrettyTypeName((re *)qword_25411D490, (const re::IntrospectionBase *)&v29);
      if ((BYTE8(v29) & 1) != 0)
        v8 = v30;
      else
        v8 = (char *)&v29 + 9;
      if ((_QWORD)v29 && (BYTE8(v29) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v29 + 40))();
      v27 = *((_OWORD *)v1 + 2);
      v9 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v28);
      if (v9)
      {
        v10 = *v9;
        *((_QWORD *)&v26 + 1) = v10;
      }
      else
      {
        v31 = v27;
        re::TypeBuilder::beginOptionalType((uint64_t)&v29, v28, 0x10uLL, 4uLL, &v31);
        re::TypeBuilder::setOptionalAccessors((uint64_t)&v29, (void *(*)(void *))re::TypeBuilderHelper::registerOptional<re::SpatialForceFalloff>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (void (*)(void *, const void *))re::TypeBuilderHelper::registerOptional<re::SpatialForceFalloff>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,void const*)#1}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v29, v11);
      }
      unk_25411D4B0 = v26;
      re::StringID::destroyString((re::StringID *)v28);
    }
  }
}

void re::IntrospectionInfo<re::Optional<re::TimedForceFalloff>>::get()
{
  unsigned __int8 v0;
  uint64_t *v1;
  unsigned __int8 v2;
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  int v5;
  re::IntrospectionRegistry *v6;
  const re::IntrospectionBase *v7;
  const char *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  re *v13;
  uint64_t *v14;
  const re::IntrospectionBase *v15;
  void *v16;
  uint64_t v17;
  uint64_t *v18;
  const re::IntrospectionBase *v19;
  void *v20;
  uint64_t v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24[2];
  __int128 v25;
  const char *v26;
  __int128 v27;

  v0 = atomic_load((unsigned __int8 *)&qword_25411D410);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_25411D410))
  {
    re::IntrospectionOptionalBase::IntrospectionOptionalBase((re::IntrospectionOptionalBase *)&qword_25411D4D0);
    qword_25411D4D0 = (uint64_t)&off_24ED7EBF8;
    __cxa_guard_release(&qword_25411D410);
  }
  if ((byte_25411D3B2 & 1) == 0)
  {
    v1 = (uint64_t *)qword_25411D3D8;
    if (qword_25411D3D8)
      goto LABEL_7;
    v2 = atomic_load((unsigned __int8 *)&qword_25411D3C8);
    if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_25411D3C8))
    {
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_25411D558, 0);
      *(_QWORD *)(v12 + 22) = 0;
      qword_25411D568 = 0;
      *(_QWORD *)&xmmword_25411D578 = 0;
      *((_QWORD *)&xmmword_25411D578 + 1) = 0xFFFFFFFFLL;
      qword_25411D558 = (uint64_t)&off_24ED7DAA8;
      qword_25411D588 = (uint64_t)"TimedForceFalloff";
      dword_25411D590 = 0;
      xmmword_25411D598 = 0u;
      *(_OWORD *)&qword_25411D5A8 = 0u;
      xmmword_25411D5B8 = 0u;
      qword_25411D5C8 = 0;
      __cxa_guard_release(&qword_25411D3C8);
    }
    qword_25411D3D8 = (uint64_t)&qword_25411D558;
    *(_QWORD *)&v27 = 0x49AF4234DC13BEC0;
    *((_QWORD *)&v27 + 1) = "TimedForceFalloff";
    re::StringID::destroyString((re::StringID *)&v27);
    xmmword_25411D578 = v25;
    v4 = atomic_load((unsigned __int8 *)&qword_25411D3D0);
    if ((v4 & 1) == 0)
    {
      v13 = (re *)__cxa_guard_acquire(&qword_25411D3D0);
      if ((_DWORD)v13)
      {
        v14 = re::introspectionAllocator(v13);
        v16 = re::introspect_double((re *)1, v15);
        v17 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v14 + 32))(v14, 72, 8);
        *(_DWORD *)v17 = 1;
        *(_QWORD *)(v17 + 8) = "duration";
        *(_QWORD *)(v17 + 16) = v16;
        *(_QWORD *)(v17 + 24) = 0;
        *(_QWORD *)(v17 + 32) = 1;
        *(_DWORD *)(v17 + 40) = 0;
        *(_QWORD *)(v17 + 48) = 0;
        *(_QWORD *)(v17 + 56) = 0;
        *(_DWORD *)(v17 + 64) = 0;
        qword_25411D418 = v17;
        v18 = re::introspectionAllocator((re *)v17);
        v20 = re::introspect_float((re *)1, v19);
        v21 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v18 + 32))(v18, 72, 8);
        *(_DWORD *)v21 = 1;
        *(_QWORD *)(v21 + 8) = "rate";
        *(_QWORD *)(v21 + 16) = v20;
        *(_QWORD *)(v21 + 24) = 0;
        *(_QWORD *)(v21 + 32) = 0x800000002;
        *(_DWORD *)(v21 + 40) = 0;
        *(_QWORD *)(v21 + 48) = 0;
        *(_QWORD *)(v21 + 56) = 0;
        *(_DWORD *)(v21 + 64) = 0;
        qword_25411D420 = v21;
        __cxa_guard_release(&qword_25411D3D0);
      }
    }
    qword_25411D568 = 0x1000000008;
    v1 = &qword_25411D558;
    dword_25411D570 = 8;
    word_25411D574 = 1;
    dword_25411D590 = 2;
    *(_QWORD *)&xmmword_25411D598 = &qword_25411D418;
    *((_QWORD *)&xmmword_25411D598 + 1) = re::internal::defaultConstruct<re::TimedForceFalloff>;
    *(_QWORD *)&xmmword_25411D5B8 = 0;
    qword_25411D5A8 = (uint64_t)re::internal::defaultDestruct<re::TimedForceFalloff>;
    unk_25411D5B0 = 0;
    *((_QWORD *)&xmmword_25411D5B8 + 1) = re::internal::defaultConstructV2<re::TimedForceFalloff>;
    qword_25411D5C8 = (uint64_t)re::internal::defaultDestructV2<re::TimedForceFalloff>;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_25411D558, v3);
    v27 = v25;
    if ((byte_25411D3B2 & 1) == 0)
    {
LABEL_7:
      byte_25411D3B2 = 1;
      v5 = *((_DWORD *)v1 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_25411D4D0, 0);
      qword_25411D4E0 = 0x180000000DLL;
      dword_25411D4E8 = v5;
      word_25411D4EC = 0;
      *(_QWORD *)&xmmword_25411D4F0 = 0;
      *((_QWORD *)&xmmword_25411D4F0 + 1) = 0xFFFFFFFFLL;
      qword_25411D500 = (uint64_t)v1;
      unk_25411D508 = 0;
      qword_25411D4D0 = (uint64_t)&off_24ED7EBF8;
      re::IntrospectionRegistry::add(v6, v7);
      re::getPrettyTypeName((re *)&qword_25411D4D0, (const re::IntrospectionBase *)&v25);
      if ((BYTE8(v25) & 1) != 0)
        v8 = v26;
      else
        v8 = (char *)&v25 + 9;
      if ((_QWORD)v25 && (BYTE8(v25) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v25 + 40))();
      v23 = *((_OWORD *)v1 + 2);
      v9 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v24);
      if (v9)
      {
        v10 = *v9;
        *((_QWORD *)&v22 + 1) = v10;
      }
      else
      {
        v27 = v23;
        re::TypeBuilder::beginOptionalType((uint64_t)&v25, v24, 0x18uLL, 8uLL, &v27);
        re::TypeBuilder::setOptionalAccessors((uint64_t)&v25, (void *(*)(void *))re::TypeBuilderHelper::registerOptional<re::TimedForceFalloff>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (void (*)(void *, const void *))re::TypeBuilderHelper::registerOptional<re::TimedForceFalloff>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,void const*)#1}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v25, v11);
      }
      xmmword_25411D4F0 = v22;
      re::StringID::destroyString((re::StringID *)v24);
    }
  }
}

void re::internal::defaultConstruct<re::ForceEffectDefinition>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  *(_QWORD *)(a3 + 24) = 0x3F80000000000000;
  *(_QWORD *)(a3 + 32) = -3229614080;
  *(_BYTE *)(a3 + 40) = 0;
  *(_BYTE *)(a3 + 44) = 0;
  *(_BYTE *)(a3 + 64) = 0;
  *(_QWORD *)(a3 + 88) = 0;
  *(_BYTE *)(a3 + 152) = 0;
  *(_BYTE *)(a3 + 168) = 0;
  *(_QWORD *)(a3 + 120) = 0;
  *(_QWORD *)(a3 + 128) = 0;
  *(_BYTE *)(a3 + 136) = 0;
}

uint64_t *re::internal::defaultDestruct<re::ForceEffectDefinition>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return std::unique_ptr<re::RigHierarchy,std::function<void ()(re::RigHierarchy*)>>::~unique_ptr[abi:nn180100]((uint64_t *)(a3 + 88));
}

uint64_t re::internal::defaultConstructV2<re::ForceEffectDefinition>(uint64_t result)
{
  *(_QWORD *)result = 0;
  *(_QWORD *)(result + 8) = 0;
  *(_QWORD *)(result + 16) = 0;
  *(_QWORD *)(result + 24) = 0x3F80000000000000;
  *(_QWORD *)(result + 32) = -3229614080;
  *(_BYTE *)(result + 40) = 0;
  *(_BYTE *)(result + 44) = 0;
  *(_BYTE *)(result + 64) = 0;
  *(_QWORD *)(result + 88) = 0;
  *(_BYTE *)(result + 152) = 0;
  *(_BYTE *)(result + 168) = 0;
  *(_QWORD *)(result + 120) = 0;
  *(_QWORD *)(result + 128) = 0;
  *(_BYTE *)(result + 136) = 0;
  return result;
}

uint64_t *re::internal::defaultDestructV2<re::ForceEffectDefinition>(uint64_t a1)
{
  return std::unique_ptr<re::RigHierarchy,std::function<void ()(re::RigHierarchy*)>>::~unique_ptr[abi:nn180100]((uint64_t *)(a1 + 88));
}

uint64_t re::introspect_ForceEffectDefinition(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"ForceEffectDefinition", (uint64_t (*)(re::internal *))re::allocInfo_ForceEffectDefinition, (re::IntrospectionBase *(*)(void))re::initInfo_ForceEffectDefinition, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::ForceEffectDefinition>, this);
}

uint64_t re::ForceEffectDefinition::advance(uint64_t this, float a2)
{
  double v2;
  double v3;
  double v4;

  if (*(_QWORD *)(this + 128) && *(_BYTE *)(this + 136) && *(_BYTE *)(this + 168))
  {
    v2 = *(double *)(this + 160) + a2;
    if (*(_BYTE *)(this + 64))
    {
      v3 = *(double *)(this + 144);
      v4 = *(double *)(this + 72);
      if (v2 - v3 >= v4)
        v2 = v3 + v4;
    }
    if (!*(_BYTE *)(this + 152))
      *(_BYTE *)(this + 152) = 1;
    *(double *)(this + 160) = v2;
  }
  return this;
}

uint64_t re::ForceEffectFunctionRuntime::elementSize(uint64_t a1, int a2)
{
  uint64_t result;

  result = 0;
  if (a2 > 15)
  {
    if (a2 != 16)
    {
      if (a2 == 64)
        return 48;
      if (a2 != 32)
        return result;
    }
    return 4;
  }
  switch(a2)
  {
    case 1:
    case 2:
    case 4:
    case 8:
      result = 16;
      break;
    default:
      return result;
  }
  return result;
}

void re::ForceEffectFunctionRuntime::reserveInputBuffers(uint64_t a1, unsigned int a2, uint64_t a3)
{
  unsigned int v4;
  uint64_t v5;
  char v6;
  unint64_t v7;
  BOOL v8;

  if (a2)
  {
    v4 = a2;
    v5 = a1;
    v6 = 0;
    do
    {
      if ((v4 & 1) != 0)
      {
        a1 = re::ForceEffectFunctionRuntime::elementSize(a1, 1 << v6);
        v7 = a1 * a3;
        if (v7 > 16 * *(_QWORD *)(v5 + 16))
          re::DynamicArray<re::Vector4<float>>::resize(v5, vcvtpd_u64_f64((double)v7 * 0.0625));
      }
      v5 += 40;
      ++v6;
      v8 = v4 > 1;
      v4 >>= 1;
    }
    while (v8);
  }
}

void re::ForceEffectFunctionRuntime::reserveOutputBuffers(re::ForceEffectFunctionRuntime *this, unint64_t a2)
{
  uint64_t v4;
  size_t v5;
  char v6;
  char v7;
  void **v8;
  uint64_t v9;
  char v10;
  char v11;
  void **v12;

  v4 = 0;
  v5 = 16 * a2;
  v6 = 1;
  do
  {
    v7 = v6;
    if (*((_QWORD *)this + 5 * v4 + 42) < a2)
    {
      v8 = (void **)((char *)this + 40 * v4);
      re::DynamicArray<re::Vector3<float>>::resize((uint64_t)(v8 + 40), a2);
      bzero(v8[44], v5);
    }
    v6 = 0;
    v4 = 1;
  }
  while ((v7 & 1) != 0);
  v9 = 0;
  v10 = 1;
  do
  {
    v11 = v10;
    if (*((_QWORD *)this + 5 * v9 + 52) < a2)
    {
      v12 = (void **)((char *)this + 40 * v9);
      re::DynamicArray<re::Vector3<float>>::resize((uint64_t)(v12 + 50), a2);
      bzero(v12[54], v5);
    }
    v10 = 0;
    v9 = 1;
  }
  while ((v11 & 1) != 0);
}

uint64_t re::CustomForceEffectFunction::compute(uint64_t result, uint64_t a2)
{
  uint64_t v2;

  if (*(_QWORD *)a2)
  {
    v2 = result;
    result = *(_QWORD *)(*(_QWORD *)a2 + 40);
    if (result)
    {
      if (*(_QWORD *)(v2 + 8))
        return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 16))(result);
    }
  }
  return result;
}

void re::CustomForceEffectFunction::~CustomForceEffectFunction(re::CustomForceEffectFunction *this)
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::CustomForceEffectFunction::type(re::CustomForceEffectFunction *this)
{
  return 11;
}

uint64_t re::CustomForceEffectFunction::userData(re::CustomForceEffectFunction *this)
{
  return *((_QWORD *)this + 1);
}

uint64_t re::CustomForceEffectFunction::inputs(re::CustomForceEffectFunction *this)
{
  return *((unsigned int *)this + 4);
}

_QWORD *re::IntrospectionOptional<re::SpatialForceFalloff>::~IntrospectionOptional(_QWORD *a1)
{
  *a1 = &off_24ED2DDF8;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionOptional<re::SpatialForceFalloff>::~IntrospectionOptional(_QWORD *a1)
{
  *a1 = &off_24ED2DDF8;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x2276933B8);
}

void re::IntrospectionOptional<re::SpatialForceFalloff>::construct(uint64_t a1, _BYTE *a2)
{
  *a2 = 0;
}

uint64_t re::IntrospectionOptional<re::SpatialForceFalloff>::hasValue(uint64_t a1, unsigned __int8 *a2)
{
  return *a2;
}

void re::IntrospectionOptional<re::SpatialForceFalloff>::setHasValue(uint64_t a1, uint64_t a2, int a3)
{
  if (a3)
  {
    if (!*(_BYTE *)a2)
      *(_BYTE *)a2 = 1;
    *(_QWORD *)(a2 + 4) = 1065353216;
    *(_DWORD *)(a2 + 12) = 1065353216;
  }
  else if (*(_BYTE *)a2)
  {
    *(_BYTE *)a2 = 0;
  }
}

uint64_t re::IntrospectionOptional<re::SpatialForceFalloff>::value(uint64_t a1, uint64_t a2)
{
  return a2 + 4;
}

{
  return a2 + 4;
}

unsigned __int8 *re::TypeBuilderHelper::registerOptional<re::SpatialForceFalloff>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(unsigned __int8 *a1)
{
  unsigned __int8 *result;
  int v2;

  v2 = *a1;
  result = a1 + 4;
  if (!v2)
    return 0;
  return result;
}

uint64_t re::TypeBuilderHelper::registerOptional<re::SpatialForceFalloff>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,void const*)#1}::__invoke(uint64_t result, uint64_t *a2)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  int v5;

  if (a2)
  {
    v4 = *a2;
    v5 = *((_DWORD *)a2 + 2);
    v2 = (_QWORD *)(result + 4);
    if (*(_BYTE *)result)
    {
      v3 = *a2;
      *(_DWORD *)(result + 12) = *((_DWORD *)a2 + 2);
      *v2 = v3;
    }
    else
    {
      *(_BYTE *)result = 1;
      *v2 = v4;
      *(_DWORD *)(result + 12) = v5;
    }
  }
  else if (*(_BYTE *)result)
  {
    *(_BYTE *)result = 0;
  }
  return result;
}

_QWORD *re::IntrospectionOptional<re::TimedForceFalloff>::~IntrospectionOptional(_QWORD *a1)
{
  *a1 = &off_24ED2DDF8;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionOptional<re::TimedForceFalloff>::~IntrospectionOptional(_QWORD *a1)
{
  *a1 = &off_24ED2DDF8;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 6);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x2276933B8);
}

void re::IntrospectionOptional<re::TimedForceFalloff>::construct(uint64_t a1, _BYTE *a2)
{
  *a2 = 0;
}

uint64_t re::IntrospectionOptional<re::TimedForceFalloff>::hasValue(uint64_t a1, unsigned __int8 *a2)
{
  return *a2;
}

void re::IntrospectionOptional<re::TimedForceFalloff>::setHasValue(uint64_t a1, uint64_t a2, int a3)
{
  if (a3)
  {
    if (!*(_BYTE *)a2)
      *(_BYTE *)a2 = 1;
    *(_QWORD *)(a2 + 8) = 0x3FF0000000000000;
    *(_DWORD *)(a2 + 16) = 1065353216;
  }
  else if (*(_BYTE *)a2)
  {
    *(_BYTE *)a2 = 0;
  }
}

uint64_t re::IntrospectionOptional<re::TimedForceFalloff>::value(uint64_t a1, uint64_t a2)
{
  return a2 + 8;
}

{
  return a2 + 8;
}

unsigned __int8 *re::TypeBuilderHelper::registerOptional<re::TimedForceFalloff>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(unsigned __int8 *a1)
{
  unsigned __int8 *result;
  int v2;

  v2 = *a1;
  result = a1 + 8;
  if (!v2)
    return 0;
  return result;
}

__n128 re::TypeBuilderHelper::registerOptional<re::TimedForceFalloff>(re::TypeRegistry *,re::StringID const&,re::TypeID const&)::{lambda(void *,void const*)#1}::__invoke(uint64_t a1, __n128 *a2)
{
  __n128 result;
  __n128 *v3;
  unint64_t v4;
  __n128 v5;

  if (a2)
  {
    result = *a2;
    v5 = *a2;
    v3 = (__n128 *)(a1 + 8);
    if (*(_BYTE *)a1)
    {
      v4 = a2->n128_u64[0];
      *(_DWORD *)(a1 + 16) = a2->n128_u32[2];
      v3->n128_u64[0] = v4;
    }
    else
    {
      *(_BYTE *)a1 = 1;
      result = v5;
      *v3 = v5;
    }
  }
  else if (*(_BYTE *)a1)
  {
    *(_BYTE *)a1 = 0;
  }
  return result;
}

uint64_t *re::allocInfo_PhysicsSolverIterations(re *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&_MergedGlobals_421);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&_MergedGlobals_421))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_25411D6E0, 0);
    *(uint64_t *)((char *)&qword_25411D6F0 + 6) = 0;
    qword_25411D6F0 = 0;
    qword_25411D700 = 0;
    qword_25411D708 = 0xFFFFFFFFLL;
    qword_25411D6E0 = (uint64_t)&off_24ED7DAA8;
    qword_25411D710 = (uint64_t)"PhysicsSolverIterations";
    dword_25411D718 = 0;
    xmmword_25411D720 = 0u;
    unk_25411D730 = 0u;
    xmmword_25411D740 = 0u;
    qword_25411D750 = 0;
    __cxa_guard_release(&_MergedGlobals_421);
  }
  return &qword_25411D6E0;
}

void re::initInfo_PhysicsSolverIterations(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  const re::IntrospectionBase *v7;
  void *v8;
  uint64_t v9;
  uint64_t *v10;
  const re::IntrospectionBase *v11;
  void *v12;
  uint64_t v13;
  __int128 v14;
  _QWORD v15[2];
  __int128 v16;

  v15[0] = 0xAE83321A565603E0;
  v15[1] = "PhysicsSolverIterations";
  re::StringID::destroyString((re::StringID *)v15);
  *((_OWORD *)this + 2) = v16;
  v4 = atomic_load((unsigned __int8 *)&qword_25411D6C8);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_25411D6C8);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      v8 = re::introspect_uint32_t((re *)1, v7);
      v9 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
      *(_DWORD *)v9 = 1;
      *(_QWORD *)(v9 + 8) = "positionIterations";
      *(_QWORD *)(v9 + 16) = v8;
      *(_QWORD *)(v9 + 24) = 0;
      *(_QWORD *)(v9 + 32) = 1;
      *(_DWORD *)(v9 + 40) = 0;
      *(_QWORD *)(v9 + 48) = 0;
      *(_QWORD *)(v9 + 56) = 0;
      *(_DWORD *)(v9 + 64) = 0;
      qword_25411D6D0 = v9;
      v10 = re::introspectionAllocator((re *)v9);
      v12 = re::introspect_uint32_t((re *)1, v11);
      v13 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v10 + 32))(v10, 72, 8);
      *(_DWORD *)v13 = 1;
      *(_QWORD *)(v13 + 8) = "velocityIterations";
      *(_QWORD *)(v13 + 16) = v12;
      *(_QWORD *)(v13 + 24) = 0;
      *(_QWORD *)(v13 + 32) = 0x400000002;
      *(_DWORD *)(v13 + 40) = 0;
      *(_QWORD *)(v13 + 48) = 0;
      *(_QWORD *)(v13 + 56) = 0;
      *(_DWORD *)(v13 + 64) = 0;
      qword_25411D6D8 = v13;
      __cxa_guard_release(&qword_25411D6C8);
    }
  }
  *((_QWORD *)this + 2) = 0x800000008;
  *((_DWORD *)this + 6) = 4;
  *((_WORD *)this + 14) = 1;
  *((_DWORD *)this + 14) = 2;
  *((_QWORD *)this + 8) = &qword_25411D6D0;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::PhysicsSolverIterations>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::PhysicsSolverIterations>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::PhysicsSolverIterations>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::PhysicsSolverIterations>;
  re::IntrospectionRegistry::add(this, v3);
  v14 = v16;
}

double re::internal::defaultConstruct<re::PhysicsSolverIterations>(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  double result;

  *(_QWORD *)&result = 0x100000006;
  *a3 = 0x100000006;
  return result;
}

double re::internal::defaultConstructV2<re::PhysicsSolverIterations>(_QWORD *a1)
{
  double result;

  *(_QWORD *)&result = 0x100000006;
  *a1 = 0x100000006;
  return result;
}

uint64_t re::introspect_PhysicsSolverIterations(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"PhysicsSolverIterations", (uint64_t (*)(re::internal *))re::allocInfo_PhysicsSolverIterations, (re::IntrospectionBase *(*)(void))re::initInfo_PhysicsSolverIterations, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::PhysicsSolverIterations>, this);
}

void re::RigidBody::setMotionType(uint64_t a1, unsigned int a2)
{
  re *v4;
  uint64_t v5;
  float v6;
  NSObject *v8;
  const char *v9;
  const char *v10;
  uint64_t v11;
  re::CollisionObject *v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  const char *v16;
  __int16 v17;
  const char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  v4 = (re *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 64) + 56))(*(_QWORD *)(a1 + 64));
  if ((_DWORD)v4)
    v5 = 0;
  else
    v5 = a2;
  if ((_DWORD)v5 == 2)
  {
    v6 = fabsf(*(float *)(a1 + 192));
    if (v6 < 0.00001 || v6 == INFINITY)
      v5 = 1;
    else
      v5 = 2;
  }
  if ((_DWORD)v5 != a2)
  {
    v8 = *re::physicsLogObjects(v4);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = "static";
      if (a2 == 1)
        v10 = "kinematic";
      else
        v10 = "static";
      if (a2 == 2)
        v10 = "dynamic";
      if ((_DWORD)v5 == 1)
        v9 = "kinematic";
      if ((_DWORD)v5 == 2)
        v9 = "dynamic";
      v15 = 136315394;
      v16 = v10;
      v17 = 2080;
      v18 = v9;
      _os_log_impl(&dword_224FE9000, v8, OS_LOG_TYPE_DEFAULT, "Physics body motion type \"%s\" was requested but is not supported for all of its colliders.  Dynamic motion is not supported for some colliders, such as ARKit mesh colliders.  Motion type \"%s\" will be used instead.", (uint8_t *)&v15, 0x16u);
    }
  }
  if (*(_DWORD *)(a1 + 208) != (_DWORD)v5)
  {
    v11 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 56);
    if (v11 && (*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 424))(a1))
    {
      v12 = *(re::CollisionObject **)(a1 + 72);
      re::ContactSetCollection::remove(*(_QWORD *)(v11 + 128) + 72, v12);
      (*(void (**)(_QWORD, re::CollisionObject *))(**(_QWORD **)(v11 + 128) + 200))(*(_QWORD *)(v11 + 128), v12);
      *((_QWORD *)v12 + 7) = 0;
    }
    *(_DWORD *)(a1 + 208) = v5;
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 104))(a1, v5);
    v13 = *(_QWORD *)(a1 + 72);
    if (*(_QWORD *)(v13 + 56) != v11)
    {
      v14 = *(_QWORD *)(v11 + 128);
      *(_QWORD *)(v13 + 56) = v14;
      (*(void (**)(uint64_t))(*(_QWORD *)v14 + 192))(v14);
      if ((_DWORD)v5 == 2)
        (*(void (**)(uint64_t))(*(_QWORD *)a1 + 312))(a1);
    }
    *(_QWORD *)(a1 + 224) = 0;
    *(_QWORD *)(a1 + 232) = 0;
  }
}

float32x4_t re::RigidBody::pose@<Q0>(float32x4_t *this@<X0>, float32x4_t *a2@<X8>)
{
  float32x4_t v4;
  int32x4_t v6;
  int32x4_t v7;
  float32x4_t v8;
  float32x4_t v9;
  int32x4_t v10;
  float32x4_t v11;
  int32x4_t v12;
  float32x4_t v13;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  int32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v22;
  int32x4_t v23;
  float32x4_t v24;
  float32x4_t result;
  float32x4_t v30;
  int8x16_t v31;

  (*(void (**)(float32x4_t *__return_ptr))(this->i64[0] + 208))(&v30);
  v4 = this[9];
  _Q1 = this[10];
  v6 = (int32x4_t)vnegq_f32(_Q1);
  v7 = (int32x4_t)vnegq_f32(v4);
  v8 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v6, v6), (int8x16_t)v6, 0xCuLL);
  v9 = vmlsq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v7, v7), (int8x16_t)v7, 0xCuLL), _Q1), v8, v4);
  v10 = (int32x4_t)vaddq_f32(v9, v9);
  v11 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v10, v10), (int8x16_t)v10, 0xCuLL);
  v12 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v11, (int32x4_t)v11), (int8x16_t)v11, 0xCuLL), _Q1), v11, v8);
  v13 = vaddq_f32(vsubq_f32(vmulq_laneq_f32(v11, _Q1, 3), v4), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v12, v12), (int8x16_t)v12, 0xCuLL));
  _Q3 = (int32x4_t)v31;
  v15 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(_Q3, _Q3), v31, 0xCuLL);
  v16 = vnegq_f32((float32x4_t)v31);
  v17 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v13, (int32x4_t)v13), (int8x16_t)v13, 0xCuLL), v16), v13, v15);
  v18 = (int32x4_t)vaddq_f32(v17, v17);
  v19 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v18, v18), (int8x16_t)v18, 0xCuLL);
  v20 = vaddq_f32(v13, vmulq_laneq_f32(v19, (float32x4_t)v31, 3));
  _Q17 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v19, (int32x4_t)v19), (int8x16_t)v19, 0xCuLL), v16), v19, v15);
  v22 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(_Q17, _Q17), (int8x16_t)_Q17, 0xCuLL);
  _Q17.i32[0] = _Q1.i32[3];
  v23 = (int32x4_t)vmlsq_f32(vmulq_f32(v8, v16), v15, _Q1);
  v24 = vmlaq_laneq_f32(vmlsq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v23, v23), (int8x16_t)v23, 0xCuLL), _Q1, (float32x4_t)v31, 3), (float32x4_t)v31, _Q1, 3);
  __asm { FMLA            S1, S17, V3.S[3] }
  v24.i32[3] = _Q1.i32[0];
  result = vaddq_f32(v30, vaddq_f32(v20, v22));
  *a2 = result;
  a2[1] = v24;
  return result;
}

double re::RigidBody::calculateVelocityAtLocalPoint(uint64_t a1, int32x4_t *a2)
{
  float32x4_t v4;
  float32x4_t v5;
  float32x4_t v6;
  int32x4_t v7;
  float32x4_t v8;
  int32x4_t v9;
  float32x4_t v10;
  uint64_t v11;
  float32x4_t v12;
  uint64_t v13;
  float32x4_t v14;
  int32x4_t v15;
  double result;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  int32x4_t v21;
  float32x4_t v22[2];

  (*(void (**)(float32x4_t *__return_ptr))(*(_QWORD *)a1 + 40))(&v20);
  v4 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v21, v21), (int8x16_t)v21, 0xCuLL);
  v5 = vnegq_f32((float32x4_t)v21);
  v6 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(*a2, *a2), *(int8x16_t *)a2, 0xCuLL), v5), *(float32x4_t *)a2, v4);
  v7 = (int32x4_t)vaddq_f32(v6, v6);
  v8 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v7, v7), (int8x16_t)v7, 0xCuLL);
  v9 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v8, (int32x4_t)v8), (int8x16_t)v8, 0xCuLL), v5), v8, v4);
  v18 = vaddq_f32(v20, vaddq_f32(vaddq_f32(*(float32x4_t *)a2, vmulq_laneq_f32(v8, (float32x4_t)v21, 3)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v9, v9), (int8x16_t)v9, 0xCuLL)));
  v10.i64[0] = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 216))(a1);
  v10.i64[1] = v11;
  v19 = v10;
  v12.i64[0] = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 232))(a1);
  v12.i64[1] = v13;
  v17 = v12;
  (*(void (**)(float32x4_t *__return_ptr, uint64_t))(*(_QWORD *)a1 + 208))(v22, a1);
  v14 = vsubq_f32(v18, v22[0]);
  v15 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v14, (int32x4_t)v14), (int8x16_t)v14, 0xCuLL), vnegq_f32(v17)), v14, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v17, (int32x4_t)v17), (int8x16_t)v17, 0xCuLL));
  *(_QWORD *)&result = vaddq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v15, v15), (int8x16_t)v15, 0xCuLL), v19).u64[0];
  return result;
}

uint64_t re::RigidBody::setCollisionObject(re::RigidBody *this, re::CollisionObject *a2)
{
  *((_QWORD *)this + 9) = a2;
  return (*(uint64_t (**)(re::RigidBody *))(*(_QWORD *)this + 432))(this);
}

void re::RigidBody::setAttachedJointCount(re::RigidBody *this, int a2)
{
  int v4;
  NSObject *v5;
  _BOOL4 v6;
  _DWORD v7[2];
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  if (a2 < 0)
  {
    v5 = *re::physicsLogObjects(this);
    v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
    v4 = 0;
    if (v6)
    {
      v7[0] = 67109120;
      v7[1] = a2;
      _os_log_impl(&dword_224FE9000, v5, OS_LOG_TYPE_DEFAULT, "RigidBody::setAttachedJointCount(cnt=%d): Negative reference count attempted to be set", (uint8_t *)v7, 8u);
      v4 = 0;
    }
  }
  else
  {
    v4 = a2;
  }
  *((_DWORD *)this + 77) = v4;
}

void re::RigidBody::poseDidChange(re::RigidBody *this, uint64_t a2)
{
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Not supported.", "!\"Unreachable code\"", "poseDidChange", 236);
  _os_crash();
  __break(1u);
}

uint64_t re::RigidBody::setSolverIterations(uint64_t result, _QWORD *a2)
{
  *(_QWORD *)(result + 212) = *a2;
  return result;
}

uint64_t re::Damping::didEnable(uint64_t this)
{
  uint64_t v1;

  v1 = *(_QWORD *)(this + 8);
  if (v1)
    return updateRigidBodies(v1 + 80, *(float *)(this + 20), *(float *)(this + 24));
  return this;
}

uint64_t updateRigidBodies(uint64_t result, float a2, float a3)
{
  uint64_t v3;
  uint64_t v6;
  unint64_t i;
  uint64_t v8;
  float v9;
  double v10;

  v3 = *(_QWORD *)(result + 24);
  if (v3)
  {
    v6 = result;
    for (i = 0; i != v3; ++i)
    {
      v8 = re::ecs2::ComponentTypeRegistry::operator[](v6, i);
      v9 = (*(float (**)(uint64_t))(*(_QWORD *)v8 + 320))(v8) + a2;
      v10 = (*(double (**)(uint64_t))(*(_QWORD *)v8 + 328))(v8);
      result = (*(uint64_t (**)(uint64_t, float, float))(*(_QWORD *)v8 + 336))(v8, v9, *(float *)&v10 + a3);
    }
  }
  return result;
}

uint64_t re::Damping::didDisable(uint64_t this)
{
  uint64_t v1;

  v1 = *(_QWORD *)(this + 8);
  if (v1)
    return updateRigidBodies(v1 + 80, -*(float *)(this + 20), -*(float *)(this + 24));
  return this;
}

uint64_t re::Damping::didAddToSimulation(uint64_t this)
{
  if (*(_BYTE *)(this + 16))
    return updateRigidBodies(*(_QWORD *)(this + 8) + 80, *(float *)(this + 20), *(float *)(this + 24));
  return this;
}

uint64_t re::Damping::willRemoveFromSimulation(uint64_t this)
{
  if (*(_BYTE *)(this + 16))
    return updateRigidBodies(*(_QWORD *)(this + 8) + 80, -*(float *)(this + 20), -*(float *)(this + 24));
  return this;
}

uint64_t re::Damping::onRigidBodyAdded(uint64_t this, re::RigidBody *a2)
{
  uint64_t v3;
  float v4;
  double v5;

  if (*(_BYTE *)(this + 16))
  {
    v3 = this;
    v4 = (*(float (**)(re::RigidBody *))(*(_QWORD *)a2 + 320))(a2) + *(float *)(this + 20);
    v5 = (*(double (**)(re::RigidBody *))(*(_QWORD *)a2 + 328))(a2);
    return (*(uint64_t (**)(re::RigidBody *, float, float))(*(_QWORD *)a2 + 336))(a2, v4, *(float *)&v5 + *(float *)(v3 + 24));
  }
  return this;
}

uint64_t re::Damping::onRigidBodyRemoved(uint64_t this, re::RigidBody *a2)
{
  uint64_t v3;
  float v4;
  double v5;

  if (*(_BYTE *)(this + 16))
  {
    v3 = this;
    v4 = (*(float (**)(re::RigidBody *))(*(_QWORD *)a2 + 320))(a2) - *(float *)(this + 20);
    v5 = (*(double (**)(re::RigidBody *))(*(_QWORD *)a2 + 328))(a2);
    return (*(uint64_t (**)(re::RigidBody *, float, float))(*(_QWORD *)a2 + 336))(a2, v4, *(float *)&v5 - *(float *)(v3 + 24));
  }
  return this;
}

uint64_t re::Damping::setLinearDamping(uint64_t this, float a2)
{
  float v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *(float *)(this + 20);
  *(float *)(this + 20) = a2;
  if (*(_BYTE *)(this + 16))
  {
    v3 = this;
    v4 = *(_QWORD *)(this + 8);
    if (v4)
    {
      updateRigidBodies(v4 + 80, -v2, 0.0);
      return updateRigidBodies(*(_QWORD *)(v3 + 8) + 80, *(float *)(v3 + 20), 0.0);
    }
  }
  return this;
}

uint64_t re::Damping::setAngularDamping(uint64_t this, float a2)
{
  float v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *(float *)(this + 24);
  *(float *)(this + 24) = a2;
  if (*(_BYTE *)(this + 16))
  {
    v3 = this;
    v4 = *(_QWORD *)(this + 8);
    if (v4)
    {
      updateRigidBodies(v4 + 80, 0.0, -v2);
      return updateRigidBodies(*(_QWORD *)(v3 + 8) + 80, 0.0, *(float *)(v3 + 24));
    }
  }
  return this;
}

void re::Damping::~Damping(re::Damping *this)
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::Damping::type(re::Damping *this)
{
  return 2;
}

uint64_t re::BallSocketJoint::type(re::BallSocketJoint *this)
{
  return 2;
}

uint64_t re::PhysXConstraintKernel::setCollisionEnabled(re::PhysXConstraintKernel *this, uint64_t a2)
{
  return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**((_QWORD **)this + 1) + 128))(*((_QWORD *)this + 1), 8, a2);
}

void re::PhysXConstraintKernel::~PhysXConstraintKernel(re::PhysXConstraintKernel *this)
{
  void (***v1)(_QWORD);

  v1 = (void (***)(_QWORD))*((_QWORD *)this + 1);
  if (v1)
    (**v1)(v1);
}

{
  void (***v1)(_QWORD);

  v1 = (void (***)(_QWORD))*((_QWORD *)this + 1);
  if (v1)
    (**v1)(v1);
  JUMPOUT(0x2276933B8);
}

uint64_t re::PhysXConstraintKernel::bodyA(re::PhysXConstraintKernel *this)
{
  uint64_t v2;
  uint64_t v3;

  v2 = 0;
  v3 = 0;
  (*(void (**)(_QWORD, uint64_t *, uint64_t *))(**((_QWORD **)this + 1) + 56))(*((_QWORD *)this + 1), &v3, &v2);
  if (v3)
    return *(_QWORD *)(*(_QWORD *)(v3 + 16) + 16);
  else
    return 0;
}

uint64_t re::PhysXConstraintKernel::bodyB(re::PhysXConstraintKernel *this)
{
  uint64_t v2;
  uint64_t v3;

  v2 = 0;
  v3 = 0;
  (*(void (**)(_QWORD, uint64_t *, uint64_t *))(**((_QWORD **)this + 1) + 56))(*((_QWORD *)this + 1), &v3, &v2);
  if (v2)
    return *(_QWORD *)(*(_QWORD *)(v2 + 16) + 16);
  else
    return 0;
}

_QWORD *re::PhysXConstraintKernel::localAnchorPoseA@<X0>(re::PhysXConstraintKernel *this@<X0>, _QWORD *a2@<X8>)
{
  _QWORD v4[3];

  (*(void (**)(_QWORD *__return_ptr, _QWORD, _QWORD))(**((_QWORD **)this + 1) + 72))(v4, *((_QWORD *)this + 1), 0);
  return re::internal::nvphysx::fromPhysX((uint64_t)v4, a2);
}

_QWORD *re::PhysXConstraintKernel::localAnchorPoseB@<X0>(re::PhysXConstraintKernel *this@<X0>, _QWORD *a2@<X8>)
{
  _QWORD v4[3];

  (*(void (**)(_QWORD *__return_ptr, _QWORD, uint64_t))(**((_QWORD **)this + 1) + 72))(v4, *((_QWORD *)this + 1), 1);
  return re::internal::nvphysx::fromPhysX((uint64_t)v4, a2);
}

uint64_t re::PhysXConstraintKernel::collisionEnabled(re::PhysXConstraintKernel *this)
{
  uint64_t var2;

  (*(void (**)(uint64_t *__return_ptr))(**((_QWORD **)this + 1) + 136))(&var2);
  return ((unsigned __int16)var2 >> 3) & 1;
}

float re::internal::WGL_noise(unsigned int a1, __n128 a2)
{
  float v3;
  float v4;
  float v5;
  int32x2_t v6;
  float v7;
  float v8;
  int32x2_t v9;
  int32x2_t v10;
  int32x2_t v11;
  float32x2_t v12;
  float v19;
  int v20;
  float v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int8x8_t v26;
  int32x2_t v27;
  int32x2_t v28;
  int32x2_t v29;
  int32x2_t v30;
  int32x2_t v31;
  int32x2_t v32;
  int32x2_t v33;
  int32x2_t v34;
  int32x2_t v35;
  int32x2_t v36;
  int32x2_t v37;
  int32x2_t v38;
  int32x2_t v39;
  float32x2_t v40;
  float32x2_t v41;
  float32x2_t v42;
  float32x2_t v43;

  v3 = fmodf(fabsf(a2.n128_f32[0]), 1.0) * 512.0;
  v4 = fmodf(fabsf(a2.n128_f32[1]), 1.0) * 512.0;
  v5 = fmodf(fabsf(a2.n128_f32[2]), 1.0) * 512.0;
  v6 = vdup_n_s32(a1);
  v7 = 0.0;
  v8 = 64.0;
  v9 = vdup_n_s32(0x3D73u);
  v10 = vdup_n_s32(0xC0AE5u);
  v11 = vdup_n_s32(0x5208DD0Du);
  v12 = (float32x2_t)vdup_n_s32(0x30800000u);
  __asm
  {
    FMOV            V17.2D, #1.0
    FMOV            V18.2D, #0.5
  }
  v19 = 0.0;
  do
  {
    v20 = (int)(float)(v3 / v8);
    v21 = (float)(v3 / v8) - (float)v20;
    v22 = v20 & 0x1FF;
    v23 = ((_WORD)v20 - 1) & 0x1FF;
    v24 = 57 * ((int)(float)(v4 / v8) & 0x1FF);
    v25 = 57 * (((unsigned __int16)(int)(float)(v4 / v8) - 1) & 0x1FF);
    v26.i32[0] = (int)(float)(v5 / v8);
    v26.i32[1] = v26.i32[0] - 1;
    v27 = vmul_s32((int32x2_t)vand_s8(v26, (int8x8_t)0x100000001), v6);
    v28 = vadd_s32(vdup_n_s32(v24 + v23), v27);
    v29 = (int32x2_t)veor_s8((int8x8_t)vshl_n_s32(v28, 0xDuLL), (int8x8_t)v28);
    v30 = vmla_s32(v11, vmla_s32(v10, vmul_s32(v29, v29), v9), v29);
    v31 = vadd_s32(vdup_n_s32(v24 + v22), v27);
    v32 = (int32x2_t)veor_s8((int8x8_t)vshl_n_s32(v31, 0xDuLL), (int8x8_t)v31);
    v33 = vmla_s32(v11, vmla_s32(v10, vmul_s32(v32, v32), v9), v32);
    v34 = vadd_s32(vdup_n_s32(v25 + v23), v27);
    v35 = (int32x2_t)veor_s8((int8x8_t)vshl_n_s32(v34, 0xDuLL), (int8x8_t)v34);
    v36 = vmla_s32(v11, vmla_s32(v10, vmul_s32(v35, v35), v9), v35);
    v37 = vadd_s32(vdup_n_s32(v25 + v22), v27);
    v38 = (int32x2_t)veor_s8((int8x8_t)vshl_n_s32(v37, 0xDuLL), (int8x8_t)v37);
    v39 = vmla_s32(v11, vmla_s32(v10, vmul_s32(v38, v38), v9), v38);
    v40 = vcvt_f32_f64(vmulq_f64(vaddq_f64(vsubq_f64(_Q17, vcvtq_f64_f32(vmul_f32(vcvt_f32_s32((int32x2_t)(*(_QWORD *)&v30 & 0x7FFFFFFF7FFFFFFFLL)), v12))), _Q17), _Q18));
    v41 = vcvt_f32_f64(vmulq_f64(vaddq_f64(vsubq_f64(_Q17, vcvtq_f64_f32(vmul_f32(vcvt_f32_s32((int32x2_t)(*(_QWORD *)&v36 & 0x7FFFFFFF7FFFFFFFLL)), v12))), _Q17), _Q18));
    v42 = vmla_n_f32(v41, vsub_f32(vcvt_f32_f64(vmulq_f64(vaddq_f64(vsubq_f64(_Q17, vcvtq_f64_f32(vmul_f32(vcvt_f32_s32((int32x2_t)(*(_QWORD *)&v39 & 0x7FFFFFFF7FFFFFFFLL)), v12))), _Q17), _Q18)), v41), v21);
    v43 = vmla_n_f32(v42, vsub_f32(vmla_n_f32(v40, vsub_f32(vcvt_f32_f64(vmulq_f64(vaddq_f64(vsubq_f64(_Q17, vcvtq_f64_f32(vmul_f32(vcvt_f32_s32((int32x2_t)(*(_QWORD *)&v33 & 0x7FFFFFFF7FFFFFFFLL)), v12))), _Q17), _Q18)), v40), v21), v42), (float)(v4 / v8) - (float)(int)(float)(v4 / v8));
    v19 = v19
        + (float)((float)(v43.f32[1]
                        + (float)((float)((float)(v5 / v8) - (float)(int)(float)(v5 / v8))
                                * (float)(v43.f32[0] - v43.f32[1])))
                * v8);
    v7 = v7 + v8;
    v8 = v8 * 0.5;
  }
  while (v8 >= 1.0);
  return v19 / v7;
}

double WGLForceComputeLinearForce(float32x4_t *a1, uint64_t a2, float32x4_t a3)
{
  double v3;
  float32x4_t v5;
  float32x4_t v6;
  int v7;
  float v8;
  float v9;
  float32x4_t v10;
  float32x4_t v11;
  uint64_t v12;
  float v13;
  float32x4_t v18;
  float v20;
  float v22;
  float32x4_t v23;
  float32x4_t v24;
  __n128 v25;

  v3 = 0.0;
  if (!a1[5].i8[6])
  {
    v5 = *a1;
    v6 = vsubq_f32(*a1, a3);
    v7 = a1[5].i32[0];
    if (v7 || a1[5].i8[4])
    {
      v5 = vmulq_f32(v6, v6);
      v5.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v5, 2), vaddq_f32(v5, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 1))).u64[0];
      v8 = sqrtf(v5.f32[0]);
    }
    else
    {
      v8 = 0.0;
    }
    v9 = a1[4].f32[0];
    switch(a1[4].i32[3])
    {
      case 0:
        a3.f32[0] = v8;
        goto LABEL_10;
      case 1:
        v10 = a1[1];
        goto LABEL_15;
      case 2:
        a3 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)a1[1], (int32x4_t)a1[1]), (int8x16_t)a1[1], 0xCuLL), vnegq_f32(v6)), a1[1], (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v6, (int32x4_t)v6), (int8x16_t)v6, 0xCuLL));
        v5 = (float32x4_t)vuzp1q_s32((int32x4_t)a3, (int32x4_t)a3);
        v24 = (float32x4_t)vextq_s8((int8x16_t)v5, (int8x16_t)a3, 0xCuLL);
        if (!a1[5].i8[4])
          goto LABEL_18;
        v11 = vmulq_f32(a3, a3);
        v5 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2), v11);
        a3 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 1);
        goto LABEL_17;
      case 3:
        v25 = (__n128)vmlaq_f32(a1[2], a1[1], a3);
        *(float *)&v12 = re::internal::WGL_noise(0x106u, v25);
        v23.i64[0] = v12;
        v22 = re::internal::WGL_noise(0x410u, v25);
        v13 = re::internal::WGL_noise(0x26u, v25);
        v5 = v23;
        v5.f32[1] = v22;
        v5.f32[2] = v13;
        a3.i64[0] = 0x4000000040000000;
        a3.i64[1] = 0x4000000040000000;
        __asm { FMOV            V2.4S, #-1.0 }
        v10 = vmlaq_f32(_Q2, a3, v5);
LABEL_15:
        v24 = v10;
        if (!a1[5].i8[4])
          goto LABEL_18;
        v18 = vmulq_f32(v10, v10);
        v5 = vaddq_f32(v18, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v18.f32, 1));
        a3 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v18, 2);
LABEL_17:
        a3.i64[0] = vaddq_f32(a3, v5).u64[0];
        a3.f32[0] = sqrtf(a3.f32[0]);
        break;
      case 4:
      case 5:
        a3.i8[4] = 0;
        a3.i8[5] = 0;
        a3.i8[6] = 0;
        a3.i8[7] = 0;
        v24 = 0u;
LABEL_18:
        a3.i32[0] = 1.0;
        break;
      default:
        a3.i32[0] = 1.0;
LABEL_10:
        v24 = v6;
        break;
    }
    if (a3.f32[0] == 0.0 || a1[5].i8[4] == 0)
      v5.f32[0] = 1.0;
    else
      v5.f32[0] = a3.f32[0];
    a3.i32[0] = a1[4].i32[1];
    v20 = v9 / v5.f32[0];
    v5.f32[0] = v8;
    *(_QWORD *)&v3 = vmulq_f32(a1[3], vmulq_n_f32(v24, WGLComputeFalloff(v7, a2, *(double *)a3.i64, *(double *)v5.i64) * v20)).u64[0];
  }
  return v3;
}

re::PhysXBallSocketJoint *re::PhysXBallSocketJoint::PhysXBallSocketJoint(re::PhysXBallSocketJoint *this, physx::PxSphericalJoint *a2, uint64_t a3)
{
  *(_QWORD *)this = &off_24ED7EF48;
  ArcSharedObject::ArcSharedObject(this, 0);
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 8) = &off_24ED7EED0;
  *((_QWORD *)this + 4) = &str_110;
  *((_QWORD *)this + 5) = (char *)this + 64;
  *((_QWORD *)this + 6) = 0;
  *((int32x2_t *)this + 7) = vdup_n_s32(0x3FC90FDBu);
  *(_QWORD *)this = &off_24ED7EF48;
  *((_QWORD *)this + 9) = a2;
  *((_QWORD *)a2 + 2) = this;
  (*(void (**)(physx::PxSphericalJoint *, uint64_t, uint64_t))(*(_QWORD *)a2 + 128))(a2, 16, 1);
  (*(void (**)(_QWORD, uint64_t, uint64_t))(**((_QWORD **)this + 9) + 128))(*((_QWORD *)this + 9), 8, a3);
  return this;
}

uint64_t re::PhysXBallSocketJoint::updateLimits(re::PhysXBallSocketJoint *this)
{
  uint64_t v2;
  _BOOL8 v3;
  uint64_t result;
  float v5;
  float v6;
  float v7;
  _QWORD v8[2];
  float v9;
  int v10;
  float v11;

  v2 = *((_QWORD *)this + 9);
  v3 = *((float *)this + 14) >= 0.0 && *((float *)this + 15) >= 0.0;
  result = (*(uint64_t (**)(_QWORD, uint64_t, _BOOL8))(*(_QWORD *)v2 + 280))(*((_QWORD *)this + 9), 2, v3);
  v5 = *((float *)this + 14);
  if (v5 >= 0.0)
  {
    v6 = *((float *)this + 15);
    if (v6 >= 0.0)
    {
      v10 = *((_DWORD *)this + 14);
      v11 = v6;
      if (v5 < v6)
        v6 = v5;
      v7 = v6 * 0.49;
      if (v7 > 0.1)
        v7 = 0.1;
      v8[0] = 0x3F00000000000000;
      v8[1] = 0;
      v9 = v7;
      return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v2 + 248))(v2, v8);
    }
  }
  return result;
}

void re::PhysXBallSocketJoint::~PhysXBallSocketJoint(re::PhysXBallSocketJoint *this)
{
  void (***v2)(_QWORD);

  *(_QWORD *)this = &off_24ED7EF48;
  v2 = (void (***)(_QWORD))*((_QWORD *)this + 9);
  if (v2)
    (**v2)(v2);
  *(_QWORD *)this = &off_24ED7E818;
  re::StringID::destroyString((re::PhysXBallSocketJoint *)((char *)this + 24));
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  void (***v2)(_QWORD);

  *(_QWORD *)this = &off_24ED7EF48;
  v2 = (void (***)(_QWORD))*((_QWORD *)this + 9);
  if (v2)
    (**v2)(v2);
  *(_QWORD *)this = &off_24ED7E818;
  re::StringID::destroyString((re::PhysXBallSocketJoint *)((char *)this + 24));
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

re::PhysXTwistSwingJoint *re::PhysXTwistSwingJoint::PhysXTwistSwingJoint(re::PhysXTwistSwingJoint *this, physx::PxD6Joint *a2, uint64_t a3)
{
  double v6;
  _QWORD *v7;

  *(_QWORD *)this = &off_24ED7EFB0;
  v6 = re::TwistSwingJoint::TwistSwingJoint(this, (uint64_t)this + 80);
  *v7 = &off_24ED7EFB0;
  v7[10] = &off_24ED7EED0;
  v7[11] = a2;
  *((_QWORD *)a2 + 2) = v7;
  (*(void (**)(physx::PxD6Joint *, uint64_t, uint64_t, double))(*(_QWORD *)a2 + 128))(a2, 16, 1, v6);
  (*(void (**)(_QWORD, uint64_t, uint64_t))(**((_QWORD **)this + 11) + 128))(*((_QWORD *)this + 11), 8, a3);
  *((_QWORD *)this + 12) = 0xBF8000003F800000;
  *((_QWORD *)this + 13) = 0xBF8000003F800000;
  *((_QWORD *)this + 14) = 0xBF8000003F800000;
  return this;
}

uint64_t re::PhysXTwistSwingJoint::updateLimits(re::PhysXTwistSwingJoint *this, uint64_t a2, uint64_t a3, float *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _BYTE v10[4];
  int v11;
  uint64_t v12;

  v4 = *((_QWORD *)this + 11);
  v10[0] = 0;
  v12 = 0;
  v11 = 0;
  v5 = *((_QWORD *)this + 7);
  v8 = *((_QWORD *)this + 8);
  v9 = v5;
  v7 = *((_QWORD *)this + 9);
  re::setPxD6JointTwistLimit(v4, (re *)&v9, (uint64_t)v10, a4, 0.0);
  return re::setPxD6JointSwingLimit(v4, (re *)&v8, (uint64_t)v10, (float *)&v7, (uint64_t)v10, 0.0, 0.0);
}

void re::PhysXTwistSwingJoint::~PhysXTwistSwingJoint(re::PhysXTwistSwingJoint *this)
{
  void (***v2)(_QWORD);

  v2 = (void (***)(_QWORD))*((_QWORD *)this + 11);
  if (v2)
    (**v2)(v2);
  *(_QWORD *)this = &off_24ED7E818;
  re::StringID::destroyString((re::PhysXTwistSwingJoint *)((char *)this + 24));
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  void (***v2)(_QWORD);

  v2 = (void (***)(_QWORD))*((_QWORD *)this + 11);
  if (v2)
    (**v2)(v2);
  *(_QWORD *)this = &off_24ED7E818;
  re::StringID::destroyString((re::PhysXTwistSwingJoint *)((char *)this + 24));
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

uint64_t re::TwistSwingJoint::type(re::TwistSwingJoint *this)
{
  return 7;
}

void re::RadialRepulsionForce::onApply(re::RadialRepulsionForce *this)
{
  float v1;
  float v3;
  _QWORD **v4;
  uint64_t v5;
  uint64_t *v6;
  re *v7;
  uint64_t v8;
  uint64_t v9;
  re *v10;
  uint64_t *v11;
  void (***v12)(_QWORD);
  _anonymous_namespace_ *v13;
  _anonymous_namespace_ *v14;
  _anonymous_namespace_ *i;
  _anonymous_namespace_ *v16;
  float32x4_t *v17;
  uint64_t v18;
  float *v19;
  uint64_t v20;
  float32x4_t v21;
  float v22;
  float32x4_t v23;
  float32x4_t *v24;
  _OWORD *v25;
  float32x4_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  float32x4_t v30;
  float v31;
  __int128 v32;
  float32x4_t v33;
  int32x4_t v34;
  float32x2_t v35;
  float32x2_t v36;
  _OWORD *v37;
  float32x4_t v38;
  float v39;
  __int128 v40;
  float32x4_t v41;
  int32x4_t v42;
  float32x2_t v43;
  float32x2_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float v52;
  float32x4_t v53;
  float32x4_t v54;
  float v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  int32x4_t v63;
  float32x2_t v64;
  float32x2_t v65;
  uint64_t v66;
  float v67;
  float v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float v72;
  float32x4_t v73;
  float32x4_t v74;
  __int128 v75;
  float32x4_t v76;
  __int128 v77;
  __int128 v78;
  _OWORD v79[2];
  _QWORD v80[2];
  __int128 v81;
  __int128 v82;
  int v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;

  v86 = *MEMORY[0x24BDAC8D0];
  v1 = fmaxf(fmaxf(*((float *)this + 12), *((float *)this + 14)), *((float *)this + 13));
  if (v1 > 0.0)
  {
    v3 = fmaxf(fmaxf(*((float *)this + 8), *((float *)this + 10)), *((float *)this + 9));
    v4 = *(_QWORD ***)(*(_QWORD *)(*((_QWORD *)this + 3) + 72) + 56);
    v6 = re::globalAllocators(this);
    v7 = (re *)(*(uint64_t (**)(uint64_t, uint64_t, float))(*(_QWORD *)v5 + 112))(v5, v6[2], v1 + v3);
    v9 = re::globalAllocators(v7)[2];
    v10 = (re *)(*(_QWORD *(**)(__int128 *__return_ptr))(**((_QWORD **)this + 3) + 40))(&v78);
    v11 = re::globalAllocators(v10);
    v12 = (void (***)(_QWORD))(*(uint64_t (**)(uint64_t, uint64_t, re *, __int128 *, _QWORD, uint64_t))(*(_QWORD *)v8 + 168))(v8, v9, v7, &v78, 0, v11[2]);
    v13 = (_anonymous_namespace_ *)(*(uint64_t (**)(_QWORD *))(*v4[16] + 176))(v4[16]);
    if (v13)
    {
      v14 = v13;
      for (i = 0; i != v14; i = (_anonymous_namespace_ *)((char *)i + 1))
      {
        v13 = (_anonymous_namespace_ *)(*(uint64_t (**)(_QWORD *, _anonymous_namespace_ *))(*v4[16] + 184))(v4[16], i);
        if (v13 != *(_anonymous_namespace_ **)(*((_QWORD *)this + 3) + 72))
        {
          v16 = v13;
          v13 = (_anonymous_namespace_ *)(*(uint64_t (**)(_QWORD *))(**((_QWORD **)v13 + 2) + 56))(*((_QWORD **)v13 + 2));
          if ((_DWORD)v13 == 2)
          {
            v83 = 0;
            v81 = 0u;
            v82 = 0u;
            v78 = 0u;
            memset(v79, 0, 28);
            v80[0] = 0;
            *(_DWORD *)((char *)v80 + 7) = 0;
            v84 = 0;
            v85 = 0;
            v78 = 0uLL;
            re::DynamicArray<re::Contact>::setCapacity(v79, 0);
            ++DWORD2(v79[1]);
            ((void (*)(_QWORD **, void (***)(_QWORD), _anonymous_namespace_ *, __int128 *))(*v4)[13])(v4, v12, v16, &v78);
            if (*(_QWORD *)&v79[1])
            {
              v17 = (float32x4_t *)v80[0];
              v18 = 80 * *(_QWORD *)&v79[1];
              v19 = (float *)(v80[0] + 64);
              v20 = 80 * *(_QWORD *)&v79[1];
              while (*v19 > 0.0)
              {
                v21 = vmulq_f32(*(float32x4_t *)(v19 - 4), *(float32x4_t *)(v19 - 4));
                if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v21, 2), vaddq_f32(v21, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v21.f32, 1))).f32[0] != 0.0)break;
                v19 += 20;
                v20 -= 80;
                if (!v20)
                  goto LABEL_37;
              }
              v22 = 0.0;
              v23 = 0uLL;
              do
              {
                if (v22 < (float)-v17[4].f32[0])
                {
                  v24 = v17 + 1;
                  if ((void (***)(_QWORD))v78 != v12)
                    v24 = v17;
                  v23 = *v24;
                  v22 = -v17[4].f32[0];
                }
                v17 += 5;
                v18 -= 80;
              }
              while (v18);
              if (v22 > 0.0)
              {
                v70 = v23;
                v72 = v22;
                v25 = (_OWORD *)*((_QWORD *)v16 + 2);
                v26.i64[0] = (*(uint64_t (**)(_OWORD *))(*(_QWORD *)v25 + 216))(v25);
                v26.i64[1] = v27;
                v73 = v26;
                v28 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 3) + 216))(*((_QWORD *)this + 3));
                v76 = 0uLL;
                *(_QWORD *)&v77 = 0;
                *((_QWORD *)&v77 + 1) = 0x3F80000000000000;
                v30 = vmulq_f32(v73, v73);
                LODWORD(v31) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v30, 2), vaddq_f32(v30, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v30.f32, 1))).u32[0];
                if (fabsf(v31) >= 1.0e-10)
                {
                  v38.i64[0] = v28;
                  v38.i64[1] = v29;
                  v68 = v31;
                  v69 = v38;
                  v39 = v72 / v1;
                  if ((float)(v72 / v1) > 1.0)
                    v39 = 1.0;
                  if (v39 < 0.0)
                    v39 = 0.0;
                  v67 = v39;
                  (*(void (**)(float32x4_t *__return_ptr, _OWORD *))(*(_QWORD *)v25 + 40))(&v74, v25);
                  v40 = v75;
                  v77 = v75;
                  v41 = vsubq_f32(v74, v70);
                  v42 = (int32x4_t)vmulq_f32(v41, v41);
                  v42.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v42, 2), vadd_f32(*(float32x2_t *)v42.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v42.i8, 1))).u32[0];
                  v43 = vrsqrte_f32((float32x2_t)v42.u32[0]);
                  v44 = vmul_f32(v43, vrsqrts_f32((float32x2_t)v42.u32[0], vmul_f32(v43, v43)));
                  v71 = vmulq_n_f32(v41, vmul_f32(v44, vrsqrts_f32((float32x2_t)v42.u32[0], vmul_f32(v44, v44))).f32[0]);
                  v76 = vaddq_f32(v74, vmulq_n_f32(v71, v72));
                  v25[1] = v76;
                  v25[2] = v40;
                  (*(void (**)(_OWORD *, float32x4_t *))(*(_QWORD *)v25 + 64))(v25, &v76);
                  v45 = v69;
                  v46 = vmulq_f32(v45, v45);
                  if (fabsf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v46, 2), vaddq_f32(v46, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v46.f32, 1))).f32[0]) >= 1.0e-10)
                  {
                    v47 = v73;
                    v57 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v47, (int32x4_t)v47), (int8x16_t)v73, 0xCuLL);
                    v58 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v69, (int32x4_t)v69), (int8x16_t)v69, 0xCuLL), vnegq_f32(v73)), v69, v57);
                    v59 = vmulq_f32(v58, v58);
                    v52 = v68;
                    if (fabsf(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v59.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v59, 2), v59)).f32[0]) < 1.0e-10)
                    {
                      v60 = vmlaq_f32(vmulq_f32(v73, (float32x4_t)xmmword_2261027D0), (float32x4_t)xmmword_2260E5F40, v57);
                      v61 = vmulq_f32(v60, v60);
                      if (fabsf(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v61.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v61, 2), v61)).f32[0]) < 1.0e-10)v60 = vmlaq_f32(vmulq_f32(v73, (float32x4_t)xmmword_2261027C0), (float32x4_t)xmmword_2260E5F20, v57);
                      v45 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v60, (int32x4_t)v60), (int8x16_t)v60, 0xCuLL);
                    }
                    v55 = 1.0 - v67;
                    v56 = vmulq_n_f32(v45, v67);
                  }
                  else
                  {
                    v47 = v73;
                    v48 = v71;
                    v49 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v48, (int32x4_t)v48), (int8x16_t)v71, 0xCuLL);
                    v50 = vmlaq_f32(vmulq_f32(v49, vnegq_f32(v73)), v71, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v47, (int32x4_t)v47), (int8x16_t)v73, 0xCuLL));
                    v51 = vmulq_f32(v50, v50);
                    v52 = v68;
                    if (fabsf(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v51.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v51, 2), v51)).f32[0]) < 1.0e-10)
                    {
                      v53 = vmlaq_f32(vmulq_f32(v71, (float32x4_t)xmmword_2261027D0), (float32x4_t)xmmword_2260E5F40, v49);
                      v54 = vmulq_f32(v53, v53);
                      if (fabsf(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v54.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v54, 2), v54)).f32[0]) < 1.0e-10)v53 = vmlaq_f32(vmulq_f32(v71, (float32x4_t)xmmword_2261027C0), (float32x4_t)xmmword_2260E5F20, v49);
                      v48 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v53, (int32x4_t)v53), (int8x16_t)v53, 0xCuLL);
                    }
                    v55 = 1.0 - v67;
                    v56 = vmulq_n_f32(vnegq_f32(v48), v67);
                  }
                  v62 = vmlaq_n_f32(v56, v47, v55);
                  v63 = (int32x4_t)vmulq_f32(v62, v62);
                  v63.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v63, 2), vadd_f32(*(float32x2_t *)v63.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v63.i8, 1))).u32[0];
                  v64 = vrsqrte_f32((float32x2_t)v63.u32[0]);
                  v65 = vmul_f32(v64, vrsqrts_f32((float32x2_t)v63.u32[0], vmul_f32(v64, v64)));
                  v74 = vmulq_n_f32(vmulq_n_f32(v62, vmul_f32(v65, vrsqrts_f32((float32x2_t)v63.u32[0], vmul_f32(v65, v65))).f32[0]), sqrtf(v52));
                  (*(void (**)(_OWORD *, float32x4_t *))(*(_QWORD *)v25 + 224))(v25, &v74);
                }
                else
                {
                  (*(void (**)(float32x4_t *__return_ptr))(**((_QWORD **)this + 3) + 40))(&v74);
                  v32 = v75;
                  v77 = v75;
                  v33 = vsubq_f32(v70, v74);
                  v34 = (int32x4_t)vmulq_f32(v33, v33);
                  v34.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v34, 2), vadd_f32(*(float32x2_t *)v34.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v34.i8, 1))).u32[0];
                  v35 = vrsqrte_f32((float32x2_t)v34.u32[0]);
                  v36 = vmul_f32(v35, vrsqrts_f32((float32x2_t)v34.u32[0], vmul_f32(v35, v35)));
                  v76 = vaddq_f32(v74, vmulq_n_f32(vmulq_n_f32(v33, vmul_f32(v36, vrsqrts_f32((float32x2_t)v34.u32[0], vmul_f32(v36, v36))).f32[0]), v72));
                  v37 = (_OWORD *)*((_QWORD *)this + 3);
                  v37[1] = v76;
                  v37[2] = v32;
                  (*(void (**)(_OWORD *, float32x4_t *))(*(_QWORD *)v37 + 64))(v37, &v76);
                }
              }
            }
LABEL_37:
            re::ContactSet::~ContactSet((re::ContactSet *)&v78);
          }
        }
      }
    }
    if (v12)
    {
      v66 = re::globalAllocators(v13)[2];
      (**v12)(v12);
      (*(void (**)(uint64_t, void (***)(_QWORD)))(*(_QWORD *)v66 + 40))(v66, v12);
    }
  }
}

void re::RadialRepulsionForce::~RadialRepulsionForce(re::RadialRepulsionForce *this)
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::RadialRepulsionForce::type(re::RadialRepulsionForce *this)
{
  return 8;
}

double re::TwistSwingJoint::TwistSwingJoint(_anonymous_namespace_ *a1, uint64_t a2)
{
  double result;

  ArcSharedObject::ArcSharedObject(a1, 0);
  *((_QWORD *)a1 + 3) = 0;
  *((_QWORD *)a1 + 4) = &str_110;
  *((_QWORD *)a1 + 5) = a2;
  *((_QWORD *)a1 + 6) = 0;
  *(_QWORD *)a1 = off_24ED7F0A8;
  result = -0.00781250185;
  *((_QWORD *)a1 + 7) = 0xBF8000003F800000;
  *((_QWORD *)a1 + 8) = 0xBF8000003F800000;
  *((_QWORD *)a1 + 9) = 0xBF8000003F800000;
  return result;
}

uint64_t re::TwistSwingJoint::setAngularLimit(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t result;

  if (a2 >= 3)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < N", "operator[]", 234, (int)a2, 3);
    result = _os_crash();
    __break(1u);
  }
  else
  {
    *(_QWORD *)(a1 + 8 * (int)a2 + 56) = *a3;
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
  }
  return result;
}

void re::PhysXPhysicsSimulation::~PhysXPhysicsSimulation(re::PhysXPhysicsSimulation *this)
{
  *(_QWORD *)this = &off_24ED7F0F8;
  re::PhysXPhysicsSimulation::deinit(this);
  re::PhysicsSimulation::~PhysicsSimulation(this);
}

{
  *(_QWORD *)this = &off_24ED7F0F8;
  re::PhysXPhysicsSimulation::deinit(this);
  re::PhysicsSimulation::~PhysicsSimulation(this);
  JUMPOUT(0x2276933B8);
}

uint64_t re::PhysXPhysicsSimulation::init(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v9;
  uint64_t result;
  _QWORD v11[2];

  v11[0] = a5;
  v11[1] = a6;
  a1[118] = a2;
  a1[119] = a3;
  a1[7] = v9;
  (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD *, _QWORD))(*(_QWORD *)v9 + 16))(v9, a3, a4, a1, 0);
  *(_QWORD *)(a1[7] + 136) = a1;
  (*(void (**)(_QWORD *, _QWORD *))(*a1 + 80))(a1, v11);
  a1[121] = *(_QWORD *)(a1[7] + 144);
  result = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)a3 + 32))(a3, 0x100000, 0);
  a1[122] = result;
  return result;
}

uint64_t re::PhysXPhysicsSimulation::deinit(re::PhysXPhysicsSimulation *this)
{
  uint64_t result;
  void (***v3)(_QWORD);
  uint64_t v4;

  result = (*(uint64_t (**)(re::PhysXPhysicsSimulation *))(*(_QWORD *)this + 32))(this);
  if ((_DWORD)result)
  {
    (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 119) + 40))(*((_QWORD *)this + 119), *((_QWORD *)this + 122));
    result = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 7) + 24))(*((_QWORD *)this + 7));
    v3 = (void (***)(_QWORD))*((_QWORD *)this + 7);
    if (v3)
    {
      v4 = *((_QWORD *)this + 119);
      (**v3)(*((_QWORD *)this + 7));
      result = (*(uint64_t (**)(uint64_t, void (***)(_QWORD)))(*(_QWORD *)v4 + 40))(v4, v3);
    }
    *((_QWORD *)this + 121) = 0;
    *((_QWORD *)this + 119) = 0;
  }
  return result;
}

BOOL re::PhysXPhysicsSimulation::hasDynamics(re::PhysXPhysicsSimulation *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 7);
  return *(_QWORD *)(v1 + 152) && *(_QWORD *)(v1 + 400) != 0;
}

BOOL re::PhysXPhysicsSimulation::needsPeriodicUpdates(re::PhysXPhysicsSimulation *this)
{
  uint64_t v1;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;

  v1 = *((_QWORD *)this + 7);
  if (!*(_QWORD *)(v1 + 152))
    return 0;
  v3 = *((_QWORD *)this + 13);
  if (!v3)
    return *(_DWORD *)(v1 + 100) != 0;
  v4 = (_QWORD *)*((_QWORD *)this + 15);
  v5 = 8 * v3;
  while (((*(uint64_t (**)(_QWORD))(*(_QWORD *)*v4 + 296))(*v4) & 1) != 0)
  {
    ++v4;
    v5 -= 8;
    if (!v5)
    {
      v1 = *((_QWORD *)this + 7);
      return *(_DWORD *)(v1 + 100) != 0;
    }
  }
  return 1;
}

double re::PhysXPhysicsSimulation::advance(re::PhysXPhysicsSimulation *this, float a2)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  __int128 v11;
  uint64_t v12;
  __int128 v13;
  __int128 v14;
  int v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  double result;

  v4 = *((_QWORD *)this + 7);
  v5 = *(_QWORD *)(v4 + 152);
  v6 = *((unsigned __int8 *)this + 72);
  *(_BYTE *)(v4 + 389) = v6;
  if (v6 && (physx::shdfnd::g_alwaysUseLocking & 1) == 0)
    physx::shdfnd::g_alwaysUseLocking = 1;
  v7 = *(_QWORD *)(v4 + 168);
  if (v7)
    *(_BYTE *)(v7 + 16) = *(_BYTE *)(v4 + 388) | v6;
  v8 = *((_QWORD *)this + 13);
  if (v8)
  {
    v9 = (uint64_t *)*((_QWORD *)this + 15);
    v10 = 8 * v8;
    v11 = 0uLL;
    while (1)
    {
      v12 = *v9;
      v13 = *(_OWORD *)(*v9 + 256);
      *(_OWORD *)(v12 + 368) = *(_OWORD *)(*v9 + 240);
      *(_OWORD *)(v12 + 384) = v13;
      v14 = *(_OWORD *)(v12 + 288);
      *(_OWORD *)(v12 + 400) = *(_OWORD *)(v12 + 272);
      *(_OWORD *)(v12 + 416) = v14;
      *(_OWORD *)(v12 + 272) = v11;
      *(_OWORD *)(v12 + 288) = v11;
      *(_OWORD *)(v12 + 240) = v11;
      *(_OWORD *)(v12 + 256) = v11;
      v15 = *(_DWORD *)(v12 + 208);
      if (v15 == 2)
        break;
      if (v15 == 1)
      {
        re::PhysXRigidBody::updateKinematicTargetFromVelocity((float32x4_t *)v12, a2);
LABEL_12:
        v11 = 0uLL;
      }
      *(_OWORD *)(v12 + 272) = v11;
      *(_OWORD *)(v12 + 288) = v11;
      *(_OWORD *)(v12 + 240) = v11;
      *(_OWORD *)(v12 + 256) = v11;
      ++v9;
      v10 -= 8;
      if (!v10)
        goto LABEL_14;
    }
    re::PhysXRigidBody::applyUserForces((float32x4_t *)v12);
    goto LABEL_12;
  }
LABEL_14:
  re::PhysicsSimulation::applyForceEffects(this);
  v16 = *((_QWORD *)this + 45);
  if (v16)
  {
    v17 = (uint64_t *)*((_QWORD *)this + 47);
    v18 = 8 * v16;
    do
    {
      v19 = *v17++;
      (*(void (**)(re::PhysXPhysicsSimulation *, uint64_t, char *, float))(*(_QWORD *)this + 112))(this, v19, (char *)this + 384, a2);
      v18 -= 8;
    }
    while (v18);
  }
  (*(void (**)(uint64_t, _QWORD, _QWORD, uint64_t, uint64_t, float))(*(_QWORD *)v5 + 400))(v5, 0, *((_QWORD *)this + 122), 0x100000, 1, a2);
  v20 = *((_QWORD *)this + 13);
  if (v20)
  {
    v21 = (uint64_t *)*((_QWORD *)this + 15);
    v22 = 8 * v20;
    do
    {
      v23 = *v21++;
      (*(void (**)(uint64_t))(*(_QWORD *)v23 + 368))(v23);
      v22 -= 8;
    }
    while (v22);
  }
  result = *((double *)this + 3) + a2;
  *((double *)this + 3) = result;
  return result;
}

int64x2_t re::PhysXPhysicsSimulation::collectStats(re::PhysXPhysicsSimulation *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t isStatisticCollectionEnabled;
  int64x2_t *v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  int64x2_t v9;
  uint64_t v10;
  int64x2_t *v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  int64x2_t v15;
  uint64_t v16;
  int64x2_t *v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  int64x2_t v21;
  re *v22;
  uint64_t v23;
  int64x2_t *v24;
  re *v25;
  re *v26;
  int64x2_t v27;
  uint64_t v28;
  int64x2_t *v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  int64x2_t v33;
  uint64_t v34;
  int64x2_t *v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  int64x2_t v39;
  uint64_t v40;
  int64x2_t *v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  int64x2_t v45;
  uint64_t v46;
  int64x2_t *v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  int64x2_t v51;
  uint64_t v52;
  int64x2_t *v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  int64x2_t v57;
  uint64_t v58;
  int64x2_t *v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  int64x2_t v63;
  uint64_t v64;
  int64x2_t *v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  int64x2_t v69;
  re *v70;
  int64x2_t result;
  uint64_t v72;
  int64x2_t *v73;
  unint64_t v74;
  unint64_t v75;
  unint64_t v76;
  int64x2_t v77;
  unsigned int v78;
  int v79;
  int v80;
  int v81;
  int v82;
  int v83;
  unsigned int v84;
  unsigned int v85;
  unsigned int v86;
  unsigned int v87;
  unsigned int v88;
  unsigned int v89;
  unsigned int v90;

  v2 = *(_QWORD *)(*((_QWORD *)this + 7) + 152);
  physx::PxSimulationStatistics::PxSimulationStatistics((uint64_t)&v78);
  (*(void (**)(uint64_t, unsigned int *))(*(_QWORD *)v2 + 592))(v2, &v78);
  if (re::internal::enableSignposts(0, 0))
    kdebug_trace();
  if (re::internal::enableSignposts(0, 0))
    kdebug_trace();
  if (re::internal::enableSignposts(0, 0))
    kdebug_trace();
  if (re::internal::enableSignposts(0, 0))
    kdebug_trace();
  if (re::internal::enableSignposts(0, 0))
    kdebug_trace();
  if (re::internal::enableSignposts(0, 0))
    kdebug_trace();
  if (re::internal::enableSignposts(0, 0))
    kdebug_trace();
  if (re::internal::enableSignposts(0, 0))
    kdebug_trace();
  if (re::internal::enableSignposts(0, 0))
    kdebug_trace();
  v3 = re::internal::enableSignposts(0, 0);
  if ((_DWORD)v3)
    v3 = kdebug_trace();
  isStatisticCollectionEnabled = re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)v3);
  if ((_DWORD)isStatisticCollectionEnabled)
  {
    isStatisticCollectionEnabled = re::profilerThreadContext((re *)isStatisticCollectionEnabled);
    v5 = *(int64x2_t **)(isStatisticCollectionEnabled + 152);
    if (v5)
    {
      v6 = (v82 + v81 + v83);
      v7 = v5[268].u64[0];
      if (v7 >= v6)
        v7 = (v82 + v81 + v83);
      v5[268].i64[0] = v7;
      v8 = v5[268].u64[1];
      if (v8 <= v6)
        v8 = v6;
      v5[268].i64[1] = v8;
      v9 = vdupq_n_s64(1uLL);
      v9.i64[0] = v6;
      v5[269] = vaddq_s64(v5[269], v9);
      *(_BYTE *)(isStatisticCollectionEnabled + 184) = 0;
    }
  }
  v10 = re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)isStatisticCollectionEnabled);
  if ((_DWORD)v10)
  {
    v10 = re::profilerThreadContext((re *)v10);
    v11 = *(int64x2_t **)(v10 + 152);
    if (v11)
    {
      v12 = (v80 + v79);
      v13 = v11[272].u64[0];
      if (v13 >= v12)
        v13 = (v80 + v79);
      v11[272].i64[0] = v13;
      v14 = v11[272].u64[1];
      if (v14 <= v12)
        v14 = v12;
      v11[272].i64[1] = v14;
      v15 = vdupq_n_s64(1uLL);
      v15.i64[0] = v12;
      v11[273] = vaddq_s64(v11[273], v15);
      *(_BYTE *)(v10 + 184) = 0;
    }
  }
  v16 = re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)v10);
  if ((_DWORD)v16)
  {
    v16 = re::profilerThreadContext((re *)v16);
    v17 = *(int64x2_t **)(v16 + 152);
    if (v17)
    {
      v18 = *((_QWORD *)this + 34);
      v19 = v17[288].u64[0];
      if (v19 >= v18)
        v19 = *((_QWORD *)this + 34);
      v17[288].i64[0] = v19;
      v20 = v17[288].u64[1];
      if (v20 <= v18)
        v20 = v18;
      v17[288].i64[1] = v20;
      v21 = vdupq_n_s64(1uLL);
      v21.i64[0] = v18;
      v17[289] = vaddq_s64(v17[289], v21);
      *(_BYTE *)(v16 + 184) = 0;
    }
  }
  v22 = (re *)re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)v16);
  if ((_DWORD)v22)
  {
    v23 = re::profilerThreadContext(v22);
    v22 = (re *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(*((_QWORD *)this + 7) + 128) + 176))(*(_QWORD *)(*((_QWORD *)this + 7) + 128));
    v24 = *(int64x2_t **)(v23 + 152);
    if (v24)
    {
      v25 = (re *)v24[276].i64[0];
      if (v25 >= v22)
        v25 = v22;
      v24[276].i64[0] = (uint64_t)v25;
      v26 = (re *)v24[276].i64[1];
      if (v26 <= v22)
        v26 = v22;
      v24[276].i64[1] = (uint64_t)v26;
      v27 = vdupq_n_s64(1uLL);
      v27.i64[0] = (uint64_t)v22;
      v24[277] = vaddq_s64(v24[277], v27);
      *(_BYTE *)(v23 + 184) = 0;
    }
  }
  v28 = re::ProfilerConfig::isStatisticCollectionEnabled(v22);
  if ((_DWORD)v28)
  {
    v28 = re::profilerThreadContext((re *)v28);
    v29 = *(int64x2_t **)(v28 + 152);
    if (v29)
    {
      v30 = v90;
      v31 = v29[280].u64[0];
      if (v31 >= v90)
        v31 = v90;
      v29[280].i64[0] = v31;
      v32 = v29[280].u64[1];
      if (v32 <= v30)
        v32 = v30;
      v29[280].i64[1] = v32;
      v33 = vdupq_n_s64(1uLL);
      v33.i64[0] = v30;
      v29[281] = vaddq_s64(v29[281], v33);
      *(_BYTE *)(v28 + 184) = 0;
    }
  }
  v34 = re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)v28);
  if ((_DWORD)v34)
  {
    v34 = re::profilerThreadContext((re *)v34);
    v35 = *(int64x2_t **)(v34 + 152);
    if (v35)
    {
      v36 = v78;
      v37 = v35[284].u64[0];
      if (v37 >= v78)
        v37 = v78;
      v35[284].i64[0] = v37;
      v38 = v35[284].u64[1];
      if (v38 <= v36)
        v38 = v36;
      v35[284].i64[1] = v38;
      v39 = vdupq_n_s64(1uLL);
      v39.i64[0] = v36;
      v35[285] = vaddq_s64(v35[285], v39);
      *(_BYTE *)(v34 + 184) = 0;
    }
  }
  v40 = re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)v34);
  if ((_DWORD)v40)
  {
    v40 = re::profilerThreadContext((re *)v40);
    v41 = *(int64x2_t **)(v40 + 152);
    if (v41)
    {
      v42 = v84;
      v43 = v41[292].u64[0];
      if (v43 >= v84)
        v43 = v84;
      v41[292].i64[0] = v43;
      v44 = v41[292].u64[1];
      if (v44 <= v42)
        v44 = v42;
      v41[292].i64[1] = v44;
      v45 = vdupq_n_s64(1uLL);
      v45.i64[0] = v42;
      v41[293] = vaddq_s64(v41[293], v45);
      *(_BYTE *)(v40 + 184) = 0;
    }
  }
  v46 = re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)v40);
  if ((_DWORD)v46)
  {
    v46 = re::profilerThreadContext((re *)v46);
    v47 = *(int64x2_t **)(v46 + 152);
    if (v47)
    {
      v48 = v85;
      v49 = v47[296].u64[0];
      if (v49 >= v85)
        v49 = v85;
      v47[296].i64[0] = v49;
      v50 = v47[296].u64[1];
      if (v50 <= v48)
        v50 = v48;
      v47[296].i64[1] = v50;
      v51 = vdupq_n_s64(1uLL);
      v51.i64[0] = v48;
      v47[297] = vaddq_s64(v47[297], v51);
      *(_BYTE *)(v46 + 184) = 0;
    }
  }
  v52 = re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)v46);
  if ((_DWORD)v52)
  {
    v52 = re::profilerThreadContext((re *)v52);
    v53 = *(int64x2_t **)(v52 + 152);
    if (v53)
    {
      v54 = v86;
      v55 = v53[300].u64[0];
      if (v55 >= v86)
        v55 = v86;
      v53[300].i64[0] = v55;
      v56 = v53[300].u64[1];
      if (v56 <= v54)
        v56 = v54;
      v53[300].i64[1] = v56;
      v57 = vdupq_n_s64(1uLL);
      v57.i64[0] = v54;
      v53[301] = vaddq_s64(v53[301], v57);
      *(_BYTE *)(v52 + 184) = 0;
    }
  }
  v58 = re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)v52);
  if ((_DWORD)v58)
  {
    v58 = re::profilerThreadContext((re *)v58);
    v59 = *(int64x2_t **)(v58 + 152);
    if (v59)
    {
      v60 = v87;
      v61 = v59[304].u64[0];
      if (v61 >= v87)
        v61 = v87;
      v59[304].i64[0] = v61;
      v62 = v59[304].u64[1];
      if (v62 <= v60)
        v62 = v60;
      v59[304].i64[1] = v62;
      v63 = vdupq_n_s64(1uLL);
      v63.i64[0] = v60;
      v59[305] = vaddq_s64(v59[305], v63);
      *(_BYTE *)(v58 + 184) = 0;
    }
  }
  v64 = re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)v58);
  if ((_DWORD)v64)
  {
    v64 = re::profilerThreadContext((re *)v64);
    v65 = *(int64x2_t **)(v64 + 152);
    if (v65)
    {
      v66 = v89;
      v67 = v65[308].u64[0];
      if (v67 >= v89)
        v67 = v89;
      v65[308].i64[0] = v67;
      v68 = v65[308].u64[1];
      if (v68 <= v66)
        v68 = v66;
      v65[308].i64[1] = v68;
      v69 = vdupq_n_s64(1uLL);
      v69.i64[0] = v66;
      v65[309] = vaddq_s64(v65[309], v69);
      *(_BYTE *)(v64 + 184) = 0;
    }
  }
  v70 = (re *)re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)v64);
  if ((_DWORD)v70)
  {
    v72 = re::profilerThreadContext(v70);
    v73 = *(int64x2_t **)(v72 + 152);
    if (v73)
    {
      v74 = v88;
      v75 = v73[312].u64[0];
      if (v75 >= v88)
        v75 = v88;
      v73[312].i64[0] = v75;
      v76 = v73[312].u64[1];
      if (v76 <= v74)
        v76 = v74;
      v73[312].i64[1] = v76;
      v77 = vdupq_n_s64(1uLL);
      v77.i64[0] = v74;
      result = vaddq_s64(v73[313], v77);
      v73[313] = result;
      *(_BYTE *)(v72 + 184) = 0;
    }
  }
  return result;
}

uint64_t re::PhysXPhysicsSimulation::gravity(re::PhysXPhysicsSimulation *this)
{
  uint64_t v2;

  (*(void (**)(uint64_t *__return_ptr))(**(_QWORD **)(*((_QWORD *)this + 7) + 152) + 488))(&v2);
  return v2;
}

_QWORD *re::PhysXPhysicsSimulation::setGravity(_QWORD *a1, float32x4_t *a2)
{
  _QWORD *result;
  float v5;
  float v6;
  float v7;
  int v8;
  float32x4_t v9;
  float v10;
  uint64_t v11;
  uint64_t v12;
  float32x4_t v13;
  re::PhysXRigidBody **v14;
  uint64_t v15;
  re::PhysXRigidBody *v16;
  unsigned __int32 v17;

  result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*a1 + 72))(a1);
  if (a2->f32[0] != *(float *)&result
    && vabds_f32(a2->f32[0], *(float *)&result) >= (float)((float)((float)(fabsf(a2->f32[0]) + fabsf(*(float *)&result))
                                                                 + 1.0)
                                                         * 0.00001)
    || (v6 = a2->f32[1], v6 != *((float *)&result + 1))
    && vabds_f32(v6, *((float *)&result + 1)) >= (float)((float)((float)(fabsf(*((float *)&result + 1)) + fabsf(v6))
                                                               + 1.0)
                                                       * 0.00001)
    || (v7 = a2->f32[2], v7 != v5)
    && vabds_f32(v7, v5) >= (float)((float)((float)(fabsf(v5) + fabsf(v7)) + 1.0) * 0.00001))
  {
    if (physx::shdfnd::g_isLockingEnabled)
      v8 = 1;
    else
      v8 = physx::shdfnd::g_alwaysUseLocking;
    if ((physx::shdfnd::g_alwaysUseLocking & 1) == 0 && physx::shdfnd::g_isLockingEnabled)
      physx::shdfnd::g_isLockingEnabled = 0;
    v9 = vmulq_f32(*a2, *a2);
    v10 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v9, 2), vaddq_f32(v9, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v9.f32, 1))).f32[0]);
    v11 = *(_QWORD *)(a1[7] + 152);
    (*(void (**)(uint64_t, float32x4_t *))(*(_QWORD *)v11 + 480))(v11, a2);
    result = (_QWORD *)(*(uint64_t (**)(uint64_t, float))(*(_QWORD *)v11 + 496))(v11, v10 * 0.2);
    v12 = a1[13];
    if (v12)
    {
      v13 = vmulq_f32(*a2, *a2);
      v17 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 2), vaddq_f32(v13, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13.f32, 1))).u32[0];
      v14 = (re::PhysXRigidBody **)a1[15];
      v15 = 8 * v12;
      do
      {
        v16 = *v14++;
        *((_DWORD *)v16 + 78) = v17;
        re::PhysXRigidBody::updateSleepThreshold(v16);
        result = re::PhysXRigidBody::wakeUp(v16);
        v15 -= 8;
      }
      while (v15);
    }
    if (physx::shdfnd::g_isLockingEnabled != v8)
      physx::shdfnd::g_isLockingEnabled = v8;
  }
  return result;
}

_QWORD *re::PhysXPhysicsSimulation::onRigidBodyAdded(re::PhysXPhysicsSimulation *this, re::RigidBody *a2)
{
  int v4;
  float32x4_t v5;
  uint64_t v6;
  float32x4_t v7;
  _QWORD *result;

  if (physx::shdfnd::g_isLockingEnabled)
    v4 = 1;
  else
    v4 = physx::shdfnd::g_alwaysUseLocking;
  if ((physx::shdfnd::g_alwaysUseLocking & 1) == 0 && physx::shdfnd::g_isLockingEnabled)
    physx::shdfnd::g_isLockingEnabled = 0;
  re::PhysicsSimulation::onRigidBodyAdded(this, a2);
  v5.i64[0] = (*(uint64_t (**)(re::PhysXPhysicsSimulation *))(*(_QWORD *)this + 72))(this);
  v5.i64[1] = v6;
  v7 = vmulq_f32(v5, v5);
  *((_DWORD *)a2 + 78) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2), vaddq_f32(v7, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 1))).u32[0];
  re::PhysXRigidBody::updateSleepThreshold(a2);
  result = re::PhysXRigidBody::wakeUp(a2);
  if (physx::shdfnd::g_isLockingEnabled != v4)
    physx::shdfnd::g_isLockingEnabled = v4;
  return result;
}

uint64_t re::PhysXPhysicsSimulation::applyForceEffect(uint64_t this, float32x4_t *a2, re::ForceEffectFunctionRuntime *a3, float a4)
{
  uint64_t v7;
  float32x4_t *v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double *v13;
  float v15;
  float v16;
  float v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float v23;
  float v24;
  uint64_t v25;
  unint64_t i;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int v30;
  char v31;
  re::ForceEffectFunctionRuntime *v32;
  uint64_t v33;
  _DWORD *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  BOOL v40;
  float32x4_t v42;
  int8x16_t v43;
  float32x4_t v44;
  float32x4_t v45;
  int8x16_t v46;
  float32x4_t v47;
  int8x16_t v48;
  float32x4_t v49;
  float32x4_t v50;
  int8x16_t v51;
  float32x4_t v52;
  uint64_t v53;
  BOOL v54;
  unint64_t v55;
  unint64_t v56;
  float32x4_t v57;
  float32x4_t v58;
  uint64_t *v59;
  _DWORD *v60;
  uint64_t v61;
  _BOOL4 v62;
  unint64_t v63;
  float32x4_t v66;
  int8x16_t v67;
  float32x4_t v68;
  int8x16_t v69;
  int8x16_t v70;
  float32x4_t v71;
  unint64_t v76;
  uint64_t v77;
  int32x4_t v78;
  uint64_t v79;
  float32x4_t v80;
  int8x16_t v81;
  float32x4_t v82;
  int8x16_t v83;
  unint64_t v84;
  uint64_t v85;
  int32x4_t v86;
  uint64_t v87;
  float32x4_t v88;
  int8x16_t v89;
  float32x4_t v90;
  int8x16_t v91;
  _BOOL4 v92;
  unint64_t v93;
  uint64_t v95;
  unint64_t v96;
  int32x4_t v97;
  uint64_t v98;
  int8x16_t v99;
  float v101;
  float v102;
  float v103;
  float v104;
  float v105;
  float v106;
  float v107;
  int32x4_t v108;
  float32x4_t v110;
  float32x4_t v111;
  int32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;
  uint64_t v115;
  float32x4_t v116;
  float32x4_t v117;
  float32x4_t v118;
  int32x4_t v119;
  int32x4_t v120;
  int32x4_t v121;
  int32x4_t v122;
  __int32 v123;
  int8x16_t v124;
  float32x4_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  unint64_t v130;
  float v131;
  float v132;
  float v133;
  float v134;
  float32x4_t v135;
  float32x4_t v136;
  float v137;
  float v138;
  uint64_t v139;
  uint64_t v140;
  float v141;
  float v142;
  float v143;
  float v144;
  float v145;
  float v146;
  uint64_t v147;
  uint64_t v148;
  float32x4_t v149;
  float32x4_t v150;
  float32x4_t v151;
  float32x4_t v152;
  float32x4_t v153;
  int8x16_t v154;
  float32x4_t v155;
  float32x4_t v156;
  int8x16_t v157;
  uint64_t v158;
  float32x4_t v159;
  float32x4_t v160;
  float32x4_t v161;
  float32x4_t v162;
  float32x4_t v163;
  int8x16_t v164;
  float32x4_t v165;
  float32x4_t v166;
  int8x16_t v167;
  uint64_t v168;
  int *v169;
  double *v170;
  _DWORD *v171;
  float32x4_t v172;
  float32x4_t v173;
  float32x4_t v174;
  uint64_t v175;
  int32x4_t v176;
  int32x4_t v177;
  float32x4_t v178;
  float32x4_t v179;
  float32x4_t v180;
  float32x4_t v181;
  float32x4_t v182;
  float32x4_t v183;
  float32x4_t v184;
  float32x4_t v185;
  float32x4_t v186;
  int8x16_t v187;
  float32x4_t v188;
  __int128 v189;
  __int128 v190;
  __int128 v191;
  __int128 v192;
  __int128 v193;
  __int128 v194;
  __int128 v195;
  __int128 v196;
  __int128 v197;
  __int128 v198;
  _QWORD v199[2];
  unint64_t v200;
  int v201;
  uint64_t *v202;
  uint64_t v203;
  _BYTE v204[28];
  __int16 v205;
  unint64_t v206;
  float32x4_t v207;
  int32x4_t v208;
  int32x4_t v209;
  __int128 v210;
  __int128 v211;
  uint64_t v212;

  v212 = *MEMORY[0x24BDAC8D0];
  if (!a2[10].i8[8])
    return this;
  v7 = this;
  re::ForceEffectDefinition::advance((uint64_t)a2, a4);
  if (!a2[8].i64[0])
  {
    v8 = a2 + 4;
    v13 = (double *)&a2[4].i64[1];
    v10 = 0.0;
    goto LABEL_17;
  }
  v8 = a2 + 4;
  v9 = *(double *)a2[9].i64;
  v10 = *(double *)a2[10].i64 - v9;
  v11 = 0.0;
  if (a2[8].i8[8])
    v12 = *(double *)a2[10].i64 - v9;
  else
    v12 = 0.0;
  v13 = (double *)&a2[4].i64[1];
  if (v12 < *(double *)&a2[4].i64[1] || a2[4].i8[0] == 0)
  {
    v11 = v12;
LABEL_16:
    v10 = v11;
    goto LABEL_17;
  }
  if (!a2[8].i8[8])
    goto LABEL_16;
  a2[8].i8[8] = 0;
  if (a2[9].i8[8])
    a2[9].i8[8] = 0;
  a2[10].i8[8] = 0;
LABEL_17:
  v202 = 0;
  v200 = 0;
  v199[0] = 0;
  v199[1] = 0;
  v201 = 0;
  if (a2[2].i8[12])
  {
    v15 = a2[3].f32[0];
    v16 = a2[3].f32[1];
    v17 = a2[3].f32[2];
    v185.i32[0] = 0;
    v185.f32[1] = v15;
    *(float32x4_t *)v204 = a2[1];
    *(_QWORD *)&v204[16] = a2->i64[0];
    *(_DWORD *)&v204[24] = a2->i32[2];
    re::PhysXCollisionWorld::overlap(*(_QWORD *)(v7 + 56), (uint64_t)&v185, (uint64_t)v204, a2[2].i32[1], (uint64_t)&v186);
    if (v187.i64[0])
    {
      v18 = v188.i64[0];
      v19 = 8 * v187.i64[0];
      do
      {
        if ((*(_BYTE *)(*(_QWORD *)v18 + 8) & 1) != 0)
        {
          v20 = *(_QWORD *)(*(_QWORD *)v18 + 16);
          v184.i64[0] = v20;
          if (v20)
          {
            if (*(_DWORD *)(v20 + 208) == 2 && *(float *)(v20 + 192) > 0.0)
            {
              (*(void (**)(float32x4_t *__return_ptr))(*(_QWORD *)v20 + 40))(&v207);
              if (v15 <= v16)
                goto LABEL_31;
              v21 = vsubq_f32(v207, *a2);
              v22 = vmulq_f32(v21, v21);
              v23 = (float)(sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v22, 2), vaddq_f32(v22, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v22.f32, 1))).f32[0])- v16)/ (float)(v15 - v16);
              if (v23 > 1.0)
                v23 = 1.0;
              v24 = v23 >= 0.0 ? 1.0 - v23 : 1.0;
              if (powf(v24, v17) > 0.00000001)
LABEL_31:
                re::DynamicArray<re::TransitionCondition *>::add(v199, &v184);
            }
          }
        }
        v18 += 8;
        v19 -= 8;
      }
      while (v19);
    }
    if (v186.i64[0] && v188.i64[0])
      (*(void (**)(void))(*(_QWORD *)v186.i64[0] + 40))();
  }
  else
  {
    v25 = *(_QWORD *)(v7 + 104);
    if (v25)
    {
      for (i = 0; i != v25; ++i)
      {
        v186.i64[0] = 0;
        v27 = re::ecs2::ComponentTypeRegistry::operator[](v7 + 80, i);
        v186.i64[0] = v27;
        if (*(_DWORD *)(v27 + 208) == 2)
        {
          v28 = *(_QWORD *)(v27 + 72);
          if (v28)
          {
            if ((a2[2].i32[1] & *(_DWORD *)(v28 + 32)) != 0 && *(float *)(v27 + 192) > 0.0)
              re::DynamicArray<re::TransitionCondition *>::add(v199, &v186);
          }
        }
      }
    }
  }
  if (v200)
  {
    v29 = a2[5].i64[1];
    if (v29)
    {
      v168 = v7;
      v170 = v13;
      v30 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v29 + 40))(v29);
      v31 = v30;
      re::ForceEffectFunctionRuntime::reserveInputBuffers((uint64_t)a3, v30, v200);
      v32 = a3;
      if ((v31 & 0x10) != 0)
        v33 = *((_QWORD *)a3 + 24);
      else
        v33 = 0;
      v34 = (_DWORD *)*((_QWORD *)v32 + 29);
      if ((v31 & 0x20) == 0)
        v34 = 0;
      v171 = v34;
      if ((v31 & 2) != 0)
        v35 = *((_QWORD *)v32 + 9);
      else
        v35 = 0;
      if ((v31 & 1) != 0)
        v36 = *((_QWORD *)v32 + 4);
      else
        v36 = 0;
      if ((v31 & 4) != 0)
        v37 = *((_QWORD *)v32 + 14);
      else
        v37 = 0;
      if ((v31 & 8) != 0)
        v38 = *((_QWORD *)v32 + 19);
      else
        v38 = 0;
      v169 = (int *)v32;
      v39 = *((_QWORD *)v32 + 34);
      if ((v31 & 0x40) == 0)
        v39 = 0;
      v175 = v39;
      if (v36 | v35)
        v40 = 0;
      else
        v40 = v37 == 0;
      if (v40 && v38 == 0)
      {
        v44 = (float32x4_t)xmmword_2260E5D70;
        v52 = 0uLL;
      }
      else
      {
        v42 = a2[1];
        v43 = (int8x16_t)vnegq_f32(v42);
        v44 = (float32x4_t)v43;
        v44.i32[3] = v42.i32[3];
        v45 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v43, (int32x4_t)v43), v43, 0xCuLL);
        v46 = (int8x16_t)vnegq_f32(*a2);
        v47 = vmlsq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v46, (int32x4_t)v46), v46, 0xCuLL), v42), v45, *a2);
        v48 = (int8x16_t)vaddq_f32(v47, v47);
        v49 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v48, (int32x4_t)v48), v48, 0xCuLL);
        v50 = vsubq_f32(vmulq_laneq_f32(v49, v42, 3), *a2);
        v51 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v49, (int32x4_t)v49), (int8x16_t)v49, 0xCuLL), v42), v49, v45);
        v52 = vaddq_f32(v50, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v51, (int32x4_t)v51), v51, 0xCuLL));
      }
      v180 = v52;
      v53 = v200;
      if (v33)
        v54 = v200 == 0;
      else
        v54 = 1;
      v55 = (unint64_t)v171;
      v183 = v44;
      if (!v54)
      {
        v56 = 0;
        do
        {
          (*(void (**)(float32x4_t *__return_ptr))(*(_QWORD *)v202[v56] + 40))(&v186);
          v57 = vsubq_f32(v186, *a2);
          v58 = vmulq_f32(v57, v57);
          *(float *)(v33 + 4 * v56++) = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v58, 2), vaddq_f32(v58, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v58.f32, 1))).f32[0]);
          v53 = v200;
        }
        while (v56 < v200);
        v44 = v183;
      }
      if (v171)
      {
        if (!v53)
        {
          v92 = v175 != 0;
LABEL_114:
          v197 = 0u;
          v198 = 0u;
          v195 = 0u;
          v196 = 0u;
          v193 = 0u;
          v194 = 0u;
          v191 = 0u;
          v192 = 0u;
          v189 = 0u;
          v190 = 0u;
          v188 = 0u;
          v186.i64[0] = v168;
          v186.f32[2] = a4;
          *(double *)v187.i64 = v10;
          v187.i64[1] = v53;
          if (v36)
          {
            *(_QWORD *)&v189 = v36;
            *((_QWORD *)&v189 + 1) = v53;
          }
          if (v35)
          {
            *(_QWORD *)&v190 = v35;
            *((_QWORD *)&v190 + 1) = v53;
          }
          if (v37)
          {
            *(_QWORD *)&v191 = v37;
            *((_QWORD *)&v191 + 1) = v53;
          }
          if (v38)
          {
            *(_QWORD *)&v192 = v38;
            *((_QWORD *)&v192 + 1) = v53;
          }
          if (v33)
          {
            v188.i64[0] = v33;
            v188.i64[1] = v53;
          }
          if (v55)
          {
            *(_QWORD *)&v193 = v55;
            *((_QWORD *)&v193 + 1) = v53;
          }
          if (v92)
          {
            *(_QWORD *)&v194 = v175;
            *((_QWORD *)&v194 + 1) = v53;
          }
          re::ForceEffectFunctionRuntime::reserveOutputBuffers((re::ForceEffectFunctionRuntime *)v169, v53);
          v127 = 5 * v169[120];
          *(_QWORD *)&v195 = *(_QWORD *)&v169[-10 * v169[120] + 98];
          *((_QWORD *)&v195 + 1) = v187.i64[1];
          v128 = 5 * v169[121];
          *(_QWORD *)&v196 = *(_QWORD *)&v169[-10 * v169[121] + 118];
          *((_QWORD *)&v196 + 1) = v187.i64[1];
          *(_QWORD *)&v197 = *(_QWORD *)&v169[2 * v127 + 88];
          *((_QWORD *)&v197 + 1) = v187.i64[1];
          *(_QWORD *)&v198 = *(_QWORD *)&v169[2 * v128 + 108];
          *((_QWORD *)&v198 + 1) = v187.i64[1];
          (*(void (**)(uint64_t, float32x4_t *, int *))(*(_QWORD *)a2[5].i64[1] + 24))(a2[5].i64[1], &v186, v169);
          if (a2[2].i8[12] && v200)
          {
            v130 = 0;
            v132 = a2[3].f32[1];
            v131 = a2[3].f32[2];
            v133 = a2[3].f32[0];
            while (1)
            {
              (*(void (**)(float32x4_t *__return_ptr))(*(_QWORD *)v202[v130] + 40))(&v207);
              v134 = 1.0;
              if (v133 > v132)
              {
                v135 = vsubq_f32(v207, *a2);
                v136 = vmulq_f32(v135, v135);
                v137 = (float)(sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v136, 2), vaddq_f32(v136, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v136.f32, 1))).f32[0])- v132)/ (float)(v133 - v132);
                if (v137 > 1.0)
                  v137 = 1.0;
                if (v137 >= 0.0)
                  v138 = 1.0 - v137;
                else
                  v138 = 1.0;
                v134 = powf(v138, v131);
              }
              v139 = *((_QWORD *)&v197 + 1);
              if (*((_QWORD *)&v197 + 1) <= v130)
                break;
              *(float32x4_t *)(v197 + 16 * v130) = vmulq_n_f32(*(float32x4_t *)(v197 + 16 * v130), v134);
              v140 = *((_QWORD *)&v198 + 1);
              if (*((_QWORD *)&v198 + 1) <= v130)
                goto LABEL_169;
              *(float32x4_t *)(v198 + 16 * v130) = vmulq_n_f32(*(float32x4_t *)(v198 + 16 * v130), v134);
              if (++v130 >= v200)
                goto LABEL_141;
            }
LABEL_168:
            re::internal::assertLog((re::internal *)6, v129, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v130, v139);
            _os_crash();
            __break(1u);
LABEL_169:
            re::internal::assertLog((re::internal *)6, v129, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v130, v140);
            _os_crash();
            __break(1u);
          }
LABEL_141:
          v141 = 1.0;
          if (v8->i8[0])
          {
            v142 = *v170;
            if (v142 > 0.0)
            {
              v143 = v10;
              v144 = v143 / v142;
              if (v144 > 1.0)
                v144 = 1.0;
              if (v144 >= 0.0)
                v145 = 1.0 - v144;
              else
                v145 = 1.0;
              v141 = powf(v145, a2[5].f32[0]);
            }
          }
          if (v200)
          {
            v130 = 0;
            while (*((_QWORD *)&v197 + 1) > v130)
            {
              v146 = v141 * a2[2].f32[0];
              *(float32x4_t *)(v197 + 16 * v130) = vmulq_n_f32(*(float32x4_t *)(v197 + 16 * v130), v146);
              v147 = *((_QWORD *)&v197 + 1);
              if (*((_QWORD *)&v197 + 1) <= v130)
                goto LABEL_163;
              v148 = *((_QWORD *)&v198 + 1);
              v149 = *(float32x4_t *)(v197 + 16 * v130);
              v150 = a2[1];
              v151 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v150, (int32x4_t)v150), (int8x16_t)v150, 0xCuLL);
              v152 = vnegq_f32(v150);
              v153 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v149, (int32x4_t)v149), (int8x16_t)v149, 0xCuLL), v152), v149, v151);
              v154 = (int8x16_t)vaddq_f32(v153, v153);
              v155 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v154, (int32x4_t)v154), v154, 0xCuLL);
              v156 = vaddq_f32(v149, vmulq_laneq_f32(v155, v150, 3));
              v157 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v155, (int32x4_t)v155), (int8x16_t)v155, 0xCuLL), v152), v155, v151);
              v185 = vaddq_f32(v156, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v157, (int32x4_t)v157), v157, 0xCuLL));
              if (*((_QWORD *)&v198 + 1) <= v130)
                goto LABEL_164;
              *(float32x4_t *)(v198 + 16 * v130) = vmulq_n_f32(*(float32x4_t *)(v198 + 16 * v130), v146);
              v158 = *((_QWORD *)&v198 + 1);
              if (*((_QWORD *)&v198 + 1) <= v130)
                goto LABEL_165;
              v159 = a2[1];
              v160 = *(float32x4_t *)(v198 + 16 * v130);
              v161 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v159, (int32x4_t)v159), (int8x16_t)v159, 0xCuLL);
              v162 = vnegq_f32(v159);
              v163 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v160, (int32x4_t)v160), (int8x16_t)v160, 0xCuLL), v162), v160, v161);
              v164 = (int8x16_t)vaddq_f32(v163, v163);
              v165 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v164, (int32x4_t)v164), v164, 0xCuLL);
              v166 = vaddq_f32(v160, vmulq_laneq_f32(v165, v159, 3));
              v167 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v165, (int32x4_t)v165), (int8x16_t)v165, 0xCuLL), v162), v165, v161);
              v184 = vaddq_f32(v166, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v167, (int32x4_t)v167), v167, 0xCuLL));
              v55 = v200;
              if (v200 <= v130)
                goto LABEL_166;
              (*(void (**)(uint64_t, float32x4_t *, _QWORD))(*(_QWORD *)v202[v130] + 408))(v202[v130], &v185, a2[2].u8[8]);
              v55 = v200;
              if (v200 <= v130)
                goto LABEL_167;
              (*(void (**)(uint64_t, float32x4_t *, _QWORD))(*(_QWORD *)v202[v130] + 416))(v202[v130], &v184, a2[2].u8[8]);
              if (++v130 >= v200)
                goto LABEL_158;
            }
            re::internal::assertLog((re::internal *)6, v129, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v130, *((_QWORD *)&v197 + 1));
            _os_crash();
            __break(1u);
LABEL_163:
            re::internal::assertLog((re::internal *)6, v129, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v130, v147);
            _os_crash();
            __break(1u);
LABEL_164:
            re::internal::assertLog((re::internal *)6, v129, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v130, v148);
            _os_crash();
            __break(1u);
LABEL_165:
            re::internal::assertLog((re::internal *)6, v129, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 658, v130, v158);
            _os_crash();
            __break(1u);
LABEL_166:
            v203 = 0;
            v210 = 0u;
            v211 = 0u;
            v208 = 0u;
            v209 = 0u;
            v207 = 0u;
            os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
            *(_DWORD *)v204 = 136315906;
            *(_QWORD *)&v204[4] = "operator[]";
            *(_WORD *)&v204[12] = 1024;
            *(_DWORD *)&v204[14] = 789;
            *(_WORD *)&v204[18] = 2048;
            *(_QWORD *)&v204[20] = v130;
            v205 = 2048;
            v206 = v55;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_167:
            v203 = 0;
            v210 = 0u;
            v211 = 0u;
            v208 = 0u;
            v209 = 0u;
            v207 = 0u;
            os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
            *(_DWORD *)v204 = 136315906;
            *(_QWORD *)&v204[4] = "operator[]";
            *(_WORD *)&v204[12] = 1024;
            *(_DWORD *)&v204[14] = 789;
            *(_WORD *)&v204[18] = 2048;
            *(_QWORD *)&v204[20] = v130;
            v205 = 2048;
            v206 = v55;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
            goto LABEL_168;
          }
          goto LABEL_158;
        }
        v59 = v202;
        v60 = v171;
        do
        {
          v61 = *v59++;
          *v60++ = *(_DWORD *)(v61 + 192);
          --v53;
        }
        while (v53);
        v53 = v200;
      }
      if (v53)
        v62 = (v36 | v35) != 0;
      else
        v62 = 0;
      if (v62)
      {
        v63 = 0;
        v181 = vnegq_f32(v44);
        v182 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v44, (int32x4_t)v44), (int8x16_t)v44, 0xCuLL);
        v178 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v44, 3);
        _S9 = v44.i32[3];
        do
        {
          (*(void (**)(float32x4_t *__return_ptr))(*(_QWORD *)v202[v63] + 40))(&v186);
          v44 = v183;
          _Q0 = (float32x4_t)v187;
          if (v36)
          {
            v66 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v186, (int32x4_t)v186), (int8x16_t)v186, 0xCuLL), v181), v186, v182);
            v67 = (int8x16_t)vaddq_f32(v66, v66);
            v68 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v67, (int32x4_t)v67), v67, 0xCuLL);
            v69 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v68, (int32x4_t)v68), (int8x16_t)v68, 0xCuLL), v181), v68, v182);
            *(float32x4_t *)(v36 + 16 * v63) = vaddq_f32(v180, vaddq_f32(vaddq_f32(v186, vmulq_laneq_f32(v68, v183, 3)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v69, (int32x4_t)v69), v69, 0xCuLL)));
          }
          if (v35)
          {
            v70 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q0, (int32x4_t)_Q0), (int8x16_t)_Q0, 0xCuLL), v181), _Q0, v182);
            v71 = vmlaq_laneq_f32(vmlaq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v70, (int32x4_t)v70), v70, 0xCuLL), _Q0, v178), v183, _Q0, 3);
            __asm { FMLA            S2, S9, V0.S[3] }
            v71.i32[3] = _S2;
            *(float32x4_t *)(v35 + 16 * v63) = v71;
          }
          ++v63;
          v53 = v200;
        }
        while (v63 < v200);
      }
      if (v37 && v53)
      {
        v76 = 0;
        v181 = vnegq_f32(v44);
        v182 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v44, (int32x4_t)v44), (int8x16_t)v44, 0xCuLL);
        do
        {
          v77 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v202[v76] + 216))(v202[v76]);
          v44 = v183;
          v78.i64[0] = v77;
          v78.i64[1] = v79;
          v80 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v78, v78), (int8x16_t)v78, 0xCuLL), v181), (float32x4_t)v78, v182);
          v81 = (int8x16_t)vaddq_f32(v80, v80);
          v82 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v81, (int32x4_t)v81), v81, 0xCuLL);
          v83 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v82, (int32x4_t)v82), (int8x16_t)v82, 0xCuLL), v181), v82, v182);
          *(float32x4_t *)(v37 + 16 * v76++) = vaddq_f32(vaddq_f32(vmulq_laneq_f32(v82, v183, 3), (float32x4_t)v78), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v83, (int32x4_t)v83), v83, 0xCuLL));
          v53 = v200;
        }
        while (v76 < v200);
      }
      if (v38 && v53)
      {
        v84 = 0;
        v181 = vnegq_f32(v44);
        v182 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v44, (int32x4_t)v44), (int8x16_t)v44, 0xCuLL);
        do
        {
          v85 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v202[v84] + 232))(v202[v84]);
          v44 = v183;
          v86.i64[0] = v85;
          v86.i64[1] = v87;
          v88 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v86, v86), (int8x16_t)v86, 0xCuLL), v181), (float32x4_t)v86, v182);
          v89 = (int8x16_t)vaddq_f32(v88, v88);
          v90 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v89, (int32x4_t)v89), v89, 0xCuLL);
          v91 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v90, (int32x4_t)v90), (int8x16_t)v90, 0xCuLL), v181), v90, v182);
          *(float32x4_t *)(v38 + 16 * v84++) = vaddq_f32(vaddq_f32(vmulq_laneq_f32(v90, v183, 3), (float32x4_t)v86), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v91, (int32x4_t)v91), v91, 0xCuLL));
          v53 = v200;
        }
        while (v84 < v200);
      }
      v92 = v175 != 0;
      if (v175 && v53)
      {
        v93 = 0;
        v173 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v44, 3);
        v174 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v44, (int32x4_t)v44), (int8x16_t)v44, 0xCuLL);
        v172 = vnegq_f32(v44);
        _S9 = v44.i32[3];
        do
        {
          v95 = v202[v93];
          v179 = (float32x4_t)*(_OWORD *)(v95 + 176);
          LODWORD(v96) = 0;
          HIDWORD(v96) = HIDWORD(*(_QWORD *)(v95 + 176));
          v177 = (int32x4_t)v96;
          v97.i64[0] = 0;
          v97.i64[1] = *(_QWORD *)(v95 + 184);
          v176 = v97;
          (*(void (**)(float32x4_t *__return_ptr))(*(_QWORD *)v95 + 40))(&v186);
          v98 = 0;
          _Q0 = (int32x4_t)v187;
          v99 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(_Q0, _Q0), v187, 0xCuLL), v172), (float32x4_t)v187, v174);
          v111 = vmlaq_laneq_f32(vmlaq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v99, (int32x4_t)v99), v99, 0xCuLL), (float32x4_t)v187, v173), v183, (float32x4_t)v187, 3);
          _Q2 = (int32x4_t)vmulq_f32(v183, (float32x4_t)v187);
          v108 = vdupq_lane_s32(*(int32x2_t *)_Q2.i8, 1);
          v112 = vdupq_laneq_s32(_Q2, 2);
          __asm { FMLA            S2, S9, V0.S[3] }
          v101 = (float)(v111.f32[0] + v111.f32[0]) * v111.f32[0];
          v102 = vmuls_lane_f32(v111.f32[1] + v111.f32[1], *(float32x2_t *)v111.f32, 1);
          v103 = vmuls_lane_f32(v111.f32[2] + v111.f32[2], v111, 2);
          v104 = vmuls_lane_f32(v111.f32[0] + v111.f32[0], *(float32x2_t *)v111.f32, 1);
          v105 = vmuls_lane_f32(v111.f32[0] + v111.f32[0], v111, 2);
          v106 = vmuls_lane_f32(v111.f32[1] + v111.f32[1], v111, 2);
          v107 = *(float *)_Q2.i32 * (float)(v111.f32[0] + v111.f32[0]);
          *(float *)v108.i32 = *(float *)_Q2.i32 * (float)(v111.f32[1] + v111.f32[1]);
          v111.f32[0] = *(float *)_Q2.i32 * (float)(v111.f32[2] + v111.f32[2]);
          *(float *)_Q0.i32 = 1.0 - (float)(v102 + v103);
          *(float *)&_Q0.i32[1] = v104 + v111.f32[0];
          v110 = (float32x4_t)_Q0;
          v110.f32[2] = v105 - *(float *)v108.i32;
          v111.f32[0] = v104 - v111.f32[0];
          v111.f32[1] = 1.0 - (float)(v101 + v103);
          *(float *)v112.i32 = v105 + *(float *)v108.i32;
          *(float *)&v112.i32[1] = v106 - v107;
          v113 = (float32x4_t)v112;
          v113.f32[2] = 1.0 - (float)(v101 + v102);
          v207 = v179;
          v208 = v177;
          v209 = v176;
          v114 = v111;
          do
          {
            v114.f32[2] = v106 + v107;
            *(float32x4_t *)((char *)&v186 + v98 * 4) = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v110, COERCE_FLOAT(*(_OWORD *)((char *)&v207 + v98 * 4))), v114, *(float32x2_t *)&v207.f32[v98], 1), v113, *(float32x4_t *)((char *)&v207 + v98 * 4), 2);
            v98 += 4;
          }
          while (v98 != 12);
          v115 = 0;
          v116 = v186;
          v117 = (float32x4_t)v187;
          v118 = v188;
          v119 = vzip1q_s32(_Q0, v112);
          v120 = vzip1q_s32(v119, (int32x4_t)v111);
          v120.i32[3] = v180.i32[3];
          v121 = vzip2q_s32(v119, vdupq_lane_s32(*(int32x2_t *)v111.f32, 1));
          v121.i32[3] = v181.i32[3];
          *(float *)v108.i32 = v106 + v107;
          v122 = vzip1q_s32(vzip2q_s32((int32x4_t)v110, (int32x4_t)v113), v108);
          v122.i32[3] = v182.i32[3];
          v207 = (float32x4_t)v120;
          v208 = v121;
          v209 = v122;
          do
          {
            *(float32x4_t *)((char *)&v186 + v115 * 4) = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v116, COERCE_FLOAT(*(_OWORD *)((char *)&v207 + v115 * 4))), v117, *(float32x2_t *)&v207.f32[v115], 1), v118, *(float32x4_t *)((char *)&v207 + v115 * 4), 2);
            v115 += 4;
          }
          while (v115 != 12);
          v123 = v186.i32[2];
          v124 = v187;
          v125 = v188;
          v126 = v175 + 48 * v93;
          *(_QWORD *)v126 = v186.i64[0];
          *(_DWORD *)(v126 + 8) = v123;
          *(_QWORD *)(v126 + 16) = v124.i64[0];
          *(_DWORD *)(v126 + 24) = v124.i32[2];
          *(_QWORD *)(v126 + 32) = v125.i64[0];
          *(_DWORD *)(v126 + 40) = v125.i32[2];
          ++v93;
          v53 = v200;
        }
        while (v93 < v200);
        v92 = 1;
        v55 = (unint64_t)v171;
      }
      goto LABEL_114;
    }
  }
LABEL_158:
  this = v199[0];
  if (v199[0])
  {
    if (v202)
      return (*(uint64_t (**)(void))(*(_QWORD *)v199[0] + 40))();
  }
  return this;
}

BOOL re::PhysXPhysicsSimulation::isInitialized(re::PhysXPhysicsSimulation *this)
{
  return *((_QWORD *)this + 119) != 0;
}

uint64_t re::PhysXPhysicsSimulation::services(re::PhysXPhysicsSimulation *this)
{
  return *((_QWORD *)this + 118);
}

uint64_t physx::PxSimulationStatistics::PxSimulationStatistics(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v1 = 0;
  *(_QWORD *)this = 0;
  *(_QWORD *)(this + 8) = 0;
  *(_QWORD *)(this + 16) = 0;
  *(_OWORD *)(this + 52) = 0u;
  *(_OWORD *)(this + 68) = 0u;
  *(_OWORD *)(this + 84) = 0u;
  v2 = this;
  *(_OWORD *)(this + 100) = 0u;
  do
  {
    v3 = 0;
    v4 = this + 28 * v1;
    *(_QWORD *)(v4 + 124) = 0;
    *(_QWORD *)(v4 + 116) = 0;
    *(_DWORD *)(v4 + 140) = 0;
    *(_QWORD *)(v4 + 132) = 0;
    *(_QWORD *)(v4 + 320) = 0;
    *(_QWORD *)(v4 + 328) = 0;
    *(_QWORD *)(v4 + 312) = 0;
    *(_DWORD *)(v4 + 336) = 0;
    do
    {
      v5 = v2 + v3;
      *(_DWORD *)(v5 + 508) = 0;
      *(_DWORD *)(v5 + 704) = 0;
      v3 += 4;
    }
    while (v3 != 28);
    ++v1;
    v2 += 28;
  }
  while (v1 != 7);
  *(_QWORD *)(this + 24) = 0;
  *(_QWORD *)(this + 32) = 0;
  *(_DWORD *)(this + 48) = 0;
  *(_QWORD *)(this + 40) = 0;
  return this;
}

void re::AssetDeduplication::deduplicate(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  __int128 v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  int *v11;
  int v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t *v21;
  uint64_t v22;
  re::AssetHandle *v23;
  __n128 v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unsigned int v34;
  unsigned int v35;
  uint64_t v36;
  int *v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  unint64_t *v43;
  unint64_t v44;
  re::AssetHandle *v45;
  re::AssetHandle *v46;
  re::AssetHandle *v47;
  uint64_t v48;
  _QWORD *v49;
  char *v50;
  unint64_t v51;
  unint64_t *v52;
  uint64_t v53;
  re *v54;
  NSObject *v55;
  unint64_t v56;
  _QWORD *v57;
  char *v58;
  _QWORD *v59;
  char *v60;
  unsigned int v61;
  unsigned int v62;
  uint64_t v63;
  uint64_t v64;
  int *v65;
  int v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  int v70;
  int v71;
  NSObject *v72;
  unsigned int v73;
  unint64_t v74;
  char v75[8];
  __int128 v76;
  __int128 v77;
  _QWORD v78[4];
  int v79;
  __int16 v80;
  _QWORD v81[2];
  _QWORD v82[3];
  __int128 v83;
  __int128 v84;
  unsigned int v85;
  uint64_t v86;
  __int128 v87;
  __int128 v88;
  unsigned int v89;
  uint64_t v90;
  unint64_t v91;
  uint64_t v92;
  uint64_t v93;
  int v94;
  uint64_t v95;
  uint8_t buf[24];
  char *v97;
  uint64_t v98;
  uint64_t v99;

  v99 = *MEMORY[0x24BDAC8D0];
  v89 = 0;
  v5 = 0uLL;
  v87 = 0u;
  v88 = 0u;
  v90 = 0x7FFFFFFFLL;
  v6 = *(_QWORD *)(a1 + 8);
  if (v6)
  {
    v7 = *(_QWORD *)a1;
    v8 = 24 * v6;
    do
    {
      v7 += 24;
      v8 -= 24;
    }
    while (v8);
    v9 = v89;
    v5 = 0uLL;
  }
  else
  {
    v9 = 0;
  }
  *(_DWORD *)(a3 + 32) = 0;
  *(_OWORD *)a3 = v5;
  *(_OWORD *)(a3 + 16) = v5;
  *(_QWORD *)(a3 + 36) = 0x7FFFFFFFLL;
  v85 = 0;
  v83 = v5;
  v84 = v5;
  v86 = 0x7FFFFFFFLL;
  v82[1] = 0;
  v82[2] = 0;
  v82[0] = *(_QWORD *)(a2 + 1104);
  v10 = 0;
  if (v9)
  {
    v11 = (int *)(v88 + 8);
    while (1)
    {
      v12 = *v11;
      v11 += 10;
      if (v12 < 0)
        break;
      if (v9 == ++v10)
      {
        LODWORD(v10) = v9;
        break;
      }
    }
  }
  if (v9 == (_DWORD)v10)
  {
    v13 = 0;
LABEL_64:
    LODWORD(v36) = 0;
    goto LABEL_65;
  }
  v14 = v10;
  v15 = v88;
  do
  {
    v16 = v15 + 40 * v14;
    v19 = *(_QWORD *)(v16 + 24);
    v18 = v16 + 24;
    v17 = v19;
    if (v19)
    {
      v20 = *(uint64_t **)(v17 + 264);
      v21 = re::TextureAsset::assetType((re::TextureAsset *)a1);
      if (v20 == v21)
        goto LABEL_20;
    }
    else
    {
      v21 = re::TextureAsset::assetType((re::TextureAsset *)a1);
    }
    if (*(_QWORD *)v18)
    {
      v22 = *(_QWORD *)(*(_QWORD *)v18 + 264);
      a1 = (uint64_t)re::MeshAsset::assetType((re::MeshAsset *)v21);
      if (v22 == a1)
      {
LABEL_20:
        v23 = (re::AssetHandle *)(v18 - 8);
        v98 = 0;
        memset(buf, 0, sizeof(buf));
        LODWORD(v97) = 0;
        v81[0] = &off_24ED7C100;
        v81[1] = buf;
        v78[0] = v82;
        memset(&v78[1], 0, 24);
        v79 = 2;
        v80 = 256;
        v24 = re::AssetUtilities::saveAssetHandleToStream(v23, (uint64_t)v81, (uint64_t)v78, (uint64_t)v75);
        if (!v75[0] && (_QWORD)v76)
        {
          if ((BYTE8(v76) & 1) != 0)
            (*(void (**)(__n128))(*(_QWORD *)v76 + 40))(v24);
          v76 = 0u;
          v77 = 0u;
        }
        if (*(_QWORD *)&buf[16])
        {
          MurmurHash3_x64_128(v98, *(int *)&buf[16], 0, &v91);
          v25 = (v92 + (v91 << 6) + (v91 >> 2) - 0x61C8864680B583E9) ^ v91;
        }
        else
        {
          v25 = 0;
        }
        v74 = v25;
        v26 = v83;
        v27 = 0x94D049BB133111EBLL
            * ((0xBF58476D1CE4E5B9 * (v25 ^ (v25 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v25 ^ (v25 >> 30))) >> 27));
        v28 = v27 ^ (v27 >> 31);
        if ((_QWORD)v83)
        {
          v29 = *(unsigned int *)(*((_QWORD *)&v83 + 1) + 4 * (v28 % DWORD2(v84)));
          if ((_DWORD)v29 != 0x7FFFFFFF)
          {
            if (*(_QWORD *)(v84 + (v29 << 6) + 16) == v25)
              goto LABEL_41;
            while (1)
            {
              v29 = *(_DWORD *)(v84 + (v29 << 6) + 8) & 0x7FFFFFFF;
              if ((_DWORD)v29 == 0x7FFFFFFF)
                break;
              if (*(_QWORD *)(v84 + (v29 << 6) + 16) == v25)
                goto LABEL_38;
            }
          }
          v95 = 0;
          v92 = 0;
          v93 = 0;
          v91 = 0;
          v94 = 0;
          v30 = v28 % DWORD2(v84);
          v31 = *(unsigned int *)(*((_QWORD *)&v83 + 1) + 4 * v30);
          if ((_DWORD)v31 != 0x7FFFFFFF)
          {
            while (*(_QWORD *)(v84 + (v31 << 6) + 16) != v25)
            {
              v31 = *(_DWORD *)(v84 + (v31 << 6) + 8) & 0x7FFFFFFF;
              if ((_DWORD)v31 == 0x7FFFFFFF)
                goto LABEL_36;
            }
            goto LABEL_37;
          }
        }
        else
        {
          LODWORD(v30) = 0;
          v95 = 0;
          v92 = 0;
          v93 = 0;
          v91 = 0;
          v94 = 0;
        }
LABEL_36:
        re::HashTable<unsigned long,re::DynamicArray<re::AssetHandle>,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::addAsMove((uint64_t)&v83, v30, v28, &v74, (uint64_t)&v91);
        ++HIDWORD(v86);
        v26 = v83;
LABEL_37:
        re::DynamicArray<re::AssetHandle>::deinit((uint64_t)&v91);
LABEL_38:
        if (!v26)
        {
          v32 = v84;
          goto LABEL_44;
        }
LABEL_41:
        v32 = v84;
        v33 = *(unsigned int *)(*((_QWORD *)&v83 + 1) + 4 * (v28 % DWORD2(v84)));
        if ((_DWORD)v33 != 0x7FFFFFFF)
        {
          while (*(_QWORD *)(v84 + (v33 << 6) + 16) != v25)
          {
            v33 = *(_DWORD *)(v84 + (v33 << 6) + 8) & 0x7FFFFFFF;
            if (v33 == 0x7FFFFFFF)
              goto LABEL_44;
          }
          goto LABEL_45;
        }
LABEL_44:
        v33 = 0x7FFFFFFFLL;
LABEL_45:
        re::DynamicArray<re::AssetHandle>::add((_anonymous_namespace_ *)(v32 + (v33 << 6) + 24), v23);
        a1 = *(_QWORD *)buf;
        if (*(_QWORD *)buf && v98)
          a1 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)buf + 40))(*(_QWORD *)buf);
      }
    }
    else
    {
      a1 = (uint64_t)re::MeshAsset::assetType((re::MeshAsset *)v21);
    }
    v15 = v88;
    if (v89 <= (int)v10 + 1)
      v34 = v10 + 1;
    else
      v34 = v89;
    while (1)
    {
      v14 = (v10 + 1);
      if (v34 - 1 == (_DWORD)v10)
        break;
      LODWORD(v10) = v10 + 1;
      v35 = v14;
      if ((*(_DWORD *)(v88 + 40 * v14 + 8) & 0x80000000) != 0)
        goto LABEL_58;
    }
    v35 = v34;
LABEL_58:
    LODWORD(v10) = v35;
  }
  while (v9 != v35);
  v13 = v85;
  if (!v85)
    goto LABEL_64;
  v36 = 0;
  v37 = (int *)(v84 + 8);
  while (1)
  {
    v38 = *v37;
    v37 += 16;
    if (v38 < 0)
      break;
    if (v85 == ++v36)
    {
      LODWORD(v36) = v85;
      break;
    }
  }
LABEL_65:
  if (v13 != (_DWORD)v36)
  {
    v39 = v36;
    v40 = v84;
    v73 = v13;
    while (1)
    {
      v41 = v40 + (v39 << 6);
      v44 = *(_QWORD *)(v41 + 40);
      v43 = (unint64_t *)(v41 + 40);
      v42 = v44;
      v45 = (re::AssetHandle *)v43[2];
      if (v44 < 2)
        break;
      v47 = (re::AssetHandle *)((char *)v45 + 24);
      v48 = 24 * v42 - 24;
      do
      {
        v49 = re::AssetHandle::assetInfo(v47);
        if ((v49[13] & 1) != 0)
          v50 = (char *)v49[14];
        else
          v50 = (char *)v49 + 105;
        a1 = (uint64_t)re::AssetHandle::assetInfo(v45);
        v51 = *(_QWORD *)(a1 + 112);
        if ((*(_BYTE *)(a1 + 104) & 1) == 0)
          v51 = a1 + 105;
        if ((unint64_t)v50 < v51)
          v45 = v47;
        v47 = (re::AssetHandle *)((char *)v47 + 24);
        v48 -= 24;
      }
      while (v48);
      v46 = (re::AssetHandle *)v43[2];
      v42 = *v43;
      if (*v43)
        goto LABEL_80;
LABEL_91:
      if (v73 <= (int)v36 + 1)
        v61 = v36 + 1;
      else
        v61 = v73;
      while (1)
      {
        v39 = (v36 + 1);
        if (v61 - 1 == (_DWORD)v36)
          break;
        LODWORD(v36) = v36 + 1;
        v62 = v39;
        if ((*(_DWORD *)(v40 + (v39 << 6) + 8) & 0x80000000) != 0)
          goto LABEL_98;
      }
      v62 = v61;
LABEL_98:
      LODWORD(v36) = v62;
      if (v73 == v62)
        goto LABEL_99;
    }
    v46 = (re::AssetHandle *)v43[2];
    if (!v42)
      goto LABEL_91;
LABEL_80:
    v52 = v43 - 3;
    v53 = 24 * v42;
    do
    {
      v54 = (re *)re::HashTable<re::AssetHandle,re::AssetHandle,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::add(a3, v46, v45);
      v55 = *re::pipelineLogObjects(v54);
      a1 = os_log_type_enabled(v55, OS_LOG_TYPE_DEBUG);
      if ((_DWORD)a1)
      {
        v56 = *v52;
        v57 = re::AssetHandle::assetInfo(v46);
        if ((v57[17] & 1) != 0)
          v58 = (char *)v57[18];
        else
          v58 = (char *)v57 + 137;
        v59 = re::AssetHandle::assetInfo(v45);
        if ((v59[17] & 1) != 0)
          v60 = (char *)v59[18];
        else
          v60 = (char *)v59 + 137;
        *(_DWORD *)buf = 134218498;
        *(_QWORD *)&buf[4] = v56;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = v58;
        *(_WORD *)&buf[22] = 2080;
        v97 = v60;
        _os_log_debug_impl(&dword_224FE9000, v55, OS_LOG_TYPE_DEBUG, "AssetDeduplication: Computed hash %zu (matching '%s') for asset '%s'", buf, 0x20u);
      }
      v46 = (re::AssetHandle *)((char *)v46 + 24);
      v53 -= 24;
    }
    while (v53);
    goto LABEL_91;
  }
LABEL_99:
  v63 = *(unsigned int *)(a3 + 32);
  if ((_DWORD)v63)
  {
    v64 = 0;
    v65 = (int *)(*(_QWORD *)(a3 + 16) + 8);
    while (1)
    {
      v66 = *v65;
      v65 += 16;
      if (v66 < 0)
        break;
      if (v63 == ++v64)
      {
        LODWORD(v64) = *(_DWORD *)(a3 + 32);
        break;
      }
    }
  }
  else
  {
    LODWORD(v64) = 0;
  }
  if ((_DWORD)v63 == (_DWORD)v64)
  {
    v67 = 0;
  }
  else
  {
    v67 = 0;
    v68 = v64;
    v69 = *(_QWORD *)(a3 + 16);
    do
    {
      if (*(_QWORD *)(v69 + (v68 << 6) + 24) != *(_QWORD *)(v69 + (v68 << 6) + 48))
        ++v67;
      if (v63 <= (int)v64 + 1)
        v70 = v64 + 1;
      else
        v70 = *(_DWORD *)(a3 + 32);
      v71 = v64;
      while (1)
      {
        v68 = (v71 + 1);
        if (v70 - 1 == v71)
          break;
        ++v71;
        LODWORD(v64) = v68;
        if ((*(_DWORD *)(v69 + (v68 << 6) + 8) & 0x80000000) != 0)
          goto LABEL_118;
      }
      LODWORD(v64) = v70;
LABEL_118:
      ;
    }
    while ((_DWORD)v63 != (_DWORD)v64);
  }
  v72 = *re::pipelineLogObjects((re *)a1);
  if (os_log_type_enabled(v72, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 134218240;
    *(_QWORD *)&buf[4] = v67;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = HIDWORD(v88);
    _os_log_debug_impl(&dword_224FE9000, v72, OS_LOG_TYPE_DEBUG, "AssetDeduplication: Deduplicated %li assets out of %u", buf, 0x12u);
  }
  re::HashTable<unsigned long,re::DynamicArray<re::AssetHandle>,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::deinit((uint64_t *)&v83);
  re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)&v87);
}

uint64_t re::`anonymous namespace'::gatherDependencies(uint64_t result, uint64_t a2, uint64_t a3)
{
  re::AssetHandle *v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD v8[2];
  uint64_t v9;
  uint64_t v10;

  if (*(_QWORD *)(result + 8))
  {
    v5 = (re::AssetHandle *)result;
    result = re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::contains(a3, result);
    if ((result & 1) == 0)
    {
      re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::add(a3, v5);
      (*(void (**)(_QWORD *__return_ptr, uint64_t, re::AssetHandle *))(*(_QWORD *)a2 + 280))(v8, a2, v5);
      if (v9)
      {
        v6 = v10;
        v7 = 24 * v9;
        do
        {
          v6 += 24;
          v7 -= 24;
        }
        while (v7);
      }
      return re::DynamicArray<re::AssetHandle>::deinit((uint64_t)v8);
    }
  }
  return result;
}

void re::AssetDeduplication::remap(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6;
  uint64_t v7;
  int *v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _BOOL8 v18;
  uint64_t v19;
  NSObject *v20;
  _QWORD *v21;
  char *v22;
  _QWORD *v23;
  char *v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  uint64_t v28;
  int v29;
  int v30;
  uint64_t v31;
  unint64_t v32;
  char v33[8];
  unint64_t v34;
  uint8_t buf[4];
  char *v36;
  __int16 v37;
  char *v38;
  uint64_t v39;

  v39 = *MEMORY[0x24BDAC8D0];
  *(_DWORD *)(a3 + 32) = 0;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_QWORD *)(a3 + 36) = 0x7FFFFFFFLL;
  v6 = *(unsigned int *)(a2 + 32);
  if ((_DWORD)v6)
  {
    v7 = 0;
    v8 = (int *)(*(_QWORD *)(a2 + 16) + 8);
    while (1)
    {
      v9 = *v8;
      v8 += 18;
      if (v9 < 0)
        break;
      if (v6 == ++v7)
      {
        LODWORD(v7) = *(_DWORD *)(a2 + 32);
        break;
      }
    }
  }
  else
  {
    LODWORD(v7) = 0;
  }
  if ((_DWORD)v6 != (_DWORD)v7)
  {
    v10 = v7;
    v11 = *(_QWORD *)(a2 + 16);
    do
    {
      re::AssetHandle::AssetHandle((re::AssetHandle *)v33, (const re::AssetHandle *)(v11 + 72 * v10 + 16));
      re::AssetHandle::AssetHandle((re::AssetHandle *)&v31, (const re::AssetHandle *)v33);
      if (!re::HashTable<re::AssetHandle,re::AssetHandle,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::containsKey(a1, (uint64_t)v33))goto LABEL_20;
      if (*(_QWORD *)a1)
      {
        if (v34)
          v12 = *(_QWORD *)(v34 + 664);
        else
          v12 = 0;
        v14 = 0x94D049BB133111EBLL
            * ((0xBF58476D1CE4E5B9 * (v34 ^ (v34 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v34 ^ (v34 >> 30))) >> 27));
        v15 = (v12 ^ (v14 >> 31) ^ v14) % *(unsigned int *)(a1 + 24);
        v13 = *(_QWORD *)(a1 + 16);
        v16 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v15);
        if ((_DWORD)v16 != 0x7FFFFFFF)
        {
          do
          {
            v17 = v13 + (v16 << 6);
            if (*(_QWORD *)(v17 + 24) == v34)
              goto LABEL_19;
            v16 = *(_DWORD *)(v17 + 8) & 0x7FFFFFFF;
          }
          while (v16 != 0x7FFFFFFF);
        }
      }
      else
      {
        v13 = *(_QWORD *)(a1 + 16);
      }
      v16 = 0x7FFFFFFFLL;
LABEL_19:
      re::AssetHandle::operator=(&v31, (uint64_t *)(v13 + (v16 << 6) + 40));
LABEL_20:
      v18 = re::HashTable<re::AssetHandle,re::DynamicString,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::containsKey(a2, (uint64_t)&v31);
      if (v18)
      {
        if (*(_QWORD *)a2)
        {
          if (v32)
            v19 = *(_QWORD *)(v32 + 664);
          else
            v19 = 0;
          v26 = 0x94D049BB133111EBLL
              * ((0xBF58476D1CE4E5B9 * (v32 ^ (v32 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v32 ^ (v32 >> 30))) >> 27));
          v27 = (v19 ^ (v26 >> 31) ^ v26) % *(unsigned int *)(a2 + 24);
          v25 = *(_QWORD *)(a2 + 16);
          v28 = *(unsigned int *)(*(_QWORD *)(a2 + 8) + 4 * v27);
          if ((_DWORD)v28 != 0x7FFFFFFF)
          {
            while (*(_QWORD *)(v25 + 72 * v28 + 24) != v32)
            {
              v28 = *(_DWORD *)(v25 + 72 * v28 + 8) & 0x7FFFFFFF;
              if (v28 == 0x7FFFFFFF)
                goto LABEL_37;
            }
            goto LABEL_38;
          }
        }
        else
        {
          v25 = *(_QWORD *)(a2 + 16);
        }
LABEL_37:
        v28 = 0x7FFFFFFFLL;
LABEL_38:
        re::HashTable<re::AssetHandle,re::DynamicString,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::add(a3, (re::AssetHandle *)v33, (const re::DynamicString *)(v25 + 72 * v28 + 40));
        goto LABEL_39;
      }
      v20 = *re::pipelineLogObjects((re *)v18);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
      {
        v21 = re::AssetHandle::assetInfo((re::AssetHandle *)v33);
        if ((v21[17] & 1) != 0)
          v22 = (char *)v21[18];
        else
          v22 = (char *)v21 + 137;
        v23 = re::AssetHandle::assetInfo((re::AssetHandle *)&v31);
        if ((v23[17] & 1) != 0)
          v24 = (char *)v23[18];
        else
          v24 = (char *)v23 + 137;
        *(_DWORD *)buf = 136315394;
        v36 = v22;
        v37 = 2080;
        v38 = v24;
        _os_log_debug_impl(&dword_224FE9000, v20, OS_LOG_TYPE_DEBUG, "Found a duplicate asset '%s' (equal to '%s') that is not remapped. Leaving it unchanged.", buf, 0x16u);
      }
LABEL_39:
      re::AssetHandle::~AssetHandle((re::AssetHandle *)&v31);
      re::AssetHandle::~AssetHandle((re::AssetHandle *)v33);
      v11 = *(_QWORD *)(a2 + 16);
      if (*(_DWORD *)(a2 + 32) <= (v7 + 1))
        v29 = v7 + 1;
      else
        v29 = *(_DWORD *)(a2 + 32);
      while (1)
      {
        v10 = (v7 + 1);
        if (v29 - 1 == (_DWORD)v7)
          break;
        LODWORD(v7) = v7 + 1;
        v30 = v10;
        if ((*(_DWORD *)(v11 + 72 * v10 + 8) & 0x80000000) != 0)
          goto LABEL_46;
      }
      v30 = v29;
LABEL_46:
      LODWORD(v7) = v30;
    }
    while ((_DWORD)v6 != v30);
  }
}

double re::HashTable<unsigned long,re::DynamicArray<re::AssetHandle>,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t i;
  uint64_t v6;
  int v7;
  double result;

  v2 = *a1;
  if (v2)
  {
    v3 = *((unsigned int *)a1 + 8);
    if ((_DWORD)v3)
    {
      v4 = 0;
      for (i = 0; i < v3; ++i)
      {
        v6 = a1[2] + v4;
        v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
          re::DynamicArray<re::AssetHandle>::deinit(v6 + 24);
          v3 = *((unsigned int *)a1 + 8);
        }
        v4 += 64;
      }
      v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

void re::HashTable<unsigned long,re::DynamicArray<re::AssetHandle>,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, _QWORD *a4, uint64_t a5)
{
  uint64_t v9;
  int v10;
  int v11;
  signed int v12;
  uint64_t v13;
  BOOL v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  __int128 v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  signed int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _BYTE v28[44];

  v9 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
    v9 = *(unsigned int *)(a1 + 32);
    v10 = v9;
    if ((_DWORD)v9 == *(_DWORD *)(a1 + 24))
    {
      v11 = *(_DWORD *)(a1 + 28);
      v12 = 2 * v11;
      v13 = *(_QWORD *)a1;
      if (*(_QWORD *)a1)
      {
        if (v12)
          v14 = (_DWORD)v9 == v12;
        else
          v14 = 1;
        if (!v14 && (v11 & 0x80000000) == 0)
        {
          memset(v28, 0, 36);
          *(_QWORD *)&v28[36] = 0x7FFFFFFFLL;
          re::HashTable<unsigned long long,re::Function<void ()(void)>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init((uint64_t)v28, v13, v12);
          v15 = *(_OWORD *)v28;
          *(_OWORD *)v28 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v15;
          v16 = *(_QWORD *)&v28[16];
          v17 = *(_QWORD *)(a1 + 16);
          *(_QWORD *)&v28[16] = v17;
          *(_QWORD *)(a1 + 16) = v16;
          v19 = *(_OWORD *)&v28[24];
          *(_OWORD *)&v28[24] = *(_OWORD *)(a1 + 24);
          v18 = *(_DWORD *)&v28[32];
          *(_OWORD *)(a1 + 24) = v19;
          v20 = v18;
          if (v18)
          {
            v21 = v17 + 16;
            do
            {
              if ((*(_DWORD *)(v21 - 8) & 0x80000000) != 0)
                re::HashTable<unsigned long,re::DynamicArray<re::AssetHandle>,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::addAsMove(a1, *(_QWORD *)(v21 - 16) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(v21 - 16), v21, v21 + 8);
              v21 += 64;
              --v20;
            }
            while (v20);
          }
          re::HashTable<unsigned long,re::DynamicArray<re::AssetHandle>,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::deinit((uint64_t *)v28);
        }
      }
      else
      {
        if (v12)
          v24 = 2 * v11;
        else
          v24 = 3;
      }
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    v22 = *(_QWORD *)(a1 + 16);
    v23 = *(_DWORD *)(v22 + (v9 << 6) + 8);
  }
  else
  {
    v22 = *(_QWORD *)(a1 + 16);
    v23 = *(_DWORD *)(v22 + (v9 << 6) + 8);
    *(_DWORD *)(a1 + 36) = v23 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v22 + (v9 << 6) + 8) = v23 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + (v9 << 6) + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + (v9 << 6) + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + (v9 << 6)) = a3;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + (v9 << 6) + 16) = *a4;
  v25 = *(_QWORD *)(a1 + 16) + (v9 << 6);
  *(_QWORD *)(v25 + 56) = 0;
  *(_DWORD *)(v25 + 48) = 0;
  *(_QWORD *)(v25 + 32) = 0;
  *(_QWORD *)(v25 + 40) = 0;
  *(_QWORD *)(v25 + 24) = 0;
  *(_QWORD *)(v25 + 24) = *(_QWORD *)a5;
  *(_QWORD *)a5 = 0;
  *(_QWORD *)(v25 + 32) = *(_QWORD *)(a5 + 8);
  *(_QWORD *)(a5 + 8) = 0;
  v26 = *(_QWORD *)(v25 + 40);
  *(_QWORD *)(v25 + 40) = *(_QWORD *)(a5 + 16);
  *(_QWORD *)(a5 + 16) = v26;
  v27 = *(_QWORD *)(v25 + 56);
  *(_QWORD *)(v25 + 56) = *(_QWORD *)(a5 + 32);
  *(_QWORD *)(a5 + 32) = v27;
  ++*(_DWORD *)(a5 + 24);
  ++*(_DWORD *)(v25 + 48);
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
}

void ___ZN2re35pipelineHighFrequencyLoggingEnabledEv_block_invoke(uint64_t a1, const char *a2)
{
  re *v2;
  unsigned __int8 v3;
  NSObject *v4;
  _DWORD v5[2];
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  re::Defaults::BOOLValue((re::Defaults *)"enablePipelineHFLogs", a2, (char *)v5);
  if (LOBYTE(v5[0]))
    v3 = BYTE1(v5[0]);
  else
    v3 = 0;
  re::pipelineLogObjects(v2);
  v4 = re::pipelineLogObjects(void)::logObjects;
  if (os_log_type_enabled((os_log_t)re::pipelineLogObjects(void)::logObjects, OS_LOG_TYPE_DEFAULT))
  {
    v5[0] = 67109120;
    v5[1] = v3;
    _os_log_impl(&dword_224FE9000, v4, OS_LOG_TYPE_DEFAULT, "enablePipelineHFLogs=%d.", (uint8_t *)v5, 8u);
  }
  re::pipelineHighFrequencyLoggingEnabled(void)::shouldLog = v3;
}

uint64_t *re::pipelineLogObjects(re *this)
{
  unsigned __int8 v1;

  {
    re::pipelineLogObjects(void)::logObjects = (uint64_t)os_log_create("com.apple.re", "Pipeline");
  }
  return &re::pipelineLogObjects(void)::logObjects;
}

uint64_t re::readZipArchiveEntry@<X0>(re *this@<X0>, const char *a2@<X1>, const char *a3@<X2>, uint64_t a4@<X8>)
{
  NSObject *v9;
  uint64_t v10;
  int support_format_zip_seekable;
  uint64_t v12;
  re *next_header;
  int v15;
  const char *v16;
  re *is_set;
  unint64_t v18;
  uint64_t data;
  NSObject *v20;
  re::WrappedError *v21;
  uint64_t v22;
  id v23;
  NSObject *v24;
  uint64_t v25;
  uint64_t v26;
  __int128 v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _BYTE buf[24];
  uint64_t v32;
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  v9 = *re::pipelineLogObjects(this);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = a2;
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = this;
    _os_log_debug_impl(&dword_224FE9000, v9, OS_LOG_TYPE_DEBUG, "Reading archived file '%s' from archive '%s'", buf, 0x16u);
  }
  v30 = archive_read_new();
  if (!v30)
  {
    re::internal::assertLog((re::internal *)4, v10, "assertion failure: '%s' (%s:line %i) archive_read_new() returned null", "ar.get()", "readZipArchiveEntry", 69);
    _os_crash();
    __break(1u);
  }
  support_format_zip_seekable = archive_read_support_format_zip_seekable();
  if (!support_format_zip_seekable)
  {
    support_format_zip_seekable = archive_read_open_filename();
    if (!support_format_zip_seekable)
    {
      v29 = 0;
      while (1)
      {
        next_header = (re *)archive_read_next_header();
        if ((_DWORD)next_header)
        {
          v15 = (int)next_header;
          if ((_DWORD)next_header == 1)
          {
            v20 = *re::pipelineLogObjects(next_header);
            if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136315394;
              *(_QWORD *)&buf[4] = a2;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = this;
              _os_log_error_impl(&dword_224FE9000, v20, OS_LOG_TYPE_ERROR, "No such file '%s' in archive '%s'", buf, 0x16u);
            }
            v21 = (re::WrappedError *)*MEMORY[0x24BDBD390];
            v22 = 2;
            goto LABEL_26;
          }
          if (v15 != -20)
          {
            v23 = *(id *)buf;
            *(_BYTE *)a4 = 0;
            *(_QWORD *)(a4 + 8) = v23;
            goto LABEL_8;
          }

        }
        v16 = (const char *)archive_entry_pathname();
        if (!strcmp(v16, a2))
        {
          is_set = (re *)archive_entry_size_is_set();
          if ((_DWORD)is_set)
          {
            v18 = archive_entry_size();
            *(_QWORD *)&buf[16] = 0;
            v32 = 0;
            *(_QWORD *)buf = a3;
            *(_QWORD *)&buf[8] = 0;
            re::DynamicString::setCapacity(buf, v18 + 1);
            re::DynamicString::resize(buf, v18, 0);
            data = archive_read_data();
            if (data == v18)
            {
              re::DynamicString::DynamicString((re::DynamicString *)&v26, (const re::DynamicString *)buf);
              *(_BYTE *)a4 = 1;
              *(_QWORD *)(a4 + 8) = v26;
              *(_QWORD *)(a4 + 32) = v28;
              *(_OWORD *)(a4 + 16) = v27;
            }
            else
            {
              v25 = v26;
              v26 = 0;
              *(_BYTE *)a4 = 0;
              *(_QWORD *)(a4 + 8) = v25;

            }
            if (*(_QWORD *)buf && (buf[8] & 1) != 0)
              (*(void (**)(void))(**(_QWORD **)buf + 40))();
            return archive_read_free();
          }
          v24 = *re::pipelineLogObjects(is_set);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)buf = 0;
            _os_log_error_impl(&dword_224FE9000, v24, OS_LOG_TYPE_ERROR, "Archive read error: entry size unexpectedly not set", buf, 2u);
          }
          v21 = (re::WrappedError *)*MEMORY[0x24BDBD390];
          v22 = 79;
LABEL_26:
          re::WrappedError::make(v21, (const __CFString *)v22, 0, buf);
          goto LABEL_7;
        }
      }
    }
  }
LABEL_7:
  v12 = *(_QWORD *)buf;
  *(_QWORD *)buf = 0;
  *(_BYTE *)a4 = 0;
  *(_QWORD *)(a4 + 8) = v12;
LABEL_8:

  return archive_read_free();
}

void re::`anonymous namespace'::makeArchiveError(_QWORD *a1, uint64_t a2, int a3)
{
  re *v5;
  int v6;
  NSObject *v7;
  const char *v8;
  NSObject *v9;
  uint32_t v10;
  NSObject *v11;
  int v12;
  int v13;
  __int16 v14;
  _WORD v15[11];

  *(_QWORD *)&v15[7] = *MEMORY[0x24BDAC8D0];
  v5 = (re *)archive_errno();
  v6 = (int)v5;
  if (a3 <= -21)
  {
    if (a3 == -30)
    {
      v7 = *re::pipelineLogObjects(v5);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        v12 = 67109378;
        v13 = v6;
        v14 = 2082;
        *(_QWORD *)v15 = archive_error_string();
        v8 = "Archive read error (fatal) %d: %{public}s";
        goto LABEL_14;
      }
      goto LABEL_18;
    }
    if (a3 == -25)
    {
      v7 = *re::pipelineLogObjects(v5);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        v12 = 67109378;
        v13 = v6;
        v14 = 2082;
        *(_QWORD *)v15 = archive_error_string();
        v8 = "Archive read error %d: %{public}s";
LABEL_14:
        v9 = v7;
        v10 = 18;
LABEL_17:
        _os_log_error_impl(&dword_224FE9000, v9, OS_LOG_TYPE_ERROR, v8, (uint8_t *)&v12, v10);
        goto LABEL_18;
      }
      goto LABEL_18;
    }
LABEL_15:
    v11 = *re::pipelineLogObjects(v5);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      v12 = 67109634;
      v13 = a3;
      v14 = 1024;
      *(_DWORD *)v15 = v6;
      v15[2] = 2082;
      *(_QWORD *)&v15[3] = archive_error_string();
      v8 = "Archive read unexpected result %d, errno %d: %{public}s";
      v9 = v11;
      v10 = 24;
      goto LABEL_17;
    }
    goto LABEL_18;
  }
  if (a3 == -20)
  {
    v7 = *re::pipelineLogObjects(v5);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      v12 = 67109378;
      v13 = v6;
      v14 = 2082;
      *(_QWORD *)v15 = archive_error_string();
      v8 = "Archive read error (partial) %d: %{public}s";
      goto LABEL_14;
    }
    goto LABEL_18;
  }
  if (a3 != -10)
    goto LABEL_15;
  v7 = *re::pipelineLogObjects(v5);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    v12 = 67109378;
    v13 = v6;
    v14 = 2082;
    *(_QWORD *)v15 = archive_error_string();
    v8 = "Archive read error (retryable) %d: %{public}s";
    goto LABEL_14;
  }
LABEL_18:
  re::WrappedError::make((re::WrappedError *)*MEMORY[0x24BDBD390], (const __CFString *)v6, 0, a1);
}

double re::ZipArchiveGetDefaultLayerMTimeFromArchive()
{
  double v0;
  char *v1;
  std::string::size_type size;
  std::string *p_str;
  char *v4;
  int v5;
  std::string *p_p;
  char v7;
  std::string __p;
  std::string __str;
  uint64_t v13;
  char v14;

  v13 = 0;
  while (!archive_read_next_header())
  {
    v1 = (char *)archive_entry_pathname();
    std::string::basic_string[abi:nn180100]<0>(&__str, v1);
    size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
    p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      size = __str.__r_.__value_.__l.__size_;
    else
      p_str = &__str;
    v4 = (char *)&p_str[-1].__r_.__value_.__r.__words[2] + 7;
    while (size)
    {
      v5 = v4[size--];
      if (v5 == 46)
        goto LABEL_11;
    }
    size = -1;
LABEL_11:
    std::string::basic_string(&__p, &__str, size + 1, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v14);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      if (__p.__r_.__value_.__l.__size_ == 3)
      {
        if (*(_WORD *)__p.__r_.__value_.__l.__data_ != 29557 || *(_BYTE *)(__p.__r_.__value_.__r.__words[0] + 2) != 100)
        {
LABEL_31:
          v7 = 1;
LABEL_33:
          operator delete(__p.__r_.__value_.__l.__data_);
          goto LABEL_34;
        }
        goto LABEL_32;
      }
      if (__p.__r_.__value_.__l.__size_ != 4)
        goto LABEL_31;
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      if (*(_DWORD *)__p.__r_.__value_.__l.__data_ != 1667527541)
        goto LABEL_19;
    }
    else
    {
      if (HIBYTE(__p.__r_.__value_.__r.__words[2]) == 3)
      {
        if (LOWORD(__p.__r_.__value_.__l.__data_) != 29557 || __p.__r_.__value_.__s.__data_[2] != 100)
        {
LABEL_26:
          v7 = 1;
          goto LABEL_34;
        }
        goto LABEL_32;
      }
      if (HIBYTE(__p.__r_.__value_.__r.__words[2]) != 4)
        goto LABEL_26;
      if (LODWORD(__p.__r_.__value_.__l.__data_) != 1667527541)
      {
        p_p = &__p;
LABEL_19:
        if (LODWORD(p_p->__r_.__value_.__l.__data_) != 1633973109)
        {
          v7 = 1;
          if ((*((_BYTE *)&__p.__r_.__value_.__s + 23) & 0x80) != 0)
            goto LABEL_33;
          goto LABEL_34;
        }
      }
    }
LABEL_32:
    v7 = 0;
    v0 = (double)archive_entry_mtime();
    if ((*((_BYTE *)&__p.__r_.__value_.__s + 23) & 0x80) != 0)
      goto LABEL_33;
LABEL_34:
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__str.__r_.__value_.__l.__data_);
      if ((v7 & 1) == 0)
        return v0;
    }
    else if ((v7 & 1) == 0)
    {
      return v0;
    }
  }
  return 0.0;
}

double re::ZipArchiveGetDefaultLayerMTime(re *this, char *a2, __CFError **a3)
{
  double DefaultLayerMTimeFromArchive;
  const __CFString *v5;
  int v6;

  if (!archive_read_new())
    return 0.0;
  archive_read_support_format_zip();
  if (archive_read_open_filename())
  {
    DefaultLayerMTimeFromArchive = 0.0;
    if (a2)
    {
      v5 = (const __CFString *)*MEMORY[0x24BDBD390];
      v6 = archive_errno();
      *(_QWORD *)a2 = CFErrorCreate(0, v5, v6, 0);
    }
  }
  else
  {
    DefaultLayerMTimeFromArchive = re::ZipArchiveGetDefaultLayerMTimeFromArchive();
  }
  archive_read_free();
  return DefaultLayerMTimeFromArchive;
}

uint64_t re::AssetCompilerRegistry::registerAssetCompiler(uint64_t a1, uint64_t *a2)
{
  unint64_t v2;
  _anonymous_namespace_ *v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  BOOL v10;
  unint64_t v11;
  unint64_t v12;
  _anonymous_namespace_ *v13;
  uint64_t v14;
  unint64_t v15;
  const char *v16;
  _BOOL4 v17;
  _anonymous_namespace_ *v18;
  unint64_t v19;
  const char *v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  const char *v24;
  _BYTE *v25;
  re *v26;
  NSObject *v27;
  uint64_t v28;
  _BYTE *v29;
  uint64_t result;
  re *v31;
  char v32;
  _anonymous_namespace_ *v33;
  char v34;
  _BYTE v35[7];
  _BYTE *v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  _QWORD v43[5];
  _BYTE v44[12];
  __int16 v45;
  int v46;
  __int16 v47;
  unint64_t v48;
  __int16 v49;
  unint64_t v50;
  uint8_t buf[32];
  __int128 v52;
  __int128 v53;
  __int128 v54;
  uint64_t v55;

  v55 = *MEMORY[0x24BDAC8D0];
  v5 = (_anonymous_namespace_ *)(*(_QWORD *(**)(uint64_t *__return_ptr))(*(_QWORD *)*a2 + 32))(&v38);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = *(_QWORD *)(a1 + 24);
  if (v7 >= v6)
  {
    v8 = v7 + 1;
    if (v6 < v7 + 1)
    {
      if (*(_QWORD *)(a1 + 8))
      {
        v9 = 2 * v6;
        v10 = v6 == 0;
        v11 = 8;
        if (!v10)
          v11 = v9;
        if (v11 <= v8)
          v12 = v8;
        else
          v12 = v11;
        re::DynamicArray<std::unique_ptr<re::AssetCompiler,std::function<void ()(re::AssetCompiler*)>>>::setCapacity((_QWORD *)(a1 + 8), v12);
      }
      else
      {
        re::DynamicArray<std::unique_ptr<re::AssetCompiler,std::function<void ()(re::AssetCompiler*)>>>::setCapacity((_QWORD *)(a1 + 8), v8);
        ++*(_DWORD *)(a1 + 32);
      }
    }
    v7 = *(_QWORD *)(a1 + 24);
  }
  v13 = (_anonymous_namespace_ *)std::unique_ptr<void,std::function<void ()(void *)>>::unique_ptr[abi:nn180100]((_QWORD *)(*(_QWORD *)(a1 + 40) + 40 * v7), a2);
  v14 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = v14 + 1;
  ++*(_DWORD *)(a1 + 32);
  v37 = v14;
  if (v39)
  {
    v15 = 0;
    while (1)
    {
      v16 = *(const char **)(v40 + 8 * v15);
      v17 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::containsKey(a1 + 48, (uint64_t)buf);
      v18 = *(_anonymous_namespace_ **)buf;
      if (*(_QWORD *)buf && (buf[8] & 1) != 0)
        v18 = (_anonymous_namespace_ *)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)buf + 40))(*(_QWORD *)buf, *(_QWORD *)&buf[16]);
      if (!v17)
      {
        v19 = v39;
        if (v39 <= v15)
          goto LABEL_54;
        v24 = *(const char **)(v40 + 8 * v15);
        re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<unsigned long &>(a1 + 48, (re::DynamicString *)buf, &v37);
        v13 = *(_anonymous_namespace_ **)buf;
        if (!*(_QWORD *)buf || (buf[8] & 1) == 0)
          goto LABEL_43;
        v25 = *(_BYTE **)&buf[16];
        goto LABEL_42;
      }
      v19 = v39;
      if (v39 <= v15)
      {
        v31 = 0;
        v53 = 0u;
        v54 = 0u;
        v52 = 0u;
        memset(buf, 0, sizeof(buf));
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        *(_DWORD *)v44 = 136315906;
        *(_QWORD *)&v44[4] = "operator[]";
        v45 = 1024;
        v46 = 797;
        v47 = 2048;
        v48 = v15;
        v49 = 2048;
        v50 = v19;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_54:
        *(_QWORD *)v44 = 0;
        v53 = 0u;
        v54 = 0u;
        v52 = 0u;
        memset(buf, 0, sizeof(buf));
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        v42 = 136315906;
        v43[0] = "operator[]";
        v43[1] = 0x8000000031D0400;
        v43[2] = v15;
        LOWORD(v43[3]) = 2048;
        *(_QWORD *)((char *)&v43[3] + 2) = v19;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_55:
        v41 = 0;
        v53 = 0u;
        v54 = 0u;
        v52 = 0u;
        memset(buf, 0, sizeof(buf));
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        *(_DWORD *)v44 = 136315906;
        *(_QWORD *)&v44[4] = "operator[]";
        v45 = 1024;
        v46 = 789;
        v47 = 2048;
        v48 = v19;
        v49 = 2048;
        v50 = v2;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_56:
        *(_QWORD *)v44 = 0;
        v53 = 0u;
        v54 = 0u;
        v52 = 0u;
        memset(buf, 0, sizeof(buf));
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        v42 = 136315906;
        v43[0] = "operator[]";
        v43[1] = 0x8000000031D0400;
        v43[2] = v15;
        LOWORD(v43[3]) = 2048;
        *(_QWORD *)((char *)&v43[3] + 2) = v2;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      v20 = *(const char **)(v40 + 8 * v15);
      v21 = re::Hash<re::DynamicString>::operator()((uint64_t)buf, (uint64_t)&v31);
      if (!*(_QWORD *)(a1 + 48))
        break;
      v22 = *(_QWORD *)(a1 + 64);
      v23 = *(unsigned int *)(*(_QWORD *)(a1 + 56) + 4 * (v21 % *(unsigned int *)(a1 + 72)));
      if ((_DWORD)v23 == 0x7FFFFFFF)
        goto LABEL_29;
      while (!re::DynamicString::operator==(v22 + 56 * v23 + 16, (uint64_t)&v31))
      {
        v23 = *(_DWORD *)(v22 + 56 * v23 + 8) & 0x7FFFFFFF;
        if (v23 == 0x7FFFFFFF)
          goto LABEL_29;
      }
LABEL_30:
      v19 = *(_QWORD *)(v22 + 56 * v23 + 48);
      v2 = *(_QWORD *)(a1 + 24);
      if (v2 <= v19)
        goto LABEL_55;
      (*(void (**)(int *__return_ptr))(**(_QWORD **)(*(_QWORD *)(a1 + 40) + 40 * v19) + 16))(&v42);
      re::DynamicString::DynamicString((re::DynamicString *)&v33, (const re::DynamicString *)((char *)v43 + 4));
      if (*(_QWORD *)((char *)v43 + 4))
      {
        if ((v43[1] & 0x100000000) != 0)
          (*(void (**)(void))(**(_QWORD **)((char *)v43 + 4) + 40))();
        memset((char *)v43 + 4, 0, 32);
      }
      v26 = v31;
      if (v31 && (v32 & 1) != 0)
        v26 = (re *)(*(uint64_t (**)(void))(*(_QWORD *)v31 + 40))();
      v27 = *re::pipelineLogObjects(v26);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      {
        v2 = v39;
        if (v39 <= v15)
          goto LABEL_56;
        v28 = *(_QWORD *)(v40 + 8 * v15);
        v29 = v35;
        if ((v34 & 1) != 0)
          v29 = v36;
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)&buf[4] = v28;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = v29;
        _os_log_error_impl(&dword_224FE9000, v27, OS_LOG_TYPE_ERROR, "This extension %s is already registered for assets of type %s", buf, 0x16u);
      }
      v13 = v33;
      if (v33 && (v34 & 1) != 0)
      {
        v25 = v36;
LABEL_42:
        v13 = (_anonymous_namespace_ *)(*(uint64_t (**)(_anonymous_namespace_ *, _BYTE *))(*(_QWORD *)v13 + 40))(v13, v25);
      }
LABEL_43:
      if (v39 <= ++v15)
        goto LABEL_49;
    }
    v22 = *(_QWORD *)(a1 + 64);
LABEL_29:
    v23 = 0x7FFFFFFFLL;
    goto LABEL_30;
  }
LABEL_49:
  result = v38;
  if (v38)
  {
    if (v40)
      return (*(uint64_t (**)(void))(*(_QWORD *)v38 + 40))();
  }
  return result;
}

uint64_t re::AssetCompilerRegistry::getCompilerForExtension(re::AssetCompilerRegistry *this, char *a2)
{
  char v3;
  char *v4;
  uint64_t v5;
  uint64_t v6;
  BOOL v7;
  unint64_t *v8;
  unint64_t v9;
  unint64_t v10;
  char __s[32];
  int v13;
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  unint64_t v18;
  __int16 v19;
  unint64_t v20;
  _OWORD v21[5];
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  v3 = *a2;
  v4 = __s;
  if (*a2)
  {
    v5 = 0;
    do
    {
      if ((v3 - 65) < 0x1Au)
        v3 += 32;
      __s[v5] = v3;
      v6 = v5 + 1;
      v3 = a2[v5 + 1];
      if (v3)
        v7 = v5 == 30;
      else
        v7 = 1;
      ++v5;
    }
    while (!v7);
    v4 = &__s[v6];
  }
  *v4 = 0;
  v8 = (unint64_t *)re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)this + 48, (uint64_t)v21);
  if (*(_QWORD *)&v21[0] && (BYTE8(v21[0]) & 1) != 0)
    (*(void (**)(void))(**(_QWORD **)&v21[0] + 40))();
  if (!v8)
    return 0;
  v9 = *v8;
  v10 = *((_QWORD *)this + 3);
  if (v10 <= v9)
  {
    memset(v21, 0, sizeof(v21));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v13 = 136315906;
    v14 = "operator[]";
    v15 = 1024;
    v16 = 797;
    v17 = 2048;
    v18 = v9;
    v19 = 2048;
    v20 = v10;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(*((_QWORD *)this + 5) + 40 * v9);
}

uint64_t *re::DynamicArray<std::unique_ptr<re::AssetCompiler,std::function<void ()(re::AssetCompiler*)>>>::clear(uint64_t *result)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t v3;

  v1 = result;
  v2 = result[2];
  result[2] = 0;
  if (v2)
  {
    result = (uint64_t *)result[4];
    v3 = 40 * v2;
    do
    {
      result = std::unique_ptr<re::RigHierarchy,std::function<void ()(re::RigHierarchy*)>>::~unique_ptr[abi:nn180100](result)
             + 5;
      v3 -= 40;
    }
    while (v3);
  }
  ++*((_DWORD *)v1 + 6);
  return result;
}

_QWORD *re::DynamicArray<std::unique_ptr<re::AssetCompiler,std::function<void ()(re::AssetCompiler*)>>>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<std::unique_ptr<re::AssetCompiler,std::function<void ()(re::AssetCompiler*)>>>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x28uLL))
        {
          v2 = 40 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 40 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_16;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 40, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = (uint64_t *)v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = 40 * v9;
        v11 = v7;
        do
        {
          std::unique_ptr<void,std::function<void ()(void *)>>::unique_ptr[abi:nn180100](v11, v8);
          std::unique_ptr<re::RigHierarchy,std::function<void ()(re::RigHierarchy*)>>::~unique_ptr[abi:nn180100](v8);
          v8 += 5;
          v11 += 5;
          v10 -= 40;
        }
        while (v10);
        v8 = (uint64_t *)v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t *))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

uint64_t *re::allocInfo_AssetCompilerService(re *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&_MergedGlobals_422);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&_MergedGlobals_422))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_25411D760, 0);
    *(uint64_t *)((char *)&qword_25411D770 + 6) = 0;
    qword_25411D770 = 0;
    qword_25411D780 = 0;
    qword_25411D788 = 0xFFFFFFFFLL;
    qword_25411D760 = (uint64_t)&off_24ED7DAA8;
    qword_25411D790 = (uint64_t)"AssetCompilerService";
    dword_25411D798 = 0;
    unk_25411D7A0 = 0u;
    unk_25411D7B0 = 0u;
    unk_25411D7C0 = 0u;
    qword_25411D7D0 = 0;
    __cxa_guard_release(&_MergedGlobals_422);
  }
  return &qword_25411D760;
}

void re::initInfo_AssetCompilerService(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  __int128 v4;
  _QWORD v5[2];
  __int128 v6;

  v5[0] = 0x5FF8D78549D7284CLL;
  v5[1] = "AssetCompilerService";
  re::StringID::destroyString((re::StringID *)v5);
  *((_OWORD *)this + 2) = v6;
  *((_QWORD *)this + 2) = 0x800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 8) = &re::initInfo_AssetCompilerService(re::IntrospectionBase *)::structureAttributes;
  re::IntrospectionRegistry::add(this, v3);
  v4 = v6;
}

uint64_t re::introspect_AssetCompilerService(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"AssetCompilerService", (uint64_t (*)(re::internal *))re::allocInfo_AssetCompilerService, (re::IntrospectionBase *(*)(void))re::initInfo_AssetCompilerService, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::AssetCompilerService>, this);
}

uint64_t re::UniqueNameGenerator::uniqueName@<X0>(re::UniqueNameGenerator *this@<X0>, const char *a2@<X1>, const char *a3@<X2>, re::StringID *a4@<X8>)
{
  _DWORD *i;
  uint64_t v8;
  _BYTE *v9;
  _anonymous_namespace_ *v10;
  const char *v11;
  uint64_t result;
  uint64_t v13;
  char v14;
  uint64_t v15;
  char v16;
  _BYTE v17[7];
  _BYTE *v18;

  if (a2 && *a2)
    a3 = a2;
  for (i = (_DWORD *)re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)this, (uint64_t)&v15);
        i;
        i = (_DWORD *)re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)this, (uint64_t)&v15))
  {
    v8 = (*i + 1);
    *i = v8;
    if ((v16 & 1) != 0)
      v9 = v18;
    else
      v9 = v17;
    re::DynamicString::format((re::DynamicString *)"%s[%u]", (re::DynamicString *)&v13, v9, v8);
    re::DynamicString::operator=((re::DynamicString *)&v15, (re::DynamicString *)&v13);
    if (v13 && (v14 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v13 + 40))();
  }
  LODWORD(v13) = 0;
  v10 = (_anonymous_namespace_ *)re::HashTable<re::DynamicString,unsigned int,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<unsigned int &>((uint64_t)this, (re::DynamicString *)&v15, &v13);
  if ((v16 & 1) != 0)
    v11 = v18;
  else
    v11 = v17;
  *(_QWORD *)a4 = 0;
  *((_QWORD *)a4 + 1) = &str_110;
  result = v15;
  if (v15)
  {
    if ((v16 & 1) != 0)
      return (*(uint64_t (**)(void))(*(_QWORD *)v15 + 40))();
  }
  return result;
}

void re::usdkit::Resource::makeWithPath(re::usdkit::Resource *this@<X0>, _QWORD *a2@<X8>)
{
  void *v4;
  id v5;
  id v6;

  v4 = (void *)MEMORY[0x24BEBECF8];
  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", this);
  v6 = (id)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v4, "resourceWithPath:", v6);
  v5 = (id)objc_claimAutoreleasedReturnValue();
  *a2 = v5;

}

void re::usdkit::Resource::makeMappedData(id *this@<X0>, _QWORD *a2@<X8>)
{
  id v3;
  void *v4;
  id v5;
  void *v6;
  id v7;
  id v8;
  id v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t (*v12)();
  void *v13;
  id v14;
  id v15;

  v3 = *this;
  objc_msgSend(v3, "dataNoCopy");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  if (v4)
  {
    v10 = MEMORY[0x24BDAC760];
    v11 = 3221225472;
    v12 = ___ZNK2re6usdkit8Resource14makeMappedDataEv_block_invoke;
    v13 = &unk_24ED7F210;
    v14 = v3;
    v5 = v4;
    v15 = v5;
    v6 = _Block_copy(&v10);
    v7 = objc_alloc(MEMORY[0x24BDBCE50]);
    v8 = objc_retainAutorelease(v5);
    v9 = (id)objc_msgSend(v7, "initWithBytesNoCopy:length:deallocator:", objc_msgSend(v8, "bytes", v10, v11, v12, v13), objc_msgSend(v8, "length"), v6);

  }
  else
  {
    v9 = 0;
  }
  *a2 = v9;

}

re::FrameProfiler *re::FrameProfiler::FrameProfiler(re::FrameProfiler *this)
{
  char *v2;
  double v3;
  _anonymous_namespace_ *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  re::FrameProfiler *result;
  _OWORD v9[2];
  _QWORD v10[2];

  *((_BYTE *)this + 8) = 0;
  *(_QWORD *)this = &off_24ED7F240;
  *((_DWORD *)this + 3) = 0;
  *((_WORD *)this + 8) = 1;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *((_DWORD *)this + 14) = 0;
  *(_QWORD *)((char *)this + 60) = 0x7FFFFFFFLL;
  *(_OWORD *)((char *)this + 88) = 0u;
  *((_DWORD *)this + 26) = 0;
  *(_OWORD *)((char *)this + 72) = 0u;
  v2 = (char *)this + 72;
  *(_QWORD *)((char *)this + 108) = 0x7FFFFFFFLL;
  *((_QWORD *)this + 19) = 0;
  *((_QWORD *)this + 16) = 0;
  *((_QWORD *)this + 17) = 0;
  *((_QWORD *)this + 15) = 0;
  *((_DWORD *)this + 36) = 0;
  *((_DWORD *)this + 44) = 545;
  *((_QWORD *)this + 23) = 0;
  *((_QWORD *)this + 24) = 10;
  *((_DWORD *)this + 50) = 1;
  *((_WORD *)this + 102) = 0;
  *((_BYTE *)this + 206) = 0;
  *((_QWORD *)this + 29) = 0;
  *((_DWORD *)this + 60) = 0;
  *((_QWORD *)this + 31) = 0;
  *((_QWORD *)this + 32) = 0;
  *((_BYTE *)this + 264) = 0;
  *((_QWORD *)this + 34) = 0;
  *((_QWORD *)this + 35) = 0;
  *((_BYTE *)this + 288) = 0;
  *((_BYTE *)this + 296) = 0;
  *((_QWORD *)this + 39) = 0;
  *((_QWORD *)this + 40) = 0;
  *((_DWORD *)this + 82) = 0;
  *((_QWORD *)this + 38) = 0;
  *((_QWORD *)this + 26) = 0;
  *((_QWORD *)this + 27) = 0;
  *((_DWORD *)this + 56) = 0;
  *(_OWORD *)((char *)this + 364) = 0u;
  *((_OWORD *)this + 21) = 0u;
  *((_OWORD *)this + 22) = 0u;
  *(_QWORD *)((char *)this + 380) = 0x7FFFFFFFLL;
  *((_DWORD *)this + 106) = 0;
  *(_OWORD *)((char *)this + 392) = 0u;
  *(_OWORD *)((char *)this + 408) = 0u;
  *(_QWORD *)((char *)this + 428) = 0x7FFFFFFFLL;
  LODWORD(v10[0]) = 0;
  memset(v9, 0, sizeof(v9));
  *(_QWORD *)((char *)v10 + 4) = 0x7FFFFFFFLL;
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=((uint64_t)v2, (uint64_t *)v9);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v9, v3);
  v10[0] = 0;
  memset((char *)v9 + 8, 0, 20);
  re::DynamicArray<float *>::setCapacity(v9, 0xFuLL);
  v6 = *((_QWORD *)this + 15);
  if (v6 && *(_QWORD *)&v9[0] && v6 != *(_QWORD *)&v9[0])
  {
    re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) ", "!isInitialized() || !other.isInitialized() || m_allocator == other.m_allocator", "operator=", 503);
    result = (re::FrameProfiler *)_os_crash();
    __break(1u);
  }
  else
  {
    *((_QWORD *)this + 15) = *(_QWORD *)&v9[0];
    *((_OWORD *)this + 8) = *(_OWORD *)((char *)v9 + 8);
    v7 = *((_QWORD *)this + 19);
    *((_QWORD *)this + 19) = v10[0];
    ++*((_DWORD *)this + 36);
    if (v6)
    {
      if (v7)
        (*(void (**)(uint64_t))(*(_QWORD *)v6 + 40))(v6);
    }
    return this;
  }
  return result;
}

uint64_t re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    if (!*(_QWORD *)a1 || *(_QWORD *)a1 == *a2)
    {
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)a1, a2);
    }
    else if (*a2)
    {
      re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::copy(a1, (uint64_t)a2);
      ++*(_DWORD *)(a1 + 40);
    }
    else
    {
      re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear(a1);
    }
  }
  return a1;
}

void re::FrameProfiler::~FrameProfiler(re::FrameProfiler *this)
{
  re *v2;
  double v3;
  uint64_t v4;
  re::FrameCustomStats **v5;
  uint64_t v6;
  re::FrameCustomStats *v7;
  uint64_t v8;
  double v9;
  _QWORD *v10;
  double v11;
  uint64_t v12;
  __n128 v13;
  uint64_t v14;
  __n128 *v15;
  uint64_t v16;
  uint64_t v17;

  re::FrameProfiler::deinit(this);
  v4 = *((_QWORD *)this + 17);
  if (v4)
  {
    v5 = (re::FrameCustomStats **)*((_QWORD *)this + 19);
    v6 = 8 * v4;
    do
    {
      v7 = *v5++;
      *((_BYTE *)v7 + 64) = 0;
      v8 = re::globalAllocators(v2)[2];
      re::FrameCustomStats::~FrameCustomStats(v7, v9);
      v2 = (re *)(*(uint64_t (**)(uint64_t, re::FrameCustomStats *))(*(_QWORD *)v8 + 40))(v8, v7);
      v6 -= 8;
    }
    while (v6);
  }
  v10 = (_QWORD *)((char *)this + 120);
  v11 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 9, v3);
  v12 = *((_QWORD *)this + 15);
  if (v12)
  {
    if (*((_QWORD *)this + 19))
      (*(void (**)(uint64_t, double))(*(_QWORD *)v12 + 40))(v12, v11);
    *((_QWORD *)this + 19) = 0;
    *((_QWORD *)this + 16) = 0;
    *((_QWORD *)this + 17) = 0;
    *v10 = 0;
    ++*((_DWORD *)this + 36);
  }
  re::HashTable<unsigned long long,re::ecs2::RenderPassGroupBoundsInfo,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)this + 49);
  v13.n128_f64[0] = re::HashTable<unsigned long long,re::ecs2::RenderPassGroupBoundsInfo,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)this + 43);
  v14 = *((_QWORD *)this + 38);
  if (v14)
  {
    v15 = (__n128 *)*((_QWORD *)this + 42);
    if (v15)
    {
      v16 = *((_QWORD *)this + 40);
      if (v16)
      {
        v17 = 48 * v16;
        v13 = 0uLL;
        do
        {
          if (v15->n128_u64[0])
          {
            if ((v15->n128_u8[8] & 1) != 0)
            {
              (*(void (**)(unint64_t, unint64_t, __n128))(*(_QWORD *)v15->n128_u64[0] + 40))(v15->n128_u64[0], v15[1].n128_u64[0], v13);
              v13 = 0uLL;
            }
            *v15 = v13;
            v15[1] = v13;
          }
          v15 += 3;
          v17 -= 48;
        }
        while (v17);
        v14 = *((_QWORD *)this + 38);
        v15 = (__n128 *)*((_QWORD *)this + 42);
      }
      (*(void (**)(uint64_t, __n128 *, __n128))(*(_QWORD *)v14 + 40))(v14, v15, v13);
    }
    *((_QWORD *)this + 42) = 0;
    *((_QWORD *)this + 39) = 0;
    *((_QWORD *)this + 40) = 0;
    *((_QWORD *)this + 38) = 0;
    ++*((_DWORD *)this + 82);
  }
  if (*v10)
  {
    if (*((_QWORD *)this + 19))
      (*(void (**)(_QWORD, __n128))(*(_QWORD *)*v10 + 40))(*v10, v13);
    *((_QWORD *)this + 19) = 0;
    *((_QWORD *)this + 16) = 0;
    *((_QWORD *)this + 17) = 0;
    *v10 = 0;
    ++*((_DWORD *)this + 36);
  }
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 9, v13.n128_f64[0]);
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)this + 3);
}

{
  re::FrameProfiler::~FrameProfiler(this);
  JUMPOUT(0x2276933B8);
}

void re::FrameProfiler::deinit(re::FrameProfiler *this)
{
  re::FrameProfiler *v1;
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  int *v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  int v11;

  if (*((_BYTE *)this + 206))
  {
    v1 = this;
    v2 = (uint64_t *)((char *)this + 24);
    v3 = *((unsigned int *)this + 14);
    if ((_DWORD)v3)
    {
      v4 = 0;
      v5 = (int *)(*((_QWORD *)this + 5) + 8);
      while (1)
      {
        v6 = *v5;
        v5 += 6;
        if (v6 < 0)
          break;
        if (v3 == ++v4)
        {
          LODWORD(v4) = *((_DWORD *)this + 14);
          break;
        }
      }
    }
    else
    {
      LODWORD(v4) = 0;
    }
    if ((_DWORD)v3 != (_DWORD)v4)
    {
      v7 = v4;
      do
      {
        v8 = *(_QWORD *)(*((_QWORD *)v1 + 5) + 24 * v7 + 16);
        *(_BYTE *)(v8 + 64) = 0;
        v9 = re::globalAllocators(this)[2];
        (**(void (***)(uint64_t))v8)(v8);
        this = (re::FrameProfiler *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v9 + 40))(v9, v8);
        if (*((_DWORD *)v1 + 14) <= (v4 + 1))
          v10 = v4 + 1;
        else
          v10 = *((_DWORD *)v1 + 14);
        v11 = v4;
        while (1)
        {
          v7 = (v11 + 1);
          if (v10 - 1 == v11)
            break;
          ++v11;
          LODWORD(v4) = v7;
          if ((*(_DWORD *)(*((_QWORD *)v1 + 5) + 24 * v7 + 8) & 0x80000000) != 0)
            goto LABEL_18;
        }
        LODWORD(v4) = v10;
LABEL_18:
        ;
      }
      while ((_DWORD)v3 != (_DWORD)v4);
    }
    re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(v2);
    re::HashTable<unsigned long long,re::ecs2::RenderPassGroupBoundsInfo,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)v1 + 43);
    *((_BYTE *)v1 + 206) = 0;
  }
}

void re::FrameProfiler::init(re::FrameProfiler *this)
{
  _anonymous_namespace_ *v2;
  uint64_t v3;
  unint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  unint64_t v13;
  unint64_t v14;
  _QWORD *v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  __int128 v25;
  __int128 v26;
  re *v27;
  uint64_t *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  int v36;
  uint64_t *v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  uint64_t v44;
  int v45;
  uint64_t *v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  uint64_t v51;
  int v52;
  uint64_t v53;
  int v54;
  uint64_t *v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;
  uint64_t v59;
  uint64_t v60;
  int v61;
  uint64_t v62;
  int v63;
  uint64_t *v64;
  uint64_t v65;
  uint64_t v66;
  unint64_t v67;
  uint64_t v68;
  uint64_t v69;
  int v70;
  uint64_t v71;
  int v72;
  uint64_t *v73;
  uint64_t v74;
  uint64_t v75;
  unint64_t v76;
  uint64_t v77;
  uint64_t v78;
  int v79;
  uint64_t v80;
  int v81;
  uint64_t *v82;
  uint64_t v83;
  uint64_t v84;
  unint64_t v85;
  uint64_t v86;
  uint64_t v87;
  int v88;
  uint64_t v89;
  int v90;
  uint64_t *v91;
  uint64_t v92;
  uint64_t v93;
  unint64_t v94;
  uint64_t v95;
  uint64_t v96;
  int v97;
  uint64_t v98;
  int v99;
  uint64_t *v100;
  uint64_t v101;
  uint64_t v102;
  unint64_t v103;
  uint64_t v104;
  uint64_t v105;
  int v106;
  uint64_t v107;
  int v108;
  uint64_t *v109;
  re::FrameMemoryStats *v110;
  re *v111;
  unint64_t v112;
  uint64_t v113;
  uint64_t v114;
  int v115;
  uint64_t v116;
  int v117;
  uint64_t *v118;
  uint64_t v119;
  uint64_t v120;
  unint64_t v121;
  uint64_t v122;
  uint64_t v123;
  int v124;
  uint64_t v125;
  int v126;
  uint64_t *v127;
  uint64_t v128;
  uint64_t v129;
  unint64_t v130;
  uint64_t v131;
  uint64_t v132;
  int v133;
  uint64_t v134;
  int v135;
  uint64_t *v136;
  re::FrameCustomStats *v137;
  unint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  int v143;
  uint64_t v144;
  int v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  re *Line;
  uint64_t *v150;
  uint64_t v151;
  uint64_t v152;
  unint64_t v153;
  uint64_t v154;
  uint64_t v155;
  int v156;
  uint64_t v157;
  int v158;
  uint64_t *v159;
  uint64_t v160;
  uint64_t v161;
  unint64_t v162;
  uint64_t v163;
  uint64_t v164;
  int v165;
  uint64_t v166;
  int v167;
  uint64_t v168;
  uint64_t v169;
  int *v170;
  int v171;
  uint64_t v172;
  int v173;
  int v174;
  _anonymous_namespace_ *v175;
  unsigned int v176;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  _BYTE v192[56];
  uint64_t v193;
  char v194;

  if (*((_BYTE *)this + 206))
    return;
  *((_DWORD *)this + 49) = 0;
  v2 = (_anonymous_namespace_ *)std::thread::hardware_concurrency();
  *((_DWORD *)this + 50) = (_DWORD)v2;
  memset(v192, 0, 36);
  *(_QWORD *)&v192[36] = 0x7FFFFFFFLL;
  v4 = (unint64_t *)((char *)this + 24);
  v3 = *((_QWORD *)this + 3);
  v5 = *(_QWORD *)v192;
  if (!v3 || v3 == *(_QWORD *)v192)
  {
    *(_QWORD *)v192 = *((_QWORD *)this + 3);
    v23 = *(_QWORD *)&v192[8];
    v24 = *(_QWORD *)&v192[16];
    v25 = *((_OWORD *)this + 2);
    v26 = *((_OWORD *)this + 3);
    *((_QWORD *)this + 3) = v5;
    *((_QWORD *)this + 4) = v23;
    *((_QWORD *)this + 5) = v24;
    *(_OWORD *)&v192[8] = v25;
    *((_OWORD *)this + 3) = *(_OWORD *)&v192[24];
    *(_OWORD *)&v192[24] = v26;
  }
  else
  {
    if (*((_DWORD *)this + 13))
    {
      v6 = *((unsigned int *)this + 12);
      if ((_DWORD)v6)
        memset_pattern16(*((void **)this + 4), &unk_2260EB7B0, 4 * v6);
      v7 = *((unsigned int *)this + 14);
      if ((_DWORD)v7)
      {
        v8 = 0;
        v9 = 24 * v7;
        do
        {
          v10 = *((_QWORD *)this + 5) + v8;
          v11 = *(_DWORD *)(v10 + 8);
          if (v11 < 0)
            *(_DWORD *)(v10 + 8) = v11 & 0x7FFFFFFF;
          v8 += 24;
        }
        while (v9 != v8);
      }
      *((_DWORD *)this + 13) = 0;
      *((_DWORD *)this + 14) = 0;
      v12 = *((_DWORD *)this + 16) + 1;
      *((_DWORD *)this + 15) = 0x7FFFFFFF;
      *((_DWORD *)this + 16) = v12;
    }
    if (v5)
    {
      if (*((_DWORD *)this + 12) < *(_DWORD *)&v192[28])
        re::HashTable<re::FrameProfilerStatisticsOptions,re::FrameStats *,re::Hash<re::FrameProfilerStatisticsOptions>,re::EqualTo<re::FrameProfilerStatisticsOptions>,true,false>::setCapacity((uint64_t)this + 24, *(unsigned int *)&v192[28]);
      v13 = *(unsigned int *)&v192[32];
      if (*(_DWORD *)&v192[32])
      {
        v14 = 0;
        v15 = (_QWORD *)(*(_QWORD *)&v192[16] + 16);
        do
        {
          if ((*(_DWORD *)(v15 - 1) & 0x80000000) != 0)
          {
            v16 = *(v15 - 2);
            v17 = *((unsigned int *)this + 12);
            v18 = v16 % v17;
            v19 = *((unsigned int *)this + 15);
            if ((_DWORD)v19 == 0x7FFFFFFF)
            {
              v19 = *((unsigned int *)this + 14);
              v20 = v19;
              if ((_DWORD)v19 == (_DWORD)v17)
              {
                re::HashTable<re::FrameProfilerStatisticsOptions,re::FrameStats *,re::Hash<re::FrameProfilerStatisticsOptions>,re::EqualTo<re::FrameProfilerStatisticsOptions>,true,false>::setCapacity((uint64_t)this + 24, 2 * *((_DWORD *)this + 13));
                v18 = v16 % *((unsigned int *)this + 12);
                v20 = *((_DWORD *)this + 14);
              }
              *((_DWORD *)this + 14) = v20 + 1;
              v21 = *((_QWORD *)this + 5);
              v22 = *(_DWORD *)(v21 + 24 * v19 + 8);
            }
            else
            {
              v21 = *((_QWORD *)this + 5);
              v22 = *(_DWORD *)(v21 + 24 * v19 + 8);
              *((_DWORD *)this + 15) = v22 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v21 + 24 * v19 + 8) = v22 | 0x80000000;
            *(_DWORD *)(*((_QWORD *)this + 5) + 24 * v19 + 8) = *(_DWORD *)(*((_QWORD *)this + 5) + 24 * v19 + 8) & 0x80000000 | *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v18);
            *(_QWORD *)(*((_QWORD *)this + 5) + 24 * v19) = v16;
            *(_DWORD *)(*((_QWORD *)this + 5) + 24 * v19 + 12) = *((_DWORD *)v15 - 1);
            *(_QWORD *)(*((_QWORD *)this + 5) + 24 * v19 + 16) = *v15;
            *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v18) = v19;
            ++*((_DWORD *)this + 13);
          }
          ++v14;
          v15 += 3;
        }
        while (v14 < v13);
      }
      ++*((_DWORD *)this + 16);
    }
  }
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)v192);
  v28 = re::globalAllocators(v27);
  v29 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v28[2] + 32))(v28[2], 72, 8);
  v30 = v29;
  *(_OWORD *)(v29 + 8) = 0u;
  *(_OWORD *)(v29 + 24) = 0u;
  *(_OWORD *)(v29 + 40) = 0u;
  *(_OWORD *)(v29 + 56) = 0u;
  *(_DWORD *)(v29 + 8) = 10;
  *(_OWORD *)(v29 + 16) = 0u;
  *(_OWORD *)(v29 + 32) = 0u;
  *(_QWORD *)(v29 + 48) = 0x7FFFFFFF00000000;
  *(_BYTE *)(v29 + 64) = 0;
  *(_QWORD *)v29 = &off_24ED7F350;
  v31 = *v4;
  if (*v4)
  {
    v31 = 0x5692161D100B05E5uLL % *((unsigned int *)this + 12);
    v32 = *(unsigned int *)(*((_QWORD *)this + 4) + 4 * v31);
    if ((_DWORD)v32 != 0x7FFFFFFF)
    {
      v178 = *((_QWORD *)this + 5);
      if (*(_DWORD *)(v178 + 24 * v32 + 12) == 1)
        goto LABEL_36;
      while (1)
      {
        LODWORD(v32) = *(_DWORD *)(v178 + 24 * v32 + 8) & 0x7FFFFFFF;
        if ((_DWORD)v32 == 0x7FFFFFFF)
          break;
        if (*(_DWORD *)(v178 + 24 * v32 + 12) == 1)
          goto LABEL_36;
      }
    }
  }
  v33 = *((unsigned int *)this + 15);
  if ((_DWORD)v33 == 0x7FFFFFFF)
  {
    v33 = *((unsigned int *)this + 14);
    v34 = v33;
    if ((_DWORD)v33 == *((_DWORD *)this + 12))
    {
      re::HashTable<re::FrameProfilerStatisticsOptions,re::FrameStats *,re::Hash<re::FrameProfilerStatisticsOptions>,re::EqualTo<re::FrameProfilerStatisticsOptions>,true,false>::setCapacity((uint64_t)this + 24, 2 * *((_DWORD *)this + 13));
      LODWORD(v31) = 0x5692161D100B05E5uLL % *((unsigned int *)this + 12);
      v34 = *((_DWORD *)this + 14);
    }
    *((_DWORD *)this + 14) = v34 + 1;
    v35 = *((_QWORD *)this + 5);
    v36 = *(_DWORD *)(v35 + 24 * v33 + 8);
  }
  else
  {
    v35 = *((_QWORD *)this + 5);
    v36 = *(_DWORD *)(v35 + 24 * v33 + 8);
    *((_DWORD *)this + 15) = v36 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v35 + 24 * v33 + 8) = v36 | 0x80000000;
  *(_DWORD *)(*((_QWORD *)this + 5) + 24 * v33 + 8) = *(_DWORD *)(*((_QWORD *)this + 5) + 24 * v33 + 8) & 0x80000000 | *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v31);
  *(_QWORD *)(*((_QWORD *)this + 5) + 24 * v33) = 0x5692161D100B05E5;
  *(_DWORD *)(*((_QWORD *)this + 5) + 24 * v33 + 12) = 1;
  *(_QWORD *)(*((_QWORD *)this + 5) + 24 * v33 + 16) = v30;
  *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v31) = v33;
  ++*((_DWORD *)this + 13);
  ++*((_DWORD *)this + 16);
LABEL_36:
  v37 = re::globalAllocators((re *)v29);
  v38 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v37[2] + 32))(v37[2], 72, 8);
  v39 = v38;
  *(_OWORD *)(v38 + 8) = 0u;
  *(_OWORD *)(v38 + 24) = 0u;
  *(_OWORD *)(v38 + 40) = 0u;
  *(_OWORD *)(v38 + 56) = 0u;
  *(_DWORD *)(v38 + 8) = 10;
  *(_OWORD *)(v38 + 16) = 0u;
  *(_OWORD *)(v38 + 32) = 0u;
  *(_QWORD *)(v38 + 48) = 0x7FFFFFFF00000000;
  *(_BYTE *)(v38 + 64) = 0;
  *(_QWORD *)v38 = &off_24ED7F398;
  v40 = *v4;
  if (*v4)
  {
    v40 = 0xDBD238973A2B148ALL % *((unsigned int *)this + 12);
    v41 = *(unsigned int *)(*((_QWORD *)this + 4) + 4 * v40);
    if ((_DWORD)v41 != 0x7FFFFFFF)
    {
      v179 = *((_QWORD *)this + 5);
      if (*(_DWORD *)(v179 + 24 * v41 + 12) == 2)
        goto LABEL_44;
      while (1)
      {
        LODWORD(v41) = *(_DWORD *)(v179 + 24 * v41 + 8) & 0x7FFFFFFF;
        if ((_DWORD)v41 == 0x7FFFFFFF)
          break;
        if (*(_DWORD *)(v179 + 24 * v41 + 12) == 2)
          goto LABEL_44;
      }
    }
  }
  v42 = *((unsigned int *)this + 15);
  if ((_DWORD)v42 == 0x7FFFFFFF)
  {
    v42 = *((unsigned int *)this + 14);
    v43 = v42;
    if ((_DWORD)v42 == *((_DWORD *)this + 12))
    {
      re::HashTable<re::FrameProfilerStatisticsOptions,re::FrameStats *,re::Hash<re::FrameProfilerStatisticsOptions>,re::EqualTo<re::FrameProfilerStatisticsOptions>,true,false>::setCapacity((uint64_t)this + 24, 2 * *((_DWORD *)this + 13));
      LODWORD(v40) = 0xDBD238973A2B148ALL % *((unsigned int *)this + 12);
      v43 = *((_DWORD *)this + 14);
    }
    *((_DWORD *)this + 14) = v43 + 1;
    v44 = *((_QWORD *)this + 5);
    v45 = *(_DWORD *)(v44 + 24 * v42 + 8);
  }
  else
  {
    v44 = *((_QWORD *)this + 5);
    v45 = *(_DWORD *)(v44 + 24 * v42 + 8);
    *((_DWORD *)this + 15) = v45 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v44 + 24 * v42 + 8) = v45 | 0x80000000;
  *(_DWORD *)(*((_QWORD *)this + 5) + 24 * v42 + 8) = *(_DWORD *)(*((_QWORD *)this + 5) + 24 * v42 + 8) & 0x80000000 | *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v40);
  *(_QWORD *)(*((_QWORD *)this + 5) + 24 * v42) = 0xDBD238973A2B148ALL;
  *(_DWORD *)(*((_QWORD *)this + 5) + 24 * v42 + 12) = 2;
  *(_QWORD *)(*((_QWORD *)this + 5) + 24 * v42 + 16) = v39;
  *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v40) = v42;
  ++*((_DWORD *)this + 13);
  ++*((_DWORD *)this + 16);
LABEL_44:
  v46 = re::globalAllocators((re *)v38);
  v47 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v46[2] + 32))(v46[2], 72, 8);
  v48 = v47;
  *(_OWORD *)(v47 + 8) = 0u;
  *(_OWORD *)(v47 + 24) = 0u;
  *(_OWORD *)(v47 + 40) = 0u;
  *(_OWORD *)(v47 + 56) = 0u;
  *(_DWORD *)(v47 + 8) = 10;
  *(_OWORD *)(v47 + 16) = 0u;
  *(_OWORD *)(v47 + 32) = 0u;
  *(_QWORD *)(v47 + 48) = 0x7FFFFFFF00000000;
  *(_BYTE *)(v47 + 64) = 0;
  *(_QWORD *)v47 = &off_24ED7F3E0;
  v49 = *v4;
  if (*v4)
  {
    v49 = 0xB7A4712C74562914 % *((unsigned int *)this + 12);
    v50 = *(unsigned int *)(*((_QWORD *)this + 4) + 4 * v49);
    if ((_DWORD)v50 != 0x7FFFFFFF)
    {
      v180 = *((_QWORD *)this + 5);
      if (*(_DWORD *)(v180 + 24 * v50 + 12) == 4)
        goto LABEL_52;
      while (1)
      {
        LODWORD(v50) = *(_DWORD *)(v180 + 24 * v50 + 8) & 0x7FFFFFFF;
        if ((_DWORD)v50 == 0x7FFFFFFF)
          break;
        if (*(_DWORD *)(v180 + 24 * v50 + 12) == 4)
          goto LABEL_52;
      }
    }
  }
  v51 = *((unsigned int *)this + 15);
  if ((_DWORD)v51 == 0x7FFFFFFF)
  {
    v51 = *((unsigned int *)this + 14);
    v52 = v51;
    if ((_DWORD)v51 == *((_DWORD *)this + 12))
    {
      re::HashTable<re::FrameProfilerStatisticsOptions,re::FrameStats *,re::Hash<re::FrameProfilerStatisticsOptions>,re::EqualTo<re::FrameProfilerStatisticsOptions>,true,false>::setCapacity((uint64_t)this + 24, 2 * *((_DWORD *)this + 13));
      LODWORD(v49) = 0xB7A4712C74562914 % *((unsigned int *)this + 12);
      v52 = *((_DWORD *)this + 14);
    }
    *((_DWORD *)this + 14) = v52 + 1;
    v53 = *((_QWORD *)this + 5);
    v54 = *(_DWORD *)(v53 + 24 * v51 + 8);
  }
  else
  {
    v53 = *((_QWORD *)this + 5);
    v54 = *(_DWORD *)(v53 + 24 * v51 + 8);
    *((_DWORD *)this + 15) = v54 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v53 + 24 * v51 + 8) = v54 | 0x80000000;
  *(_DWORD *)(*((_QWORD *)this + 5) + 24 * v51 + 8) = *(_DWORD *)(*((_QWORD *)this + 5) + 24 * v51 + 8) & 0x80000000 | *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v49);
  *(_QWORD *)(*((_QWORD *)this + 5) + 24 * v51) = 0xB7A4712C74562914;
  *(_DWORD *)(*((_QWORD *)this + 5) + 24 * v51 + 12) = 4;
  *(_QWORD *)(*((_QWORD *)this + 5) + 24 * v51 + 16) = v48;
  *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v49) = v51;
  ++*((_DWORD *)this + 13);
  ++*((_DWORD *)this + 16);
LABEL_52:
  v55 = re::globalAllocators((re *)v47);
  v56 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v55[2] + 32))(v55[2], 72, 8);
  v57 = v56;
  *(_OWORD *)(v56 + 8) = 0u;
  *(_OWORD *)(v56 + 24) = 0u;
  *(_OWORD *)(v56 + 40) = 0u;
  *(_OWORD *)(v56 + 56) = 0u;
  *(_DWORD *)(v56 + 8) = 10;
  *(_OWORD *)(v56 + 16) = 0u;
  *(_OWORD *)(v56 + 32) = 0u;
  *(_QWORD *)(v56 + 48) = 0x7FFFFFFF00000000;
  *(_BYTE *)(v56 + 64) = 0;
  *(_QWORD *)v56 = &off_24ED7F428;
  v58 = *v4;
  if (*v4)
  {
    v58 = 0xD56B1FBB9CEBA9E8 % *((unsigned int *)this + 12);
    v59 = *(unsigned int *)(*((_QWORD *)this + 4) + 4 * v58);
    if ((_DWORD)v59 != 0x7FFFFFFF)
    {
      v181 = *((_QWORD *)this + 5);
      if (*(_DWORD *)(v181 + 24 * v59 + 12) == 8)
        goto LABEL_60;
      while (1)
      {
        LODWORD(v59) = *(_DWORD *)(v181 + 24 * v59 + 8) & 0x7FFFFFFF;
        if ((_DWORD)v59 == 0x7FFFFFFF)
          break;
        if (*(_DWORD *)(v181 + 24 * v59 + 12) == 8)
          goto LABEL_60;
      }
    }
  }
  v60 = *((unsigned int *)this + 15);
  if ((_DWORD)v60 == 0x7FFFFFFF)
  {
    v60 = *((unsigned int *)this + 14);
    v61 = v60;
    if ((_DWORD)v60 == *((_DWORD *)this + 12))
    {
      re::HashTable<re::FrameProfilerStatisticsOptions,re::FrameStats *,re::Hash<re::FrameProfilerStatisticsOptions>,re::EqualTo<re::FrameProfilerStatisticsOptions>,true,false>::setCapacity((uint64_t)this + 24, 2 * *((_DWORD *)this + 13));
      LODWORD(v58) = 0xD56B1FBB9CEBA9E8 % *((unsigned int *)this + 12);
      v61 = *((_DWORD *)this + 14);
    }
    *((_DWORD *)this + 14) = v61 + 1;
    v62 = *((_QWORD *)this + 5);
    v63 = *(_DWORD *)(v62 + 24 * v60 + 8);
  }
  else
  {
    v62 = *((_QWORD *)this + 5);
    v63 = *(_DWORD *)(v62 + 24 * v60 + 8);
    *((_DWORD *)this + 15) = v63 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v62 + 24 * v60 + 8) = v63 | 0x80000000;
  *(_DWORD *)(*((_QWORD *)this + 5) + 24 * v60 + 8) = *(_DWORD *)(*((_QWORD *)this + 5) + 24 * v60 + 8) & 0x80000000 | *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v58);
  *(_QWORD *)(*((_QWORD *)this + 5) + 24 * v60) = 0xD56B1FBB9CEBA9E8;
  *(_DWORD *)(*((_QWORD *)this + 5) + 24 * v60 + 12) = 8;
  *(_QWORD *)(*((_QWORD *)this + 5) + 24 * v60 + 16) = v57;
  *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v58) = v60;
  ++*((_DWORD *)this + 13);
  ++*((_DWORD *)this + 16);
LABEL_60:
  v64 = re::globalAllocators((re *)v56);
  v65 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v64[2] + 32))(v64[2], 72, 8);
  v66 = v65;
  *(_OWORD *)(v65 + 8) = 0u;
  *(_OWORD *)(v65 + 24) = 0u;
  *(_OWORD *)(v65 + 40) = 0u;
  *(_OWORD *)(v65 + 56) = 0u;
  *(_DWORD *)(v65 + 8) = 10;
  *(_OWORD *)(v65 + 16) = 0u;
  *(_OWORD *)(v65 + 32) = 0u;
  *(_QWORD *)(v65 + 48) = 0x7FFFFFFF00000000;
  *(_BYTE *)(v65 + 64) = 0;
  *(_QWORD *)v65 = &off_24ED7F470;
  v67 = *v4;
  if (*v4)
  {
    v67 = 0xD9844BCECCA4A8BDLL % *((unsigned int *)this + 12);
    v68 = *(unsigned int *)(*((_QWORD *)this + 4) + 4 * v67);
    if ((_DWORD)v68 != 0x7FFFFFFF)
    {
      v182 = *((_QWORD *)this + 5);
      if (*(_DWORD *)(v182 + 24 * v68 + 12) == 16)
        goto LABEL_68;
      while (1)
      {
        LODWORD(v68) = *(_DWORD *)(v182 + 24 * v68 + 8) & 0x7FFFFFFF;
        if ((_DWORD)v68 == 0x7FFFFFFF)
          break;
        if (*(_DWORD *)(v182 + 24 * v68 + 12) == 16)
          goto LABEL_68;
      }
    }
  }
  v69 = *((unsigned int *)this + 15);
  if ((_DWORD)v69 == 0x7FFFFFFF)
  {
    v69 = *((unsigned int *)this + 14);
    v70 = v69;
    if ((_DWORD)v69 == *((_DWORD *)this + 12))
    {
      re::HashTable<re::FrameProfilerStatisticsOptions,re::FrameStats *,re::Hash<re::FrameProfilerStatisticsOptions>,re::EqualTo<re::FrameProfilerStatisticsOptions>,true,false>::setCapacity((uint64_t)this + 24, 2 * *((_DWORD *)this + 13));
      LODWORD(v67) = 0xD9844BCECCA4A8BDLL % *((unsigned int *)this + 12);
      v70 = *((_DWORD *)this + 14);
    }
    *((_DWORD *)this + 14) = v70 + 1;
    v71 = *((_QWORD *)this + 5);
    v72 = *(_DWORD *)(v71 + 24 * v69 + 8);
  }
  else
  {
    v71 = *((_QWORD *)this + 5);
    v72 = *(_DWORD *)(v71 + 24 * v69 + 8);
    *((_DWORD *)this + 15) = v72 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v71 + 24 * v69 + 8) = v72 | 0x80000000;
  *(_DWORD *)(*((_QWORD *)this + 5) + 24 * v69 + 8) = *(_DWORD *)(*((_QWORD *)this + 5) + 24 * v69 + 8) & 0x80000000 | *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v67);
  *(_QWORD *)(*((_QWORD *)this + 5) + 24 * v69) = 0xD9844BCECCA4A8BDLL;
  *(_DWORD *)(*((_QWORD *)this + 5) + 24 * v69 + 12) = 16;
  *(_QWORD *)(*((_QWORD *)this + 5) + 24 * v69 + 16) = v66;
  *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v67) = v69;
  ++*((_DWORD *)this + 13);
  ++*((_DWORD *)this + 16);
LABEL_68:
  v73 = re::globalAllocators((re *)v65);
  v74 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v73[2] + 32))(v73[2], 72, 8);
  v75 = v74;
  *(_OWORD *)(v74 + 8) = 0u;
  *(_OWORD *)(v74 + 24) = 0u;
  *(_OWORD *)(v74 + 40) = 0u;
  *(_OWORD *)(v74 + 56) = 0u;
  *(_DWORD *)(v74 + 8) = 10;
  *(_OWORD *)(v74 + 16) = 0u;
  *(_OWORD *)(v74 + 32) = 0u;
  *(_QWORD *)(v74 + 48) = 0x7FFFFFFF00000000;
  *(_BYTE *)(v74 + 64) = 0;
  *(_QWORD *)v74 = &off_24ED7F4B8;
  v76 = *v4;
  if (*v4)
  {
    v76 = 0xADFB1EBB497FAD45 % *((unsigned int *)this + 12);
    v77 = *(unsigned int *)(*((_QWORD *)this + 4) + 4 * v76);
    if ((_DWORD)v77 != 0x7FFFFFFF)
    {
      v183 = *((_QWORD *)this + 5);
      if (*(_DWORD *)(v183 + 24 * v77 + 12) == 32)
        goto LABEL_76;
      while (1)
      {
        LODWORD(v77) = *(_DWORD *)(v183 + 24 * v77 + 8) & 0x7FFFFFFF;
        if ((_DWORD)v77 == 0x7FFFFFFF)
          break;
        if (*(_DWORD *)(v183 + 24 * v77 + 12) == 32)
          goto LABEL_76;
      }
    }
  }
  v78 = *((unsigned int *)this + 15);
  if ((_DWORD)v78 == 0x7FFFFFFF)
  {
    v78 = *((unsigned int *)this + 14);
    v79 = v78;
    if ((_DWORD)v78 == *((_DWORD *)this + 12))
    {
      re::HashTable<re::FrameProfilerStatisticsOptions,re::FrameStats *,re::Hash<re::FrameProfilerStatisticsOptions>,re::EqualTo<re::FrameProfilerStatisticsOptions>,true,false>::setCapacity((uint64_t)this + 24, 2 * *((_DWORD *)this + 13));
      LODWORD(v76) = 0xADFB1EBB497FAD45 % *((unsigned int *)this + 12);
      v79 = *((_DWORD *)this + 14);
    }
    *((_DWORD *)this + 14) = v79 + 1;
    v80 = *((_QWORD *)this + 5);
    v81 = *(_DWORD *)(v80 + 24 * v78 + 8);
  }
  else
  {
    v80 = *((_QWORD *)this + 5);
    v81 = *(_DWORD *)(v80 + 24 * v78 + 8);
    *((_DWORD *)this + 15) = v81 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v80 + 24 * v78 + 8) = v81 | 0x80000000;
  *(_DWORD *)(*((_QWORD *)this + 5) + 24 * v78 + 8) = *(_DWORD *)(*((_QWORD *)this + 5) + 24 * v78 + 8) & 0x80000000 | *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v76);
  *(_QWORD *)(*((_QWORD *)this + 5) + 24 * v78) = 0xADFB1EBB497FAD45;
  *(_DWORD *)(*((_QWORD *)this + 5) + 24 * v78 + 12) = 32;
  *(_QWORD *)(*((_QWORD *)this + 5) + 24 * v78 + 16) = v75;
  *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v76) = v78;
  ++*((_DWORD *)this + 13);
  ++*((_DWORD *)this + 16);
LABEL_76:
  v82 = re::globalAllocators((re *)v74);
  v83 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v82[2] + 32))(v82[2], 72, 8);
  v84 = v83;
  *(_OWORD *)(v83 + 8) = 0u;
  *(_OWORD *)(v83 + 24) = 0u;
  *(_OWORD *)(v83 + 40) = 0u;
  *(_OWORD *)(v83 + 56) = 0u;
  *(_DWORD *)(v83 + 8) = 10;
  *(_OWORD *)(v83 + 16) = 0u;
  *(_OWORD *)(v83 + 32) = 0u;
  *(_QWORD *)(v83 + 48) = 0x7FFFFFFF00000000;
  *(_BYTE *)(v83 + 64) = 0;
  *(_QWORD *)v83 = &off_24ED7F500;
  v85 = *v4;
  if (*v4)
  {
    v85 = 0x8AA449CE2D0CA1D3 % *((unsigned int *)this + 12);
    v86 = *(unsigned int *)(*((_QWORD *)this + 4) + 4 * v85);
    if ((_DWORD)v86 != 0x7FFFFFFF)
    {
      v184 = *((_QWORD *)this + 5);
      if (*(_DWORD *)(v184 + 24 * v86 + 12) == 64)
        goto LABEL_84;
      while (1)
      {
        LODWORD(v86) = *(_DWORD *)(v184 + 24 * v86 + 8) & 0x7FFFFFFF;
        if ((_DWORD)v86 == 0x7FFFFFFF)
          break;
        if (*(_DWORD *)(v184 + 24 * v86 + 12) == 64)
          goto LABEL_84;
      }
    }
  }
  v87 = *((unsigned int *)this + 15);
  if ((_DWORD)v87 == 0x7FFFFFFF)
  {
    v87 = *((unsigned int *)this + 14);
    v88 = v87;
    if ((_DWORD)v87 == *((_DWORD *)this + 12))
    {
      re::HashTable<re::FrameProfilerStatisticsOptions,re::FrameStats *,re::Hash<re::FrameProfilerStatisticsOptions>,re::EqualTo<re::FrameProfilerStatisticsOptions>,true,false>::setCapacity((uint64_t)this + 24, 2 * *((_DWORD *)this + 13));
      LODWORD(v85) = 0x8AA449CE2D0CA1D3 % *((unsigned int *)this + 12);
      v88 = *((_DWORD *)this + 14);
    }
    *((_DWORD *)this + 14) = v88 + 1;
    v89 = *((_QWORD *)this + 5);
    v90 = *(_DWORD *)(v89 + 24 * v87 + 8);
  }
  else
  {
    v89 = *((_QWORD *)this + 5);
    v90 = *(_DWORD *)(v89 + 24 * v87 + 8);
    *((_DWORD *)this + 15) = v90 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v89 + 24 * v87 + 8) = v90 | 0x80000000;
  *(_DWORD *)(*((_QWORD *)this + 5) + 24 * v87 + 8) = *(_DWORD *)(*((_QWORD *)this + 5) + 24 * v87 + 8) & 0x80000000 | *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v85);
  *(_QWORD *)(*((_QWORD *)this + 5) + 24 * v87) = 0x8AA449CE2D0CA1D3;
  *(_DWORD *)(*((_QWORD *)this + 5) + 24 * v87 + 12) = 64;
  *(_QWORD *)(*((_QWORD *)this + 5) + 24 * v87 + 16) = v84;
  *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v85) = v87;
  ++*((_DWORD *)this + 13);
  ++*((_DWORD *)this + 16);
LABEL_84:
  v91 = re::globalAllocators((re *)v83);
  v92 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v91[2] + 32))(v91[2], 72, 8);
  v93 = v92;
  *(_OWORD *)(v92 + 8) = 0u;
  *(_OWORD *)(v92 + 24) = 0u;
  *(_OWORD *)(v92 + 40) = 0u;
  *(_OWORD *)(v92 + 56) = 0u;
  *(_DWORD *)(v92 + 8) = 10;
  *(_OWORD *)(v92 + 16) = 0u;
  *(_OWORD *)(v92 + 32) = 0u;
  *(_QWORD *)(v92 + 48) = 0x7FFFFFFF00000000;
  *(_BYTE *)(v92 + 64) = 0;
  *(_QWORD *)v92 = &off_24ED7F548;
  v94 = *v4;
  if (*v4)
  {
    v94 = 0xAF26563F2EC4C8E6 % *((unsigned int *)this + 12);
    v95 = *(unsigned int *)(*((_QWORD *)this + 4) + 4 * v94);
    if ((_DWORD)v95 != 0x7FFFFFFF)
    {
      v185 = *((_QWORD *)this + 5);
      if (*(_DWORD *)(v185 + 24 * v95 + 12) == 128)
        goto LABEL_92;
      while (1)
      {
        LODWORD(v95) = *(_DWORD *)(v185 + 24 * v95 + 8) & 0x7FFFFFFF;
        if ((_DWORD)v95 == 0x7FFFFFFF)
          break;
        if (*(_DWORD *)(v185 + 24 * v95 + 12) == 128)
          goto LABEL_92;
      }
    }
  }
  v96 = *((unsigned int *)this + 15);
  if ((_DWORD)v96 == 0x7FFFFFFF)
  {
    v96 = *((unsigned int *)this + 14);
    v97 = v96;
    if ((_DWORD)v96 == *((_DWORD *)this + 12))
    {
      re::HashTable<re::FrameProfilerStatisticsOptions,re::FrameStats *,re::Hash<re::FrameProfilerStatisticsOptions>,re::EqualTo<re::FrameProfilerStatisticsOptions>,true,false>::setCapacity((uint64_t)this + 24, 2 * *((_DWORD *)this + 13));
      LODWORD(v94) = 0xAF26563F2EC4C8E6 % *((unsigned int *)this + 12);
      v97 = *((_DWORD *)this + 14);
    }
    *((_DWORD *)this + 14) = v97 + 1;
    v98 = *((_QWORD *)this + 5);
    v99 = *(_DWORD *)(v98 + 24 * v96 + 8);
  }
  else
  {
    v98 = *((_QWORD *)this + 5);
    v99 = *(_DWORD *)(v98 + 24 * v96 + 8);
    *((_DWORD *)this + 15) = v99 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v98 + 24 * v96 + 8) = v99 | 0x80000000;
  *(_DWORD *)(*((_QWORD *)this + 5) + 24 * v96 + 8) = *(_DWORD *)(*((_QWORD *)this + 5) + 24 * v96 + 8) & 0x80000000 | *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v94);
  *(_QWORD *)(*((_QWORD *)this + 5) + 24 * v96) = 0xAF26563F2EC4C8E6;
  *(_DWORD *)(*((_QWORD *)this + 5) + 24 * v96 + 12) = 128;
  *(_QWORD *)(*((_QWORD *)this + 5) + 24 * v96 + 16) = v93;
  *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v94) = v96;
  ++*((_DWORD *)this + 13);
  ++*((_DWORD *)this + 16);
LABEL_92:
  v100 = re::globalAllocators((re *)v92);
  v101 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v100[2] + 32))(v100[2], 72, 8);
  v102 = v101;
  *(_OWORD *)(v101 + 8) = 0u;
  *(_OWORD *)(v101 + 24) = 0u;
  *(_OWORD *)(v101 + 40) = 0u;
  *(_OWORD *)(v101 + 56) = 0u;
  *(_DWORD *)(v101 + 8) = 10;
  *(_OWORD *)(v101 + 16) = 0u;
  *(_OWORD *)(v101 + 32) = 0u;
  *(_QWORD *)(v101 + 48) = 0x7FFFFFFF00000000;
  *(_BYTE *)(v101 + 64) = 0;
  *(_QWORD *)v101 = &off_24ED7F590;
  v103 = *v4;
  if (*v4)
  {
    v103 = 0xF82A6F1D1144170DLL % *((unsigned int *)this + 12);
    v104 = *(unsigned int *)(*((_QWORD *)this + 4) + 4 * v103);
    if ((_DWORD)v104 != 0x7FFFFFFF)
    {
      v186 = *((_QWORD *)this + 5);
      if (*(_DWORD *)(v186 + 24 * v104 + 12) == 256)
        goto LABEL_100;
      while (1)
      {
        LODWORD(v104) = *(_DWORD *)(v186 + 24 * v104 + 8) & 0x7FFFFFFF;
        if ((_DWORD)v104 == 0x7FFFFFFF)
          break;
        if (*(_DWORD *)(v186 + 24 * v104 + 12) == 256)
          goto LABEL_100;
      }
    }
  }
  v105 = *((unsigned int *)this + 15);
  if ((_DWORD)v105 == 0x7FFFFFFF)
  {
    v105 = *((unsigned int *)this + 14);
    v106 = v105;
    if ((_DWORD)v105 == *((_DWORD *)this + 12))
    {
      re::HashTable<re::FrameProfilerStatisticsOptions,re::FrameStats *,re::Hash<re::FrameProfilerStatisticsOptions>,re::EqualTo<re::FrameProfilerStatisticsOptions>,true,false>::setCapacity((uint64_t)this + 24, 2 * *((_DWORD *)this + 13));
      LODWORD(v103) = 0xF82A6F1D1144170DLL % *((unsigned int *)this + 12);
      v106 = *((_DWORD *)this + 14);
    }
    *((_DWORD *)this + 14) = v106 + 1;
    v107 = *((_QWORD *)this + 5);
    v108 = *(_DWORD *)(v107 + 24 * v105 + 8);
  }
  else
  {
    v107 = *((_QWORD *)this + 5);
    v108 = *(_DWORD *)(v107 + 24 * v105 + 8);
    *((_DWORD *)this + 15) = v108 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v107 + 24 * v105 + 8) = v108 | 0x80000000;
  *(_DWORD *)(*((_QWORD *)this + 5) + 24 * v105 + 8) = *(_DWORD *)(*((_QWORD *)this + 5) + 24 * v105 + 8) & 0x80000000 | *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v103);
  *(_QWORD *)(*((_QWORD *)this + 5) + 24 * v105) = 0xF82A6F1D1144170DLL;
  *(_DWORD *)(*((_QWORD *)this + 5) + 24 * v105 + 12) = 256;
  *(_QWORD *)(*((_QWORD *)this + 5) + 24 * v105 + 16) = v102;
  *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v103) = v105;
  ++*((_DWORD *)this + 13);
  ++*((_DWORD *)this + 16);
LABEL_100:
  v109 = re::globalAllocators((re *)v101);
  v110 = (re::FrameMemoryStats *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v109[2] + 32))(v109[2], 80, 8);
  v111 = re::FrameMemoryStats::FrameMemoryStats(v110);
  v112 = *v4;
  if (*v4)
  {
    v112 = 0x852527F5DF18EBBALL % *((unsigned int *)this + 12);
    v113 = *(unsigned int *)(*((_QWORD *)this + 4) + 4 * v112);
    if ((_DWORD)v113 != 0x7FFFFFFF)
    {
      v187 = *((_QWORD *)this + 5);
      if (*(_DWORD *)(v187 + 24 * v113 + 12) == 512)
        goto LABEL_108;
      while (1)
      {
        LODWORD(v113) = *(_DWORD *)(v187 + 24 * v113 + 8) & 0x7FFFFFFF;
        if ((_DWORD)v113 == 0x7FFFFFFF)
          break;
        if (*(_DWORD *)(v187 + 24 * v113 + 12) == 512)
          goto LABEL_108;
      }
    }
  }
  v114 = *((unsigned int *)this + 15);
  if ((_DWORD)v114 == 0x7FFFFFFF)
  {
    v114 = *((unsigned int *)this + 14);
    v115 = v114;
    if ((_DWORD)v114 == *((_DWORD *)this + 12))
    {
      re::HashTable<re::FrameProfilerStatisticsOptions,re::FrameStats *,re::Hash<re::FrameProfilerStatisticsOptions>,re::EqualTo<re::FrameProfilerStatisticsOptions>,true,false>::setCapacity((uint64_t)this + 24, 2 * *((_DWORD *)this + 13));
      LODWORD(v112) = 0x852527F5DF18EBBALL % *((unsigned int *)this + 12);
      v115 = *((_DWORD *)this + 14);
    }
    *((_DWORD *)this + 14) = v115 + 1;
    v116 = *((_QWORD *)this + 5);
    v117 = *(_DWORD *)(v116 + 24 * v114 + 8);
  }
  else
  {
    v116 = *((_QWORD *)this + 5);
    v117 = *(_DWORD *)(v116 + 24 * v114 + 8);
    *((_DWORD *)this + 15) = v117 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v116 + 24 * v114 + 8) = v117 | 0x80000000;
  *(_DWORD *)(*((_QWORD *)this + 5) + 24 * v114 + 8) = *(_DWORD *)(*((_QWORD *)this + 5) + 24 * v114 + 8) & 0x80000000 | *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v112);
  *(_QWORD *)(*((_QWORD *)this + 5) + 24 * v114) = 0x852527F5DF18EBBALL;
  *(_DWORD *)(*((_QWORD *)this + 5) + 24 * v114 + 12) = 512;
  *(_QWORD *)(*((_QWORD *)this + 5) + 24 * v114 + 16) = v110;
  *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v112) = v114;
  ++*((_DWORD *)this + 13);
  ++*((_DWORD *)this + 16);
LABEL_108:
  v118 = re::globalAllocators(v111);
  v119 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v118[2] + 32))(v118[2], 96, 8);
  v120 = v119;
  *(_OWORD *)(v119 + 8) = 0u;
  *(_OWORD *)(v119 + 40) = 0u;
  *(_OWORD *)(v119 + 24) = 0u;
  *(_OWORD *)(v119 + 56) = 0u;
  *(_OWORD *)(v119 + 72) = 0u;
  *(_QWORD *)(v119 + 88) = 0;
  *(_DWORD *)(v119 + 8) = 10;
  *(_QWORD *)(v119 + 48) = 0x7FFFFFFF00000000;
  *(_OWORD *)(v119 + 16) = 0u;
  *(_OWORD *)(v119 + 32) = 0u;
  *(_BYTE *)(v119 + 64) = 0;
  *(_QWORD *)v119 = &off_24ED7F5F0;
  *(_QWORD *)(v119 + 68) = 0;
  *(_QWORD *)(v119 + 76) = 0;
  *(_QWORD *)(v119 + 84) = 0;
  v121 = *v4;
  if (*v4)
  {
    v121 = 0x706C8D494A7C5235uLL % *((unsigned int *)this + 12);
    v122 = *(unsigned int *)(*((_QWORD *)this + 4) + 4 * v121);
    if ((_DWORD)v122 != 0x7FFFFFFF)
    {
      v188 = *((_QWORD *)this + 5);
      if (*(_DWORD *)(v188 + 24 * v122 + 12) == 1024)
        goto LABEL_116;
      while (1)
      {
        LODWORD(v122) = *(_DWORD *)(v188 + 24 * v122 + 8) & 0x7FFFFFFF;
        if ((_DWORD)v122 == 0x7FFFFFFF)
          break;
        if (*(_DWORD *)(v188 + 24 * v122 + 12) == 1024)
          goto LABEL_116;
      }
    }
  }
  v123 = *((unsigned int *)this + 15);
  if ((_DWORD)v123 == 0x7FFFFFFF)
  {
    v123 = *((unsigned int *)this + 14);
    v124 = v123;
    if ((_DWORD)v123 == *((_DWORD *)this + 12))
    {
      re::HashTable<re::FrameProfilerStatisticsOptions,re::FrameStats *,re::Hash<re::FrameProfilerStatisticsOptions>,re::EqualTo<re::FrameProfilerStatisticsOptions>,true,false>::setCapacity((uint64_t)this + 24, 2 * *((_DWORD *)this + 13));
      LODWORD(v121) = 0x706C8D494A7C5235uLL % *((unsigned int *)this + 12);
      v124 = *((_DWORD *)this + 14);
    }
    *((_DWORD *)this + 14) = v124 + 1;
    v125 = *((_QWORD *)this + 5);
    v126 = *(_DWORD *)(v125 + 24 * v123 + 8);
  }
  else
  {
    v125 = *((_QWORD *)this + 5);
    v126 = *(_DWORD *)(v125 + 24 * v123 + 8);
    *((_DWORD *)this + 15) = v126 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v125 + 24 * v123 + 8) = v126 | 0x80000000;
  *(_DWORD *)(*((_QWORD *)this + 5) + 24 * v123 + 8) = *(_DWORD *)(*((_QWORD *)this + 5) + 24 * v123 + 8) & 0x80000000 | *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v121);
  *(_QWORD *)(*((_QWORD *)this + 5) + 24 * v123) = 0x706C8D494A7C5235;
  *(_DWORD *)(*((_QWORD *)this + 5) + 24 * v123 + 12) = 1024;
  *(_QWORD *)(*((_QWORD *)this + 5) + 24 * v123 + 16) = v120;
  *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v121) = v123;
  ++*((_DWORD *)this + 13);
  ++*((_DWORD *)this + 16);
LABEL_116:
  v127 = re::globalAllocators((re *)v119);
  v128 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v127[2] + 32))(v127[2], 72, 8);
  v129 = v128;
  *(_OWORD *)(v128 + 8) = 0u;
  *(_OWORD *)(v128 + 24) = 0u;
  *(_OWORD *)(v128 + 40) = 0u;
  *(_OWORD *)(v128 + 56) = 0u;
  *(_DWORD *)(v128 + 8) = 10;
  *(_OWORD *)(v128 + 16) = 0u;
  *(_OWORD *)(v128 + 32) = 0u;
  *(_QWORD *)(v128 + 48) = 0x7FFFFFFF00000000;
  *(_BYTE *)(v128 + 64) = 0;
  *(_QWORD *)v128 = &off_24ED7F638;
  v130 = *v4;
  if (*v4)
  {
    v130 = 0xE0D91A9294F8A46ALL % *((unsigned int *)this + 12);
    v131 = *(unsigned int *)(*((_QWORD *)this + 4) + 4 * v130);
    if ((_DWORD)v131 != 0x7FFFFFFF)
    {
      v189 = *((_QWORD *)this + 5);
      if (*(_DWORD *)(v189 + 24 * v131 + 12) == 2048)
        goto LABEL_124;
      while (1)
      {
        LODWORD(v131) = *(_DWORD *)(v189 + 24 * v131 + 8) & 0x7FFFFFFF;
        if ((_DWORD)v131 == 0x7FFFFFFF)
          break;
        if (*(_DWORD *)(v189 + 24 * v131 + 12) == 2048)
          goto LABEL_124;
      }
    }
  }
  v132 = *((unsigned int *)this + 15);
  if ((_DWORD)v132 == 0x7FFFFFFF)
  {
    v132 = *((unsigned int *)this + 14);
    v133 = v132;
    if ((_DWORD)v132 == *((_DWORD *)this + 12))
    {
      re::HashTable<re::FrameProfilerStatisticsOptions,re::FrameStats *,re::Hash<re::FrameProfilerStatisticsOptions>,re::EqualTo<re::FrameProfilerStatisticsOptions>,true,false>::setCapacity((uint64_t)this + 24, 2 * *((_DWORD *)this + 13));
      LODWORD(v130) = 0xE0D91A9294F8A46ALL % *((unsigned int *)this + 12);
      v133 = *((_DWORD *)this + 14);
    }
    *((_DWORD *)this + 14) = v133 + 1;
    v134 = *((_QWORD *)this + 5);
    v135 = *(_DWORD *)(v134 + 24 * v132 + 8);
  }
  else
  {
    v134 = *((_QWORD *)this + 5);
    v135 = *(_DWORD *)(v134 + 24 * v132 + 8);
    *((_DWORD *)this + 15) = v135 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v134 + 24 * v132 + 8) = v135 | 0x80000000;
  *(_DWORD *)(*((_QWORD *)this + 5) + 24 * v132 + 8) = *(_DWORD *)(*((_QWORD *)this + 5) + 24 * v132 + 8) & 0x80000000 | *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v130);
  *(_QWORD *)(*((_QWORD *)this + 5) + 24 * v132) = 0xE0D91A9294F8A46ALL;
  *(_DWORD *)(*((_QWORD *)this + 5) + 24 * v132 + 12) = 2048;
  *(_QWORD *)(*((_QWORD *)this + 5) + 24 * v132 + 16) = v129;
  *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v130) = v132;
  ++*((_DWORD *)this + 13);
  ++*((_DWORD *)this + 16);
LABEL_124:
  v136 = re::globalAllocators((re *)v128);
  v137 = (re::FrameCustomStats *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v136[2] + 32))(v136[2], 168, 8);
  re::FrameCustomStats::FrameCustomStats(v137);
  if (*v4)
  {
    v138 = 0xF6E8F5E9060644CuLL % *((unsigned int *)this + 12);
    v139 = *((_QWORD *)this + 4);
    v140 = *(unsigned int *)(v139 + 4 * v138);
    if ((_DWORD)v140 != 0x7FFFFFFF)
    {
      v141 = *((_QWORD *)this + 5);
      if (*(_DWORD *)(v141 + 24 * v140 + 12) == 0x2000)
        goto LABEL_138;
      while (1)
      {
        LODWORD(v140) = *(_DWORD *)(v141 + 24 * v140 + 8) & 0x7FFFFFFF;
        if ((_DWORD)v140 == 0x7FFFFFFF)
          break;
        if (*(_DWORD *)(v141 + 24 * v140 + 12) == 0x2000)
        {
          if (*v4)
            goto LABEL_138;
          goto LABEL_144;
        }
      }
    }
  }
  else
  {
    LODWORD(v138) = 0;
  }
  v142 = *((unsigned int *)this + 15);
  if ((_DWORD)v142 == 0x7FFFFFFF)
  {
    v142 = *((unsigned int *)this + 14);
    v143 = v142;
    if ((_DWORD)v142 == *((_DWORD *)this + 12))
    {
      re::HashTable<re::FrameProfilerStatisticsOptions,re::FrameStats *,re::Hash<re::FrameProfilerStatisticsOptions>,re::EqualTo<re::FrameProfilerStatisticsOptions>,true,false>::setCapacity((uint64_t)this + 24, 2 * *((_DWORD *)this + 13));
      LODWORD(v138) = 0xF6E8F5E9060644CuLL % *((unsigned int *)this + 12);
      v143 = *((_DWORD *)this + 14);
    }
    *((_DWORD *)this + 14) = v143 + 1;
    v144 = *((_QWORD *)this + 5);
    v145 = *(_DWORD *)(v144 + 24 * v142 + 8);
  }
  else
  {
    v144 = *((_QWORD *)this + 5);
    v145 = *(_DWORD *)(v144 + 24 * v142 + 8);
    *((_DWORD *)this + 15) = v145 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v144 + 24 * v142 + 8) = v145 | 0x80000000;
  *(_DWORD *)(*((_QWORD *)this + 5) + 24 * v142 + 8) = *(_DWORD *)(*((_QWORD *)this + 5) + 24 * v142 + 8) & 0x80000000 | *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v138);
  *(_QWORD *)(*((_QWORD *)this + 5) + 24 * v142) = 0xF6E8F5E9060644CLL;
  *(_DWORD *)(*((_QWORD *)this + 5) + 24 * v142 + 12) = 0x2000;
  *(_QWORD *)(*((_QWORD *)this + 5) + 24 * v142 + 16) = v137;
  v139 = *((_QWORD *)this + 4);
  *(_DWORD *)(v139 + 4 * v138) = v142;
  ++*((_DWORD *)this + 13);
  ++*((_DWORD *)this + 16);
  if (!*((_QWORD *)this + 3))
  {
LABEL_144:
    LODWORD(v147) = 0x7FFFFFFF;
    goto LABEL_145;
  }
LABEL_138:
  v146 = *(unsigned int *)(v139 + 4 * (0xF6E8F5E9060644CuLL % *((unsigned int *)this + 12)));
  LODWORD(v147) = 0x7FFFFFFF;
  if ((_DWORD)v146 != 0x7FFFFFFF)
  {
    v148 = *((_QWORD *)this + 5);
    LODWORD(v147) = v146;
    if (*(_DWORD *)(v148 + 24 * v146 + 12) != 0x2000)
    {
      v147 = v146;
      do
      {
        LODWORD(v147) = *(_DWORD *)(v148 + 24 * v147 + 8) & 0x7FFFFFFF;
        if ((_DWORD)v147 == 0x7FFFFFFF)
          goto LABEL_144;
      }
      while (*(_DWORD *)(v148 + 24 * v147 + 12) != 0x2000);
    }
  }
LABEL_145:
  Line = (re *)re::FrameCustomStats::addOrGetLine(*(re::FrameCustomStats **)(*((_QWORD *)this + 5) + 24 * v147 + 16), "Custom Stats");
  v150 = re::globalAllocators(Line);
  v151 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v150[2] + 32))(v150[2], 72, 8);
  v152 = v151;
  *(_OWORD *)(v151 + 8) = 0u;
  *(_OWORD *)(v151 + 24) = 0u;
  *(_OWORD *)(v151 + 40) = 0u;
  *(_OWORD *)(v151 + 56) = 0u;
  *(_DWORD *)(v151 + 8) = 10;
  *(_OWORD *)(v151 + 16) = 0u;
  *(_OWORD *)(v151 + 32) = 0u;
  *(_QWORD *)(v151 + 48) = 0x7FFFFFFF00000000;
  *(_BYTE *)(v151 + 64) = 0;
  *(_QWORD *)v151 = &off_24ED7F698;
  v153 = *((_QWORD *)this + 3);
  if (v153)
  {
    v153 = 0xB3AD687957F6D73DLL % *((unsigned int *)this + 12);
    v154 = *(unsigned int *)(*((_QWORD *)this + 4) + 4 * v153);
    if ((_DWORD)v154 != 0x7FFFFFFF)
    {
      v190 = *((_QWORD *)this + 5);
      if (*(_DWORD *)(v190 + 24 * v154 + 12) == 0x4000)
        goto LABEL_153;
      while (1)
      {
        LODWORD(v154) = *(_DWORD *)(v190 + 24 * v154 + 8) & 0x7FFFFFFF;
        if ((_DWORD)v154 == 0x7FFFFFFF)
          break;
        if (*(_DWORD *)(v190 + 24 * v154 + 12) == 0x4000)
          goto LABEL_153;
      }
    }
  }
  v155 = *((unsigned int *)this + 15);
  if ((_DWORD)v155 == 0x7FFFFFFF)
  {
    v155 = *((unsigned int *)this + 14);
    v156 = v155;
    if ((_DWORD)v155 == *((_DWORD *)this + 12))
    {
      re::HashTable<re::FrameProfilerStatisticsOptions,re::FrameStats *,re::Hash<re::FrameProfilerStatisticsOptions>,re::EqualTo<re::FrameProfilerStatisticsOptions>,true,false>::setCapacity((uint64_t)this + 24, 2 * *((_DWORD *)this + 13));
      LODWORD(v153) = 0xB3AD687957F6D73DLL % *((unsigned int *)this + 12);
      v156 = *((_DWORD *)this + 14);
    }
    *((_DWORD *)this + 14) = v156 + 1;
    v157 = *((_QWORD *)this + 5);
    v158 = *(_DWORD *)(v157 + 24 * v155 + 8);
  }
  else
  {
    v157 = *((_QWORD *)this + 5);
    v158 = *(_DWORD *)(v157 + 24 * v155 + 8);
    *((_DWORD *)this + 15) = v158 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v157 + 24 * v155 + 8) = v158 | 0x80000000;
  *(_DWORD *)(*((_QWORD *)this + 5) + 24 * v155 + 8) = *(_DWORD *)(*((_QWORD *)this + 5) + 24 * v155 + 8) & 0x80000000 | *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v153);
  *(_QWORD *)(*((_QWORD *)this + 5) + 24 * v155) = 0xB3AD687957F6D73DLL;
  *(_DWORD *)(*((_QWORD *)this + 5) + 24 * v155 + 12) = 0x4000;
  *(_QWORD *)(*((_QWORD *)this + 5) + 24 * v155 + 16) = v152;
  *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v153) = v155;
  ++*((_DWORD *)this + 13);
  ++*((_DWORD *)this + 16);
LABEL_153:
  v159 = re::globalAllocators((re *)v151);
  v160 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v159[2] + 32))(v159[2], 72, 8);
  v161 = v160;
  *(_OWORD *)(v160 + 8) = 0u;
  *(_OWORD *)(v160 + 24) = 0u;
  *(_OWORD *)(v160 + 40) = 0u;
  *(_OWORD *)(v160 + 56) = 0u;
  *(_DWORD *)(v160 + 8) = 10;
  *(_OWORD *)(v160 + 16) = 0u;
  *(_OWORD *)(v160 + 32) = 0u;
  *(_QWORD *)(v160 + 48) = 0x7FFFFFFF00000000;
  *(_BYTE *)(v160 + 64) = 0;
  *(_QWORD *)v160 = &off_24ED7F6E0;
  v162 = *v4;
  if (!*v4
    || (v162 = 0x323B8D7CFCE64AAAuLL % *((unsigned int *)this + 12),
        v163 = *(unsigned int *)(*((_QWORD *)this + 4) + 4 * v162),
        (_DWORD)v163 == 0x7FFFFFFF))
  {
LABEL_155:
    v164 = *((unsigned int *)this + 15);
    if ((_DWORD)v164 == 0x7FFFFFFF)
    {
      v164 = *((unsigned int *)this + 14);
      v165 = v164;
      if ((_DWORD)v164 == *((_DWORD *)this + 12))
      {
        re::HashTable<re::FrameProfilerStatisticsOptions,re::FrameStats *,re::Hash<re::FrameProfilerStatisticsOptions>,re::EqualTo<re::FrameProfilerStatisticsOptions>,true,false>::setCapacity((uint64_t)this + 24, 2 * *((_DWORD *)this + 13));
        LODWORD(v162) = 0x323B8D7CFCE64AAAuLL % *((unsigned int *)this + 12);
        v165 = *((_DWORD *)this + 14);
      }
      *((_DWORD *)this + 14) = v165 + 1;
      v166 = *((_QWORD *)this + 5);
      v167 = *(_DWORD *)(v166 + 24 * v164 + 8);
    }
    else
    {
      v166 = *((_QWORD *)this + 5);
      v167 = *(_DWORD *)(v166 + 24 * v164 + 8);
      *((_DWORD *)this + 15) = v167 & 0x7FFFFFFF;
    }
    *(_DWORD *)(v166 + 24 * v164 + 8) = v167 | 0x80000000;
    *(_DWORD *)(*((_QWORD *)this + 5) + 24 * v164 + 8) = *(_DWORD *)(*((_QWORD *)this + 5) + 24 * v164 + 8) & 0x80000000 | *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v162);
    *(_QWORD *)(*((_QWORD *)this + 5) + 24 * v164) = 0x323B8D7CFCE64AAALL;
    *(_DWORD *)(*((_QWORD *)this + 5) + 24 * v164 + 12) = 0x20000;
    *(_QWORD *)(*((_QWORD *)this + 5) + 24 * v164 + 16) = v161;
    *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v162) = v164;
    ++*((_DWORD *)this + 13);
    ++*((_DWORD *)this + 16);
    goto LABEL_161;
  }
  v191 = *((_QWORD *)this + 5);
  while (*(_DWORD *)(v191 + 24 * v163 + 12) != 0x20000)
  {
    LODWORD(v163) = *(_DWORD *)(v191 + 24 * v163 + 8) & 0x7FFFFFFF;
    if ((_DWORD)v163 == 0x7FFFFFFF)
      goto LABEL_155;
  }
LABEL_161:
  v168 = *((unsigned int *)this + 14);
  if ((_DWORD)v168)
  {
    v169 = 0;
    v170 = (int *)(*((_QWORD *)this + 5) + 8);
    while (1)
    {
      v171 = *v170;
      v170 += 6;
      if (v171 < 0)
        break;
      if (v168 == ++v169)
      {
        LODWORD(v169) = *((_DWORD *)this + 14);
        break;
      }
    }
  }
  else
  {
    LODWORD(v169) = 0;
  }
  if ((_DWORD)v168 != (_DWORD)v169)
  {
    v172 = v169;
    do
    {
      v160 = re::FrameStats::init(*(re::FrameStats **)(*((_QWORD *)this + 5) + 24 * v172 + 16), *((_DWORD *)this + 50), *((_DWORD *)this + 48));
      if (*((_DWORD *)this + 14) <= (v169 + 1))
        v173 = v169 + 1;
      else
        v173 = *((_DWORD *)this + 14);
      v174 = v169;
      while (1)
      {
        v172 = (v174 + 1);
        if (v173 - 1 == v174)
          break;
        ++v174;
        LODWORD(v169) = v172;
        if ((*(_DWORD *)(*((_QWORD *)this + 5) + 24 * v172 + 8) & 0x80000000) != 0)
          goto LABEL_177;
      }
      LODWORD(v169) = v173;
LABEL_177:
      ;
    }
    while ((_DWORD)v168 != (_DWORD)v169);
  }
  memset(v192, 0, 36);
  *(_QWORD *)&v192[36] = 0x7FFFFFFFLL;
  re::HashTable<re::ProfilerStatistic,re::FrameStats::CollectedStatistics,re::Hash<re::ProfilerStatistic>,re::EqualTo<re::ProfilerStatistic>,true,false>::operator=((uint64_t)this + 344, (uint64_t *)v192);
  re::HashTable<unsigned long long,re::ecs2::RenderPassGroupBoundsInfo,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)v192);
  memset(v192, 0, 36);
  *(_QWORD *)&v192[36] = 0x7FFFFFFFLL;
  re::HashTable<re::ProfilerStatistic,re::FrameStats::CollectedStatistics,re::Hash<re::ProfilerStatistic>,re::EqualTo<re::ProfilerStatistic>,true,false>::operator=((uint64_t)this + 392, (uint64_t *)v192);
  re::HashTable<unsigned long long,re::ecs2::RenderPassGroupBoundsInfo,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)v192);
  v176 = 0;
  do
  {
    v194 = v176;
    *(_OWORD *)v192 = 0xFF7FFFFF7F7FFFFFLL;
    *(_QWORD *)&v192[16] = 0;
    *(_OWORD *)&v192[24] = xmmword_226192590;
    *(_OWORD *)&v192[40] = xmmword_2261925A0;
    v193 = 0;
    re::HashTable<re::ProfilerStatistic,re::FrameStats::CollectedStatistics,re::Hash<re::ProfilerStatistic>,re::EqualTo<re::ProfilerStatistic>,true,false>::addNew((uint64_t)this + 344, &v194, (re::FrameStats::CollectedStatistics *)v192);
    *(_OWORD *)v192 = 0xFF7FFFFF7F7FFFFFLL;
    *(_QWORD *)&v192[16] = 0;
    *(_OWORD *)&v192[24] = xmmword_226192590;
    *(_OWORD *)&v192[40] = xmmword_2261925A0;
    v193 = 0;
    re::HashTable<re::ProfilerStatistic,re::FrameStats::CollectedStatistics,re::Hash<re::ProfilerStatistic>,re::EqualTo<re::ProfilerStatistic>,true,false>::addNew((uint64_t)this + 392, &v194, (re::FrameStats::CollectedStatistics *)v192);
  }
  while (v176++ < 0x9C);
  *((_BYTE *)this + 206) = 1;
  re::FrameProfiler::setEngineInitializedTimestamp(this, *((_QWORD *)this + 26));
}

uint64_t re::HashTable<re::ProfilerStatistic,re::FrameStats::CollectedStatistics,re::Hash<re::ProfilerStatistic>,re::EqualTo<re::ProfilerStatistic>,true,false>::operator=(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    if (!*(_QWORD *)a1 || *(_QWORD *)a1 == *a2)
    {
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)a1, a2);
    }
    else if (*a2)
    {
      re::HashTable<re::ProfilerStatistic,re::FrameStats::CollectedStatistics,re::Hash<re::ProfilerStatistic>,re::EqualTo<re::ProfilerStatistic>,true,false>::copy(a1, (uint64_t)a2);
      ++*(_DWORD *)(a1 + 40);
    }
    else
    {
      re::HashTable<re::ProfilerStatistic,re::FrameStats::CollectedStatistics,re::Hash<re::ProfilerStatistic>,re::EqualTo<re::ProfilerStatistic>,true,false>::clear(a1);
    }
  }
  return a1;
}

uint64_t re::HashTable<re::ProfilerStatistic,re::FrameStats::CollectedStatistics,re::Hash<re::ProfilerStatistic>,re::EqualTo<re::ProfilerStatistic>,true,false>::addNew(uint64_t a1, _BYTE *a2, re::FrameStats::CollectedStatistics *a3)
{
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;

  v6 = *a2;
  v7 = 0x94D049BB133111EBLL * ((0xBF58476D1CE4E5B9 * v6) ^ ((0xBF58476D1CE4E5B9 * v6) >> 27));
  v8 = v7 ^ (v7 >> 31);
  if (!*(_QWORD *)a1)
  {
    LODWORD(v9) = 0;
    goto LABEL_8;
  }
  v9 = v8 % *(unsigned int *)(a1 + 24);
  v10 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v9);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
LABEL_8:
    v13 = re::HashTable<re::ProfilerStatistic,re::FrameStats::CollectedStatistics,re::Hash<re::ProfilerStatistic>,re::EqualTo<re::ProfilerStatistic>,true,false>::addAsCopy(a1, v9, v8, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    v12 = *(_QWORD *)(a1 + 16) + 80 * v13;
    return v12 + 16;
  }
  v11 = *(_QWORD *)(a1 + 16);
  while (*(unsigned __int8 *)(v11 + 80 * v10 + 12) != (_DWORD)v6)
  {
    LODWORD(v10) = *(_DWORD *)(v11 + 80 * v10 + 8) & 0x7FFFFFFF;
    if ((_DWORD)v10 == 0x7FFFFFFF)
      goto LABEL_8;
  }
  v12 = v11 + 80 * v10;
  return v12 + 16;
}

void re::FrameProfiler::setEngineInitializedTimestamp(re::FrameProfiler *this, unint64_t a2)
{
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;

  if (*((_BYTE *)this + 206))
  {
    v4 = 0x7FFFFFFF;
    if (*((_QWORD *)this + 3))
    {
      v5 = *(_DWORD *)(*((_QWORD *)this + 4) + 4 * (0x706C8D494A7C5235uLL % *((unsigned int *)this + 12)));
      if (v5 != 0x7FFFFFFF)
      {
        v6 = *((_QWORD *)this + 5);
        v4 = *(_DWORD *)(*((_QWORD *)this + 4) + 4 * (0x706C8D494A7C5235uLL % *((unsigned int *)this + 12)));
        if (*(_DWORD *)(v6 + 24 * v5 + 12) != 1024)
        {
          while (1)
          {
            v4 = *(_DWORD *)(v6
                           + 24
                           * *(unsigned int *)(*((_QWORD *)this + 4)
                                             + 4 * (0x706C8D494A7C5235uLL % *((unsigned int *)this + 12)))
                           + 8) & 0x7FFFFFFF;
            if (v4 == 0x7FFFFFFF)
              break;
            if (*(_DWORD *)(v6 + 24 * v4 + 12) == 1024)
              goto LABEL_9;
          }
          v4 = 0x7FFFFFFF;
        }
      }
    }
LABEL_9:
    re::FrameThermalStats::setEngineInitializedTimestamp(*(re::FrameThermalStats **)(*((_QWORD *)this + 5) + 24 * v4 + 16), a2);
  }
  *((_QWORD *)this + 26) = a2;
}

void re::FrameProfiler::process(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  BOOL v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t *v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD *v34;
  _QWORD *v35;
  _WORD v36[36];

  if (!*(_BYTE *)(a1 + 206) || !*(_BYTE *)(a1 + 204))
    return;
  v7 = *(_QWORD **)a4;
  v8 = *(_QWORD **)(a4 + 8);
  if (*(_QWORD **)a4 == v8)
    goto LABEL_17;
  do
  {
    v9 = 0;
    v10 = *v7 + 64;
    do
    {
      v11 = (unint64_t *)(v10 + (v9 << 6));
      v12 = v11[3];
      if (v12)
      {
        v13 = v11[2];
        if (v13)
        {
          if (*(_QWORD *)(a1 + 344))
          {
            v14 = 0x94D049BB133111EBLL * ((0xBF58476D1CE4E5B9 * v9) ^ ((0xBF58476D1CE4E5B9 * v9) >> 27));
            v15 = (v14 ^ (v14 >> 31)) % *(unsigned int *)(a1 + 368);
            v16 = *(_QWORD *)(a1 + 360);
            v17 = *(unsigned int *)(*(_QWORD *)(a1 + 352) + 4 * v15);
            if ((_DWORD)v17 != 0x7FFFFFFF)
            {
              while (v9 != *(unsigned __int8 *)(v16 + 80 * v17 + 12))
              {
                v17 = *(_DWORD *)(v16 + 80 * v17 + 8) & 0x7FFFFFFF;
                if (v17 == 0x7FFFFFFF)
                  goto LABEL_13;
              }
              goto LABEL_14;
            }
          }
          else
          {
            v16 = *(_QWORD *)(a1 + 360);
          }
LABEL_13:
          LODWORD(v17) = 0x7FFFFFFF;
LABEL_14:
          re::FrameStats::CollectedStatistics::addGroupValues((re::FrameStats::CollectedStatistics *)(v16 + 80 * v17 + 16), (float)v13, (float)v12, (float)*v11, (float)*(unint64_t *)(v10 + (v9 << 6) + 8));
        }
      }
      ++v9;
    }
    while (v9 != 157);
    ++v7;
  }
  while (v7 != v8);
LABEL_17:
  v18 = *(_QWORD **)a5;
  v34 = *(_QWORD **)(a5 + 8);
  if (*(_QWORD **)a5 != v34)
  {
    while (1)
    {
      v19 = 0;
      v20 = 0;
      v35 = v18;
      v21 = *v18;
      do
      {
        if (*(_QWORD *)(v21 + 8 * v20))
          v22 = v19 > 0x1F;
        else
          v22 = 1;
        if (!v22)
          v36[v19++] = v20;
        ++v20;
      }
      while (v20 != 32);
      if (v19)
        break;
LABEL_41:
      v18 = v35 + 1;
      if (v35 + 1 == v34)
        return;
    }
    v23 = 0;
    while (1)
    {
      v24 = (unsigned __int16)v36[v23];
      if (*(_QWORD *)(a1 + 168) == v24)
        break;
LABEL_40:
      if (++v23 == v19)
        goto LABEL_41;
    }
    v25 = 0;
    v26 = *(_QWORD *)(v21 + 8 * v24) + 64;
    while (2)
    {
      v27 = (unint64_t *)(v26 + (v25 << 6));
      v28 = v27[3];
      if (!v28)
        goto LABEL_39;
      v29 = v27[2];
      if (!v29)
        goto LABEL_39;
      if (*(_QWORD *)(a1 + 392))
      {
        v30 = 0x94D049BB133111EBLL * ((0xBF58476D1CE4E5B9 * v25) ^ ((0xBF58476D1CE4E5B9 * v25) >> 27));
        v31 = (v30 ^ (v30 >> 31)) % *(unsigned int *)(a1 + 416);
        v32 = *(_QWORD *)(a1 + 408);
        v33 = *(unsigned int *)(*(_QWORD *)(a1 + 400) + 4 * v31);
        if ((_DWORD)v33 != 0x7FFFFFFF)
        {
          while (v25 != *(unsigned __int8 *)(v32 + 80 * v33 + 12))
          {
            v33 = *(_DWORD *)(v32 + 80 * v33 + 8) & 0x7FFFFFFF;
            if (v33 == 0x7FFFFFFF)
              goto LABEL_37;
          }
LABEL_38:
          re::FrameStats::CollectedStatistics::addGroupValues((re::FrameStats::CollectedStatistics *)(v32 + 80 * v33 + 16), (float)v29, (float)v28, (float)*v27, (float)*(unint64_t *)(v26 + (v25 << 6) + 8));
LABEL_39:
          if (++v25 == 157)
            goto LABEL_40;
          continue;
        }
      }
      else
      {
        v32 = *(_QWORD *)(a1 + 408);
      }
      break;
    }
LABEL_37:
    LODWORD(v33) = 0x7FFFFFFF;
    goto LABEL_38;
  }
}

void re::FrameProfiler::setOverlayEnabled(re::FrameProfiler *this, int a2)
{
  os_unfair_lock_s *v4;
  const char *v5;
  char v6;
  uint64_t v7;
  _BYTE v8[4];
  int v9;

  v4 = (os_unfair_lock_s *)((char *)this + 224);
  os_unfair_lock_lock((os_unfair_lock_t)this + 56);
  re::Defaults::intValue((re::Defaults *)"statisticsOverlayEnabled", v5, (uint64_t)v8);
  if (v8[0])
  {
    if (v9)
      v6 = a2;
    else
      v6 = 0;
    if (v9 != 1 && (v6 & 1) == 0)
      goto LABEL_7;
LABEL_10:
    if (!*((_BYTE *)this + 206))
      re::FrameProfiler::init(this);
    v7 = 1;
    goto LABEL_13;
  }
  if (a2)
    goto LABEL_10;
LABEL_7:
  if (!*((_BYTE *)this + 206))
  {
    LOBYTE(v7) = 0;
    goto LABEL_15;
  }
  re::FrameProfiler::deinit(this);
  v7 = 0;
LABEL_13:
  re::ProfilerManager::setProcessorEnabled<re::FrameProfiler,void>(*((_QWORD *)this + 23), v7);
LABEL_15:
  *((_BYTE *)this + 204) = v7;
  os_unfair_lock_unlock(v4);
}

void re::FrameProfiler::checkUserDefaultsForStatisticsOptions(re::FrameProfiler *this, const char *a2)
{
  const char *v3;
  const char *v4;
  const char *v5;
  const char *v6;
  const char *v7;
  const char *v8;
  const char *v9;
  const char *v10;
  const char *v11;
  const char *v12;
  const char *v13;
  const char *v14;
  const char *v15;
  const char *v16;
  const char *v17;
  const char *v18;
  re *v19;
  int v20;
  NSObject *v21;
  uint8_t v22[8];
  _BYTE v23[4];
  int v24;
  _BYTE v25[4];
  int v26;
  _BYTE v27[4];
  int v28;
  _BYTE v29[4];
  int v30;
  _BYTE v31[4];
  int v32;
  _BYTE v33[4];
  int v34;
  _BYTE v35[4];
  int v36;
  _BYTE v37[4];
  int v38;
  _BYTE v39[4];
  int v40;
  _BYTE v41[4];
  int v42;
  _BYTE v43[4];
  int v44;
  _BYTE v45[4];
  int v46;
  _BYTE v47[4];
  int v48;
  _BYTE v49[4];
  int v50;
  _BYTE v51[4];
  int v52;
  _BYTE v53[4];
  int v54;
  _BYTE v55[4];
  int v56;

  re::Defaults::intValue((re::Defaults *)"showFrameTimeStatistics", a2, (uint64_t)v55);
  re::Defaults::intValue((re::Defaults *)"showAnimationStatistics", v3, (uint64_t)v53);
  re::Defaults::intValue((re::Defaults *)"showAssetPipelineStatistics", v4, (uint64_t)v51);
  re::Defaults::intValue((re::Defaults *)"showAudioStatistics", v5, (uint64_t)v49);
  re::Defaults::intValue((re::Defaults *)"showECSStatistics", v6, (uint64_t)v47);
  re::Defaults::intValue((re::Defaults *)"showMeshStatistics", v7, (uint64_t)v45);
  re::Defaults::intValue((re::Defaults *)"showNetworkStatistics", v8, (uint64_t)v43);
  re::Defaults::intValue((re::Defaults *)"showPhysicsStatistics", v9, (uint64_t)v41);
  re::Defaults::intValue((re::Defaults *)"showRenderingStatistics", v10, (uint64_t)v39);
  re::Defaults::intValue((re::Defaults *)"showMemoryStatistics", v11, (uint64_t)v37);
  re::Defaults::intValue((re::Defaults *)"showThermalStatistics", v12, (uint64_t)v35);
  re::Defaults::intValue((re::Defaults *)"showSceneUnderstandingStatistics", v13, (uint64_t)v33);
  re::Defaults::intValue((re::Defaults *)"showCustomStatistics", v14, (uint64_t)v31);
  re::Defaults::intValue((re::Defaults *)"showAttributionStatistics", v15, (uint64_t)v29);
  re::Defaults::intValue((re::Defaults *)"showVFXStatistics", v16, (uint64_t)v27);
  re::Defaults::intValue((re::Defaults *)"showAllStatistics", v17, (uint64_t)v25);
  re::Defaults::intValue((re::Defaults *)"showMTLCounterAPIStatistics", v18, (uint64_t)v23);
  if (v55[0])
    *((_DWORD *)this + 44) = *((_DWORD *)this + 44) & 0xFFFFFFFE | (v56 != 0);
  if (v53[0])
    *((_DWORD *)this + 44) = *((_DWORD *)this + 44) & 0xFFFFFFFD | (2 * (v54 != 0));
  if (v51[0])
    *((_DWORD *)this + 44) = *((_DWORD *)this + 44) & 0xFFFFFFFB | (4 * (v52 != 0));
  if (v49[0])
    *((_DWORD *)this + 44) = *((_DWORD *)this + 44) & 0xFFFFFFF7 | (8 * (v50 != 0));
  if (v47[0])
    *((_DWORD *)this + 44) = *((_DWORD *)this + 44) & 0xFFFFFFEF | (16 * (v48 != 0));
  if (v45[0])
    *((_DWORD *)this + 44) = *((_DWORD *)this + 44) & 0xFFFFFFDF | (32 * (v46 != 0));
  if (v43[0])
    *((_DWORD *)this + 44) = *((_DWORD *)this + 44) & 0xFFFFFFBF | ((v44 != 0) << 6);
  if (v41[0])
    *((_DWORD *)this + 44) = *((_DWORD *)this + 44) & 0xFFFFFF7F | ((v42 != 0) << 7);
  if (v39[0])
    *((_DWORD *)this + 44) = *((_DWORD *)this + 44) & 0xFFFFFEFF | ((v40 != 0) << 8);
  if (v37[0])
    *((_DWORD *)this + 44) = *((_DWORD *)this + 44) & 0xFFFFFDFF | ((v38 != 0) << 9);
  if (v35[0])
    *((_DWORD *)this + 44) = *((_DWORD *)this + 44) & 0xFFFFFBFF | ((v36 != 0) << 10);
  if (v33[0])
    *((_DWORD *)this + 44) = *((_DWORD *)this + 44) & 0xFFFFF7FF | ((v34 != 0) << 11);
  if (v31[0])
    *((_DWORD *)this + 44) = *((_DWORD *)this + 44) & 0xFFFFDFFF | ((v32 != 0) << 13);
  if (v29[0])
    *((_DWORD *)this + 44) = *((_DWORD *)this + 44) & 0xFFFFBFFF | ((v30 != 0) << 14);
  if (v27[0])
    *((_DWORD *)this + 44) = *((_DWORD *)this + 44) & 0xFFFDFFFF | ((v28 != 0) << 17);
  if (v25[0])
  {
    if (v26)
      v20 = -1;
    else
      v20 = 0;
    *((_DWORD *)this + 44) = v20;
  }
  if (v23[0])
  {
    *((_DWORD *)this + 44) = *((_DWORD *)this + 44) & 0xFFFFEFFF | ((v24 != 0) << 12);
  }
  else
  {
    v21 = *re::foundationProfilingLogObjects(v19);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v22 = 0;
      _os_log_impl(&dword_224FE9000, v21, OS_LOG_TYPE_DEFAULT, "MTLCounter API disabled. Enable with 'defaults write -g com.apple.re.showMTLCounterAPIStatistics 1'", v22, 2u);
    }
  }
}

uint64_t re::FrameProfiler::totalNumberOfFlags(re::FrameProfiler *this, int a2)
{
  uint64_t v3;
  uint64_t v4;
  int *v5;
  int v6;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  int v10;
  int v11;

  v3 = *((unsigned int *)this + 14);
  if ((_DWORD)v3)
  {
    v4 = 0;
    v5 = (int *)(*((_QWORD *)this + 5) + 8);
    while (1)
    {
      v6 = *v5;
      v5 += 6;
      if (v6 < 0)
        break;
      if (v3 == ++v4)
      {
        LODWORD(v4) = *((_DWORD *)this + 14);
        break;
      }
    }
  }
  else
  {
    LODWORD(v4) = 0;
  }
  if ((_DWORD)v3 == (_DWORD)v4)
    return 0;
  LODWORD(result) = 0;
  v8 = v4;
  v9 = *((_QWORD *)this + 5);
  do
  {
    if ((*(_DWORD *)(v9 + 24 * v8 + 12) & a2) != 0)
      result = (result + 1);
    else
      result = result;
    if (v3 <= (int)v4 + 1)
      v10 = v4 + 1;
    else
      v10 = v3;
    v11 = v4;
    while (1)
    {
      v8 = (v11 + 1);
      if (v10 - 1 == v11)
        break;
      ++v11;
      LODWORD(v4) = v8;
      if ((*(_DWORD *)(v9 + 24 * v8 + 8) & 0x80000000) != 0)
        goto LABEL_21;
    }
    LODWORD(v4) = v10;
LABEL_21:
    ;
  }
  while ((_DWORD)v3 != (_DWORD)v4);
  return result;
}

uint64_t re::FrameProfiler::setProfilerUpdateInterval(uint64_t this, float a2)
{
  uint64_t v2;
  uint64_t v3;
  int *v4;
  int v5;
  int v6;
  uint64_t v7;
  int v8;
  int v9;

  if (*(_BYTE *)(this + 206))
  {
    v2 = *(unsigned int *)(this + 56);
    if ((_DWORD)v2)
    {
      v3 = 0;
      v4 = (int *)(*(_QWORD *)(this + 40) + 8);
      while (1)
      {
        v5 = *v4;
        v4 += 6;
        if (v5 < 0)
          break;
        if (v2 == ++v3)
        {
          LODWORD(v3) = *(_DWORD *)(this + 56);
          break;
        }
      }
    }
    else
    {
      LODWORD(v3) = 0;
    }
    if ((_DWORD)v2 == (_DWORD)v3)
    {
      v6 = (int)a2;
    }
    else
    {
      v7 = v3;
      v6 = (int)a2;
      do
      {
        *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(this + 40) + 24 * v7 + 16) + 8) = v6;
        if (v2 <= (int)v3 + 1)
          v8 = v3 + 1;
        else
          v8 = v2;
        v9 = v3;
        while (1)
        {
          v7 = (v9 + 1);
          if (v8 - 1 == v9)
            break;
          ++v9;
          LODWORD(v3) = v7;
          if ((*(_DWORD *)(*(_QWORD *)(this + 40) + 24 * v7 + 8) & 0x80000000) != 0)
            goto LABEL_19;
        }
        LODWORD(v3) = v8;
LABEL_19:
        ;
      }
      while ((_DWORD)v2 != (_DWORD)v3);
    }
    *(_DWORD *)(this + 192) = v6;
  }
  return this;
}

void re::FrameProfiler::checkUserDefaults(re::FrameProfiler *this, const char *a2)
{
  const char *v3;
  _BYTE v4[8];

  re::Defaults::intValue((re::Defaults *)"statisticsOverlayEnabled", a2, (uint64_t)v4);
  if (v4[0])
    re::FrameProfiler::setOverlayEnabled(this, 1);
  re::FrameProfiler::checkUserDefaultsForStatisticsOptions(this, v3);
}

float re::FrameProfiler::totalFrameTime(re::FrameProfiler *this)
{
  unsigned int v1;
  unsigned int v2;
  uint64_t v3;
  NSObject *v4;
  float v5;
  float v6;
  int v7;
  double v8;
  unint64_t v9;
  unint64_t v10;
  double v11;
  uint8_t v13[8];
  mach_timebase_info info;

  if (*((_BYTE *)this + 206))
  {
    v1 = 0x7FFFFFFF;
    if (*((_QWORD *)this + 43))
    {
      v2 = *(_DWORD *)(*((_QWORD *)this + 44) + 4 * (0x5692161D100B05E5uLL % *((unsigned int *)this + 92)));
      if (v2 != 0x7FFFFFFF)
      {
        v3 = *((_QWORD *)this + 45);
        v1 = *(_DWORD *)(*((_QWORD *)this + 44) + 4 * (0x5692161D100B05E5uLL % *((unsigned int *)this + 92)));
        if (*(_BYTE *)(v3 + 80 * v2 + 12) != 1)
        {
          while (1)
          {
            v1 = *(_DWORD *)(v3
                           + 80
                           * *(unsigned int *)(*((_QWORD *)this + 44)
                                             + 4 * (0x5692161D100B05E5uLL % *((unsigned int *)this + 92)))
                           + 8) & 0x7FFFFFFF;
            if (v1 == 0x7FFFFFFF)
              break;
            if (*(_BYTE *)(v3 + 80 * v1 + 12) == 1)
              goto LABEL_11;
          }
          v1 = 0x7FFFFFFF;
        }
      }
    }
LABEL_11:
    v6 = *(float *)(*((_QWORD *)this + 45) + 80 * v1 + 48);
    v7 = *((_DWORD *)this + 48);
    v8 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(&info))
      {
        v11 = NAN;
        return v11 / 1000000.0;
      }
      LODWORD(v9) = info.numer;
      LODWORD(v10) = info.denom;
      v8 = (double)v9 / (double)v10;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v8;
    }
    v11 = v8 * (double)(unint64_t)(float)(v6 / (float)v7);
    return v11 / 1000000.0;
  }
  v4 = *re::foundationProfilingLogObjects(this);
  v5 = -1.0;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v13 = 0;
    _os_log_impl(&dword_224FE9000, v4, OS_LOG_TYPE_DEFAULT, "totalFrameTime returns an accurate value only while statistics overlay is enabled", v13, 2u);
  }
  return v5;
}

float re::FrameThermalStats::setEngineInitializedTimestamp(re::FrameThermalStats *this, unint64_t a2)
{
  double v4;
  unint64_t v5;
  unint64_t v6;
  double v7;
  float result;
  mach_timebase_info info;

  v4 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale >= 0.0)
    goto LABEL_5;
  if (!mach_timebase_info(&info))
  {
    LODWORD(v5) = info.numer;
    LODWORD(v6) = info.denom;
    v4 = (double)v5 / (double)v6;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v4;
LABEL_5:
    v7 = v4 * (double)a2;
    goto LABEL_6;
  }
  v7 = NAN;
LABEL_6:
  result = v7 / 1000000.0;
  *((float *)this + 21) = result;
  return result;
}

uint64_t re::FrameProfiler::frameUpdateFinished(re::FrameProfiler *this)
{
  int v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  int *v6;
  int v7;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  int *v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int v20;
  uint64_t v21;
  __n128 *v22;
  uint64_t v23;
  __n128 v24;
  uint64_t v25;
  _QWORD *v26;
  _QWORD *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int *v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  int *v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  int *v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  int v51;
  int v52;
  int v53;

  if (!*((_BYTE *)this + 206))
    return 0;
  v2 = *((_DWORD *)this + 48);
  v3 = *((_DWORD *)this + 49) + 1;
  *((_DWORD *)this + 49) = v3;
  if (v3 != v2)
    return 0;
  v4 = *((unsigned int *)this + 94);
  if ((_DWORD)v4)
  {
    v5 = 0;
    v6 = (int *)(*((_QWORD *)this + 45) + 8);
    while (1)
    {
      v7 = *v6;
      v6 += 20;
      if (v7 < 0)
        break;
      if (v4 == ++v5)
      {
        LODWORD(v5) = *((_DWORD *)this + 94);
        break;
      }
    }
  }
  else
  {
    LODWORD(v5) = 0;
  }
  if ((_DWORD)v4 != (_DWORD)v5)
  {
    v9 = v5;
    do
    {
      v10 = *((_QWORD *)this + 45) + 80 * v9;
      *(_OWORD *)(v10 + 40) = *(_OWORD *)(v10 + 16);
      *(_DWORD *)(v10 + 56) = *(_DWORD *)(v10 + 32);
      *(_OWORD *)(v10 + 16) = xmmword_2261925B0;
      *(_DWORD *)(v10 + 32) = 0;
      if (v4 <= (int)v5 + 1)
        v11 = v5 + 1;
      else
        v11 = v4;
      v12 = v5;
      while (1)
      {
        v9 = (v12 + 1);
        if (v11 - 1 == v12)
          break;
        ++v12;
        LODWORD(v5) = v9;
        if ((*(_DWORD *)(*((_QWORD *)this + 45) + 80 * v9 + 8) & 0x80000000) != 0)
          goto LABEL_20;
      }
      LODWORD(v5) = v11;
LABEL_20:
      ;
    }
    while ((_DWORD)v4 != (_DWORD)v5);
  }
  v13 = *((unsigned int *)this + 106);
  if ((_DWORD)v13)
  {
    v14 = 0;
    v15 = (int *)(*((_QWORD *)this + 51) + 8);
    while (1)
    {
      v16 = *v15;
      v15 += 20;
      if (v16 < 0)
        break;
      if (v13 == ++v14)
      {
        LODWORD(v14) = *((_DWORD *)this + 106);
        break;
      }
    }
  }
  else
  {
    LODWORD(v14) = 0;
  }
  if ((_DWORD)v13 != (_DWORD)v14)
  {
    v17 = v14;
    do
    {
      v18 = *((_QWORD *)this + 51) + 80 * v17;
      *(_OWORD *)(v18 + 40) = *(_OWORD *)(v18 + 16);
      *(_DWORD *)(v18 + 56) = *(_DWORD *)(v18 + 32);
      *(_OWORD *)(v18 + 16) = xmmword_2261925B0;
      *(_DWORD *)(v18 + 32) = 0;
      if (v13 <= (int)v14 + 1)
        v19 = v14 + 1;
      else
        v19 = v13;
      v20 = v14;
      while (1)
      {
        v17 = (v20 + 1);
        if (v19 - 1 == v20)
          break;
        ++v20;
        LODWORD(v14) = v17;
        if ((*(_DWORD *)(*((_QWORD *)this + 51) + 80 * v17 + 8) & 0x80000000) != 0)
          goto LABEL_37;
      }
      LODWORD(v14) = v19;
LABEL_37:
      ;
    }
    while ((_DWORD)v13 != (_DWORD)v14);
  }
  *((_DWORD *)this + 49) = 0;
  v21 = *((_QWORD *)this + 40);
  *((_QWORD *)this + 40) = 0;
  if (v21)
  {
    v22 = (__n128 *)*((_QWORD *)this + 42);
    v23 = 48 * v21;
    v24 = 0uLL;
    do
    {
      if (v22->n128_u64[0])
      {
        if ((v22->n128_u8[8] & 1) != 0)
        {
          (*(void (**)(unint64_t, unint64_t, __n128))(*(_QWORD *)v22->n128_u64[0] + 40))(v22->n128_u64[0], v22[1].n128_u64[0], v24);
          v24 = 0uLL;
        }
        *v22 = v24;
        v22[1] = v24;
      }
      v22 += 3;
      v23 -= 48;
    }
    while (v23);
  }
  ++*((_DWORD *)this + 82);
  os_unfair_lock_lock((os_unfair_lock_t)this + 56);
  v25 = *((_QWORD *)this + 17);
  if (v25)
  {
    v26 = (_QWORD *)*((_QWORD *)this + 19);
    v27 = &v26[v25];
    do
    {
      v28 = *v26;
      if (*(_BYTE *)(*v26 + 160))
      {
        (*(void (**)(_QWORD, uint64_t, char *, char *))(*(_QWORD *)v28 + 24))(*v26, v28 + 16, (char *)this + 344, (char *)this + 392);
        v29 = *(unsigned int *)(v28 + 48);
        if ((_DWORD)v29)
        {
          v30 = 0;
          v31 = (int *)(*(_QWORD *)(v28 + 32) + 8);
          while (1)
          {
            v32 = *v31;
            v31 += 16;
            if (v32 < 0)
              break;
            if (v29 == ++v30)
            {
              LODWORD(v30) = *(_DWORD *)(v28 + 48);
              break;
            }
          }
        }
        else
        {
          LODWORD(v30) = 0;
        }
        if ((_DWORD)v29 != (_DWORD)v30)
        {
          v33 = v30;
          v34 = *(_QWORD *)(v28 + 32);
          do
          {
            re::DynamicArray<re::FrameStatisticsOutput>::add((uint64_t)this + 304, (re::DynamicString *)(v34 + (v33 << 6) + 16));
            v34 = *(_QWORD *)(v28 + 32);
            if (*(_DWORD *)(v28 + 48) <= (v30 + 1))
              v35 = v30 + 1;
            else
              v35 = *(_DWORD *)(v28 + 48);
            v36 = v30;
            while (1)
            {
              v33 = (v36 + 1);
              if (v35 - 1 == v36)
                break;
              ++v36;
              LODWORD(v30) = v33;
              if ((*(_DWORD *)(v34 + (v33 << 6) + 8) & 0x80000000) != 0)
                goto LABEL_64;
            }
            LODWORD(v30) = v35;
LABEL_64:
            ;
          }
          while ((_DWORD)v29 != (_DWORD)v30);
        }
      }
      ++v26;
    }
    while (v26 != v27);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)this + 56);
  v37 = *((unsigned int *)this + 14);
  if ((_DWORD)v37)
  {
    v38 = 0;
    v39 = (int *)(*((_QWORD *)this + 5) + 8);
    while (1)
    {
      v40 = *v39;
      v39 += 6;
      if (v40 < 0)
        break;
      if (v37 == ++v38)
      {
        LODWORD(v38) = *((_DWORD *)this + 14);
        break;
      }
    }
  }
  else
  {
    LODWORD(v38) = 0;
  }
  if ((_DWORD)v37 != (_DWORD)v38)
  {
    v41 = v38;
    do
    {
      v42 = *((_QWORD *)this + 5);
      if ((*((_DWORD *)this + 44) & *(_DWORD *)(v42 + 24 * v41 + 12)) != 0)
      {
        v43 = *(_QWORD *)(v42 + 24 * v41 + 16);
        (*(void (**)(uint64_t, uint64_t, char *, char *))(*(_QWORD *)v43 + 24))(v43, v43 + 16, (char *)this + 344, (char *)this + 392);
        v44 = *(unsigned int *)(v43 + 48);
        if ((_DWORD)v44)
        {
          v45 = 0;
          v46 = (int *)(*(_QWORD *)(v43 + 32) + 8);
          while (1)
          {
            v47 = *v46;
            v46 += 16;
            if (v47 < 0)
              break;
            if (v44 == ++v45)
            {
              LODWORD(v45) = *(_DWORD *)(v43 + 48);
              break;
            }
          }
        }
        else
        {
          LODWORD(v45) = 0;
        }
        if ((_DWORD)v44 != (_DWORD)v45)
        {
          v48 = v45;
          v49 = *(_QWORD *)(v43 + 32);
          do
          {
            re::DynamicArray<re::FrameStatisticsOutput>::add((uint64_t)this + 304, (re::DynamicString *)(v49 + (v48 << 6) + 16));
            v49 = *(_QWORD *)(v43 + 32);
            if (*(_DWORD *)(v43 + 48) <= (v45 + 1))
              v50 = v45 + 1;
            else
              v50 = *(_DWORD *)(v43 + 48);
            v51 = v45;
            while (1)
            {
              v48 = (v51 + 1);
              if (v50 - 1 == v51)
                break;
              ++v51;
              LODWORD(v45) = v48;
              if ((*(_DWORD *)(v49 + (v48 << 6) + 8) & 0x80000000) != 0)
                goto LABEL_91;
            }
            LODWORD(v45) = v50;
LABEL_91:
            ;
          }
          while ((_DWORD)v44 != (_DWORD)v45);
        }
      }
      if (*((_DWORD *)this + 14) <= (v38 + 1))
        v52 = v38 + 1;
      else
        v52 = *((_DWORD *)this + 14);
      while (1)
      {
        v41 = (v38 + 1);
        if (v52 - 1 == (_DWORD)v38)
          break;
        LODWORD(v38) = v38 + 1;
        v53 = v41;
        if ((*(_DWORD *)(*((_QWORD *)this + 5) + 24 * v41 + 8) & 0x80000000) != 0)
          goto LABEL_99;
      }
      v53 = v52;
LABEL_99:
      LODWORD(v38) = v53;
    }
    while ((_DWORD)v37 != v53);
  }
  return 1;
}

re::DynamicString *re::DynamicArray<re::FrameStatisticsOutput>::add(uint64_t a1, re::DynamicString *a2)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  BOOL v8;
  unint64_t v9;
  unint64_t v10;
  re::DynamicString *result;
  uint64_t v12;

  v4 = *(_QWORD *)(a1 + 8);
  v5 = *(_QWORD *)(a1 + 16);
  if (v5 >= v4)
  {
    v6 = v5 + 1;
    if (v4 < v5 + 1)
    {
      if (*(_QWORD *)a1)
      {
        v7 = 2 * v4;
        v8 = v4 == 0;
        v9 = 8;
        if (!v8)
          v9 = v7;
        if (v9 <= v6)
          v10 = v6;
        else
          v10 = v9;
        re::DynamicArray<re::FrameStatisticsOutput>::setCapacity((_QWORD *)a1, v10);
      }
      else
      {
        re::DynamicArray<re::FrameStatisticsOutput>::setCapacity((_QWORD *)a1, v6);
        ++*(_DWORD *)(a1 + 24);
      }
    }
    v5 = *(_QWORD *)(a1 + 16);
  }
  result = re::DynamicString::DynamicString((re::DynamicString *)(*(_QWORD *)(a1 + 32) + 48 * v5), a2);
  v12 = *((_QWORD *)a2 + 4);
  *((_DWORD *)result + 10) = *((_DWORD *)a2 + 10);
  *((_QWORD *)result + 4) = v12;
  ++*(_QWORD *)(a1 + 16);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

void re::FrameProfiler::addCustomFrameStats(os_unfair_lock_s *this, const char *a2, float a3)
{
  os_unfair_lock_s *v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  unint64_t Stat;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;

  if (BYTE2(this[51]._os_unfair_lock_opaque))
  {
    v6 = this + 56;
    os_unfair_lock_lock(this + 56);
    v7 = 0x7FFFFFFF;
    if (*(_QWORD *)&this[6]._os_unfair_lock_opaque)
    {
      v8 = *(_DWORD *)(*(_QWORD *)&this[8]._os_unfair_lock_opaque
                     + 4 * (0xF6E8F5E9060644CuLL % this[12]._os_unfair_lock_opaque));
      if (v8 != 0x7FFFFFFF)
      {
        v9 = *(_QWORD *)&this[10]._os_unfair_lock_opaque;
        v7 = *(_DWORD *)(*(_QWORD *)&this[8]._os_unfair_lock_opaque
                       + 4 * (0xF6E8F5E9060644CuLL % this[12]._os_unfair_lock_opaque));
        if (*(_DWORD *)(v9 + 24 * v8 + 12) != 0x2000)
        {
          while (1)
          {
            v7 = *(_DWORD *)(v9
                           + 24
                           * *(unsigned int *)(*(_QWORD *)&this[8]._os_unfair_lock_opaque
                                             + 4 * (0xF6E8F5E9060644CuLL % this[12]._os_unfair_lock_opaque))
                           + 8) & 0x7FFFFFFF;
            if (v7 == 0x7FFFFFFF)
              break;
            if (*(_DWORD *)(v9 + 24 * v7 + 12) == 0x2000)
              goto LABEL_10;
          }
          v7 = 0x7FFFFFFF;
        }
      }
    }
LABEL_10:
    Stat = re::FrameCustomStats::addOrGetStat(*(re::FrameCustomStats **)(*(_QWORD *)&this[10]._os_unfair_lock_opaque + 24 * v7 + 16), a2);
    if (*(_QWORD *)&this[6]._os_unfair_lock_opaque)
    {
      v11 = *(_QWORD *)&this[10]._os_unfair_lock_opaque;
      v12 = *(unsigned int *)(*(_QWORD *)&this[8]._os_unfair_lock_opaque
                            + 4 * (0xF6E8F5E9060644CuLL % this[12]._os_unfair_lock_opaque));
      v13 = 0x7FFFFFFF;
      if ((_DWORD)v12 != 0x7FFFFFFF)
      {
        if (*(_DWORD *)(v11 + 24 * v12 + 12) == 0x2000)
        {
LABEL_15:
          v13 = v12;
        }
        else
        {
          while (1)
          {
            LODWORD(v12) = *(_DWORD *)(v11 + 24 * v12 + 8) & 0x7FFFFFFF;
            v13 = 0x7FFFFFFF;
            if ((_DWORD)v12 == 0x7FFFFFFF)
              break;
            if (*(_DWORD *)(v11 + 24 * v12 + 12) == 0x2000)
              goto LABEL_15;
          }
        }
      }
    }
    else
    {
      v11 = *(_QWORD *)&this[10]._os_unfair_lock_opaque;
      v13 = 0x7FFFFFFF;
    }
    v14 = *(_QWORD *)(v11 + 24 * v13 + 16);
    if (*(_QWORD *)(v14 + 136) > Stat)
      re::FrameStats::CollectedStatistics::addValue((re::FrameStats::CollectedStatistics *)(*(_QWORD *)(v14 + 152) + 104 * Stat + 36), a3);
    os_unfair_lock_unlock(v6);
  }
}

uint64_t re::FrameProfiler::addOrGetCustomStatClass(os_unfair_lock_s *this, const char *a2)
{
  os_unfair_lock_s *v4;
  _anonymous_namespace_ *v5;
  uint64_t *v6;
  re *v7;
  uint64_t v8;
  uint64_t *v9;
  re::FrameCustomStats *v10;
  _anonymous_namespace_ *v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  BOOL v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _BYTE v22[12];
  __int16 v23;
  int v24;
  __int16 v25;
  uint64_t v26;
  __int16 v27;
  uint64_t v28;
  _OWORD v29[5];
  uint64_t v30;

  v30 = *MEMORY[0x24BDAC8D0];
  v4 = this + 56;
  os_unfair_lock_lock(this + 56);
  v6 = (uint64_t *)re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)&this[18], (uint64_t)v29);
  v7 = *(re **)&v29[0];
  if (*(_QWORD *)&v29[0] && (BYTE8(v29[0]) & 1) != 0)
    v7 = (re *)(*(uint64_t (**)(void))(**(_QWORD **)&v29[0] + 40))();
  if (v6)
  {
    v8 = *v6;
  }
  else
  {
    v9 = re::globalAllocators(v7);
    v10 = (re::FrameCustomStats *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v9[2] + 32))(v9[2], 168, 8);
    v11 = re::FrameCustomStats::FrameCustomStats(v10);
    v12 = *(_QWORD *)&this[32]._os_unfair_lock_opaque;
    v13 = *(_QWORD *)&this[34]._os_unfair_lock_opaque;
    if (v13 >= v12)
    {
      v14 = v13 + 1;
      if (v12 < v13 + 1)
      {
        if (*(_QWORD *)&this[30]._os_unfair_lock_opaque)
        {
          v15 = 2 * v12;
          v16 = v12 == 0;
          v17 = 8;
          if (!v16)
            v17 = v15;
          if (v17 <= v14)
            v18 = v14;
          else
            v18 = v17;
          v11 = (_anonymous_namespace_ *)re::DynamicArray<float *>::setCapacity(&this[30]._os_unfair_lock_opaque, v18);
        }
        else
        {
          v11 = (_anonymous_namespace_ *)re::DynamicArray<float *>::setCapacity(&this[30]._os_unfair_lock_opaque, v14);
          ++this[36]._os_unfair_lock_opaque;
        }
      }
      v13 = *(_QWORD *)&this[34]._os_unfair_lock_opaque;
    }
    *(_QWORD *)(*(_QWORD *)&this[38]._os_unfair_lock_opaque + 8 * v13) = v10;
    *(_QWORD *)&this[34]._os_unfair_lock_opaque = v13 + 1;
    ++this[36]._os_unfair_lock_opaque;
    *(_QWORD *)v22 = *(_QWORD *)&this[34]._os_unfair_lock_opaque - 1;
    re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<unsigned long &>((uint64_t)&this[18], (re::DynamicString *)v29, v22);
    if (*(_QWORD *)&v29[0] && (BYTE8(v29[0]) & 1) != 0)
      (*(void (**)(void))(**(_QWORD **)&v29[0] + 40))();
    v19 = *(_QWORD *)&this[34]._os_unfair_lock_opaque;
    v20 = v19 - 1;
    if (!v19)
    {
      memset(v29, 0, sizeof(v29));
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v22 = 136315906;
      *(_QWORD *)&v22[4] = "operator[]";
      v23 = 1024;
      v24 = 789;
      v25 = 2048;
      v26 = v20;
      v27 = 2048;
      v28 = 0;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    re::FrameCustomStats::addOrGetLine(*(re::FrameCustomStats **)(*(_QWORD *)&this[38]._os_unfair_lock_opaque + 8 * v20), a2);
    v8 = *(_QWORD *)&this[34]._os_unfair_lock_opaque - 1;
  }
  os_unfair_lock_unlock(v4);
  return v8;
}

void re::FrameProfiler::setCustomStatClassEnabled(os_unfair_lock_s *this, unint64_t a2, char a3)
{
  os_unfair_lock_s *v6;

  v6 = this + 56;
  os_unfair_lock_lock(this + 56);
  if (*(_QWORD *)&this[34]._os_unfair_lock_opaque > a2)
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)&this[38]._os_unfair_lock_opaque + 8 * a2) + 160) = a3;
  os_unfair_lock_unlock(v6);
}

uint64_t re::FrameProfiler::addOrGetStatLine(os_unfair_lock_s *this, unint64_t a2, const char *a3)
{
  os_unfair_lock_s *v6;
  uint64_t Stat;

  v6 = this + 56;
  os_unfair_lock_lock(this + 56);
  if (*(_QWORD *)&this[34]._os_unfair_lock_opaque <= a2)
    Stat = 0;
  else
    Stat = re::FrameCustomStats::addOrGetStat(*(re::FrameCustomStats **)(*(_QWORD *)&this[38]._os_unfair_lock_opaque + 8 * a2), a3);
  os_unfair_lock_unlock(v6);
  return Stat;
}

void re::FrameProfiler::logStat(os_unfair_lock_s *this, unint64_t a2, unint64_t a3, float a4)
{
  os_unfair_lock_s *v8;
  uint64_t v9;

  if (BYTE2(this[51]._os_unfair_lock_opaque))
  {
    v8 = this + 56;
    os_unfair_lock_lock(this + 56);
    if (*(_QWORD *)&this[34]._os_unfair_lock_opaque > a2)
    {
      v9 = *(_QWORD *)(*(_QWORD *)&this[38]._os_unfair_lock_opaque + 8 * a2);
      if (*(_QWORD *)(v9 + 136) > a3)
        re::FrameStats::CollectedStatistics::addValue((re::FrameStats::CollectedStatistics *)(*(_QWORD *)(v9 + 152) + 104 * a3 + 36), a4);
    }
    os_unfair_lock_unlock(v8);
  }
}

uint64_t re::FrameProfiler::addOrGetLine(os_unfair_lock_s *this, unint64_t a2, const char *a3)
{
  os_unfair_lock_s *v6;
  uint64_t Line;

  v6 = this + 56;
  os_unfair_lock_lock(this + 56);
  if (*(_QWORD *)&this[34]._os_unfair_lock_opaque <= a2)
    Line = 0;
  else
    Line = re::FrameCustomStats::addOrGetLine(*(re::FrameCustomStats **)(*(_QWORD *)&this[38]._os_unfair_lock_opaque + 8 * a2), a3);
  os_unfair_lock_unlock(v6);
  return Line;
}

void re::FrameProfiler::updateText(os_unfair_lock_s *this, unint64_t a2, unint64_t a3, const char *a4)
{
  os_unfair_lock_s *v8;

  v8 = this + 56;
  os_unfair_lock_lock(this + 56);
  if (*(_QWORD *)&this[34]._os_unfair_lock_opaque > a2)
    re::FrameCustomStats::updateText(*(_QWORD **)(*(_QWORD *)&this[38]._os_unfair_lock_opaque + 8 * a2), a3, a4);
  os_unfair_lock_unlock(v8);
}

void re::FrameProfiler::setCustomStatOrLineEnabled(os_unfair_lock_s *this, unint64_t a2, unint64_t a3, char a4)
{
  os_unfair_lock_s *v8;
  uint64_t v9;

  v8 = this + 56;
  os_unfair_lock_lock(this + 56);
  if (*(_QWORD *)&this[34]._os_unfair_lock_opaque > a2)
  {
    v9 = *(_QWORD *)(*(_QWORD *)&this[38]._os_unfair_lock_opaque + 8 * a2);
    if (*(_QWORD *)(v9 + 136) > a3)
      *(_BYTE *)(*(_QWORD *)(v9 + 152) + 104 * a3 + 32) = a4;
  }
  os_unfair_lock_unlock(v8);
}

re::DynamicString *re::FrameProfiler::getStatisticOutputForOption(re::FrameProfiler *this, unsigned int a2, int a3)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  re::DynamicString *v13;
  uint64_t v15;
  uint64_t v16;
  int *v17;
  int v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  const char *v22;
  size_t v23;
  unsigned int v24;
  unsigned int v25;

  LODWORD(v4) = 0x7FFFFFFF;
  if (*((_QWORD *)this + 3))
  {
    v5 = 0xBF58476D1CE4E5B9 * (a2 ^ ((unint64_t)a2 >> 30));
    v6 = *(unsigned int *)(*((_QWORD *)this + 4)
                         + 4
                         * (((0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) ^ ((0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) >> 31))
                          % *((unsigned int *)this + 12)));
    if ((_DWORD)v6 != 0x7FFFFFFF)
    {
      v7 = *((_QWORD *)this + 5);
      LODWORD(v4) = v6;
      if (*(_DWORD *)(v7 + 24 * v6 + 12) != a2)
      {
        v4 = v6;
        while (1)
        {
          LODWORD(v4) = *(_DWORD *)(v7 + 24 * v4 + 8) & 0x7FFFFFFF;
          if ((_DWORD)v4 == 0x7FFFFFFF)
            break;
          if (*(_DWORD *)(v7 + 24 * v4 + 12) == a2)
            goto LABEL_9;
        }
        LODWORD(v4) = 0x7FFFFFFF;
      }
    }
  }
LABEL_9:
  v8 = *(_QWORD *)(*((_QWORD *)this + 5) + 24 * v4 + 16);
  (*(void (**)(uint64_t, uint64_t, char *, char *))(*(_QWORD *)v8 + 24))(v8, v8 + 16, (char *)this + 344, (char *)this + 392);
  LODWORD(v9) = 0x7FFFFFFF;
  if (*(_QWORD *)(v8 + 16))
  {
    v10 = **(unsigned int **)(v8 + 24);
    if ((_DWORD)v10 != 0x7FFFFFFF)
    {
      v11 = *(_QWORD *)(v8 + 32);
      if (*(_DWORD *)(v11 + (v10 << 6) + 12))
      {
        v9 = **(unsigned int **)(v8 + 24);
        while (1)
        {
          v9 = *(_DWORD *)(v11 + (v9 << 6) + 8) & 0x7FFFFFFF;
          if ((_DWORD)v9 == 0x7FFFFFFF)
            break;
          if (!*(_DWORD *)(v11 + (v9 << 6) + 12))
            goto LABEL_18;
        }
        LODWORD(v9) = 0x7FFFFFFF;
      }
      else
      {
        LODWORD(v9) = **(_DWORD **)(v8 + 24);
      }
    }
  }
LABEL_18:
  v12 = *(_QWORD *)(v8 + 32);
  v13 = (re::DynamicString *)(v12 + ((unint64_t)v9 << 6) + 16);
  if (*(_DWORD *)(v8 + 44) != 1 && a3 != 0)
  {
    v15 = *(unsigned int *)(v8 + 48);
    if ((_DWORD)v15)
    {
      v16 = 0;
      v17 = (int *)(v12 + 8);
      while (1)
      {
        v18 = *v17;
        v17 += 16;
        if (v18 < 0)
          break;
        if (v15 == ++v16)
        {
          LODWORD(v16) = *(_DWORD *)(v8 + 48);
          break;
        }
      }
    }
    else
    {
      LODWORD(v16) = 0;
    }
    if ((_DWORD)v15 != (_DWORD)v16)
    {
      v19 = v16;
      v20 = *(_DWORD *)(v8 + 48);
      do
      {
        v21 = v12 + (v19 << 6);
        if (*(_DWORD *)(v21 + 12))
        {
          if ((*(_BYTE *)(v21 + 24) & 1) != 0)
            v22 = *(const char **)(v21 + 32);
          else
            v22 = (const char *)(v21 + 25);
          v23 = strlen(v22);
          re::DynamicString::append(v13, v22, v23);
          v20 = *(_DWORD *)(v8 + 48);
          v12 = *(_QWORD *)(v8 + 32);
        }
        if (v20 <= (int)v16 + 1)
          v24 = v16 + 1;
        else
          v24 = v20;
        while (1)
        {
          v19 = (v16 + 1);
          if (v24 - 1 == (_DWORD)v16)
            break;
          LODWORD(v16) = v16 + 1;
          v25 = v19;
          if ((*(_DWORD *)(v12 + (v19 << 6) + 8) & 0x80000000) != 0)
            goto LABEL_42;
        }
        v25 = v24;
LABEL_42:
        LODWORD(v16) = v25;
      }
      while ((_DWORD)v15 != v25);
    }
  }
  return v13;
}

uint64_t *re::allocInfo_FrameProfiler(re *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&_MergedGlobals_423);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&_MergedGlobals_423))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_25411D7E0, 0);
    *(uint64_t *)((char *)&qword_25411D7F0 + 6) = 0;
    qword_25411D7F0 = 0;
    qword_25411D800 = 0;
    qword_25411D808 = 0xFFFFFFFFLL;
    qword_25411D7E0 = (uint64_t)&off_24ED7DAA8;
    qword_25411D810 = (uint64_t)"FrameProfiler";
    dword_25411D818 = 0;
    unk_25411D820 = 0u;
    unk_25411D830 = 0u;
    unk_25411D840 = 0u;
    qword_25411D850 = 0;
    __cxa_guard_release(&_MergedGlobals_423);
  }
  return &qword_25411D7E0;
}

void re::initInfo_FrameProfiler(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  __int128 v4;
  _QWORD v5[2];
  __int128 v6;

  v5[0] = 0x4D07016EB3F258ACLL;
  v5[1] = "FrameProfiler";
  re::StringID::destroyString((re::StringID *)v5);
  *((_OWORD *)this + 2) = v6;
  *((_QWORD *)this + 2) = 0x1B800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 8) = &re::initInfo_FrameProfiler(re::IntrospectionBase *)::structureAttributes;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::FrameProfiler>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::FrameProfiler>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::FrameProfiler>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::FrameProfiler>;
  re::IntrospectionRegistry::add(this, v3);
  v4 = v6;
}

re::FrameProfiler *re::internal::defaultConstruct<re::FrameProfiler>(int a1, int a2, re::FrameProfiler *this)
{
  return re::FrameProfiler::FrameProfiler(this);
}

void re::internal::defaultDestruct<re::FrameProfiler>(int a1, int a2, re::FrameProfiler *this)
{
  re::FrameProfiler::~FrameProfiler(this);
}

uint64_t re::introspect_FrameProfiler(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"FrameProfiler", (uint64_t (*)(re::internal *))re::allocInfo_FrameProfiler, (re::IntrospectionBase *(*)(void))re::initInfo_FrameProfiler, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::FrameProfiler>, this);
}

uint64_t re::FrameProfiler::willNeedEvents(re::FrameProfiler *this)
{
  return 0;
}

uint64_t re::FrameProfiler::willNeedStatistics(re::FrameProfiler *this)
{
  return 1;
}

uint64_t re::FrameProfiler::willNeedAttributions(re::FrameProfiler *this)
{
  return 1;
}

uint64_t re::FrameProfiler::willNeedMemoryStatistics(re::FrameProfiler *this)
{
  return 0;
}

uint64_t re::HashTable<unsigned int,re::FrameStatisticsOutput,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::addEmplace<re::FrameStatisticsOutput&>(uint64_t a1, unsigned int a2, unint64_t a3, _DWORD *a4, re::DynamicString *a5)
{
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;

  v10 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
    v10 = *(unsigned int *)(a1 + 32);
    v11 = v10;
    if ((_DWORD)v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<unsigned int,re::FrameStatisticsOutput,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + (v10 << 6) + 8);
  }
  else
  {
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + (v10 << 6) + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + (v10 << 6) + 8) = v13 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + (v10 << 6) + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + (v10 << 6) + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + (v10 << 6)) = a3;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + (v10 << 6) + 12) = *a4;
  v14 = *(_QWORD *)(a1 + 16) + (v10 << 6);
  re::DynamicString::DynamicString((re::DynamicString *)(v14 + 16), a5);
  v15 = *((_QWORD *)a5 + 4);
  *(_DWORD *)(v14 + 56) = *((_DWORD *)a5 + 10);
  *(_QWORD *)(v14 + 48) = v15;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

void re::HashTable<unsigned int,re::FrameStatisticsOutput,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  __int128 v7;
  __int128 v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  signed int v12;
  _BYTE v13[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(_QWORD *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<unsigned long long,re::Function<void ()(void)>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init((uint64_t)v13, v4, a2);
      v5 = *(_OWORD *)v13;
      *(_OWORD *)v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      v6 = *(_QWORD *)&v13[16];
      *(_QWORD *)&v13[16] = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 16) = v6;
      v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      v7 = *(_OWORD *)&v13[24];
      *(_OWORD *)(a1 + 24) = v8;
      v9 = DWORD2(v7);
      if (DWORD2(v7))
      {
        v10 = 0;
        v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(_QWORD *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<unsigned int,re::FrameStatisticsOutput,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::addAsMove(a1, *(_QWORD *)(*(_QWORD *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(*(_QWORD *)&v13[16] + v10), (_DWORD *)(*(_QWORD *)&v13[16] + v10 + 12), *(_QWORD *)&v13[16] + v10 + 16);
            v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 64;
        }
        while (v11 < v9);
      }
      re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v13, *(double *)&v7);
    }
  }
  else
  {
    if (a2)
      v12 = a2;
    else
      v12 = 3;
  }
}

uint64_t re::HashTable<unsigned int,re::FrameStatisticsOutput,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, _DWORD *a4, uint64_t a5)
{
  uint64_t v9;
  int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v9 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
    v9 = *(unsigned int *)(a1 + 32);
    v10 = v9;
    if ((_DWORD)v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<unsigned int,re::FrameStatisticsOutput,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::setCapacity(a1, (2 * *(_DWORD *)(a1 + 28)));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + (v9 << 6) + 8);
  }
  else
  {
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + (v9 << 6) + 8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v11 + (v9 << 6) + 8) = v12 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + (v9 << 6) + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + (v9 << 6) + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + (v9 << 6)) = a3;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + (v9 << 6) + 12) = *a4;
  v13 = *(_QWORD *)(a1 + 16) + (v9 << 6);
  *(_OWORD *)(v13 + 16) = 0u;
  *(_OWORD *)(v13 + 32) = 0u;
  *(_QWORD *)(v13 + 40) = *(_QWORD *)(a5 + 24);
  v14 = *(_QWORD *)(a5 + 8);
  *(_QWORD *)(v13 + 16) = *(_QWORD *)a5;
  *(_QWORD *)a5 = 0;
  v15 = *(_QWORD *)(a5 + 16);
  *(_QWORD *)(a5 + 24) = 0;
  v17 = *(_QWORD *)(v13 + 24);
  v16 = *(_QWORD *)(v13 + 32);
  *(_QWORD *)(v13 + 24) = v14;
  *(_QWORD *)(v13 + 32) = v15;
  *(_QWORD *)(a5 + 8) = v17;
  *(_QWORD *)(a5 + 16) = v16;
  v18 = *(_QWORD *)(a5 + 32);
  *(_DWORD *)(v13 + 56) = *(_DWORD *)(a5 + 40);
  *(_QWORD *)(v13 + 48) = v18;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

BOOL re::HashTable<unsigned int,re::FrameStatisticsOutput,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::containsKey(uint64_t a1, unsigned int *a2)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  _BOOL8 result;
  uint64_t v6;

  if (!*(_QWORD *)a1)
    return 0;
  v2 = *a2;
  v3 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (v2 ^ (v2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v2 ^ (v2 >> 30))) >> 27));
  v4 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * ((v3 ^ (v3 >> 31)) % *(unsigned int *)(a1 + 24)));
  if ((_DWORD)v4 == 0x7FFFFFFF)
    return 0;
  v6 = *(_QWORD *)(a1 + 16);
  if (*(_DWORD *)(v6 + (v4 << 6) + 12) == (_DWORD)v2)
    return 1;
  do
  {
    v4 = *(_DWORD *)(v6 + (v4 << 6) + 8) & 0x7FFFFFFF;
    result = (_DWORD)v4 != 0x7FFFFFFF;
  }
  while ((_DWORD)v4 != 0x7FFFFFFF && *(_DWORD *)(v6 + (v4 << 6) + 12) != (_DWORD)v2);
  return result;
}

void re::HashTable<re::FrameProfilerStatisticsOptions,re::FrameStats *,re::Hash<re::FrameProfilerStatisticsOptions>,re::EqualTo<re::FrameProfilerStatisticsOptions>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  __int128 v7;
  unsigned int v8;
  __int128 v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  _QWORD *v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  signed int v21;
  _BYTE v22[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v22, 0, 36);
      *(_QWORD *)&v22[36] = 0x7FFFFFFFLL;
      re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::init((uint64_t)v22, v4, a2);
      v5 = *(_OWORD *)a1;
      *(_QWORD *)a1 = *(_QWORD *)v22;
      v6 = *(_QWORD *)(a1 + 16);
      v7 = *(_OWORD *)&v22[8];
      *(_OWORD *)v22 = v5;
      *(_QWORD *)&v22[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      v9 = *(_OWORD *)&v22[24];
      *(_OWORD *)&v22[24] = *(_OWORD *)(a1 + 24);
      v8 = *(_DWORD *)&v22[32];
      *(_OWORD *)(a1 + 24) = v9;
      v10 = v8;
      if (v8)
      {
        v11 = DWORD1(v9);
        v12 = v7;
        v13 = (_QWORD *)(v6 + 16);
        do
        {
          if ((*(_DWORD *)(v13 - 1) & 0x80000000) != 0)
          {
            v14 = *(v13 - 2);
            v15 = *(unsigned int *)(a1 + 24);
            v16 = v14 % v15;
            v17 = *(unsigned int *)(a1 + 36);
            if ((_DWORD)v17 == 0x7FFFFFFF)
            {
              v17 = *(unsigned int *)(a1 + 32);
              v18 = v17;
              if ((_DWORD)v17 == (_DWORD)v15)
              {
                re::HashTable<re::FrameProfilerStatisticsOptions,re::FrameStats *,re::Hash<re::FrameProfilerStatisticsOptions>,re::EqualTo<re::FrameProfilerStatisticsOptions>,true,false>::setCapacity(a1, (2 * v11));
                v16 = v14 % *(unsigned int *)(a1 + 24);
                v18 = *(_DWORD *)(a1 + 32);
                v12 = *(_QWORD *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v18 + 1;
              v19 = *(_QWORD *)(a1 + 16);
              v20 = *(_DWORD *)(v19 + 24 * v17 + 8);
            }
            else
            {
              v19 = *(_QWORD *)(a1 + 16);
              v20 = *(_DWORD *)(v19 + 24 * v17 + 8);
              *(_DWORD *)(a1 + 36) = v20 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v19 + 24 * v17 + 8) = v20 | 0x80000000;
            *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v17 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v17 + 8) & 0x80000000 | *(_DWORD *)(v12 + 4 * v16);
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v17) = v14;
            *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v17 + 12) = *((_DWORD *)v13 - 1);
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v17 + 16) = *v13;
            v12 = *(_QWORD *)(a1 + 8);
            *(_DWORD *)(v12 + 4 * v16) = v17;
            v11 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v11;
          }
          v13 += 3;
          --v10;
        }
        while (v10);
      }
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)v22);
    }
  }
  else
  {
    if (a2)
      v21 = a2;
    else
      v21 = 3;
  }
}

void re::HashTable<re::ProfilerStatistic,re::FrameStats::CollectedStatistics,re::Hash<re::ProfilerStatistic>,re::EqualTo<re::ProfilerStatistic>,true,false>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;

  if (*(_DWORD *)(a1 + 28))
  {
    v2 = *(unsigned int *)(a1 + 24);
    if ((_DWORD)v2)
      memset_pattern16(*(void **)(a1 + 8), &unk_2260EB7B0, 4 * v2);
    v3 = *(unsigned int *)(a1 + 32);
    if ((_DWORD)v3)
    {
      v4 = 0;
      v5 = 80 * v3;
      do
      {
        v6 = *(_QWORD *)(a1 + 16) + v4;
        v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
        v4 += 80;
      }
      while (v5 != v4);
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    v8 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v8;
  }
}

void re::HashTable<re::ProfilerStatistic,re::FrameStats::CollectedStatistics,re::Hash<re::ProfilerStatistic>,re::EqualTo<re::ProfilerStatistic>,true,false>::copy(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t i;
  uint64_t v8;

  re::HashTable<re::ProfilerStatistic,re::FrameStats::CollectedStatistics,re::Hash<re::ProfilerStatistic>,re::EqualTo<re::ProfilerStatistic>,true,false>::clear(a1);
  v4 = *(_DWORD *)(a2 + 28);
  if (*(_DWORD *)(a1 + 24) < v4)
    re::HashTable<re::ProfilerStatistic,re::FrameStats::CollectedStatistics,re::Hash<re::ProfilerStatistic>,re::EqualTo<re::ProfilerStatistic>,true,false>::setCapacity(a1, v4);
  v5 = *(unsigned int *)(a2 + 32);
  if ((_DWORD)v5)
  {
    v6 = 0;
    for (i = 0; i < v5; ++i)
    {
      v8 = *(_QWORD *)(a2 + 16) + v6;
      if ((*(_DWORD *)(v8 + 8) & 0x80000000) != 0)
      {
        re::HashTable<re::ProfilerStatistic,re::FrameStats::CollectedStatistics,re::Hash<re::ProfilerStatistic>,re::EqualTo<re::ProfilerStatistic>,true,false>::addAsCopy(a1, *(_QWORD *)v8 % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)v8, (_BYTE *)(v8 + 12), (re::FrameStats::CollectedStatistics *)(v8 + 16));
        v5 = *(unsigned int *)(a2 + 32);
      }
      v6 += 80;
    }
  }
}

void re::HashTable<re::ProfilerStatistic,re::FrameStats::CollectedStatistics,re::Hash<re::ProfilerStatistic>,re::EqualTo<re::ProfilerStatistic>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  unsigned int v7;
  __int128 v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  signed int v12;
  _BYTE v13[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(_QWORD *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::ecs2::Scene *,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene *>,re::EqualTo<re::ecs2::Scene *>,true,false>::init((uint64_t)v13, v4, a2);
      v5 = *(_OWORD *)v13;
      *(_OWORD *)v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      v6 = *(_QWORD *)&v13[16];
      *(_QWORD *)&v13[16] = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 16) = v6;
      v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      v9 = v7;
      if (v7)
      {
        v10 = 0;
        v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(_QWORD *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<re::ProfilerStatistic,re::FrameStats::CollectedStatistics,re::Hash<re::ProfilerStatistic>,re::EqualTo<re::ProfilerStatistic>,true,false>::addAsCopy(a1, *(_QWORD *)(*(_QWORD *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(*(_QWORD *)&v13[16] + v10), (_BYTE *)(*(_QWORD *)&v13[16] + v10 + 12), (re::FrameStats::CollectedStatistics *)(*(_QWORD *)&v13[16] + v10 + 16));
            v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 80;
        }
        while (v11 < v9);
      }
      re::HashTable<unsigned long long,re::ecs2::RenderPassGroupBoundsInfo,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2)
      v12 = a2;
    else
      v12 = 3;
  }
}

uint64_t re::HashTable<re::ProfilerStatistic,re::FrameStats::CollectedStatistics,re::Hash<re::ProfilerStatistic>,re::EqualTo<re::ProfilerStatistic>,true,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, _BYTE *a4, re::FrameStats::CollectedStatistics *a5)
{
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;

  v10 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
    v10 = *(unsigned int *)(a1 + 32);
    v11 = v10;
    if ((_DWORD)v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::ProfilerStatistic,re::FrameStats::CollectedStatistics,re::Hash<re::ProfilerStatistic>,re::EqualTo<re::ProfilerStatistic>,true,false>::setCapacity(a1, (2 * *(_DWORD *)(a1 + 28)));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 80 * v10 + 8);
  }
  else
  {
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 80 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + 80 * v10 + 8) = v13 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 80 * v10 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 80 * v10 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 80 * v10) = a3;
  *(_BYTE *)(*(_QWORD *)(a1 + 16) + 80 * v10 + 12) = *a4;
  re::FrameStats::CollectedStatistics::CollectedStatistics((re::FrameStats::CollectedStatistics *)(*(_QWORD *)(a1 + 16) + 80 * v10 + 16), a5);
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

_QWORD *re::DynamicArray<re::FrameStatisticsOutput>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  __int128 v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::FrameStatisticsOutput>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x30uLL))
        {
          v2 = 48 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 48 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_20;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 48, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_20:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = 48 * v9;
        v11 = (uint64_t *)(v8 + 16);
        v12 = 0uLL;
        v13 = v7;
        do
        {
          *(_OWORD *)v13 = v12;
          *((_OWORD *)v13 + 1) = v12;
          *v13 = *(v11 - 2);
          *(v11 - 2) = 0;
          v14 = *v11;
          v13[3] = v11[1];
          v11[1] = 0;
          v16 = v13[1];
          v15 = v13[2];
          v17 = *(v11 - 1);
          v13[2] = v14;
          *v11 = v15;
          v13[1] = v17;
          *(v11 - 1) = v16;
          v18 = v11[2];
          *((_DWORD *)v13 + 10) = *((_DWORD *)v11 + 6);
          v13[4] = v18;
          v19 = *(v11 - 2);
          if (v19)
          {
            if ((*(_BYTE *)(v11 - 1) & 1) != 0)
            {
              (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v19 + 40))(v19, *v11);
              v12 = 0uLL;
            }
            *((_OWORD *)v11 - 1) = v12;
            *(_OWORD *)v11 = v12;
          }
          v11 += 6;
          v13 += 6;
          v10 -= 48;
        }
        while (v10);
        v8 = v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_20;
    }
  }
  return result;
}

uint64_t re::FrameStats::init(re::FrameStats *this, int a2, int a3)
{
  re::FrameStats *v3;
  double v4;
  _anonymous_namespace_ *v5;
  uint64_t result;
  int v7;
  __int128 v8;
  __int128 v9;
  _BYTE v10[12];

  v3 = this;
  *((_DWORD *)this + 2) = a3;
  *((_BYTE *)this + 64) = 1;
  *(_DWORD *)v10 = 0;
  v8 = 0u;
  v9 = 0u;
  *(_QWORD *)&v10[4] = 0x7FFFFFFFLL;
  v3 = (re::FrameStats *)((char *)v3 + 16);
  re::HashTable<unsigned int,re::FrameStatisticsOutput,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::operator=((uint64_t)v3, (uint64_t *)&v8);
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v8, v4);
  *((_QWORD *)&v8 + 1) = 0;
  v9 = 0uLL;
  re::DynamicString::setCapacity(&v8, 0);
  *(_QWORD *)v10 = 0x2800000006;
  *(_DWORD *)&v10[8] = 1;
  v7 = 0;
  re::HashTable<unsigned int,re::FrameStatisticsOutput,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::add<re::FrameStatisticsOutput&>((uint64_t)v3, &v7, (re::DynamicString *)&v8);
  result = v8;
  if ((_QWORD)v8)
  {
    if ((BYTE8(v8) & 1) != 0)
      return (*(uint64_t (**)(void))(*(_QWORD *)v8 + 40))();
  }
  return result;
}

uint64_t re::HashTable<unsigned int,re::FrameStatisticsOutput,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::operator=(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    if (!*(_QWORD *)a1 || *(_QWORD *)a1 == *a2)
    {
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)a1, a2);
    }
    else if (*a2)
    {
      re::HashTable<unsigned int,re::FrameStatisticsOutput,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::copy(a1, (uint64_t)a2);
      ++*(_DWORD *)(a1 + 40);
    }
    else
    {
      re::HashTable<unsigned int,re::FrameStatisticsOutput,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::clear(a1);
    }
  }
  return a1;
}

unint64_t re::HashTable<unsigned int,re::FrameStatisticsOutput,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::add<re::FrameStatisticsOutput&>(uint64_t a1, _DWORD *a2, re::DynamicString *a3)
{
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unsigned int v13;

  v6 = *a2;
  v7 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (v6 ^ (v6 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v6 ^ (v6 >> 30))) >> 27));
  v8 = v7 ^ (v7 >> 31);
  if (!*(_QWORD *)a1)
  {
    LODWORD(v9) = 0;
    goto LABEL_8;
  }
  v9 = v8 % *(unsigned int *)(a1 + 24);
  v10 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v9);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
LABEL_8:
    v13 = re::HashTable<unsigned int,re::FrameStatisticsOutput,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::addEmplace<re::FrameStatisticsOutput&>(a1, v9, v8, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    v12 = *(_QWORD *)(a1 + 16) + ((unint64_t)v13 << 6);
    return v12 + 16;
  }
  v11 = *(_QWORD *)(a1 + 16);
  while (*(_DWORD *)(v11 + (v10 << 6) + 12) != (_DWORD)v6)
  {
    v10 = *(_DWORD *)(v11 + (v10 << 6) + 8) & 0x7FFFFFFF;
    if ((_DWORD)v10 == 0x7FFFFFFF)
      goto LABEL_8;
  }
  v12 = v11 + (v10 << 6);
  return v12 + 16;
}

float re::FrameStats::CollectedStatistics::addValue(re::FrameStats::CollectedStatistics *this, float a2)
{
  float v2;
  float v3;
  float v4;
  float v5;
  float result;

  if (*(float *)this > a2)
    *(float *)this = a2;
  if (*((float *)this + 1) < a2)
    *((float *)this + 1) = a2;
  v2 = *((float *)this + 2) + a2;
  v3 = *((float *)this + 3) + 1.0;
  *((float *)this + 2) = v2;
  *((float *)this + 3) = v3;
  *((float *)this + 4) = v2 / v3;
  *((float *)this + 5) = a2;
  if (*((float *)this + 11) > a2)
    *((float *)this + 11) = a2;
  if (*((float *)this + 12) < a2)
    *((float *)this + 12) = a2;
  v4 = *((float *)this + 13) + a2;
  v5 = *((float *)this + 14) + 1.0;
  *((float *)this + 13) = v4;
  *((float *)this + 14) = v5;
  result = v4 / v5;
  *((float *)this + 15) = result;
  return result;
}

float re::FrameStats::CollectedStatistics::addGroupValues(re::FrameStats::CollectedStatistics *this, float a2, float a3, float a4, float a5)
{
  float v5;
  float v6;
  float v7;
  float v8;
  float result;

  if (*(float *)this > a4)
    *(float *)this = a4;
  if (*((float *)this + 1) < a5)
    *((float *)this + 1) = a5;
  v5 = *((float *)this + 2) + a2;
  v6 = *((float *)this + 3) + a3;
  *((float *)this + 2) = v5;
  *((float *)this + 3) = v6;
  *((float *)this + 4) = v5 / v6;
  if (*((float *)this + 11) > a4)
    *((float *)this + 11) = a4;
  if (*((float *)this + 12) < a5)
    *((float *)this + 12) = a5;
  v7 = *((float *)this + 13) + a2;
  v8 = *((float *)this + 14) + a3;
  *((float *)this + 13) = v7;
  *((float *)this + 14) = v8;
  result = v7 / v8;
  *((float *)this + 15) = result;
  return result;
}

float re::FrameStats::CollectedStatistics::CollectedStatistics(re::FrameStats::CollectedStatistics *this, const re::FrameStats::CollectedStatistics *a2)
{
  float result;

  *(_QWORD *)this = 0xFF7FFFFF7F7FFFFFLL;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *(_OWORD *)((char *)this + 24) = xmmword_226192590;
  *(_OWORD *)((char *)this + 40) = xmmword_2261925A0;
  *((_QWORD *)this + 7) = 0;
  *(_OWORD *)this = *(_OWORD *)a2;
  *((_DWORD *)this + 4) = *((_DWORD *)a2 + 4);
  *(_OWORD *)((char *)this + 44) = *(_OWORD *)((char *)a2 + 44);
  result = *((float *)a2 + 15);
  *((float *)this + 15) = result;
  return result;
}

uint64_t re::FrameTimeStats::dumpStatisticsInternal(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  _BYTE *v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  float v17;
  int v18;
  double v19;
  unint64_t v20;
  unint64_t v21;
  double v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  float v26;
  int v27;
  double v28;
  unint64_t v29;
  unint64_t v30;
  double v31;
  uint64_t v32;
  uint64_t v33;
  unsigned int v34;
  float v35;
  int v36;
  double v37;
  unint64_t v38;
  unint64_t v39;
  double v40;
  uint64_t v41;
  uint64_t v42;
  unsigned int v43;
  float v44;
  int v45;
  double v46;
  unint64_t v47;
  unint64_t v48;
  double v49;
  uint64_t v50;
  uint64_t v51;
  unsigned int v52;
  float v53;
  int v54;
  double v55;
  unint64_t v56;
  unint64_t v57;
  uint64_t v58;
  uint64_t v59;
  unsigned int v60;
  float v61;
  int v62;
  double v63;
  unint64_t v64;
  unint64_t v65;
  uint64_t v66;
  uint64_t v67;
  unsigned int v68;
  float v69;
  int v70;
  double v71;
  unint64_t v72;
  unint64_t v73;
  uint64_t v74;
  uint64_t v75;
  unsigned int v76;
  float v77;
  int v78;
  double v79;
  unint64_t v80;
  unint64_t v81;
  double v82;
  uint64_t v83;
  uint64_t v84;
  unsigned int v85;
  float v86;
  int v87;
  double v88;
  unint64_t v89;
  unint64_t v90;
  double v91;
  uint64_t v92;
  uint64_t v93;
  unsigned int v94;
  float v95;
  int v96;
  double v97;
  unint64_t v98;
  unint64_t v99;
  double v100;
  uint64_t v101;
  uint64_t v102;
  unsigned int v103;
  float v104;
  int v105;
  double v106;
  unint64_t v107;
  unint64_t v108;
  uint64_t v109;
  uint64_t v110;
  unsigned int v111;
  float v112;
  int v113;
  double v114;
  unint64_t v115;
  unint64_t v116;
  uint64_t v117;
  uint64_t v118;
  unsigned int v119;
  float v120;
  int v121;
  double v122;
  unint64_t v123;
  unint64_t v124;
  double v125;
  uint64_t v126;
  uint64_t v127;
  unsigned int v128;
  float v129;
  int v130;
  double v131;
  unint64_t v132;
  unint64_t v133;
  double v134;
  uint64_t v135;
  uint64_t v136;
  unsigned int v137;
  float v138;
  int v139;
  double v140;
  unint64_t v141;
  unint64_t v142;
  uint64_t v143;
  uint64_t v144;
  unsigned int v145;
  float v146;
  int v147;
  double v148;
  unint64_t v149;
  unint64_t v150;
  double v151;
  uint64_t v152;
  uint64_t v153;
  unsigned int v154;
  float v155;
  int v156;
  double v157;
  unint64_t v158;
  unint64_t v159;
  double v160;
  uint64_t v161;
  uint64_t v162;
  unsigned int v163;
  float v164;
  int v165;
  double v166;
  unint64_t v167;
  unint64_t v168;
  uint64_t v169;
  uint64_t v170;
  unsigned int v171;
  float v172;
  int v173;
  double v174;
  unint64_t v175;
  unint64_t v176;
  double v177;
  uint64_t v178;
  uint64_t v179;
  unsigned int v180;
  float v181;
  int v182;
  double v183;
  unint64_t v184;
  unint64_t v185;
  uint64_t v186;
  uint64_t v187;
  unsigned int v188;
  float v189;
  int v190;
  double v191;
  unint64_t v192;
  unint64_t v193;
  uint64_t v194;
  uint64_t v195;
  unsigned int v196;
  double v197;
  double v198;
  double v199;
  float v200;
  int v201;
  double v202;
  unint64_t v203;
  unint64_t v204;
  float v205;
  float v206;
  uint64_t v207;
  uint64_t v208;
  unsigned int v209;
  float v210;
  float v211;
  float v212;
  int v213;
  double v214;
  unint64_t v215;
  unint64_t v216;
  double v217;
  float v218;
  uint64_t v219;
  uint64_t v220;
  unsigned int v221;
  float v222;
  float v223;
  float v224;
  int v225;
  double v226;
  unint64_t v227;
  unint64_t v228;
  double v229;
  float v230;
  float v231;
  double v232;
  uint64_t v233;
  uint64_t v234;
  unsigned int v235;
  float v236;
  float v237;
  float v238;
  float v239;
  float v240;
  float v241;
  float v242;
  float v243;
  float v244;
  float v245;
  int v246;
  double v247;
  float v248;
  unint64_t v249;
  unint64_t v250;
  double v251;
  double v252;
  double v253;
  float v254;
  float v255;
  float v256;
  float v257;
  float v258;
  float v259;
  double v260;
  float v261;
  uint64_t v262;
  uint64_t v263;
  unsigned int v264;
  float v265;
  int v266;
  double v267;
  unint64_t v268;
  unint64_t v269;
  double v270;
  uint64_t v271;
  uint64_t v272;
  unsigned int v273;
  float v274;
  float v275;
  int v276;
  double v277;
  unint64_t v278;
  unint64_t v279;
  double v280;
  double v281;
  uint64_t v282;
  uint64_t v283;
  unsigned int v284;
  double v285;
  double v286;
  float v287;
  int v288;
  double v289;
  double v290;
  unint64_t v291;
  unint64_t v292;
  double v293;
  float v294;
  double v295;
  uint64_t v296;
  uint64_t v297;
  unsigned int v298;
  float v299;
  double v300;
  double v301;
  float v302;
  int v303;
  double v304;
  unint64_t v305;
  unint64_t v306;
  double v307;
  double v308;
  uint64_t v309;
  uint64_t v310;
  unsigned int v311;
  double v312;
  float v313;
  int v314;
  double v315;
  unint64_t v316;
  unint64_t v317;
  double v318;
  float v319;
  uint64_t v320;
  uint64_t v321;
  unsigned int v322;
  double v323;
  double v324;
  float v325;
  int v326;
  double v327;
  double v328;
  unint64_t v329;
  unint64_t v330;
  double v331;
  float v332;
  double v333;
  uint64_t v334;
  uint64_t v335;
  unsigned int v336;
  float v337;
  double v338;
  double v339;
  float v340;
  int v341;
  double v342;
  unint64_t v343;
  unint64_t v344;
  double v345;
  float v346;
  float v347;
  uint64_t v348;
  uint64_t v349;
  unsigned int v350;
  float v351;
  int v352;
  double v353;
  unint64_t v354;
  unint64_t v355;
  double v356;
  uint64_t v357;
  uint64_t v358;
  unsigned int v359;
  float v360;
  int v361;
  double v362;
  unint64_t v363;
  unint64_t v364;
  double v365;
  float v366;
  float v367;
  float v368;
  float v369;
  float v370;
  float v371;
  float v372;
  uint64_t result;
  double v374;
  double v375;
  double v376;
  double v377;
  double v378;
  double v379;
  double v380;
  double v381;
  double v382;
  double v383;
  float v384;
  double v385;
  float v386;
  float v387;
  float v388;
  double v389;
  double v390;
  double v391;
  double v392;
  float v393;
  float v394;
  double v395;
  float v396;
  double v397;
  float v398;
  double v399;
  float v400;
  mach_timebase_info info;

  LODWORD(v5) = 0x7FFFFFFF;
  if (*(_QWORD *)a2)
  {
    v6 = **(unsigned int **)(a2 + 8);
    if ((_DWORD)v6 != 0x7FFFFFFF)
    {
      v7 = *(_QWORD *)(a2 + 16);
      if (*(_DWORD *)(v7 + (v6 << 6) + 12))
      {
        v5 = **(unsigned int **)(a2 + 8);
        while (1)
        {
          v5 = *(_DWORD *)(v7 + (v5 << 6) + 8) & 0x7FFFFFFF;
          if ((_DWORD)v5 == 0x7FFFFFFF)
            break;
          if (!*(_DWORD *)(v7 + (v5 << 6) + 12))
            goto LABEL_10;
        }
        LODWORD(v5) = 0x7FFFFFFF;
      }
      else
      {
        LODWORD(v5) = **(_DWORD **)(a2 + 8);
      }
    }
  }
LABEL_10:
  v8 = *(_QWORD *)(a2 + 16);
  v9 = v5;
  v10 = v8 + ((unint64_t)v5 << 6);
  v11 = (_QWORD *)(v10 + 16);
  v12 = *(_QWORD *)(v10 + 24);
  if ((v12 & 1) != 0)
  {
    v11[1] = 1;
    v13 = (_BYTE *)v11[2];
  }
  else
  {
    *((_BYTE *)v11 + 8) = v12 & 1;
    v13 = (char *)v11 + 9;
  }
  *v13 = 0;
  v14 = 0x7FFFFFFF;
  if (*(_QWORD *)a3)
  {
    v15 = *(_DWORD *)(*(_QWORD *)(a3 + 8) + 4 * (0x5692161D100B05E5uLL % *(unsigned int *)(a3 + 24)));
    if (v15 != 0x7FFFFFFF)
    {
      v16 = *(_QWORD *)(a3 + 16);
      v14 = *(_DWORD *)(*(_QWORD *)(a3 + 8) + 4 * (0x5692161D100B05E5uLL % *(unsigned int *)(a3 + 24)));
      if (*(_BYTE *)(v16 + 80 * v15 + 12) != 1)
      {
        while (1)
        {
          v14 = *(_DWORD *)(v16
                          + 80
                          * *(unsigned int *)(*(_QWORD *)(a3 + 8)
                                            + 4 * (0x5692161D100B05E5uLL % *(unsigned int *)(a3 + 24)))
                          + 8) & 0x7FFFFFFF;
          if (v14 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v16 + 80 * v14 + 12) == 1)
            goto LABEL_20;
        }
        v14 = 0x7FFFFFFF;
      }
    }
  }
LABEL_20:
  v17 = *(float *)(*(_QWORD *)(a3 + 16) + 80 * v14 + 48);
  v18 = *(_DWORD *)(a1 + 8);
  v19 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v22 = NAN;
      goto LABEL_25;
    }
    LODWORD(v20) = info.numer;
    LODWORD(v21) = info.denom;
    v19 = (double)v20 / (double)v21;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v19;
  }
  v22 = v19 * (double)(unint64_t)(float)(v17 / (float)v18);
LABEL_25:
  v395 = v22;
  if (*(_QWORD *)a3)
  {
    v23 = *(_QWORD *)(a3 + 16);
    v24 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0xDBD238973A2B148ALL % *(unsigned int *)(a3 + 24)));
    v25 = 0x7FFFFFFF;
    if ((_DWORD)v24 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v23 + 80 * v24 + 12) == 2)
      {
LABEL_30:
        v25 = v24;
      }
      else
      {
        while (1)
        {
          LODWORD(v24) = *(_DWORD *)(v23 + 80 * v24 + 8) & 0x7FFFFFFF;
          v25 = 0x7FFFFFFF;
          if ((_DWORD)v24 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v23 + 80 * v24 + 12) == 2)
            goto LABEL_30;
        }
      }
    }
  }
  else
  {
    v23 = *(_QWORD *)(a3 + 16);
    v25 = 0x7FFFFFFF;
  }
  v26 = *(float *)(v23 + 80 * v25 + 48);
  v27 = *(_DWORD *)(a1 + 8);
  v28 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v31 = NAN;
      goto LABEL_37;
    }
    LODWORD(v29) = info.numer;
    LODWORD(v30) = info.denom;
    v28 = (double)v29 / (double)v30;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v28;
  }
  v31 = v28 * (double)(unint64_t)(float)(v26 / (float)v27);
LABEL_37:
  if (*(_QWORD *)a3)
  {
    v32 = *(_QWORD *)(a3 + 16);
    v33 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x1E535EEDE31428F0uLL % *(unsigned int *)(a3 + 24)));
    v34 = 0x7FFFFFFF;
    if ((_DWORD)v33 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v32 + 80 * v33 + 12) == 3)
      {
LABEL_42:
        v34 = v33;
      }
      else
      {
        while (1)
        {
          LODWORD(v33) = *(_DWORD *)(v32 + 80 * v33 + 8) & 0x7FFFFFFF;
          v34 = 0x7FFFFFFF;
          if ((_DWORD)v33 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v32 + 80 * v33 + 12) == 3)
            goto LABEL_42;
        }
      }
    }
  }
  else
  {
    v32 = *(_QWORD *)(a3 + 16);
    v34 = 0x7FFFFFFF;
  }
  v35 = *(float *)(v32 + 80 * v34 + 48);
  v36 = *(_DWORD *)(a1 + 8);
  v37 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v40 = NAN;
      goto LABEL_49;
    }
    LODWORD(v38) = info.numer;
    LODWORD(v39) = info.denom;
    v37 = (double)v38 / (double)v39;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v37;
  }
  v40 = v37 * (double)(unint64_t)(float)(v35 / (float)v36);
LABEL_49:
  if (*(_QWORD *)a3)
  {
    v41 = *(_QWORD *)(a3 + 16);
    v42 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0xB7A4712C74562914 % *(unsigned int *)(a3 + 24)));
    v43 = 0x7FFFFFFF;
    if ((_DWORD)v42 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v41 + 80 * v42 + 12) == 4)
      {
LABEL_54:
        v43 = v42;
      }
      else
      {
        while (1)
        {
          LODWORD(v42) = *(_DWORD *)(v41 + 80 * v42 + 8) & 0x7FFFFFFF;
          v43 = 0x7FFFFFFF;
          if ((_DWORD)v42 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v41 + 80 * v42 + 12) == 4)
            goto LABEL_54;
        }
      }
    }
  }
  else
  {
    v41 = *(_QWORD *)(a3 + 16);
    v43 = 0x7FFFFFFF;
  }
  v44 = *(float *)(v41 + 80 * v43 + 48);
  v45 = *(_DWORD *)(a1 + 8);
  v46 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v49 = NAN;
      goto LABEL_61;
    }
    LODWORD(v47) = info.numer;
    LODWORD(v48) = info.denom;
    v46 = (double)v47 / (double)v48;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v46;
  }
  v49 = v46 * (double)(unint64_t)(float)(v44 / (float)v45);
LABEL_61:
  if (*(_QWORD *)a3)
  {
    v50 = *(_QWORD *)(a3 + 16);
    v51 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0xB6BF613DBEBB45DCLL % *(unsigned int *)(a3 + 24)));
    v52 = 0x7FFFFFFF;
    if ((_DWORD)v51 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v50 + 80 * v51 + 12) == 5)
      {
LABEL_66:
        v52 = v51;
      }
      else
      {
        while (1)
        {
          LODWORD(v51) = *(_DWORD *)(v50 + 80 * v51 + 8) & 0x7FFFFFFF;
          v52 = 0x7FFFFFFF;
          if ((_DWORD)v51 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v50 + 80 * v51 + 12) == 5)
            goto LABEL_66;
        }
      }
    }
  }
  else
  {
    v50 = *(_QWORD *)(a3 + 16);
    v52 = 0x7FFFFFFF;
  }
  v53 = *(float *)(v50 + 80 * v52 + 48);
  v54 = *(_DWORD *)(a1 + 8);
  v55 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v399 = NAN;
      goto LABEL_73;
    }
    LODWORD(v56) = info.numer;
    LODWORD(v57) = info.denom;
    v55 = (double)v56 / (double)v57;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v55;
  }
  v399 = v55 * (double)(unint64_t)(float)(v53 / (float)v54);
LABEL_73:
  if (*(_QWORD *)a3)
  {
    v58 = *(_QWORD *)(a3 + 16);
    v59 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0xD17707977078336CLL % *(unsigned int *)(a3 + 24)));
    v60 = 0x7FFFFFFF;
    if ((_DWORD)v59 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v58 + 80 * v59 + 12) == 6)
      {
LABEL_78:
        v60 = v59;
      }
      else
      {
        while (1)
        {
          LODWORD(v59) = *(_DWORD *)(v58 + 80 * v59 + 8) & 0x7FFFFFFF;
          v60 = 0x7FFFFFFF;
          if ((_DWORD)v59 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v58 + 80 * v59 + 12) == 6)
            goto LABEL_78;
        }
      }
    }
  }
  else
  {
    v58 = *(_QWORD *)(a3 + 16);
    v60 = 0x7FFFFFFF;
  }
  v61 = *(float *)(v58 + 80 * v60 + 48);
  v62 = *(_DWORD *)(a1 + 8);
  v63 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v379 = NAN;
      goto LABEL_85;
    }
    LODWORD(v64) = info.numer;
    LODWORD(v65) = info.denom;
    v63 = (double)v64 / (double)v65;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v63;
  }
  v379 = v63 * (double)(unint64_t)(float)(v61 / (float)v62);
LABEL_85:
  if (*(_QWORD *)a3)
  {
    v66 = *(_QWORD *)(a3 + 16);
    v67 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x12AE30237B17DF14uLL % *(unsigned int *)(a3 + 24)));
    v68 = 0x7FFFFFFF;
    if ((_DWORD)v67 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v66 + 80 * v67 + 12) == 7)
      {
LABEL_90:
        v68 = v67;
      }
      else
      {
        while (1)
        {
          LODWORD(v67) = *(_DWORD *)(v66 + 80 * v67 + 8) & 0x7FFFFFFF;
          v68 = 0x7FFFFFFF;
          if ((_DWORD)v67 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v66 + 80 * v67 + 12) == 7)
            goto LABEL_90;
        }
      }
    }
  }
  else
  {
    v66 = *(_QWORD *)(a3 + 16);
    v68 = 0x7FFFFFFF;
  }
  v69 = *(float *)(v66 + 80 * v68 + 48);
  v70 = *(_DWORD *)(a1 + 8);
  v71 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v397 = NAN;
      goto LABEL_97;
    }
    LODWORD(v72) = info.numer;
    LODWORD(v73) = info.denom;
    v71 = (double)v72 / (double)v73;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v71;
  }
  v397 = v71 * (double)(unint64_t)(float)(v69 / (float)v70);
LABEL_97:
  if (*(_QWORD *)a3)
  {
    v74 = *(_QWORD *)(a3 + 16);
    v75 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x826C6ABF7FDD5AD7 % *(unsigned int *)(a3 + 24)));
    v76 = 0x7FFFFFFF;
    if ((_DWORD)v75 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v74 + 80 * v75 + 12) == 9)
      {
LABEL_102:
        v76 = v75;
      }
      else
      {
        while (1)
        {
          LODWORD(v75) = *(_DWORD *)(v74 + 80 * v75 + 8) & 0x7FFFFFFF;
          v76 = 0x7FFFFFFF;
          if ((_DWORD)v75 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v74 + 80 * v75 + 12) == 9)
            goto LABEL_102;
        }
      }
    }
  }
  else
  {
    v74 = *(_QWORD *)(a3 + 16);
    v76 = 0x7FFFFFFF;
  }
  v77 = *(float *)(v74 + 80 * v76 + 48);
  v78 = *(_DWORD *)(a1 + 8);
  v79 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v82 = NAN;
      goto LABEL_109;
    }
    LODWORD(v80) = info.numer;
    LODWORD(v81) = info.denom;
    v79 = (double)v80 / (double)v81;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v79;
  }
  v82 = v79 * (double)(unint64_t)(float)(v77 / (float)v78);
LABEL_109:
  v392 = v82;
  if (*(_QWORD *)a3)
  {
    v83 = *(_QWORD *)(a3 + 16);
    v84 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x75C8519A9320579uLL % *(unsigned int *)(a3 + 24)));
    v85 = 0x7FFFFFFF;
    if ((_DWORD)v84 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v83 + 80 * v84 + 12) == 10)
      {
LABEL_114:
        v85 = v84;
      }
      else
      {
        while (1)
        {
          LODWORD(v84) = *(_DWORD *)(v83 + 80 * v84 + 8) & 0x7FFFFFFF;
          v85 = 0x7FFFFFFF;
          if ((_DWORD)v84 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v83 + 80 * v84 + 12) == 10)
            goto LABEL_114;
        }
      }
    }
  }
  else
  {
    v83 = *(_QWORD *)(a3 + 16);
    v85 = 0x7FFFFFFF;
  }
  v86 = *(float *)(v83 + 80 * v85 + 48);
  v87 = *(_DWORD *)(a1 + 8);
  v88 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v91 = NAN;
      goto LABEL_121;
    }
    LODWORD(v89) = info.numer;
    LODWORD(v90) = info.denom;
    v88 = (double)v89 / (double)v90;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v88;
  }
  v91 = v88 * (double)(unint64_t)(float)(v86 / (float)v87);
LABEL_121:
  v385 = v91;
  if (*(_QWORD *)a3)
  {
    v92 = *(_QWORD *)(a3 + 16);
    v93 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0xD56B1FBB9CEBA9E8 % *(unsigned int *)(a3 + 24)));
    v94 = 0x7FFFFFFF;
    if ((_DWORD)v93 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v92 + 80 * v93 + 12) == 8)
      {
LABEL_126:
        v94 = v93;
      }
      else
      {
        while (1)
        {
          LODWORD(v93) = *(_DWORD *)(v92 + 80 * v93 + 8) & 0x7FFFFFFF;
          v94 = 0x7FFFFFFF;
          if ((_DWORD)v93 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v92 + 80 * v93 + 12) == 8)
            goto LABEL_126;
        }
      }
    }
  }
  else
  {
    v92 = *(_QWORD *)(a3 + 16);
    v94 = 0x7FFFFFFF;
  }
  v95 = *(float *)(v92 + 80 * v94 + 48);
  v96 = *(_DWORD *)(a1 + 8);
  v97 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v100 = NAN;
      goto LABEL_133;
    }
    LODWORD(v98) = info.numer;
    LODWORD(v99) = info.denom;
    v97 = (double)v98 / (double)v99;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v97;
  }
  v100 = v97 * (double)(unint64_t)(float)(v95 / (float)v96);
LABEL_133:
  if (*(_QWORD *)a3)
  {
    v101 = *(_QWORD *)(a3 + 16);
    v102 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x3462D848F53ABB6DuLL % *(unsigned int *)(a3 + 24)));
    v103 = 0x7FFFFFFF;
    if ((_DWORD)v102 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v101 + 80 * v102 + 12) == 11)
      {
LABEL_138:
        v103 = v102;
      }
      else
      {
        while (1)
        {
          LODWORD(v102) = *(_DWORD *)(v101 + 80 * v102 + 8) & 0x7FFFFFFF;
          v103 = 0x7FFFFFFF;
          if ((_DWORD)v102 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v101 + 80 * v102 + 12) == 11)
            goto LABEL_138;
        }
      }
    }
  }
  else
  {
    v101 = *(_QWORD *)(a3 + 16);
    v103 = 0x7FFFFFFF;
  }
  v104 = *(float *)(v101 + 80 * v103 + 48);
  v105 = *(_DWORD *)(a1 + 8);
  v106 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v378 = NAN;
      goto LABEL_145;
    }
    LODWORD(v107) = info.numer;
    LODWORD(v108) = info.denom;
    v106 = (double)v107 / (double)v108;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v106;
  }
  v378 = v106 * (double)(unint64_t)(float)(v104 / (float)v105);
LABEL_145:
  if (*(_QWORD *)a3)
  {
    v109 = *(_QWORD *)(a3 + 16);
    v110 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x37BE58E8D7213BBCuLL % *(unsigned int *)(a3 + 24)));
    v111 = 0x7FFFFFFF;
    if ((_DWORD)v110 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v109 + 80 * v110 + 12) == 12)
      {
LABEL_150:
        v111 = v110;
      }
      else
      {
        while (1)
        {
          LODWORD(v110) = *(_DWORD *)(v109 + 80 * v110 + 8) & 0x7FFFFFFF;
          v111 = 0x7FFFFFFF;
          if ((_DWORD)v110 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v109 + 80 * v110 + 12) == 12)
            goto LABEL_150;
        }
      }
    }
  }
  else
  {
    v109 = *(_QWORD *)(a3 + 16);
    v111 = 0x7FFFFFFF;
  }
  v112 = *(float *)(v109 + 80 * v111 + 48);
  v113 = *(_DWORD *)(a1 + 8);
  v114 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v376 = NAN;
      goto LABEL_157;
    }
    LODWORD(v115) = info.numer;
    LODWORD(v116) = info.denom;
    v114 = (double)v115 / (double)v116;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v114;
  }
  v376 = v114 * (double)(unint64_t)(float)(v112 / (float)v113);
LABEL_157:
  if (*(_QWORD *)a3)
  {
    v117 = *(_QWORD *)(a3 + 16);
    v118 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0xDCFA9555B5F881D1 % *(unsigned int *)(a3 + 24)));
    v119 = 0x7FFFFFFF;
    if ((_DWORD)v118 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v117 + 80 * v118 + 12) == 13)
      {
LABEL_162:
        v119 = v118;
      }
      else
      {
        while (1)
        {
          LODWORD(v118) = *(_DWORD *)(v117 + 80 * v118 + 8) & 0x7FFFFFFF;
          v119 = 0x7FFFFFFF;
          if ((_DWORD)v118 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v117 + 80 * v118 + 12) == 13)
            goto LABEL_162;
        }
      }
    }
  }
  else
  {
    v117 = *(_QWORD *)(a3 + 16);
    v119 = 0x7FFFFFFF;
  }
  v120 = *(float *)(v117 + 80 * v119 + 48);
  v121 = *(_DWORD *)(a1 + 8);
  v122 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v125 = NAN;
      goto LABEL_169;
    }
    LODWORD(v123) = info.numer;
    LODWORD(v124) = info.denom;
    v122 = (double)v123 / (double)v124;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v122;
  }
  v125 = v122 * (double)(unint64_t)(float)(v120 / (float)v121);
LABEL_169:
  v390 = v125;
  if (*(_QWORD *)a3)
  {
    v126 = *(_QWORD *)(a3 + 16);
    v127 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x255C6046F62FBE29uLL % *(unsigned int *)(a3 + 24)));
    v128 = 0x7FFFFFFF;
    if ((_DWORD)v127 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v126 + 80 * v127 + 12) == 14)
      {
LABEL_174:
        v128 = v127;
      }
      else
      {
        while (1)
        {
          LODWORD(v127) = *(_DWORD *)(v126 + 80 * v127 + 8) & 0x7FFFFFFF;
          v128 = 0x7FFFFFFF;
          if ((_DWORD)v127 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v126 + 80 * v127 + 12) == 14)
            goto LABEL_174;
        }
      }
    }
  }
  else
  {
    v126 = *(_QWORD *)(a3 + 16);
    v128 = 0x7FFFFFFF;
  }
  v129 = *(float *)(v126 + 80 * v128 + 48);
  v130 = *(_DWORD *)(a1 + 8);
  v131 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v134 = NAN;
      goto LABEL_181;
    }
    LODWORD(v132) = info.numer;
    LODWORD(v133) = info.denom;
    v131 = (double)v132 / (double)v133;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v131;
  }
  v134 = v131 * (double)(unint64_t)(float)(v129 / (float)v130);
LABEL_181:
  if (*(_QWORD *)a3)
  {
    v135 = *(_QWORD *)(a3 + 16);
    v136 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x392754934EA1539uLL % *(unsigned int *)(a3 + 24)));
    v137 = 0x7FFFFFFF;
    if ((_DWORD)v136 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v135 + 80 * v136 + 12) == 15)
      {
LABEL_186:
        v137 = v136;
      }
      else
      {
        while (1)
        {
          LODWORD(v136) = *(_DWORD *)(v135 + 80 * v136 + 8) & 0x7FFFFFFF;
          v137 = 0x7FFFFFFF;
          if ((_DWORD)v136 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v135 + 80 * v136 + 12) == 15)
            goto LABEL_186;
        }
      }
    }
  }
  else
  {
    v135 = *(_QWORD *)(a3 + 16);
    v137 = 0x7FFFFFFF;
  }
  v138 = *(float *)(v135 + 80 * v137 + 48);
  v139 = *(_DWORD *)(a1 + 8);
  v140 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v380 = NAN;
      goto LABEL_193;
    }
    LODWORD(v141) = info.numer;
    LODWORD(v142) = info.denom;
    v140 = (double)v141 / (double)v142;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v140;
  }
  v380 = v140 * (double)(unint64_t)(float)(v138 / (float)v139);
LABEL_193:
  if (*(_QWORD *)a3)
  {
    v143 = *(_QWORD *)(a3 + 16);
    v144 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0xD9844BCECCA4A8BDLL % *(unsigned int *)(a3 + 24)));
    v145 = 0x7FFFFFFF;
    if ((_DWORD)v144 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v143 + 80 * v144 + 12) == 16)
      {
LABEL_198:
        v145 = v144;
      }
      else
      {
        while (1)
        {
          LODWORD(v144) = *(_DWORD *)(v143 + 80 * v144 + 8) & 0x7FFFFFFF;
          v145 = 0x7FFFFFFF;
          if ((_DWORD)v144 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v143 + 80 * v144 + 12) == 16)
            goto LABEL_198;
        }
      }
    }
  }
  else
  {
    v143 = *(_QWORD *)(a3 + 16);
    v145 = 0x7FFFFFFF;
  }
  v146 = *(float *)(v143 + 80 * v145 + 48);
  v147 = *(_DWORD *)(a1 + 8);
  v148 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v151 = NAN;
      goto LABEL_205;
    }
    LODWORD(v149) = info.numer;
    LODWORD(v150) = info.denom;
    v148 = (double)v149 / (double)v150;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v148;
  }
  v151 = v148 * (double)(unint64_t)(float)(v146 / (float)v147);
LABEL_205:
  v382 = v151;
  if (*(_QWORD *)a3)
  {
    v152 = *(_QWORD *)(a3 + 16);
    v153 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x302B8631721C51BEuLL % *(unsigned int *)(a3 + 24)));
    v154 = 0x7FFFFFFF;
    if ((_DWORD)v153 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v152 + 80 * v153 + 12) == 17)
      {
LABEL_210:
        v154 = v153;
      }
      else
      {
        while (1)
        {
          LODWORD(v153) = *(_DWORD *)(v152 + 80 * v153 + 8) & 0x7FFFFFFF;
          v154 = 0x7FFFFFFF;
          if ((_DWORD)v153 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v152 + 80 * v153 + 12) == 17)
            goto LABEL_210;
        }
      }
    }
  }
  else
  {
    v152 = *(_QWORD *)(a3 + 16);
    v154 = 0x7FFFFFFF;
  }
  v155 = *(float *)(v152 + 80 * v154 + 48);
  v156 = *(_DWORD *)(a1 + 8);
  v157 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v160 = NAN;
      goto LABEL_217;
    }
    LODWORD(v158) = info.numer;
    LODWORD(v159) = info.denom;
    v157 = (double)v158 / (double)v159;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v157;
  }
  v160 = v157 * (double)(unint64_t)(float)(v155 / (float)v156);
LABEL_217:
  v383 = v160;
  if (*(_QWORD *)a3)
  {
    v161 = *(_QWORD *)(a3 + 16);
    v162 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0xE34A1ED09841F857 % *(unsigned int *)(a3 + 24)));
    v163 = 0x7FFFFFFF;
    if ((_DWORD)v162 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v161 + 80 * v162 + 12) == 19)
      {
LABEL_222:
        v163 = v162;
      }
      else
      {
        while (1)
        {
          LODWORD(v162) = *(_DWORD *)(v161 + 80 * v162 + 8) & 0x7FFFFFFF;
          v163 = 0x7FFFFFFF;
          if ((_DWORD)v162 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v161 + 80 * v162 + 12) == 19)
            goto LABEL_222;
        }
      }
    }
  }
  else
  {
    v161 = *(_QWORD *)(a3 + 16);
    v163 = 0x7FFFFFFF;
  }
  v164 = *(float *)(v161 + 80 * v163 + 48);
  v165 = *(_DWORD *)(a1 + 8);
  v166 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v375 = NAN;
      goto LABEL_229;
    }
    LODWORD(v167) = info.numer;
    LODWORD(v168) = info.denom;
    v166 = (double)v167 / (double)v168;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v166;
  }
  v375 = v166 * (double)(unint64_t)(float)(v164 / (float)v165);
LABEL_229:
  if (*(_QWORD *)a3)
  {
    v169 = *(_QWORD *)(a3 + 16);
    v170 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0xEB90A3352640AF2uLL % *(unsigned int *)(a3 + 24)));
    v171 = 0x7FFFFFFF;
    if ((_DWORD)v170 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v169 + 80 * v170 + 12) == 20)
      {
LABEL_234:
        v171 = v170;
      }
      else
      {
        while (1)
        {
          LODWORD(v170) = *(_DWORD *)(v169 + 80 * v170 + 8) & 0x7FFFFFFF;
          v171 = 0x7FFFFFFF;
          if ((_DWORD)v170 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v169 + 80 * v170 + 12) == 20)
            goto LABEL_234;
        }
      }
    }
  }
  else
  {
    v169 = *(_QWORD *)(a3 + 16);
    v171 = 0x7FFFFFFF;
  }
  v172 = *(float *)(v169 + 80 * v171 + 48);
  v173 = *(_DWORD *)(a1 + 8);
  v174 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v177 = NAN;
      goto LABEL_241;
    }
    LODWORD(v175) = info.numer;
    LODWORD(v176) = info.denom;
    v174 = (double)v175 / (double)v176;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v174;
  }
  v177 = v174 * (double)(unint64_t)(float)(v172 / (float)v173);
LABEL_241:
  v381 = v177;
  if (*(_QWORD *)a3)
  {
    v178 = *(_QWORD *)(a3 + 16);
    v179 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0xD633B1846FAF2B49 % *(unsigned int *)(a3 + 24)));
    v180 = 0x7FFFFFFF;
    if ((_DWORD)v179 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v178 + 80 * v179 + 12) == 21)
      {
LABEL_246:
        v180 = v179;
      }
      else
      {
        while (1)
        {
          LODWORD(v179) = *(_DWORD *)(v178 + 80 * v179 + 8) & 0x7FFFFFFF;
          v180 = 0x7FFFFFFF;
          if ((_DWORD)v179 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v178 + 80 * v179 + 12) == 21)
            goto LABEL_246;
        }
      }
    }
  }
  else
  {
    v178 = *(_QWORD *)(a3 + 16);
    v180 = 0x7FFFFFFF;
  }
  v181 = *(float *)(v178 + 80 * v180 + 48);
  v182 = *(_DWORD *)(a1 + 8);
  v183 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v377 = NAN;
      goto LABEL_253;
    }
    LODWORD(v184) = info.numer;
    LODWORD(v185) = info.denom;
    v183 = (double)v184 / (double)v185;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v183;
  }
  v377 = v183 * (double)(unint64_t)(float)(v181 / (float)v182);
LABEL_253:
  if (*(_QWORD *)a3)
  {
    v186 = *(_QWORD *)(a3 + 16);
    v187 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x378A5760BE593CA5uLL % *(unsigned int *)(a3 + 24)));
    v188 = 0x7FFFFFFF;
    if ((_DWORD)v187 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v186 + 80 * v187 + 12) == 23)
      {
LABEL_258:
        v188 = v187;
      }
      else
      {
        while (1)
        {
          LODWORD(v187) = *(_DWORD *)(v186 + 80 * v187 + 8) & 0x7FFFFFFF;
          v188 = 0x7FFFFFFF;
          if ((_DWORD)v187 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v186 + 80 * v187 + 12) == 23)
            goto LABEL_258;
        }
      }
    }
  }
  else
  {
    v186 = *(_QWORD *)(a3 + 16);
    v188 = 0x7FFFFFFF;
  }
  v189 = *(float *)(v186 + 80 * v188 + 48);
  v190 = *(_DWORD *)(a1 + 8);
  v191 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v374 = NAN;
      goto LABEL_265;
    }
    LODWORD(v192) = info.numer;
    LODWORD(v193) = info.denom;
    v191 = (double)v192 / (double)v193;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v191;
  }
  v374 = v191 * (double)(unint64_t)(float)(v189 / (float)v190);
LABEL_265:
  v389 = v134;
  if (*(_QWORD *)a3)
  {
    v194 = *(_QWORD *)(a3 + 16);
    v195 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0xFD95FA4DB404DD7BLL % *(unsigned int *)(a3 + 24)));
    v196 = 0x7FFFFFFF;
    v197 = v100;
    v198 = v49;
    if ((_DWORD)v195 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v194 + 80 * v195 + 12) == 22)
      {
LABEL_270:
        v196 = v195;
      }
      else
      {
        while (1)
        {
          LODWORD(v195) = *(_DWORD *)(v194 + 80 * v195 + 8) & 0x7FFFFFFF;
          v196 = 0x7FFFFFFF;
          if ((_DWORD)v195 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v194 + 80 * v195 + 12) == 22)
            goto LABEL_270;
        }
      }
    }
  }
  else
  {
    v197 = v100;
    v198 = v49;
    v194 = *(_QWORD *)(a3 + 16);
    v196 = 0x7FFFFFFF;
  }
  v199 = v31 / 1000000.0;
  v200 = *(float *)(v194 + 80 * v196 + 48);
  v201 = *(_DWORD *)(a1 + 8);
  v202 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v391 = NAN;
      goto LABEL_277;
    }
    LODWORD(v203) = info.numer;
    LODWORD(v204) = info.denom;
    v202 = (double)v203 / (double)v204;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v202;
  }
  v391 = v202 * (double)(unint64_t)(float)(v200 / (float)v201);
LABEL_277:
  if (*(_QWORD *)a3)
  {
    v207 = *(_QWORD *)(a3 + 16);
    v208 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x968A5BA23473FAFFLL % *(unsigned int *)(a3 + 24)));
    v209 = 0x7FFFFFFF;
    if ((_DWORD)v208 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v207 + 80 * v208 + 12) == 91)
      {
LABEL_282:
        v209 = v208;
      }
      else
      {
        while (1)
        {
          LODWORD(v208) = *(_DWORD *)(v207 + 80 * v208 + 8) & 0x7FFFFFFF;
          v209 = 0x7FFFFFFF;
          if ((_DWORD)v208 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v207 + 80 * v208 + 12) == 91)
            goto LABEL_282;
        }
      }
    }
  }
  else
  {
    v207 = *(_QWORD *)(a3 + 16);
    v209 = 0x7FFFFFFF;
  }
  v205 = v199;
  v206 = v40 / 1000000.0;
  v211 = v205 + v206;
  v212 = *(float *)(v207 + 80 * v209 + 48);
  v213 = *(_DWORD *)(a1 + 8);
  v214 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v217 = NAN;
      goto LABEL_289;
    }
    LODWORD(v215) = info.numer;
    LODWORD(v216) = info.denom;
    v214 = (double)v215 / (double)v216;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v214;
  }
  v217 = v214 * (double)(unint64_t)(float)(v212 / (float)v213);
LABEL_289:
  if (*(_QWORD *)a3)
  {
    v219 = *(_QWORD *)(a3 + 16);
    v220 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0xDE295D82F964F296 % *(unsigned int *)(a3 + 24)));
    v221 = 0x7FFFFFFF;
    if ((_DWORD)v220 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v219 + 80 * v220 + 12) == 92)
      {
LABEL_294:
        v221 = v220;
      }
      else
      {
        while (1)
        {
          LODWORD(v220) = *(_DWORD *)(v219 + 80 * v220 + 8) & 0x7FFFFFFF;
          v221 = 0x7FFFFFFF;
          if ((_DWORD)v220 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v219 + 80 * v220 + 12) == 92)
            goto LABEL_294;
        }
      }
    }
  }
  else
  {
    v219 = *(_QWORD *)(a3 + 16);
    v221 = 0x7FFFFFFF;
  }
  v218 = v399 / 1000000.0;
  v210 = v198 / 1000000.0;
  v223 = (float)(v211 + v210) + v218;
  v224 = *(float *)(v219 + 80 * v221 + 48);
  v225 = *(_DWORD *)(a1 + 8);
  v226 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v229 = NAN;
      goto LABEL_301;
    }
    LODWORD(v227) = info.numer;
    LODWORD(v228) = info.denom;
    v226 = (double)v227 / (double)v228;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v226;
  }
  v229 = v226 * (double)(unint64_t)(float)(v224 / (float)v225);
LABEL_301:
  v230 = v397 / 1000000.0;
  v222 = v379 / 1000000.0;
  v231 = v223 + v222;
  v232 = v229 / 1000000.0;
  if (*(_QWORD *)a3)
  {
    v233 = *(_QWORD *)(a3 + 16);
    v234 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0xFEBD6A4FBD0A7802 % *(unsigned int *)(a3 + 24)));
    v235 = 0x7FFFFFFF;
    if ((_DWORD)v234 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v233 + 80 * v234 + 12) == 93)
      {
LABEL_306:
        v235 = v234;
      }
      else
      {
        while (1)
        {
          LODWORD(v234) = *(_DWORD *)(v233 + 80 * v234 + 8) & 0x7FFFFFFF;
          v235 = 0x7FFFFFFF;
          if ((_DWORD)v234 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v233 + 80 * v234 + 12) == 93)
            goto LABEL_306;
        }
      }
    }
  }
  else
  {
    v233 = *(_QWORD *)(a3 + 16);
    v235 = 0x7FFFFFFF;
  }
  v236 = v385 / 1000000.0;
  v237 = v197 / 1000000.0;
  v400 = v237;
  v238 = v378 / 1000000.0;
  v239 = v376 / 1000000.0;
  v240 = v374 / 1000000.0;
  v398 = v240;
  v241 = v395 / 1000000.0;
  v242 = v231 + v230;
  v243 = v217 / 1000000.0;
  v244 = v232;
  v245 = *(float *)(v233 + 80 * v235 + 48);
  v246 = *(_DWORD *)(a1 + 8);
  v247 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    v386 = v385 / 1000000.0;
    v248 = v231 + v230;
    if (mach_timebase_info(&info))
    {
      v251 = NAN;
      v242 = v248;
      v252 = v392;
      v236 = v386;
      goto LABEL_313;
    }
    LODWORD(v249) = info.numer;
    LODWORD(v250) = info.denom;
    v247 = (double)v249 / (double)v250;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v247;
    v242 = v248;
    v236 = v386;
  }
  v251 = v247 * (double)(unint64_t)(float)(v245 / (float)v246);
  v252 = v392;
LABEL_313:
  v253 = v252 / 1000000.0;
  v254 = v251 / 1000000.0;
  v396 = v242;
  v387 = (float)(v243 + v244) + v254;
  v255 = v242 + v387;
  v256 = (float)(v238 + v239) + v398;
  v257 = 0.0;
  if (v400 <= 0.0)
    v257 = (float)(v238 + v239) + v398;
  v393 = v257;
  v258 = v236;
  if (v400 > 0.0)
    v256 = v236;
  v259 = v255 - v256;
  if (v241 > 0.0)
    v260 = (float)(1000.0 / v241);
  else
    v260 = 0.0;
  re::DynamicString::appendf((re::DynamicString *)v11, "Frame Times (ms)\n");
  re::DynamicString::appendf((re::DynamicString *)v11, "FPS : %.2f    Main Thread : %.2f\n", v260, v259);
  if (v400 > 0.0)
    re::DynamicString::appendf((re::DynamicString *)v11, "Render Thread : %.2f\n", (float)((float)((float)(v400 - v238) - v239) - v398));
  v261 = v253;
  re::DynamicString::appendf((re::DynamicString *)v11, "Main Thread Breakdown (ms)\n");
  if (*(_QWORD *)a3)
  {
    v262 = *(_QWORD *)(a3 + 16);
    v263 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x8AEB093D93E71BBFLL % *(unsigned int *)(a3 + 24)));
    v264 = 0x7FFFFFFF;
    if ((_DWORD)v263 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v262 + 80 * v263 + 12) == 122)
      {
LABEL_327:
        v264 = v263;
      }
      else
      {
        while (1)
        {
          LODWORD(v263) = *(_DWORD *)(v262 + 80 * v263 + 8) & 0x7FFFFFFF;
          v264 = 0x7FFFFFFF;
          if ((_DWORD)v263 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v262 + 80 * v263 + 12) == 122)
            goto LABEL_327;
        }
      }
    }
  }
  else
  {
    v262 = *(_QWORD *)(a3 + 16);
    v264 = 0x7FFFFFFF;
  }
  v265 = *(float *)(v262 + 80 * v264 + 48);
  v266 = *(_DWORD *)(a1 + 8);
  v267 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v270 = NAN;
      goto LABEL_334;
    }
    LODWORD(v268) = info.numer;
    LODWORD(v269) = info.denom;
    v267 = (double)v268 / (double)v269;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v267;
  }
  v270 = v267 * (double)(unint64_t)(float)(v265 / (float)v266);
LABEL_334:
  if (*(_QWORD *)a3)
  {
    v271 = *(_QWORD *)(a3 + 16);
    v272 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x89607B27DA843F55 % *(unsigned int *)(a3 + 24)));
    v273 = 0x7FFFFFFF;
    if ((_DWORD)v272 != 0x7FFFFFFF)
    {
      if (*(unsigned __int8 *)(v271 + 80 * v272 + 12) == 129)
      {
LABEL_339:
        v273 = v272;
      }
      else
      {
        while (1)
        {
          LODWORD(v272) = *(_DWORD *)(v271 + 80 * v272 + 8) & 0x7FFFFFFF;
          v273 = 0x7FFFFFFF;
          if ((_DWORD)v272 == 0x7FFFFFFF)
            break;
          if (*(unsigned __int8 *)(v271 + 80 * v272 + 12) == 129)
            goto LABEL_339;
        }
      }
    }
  }
  else
  {
    v271 = *(_QWORD *)(a3 + 16);
    v273 = 0x7FFFFFFF;
  }
  v274 = (float)((float)(v261 - v258) + v387) - v393;
  v275 = *(float *)(v271 + 80 * v273 + 48);
  v276 = *(_DWORD *)(a1 + 8);
  v277 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v280 = NAN;
      goto LABEL_346;
    }
    LODWORD(v278) = info.numer;
    LODWORD(v279) = info.denom;
    v277 = (double)v278 / (double)v279;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v277;
  }
  v280 = v277 * (double)(unint64_t)(float)(v275 / (float)v276);
LABEL_346:
  v281 = v270 / 1000000.0;
  if (*(_QWORD *)a3)
  {
    v282 = *(_QWORD *)(a3 + 16);
    v283 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0xAF26563F2EC4C8E6 % *(unsigned int *)(a3 + 24)));
    v284 = 0x7FFFFFFF;
    if ((_DWORD)v283 != 0x7FFFFFFF)
    {
      if (*(unsigned __int8 *)(v282 + 80 * v283 + 12) == 128)
      {
LABEL_351:
        v284 = v283;
      }
      else
      {
        while (1)
        {
          LODWORD(v283) = *(_DWORD *)(v282 + 80 * v283 + 8) & 0x7FFFFFFF;
          v284 = 0x7FFFFFFF;
          if ((_DWORD)v283 == 0x7FFFFFFF)
            break;
          if (*(unsigned __int8 *)(v282 + 80 * v283 + 12) == 128)
            goto LABEL_351;
        }
      }
    }
  }
  else
  {
    v282 = *(_QWORD *)(a3 + 16);
    v284 = 0x7FFFFFFF;
  }
  v285 = v375 / 1000000.0;
  v286 = v281 + v274;
  v287 = *(float *)(v282 + 80 * v284 + 48);
  v288 = *(_DWORD *)(a1 + 8);
  v289 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  v290 = v280 / 1000000.0;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v293 = NAN;
      goto LABEL_358;
    }
    LODWORD(v291) = info.numer;
    LODWORD(v292) = info.denom;
    v289 = (double)v291 / (double)v292;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v289;
  }
  v293 = v289 * (double)(unint64_t)(float)(v287 / (float)v288);
LABEL_358:
  v295 = v293 / 1000000.0;
  if (*(_QWORD *)a3)
  {
    v296 = *(_QWORD *)(a3 + 16);
    v297 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x8BC946409C88CB8FLL % *(unsigned int *)(a3 + 24)));
    v298 = 0x7FFFFFFF;
    if ((_DWORD)v297 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v296 + 80 * v297 + 12) == 121)
      {
LABEL_363:
        v298 = v297;
      }
      else
      {
        while (1)
        {
          LODWORD(v297) = *(_DWORD *)(v296 + 80 * v297 + 8) & 0x7FFFFFFF;
          v298 = 0x7FFFFFFF;
          if ((_DWORD)v297 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v296 + 80 * v297 + 12) == 121)
            goto LABEL_363;
        }
      }
    }
  }
  else
  {
    v296 = *(_QWORD *)(a3 + 16);
    v298 = 0x7FFFFFFF;
  }
  v300 = v286 + v290 + v295;
  v388 = v285;
  v294 = v285;
  v301 = v294;
  v302 = *(float *)(v296 + 80 * v298 + 48);
  v303 = *(_DWORD *)(a1 + 8);
  v304 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v307 = NAN;
      goto LABEL_370;
    }
    LODWORD(v305) = info.numer;
    LODWORD(v306) = info.denom;
    v304 = (double)v305 / (double)v306;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v304;
  }
  v307 = v304 * (double)(unint64_t)(float)(v302 / (float)v303);
LABEL_370:
  v299 = v382 / 1000000.0;
  v308 = v299;
  re::DynamicString::appendf((re::DynamicString *)v11, "Rendering : %.2f    Physics : %.2f\n", v300, v307 / 1000000.0 + v301);
  if (*(_QWORD *)a3)
  {
    v309 = *(_QWORD *)(a3 + 16);
    v310 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0xD94FA4A9067DC0C4 % *(unsigned int *)(a3 + 24)));
    v311 = 0x7FFFFFFF;
    if ((_DWORD)v310 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v309 + 80 * v310 + 12) == 123)
      {
LABEL_375:
        v311 = v310;
      }
      else
      {
        while (1)
        {
          LODWORD(v310) = *(_DWORD *)(v309 + 80 * v310 + 8) & 0x7FFFFFFF;
          v311 = 0x7FFFFFFF;
          if ((_DWORD)v310 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v309 + 80 * v310 + 12) == 123)
            goto LABEL_375;
        }
      }
    }
  }
  else
  {
    v309 = *(_QWORD *)(a3 + 16);
    v311 = 0x7FFFFFFF;
  }
  v312 = v383 / 1000000.0 + v308;
  v313 = *(float *)(v309 + 80 * v311 + 48);
  v314 = *(_DWORD *)(a1 + 8);
  v315 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v318 = NAN;
      goto LABEL_382;
    }
    LODWORD(v316) = info.numer;
    LODWORD(v317) = info.denom;
    v315 = (double)v316 / (double)v317;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v315;
  }
  v318 = v315 * (double)(unint64_t)(float)(v313 / (float)v314);
LABEL_382:
  if (*(_QWORD *)a3)
  {
    v320 = *(_QWORD *)(a3 + 16);
    v321 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0xEAD39EBF60CC176uLL % *(unsigned int *)(a3 + 24)));
    v322 = 0x7FFFFFFF;
    if ((_DWORD)v321 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v320 + 80 * v321 + 12) == 124)
      {
LABEL_387:
        v322 = v321;
      }
      else
      {
        while (1)
        {
          LODWORD(v321) = *(_DWORD *)(v320 + 80 * v321 + 8) & 0x7FFFFFFF;
          v322 = 0x7FFFFFFF;
          if ((_DWORD)v321 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v320 + 80 * v321 + 12) == 124)
            goto LABEL_387;
        }
      }
    }
  }
  else
  {
    v320 = *(_QWORD *)(a3 + 16);
    v322 = 0x7FFFFFFF;
  }
  v323 = v381 / 1000000.0;
  v384 = v312;
  v319 = v312;
  v324 = v319;
  v325 = *(float *)(v320 + 80 * v322 + 48);
  v326 = *(_DWORD *)(a1 + 8);
  v327 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  v328 = v318 / 1000000.0;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v331 = NAN;
      goto LABEL_394;
    }
    LODWORD(v329) = info.numer;
    LODWORD(v330) = info.denom;
    v327 = (double)v329 / (double)v330;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v327;
  }
  v331 = v327 * (double)(unint64_t)(float)(v325 / (float)v326);
LABEL_394:
  v333 = v331 / 1000000.0;
  if (*(_QWORD *)a3)
  {
    v334 = *(_QWORD *)(a3 + 16);
    v335 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x2D2898CE1F8CEF8EuLL % *(unsigned int *)(a3 + 24)));
    v336 = 0x7FFFFFFF;
    v337 = v261;
    if ((_DWORD)v335 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v334 + 80 * v335 + 12) == 125)
      {
LABEL_399:
        v336 = v335;
      }
      else
      {
        while (1)
        {
          LODWORD(v335) = *(_DWORD *)(v334 + 80 * v335 + 8) & 0x7FFFFFFF;
          v336 = 0x7FFFFFFF;
          if ((_DWORD)v335 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v334 + 80 * v335 + 12) == 125)
            goto LABEL_399;
        }
      }
    }
  }
  else
  {
    v337 = v261;
    v334 = *(_QWORD *)(a3 + 16);
    v336 = 0x7FFFFFFF;
  }
  v338 = v328 + v324 + v333;
  v394 = v323;
  v332 = v323;
  v339 = v332;
  v340 = *(float *)(v334 + 80 * v336 + 48);
  v341 = *(_DWORD *)(a1 + 8);
  v342 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v345 = NAN;
      goto LABEL_406;
    }
    LODWORD(v343) = info.numer;
    LODWORD(v344) = info.denom;
    v342 = (double)v343 / (double)v344;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v342;
  }
  v345 = v342 * (double)(unint64_t)(float)(v340 / (float)v341);
LABEL_406:
  v346 = v377 / 1000000.0;
  v347 = v391 / 1000000.0;
  re::DynamicString::appendf((re::DynamicString *)v11, "Network : %.2f    Animation : %.2f\n", v338, v345 / 1000000.0 + v339);
  if (*(_QWORD *)a3)
  {
    v348 = *(_QWORD *)(a3 + 16);
    v349 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x178631649EA56D8AuLL % *(unsigned int *)(a3 + 24)));
    v350 = 0x7FFFFFFF;
    if ((_DWORD)v349 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v348 + 80 * v349 + 12) == 120)
      {
LABEL_411:
        v350 = v349;
      }
      else
      {
        while (1)
        {
          LODWORD(v349) = *(_DWORD *)(v348 + 80 * v349 + 8) & 0x7FFFFFFF;
          v350 = 0x7FFFFFFF;
          if ((_DWORD)v349 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v348 + 80 * v349 + 12) == 120)
            goto LABEL_411;
        }
      }
    }
  }
  else
  {
    v348 = *(_QWORD *)(a3 + 16);
    v350 = 0x7FFFFFFF;
  }
  v351 = *(float *)(v348 + 80 * v350 + 48);
  v352 = *(_DWORD *)(a1 + 8);
  v353 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v356 = NAN;
      goto LABEL_418;
    }
    LODWORD(v354) = info.numer;
    LODWORD(v355) = info.denom;
    v353 = (double)v354 / (double)v355;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v353;
  }
  v356 = v353 * (double)(unint64_t)(float)(v351 / (float)v352);
LABEL_418:
  re::DynamicString::appendf((re::DynamicString *)v11, "Assets : %.2f    Audio : %.2f\n", v346, v356 / 1000000.0 + v347);
  *(_DWORD *)(v8 + (v9 << 6) + 56) = 1;
  if (*(_QWORD *)a3)
  {
    v357 = *(_QWORD *)(a3 + 16);
    v358 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0xFFCB5C99F6AA8871 % *(unsigned int *)(a3 + 24)));
    v359 = 0x7FFFFFFF;
    if ((_DWORD)v358 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v357 + 80 * v358 + 12) == 18)
      {
LABEL_423:
        v359 = v358;
      }
      else
      {
        while (1)
        {
          LODWORD(v358) = *(_DWORD *)(v357 + 80 * v358 + 8) & 0x7FFFFFFF;
          v359 = 0x7FFFFFFF;
          if ((_DWORD)v358 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v357 + 80 * v358 + 12) == 18)
            goto LABEL_423;
        }
      }
    }
  }
  else
  {
    v357 = *(_QWORD *)(a3 + 16);
    v359 = 0x7FFFFFFF;
  }
  v360 = *(float *)(v357 + 80 * v359 + 48);
  v361 = *(_DWORD *)(a1 + 8);
  v362 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v365 = NAN;
      goto LABEL_430;
    }
    LODWORD(v363) = info.numer;
    LODWORD(v364) = info.denom;
    v362 = (double)v363 / (double)v364;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v362;
  }
  v365 = v362 * (double)(unint64_t)(float)(v360 / (float)v361);
LABEL_430:
  v366 = v390 / 1000000.0;
  v367 = v389 / 1000000.0;
  v368 = v366 + v367;
  v369 = v380 / 1000000.0;
  v370 = (float)((float)((float)((float)((float)((float)(v396 - (float)(v368 + v369)) - v384) - v388) - v394) - v346)
               - v347)
       - v337;
  v371 = 0.0;
  if (v400 <= 0.0)
    v371 = v398;
  v372 = v365 / 1000000.0;
  result = re::DynamicString::appendf((re::DynamicString *)v11, "Update Callback : %.2f    Others : %.2f\n", v372, (float)((float)(v370 - v371) - v372));
  *(_DWORD *)(v8 + (v9 << 6) + 48) = 7;
  return result;
}

double re::FrameAnimationStats::dumpStatisticsInternal(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  _BYTE *v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  float v17;
  int v18;
  double v19;
  unint64_t v20;
  unint64_t v21;
  double v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  float v26;
  int v27;
  double v28;
  unint64_t v29;
  unint64_t v30;
  double v31;
  uint64_t v32;
  uint64_t v33;
  unsigned int v34;
  float v35;
  int v36;
  double v37;
  unint64_t v38;
  unint64_t v39;
  double v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  float v45;
  float v46;
  unsigned int v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  float v54;
  float v55;
  float v56;
  unsigned int v57;
  uint64_t v58;
  unsigned int v59;
  unsigned int v60;
  uint64_t v61;
  unint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  float v66;
  float v67;
  unsigned int v68;
  uint64_t v69;
  unint64_t v70;
  uint64_t v71;
  uint64_t v72;
  unsigned int v73;
  unsigned int v74;
  unsigned int v75;
  float v76;
  int v77;
  uint64_t v78;
  uint64_t v79;
  double result;
  mach_timebase_info info;

  LODWORD(v5) = 0x7FFFFFFF;
  if (*(_QWORD *)a2)
  {
    v6 = **(unsigned int **)(a2 + 8);
    if ((_DWORD)v6 != 0x7FFFFFFF)
    {
      v7 = *(_QWORD *)(a2 + 16);
      if (*(_DWORD *)(v7 + (v6 << 6) + 12))
      {
        v5 = **(unsigned int **)(a2 + 8);
        while (1)
        {
          v5 = *(_DWORD *)(v7 + (v5 << 6) + 8) & 0x7FFFFFFF;
          if ((_DWORD)v5 == 0x7FFFFFFF)
            break;
          if (!*(_DWORD *)(v7 + (v5 << 6) + 12))
            goto LABEL_10;
        }
        LODWORD(v5) = 0x7FFFFFFF;
      }
      else
      {
        LODWORD(v5) = **(_DWORD **)(a2 + 8);
      }
    }
  }
LABEL_10:
  v8 = *(_QWORD *)(a2 + 16);
  v9 = v5;
  v10 = v8 + ((unint64_t)v5 << 6);
  v11 = (_QWORD *)(v10 + 16);
  v12 = *(_QWORD *)(v10 + 24);
  if ((v12 & 1) != 0)
  {
    v11[1] = 1;
    v13 = (_BYTE *)v11[2];
  }
  else
  {
    *((_BYTE *)v11 + 8) = v12 & 1;
    v13 = (char *)v11 + 9;
  }
  *v13 = 0;
  re::DynamicString::appendf((re::DynamicString *)v11, "Animation Stats\n");
  v14 = 0x7FFFFFFF;
  if (*(_QWORD *)a3)
  {
    v15 = *(_DWORD *)(*(_QWORD *)(a3 + 8) + 4 * (0x2D2898CE1F8CEF8EuLL % *(unsigned int *)(a3 + 24)));
    if (v15 != 0x7FFFFFFF)
    {
      v16 = *(_QWORD *)(a3 + 16);
      v14 = *(_DWORD *)(*(_QWORD *)(a3 + 8) + 4 * (0x2D2898CE1F8CEF8EuLL % *(unsigned int *)(a3 + 24)));
      if (*(_BYTE *)(v16 + 80 * v15 + 12) != 125)
      {
        while (1)
        {
          v14 = *(_DWORD *)(v16
                          + 80
                          * *(unsigned int *)(*(_QWORD *)(a3 + 8)
                                            + 4 * (0x2D2898CE1F8CEF8EuLL % *(unsigned int *)(a3 + 24)))
                          + 8) & 0x7FFFFFFF;
          if (v14 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v16 + 80 * v14 + 12) == 125)
            goto LABEL_20;
        }
        v14 = 0x7FFFFFFF;
      }
    }
  }
LABEL_20:
  v17 = *(float *)(*(_QWORD *)(a3 + 16) + 80 * v14 + 48);
  v18 = *(_DWORD *)(a1 + 8);
  v19 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v22 = NAN;
      goto LABEL_25;
    }
    LODWORD(v20) = info.numer;
    LODWORD(v21) = info.denom;
    v19 = (double)v20 / (double)v21;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v19;
  }
  v22 = v19 * (double)(unint64_t)(float)(v17 / (float)v18);
LABEL_25:
  re::DynamicString::appendf((re::DynamicString *)v11, "ECS Animations CPU Time (ms) : %.2f\n", v22 / 1000000.0);
  if (*(_QWORD *)a3)
  {
    v23 = *(_QWORD *)(a3 + 16);
    v24 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0xEB90A3352640AF2uLL % *(unsigned int *)(a3 + 24)));
    v25 = 0x7FFFFFFF;
    if ((_DWORD)v24 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v23 + 80 * v24 + 12) == 20)
      {
LABEL_30:
        v25 = v24;
      }
      else
      {
        while (1)
        {
          LODWORD(v24) = *(_DWORD *)(v23 + 80 * v24 + 8) & 0x7FFFFFFF;
          v25 = 0x7FFFFFFF;
          if ((_DWORD)v24 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v23 + 80 * v24 + 12) == 20)
            goto LABEL_30;
        }
      }
    }
  }
  else
  {
    v23 = *(_QWORD *)(a3 + 16);
    v25 = 0x7FFFFFFF;
  }
  v26 = *(float *)(v23 + 80 * v25 + 48);
  v27 = *(_DWORD *)(a1 + 8);
  v28 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v31 = NAN;
      goto LABEL_37;
    }
    LODWORD(v29) = info.numer;
    LODWORD(v30) = info.denom;
    v28 = (double)v29 / (double)v30;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v28;
  }
  v31 = v28 * (double)(unint64_t)(float)(v26 / (float)v27);
LABEL_37:
  re::DynamicString::appendf((re::DynamicString *)v11, "Animation Manager CPU Time (ms) : %.2f\n", v31 / 1000000.0);
  if (*(_QWORD *)a3)
  {
    v32 = *(_QWORD *)(a3 + 16);
    v33 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x786DD0AB972D849AuLL % *(unsigned int *)(a3 + 24)));
    v34 = 0x7FFFFFFF;
    if ((_DWORD)v33 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v32 + 80 * v33 + 12) == 115)
      {
LABEL_42:
        v34 = v33;
      }
      else
      {
        while (1)
        {
          LODWORD(v33) = *(_DWORD *)(v32 + 80 * v33 + 8) & 0x7FFFFFFF;
          v34 = 0x7FFFFFFF;
          if ((_DWORD)v33 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v32 + 80 * v33 + 12) == 115)
            goto LABEL_42;
        }
      }
    }
  }
  else
  {
    v32 = *(_QWORD *)(a3 + 16);
    v34 = 0x7FFFFFFF;
  }
  v35 = *(float *)(v32 + 80 * v34 + 48);
  v36 = *(_DWORD *)(a1 + 8);
  v37 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v40 = NAN;
      goto LABEL_49;
    }
    LODWORD(v38) = info.numer;
    LODWORD(v39) = info.denom;
    v37 = (double)v38 / (double)v39;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v37;
  }
  v40 = v37 * (double)(unint64_t)(float)(v35 / (float)v36);
LABEL_49:
  re::DynamicString::appendf((re::DynamicString *)v11, "Deform Processing CPU Time (ms) : %.2f\n", v40 / 1000000.0);
  if (!*(_QWORD *)a3)
  {
    v42 = *(_QWORD *)(a3 + 16);
    v45 = (float)*(int *)(a1 + 8);
    v46 = *(float *)(v42 + 0x27FFFFFFE0) / v45;
    v47 = 0x7FFFFFFF;
    goto LABEL_63;
  }
  v41 = *(unsigned int *)(a3 + 24);
  v43 = *(_QWORD *)(a3 + 8);
  v42 = *(_QWORD *)(a3 + 16);
  v44 = *(unsigned int *)(v43 + 4 * (0x33CFFC116CF4F2F0 % v41));
  if ((_DWORD)v44 == 0x7FFFFFFF)
  {
    LODWORD(v44) = 0x7FFFFFFF;
LABEL_54:
    v48 = v42 + 80 * v44;
    goto LABEL_58;
  }
  if (*(_BYTE *)(v42 + 80 * v44 + 12) == 116)
    goto LABEL_54;
  do
    LODWORD(v44) = *(_DWORD *)(v42 + 80 * v44 + 8) & 0x7FFFFFFF;
  while ((_DWORD)v44 != 0x7FFFFFFF && *(_BYTE *)(v42 + 80 * v44 + 12) != 116);
  v48 = v42 + 80 * v44;
LABEL_58:
  v45 = (float)*(int *)(a1 + 8);
  v46 = *(float *)(v48 + 48) / v45;
  v49 = *(unsigned int *)(v43 + 4 * (0xEF08A61A384AADEELL % v41));
  v47 = 0x7FFFFFFF;
  if ((_DWORD)v49 != 0x7FFFFFFF)
  {
    if (*(_BYTE *)(v42 + 80 * v49 + 12) == 117)
    {
LABEL_62:
      v47 = v49;
    }
    else
    {
      while (1)
      {
        LODWORD(v49) = *(_DWORD *)(v42 + 80 * v49 + 8) & 0x7FFFFFFF;
        v47 = 0x7FFFFFFF;
        if ((_DWORD)v49 == 0x7FFFFFFF)
          break;
        if (*(_BYTE *)(v42 + 80 * v49 + 12) == 117)
          goto LABEL_62;
      }
    }
  }
LABEL_63:
  re::DynamicString::appendf((re::DynamicString *)v11, "Active Deformations : %.0f, Total Joints : %.0f\n", v46, (float)(*(float *)(v42 + 80 * v47 + 48) / v45));
  re::DynamicString::appendf((re::DynamicString *)v11, "Component Counts\n");
  if (!*(_QWORD *)a3)
  {
    v51 = *(_QWORD *)(a3 + 16);
    v54 = *(float *)(v51 + 0x27FFFFFFE0);
    v55 = (float)*(int *)(a1 + 8);
    v56 = v54 / v55;
    v57 = 0x7FFFFFFF;
    goto LABEL_83;
  }
  v50 = *(unsigned int *)(a3 + 24);
  v52 = *(_QWORD *)(a3 + 8);
  v51 = *(_QWORD *)(a3 + 16);
  v53 = *(unsigned int *)(v52 + 4 * (0x8607C7321697C49DLL % v50));
  if ((_DWORD)v53 == 0x7FFFFFFF)
  {
    LODWORD(v53) = 0x7FFFFFFF;
  }
  else if (*(_BYTE *)(v51 + 80 * v53 + 12) != 107)
  {
    do
      LODWORD(v53) = *(_DWORD *)(v51 + 80 * v53 + 8) & 0x7FFFFFFF;
    while ((_DWORD)v53 != 0x7FFFFFFF && *(_BYTE *)(v51 + 80 * v53 + 12) != 107);
    v58 = v51 + 80 * v53;
    goto LABEL_72;
  }
  v58 = v51 + 80 * v53;
LABEL_72:
  v55 = (float)*(int *)(a1 + 8);
  v56 = *(float *)(v58 + 48) / v55;
  v59 = *(_DWORD *)(v52 + 4 * (0x581D666DC9C63F77 % v50));
  v57 = 0x7FFFFFFF;
  v60 = 0x7FFFFFFF;
  if (v59 != 0x7FFFFFFF)
  {
    v60 = *(_DWORD *)(v52 + 4 * (0x581D666DC9C63F77 % v50));
    if (*(_BYTE *)(v51 + 80 * v59 + 12) != 111)
    {
      while (1)
      {
        v60 = *(_DWORD *)(v51 + 80 * *(unsigned int *)(v52 + 4 * (0x581D666DC9C63F77 % v50)) + 8) & 0x7FFFFFFF;
        if (v60 == 0x7FFFFFFF)
          break;
        if (*(_BYTE *)(v51 + 80 * v60 + 12) == 111)
          goto LABEL_78;
      }
      v60 = 0x7FFFFFFF;
    }
  }
LABEL_78:
  v54 = *(float *)(v51 + 80 * v60 + 48);
  v61 = *(unsigned int *)(v52 + 4 * (0x30AF74B32E05F342 % v50));
  if ((_DWORD)v61 != 0x7FFFFFFF)
  {
    if (*(_BYTE *)(v51 + 80 * v61 + 12) == 109)
    {
LABEL_82:
      v57 = v61;
    }
    else
    {
      while (1)
      {
        LODWORD(v61) = *(_DWORD *)(v51 + 80 * v61 + 8) & 0x7FFFFFFF;
        v57 = 0x7FFFFFFF;
        if ((_DWORD)v61 == 0x7FFFFFFF)
          break;
        if (*(_BYTE *)(v51 + 80 * v61 + 12) == 109)
          goto LABEL_82;
      }
    }
  }
LABEL_83:
  re::DynamicString::appendf((re::DynamicString *)v11, "Animations : %.0f, Blend Shapes : %.0f, Rigs : %.0f\n", v56, (float)(v54 / v55), (float)(*(float *)(v51 + 80 * v57 + 48) / v55));
  if (!*(_QWORD *)a3)
  {
    v63 = *(_QWORD *)(a3 + 16);
    v66 = (float)*(int *)(a1 + 8);
    v67 = *(float *)(v63 + 0x27FFFFFFE0) / v66;
    v68 = 0x7FFFFFFF;
    goto LABEL_95;
  }
  v62 = *(unsigned int *)(a3 + 24);
  v64 = *(_QWORD *)(a3 + 8);
  v63 = *(_QWORD *)(a3 + 16);
  v65 = *(unsigned int *)(v64 + 4 * (0xF2BAED4A618B76B9 % v62));
  if ((_DWORD)v65 == 0x7FFFFFFF)
    goto LABEL_85;
  if (*(_BYTE *)(v63 + 80 * v65 + 12) != 108)
  {
    while (1)
    {
      LODWORD(v65) = *(_DWORD *)(v63 + 80 * v65 + 8) & 0x7FFFFFFF;
      if ((_DWORD)v65 == 0x7FFFFFFF)
        break;
      if (*(_BYTE *)(v63 + 80 * v65 + 12) == 108)
        goto LABEL_90;
    }
LABEL_85:
    LODWORD(v65) = 0x7FFFFFFF;
  }
LABEL_90:
  v66 = (float)*(int *)(a1 + 8);
  v67 = *(float *)(v63 + 80 * v65 + 48) / v66;
  v69 = *(unsigned int *)(v64 + 4 * (0xE2D92833383B377ELL % v62));
  v68 = 0x7FFFFFFF;
  if ((_DWORD)v69 != 0x7FFFFFFF)
  {
    if (*(_BYTE *)(v63 + 80 * v69 + 12) == 113)
    {
LABEL_94:
      v68 = v69;
    }
    else
    {
      while (1)
      {
        LODWORD(v69) = *(_DWORD *)(v63 + 80 * v69 + 8) & 0x7FFFFFFF;
        v68 = 0x7FFFFFFF;
        if ((_DWORD)v69 == 0x7FFFFFFF)
          break;
        if (*(_BYTE *)(v63 + 80 * v69 + 12) == 113)
          goto LABEL_94;
      }
    }
  }
LABEL_95:
  re::DynamicString::appendf((re::DynamicString *)v11, "Skeletal Poses : %.0f, Mesh Offsets : %.0f\n", v67, (float)(*(float *)(v63 + 80 * v68 + 48) / v66));
  if (*(_QWORD *)a3)
  {
    v70 = *(unsigned int *)(a3 + 24);
    v72 = *(_QWORD *)(a3 + 8);
    v71 = *(_QWORD *)(a3 + 16);
    v73 = *(_DWORD *)(v72 + 4 * (0x1801EBC20183EB48 % v70));
    v74 = 0x7FFFFFFF;
    v75 = 0x7FFFFFFF;
    if (v73 != 0x7FFFFFFF)
    {
      v75 = *(_DWORD *)(v72 + 4 * (0x1801EBC20183EB48 % v70));
      if (*(_BYTE *)(v71 + 80 * v73 + 12) != 112)
      {
        while (1)
        {
          v75 = *(_DWORD *)(v71 + 80 * *(unsigned int *)(v72 + 4 * (0x1801EBC20183EB48 % v70)) + 8) & 0x7FFFFFFF;
          if (v75 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v71 + 80 * v75 + 12) == 112)
            goto LABEL_103;
        }
        v75 = 0x7FFFFFFF;
      }
    }
LABEL_103:
    v76 = *(float *)(v71 + 80 * v75 + 48);
    v77 = *(_DWORD *)(a1 + 8);
    v78 = *(unsigned int *)(v72 + 4 * (0xCA4B25A23588FF96 % v70));
    if ((_DWORD)v78 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v71 + 80 * v78 + 12) == 110)
      {
LABEL_107:
        v74 = v78;
      }
      else
      {
        while (1)
        {
          LODWORD(v78) = *(_DWORD *)(v71 + 80 * v78 + 8) & 0x7FFFFFFF;
          v74 = 0x7FFFFFFF;
          if ((_DWORD)v78 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v71 + 80 * v78 + 12) == 110)
            goto LABEL_107;
        }
      }
    }
  }
  else
  {
    v71 = *(_QWORD *)(a3 + 16);
    v76 = *(float *)(v71 + 0x27FFFFFFE0);
    v77 = *(_DWORD *)(a1 + 8);
    v74 = 0x7FFFFFFF;
  }
  re::DynamicString::appendf((re::DynamicString *)v11, "Mesh Smooths : %.0f, Mesh Deformations : %.0f\n", (float)(v76 / (float)v77), (float)(*(float *)(v71 + 80 * v74 + 48) / (float)v77));
  v79 = v8 + (v9 << 6);
  *(_QWORD *)&result = 0x2D00000009;
  *(_QWORD *)(v79 + 48) = 0x2D00000009;
  *(_DWORD *)(v79 + 56) = 2;
  return result;
}

double re::FrameAssetStats::dumpStatisticsInternal(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  _BYTE *v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  float v17;
  int v18;
  double v19;
  unint64_t v20;
  unint64_t v21;
  double v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  float v26;
  double v27;
  unint64_t v28;
  unint64_t v29;
  double v30;
  uint64_t v31;
  uint64_t v32;
  unsigned int v33;
  float v34;
  double v35;
  unint64_t v36;
  unint64_t v37;
  double v38;
  uint64_t v39;
  uint64_t v40;
  unsigned int v41;
  float v42;
  double v43;
  unint64_t v44;
  unint64_t v45;
  double v46;
  double v47;
  uint64_t v48;
  uint64_t v49;
  unsigned int v50;
  float v51;
  double v52;
  double v53;
  unint64_t v54;
  unint64_t v55;
  double v56;
  uint64_t v57;
  uint64_t v58;
  unsigned int v59;
  float v60;
  double v61;
  unint64_t v62;
  unint64_t v63;
  double v64;
  uint64_t v65;
  uint64_t v66;
  unsigned int v67;
  float v68;
  double v69;
  unint64_t v70;
  unint64_t v71;
  double v72;
  uint64_t v73;
  uint64_t v74;
  unsigned int v75;
  float v76;
  double v77;
  unint64_t v78;
  unint64_t v79;
  double v80;
  uint64_t v81;
  uint64_t v82;
  unsigned int v83;
  double v84;
  double v85;
  float v86;
  double v87;
  double v88;
  unint64_t v89;
  unint64_t v90;
  double v91;
  uint64_t v92;
  uint64_t v93;
  unsigned int v94;
  unint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  float v99;
  float v100;
  unsigned int v101;
  uint64_t v102;
  uint64_t v103;
  unint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  float v108;
  float v109;
  unsigned int v110;
  uint64_t v111;
  uint64_t v112;
  unint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  float v117;
  float v118;
  unsigned int v119;
  uint64_t v120;
  double v121;
  const char *v122;
  unint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  float v127;
  int v128;
  unsigned int v129;
  uint64_t v130;
  double v131;
  const char *v132;
  uint64_t v133;
  double result;
  mach_timebase_info info;
  char v136;
  _BYTE v137[7];
  const char *v138;

  LODWORD(v5) = 0x7FFFFFFF;
  if (*(_QWORD *)a2)
  {
    v6 = **(unsigned int **)(a2 + 8);
    if ((_DWORD)v6 != 0x7FFFFFFF)
    {
      v7 = *(_QWORD *)(a2 + 16);
      if (*(_DWORD *)(v7 + (v6 << 6) + 12))
      {
        v5 = **(unsigned int **)(a2 + 8);
        while (1)
        {
          v5 = *(_DWORD *)(v7 + (v5 << 6) + 8) & 0x7FFFFFFF;
          if ((_DWORD)v5 == 0x7FFFFFFF)
            break;
          if (!*(_DWORD *)(v7 + (v5 << 6) + 12))
            goto LABEL_10;
        }
        LODWORD(v5) = 0x7FFFFFFF;
      }
      else
      {
        LODWORD(v5) = **(_DWORD **)(a2 + 8);
      }
    }
  }
LABEL_10:
  v8 = *(_QWORD *)(a2 + 16);
  v9 = v5;
  v10 = v8 + ((unint64_t)v5 << 6);
  v11 = (_QWORD *)(v10 + 16);
  v12 = *(_QWORD *)(v10 + 24);
  if ((v12 & 1) != 0)
  {
    v11[1] = 1;
    v13 = (_BYTE *)v11[2];
  }
  else
  {
    *((_BYTE *)v11 + 8) = v12 & 1;
    v13 = (char *)v11 + 9;
  }
  *v13 = 0;
  re::DynamicString::appendf((re::DynamicString *)v11, "Asset Pipeline Stats\n");
  v14 = 0x7FFFFFFF;
  if (*(_QWORD *)a3)
  {
    v15 = *(_DWORD *)(*(_QWORD *)(a3 + 8) + 4 * (0xD633B1846FAF2B49 % *(unsigned int *)(a3 + 24)));
    if (v15 != 0x7FFFFFFF)
    {
      v16 = *(_QWORD *)(a3 + 16);
      v14 = *(_DWORD *)(*(_QWORD *)(a3 + 8) + 4 * (0xD633B1846FAF2B49 % *(unsigned int *)(a3 + 24)));
      if (*(_BYTE *)(v16 + 80 * v15 + 12) != 21)
      {
        while (1)
        {
          v14 = *(_DWORD *)(v16
                          + 80
                          * *(unsigned int *)(*(_QWORD *)(a3 + 8)
                                            + 4 * (0xD633B1846FAF2B49 % *(unsigned int *)(a3 + 24)))
                          + 8) & 0x7FFFFFFF;
          if (v14 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v16 + 80 * v14 + 12) == 21)
            goto LABEL_20;
        }
        v14 = 0x7FFFFFFF;
      }
    }
  }
LABEL_20:
  v17 = *(float *)(*(_QWORD *)(a3 + 16) + 80 * v14 + 48);
  v18 = *(_DWORD *)(a1 + 8);
  v19 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v22 = NAN;
      goto LABEL_25;
    }
    LODWORD(v20) = info.numer;
    LODWORD(v21) = info.denom;
    v19 = (double)v20 / (double)v21;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v19;
  }
  v22 = v19 * (double)(unint64_t)(float)(v17 / (float)v18);
LABEL_25:
  re::DynamicString::appendf((re::DynamicString *)v11, "AssetManager Update Time (ms) : %.2f\n", v22 / 1000000.0);
  re::DynamicString::appendf((re::DynamicString *)v11, "Asset Registration App Lifetime Times (sec)\n");
  if (*(_QWORD *)a3)
  {
    v23 = *(_QWORD *)(a3 + 16);
    v24 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x926465EF67D04F3FLL % *(unsigned int *)(a3 + 24)));
    v25 = 0x7FFFFFFF;
    if ((_DWORD)v24 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v23 + 80 * v24 + 12) == 61)
      {
LABEL_30:
        v25 = v24;
      }
      else
      {
        while (1)
        {
          LODWORD(v24) = *(_DWORD *)(v23 + 80 * v24 + 8) & 0x7FFFFFFF;
          v25 = 0x7FFFFFFF;
          if ((_DWORD)v24 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v23 + 80 * v24 + 12) == 61)
            goto LABEL_30;
        }
      }
    }
  }
  else
  {
    v23 = *(_QWORD *)(a3 + 16);
    v25 = 0x7FFFFFFF;
  }
  v26 = *(float *)(v23 + 80 * v25 + 68);
  v27 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v30 = NAN;
      goto LABEL_37;
    }
    LODWORD(v28) = info.numer;
    LODWORD(v29) = info.denom;
    v27 = (double)v28 / (double)v29;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v27;
  }
  v30 = v27 * (double)(unint64_t)v26;
LABEL_37:
  if (*(_QWORD *)a3)
  {
    v31 = *(_QWORD *)(a3 + 16);
    v32 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x926465EF67D04F3FLL % *(unsigned int *)(a3 + 24)));
    v33 = 0x7FFFFFFF;
    if ((_DWORD)v32 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v31 + 80 * v32 + 12) == 61)
      {
LABEL_42:
        v33 = v32;
      }
      else
      {
        while (1)
        {
          LODWORD(v32) = *(_DWORD *)(v31 + 80 * v32 + 8) & 0x7FFFFFFF;
          v33 = 0x7FFFFFFF;
          if ((_DWORD)v32 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v31 + 80 * v32 + 12) == 61)
            goto LABEL_42;
        }
      }
    }
  }
  else
  {
    v31 = *(_QWORD *)(a3 + 16);
    v33 = 0x7FFFFFFF;
  }
  v34 = *(float *)(v31 + 80 * v33 + 64);
  v35 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v38 = NAN;
      goto LABEL_49;
    }
    LODWORD(v36) = info.numer;
    LODWORD(v37) = info.denom;
    v35 = (double)v36 / (double)v37;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v35;
  }
  v38 = v35 * (double)(unint64_t)v34;
LABEL_49:
  if (*(_QWORD *)a3)
  {
    v39 = *(_QWORD *)(a3 + 16);
    v40 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x926465EF67D04F3FLL % *(unsigned int *)(a3 + 24)));
    v41 = 0x7FFFFFFF;
    if ((_DWORD)v40 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v39 + 80 * v40 + 12) == 61)
      {
LABEL_54:
        v41 = v40;
      }
      else
      {
        while (1)
        {
          LODWORD(v40) = *(_DWORD *)(v39 + 80 * v40 + 8) & 0x7FFFFFFF;
          v41 = 0x7FFFFFFF;
          if ((_DWORD)v40 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v39 + 80 * v40 + 12) == 61)
            goto LABEL_54;
        }
      }
    }
  }
  else
  {
    v39 = *(_QWORD *)(a3 + 16);
    v41 = 0x7FFFFFFF;
  }
  v42 = *(float *)(v39 + 80 * v41 + 60);
  v43 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v46 = NAN;
      goto LABEL_61;
    }
    LODWORD(v44) = info.numer;
    LODWORD(v45) = info.denom;
    v43 = (double)v44 / (double)v45;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v43;
  }
  v46 = v43 * (double)(unint64_t)v42;
LABEL_61:
  v47 = v46 / 1000000.0;
  if (*(_QWORD *)a3)
  {
    v48 = *(_QWORD *)(a3 + 16);
    v49 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x926465EF67D04F3FLL % *(unsigned int *)(a3 + 24)));
    v50 = 0x7FFFFFFF;
    if ((_DWORD)v49 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v48 + 80 * v49 + 12) == 61)
      {
LABEL_66:
        v50 = v49;
      }
      else
      {
        while (1)
        {
          LODWORD(v49) = *(_DWORD *)(v48 + 80 * v49 + 8) & 0x7FFFFFFF;
          v50 = 0x7FFFFFFF;
          if ((_DWORD)v49 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v48 + 80 * v49 + 12) == 61)
            goto LABEL_66;
        }
      }
    }
  }
  else
  {
    v48 = *(_QWORD *)(a3 + 16);
    v50 = 0x7FFFFFFF;
  }
  v51 = *(float *)(v48 + 80 * v50 + 76);
  v52 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  v53 = v47 / 1000.0;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v56 = NAN;
      goto LABEL_73;
    }
    LODWORD(v54) = info.numer;
    LODWORD(v55) = info.denom;
    v52 = (double)v54 / (double)v55;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v52;
  }
  v56 = v52 * (double)(unint64_t)v51;
LABEL_73:
  re::DynamicString::appendf((re::DynamicString *)v11, "Total : %.2f, Max : %.2f, Min : %.2f, Mean : %.2f\n", v30 / 1000000.0 / 1000.0, v38 / 1000000.0 / 1000.0, v53, v56 / 1000000.0 / 1000.0);
  re::DynamicString::appendf((re::DynamicString *)v11, "Asset Load App Lifetime Times (sec)\n");
  if (*(_QWORD *)a3)
  {
    v57 = *(_QWORD *)(a3 + 16);
    v58 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x8BD899976CB6021ELL % *(unsigned int *)(a3 + 24)));
    v59 = 0x7FFFFFFF;
    if ((_DWORD)v58 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v57 + 80 * v58 + 12) == 59)
      {
LABEL_78:
        v59 = v58;
      }
      else
      {
        while (1)
        {
          LODWORD(v58) = *(_DWORD *)(v57 + 80 * v58 + 8) & 0x7FFFFFFF;
          v59 = 0x7FFFFFFF;
          if ((_DWORD)v58 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v57 + 80 * v58 + 12) == 59)
            goto LABEL_78;
        }
      }
    }
  }
  else
  {
    v57 = *(_QWORD *)(a3 + 16);
    v59 = 0x7FFFFFFF;
  }
  v60 = *(float *)(v57 + 80 * v59 + 48);
  v61 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v64 = NAN;
      goto LABEL_85;
    }
    LODWORD(v62) = info.numer;
    LODWORD(v63) = info.denom;
    v61 = (double)v62 / (double)v63;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v61;
  }
  v64 = v61 * (double)(unint64_t)(float)(v60 / 1000.0);
LABEL_85:
  if (*(_QWORD *)a3)
  {
    v65 = *(_QWORD *)(a3 + 16);
    v66 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x8BD899976CB6021ELL % *(unsigned int *)(a3 + 24)));
    v67 = 0x7FFFFFFF;
    if ((_DWORD)v66 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v65 + 80 * v66 + 12) == 59)
      {
LABEL_90:
        v67 = v66;
      }
      else
      {
        while (1)
        {
          LODWORD(v66) = *(_DWORD *)(v65 + 80 * v66 + 8) & 0x7FFFFFFF;
          v67 = 0x7FFFFFFF;
          if ((_DWORD)v66 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v65 + 80 * v66 + 12) == 59)
            goto LABEL_90;
        }
      }
    }
  }
  else
  {
    v65 = *(_QWORD *)(a3 + 16);
    v67 = 0x7FFFFFFF;
  }
  v68 = *(float *)(v65 + 80 * v67 + 44);
  v69 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v72 = NAN;
      goto LABEL_97;
    }
    LODWORD(v70) = info.numer;
    LODWORD(v71) = info.denom;
    v69 = (double)v70 / (double)v71;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v69;
  }
  v72 = v69 * (double)(unint64_t)(float)(v68 / 1000.0);
LABEL_97:
  if (*(_QWORD *)a3)
  {
    v73 = *(_QWORD *)(a3 + 16);
    v74 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x8BD899976CB6021ELL % *(unsigned int *)(a3 + 24)));
    v75 = 0x7FFFFFFF;
    if ((_DWORD)v74 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v73 + 80 * v74 + 12) == 59)
      {
LABEL_102:
        v75 = v74;
      }
      else
      {
        while (1)
        {
          LODWORD(v74) = *(_DWORD *)(v73 + 80 * v74 + 8) & 0x7FFFFFFF;
          v75 = 0x7FFFFFFF;
          if ((_DWORD)v74 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v73 + 80 * v74 + 12) == 59)
            goto LABEL_102;
        }
      }
    }
  }
  else
  {
    v73 = *(_QWORD *)(a3 + 16);
    v75 = 0x7FFFFFFF;
  }
  v76 = *(float *)(v73 + 80 * v75 + 40);
  v77 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v80 = NAN;
      goto LABEL_109;
    }
    LODWORD(v78) = info.numer;
    LODWORD(v79) = info.denom;
    v77 = (double)v78 / (double)v79;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v77;
  }
  v80 = v77 * (double)(unint64_t)(float)(v76 / 1000.0);
LABEL_109:
  if (*(_QWORD *)a3)
  {
    v81 = *(_QWORD *)(a3 + 16);
    v82 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x8BD899976CB6021ELL % *(unsigned int *)(a3 + 24)));
    v83 = 0x7FFFFFFF;
    if ((_DWORD)v82 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v81 + 80 * v82 + 12) == 59)
      {
LABEL_114:
        v83 = v82;
      }
      else
      {
        while (1)
        {
          LODWORD(v82) = *(_DWORD *)(v81 + 80 * v82 + 8) & 0x7FFFFFFF;
          v83 = 0x7FFFFFFF;
          if ((_DWORD)v82 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v81 + 80 * v82 + 12) == 59)
            goto LABEL_114;
        }
      }
    }
  }
  else
  {
    v81 = *(_QWORD *)(a3 + 16);
    v83 = 0x7FFFFFFF;
  }
  v84 = v64 / 1000000.0;
  v85 = v72 / 1000000.0;
  v86 = *(float *)(v81 + 80 * v83 + 56);
  v87 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  v88 = v80 / 1000000.0;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v91 = NAN;
      goto LABEL_121;
    }
    LODWORD(v89) = info.numer;
    LODWORD(v90) = info.denom;
    v87 = (double)v89 / (double)v90;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v87;
  }
  v91 = v87 * (double)(unint64_t)(float)(v86 / 1000.0);
LABEL_121:
  re::DynamicString::appendf((re::DynamicString *)v11, "Total : %.2f, Max : %.2f, Min : %.2f, Mean : %.2f\n", v84, v85, v88, v91 / 1000000.0);
  if (*(_QWORD *)a3)
  {
    v92 = *(_QWORD *)(a3 + 16);
    v93 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x99E7FE09B67A7978 % *(unsigned int *)(a3 + 24)));
    v94 = 0x7FFFFFFF;
    if ((_DWORD)v93 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v92 + 80 * v93 + 12) == 58)
      {
LABEL_126:
        v94 = v93;
      }
      else
      {
        while (1)
        {
          LODWORD(v93) = *(_DWORD *)(v92 + 80 * v93 + 8) & 0x7FFFFFFF;
          v94 = 0x7FFFFFFF;
          if ((_DWORD)v93 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v92 + 80 * v93 + 12) == 58)
            goto LABEL_126;
        }
      }
    }
  }
  else
  {
    v92 = *(_QWORD *)(a3 + 16);
    v94 = 0x7FFFFFFF;
  }
  re::DynamicString::appendf((re::DynamicString *)v11, "Total Assets : %.0f\n", (float)(*(float *)(v92 + 80 * v94 + 48) / (float)*(int *)(a1 + 8)));
  if (!*(_QWORD *)a3)
  {
    v96 = *(_QWORD *)(a3 + 16);
    v99 = (float)*(int *)(a1 + 8);
    v100 = *(float *)(v96 + 0x27FFFFFFE0) / v99;
    v101 = 0x7FFFFFFF;
    goto LABEL_142;
  }
  v95 = *(unsigned int *)(a3 + 24);
  v97 = *(_QWORD *)(a3 + 8);
  v96 = *(_QWORD *)(a3 + 16);
  v98 = *(unsigned int *)(v97 + 4 * (0x58EFD731A91FB004 % v95));
  if ((_DWORD)v98 == 0x7FFFFFFF)
  {
    LODWORD(v98) = 0x7FFFFFFF;
LABEL_133:
    v102 = v96 + 80 * v98;
    goto LABEL_137;
  }
  if (*(_BYTE *)(v96 + 80 * v98 + 12) == 56)
    goto LABEL_133;
  do
    LODWORD(v98) = *(_DWORD *)(v96 + 80 * v98 + 8) & 0x7FFFFFFF;
  while ((_DWORD)v98 != 0x7FFFFFFF && *(_BYTE *)(v96 + 80 * v98 + 12) != 56);
  v102 = v96 + 80 * v98;
LABEL_137:
  v99 = (float)*(int *)(a1 + 8);
  v100 = *(float *)(v102 + 48) / v99;
  v103 = *(unsigned int *)(v97 + 4 * (0x9ABD6DF5738C0A9BLL % v95));
  v101 = 0x7FFFFFFF;
  if ((_DWORD)v103 != 0x7FFFFFFF)
  {
    if (*(_BYTE *)(v96 + 80 * v103 + 12) == 55)
    {
LABEL_141:
      v101 = v103;
    }
    else
    {
      while (1)
      {
        LODWORD(v103) = *(_DWORD *)(v96 + 80 * v103 + 8) & 0x7FFFFFFF;
        v101 = 0x7FFFFFFF;
        if ((_DWORD)v103 == 0x7FFFFFFF)
          break;
        if (*(_BYTE *)(v96 + 80 * v103 + 12) == 55)
          goto LABEL_141;
      }
    }
  }
LABEL_142:
  re::DynamicString::appendf((re::DynamicString *)v11, "Loaded : %.0f, Loading : %.0f\n", v100, (float)(*(float *)(v96 + 80 * v101 + 48) / v99));
  if (!*(_QWORD *)a3)
  {
    v105 = *(_QWORD *)(a3 + 16);
    v108 = (float)*(int *)(a1 + 8);
    v109 = *(float *)(v105 + 0x27FFFFFFE0) / v108;
    v110 = 0x7FFFFFFF;
    goto LABEL_156;
  }
  v104 = *(unsigned int *)(a3 + 24);
  v106 = *(_QWORD *)(a3 + 8);
  v105 = *(_QWORD *)(a3 + 16);
  v107 = *(unsigned int *)(v106 + 4 * (0x6231EAB2525BA011 % v104));
  if ((_DWORD)v107 == 0x7FFFFFFF)
  {
    LODWORD(v107) = 0x7FFFFFFF;
LABEL_147:
    v111 = v105 + 80 * v107;
    goto LABEL_151;
  }
  if (*(_BYTE *)(v105 + 80 * v107 + 12) == 57)
    goto LABEL_147;
  do
    LODWORD(v107) = *(_DWORD *)(v105 + 80 * v107 + 8) & 0x7FFFFFFF;
  while ((_DWORD)v107 != 0x7FFFFFFF && *(_BYTE *)(v105 + 80 * v107 + 12) != 57);
  v111 = v105 + 80 * v107;
LABEL_151:
  v108 = (float)*(int *)(a1 + 8);
  v109 = *(float *)(v111 + 48) / v108;
  v112 = *(unsigned int *)(v106 + 4 * (0xF95D76A430C5BB5CLL % v104));
  v110 = 0x7FFFFFFF;
  if ((_DWORD)v112 != 0x7FFFFFFF)
  {
    if (*(_BYTE *)(v105 + 80 * v112 + 12) == 54)
    {
LABEL_155:
      v110 = v112;
    }
    else
    {
      while (1)
      {
        LODWORD(v112) = *(_DWORD *)(v105 + 80 * v112 + 8) & 0x7FFFFFFF;
        v110 = 0x7FFFFFFF;
        if ((_DWORD)v112 == 0x7FFFFFFF)
          break;
        if (*(_BYTE *)(v105 + 80 * v112 + 12) == 54)
          goto LABEL_155;
      }
    }
  }
LABEL_156:
  re::DynamicString::appendf((re::DynamicString *)v11, "Failed Loads: %.0f, Unloaded : %.0f\n", v109, (float)(*(float *)(v105 + 80 * v110 + 48) / v108));
  if (!*(_QWORD *)a3)
  {
    v114 = *(_QWORD *)(a3 + 16);
    v117 = (float)*(int *)(a1 + 8);
    v118 = *(float *)(v114 + 0x27FFFFFFE0) / v117;
    v119 = 0x7FFFFFFF;
    goto LABEL_168;
  }
  v113 = *(unsigned int *)(a3 + 24);
  v115 = *(_QWORD *)(a3 + 8);
  v114 = *(_QWORD *)(a3 + 16);
  v116 = *(unsigned int *)(v115 + 4 * (0x3CEE781815CE206BLL % v113));
  if ((_DWORD)v116 == 0x7FFFFFFF)
    goto LABEL_158;
  if (*(_BYTE *)(v114 + 80 * v116 + 12) != 62)
  {
    while (1)
    {
      LODWORD(v116) = *(_DWORD *)(v114 + 80 * v116 + 8) & 0x7FFFFFFF;
      if ((_DWORD)v116 == 0x7FFFFFFF)
        break;
      if (*(_BYTE *)(v114 + 80 * v116 + 12) == 62)
        goto LABEL_163;
    }
LABEL_158:
    LODWORD(v116) = 0x7FFFFFFF;
  }
LABEL_163:
  v117 = (float)*(int *)(a1 + 8);
  v118 = *(float *)(v114 + 80 * v116 + 48) / v117;
  v120 = *(unsigned int *)(v115 + 4 * (0xE1BAA47D01408015 % v113));
  v119 = 0x7FFFFFFF;
  if ((_DWORD)v120 != 0x7FFFFFFF)
  {
    if (*(_BYTE *)(v114 + 80 * v120 + 12) == 63)
    {
LABEL_167:
      v119 = v120;
    }
    else
    {
      while (1)
      {
        LODWORD(v120) = *(_DWORD *)(v114 + 80 * v120 + 8) & 0x7FFFFFFF;
        v119 = 0x7FFFFFFF;
        if ((_DWORD)v120 == 0x7FFFFFFF)
          break;
        if (*(_BYTE *)(v114 + 80 * v120 + 12) == 63)
          goto LABEL_167;
      }
    }
  }
LABEL_168:
  v121 = v118;
  if ((v136 & 1) != 0)
    v122 = v138;
  else
    v122 = v137;
  re::DynamicString::appendf((re::DynamicString *)v11, "Mesh Info: %.0f mesh(es) @ %s\n", v121, v122);
  if (*(_QWORD *)&info && (v136 & 1) != 0)
    (*(void (**)(void))(**(_QWORD **)&info + 40))();
  if (!*(_QWORD *)a3)
  {
    v124 = *(_QWORD *)(a3 + 16);
    v127 = *(float *)(v124 + 0x27FFFFFFE0);
    v128 = *(_DWORD *)(a1 + 8);
    v129 = 0x7FFFFFFF;
    goto LABEL_186;
  }
  v123 = *(unsigned int *)(a3 + 24);
  v125 = *(_QWORD *)(a3 + 8);
  v124 = *(_QWORD *)(a3 + 16);
  v126 = *(unsigned int *)(v125 + 4 * (0x8AA449CE2D0CA1D3 % v123));
  if ((_DWORD)v126 == 0x7FFFFFFF)
    goto LABEL_176;
  if (*(_BYTE *)(v124 + 80 * v126 + 12) != 64)
  {
    while (1)
    {
      LODWORD(v126) = *(_DWORD *)(v124 + 80 * v126 + 8) & 0x7FFFFFFF;
      if ((_DWORD)v126 == 0x7FFFFFFF)
        break;
      if (*(_BYTE *)(v124 + 80 * v126 + 12) == 64)
        goto LABEL_181;
    }
LABEL_176:
    LODWORD(v126) = 0x7FFFFFFF;
  }
LABEL_181:
  v127 = *(float *)(v124 + 80 * v126 + 48);
  v128 = *(_DWORD *)(a1 + 8);
  v130 = *(unsigned int *)(v125 + 4 * (0x6B18769D9C324EABLL % v123));
  v129 = 0x7FFFFFFF;
  if ((_DWORD)v130 != 0x7FFFFFFF)
  {
    if (*(_BYTE *)(v124 + 80 * v130 + 12) == 65)
    {
LABEL_185:
      v129 = v130;
    }
    else
    {
      while (1)
      {
        LODWORD(v130) = *(_DWORD *)(v124 + 80 * v130 + 8) & 0x7FFFFFFF;
        v129 = 0x7FFFFFFF;
        if ((_DWORD)v130 == 0x7FFFFFFF)
          break;
        if (*(_BYTE *)(v124 + 80 * v130 + 12) == 65)
          goto LABEL_185;
      }
    }
  }
LABEL_186:
  v131 = (float)(v127 / (float)v128);
  if ((v136 & 1) != 0)
    v132 = v138;
  else
    v132 = v137;
  re::DynamicString::appendf((re::DynamicString *)v11, "Texture Info: %.0f texture(s) @ %s\n", v131, v132);
  if (*(_QWORD *)&info && (v136 & 1) != 0)
    (*(void (**)(void))(**(_QWORD **)&info + 40))();
  v133 = v8 + (v9 << 6);
  *(_QWORD *)&result = 0x3C0000000BLL;
  *(_QWORD *)(v133 + 48) = 0x3C0000000BLL;
  *(_DWORD *)(v133 + 56) = 4;
  return result;
}

uint64_t `anonymous namespace'::getFormattedBytes(_anonymous_namespace_ *this, float a2)
{
  uint64_t v2;
  float v3;
  double v4;
  const char *v5;

  v2 = 0;
  while (1)
  {
    v3 = a2 * 0.00097656;
    if ((float)(a2 * 0.00097656) < 1.0)
      break;
    ++v2;
    a2 = a2 * 0.00097656;
    if (v2 == 5)
    {
      v4 = v3;
      v5 = "TB";
      return re::DynamicString::format((re::DynamicString *)"%.2f %s", this, *(_QWORD *)&v4, v5);
    }
  }
  v4 = a2;
  v5 = off_24ED7F718[v2];
  return re::DynamicString::format((re::DynamicString *)"%.2f %s", this, *(_QWORD *)&v4, v5);
}

uint64_t re::FrameAudioStats::dumpStatisticsInternal(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  _BYTE *v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  float v17;
  int v18;
  double v19;
  unint64_t v20;
  unint64_t v21;
  double v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  float v26;
  int v27;
  double v28;
  unint64_t v29;
  unint64_t v30;
  double v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  float v36;
  float v37;
  float v38;
  unsigned int v39;
  uint64_t v40;
  unsigned int v41;
  unsigned int v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  float v48;
  float v49;
  unsigned int v50;
  uint64_t v51;
  uint64_t v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  float v57;
  float v58;
  unsigned int v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unsigned int v63;
  uint64_t v64;
  uint64_t v65;
  unsigned int v66;
  uint64_t result;
  mach_timebase_info info;

  LODWORD(v5) = 0x7FFFFFFF;
  if (*(_QWORD *)a2)
  {
    v6 = **(unsigned int **)(a2 + 8);
    if ((_DWORD)v6 != 0x7FFFFFFF)
    {
      v7 = *(_QWORD *)(a2 + 16);
      if (*(_DWORD *)(v7 + (v6 << 6) + 12))
      {
        v5 = **(unsigned int **)(a2 + 8);
        while (1)
        {
          v5 = *(_DWORD *)(v7 + (v5 << 6) + 8) & 0x7FFFFFFF;
          if ((_DWORD)v5 == 0x7FFFFFFF)
            break;
          if (!*(_DWORD *)(v7 + (v5 << 6) + 12))
            goto LABEL_10;
        }
        LODWORD(v5) = 0x7FFFFFFF;
      }
      else
      {
        LODWORD(v5) = **(_DWORD **)(a2 + 8);
      }
    }
  }
LABEL_10:
  v8 = *(_QWORD *)(a2 + 16);
  v9 = v5;
  v10 = v8 + ((unint64_t)v5 << 6);
  v11 = (_QWORD *)(v10 + 16);
  v12 = *(_QWORD *)(v10 + 24);
  if ((v12 & 1) != 0)
  {
    v11[1] = 1;
    v13 = (_BYTE *)v11[2];
  }
  else
  {
    *((_BYTE *)v11 + 8) = v12 & 1;
    v13 = (char *)v11 + 9;
  }
  *v13 = 0;
  re::DynamicString::appendf((re::DynamicString *)v11, "Audio Stats\n");
  v14 = 0x7FFFFFFF;
  if (*(_QWORD *)a3)
  {
    v15 = *(_DWORD *)(*(_QWORD *)(a3 + 8) + 4 * (0x178631649EA56D8AuLL % *(unsigned int *)(a3 + 24)));
    if (v15 != 0x7FFFFFFF)
    {
      v16 = *(_QWORD *)(a3 + 16);
      v14 = *(_DWORD *)(*(_QWORD *)(a3 + 8) + 4 * (0x178631649EA56D8AuLL % *(unsigned int *)(a3 + 24)));
      if (*(_BYTE *)(v16 + 80 * v15 + 12) != 120)
      {
        while (1)
        {
          v14 = *(_DWORD *)(v16
                          + 80
                          * *(unsigned int *)(*(_QWORD *)(a3 + 8)
                                            + 4 * (0x178631649EA56D8AuLL % *(unsigned int *)(a3 + 24)))
                          + 8) & 0x7FFFFFFF;
          if (v14 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v16 + 80 * v14 + 12) == 120)
            goto LABEL_20;
        }
        v14 = 0x7FFFFFFF;
      }
    }
  }
LABEL_20:
  v17 = *(float *)(*(_QWORD *)(a3 + 16) + 80 * v14 + 48);
  v18 = *(_DWORD *)(a1 + 8);
  v19 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v22 = NAN;
      goto LABEL_25;
    }
    LODWORD(v20) = info.numer;
    LODWORD(v21) = info.denom;
    v19 = (double)v20 / (double)v21;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v19;
  }
  v22 = v19 * (double)(unint64_t)(float)(v17 / (float)v18);
LABEL_25:
  re::DynamicString::appendf((re::DynamicString *)v11, "Audio ECS Work (ms) : %.2f\n", v22 / 1000000.0);
  if (*(_QWORD *)a3)
  {
    v23 = *(_QWORD *)(a3 + 16);
    v24 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0xFD95FA4DB404DD7BLL % *(unsigned int *)(a3 + 24)));
    v25 = 0x7FFFFFFF;
    if ((_DWORD)v24 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v23 + 80 * v24 + 12) == 22)
      {
LABEL_30:
        v25 = v24;
      }
      else
      {
        while (1)
        {
          LODWORD(v24) = *(_DWORD *)(v23 + 80 * v24 + 8) & 0x7FFFFFFF;
          v25 = 0x7FFFFFFF;
          if ((_DWORD)v24 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v23 + 80 * v24 + 12) == 22)
            goto LABEL_30;
        }
      }
    }
  }
  else
  {
    v23 = *(_QWORD *)(a3 + 16);
    v25 = 0x7FFFFFFF;
  }
  v26 = *(float *)(v23 + 80 * v25 + 48);
  v27 = *(_DWORD *)(a1 + 8);
  v28 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v31 = NAN;
      goto LABEL_37;
    }
    LODWORD(v29) = info.numer;
    LODWORD(v30) = info.denom;
    v28 = (double)v29 / (double)v30;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v28;
  }
  v31 = v28 * (double)(unint64_t)(float)(v26 / (float)v27);
LABEL_37:
  re::DynamicString::appendf((re::DynamicString *)v11, "Audio Pre/Post Frame Update (ms) : %.2f\n", v31 / 1000000.0);
  if (!*(_QWORD *)a3)
  {
    v33 = *(_QWORD *)(a3 + 16);
    v36 = *(float *)(v33 + 0x27FFFFFFE0);
    v37 = (float)*(int *)(a1 + 8);
    v38 = v36 / v37;
    v39 = 0x7FFFFFFF;
    goto LABEL_57;
  }
  v32 = *(unsigned int *)(a3 + 24);
  v34 = *(_QWORD *)(a3 + 8);
  v33 = *(_QWORD *)(a3 + 16);
  v35 = *(unsigned int *)(v34 + 4 * (0x2427CEE8D2E4A800 % v32));
  if ((_DWORD)v35 == 0x7FFFFFFF)
  {
    LODWORD(v35) = 0x7FFFFFFF;
  }
  else if (*(unsigned __int8 *)(v33 + 80 * v35 + 12) != 143)
  {
    do
      LODWORD(v35) = *(_DWORD *)(v33 + 80 * v35 + 8) & 0x7FFFFFFF;
    while ((_DWORD)v35 != 0x7FFFFFFF && *(unsigned __int8 *)(v33 + 80 * v35 + 12) != 143);
    v40 = v33 + 80 * v35;
    goto LABEL_46;
  }
  v40 = v33 + 80 * v35;
LABEL_46:
  v37 = (float)*(int *)(a1 + 8);
  v38 = *(float *)(v40 + 48) / v37;
  v41 = *(_DWORD *)(v34 + 4 * (0xA46F85AC5FAF045DLL % v32));
  v39 = 0x7FFFFFFF;
  v42 = 0x7FFFFFFF;
  if (v41 != 0x7FFFFFFF)
  {
    v42 = *(_DWORD *)(v34 + 4 * (0xA46F85AC5FAF045DLL % v32));
    if (*(unsigned __int8 *)(v33 + 80 * v41 + 12) != 140)
    {
      while (1)
      {
        v42 = *(_DWORD *)(v33 + 80 * *(unsigned int *)(v34 + 4 * (0xA46F85AC5FAF045DLL % v32)) + 8) & 0x7FFFFFFF;
        if (v42 == 0x7FFFFFFF)
          break;
        if (*(unsigned __int8 *)(v33 + 80 * v42 + 12) == 140)
          goto LABEL_52;
      }
      v42 = 0x7FFFFFFF;
    }
  }
LABEL_52:
  v36 = *(float *)(v33 + 80 * v42 + 48);
  v43 = *(unsigned int *)(v34 + 4 * (0xFB7C0C284AF128D0 % v32));
  if ((_DWORD)v43 != 0x7FFFFFFF)
  {
    if (*(unsigned __int8 *)(v33 + 80 * v43 + 12) == 147)
    {
LABEL_56:
      v39 = v43;
    }
    else
    {
      while (1)
      {
        LODWORD(v43) = *(_DWORD *)(v33 + 80 * v43 + 8) & 0x7FFFFFFF;
        v39 = 0x7FFFFFFF;
        if ((_DWORD)v43 == 0x7FFFFFFF)
          break;
        if (*(unsigned __int8 *)(v33 + 80 * v43 + 12) == 147)
          goto LABEL_56;
      }
    }
  }
LABEL_57:
  re::DynamicString::appendf((re::DynamicString *)v11, "Players : %.0f, Listeners: %.0f, Timebases: %.0f\n", v38, (float)(v36 / v37), (float)(*(float *)(v33 + 80 * v39 + 48) / v37));
  if (!*(_QWORD *)a3)
  {
    v45 = *(_QWORD *)(a3 + 16);
    v48 = (float)*(int *)(a1 + 8);
    v49 = *(float *)(v45 + 0x27FFFFFFE0) / v48;
    v50 = 0x7FFFFFFF;
    goto LABEL_71;
  }
  v44 = *(unsigned int *)(a3 + 24);
  v46 = *(_QWORD *)(a3 + 8);
  v45 = *(_QWORD *)(a3 + 16);
  v47 = *(unsigned int *)(v46 + 4 * (0xD8013BA0973C70B4 % v44));
  if ((_DWORD)v47 == 0x7FFFFFFF)
  {
    LODWORD(v47) = 0x7FFFFFFF;
LABEL_62:
    v51 = v45 + 80 * v47;
    goto LABEL_66;
  }
  if (*(unsigned __int8 *)(v45 + 80 * v47 + 12) == 145)
    goto LABEL_62;
  do
    LODWORD(v47) = *(_DWORD *)(v45 + 80 * v47 + 8) & 0x7FFFFFFF;
  while ((_DWORD)v47 != 0x7FFFFFFF && *(unsigned __int8 *)(v45 + 80 * v47 + 12) != 145);
  v51 = v45 + 80 * v47;
LABEL_66:
  v48 = (float)*(int *)(a1 + 8);
  v49 = *(float *)(v51 + 48) / v48;
  v52 = *(unsigned int *)(v46 + 4 * (0xC1726A6640A7C667 % v44));
  v50 = 0x7FFFFFFF;
  if ((_DWORD)v52 != 0x7FFFFFFF)
  {
    if (*(unsigned __int8 *)(v45 + 80 * v52 + 12) == 141)
    {
LABEL_70:
      v50 = v52;
    }
    else
    {
      while (1)
      {
        LODWORD(v52) = *(_DWORD *)(v45 + 80 * v52 + 8) & 0x7FFFFFFF;
        v50 = 0x7FFFFFFF;
        if ((_DWORD)v52 == 0x7FFFFFFF)
          break;
        if (*(unsigned __int8 *)(v45 + 80 * v52 + 12) == 141)
          goto LABEL_70;
      }
    }
  }
LABEL_71:
  re::DynamicString::appendf((re::DynamicString *)v11, "Voices : %.0f, Generators : %.0f\n", v49, (float)(*(float *)(v45 + 80 * v50 + 48) / v48));
  if (!*(_QWORD *)a3)
  {
    v54 = *(_QWORD *)(a3 + 16);
    v57 = (float)*(int *)(a1 + 8);
    v58 = *(float *)(v54 + 0x27FFFFFFE0) / v57;
    v59 = 0x7FFFFFFF;
    goto LABEL_83;
  }
  v53 = *(unsigned int *)(a3 + 24);
  v55 = *(_QWORD *)(a3 + 8);
  v54 = *(_QWORD *)(a3 + 16);
  v56 = *(unsigned int *)(v55 + 4 * (0x97DCC30D0B60AE52 % v53));
  if ((_DWORD)v56 == 0x7FFFFFFF)
    goto LABEL_73;
  if (*(unsigned __int8 *)(v54 + 80 * v56 + 12) != 142)
  {
    while (1)
    {
      LODWORD(v56) = *(_DWORD *)(v54 + 80 * v56 + 8) & 0x7FFFFFFF;
      if ((_DWORD)v56 == 0x7FFFFFFF)
        break;
      if (*(unsigned __int8 *)(v54 + 80 * v56 + 12) == 142)
        goto LABEL_78;
    }
LABEL_73:
    LODWORD(v56) = 0x7FFFFFFF;
  }
LABEL_78:
  v57 = (float)*(int *)(a1 + 8);
  v58 = *(float *)(v54 + 80 * v56 + 48) / v57;
  v60 = *(unsigned int *)(v55 + 4 * (0x4A1AC66DC58909F5 % v53));
  v59 = 0x7FFFFFFF;
  if ((_DWORD)v60 != 0x7FFFFFFF)
  {
    if (*(unsigned __int8 *)(v54 + 80 * v60 + 12) == 146)
    {
LABEL_82:
      v59 = v60;
    }
    else
    {
      while (1)
      {
        LODWORD(v60) = *(_DWORD *)(v54 + 80 * v60 + 8) & 0x7FFFFFFF;
        v59 = 0x7FFFFFFF;
        if ((_DWORD)v60 == 0x7FFFFFFF)
          break;
        if (*(unsigned __int8 *)(v54 + 80 * v60 + 12) == 146)
          goto LABEL_82;
      }
    }
  }
LABEL_83:
  re::DynamicString::appendf((re::DynamicString *)v11, "Animations: %.0f, Acoustic Meshes : %.0f\n", v58, (float)(*(float *)(v54 + 80 * v59 + 48) / v57));
  if (*(_QWORD *)a3)
  {
    v61 = *(_QWORD *)(a3 + 16);
    v62 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x30C19CE02862B3C8uLL % *(unsigned int *)(a3 + 24)));
    v63 = 0x7FFFFFFF;
    if ((_DWORD)v62 != 0x7FFFFFFF)
    {
      if (*(unsigned __int8 *)(v61 + 80 * v62 + 12) == 144)
      {
LABEL_88:
        v63 = v62;
      }
      else
      {
        while (1)
        {
          LODWORD(v62) = *(_DWORD *)(v61 + 80 * v62 + 8) & 0x7FFFFFFF;
          v63 = 0x7FFFFFFF;
          if ((_DWORD)v62 == 0x7FFFFFFF)
            break;
          if (*(unsigned __int8 *)(v61 + 80 * v62 + 12) == 144)
            goto LABEL_88;
        }
      }
    }
  }
  else
  {
    v61 = *(_QWORD *)(a3 + 16);
    v63 = 0x7FFFFFFF;
  }
  re::DynamicString::appendf((re::DynamicString *)v11, "Audio Files: <T.B.D> %.0f\n", (float)(*(float *)(v61 + 80 * v63 + 48) / (float)*(int *)(a1 + 8)));
  if (*(_QWORD *)a3)
  {
    v64 = *(_QWORD *)(a3 + 16);
    v65 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x83D7EAD9103E6A46 % *(unsigned int *)(a3 + 24)));
    v66 = 0x7FFFFFFF;
    if ((_DWORD)v65 != 0x7FFFFFFF)
    {
      if (*(unsigned __int8 *)(v64 + 80 * v65 + 12) == 148)
      {
LABEL_95:
        v66 = v65;
      }
      else
      {
        while (1)
        {
          LODWORD(v65) = *(_DWORD *)(v64 + 80 * v65 + 8) & 0x7FFFFFFF;
          v66 = 0x7FFFFFFF;
          if ((_DWORD)v65 == 0x7FFFFFFF)
            break;
          if (*(unsigned __int8 *)(v64 + 80 * v65 + 12) == 148)
            goto LABEL_95;
        }
      }
    }
  }
  else
  {
    v64 = *(_QWORD *)(a3 + 16);
    v66 = 0x7FFFFFFF;
  }
  result = re::DynamicString::appendf((re::DynamicString *)v11, "AR Spatial Scene Classification %.0f\n", (float)(*(float *)(v64 + 80 * v66 + 48) / (float)*(int *)(a1 + 8)));
  *(_DWORD *)(v8 + (v9 << 6) + 56) = 8;
  return result;
}

uint64_t re::FrameECSStats::dumpStatisticsInternal(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  _BYTE *v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  float v17;
  int v18;
  double v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v24;
  float v25;
  int v26;
  double v27;
  unint64_t v28;
  unint64_t v29;
  double v30;
  uint64_t v31;
  uint64_t v32;
  unsigned int v33;
  float v34;
  int v35;
  double v36;
  unint64_t v37;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unsigned int v41;
  float v42;
  int v43;
  double v44;
  unint64_t v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unsigned int v49;
  float v50;
  int v51;
  double v52;
  unint64_t v53;
  unint64_t v54;
  uint64_t v55;
  uint64_t v56;
  unsigned int v57;
  float v58;
  int v59;
  double v60;
  unint64_t v61;
  unint64_t v62;
  double v63;
  uint64_t v64;
  uint64_t v65;
  unsigned int v66;
  float v67;
  int v68;
  double v69;
  unint64_t v70;
  unint64_t v71;
  double v72;
  uint64_t v73;
  uint64_t v74;
  unsigned int v75;
  float v76;
  int v77;
  double v78;
  unint64_t v79;
  unint64_t v80;
  double v81;
  uint64_t v82;
  uint64_t v83;
  unsigned int v84;
  float v85;
  int v86;
  double v87;
  unint64_t v88;
  unint64_t v89;
  double v90;
  uint64_t v91;
  uint64_t v92;
  unsigned int v93;
  float v94;
  int v95;
  double v96;
  unint64_t v97;
  unint64_t v98;
  double v99;
  uint64_t v100;
  uint64_t v101;
  unsigned int v102;
  float v103;
  int v104;
  double v105;
  unint64_t v106;
  unint64_t v107;
  double v108;
  double v109;
  double v110;
  double v111;
  uint64_t v112;
  uint64_t v113;
  unsigned int v114;
  float v115;
  float v116;
  float v117;
  float v118;
  float v119;
  float v120;
  float v121;
  float v122;
  float v123;
  float v124;
  float v125;
  uint64_t result;
  uint64_t v127;
  double v128;
  double v129;
  float v130;
  double v131;
  float v132;
  double v133;
  float v134;
  mach_timebase_info info;

  LODWORD(v5) = 0x7FFFFFFF;
  if (*(_QWORD *)a2)
  {
    v6 = **(unsigned int **)(a2 + 8);
    if ((_DWORD)v6 != 0x7FFFFFFF)
    {
      v7 = *(_QWORD *)(a2 + 16);
      if (*(_DWORD *)(v7 + (v6 << 6) + 12))
      {
        v5 = **(unsigned int **)(a2 + 8);
        while (1)
        {
          v5 = *(_DWORD *)(v7 + (v5 << 6) + 8) & 0x7FFFFFFF;
          if ((_DWORD)v5 == 0x7FFFFFFF)
            break;
          if (!*(_DWORD *)(v7 + (v5 << 6) + 12))
            goto LABEL_10;
        }
        LODWORD(v5) = 0x7FFFFFFF;
      }
      else
      {
        LODWORD(v5) = **(_DWORD **)(a2 + 8);
      }
    }
  }
LABEL_10:
  v8 = *(_QWORD *)(a2 + 16);
  v9 = v5;
  v10 = v8 + ((unint64_t)v5 << 6);
  v11 = (_QWORD *)(v10 + 16);
  v12 = *(_QWORD *)(v10 + 24);
  if ((v12 & 1) != 0)
  {
    v11[1] = 1;
    v13 = (_BYTE *)v11[2];
  }
  else
  {
    *((_BYTE *)v11 + 8) = v12 & 1;
    v13 = (char *)v11 + 9;
  }
  *v13 = 0;
  v14 = 0x7FFFFFFF;
  if (*(_QWORD *)a3)
  {
    v15 = *(_DWORD *)(*(_QWORD *)(a3 + 8) + 4 * (0xDCFA9555B5F881D1 % *(unsigned int *)(a3 + 24)));
    if (v15 != 0x7FFFFFFF)
    {
      v16 = *(_QWORD *)(a3 + 16);
      v14 = *(_DWORD *)(*(_QWORD *)(a3 + 8) + 4 * (0xDCFA9555B5F881D1 % *(unsigned int *)(a3 + 24)));
      if (*(_BYTE *)(v16 + 80 * v15 + 12) != 13)
      {
        while (1)
        {
          v14 = *(_DWORD *)(v16
                          + 80
                          * *(unsigned int *)(*(_QWORD *)(a3 + 8)
                                            + 4 * (0xDCFA9555B5F881D1 % *(unsigned int *)(a3 + 24)))
                          + 8) & 0x7FFFFFFF;
          if (v14 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v16 + 80 * v14 + 12) == 13)
            goto LABEL_20;
        }
        v14 = 0x7FFFFFFF;
      }
    }
  }
LABEL_20:
  v17 = *(float *)(*(_QWORD *)(a3 + 16) + 80 * v14 + 48);
  v18 = *(_DWORD *)(a1 + 8);
  v19 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v131 = NAN;
      goto LABEL_25;
    }
    LODWORD(v20) = info.numer;
    LODWORD(v21) = info.denom;
    v19 = (double)v20 / (double)v21;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v19;
  }
  v131 = v19 * (double)(unint64_t)(float)(v17 / (float)v18);
LABEL_25:
  if (*(_QWORD *)a3)
  {
    v22 = *(_QWORD *)(a3 + 16);
    v23 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x255C6046F62FBE29uLL % *(unsigned int *)(a3 + 24)));
    v24 = 0x7FFFFFFF;
    if ((_DWORD)v23 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v22 + 80 * v23 + 12) == 14)
      {
LABEL_30:
        v24 = v23;
      }
      else
      {
        while (1)
        {
          LODWORD(v23) = *(_DWORD *)(v22 + 80 * v23 + 8) & 0x7FFFFFFF;
          v24 = 0x7FFFFFFF;
          if ((_DWORD)v23 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v22 + 80 * v23 + 12) == 14)
            goto LABEL_30;
        }
      }
    }
  }
  else
  {
    v22 = *(_QWORD *)(a3 + 16);
    v24 = 0x7FFFFFFF;
  }
  v25 = *(float *)(v22 + 80 * v24 + 48);
  v26 = *(_DWORD *)(a1 + 8);
  v27 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v30 = NAN;
      goto LABEL_37;
    }
    LODWORD(v28) = info.numer;
    LODWORD(v29) = info.denom;
    v27 = (double)v28 / (double)v29;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v27;
  }
  v30 = v27 * (double)(unint64_t)(float)(v25 / (float)v26);
LABEL_37:
  if (*(_QWORD *)a3)
  {
    v31 = *(_QWORD *)(a3 + 16);
    v32 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x392754934EA1539uLL % *(unsigned int *)(a3 + 24)));
    v33 = 0x7FFFFFFF;
    if ((_DWORD)v32 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v31 + 80 * v32 + 12) == 15)
      {
LABEL_42:
        v33 = v32;
      }
      else
      {
        while (1)
        {
          LODWORD(v32) = *(_DWORD *)(v31 + 80 * v32 + 8) & 0x7FFFFFFF;
          v33 = 0x7FFFFFFF;
          if ((_DWORD)v32 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v31 + 80 * v32 + 12) == 15)
            goto LABEL_42;
        }
      }
    }
  }
  else
  {
    v31 = *(_QWORD *)(a3 + 16);
    v33 = 0x7FFFFFFF;
  }
  v34 = *(float *)(v31 + 80 * v33 + 48);
  v35 = *(_DWORD *)(a1 + 8);
  v36 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v133 = NAN;
      goto LABEL_49;
    }
    LODWORD(v37) = info.numer;
    LODWORD(v38) = info.denom;
    v36 = (double)v37 / (double)v38;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v36;
  }
  v133 = v36 * (double)(unint64_t)(float)(v34 / (float)v35);
LABEL_49:
  if (*(_QWORD *)a3)
  {
    v39 = *(_QWORD *)(a3 + 16);
    v40 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0xA09D66D4686AD125 % *(unsigned int *)(a3 + 24)));
    v41 = 0x7FFFFFFF;
    if ((_DWORD)v40 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v39 + 80 * v40 + 12) == 127)
      {
LABEL_54:
        v41 = v40;
      }
      else
      {
        while (1)
        {
          LODWORD(v40) = *(_DWORD *)(v39 + 80 * v40 + 8) & 0x7FFFFFFF;
          v41 = 0x7FFFFFFF;
          if ((_DWORD)v40 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v39 + 80 * v40 + 12) == 127)
            goto LABEL_54;
        }
      }
    }
  }
  else
  {
    v39 = *(_QWORD *)(a3 + 16);
    v41 = 0x7FFFFFFF;
  }
  v42 = *(float *)(v39 + 80 * v41 + 48);
  v43 = *(_DWORD *)(a1 + 8);
  v44 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v129 = NAN;
      goto LABEL_61;
    }
    LODWORD(v45) = info.numer;
    LODWORD(v46) = info.denom;
    v44 = (double)v45 / (double)v46;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v44;
  }
  v129 = v44 * (double)(unint64_t)(float)(v42 / (float)v43);
LABEL_61:
  if (*(_QWORD *)a3)
  {
    v47 = *(_QWORD *)(a3 + 16);
    v48 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x178631649EA56D8AuLL % *(unsigned int *)(a3 + 24)));
    v49 = 0x7FFFFFFF;
    if ((_DWORD)v48 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v47 + 80 * v48 + 12) == 120)
      {
LABEL_66:
        v49 = v48;
      }
      else
      {
        while (1)
        {
          LODWORD(v48) = *(_DWORD *)(v47 + 80 * v48 + 8) & 0x7FFFFFFF;
          v49 = 0x7FFFFFFF;
          if ((_DWORD)v48 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v47 + 80 * v48 + 12) == 120)
            goto LABEL_66;
        }
      }
    }
  }
  else
  {
    v47 = *(_QWORD *)(a3 + 16);
    v49 = 0x7FFFFFFF;
  }
  v50 = *(float *)(v47 + 80 * v49 + 48);
  v51 = *(_DWORD *)(a1 + 8);
  v52 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v128 = NAN;
      goto LABEL_73;
    }
    LODWORD(v53) = info.numer;
    LODWORD(v54) = info.denom;
    v52 = (double)v53 / (double)v54;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v52;
  }
  v128 = v52 * (double)(unint64_t)(float)(v50 / (float)v51);
LABEL_73:
  if (*(_QWORD *)a3)
  {
    v55 = *(_QWORD *)(a3 + 16);
    v56 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x8BC946409C88CB8FLL % *(unsigned int *)(a3 + 24)));
    v57 = 0x7FFFFFFF;
    if ((_DWORD)v56 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v55 + 80 * v56 + 12) == 121)
      {
LABEL_78:
        v57 = v56;
      }
      else
      {
        while (1)
        {
          LODWORD(v56) = *(_DWORD *)(v55 + 80 * v56 + 8) & 0x7FFFFFFF;
          v57 = 0x7FFFFFFF;
          if ((_DWORD)v56 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v55 + 80 * v56 + 12) == 121)
            goto LABEL_78;
        }
      }
    }
  }
  else
  {
    v55 = *(_QWORD *)(a3 + 16);
    v57 = 0x7FFFFFFF;
  }
  v58 = *(float *)(v55 + 80 * v57 + 48);
  v59 = *(_DWORD *)(a1 + 8);
  v60 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v63 = NAN;
      goto LABEL_85;
    }
    LODWORD(v61) = info.numer;
    LODWORD(v62) = info.denom;
    v60 = (double)v61 / (double)v62;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v60;
  }
  v63 = v60 * (double)(unint64_t)(float)(v58 / (float)v59);
LABEL_85:
  if (*(_QWORD *)a3)
  {
    v64 = *(_QWORD *)(a3 + 16);
    v65 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0xD94FA4A9067DC0C4 % *(unsigned int *)(a3 + 24)));
    v66 = 0x7FFFFFFF;
    if ((_DWORD)v65 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v64 + 80 * v65 + 12) == 123)
      {
LABEL_90:
        v66 = v65;
      }
      else
      {
        while (1)
        {
          LODWORD(v65) = *(_DWORD *)(v64 + 80 * v65 + 8) & 0x7FFFFFFF;
          v66 = 0x7FFFFFFF;
          if ((_DWORD)v65 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v64 + 80 * v65 + 12) == 123)
            goto LABEL_90;
        }
      }
    }
  }
  else
  {
    v64 = *(_QWORD *)(a3 + 16);
    v66 = 0x7FFFFFFF;
  }
  v67 = *(float *)(v64 + 80 * v66 + 48);
  v68 = *(_DWORD *)(a1 + 8);
  v69 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v72 = NAN;
      goto LABEL_97;
    }
    LODWORD(v70) = info.numer;
    LODWORD(v71) = info.denom;
    v69 = (double)v70 / (double)v71;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v69;
  }
  v72 = v69 * (double)(unint64_t)(float)(v67 / (float)v68);
LABEL_97:
  if (*(_QWORD *)a3)
  {
    v73 = *(_QWORD *)(a3 + 16);
    v74 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0xEAD39EBF60CC176uLL % *(unsigned int *)(a3 + 24)));
    v75 = 0x7FFFFFFF;
    if ((_DWORD)v74 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v73 + 80 * v74 + 12) == 124)
      {
LABEL_102:
        v75 = v74;
      }
      else
      {
        while (1)
        {
          LODWORD(v74) = *(_DWORD *)(v73 + 80 * v74 + 8) & 0x7FFFFFFF;
          v75 = 0x7FFFFFFF;
          if ((_DWORD)v74 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v73 + 80 * v74 + 12) == 124)
            goto LABEL_102;
        }
      }
    }
  }
  else
  {
    v73 = *(_QWORD *)(a3 + 16);
    v75 = 0x7FFFFFFF;
  }
  v76 = *(float *)(v73 + 80 * v75 + 48);
  v77 = *(_DWORD *)(a1 + 8);
  v78 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v81 = NAN;
      goto LABEL_109;
    }
    LODWORD(v79) = info.numer;
    LODWORD(v80) = info.denom;
    v78 = (double)v79 / (double)v80;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v78;
  }
  v81 = v78 * (double)(unint64_t)(float)(v76 / (float)v77);
LABEL_109:
  if (*(_QWORD *)a3)
  {
    v82 = *(_QWORD *)(a3 + 16);
    v83 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x8AEB093D93E71BBFLL % *(unsigned int *)(a3 + 24)));
    v84 = 0x7FFFFFFF;
    if ((_DWORD)v83 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v82 + 80 * v83 + 12) == 122)
      {
LABEL_114:
        v84 = v83;
      }
      else
      {
        while (1)
        {
          LODWORD(v83) = *(_DWORD *)(v82 + 80 * v83 + 8) & 0x7FFFFFFF;
          v84 = 0x7FFFFFFF;
          if ((_DWORD)v83 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v82 + 80 * v83 + 12) == 122)
            goto LABEL_114;
        }
      }
    }
  }
  else
  {
    v82 = *(_QWORD *)(a3 + 16);
    v84 = 0x7FFFFFFF;
  }
  v85 = *(float *)(v82 + 80 * v84 + 48);
  v86 = *(_DWORD *)(a1 + 8);
  v87 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v90 = NAN;
      goto LABEL_121;
    }
    LODWORD(v88) = info.numer;
    LODWORD(v89) = info.denom;
    v87 = (double)v88 / (double)v89;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v87;
  }
  v90 = v87 * (double)(unint64_t)(float)(v85 / (float)v86);
LABEL_121:
  if (*(_QWORD *)a3)
  {
    v91 = *(_QWORD *)(a3 + 16);
    v92 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x2D2898CE1F8CEF8EuLL % *(unsigned int *)(a3 + 24)));
    v93 = 0x7FFFFFFF;
    if ((_DWORD)v92 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v91 + 80 * v92 + 12) == 125)
      {
LABEL_126:
        v93 = v92;
      }
      else
      {
        while (1)
        {
          LODWORD(v92) = *(_DWORD *)(v91 + 80 * v92 + 8) & 0x7FFFFFFF;
          v93 = 0x7FFFFFFF;
          if ((_DWORD)v92 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v91 + 80 * v92 + 12) == 125)
            goto LABEL_126;
        }
      }
    }
  }
  else
  {
    v91 = *(_QWORD *)(a3 + 16);
    v93 = 0x7FFFFFFF;
  }
  v94 = *(float *)(v91 + 80 * v93 + 48);
  v95 = *(_DWORD *)(a1 + 8);
  v96 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v99 = NAN;
      goto LABEL_133;
    }
    LODWORD(v97) = info.numer;
    LODWORD(v98) = info.denom;
    v96 = (double)v97 / (double)v98;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v96;
  }
  v99 = v96 * (double)(unint64_t)(float)(v94 / (float)v95);
LABEL_133:
  if (*(_QWORD *)a3)
  {
    v100 = *(_QWORD *)(a3 + 16);
    v101 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x584592B4271786AAuLL % *(unsigned int *)(a3 + 24)));
    v102 = 0x7FFFFFFF;
    if ((_DWORD)v101 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v100 + 80 * v101 + 12) == 126)
      {
LABEL_138:
        v102 = v101;
      }
      else
      {
        while (1)
        {
          LODWORD(v101) = *(_DWORD *)(v100 + 80 * v101 + 8) & 0x7FFFFFFF;
          v102 = 0x7FFFFFFF;
          if ((_DWORD)v101 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v100 + 80 * v101 + 12) == 126)
            goto LABEL_138;
        }
      }
    }
  }
  else
  {
    v100 = *(_QWORD *)(a3 + 16);
    v102 = 0x7FFFFFFF;
  }
  v103 = *(float *)(v100 + 80 * v102 + 48);
  v104 = *(_DWORD *)(a1 + 8);
  v105 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v108 = NAN;
      goto LABEL_145;
    }
    LODWORD(v106) = info.numer;
    LODWORD(v107) = info.denom;
    v105 = (double)v106 / (double)v107;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v105;
  }
  v108 = v105 * (double)(unint64_t)(float)(v103 / (float)v104);
LABEL_145:
  v109 = v30;
  v110 = v133;
  v111 = v129;
  if (*(_QWORD *)a3)
  {
    v112 = *(_QWORD *)(a3 + 16);
    v113 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x17B1332CD96C043DuLL % *(unsigned int *)(a3 + 24)));
    v114 = 0x7FFFFFFF;
    if ((_DWORD)v113 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v112 + 80 * v113 + 12) == 118)
      {
LABEL_150:
        v114 = v113;
      }
      else
      {
        while (1)
        {
          LODWORD(v113) = *(_DWORD *)(v112 + 80 * v113 + 8) & 0x7FFFFFFF;
          v114 = 0x7FFFFFFF;
          if ((_DWORD)v113 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v112 + 80 * v113 + 12) == 118)
            goto LABEL_150;
        }
      }
    }
  }
  else
  {
    v112 = *(_QWORD *)(a3 + 16);
    v114 = 0x7FFFFFFF;
  }
  v115 = v108 / 1000000.0;
  v130 = v115;
  v116 = v99 / 1000000.0;
  v117 = v90 / 1000000.0;
  v118 = v72 / 1000000.0;
  v119 = v81 / 1000000.0 + v118;
  v120 = v63 / 1000000.0;
  v121 = v128 / 1000000.0;
  v122 = v111 / 1000000.0;
  v134 = v122;
  v123 = v110 / 1000000.0;
  v124 = v109 / 1000000.0;
  v125 = v131 / 1000000.0;
  v132 = (float)((float)((float)((float)((float)((float)((float)((float)(v125 + v124) + v123) - v122) - v121) - v120)
                               - v119)
                       - v117)
               - v116)
       - v115;
  re::DynamicString::appendf((re::DynamicString *)v11, "ECS Stats - Total Entities : %.0f\n", (float)(*(float *)(v112 + 80 * v114 + 48) / (float)*(int *)(a1 + 8)));
  re::DynamicString::appendf((re::DynamicString *)v11, "ECS Phases CPU Frame Times (ms)\n");
  re::DynamicString::appendf((re::DynamicString *)v11, "Prepare: %.2f\n", v125);
  re::DynamicString::appendf((re::DynamicString *)v11, "Simulate: %.2f   Commit: %.2f\n", v124, v123);
  re::DynamicString::appendf((re::DynamicString *)v11, "ECS Frame Times per Module (ms)\n");
  re::DynamicString::appendf((re::DynamicString *)v11, "Rendering : %.2f    Physics : %.2f\n", v117, v120);
  re::DynamicString::appendf((re::DynamicString *)v11, "Network : %.2f    Animation : %.2f\n", v119, v116);
  re::DynamicString::appendf((re::DynamicString *)v11, "Audio : %.2f    Custom Systems : %.2f\n", v121, v130);
  result = re::DynamicString::appendf((re::DynamicString *)v11, "User Callback : %.2f    Others : %.2f\n", v134, v132);
  v127 = v8 + (v9 << 6);
  *(_DWORD *)(v127 + 48) = 10;
  *(_DWORD *)(v127 + 56) = 16;
  return result;
}

uint64_t re::FrameMeshStats::dumpStatisticsInternal(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  _BYTE *v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  float v18;
  double v19;
  unsigned int v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int v27;
  uint64_t result;

  LODWORD(v5) = 0x7FFFFFFF;
  if (*(_QWORD *)a2)
  {
    v6 = **(unsigned int **)(a2 + 8);
    if ((_DWORD)v6 != 0x7FFFFFFF)
    {
      v7 = *(_QWORD *)(a2 + 16);
      if (*(_DWORD *)(v7 + (v6 << 6) + 12))
      {
        v5 = **(unsigned int **)(a2 + 8);
        while (1)
        {
          v5 = *(_DWORD *)(v7 + (v5 << 6) + 8) & 0x7FFFFFFF;
          if ((_DWORD)v5 == 0x7FFFFFFF)
            break;
          if (!*(_DWORD *)(v7 + (v5 << 6) + 12))
            goto LABEL_10;
        }
        LODWORD(v5) = 0x7FFFFFFF;
      }
      else
      {
        LODWORD(v5) = **(_DWORD **)(a2 + 8);
      }
    }
  }
LABEL_10:
  v8 = *(_QWORD *)(a2 + 16);
  v9 = v5;
  v10 = v8 + ((unint64_t)v5 << 6);
  v11 = (_QWORD *)(v10 + 16);
  v12 = *(_QWORD *)(v10 + 24);
  if ((v12 & 1) != 0)
  {
    v11[1] = 1;
    v13 = (_BYTE *)v11[2];
  }
  else
  {
    *((_BYTE *)v11 + 8) = v12 & 1;
    v13 = (char *)v11 + 9;
  }
  *v13 = 0;
  re::DynamicString::appendf((re::DynamicString *)v11, "Scene Mesh Stats\n");
  v14 = 0x7FFFFFFF;
  if (*(_QWORD *)a3)
  {
    v15 = *(_DWORD *)(*(_QWORD *)(a3 + 8) + 4 * (0xC67949C3A864283CLL % *(unsigned int *)(a3 + 24)));
    if (v15 != 0x7FFFFFFF)
    {
      v16 = *(_QWORD *)(a3 + 16);
      v14 = *(_DWORD *)(*(_QWORD *)(a3 + 8) + 4 * (0xC67949C3A864283CLL % *(unsigned int *)(a3 + 24)));
      if (*(_BYTE *)(v16 + 80 * v15 + 12) != 34)
      {
        while (1)
        {
          v14 = *(_DWORD *)(v16
                          + 80
                          * *(unsigned int *)(*(_QWORD *)(a3 + 8)
                                            + 4 * (0xC67949C3A864283CLL % *(unsigned int *)(a3 + 24)))
                          + 8) & 0x7FFFFFFF;
          if (v14 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v16 + 80 * v14 + 12) == 34)
            goto LABEL_20;
        }
        v14 = 0x7FFFFFFF;
      }
    }
  }
LABEL_20:
  v17 = *(_QWORD *)(a3 + 16);
  v18 = (float)*(int *)(a1 + 8);
  v19 = (float)(*(float *)(v17 + 80 * v14 + 48) / v18);
  v20 = 0x7FFFFFFF;
  if (*(_QWORD *)a3)
  {
    v21 = *(_DWORD *)(*(_QWORD *)(a3 + 8) + 4 * (0x43E7CEFC06C022BEuLL % *(unsigned int *)(a3 + 24)));
    if (v21 != 0x7FFFFFFF)
    {
      v20 = *(_DWORD *)(*(_QWORD *)(a3 + 8) + 4 * (0x43E7CEFC06C022BEuLL % *(unsigned int *)(a3 + 24)));
      if (*(_BYTE *)(v17 + 80 * v21 + 12) != 35)
      {
        while (1)
        {
          v20 = *(_DWORD *)(v17
                          + 80
                          * *(unsigned int *)(*(_QWORD *)(a3 + 8)
                                            + 4 * (0x43E7CEFC06C022BEuLL % *(unsigned int *)(a3 + 24)))
                          + 8) & 0x7FFFFFFF;
          if (v20 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v17 + 80 * v20 + 12) == 35)
            goto LABEL_27;
        }
        v20 = 0x7FFFFFFF;
      }
    }
  }
LABEL_27:
  re::DynamicString::appendf((re::DynamicString *)v11, "Meshes : %.0f    Draw Calls : %.0f\n", v19, (float)(*(float *)(v17 + 80 * v20 + 48) / v18));
  if (*(_QWORD *)a3)
  {
    v22 = *(_QWORD *)(a3 + 16);
    v23 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0xFF96B931ED5510E2 % *(unsigned int *)(a3 + 24)));
    v24 = 0x7FFFFFFF;
    if ((_DWORD)v23 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v22 + 80 * v23 + 12) == 36)
      {
LABEL_32:
        v24 = v23;
      }
      else
      {
        while (1)
        {
          LODWORD(v23) = *(_DWORD *)(v22 + 80 * v23 + 8) & 0x7FFFFFFF;
          v24 = 0x7FFFFFFF;
          if ((_DWORD)v23 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v22 + 80 * v23 + 12) == 36)
            goto LABEL_32;
        }
      }
    }
  }
  else
  {
    v22 = *(_QWORD *)(a3 + 16);
    v24 = 0x7FFFFFFF;
  }
  re::DynamicString::appendf((re::DynamicString *)v11, "Triangles Submitted: %.0f\n", (float)(*(float *)(v22 + 80 * v24 + 48) / (float)*(int *)(a1 + 8)));
  if (*(_QWORD *)a3)
  {
    v25 = *(_QWORD *)(a3 + 16);
    v26 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x499EF488EF760E18uLL % *(unsigned int *)(a3 + 24)));
    v27 = 0x7FFFFFFF;
    if ((_DWORD)v26 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v25 + 80 * v26 + 12) == 37)
      {
LABEL_39:
        v27 = v26;
      }
      else
      {
        while (1)
        {
          LODWORD(v26) = *(_DWORD *)(v25 + 80 * v26 + 8) & 0x7FFFFFFF;
          v27 = 0x7FFFFFFF;
          if ((_DWORD)v26 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v25 + 80 * v26 + 12) == 37)
            goto LABEL_39;
        }
      }
    }
  }
  else
  {
    v25 = *(_QWORD *)(a3 + 16);
    v27 = 0x7FFFFFFF;
  }
  result = re::DynamicString::appendf((re::DynamicString *)v11, "Vertices Submitted: %.0f\n", (float)(*(float *)(v25 + 80 * v27 + 48) / (float)*(int *)(a1 + 8)));
  *(_DWORD *)(v8 + (v9 << 6) + 56) = 32;
  return result;
}

double re::FrameNetworkStats::dumpStatisticsInternal(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  _BYTE *v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  float v20;
  int v21;
  double v22;
  unint64_t v23;
  unint64_t v24;
  double v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int v28;
  float v29;
  int v30;
  double v31;
  double v32;
  unint64_t v33;
  unint64_t v34;
  double v35;
  uint64_t v36;
  uint64_t v37;
  unsigned int v38;
  float v39;
  int v40;
  double v41;
  unint64_t v42;
  unint64_t v43;
  double v44;
  uint64_t v45;
  uint64_t v46;
  unsigned int v47;
  float v48;
  int v49;
  double v50;
  double v51;
  unint64_t v52;
  unint64_t v53;
  double v54;
  uint64_t v55;
  uint64_t v56;
  unsigned int v57;
  float v58;
  double v59;
  unsigned int v60;
  unsigned int v61;
  unint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  float v66;
  float v67;
  unsigned int v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  float v75;
  float v76;
  unsigned int v77;
  uint64_t v78;
  uint64_t v79;
  unint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  float v84;
  float v85;
  unsigned int v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  unsigned int v91;
  float v92;
  int v93;
  double v94;
  unint64_t v95;
  unint64_t v96;
  double v97;
  double v98;
  uint64_t v99;
  uint64_t v100;
  unsigned int v101;
  uint64_t v102;
  uint64_t v103;
  unsigned int v104;
  float v105;
  int v106;
  double v107;
  unint64_t v108;
  unint64_t v109;
  double v110;
  double v111;
  uint64_t v112;
  uint64_t v113;
  unsigned int v114;
  uint64_t v115;
  uint64_t v116;
  unsigned int v117;
  uint64_t v118;
  double v119;
  unint64_t v120;
  unint64_t v121;
  double v122;
  double v123;
  uint64_t v124;
  uint64_t v125;
  unsigned int v126;
  double v127;
  unint64_t v128;
  unint64_t v129;
  double v130;
  uint64_t v131;
  uint64_t v132;
  unsigned int v133;
  uint64_t v134;
  double result;
  mach_timebase_info info;

  LODWORD(v5) = 0x7FFFFFFF;
  if (*(_QWORD *)a2)
  {
    v6 = **(unsigned int **)(a2 + 8);
    if ((_DWORD)v6 != 0x7FFFFFFF)
    {
      v7 = *(_QWORD *)(a2 + 16);
      if (*(_DWORD *)(v7 + (v6 << 6) + 12))
      {
        v5 = **(unsigned int **)(a2 + 8);
        while (1)
        {
          v5 = *(_DWORD *)(v7 + (v5 << 6) + 8) & 0x7FFFFFFF;
          if ((_DWORD)v5 == 0x7FFFFFFF)
            break;
          if (!*(_DWORD *)(v7 + (v5 << 6) + 12))
            goto LABEL_10;
        }
        LODWORD(v5) = 0x7FFFFFFF;
      }
      else
      {
        LODWORD(v5) = **(_DWORD **)(a2 + 8);
      }
    }
  }
LABEL_10:
  v8 = *(_QWORD *)(a2 + 16);
  v9 = v5;
  v10 = v8 + ((unint64_t)v5 << 6);
  v11 = (_QWORD *)(v10 + 16);
  v12 = *(_QWORD *)(v10 + 24);
  if ((v12 & 1) != 0)
  {
    v11[1] = 1;
    v13 = (_BYTE *)v11[2];
  }
  else
  {
    *((_BYTE *)v11 + 8) = v12 & 1;
    v13 = (char *)v11 + 9;
  }
  *v13 = 0;
  re::DynamicString::append((re::DynamicString *)v11, "Frame Network Stats\n", 0x14uLL);
  v14 = 0x7FFFFFFF;
  if (*(_QWORD *)a3)
  {
    v15 = *(_DWORD *)(*(_QWORD *)(a3 + 8) + 4 * (0xA630657CB8C7F164 % *(unsigned int *)(a3 + 24)));
    if (v15 != 0x7FFFFFFF)
    {
      v16 = *(_QWORD *)(a3 + 16);
      v14 = *(_DWORD *)(*(_QWORD *)(a3 + 8) + 4 * (0xA630657CB8C7F164 % *(unsigned int *)(a3 + 24)));
      if (*(_BYTE *)(v16 + 80 * v15 + 12) != 48)
      {
        while (1)
        {
          v14 = *(_DWORD *)(v16
                          + 80
                          * *(unsigned int *)(*(_QWORD *)(a3 + 8)
                                            + 4 * (0xA630657CB8C7F164 % *(unsigned int *)(a3 + 24)))
                          + 8) & 0x7FFFFFFF;
          if (v14 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v16 + 80 * v14 + 12) == 48)
            goto LABEL_20;
        }
        v14 = 0x7FFFFFFF;
      }
    }
  }
LABEL_20:
  re::DynamicString::appendf((re::DynamicString *)v11, "Network Components : %.0f\n", (float)(*(float *)(*(_QWORD *)(a3 + 16) + 80 * v14 + 48) / (float)*(int *)(a1 + 8)));
  if (*(_QWORD *)a3)
  {
    v17 = *(_QWORD *)(a3 + 16);
    v18 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0xD9844BCECCA4A8BDLL % *(unsigned int *)(a3 + 24)));
    v19 = 0x7FFFFFFF;
    if ((_DWORD)v18 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v17 + 80 * v18 + 12) == 16)
      {
LABEL_25:
        v19 = v18;
      }
      else
      {
        while (1)
        {
          LODWORD(v18) = *(_DWORD *)(v17 + 80 * v18 + 8) & 0x7FFFFFFF;
          v19 = 0x7FFFFFFF;
          if ((_DWORD)v18 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v17 + 80 * v18 + 12) == 16)
            goto LABEL_25;
        }
      }
    }
  }
  else
  {
    v17 = *(_QWORD *)(a3 + 16);
    v19 = 0x7FFFFFFF;
  }
  v20 = *(float *)(v17 + 80 * v19 + 48);
  v21 = *(_DWORD *)(a1 + 8);
  v22 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v25 = NAN;
      goto LABEL_32;
    }
    LODWORD(v23) = info.numer;
    LODWORD(v24) = info.denom;
    v22 = (double)v23 / (double)v24;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v22;
  }
  v25 = v22 * (double)(unint64_t)(float)(v20 / (float)v21);
LABEL_32:
  if (*(_QWORD *)a3)
  {
    v26 = *(_QWORD *)(a3 + 16);
    v27 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x302B8631721C51BEuLL % *(unsigned int *)(a3 + 24)));
    v28 = 0x7FFFFFFF;
    if ((_DWORD)v27 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v26 + 80 * v27 + 12) == 17)
      {
LABEL_37:
        v28 = v27;
      }
      else
      {
        while (1)
        {
          LODWORD(v27) = *(_DWORD *)(v26 + 80 * v27 + 8) & 0x7FFFFFFF;
          v28 = 0x7FFFFFFF;
          if ((_DWORD)v27 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v26 + 80 * v27 + 12) == 17)
            goto LABEL_37;
        }
      }
    }
  }
  else
  {
    v26 = *(_QWORD *)(a3 + 16);
    v28 = 0x7FFFFFFF;
  }
  v29 = *(float *)(v26 + 80 * v28 + 48);
  v30 = *(_DWORD *)(a1 + 8);
  v31 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  v32 = v25 / 1000000.0;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v35 = NAN;
      goto LABEL_44;
    }
    LODWORD(v33) = info.numer;
    LODWORD(v34) = info.denom;
    v31 = (double)v33 / (double)v34;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v31;
  }
  v35 = v31 * (double)(unint64_t)(float)(v29 / (float)v30);
LABEL_44:
  re::DynamicString::appendf((re::DynamicString *)v11, "PreFrame (ms): %.2f    PostFrame (ms): %.2f\n", v32, v35 / 1000000.0);
  if (*(_QWORD *)a3)
  {
    v36 = *(_QWORD *)(a3 + 16);
    v37 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0xD94FA4A9067DC0C4 % *(unsigned int *)(a3 + 24)));
    v38 = 0x7FFFFFFF;
    if ((_DWORD)v37 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v36 + 80 * v37 + 12) == 123)
      {
LABEL_49:
        v38 = v37;
      }
      else
      {
        while (1)
        {
          LODWORD(v37) = *(_DWORD *)(v36 + 80 * v37 + 8) & 0x7FFFFFFF;
          v38 = 0x7FFFFFFF;
          if ((_DWORD)v37 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v36 + 80 * v37 + 12) == 123)
            goto LABEL_49;
        }
      }
    }
  }
  else
  {
    v36 = *(_QWORD *)(a3 + 16);
    v38 = 0x7FFFFFFF;
  }
  v39 = *(float *)(v36 + 80 * v38 + 48);
  v40 = *(_DWORD *)(a1 + 8);
  v41 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v44 = NAN;
      goto LABEL_56;
    }
    LODWORD(v42) = info.numer;
    LODWORD(v43) = info.denom;
    v41 = (double)v42 / (double)v43;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v41;
  }
  v44 = v41 * (double)(unint64_t)(float)(v39 / (float)v40);
LABEL_56:
  if (*(_QWORD *)a3)
  {
    v45 = *(_QWORD *)(a3 + 16);
    v46 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0xEAD39EBF60CC176uLL % *(unsigned int *)(a3 + 24)));
    v47 = 0x7FFFFFFF;
    if ((_DWORD)v46 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v45 + 80 * v46 + 12) == 124)
      {
LABEL_61:
        v47 = v46;
      }
      else
      {
        while (1)
        {
          LODWORD(v46) = *(_DWORD *)(v45 + 80 * v46 + 8) & 0x7FFFFFFF;
          v47 = 0x7FFFFFFF;
          if ((_DWORD)v46 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v45 + 80 * v46 + 12) == 124)
            goto LABEL_61;
        }
      }
    }
  }
  else
  {
    v45 = *(_QWORD *)(a3 + 16);
    v47 = 0x7FFFFFFF;
  }
  v48 = *(float *)(v45 + 80 * v47 + 48);
  v49 = *(_DWORD *)(a1 + 8);
  v50 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  v51 = v44 / 1000000.0;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v54 = NAN;
      goto LABEL_68;
    }
    LODWORD(v52) = info.numer;
    LODWORD(v53) = info.denom;
    v50 = (double)v52 / (double)v53;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v50;
  }
  v54 = v50 * (double)(unint64_t)(float)(v48 / (float)v49);
LABEL_68:
  re::DynamicString::appendf((re::DynamicString *)v11, "SendSystem (ms): %.2f    ReceiveSystem (ms): %.2f\n", v51, v54 / 1000000.0);
  re::DynamicString::append((re::DynamicString *)v11, "Network Session Stats\n", 0x16uLL);
  re::DynamicString::append((re::DynamicString *)v11, "Sent/Received\n", 0xEuLL);
  if (*(_QWORD *)a3)
  {
    v55 = *(_QWORD *)(a3 + 16);
    v56 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0xB74FD707F0B39325 % *(unsigned int *)(a3 + 24)));
    v57 = 0x7FFFFFFF;
    if ((_DWORD)v56 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v55 + 80 * v56 + 12) == 40)
      {
LABEL_73:
        v57 = v56;
      }
      else
      {
        while (1)
        {
          LODWORD(v56) = *(_DWORD *)(v55 + 80 * v56 + 8) & 0x7FFFFFFF;
          v57 = 0x7FFFFFFF;
          if ((_DWORD)v56 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v55 + 80 * v56 + 12) == 40)
            goto LABEL_73;
        }
      }
    }
  }
  else
  {
    v55 = *(_QWORD *)(a3 + 16);
    v57 = 0x7FFFFFFF;
  }
  v58 = (float)*(int *)(a1 + 8);
  v59 = (float)(*(float *)(v55 + 80 * v57 + 48) / v58) * 0.0009765625;
  v60 = 0x7FFFFFFF;
  if (*(_QWORD *)a3)
  {
    v61 = *(_DWORD *)(*(_QWORD *)(a3 + 8) + 4 * (0x66D1ECF1BBB89D25uLL % *(unsigned int *)(a3 + 24)));
    if (v61 != 0x7FFFFFFF)
    {
      v60 = *(_DWORD *)(*(_QWORD *)(a3 + 8) + 4 * (0x66D1ECF1BBB89D25uLL % *(unsigned int *)(a3 + 24)));
      if (*(_BYTE *)(v55 + 80 * v61 + 12) != 41)
      {
        while (1)
        {
          v60 = *(_DWORD *)(v55
                          + 80
                          * *(unsigned int *)(*(_QWORD *)(a3 + 8)
                                            + 4 * (0x66D1ECF1BBB89D25uLL % *(unsigned int *)(a3 + 24)))
                          + 8) & 0x7FFFFFFF;
          if (v60 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v55 + 80 * v60 + 12) == 41)
            goto LABEL_82;
        }
        v60 = 0x7FFFFFFF;
      }
    }
  }
LABEL_82:
  re::DynamicString::appendf((re::DynamicString *)v11, "Data [KB]: %.2f/%.2f\n", v59, (float)(*(float *)(v55 + 80 * v60 + 48) / v58) * 0.0009765625);
  if (!*(_QWORD *)a3)
  {
    v63 = *(_QWORD *)(a3 + 16);
    v66 = (float)*(int *)(a1 + 8);
    v67 = *(float *)(v63 + 0x27FFFFFFE0) / v66;
    v68 = 0x7FFFFFFF;
    goto LABEL_96;
  }
  v62 = *(unsigned int *)(a3 + 24);
  v64 = *(_QWORD *)(a3 + 8);
  v63 = *(_QWORD *)(a3 + 16);
  v65 = *(unsigned int *)(v64 + 4 * (0xA759EA27D4727622 % v62));
  if ((_DWORD)v65 == 0x7FFFFFFF)
  {
    LODWORD(v65) = 0x7FFFFFFF;
LABEL_87:
    v69 = v63 + 80 * v65;
    goto LABEL_91;
  }
  if (*(_BYTE *)(v63 + 80 * v65 + 12) == 42)
    goto LABEL_87;
  do
    LODWORD(v65) = *(_DWORD *)(v63 + 80 * v65 + 8) & 0x7FFFFFFF;
  while ((_DWORD)v65 != 0x7FFFFFFF && *(_BYTE *)(v63 + 80 * v65 + 12) != 42);
  v69 = v63 + 80 * v65;
LABEL_91:
  v66 = (float)*(int *)(a1 + 8);
  v67 = *(float *)(v69 + 48) / v66;
  v70 = *(unsigned int *)(v64 + 4 * (0x4F0A61D9C798D8CALL % v62));
  v68 = 0x7FFFFFFF;
  if ((_DWORD)v70 != 0x7FFFFFFF)
  {
    if (*(_BYTE *)(v63 + 80 * v70 + 12) == 43)
    {
LABEL_95:
      v68 = v70;
    }
    else
    {
      while (1)
      {
        LODWORD(v70) = *(_DWORD *)(v63 + 80 * v70 + 8) & 0x7FFFFFFF;
        v68 = 0x7FFFFFFF;
        if ((_DWORD)v70 == 0x7FFFFFFF)
          break;
        if (*(_BYTE *)(v63 + 80 * v70 + 12) == 43)
          goto LABEL_95;
      }
    }
  }
LABEL_96:
  re::DynamicString::appendf((re::DynamicString *)v11, "Packets: %.0f/%.0f\n", v67, (float)(*(float *)(v63 + 80 * v68 + 48) / v66));
  if (!*(_QWORD *)a3)
  {
    v72 = *(_QWORD *)(a3 + 16);
    v75 = (float)*(int *)(a1 + 8);
    v76 = *(float *)(v72 + 0x27FFFFFFE0) / v75;
    v77 = 0x7FFFFFFF;
    goto LABEL_110;
  }
  v71 = *(unsigned int *)(a3 + 24);
  v73 = *(_QWORD *)(a3 + 8);
  v72 = *(_QWORD *)(a3 + 16);
  v74 = *(unsigned int *)(v73 + 4 * (0xFB2BF4996809BAF7 % v71));
  if ((_DWORD)v74 == 0x7FFFFFFF)
  {
    LODWORD(v74) = 0x7FFFFFFF;
LABEL_101:
    v78 = v72 + 80 * v74;
    goto LABEL_105;
  }
  if (*(_BYTE *)(v72 + 80 * v74 + 12) == 44)
    goto LABEL_101;
  do
    LODWORD(v74) = *(_DWORD *)(v72 + 80 * v74 + 8) & 0x7FFFFFFF;
  while ((_DWORD)v74 != 0x7FFFFFFF && *(_BYTE *)(v72 + 80 * v74 + 12) != 44);
  v78 = v72 + 80 * v74;
LABEL_105:
  v75 = (float)*(int *)(a1 + 8);
  v76 = *(float *)(v78 + 48) / v75;
  v79 = *(unsigned int *)(v73 + 4 * (0xBDBFB556329AEE83 % v71));
  v77 = 0x7FFFFFFF;
  if ((_DWORD)v79 != 0x7FFFFFFF)
  {
    if (*(_BYTE *)(v72 + 80 * v79 + 12) == 45)
    {
LABEL_109:
      v77 = v79;
    }
    else
    {
      while (1)
      {
        LODWORD(v79) = *(_DWORD *)(v72 + 80 * v79 + 8) & 0x7FFFFFFF;
        v77 = 0x7FFFFFFF;
        if ((_DWORD)v79 == 0x7FFFFFFF)
          break;
        if (*(_BYTE *)(v72 + 80 * v79 + 12) == 45)
          goto LABEL_109;
      }
    }
  }
LABEL_110:
  re::DynamicString::appendf((re::DynamicString *)v11, "Components: %.0f/%.0f\n", v76, (float)(*(float *)(v72 + 80 * v77 + 48) / v75));
  if (!*(_QWORD *)a3)
  {
    v81 = *(_QWORD *)(a3 + 16);
    v84 = (float)*(int *)(a1 + 8);
    v85 = *(float *)(v81 + 0x27FFFFFFE0) / v84;
    v86 = 0x7FFFFFFF;
    goto LABEL_124;
  }
  v80 = *(unsigned int *)(a3 + 24);
  v82 = *(_QWORD *)(a3 + 8);
  v81 = *(_QWORD *)(a3 + 16);
  v83 = *(unsigned int *)(v82 + 4 * (0x6F14AEC17CB2794BLL % v80));
  if ((_DWORD)v83 == 0x7FFFFFFF)
  {
    LODWORD(v83) = 0x7FFFFFFF;
LABEL_115:
    v87 = v81 + 80 * v83;
    goto LABEL_119;
  }
  if (*(_BYTE *)(v81 + 80 * v83 + 12) == 46)
    goto LABEL_115;
  do
    LODWORD(v83) = *(_DWORD *)(v81 + 80 * v83 + 8) & 0x7FFFFFFF;
  while ((_DWORD)v83 != 0x7FFFFFFF && *(_BYTE *)(v81 + 80 * v83 + 12) != 46);
  v87 = v81 + 80 * v83;
LABEL_119:
  v84 = (float)*(int *)(a1 + 8);
  v85 = *(float *)(v87 + 48) / v84;
  v88 = *(unsigned int *)(v82 + 4 * (0x5A9FF51BA33ADC1CLL % v80));
  v86 = 0x7FFFFFFF;
  if ((_DWORD)v88 != 0x7FFFFFFF)
  {
    if (*(_BYTE *)(v81 + 80 * v88 + 12) == 47)
    {
LABEL_123:
      v86 = v88;
    }
    else
    {
      while (1)
      {
        LODWORD(v88) = *(_DWORD *)(v81 + 80 * v88 + 8) & 0x7FFFFFFF;
        v86 = 0x7FFFFFFF;
        if ((_DWORD)v88 == 0x7FFFFFFF)
          break;
        if (*(_BYTE *)(v81 + 80 * v88 + 12) == 47)
          goto LABEL_123;
      }
    }
  }
LABEL_124:
  re::DynamicString::appendf((re::DynamicString *)v11, "Entities: %.0f/%.0f\n", v85, (float)(*(float *)(v81 + 80 * v86 + 48) / v84));
  if (*(_QWORD *)a3)
  {
    v89 = *(_QWORD *)(a3 + 16);
    v90 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x5B64875D6615936EuLL % *(unsigned int *)(a3 + 24)));
    v91 = 0x7FFFFFFF;
    if ((_DWORD)v90 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v89 + 80 * v90 + 12) == 38)
      {
LABEL_129:
        v91 = v90;
      }
      else
      {
        while (1)
        {
          LODWORD(v90) = *(_DWORD *)(v89 + 80 * v90 + 8) & 0x7FFFFFFF;
          v91 = 0x7FFFFFFF;
          if ((_DWORD)v90 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v89 + 80 * v90 + 12) == 38)
            goto LABEL_129;
        }
      }
    }
  }
  else
  {
    v89 = *(_QWORD *)(a3 + 16);
    v91 = 0x7FFFFFFF;
  }
  v92 = *(float *)(v89 + 80 * v91 + 48);
  v93 = *(_DWORD *)(a1 + 8);
  v94 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v97 = NAN;
      goto LABEL_136;
    }
    LODWORD(v95) = info.numer;
    LODWORD(v96) = info.denom;
    v94 = (double)v95 / (double)v96;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v94;
  }
  v97 = v94 * (double)(unint64_t)(float)(v92 / (float)v93);
LABEL_136:
  v98 = v97 / 1000000.0;
  if (*(_QWORD *)a3)
  {
    v99 = *(_QWORD *)(a3 + 16);
    v100 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x271C93C147C4CD83uLL % *(unsigned int *)(a3 + 24)));
    v101 = 0x7FFFFFFF;
    if ((_DWORD)v100 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v99 + 80 * v100 + 12) == 39)
      {
LABEL_141:
        v101 = v100;
      }
      else
      {
        while (1)
        {
          LODWORD(v100) = *(_DWORD *)(v99 + 80 * v100 + 8) & 0x7FFFFFFF;
          v101 = 0x7FFFFFFF;
          if ((_DWORD)v100 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v99 + 80 * v100 + 12) == 39)
            goto LABEL_141;
        }
      }
    }
  }
  else
  {
    v99 = *(_QWORD *)(a3 + 16);
    v101 = 0x7FFFFFFF;
  }
  re::DynamicString::appendf((re::DynamicString *)v11, "RTT [ms]: %.2f    PacketLoss: %.2f\n", v98, (float)(*(float *)(v99 + 80 * v101 + 48) / (float)*(int *)(a1 + 8)));
  re::DynamicString::append((re::DynamicString *)v11, "SyncPacket Stats\n", 0x11uLL);
  if (*(_QWORD *)a3)
  {
    v102 = *(_QWORD *)(a3 + 16);
    v103 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x622570C6C262C8DFuLL % *(unsigned int *)(a3 + 24)));
    v104 = 0x7FFFFFFF;
    if ((_DWORD)v103 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v102 + 80 * v103 + 12) == 49)
      {
LABEL_148:
        v104 = v103;
      }
      else
      {
        while (1)
        {
          LODWORD(v103) = *(_DWORD *)(v102 + 80 * v103 + 8) & 0x7FFFFFFF;
          v104 = 0x7FFFFFFF;
          if ((_DWORD)v103 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v102 + 80 * v103 + 12) == 49)
            goto LABEL_148;
        }
      }
    }
  }
  else
  {
    v102 = *(_QWORD *)(a3 + 16);
    v104 = 0x7FFFFFFF;
  }
  v105 = *(float *)(v102 + 80 * v104 + 48);
  v106 = *(_DWORD *)(a1 + 8);
  v107 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v110 = NAN;
      goto LABEL_155;
    }
    LODWORD(v108) = info.numer;
    LODWORD(v109) = info.denom;
    v107 = (double)v108 / (double)v109;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v107;
  }
  v110 = v107 * (double)(unint64_t)(float)(v105 / (float)v106);
LABEL_155:
  v111 = v110 / 1000000.0;
  if (*(_QWORD *)a3)
  {
    v112 = *(_QWORD *)(a3 + 16);
    v113 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0xCB9EBFBDFE40F3F9 % *(unsigned int *)(a3 + 24)));
    v114 = 0x7FFFFFFF;
    if ((_DWORD)v113 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v112 + 80 * v113 + 12) == 51)
      {
LABEL_160:
        v114 = v113;
      }
      else
      {
        while (1)
        {
          LODWORD(v113) = *(_DWORD *)(v112 + 80 * v113 + 8) & 0x7FFFFFFF;
          v114 = 0x7FFFFFFF;
          if ((_DWORD)v113 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v112 + 80 * v113 + 12) == 51)
            goto LABEL_160;
        }
      }
    }
  }
  else
  {
    v112 = *(_QWORD *)(a3 + 16);
    v114 = 0x7FFFFFFF;
  }
  re::DynamicString::appendf((re::DynamicString *)v11, "RTT [ms]: %.2f    Packet Loss [1s]: %.2f\n", v111, (float)(*(float *)(v112 + 80 * v114 + 48) / (float)*(int *)(a1 + 8)));
  if (*(_QWORD *)a3)
  {
    v115 = *(_QWORD *)(a3 + 16);
    v116 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x4930C821C1606730uLL % *(unsigned int *)(a3 + 24)));
    v117 = 0x7FFFFFFF;
    if ((_DWORD)v116 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v115 + 80 * v116 + 12) == 50)
      {
LABEL_167:
        v117 = v116;
      }
      else
      {
        while (1)
        {
          LODWORD(v116) = *(_DWORD *)(v115 + 80 * v116 + 8) & 0x7FFFFFFF;
          v117 = 0x7FFFFFFF;
          if ((_DWORD)v116 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v115 + 80 * v116 + 12) == 50)
            goto LABEL_167;
        }
      }
    }
  }
  else
  {
    v115 = *(_QWORD *)(a3 + 16);
    v117 = 0x7FFFFFFF;
  }
  re::DynamicString::appendf((re::DynamicString *)v11, "Packet Loss [avg]: %.2f\n", (float)(*(float *)(v115 + 80 * v117 + 48) / (float)*(int *)(a1 + 8)));
  v118 = mach_absolute_time();
  v119 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v122 = NAN;
      goto LABEL_174;
    }
    LODWORD(v120) = info.numer;
    LODWORD(v121) = info.denom;
    v119 = (double)v120 / (double)v121;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v119;
  }
  v122 = v119 * (double)v118;
LABEL_174:
  v123 = v122 / 1000000000.0;
  if (*(_QWORD *)a3)
  {
    v124 = *(_QWORD *)(a3 + 16);
    v125 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x6616B7C1A5E48C27uLL % *(unsigned int *)(a3 + 24)));
    v126 = 0x7FFFFFFF;
    if ((_DWORD)v125 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v124 + 80 * v125 + 12) == 52)
      {
LABEL_179:
        v126 = v125;
      }
      else
      {
        while (1)
        {
          LODWORD(v125) = *(_DWORD *)(v124 + 80 * v125 + 8) & 0x7FFFFFFF;
          v126 = 0x7FFFFFFF;
          if ((_DWORD)v125 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v124 + 80 * v125 + 12) == 52)
            goto LABEL_179;
        }
      }
    }
  }
  else
  {
    v124 = *(_QWORD *)(a3 + 16);
    v126 = 0x7FFFFFFF;
  }
  re::DynamicString::appendf((re::DynamicString *)v11, "Hand Tap Latency [ms]: %.2f", (v123 - *(float *)(v124 + 80 * v126 + 36)) * 1000.0);
  v127 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v130 = NAN;
      goto LABEL_186;
    }
    LODWORD(v128) = info.numer;
    LODWORD(v129) = info.denom;
    v127 = (double)v128 / (double)v129;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v127;
  }
  v130 = v127 * (double)v118;
LABEL_186:
  if (*(_QWORD *)a3)
  {
    v131 = *(_QWORD *)(a3 + 16);
    v132 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x632FD669A7AB1BD4uLL % *(unsigned int *)(a3 + 24)));
    v133 = 0x7FFFFFFF;
    if ((_DWORD)v132 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v131 + 80 * v132 + 12) == 53)
      {
LABEL_191:
        v133 = v132;
      }
      else
      {
        while (1)
        {
          LODWORD(v132) = *(_DWORD *)(v131 + 80 * v132 + 8) & 0x7FFFFFFF;
          v133 = 0x7FFFFFFF;
          if ((_DWORD)v132 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v131 + 80 * v132 + 12) == 53)
            goto LABEL_191;
        }
      }
    }
  }
  else
  {
    v131 = *(_QWORD *)(a3 + 16);
    v133 = 0x7FFFFFFF;
  }
  re::DynamicString::appendf((re::DynamicString *)v11, "Direct Gaze Latency [ms]: %.2f", (v130 / 1000000000.0 - *(float *)(v131 + 80 * v133 + 36)) * 1000.0);
  v134 = v8 + (v9 << 6);
  *(_QWORD *)&result = 0x2D00000010;
  *(_QWORD *)(v134 + 48) = 0x2D00000010;
  *(_DWORD *)(v134 + 56) = 64;
  return result;
}

double re::FramePhysicsStats::dumpStatisticsInternal(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  _BYTE *v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  float v17;
  int v18;
  double v19;
  unint64_t v20;
  unint64_t v21;
  double v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  float v26;
  int v27;
  double v28;
  unint64_t v29;
  unint64_t v30;
  double v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  float v36;
  float v37;
  unsigned int v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  float v45;
  float v46;
  unsigned int v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  float v54;
  float v55;
  unsigned int v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  float v63;
  float v64;
  float v65;
  unsigned int v66;
  unsigned int v67;
  unsigned int v68;
  uint64_t v69;
  unint64_t v70;
  uint64_t v71;
  uint64_t v72;
  unsigned int v73;
  unsigned int v74;
  unsigned int v75;
  int v76;
  float v77;
  unsigned int v78;
  float v79;
  uint64_t v80;
  unsigned int v81;
  uint64_t v82;
  uint64_t v83;
  double result;
  mach_timebase_info info;

  LODWORD(v5) = 0x7FFFFFFF;
  if (*(_QWORD *)a2)
  {
    v6 = **(unsigned int **)(a2 + 8);
    if ((_DWORD)v6 != 0x7FFFFFFF)
    {
      v7 = *(_QWORD *)(a2 + 16);
      if (*(_DWORD *)(v7 + (v6 << 6) + 12))
      {
        v5 = **(unsigned int **)(a2 + 8);
        while (1)
        {
          v5 = *(_DWORD *)(v7 + (v5 << 6) + 8) & 0x7FFFFFFF;
          if ((_DWORD)v5 == 0x7FFFFFFF)
            break;
          if (!*(_DWORD *)(v7 + (v5 << 6) + 12))
            goto LABEL_10;
        }
        LODWORD(v5) = 0x7FFFFFFF;
      }
      else
      {
        LODWORD(v5) = **(_DWORD **)(a2 + 8);
      }
    }
  }
LABEL_10:
  v8 = *(_QWORD *)(a2 + 16);
  v9 = v5;
  v10 = v8 + ((unint64_t)v5 << 6);
  v11 = (_QWORD *)(v10 + 16);
  v12 = *(_QWORD *)(v10 + 24);
  if ((v12 & 1) != 0)
  {
    v11[1] = 1;
    v13 = (_BYTE *)v11[2];
  }
  else
  {
    *((_BYTE *)v11 + 8) = v12 & 1;
    v13 = (char *)v11 + 9;
  }
  *v13 = 0;
  re::DynamicString::appendf((re::DynamicString *)v11, "Physics Stats\n");
  v14 = 0x7FFFFFFF;
  if (*(_QWORD *)a3)
  {
    v15 = *(_DWORD *)(*(_QWORD *)(a3 + 8) + 4 * (0xE34A1ED09841F857 % *(unsigned int *)(a3 + 24)));
    if (v15 != 0x7FFFFFFF)
    {
      v16 = *(_QWORD *)(a3 + 16);
      v14 = *(_DWORD *)(*(_QWORD *)(a3 + 8) + 4 * (0xE34A1ED09841F857 % *(unsigned int *)(a3 + 24)));
      if (*(_BYTE *)(v16 + 80 * v15 + 12) != 19)
      {
        while (1)
        {
          v14 = *(_DWORD *)(v16
                          + 80
                          * *(unsigned int *)(*(_QWORD *)(a3 + 8)
                                            + 4 * (0xE34A1ED09841F857 % *(unsigned int *)(a3 + 24)))
                          + 8) & 0x7FFFFFFF;
          if (v14 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v16 + 80 * v14 + 12) == 19)
            goto LABEL_20;
        }
        v14 = 0x7FFFFFFF;
      }
    }
  }
LABEL_20:
  v17 = *(float *)(*(_QWORD *)(a3 + 16) + 80 * v14 + 48);
  v18 = *(_DWORD *)(a1 + 8);
  v19 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v22 = NAN;
      goto LABEL_25;
    }
    LODWORD(v20) = info.numer;
    LODWORD(v21) = info.denom;
    v19 = (double)v20 / (double)v21;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v19;
  }
  v22 = v19 * (double)(unint64_t)(float)(v17 / (float)v18);
LABEL_25:
  re::DynamicString::appendf((re::DynamicString *)v11, "PhysX Update Time (ms) : %.2f\n", v22 / 1000000.0);
  if (*(_QWORD *)a3)
  {
    v23 = *(_QWORD *)(a3 + 16);
    v24 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x8BC946409C88CB8FLL % *(unsigned int *)(a3 + 24)));
    v25 = 0x7FFFFFFF;
    if ((_DWORD)v24 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v23 + 80 * v24 + 12) == 121)
      {
LABEL_30:
        v25 = v24;
      }
      else
      {
        while (1)
        {
          LODWORD(v24) = *(_DWORD *)(v23 + 80 * v24 + 8) & 0x7FFFFFFF;
          v25 = 0x7FFFFFFF;
          if ((_DWORD)v24 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v23 + 80 * v24 + 12) == 121)
            goto LABEL_30;
        }
      }
    }
  }
  else
  {
    v23 = *(_QWORD *)(a3 + 16);
    v25 = 0x7FFFFFFF;
  }
  v26 = *(float *)(v23 + 80 * v25 + 48);
  v27 = *(_DWORD *)(a1 + 8);
  v28 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v31 = NAN;
      goto LABEL_37;
    }
    LODWORD(v29) = info.numer;
    LODWORD(v30) = info.denom;
    v28 = (double)v29 / (double)v30;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v28;
  }
  v31 = v28 * (double)(unint64_t)(float)(v26 / (float)v27);
LABEL_37:
  re::DynamicString::appendf((re::DynamicString *)v11, "Physics ECS Work (ms) : %.2f\n", v31 / 1000000.0);
  if (!*(_QWORD *)a3)
  {
    v33 = *(_QWORD *)(a3 + 16);
    v36 = (float)*(int *)(a1 + 8);
    v37 = *(float *)(v33 + 0x27FFFFFFE0) / v36;
    v38 = 0x7FFFFFFF;
    goto LABEL_51;
  }
  v32 = *(unsigned int *)(a3 + 24);
  v34 = *(_QWORD *)(a3 + 8);
  v33 = *(_QWORD *)(a3 + 16);
  v35 = *(unsigned int *)(v34 + 4 * (0xA46B02245B9F3AF4 % v32));
  if ((_DWORD)v35 == 0x7FFFFFFF)
  {
    LODWORD(v35) = 0x7FFFFFFF;
LABEL_42:
    v39 = v33 + 80 * v35;
    goto LABEL_46;
  }
  if (*(_BYTE *)(v33 + 80 * v35 + 12) == 67)
    goto LABEL_42;
  do
    LODWORD(v35) = *(_DWORD *)(v33 + 80 * v35 + 8) & 0x7FFFFFFF;
  while ((_DWORD)v35 != 0x7FFFFFFF && *(_BYTE *)(v33 + 80 * v35 + 12) != 67);
  v39 = v33 + 80 * v35;
LABEL_46:
  v36 = (float)*(int *)(a1 + 8);
  v37 = *(float *)(v39 + 48) / v36;
  v40 = *(unsigned int *)(v34 + 4 * (0xCF4A7B3C48D45C4FLL % v32));
  v38 = 0x7FFFFFFF;
  if ((_DWORD)v40 != 0x7FFFFFFF)
  {
    if (*(_BYTE *)(v33 + 80 * v40 + 12) == 66)
    {
LABEL_50:
      v38 = v40;
    }
    else
    {
      while (1)
      {
        LODWORD(v40) = *(_DWORD *)(v33 + 80 * v40 + 8) & 0x7FFFFFFF;
        v38 = 0x7FFFFFFF;
        if ((_DWORD)v40 == 0x7FFFFFFF)
          break;
        if (*(_BYTE *)(v33 + 80 * v40 + 12) == 66)
          goto LABEL_50;
      }
    }
  }
LABEL_51:
  re::DynamicString::appendf((re::DynamicString *)v11, "Active Rigid Bodies : %.0f    Rigid Bodies : %.0f\n", v37, (float)(*(float *)(v33 + 80 * v38 + 48) / v36));
  if (!*(_QWORD *)a3)
  {
    v42 = *(_QWORD *)(a3 + 16);
    v45 = (float)*(int *)(a1 + 8);
    v46 = *(float *)(v42 + 0x27FFFFFFE0) / v45;
    v47 = 0x7FFFFFFF;
    goto LABEL_65;
  }
  v41 = *(unsigned int *)(a3 + 24);
  v43 = *(_QWORD *)(a3 + 8);
  v42 = *(_QWORD *)(a3 + 16);
  v44 = *(unsigned int *)(v43 + 4 * (0x21C2DD3F1FDB3325 % v41));
  if ((_DWORD)v44 == 0x7FFFFFFF)
  {
    LODWORD(v44) = 0x7FFFFFFF;
LABEL_56:
    v48 = v42 + 80 * v44;
    goto LABEL_60;
  }
  if (*(_BYTE *)(v42 + 80 * v44 + 12) == 68)
    goto LABEL_56;
  do
    LODWORD(v44) = *(_DWORD *)(v42 + 80 * v44 + 8) & 0x7FFFFFFF;
  while ((_DWORD)v44 != 0x7FFFFFFF && *(_BYTE *)(v42 + 80 * v44 + 12) != 68);
  v48 = v42 + 80 * v44;
LABEL_60:
  v45 = (float)*(int *)(a1 + 8);
  v46 = *(float *)(v48 + 48) / v45;
  v49 = *(unsigned int *)(v43 + 4 * (0x41956A36DBC51080 % v41));
  v47 = 0x7FFFFFFF;
  if ((_DWORD)v49 != 0x7FFFFFFF)
  {
    if (*(_BYTE *)(v42 + 80 * v49 + 12) == 69)
    {
LABEL_64:
      v47 = v49;
    }
    else
    {
      while (1)
      {
        LODWORD(v49) = *(_DWORD *)(v42 + 80 * v49 + 8) & 0x7FFFFFFF;
        v47 = 0x7FFFFFFF;
        if ((_DWORD)v49 == 0x7FFFFFFF)
          break;
        if (*(_BYTE *)(v42 + 80 * v49 + 12) == 69)
          goto LABEL_64;
      }
    }
  }
LABEL_65:
  re::DynamicString::appendf((re::DynamicString *)v11, "Collision Objects : %.0f    Contacts : %.0f\n", v46, (float)(*(float *)(v42 + 80 * v47 + 48) / v45));
  if (!*(_QWORD *)a3)
  {
    v51 = *(_QWORD *)(a3 + 16);
    v54 = (float)*(int *)(a1 + 8);
    v55 = *(float *)(v51 + 0x27FFFFFFE0) / v54;
    v56 = 0x7FFFFFFF;
    goto LABEL_79;
  }
  v50 = *(unsigned int *)(a3 + 24);
  v52 = *(_QWORD *)(a3 + 8);
  v51 = *(_QWORD *)(a3 + 16);
  v53 = *(unsigned int *)(v52 + 4 * (0x4BEE618685B05729 % v50));
  if ((_DWORD)v53 == 0x7FFFFFFF)
  {
    LODWORD(v53) = 0x7FFFFFFF;
LABEL_70:
    v57 = v51 + 80 * v53;
    goto LABEL_74;
  }
  if (*(_BYTE *)(v51 + 80 * v53 + 12) == 71)
    goto LABEL_70;
  do
    LODWORD(v53) = *(_DWORD *)(v51 + 80 * v53 + 8) & 0x7FFFFFFF;
  while ((_DWORD)v53 != 0x7FFFFFFF && *(_BYTE *)(v51 + 80 * v53 + 12) != 71);
  v57 = v51 + 80 * v53;
LABEL_74:
  v54 = (float)*(int *)(a1 + 8);
  v55 = *(float *)(v57 + 48) / v54;
  v58 = *(unsigned int *)(v52 + 4 * (0x87CF9DF80D80457CLL % v50));
  v56 = 0x7FFFFFFF;
  if ((_DWORD)v58 != 0x7FFFFFFF)
  {
    if (*(_BYTE *)(v51 + 80 * v58 + 12) == 70)
    {
LABEL_78:
      v56 = v58;
    }
    else
    {
      while (1)
      {
        LODWORD(v58) = *(_DWORD *)(v51 + 80 * v58 + 8) & 0x7FFFFFFF;
        v56 = 0x7FFFFFFF;
        if ((_DWORD)v58 == 0x7FFFFFFF)
          break;
        if (*(_BYTE *)(v51 + 80 * v58 + 12) == 70)
          goto LABEL_78;
      }
    }
  }
LABEL_79:
  re::DynamicString::appendf((re::DynamicString *)v11, "Force Effects : %.0f    Active Constraints : %.0f\n", v55, (float)(*(float *)(v51 + 80 * v56 + 48) / v54));
  re::DynamicString::appendf((re::DynamicString *)v11, "Physics Shapes\n");
  if (!*(_QWORD *)a3)
  {
    v60 = *(_QWORD *)(a3 + 16);
    v63 = *(float *)(v60 + 0x27FFFFFFE0);
    v64 = (float)*(int *)(a1 + 8);
    v65 = v63 / v64;
    v66 = 0x7FFFFFFF;
    goto LABEL_97;
  }
  v59 = *(unsigned int *)(a3 + 24);
  v61 = *(_QWORD *)(a3 + 8);
  v60 = *(_QWORD *)(a3 + 16);
  v62 = *(unsigned int *)(v61 + 4 * (0x654FAFC0EE6F9A84 % v59));
  if ((_DWORD)v62 == 0x7FFFFFFF)
    goto LABEL_81;
  if (*(_BYTE *)(v60 + 80 * v62 + 12) != 72)
  {
    while (1)
    {
      LODWORD(v62) = *(_DWORD *)(v60 + 80 * v62 + 8) & 0x7FFFFFFF;
      if ((_DWORD)v62 == 0x7FFFFFFF)
        break;
      if (*(_BYTE *)(v60 + 80 * v62 + 12) == 72)
        goto LABEL_86;
    }
LABEL_81:
    LODWORD(v62) = 0x7FFFFFFF;
  }
LABEL_86:
  v64 = (float)*(int *)(a1 + 8);
  v65 = *(float *)(v60 + 80 * v62 + 48) / v64;
  v67 = *(_DWORD *)(v61 + 4 * (0xA7941FA8506D86F0 % v59));
  v66 = 0x7FFFFFFF;
  v68 = 0x7FFFFFFF;
  if (v67 != 0x7FFFFFFF)
  {
    v68 = *(_DWORD *)(v61 + 4 * (0xA7941FA8506D86F0 % v59));
    if (*(_BYTE *)(v60 + 80 * v67 + 12) != 73)
    {
      while (1)
      {
        v68 = *(_DWORD *)(v60 + 80 * *(unsigned int *)(v61 + 4 * (0xA7941FA8506D86F0 % v59)) + 8) & 0x7FFFFFFF;
        if (v68 == 0x7FFFFFFF)
          break;
        if (*(_BYTE *)(v60 + 80 * v68 + 12) == 73)
          goto LABEL_92;
      }
      v68 = 0x7FFFFFFF;
    }
  }
LABEL_92:
  v63 = *(float *)(v60 + 80 * v68 + 48);
  v69 = *(unsigned int *)(v61 + 4 * (0xC1EBF56D881F3523 % v59));
  if ((_DWORD)v69 != 0x7FFFFFFF)
  {
    if (*(_BYTE *)(v60 + 80 * v69 + 12) == 74)
    {
LABEL_96:
      v66 = v69;
    }
    else
    {
      while (1)
      {
        LODWORD(v69) = *(_DWORD *)(v60 + 80 * v69 + 8) & 0x7FFFFFFF;
        v66 = 0x7FFFFFFF;
        if ((_DWORD)v69 == 0x7FFFFFFF)
          break;
        if (*(_BYTE *)(v60 + 80 * v69 + 12) == 74)
          goto LABEL_96;
      }
    }
  }
LABEL_97:
  re::DynamicString::appendf((re::DynamicString *)v11, "Spheres : %.0f, Planes : %.0f, Capsules : %.0f\n", v65, (float)(v63 / v64), (float)(*(float *)(v60 + 80 * v66 + 48) / v64));
  if (*(_QWORD *)a3)
  {
    v70 = *(unsigned int *)(a3 + 24);
    v72 = *(_QWORD *)(a3 + 8);
    v71 = *(_QWORD *)(a3 + 16);
    v73 = *(_DWORD *)(v72 + 4 * (0xCFCA9D2880B2128DLL % v70));
    v74 = 0x7FFFFFFF;
    v75 = 0x7FFFFFFF;
    if (v73 != 0x7FFFFFFF)
    {
      v75 = *(_DWORD *)(v72 + 4 * (0xCFCA9D2880B2128DLL % v70));
      if (*(_BYTE *)(v71 + 80 * v73 + 12) != 75)
      {
        while (1)
        {
          v75 = *(_DWORD *)(v71 + 80 * *(unsigned int *)(v72 + 4 * (0xCFCA9D2880B2128DLL % v70)) + 8) & 0x7FFFFFFF;
          if (v75 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v71 + 80 * v75 + 12) == 75)
            goto LABEL_105;
        }
        v75 = 0x7FFFFFFF;
      }
    }
LABEL_105:
    v80 = v71 + 80 * v75;
    v76 = *(_DWORD *)(a1 + 8);
    v81 = *(_DWORD *)(v72 + 4 * (0xB6C90EBACC2B26DDLL % v70));
    if (v81 != 0x7FFFFFFF)
    {
      v74 = *(_DWORD *)(v72 + 4 * (0xB6C90EBACC2B26DDLL % v70));
      if (*(_BYTE *)(v71 + 80 * v81 + 12) != 76)
      {
        while (1)
        {
          v74 = *(_DWORD *)(v71 + 80 * *(unsigned int *)(v72 + 4 * (0xB6C90EBACC2B26DDLL % v70)) + 8) & 0x7FFFFFFF;
          if (v74 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v71 + 80 * v74 + 12) == 76)
            goto LABEL_111;
        }
        v74 = 0x7FFFFFFF;
      }
    }
LABEL_111:
    v77 = *(float *)(v80 + 48);
    v79 = *(float *)(v71 + 80 * v74 + 48);
    v82 = *(unsigned int *)(v72 + 4 * (0x2CFA56B4A2AF9298 % v70));
    v78 = 0x7FFFFFFF;
    if ((_DWORD)v82 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v71 + 80 * v82 + 12) == 77)
      {
LABEL_115:
        v78 = v82;
      }
      else
      {
        while (1)
        {
          LODWORD(v82) = *(_DWORD *)(v71 + 80 * v82 + 8) & 0x7FFFFFFF;
          v78 = 0x7FFFFFFF;
          if ((_DWORD)v82 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v71 + 80 * v82 + 12) == 77)
            goto LABEL_115;
        }
      }
    }
  }
  else
  {
    v76 = *(_DWORD *)(a1 + 8);
    v71 = *(_QWORD *)(a3 + 16);
    v77 = *(float *)(v71 + 0x27FFFFFFE0);
    v78 = 0x7FFFFFFF;
    v79 = v77;
  }
  re::DynamicString::appendf((re::DynamicString *)v11, "Boxes : %.0f, Triangles : %.0f, Convexes : %.0f\n", (float)(v77 / (float)v76), (float)(v79 / (float)v76), (float)(*(float *)(v71 + 80 * v78 + 48) / (float)v76));
  v83 = v8 + (v9 << 6);
  *(_QWORD *)&result = 0x320000000ALL;
  *(_QWORD *)(v83 + 48) = 0x320000000ALL;
  *(_DWORD *)(v83 + 56) = 128;
  return result;
}

double re::FrameRenderingStats::dumpStatisticsInternal(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  _BYTE *v14;
  unsigned int v15;
  unsigned int v16;
  uint64_t v17;
  float v18;
  int v19;
  double v20;
  unint64_t v21;
  unint64_t v22;
  double v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  float v27;
  int v28;
  double v29;
  unint64_t v30;
  unint64_t v31;
  double v32;
  uint64_t v33;
  uint64_t v34;
  unsigned int v35;
  float v36;
  int v37;
  double v38;
  unint64_t v39;
  unint64_t v40;
  double v41;
  uint64_t v42;
  uint64_t v43;
  unsigned int v44;
  float v45;
  int v46;
  double v47;
  unint64_t v48;
  unint64_t v49;
  double v50;
  uint64_t v51;
  uint64_t v52;
  unsigned int v53;
  float v54;
  int v55;
  double v56;
  unint64_t v57;
  unint64_t v58;
  double v59;
  uint64_t v60;
  uint64_t v61;
  unsigned int v62;
  float v63;
  int v64;
  double v65;
  unint64_t v66;
  unint64_t v67;
  double v68;
  uint64_t v69;
  uint64_t v70;
  unsigned int v71;
  float v72;
  int v73;
  double v74;
  unint64_t v75;
  unint64_t v76;
  double v77;
  uint64_t v78;
  uint64_t v79;
  unsigned int v80;
  float v81;
  int v82;
  double v83;
  unint64_t v84;
  unint64_t v85;
  double v86;
  uint64_t v87;
  uint64_t v88;
  unsigned int v89;
  float v90;
  int v91;
  double v92;
  unint64_t v93;
  unint64_t v94;
  double v95;
  uint64_t v96;
  uint64_t v97;
  unsigned int v98;
  float v99;
  int v100;
  double v101;
  unint64_t v102;
  unint64_t v103;
  double v104;
  uint64_t v105;
  uint64_t v106;
  unsigned int v107;
  double v108;
  float v109;
  int v110;
  double v111;
  double v112;
  unint64_t v113;
  unint64_t v114;
  double v115;
  double v116;
  double v117;
  float v118;
  float v119;
  double v120;
  uint64_t v121;
  uint64_t v122;
  unsigned int v123;
  float v124;
  float v125;
  float v126;
  float v127;
  float v128;
  float v129;
  float v130;
  float v131;
  int v132;
  double v133;
  double v134;
  unint64_t v135;
  unint64_t v136;
  double v137;
  float v138;
  float v139;
  float v140;
  float v141;
  float v142;
  float v143;
  uint64_t v144;
  uint64_t v145;
  unsigned int v146;
  float v147;
  float v148;
  BOOL v149;
  double v150;
  double v151;
  float v152;
  unint64_t v153;
  uint64_t v154;
  unsigned int v155;
  unsigned int v156;
  unsigned int v157;
  float v158;
  unsigned int v159;
  float v160;
  float v161;
  unsigned int v162;
  uint64_t v163;
  uint64_t v164;
  unsigned int v165;
  unsigned int v166;
  uint64_t v167;
  unint64_t v168;
  unint64_t v169;
  unint64_t v170;
  unint64_t v171;
  double v172;
  uint64_t v173;
  uint64_t v174;
  unsigned int v175;
  float v176;
  uint64_t v177;
  uint64_t v178;
  unsigned int v179;
  float v180;
  float v181;
  float v182;
  int v183;
  double v184;
  unint64_t v185;
  unint64_t v186;
  double v187;
  float v188;
  int v189;
  double v190;
  unint64_t v191;
  unint64_t v192;
  double v193;
  uint64_t v194;
  uint64_t v195;
  unsigned int v196;
  float v197;
  int v198;
  double v199;
  double v200;
  unint64_t v201;
  unint64_t v202;
  double v203;
  uint64_t v204;
  uint64_t v205;
  unsigned int v206;
  float v207;
  int v208;
  double v209;
  double v210;
  unint64_t v211;
  unint64_t v212;
  double v213;
  double v214;
  uint64_t v215;
  uint64_t v216;
  unsigned int v217;
  double v218;
  float v219;
  int v220;
  double v221;
  unint64_t v222;
  unint64_t v223;
  double v224;
  double v225;
  uint64_t v226;
  uint64_t v227;
  unsigned int v228;
  double v229;
  float v230;
  int v231;
  double v232;
  unint64_t v233;
  unint64_t v234;
  double v235;
  uint64_t v236;
  uint64_t v237;
  int v238;
  uint64_t v239;
  _BOOL8 v240;
  uint64_t v241;
  uint64_t i;
  unsigned int v243;
  uint64_t v244;
  uint64_t v245;
  _QWORD *v246;
  uint64_t v247;
  _BYTE *v248;
  unint64_t v249;
  uint64_t v250;
  uint64_t v251;
  uint64_t v252;
  float v253;
  float v254;
  unsigned int v255;
  uint64_t v256;
  uint64_t v257;
  unint64_t v258;
  uint64_t v259;
  uint64_t v260;
  uint64_t v261;
  float v262;
  float v263;
  unsigned int v264;
  uint64_t v265;
  uint64_t v266;
  uint64_t v267;
  uint64_t v268;
  unsigned int v269;
  uint64_t v270;
  uint64_t v271;
  unsigned int v272;
  unint64_t v273;
  uint64_t v274;
  uint64_t v275;
  uint64_t v276;
  float v277;
  float v278;
  unsigned int v279;
  uint64_t v280;
  uint64_t v281;
  uint64_t v282;
  uint64_t v283;
  unsigned int v284;
  double v285;
  unsigned int v286;
  unsigned int v287;
  unint64_t v288;
  uint64_t v289;
  uint64_t v290;
  unsigned int v291;
  unsigned int v292;
  unsigned int v293;
  float v294;
  int v295;
  uint64_t v296;
  uint64_t v297;
  double result;
  float v299;
  uint64_t v300;
  uint64_t v301;
  double v302;
  double v303;
  float v304;
  double v305;
  float v306;
  double v307;
  float v308;
  double v309;
  float v310;
  int v311;
  mach_timebase_info info[2];
  __int128 v313;
  uint64_t v314;
  int v315;

  LODWORD(v6) = 0x7FFFFFFF;
  if (*(_QWORD *)a2)
  {
    v7 = **(unsigned int **)(a2 + 8);
    if ((_DWORD)v7 != 0x7FFFFFFF)
    {
      v8 = *(_QWORD *)(a2 + 16);
      if (*(_DWORD *)(v8 + (v7 << 6) + 12))
      {
        v6 = **(unsigned int **)(a2 + 8);
        while (1)
        {
          v6 = *(_DWORD *)(v8 + (v6 << 6) + 8) & 0x7FFFFFFF;
          if ((_DWORD)v6 == 0x7FFFFFFF)
            break;
          if (!*(_DWORD *)(v8 + (v6 << 6) + 12))
            goto LABEL_10;
        }
        LODWORD(v6) = 0x7FFFFFFF;
      }
      else
      {
        LODWORD(v6) = **(_DWORD **)(a2 + 8);
      }
    }
  }
LABEL_10:
  v9 = *(_QWORD *)(a2 + 16);
  v10 = v6;
  v11 = v9 + ((unint64_t)v6 << 6);
  v12 = (_QWORD *)(v11 + 16);
  v13 = *(_QWORD *)(v11 + 24);
  if ((v13 & 1) != 0)
  {
    v12[1] = 1;
    v14 = (_BYTE *)v12[2];
  }
  else
  {
    *((_BYTE *)v12 + 8) = v13 & 1;
    v14 = (char *)v12 + 9;
  }
  *v14 = 0;
  v15 = 0x7FFFFFFF;
  if (*(_QWORD *)a3)
  {
    v16 = *(_DWORD *)(*(_QWORD *)(a3 + 8) + 4 * (0x5692161D100B05E5uLL % *(unsigned int *)(a3 + 24)));
    if (v16 != 0x7FFFFFFF)
    {
      v17 = *(_QWORD *)(a3 + 16);
      v15 = *(_DWORD *)(*(_QWORD *)(a3 + 8) + 4 * (0x5692161D100B05E5uLL % *(unsigned int *)(a3 + 24)));
      if (*(_BYTE *)(v17 + 80 * v16 + 12) != 1)
      {
        while (1)
        {
          v15 = *(_DWORD *)(v17
                          + 80
                          * *(unsigned int *)(*(_QWORD *)(a3 + 8)
                                            + 4 * (0x5692161D100B05E5uLL % *(unsigned int *)(a3 + 24)))
                          + 8) & 0x7FFFFFFF;
          if (v15 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v17 + 80 * v15 + 12) == 1)
            goto LABEL_20;
        }
        v15 = 0x7FFFFFFF;
      }
    }
  }
LABEL_20:
  v300 = v10;
  v301 = v9;
  v18 = *(float *)(*(_QWORD *)(a3 + 16) + 80 * v15 + 48);
  v19 = *(_DWORD *)(a1 + 8);
  v20 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      v23 = NAN;
      goto LABEL_25;
    }
    LODWORD(v21) = info[0].numer;
    LODWORD(v22) = info[0].denom;
    v20 = (double)v21 / (double)v22;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v20;
  }
  v23 = v20 * (double)(unint64_t)(float)(v18 / (float)v19);
LABEL_25:
  v305 = v23;
  if (*(_QWORD *)a3)
  {
    v24 = *(_QWORD *)(a3 + 16);
    v25 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x826C6ABF7FDD5AD7 % *(unsigned int *)(a3 + 24)));
    v26 = 0x7FFFFFFF;
    if ((_DWORD)v25 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v24 + 80 * v25 + 12) == 9)
      {
LABEL_30:
        v26 = v25;
      }
      else
      {
        while (1)
        {
          LODWORD(v25) = *(_DWORD *)(v24 + 80 * v25 + 8) & 0x7FFFFFFF;
          v26 = 0x7FFFFFFF;
          if ((_DWORD)v25 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v24 + 80 * v25 + 12) == 9)
            goto LABEL_30;
        }
      }
    }
  }
  else
  {
    v24 = *(_QWORD *)(a3 + 16);
    v26 = 0x7FFFFFFF;
  }
  v27 = *(float *)(v24 + 80 * v26 + 48);
  v28 = *(_DWORD *)(a1 + 8);
  v29 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      v32 = NAN;
      goto LABEL_37;
    }
    LODWORD(v30) = info[0].numer;
    LODWORD(v31) = info[0].denom;
    v29 = (double)v30 / (double)v31;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v29;
  }
  v32 = v29 * (double)(unint64_t)(float)(v27 / (float)v28);
LABEL_37:
  if (*(_QWORD *)a3)
  {
    v33 = *(_QWORD *)(a3 + 16);
    v34 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x75C8519A9320579uLL % *(unsigned int *)(a3 + 24)));
    v35 = 0x7FFFFFFF;
    if ((_DWORD)v34 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v33 + 80 * v34 + 12) == 10)
      {
LABEL_42:
        v35 = v34;
      }
      else
      {
        while (1)
        {
          LODWORD(v34) = *(_DWORD *)(v33 + 80 * v34 + 8) & 0x7FFFFFFF;
          v35 = 0x7FFFFFFF;
          if ((_DWORD)v34 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v33 + 80 * v34 + 12) == 10)
            goto LABEL_42;
        }
      }
    }
  }
  else
  {
    v33 = *(_QWORD *)(a3 + 16);
    v35 = 0x7FFFFFFF;
  }
  v36 = *(float *)(v33 + 80 * v35 + 48);
  v37 = *(_DWORD *)(a1 + 8);
  v38 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      v41 = NAN;
      goto LABEL_49;
    }
    LODWORD(v39) = info[0].numer;
    LODWORD(v40) = info[0].denom;
    v38 = (double)v39 / (double)v40;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v38;
  }
  v41 = v38 * (double)(unint64_t)(float)(v36 / (float)v37);
LABEL_49:
  if (*(_QWORD *)a3)
  {
    v42 = *(_QWORD *)(a3 + 16);
    v43 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0xD56B1FBB9CEBA9E8 % *(unsigned int *)(a3 + 24)));
    v44 = 0x7FFFFFFF;
    if ((_DWORD)v43 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v42 + 80 * v43 + 12) == 8)
      {
LABEL_54:
        v44 = v43;
      }
      else
      {
        while (1)
        {
          LODWORD(v43) = *(_DWORD *)(v42 + 80 * v43 + 8) & 0x7FFFFFFF;
          v44 = 0x7FFFFFFF;
          if ((_DWORD)v43 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v42 + 80 * v43 + 12) == 8)
            goto LABEL_54;
        }
      }
    }
  }
  else
  {
    v42 = *(_QWORD *)(a3 + 16);
    v44 = 0x7FFFFFFF;
  }
  v45 = *(float *)(v42 + 80 * v44 + 48);
  v46 = *(_DWORD *)(a1 + 8);
  v47 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      v50 = NAN;
      goto LABEL_61;
    }
    LODWORD(v48) = info[0].numer;
    LODWORD(v49) = info[0].denom;
    v47 = (double)v48 / (double)v49;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v47;
  }
  v50 = v47 * (double)(unint64_t)(float)(v45 / (float)v46);
LABEL_61:
  v309 = v50;
  if (*(_QWORD *)a3)
  {
    v51 = *(_QWORD *)(a3 + 16);
    v52 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x3462D848F53ABB6DuLL % *(unsigned int *)(a3 + 24)));
    v53 = 0x7FFFFFFF;
    if ((_DWORD)v52 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v51 + 80 * v52 + 12) == 11)
      {
LABEL_66:
        v53 = v52;
      }
      else
      {
        while (1)
        {
          LODWORD(v52) = *(_DWORD *)(v51 + 80 * v52 + 8) & 0x7FFFFFFF;
          v53 = 0x7FFFFFFF;
          if ((_DWORD)v52 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v51 + 80 * v52 + 12) == 11)
            goto LABEL_66;
        }
      }
    }
  }
  else
  {
    v51 = *(_QWORD *)(a3 + 16);
    v53 = 0x7FFFFFFF;
  }
  v54 = *(float *)(v51 + 80 * v53 + 48);
  v55 = *(_DWORD *)(a1 + 8);
  v56 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      v59 = NAN;
      goto LABEL_73;
    }
    LODWORD(v57) = info[0].numer;
    LODWORD(v58) = info[0].denom;
    v56 = (double)v57 / (double)v58;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v56;
  }
  v59 = v56 * (double)(unint64_t)(float)(v54 / (float)v55);
LABEL_73:
  v307 = v59;
  if (*(_QWORD *)a3)
  {
    v60 = *(_QWORD *)(a3 + 16);
    v61 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x37BE58E8D7213BBCuLL % *(unsigned int *)(a3 + 24)));
    v62 = 0x7FFFFFFF;
    if ((_DWORD)v61 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v60 + 80 * v61 + 12) == 12)
      {
LABEL_78:
        v62 = v61;
      }
      else
      {
        while (1)
        {
          LODWORD(v61) = *(_DWORD *)(v60 + 80 * v61 + 8) & 0x7FFFFFFF;
          v62 = 0x7FFFFFFF;
          if ((_DWORD)v61 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v60 + 80 * v61 + 12) == 12)
            goto LABEL_78;
        }
      }
    }
  }
  else
  {
    v60 = *(_QWORD *)(a3 + 16);
    v62 = 0x7FFFFFFF;
  }
  v63 = *(float *)(v60 + 80 * v62 + 48);
  v64 = *(_DWORD *)(a1 + 8);
  v65 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      v68 = NAN;
      goto LABEL_85;
    }
    LODWORD(v66) = info[0].numer;
    LODWORD(v67) = info[0].denom;
    v65 = (double)v66 / (double)v67;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v65;
  }
  v68 = v65 * (double)(unint64_t)(float)(v63 / (float)v64);
LABEL_85:
  if (*(_QWORD *)a3)
  {
    v69 = *(_QWORD *)(a3 + 16);
    v70 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x378A5760BE593CA5uLL % *(unsigned int *)(a3 + 24)));
    v71 = 0x7FFFFFFF;
    if ((_DWORD)v70 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v69 + 80 * v70 + 12) == 23)
      {
LABEL_90:
        v71 = v70;
      }
      else
      {
        while (1)
        {
          LODWORD(v70) = *(_DWORD *)(v69 + 80 * v70 + 8) & 0x7FFFFFFF;
          v71 = 0x7FFFFFFF;
          if ((_DWORD)v70 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v69 + 80 * v70 + 12) == 23)
            goto LABEL_90;
        }
      }
    }
  }
  else
  {
    v69 = *(_QWORD *)(a3 + 16);
    v71 = 0x7FFFFFFF;
  }
  v72 = *(float *)(v69 + 80 * v71 + 48);
  v73 = *(_DWORD *)(a1 + 8);
  v74 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      v77 = NAN;
      goto LABEL_97;
    }
    LODWORD(v75) = info[0].numer;
    LODWORD(v76) = info[0].denom;
    v74 = (double)v75 / (double)v76;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v74;
  }
  v77 = v74 * (double)(unint64_t)(float)(v72 / (float)v73);
LABEL_97:
  if (*(_QWORD *)a3)
  {
    v78 = *(_QWORD *)(a3 + 16);
    v79 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0xCFF0446243756E89 % *(unsigned int *)(a3 + 24)));
    v80 = 0x7FFFFFFF;
    if ((_DWORD)v79 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v78 + 80 * v79 + 12) == 79)
      {
LABEL_102:
        v80 = v79;
      }
      else
      {
        while (1)
        {
          LODWORD(v79) = *(_DWORD *)(v78 + 80 * v79 + 8) & 0x7FFFFFFF;
          v80 = 0x7FFFFFFF;
          if ((_DWORD)v79 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v78 + 80 * v79 + 12) == 79)
            goto LABEL_102;
        }
      }
    }
  }
  else
  {
    v78 = *(_QWORD *)(a3 + 16);
    v80 = 0x7FFFFFFF;
  }
  v81 = *(float *)(v78 + 80 * v80 + 48);
  v82 = *(_DWORD *)(a1 + 8);
  v83 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      v86 = NAN;
      goto LABEL_109;
    }
    LODWORD(v84) = info[0].numer;
    LODWORD(v85) = info[0].denom;
    v83 = (double)v84 / (double)v85;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v83;
  }
  v86 = v83 * (double)(unint64_t)(float)(v81 / (float)v82);
LABEL_109:
  v303 = v86;
  if (*(_QWORD *)a3)
  {
    v87 = *(_QWORD *)(a3 + 16);
    v88 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x8AEB093D93E71BBFLL % *(unsigned int *)(a3 + 24)));
    v89 = 0x7FFFFFFF;
    if ((_DWORD)v88 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v87 + 80 * v88 + 12) == 122)
      {
LABEL_114:
        v89 = v88;
      }
      else
      {
        while (1)
        {
          LODWORD(v88) = *(_DWORD *)(v87 + 80 * v88 + 8) & 0x7FFFFFFF;
          v89 = 0x7FFFFFFF;
          if ((_DWORD)v88 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v87 + 80 * v88 + 12) == 122)
            goto LABEL_114;
        }
      }
    }
  }
  else
  {
    v87 = *(_QWORD *)(a3 + 16);
    v89 = 0x7FFFFFFF;
  }
  v90 = *(float *)(v87 + 80 * v89 + 48);
  v91 = *(_DWORD *)(a1 + 8);
  v92 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      v95 = NAN;
      goto LABEL_121;
    }
    LODWORD(v93) = info[0].numer;
    LODWORD(v94) = info[0].denom;
    v92 = (double)v93 / (double)v94;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v92;
  }
  v95 = v92 * (double)(unint64_t)(float)(v90 / (float)v91);
LABEL_121:
  v302 = v95;
  if (*(_QWORD *)a3)
  {
    v96 = *(_QWORD *)(a3 + 16);
    v97 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x968A5BA23473FAFFLL % *(unsigned int *)(a3 + 24)));
    v98 = 0x7FFFFFFF;
    if ((_DWORD)v97 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v96 + 80 * v97 + 12) == 91)
      {
LABEL_126:
        v98 = v97;
      }
      else
      {
        while (1)
        {
          LODWORD(v97) = *(_DWORD *)(v96 + 80 * v97 + 8) & 0x7FFFFFFF;
          v98 = 0x7FFFFFFF;
          if ((_DWORD)v97 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v96 + 80 * v97 + 12) == 91)
            goto LABEL_126;
        }
      }
    }
  }
  else
  {
    v96 = *(_QWORD *)(a3 + 16);
    v98 = 0x7FFFFFFF;
  }
  v99 = *(float *)(v96 + 80 * v98 + 48);
  v100 = *(_DWORD *)(a1 + 8);
  v101 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      v104 = NAN;
      goto LABEL_133;
    }
    LODWORD(v102) = info[0].numer;
    LODWORD(v103) = info[0].denom;
    v101 = (double)v102 / (double)v103;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v101;
  }
  v104 = v101 * (double)(unint64_t)(float)(v99 / (float)v100);
LABEL_133:
  if (*(_QWORD *)a3)
  {
    v105 = *(_QWORD *)(a3 + 16);
    v106 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0xDE295D82F964F296 % *(unsigned int *)(a3 + 24)));
    v107 = 0x7FFFFFFF;
    if ((_DWORD)v106 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v105 + 80 * v106 + 12) == 92)
      {
LABEL_138:
        v107 = v106;
      }
      else
      {
        while (1)
        {
          LODWORD(v106) = *(_DWORD *)(v105 + 80 * v106 + 8) & 0x7FFFFFFF;
          v107 = 0x7FFFFFFF;
          if ((_DWORD)v106 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v105 + 80 * v106 + 12) == 92)
            goto LABEL_138;
        }
      }
    }
  }
  else
  {
    v105 = *(_QWORD *)(a3 + 16);
    v107 = 0x7FFFFFFF;
  }
  v108 = v32 / 1000000.0;
  v109 = *(float *)(v105 + 80 * v107 + 48);
  v110 = *(_DWORD *)(a1 + 8);
  v111 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  v112 = v41 / 1000000.0;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      v115 = NAN;
      goto LABEL_145;
    }
    LODWORD(v113) = info[0].numer;
    LODWORD(v114) = info[0].denom;
    v111 = (double)v113 / (double)v114;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v111;
  }
  v115 = v111 * (double)(unint64_t)(float)(v109 / (float)v110);
LABEL_145:
  v116 = v307 / 1000000.0;
  v117 = v77 / 1000000.0;
  v120 = v115 / 1000000.0;
  if (*(_QWORD *)a3)
  {
    v121 = *(_QWORD *)(a3 + 16);
    v122 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0xFEBD6A4FBD0A7802 % *(unsigned int *)(a3 + 24)));
    v123 = 0x7FFFFFFF;
    if ((_DWORD)v122 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v121 + 80 * v122 + 12) == 93)
      {
LABEL_150:
        v123 = v122;
      }
      else
      {
        while (1)
        {
          LODWORD(v122) = *(_DWORD *)(v121 + 80 * v122 + 8) & 0x7FFFFFFF;
          v123 = 0x7FFFFFFF;
          if ((_DWORD)v122 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v121 + 80 * v122 + 12) == 93)
            goto LABEL_150;
        }
      }
    }
  }
  else
  {
    v121 = *(_QWORD *)(a3 + 16);
    v123 = 0x7FFFFFFF;
  }
  v124 = v309 / 1000000.0;
  v308 = v124;
  v125 = v116;
  v310 = v125;
  v126 = v68 / 1000000.0;
  v127 = v117;
  v299 = v112;
  v118 = v108;
  v119 = v112;
  v128 = v118 - v119;
  v129 = v104 / 1000000.0;
  v130 = v120;
  v131 = *(float *)(v121 + 80 * v123 + 48);
  v132 = *(_DWORD *)(a1 + 8);
  v133 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  v134 = v305 / 1000000.0;
  v306 = v127;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      v137 = NAN;
      v127 = v306;
      goto LABEL_157;
    }
    LODWORD(v135) = info[0].numer;
    LODWORD(v136) = info[0].denom;
    v133 = (double)v135 / (double)v136;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v133;
    v127 = v306;
  }
  v137 = v133 * (double)(unint64_t)(float)(v131 / (float)v132);
LABEL_157:
  v138 = v134;
  v139 = v137 / 1000000.0;
  v140 = v128 + (float)((float)(v129 + v130) + v139);
  v141 = v126;
  v142 = (float)(v310 + v126) + v127;
  v143 = 0.0;
  if (v308 <= 0.0)
    v143 = v142;
  if (*(_QWORD *)a3)
  {
    v144 = *(_QWORD *)(a3 + 16);
    v145 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0xD59EEF30DB86CAB8 % *(unsigned int *)(a3 + 24)));
    v146 = 0x7FFFFFFF;
    if ((_DWORD)v145 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v144 + 80 * v145 + 12) == 24)
      {
LABEL_164:
        v146 = v145;
      }
      else
      {
        while (1)
        {
          LODWORD(v145) = *(_DWORD *)(v144 + 80 * v145 + 8) & 0x7FFFFFFF;
          v146 = 0x7FFFFFFF;
          if ((_DWORD)v145 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v144 + 80 * v145 + 12) == 24)
            goto LABEL_164;
        }
      }
    }
  }
  else
  {
    v144 = *(_QWORD *)(a3 + 16);
    v146 = 0x7FFFFFFF;
  }
  v147 = v140 - v143;
  v148 = (float)*(int *)(a1 + 8);
  v149 = v138 <= 0.0;
  v150 = (float)(1000.0 / v138);
  if (v149)
    v151 = 0.0;
  else
    v151 = v150;
  v152 = (float)(*(float *)(v144 + 80 * v146 + 48) / v148) / 1000000.0;
  if (*(_QWORD *)a3)
  {
    v153 = *(unsigned int *)(a3 + 24);
    v154 = *(_QWORD *)(a3 + 8);
    v155 = *(_DWORD *)(v154 + 4 * (0x4F7ABB7627B74F52 % v153));
    v156 = 0x7FFFFFFF;
    v157 = 0x7FFFFFFF;
    if (v155 != 0x7FFFFFFF)
    {
      v157 = *(_DWORD *)(v154 + 4 * (0x4F7ABB7627B74F52 % v153));
      if (*(_BYTE *)(v144 + 80 * v155 + 12) != 29)
      {
        while (1)
        {
          v157 = *(_DWORD *)(v144 + 80 * *(unsigned int *)(v154 + 4 * (0x4F7ABB7627B74F52 % v153)) + 8) & 0x7FFFFFFF;
          if (v157 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v144 + 80 * v157 + 12) == 29)
            goto LABEL_177;
        }
        v157 = 0x7FFFFFFF;
      }
    }
LABEL_177:
    v162 = *(_DWORD *)(v154 + 4 * (0x724EA9269D42A72 % v153));
    if (v162 != 0x7FFFFFFF)
    {
      v156 = *(_DWORD *)(v154 + 4 * (0x724EA9269D42A72 % v153));
      if (*(_BYTE *)(v144 + 80 * v162 + 12) != 30)
      {
        while (1)
        {
          v156 = *(_DWORD *)(v144 + 80 * *(unsigned int *)(v154 + 4 * (0x724EA9269D42A72 % v153)) + 8) & 0x7FFFFFFF;
          if (v156 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v144 + 80 * v156 + 12) == 30)
            goto LABEL_183;
        }
        v156 = 0x7FFFFFFF;
      }
    }
LABEL_183:
    v163 = v144 + 80 * v157;
    v164 = v144 + 80 * v156;
    v165 = *(_DWORD *)(v154 + 4 * (0x540F172E046EF165 % v153));
    v159 = 0x7FFFFFFF;
    v166 = 0x7FFFFFFF;
    if (v165 != 0x7FFFFFFF)
    {
      v166 = *(_DWORD *)(v154 + 4 * (0x540F172E046EF165 % v153));
      if (*(_BYTE *)(v144 + 80 * v165 + 12) != 31)
      {
        while (1)
        {
          v166 = *(_DWORD *)(v144 + 80 * *(unsigned int *)(v154 + 4 * (0x540F172E046EF165 % v153)) + 8) & 0x7FFFFFFF;
          if (v166 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v144 + 80 * v166 + 12) == 31)
            goto LABEL_189;
        }
        v166 = 0x7FFFFFFF;
      }
    }
LABEL_189:
    v160 = *(float *)(v163 + 48);
    v161 = *(float *)(v164 + 48);
    v158 = *(float *)(v144 + 80 * v166 + 48);
    v167 = *(unsigned int *)(v154 + 4 * (0xADFB1EBB497FAD45 % v153));
    if ((_DWORD)v167 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v144 + 80 * v167 + 12) == 32)
      {
LABEL_193:
        v159 = v167;
      }
      else
      {
        while (1)
        {
          LODWORD(v167) = *(_DWORD *)(v144 + 80 * v167 + 8) & 0x7FFFFFFF;
          v159 = 0x7FFFFFFF;
          if ((_DWORD)v167 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v144 + 80 * v167 + 12) == 32)
            goto LABEL_193;
        }
      }
    }
  }
  else
  {
    v158 = *(float *)(v144 + 0x27FFFFFFE0);
    v159 = 0x7FFFFFFF;
    v160 = v158;
    v161 = v158;
  }
  v168 = (unint64_t)(float)((float)(v161 / v148) / 1000000.0);
  v169 = (unint64_t)(float)((float)(v160 / v148) / 1000000.0);
  v170 = (unint64_t)(float)((float)(v158 / v148) / 1000000.0);
  v171 = (unint64_t)(float)((float)(*(float *)(v144 + 80 * v159 + 48) / v148) / 1000000.0);
  re::DynamicString::appendf((re::DynamicString *)v12, "Frame Render GPU Times (ms)\n");
  re::DynamicString::appendf((re::DynamicString *)v12, "FPS : %.2f    GPU : %.2f\n", v151, v152);
  re::DynamicString::appendf((re::DynamicString *)v12, "Vtx : %.2f    Frg : %.2f\nRenderGraph compute : %0.2f\nDeformer compute : %0.2f\n", (double)v169 / 1000000.0, (double)v168 / 1000000.0, (double)v170 / 1000000.0, (double)v171 / 1000000.0);
  re::DynamicString::appendf((re::DynamicString *)v12, "Frame Render CPU Times (ms)\n");
  v172 = v147;
  if (v308 <= 0.0)
  {
    if (*(_QWORD *)a3)
    {
      v177 = *(_QWORD *)(a3 + 16);
      v178 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x8AEB093D93E71BBFLL % *(unsigned int *)(a3 + 24)));
      v179 = 0x7FFFFFFF;
      v180 = v302 / 1000000.0;
      v181 = v303 / 1000000.0;
      if ((_DWORD)v178 != 0x7FFFFFFF)
      {
        if (*(_BYTE *)(v177 + 80 * v178 + 12) == 122)
        {
LABEL_206:
          v179 = v178;
        }
        else
        {
          while (1)
          {
            LODWORD(v178) = *(_DWORD *)(v177 + 80 * v178 + 8) & 0x7FFFFFFF;
            v179 = 0x7FFFFFFF;
            if ((_DWORD)v178 == 0x7FFFFFFF)
              break;
            if (*(_BYTE *)(v177 + 80 * v178 + 12) == 122)
              goto LABEL_206;
          }
        }
      }
    }
    else
    {
      v180 = v302 / 1000000.0;
      v181 = v303 / 1000000.0;
      v177 = *(_QWORD *)(a3 + 16);
      v179 = 0x7FFFFFFF;
    }
    v188 = *(float *)(v177 + 80 * v179 + 48);
    v189 = *(_DWORD *)(a1 + 8);
    v190 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        v193 = NAN;
        goto LABEL_229;
      }
      LODWORD(v191) = info[0].numer;
      LODWORD(v192) = info[0].denom;
      v190 = (double)v191 / (double)v192;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v190;
    }
    v193 = v190 * (double)(unint64_t)(float)(v188 / (float)v189);
LABEL_229:
    if (*(_QWORD *)a3)
    {
      v204 = *(_QWORD *)(a3 + 16);
      v205 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x89607B27DA843F55 % *(unsigned int *)(a3 + 24)));
      v206 = 0x7FFFFFFF;
      if ((_DWORD)v205 != 0x7FFFFFFF)
      {
        if (*(unsigned __int8 *)(v204 + 80 * v205 + 12) == 129)
        {
LABEL_234:
          v206 = v205;
        }
        else
        {
          while (1)
          {
            LODWORD(v205) = *(_DWORD *)(v204 + 80 * v205 + 8) & 0x7FFFFFFF;
            v206 = 0x7FFFFFFF;
            if ((_DWORD)v205 == 0x7FFFFFFF)
              break;
            if (*(unsigned __int8 *)(v204 + 80 * v205 + 12) == 129)
              goto LABEL_234;
          }
        }
      }
    }
    else
    {
      v204 = *(_QWORD *)(a3 + 16);
      v206 = 0x7FFFFFFF;
    }
    v207 = *(float *)(v204 + 80 * v206 + 48);
    v208 = *(_DWORD *)(a1 + 8);
    v209 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    v210 = v193 / 1000000.0;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        v213 = NAN;
        goto LABEL_253;
      }
      LODWORD(v211) = info[0].numer;
      LODWORD(v212) = info[0].denom;
      v209 = (double)v211 / (double)v212;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v209;
    }
    v213 = v209 * (double)(unint64_t)(float)(v207 / (float)v208);
LABEL_253:
    v225 = v213 / 1000000.0;
    if (*(_QWORD *)a3)
    {
      v226 = *(_QWORD *)(a3 + 16);
      v227 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0xAF26563F2EC4C8E6 % *(unsigned int *)(a3 + 24)));
      v228 = 0x7FFFFFFF;
      if ((_DWORD)v227 != 0x7FFFFFFF)
      {
        if (*(unsigned __int8 *)(v226 + 80 * v227 + 12) == 128)
        {
LABEL_258:
          v228 = v227;
        }
        else
        {
          while (1)
          {
            LODWORD(v227) = *(_DWORD *)(v226 + 80 * v227 + 8) & 0x7FFFFFFF;
            v228 = 0x7FFFFFFF;
            if ((_DWORD)v227 == 0x7FFFFFFF)
              break;
            if (*(unsigned __int8 *)(v226 + 80 * v227 + 12) == 128)
              goto LABEL_258;
          }
        }
      }
    }
    else
    {
      v226 = *(_QWORD *)(a3 + 16);
      v228 = 0x7FFFFFFF;
    }
    v229 = v210 + v172 + v225;
    v230 = *(float *)(v226 + 80 * v228 + 48);
    v231 = *(_DWORD *)(a1 + 8);
    v232 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        v235 = NAN;
LABEL_268:
        v237 = v300;
        v236 = v301;
        re::DynamicString::appendf((re::DynamicString *)v12, "MainThread Render : %.2f\n", v229 + v235 / 1000000.0);
        re::DynamicString::appendf((re::DynamicString *)v12, "EncodeDrawCalls : %.2f    ECS Render : %.2f\n", v181, v180);
        re::DynamicString::appendf((re::DynamicString *)v12, "Drawables Wait : %.2f    GPU Wait : %.2f\n", v310, v141);
        v238 = 10;
        goto LABEL_269;
      }
      LODWORD(v233) = info[0].numer;
      LODWORD(v234) = info[0].denom;
      v232 = (double)v233 / (double)v234;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v232;
    }
    v235 = v232 * (double)(unint64_t)(float)(v230 / (float)v231);
    goto LABEL_268;
  }
  if (*(_QWORD *)a3)
  {
    v173 = *(_QWORD *)(a3 + 16);
    v174 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x8AEB093D93E71BBFLL % *(unsigned int *)(a3 + 24)));
    v175 = 0x7FFFFFFF;
    v176 = v303 / 1000000.0;
    if ((_DWORD)v174 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v173 + 80 * v174 + 12) == 122)
      {
LABEL_200:
        v175 = v174;
      }
      else
      {
        while (1)
        {
          LODWORD(v174) = *(_DWORD *)(v173 + 80 * v174 + 8) & 0x7FFFFFFF;
          v175 = 0x7FFFFFFF;
          if ((_DWORD)v174 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v173 + 80 * v174 + 12) == 122)
            goto LABEL_200;
        }
      }
    }
  }
  else
  {
    v176 = v303 / 1000000.0;
    v173 = *(_QWORD *)(a3 + 16);
    v175 = 0x7FFFFFFF;
  }
  v182 = *(float *)(v173 + 80 * v175 + 48);
  v183 = *(_DWORD *)(a1 + 8);
  v184 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      v187 = NAN;
      goto LABEL_217;
    }
    LODWORD(v185) = info[0].numer;
    LODWORD(v186) = info[0].denom;
    v184 = (double)v185 / (double)v186;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v184;
  }
  v187 = v184 * (double)(unint64_t)(float)(v182 / (float)v183);
LABEL_217:
  if (*(_QWORD *)a3)
  {
    v194 = *(_QWORD *)(a3 + 16);
    v195 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x89607B27DA843F55 % *(unsigned int *)(a3 + 24)));
    v196 = 0x7FFFFFFF;
    if ((_DWORD)v195 != 0x7FFFFFFF)
    {
      if (*(unsigned __int8 *)(v194 + 80 * v195 + 12) == 129)
      {
LABEL_222:
        v196 = v195;
      }
      else
      {
        while (1)
        {
          LODWORD(v195) = *(_DWORD *)(v194 + 80 * v195 + 8) & 0x7FFFFFFF;
          v196 = 0x7FFFFFFF;
          if ((_DWORD)v195 == 0x7FFFFFFF)
            break;
          if (*(unsigned __int8 *)(v194 + 80 * v195 + 12) == 129)
            goto LABEL_222;
        }
      }
    }
  }
  else
  {
    v194 = *(_QWORD *)(a3 + 16);
    v196 = 0x7FFFFFFF;
  }
  v197 = *(float *)(v194 + 80 * v196 + 48);
  v198 = *(_DWORD *)(a1 + 8);
  v199 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  v200 = v187 / 1000000.0;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      v203 = NAN;
      goto LABEL_241;
    }
    LODWORD(v201) = info[0].numer;
    LODWORD(v202) = info[0].denom;
    v199 = (double)v201 / (double)v202;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v199;
  }
  v203 = v199 * (double)(unint64_t)(float)(v197 / (float)v198);
LABEL_241:
  v214 = v203 / 1000000.0;
  if (*(_QWORD *)a3)
  {
    v215 = *(_QWORD *)(a3 + 16);
    v216 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0xAF26563F2EC4C8E6 % *(unsigned int *)(a3 + 24)));
    v217 = 0x7FFFFFFF;
    if ((_DWORD)v216 != 0x7FFFFFFF)
    {
      if (*(unsigned __int8 *)(v215 + 80 * v216 + 12) == 128)
      {
LABEL_246:
        v217 = v216;
      }
      else
      {
        while (1)
        {
          LODWORD(v216) = *(_DWORD *)(v215 + 80 * v216 + 8) & 0x7FFFFFFF;
          v217 = 0x7FFFFFFF;
          if ((_DWORD)v216 == 0x7FFFFFFF)
            break;
          if (*(unsigned __int8 *)(v215 + 80 * v216 + 12) == 128)
            goto LABEL_246;
        }
      }
    }
  }
  else
  {
    v215 = *(_QWORD *)(a3 + 16);
    v217 = 0x7FFFFFFF;
  }
  v218 = v200 + v172 + v214;
  v219 = *(float *)(v215 + 80 * v217 + 48);
  v220 = *(_DWORD *)(a1 + 8);
  v221 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale >= 0.0)
    goto LABEL_264;
  if (!mach_timebase_info(info))
  {
    LODWORD(v222) = info[0].numer;
    LODWORD(v223) = info[0].denom;
    v221 = (double)v222 / (double)v223;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v221;
LABEL_264:
    v224 = v221 * (double)(unint64_t)(float)(v219 / (float)v220);
    goto LABEL_265;
  }
  v224 = NAN;
LABEL_265:
  v237 = v300;
  v236 = v301;
  re::DynamicString::appendf((re::DynamicString *)v12, "RenderThread : %.2f    MainThread Render : %.2f\n", (float)((float)((float)(v308 - v310) - v126) - v306), v218 + v224 / 1000000.0);
  v304 = v302 / 1000000.0;
  re::DynamicString::appendf((re::DynamicString *)v12, "EncodeDrawCalls : %.2f    ECS Render : %.2f\n", v176, v304);
  re::DynamicString::appendf((re::DynamicString *)v12, "Drawables Wait : %.2f    GPU Wait : %.2f\n", v310, v126);
  re::DynamicString::appendf((re::DynamicString *)v12, "Render Thread Sync Latency: %.2f\n", v299);
  v238 = 11;
LABEL_269:
  v239 = v236 + (v237 << 6);
  *(_DWORD *)(v239 + 48) = v238;
  *(_QWORD *)(v239 + 52) = 0x10000000032;
  info[0].numer = 1;
  v240 = re::HashTable<unsigned int,re::FrameStatisticsOutput,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::containsKey(a2, (unsigned int *)info);
  if (!v240)
  {
    *(_OWORD *)&info[0].numer = 0u;
    v313 = 0u;
    re::DynamicString::setCapacity(info, 0);
    v314 = 0x2800000006;
    v315 = 1;
    v311 = 1;
    re::HashTable<unsigned int,re::FrameStatisticsOutput,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::add<re::FrameStatisticsOutput&>(a2, &v311, (re::DynamicString *)info);
    if (info[0])
    {
      if ((info[1].numer & 1) != 0)
        (*(void (**)(void))(**(_QWORD **)info + 40))();
    }
  }
  if (*(_QWORD *)a2)
  {
    v241 = *(_QWORD *)(a2 + 16);
    for (i = *(unsigned int *)(*(_QWORD *)(a2 + 8) + 4 * (0x5692161D100B05E5uLL % *(unsigned int *)(a2 + 24)));
          ;
          i = *(_DWORD *)(v241 + (i << 6) + 8) & 0x7FFFFFFF)
    {
      v243 = 0x7FFFFFFF;
      if ((_DWORD)i == 0x7FFFFFFF)
        break;
      if (*(_DWORD *)(v241 + (i << 6) + 12) == 1)
      {
        v243 = i;
        break;
      }
    }
  }
  else
  {
    v241 = *(_QWORD *)(a2 + 16);
    v243 = 0x7FFFFFFF;
  }
  v244 = v243;
  v245 = v241 + ((unint64_t)v243 << 6);
  v246 = (_QWORD *)(v245 + 16);
  v247 = *(_QWORD *)(v245 + 24);
  if ((v247 & 1) != 0)
  {
    v246[1] = 1;
    v248 = (_BYTE *)v246[2];
  }
  else
  {
    *((_BYTE *)v246 + 8) = v247 & 1;
    v248 = (char *)v246 + 9;
  }
  *v248 = 0;
  re::DynamicString::appendf((re::DynamicString *)v246, "Metal Heap Allocation Stats Per Frame [MB]\n");
  if (!*(_QWORD *)a3)
  {
    v250 = *(_QWORD *)(a3 + 16);
    v253 = (float)*(int *)(a1 + 8);
    v254 = *(float *)(v250 + 0x27FFFFFFE0) / v253;
    v255 = 0x7FFFFFFF;
    goto LABEL_297;
  }
  v249 = *(unsigned int *)(a3 + 24);
  v251 = *(_QWORD *)(a3 + 8);
  v250 = *(_QWORD *)(a3 + 16);
  v252 = *(unsigned int *)(v251 + 4 * (0x87D70AD2CA29B0ALL % v249));
  if ((_DWORD)v252 == 0x7FFFFFFF)
  {
    LODWORD(v252) = 0x7FFFFFFF;
LABEL_288:
    v256 = v250 + 80 * v252;
    goto LABEL_292;
  }
  if (*(_BYTE *)(v250 + 80 * v252 + 12) == 80)
    goto LABEL_288;
  do
    LODWORD(v252) = *(_DWORD *)(v250 + 80 * v252 + 8) & 0x7FFFFFFF;
  while ((_DWORD)v252 != 0x7FFFFFFF && *(_BYTE *)(v250 + 80 * v252 + 12) != 80);
  v256 = v250 + 80 * v252;
LABEL_292:
  v253 = (float)*(int *)(a1 + 8);
  v254 = *(float *)(v256 + 48) / v253;
  v257 = *(unsigned int *)(v251 + 4 * (0x8B37E5E0A757936CLL % v249));
  v255 = 0x7FFFFFFF;
  if ((_DWORD)v257 != 0x7FFFFFFF)
  {
    if (*(_BYTE *)(v250 + 80 * v257 + 12) == 81)
    {
LABEL_296:
      v255 = v257;
    }
    else
    {
      while (1)
      {
        LODWORD(v257) = *(_DWORD *)(v250 + 80 * v257 + 8) & 0x7FFFFFFF;
        v255 = 0x7FFFFFFF;
        if ((_DWORD)v257 == 0x7FFFFFFF)
          break;
        if (*(_BYTE *)(v250 + 80 * v257 + 12) == 81)
          goto LABEL_296;
      }
    }
  }
LABEL_297:
  re::DynamicString::appendf((re::DynamicString *)v246, "Heaps : %.0f, Heap Memory [MB]: %.2f\n", v254, (float)((float)((float)(*(float *)(v250 + 80 * v255 + 48) / v253) * 0.00097656) * 0.00097656));
  if (!*(_QWORD *)a3)
  {
    v259 = *(_QWORD *)(a3 + 16);
    v262 = (float)*(int *)(a1 + 8);
    v263 = *(float *)(v259 + 0x27FFFFFFE0) / v262;
    v264 = 0x7FFFFFFF;
    goto LABEL_311;
  }
  v258 = *(unsigned int *)(a3 + 24);
  v260 = *(_QWORD *)(a3 + 8);
  v259 = *(_QWORD *)(a3 + 16);
  v261 = *(unsigned int *)(v260 + 4 * (0x33C617428BBAA70BLL % v258));
  if ((_DWORD)v261 == 0x7FFFFFFF)
  {
    LODWORD(v261) = 0x7FFFFFFF;
LABEL_302:
    v265 = v259 + 80 * v261;
    goto LABEL_306;
  }
  if (*(_BYTE *)(v259 + 80 * v261 + 12) == 82)
    goto LABEL_302;
  do
    LODWORD(v261) = *(_DWORD *)(v259 + 80 * v261 + 8) & 0x7FFFFFFF;
  while ((_DWORD)v261 != 0x7FFFFFFF && *(_BYTE *)(v259 + 80 * v261 + 12) != 82);
  v265 = v259 + 80 * v261;
LABEL_306:
  v262 = (float)*(int *)(a1 + 8);
  v263 = *(float *)(v265 + 48) / v262;
  v266 = *(unsigned int *)(v260 + 4 * (0x45F79258E41B3AE0 % v258));
  v264 = 0x7FFFFFFF;
  if ((_DWORD)v266 != 0x7FFFFFFF)
  {
    if (*(_BYTE *)(v259 + 80 * v266 + 12) == 83)
    {
LABEL_310:
      v264 = v266;
    }
    else
    {
      while (1)
      {
        LODWORD(v266) = *(_DWORD *)(v259 + 80 * v266 + 8) & 0x7FFFFFFF;
        v264 = 0x7FFFFFFF;
        if ((_DWORD)v266 == 0x7FFFFFFF)
          break;
        if (*(_BYTE *)(v259 + 80 * v266 + 12) == 83)
          goto LABEL_310;
      }
    }
  }
LABEL_311:
  re::DynamicString::appendf((re::DynamicString *)v246, "Protected Heaps : %.0f, Heap Memory [MB]: %.2f\n", v263, (float)((float)((float)(*(float *)(v259 + 80 * v264 + 48) / v262) * 0.00097656) * 0.00097656));
  if (*(_QWORD *)a3)
  {
    v267 = *(_QWORD *)(a3 + 16);
    v268 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0xAA2D7708F2A6F456 % *(unsigned int *)(a3 + 24)));
    v269 = 0x7FFFFFFF;
    if ((_DWORD)v268 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v267 + 80 * v268 + 12) == 90)
      {
LABEL_316:
        v269 = v268;
      }
      else
      {
        while (1)
        {
          LODWORD(v268) = *(_DWORD *)(v267 + 80 * v268 + 8) & 0x7FFFFFFF;
          v269 = 0x7FFFFFFF;
          if ((_DWORD)v268 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v267 + 80 * v268 + 12) == 90)
            goto LABEL_316;
        }
      }
    }
  }
  else
  {
    v267 = *(_QWORD *)(a3 + 16);
    v269 = 0x7FFFFFFF;
  }
  re::DynamicString::appendf((re::DynamicString *)v246, "Peak Frame Memory : %.2f\n", (float)((float)((float)(*(float *)(v267 + 80 * v269 + 48) / (float)*(int *)(a1 + 8)) * 0.00097656) * 0.00097656));
  if (*(_QWORD *)a3)
  {
    v270 = *(_QWORD *)(a3 + 16);
    v271 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0xAA2D7708F2A6F456 % *(unsigned int *)(a3 + 24)));
    v272 = 0x7FFFFFFF;
    if ((_DWORD)v271 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v270 + 80 * v271 + 12) == 90)
      {
LABEL_323:
        v272 = v271;
      }
      else
      {
        while (1)
        {
          LODWORD(v271) = *(_DWORD *)(v270 + 80 * v271 + 8) & 0x7FFFFFFF;
          v272 = 0x7FFFFFFF;
          if ((_DWORD)v271 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v270 + 80 * v271 + 12) == 90)
            goto LABEL_323;
        }
      }
    }
  }
  else
  {
    v270 = *(_QWORD *)(a3 + 16);
    v272 = 0x7FFFFFFF;
  }
  re::DynamicString::appendf((re::DynamicString *)v246, "Max of all Peaks : %.2f\n", (float)((float)(*(float *)(v270 + 80 * v272 + 64) * 0.00097656) * 0.00097656));
  if (!*(_QWORD *)a3)
  {
    v274 = *(_QWORD *)(a3 + 16);
    v277 = (float)*(int *)(a1 + 8);
    v278 = *(float *)(v274 + 0x27FFFFFFE0) / v277;
    v279 = 0x7FFFFFFF;
    goto LABEL_339;
  }
  v273 = *(unsigned int *)(a3 + 24);
  v275 = *(_QWORD *)(a3 + 8);
  v274 = *(_QWORD *)(a3 + 16);
  v276 = *(unsigned int *)(v275 + 4 * (0xE3841E098FBC6AD9 % v273));
  if ((_DWORD)v276 == 0x7FFFFFFF)
  {
    LODWORD(v276) = 0x7FFFFFFF;
LABEL_330:
    v280 = v274 + 80 * v276;
    goto LABEL_334;
  }
  if (*(_BYTE *)(v274 + 80 * v276 + 12) == 84)
    goto LABEL_330;
  do
    LODWORD(v276) = *(_DWORD *)(v274 + 80 * v276 + 8) & 0x7FFFFFFF;
  while ((_DWORD)v276 != 0x7FFFFFFF && *(_BYTE *)(v274 + 80 * v276 + 12) != 84);
  v280 = v274 + 80 * v276;
LABEL_334:
  v277 = (float)*(int *)(a1 + 8);
  v278 = *(float *)(v280 + 48) / v277;
  v281 = *(unsigned int *)(v275 + 4 * (0x8505BE27DEF25DA7 % v273));
  v279 = 0x7FFFFFFF;
  if ((_DWORD)v281 != 0x7FFFFFFF)
  {
    if (*(_BYTE *)(v274 + 80 * v281 + 12) == 85)
    {
LABEL_338:
      v279 = v281;
    }
    else
    {
      while (1)
      {
        LODWORD(v281) = *(_DWORD *)(v274 + 80 * v281 + 8) & 0x7FFFFFFF;
        v279 = 0x7FFFFFFF;
        if ((_DWORD)v281 == 0x7FFFFFFF)
          break;
        if (*(_BYTE *)(v274 + 80 * v281 + 12) == 85)
          goto LABEL_338;
      }
    }
  }
LABEL_339:
  re::DynamicString::appendf((re::DynamicString *)v246, "Textures: %.0f, Memoryless Textures: %.0f\n", v278, (float)(*(float *)(v274 + 80 * v279 + 48) / v277));
  if (*(_QWORD *)a3)
  {
    v282 = *(_QWORD *)(a3 + 16);
    v283 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0xCF15A836B33FD539 % *(unsigned int *)(a3 + 24)));
    v284 = 0x7FFFFFFF;
    if ((_DWORD)v283 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v282 + 80 * v283 + 12) == 87)
      {
LABEL_344:
        v284 = v283;
      }
      else
      {
        while (1)
        {
          LODWORD(v283) = *(_DWORD *)(v282 + 80 * v283 + 8) & 0x7FFFFFFF;
          v284 = 0x7FFFFFFF;
          if ((_DWORD)v283 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v282 + 80 * v283 + 12) == 87)
            goto LABEL_344;
        }
      }
    }
  }
  else
  {
    v282 = *(_QWORD *)(a3 + 16);
    v284 = 0x7FFFFFFF;
  }
  v285 = (float)((float)((float)(*(float *)(v282 + 80 * v284 + 48) / (float)*(int *)(a1 + 8)) * 0.00097656)
               * 0.00097656);
  v286 = 0x7FFFFFFF;
  if (*(_QWORD *)a3)
  {
    v287 = *(_DWORD *)(*(_QWORD *)(a3 + 8) + 4 * (0x2505F58C05E6526FuLL % *(unsigned int *)(a3 + 24)));
    if (v287 != 0x7FFFFFFF)
    {
      v286 = *(_DWORD *)(*(_QWORD *)(a3 + 8) + 4 * (0x2505F58C05E6526FuLL % *(unsigned int *)(a3 + 24)));
      if (*(_BYTE *)(v282 + 80 * v287 + 12) != 88)
      {
        while (1)
        {
          v286 = *(_DWORD *)(v282
                           + 80
                           * *(unsigned int *)(*(_QWORD *)(a3 + 8)
                                             + 4 * (0x2505F58C05E6526FuLL % *(unsigned int *)(a3 + 24)))
                           + 8) & 0x7FFFFFFF;
          if (v286 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v282 + 80 * v286 + 12) == 88)
            goto LABEL_353;
        }
        v286 = 0x7FFFFFFF;
      }
    }
  }
LABEL_353:
  re::DynamicString::appendf((re::DynamicString *)v246, "Texture Memory: %.2f, Largest Texture: %.2f\n", v285, (float)((float)(*(float *)(v282 + 80 * v286 + 44) * 0.00097656) * 0.00097656));
  if (*(_QWORD *)a3)
  {
    v288 = *(unsigned int *)(a3 + 24);
    v290 = *(_QWORD *)(a3 + 8);
    v289 = *(_QWORD *)(a3 + 16);
    v291 = *(_DWORD *)(v290 + 4 * (0x9E14C3B38F31B195 % v288));
    v292 = 0x7FFFFFFF;
    v293 = 0x7FFFFFFF;
    if (v291 != 0x7FFFFFFF)
    {
      v293 = *(_DWORD *)(v290 + 4 * (0x9E14C3B38F31B195 % v288));
      if (*(_BYTE *)(v289 + 80 * v291 + 12) != 86)
      {
        while (1)
        {
          v293 = *(_DWORD *)(v289 + 80 * *(unsigned int *)(v290 + 4 * (0x9E14C3B38F31B195 % v288)) + 8) & 0x7FFFFFFF;
          if (v293 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v289 + 80 * v293 + 12) == 86)
            goto LABEL_361;
        }
        v293 = 0x7FFFFFFF;
      }
    }
LABEL_361:
    v294 = *(float *)(v289 + 80 * v293 + 48);
    v295 = *(_DWORD *)(a1 + 8);
    v296 = *(unsigned int *)(v290 + 4 * (0x1D3169FBB198C267 % v288));
    if ((_DWORD)v296 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v289 + 80 * v296 + 12) == 89)
      {
LABEL_365:
        v292 = v296;
      }
      else
      {
        while (1)
        {
          LODWORD(v296) = *(_DWORD *)(v289 + 80 * v296 + 8) & 0x7FFFFFFF;
          v292 = 0x7FFFFFFF;
          if ((_DWORD)v296 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v289 + 80 * v296 + 12) == 89)
            goto LABEL_365;
        }
      }
    }
  }
  else
  {
    v289 = *(_QWORD *)(a3 + 16);
    v294 = *(float *)(v289 + 0x27FFFFFFE0);
    v295 = *(_DWORD *)(a1 + 8);
    v292 = 0x7FFFFFFF;
  }
  re::DynamicString::appendf((re::DynamicString *)v246, "Buffers : %.0f, Total Buffer Memory : %.2f\n", (float)(v294 / (float)v295), (float)((float)((float)(*(float *)(v289 + 80 * v292 + 48) / (float)v295) * 0.00097656) * 0.00097656));
  v297 = v241 + (v244 << 6);
  *(_QWORD *)&result = 0x3200000007;
  *(_QWORD *)(v297 + 48) = 0x3200000007;
  *(_DWORD *)(v297 + 56) = 256;
  return result;
}

re::FrameMemoryStats *re::FrameMemoryStats::FrameMemoryStats(re::FrameMemoryStats *this)
{
  *((_DWORD *)this + 2) = 10;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_DWORD *)this + 12) = 0;
  *(_QWORD *)((char *)this + 52) = 0x7FFFFFFFLL;
  *((_BYTE *)this + 64) = 0;
  *(_QWORD *)this = &off_24ED7F2E0;
  *((_QWORD *)this + 9) = 0;
  getpid();
  memorystatus_control();
  *((_QWORD *)this + 9) = 0;
  return this;
}

uint64_t re::FrameMemoryStats::dumpStatisticsInternal(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  _BYTE *v11;
  uint64_t result;
  mach_msg_type_number_t task_info_outCnt;
  integer_t task_info_out[36];
  unint64_t v15;
  uint64_t v16;

  LODWORD(v3) = 0x7FFFFFFF;
  if (*(_QWORD *)a2)
  {
    v4 = **(unsigned int **)(a2 + 8);
    if ((_DWORD)v4 != 0x7FFFFFFF)
    {
      v5 = *(_QWORD *)(a2 + 16);
      if (*(_DWORD *)(v5 + (v4 << 6) + 12))
      {
        v3 = **(unsigned int **)(a2 + 8);
        while (1)
        {
          v3 = *(_DWORD *)(v5 + (v3 << 6) + 8) & 0x7FFFFFFF;
          if ((_DWORD)v3 == 0x7FFFFFFF)
            break;
          if (!*(_DWORD *)(v5 + (v3 << 6) + 12))
            goto LABEL_10;
        }
        LODWORD(v3) = 0x7FFFFFFF;
      }
      else
      {
        LODWORD(v3) = **(_DWORD **)(a2 + 8);
      }
    }
  }
LABEL_10:
  v6 = *(_QWORD *)(a2 + 16);
  v7 = v3;
  v8 = v6 + ((unint64_t)v3 << 6);
  v9 = (_QWORD *)(v8 + 16);
  v10 = *(_QWORD *)(v8 + 24);
  if ((v10 & 1) != 0)
  {
    v9[1] = 1;
    v11 = (_BYTE *)v9[2];
  }
  else
  {
    *((_BYTE *)v9 + 8) = v10 & 1;
    v11 = (char *)v9 + 9;
  }
  *v11 = 0;
  re::DynamicString::append((re::DynamicString *)v9, "Process Memory Usage [MB]\n", 0x1AuLL);
  task_info_outCnt = 93;
  task_info(*MEMORY[0x24BDAEC58], 0x16u, task_info_out, &task_info_outCnt);
  re::DynamicString::appendf((re::DynamicString *)v9, "Dirty Memory Footprint : %.2f\n", (float)((float)((float)v15 * 0.00097656) * 0.00097656));
  re::DynamicString::appendf((re::DynamicString *)v9, "Peak Dirty Memory Footprint : %.2f\n", (float)((float)((float)v16 * 0.00097656) * 0.00097656));
  result = re::DynamicString::appendf((re::DynamicString *)v9, "Memory Limit : %.2f\n", (float)((float)((float)*(unint64_t *)(a1 + 72) * 0.00097656) * 0.00097656));
  *(_DWORD *)(v6 + (v7 << 6) + 56) = 512;
  return result;
}

uint64_t re::FrameThermalStats::dumpStatisticsInternal(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  _BYTE *v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  double v15;
  unint64_t v16;
  unint64_t v17;
  double v18;
  uint64_t v19;
  double v20;
  unint64_t v21;
  unint64_t v22;
  double v23;
  uint64_t v24;
  double v25;
  unint64_t v26;
  unint64_t v27;
  double v28;
  uint64_t v29;
  double v30;
  unint64_t v31;
  unint64_t v32;
  double v33;
  float v34;
  __int16 v35;
  float v36;
  float v37;
  float v38;
  uint64_t v39;
  double v40;
  unint64_t v41;
  unint64_t v42;
  double v43;
  float v44;
  uint64_t result;
  mach_timebase_info info;

  LODWORD(v3) = 0x7FFFFFFF;
  if (*(_QWORD *)a2)
  {
    v4 = **(unsigned int **)(a2 + 8);
    if ((_DWORD)v4 != 0x7FFFFFFF)
    {
      v5 = *(_QWORD *)(a2 + 16);
      if (*(_DWORD *)(v5 + (v4 << 6) + 12))
      {
        v3 = **(unsigned int **)(a2 + 8);
        while (1)
        {
          v3 = *(_DWORD *)(v5 + (v3 << 6) + 8) & 0x7FFFFFFF;
          if ((_DWORD)v3 == 0x7FFFFFFF)
            break;
          if (!*(_DWORD *)(v5 + (v3 << 6) + 12))
            goto LABEL_10;
        }
        LODWORD(v3) = 0x7FFFFFFF;
      }
      else
      {
        LODWORD(v3) = **(_DWORD **)(a2 + 8);
      }
    }
  }
LABEL_10:
  v6 = *(_QWORD *)(a2 + 16);
  v7 = v3;
  v8 = v6 + ((unint64_t)v3 << 6);
  v9 = (_QWORD *)(v8 + 16);
  v10 = *(_QWORD *)(v8 + 24);
  if ((v10 & 1) != 0)
  {
    v9[1] = 1;
    v11 = (_BYTE *)v9[2];
  }
  else
  {
    *((_BYTE *)v9 + 8) = v10 & 1;
    v11 = (char *)v9 + 9;
  }
  *v11 = 0;
  re::DynamicString::append((re::DynamicString *)v9, "App Thermal Info\n", 0x11uLL);
  objc_msgSend(MEMORY[0x24BDD1760], "processInfo");
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  v13 = objc_msgSend(v12, "thermalState");

  switch(v13)
  {
    case 2:
      re::DynamicString::appendf((re::DynamicString *)v9, "Thermal State : Serious\n");
      if (*(unsigned __int16 *)(a1 + 90) > 2u)
      {
LABEL_39:
        v35 = 3;
        goto LABEL_48;
      }
      v19 = mach_absolute_time();
      v20 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
      if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
      {
        if (mach_timebase_info(&info))
        {
          v23 = NAN;
LABEL_38:
          v36 = v23 / 1000000.0;
          *(float *)(a1 + 76) = v36;
          ++*(_WORD *)(a1 + 88);
          goto LABEL_39;
        }
        LODWORD(v21) = info.numer;
        LODWORD(v22) = info.denom;
        v20 = (double)v21 / (double)v22;
        re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v20;
      }
      v23 = v20 * (double)v19;
      goto LABEL_38;
    case 1:
      re::DynamicString::appendf((re::DynamicString *)v9, "Thermal State : Fair\n");
      if (*(unsigned __int16 *)(a1 + 90) < 3u)
      {
LABEL_43:
        v35 = 2;
        goto LABEL_48;
      }
      v24 = mach_absolute_time();
      v25 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
      if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
      {
        if (mach_timebase_info(&info))
        {
          v28 = NAN;
LABEL_42:
          v37 = v28 / 1000000.0;
          *(float *)(a1 + 80) = v37;
          goto LABEL_43;
        }
        LODWORD(v26) = info.numer;
        LODWORD(v27) = info.denom;
        v25 = (double)v26 / (double)v27;
        re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v25;
      }
      v28 = v25 * (double)v24;
      goto LABEL_42;
    case 0:
      re::DynamicString::appendf((re::DynamicString *)v9, "Thermal State : Nominal\n");
      if (*(unsigned __int16 *)(a1 + 90) < 3u)
      {
LABEL_35:
        v35 = 1;
        goto LABEL_48;
      }
      v14 = mach_absolute_time();
      v15 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
      if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
      {
        if (mach_timebase_info(&info))
        {
          v18 = NAN;
LABEL_34:
          v34 = v18 / 1000000.0;
          *(float *)(a1 + 80) = v34;
          goto LABEL_35;
        }
        LODWORD(v16) = info.numer;
        LODWORD(v17) = info.denom;
        v15 = (double)v16 / (double)v17;
        re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v15;
      }
      v18 = v15 * (double)v14;
      goto LABEL_34;
  }
  re::DynamicString::appendf((re::DynamicString *)v9, "Thermal State : Critical\n");
  if (*(unsigned __int16 *)(a1 + 90) > 2u)
    goto LABEL_47;
  v29 = mach_absolute_time();
  v30 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale >= 0.0)
    goto LABEL_45;
  if (!mach_timebase_info(&info))
  {
    LODWORD(v31) = info.numer;
    LODWORD(v32) = info.denom;
    v30 = (double)v31 / (double)v32;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v30;
LABEL_45:
    v33 = v30 * (double)v29;
    goto LABEL_46;
  }
  v33 = NAN;
LABEL_46:
  v38 = v33 / 1000000.0;
  *(float *)(a1 + 76) = v38;
  ++*(_WORD *)(a1 + 88);
LABEL_47:
  v35 = 4;
LABEL_48:
  *(_WORD *)(a1 + 90) = v35;
  v39 = mach_absolute_time();
  v40 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v43 = NAN;
      goto LABEL_53;
    }
    LODWORD(v41) = info.numer;
    LODWORD(v42) = info.denom;
    v40 = (double)v41 / (double)v42;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v40;
  }
  v43 = v40 * (double)v39;
LABEL_53:
  v44 = v43 / 1000000.0 - *(float *)(a1 + 84);
  *(float *)(a1 + 68) = v44;
  re::DynamicString::appendf((re::DynamicString *)v9, "Time Since App Launch : %.2f sec\n", (float)(v44 / 1000.0));
  if (*(unsigned __int16 *)(a1 + 90) > 2u)
    result = re::DynamicString::appendf((re::DynamicString *)v9, "Thermally Throttled in %.2f sec\n");
  else
    result = re::DynamicString::appendf((re::DynamicString *)v9, "Not Thermally Throttled\n");
  *(_DWORD *)(v6 + (v7 << 6) + 56) = 1024;
  return result;
}

double re::FrameSceneUnderstandingStats::dumpStatisticsInternal(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  _BYTE *v14;
  unsigned int v15;
  unsigned int v16;
  uint64_t v17;
  float v18;
  int v19;
  double v20;
  unint64_t v21;
  unint64_t v22;
  double v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  float v27;
  int v28;
  double v29;
  unint64_t v30;
  unint64_t v31;
  double v32;
  uint64_t v33;
  uint64_t v34;
  unsigned int v35;
  float v36;
  double v37;
  unint64_t v38;
  unint64_t v39;
  double v40;
  uint64_t v41;
  uint64_t v42;
  unsigned int v43;
  float v44;
  double v45;
  double v46;
  unint64_t v47;
  unint64_t v48;
  double v49;
  uint64_t v50;
  uint64_t v51;
  unsigned int v52;
  float v53;
  double v54;
  unint64_t v55;
  unint64_t v56;
  double v57;
  uint64_t v58;
  uint64_t v59;
  unsigned int v60;
  float v61;
  double v62;
  double v63;
  unint64_t v64;
  unint64_t v65;
  double v66;
  unint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  float v71;
  float v72;
  unsigned int v73;
  float v74;
  unsigned int v75;
  unsigned int v76;
  unsigned int v77;
  unsigned int v78;
  uint64_t v79;
  float v80;
  double v81;
  double v82;
  uint64_t v83;
  _BOOL8 v84;
  uint64_t v85;
  uint64_t i;
  unsigned int v87;
  uint64_t v88;
  uint64_t v89;
  _QWORD *v90;
  uint64_t v91;
  _BYTE *v92;
  uint64_t v93;
  uint64_t v94;
  unsigned int v95;
  float v96;
  double v97;
  unint64_t v98;
  unint64_t v99;
  double v100;
  uint64_t v101;
  uint64_t v102;
  unsigned int v103;
  float v104;
  double v105;
  double v106;
  unint64_t v107;
  unint64_t v108;
  double v109;
  uint64_t v110;
  uint64_t v111;
  unsigned int v112;
  float v113;
  double v114;
  unint64_t v115;
  unint64_t v116;
  double v117;
  uint64_t v118;
  uint64_t v119;
  unsigned int v120;
  float v121;
  double v122;
  double v123;
  unint64_t v124;
  unint64_t v125;
  double v126;
  uint64_t v127;
  uint64_t v128;
  unsigned int v129;
  float v130;
  double v131;
  unint64_t v132;
  unint64_t v133;
  double v134;
  uint64_t v135;
  uint64_t v136;
  unsigned int v137;
  float v138;
  double v139;
  double v140;
  unint64_t v141;
  unint64_t v142;
  double v143;
  uint64_t v144;
  uint64_t v145;
  unsigned int v146;
  float v147;
  double v148;
  unint64_t v149;
  unint64_t v150;
  double v151;
  uint64_t v152;
  uint64_t v153;
  unsigned int v154;
  float v155;
  double v156;
  double v157;
  unint64_t v158;
  unint64_t v159;
  double v160;
  unint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  float v165;
  float v166;
  unsigned int v167;
  uint64_t v168;
  unsigned int v169;
  unsigned int v170;
  float v171;
  unsigned int v172;
  unsigned int v173;
  uint64_t v174;
  uint64_t v175;
  double result;
  int v177;
  mach_timebase_info info[2];
  __int128 v179;
  uint64_t v180;
  int v181;

  LODWORD(v6) = 0x7FFFFFFF;
  if (*(_QWORD *)a2)
  {
    v7 = **(unsigned int **)(a2 + 8);
    if ((_DWORD)v7 != 0x7FFFFFFF)
    {
      v8 = *(_QWORD *)(a2 + 16);
      if (*(_DWORD *)(v8 + (v7 << 6) + 12))
      {
        v6 = **(unsigned int **)(a2 + 8);
        while (1)
        {
          v6 = *(_DWORD *)(v8 + (v6 << 6) + 8) & 0x7FFFFFFF;
          if ((_DWORD)v6 == 0x7FFFFFFF)
            break;
          if (!*(_DWORD *)(v8 + (v6 << 6) + 12))
            goto LABEL_10;
        }
        LODWORD(v6) = 0x7FFFFFFF;
      }
      else
      {
        LODWORD(v6) = **(_DWORD **)(a2 + 8);
      }
    }
  }
LABEL_10:
  v9 = *(_QWORD *)(a2 + 16);
  v10 = v6;
  v11 = v9 + ((unint64_t)v6 << 6);
  v12 = (_QWORD *)(v11 + 16);
  v13 = *(_QWORD *)(v11 + 24);
  if ((v13 & 1) != 0)
  {
    v12[1] = 1;
    v14 = (_BYTE *)v12[2];
  }
  else
  {
    *((_BYTE *)v12 + 8) = v13 & 1;
    v14 = (char *)v12 + 9;
  }
  *v14 = 0;
  re::DynamicString::appendf((re::DynamicString *)v12, "Scene Understanding Metrics (Profiler Pass)\n");
  v15 = 0x7FFFFFFF;
  if (*(_QWORD *)a3)
  {
    v16 = *(_DWORD *)(*(_QWORD *)(a3 + 8) + 4 * (0xAF26563F2EC4C8E6 % *(unsigned int *)(a3 + 24)));
    if (v16 != 0x7FFFFFFF)
    {
      v17 = *(_QWORD *)(a3 + 16);
      v15 = *(_DWORD *)(*(_QWORD *)(a3 + 8) + 4 * (0xAF26563F2EC4C8E6 % *(unsigned int *)(a3 + 24)));
      if (*(unsigned __int8 *)(v17 + 80 * v16 + 12) != 128)
      {
        while (1)
        {
          v15 = *(_DWORD *)(v17
                          + 80
                          * *(unsigned int *)(*(_QWORD *)(a3 + 8)
                                            + 4 * (0xAF26563F2EC4C8E6 % *(unsigned int *)(a3 + 24)))
                          + 8) & 0x7FFFFFFF;
          if (v15 == 0x7FFFFFFF)
            break;
          if (*(unsigned __int8 *)(v17 + 80 * v15 + 12) == 128)
            goto LABEL_20;
        }
        v15 = 0x7FFFFFFF;
      }
    }
  }
LABEL_20:
  v18 = *(float *)(*(_QWORD *)(a3 + 16) + 80 * v15 + 48);
  v19 = *(_DWORD *)(a1 + 8);
  v20 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      v23 = NAN;
      goto LABEL_25;
    }
    LODWORD(v21) = info[0].numer;
    LODWORD(v22) = info[0].denom;
    v20 = (double)v21 / (double)v22;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v20;
  }
  v23 = v20 * (double)(unint64_t)(float)(v18 / (float)v19);
LABEL_25:
  re::DynamicString::appendf((re::DynamicString *)v12, "SUProcessingSystem Update (ms): %.2f\n", v23 / 1000000.0);
  if (*(_QWORD *)a3)
  {
    v24 = *(_QWORD *)(a3 + 16);
    v25 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x89607B27DA843F55 % *(unsigned int *)(a3 + 24)));
    v26 = 0x7FFFFFFF;
    if ((_DWORD)v25 != 0x7FFFFFFF)
    {
      if (*(unsigned __int8 *)(v24 + 80 * v25 + 12) == 129)
      {
LABEL_30:
        v26 = v25;
      }
      else
      {
        while (1)
        {
          LODWORD(v25) = *(_DWORD *)(v24 + 80 * v25 + 8) & 0x7FFFFFFF;
          v26 = 0x7FFFFFFF;
          if ((_DWORD)v25 == 0x7FFFFFFF)
            break;
          if (*(unsigned __int8 *)(v24 + 80 * v25 + 12) == 129)
            goto LABEL_30;
        }
      }
    }
  }
  else
  {
    v24 = *(_QWORD *)(a3 + 16);
    v26 = 0x7FFFFFFF;
  }
  v27 = *(float *)(v24 + 80 * v26 + 48);
  v28 = *(_DWORD *)(a1 + 8);
  v29 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      v32 = NAN;
      goto LABEL_37;
    }
    LODWORD(v30) = info[0].numer;
    LODWORD(v31) = info[0].denom;
    v29 = (double)v30 / (double)v31;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v29;
  }
  v32 = v29 * (double)(unint64_t)(float)(v27 / (float)v28);
LABEL_37:
  re::DynamicString::appendf((re::DynamicString *)v12, "SUMeshSystem Update (ms): %.2f\n", v32 / 1000000.0);
  re::DynamicString::appendf((re::DynamicString *)v12, "Physics Chunk Creation (ms)\n");
  if (*(_QWORD *)a3)
  {
    v33 = *(_QWORD *)(a3 + 16);
    v34 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x629BE6C3EEC6E119uLL % *(unsigned int *)(a3 + 24)));
    v35 = 0x7FFFFFFF;
    if ((_DWORD)v34 != 0x7FFFFFFF)
    {
      if (*(unsigned __int8 *)(v33 + 80 * v34 + 12) == 133)
      {
LABEL_42:
        v35 = v34;
      }
      else
      {
        while (1)
        {
          LODWORD(v34) = *(_DWORD *)(v33 + 80 * v34 + 8) & 0x7FFFFFFF;
          v35 = 0x7FFFFFFF;
          if ((_DWORD)v34 == 0x7FFFFFFF)
            break;
          if (*(unsigned __int8 *)(v33 + 80 * v34 + 12) == 133)
            goto LABEL_42;
        }
      }
    }
  }
  else
  {
    v33 = *(_QWORD *)(a3 + 16);
    v35 = 0x7FFFFFFF;
  }
  v36 = *(float *)(v33 + 80 * v35 + 56);
  v37 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      v40 = NAN;
      goto LABEL_49;
    }
    LODWORD(v38) = info[0].numer;
    LODWORD(v39) = info[0].denom;
    v37 = (double)v38 / (double)v39;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v37;
  }
  v40 = v37 * (double)(unint64_t)v36;
LABEL_49:
  if (*(_QWORD *)a3)
  {
    v41 = *(_QWORD *)(a3 + 16);
    v42 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x629BE6C3EEC6E119uLL % *(unsigned int *)(a3 + 24)));
    v43 = 0x7FFFFFFF;
    if ((_DWORD)v42 != 0x7FFFFFFF)
    {
      if (*(unsigned __int8 *)(v41 + 80 * v42 + 12) == 133)
      {
LABEL_54:
        v43 = v42;
      }
      else
      {
        while (1)
        {
          LODWORD(v42) = *(_DWORD *)(v41 + 80 * v42 + 8) & 0x7FFFFFFF;
          v43 = 0x7FFFFFFF;
          if ((_DWORD)v42 == 0x7FFFFFFF)
            break;
          if (*(unsigned __int8 *)(v41 + 80 * v42 + 12) == 133)
            goto LABEL_54;
        }
      }
    }
  }
  else
  {
    v41 = *(_QWORD *)(a3 + 16);
    v43 = 0x7FFFFFFF;
  }
  v44 = *(float *)(v41 + 80 * v43 + 44);
  v45 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  v46 = v40 / 1000000.0;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      v49 = NAN;
      goto LABEL_61;
    }
    LODWORD(v47) = info[0].numer;
    LODWORD(v48) = info[0].denom;
    v45 = (double)v47 / (double)v48;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v45;
  }
  v49 = v45 * (double)(unint64_t)v44;
LABEL_61:
  re::DynamicString::appendf((re::DynamicString *)v12, "Avg : %.3f, Max : %.3f\n", v46, v49 / 1000000.0);
  re::DynamicString::appendf((re::DynamicString *)v12, "Physics Chunk Update (ms)\n");
  if (*(_QWORD *)a3)
  {
    v50 = *(_QWORD *)(a3 + 16);
    v51 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0xDDA64E04828F136DLL % *(unsigned int *)(a3 + 24)));
    v52 = 0x7FFFFFFF;
    if ((_DWORD)v51 != 0x7FFFFFFF)
    {
      if (*(unsigned __int8 *)(v50 + 80 * v51 + 12) == 134)
      {
LABEL_66:
        v52 = v51;
      }
      else
      {
        while (1)
        {
          LODWORD(v51) = *(_DWORD *)(v50 + 80 * v51 + 8) & 0x7FFFFFFF;
          v52 = 0x7FFFFFFF;
          if ((_DWORD)v51 == 0x7FFFFFFF)
            break;
          if (*(unsigned __int8 *)(v50 + 80 * v51 + 12) == 134)
            goto LABEL_66;
        }
      }
    }
  }
  else
  {
    v50 = *(_QWORD *)(a3 + 16);
    v52 = 0x7FFFFFFF;
  }
  v53 = *(float *)(v50 + 80 * v52 + 56);
  v54 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      v57 = NAN;
      goto LABEL_73;
    }
    LODWORD(v55) = info[0].numer;
    LODWORD(v56) = info[0].denom;
    v54 = (double)v55 / (double)v56;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v54;
  }
  v57 = v54 * (double)(unint64_t)v53;
LABEL_73:
  if (*(_QWORD *)a3)
  {
    v58 = *(_QWORD *)(a3 + 16);
    v59 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0xDDA64E04828F136DLL % *(unsigned int *)(a3 + 24)));
    v60 = 0x7FFFFFFF;
    if ((_DWORD)v59 != 0x7FFFFFFF)
    {
      if (*(unsigned __int8 *)(v58 + 80 * v59 + 12) == 134)
      {
LABEL_78:
        v60 = v59;
      }
      else
      {
        while (1)
        {
          LODWORD(v59) = *(_DWORD *)(v58 + 80 * v59 + 8) & 0x7FFFFFFF;
          v60 = 0x7FFFFFFF;
          if ((_DWORD)v59 == 0x7FFFFFFF)
            break;
          if (*(unsigned __int8 *)(v58 + 80 * v59 + 12) == 134)
            goto LABEL_78;
        }
      }
    }
  }
  else
  {
    v58 = *(_QWORD *)(a3 + 16);
    v60 = 0x7FFFFFFF;
  }
  v61 = *(float *)(v58 + 80 * v60 + 44);
  v62 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  v63 = v57 / 1000000.0;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      v66 = NAN;
      goto LABEL_85;
    }
    LODWORD(v64) = info[0].numer;
    LODWORD(v65) = info[0].denom;
    v62 = (double)v64 / (double)v65;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v62;
  }
  v66 = v62 * (double)(unint64_t)v61;
LABEL_85:
  re::DynamicString::appendf((re::DynamicString *)v12, "Avg : %.3f, Max : %.3f\n", v63, v66 / 1000000.0);
  if (*(_QWORD *)a3)
  {
    v67 = *(unsigned int *)(a3 + 24);
    v69 = *(_QWORD *)(a3 + 8);
    v68 = *(_QWORD *)(a3 + 16);
    v70 = *(unsigned int *)(v69 + 4 * (0x3E784199B71EA792 % v67));
    if ((_DWORD)v70 == 0x7FFFFFFF)
    {
      LODWORD(v70) = 0x7FFFFFFF;
    }
    else if (*(unsigned __int8 *)(v68 + 80 * v70 + 12) != 136)
    {
      do
        LODWORD(v70) = *(_DWORD *)(v68 + 80 * v70 + 8) & 0x7FFFFFFF;
      while ((_DWORD)v70 != 0x7FFFFFFF && *(unsigned __int8 *)(v68 + 80 * v70 + 12) != 136);
    }
    v74 = *(float *)(v68 + 80 * v70 + 48);
    v75 = *(_DWORD *)(v69 + 4 * (0x1D08970C8BCEA7C1 % v67));
    v76 = 0x7FFFFFFF;
    if (v75 != 0x7FFFFFFF)
    {
      v76 = *(_DWORD *)(v69 + 4 * (0x1D08970C8BCEA7C1 % v67));
      if (*(unsigned __int8 *)(v68 + 80 * v75 + 12) != 138)
      {
        while (1)
        {
          v76 = *(_DWORD *)(v68 + 80 * *(unsigned int *)(v69 + 4 * (0x1D08970C8BCEA7C1 % v67)) + 8) & 0x7FFFFFFF;
          if (v76 == 0x7FFFFFFF)
            break;
          if (*(unsigned __int8 *)(v68 + 80 * v76 + 12) == 138)
            goto LABEL_98;
        }
        v76 = 0x7FFFFFFF;
      }
    }
LABEL_98:
    v77 = *(_DWORD *)(v69 + 4 * (0x72025A4FB5A542DBLL % v67));
    v73 = 0x7FFFFFFF;
    v78 = 0x7FFFFFFF;
    if (v77 != 0x7FFFFFFF)
    {
      v78 = *(_DWORD *)(v69 + 4 * (0x72025A4FB5A542DBLL % v67));
      if (*(unsigned __int8 *)(v68 + 80 * v77 + 12) != 137)
      {
        while (1)
        {
          v78 = *(_DWORD *)(v68 + 80 * *(unsigned int *)(v69 + 4 * (0x72025A4FB5A542DBLL % v67)) + 8) & 0x7FFFFFFF;
          if (v78 == 0x7FFFFFFF)
            break;
          if (*(unsigned __int8 *)(v68 + 80 * v78 + 12) == 137)
            goto LABEL_104;
        }
        v78 = 0x7FFFFFFF;
      }
    }
LABEL_104:
    v72 = v74 - *(float *)(v68 + 80 * v76 + 48);
    v71 = *(float *)(v68 + 80 * v78 + 48);
    v79 = *(unsigned int *)(v69 + 4 * (0x5CB85FD265949FD2 % v67));
    if ((_DWORD)v79 != 0x7FFFFFFF)
    {
      if (*(unsigned __int8 *)(v68 + 80 * v79 + 12) == 139)
      {
LABEL_108:
        v73 = v79;
      }
      else
      {
        while (1)
        {
          LODWORD(v79) = *(_DWORD *)(v68 + 80 * v79 + 8) & 0x7FFFFFFF;
          v73 = 0x7FFFFFFF;
          if ((_DWORD)v79 == 0x7FFFFFFF)
            break;
          if (*(unsigned __int8 *)(v68 + 80 * v79 + 12) == 139)
            goto LABEL_108;
        }
      }
    }
  }
  else
  {
    v68 = *(_QWORD *)(a3 + 16);
    v71 = *(float *)(v68 + 0x27FFFFFFE0);
    v72 = v71 - v71;
    v73 = 0x7FFFFFFF;
  }
  v80 = v71 - *(float *)(v68 + 80 * v73 + 48);
  v81 = v72;
  if (v81 < 0.0)
    v81 = 0.0;
  v82 = v80;
  if (v82 < 0.0)
    v82 = 0.0;
  re::DynamicString::appendf((re::DynamicString *)v12, "SU Vertices: %.2f, SU Triangles: %.2f\n", v81, v82);
  v83 = v9 + (v10 << 6);
  *(_DWORD *)(v83 + 56) = 2048;
  *(_QWORD *)(v83 + 48) = 0x2D00000008;
  info[0].numer = 1;
  v84 = re::HashTable<unsigned int,re::FrameStatisticsOutput,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::containsKey(a2, (unsigned int *)info);
  if (!v84)
  {
    *(_OWORD *)&info[0].numer = 0u;
    v179 = 0u;
    re::DynamicString::setCapacity(info, 0);
    v180 = 0x2800000006;
    v181 = 1;
    v177 = 1;
    re::HashTable<unsigned int,re::FrameStatisticsOutput,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::add<re::FrameStatisticsOutput&>(a2, &v177, (re::DynamicString *)info);
    if (info[0])
    {
      if ((info[1].numer & 1) != 0)
        (*(void (**)(void))(**(_QWORD **)info + 40))();
    }
  }
  if (*(_QWORD *)a2)
  {
    v85 = *(_QWORD *)(a2 + 16);
    for (i = *(unsigned int *)(*(_QWORD *)(a2 + 8) + 4 * (0x5692161D100B05E5uLL % *(unsigned int *)(a2 + 24)));
          ;
          i = *(_DWORD *)(v85 + (i << 6) + 8) & 0x7FFFFFFF)
    {
      v87 = 0x7FFFFFFF;
      if ((_DWORD)i == 0x7FFFFFFF)
        break;
      if (*(_DWORD *)(v85 + (i << 6) + 12) == 1)
      {
        v87 = i;
        break;
      }
    }
  }
  else
  {
    v85 = *(_QWORD *)(a2 + 16);
    v87 = 0x7FFFFFFF;
  }
  v88 = v87;
  v89 = v85 + ((unint64_t)v87 << 6);
  v90 = (_QWORD *)(v89 + 16);
  v91 = *(_QWORD *)(v89 + 24);
  if ((v91 & 1) != 0)
  {
    v90[1] = 1;
    v92 = (_BYTE *)v90[2];
  }
  else
  {
    *((_BYTE *)v90 + 8) = v91 & 1;
    v92 = (char *)v90 + 9;
  }
  *v92 = 0;
  re::DynamicString::appendf((re::DynamicString *)v90, "Scene Understanding Metrics (App Lifetime)\n");
  re::DynamicString::appendf((re::DynamicString *)v90, "SUProcessingSystem Update (s)\n");
  if (*(_QWORD *)a3)
  {
    v93 = *(_QWORD *)(a3 + 16);
    v94 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0xAF26563F2EC4C8E6 % *(unsigned int *)(a3 + 24)));
    v95 = 0x7FFFFFFF;
    if ((_DWORD)v94 != 0x7FFFFFFF)
    {
      if (*(unsigned __int8 *)(v93 + 80 * v94 + 12) == 128)
      {
LABEL_132:
        v95 = v94;
      }
      else
      {
        while (1)
        {
          LODWORD(v94) = *(_DWORD *)(v93 + 80 * v94 + 8) & 0x7FFFFFFF;
          v95 = 0x7FFFFFFF;
          if ((_DWORD)v94 == 0x7FFFFFFF)
            break;
          if (*(unsigned __int8 *)(v93 + 80 * v94 + 12) == 128)
            goto LABEL_132;
        }
      }
    }
  }
  else
  {
    v93 = *(_QWORD *)(a3 + 16);
    v95 = 0x7FFFFFFF;
  }
  v96 = *(float *)(v93 + 80 * v95 + 76);
  v97 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      v100 = NAN;
      goto LABEL_139;
    }
    LODWORD(v98) = info[0].numer;
    LODWORD(v99) = info[0].denom;
    v97 = (double)v98 / (double)v99;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v97;
  }
  v100 = v97 * (double)(unint64_t)(float)(v96 / 1000.0);
LABEL_139:
  if (*(_QWORD *)a3)
  {
    v101 = *(_QWORD *)(a3 + 16);
    v102 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0xAF26563F2EC4C8E6 % *(unsigned int *)(a3 + 24)));
    v103 = 0x7FFFFFFF;
    if ((_DWORD)v102 != 0x7FFFFFFF)
    {
      if (*(unsigned __int8 *)(v101 + 80 * v102 + 12) == 128)
      {
LABEL_144:
        v103 = v102;
      }
      else
      {
        while (1)
        {
          LODWORD(v102) = *(_DWORD *)(v101 + 80 * v102 + 8) & 0x7FFFFFFF;
          v103 = 0x7FFFFFFF;
          if ((_DWORD)v102 == 0x7FFFFFFF)
            break;
          if (*(unsigned __int8 *)(v101 + 80 * v102 + 12) == 128)
            goto LABEL_144;
        }
      }
    }
  }
  else
  {
    v101 = *(_QWORD *)(a3 + 16);
    v103 = 0x7FFFFFFF;
  }
  v104 = *(float *)(v101 + 80 * v103 + 64);
  v105 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  v106 = v100 / 1000000.0;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      v109 = NAN;
      goto LABEL_151;
    }
    LODWORD(v107) = info[0].numer;
    LODWORD(v108) = info[0].denom;
    v105 = (double)v107 / (double)v108;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v105;
  }
  v109 = v105 * (double)(unint64_t)(float)(v104 / 1000.0);
LABEL_151:
  re::DynamicString::appendf((re::DynamicString *)v90, "Avg : %.3f, Max : %.3f\n", v106, v109 / 1000000.0);
  re::DynamicString::appendf((re::DynamicString *)v90, "SUMeshSystem Update (s)\n");
  if (*(_QWORD *)a3)
  {
    v110 = *(_QWORD *)(a3 + 16);
    v111 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x89607B27DA843F55 % *(unsigned int *)(a3 + 24)));
    v112 = 0x7FFFFFFF;
    if ((_DWORD)v111 != 0x7FFFFFFF)
    {
      if (*(unsigned __int8 *)(v110 + 80 * v111 + 12) == 129)
      {
LABEL_156:
        v112 = v111;
      }
      else
      {
        while (1)
        {
          LODWORD(v111) = *(_DWORD *)(v110 + 80 * v111 + 8) & 0x7FFFFFFF;
          v112 = 0x7FFFFFFF;
          if ((_DWORD)v111 == 0x7FFFFFFF)
            break;
          if (*(unsigned __int8 *)(v110 + 80 * v111 + 12) == 129)
            goto LABEL_156;
        }
      }
    }
  }
  else
  {
    v110 = *(_QWORD *)(a3 + 16);
    v112 = 0x7FFFFFFF;
  }
  v113 = *(float *)(v110 + 80 * v112 + 76);
  v114 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      v117 = NAN;
      goto LABEL_163;
    }
    LODWORD(v115) = info[0].numer;
    LODWORD(v116) = info[0].denom;
    v114 = (double)v115 / (double)v116;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v114;
  }
  v117 = v114 * (double)(unint64_t)(float)(v113 / 1000.0);
LABEL_163:
  if (*(_QWORD *)a3)
  {
    v118 = *(_QWORD *)(a3 + 16);
    v119 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x89607B27DA843F55 % *(unsigned int *)(a3 + 24)));
    v120 = 0x7FFFFFFF;
    if ((_DWORD)v119 != 0x7FFFFFFF)
    {
      if (*(unsigned __int8 *)(v118 + 80 * v119 + 12) == 129)
      {
LABEL_168:
        v120 = v119;
      }
      else
      {
        while (1)
        {
          LODWORD(v119) = *(_DWORD *)(v118 + 80 * v119 + 8) & 0x7FFFFFFF;
          v120 = 0x7FFFFFFF;
          if ((_DWORD)v119 == 0x7FFFFFFF)
            break;
          if (*(unsigned __int8 *)(v118 + 80 * v119 + 12) == 129)
            goto LABEL_168;
        }
      }
    }
  }
  else
  {
    v118 = *(_QWORD *)(a3 + 16);
    v120 = 0x7FFFFFFF;
  }
  v121 = *(float *)(v118 + 80 * v120 + 64);
  v122 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  v123 = v117 / 1000000.0;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      v126 = NAN;
      goto LABEL_175;
    }
    LODWORD(v124) = info[0].numer;
    LODWORD(v125) = info[0].denom;
    v122 = (double)v124 / (double)v125;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v122;
  }
  v126 = v122 * (double)(unint64_t)(float)(v121 / 1000.0);
LABEL_175:
  re::DynamicString::appendf((re::DynamicString *)v90, "Avg : %.3f, Max : %.3f\n", v123, v126 / 1000000.0);
  re::DynamicString::appendf((re::DynamicString *)v90, "Physics Chunk Creation (s)\n");
  if (*(_QWORD *)a3)
  {
    v127 = *(_QWORD *)(a3 + 16);
    v128 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x629BE6C3EEC6E119uLL % *(unsigned int *)(a3 + 24)));
    v129 = 0x7FFFFFFF;
    if ((_DWORD)v128 != 0x7FFFFFFF)
    {
      if (*(unsigned __int8 *)(v127 + 80 * v128 + 12) == 133)
      {
LABEL_180:
        v129 = v128;
      }
      else
      {
        while (1)
        {
          LODWORD(v128) = *(_DWORD *)(v127 + 80 * v128 + 8) & 0x7FFFFFFF;
          v129 = 0x7FFFFFFF;
          if ((_DWORD)v128 == 0x7FFFFFFF)
            break;
          if (*(unsigned __int8 *)(v127 + 80 * v128 + 12) == 133)
            goto LABEL_180;
        }
      }
    }
  }
  else
  {
    v127 = *(_QWORD *)(a3 + 16);
    v129 = 0x7FFFFFFF;
  }
  v130 = *(float *)(v127 + 80 * v129 + 76);
  v131 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      v134 = NAN;
      goto LABEL_187;
    }
    LODWORD(v132) = info[0].numer;
    LODWORD(v133) = info[0].denom;
    v131 = (double)v132 / (double)v133;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v131;
  }
  v134 = v131 * (double)(unint64_t)(float)(v130 / 1000.0);
LABEL_187:
  if (*(_QWORD *)a3)
  {
    v135 = *(_QWORD *)(a3 + 16);
    v136 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x629BE6C3EEC6E119uLL % *(unsigned int *)(a3 + 24)));
    v137 = 0x7FFFFFFF;
    if ((_DWORD)v136 != 0x7FFFFFFF)
    {
      if (*(unsigned __int8 *)(v135 + 80 * v136 + 12) == 133)
      {
LABEL_192:
        v137 = v136;
      }
      else
      {
        while (1)
        {
          LODWORD(v136) = *(_DWORD *)(v135 + 80 * v136 + 8) & 0x7FFFFFFF;
          v137 = 0x7FFFFFFF;
          if ((_DWORD)v136 == 0x7FFFFFFF)
            break;
          if (*(unsigned __int8 *)(v135 + 80 * v136 + 12) == 133)
            goto LABEL_192;
        }
      }
    }
  }
  else
  {
    v135 = *(_QWORD *)(a3 + 16);
    v137 = 0x7FFFFFFF;
  }
  v138 = *(float *)(v135 + 80 * v137 + 64);
  v139 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  v140 = v134 / 1000000.0;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      v143 = NAN;
      goto LABEL_199;
    }
    LODWORD(v141) = info[0].numer;
    LODWORD(v142) = info[0].denom;
    v139 = (double)v141 / (double)v142;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v139;
  }
  v143 = v139 * (double)(unint64_t)(float)(v138 / 1000.0);
LABEL_199:
  re::DynamicString::appendf((re::DynamicString *)v90, "Avg : %.3f, Max : %.3f\n", v140, v143 / 1000000.0);
  re::DynamicString::appendf((re::DynamicString *)v90, "Physics Chunk Update (s)\n");
  if (*(_QWORD *)a3)
  {
    v144 = *(_QWORD *)(a3 + 16);
    v145 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0xDDA64E04828F136DLL % *(unsigned int *)(a3 + 24)));
    v146 = 0x7FFFFFFF;
    if ((_DWORD)v145 != 0x7FFFFFFF)
    {
      if (*(unsigned __int8 *)(v144 + 80 * v145 + 12) == 134)
      {
LABEL_204:
        v146 = v145;
      }
      else
      {
        while (1)
        {
          LODWORD(v145) = *(_DWORD *)(v144 + 80 * v145 + 8) & 0x7FFFFFFF;
          v146 = 0x7FFFFFFF;
          if ((_DWORD)v145 == 0x7FFFFFFF)
            break;
          if (*(unsigned __int8 *)(v144 + 80 * v145 + 12) == 134)
            goto LABEL_204;
        }
      }
    }
  }
  else
  {
    v144 = *(_QWORD *)(a3 + 16);
    v146 = 0x7FFFFFFF;
  }
  v147 = *(float *)(v144 + 80 * v146 + 76);
  v148 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      v151 = NAN;
      goto LABEL_211;
    }
    LODWORD(v149) = info[0].numer;
    LODWORD(v150) = info[0].denom;
    v148 = (double)v149 / (double)v150;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v148;
  }
  v151 = v148 * (double)(unint64_t)(float)(v147 / 1000.0);
LABEL_211:
  if (*(_QWORD *)a3)
  {
    v152 = *(_QWORD *)(a3 + 16);
    v153 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0xDDA64E04828F136DLL % *(unsigned int *)(a3 + 24)));
    v154 = 0x7FFFFFFF;
    if ((_DWORD)v153 != 0x7FFFFFFF)
    {
      if (*(unsigned __int8 *)(v152 + 80 * v153 + 12) == 134)
      {
LABEL_216:
        v154 = v153;
      }
      else
      {
        while (1)
        {
          LODWORD(v153) = *(_DWORD *)(v152 + 80 * v153 + 8) & 0x7FFFFFFF;
          v154 = 0x7FFFFFFF;
          if ((_DWORD)v153 == 0x7FFFFFFF)
            break;
          if (*(unsigned __int8 *)(v152 + 80 * v153 + 12) == 134)
            goto LABEL_216;
        }
      }
    }
  }
  else
  {
    v152 = *(_QWORD *)(a3 + 16);
    v154 = 0x7FFFFFFF;
  }
  v155 = *(float *)(v152 + 80 * v154 + 64);
  v156 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  v157 = v151 / 1000000.0;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(info))
    {
      v160 = NAN;
      goto LABEL_223;
    }
    LODWORD(v158) = info[0].numer;
    LODWORD(v159) = info[0].denom;
    v156 = (double)v158 / (double)v159;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v156;
  }
  v160 = v156 * (double)(unint64_t)(float)(v155 / 1000.0);
LABEL_223:
  re::DynamicString::appendf((re::DynamicString *)v90, "Avg : %.3f, Max : %.3f\n", v157, v160 / 1000000.0);
  if (!*(_QWORD *)a3)
  {
    v162 = *(_QWORD *)(a3 + 16);
    v165 = *(float *)(v162 + 0x27FFFFFFF4);
    v166 = v165 - v165;
    v167 = 0x7FFFFFFF;
    goto LABEL_247;
  }
  v161 = *(unsigned int *)(a3 + 24);
  v163 = *(_QWORD *)(a3 + 8);
  v162 = *(_QWORD *)(a3 + 16);
  v164 = *(unsigned int *)(v163 + 4 * (0x3E784199B71EA792 % v161));
  if ((_DWORD)v164 == 0x7FFFFFFF)
    goto LABEL_225;
  if (*(unsigned __int8 *)(v162 + 80 * v164 + 12) != 136)
  {
    while (1)
    {
      LODWORD(v164) = *(_DWORD *)(v162 + 80 * v164 + 8) & 0x7FFFFFFF;
      if ((_DWORD)v164 == 0x7FFFFFFF)
        break;
      if (*(unsigned __int8 *)(v162 + 80 * v164 + 12) == 136)
        goto LABEL_230;
    }
LABEL_225:
    LODWORD(v164) = 0x7FFFFFFF;
  }
LABEL_230:
  v168 = v162 + 80 * v164;
  v169 = *(_DWORD *)(v163 + 4 * (0x1D08970C8BCEA7C1 % v161));
  v170 = 0x7FFFFFFF;
  if (v169 != 0x7FFFFFFF)
  {
    v170 = *(_DWORD *)(v163 + 4 * (0x1D08970C8BCEA7C1 % v161));
    if (*(unsigned __int8 *)(v162 + 80 * v169 + 12) != 138)
    {
      while (1)
      {
        v170 = *(_DWORD *)(v162 + 80 * *(unsigned int *)(v163 + 4 * (0x1D08970C8BCEA7C1 % v161)) + 8) & 0x7FFFFFFF;
        if (v170 == 0x7FFFFFFF)
          break;
        if (*(unsigned __int8 *)(v162 + 80 * v170 + 12) == 138)
          goto LABEL_236;
      }
      v170 = 0x7FFFFFFF;
    }
  }
LABEL_236:
  v171 = *(float *)(v162 + 80 * v170 + 68);
  v172 = *(_DWORD *)(v163 + 4 * (0x72025A4FB5A542DBLL % v161));
  v167 = 0x7FFFFFFF;
  v173 = 0x7FFFFFFF;
  if (v172 != 0x7FFFFFFF)
  {
    v173 = *(_DWORD *)(v163 + 4 * (0x72025A4FB5A542DBLL % v161));
    if (*(unsigned __int8 *)(v162 + 80 * v172 + 12) != 137)
    {
      while (1)
      {
        v173 = *(_DWORD *)(v162 + 80 * *(unsigned int *)(v163 + 4 * (0x72025A4FB5A542DBLL % v161)) + 8) & 0x7FFFFFFF;
        if (v173 == 0x7FFFFFFF)
          break;
        if (*(unsigned __int8 *)(v162 + 80 * v173 + 12) == 137)
          goto LABEL_242;
      }
      v173 = 0x7FFFFFFF;
    }
  }
LABEL_242:
  v166 = *(float *)(v168 + 68) - v171;
  v165 = *(float *)(v162 + 80 * v173 + 68);
  v174 = *(unsigned int *)(v163 + 4 * (0x5CB85FD265949FD2 % v161));
  if ((_DWORD)v174 != 0x7FFFFFFF)
  {
    if (*(unsigned __int8 *)(v162 + 80 * v174 + 12) == 139)
    {
LABEL_246:
      v167 = v174;
    }
    else
    {
      while (1)
      {
        LODWORD(v174) = *(_DWORD *)(v162 + 80 * v174 + 8) & 0x7FFFFFFF;
        v167 = 0x7FFFFFFF;
        if ((_DWORD)v174 == 0x7FFFFFFF)
          break;
        if (*(unsigned __int8 *)(v162 + 80 * v174 + 12) == 139)
          goto LABEL_246;
      }
    }
  }
LABEL_247:
  re::DynamicString::appendf((re::DynamicString *)v90, "SU Vertices : %.2f, SU Triangles: %.2f\n", v166, (float)(v165 - *(float *)(v162 + 80 * v167 + 68)));
  v175 = v85 + (v88 << 6);
  *(_DWORD *)(v175 + 56) = 2048;
  *(_QWORD *)&result = 0x2D0000000ALL;
  *(_QWORD *)(v175 + 48) = 0x2D0000000ALL;
  return result;
}

re::FrameCustomStats *re::FrameCustomStats::FrameCustomStats(re::FrameCustomStats *this)
{
  char *v2;
  char *v3;
  double v4;
  _anonymous_namespace_ *v5;
  __int128 v7;
  __int128 v8;
  _QWORD v9[2];

  *((_DWORD *)this + 2) = 10;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_DWORD *)this + 12) = 0;
  *(_QWORD *)((char *)this + 52) = 0x7FFFFFFFLL;
  *((_BYTE *)this + 64) = 0;
  *(_QWORD *)this = &off_24ED7F310;
  *(_OWORD *)((char *)this + 88) = 0u;
  *((_DWORD *)this + 26) = 0;
  *(_OWORD *)((char *)this + 72) = 0u;
  v2 = (char *)this + 72;
  *(_QWORD *)((char *)this + 108) = 0x7FFFFFFFLL;
  *((_QWORD *)this + 19) = 0;
  *((_QWORD *)this + 16) = 0;
  *((_QWORD *)this + 17) = 0;
  *((_DWORD *)this + 36) = 0;
  *((_QWORD *)this + 15) = 0;
  v3 = (char *)this + 120;
  *((_BYTE *)this + 160) = 1;
  LODWORD(v9[0]) = 0;
  v7 = 0u;
  v8 = 0u;
  *(_QWORD *)((char *)v9 + 4) = 0x7FFFFFFFLL;
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=((uint64_t)v2, (uint64_t *)&v7);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v7, v4);
  v9[0] = 0;
  *((_QWORD *)&v7 + 1) = 0;
  *(_QWORD *)&v8 = 0;
  DWORD2(v8) = 0;
  re::DynamicArray<re::CustomStatsLineInfo>::setCapacity(&v7, 0xFuLL);
  ++DWORD2(v8);
  re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=((uint64_t)v3, (uint64_t)&v7);
  re::DynamicArray<re::CustomStatsLineInfo>::deinit((uint64_t)&v7);
  return this;
}

void re::FrameCustomStats::~FrameCustomStats(re::FrameCustomStats *this, double a2)
{
  uint64_t *v3;
  double v4;
  double v5;

  v3 = (uint64_t *)((char *)this + 72);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 9, a2);
  re::DynamicArray<re::CustomStatsLineInfo>::deinit((uint64_t)this + 120);
  re::DynamicArray<re::CustomStatsLineInfo>::deinit((uint64_t)this + 120);
  v5 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v3, v4);
  *(_QWORD *)this = off_24ED7F2B0;
  *((_BYTE *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2, v5);
}

{
  re::FrameCustomStats::~FrameCustomStats(this, a2);
  JUMPOUT(0x2276933B8);
}

uint64_t re::DynamicArray<re::CustomStatsLineInfo>::deinit(uint64_t a1)
{
  uint64_t result;
  __n128 *v3;
  uint64_t v4;
  uint64_t v5;
  __n128 v6;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(__n128 **)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 104 * v4;
        v6 = 0uLL;
        do
        {
          if (v3->n128_u64[0])
          {
            if ((v3->n128_u8[8] & 1) != 0)
            {
              (*(void (**)(unint64_t, unint64_t, __n128))(*(_QWORD *)v3->n128_u64[0] + 40))(v3->n128_u64[0], v3[1].n128_u64[0], v6);
              v6 = 0uLL;
            }
            *v3 = v6;
            v3[1] = v6;
          }
          v3 = (__n128 *)((char *)v3 + 104);
          v5 -= 104;
        }
        while (v5);
        result = *(_QWORD *)a1;
        v3 = *(__n128 **)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, __n128 *))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::FrameCustomStats::addOrGetStat(re::FrameCustomStats *this, const char *a2)
{
  char *v4;
  uint64_t v5;
  _anonymous_namespace_ *v6;
  _anonymous_namespace_ *v8;
  uint64_t v9;
  _anonymous_namespace_ *v10;
  char v11;
  __int16 v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  __int128 v16;
  __int128 v17;
  int v18;
  int v19;

  v4 = (char *)this + 72;
  v5 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)v4, (uint64_t)&v10);
  v6 = v10;
  if (v10 && (v11 & 1) != 0)
    v6 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v10 + 40))();
  if (v5)
    return *(_QWORD *)v5;
  v12 = 257;
  v13 = 0xFF7FFFFF7F7FFFFFLL;
  v15 = 0;
  v14 = 0;
  v16 = xmmword_226192590;
  v17 = xmmword_2261925A0;
  v18 = 0;
  v19 = 0;
  re::DynamicArray<re::CustomStatsLineInfo>::add((re::FrameCustomStats *)((char *)this + 120), (uint64_t)&v10);
  v8 = v10;
  if (v10 && (v11 & 1) != 0)
    v8 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v10 + 40))();
  v9 = *((_QWORD *)this + 17) - 1;
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<unsigned long &>((uint64_t)v4, (re::DynamicString *)&v10, &v9);
  if (v10)
  {
    if ((v11 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v10 + 40))();
  }
  return *((_QWORD *)this + 17) - 1;
}

void re::DynamicArray<re::CustomStatsLineInfo>::add(_anonymous_namespace_ *this, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v4 = *((_QWORD *)this + 2);
  if (v4 >= *((_QWORD *)this + 1))
  {
    re::DynamicArray<re::CustomStatsLineInfo>::growCapacity(this, v4 + 1);
    v4 = *((_QWORD *)this + 2);
  }
  v5 = *((_QWORD *)this + 4) + 104 * v4;
  *(_OWORD *)v5 = 0u;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_QWORD *)(v5 + 24) = *(_QWORD *)(a2 + 24);
  v6 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)v5 = *(_QWORD *)a2;
  *(_QWORD *)a2 = 0;
  v7 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 24) = 0;
  v9 = *(_QWORD *)(v5 + 8);
  v8 = *(_QWORD *)(v5 + 16);
  *(_QWORD *)(v5 + 8) = v6;
  *(_QWORD *)(v5 + 16) = v7;
  *(_QWORD *)(a2 + 8) = v9;
  *(_QWORD *)(a2 + 16) = v8;
  *(_WORD *)(v5 + 32) = *(_WORD *)(a2 + 32);
  re::FrameStats::CollectedStatistics::CollectedStatistics((re::FrameStats::CollectedStatistics *)(v5 + 36), (const re::FrameStats::CollectedStatistics *)(a2 + 36));
  ++*((_QWORD *)this + 2);
  ++*((_DWORD *)this + 6);
}

uint64_t re::FrameCustomStats::addOrGetLine(re::FrameCustomStats *this, const char *a2)
{
  char *v4;
  uint64_t v5;
  _anonymous_namespace_ *v6;
  _anonymous_namespace_ *v8;
  uint64_t v9;
  _anonymous_namespace_ *v10;
  char v11;
  __int16 v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  __int128 v16;
  __int128 v17;
  int v18;
  int v19;

  v4 = (char *)this + 72;
  v5 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)v4, (uint64_t)&v10);
  v6 = v10;
  if (v10 && (v11 & 1) != 0)
    v6 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v10 + 40))();
  if (v5)
    return *(_QWORD *)v5;
  v12 = 1;
  v13 = 0xFF7FFFFF7F7FFFFFLL;
  v15 = 0;
  v14 = 0;
  v16 = xmmword_226192590;
  v17 = xmmword_2261925A0;
  v18 = 0;
  v19 = 0;
  re::DynamicArray<re::CustomStatsLineInfo>::add((re::FrameCustomStats *)((char *)this + 120), (uint64_t)&v10);
  v8 = v10;
  if (v10 && (v11 & 1) != 0)
    v8 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v10 + 40))();
  v9 = *((_QWORD *)this + 17) - 1;
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<unsigned long &>((uint64_t)v4, (re::DynamicString *)&v10, &v9);
  if (v10)
  {
    if ((v11 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v10 + 40))();
  }
  return *((_QWORD *)this + 17) - 1;
}

_QWORD *re::FrameCustomStats::updateText(_QWORD *this, unint64_t a2, const char *a3)
{
  _QWORD *v5;
  unint64_t v6;
  _QWORD *v7;
  char v8;
  uint64_t v9;
  int v10;
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  unint64_t v15;
  __int16 v16;
  unint64_t v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  if (this[17] > a2)
  {
    v5 = this;
    v6 = v5[17];
    if (v6 <= a2)
    {
      v9 = 0;
      v21 = 0u;
      v22 = 0u;
      v19 = 0u;
      v20 = 0u;
      v18 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v10 = 136315906;
      v11 = "operator[]";
      v12 = 1024;
      v13 = 789;
      v14 = 2048;
      v15 = a2;
      v16 = 2048;
      v17 = v6;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    re::DynamicString::operator=((re::DynamicString *)(v5[19] + 104 * a2), (re::DynamicString *)&v7);
    this = v7;
    if (v7)
    {
      if ((v8 & 1) != 0)
        return (_QWORD *)(*(uint64_t (**)(void))(*v7 + 40))();
    }
  }
  return this;
}

uint64_t re::FrameCustomStats::dumpStatisticsInternal(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  _BYTE *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;

  LODWORD(v2) = 0x7FFFFFFF;
  if (*(_QWORD *)a2)
  {
    v3 = **(unsigned int **)(a2 + 8);
    if ((_DWORD)v3 != 0x7FFFFFFF)
    {
      v4 = *(_QWORD *)(a2 + 16);
      if (*(_DWORD *)(v4 + (v3 << 6) + 12))
      {
        v2 = **(unsigned int **)(a2 + 8);
        while (1)
        {
          v2 = *(_DWORD *)(v4 + (v2 << 6) + 8) & 0x7FFFFFFF;
          if ((_DWORD)v2 == 0x7FFFFFFF)
            break;
          if (!*(_DWORD *)(v4 + (v2 << 6) + 12))
            goto LABEL_10;
        }
        LODWORD(v2) = 0x7FFFFFFF;
      }
      else
      {
        LODWORD(v2) = **(_DWORD **)(a2 + 8);
      }
    }
  }
LABEL_10:
  v5 = *(_QWORD *)(a2 + 16);
  v6 = v2;
  v7 = v5 + ((unint64_t)v2 << 6);
  v8 = (_QWORD *)(v7 + 16);
  v9 = *(_QWORD *)(v7 + 24);
  if ((v9 & 1) != 0)
  {
    v8[1] = 1;
    v10 = (_BYTE *)v8[2];
  }
  else
  {
    *((_BYTE *)v8 + 8) = v9 & 1;
    v10 = (char *)v8 + 9;
  }
  *v10 = 0;
  v11 = *(_QWORD *)(result + 136);
  if (v11)
  {
    v18 = v6;
    v19 = v5;
    v12 = 0;
    v13 = *(_QWORD *)(result + 152);
    do
    {
      v14 = v13 + v12;
      *(_OWORD *)(v14 + 60) = *(_OWORD *)(v13 + v12 + 36);
      *(_DWORD *)(v14 + 76) = *(_DWORD *)(v13 + v12 + 52);
      *(_OWORD *)(v14 + 36) = xmmword_2261925B0;
      *(_DWORD *)(v14 + 52) = 0;
      if (*(_BYTE *)(v13 + v12 + 32))
      {
        if (*(_BYTE *)(v14 + 33))
        {
          if ((*(_QWORD *)(v14 + 8) & 1) != 0)
            v15 = *(const char **)(v13 + v12 + 16);
          else
            v15 = (const char *)(v13 + v12 + 9);
          result = re::DynamicString::appendf((re::DynamicString *)v8, "\n%.15s: ", v15);
          if (*(float *)(v14 + 72) != 0.0)
            result = re::DynamicString::appendf((re::DynamicString *)v8, "%.2f, Min/Max[%.2f-%.2f],", *(float *)(v14 + 76), *(float *)(v14 + 60), *(float *)(v14 + 64));
          if (*(float *)(v13 + v12 + 92) != 0.0)
            result = re::DynamicString::appendf((re::DynamicString *)v8, "LT Min/Max[%.2f-%.2f]");
        }
        else
        {
          result = re::DynamicString::appendf((re::DynamicString *)v8, "\n%.70s");
        }
      }
      v12 += 104;
    }
    while (104 * v11 != v12);
    v6 = v18;
    v5 = v19;
  }
  v16 = v5 + (v6 << 6);
  *(_QWORD *)(v16 + 52) = 0x20000000003CLL;
  if (v11 <= 0xB)
    v17 = 11;
  else
    v17 = v11;
  *(_DWORD *)(v16 + 48) = v17;
  return result;
}

uint64_t re::FrameAttributionStats::dumpStatisticsInternal(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  _BYTE *v14;
  unsigned int v15;
  unsigned int v16;
  uint64_t v17;
  float v18;
  int v19;
  double v20;
  unint64_t v21;
  unint64_t v22;
  double v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  float v27;
  int v28;
  double v29;
  unint64_t v30;
  unint64_t v31;
  double v32;
  uint64_t v33;
  uint64_t v34;
  unsigned int v35;
  float v36;
  int v37;
  double v38;
  unint64_t v39;
  unint64_t v40;
  double v41;
  uint64_t v42;
  uint64_t v43;
  unsigned int v44;
  float v45;
  int v46;
  double v47;
  unint64_t v48;
  unint64_t v49;
  double v50;
  uint64_t v51;
  uint64_t v52;
  unsigned int v53;
  float v54;
  int v55;
  double v56;
  unint64_t v57;
  unint64_t v58;
  double v59;
  uint64_t v60;
  uint64_t v61;
  unsigned int v62;
  float v63;
  int v64;
  double v65;
  unint64_t v66;
  unint64_t v67;
  double v68;
  float v69;
  float v70;
  float v71;
  float v72;
  float v73;
  float v74;
  uint64_t result;
  mach_timebase_info info;

  LODWORD(v6) = 0x7FFFFFFF;
  if (*(_QWORD *)a2)
  {
    v7 = **(unsigned int **)(a2 + 8);
    if ((_DWORD)v7 != 0x7FFFFFFF)
    {
      v8 = *(_QWORD *)(a2 + 16);
      if (*(_DWORD *)(v8 + (v7 << 6) + 12))
      {
        v6 = **(unsigned int **)(a2 + 8);
        while (1)
        {
          v6 = *(_DWORD *)(v8 + (v6 << 6) + 8) & 0x7FFFFFFF;
          if ((_DWORD)v6 == 0x7FFFFFFF)
            break;
          if (!*(_DWORD *)(v8 + (v6 << 6) + 12))
            goto LABEL_10;
        }
        LODWORD(v6) = 0x7FFFFFFF;
      }
      else
      {
        LODWORD(v6) = **(_DWORD **)(a2 + 8);
      }
    }
  }
LABEL_10:
  v9 = *(_QWORD *)(a2 + 16);
  v10 = v6;
  v11 = v9 + ((unint64_t)v6 << 6);
  v12 = (_QWORD *)(v11 + 16);
  v13 = *(_QWORD *)(v11 + 24);
  if ((v13 & 1) != 0)
  {
    v12[1] = 1;
    v14 = (_BYTE *)v12[2];
  }
  else
  {
    *((_BYTE *)v12 + 8) = v13 & 1;
    v14 = (char *)v12 + 9;
  }
  *v14 = 0;
  re::DynamicString::appendf((re::DynamicString *)v12, "Attribution Statistics\n");
  v15 = 0x7FFFFFFF;
  if (*(_QWORD *)a4)
  {
    v16 = *(_DWORD *)(*(_QWORD *)(a4 + 8) + 4 * (0x8AEB093D93E71BBFLL % *(unsigned int *)(a4 + 24)));
    if (v16 != 0x7FFFFFFF)
    {
      v17 = *(_QWORD *)(a4 + 16);
      v15 = *(_DWORD *)(*(_QWORD *)(a4 + 8) + 4 * (0x8AEB093D93E71BBFLL % *(unsigned int *)(a4 + 24)));
      if (*(_BYTE *)(v17 + 80 * v16 + 12) != 122)
      {
        while (1)
        {
          v15 = *(_DWORD *)(v17
                          + 80
                          * *(unsigned int *)(*(_QWORD *)(a4 + 8)
                                            + 4 * (0x8AEB093D93E71BBFLL % *(unsigned int *)(a4 + 24)))
                          + 8) & 0x7FFFFFFF;
          if (v15 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v17 + 80 * v15 + 12) == 122)
            goto LABEL_20;
        }
        v15 = 0x7FFFFFFF;
      }
    }
  }
LABEL_20:
  v18 = *(float *)(*(_QWORD *)(a4 + 16) + 80 * v15 + 48);
  v19 = *(_DWORD *)(a1 + 8);
  v20 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v23 = NAN;
      goto LABEL_25;
    }
    LODWORD(v21) = info.numer;
    LODWORD(v22) = info.denom;
    v20 = (double)v21 / (double)v22;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v20;
  }
  v23 = v20 * (double)(unint64_t)(float)(v18 / (float)v19);
LABEL_25:
  if (*(_QWORD *)a4)
  {
    v24 = *(_QWORD *)(a4 + 16);
    v25 = *(unsigned int *)(*(_QWORD *)(a4 + 8) + 4 * (0x178631649EA56D8AuLL % *(unsigned int *)(a4 + 24)));
    v26 = 0x7FFFFFFF;
    if ((_DWORD)v25 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v24 + 80 * v25 + 12) == 120)
      {
LABEL_30:
        v26 = v25;
      }
      else
      {
        while (1)
        {
          LODWORD(v25) = *(_DWORD *)(v24 + 80 * v25 + 8) & 0x7FFFFFFF;
          v26 = 0x7FFFFFFF;
          if ((_DWORD)v25 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v24 + 80 * v25 + 12) == 120)
            goto LABEL_30;
        }
      }
    }
  }
  else
  {
    v24 = *(_QWORD *)(a4 + 16);
    v26 = 0x7FFFFFFF;
  }
  v27 = *(float *)(v24 + 80 * v26 + 48);
  v28 = *(_DWORD *)(a1 + 8);
  v29 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v32 = NAN;
      goto LABEL_37;
    }
    LODWORD(v30) = info.numer;
    LODWORD(v31) = info.denom;
    v29 = (double)v30 / (double)v31;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v29;
  }
  v32 = v29 * (double)(unint64_t)(float)(v27 / (float)v28);
LABEL_37:
  if (*(_QWORD *)a4)
  {
    v33 = *(_QWORD *)(a4 + 16);
    v34 = *(unsigned int *)(*(_QWORD *)(a4 + 8) + 4 * (0x2D2898CE1F8CEF8EuLL % *(unsigned int *)(a4 + 24)));
    v35 = 0x7FFFFFFF;
    if ((_DWORD)v34 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v33 + 80 * v34 + 12) == 125)
      {
LABEL_42:
        v35 = v34;
      }
      else
      {
        while (1)
        {
          LODWORD(v34) = *(_DWORD *)(v33 + 80 * v34 + 8) & 0x7FFFFFFF;
          v35 = 0x7FFFFFFF;
          if ((_DWORD)v34 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v33 + 80 * v34 + 12) == 125)
            goto LABEL_42;
        }
      }
    }
  }
  else
  {
    v33 = *(_QWORD *)(a4 + 16);
    v35 = 0x7FFFFFFF;
  }
  v36 = *(float *)(v33 + 80 * v35 + 48);
  v37 = *(_DWORD *)(a1 + 8);
  v38 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v41 = NAN;
      goto LABEL_49;
    }
    LODWORD(v39) = info.numer;
    LODWORD(v40) = info.denom;
    v38 = (double)v39 / (double)v40;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v38;
  }
  v41 = v38 * (double)(unint64_t)(float)(v36 / (float)v37);
LABEL_49:
  if (*(_QWORD *)a4)
  {
    v42 = *(_QWORD *)(a4 + 16);
    v43 = *(unsigned int *)(*(_QWORD *)(a4 + 8) + 4 * (0x8BC946409C88CB8FLL % *(unsigned int *)(a4 + 24)));
    v44 = 0x7FFFFFFF;
    if ((_DWORD)v43 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v42 + 80 * v43 + 12) == 121)
      {
LABEL_54:
        v44 = v43;
      }
      else
      {
        while (1)
        {
          LODWORD(v43) = *(_DWORD *)(v42 + 80 * v43 + 8) & 0x7FFFFFFF;
          v44 = 0x7FFFFFFF;
          if ((_DWORD)v43 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v42 + 80 * v43 + 12) == 121)
            goto LABEL_54;
        }
      }
    }
  }
  else
  {
    v42 = *(_QWORD *)(a4 + 16);
    v44 = 0x7FFFFFFF;
  }
  v45 = *(float *)(v42 + 80 * v44 + 48);
  v46 = *(_DWORD *)(a1 + 8);
  v47 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v50 = NAN;
      goto LABEL_61;
    }
    LODWORD(v48) = info.numer;
    LODWORD(v49) = info.denom;
    v47 = (double)v48 / (double)v49;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v47;
  }
  v50 = v47 * (double)(unint64_t)(float)(v45 / (float)v46);
LABEL_61:
  if (*(_QWORD *)a4)
  {
    v51 = *(_QWORD *)(a4 + 16);
    v52 = *(unsigned int *)(*(_QWORD *)(a4 + 8) + 4 * (0xEAD39EBF60CC176uLL % *(unsigned int *)(a4 + 24)));
    v53 = 0x7FFFFFFF;
    if ((_DWORD)v52 != 0x7FFFFFFF)
    {
      if (*(_BYTE *)(v51 + 80 * v52 + 12) == 124)
      {
LABEL_66:
        v53 = v52;
      }
      else
      {
        while (1)
        {
          LODWORD(v52) = *(_DWORD *)(v51 + 80 * v52 + 8) & 0x7FFFFFFF;
          v53 = 0x7FFFFFFF;
          if ((_DWORD)v52 == 0x7FFFFFFF)
            break;
          if (*(_BYTE *)(v51 + 80 * v52 + 12) == 124)
            goto LABEL_66;
        }
      }
    }
  }
  else
  {
    v51 = *(_QWORD *)(a4 + 16);
    v53 = 0x7FFFFFFF;
  }
  v54 = *(float *)(v51 + 80 * v53 + 48);
  v55 = *(_DWORD *)(a1 + 8);
  v56 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v59 = NAN;
      goto LABEL_73;
    }
    LODWORD(v57) = info.numer;
    LODWORD(v58) = info.denom;
    v56 = (double)v57 / (double)v58;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v56;
  }
  v59 = v56 * (double)(unint64_t)(float)(v54 / (float)v55);
LABEL_73:
  if (*(_QWORD *)a4)
  {
    v60 = *(_QWORD *)(a4 + 16);
    v61 = *(unsigned int *)(*(_QWORD *)(a4 + 8) + 4 * (0xE2E7890052504D85 % *(unsigned int *)(a4 + 24)));
    v62 = 0x7FFFFFFF;
    if ((_DWORD)v61 != 0x7FFFFFFF)
    {
      if (*(unsigned __int8 *)(v60 + 80 * v61 + 12) == 131)
      {
LABEL_78:
        v62 = v61;
      }
      else
      {
        while (1)
        {
          LODWORD(v61) = *(_DWORD *)(v60 + 80 * v61 + 8) & 0x7FFFFFFF;
          v62 = 0x7FFFFFFF;
          if ((_DWORD)v61 == 0x7FFFFFFF)
            break;
          if (*(unsigned __int8 *)(v60 + 80 * v61 + 12) == 131)
            goto LABEL_78;
        }
      }
    }
  }
  else
  {
    v60 = *(_QWORD *)(a4 + 16);
    v62 = 0x7FFFFFFF;
  }
  v63 = *(float *)(v60 + 80 * v62 + 48);
  v64 = *(_DWORD *)(a1 + 8);
  v65 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale >= 0.0)
    goto LABEL_84;
  if (!mach_timebase_info(&info))
  {
    LODWORD(v66) = info.numer;
    LODWORD(v67) = info.denom;
    v65 = (double)v66 / (double)v67;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v65;
LABEL_84:
    v68 = v65 * (double)(unint64_t)(float)(v63 / (float)v64);
    goto LABEL_85;
  }
  v68 = NAN;
LABEL_85:
  v69 = v59 / 1000000.0;
  v70 = v50 / 1000000.0;
  v71 = v41 / 1000000.0;
  v72 = v32 / 1000000.0;
  v73 = v23 / 1000000.0;
  v74 = v68 / 1000000.0;
  re::DynamicString::appendf((re::DynamicString *)v12, "CPU Time %.2f\n", (float)((float)((float)((float)((float)(v73 + v72) + v71) + v70) + v69) + v74));
  re::DynamicString::appendf((re::DynamicString *)v12, "Animation %.2f\n", v71);
  re::DynamicString::appendf((re::DynamicString *)v12, "Audio %.2f\n", v72);
  re::DynamicString::appendf((re::DynamicString *)v12, "Rendering %.2f\n", v73);
  re::DynamicString::appendf((re::DynamicString *)v12, "Network %.2f\n", v69);
  re::DynamicString::appendf((re::DynamicString *)v12, "Physics %.2f\n", v70);
  result = re::DynamicString::appendf((re::DynamicString *)v12, "Misc %.2f\n", v74);
  *(_DWORD *)(v9 + (v10 << 6) + 48) = 8;
  return result;
}

double re::FrameVFXStats::dumpStatisticsInternal(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  _BYTE *v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  float v17;
  int v18;
  double v19;
  unint64_t v20;
  unint64_t v21;
  double v22;
  double v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  unsigned int v29;
  float v30;
  int v31;
  double v32;
  unint64_t v33;
  unint64_t v34;
  double v35;
  double v36;
  uint64_t v37;
  uint64_t v38;
  unsigned int v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unsigned int v43;
  unsigned int v44;
  unsigned int v45;
  float v46;
  int v47;
  uint64_t v48;
  double result;
  mach_timebase_info info;

  LODWORD(v5) = 0x7FFFFFFF;
  if (*(_QWORD *)a2)
  {
    v6 = **(unsigned int **)(a2 + 8);
    if ((_DWORD)v6 != 0x7FFFFFFF)
    {
      v7 = *(_QWORD *)(a2 + 16);
      if (*(_DWORD *)(v7 + (v6 << 6) + 12))
      {
        v5 = **(unsigned int **)(a2 + 8);
        while (1)
        {
          v5 = *(_DWORD *)(v7 + (v5 << 6) + 8) & 0x7FFFFFFF;
          if ((_DWORD)v5 == 0x7FFFFFFF)
            break;
          if (!*(_DWORD *)(v7 + (v5 << 6) + 12))
            goto LABEL_10;
        }
        LODWORD(v5) = 0x7FFFFFFF;
      }
      else
      {
        LODWORD(v5) = **(_DWORD **)(a2 + 8);
      }
    }
  }
LABEL_10:
  v8 = *(_QWORD *)(a2 + 16);
  v9 = v5;
  v10 = v8 + ((unint64_t)v5 << 6);
  v11 = (_QWORD *)(v10 + 16);
  v12 = *(_QWORD *)(v10 + 24);
  if ((v12 & 1) != 0)
  {
    v11[1] = 1;
    v13 = (_BYTE *)v11[2];
  }
  else
  {
    *((_BYTE *)v11 + 8) = v12 & 1;
    v13 = (char *)v11 + 9;
  }
  *v13 = 0;
  re::DynamicString::append((re::DynamicString *)v11, "VFX Stats\n", 0xAuLL);
  v14 = 0x7FFFFFFF;
  if (*(_QWORD *)a3)
  {
    v15 = *(_DWORD *)(*(_QWORD *)(a3 + 8) + 4 * (0xD12374540570B1A6 % *(unsigned int *)(a3 + 24)));
    if (v15 != 0x7FFFFFFF)
    {
      v16 = *(_QWORD *)(a3 + 16);
      v14 = *(_DWORD *)(*(_QWORD *)(a3 + 8) + 4 * (0xD12374540570B1A6 % *(unsigned int *)(a3 + 24)));
      if (*(unsigned __int8 *)(v16 + 80 * v15 + 12) != 130)
      {
        while (1)
        {
          v14 = *(_DWORD *)(v16
                          + 80
                          * *(unsigned int *)(*(_QWORD *)(a3 + 8)
                                            + 4 * (0xD12374540570B1A6 % *(unsigned int *)(a3 + 24)))
                          + 8) & 0x7FFFFFFF;
          if (v14 == 0x7FFFFFFF)
            break;
          if (*(unsigned __int8 *)(v16 + 80 * v14 + 12) == 130)
            goto LABEL_20;
        }
        v14 = 0x7FFFFFFF;
      }
    }
  }
LABEL_20:
  v17 = *(float *)(*(_QWORD *)(a3 + 16) + 80 * v14 + 48);
  v18 = *(_DWORD *)(a1 + 8);
  v19 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v22 = NAN;
      goto LABEL_25;
    }
    LODWORD(v20) = info.numer;
    LODWORD(v21) = info.denom;
    v19 = (double)v20 / (double)v21;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v19;
  }
  v22 = v19 * (double)(unint64_t)(float)(v17 / (float)v18);
LABEL_25:
  v23 = v22 / 1000000.0;
  if (*(_QWORD *)a3)
  {
    v24 = *(_QWORD *)(a3 + 16);
    v25 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0xD732B4173198B1FuLL % *(unsigned int *)(a3 + 24)));
    v26 = 0x7FFFFFFF;
    if ((_DWORD)v25 != 0x7FFFFFFF)
    {
      if (*(unsigned __int8 *)(v24 + 80 * v25 + 12) == 149)
      {
LABEL_30:
        v26 = v25;
      }
      else
      {
        while (1)
        {
          LODWORD(v25) = *(_DWORD *)(v24 + 80 * v25 + 8) & 0x7FFFFFFF;
          v26 = 0x7FFFFFFF;
          if ((_DWORD)v25 == 0x7FFFFFFF)
            break;
          if (*(unsigned __int8 *)(v24 + 80 * v25 + 12) == 149)
            goto LABEL_30;
        }
      }
    }
  }
  else
  {
    v24 = *(_QWORD *)(a3 + 16);
    v26 = 0x7FFFFFFF;
  }
  re::DynamicString::appendf((re::DynamicString *)v11, "VFX ECS (ms): %.2f    VFX Scene Components: %.0f\n", v23, (float)(*(float *)(v24 + 80 * v26 + 48) / (float)*(int *)(a1 + 8)));
  if (*(_QWORD *)a3)
  {
    v27 = *(_QWORD *)(a3 + 16);
    v28 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0x3465840D39B46BB3uLL % *(unsigned int *)(a3 + 24)));
    v29 = 0x7FFFFFFF;
    if ((_DWORD)v28 != 0x7FFFFFFF)
    {
      if (*(unsigned __int8 *)(v27 + 80 * v28 + 12) == 150)
      {
LABEL_37:
        v29 = v28;
      }
      else
      {
        while (1)
        {
          LODWORD(v28) = *(_DWORD *)(v27 + 80 * v28 + 8) & 0x7FFFFFFF;
          v29 = 0x7FFFFFFF;
          if ((_DWORD)v28 == 0x7FFFFFFF)
            break;
          if (*(unsigned __int8 *)(v27 + 80 * v28 + 12) == 150)
            goto LABEL_37;
        }
      }
    }
  }
  else
  {
    v27 = *(_QWORD *)(a3 + 16);
    v29 = 0x7FFFFFFF;
  }
  v30 = *(float *)(v27 + 80 * v29 + 48);
  v31 = *(_DWORD *)(a1 + 8);
  v32 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v35 = NAN;
      goto LABEL_44;
    }
    LODWORD(v33) = info.numer;
    LODWORD(v34) = info.denom;
    v32 = (double)v33 / (double)v34;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v32;
  }
  v35 = v32 * (double)(unint64_t)(float)(v30 / (float)v31);
LABEL_44:
  v36 = v35 / 1000000.0;
  if (*(_QWORD *)a3)
  {
    v37 = *(_QWORD *)(a3 + 16);
    v38 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + 4 * (0xB3CC71E5DDF6EBC3 % *(unsigned int *)(a3 + 24)));
    v39 = 0x7FFFFFFF;
    if ((_DWORD)v38 != 0x7FFFFFFF)
    {
      if (*(unsigned __int8 *)(v37 + 80 * v38 + 12) == 151)
      {
LABEL_49:
        v39 = v38;
      }
      else
      {
        while (1)
        {
          LODWORD(v38) = *(_DWORD *)(v37 + 80 * v38 + 8) & 0x7FFFFFFF;
          v39 = 0x7FFFFFFF;
          if ((_DWORD)v38 == 0x7FFFFFFF)
            break;
          if (*(unsigned __int8 *)(v37 + 80 * v38 + 12) == 151)
            goto LABEL_49;
        }
      }
    }
  }
  else
  {
    v37 = *(_QWORD *)(a3 + 16);
    v39 = 0x7FFFFFFF;
  }
  re::DynamicString::appendf((re::DynamicString *)v11, "VFX Render Node (ms): %.2f    VFX Draw Calls : %.0f\n", v36, (float)(*(float *)(v37 + 80 * v39 + 48) / (float)*(int *)(a1 + 8)));
  if (*(_QWORD *)a3)
  {
    v40 = *(unsigned int *)(a3 + 24);
    v42 = *(_QWORD *)(a3 + 8);
    v41 = *(_QWORD *)(a3 + 16);
    v43 = *(_DWORD *)(v42 + 4 * (0x76FE0174DADB77ALL % v40));
    v44 = 0x7FFFFFFF;
    v45 = 0x7FFFFFFF;
    if (v43 != 0x7FFFFFFF)
    {
      v45 = *(_DWORD *)(v42 + 4 * (0x76FE0174DADB77ALL % v40));
      if (*(unsigned __int8 *)(v41 + 80 * v43 + 12) != 152)
      {
        while (1)
        {
          v45 = *(_DWORD *)(v41 + 80 * *(unsigned int *)(v42 + 4 * (0x76FE0174DADB77ALL % v40)) + 8) & 0x7FFFFFFF;
          if (v45 == 0x7FFFFFFF)
            break;
          if (*(unsigned __int8 *)(v41 + 80 * v45 + 12) == 152)
            goto LABEL_59;
        }
        v45 = 0x7FFFFFFF;
      }
    }
LABEL_59:
    v46 = *(float *)(v41 + 80 * v45 + 48);
    v47 = *(_DWORD *)(a1 + 8);
    v48 = *(unsigned int *)(v42 + 4 * (0x4B73DAB7CD5C5CDDLL % v40));
    if ((_DWORD)v48 != 0x7FFFFFFF)
    {
      if (*(unsigned __int8 *)(v41 + 80 * v48 + 12) == 153)
      {
LABEL_63:
        v44 = v48;
      }
      else
      {
        while (1)
        {
          LODWORD(v48) = *(_DWORD *)(v41 + 80 * v48 + 8) & 0x7FFFFFFF;
          v44 = 0x7FFFFFFF;
          if ((_DWORD)v48 == 0x7FFFFFFF)
            break;
          if (*(unsigned __int8 *)(v41 + 80 * v48 + 12) == 153)
            goto LABEL_63;
        }
      }
    }
  }
  else
  {
    v41 = *(_QWORD *)(a3 + 16);
    v46 = *(float *)(v41 + 0x27FFFFFFE0);
    v47 = *(_DWORD *)(a1 + 8);
    v44 = 0x7FFFFFFF;
  }
  re::DynamicString::appendf((re::DynamicString *)v11, "VFX Vert Count: %.0f    VFX Tri Count : %.0f\n", (float)(v46 / (float)v47), (float)(*(float *)(v41 + 80 * v44 + 48) / (float)v47));
  *(_QWORD *)&result = 0x2000000000032;
  *(_QWORD *)(v8 + (v9 << 6) + 52) = 0x2000000000032;
  return result;
}

uint64_t re::FrameStats::reservedIndexCount(re::FrameStats *this)
{
  return 1;
}

void re::FrameTimeStats::~FrameTimeStats(re::FrameTimeStats *this, double a2)
{
  *(_QWORD *)this = off_24ED7F2B0;
  *((_BYTE *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2, a2);
}

{
  *(_QWORD *)this = off_24ED7F2B0;
  *((_BYTE *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2, a2);
  JUMPOUT(0x2276933B8);
}

void re::FrameAnimationStats::~FrameAnimationStats(re::FrameAnimationStats *this, double a2)
{
  *(_QWORD *)this = off_24ED7F2B0;
  *((_BYTE *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2, a2);
}

{
  *(_QWORD *)this = off_24ED7F2B0;
  *((_BYTE *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2, a2);
  JUMPOUT(0x2276933B8);
}

void re::FrameAssetStats::~FrameAssetStats(re::FrameAssetStats *this, double a2)
{
  *(_QWORD *)this = off_24ED7F2B0;
  *((_BYTE *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2, a2);
}

{
  *(_QWORD *)this = off_24ED7F2B0;
  *((_BYTE *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2, a2);
  JUMPOUT(0x2276933B8);
}

void re::FrameAudioStats::~FrameAudioStats(re::FrameAudioStats *this, double a2)
{
  *(_QWORD *)this = off_24ED7F2B0;
  *((_BYTE *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2, a2);
}

{
  *(_QWORD *)this = off_24ED7F2B0;
  *((_BYTE *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2, a2);
  JUMPOUT(0x2276933B8);
}

void re::FrameECSStats::~FrameECSStats(re::FrameECSStats *this, double a2)
{
  *(_QWORD *)this = off_24ED7F2B0;
  *((_BYTE *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2, a2);
}

{
  *(_QWORD *)this = off_24ED7F2B0;
  *((_BYTE *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2, a2);
  JUMPOUT(0x2276933B8);
}

void re::FrameMeshStats::~FrameMeshStats(re::FrameMeshStats *this, double a2)
{
  *(_QWORD *)this = off_24ED7F2B0;
  *((_BYTE *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2, a2);
}

{
  *(_QWORD *)this = off_24ED7F2B0;
  *((_BYTE *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2, a2);
  JUMPOUT(0x2276933B8);
}

void re::FrameNetworkStats::~FrameNetworkStats(re::FrameNetworkStats *this, double a2)
{
  *(_QWORD *)this = off_24ED7F2B0;
  *((_BYTE *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2, a2);
}

{
  *(_QWORD *)this = off_24ED7F2B0;
  *((_BYTE *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2, a2);
  JUMPOUT(0x2276933B8);
}

void re::FramePhysicsStats::~FramePhysicsStats(re::FramePhysicsStats *this, double a2)
{
  *(_QWORD *)this = off_24ED7F2B0;
  *((_BYTE *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2, a2);
}

{
  *(_QWORD *)this = off_24ED7F2B0;
  *((_BYTE *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2, a2);
  JUMPOUT(0x2276933B8);
}

void re::FrameRenderingStats::~FrameRenderingStats(re::FrameRenderingStats *this, double a2)
{
  *(_QWORD *)this = off_24ED7F2B0;
  *((_BYTE *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2, a2);
}

{
  *(_QWORD *)this = off_24ED7F2B0;
  *((_BYTE *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2, a2);
  JUMPOUT(0x2276933B8);
}

uint64_t re::FrameRenderingStats::reservedIndexCount(re::FrameRenderingStats *this)
{
  return 2;
}

void re::FrameMemoryStats::~FrameMemoryStats(re::FrameMemoryStats *this, double a2)
{
  *(_QWORD *)this = off_24ED7F2B0;
  *((_BYTE *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2, a2);
}

{
  *(_QWORD *)this = off_24ED7F2B0;
  *((_BYTE *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2, a2);
  JUMPOUT(0x2276933B8);
}

void re::FrameThermalStats::~FrameThermalStats(re::FrameThermalStats *this, double a2)
{
  *(_QWORD *)this = off_24ED7F2B0;
  *((_BYTE *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2, a2);
}

{
  *(_QWORD *)this = off_24ED7F2B0;
  *((_BYTE *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2, a2);
  JUMPOUT(0x2276933B8);
}

void re::FrameSceneUnderstandingStats::~FrameSceneUnderstandingStats(re::FrameSceneUnderstandingStats *this, double a2)
{
  *(_QWORD *)this = off_24ED7F2B0;
  *((_BYTE *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2, a2);
}

{
  *(_QWORD *)this = off_24ED7F2B0;
  *((_BYTE *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2, a2);
  JUMPOUT(0x2276933B8);
}

void re::FrameAttributionStats::~FrameAttributionStats(re::FrameAttributionStats *this, double a2)
{
  *(_QWORD *)this = off_24ED7F2B0;
  *((_BYTE *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2, a2);
}

{
  *(_QWORD *)this = off_24ED7F2B0;
  *((_BYTE *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2, a2);
  JUMPOUT(0x2276933B8);
}

void re::FrameVFXStats::~FrameVFXStats(re::FrameVFXStats *this, double a2)
{
  *(_QWORD *)this = off_24ED7F2B0;
  *((_BYTE *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2, a2);
}

{
  *(_QWORD *)this = off_24ED7F2B0;
  *((_BYTE *)this + 64) = 0;
  re::HashTable<re::DynamicString,re::ConstantDataEntry,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 2, a2);
  JUMPOUT(0x2276933B8);
}

void re::HashTable<unsigned int,re::FrameStatisticsOutput,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::clear(uint64_t a1)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  __n128 v6;
  uint64_t v7;
  __n128 *v8;
  int v9;
  uint64_t v10;
  __n128 *v11;
  uint64_t v12;
  int v13;

  if (*(_DWORD *)(a1 + 28))
  {
    v2 = *(unsigned int *)(a1 + 24);
    if ((_DWORD)v2)
      memset_pattern16(*(void **)(a1 + 8), &memset_pattern_151, 4 * v2);
    v3 = *(unsigned int *)(a1 + 32);
    if ((_DWORD)v3)
    {
      v4 = 0;
      v5 = 0;
      v6 = 0uLL;
      do
      {
        v7 = *(_QWORD *)(a1 + 16);
        v8 = (__n128 *)(v7 + v4);
        v9 = *(_DWORD *)(v7 + v4 + 8);
        if (v9 < 0)
        {
          v8->n128_u32[2] = v9 & 0x7FFFFFFF;
          v12 = v8[1].n128_i64[0];
          v11 = v8 + 1;
          v10 = v12;
          if (v12)
          {
            if ((*(_BYTE *)(v7 + v4 + 24) & 1) != 0)
            {
              (*(void (**)(uint64_t, _QWORD, __n128))(*(_QWORD *)v10 + 40))(v10, *(_QWORD *)(v7 + v4 + 32), v6);
              v6 = 0uLL;
            }
            *v11 = v6;
            v11[1] = v6;
            v3 = *(unsigned int *)(a1 + 32);
          }
        }
        ++v5;
        v4 += 64;
      }
      while (v5 < v3);
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    v13 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v13;
  }
}

void re::HashTable<unsigned int,re::FrameStatisticsOutput,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::copy(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t i;
  uint64_t v8;

  re::HashTable<unsigned int,re::FrameStatisticsOutput,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::clear(a1);
  v4 = *(_DWORD *)(a2 + 28);
  if (*(_DWORD *)(a1 + 24) < v4)
    re::HashTable<unsigned int,re::FrameStatisticsOutput,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::setCapacity(a1, v4);
  v5 = *(unsigned int *)(a2 + 32);
  if ((_DWORD)v5)
  {
    v6 = 0;
    for (i = 0; i < v5; ++i)
    {
      v8 = *(_QWORD *)(a2 + 16) + v6;
      if ((*(_DWORD *)(v8 + 8) & 0x80000000) != 0)
      {
        re::HashTable<unsigned int,re::FrameStatisticsOutput,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::addEmplace<re::FrameStatisticsOutput&>(a1, *(_QWORD *)v8 % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)v8, (_DWORD *)(v8 + 12), (re::DynamicString *)(v8 + 16));
        v5 = *(unsigned int *)(a2 + 32);
      }
      v6 += 64;
    }
  }
}

_QWORD *re::DynamicArray<re::CustomStatsLineInfo>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  re::FrameStats::CollectedStatistics *v10;
  const re::FrameStats::CollectedStatistics *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  float v15;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::CustomStatsLineInfo>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x68uLL))
        {
          v2 = 104 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 104 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_20;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 104, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_20:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = (re::FrameStats::CollectedStatistics *)((char *)v7 + 36);
        v11 = (const re::FrameStats::CollectedStatistics *)(v8 + 36);
        v12 = 104 * v9;
        do
        {
          *(_OWORD *)((char *)v10 - 20) = 0u;
          *(_OWORD *)((char *)v10 - 36) = 0u;
          *(_QWORD *)((char *)v10 - 36) = *(_QWORD *)((char *)v11 - 36);
          *(_QWORD *)((char *)v11 - 36) = 0;
          v13 = *(_QWORD *)((char *)v10 - 20);
          *(_QWORD *)((char *)v10 - 20) = *(_QWORD *)((char *)v11 - 20);
          *(_QWORD *)((char *)v11 - 20) = v13;
          *(_QWORD *)((char *)v10 - 12) = *(_QWORD *)((char *)v11 - 12);
          *(_QWORD *)((char *)v11 - 12) = 0;
          v14 = *(_QWORD *)((char *)v10 - 28);
          *(_QWORD *)((char *)v10 - 28) = *(_QWORD *)((char *)v11 - 28);
          *(_QWORD *)((char *)v11 - 28) = v14;
          *((_WORD *)v10 - 2) = *((_WORD *)v11 - 2);
          v15 = re::FrameStats::CollectedStatistics::CollectedStatistics(v10, v11);
          if (*(_QWORD *)((char *)v11 - 36))
          {
            if ((*((_BYTE *)v11 - 28) & 1) != 0)
              (*(void (**)(_QWORD, _QWORD, float))(**(_QWORD **)((char *)v11 - 36) + 40))(*(_QWORD *)((char *)v11 - 36), *(_QWORD *)((char *)v11 - 20), v15);
            *(_OWORD *)((char *)v11 - 36) = 0u;
            *(_OWORD *)((char *)v11 - 20) = 0u;
          }
          v10 = (re::FrameStats::CollectedStatistics *)((char *)v10 + 104);
          v11 = (const re::FrameStats::CollectedStatistics *)((char *)v11 + 104);
          v12 -= 104;
        }
        while (v12);
        v8 = v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_20;
    }
  }
  return result;
}

_QWORD *re::DynamicArray<re::CustomStatsLineInfo>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<re::CustomStatsLineInfo>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::CustomStatsLineInfo>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

uint64_t re::profilerThreadContext(re *this)
{
  uint64_t (*v1)(_QWORD);
  re::ProfilerThreadContext *v3;

  {
    v3 = (re::ProfilerThreadContext *)re::profilerThreadContext(void)::context(&re::profilerThreadContext(void)::context);
    re::ProfilerThreadContext::ProfilerThreadContext(v3);
    _tlv_atexit((void (__cdecl *)(void *))re::ProfilerThreadContext::~ProfilerThreadContext, v3);
  }
  return re::profilerThreadContext(void)::context(&re::profilerThreadContext(void)::context);
}

void re::ProfilerThreadContext::~ProfilerThreadContext(re::ProfilerThreadContext *this)
{
  void *v2;
  void *v3;
  void *v4;

  v2 = (void *)*((_QWORD *)this + 15);
  if (v2)
  {
    *((_QWORD *)this + 16) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 12);
  if (v3)
  {
    *((_QWORD *)this + 13) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 9);
  if (v4)
  {
    *((_QWORD *)this + 10) = v4;
    operator delete(v4);
  }
}

re::ProfilerThreadContext *re::ProfilerThreadContext::ProfilerThreadContext(re::ProfilerThreadContext *this)
{
  unint64_t v2;
  _opaque_pthread_t *v3;
  pthread_t v4;

  *(_BYTE *)this = 0;
  do
    v2 = __ldaxr(&re::ProfilerThreadContext::s_threadId);
  while (__stlxr(v2 + 1, &re::ProfilerThreadContext::s_threadId));
  *((_QWORD *)this + 8) = v2;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  *((_BYTE *)this + 184) = 0;
  v3 = pthread_self();
  if (!pthread_getname_np(v3, (char *)this, 0x40uLL) && !*(_BYTE *)this)
  {
    v4 = pthread_self();
    snprintf((char *)this, 0x40uLL, "Thread %p", v4);
  }
  *((_QWORD *)this + 22) = 0;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  std::vector<re::ProfilerCategory>::reserve((unint64_t *)this + 12, 0x20uLL);
  return this;
}

void std::vector<re::ProfilerCategory>::reserve(unint64_t *a1, size_t __sz)
{
  unint64_t v2;
  char *v5;
  _BYTE *v6;
  char *v7;
  _BYTE *v8;
  char *v9;
  char v10;

  v2 = *a1;
  if (a1[2] - *a1 < __sz)
  {
    if ((__sz & 0x8000000000000000) != 0)
      abort();
    v5 = (char *)a1[1];
    v6 = operator new(__sz);
    v7 = &v5[(_QWORD)v6 - v2];
    v8 = v7;
    if (v5 != (char *)v2)
    {
      v9 = &v5[~v2];
      do
      {
        v10 = *--v5;
        (v9--)[(_QWORD)v6] = v10;
      }
      while (v5 != (char *)v2);
      v8 = v6;
    }
    *a1 = (unint64_t)v8;
    a1[1] = (unint64_t)v7;
    a1[2] = (unint64_t)&v6[__sz];
    if (v2)
      operator delete((void *)v2);
  }
}

void re::ProfilerThreadContext::begin(re::ProfilerThreadContext *this, re::ProfilerManager *a2, int a3)
{
  uint64_t v6;
  _QWORD *v7;
  re::ProfilerAttributions *v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  unint64_t v12;
  char *v13;
  _QWORD *v14;
  char *v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  char *v19;
  char *v20;
  __int128 v21;
  __int128 v22;

  *((_BYTE *)this + 184) = 1;
  v6 = re::ProfilerManager::acquireEventStream(a2, a3);
  v7 = re::ProfilerManager::acquireStatistics(a2, a3);
  v8 = re::ProfilerManager::acquireAttributions(a2, a3);
  v9 = re::ProfilerManager::acquireVisualizer(a2);
  v10 = re::ProfilerManager::acquireMemoryStatistics(a2, a3);
  v11 = v10;
  v13 = (char *)*((_QWORD *)this + 10);
  v12 = *((_QWORD *)this + 11);
  if ((unint64_t)v13 >= v12)
  {
    v15 = (char *)*((_QWORD *)this + 9);
    v16 = 0xAAAAAAAAAAAAAAABLL * ((v13 - v15) >> 4) + 1;
    if (v16 > 0x555555555555555)
      abort();
    v17 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v12 - (_QWORD)v15) >> 4);
    if (2 * v17 > v16)
      v16 = 2 * v17;
    if (v17 >= 0x2AAAAAAAAAAAAAALL)
      v18 = 0x555555555555555;
    else
      v18 = v16;
    if (v18)
    {
      if (v18 > 0x555555555555555)
        std::__throw_bad_array_new_length[abi:nn180100]();
      v19 = (char *)operator new(48 * v18);
    }
    else
    {
      v19 = 0;
    }
    v20 = &v19[16 * ((v13 - v15) >> 4)];
    *(_QWORD *)v20 = a2;
    *((_QWORD *)v20 + 1) = v6;
    *((_QWORD *)v20 + 2) = v7;
    *((_QWORD *)v20 + 3) = v8;
    *((_QWORD *)v20 + 4) = v9;
    *((_QWORD *)v20 + 5) = v11;
    v14 = v20 + 48;
    if (v13 != v15)
    {
      do
      {
        v21 = *((_OWORD *)v13 - 3);
        v22 = *((_OWORD *)v13 - 1);
        *((_OWORD *)v20 - 2) = *((_OWORD *)v13 - 2);
        *((_OWORD *)v20 - 1) = v22;
        *((_OWORD *)v20 - 3) = v21;
        v20 -= 48;
        v13 -= 48;
      }
      while (v13 != v15);
      v13 = (char *)*((_QWORD *)this + 9);
    }
    *((_QWORD *)this + 9) = v20;
    *((_QWORD *)this + 10) = v14;
    *((_QWORD *)this + 11) = &v19[48 * v18];
    if (v13)
      operator delete(v13);
  }
  else
  {
    *(_QWORD *)v13 = a2;
    *((_QWORD *)v13 + 1) = v6;
    *((_QWORD *)v13 + 2) = v7;
    *((_QWORD *)v13 + 3) = v8;
    v14 = v13 + 48;
    *((_QWORD *)v13 + 4) = v9;
    *((_QWORD *)v13 + 5) = v10;
  }
  *((_QWORD *)this + 10) = v14;
  *((_QWORD *)this + 18) = v6;
  *((_QWORD *)this + 19) = v7;
  *((_QWORD *)this + 20) = v8;
  *((_QWORD *)this + 21) = v9;
  *((_QWORD *)this + 22) = v11;
  *((_BYTE *)this + 184) = 0;
}

void re::ProfilerThreadContext::end(re::ProfilerThreadContext *this)
{
  uint64_t v2;
  _QWORD *v3;
  _QWORD *v4;
  re::ProfilerAttributions *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  uint8_t v11[16];

  *((_BYTE *)this + 184) = 1;
  v2 = *((_QWORD *)this + 10);
  if (*((_QWORD *)this + 9) == v2)
  {
    v10 = *re::foundationProfilingLogObjects(this);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v11 = 0;
      _os_log_error_impl(&dword_224FE9000, v10, OS_LOG_TYPE_ERROR, "Unbalanced calls to ProfilerThreadContext begin and end.", v11, 2u);
    }
    goto LABEL_16;
  }
  v3 = *(_QWORD **)(v2 - 40);
  if (v3)
    re::ProfilerManager::submit(*(_QWORD *)(v2 - 48), v3);
  v4 = *(_QWORD **)(v2 - 32);
  if (v4)
    re::ProfilerManager::submit(*(_QWORD *)(v2 - 48), v4);
  v5 = *(re::ProfilerAttributions **)(v2 - 24);
  if (v5)
    re::ProfilerManager::submit(*(os_unfair_lock_s **)(v2 - 48), v5);
  v6 = *(_QWORD **)(v2 - 16);
  if (v6)
    re::ProfilerManager::submit(*(_QWORD *)(v2 - 48), v6);
  v7 = *(_QWORD **)(v2 - 8);
  if (v7)
    re::ProfilerManager::submit(*(_QWORD *)(v2 - 48), v7);
  v9 = *((_QWORD *)this + 9);
  v8 = *((_QWORD *)this + 10);
  *((_QWORD *)this + 10) = v8 - 48;
  if (v9 == v8 - 48)
  {
LABEL_16:
    *((_QWORD *)this + 22) = 0;
    *((_OWORD *)this + 9) = 0u;
    *((_OWORD *)this + 10) = 0u;
    goto LABEL_17;
  }
  *((_OWORD *)this + 9) = *(_OWORD *)(v8 - 88);
  *((_OWORD *)this + 10) = *(_OWORD *)(v8 - 72);
  *((_QWORD *)this + 22) = *(_QWORD *)(v8 - 56);
LABEL_17:
  *((_BYTE *)this + 184) = 0;
}

uint64_t re::ProfilerConfig::isStatisticCollectionEnabled(re::ProfilerConfig *this)
{
  unsigned __int8 v1;
  unsigned __int8 *v2;
  int v4;
  const char *v5;
  char v6;
  char v7[2];

  v2 = (unsigned __int8 *)&re::mtl::introspect_SamplerMinMagFilter(BOOL)::info;
  if ((v1 & 1) == 0)
  {
    v2 = (_BYTE *)&re::mtl::introspect_SamplerMinMagFilter(BOOL)::info;
    if (v4)
    {
      re::Defaults::BOOLValue((re::Defaults *)"profiler.statisticcollection.enable", v5, v7);
      v6 = v7[1];
      if (!v7[0])
        v6 = 1;
      re::ProfilerConfig::isStatisticCollectionEnabled(void)::enabled = v6;
      v2 = (_BYTE *)&re::mtl::introspect_SamplerMinMagFilter(BOOL)::info;
    }
  }
  return v2[3288];
}

uint64_t re::internal::PerfStats::beginStatisticsCollection(re::internal::PerfStats *this)
{
  uint64_t result;
  pid_t v3;
  int v4;
  host_t v6;
  int v7;
  mach_msg_type_number_t host_info64_outCnt;

  if (*((_BYTE *)this + 913))
    return puts("Starting perf stats already collected");
  re::internal::enableMemoryStatsCollection(this);
  v3 = getpid();
  *((_DWORD *)this + 229) = proc_pid_rusage(v3, 4, (rusage_info_t *)this) == 0;
  v4 = *((_DWORD *)this + 233);
  if (v4 == 31 || v4 == 4)
  {
    host_info64_outCnt = 38;
    v6 = MEMORY[0x227693D0C]();
    if (host_statistics64(v6, 4, (host_info64_t)this + 148, &host_info64_outCnt))
    {
      printf("failed to get statistics. error %d", 1);
      v7 = 0;
    }
    else
    {
      v7 = 1;
    }
    *((_DWORD *)this + 231) = v7;
  }
  result = mach_absolute_time();
  *((_QWORD *)this + 112) = result;
  *((_BYTE *)this + 913) = 1;
  return result;
}

void re::internal::PerfStats::endStatisticsCollection(re::internal::PerfStats *this, int a2)
{
  pid_t v4;
  re::internal *v5;
  int v6;
  host_t v8;
  int v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  mach_msg_type_number_t host_info64_outCnt;

  if (*((_BYTE *)this + 914))
  {
    puts("Ending perf stats already collected");
  }
  else
  {
    *((_QWORD *)this + 113) = mach_absolute_time();
    v4 = getpid();
    v5 = (re::internal *)proc_pid_rusage(v4, 4, (rusage_info_t *)this + 37);
    *((_DWORD *)this + 230) = (_DWORD)v5 == 0;
    v6 = *((_DWORD *)this + 233);
    if (v6 == 31 || v6 == 4)
    {
      host_info64_outCnt = 38;
      v8 = MEMORY[0x227693D0C]();
      v5 = (re::internal *)host_statistics64(v8, 4, (host_info64_t)this + 186, &host_info64_outCnt);
      if ((_DWORD)v5)
      {
        v5 = (re::internal *)printf("failed to get statistics. error %d", 1);
        v9 = 0;
      }
      else
      {
        v9 = 1;
      }
      *((_DWORD *)this + 232) = v9;
    }
    re::internal::disableMemoryStatsCollection(v5);
    *((_QWORD *)this + 120) = v10;
    *((_QWORD *)this + 121) = v11;
    *((_QWORD *)this + 122) = v12;
    *((_QWORD *)this + 123) = v13;
    *((_QWORD *)this + 124) = v14;
    *((_QWORD *)this + 125) = v15;
    *((_QWORD *)this + 126) = v16;
    *((_QWORD *)this + 127) = v17;
    *((_QWORD *)this + 128) = v18;
    *((_QWORD *)this + 129) = v19;
    *((_BYTE *)this + 914) = 1;
    if (*((_DWORD *)this + 229) && *((_DWORD *)this + 230))
    {
      if (a2)
        re::internal::PerfStats::printStatistics(this, *((_DWORD *)this + 233));
      if (*((_BYTE *)this + 912))
        re::internal::PerfStats::dumpToJson((uint64_t)this, *((_DWORD *)this + 233));
    }
  }
}

re::internal::PerfStats *re::internal::PerfStats::printStatistics(re::internal::PerfStats *this, int a2)
{
  re::internal::PerfStats *v2;

  v2 = this;
  switch(a2)
  {
    case 1:
      return (re::internal::PerfStats *)re::internal::PerfStats::printCPUStatistics(this);
    case 2:
      return (re::internal::PerfStats *)re::internal::PerfStats::printMemoryStatistics(v2);
    case 3:
      re::internal::PerfStats::printCPUStatistics(this);
      return (re::internal::PerfStats *)re::internal::PerfStats::printMemoryStatistics(v2);
    case 4:
      return (re::internal::PerfStats *)re::internal::PerfStats::printVMPagingStatistics((const char **)this);
    case 5:
    case 6:
    case 7:
      return this;
    case 8:
      return (re::internal::PerfStats *)re::internal::PerfStats::printQoSStatistics((const char **)this);
    default:
      if (a2 == 16)
        return (re::internal::PerfStats *)re::internal::PerfStats::printDiskStatistics((const char **)v2);
      if (a2 == 31)
      {
        re::internal::PerfStats::printCPUStatistics(this);
        re::internal::PerfStats::printQoSStatistics((const char **)v2);
        re::internal::PerfStats::printMemoryStatistics(v2);
        re::internal::PerfStats::printVMPagingStatistics((const char **)v2);
        return (re::internal::PerfStats *)re::internal::PerfStats::printDiskStatistics((const char **)v2);
      }
      return this;
  }
}

uint64_t re::internal::PerfStats::dumpToJson(uint64_t a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  std::ios_base *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  std::ios_base *v14;
  const char *v15;
  _QWORD *v16;
  size_t v17;
  _QWORD *v18;
  _QWORD *v19;
  size_t v20;
  _QWORD *v21;
  _QWORD *v22;
  char *v23;
  char v25[1024];
  _QWORD v26[2];
  _BYTE v27[408];
  uint64_t v28[19];
  uint64_t v29;
  _QWORD v30[51];
  _QWORD v31[21];

  v31[19] = *MEMORY[0x24BDAC8D0];
  v4 = MEMORY[0x24BEDB840];
  v5 = MEMORY[0x24BEDB840] + 64;
  v6 = (uint64_t *)MEMORY[0x24BEDB7E8];
  v7 = *(_QWORD *)(MEMORY[0x24BEDB7E8] + 8);
  v8 = *(_QWORD *)(MEMORY[0x24BEDB7E8] + 16);
  v31[0] = MEMORY[0x24BEDB840] + 64;
  v29 = v7;
  *(_QWORD *)((char *)&v30[-1] + *(_QWORD *)(v7 - 24)) = v8;
  v9 = (std::ios_base *)((char *)&v30[-1] + *(_QWORD *)(v29 - 24));
  std::ios_base::init(v9, v30);
  v9[1].__vftable = 0;
  v9[1].__fmtflags_ = -1;
  v29 = v4 + 24;
  v31[0] = v5;
  MEMORY[0x227692FD4](v30);
  if (!std::filebuf::open())
    std::ios_base::clear((std::ios_base *)((char *)&v30[-1] + *(_QWORD *)(v29 - 24)), *(_DWORD *)((char *)&v30[3] + *(_QWORD *)(v29 - 24)) | 4);
  if (v30[15])
  {
    puts("\nResults file opened....");
    v10 = MEMORY[0x24BEDB838];
    v11 = MEMORY[0x24BEDB838] + 64;
    v12 = *(_QWORD *)(MEMORY[0x24BEDB7E0] + 8);
    v13 = *(_QWORD *)(MEMORY[0x24BEDB7E0] + 16);
    v28[0] = MEMORY[0x24BEDB838] + 64;
    v26[0] = v12;
    *(_QWORD *)((char *)v26 + *(_QWORD *)(v12 - 24)) = v13;
    v26[1] = 0;
    v14 = (std::ios_base *)((char *)v26 + *(_QWORD *)(v26[0] - 24));
    std::ios_base::init(v14, v27);
    v14[1].__vftable = 0;
    v14[1].__fmtflags_ = -1;
    v26[0] = v10 + 24;
    v28[0] = v11;
    MEMORY[0x227692FD4](v27);
    if (!std::filebuf::open())
      std::ios_base::clear((std::ios_base *)((char *)v26 + *(_QWORD *)(v26[0] - 24)), *(_DWORD *)&v27[*(_QWORD *)(v26[0] - 24) + 16] | 4);
    std::istream::get();
    if ((*(_DWORD *)&v27[*(_QWORD *)(v26[0] - 24) + 16] & 2) != 0)
      v15 = "[\n";
    else
      v15 = ",\n";
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v29, (uint64_t)v15, 2);
    if (!std::filebuf::close())
      std::ios_base::clear((std::ios_base *)((char *)v26 + *(_QWORD *)(v26[0] - 24)), *(_DWORD *)&v27[*(_QWORD *)(v26[0] - 24) + 16] | 4);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v29, (uint64_t)"{\n", 2);
    v16 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v29, (uint64_t)"\t\"ModuleName\" : \"", 17);
    v17 = strlen(*(const char **)(a1 + 936));
    v18 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v16, *(_QWORD *)(a1 + 936), v17);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v18, (uint64_t)"\",\n", 3);
    v19 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v29, (uint64_t)"\t\"TestName\" : \"", 15);
    v20 = strlen(*(const char **)(a1 + 944));
    v21 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v19, *(_QWORD *)(a1 + 944), v20);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v21, (uint64_t)"\",\n", 3);
    v22 = (_QWORD *)MEMORY[0x24BEDB7E0];
    switch(a2)
    {
      case 1:
        re::internal::PerfStats::addCPUStatisticsToJson(a1, &v29);
        goto LABEL_21;
      case 2:
        goto LABEL_19;
      case 3:
        re::internal::PerfStats::addCPUStatisticsToJson(a1, &v29);
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v29, (uint64_t)",\n", 2);
LABEL_19:
        re::internal::PerfStats::addMemoryStatisticsToJson(a1, &v29);
        goto LABEL_21;
      case 4:
      case 5:
      case 6:
      case 7:
        goto LABEL_21;
      case 8:
        re::internal::PerfStats::addQoSStatisticsToJson(a1, &v29);
        goto LABEL_21;
      default:
        v22 = (_QWORD *)MEMORY[0x24BEDB7E0];
        if (a2 == 16)
          goto LABEL_17;
        if (a2 == 31)
        {
          re::internal::PerfStats::addCPUStatisticsToJson(a1, &v29);
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v29, (uint64_t)",\n", 2);
          re::internal::PerfStats::addMemoryStatisticsToJson(a1, &v29);
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v29, (uint64_t)",\n", 2);
          re::internal::PerfStats::addQoSStatisticsToJson(a1, &v29);
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v29, (uint64_t)",\n", 2);
LABEL_17:
          re::internal::PerfStats::addDiskStatisticsToJson(a1, &v29);
        }
LABEL_21:
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v29, (uint64_t)"\n}", 2);
        v23 = getcwd(v25, 0x400uLL);
        printf("\nTrace file output in current working dir: %s\n", v23);
        if (!std::filebuf::close())
          std::ios_base::clear((std::ios_base *)((char *)&v30[-1] + *(_QWORD *)(v29 - 24)), *(_DWORD *)((char *)&v30[3] + *(_QWORD *)(v29 - 24)) | 4);
        v26[0] = *v22;
        *(_QWORD *)((char *)v26 + *(_QWORD *)(v26[0] - 24)) = v22[3];
        MEMORY[0x227692FE0](v27);
        std::istream::~istream();
        MEMORY[0x227693328](v28);
        break;
    }
  }
  else
  {
    puts("\nError in opening results file....");
  }
  v29 = *v6;
  *(_QWORD *)((char *)&v30[-1] + *(_QWORD *)(v29 - 24)) = v6[3];
  MEMORY[0x227692FE0](v30);
  std::ostream::~ostream();
  return MEMORY[0x227693328](v31);
}

uint64_t re::internal::PerfStats::printCPUStatistics(re::internal::PerfStats *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  double v6;
  unint64_t v7;
  unint64_t v8;
  double v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  double v14;
  float v15;
  float v16;
  float v17;
  mach_timebase_info info;

  v2 = *((_QWORD *)this + 39);
  v3 = *((_QWORD *)this + 40);
  v4 = *((_QWORD *)this + 2);
  v5 = *((_QWORD *)this + 3);
  v6 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v6 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
      v9 = NAN;
      goto LABEL_6;
    }
    LODWORD(v7) = info.numer;
    LODWORD(v8) = info.denom;
    v6 = (double)v7 / (double)v8;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v6;
  }
  v9 = v6 * (double)(unint64_t)(v3 + v2 - (v4 + v5));
LABEL_6:
  v10 = *((_QWORD *)this + 113);
  v11 = *((_QWORD *)this + 112);
  if (v6 < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v14 = NAN;
      goto LABEL_11;
    }
    LODWORD(v12) = info.numer;
    LODWORD(v13) = info.denom;
    v6 = (double)v12 / (double)v13;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v6;
  }
  v14 = v6 * (double)(unint64_t)(v10 - v11);
LABEL_11:
  v15 = v9 / 1000000.0;
  v16 = v14 / 1000000.0;
  else
    v17 = 100.0;
  printf("\n-------------------\nModule : %s\n%s CPU Perf Stats\n-------------------\n", *((const char **)this + 117), *((const char **)this + 118));
  return puts("-------------------");
}

uint64_t re::internal::PerfStats::printQoSStatistics(const char **this)
{
  const char *v2;
  const char *v3;
  double v4;
  unint64_t v5;
  unint64_t v6;
  double v7;
  const char *v8;
  const char *v9;
  unint64_t v10;
  unint64_t v11;
  double v12;
  const char *v13;
  const char *v14;
  unint64_t v15;
  unint64_t v16;
  double v17;
  const char *v18;
  const char *v19;
  unint64_t v20;
  unint64_t v21;
  double v22;
  const char *v23;
  const char *v24;
  unint64_t v25;
  unint64_t v26;
  double v27;
  const char *v28;
  const char *v29;
  unint64_t v30;
  unint64_t v31;
  double v32;
  const char *v33;
  const char *v34;
  unint64_t v35;
  unint64_t v36;
  double v37;
  mach_timebase_info info;

  printf("\n-------------------\nModule : %s\n%s QoS Perf Stats\n-------------------\n", this[117], this[118]);
  v2 = this[57];
  v3 = this[20];
  v4 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v4 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
      v7 = NAN;
      goto LABEL_6;
    }
    LODWORD(v5) = info.numer;
    LODWORD(v6) = info.denom;
    v4 = (double)v5 / (double)v6;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v4;
  }
  v7 = v4 * (double)(unint64_t)(v2 - v3);
LABEL_6:
  v8 = this[58];
  v9 = this[21];
  if (v4 < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v4 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
      v12 = NAN;
      goto LABEL_11;
    }
    LODWORD(v10) = info.numer;
    LODWORD(v11) = info.denom;
    v4 = (double)v10 / (double)v11;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v4;
  }
  v12 = v4 * (double)(unint64_t)(v8 - v9);
LABEL_11:
  v13 = this[59];
  v14 = this[22];
  if (v4 < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v4 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
      v17 = NAN;
      goto LABEL_16;
    }
    LODWORD(v15) = info.numer;
    LODWORD(v16) = info.denom;
    v4 = (double)v15 / (double)v16;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v4;
  }
  v17 = v4 * (double)(unint64_t)(v13 - v14);
LABEL_16:
  v18 = this[60];
  v19 = this[23];
  if (v4 < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v4 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
      v22 = NAN;
      goto LABEL_21;
    }
    LODWORD(v20) = info.numer;
    LODWORD(v21) = info.denom;
    v4 = (double)v20 / (double)v21;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v4;
  }
  v22 = v4 * (double)(unint64_t)(v18 - v19);
LABEL_21:
  v23 = this[61];
  v24 = this[24];
  if (v4 < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v4 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
      v27 = NAN;
      goto LABEL_26;
    }
    LODWORD(v25) = info.numer;
    LODWORD(v26) = info.denom;
    v4 = (double)v25 / (double)v26;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v4;
  }
  v27 = v4 * (double)(unint64_t)(v23 - v24);
LABEL_26:
  v28 = this[62];
  v29 = this[25];
  if (v4 < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v4 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
      v32 = NAN;
      goto LABEL_31;
    }
    LODWORD(v30) = info.numer;
    LODWORD(v31) = info.denom;
    v4 = (double)v30 / (double)v31;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v4;
  }
  v32 = v4 * (double)(unint64_t)(v28 - v29);
LABEL_31:
  v33 = this[63];
  v34 = this[26];
  if (v4 >= 0.0)
  {
LABEL_35:
    v37 = v4 * (double)(unint64_t)(v33 - v34);
    goto LABEL_36;
  }
  if (!mach_timebase_info(&info))
  {
    LODWORD(v35) = info.numer;
    LODWORD(v36) = info.denom;
    v4 = (double)v35 / (double)v36;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v4;
    goto LABEL_35;
  }
  v37 = NAN;
LABEL_36:
  printf("QoS Threads CPU Scheduled Time\nDefault QoS Time [ms] : %f\nMaintenance QoS Time [ms] : %f\nBackground QoS Time [ms] : %f\nUtility QoS Time [ms] : %f\nLegacy QoS Time [ms] : %f\nUser Initiated QoS Time [ms] : %f\nUser Interactive QoS Time [ms] : %f\n", v7 / 1000000.0, v12 / 1000000.0, v17 / 1000000.0, v22 / 1000000.0, v27 / 1000000.0, v32 / 1000000.0, v37 / 1000000.0);
  return puts("-------------------");
}

uint64_t re::internal::PerfStats::printMemoryStatistics(re::internal::PerfStats *this)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  const char *v7;
  float v8;
  float v9;
  float v10;

  v2 = *((_QWORD *)this + 46);
  v3 = *((_QWORD *)this + 9);
  v4 = v3 - v2;
  v5 = v2 >= v3;
  v6 = v2 - v3;
  if (v5)
    v7 = "Increase";
  else
    v7 = "Decrease";
  if (!v5)
    v6 = v4;
  v8 = (double)v6 * 0.0009765625;
  v9 = (double)(unint64_t)(*((_QWORD *)this + 45) - *((_QWORD *)this + 8)) * 0.0009765625;
  v10 = (double)(unint64_t)(*((_QWORD *)this + 44) - *((_QWORD *)this + 7)) * 0.0009765625;
  printf("\n-------------------\nModule : %s\n%s Memory Perf Stats\n-------------------\n", *((const char **)this + 117), *((const char **)this + 118));
  printf("%s in Current Dirty Memory Footprint [kb] : %f\nPeak Dirty Memory Footprint [kb] : %f\n", v7, v8, (double)*((unint64_t *)this + 67) * 0.0009765625);
  printf("Increase in Current Resident Memory Footprint [kb] : %f\nIncrease in Current Wired Memory Footprint [kb] : %f\n", v9, v10);
  puts("\n-------- Malloc Allocation Stats --------");
  printf("Total Heap Allocations [kb] : %f\nTotal Heap Deallocations [kb] : %f\nPeak Heap Allocations [kb] : %f\n", (double)*((uint64_t *)this + 123) * 0.0009765625, (double)*((uint64_t *)this + 124) * 0.0009765625, (double)*((uint64_t *)this + 125) * 0.0009765625);
  printf("Total Heap Node Allocations: %llu\nTotal Heap Node Deallocations: %llu\n", *((_QWORD *)this + 120), *((_QWORD *)this + 121));
  printf("Total VM Allocations [kb] : %f\nTotal VM Deallocations [kb] : %f\nPeak VM Allocations [kb] : %f\n", (double)*((uint64_t *)this + 127) * 0.0009765625, (double)*((uint64_t *)this + 128) * 0.0009765625, (double)*((uint64_t *)this + 129) * 0.0009765625);
  return puts("-------------------");
}

uint64_t re::internal::PerfStats::printVMPagingStatistics(const char **this)
{
  printf("\n-------------------\nModule : %s\n%s Mach Virtual Memory Paging Stats : (page size of %llu bytes)\n-------------------\n", this[117], this[118], *MEMORY[0x24BDB03A8]);
  printf("-----\nPages free at start : %u\nPages free at end : %u\nChange in free pages : %u\n-----\n", *((_DWORD *)this + 148) - *((_DWORD *)this + 171), *((_DWORD *)this + 186) - *((_DWORD *)this + 209), *((_DWORD *)this + 171) - *((_DWORD *)this + 209));
  printf("-----\nPages active at start : %u\nPages active at end : %u\nChange in active pages : %u\n-----\n", *((_DWORD *)this + 149), *((_DWORD *)this + 187), *((_DWORD *)this + 187) - *((_DWORD *)this + 149));
  printf("-----\nPages inactive at start : %u\nPages inactive at end : %u\nChange in inactive page s: %u\n-----\n", *((_DWORD *)this + 150), *((_DWORD *)this + 188), *((_DWORD *)this + 188) - *((_DWORD *)this + 150));
  printf("-----\nPages speculative at start : %u\nPages speculative at end : %u\nChange in speculative pages : %u\n-----\n", *((_DWORD *)this + 171), *((_DWORD *)this + 209), *((_DWORD *)this + 209) - *((_DWORD *)this + 171));
  printf("-----\nPages uncompressed in compressor at start : %llu\nPages uncompressed in compressor  at end : %llu\nChange in uncompressed pages in compressor  : %llu\n-----\n", this[92], this[111], this[111] - this[92]);
  printf("-----\nPages compressed in compressor at start : %u\nPages compressed in compressor at end : %u\nChange in compressed pages in compressor : %u\n-----\n", *((_DWORD *)this + 180), *((_DWORD *)this + 218), *((_DWORD *)this + 218) - *((_DWORD *)this + 180));
  printf("-----\nPages file backed at start : %u\nPages file backed at end : %u\nChange in pages file backed : %u\n-----\n", *((_DWORD *)this + 182), *((_DWORD *)this + 220), *((_DWORD *)this + 220) - *((_DWORD *)this + 182));
  printf("-----\nPages anonymous at start : %u\nPages anonymous at end : %u\nChange in anonymous pages : %u\n-----\n", *((_DWORD *)this + 183), *((_DWORD *)this + 221), *((_DWORD *)this + 221) - *((_DWORD *)this + 183));
  printf("-----\nPages throttled at start : %u\nPages throttled at end : %u\nChange in throttled pages : %u\n-----\n", *((_DWORD *)this + 181), *((_DWORD *)this + 219), *((_DWORD *)this + 219) - *((_DWORD *)this + 181));
  printf("-----\nPages wired down at start : %u\nPages wired down at end : %u\nChange in wired down pages : %u\n-----\n", *((_DWORD *)this + 151), *((_DWORD *)this + 189), *((_DWORD *)this + 189) - *((_DWORD *)this + 151));
  printf("-----\nPages purgeable at start : %u\nPages purgeable at end : %u\nChange in purgeable pages : %u\n-----\n", *((_DWORD *)this + 170), *((_DWORD *)this + 208), *((_DWORD *)this + 208) - *((_DWORD *)this + 170));
  printf("-----\nPage Faults : %llu\n-----\n", this[99] - this[80]);
  printf("-----\nPage CoW faults : %llu\n-----\n", this[100] - this[81]);
  printf("-----\nPages Zero Filled: %llu\n-----\n", this[95] - this[76]);
  printf("-----\nPages Reactivated : %llu\n-----\n", this[96] - this[77]);
  printf("-----\nPages Purged : %llu\n-----\n", this[103] - this[84]);
  printf("-----\nPages Decompressed : %llu\n-----\n", this[105] - this[86]);
  printf("-----\nPages Compressed : %llu\n-----\n", this[106] - this[87]);
  printf("-----\nPage Ins : %llu\n-----\n", this[97] - this[78]);
  printf("-----\nPage Outs : %llu\n-----\n", this[98] - this[79]);
  printf("-----\nPage Swap Ins : %llu\n-----\n", this[107] - this[88]);
  printf("-----\nPage Swap Outs : %llu\n-----\n", this[108] - this[89]);
  return puts("-------------------");
}

uint64_t re::internal::PerfStats::printDiskStatistics(const char **this)
{
  printf("\n-------------------\nModule : %s\n%s Disk Perf Stats\n-------------------\n", this[117], this[118]);
  printf("Total Bytes Read From Disk : %llu\nTotal Bytes Written To Disk : %llu\n", this[55] - this[18], this[56] - this[19]);
  return puts("-------------------");
}

uint64_t re::internal::PerfStats::addCPUStatisticsToJson(uint64_t a1, _QWORD *a2)
{
  double v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  mach_timebase_info info;

  v3 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
  {
    if (mach_timebase_info(&info))
    {
      v3 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    }
    else
    {
      LODWORD(v4) = info.numer;
      LODWORD(v5) = info.denom;
      v3 = (double)v4 / (double)v5;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v3;
    }
  }
  if (v3 < 0.0 && !mach_timebase_info(&info))
  {
    LODWORD(v6) = info.numer;
    LODWORD(v7) = info.denom;
    *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = (double)v6 / (double)v7;
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"TotalCPUCoresAvailable\" : ", 28);
  v8 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v8, (uint64_t)",\n", 2);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"CPUUtil[%]\" : ", 16);
  v9 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v9, (uint64_t)",\n", 2);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"TotalAbsoluteTime[ms]\" : ", 27);
  v10 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v10, (uint64_t)",\n", 2);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"TotalCPUScheduledTime[ms]\" : ", 31);
  v11 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v11, (uint64_t)",\n", 2);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"TotalCPUInstructions\" : ", 26);
  v12 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v12, (uint64_t)",\n", 2);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"TotalCPUCycles\" : ", 20);
  return std::ostream::operator<<();
}

uint64_t re::internal::PerfStats::addMemoryStatisticsToJson(uint64_t a1, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;

  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"PeakDirtyMemoryFootprint[kb]\" : ", 34);
  v3 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v3, (uint64_t)",\n", 2);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"DirtyMemoryIncrease[kb]\" : ", 29);
  v4 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v4, (uint64_t)",\n", 2);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"ResidentMemoryIncrease[kb]\" : ", 32);
  v5 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v5, (uint64_t)",\n", 2);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"WiredMemoryIncrease[kb]\" : ", 29);
  v6 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v6, (uint64_t)",\n", 2);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"TotalHeapAllocations[kb]\" : ", 30);
  v7 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v7, (uint64_t)",\n", 2);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"TotalHeapDeallocations[kb]\" : ", 32);
  v8 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v8, (uint64_t)",\n", 2);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"PeakHeapAllocations[kb]\" : ", 29);
  v9 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v9, (uint64_t)",\n", 2);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"TotalHeapNodeAllocations\" : ", 30);
  v10 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v10, (uint64_t)",\n", 2);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"TotalHeapNodeDeallocations\" : ", 32);
  v11 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v11, (uint64_t)",\n", 2);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"TotalVMAllocations[kb]\" : ", 28);
  v12 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v12, (uint64_t)",\n", 2);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"TotalVMDeallocations[kb]\" : ", 30);
  v13 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v13, (uint64_t)",\n", 2);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"PeakVMAllocations[kb]\" : ", 27);
  return std::ostream::operator<<();
}

uint64_t re::internal::PerfStats::addQoSStatisticsToJson(uint64_t a1, _QWORD *a2)
{
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  unint64_t v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  unint64_t v10;
  _QWORD *v11;
  unint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  unint64_t v16;
  _QWORD *v17;
  unint64_t v18;
  unint64_t v19;
  _QWORD *v20;
  unint64_t v21;
  unint64_t v22;
  mach_timebase_info info;

  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"QoS-UserInitiated-CPUTime[ms]\" : ", 35);
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0 && !mach_timebase_info(&info))
  {
    LODWORD(v3) = info.numer;
    LODWORD(v4) = info.denom;
    *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = (double)v3 / (double)v4;
  }
  v5 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v5, (uint64_t)",\n", 2);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"QoS-UserInteractive-CPUTime[ms]\" : ", 37);
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0 && !mach_timebase_info(&info))
  {
    LODWORD(v6) = info.numer;
    LODWORD(v7) = info.denom;
    *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = (double)v6 / (double)v7;
  }
  v8 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v8, (uint64_t)",\n", 2);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"QoS-Default-CPUTime[ms]\" : ", 29);
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0 && !mach_timebase_info(&info))
  {
    LODWORD(v9) = info.numer;
    LODWORD(v10) = info.denom;
    *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = (double)v9 / (double)v10;
  }
  v11 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v11, (uint64_t)",\n", 2);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"QoS-Background-CPUTime[ms]\" : ", 32);
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0 && !mach_timebase_info(&info))
  {
    LODWORD(v12) = info.numer;
    LODWORD(v13) = info.denom;
    *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = (double)v12 / (double)v13;
  }
  v14 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v14, (uint64_t)",\n", 2);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"QoS-Utility-CPUTime[ms]\" : ", 29);
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0 && !mach_timebase_info(&info))
  {
    LODWORD(v15) = info.numer;
    LODWORD(v16) = info.denom;
    *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = (double)v15 / (double)v16;
  }
  v17 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v17, (uint64_t)",\n", 2);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"QoS-Maintenance-CPUTime[ms]\" : ", 33);
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0 && !mach_timebase_info(&info))
  {
    LODWORD(v18) = info.numer;
    LODWORD(v19) = info.denom;
    *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = (double)v18 / (double)v19;
  }
  v20 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v20, (uint64_t)",\n", 2);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"QoS-Legacy-CPUTime[ms]\" : ", 28);
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0 && !mach_timebase_info(&info))
  {
    LODWORD(v21) = info.numer;
    LODWORD(v22) = info.denom;
    *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = (double)v21 / (double)v22;
  }
  return std::ostream::operator<<();
}

uint64_t re::internal::PerfStats::addDiskStatisticsToJson(uint64_t a1, _QWORD *a2)
{
  _QWORD *v3;

  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"TotalBytesReadFromDisk[kb]\" : ", 32);
  v3 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v3, (uint64_t)",\n", 2);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\t\"TotalBytesWrittenToDisk[kb]\" : ", 33);
  return std::ostream::operator<<();
}

void re::ProfilerManager::~ProfilerManager(_BOOL8 this)
{
  _QWORD *v1;
  NSObject *v2;
  NSObject *v3;
  NSObject *v4;
  NSObject *v5;
  NSObject *v6;
  _QWORD *i;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  _QWORD *j;
  uint64_t v15;
  _QWORD *k;
  re::ProfilerAttributions *v17;
  uint64_t *v18;
  uint64_t *v19;
  uint64_t v20;
  _QWORD *v21;
  _QWORD *v22;
  _QWORD *v23;
  _QWORD *v24;
  _QWORD *v25;
  uint64_t v26;
  _QWORD *v27;
  _QWORD *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  _QWORD *v38;
  _QWORD *v39;
  void *v40;
  void *v41;
  void *v42;
  _QWORD *v43;
  _QWORD *v44;
  void *v45;
  void *v46;
  void *v47;
  _QWORD *v48;
  _QWORD *v49;
  void *v50;
  uint8_t v51[16];
  uint8_t v52[16];
  uint8_t v53[16];
  uint8_t v54[16];
  uint8_t buf[16];

  v1 = (_QWORD *)this;
  if (*(_QWORD *)(this + 136) != *(_QWORD *)(this + 144))
  {
    v2 = *re::foundationProfilingLogObjects((re *)this);
    this = os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
    if (this)
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_224FE9000, v2, OS_LOG_TYPE_DEFAULT, "ProfilerEventStreams submitted but never processed.", buf, 2u);
    }
  }
  if (v1[28] != v1[29])
  {
    v3 = *re::foundationProfilingLogObjects((re *)this);
    this = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
    if (this)
    {
      *(_WORD *)v54 = 0;
      _os_log_impl(&dword_224FE9000, v3, OS_LOG_TYPE_DEFAULT, "ProfilerStatistics submitted but never processed.", v54, 2u);
    }
  }
  if (v1[39] != v1[40])
  {
    v4 = *re::foundationProfilingLogObjects((re *)this);
    this = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
    if (this)
    {
      *(_WORD *)v53 = 0;
      _os_log_impl(&dword_224FE9000, v4, OS_LOG_TYPE_DEFAULT, "ProfilerAttributions submitted but never processed.", v53, 2u);
    }
  }
  if (v1[48] != v1[49])
  {
    v5 = *re::foundationProfilingLogObjects((re *)this);
    this = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
    if (this)
    {
      *(_WORD *)v52 = 0;
      _os_log_impl(&dword_224FE9000, v5, OS_LOG_TYPE_DEFAULT, "ProfilerVisualizers submitted but never processed.", v52, 2u);
    }
  }
  if (v1[57] != v1[58])
  {
    v6 = *re::foundationProfilingLogObjects((re *)this);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v51 = 0;
      _os_log_impl(&dword_224FE9000, v6, OS_LOG_TYPE_DEFAULT, "ProfilerMemoryStatistics submitted but never processed.", v51, 2u);
    }
  }
  for (i = (_QWORD *)v1[11]; i; i = (_QWORD *)*i)
  {
    v8 = (_QWORD *)i[2];
    if (v8)
    {
      v9 = v8[9];
      if (v9)
      {
        v8[10] = v9;
        MEMORY[0x2276933AC]();
      }
      v10 = (_QWORD *)v8[5];
      v11 = (_QWORD *)v8[6];
      if (v10 != v11)
      {
        do
        {
          if (*v10)
            MEMORY[0x2276933AC](*v10, 64);
          ++v10;
        }
        while (v10 != v11);
        v10 = (_QWORD *)v8[5];
      }
      if (v10)
      {
        v8[6] = v10;
        operator delete(v10);
      }
      v12 = (_QWORD *)v8[1];
      v13 = (_QWORD *)v8[2];
      if (v12 != v13)
      {
        do
        {
          if (*v12)
            MEMORY[0x2276933AC](*v12, 64);
          ++v12;
        }
        while (v12 != v13);
        v12 = (_QWORD *)v8[1];
      }
      if (v12)
      {
        v8[2] = v12;
        operator delete(v12);
      }
      MEMORY[0x2276933B8](v8, 0x10A0C40A52C3342);
    }
  }
  for (j = (_QWORD *)v1[22]; j; j = (_QWORD *)*j)
  {
    v15 = j[2];
    if (v15)
      MEMORY[0x2276933AC](v15, 64);
  }
  for (k = (_QWORD *)v1[33]; k; k = (_QWORD *)*k)
  {
    v17 = (re::ProfilerAttributions *)k[2];
    if (v17)
    {
      re::ProfilerAttributions::~ProfilerAttributions(v17);
      MEMORY[0x2276933AC]();
    }
  }
  v18 = (uint64_t *)v1[42];
  v19 = (uint64_t *)v1[43];
  while (v18 != v19)
  {
    v20 = *v18;
    if (*v18)
    {
      v21 = *(_QWORD **)(v20 + 8);
      v22 = *(_QWORD **)(v20 + 16);
      if (v21 != v22)
      {
        do
        {
          if (*v21)
            MEMORY[0x2276933B8](*v21, 0x1000C40CABF92ADLL);
          ++v21;
        }
        while (v21 != v22);
        v21 = *(_QWORD **)(v20 + 8);
      }
      if (v21)
      {
        *(_QWORD *)(v20 + 16) = v21;
        operator delete(v21);
      }
      MEMORY[0x2276933B8](v20, 0x1080C401FB89069);
    }
    ++v18;
  }
  v23 = (_QWORD *)v1[51];
  v24 = (_QWORD *)v1[52];
  while (v23 != v24)
  {
    if (*v23)
      MEMORY[0x2276933AC](*v23, 64);
    ++v23;
  }
  v25 = (_QWORD *)v1[62];
  if (v25)
  {
    do
    {
      v26 = v25[3];
      if (v26)
        (*(void (**)(uint64_t))(*(_QWORD *)v26 + 8))(v26);
      v25 = (_QWORD *)*v25;
    }
    while (v25);
    v27 = (_QWORD *)v1[62];
    if (v27)
    {
      do
      {
        v28 = (_QWORD *)*v27;
        operator delete(v27);
        v27 = v28;
      }
      while (v28);
    }
  }
  v29 = (void *)v1[60];
  v1[60] = 0;
  if (v29)
    operator delete(v29);
  v30 = (void *)v1[57];
  if (v30)
  {
    v1[58] = v30;
    operator delete(v30);
  }
  v31 = (void *)v1[54];
  if (v31)
  {
    v1[55] = v31;
    operator delete(v31);
  }
  v32 = (void *)v1[51];
  if (v32)
  {
    v1[52] = v32;
    operator delete(v32);
  }
  v33 = (void *)v1[48];
  if (v33)
  {
    v1[49] = v33;
    operator delete(v33);
  }
  v34 = (void *)v1[45];
  if (v34)
  {
    v1[46] = v34;
    operator delete(v34);
  }
  v35 = (void *)v1[42];
  if (v35)
  {
    v1[43] = v35;
    operator delete(v35);
  }
  v36 = (void *)v1[39];
  if (v36)
  {
    v1[40] = v36;
    operator delete(v36);
  }
  v37 = (void *)v1[36];
  if (v37)
  {
    v1[37] = v37;
    operator delete(v37);
  }
  v38 = (_QWORD *)v1[33];
  if (v38)
  {
    do
    {
      v39 = (_QWORD *)*v38;
      operator delete(v38);
      v38 = v39;
    }
    while (v39);
  }
  v40 = (void *)v1[31];
  v1[31] = 0;
  if (v40)
    operator delete(v40);
  v41 = (void *)v1[28];
  if (v41)
  {
    v1[29] = v41;
    operator delete(v41);
  }
  v42 = (void *)v1[25];
  if (v42)
  {
    v1[26] = v42;
    operator delete(v42);
  }
  v43 = (_QWORD *)v1[22];
  if (v43)
  {
    do
    {
      v44 = (_QWORD *)*v43;
      operator delete(v43);
      v43 = v44;
    }
    while (v44);
  }
  v45 = (void *)v1[20];
  v1[20] = 0;
  if (v45)
    operator delete(v45);
  v46 = (void *)v1[17];
  if (v46)
  {
    v1[18] = v46;
    operator delete(v46);
  }
  v47 = (void *)v1[14];
  if (v47)
  {
    v1[15] = v47;
    operator delete(v47);
  }
  v48 = (_QWORD *)v1[11];
  if (v48)
  {
    do
    {
      v49 = (_QWORD *)*v48;
      operator delete(v48);
      v48 = v49;
    }
    while (v49);
  }
  v50 = (void *)v1[9];
  v1[9] = 0;
  if (v50)
    operator delete(v50);
}

uint64_t re::ProfilerManager::acquireEventStream(re::ProfilerManager *this, int a2)
{
  os_unfair_lock_s *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  char v12;
  uint64_t v13;
  _QWORD *v14;
  _QWORD v15[3];

  v4 = (os_unfair_lock_s *)((char *)this + 16);
  os_unfair_lock_lock((os_unfair_lock_t)this + 4);
  v5 = *((unsigned __int8 *)this + 532);
  os_unfair_lock_unlock(v4);
  if (!v5)
    return 0;
  v13 = 0;
  if (a2)
  {
    os_unfair_lock_lock((os_unfair_lock_t)this + 3);
    v6 = *((_QWORD *)this + 18);
    if (*((_QWORD *)this + 17) == v6)
    {
      os_unfair_lock_unlock((os_unfair_lock_t)this + 3);
    }
    else
    {
      v13 = *(_QWORD *)(v6 - 8);
      v7 = v13;
      *((_QWORD *)this + 18) = v6 - 8;
      os_unfair_lock_unlock((os_unfair_lock_t)this + 3);
      if (v7)
        return v7;
    }
  }
  os_unfair_lock_lock((os_unfair_lock_t)this + 2);
  v8 = *((_QWORD *)this + 15);
  if (*((_QWORD *)this + 14) == v8)
  {
    if (*((_QWORD *)this + 12) >= *((_QWORD *)this + 3))
    {
      v10 = atomic_load((unint64_t *)this + 4);
      if (v10 != -1)
      {
        v15[0] = &v12;
        v15[1] = this;
        v15[2] = (char *)this + 24;
        v14 = v15;
        std::__call_once((std::once_flag::_State_type *)this + 4, &v14, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<re::ProfilerManager::acquireEventStream(BOOL)::$_0 &&,unsigned long long &,unsigned long &>>);
      }
    }
    else
    {
      v9 = operator new();
      *(_QWORD *)v9 = *(_QWORD *)this;
      *(_QWORD *)(v9 + 8) = 0;
      *(_QWORD *)(v9 + 16) = 0;
      *(_QWORD *)(v9 + 24) = 0;
      *(_DWORD *)(v9 + 32) = 0;
      *(_WORD *)(v9 + 36) = -1;
      *(_QWORD *)(v9 + 48) = 0;
      *(_QWORD *)(v9 + 56) = 0;
      *(_QWORD *)(v9 + 40) = 0;
      *(_DWORD *)(v9 + 64) = 0;
      *(_WORD *)(v9 + 68) = -1;
      *(_QWORD *)(v9 + 80) = 0;
      *(_QWORD *)(v9 + 88) = 0;
      *(_QWORD *)(v9 + 72) = 0;
      v13 = v9;
      std::__hash_table<re::ProfilerEventStream *,std::hash<re::ProfilerEventStream *>,std::equal_to<re::ProfilerEventStream *>,std::allocator<re::ProfilerEventStream *>>::__emplace_unique_key_args<re::ProfilerEventStream *,re::ProfilerEventStream *&>((float *)this + 18, &v13, &v13);
    }
  }
  else
  {
    v13 = *(_QWORD *)(v8 - 8);
    *((_QWORD *)this + 15) = v8 - 8;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)this + 2);
  return v13;
}

_QWORD *re::ProfilerManager::acquireStatistics(re::ProfilerManager *this, int a2)
{
  os_unfair_lock_s *v4;
  int v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;
  unint64_t v12;
  char v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD v17[3];

  v4 = (os_unfair_lock_s *)((char *)this + 16);
  os_unfair_lock_lock((os_unfair_lock_t)this + 4);
  v5 = *((unsigned __int8 *)this + 533);
  os_unfair_lock_unlock(v4);
  if (!v5)
    return 0;
  v15 = 0;
  if (a2)
  {
    os_unfair_lock_lock((os_unfair_lock_t)this + 3);
    v6 = *((_QWORD *)this + 29);
    if (*((_QWORD *)this + 28) == v6)
    {
      os_unfair_lock_unlock((os_unfair_lock_t)this + 3);
    }
    else
    {
      v15 = *(_QWORD **)(v6 - 8);
      v7 = v15;
      *((_QWORD *)this + 29) = v6 - 8;
      os_unfair_lock_unlock((os_unfair_lock_t)this + 3);
      if (v7)
        return v7;
    }
  }
  os_unfair_lock_lock((os_unfair_lock_t)this + 2);
  v8 = *((_QWORD *)this + 26);
  if (*((_QWORD *)this + 25) == v8)
  {
    if (*((_QWORD *)this + 23) >= *((_QWORD *)this + 3))
    {
      v12 = atomic_load((unint64_t *)this + 5);
      if (v12 != -1)
      {
        v17[0] = &v14;
        v17[1] = this;
        v17[2] = (char *)this + 24;
        v16 = v17;
        std::__call_once((std::once_flag::_State_type *)this + 5, &v16, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<re::ProfilerManager::acquireStatistics(BOOL)::$_0 &&,unsigned long long &,unsigned long &>>);
      }
    }
    else
    {
      v9 = operator new(0x2780uLL, (std::align_val_t)0x40uLL);
      *v9 = *(_QWORD *)this;
      v10 = 0x1FFFFFFFFFFFFB18;
      do
      {
        v11 = &v9[v10];
        v11[1264] = -1;
        v11[1265] = 0;
        v11[1267] = 0;
        v11[1266] = 0;
        v10 += 8;
      }
      while (v10 * 8);
      v15 = v9;
      std::__hash_table<re::ProfilerEventStream *,std::hash<re::ProfilerEventStream *>,std::equal_to<re::ProfilerEventStream *>,std::allocator<re::ProfilerEventStream *>>::__emplace_unique_key_args<re::ProfilerEventStream *,re::ProfilerEventStream *&>((float *)this + 40, &v15, &v15);
    }
  }
  else
  {
    v15 = *(_QWORD **)(v8 - 8);
    *((_QWORD *)this + 26) = v8 - 8;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)this + 2);
  return v15;
}

re::ProfilerAttributions *re::ProfilerManager::acquireAttributions(re::ProfilerManager *this, int a2)
{
  os_unfair_lock_s *v4;
  int v5;
  uint64_t v6;
  re::ProfilerAttributions *v7;
  uint64_t v8;
  re::ProfilerAttributions *v9;
  unint64_t v10;
  char v12;
  re::ProfilerAttributions *v13;
  _QWORD *v14;
  _QWORD v15[3];

  v4 = (os_unfair_lock_s *)((char *)this + 16);
  os_unfair_lock_lock((os_unfair_lock_t)this + 4);
  v5 = *((unsigned __int8 *)this + 534);
  os_unfair_lock_unlock(v4);
  if (!v5)
    return 0;
  v13 = 0;
  if (a2)
  {
    os_unfair_lock_lock((os_unfair_lock_t)this + 3);
    v6 = *((_QWORD *)this + 40);
    if (*((_QWORD *)this + 39) == v6)
    {
      os_unfair_lock_unlock((os_unfair_lock_t)this + 3);
    }
    else
    {
      v13 = *(re::ProfilerAttributions **)(v6 - 8);
      v7 = v13;
      *((_QWORD *)this + 40) = v6 - 8;
      os_unfair_lock_unlock((os_unfair_lock_t)this + 3);
      if (v7)
        return v7;
    }
  }
  os_unfair_lock_lock((os_unfair_lock_t)this + 2);
  v8 = *((_QWORD *)this + 37);
  if (*((_QWORD *)this + 36) == v8)
  {
    if (*((_QWORD *)this + 34) >= *((_QWORD *)this + 3))
    {
      v10 = atomic_load((unint64_t *)this + 6);
      if (v10 != -1)
      {
        v15[0] = &v12;
        v15[1] = this;
        v15[2] = (char *)this + 24;
        v14 = v15;
        std::__call_once((std::once_flag::_State_type *)this + 6, &v14, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<re::ProfilerManager::acquireAttributions(BOOL)::$_0 &&,unsigned long long &,unsigned long &>>);
      }
    }
    else
    {
      v9 = (re::ProfilerAttributions *)operator new(0x180uLL, (std::align_val_t)0x40uLL);
      v13 = re::ProfilerAttributions::ProfilerAttributions(v9, *(_QWORD *)this);
      std::__hash_table<re::ProfilerEventStream *,std::hash<re::ProfilerEventStream *>,std::equal_to<re::ProfilerEventStream *>,std::allocator<re::ProfilerEventStream *>>::__emplace_unique_key_args<re::ProfilerEventStream *,re::ProfilerEventStream *&>((float *)this + 62, &v13, &v13);
    }
  }
  else
  {
    v13 = *(re::ProfilerAttributions **)(v8 - 8);
    *((_QWORD *)this + 37) = v8 - 8;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)this + 2);
  return v13;
}

uint64_t re::ProfilerManager::acquireVisualizer(re::ProfilerManager *this)
{
  return 0;
}

_QWORD *re::ProfilerManager::acquireMemoryStatistics(re::ProfilerManager *this, int a2)
{
  os_unfair_lock_s *v4;
  int v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  unint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  _QWORD *v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  char *v22;
  char *v23;
  char *v24;
  char *v25;
  uint64_t v26;
  char v28;
  _QWORD *v29;
  _QWORD v30[3];

  v4 = (os_unfair_lock_s *)((char *)this + 16);
  os_unfair_lock_lock((os_unfair_lock_t)this + 4);
  v5 = *((unsigned __int8 *)this + 535);
  os_unfair_lock_unlock(v4);
  if (!v5)
    return 0;
  if (a2)
  {
    os_unfair_lock_lock((os_unfair_lock_t)this + 3);
    v6 = *((_QWORD *)this + 58);
    if (*((_QWORD *)this + 57) == v6)
    {
      os_unfair_lock_unlock((os_unfair_lock_t)this + 3);
    }
    else
    {
      v7 = *(_QWORD **)(v6 - 8);
      *((_QWORD *)this + 58) = v6 - 8;
      os_unfair_lock_unlock((os_unfair_lock_t)this + 3);
      if (v7)
        return v7;
    }
  }
  os_unfair_lock_lock((os_unfair_lock_t)this + 2);
  v8 = *((_QWORD *)this + 55);
  if (*((_QWORD *)this + 54) == v8)
  {
    v10 = *((_QWORD *)this + 51);
    v9 = (_QWORD *)*((_QWORD *)this + 52);
    v11 = ((uint64_t)v9 - v10) >> 3;
    if (v11 >= *((_QWORD *)this + 3))
    {
      v17 = atomic_load((unint64_t *)this + 8);
      if (v17 != -1)
      {
        v30[0] = &v28;
        v30[1] = this;
        v30[2] = (char *)this + 24;
        v29 = v30;
        std::__call_once((std::once_flag::_State_type *)this + 8, &v29, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<re::ProfilerManager::acquireMemoryStatistics(BOOL)::$_0 &&,unsigned long long &,unsigned long &>>);
      }
      v7 = 0;
    }
    else
    {
      v12 = operator new(0x580uLL, (std::align_val_t)0x40uLL);
      v7 = v12;
      v13 = 0;
      *v12 = *(_QWORD *)this;
      do
      {
        v14 = &v12[v13];
        v14[8] = -1;
        *(_OWORD *)(v14 + 9) = 0uLL;
        *(_OWORD *)(v14 + 11) = 0uLL;
        *(_OWORD *)(v14 + 13) = 0uLL;
        v13 += 8;
      }
      while (v13 != 160);
      v12[168] = 0;
      v15 = *((_QWORD *)this + 53);
      if ((unint64_t)v9 >= v15)
      {
        v18 = v11 + 1;
        if ((v11 + 1) >> 61)
          abort();
        v19 = v15 - v10;
        if (v19 >> 2 > v18)
          v18 = v19 >> 2;
        if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8)
          v20 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v20 = v18;
        if (v20)
          v21 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long long>>((uint64_t)this + 424, v20);
        else
          v21 = 0;
        v22 = &v21[8 * v11];
        v23 = &v21[8 * v20];
        *(_QWORD *)v22 = v7;
        v16 = v22 + 8;
        v25 = (char *)*((_QWORD *)this + 51);
        v24 = (char *)*((_QWORD *)this + 52);
        if (v24 != v25)
        {
          do
          {
            v26 = *((_QWORD *)v24 - 1);
            v24 -= 8;
            *((_QWORD *)v22 - 1) = v26;
            v22 -= 8;
          }
          while (v24 != v25);
          v24 = (char *)*((_QWORD *)this + 51);
        }
        *((_QWORD *)this + 51) = v22;
        *((_QWORD *)this + 52) = v16;
        *((_QWORD *)this + 53) = v23;
        if (v24)
          operator delete(v24);
      }
      else
      {
        *v9 = v12;
        v16 = v9 + 1;
      }
      *((_QWORD *)this + 52) = v16;
    }
  }
  else
  {
    v7 = *(_QWORD **)(v8 - 8);
    *((_QWORD *)this + 55) = v8 - 8;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)this + 2);
  return v7;
}

void re::ProfilerManager::submit(uint64_t a1, _QWORD *a2)
{
  os_unfair_lock_s *v4;
  uint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  v4 = (os_unfair_lock_s *)(a1 + 12);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 12));
  if (!a2)
  {
    re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) ", "stream", "submit", 308);
    _os_crash();
    __break(1u);
    goto LABEL_21;
  }
  if (*a2 != *(_QWORD *)a1)
  {
LABEL_21:
    re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) ", "stream->ownerId() == m_identifier", "submit", 309);
    _os_crash();
    __break(1u);
    goto LABEL_22;
  }
  v6 = *(_QWORD *)(a1 + 152);
  v7 = *(_QWORD **)(a1 + 144);
  if ((unint64_t)v7 < v6)
  {
    *v7 = a2;
    v8 = v7 + 1;
    goto LABEL_19;
  }
  v9 = *(_QWORD *)(a1 + 136);
  v10 = ((uint64_t)v7 - v9) >> 3;
  if ((unint64_t)(v10 + 1) >> 61)
LABEL_22:
    abort();
  v11 = v6 - v9;
  v12 = v11 >> 2;
  if (v11 >> 2 <= (unint64_t)(v10 + 1))
    v12 = v10 + 1;
  if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8)
    v13 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v13 = v12;
  if (v13)
    v14 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long long>>(a1 + 152, v13);
  else
    v14 = 0;
  v15 = &v14[8 * v10];
  v16 = &v14[8 * v13];
  *(_QWORD *)v15 = a2;
  v8 = v15 + 8;
  v18 = *(char **)(a1 + 136);
  v17 = *(char **)(a1 + 144);
  if (v17 != v18)
  {
    do
    {
      v19 = *((_QWORD *)v17 - 1);
      v17 -= 8;
      *((_QWORD *)v15 - 1) = v19;
      v15 -= 8;
    }
    while (v17 != v18);
    v17 = *(char **)(a1 + 136);
  }
  *(_QWORD *)(a1 + 136) = v15;
  *(_QWORD *)(a1 + 144) = v8;
  *(_QWORD *)(a1 + 152) = v16;
  if (v17)
    operator delete(v17);
LABEL_19:
  *(_QWORD *)(a1 + 144) = v8;
  os_unfair_lock_unlock(v4);
}

{
  os_unfair_lock_s *v4;
  uint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  v4 = (os_unfair_lock_s *)(a1 + 12);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 12));
  if (!a2)
  {
    re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) ", "statistics", "submit", 317);
    _os_crash();
    __break(1u);
    goto LABEL_21;
  }
  if (*a2 != *(_QWORD *)a1)
  {
LABEL_21:
    re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) ", "statistics->ownerId() == m_identifier", "submit", 318);
    _os_crash();
    __break(1u);
    goto LABEL_22;
  }
  v6 = *(_QWORD *)(a1 + 240);
  v7 = *(_QWORD **)(a1 + 232);
  if ((unint64_t)v7 < v6)
  {
    *v7 = a2;
    v8 = v7 + 1;
    goto LABEL_19;
  }
  v9 = *(_QWORD *)(a1 + 224);
  v10 = ((uint64_t)v7 - v9) >> 3;
  if ((unint64_t)(v10 + 1) >> 61)
LABEL_22:
    abort();
  v11 = v6 - v9;
  v12 = v11 >> 2;
  if (v11 >> 2 <= (unint64_t)(v10 + 1))
    v12 = v10 + 1;
  if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8)
    v13 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v13 = v12;
  if (v13)
    v14 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long long>>(a1 + 240, v13);
  else
    v14 = 0;
  v15 = &v14[8 * v10];
  v16 = &v14[8 * v13];
  *(_QWORD *)v15 = a2;
  v8 = v15 + 8;
  v18 = *(char **)(a1 + 224);
  v17 = *(char **)(a1 + 232);
  if (v17 != v18)
  {
    do
    {
      v19 = *((_QWORD *)v17 - 1);
      v17 -= 8;
      *((_QWORD *)v15 - 1) = v19;
      v15 -= 8;
    }
    while (v17 != v18);
    v17 = *(char **)(a1 + 224);
  }
  *(_QWORD *)(a1 + 224) = v15;
  *(_QWORD *)(a1 + 232) = v8;
  *(_QWORD *)(a1 + 240) = v16;
  if (v17)
    operator delete(v17);
LABEL_19:
  *(_QWORD *)(a1 + 232) = v8;
  os_unfair_lock_unlock(v4);
}

{
  os_unfair_lock_s *v4;
  uint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  v4 = (os_unfair_lock_s *)(a1 + 12);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 12));
  if (!a2)
  {
    re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) ", "memoryStatistics", "submit", 335);
    _os_crash();
    __break(1u);
    goto LABEL_21;
  }
  if (*a2 != *(_QWORD *)a1)
  {
LABEL_21:
    re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) ", "memoryStatistics->ownerId() == m_identifier", "submit", 336);
    _os_crash();
    __break(1u);
    goto LABEL_22;
  }
  v7 = *(_QWORD **)(a1 + 464);
  v6 = *(_QWORD *)(a1 + 472);
  if ((unint64_t)v7 < v6)
  {
    *v7 = a2;
    v8 = v7 + 1;
    goto LABEL_19;
  }
  v9 = *(_QWORD *)(a1 + 456);
  v10 = ((uint64_t)v7 - v9) >> 3;
  if ((unint64_t)(v10 + 1) >> 61)
LABEL_22:
    abort();
  v11 = v6 - v9;
  v12 = v11 >> 2;
  if (v11 >> 2 <= (unint64_t)(v10 + 1))
    v12 = v10 + 1;
  if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8)
    v13 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v13 = v12;
  if (v13)
    v14 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long long>>(a1 + 472, v13);
  else
    v14 = 0;
  v15 = &v14[8 * v10];
  v16 = &v14[8 * v13];
  *(_QWORD *)v15 = a2;
  v8 = v15 + 8;
  v18 = *(char **)(a1 + 456);
  v17 = *(char **)(a1 + 464);
  if (v17 != v18)
  {
    do
    {
      v19 = *((_QWORD *)v17 - 1);
      v17 -= 8;
      *((_QWORD *)v15 - 1) = v19;
      v15 -= 8;
    }
    while (v17 != v18);
    v17 = *(char **)(a1 + 456);
  }
  *(_QWORD *)(a1 + 456) = v15;
  *(_QWORD *)(a1 + 464) = v8;
  *(_QWORD *)(a1 + 472) = v16;
  if (v17)
    operator delete(v17);
LABEL_19:
  *(_QWORD *)(a1 + 464) = v8;
  os_unfair_lock_unlock(v4);
}

{
  os_unfair_lock_s *v4;
  uint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  v4 = (os_unfair_lock_s *)(a1 + 12);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 12));
  if (!a2)
  {
    re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) ", "renderer", "submit", 344);
    _os_crash();
    __break(1u);
    goto LABEL_21;
  }
  if (*a2 != *(_QWORD *)a1)
  {
LABEL_21:
    re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) ", "renderer->ownerId() == m_identifier", "submit", 345);
    _os_crash();
    __break(1u);
    goto LABEL_22;
  }
  v7 = *(_QWORD **)(a1 + 392);
  v6 = *(_QWORD *)(a1 + 400);
  if ((unint64_t)v7 < v6)
  {
    *v7 = a2;
    v8 = v7 + 1;
    goto LABEL_19;
  }
  v9 = *(_QWORD *)(a1 + 384);
  v10 = ((uint64_t)v7 - v9) >> 3;
  if ((unint64_t)(v10 + 1) >> 61)
LABEL_22:
    abort();
  v11 = v6 - v9;
  v12 = v11 >> 2;
  if (v11 >> 2 <= (unint64_t)(v10 + 1))
    v12 = v10 + 1;
  if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8)
    v13 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v13 = v12;
  if (v13)
    v14 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long long>>(a1 + 400, v13);
  else
    v14 = 0;
  v15 = &v14[8 * v10];
  v16 = &v14[8 * v13];
  *(_QWORD *)v15 = a2;
  v8 = v15 + 8;
  v18 = *(char **)(a1 + 384);
  v17 = *(char **)(a1 + 392);
  if (v17 != v18)
  {
    do
    {
      v19 = *((_QWORD *)v17 - 1);
      v17 -= 8;
      *((_QWORD *)v15 - 1) = v19;
      v15 -= 8;
    }
    while (v17 != v18);
    v17 = *(char **)(a1 + 384);
  }
  *(_QWORD *)(a1 + 384) = v15;
  *(_QWORD *)(a1 + 392) = v8;
  *(_QWORD *)(a1 + 400) = v16;
  if (v17)
    operator delete(v17);
LABEL_19:
  *(_QWORD *)(a1 + 392) = v8;
  os_unfair_lock_unlock(v4);
}

void re::ProfilerManager::submit(os_unfair_lock_s *this, re::ProfilerAttributions *a2)
{
  os_unfair_lock_s *v4;
  uint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  v4 = this + 3;
  os_unfair_lock_lock(this + 3);
  if (!a2)
  {
    re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) ", "attributions", "submit", 326);
    _os_crash();
    __break(1u);
    goto LABEL_21;
  }
  if (*((_QWORD *)a2 + 32) != *(_QWORD *)&this->_os_unfair_lock_opaque)
  {
LABEL_21:
    re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) ", "attributions->ownerId() == m_identifier", "submit", 327);
    _os_crash();
    __break(1u);
    goto LABEL_22;
  }
  v7 = *(_QWORD **)&this[80]._os_unfair_lock_opaque;
  v6 = *(_QWORD *)&this[82]._os_unfair_lock_opaque;
  if ((unint64_t)v7 < v6)
  {
    *v7 = a2;
    v8 = v7 + 1;
    goto LABEL_19;
  }
  v9 = *(_QWORD *)&this[78]._os_unfair_lock_opaque;
  v10 = ((uint64_t)v7 - v9) >> 3;
  if ((unint64_t)(v10 + 1) >> 61)
LABEL_22:
    abort();
  v11 = v6 - v9;
  v12 = v11 >> 2;
  if (v11 >> 2 <= (unint64_t)(v10 + 1))
    v12 = v10 + 1;
  if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8)
    v13 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v13 = v12;
  if (v13)
    v14 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long long>>((uint64_t)&this[82], v13);
  else
    v14 = 0;
  v15 = &v14[8 * v10];
  v16 = &v14[8 * v13];
  *(_QWORD *)v15 = a2;
  v8 = v15 + 8;
  v18 = *(char **)&this[78]._os_unfair_lock_opaque;
  v17 = *(char **)&this[80]._os_unfair_lock_opaque;
  if (v17 != v18)
  {
    do
    {
      v19 = *((_QWORD *)v17 - 1);
      v17 -= 8;
      *((_QWORD *)v15 - 1) = v19;
      v15 -= 8;
    }
    while (v17 != v18);
    v17 = *(char **)&this[78]._os_unfair_lock_opaque;
  }
  *(_QWORD *)&this[78]._os_unfair_lock_opaque = v15;
  *(_QWORD *)&this[80]._os_unfair_lock_opaque = v8;
  *(_QWORD *)&this[82]._os_unfair_lock_opaque = v16;
  if (v17)
    operator delete(v17);
LABEL_19:
  *(_QWORD *)&this[80]._os_unfair_lock_opaque = v8;
  os_unfair_lock_unlock(v4);
}

void re::ProfilerManager::process(uint64_t a1, _QWORD *a2)
{
  os_unfair_lock_s *v4;
  _BYTE *v5;
  _BYTE *v6;
  size_t v7;
  uint64_t v8;
  _BYTE *v9;
  _BYTE *v10;
  size_t v11;
  uint64_t v12;
  _BYTE *v13;
  _BYTE *v14;
  size_t v15;
  uint64_t v16;
  _BYTE *v17;
  _BYTE *v18;
  size_t v19;
  uint64_t v20;
  re::ProfilerAttributions **v21;
  re::ProfilerAttributions **v22;
  re::ProfilerAttributions *v23;
  _QWORD *i;
  _BYTE *v25;
  unsigned int v26;
  uint64_t *v27;
  uint64_t *v28;
  uint64_t v29;
  _QWORD *v30;
  _QWORD *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  re::ProfilerAttributions **v35;
  re::ProfilerAttributions **v36;
  re::ProfilerAttributions *v37;
  uint64_t *v38;
  uint64_t *v39;
  uint64_t v40;
  uint64_t j;
  uint64_t v42;
  uint64_t *v43;
  uint64_t *v44;
  _QWORD *v45;
  _QWORD *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  char *v53;
  char *v54;
  char *v55;
  char *v56;
  uint64_t v57;
  uint64_t *v58;
  uint64_t *v59;
  _QWORD *v60;
  _QWORD *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  unint64_t v67;
  char *v68;
  char *v69;
  char *v70;
  char *v71;
  uint64_t v72;
  re::ProfilerAttributions **v73;
  re::ProfilerAttributions **v74;
  _QWORD *v75;
  re::ProfilerAttributions **v76;
  re::ProfilerAttributions *v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  unint64_t v82;
  char *v83;
  char *v84;
  char *v85;
  char *v86;
  uint64_t v87;
  uint64_t *v88;
  uint64_t *v89;
  _QWORD *v90;
  _QWORD *v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  unint64_t v97;
  char *v98;
  char *v99;
  char *v100;
  char *v101;
  uint64_t v102;
  void *__p;
  char *v104;
  char *v105;
  void *v106;
  re::ProfilerAttributions **v107;
  char *v108;
  void *v109;
  char *v110;
  char *v111;
  void *v112;
  char *v113;
  char *v114;

  v4 = (os_unfair_lock_s *)(a1 + 12);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 12));
  v112 = 0;
  v113 = 0;
  v114 = 0;
  v6 = *(_BYTE **)(a1 + 136);
  v5 = *(_BYTE **)(a1 + 144);
  v7 = v5 - v6;
  if (v5 != v6)
  {
    if (v5 - v6 < 0)
      goto LABEL_121;
    v112 = std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long long>>((uint64_t)&v114, v7 >> 3);
    v114 = (char *)v112 + 8 * v8;
    memmove(v112, v6, v7);
    v113 = (char *)v112 + v7;
  }
  v109 = 0;
  v110 = 0;
  v111 = 0;
  v10 = *(_BYTE **)(a1 + 224);
  v9 = *(_BYTE **)(a1 + 232);
  v11 = v9 - v10;
  if (v9 != v10)
  {
    if (v9 - v10 < 0)
      goto LABEL_121;
    v109 = std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long long>>((uint64_t)&v111, v11 >> 3);
    v111 = (char *)v109 + 8 * v12;
    memmove(v109, v10, v11);
    v110 = (char *)v109 + v11;
  }
  v106 = 0;
  v107 = 0;
  v108 = 0;
  v14 = *(_BYTE **)(a1 + 312);
  v13 = *(_BYTE **)(a1 + 320);
  v15 = v13 - v14;
  if (v13 != v14)
  {
    if (v13 - v14 < 0)
      goto LABEL_121;
    v106 = std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long long>>((uint64_t)&v108, v15 >> 3);
    v108 = (char *)v106 + 8 * v16;
    memmove(v106, v14, v15);
    v107 = (re::ProfilerAttributions **)((char *)v106 + v15);
  }
  __p = 0;
  v104 = 0;
  v105 = 0;
  v18 = *(_BYTE **)(a1 + 456);
  v17 = *(_BYTE **)(a1 + 464);
  v19 = v17 - v18;
  if (v17 == v18)
    goto LABEL_13;
  if (v17 - v18 < 0)
LABEL_121:
    abort();
  __p = std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long long>>((uint64_t)&v105, v19 >> 3);
  v105 = (char *)__p + 8 * v20;
  memmove(__p, v18, v19);
  v104 = (char *)__p + v19;
  v18 = *(_BYTE **)(a1 + 456);
LABEL_13:
  *(_QWORD *)(a1 + 144) = *(_QWORD *)(a1 + 136);
  *(_QWORD *)(a1 + 232) = *(_QWORD *)(a1 + 224);
  *(_QWORD *)(a1 + 320) = *(_QWORD *)(a1 + 312);
  *(_QWORD *)(a1 + 464) = v18;
  os_unfair_lock_unlock(v4);
  if (a2[3])
  {
    v21 = (re::ProfilerAttributions **)v106;
    v22 = v107;
    while (v21 != v22)
    {
      v23 = *v21++;
      re::ProfilerAttributions::resolveDeferred(v23, a2);
    }
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  ++*(_DWORD *)(a1 + 528);
  for (i = *(_QWORD **)(a1 + 496); i; i = (_QWORD *)*i)
  {
    v25 = (_BYTE *)i[3];
    if (v25[8])
    {
      v26 = *(_DWORD *)(a1 + 528);
      if (!(v26 % (*(unsigned int (**)(_QWORD))(*(_QWORD *)v25 + 56))(i[3])))
        (*(void (**)(_BYTE *, _QWORD, void **, void **, void **, void **))(*(_QWORD *)v25 + 16))(v25, *(_QWORD *)(a1 + 520), &v112, &v109, &v106, &__p);
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 16));
  v27 = (uint64_t *)v112;
  v28 = (uint64_t *)v113;
  while (v27 != v28)
  {
    v29 = *v27++;
    *(_DWORD *)(v29 + 32) = 0;
    *(_DWORD *)(v29 + 64) = 0;
    *(_QWORD *)(v29 + 80) = *(_QWORD *)(v29 + 72);
  }
  v30 = v109;
  v31 = v110;
  if (v109 != v110)
  {
    do
    {
      v32 = *v30 + 64;
      v33 = -10048;
      do
      {
        v34 = v32 + v33;
        *(_OWORD *)(v34 + 10048) = re::kProfilerCounterEmpty;
        *(_OWORD *)(v34 + 10064) = *(_OWORD *)algn_226192810;
        v33 += 64;
      }
      while (v33);
      ++v30;
    }
    while (v30 != v31);
  }
  v35 = (re::ProfilerAttributions **)v106;
  v36 = v107;
  while (v35 != v36)
  {
    v37 = *v35++;
    re::ProfilerAttributions::clear(v37);
  }
  v38 = (uint64_t *)__p;
  v39 = (uint64_t *)v104;
  if (__p != v104)
  {
    do
    {
      v40 = *v38;
      for (j = 64; j != 1344; j += 64)
      {
        v42 = v40 + j;
        *(_OWORD *)v42 = re::kProfilerMemoryCounterEmpty;
        *(_OWORD *)(v42 + 16) = *(_OWORD *)algn_226192850;
        *(_OWORD *)(v42 + 32) = xmmword_226192860;
        *(_QWORD *)(v42 + 48) = 0;
      }
      *(_QWORD *)(v40 + 1344) = 0;
      ++v38;
    }
    while (v38 != v39);
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 8));
  v43 = (uint64_t *)v112;
  v44 = (uint64_t *)v113;
  if (v112 != v113)
  {
    v45 = (_QWORD *)(a1 + 128);
    v46 = *(_QWORD **)(a1 + 120);
    do
    {
      v47 = *v43;
      if ((unint64_t)v46 >= *v45)
      {
        v48 = *(_QWORD *)(a1 + 112);
        v49 = ((uint64_t)v46 - v48) >> 3;
        if ((unint64_t)(v49 + 1) >> 61)
          goto LABEL_121;
        v50 = *v45 - v48;
        v51 = v50 >> 2;
        if (v50 >> 2 <= (unint64_t)(v49 + 1))
          v51 = v49 + 1;
        if ((unint64_t)v50 >= 0x7FFFFFFFFFFFFFF8)
          v52 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v52 = v51;
        if (v52)
          v53 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long long>>(a1 + 128, v52);
        else
          v53 = 0;
        v54 = &v53[8 * v49];
        *(_QWORD *)v54 = v47;
        v46 = v54 + 8;
        v56 = *(char **)(a1 + 112);
        v55 = *(char **)(a1 + 120);
        if (v55 != v56)
        {
          do
          {
            v57 = *((_QWORD *)v55 - 1);
            v55 -= 8;
            *((_QWORD *)v54 - 1) = v57;
            v54 -= 8;
          }
          while (v55 != v56);
          v55 = *(char **)(a1 + 112);
        }
        *(_QWORD *)(a1 + 112) = v54;
        *(_QWORD *)(a1 + 120) = v46;
        *(_QWORD *)(a1 + 128) = &v53[8 * v52];
        if (v55)
          operator delete(v55);
      }
      else
      {
        *v46++ = v47;
      }
      *(_QWORD *)(a1 + 120) = v46;
      ++v43;
    }
    while (v43 != v44);
  }
  v58 = (uint64_t *)v109;
  v59 = (uint64_t *)v110;
  if (v109 != v110)
  {
    v60 = (_QWORD *)(a1 + 216);
    v61 = *(_QWORD **)(a1 + 208);
    do
    {
      v62 = *v58;
      if ((unint64_t)v61 >= *v60)
      {
        v63 = *(_QWORD *)(a1 + 200);
        v64 = ((uint64_t)v61 - v63) >> 3;
        if ((unint64_t)(v64 + 1) >> 61)
          goto LABEL_121;
        v65 = *v60 - v63;
        v66 = v65 >> 2;
        if (v65 >> 2 <= (unint64_t)(v64 + 1))
          v66 = v64 + 1;
        if ((unint64_t)v65 >= 0x7FFFFFFFFFFFFFF8)
          v67 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v67 = v66;
        if (v67)
          v68 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long long>>(a1 + 216, v67);
        else
          v68 = 0;
        v69 = &v68[8 * v64];
        *(_QWORD *)v69 = v62;
        v61 = v69 + 8;
        v71 = *(char **)(a1 + 200);
        v70 = *(char **)(a1 + 208);
        if (v70 != v71)
        {
          do
          {
            v72 = *((_QWORD *)v70 - 1);
            v70 -= 8;
            *((_QWORD *)v69 - 1) = v72;
            v69 -= 8;
          }
          while (v70 != v71);
          v70 = *(char **)(a1 + 200);
        }
        *(_QWORD *)(a1 + 200) = v69;
        *(_QWORD *)(a1 + 208) = v61;
        *(_QWORD *)(a1 + 216) = &v68[8 * v67];
        if (v70)
          operator delete(v70);
      }
      else
      {
        *v61++ = v62;
      }
      *(_QWORD *)(a1 + 208) = v61;
      ++v58;
    }
    while (v58 != v59);
  }
  v73 = (re::ProfilerAttributions **)v106;
  v74 = v107;
  if (v106 != v107)
  {
    v75 = (_QWORD *)(a1 + 304);
    v76 = *(re::ProfilerAttributions ***)(a1 + 296);
    do
    {
      v77 = *v73;
      if ((unint64_t)v76 >= *v75)
      {
        v78 = *(_QWORD *)(a1 + 288);
        v79 = ((uint64_t)v76 - v78) >> 3;
        if ((unint64_t)(v79 + 1) >> 61)
          goto LABEL_121;
        v80 = *v75 - v78;
        v81 = v80 >> 2;
        if (v80 >> 2 <= (unint64_t)(v79 + 1))
          v81 = v79 + 1;
        if ((unint64_t)v80 >= 0x7FFFFFFFFFFFFFF8)
          v82 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v82 = v81;
        if (v82)
          v83 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long long>>(a1 + 304, v82);
        else
          v83 = 0;
        v84 = &v83[8 * v79];
        *(_QWORD *)v84 = v77;
        v76 = (re::ProfilerAttributions **)(v84 + 8);
        v86 = *(char **)(a1 + 288);
        v85 = *(char **)(a1 + 296);
        if (v85 != v86)
        {
          do
          {
            v87 = *((_QWORD *)v85 - 1);
            v85 -= 8;
            *((_QWORD *)v84 - 1) = v87;
            v84 -= 8;
          }
          while (v85 != v86);
          v85 = *(char **)(a1 + 288);
        }
        *(_QWORD *)(a1 + 288) = v84;
        *(_QWORD *)(a1 + 296) = v76;
        *(_QWORD *)(a1 + 304) = &v83[8 * v82];
        if (v85)
          operator delete(v85);
      }
      else
      {
        *v76++ = v77;
      }
      *(_QWORD *)(a1 + 296) = v76;
      ++v73;
    }
    while (v73 != v74);
  }
  v88 = (uint64_t *)__p;
  v89 = (uint64_t *)v104;
  if (__p != v104)
  {
    v90 = (_QWORD *)(a1 + 448);
    v91 = *(_QWORD **)(a1 + 440);
    do
    {
      v92 = *v88;
      if ((unint64_t)v91 >= *v90)
      {
        v93 = *(_QWORD *)(a1 + 432);
        v94 = ((uint64_t)v91 - v93) >> 3;
        if ((unint64_t)(v94 + 1) >> 61)
          goto LABEL_121;
        v95 = *v90 - v93;
        v96 = v95 >> 2;
        if (v95 >> 2 <= (unint64_t)(v94 + 1))
          v96 = v94 + 1;
        if ((unint64_t)v95 >= 0x7FFFFFFFFFFFFFF8)
          v97 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v97 = v96;
        if (v97)
          v98 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long long>>(a1 + 448, v97);
        else
          v98 = 0;
        v99 = &v98[8 * v94];
        *(_QWORD *)v99 = v92;
        v91 = v99 + 8;
        v101 = *(char **)(a1 + 432);
        v100 = *(char **)(a1 + 440);
        if (v100 != v101)
        {
          do
          {
            v102 = *((_QWORD *)v100 - 1);
            v100 -= 8;
            *((_QWORD *)v99 - 1) = v102;
            v99 -= 8;
          }
          while (v100 != v101);
          v100 = *(char **)(a1 + 432);
        }
        *(_QWORD *)(a1 + 432) = v99;
        *(_QWORD *)(a1 + 440) = v91;
        *(_QWORD *)(a1 + 448) = &v98[8 * v97];
        if (v100)
          operator delete(v100);
      }
      else
      {
        *v91++ = v92;
      }
      *(_QWORD *)(a1 + 440) = v91;
      ++v88;
    }
    while (v88 != v89);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 8));
  if (__p)
  {
    v104 = (char *)__p;
    operator delete(__p);
  }
  if (v106)
  {
    v107 = (re::ProfilerAttributions **)v106;
    operator delete(v106);
  }
  if (v109)
  {
    v110 = (char *)v109;
    operator delete(v109);
  }
  if (v112)
  {
    v113 = (char *)v112;
    operator delete(v112);
  }
}

uint64_t *re::allocInfo_ProfilerManager(re *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&_MergedGlobals_424);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&_MergedGlobals_424))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_25411D860, 0);
    *(uint64_t *)((char *)&qword_25411D870 + 6) = 0;
    qword_25411D870 = 0;
    qword_25411D880 = 0;
    qword_25411D888 = 0xFFFFFFFFLL;
    qword_25411D860 = (uint64_t)&off_24ED7DAA8;
    qword_25411D890 = (uint64_t)"ProfilerManager";
    dword_25411D898 = 0;
    unk_25411D8A0 = 0u;
    unk_25411D8B0 = 0u;
    unk_25411D8C0 = 0u;
    qword_25411D8D0 = 0;
    __cxa_guard_release(&_MergedGlobals_424);
  }
  return &qword_25411D860;
}

void re::initInfo_ProfilerManager(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  __int128 v4;
  _QWORD v5[2];
  __int128 v6;

  v5[0] = 0x2B0128137FA56C8;
  v5[1] = "ProfilerManager";
  re::StringID::destroyString((re::StringID *)v5);
  *((_OWORD *)this + 2) = v6;
  *((_QWORD *)this + 2) = 0x21800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 8) = &re::initInfo_ProfilerManager(re::IntrospectionBase *)::structureAttributes;
  re::IntrospectionRegistry::add(this, v3);
  v4 = v6;
}

uint64_t re::introspect_ProfilerManager(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"ProfilerManager", (uint64_t (*)(re::internal *))re::allocInfo_ProfilerManager, (re::IntrospectionBase *(*)(void))re::initInfo_ProfilerManager, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::ProfilerManager>, this);
}

_QWORD *std::__hash_table<re::ProfilerEventStream *,std::hash<re::ProfilerEventStream *>,std::equal_to<re::ProfilerEventStream *>,std::allocator<re::ProfilerEventStream *>>::__emplace_unique_key_args<re::ProfilerEventStream *,re::ProfilerEventStream *&>(float *a1, _QWORD *a2, _QWORD *a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint8x8_t v10;
  _QWORD **v11;
  _QWORD *i;
  unint64_t v13;
  float v14;
  float v15;
  _BOOL8 v16;
  unint64_t v17;
  unint64_t v18;
  int8x8_t prime;
  void *v20;
  _QWORD *v21;
  uint64_t v22;
  _QWORD *v23;
  unint64_t v24;
  uint8x8_t v25;
  unint64_t v26;
  uint8x8_t v27;
  uint64_t v28;
  _QWORD *v29;
  unint64_t v30;
  _QWORD *v31;
  _QWORD *v32;
  unint64_t v33;
  _QWORD *v35;

  v6 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  v7 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v6 >> 47) ^ v6);
  v8 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
  v9 = *((_QWORD *)a1 + 1);
  if (v9)
  {
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      v3 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
      if (v8 >= v9)
        v3 = v8 % v9;
    }
    else
    {
      v3 = v8 & (v9 - 1);
    }
    v11 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v3);
    if (v11)
    {
      for (i = *v11; i; i = (_QWORD *)*i)
      {
        v13 = i[1];
        if (v13 == v8)
        {
          if (i[2] == *a2)
            return i;
        }
        else
        {
          if (v10.u32[0] > 1uLL)
          {
            if (v13 >= v9)
              v13 %= v9;
          }
          else
          {
            v13 &= v9 - 1;
          }
          if (v13 != v3)
            break;
        }
      }
    }
  }
  i = operator new(0x18uLL);
  *i = 0;
  i[1] = v8;
  i[2] = *a3;
  v14 = (float)(unint64_t)(*((_QWORD *)a1 + 3) + 1);
  v15 = a1[8];
  if (!v9 || (float)(v15 * (float)v9) < v14)
  {
    v16 = 1;
    if (v9 >= 3)
      v16 = (v9 & (v9 - 1)) != 0;
    v17 = v16 | (2 * v9);
    v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18)
      prime = (int8x8_t)v18;
    else
      prime = (int8x8_t)v17;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
      v9 = *((_QWORD *)a1 + 1);
    }
    if (*(_QWORD *)&prime > v9)
      goto LABEL_30;
    if (*(_QWORD *)&prime < v9)
    {
      v26 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v9 < 3 || (v27 = (uint8x8_t)vcnt_s8((int8x8_t)v9), v27.i16[0] = vaddlv_u8(v27), v27.u32[0] > 1uLL))
      {
        v26 = std::__next_prime(v26);
      }
      else
      {
        v28 = 1 << -(char)__clz(v26 - 1);
        if (v26 >= 2)
          v26 = v28;
      }
      if (*(_QWORD *)&prime <= v26)
        prime = (int8x8_t)v26;
      if (*(_QWORD *)&prime >= v9)
      {
        v9 = *((_QWORD *)a1 + 1);
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(_QWORD *)&prime >> 61)
            std::__throw_bad_array_new_length[abi:nn180100]();
          v20 = operator new(8 * *(_QWORD *)&prime);
          v21 = *(_QWORD **)a1;
          *(_QWORD *)a1 = v20;
          if (v21)
            operator delete(v21);
          v22 = 0;
          *((int8x8_t *)a1 + 1) = prime;
          do
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v22++) = 0;
          while (*(_QWORD *)&prime != v22);
          v23 = (_QWORD *)*((_QWORD *)a1 + 2);
          if (v23)
          {
            v24 = v23[1];
            v25 = (uint8x8_t)vcnt_s8(prime);
            v25.i16[0] = vaddlv_u8(v25);
            if (v25.u32[0] > 1uLL)
            {
              if (v24 >= *(_QWORD *)&prime)
                v24 %= *(_QWORD *)&prime;
            }
            else
            {
              v24 &= *(_QWORD *)&prime - 1;
            }
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v24) = a1 + 4;
            v29 = (_QWORD *)*v23;
            if (*v23)
            {
              do
              {
                v30 = v29[1];
                if (v25.u32[0] > 1uLL)
                {
                  if (v30 >= *(_QWORD *)&prime)
                    v30 %= *(_QWORD *)&prime;
                }
                else
                {
                  v30 &= *(_QWORD *)&prime - 1;
                }
                if (v30 != v24)
                {
                  if (!*(_QWORD *)(*(_QWORD *)a1 + 8 * v30))
                  {
                    *(_QWORD *)(*(_QWORD *)a1 + 8 * v30) = v23;
                    goto LABEL_55;
                  }
                  *v23 = *v29;
                  *v29 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v30);
                  **(_QWORD **)(*(_QWORD *)a1 + 8 * v30) = v29;
                  v29 = v23;
                }
                v30 = v24;
LABEL_55:
                v23 = v29;
                v29 = (_QWORD *)*v29;
                v24 = v30;
              }
              while (v29);
            }
          }
          v9 = (unint64_t)prime;
          goto LABEL_59;
        }
        v35 = *(_QWORD **)a1;
        *(_QWORD *)a1 = 0;
        if (v35)
          operator delete(v35);
        v9 = 0;
        *((_QWORD *)a1 + 1) = 0;
      }
    }
LABEL_59:
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9)
        v3 = v8 % v9;
      else
        v3 = v8;
    }
    else
    {
      v3 = (v9 - 1) & v8;
    }
  }
  v31 = *(_QWORD **)a1;
  v32 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v32)
  {
    *i = *v32;
LABEL_72:
    *v32 = i;
    goto LABEL_73;
  }
  *i = *((_QWORD *)a1 + 2);
  *((_QWORD *)a1 + 2) = i;
  v31[v3] = a1 + 4;
  if (*i)
  {
    v33 = *(_QWORD *)(*i + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v33 >= v9)
        v33 %= v9;
    }
    else
    {
      v33 &= v9 - 1;
    }
    v32 = (_QWORD *)(*(_QWORD *)a1 + 8 * v33);
    goto LABEL_72;
  }
LABEL_73:
  ++*((_QWORD *)a1 + 3);
  return i;
}

void std::__call_once_proxy[abi:nn180100]<std::tuple<re::ProfilerManager::acquireEventStream(BOOL)::$_0 &&,unsigned long long &,unsigned long &>>(re *a1)
{
  uint64_t v1;
  uint64_t v2;
  NSObject *v3;
  int v4;
  uint64_t v5;
  __int16 v6;
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v1 = **(_QWORD **)(*(_QWORD *)a1 + 8);
  v2 = **(_QWORD **)(*(_QWORD *)a1 + 16);
  v3 = *re::foundationProfilingLogObjects(a1);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = 134218240;
    v5 = v2;
    v6 = 2048;
    v7 = v1;
    _os_log_impl(&dword_224FE9000, v3, OS_LOG_TYPE_DEFAULT, "ProfilerEventStream limit of %lu for ProfilerManager %llu reached. Consider increasing this value.", (uint8_t *)&v4, 0x16u);
  }
}

void std::__call_once_proxy[abi:nn180100]<std::tuple<re::ProfilerManager::acquireStatistics(BOOL)::$_0 &&,unsigned long long &,unsigned long &>>(re *a1)
{
  uint64_t v1;
  uint64_t v2;
  NSObject *v3;
  int v4;
  uint64_t v5;
  __int16 v6;
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v1 = **(_QWORD **)(*(_QWORD *)a1 + 8);
  v2 = **(_QWORD **)(*(_QWORD *)a1 + 16);
  v3 = *re::foundationProfilingLogObjects(a1);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = 134218240;
    v5 = v2;
    v6 = 2048;
    v7 = v1;
    _os_log_impl(&dword_224FE9000, v3, OS_LOG_TYPE_DEFAULT, "ProfilerStatistics limit of %lu for ProfilerManager %llu reached. Consider increasing this value.", (uint8_t *)&v4, 0x16u);
  }
}

void std::__call_once_proxy[abi:nn180100]<std::tuple<re::ProfilerManager::acquireAttributions(BOOL)::$_0 &&,unsigned long long &,unsigned long &>>(re *a1)
{
  uint64_t v1;
  uint64_t v2;
  NSObject *v3;
  int v4;
  uint64_t v5;
  __int16 v6;
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v1 = **(_QWORD **)(*(_QWORD *)a1 + 8);
  v2 = **(_QWORD **)(*(_QWORD *)a1 + 16);
  v3 = *re::foundationProfilingLogObjects(a1);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = 134218240;
    v5 = v2;
    v6 = 2048;
    v7 = v1;
    _os_log_impl(&dword_224FE9000, v3, OS_LOG_TYPE_DEFAULT, "ProfilerAttributions limit of %lu for ProfilerManager %llu reached. Consider increasing this value.", (uint8_t *)&v4, 0x16u);
  }
}

void std::__call_once_proxy[abi:nn180100]<std::tuple<re::ProfilerManager::acquireMemoryStatistics(BOOL)::$_0 &&,unsigned long long &,unsigned long &>>(re *a1)
{
  uint64_t v1;
  uint64_t v2;
  NSObject *v3;
  int v4;
  uint64_t v5;
  __int16 v6;
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v1 = **(_QWORD **)(*(_QWORD *)a1 + 8);
  v2 = **(_QWORD **)(*(_QWORD *)a1 + 16);
  v3 = *re::foundationProfilingLogObjects(a1);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = 134218240;
    v5 = v2;
    v6 = 2048;
    v7 = v1;
    _os_log_impl(&dword_224FE9000, v3, OS_LOG_TYPE_DEFAULT, "ProfilerMemoryStatistics limit of %lu for ProfilerManager %llu reached. Consider increasing this value.", (uint8_t *)&v4, 0x16u);
  }
}

re::ProfilerAttributions *re::ProfilerAttributions::ProfilerAttributions(re::ProfilerAttributions *this, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  _QWORD *v6;

  *(_OWORD *)((char *)this + 264) = 0u;
  *(_OWORD *)((char *)this + 280) = 0u;
  *((_DWORD *)this + 74) = 1065353216;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  *(_OWORD *)((char *)this + 200) = 0u;
  *(_OWORD *)((char *)this + 216) = 0u;
  *(_OWORD *)((char *)this + 232) = 0u;
  *((_QWORD *)this + 31) = 0;
  *((_QWORD *)this + 32) = a2;
  *((_QWORD *)this + 38) = 0;
  *((_QWORD *)this + 39) = 0;
  *(_DWORD *)((char *)this + 327) = 0;
  *((_QWORD *)this + 40) = 0;
  v4 = operator new(0x2780uLL, (std::align_val_t)0x40uLL);
  *v4 = a2;
  v5 = 0x1FFFFFFFFFFFFB18;
  do
  {
    v6 = &v4[v5];
    v6[1264] = -1;
    v6[1265] = 0;
    v6[1267] = 0;
    v6[1266] = 0;
    v5 += 8;
  }
  while (v5 * 8);
  *(_QWORD *)this = v4;
  return this;
}

void re::ProfilerAttributions::~ProfilerAttributions(re::ProfilerAttributions *this)
{
  uint64_t i;
  uint64_t v3;
  uint64_t v4;

  for (i = 0; i != 256; i += 8)
  {
    v3 = *(_QWORD *)((char *)this + i);
    if (v3)
      MEMORY[0x2276933AC](v3, 64);
  }
  v4 = *((_QWORD *)this + 38);
  if (v4)
  {
    *((_QWORD *)this + 39) = v4;
    MEMORY[0x2276933AC]();
  }
  std::__hash_table<std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>>>::~__hash_table((uint64_t)this + 264);
}

void re::ProfilerAttributions::clear(re::ProfilerAttributions *this)
{
  uint64_t i;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  for (i = 0; i != 32; ++i)
  {
    v3 = *((_QWORD *)this + i);
    if (v3)
    {
      v4 = v3 + 64;
      v5 = -10048;
      do
      {
        v6 = v4 + v5;
        *(_OWORD *)(v6 + 10048) = re::kProfilerCounterEmpty;
        *(_OWORD *)(v6 + 10064) = *(_OWORD *)algn_226192890;
        v5 += 64;
      }
      while (v5);
    }
  }
  std::__hash_table<std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>>>::clear((uint64_t)this + 264);
  *((_QWORD *)this + 39) = *((_QWORD *)this + 38);
  *((_WORD *)this + 164) = 0;
  *((_BYTE *)this + 330) = 0;
}

void re::ProfilerAttributions::resolveDeferred(re::ProfilerAttributions *a1, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v5;
  unsigned int v6;
  _QWORD *Statistics;
  uint64_t v8;
  unsigned __int8 *v9;
  unsigned __int8 *i;
  unint64_t v11;
  unsigned int v12;
  int64x2_t *v13;
  unint64_t v14;
  unint64_t v15;
  int64x2_t v16;
  int64x2_t v17;

  v3 = (_QWORD *)*((_QWORD *)a1 + 35);
  if (v3)
  {
    v17 = vdupq_n_s64(1uLL);
    do
    {
      v5 = std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(a2, v3 + 2);
      if (v5)
      {
        if (*((unsigned __int16 *)v5 + 12) >= 0x20u)
          v6 = 0;
        else
          v6 = *((unsigned __int16 *)v5 + 12);
      }
      else
      {
        v6 = 0;
      }
      Statistics = (_QWORD *)*((_QWORD *)a1 + v6);
      v8 = v17.i64[1];
      if (!Statistics)
      {
        Statistics = re::ProfilerAttributions::createStatistics(a1, v6);
        v8 = v17.i64[1];
      }
      v9 = (unsigned __int8 *)v3[3];
      for (i = (unsigned __int8 *)v3[4]; v9 != i; v13[1] = vaddq_s64(v13[1], v16))
      {
        v11 = *((_QWORD *)v9 + 1);
        v12 = *v9;
        v9 += 16;
        v13 = (int64x2_t *)&Statistics[8 * (unint64_t)v12 + 8];
        v14 = v13->i64[0];
        v15 = v13->u64[1];
        if (v13->i64[0] >= v11)
          v14 = v11;
        if (v15 <= v11)
          v15 = v11;
        v13->i64[0] = v14;
        v13->i64[1] = v15;
        v16.i64[1] = v8;
        v16.i64[0] = v11;
      }
      v3 = (_QWORD *)*v3;
    }
    while (v3);
  }
  std::__hash_table<std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>>>::clear((uint64_t)a1 + 264);
}

_QWORD *re::ProfilerAttributions::createStatistics(re::ProfilerAttributions *this, unsigned int a2)
{
  _QWORD *result;
  uint64_t v5;
  _QWORD *v6;

  result = operator new(0x2780uLL, (std::align_val_t)0x40uLL);
  *result = *((_QWORD *)this + 32);
  v5 = 0x1FFFFFFFFFFFFB18;
  do
  {
    v6 = &result[v5];
    v6[1264] = -1;
    v6[1265] = 0;
    v6[1267] = 0;
    v6[1266] = 0;
    v5 += 8;
  }
  while (v5 * 8);
  *((_QWORD *)this + a2) = result;
  return result;
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>>>::__deallocate_node(a1, *(_QWORD **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>>>::__deallocate_node(int a1, _QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;

  if (__p)
  {
    v2 = __p;
    do
    {
      v3 = (_QWORD *)*v2;
      v4 = (void *)v2[3];
      if (v4)
      {
        v2[4] = v4;
        operator delete(v4);
      }
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

void std::__hash_table<std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>>>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t i;

  if (*(_QWORD *)(a1 + 24))
  {
    std::__hash_table<std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::vector<re::ProfilerDeferredStatisticCount>>>>::__deallocate_node(a1, *(_QWORD **)(a1 + 16));
    *(_QWORD *)(a1 + 16) = 0;
    v2 = *(_QWORD *)(a1 + 8);
    if (v2)
    {
      for (i = 0; i != v2; ++i)
        *(_QWORD *)(*(_QWORD *)a1 + 8 * i) = 0;
    }
    *(_QWORD *)(a1 + 24) = 0;
  }
}

uint64_t *re::foundationProfilingLogObjects(re *this)
{
  unsigned __int8 v1;

  {
    re::foundationProfilingLogObjects(void)::logObjects = (uint64_t)os_log_create("com.apple.re", "Foundation.Profiling");
  }
  return &re::foundationProfilingLogObjects(void)::logObjects;
}

void re::internal::enableMemoryStatsCollection(re::internal *this)
{
  NSObject *v1;
  size_t (**v2)(size_t, uint64_t, char *, uint64_t, uint64_t, int);
  uint64_t v3;
  uint8_t v4[16];

  if (_MergedGlobals_425 == 1)
  {
    v1 = *re::foundationProfilingLogObjects(this);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v4 = 0;
      _os_log_impl(&dword_224FE9000, v1, OS_LOG_TYPE_DEFAULT, "Malloc allocation statistics already being collected", v4, 2u);
    }
  }
  else
  {
    v2 = (size_t (**)(size_t, uint64_t, char *, uint64_t, uint64_t, int))MEMORY[0x24BDAC928];
    v3 = *MEMORY[0x24BDAC928];
    off_25411D8E0 = (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))*MEMORY[0x24BDAED40];
    unk_25411D8E8 = v3;
    *MEMORY[0x24BDAED40] = _objectalloc_logger;
    *v2 = _objectalloc_logger;
    _MergedGlobals_425 = 1;
  }
}

size_t _objectalloc_logger(size_t result, uint64_t a2, char *ptr, uint64_t a4, uint64_t a5, int a6)
{
  int v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  int64_t v16;
  int64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  int64_t v22;
  int64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  char *v28;
  int64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  int64_t v34;
  int64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  int64_t v40;
  int64_t v41;
  unint64_t v42;

  v10 = result;
  if (off_25411D8E0)
    result = off_25411D8E0(result, a2, ptr, a4, a5, (a6 + 1));
  if ((~v10 & 6) != 0)
  {
    if ((v10 & 2) != 0)
    {
      if (a5)
      {
        do
        do
        do
        {
          v28 = &ptr[v27];
        }
        while (1)
        {
          if ((uint64_t)v28 <= v29)
            break;
          while (1)
          {
            if (v30 != v29)
              break;
              return result;
          }
          __clrex();
        }
      }
    }
    else if ((v10 & 4) != 0)
    {
      if (ptr)
      {
        result = malloc_size(ptr);
        do
        do
        do
        v34 = v33 - result;
        while (1)
        {
          if (v34 <= v35)
            break;
          while (1)
          {
            if (v36 != v35)
              break;
              return result;
          }
          __clrex();
        }
      }
    }
    else if ((v10 & 0x10) != 0)
    {
      if (a5 && *MEMORY[0x24BDAEC58] == a2)
      {
        v37 = ~*MEMORY[0x24BDB03B8] & (unint64_t)&ptr[*MEMORY[0x24BDB03B8]];
        do
        do
        v40 = v37 + v39;
        while (1)
        {
          if (v40 <= v41)
            break;
          while (1)
          {
            if (v42 != v41)
              break;
              return result;
          }
          __clrex();
        }
      }
    }
    else if ((v10 & 0x20) != 0 && ptr && *MEMORY[0x24BDAEC58] == a2)
    {
      v19 = ~*MEMORY[0x24BDB03B8] & (unint64_t)(*MEMORY[0x24BDB03B8] + a4);
      do
      do
      v22 = v21 - v19;
      while (1)
      {
        if (v22 <= v23)
          break;
        while (1)
        {
          if (v24 != v23)
            break;
            return result;
        }
        __clrex();
      }
    }
  }
  else if (a5)
  {
    result = malloc_size(ptr);
    do
    do
    do
    do
    do
    {
      v16 = v15 + a4 - result;
    }
    while (1)
    {
      if (v16 <= v17)
        break;
      while (1)
      {
        if (v18 != v17)
          break;
          return result;
      }
      __clrex();
    }
  }
  return result;
}

void re::internal::disableMemoryStatsCollection(re::internal *this)
{
  uint64_t v1;
  NSObject *v2;
  uint8_t v3[16];

  if ((_MergedGlobals_425 & 1) != 0)
  {
    v1 = unk_25411D8E8;
    *MEMORY[0x24BDAED40] = off_25411D8E0;
    *MEMORY[0x24BDAC928] = v1;
    _MergedGlobals_425 = 0;
  }
  else
  {
    v2 = *re::foundationProfilingLogObjects(this);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v3 = 0;
      _os_log_impl(&dword_224FE9000, v2, OS_LOG_TYPE_DEFAULT, "Malloc allocation statistics already disabled", v3, 2u);
    }
  }
}

re::ProfilerFlameChartProcessor *re::ProfilerFlameChartProcessor::ProfilerFlameChartProcessor(re::ProfilerFlameChartProcessor *this)
{
  *((_BYTE *)this + 8) = 0;
  *(_QWORD *)this = &off_24ED7F750;
  *(_OWORD *)((char *)this + 28) = 0u;
  *(_OWORD *)((char *)this + 44) = 0u;
  *(_OWORD *)((char *)this + 60) = 0u;
  *(_OWORD *)((char *)this + 76) = 0u;
  *(_OWORD *)((char *)this + 92) = 0u;
  *(_OWORD *)((char *)this + 108) = 0u;
  *(_OWORD *)((char *)this + 124) = 0u;
  *(_OWORD *)((char *)this + 140) = 0u;
  *(_OWORD *)((char *)this + 156) = 0u;
  *(_OWORD *)((char *)this + 172) = 0u;
  *(_OWORD *)((char *)this + 188) = 0u;
  *(_OWORD *)((char *)this + 204) = 0u;
  *(_OWORD *)((char *)this + 220) = 0u;
  *(_OWORD *)((char *)this + 236) = 0u;
  *(_OWORD *)((char *)this + 252) = 0u;
  *((_DWORD *)this + 95) = 0;
  *(_OWORD *)((char *)this + 12) = 0u;
  *(_OWORD *)((char *)this + 268) = 0u;
  *(_OWORD *)((char *)this + 284) = 0u;
  *(_OWORD *)((char *)this + 300) = 0u;
  *(_OWORD *)((char *)this + 316) = 0u;
  *(_OWORD *)((char *)this + 332) = 0u;
  *(_OWORD *)((char *)this + 348) = 0u;
  *(_OWORD *)((char *)this + 364) = 0u;
  *((_QWORD *)this + 48) = 0x10000001ELL;
  *((_DWORD *)this + 98) = 1;
  *((_OWORD *)this + 25) = xmmword_2260FF4D0;
  *((_BYTE *)this + 416) = 1;
  std::vector<re::ProfilerFlameChartBlock>::resize((uint64_t)this + 16, 0x80uLL);
  std::vector<re::ProfilerFlameChartBlock>::resize((uint64_t)this + 40, 0x80uLL);
  re::ProfilerFlameChartProcessor::mapColorsToCategories(this);
  return this;
}

void std::vector<re::ProfilerFlameChartBlock>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;

  v2 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 6);
  v3 = a2 >= v2;
  v4 = a2 - v2;
  if (v4 != 0 && v3)
  {
    std::vector<re::ProfilerFlameChartBlock>::__append((char **)a1, v4);
  }
  else if (!v3)
  {
    *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 320 * a2;
  }
}

double re::ProfilerFlameChartProcessor::mapColorsToCategories(re::ProfilerFlameChartProcessor *this)
{
  uint64_t i;
  _OWORD *v2;
  double result;

  for (i = 64; i != 384; i += 64)
  {
    v2 = (_OWORD *)((char *)this + i);
    v2[2] = xmmword_2261928D0;
    v2[3] = xmmword_2261928D0;
    *v2 = xmmword_2261928D0;
    v2[1] = xmmword_2261928D0;
  }
  *((_QWORD *)this + 44) = 0x3F00808100000000;
  *((_QWORD *)this + 45) = 0x3F4CCCCD3F008081;
  *((_OWORD *)this + 5) = xmmword_2261928E0;
  *((_OWORD *)this + 6) = xmmword_226192900;
  *((_QWORD *)this + 40) = 0x3EDCDCDD3F2AAAABLL;
  *((_QWORD *)this + 41) = 0x3F4CCCCD3E20A0A1;
  *((_QWORD *)this + 42) = 1056997505;
  *((_QWORD *)this + 43) = 0x3F4CCCCD00000000;
  *((_OWORD *)this + 7) = xmmword_2261928F0;
  *((_OWORD *)this + 8) = xmmword_226192910;
  *((_OWORD *)this + 9) = xmmword_226192920;
  *((_OWORD *)this + 10) = xmmword_226192930;
  *((_QWORD *)this + 28) = 0x3F70F0F13E8C8C8DLL;
  *((_QWORD *)this + 29) = 0x3F4CCCCD3F70F0F1;
  *((_OWORD *)this + 11) = xmmword_226192910;
  *((_OWORD *)this + 12) = xmmword_226192940;
  *((_OWORD *)this + 15) = xmmword_226192950;
  *((_OWORD *)this + 16) = xmmword_226192910;
  *((_OWORD *)this + 13) = xmmword_226192960;
  *((_OWORD *)this + 17) = xmmword_226192970;
  *((_OWORD *)this + 18) = xmmword_226192980;
  *((_OWORD *)this + 19) = xmmword_226192990;
  result = 0.0065870108;
  *((_OWORD *)this + 23) = xmmword_2261929A0;
  return result;
}

void *re::ProfilerFlameChartProcessor::ProcessBlock(void *result, uint64_t a2, unsigned int a3, int a4, int a5, int a6, int a7, int a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16, uint64_t a17, uint64_t a18, char __dst, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,double a37,double a38,__int128 a39,uint64_t a40,__int128 a41,__int128 a42,__int128 a43,__int128 a44,__int128 a45,__int128 a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53)
{
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t *v49;
  uint64_t v50;
  unint64_t *v51;
  uint64_t v52;
  uint64_t v53;
  double v54;
  unint64_t v55;
  unint64_t v56;
  double v57;
  double v58;
  unint64_t v59;
  unint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t v63;
  uint64_t v64;
  int v65;
  std::string *v66;
  std::string::size_type size;
  int v68;
  const std::string::value_type *v69;
  std::string *v70;
  std::string::size_type v71;
  size_t v72;
  unint64_t v73;
  unint64_t v74;
  char *v75;
  uint64_t v76;
  unint64_t v77;
  unint64_t v78;
  unint64_t v79;
  unint64_t v80;
  char *v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  char *v85;
  char *v86;
  char *v87;
  char *v88;
  uint64_t v89;
  uint64_t v90;
  std::string var10;
  mach_timebase_info info;

  a53 = *MEMORY[0x24BDAC8D0];
  if (a3)
  {
    v46 = (uint64_t)result;
    v47 = 0;
    v89 = (uint64_t)result + 32;
    v90 = a3;
    do
    {
      v48 = a2 + (v47 << 6);
      a37 = 0.0;
      a38 = 0.0;
      a41 = 0u;
      a42 = 0u;
      a43 = 0u;
      a44 = 0u;
      a45 = 0u;
      a46 = 0u;
      a36 = *(_QWORD *)v48;
      LOWORD(a39) = *(_WORD *)(v48 + 18);
      *(__int128 *)((char *)&a39 + 4) = *(_OWORD *)(v46 + 16 * *(unsigned __int8 *)(v48 + 16) + 64);
      v49 = (unint64_t *)(v48 + 32);
      v50 = *(_QWORD *)(v48 + 32);
      v53 = *(_QWORD *)(v48 + 24);
      v51 = (unint64_t *)(v48 + 24);
      v52 = v53;
      v54 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
      if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
      {
        if (mach_timebase_info(&info))
        {
          v57 = NAN;
          goto LABEL_8;
        }
        LODWORD(v55) = info.numer;
        LODWORD(v56) = info.denom;
        v54 = (double)v55 / (double)v56;
        re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v54;
      }
      v57 = v54 * (double)(unint64_t)(v50 - v52);
LABEL_8:
      v58 = v57 / 1000000.0;
      *(double *)&a41 = v57 / 1000000.0;
      v59 = *v51;
      if (*(_QWORD *)(v46 + 400) > *v51 && *(_DWORD *)(v46 + 392) == 1)
        *(_QWORD *)(v46 + 400) = v59;
      v60 = *v49;
      if (*(_QWORD *)(v46 + 408) < *v49)
        *(_QWORD *)(v46 + 408) = v60;
      v61 = 0;
      a37 = (double)v59;
      a38 = (double)v60;
      v62 = *(_QWORD *)(a2 + (v47 << 6) + 8);
LABEL_14:
      v63 = 0;
      v64 = v62 + v61;
      while (1)
      {
        v65 = *(unsigned __int8 *)(v64 + v63);
        if (!*(_BYTE *)(v64 + v63))
          break;
        if (v65 == 32)
        {
          v61 += v63 + 1;
          goto LABEL_14;
        }
        if (v65 == 40)
          break;
        ++v63;
      }
      info = 0;
      std::string::reserve((std::string *)&info, 0x78uLL);
      std::string::append((std::string *)&info, "(");
      std::to_string(&var10, (int)v58);
      if ((var10.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v66 = &var10;
      else
        v66 = (std::string *)var10.__r_.__value_.__r.__words[0];
      if ((var10.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        size = HIBYTE(var10.__r_.__value_.__r.__words[2]);
      else
        size = var10.__r_.__value_.__l.__size_;
      std::string::append((std::string *)&info, (const std::string::value_type *)v66, size);
      if (SHIBYTE(var10.__r_.__value_.__r.__words[2]) < 0)
        operator delete(var10.__r_.__value_.__l.__data_);
      v68 = (int)(v58 * 100.0) - 100 * (int)v58;
      if (v68 >= 10)
        v69 = ".";
      else
        v69 = ".0";
      std::string::append((std::string *)&info, v69);
      std::to_string(&var10, v68);
      if ((var10.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v70 = &var10;
      else
        v70 = (std::string *)var10.__r_.__value_.__r.__words[0];
      if ((var10.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v71 = HIBYTE(var10.__r_.__value_.__r.__words[2]);
      else
        v71 = var10.__r_.__value_.__l.__size_;
      std::string::append((std::string *)&info, (const std::string::value_type *)v70, v71);
      if (SHIBYTE(var10.__r_.__value_.__r.__words[2]) < 0)
        operator delete(var10.__r_.__value_.__l.__data_);
      std::string::append((std::string *)&info, ")");
      if (v63 >= 0x78)
        v72 = 120;
      else
        v72 = v63;
      strncpy(&__dst, (const char *)(v62 + v61), v72);
      strncpy(&__dst + v72, (const char *)&info, 1uLL);
      v74 = *(_QWORD *)(v46 + 24);
      v73 = *(_QWORD *)(v46 + 32);
      if (v74 >= v73)
      {
        v76 = *(_QWORD *)(v46 + 16);
        v77 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v74 - v76) >> 6);
        v78 = v77 + 1;
        if (v77 + 1 > 0xCCCCCCCCCCCCCCLL)
          abort();
        v79 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v73 - v76) >> 6);
        if (2 * v79 > v78)
          v78 = 2 * v79;
        if (v79 >= 0x66666666666666)
          v80 = 0xCCCCCCCCCCCCCCLL;
        else
          v80 = v78;
        if (v80)
        {
          v81 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<re::ProfilerFlameChartBlock>>(v89, v80);
          v83 = v82;
        }
        else
        {
          v81 = 0;
          v83 = 0;
        }
        v84 = a2;
        v85 = &v81[320 * v77];
        result = memcpy(v85, &__dst, 0x140uLL);
        v86 = *(char **)(v46 + 16);
        v87 = *(char **)(v46 + 24);
        v88 = v85;
        if (v87 != v86)
        {
          do
          {
            v87 -= 320;
            v88 -= 320;
            result = memcpy(v88, v87, 0x140uLL);
          }
          while (v87 != v86);
          v87 = *(char **)(v46 + 16);
        }
        v75 = v85 + 320;
        *(_QWORD *)(v46 + 16) = v88;
        *(_QWORD *)(v46 + 24) = v85 + 320;
        *(_QWORD *)(v46 + 32) = &v81[320 * v83];
        if (v87)
          result = (void *)MEMORY[0x2276933AC](v87, 64);
        a2 = v84;
      }
      else
      {
        result = memcpy(*(void **)(v46 + 24), &__dst, 0x140uLL);
        v75 = (char *)(v74 + 320);
      }
      *(_QWORD *)(v46 + 24) = v75;
      ++v47;
    }
    while (v47 != v90);
  }
  return result;
}

#error "225BC6FE0: call analysis failed (funcsize=119)"

char *std::vector<re::ProfilerFlameChartBlock>::reserve(_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  char *v8;
  char *v9;
  char *v10;
  char *v11;

  v4 = a1[2];
  result = (char *)(a1 + 2);
  if (0xCCCCCCCCCCCCCCCDLL * ((v4 - *a1) >> 6) < a2)
  {
    if (a2 >= 0xCCCCCCCCCCCCCDLL)
      abort();
    v5 = (a1[1] - *a1) / 320;
    result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<re::ProfilerFlameChartBlock>>((uint64_t)result, a2);
    v6 = &result[320 * v5];
    v8 = &result[320 * v7];
    v10 = (char *)*a1;
    v9 = (char *)a1[1];
    v11 = v6;
    if (v9 != (char *)*a1)
    {
      do
      {
        v9 -= 320;
        v11 -= 320;
        result = (char *)memcpy(v11, v9, 0x140uLL);
      }
      while (v9 != v10);
      v9 = (char *)*a1;
    }
    *a1 = v11;
    a1[1] = v6;
    a1[2] = v8;
    if (v9)
      JUMPOUT(0x2276933ACLL);
  }
  return result;
}

void re::ProfilerFlameChartProcessor::~ProfilerFlameChartProcessor(re::ProfilerFlameChartProcessor *this)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = &off_24ED7F750;
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    *((_QWORD *)this + 6) = v2;
    MEMORY[0x2276933AC]();
  }
  v3 = *((_QWORD *)this + 2);
  if (v3)
  {
    *((_QWORD *)this + 3) = v3;
    MEMORY[0x2276933AC]();
  }
}

{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = &off_24ED7F750;
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    *((_QWORD *)this + 6) = v2;
    MEMORY[0x2276933AC]();
  }
  v3 = *((_QWORD *)this + 2);
  if (v3)
  {
    *((_QWORD *)this + 3) = v3;
    MEMORY[0x2276933AC]();
  }
  JUMPOUT(0x2276933B8);
}

uint64_t re::ProfilerFlameChartProcessor::willNeedEvents(re::ProfilerFlameChartProcessor *this)
{
  return 1;
}

uint64_t re::ProfilerFlameChartProcessor::willNeedStatistics(re::ProfilerFlameChartProcessor *this)
{
  return 0;
}

uint64_t re::ProfilerFlameChartProcessor::willNeedAttributions(re::ProfilerFlameChartProcessor *this)
{
  return 0;
}

uint64_t re::ProfilerFlameChartProcessor::willNeedMemoryStatistics(re::ProfilerFlameChartProcessor *this)
{
  return 0;
}

uint64_t re::ProfilerFlameChartProcessor::updateInterval(re::ProfilerFlameChartProcessor *this)
{
  return *((unsigned int *)this + 96);
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<re::ProfilerFlameChartBlock>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xCCCCCCCCCCCCCDLL)
    std::__throw_bad_array_new_length[abi:nn180100]();
  return operator new(320 * a2, (std::align_val_t)0x40uLL);
}

char *std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::__wrap_iter<re::ProfilerFlameChartBlock *>,std::__wrap_iter<re::ProfilerFlameChartBlock *>,std::back_insert_iterator<std::vector<re::ProfilerFlameChartBlock>>,0>(char *__src, char *a2, uint64_t a3)
{
  char *v3;
  char *v4;
  uint64_t v6;

  v3 = __src;
  v6 = a3;
  if (__src == a2)
    return __src;
  v4 = a2;
  do
  {
    std::back_insert_iterator<std::vector<re::ProfilerFlameChartBlock>>::operator=[abi:nn180100](&v6, v3);
    v3 += 320;
  }
  while (v3 != v4);
  return v4;
}

uint64_t *std::back_insert_iterator<std::vector<re::ProfilerFlameChartBlock>>::operator=[abi:nn180100](uint64_t *a1, void *__src)
{
  _QWORD *v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  char *v19;

  v4 = (_QWORD *)*a1;
  v5 = *(char **)(*a1 + 8);
  v6 = *a1;
  v9 = *(_QWORD *)(v6 + 16);
  v7 = v6 + 16;
  v8 = v9;
  if ((unint64_t)v5 >= v9)
  {
    v11 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)&v5[-*v4] >> 6);
    if (v11 + 1 > 0xCCCCCCCCCCCCCCLL)
      abort();
    v12 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v8 - *v4) >> 6);
    v13 = 2 * v12;
    if (2 * v12 <= v11 + 1)
      v13 = v11 + 1;
    if (v12 >= 0x66666666666666)
      v14 = 0xCCCCCCCCCCCCCCLL;
    else
      v14 = v13;
    if (v14)
      v15 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<re::ProfilerFlameChartBlock>>(v7, v14);
    else
      v15 = 0;
    v16 = &v15[320 * v11];
    v17 = &v15[320 * v14];
    memcpy(v16, __src, 0x140uLL);
    v10 = v16 + 320;
    v19 = (char *)*v4;
    v18 = (char *)v4[1];
    if (v18 != (char *)*v4)
    {
      do
      {
        v18 -= 320;
        v16 -= 320;
        memcpy(v16, v18, 0x140uLL);
      }
      while (v18 != v19);
      v18 = (char *)*v4;
    }
    *v4 = v16;
    v4[1] = v10;
    v4[2] = v17;
    if (v18)
      MEMORY[0x2276933AC](v18, 64);
  }
  else
  {
    memcpy(v5, __src, 0x140uLL);
    v10 = v5 + 320;
  }
  v4[1] = v10;
  return a1;
}

void std::vector<re::ProfilerFlameChartBlock>::__append(char **a1, unint64_t a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  size_t v13;
  char *v14;
  char *v15;
  size_t v16;
  char *v17;
  char *v18;
  char *v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (0xCCCCCCCCCCCCCCCDLL * ((v6 - v7) >> 6) >= a2)
  {
    if (a2)
    {
      v13 = 320 * ((320 * a2 - 320) / 0x140) + 320;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = 0xCCCCCCCCCCCCCCCDLL * ((v7 - *a1) >> 6);
    v9 = v8 + a2;
    if (v8 + a2 > 0xCCCCCCCCCCCCCCLL)
      abort();
    v10 = 0xCCCCCCCCCCCCCCCDLL * ((v5 - *a1) >> 6);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x66666666666666)
      v11 = 0xCCCCCCCCCCCCCCLL;
    else
      v11 = v9;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<re::ProfilerFlameChartBlock>>(v4, v11);
    else
      v12 = 0;
    v14 = &v12[320 * v8];
    v15 = &v12[320 * v11];
    v16 = 320 * ((320 * a2 - 320) / 0x140) + 320;
    bzero(v14, v16);
    v17 = &v14[v16];
    v19 = *a1;
    v18 = a1[1];
    if (v18 != *a1)
    {
      do
      {
        v18 -= 320;
        v14 -= 320;
        memcpy(v14, v18, 0x140uLL);
      }
      while (v18 != v19);
      v18 = *a1;
    }
    *a1 = v14;
    a1[1] = v17;
    a1[2] = v15;
    if (v18)
      JUMPOUT(0x2276933ACLL);
  }
}

re::ProfilerMiniHUDProcessor *re::ProfilerMiniHUDProcessor::ProfilerMiniHUDProcessor(re::ProfilerMiniHUDProcessor *this)
{
  _anonymous_namespace_ *v2;
  _anonymous_namespace_ *v3;
  _anonymous_namespace_ *v4;
  _anonymous_namespace_ *v5;
  _anonymous_namespace_ *v6;
  _anonymous_namespace_ *v7;
  _anonymous_namespace_ *v8;
  _anonymous_namespace_ *v9;
  _anonymous_namespace_ *v10;
  _anonymous_namespace_ *v11;
  _anonymous_namespace_ *v12;
  _anonymous_namespace_ *v13;
  _anonymous_namespace_ *v14;
  _anonymous_namespace_ *v15;
  _anonymous_namespace_ *v16;
  _anonymous_namespace_ *v17;
  _anonymous_namespace_ *v18;
  _anonymous_namespace_ *v19;
  _anonymous_namespace_ *v20;
  _anonymous_namespace_ *v21;
  _anonymous_namespace_ *v22;

  *((_BYTE *)this + 8) = 0;
  *(_QWORD *)this = &off_24ED7F7C0;
  *(_OWORD *)((char *)this + 12) = 0u;
  *(_OWORD *)((char *)this + 28) = 0u;
  *(_OWORD *)((char *)this + 44) = 0u;
  *(_OWORD *)((char *)this + 60) = 0u;
  *(_OWORD *)((char *)this + 76) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  v2 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)this + 9, 0);
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  v3 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)this + 13, 0);
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  v4 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)this + 17, 0);
  *(_OWORD *)((char *)this + 184) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  v5 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)this + 21, 0);
  *(_OWORD *)((char *)this + 216) = 0u;
  *(_OWORD *)((char *)this + 200) = 0u;
  v6 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)this + 25, 0);
  *(_OWORD *)((char *)this + 248) = 0u;
  *(_OWORD *)((char *)this + 232) = 0u;
  v7 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)this + 29, 0);
  *(_OWORD *)((char *)this + 264) = 0u;
  *(_OWORD *)((char *)this + 280) = 0u;
  v8 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)this + 33, 0);
  *(_OWORD *)((char *)this + 296) = 0u;
  *(_OWORD *)((char *)this + 312) = 0u;
  v9 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)this + 37, 0);
  *(_OWORD *)((char *)this + 328) = 0u;
  *(_OWORD *)((char *)this + 344) = 0u;
  v10 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)this + 41, 0);
  *(_OWORD *)((char *)this + 360) = 0u;
  *(_OWORD *)((char *)this + 376) = 0u;
  v11 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)this + 45, 0);
  *(_OWORD *)((char *)this + 392) = 0u;
  *(_OWORD *)((char *)this + 408) = 0u;
  v12 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)this + 49, 0);
  *((_QWORD *)this + 63) = 0;
  *(_OWORD *)((char *)this + 472) = 0u;
  *(_OWORD *)((char *)this + 488) = 0u;
  *(_OWORD *)((char *)this + 440) = 0u;
  *(_OWORD *)((char *)this + 456) = 0u;
  *(_OWORD *)((char *)this + 424) = 0u;
  v13 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)this + 60, 0);
  *((_OWORD *)this + 32) = 0u;
  *((_OWORD *)this + 33) = 0u;
  v14 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)this + 64, 0);
  *((_OWORD *)this + 34) = 0u;
  *((_OWORD *)this + 35) = 0u;
  v15 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)this + 68, 0);
  *((_OWORD *)this + 36) = 0u;
  *((_OWORD *)this + 37) = 0u;
  v16 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)this + 72, 0);
  *((_OWORD *)this + 38) = 0u;
  *((_OWORD *)this + 39) = 0u;
  v17 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)this + 76, 0);
  *((_OWORD *)this + 40) = 0u;
  *((_OWORD *)this + 41) = 0u;
  v18 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)this + 80, 0);
  *((_OWORD *)this + 42) = 0u;
  *((_OWORD *)this + 43) = 0u;
  v19 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)this + 84, 0);
  *((_OWORD *)this + 44) = 0u;
  *((_OWORD *)this + 45) = 0u;
  v20 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)this + 88, 0);
  *((_OWORD *)this + 46) = 0u;
  *((_OWORD *)this + 47) = 0u;
  v21 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)this + 92, 0);
  *((_OWORD *)this + 48) = 0u;
  *((_OWORD *)this + 49) = 0u;
  v22 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)this + 96, 0);
  *((_OWORD *)this + 50) = 0u;
  *((_OWORD *)this + 51) = 0u;
  re::DynamicString::setCapacity((_QWORD *)this + 100, 0);
  *((_OWORD *)this + 52) = xmmword_2261929E0;
  *((_OWORD *)this + 53) = xmmword_226104350;
  *((_OWORD *)this + 54) = xmmword_2261929F0;
  *((_OWORD *)this + 55) = 0u;
  *((_OWORD *)this + 56) = 0u;
  getpid();
  memorystatus_control();
  *((_QWORD *)this + 113) = 0;
  return this;
}

void re::ProfilerMiniHUDProcessor::process(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t **a6)
{
  unint64_t v7;
  float v8;
  float v9;
  float v10;
  float v11;
  _QWORD *v12;
  _QWORD *v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  uint64_t v27;
  _QWORD *v28;
  unint64_t v29;
  float v30;
  float v31;
  float v32;
  float v33;
  BOOL v34;
  float v35;
  float v36;
  float v37;
  float v38;
  uint64_t *v39;
  uint64_t *v40;
  uint64_t v41;
  uint64_t v42;
  int64x2_t v43;
  int64x2_t v44;
  uint64_t v45;
  uint64_t v46;
  float v47;
  unint64_t v48;
  double v49;
  unint64_t v50;
  unint64_t v51;
  double v52;
  float v53;
  float v54;
  float v55;
  float v56;
  unint64_t v57;
  unint64_t v58;
  unint64_t v59;
  double v60;
  float v61;
  float v62;
  unint64_t v63;
  unint64_t v64;
  unint64_t v65;
  double v66;
  float v67;
  float v68;
  unint64_t v69;
  unint64_t v70;
  unint64_t v71;
  double v72;
  float v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  _BYTE *v77;
  uint64_t v78;
  _BYTE *v79;
  uint64_t v80;
  _BYTE *v81;
  uint64_t v82;
  _BYTE *v83;
  uint64_t v84;
  _BYTE *v85;
  uint64_t v86;
  _BYTE *v87;
  uint64_t v88;
  _BYTE *v89;
  uint64_t v90;
  _BYTE *v91;
  uint64_t v92;
  _BYTE *v93;
  uint64_t v94;
  _BYTE *v95;
  float *v96;
  float v97;
  float v98;
  unint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  double v103;
  unint64_t v104;
  unint64_t v105;
  double v106;
  uint64_t v107;
  _BYTE *v108;
  uint64_t v109;
  uint64_t v110;
  float v111;
  int64x2_t v112;
  int64x2_t v113;
  mach_msg_type_number_t task_info_outCnt;
  mach_timebase_info info;

  v7 = *(_QWORD *)(a1 + 840) + 1;
  *(_QWORD *)(a1 + 840) = v7;
  v8 = 0.0;
  v9 = 0.0;
  v10 = 0.0;
  v11 = 0.0;
  v12 = *(_QWORD **)a4;
  v13 = *(_QWORD **)(a4 + 8);
  v14 = 0.0;
  v15 = 0.0;
  v16 = 0.0;
  v17 = 0.0;
  v18 = 0.0;
  v19 = 0.0;
  if (*(_QWORD **)a4 != v13)
  {
    v20 = 0.0;
    v21 = 0.0;
    v22 = 0.0;
    v23 = 0.0;
    v24 = 0.0;
    v25 = 0.0;
    v26 = 0.0;
    do
    {
      v27 = 0;
      v28 = (_QWORD *)(*v12 + 88);
      do
      {
        if (*v28)
        {
          v29 = *(v28 - 1);
          if (v29)
          {
            if (v27 > 0x5Au)
            {
              switch(v27)
              {
                case '[':
                  v26 = v26 + (float)v29;
                  break;
                case '\\':
                  v25 = v25 + (float)v29;
                  break;
                case ']':
                  v24 = v24 + (float)v29;
                  break;
              }
            }
            else
            {
              switch((char)v27)
              {
                case 1:
                  v17 = v17 + (float)v29;
                  break;
                case 2:
                  v18 = v18 + (float)v29;
                  break;
                case 3:
                  v20 = v20 + (float)v29;
                  break;
                case 4:
                  v21 = v21 + (float)v29;
                  break;
                case 5:
                  v22 = v22 + (float)v29;
                  break;
                case 6:
                  v23 = v23 + (float)v29;
                  break;
                case 7:
                  v19 = v19 + (float)v29;
                  break;
                case 8:
                  v14 = v14 + (float)v29;
                  break;
                case 9:
                  v16 = v16 + (float)v29;
                  break;
                case 10:
                  v15 = v15 + (float)v29;
                  break;
                case 11:
                  v11 = v11 + (float)v29;
                  break;
                case 12:
                  v8 = v8 + (float)v29;
                  break;
                case 23:
                  v9 = v9 + (float)v29;
                  break;
                case 24:
                  v10 = v10 + (float)v29;
                  break;
                default:
                  break;
              }
            }
          }
        }
        ++v27;
        v28 += 8;
      }
      while (v27 != 157);
      ++v12;
    }
    while (v12 != v13);
    v18 = v19 + (float)(v23 + (float)(v22 + (float)(v21 + (float)(v20 + v18))));
    v19 = (float)(v26 + v25) + v24;
  }
  v30 = (float)((float)(v14 - v11) - v8) - v9;
  v31 = (float)(v16 - v15) + v19;
  v32 = v18 + v19;
  v33 = v9 + (float)(v8 + v11);
  v34 = v14 <= 0.0;
  if (v14 <= 0.0)
    v35 = v33;
  else
    v35 = 0.0;
  v36 = v31 - v35;
  if (v34)
    v15 = v33;
  v37 = *(float *)(a1 + 24);
  *(float *)(a1 + 20) = v17 + *(float *)(a1 + 20);
  *(float *)(a1 + 24) = (float)((float)(v32 - v15) - v36) + v37;
  v38 = *(float *)(a1 + 32);
  *(float *)(a1 + 28) = v36 + *(float *)(a1 + 28);
  *(float *)(a1 + 32) = fmaxf(v30, 0.0) + v38;
  *(float *)(a1 + 36) = v10 + *(float *)(a1 + 36);
  v39 = *a6;
  v40 = a6[1];
  if (*a6 == v40)
  {
    v42 = 0;
    v41 = 0;
    v43 = 0uLL;
    v44 = 0uLL;
  }
  else
  {
    v41 = 0;
    v42 = 0;
    v43 = 0uLL;
    v44 = 0uLL;
    do
    {
      v45 = 0;
      v46 = *v39;
      do
      {
        v44 = vaddq_s64(*(int64x2_t *)(v46 + v45 + 96), v44);
        v43 = vaddq_s64(*(int64x2_t *)(v46 + v45 + 80), v43);
        v42 += *(_QWORD *)(v46 + v45 + 112);
        v45 += 64;
      }
      while (v45 != 1280);
      v41 += *(_QWORD *)(v46 + 1344);
      ++v39;
    }
    while (v39 != v40);
  }
  if (!(v7 % *(_QWORD *)(a1 + 832)))
  {
    v112 = v44;
    v113 = v43;
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 12));
    v47 = *(float *)(a1 + 20);
    v48 = *(_QWORD *)(a1 + 832);
    v49 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(&info))
      {
        v49 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
        v52 = NAN;
        goto LABEL_50;
      }
      LODWORD(v50) = info.numer;
      LODWORD(v51) = info.denom;
      v49 = (double)v50 / (double)v51;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v49;
    }
    v52 = v49 * (double)(unint64_t)(float)(v47 / (float)v48);
LABEL_50:
    v53 = v52 / 1000000.0;
    *(float *)(a1 + 428) = v53;
    v54 = 1000.0 / v53;
    v34 = v53 <= 0.0;
    v55 = 0.0;
    if (!v34)
      v55 = v54;
    *(float *)(a1 + 424) = v55;
    v56 = *(float *)(a1 + 24);
    v57 = *(_QWORD *)(a1 + 832);
    if (v49 < 0.0)
    {
      if (mach_timebase_info(&info))
      {
        v49 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
        v60 = NAN;
        goto LABEL_57;
      }
      LODWORD(v58) = info.numer;
      LODWORD(v59) = info.denom;
      v49 = (double)v58 / (double)v59;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v49;
    }
    v60 = v49 * (double)(unint64_t)(float)(v56 / (float)v57);
LABEL_57:
    v61 = v60 / 1000000.0;
    *(float *)(a1 + 432) = v61;
    v62 = *(float *)(a1 + 28);
    v63 = *(_QWORD *)(a1 + 832);
    if (v49 < 0.0)
    {
      if (mach_timebase_info(&info))
      {
        v49 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
        v66 = NAN;
        goto LABEL_62;
      }
      LODWORD(v64) = info.numer;
      LODWORD(v65) = info.denom;
      v49 = (double)v64 / (double)v65;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v49;
    }
    v66 = v49 * (double)(unint64_t)(float)(v62 / (float)v63);
LABEL_62:
    v67 = v66 / 1000000.0;
    *(float *)(a1 + 436) = v67;
    v68 = *(float *)(a1 + 32);
    v69 = *(_QWORD *)(a1 + 832);
    if (v49 < 0.0)
    {
      if (mach_timebase_info(&info))
      {
        v72 = NAN;
        goto LABEL_67;
      }
      LODWORD(v70) = info.numer;
      LODWORD(v71) = info.denom;
      v49 = (double)v70 / (double)v71;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v49;
    }
    v72 = v49 * (double)(unint64_t)(float)(v68 / (float)v69);
LABEL_67:
    v73 = v72 / 1000000.0;
    *(float *)(a1 + 440) = v73;
    *(float *)(a1 + 444) = *(float *)(a1 + 36) / (float)*(unint64_t *)(a1 + 832);
    *(_QWORD *)(a1 + 64) = 0;
    *(_QWORD *)(a1 + 48) = 0;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_OWORD *)(a1 + 32) = 0u;
    v74 = qword_2558356F0;
    task_info_outCnt = 93;
    task_info(*MEMORY[0x24BDAEC58], 0x16u, re::ProfilerMiniHUDProcessor::process(unsigned long long,std::vector<re::ProfilerEventStream *> const&,std::vector<re::ProfilerStatistics *> const&,std::vector<re::ProfilerAttributions *> const&,std::vector<re::ProfilerMemoryStatistics *> const&)::vmInfo, &task_info_outCnt);
    v75 = qword_2558356F0;
    *(_QWORD *)(a1 + 448) = qword_2558356F0;
    *(_QWORD *)(a1 + 456) = v75 - v74;
    *(_QWORD *)(a1 + 472) = *(_QWORD *)(a1 + 904);
    v76 = *(_QWORD *)(a1 + 488);
    if ((v76 & 1) != 0)
    {
      *(_QWORD *)(a1 + 488) = 1;
      v77 = *(_BYTE **)(a1 + 496);
    }
    else
    {
      *(_BYTE *)(a1 + 488) = v76 & 1;
      v77 = (_BYTE *)(a1 + 489);
    }
    *v77 = 0;
    v78 = *(_QWORD *)(a1 + 520);
    if ((v78 & 1) != 0)
    {
      *(_QWORD *)(a1 + 520) = 1;
      v79 = *(_BYTE **)(a1 + 528);
    }
    else
    {
      *(_BYTE *)(a1 + 520) = v78 & 1;
      v79 = (_BYTE *)(a1 + 521);
    }
    *v79 = 0;
    v80 = *(_QWORD *)(a1 + 552);
    if ((v80 & 1) != 0)
    {
      *(_QWORD *)(a1 + 552) = 1;
      v81 = *(_BYTE **)(a1 + 560);
    }
    else
    {
      *(_BYTE *)(a1 + 552) = v80 & 1;
      v81 = (_BYTE *)(a1 + 553);
    }
    *v81 = 0;
    v82 = *(_QWORD *)(a1 + 584);
    if ((v82 & 1) != 0)
    {
      *(_QWORD *)(a1 + 584) = 1;
      v83 = *(_BYTE **)(a1 + 592);
    }
    else
    {
      *(_BYTE *)(a1 + 584) = v82 & 1;
      v83 = (_BYTE *)(a1 + 585);
    }
    *v83 = 0;
    v84 = *(_QWORD *)(a1 + 616);
    if ((v84 & 1) != 0)
    {
      *(_QWORD *)(a1 + 616) = 1;
      v85 = *(_BYTE **)(a1 + 624);
    }
    else
    {
      *(_BYTE *)(a1 + 616) = v84 & 1;
      v85 = (_BYTE *)(a1 + 617);
    }
    *v85 = 0;
    v86 = *(_QWORD *)(a1 + 648);
    if ((v86 & 1) != 0)
    {
      *(_QWORD *)(a1 + 648) = 1;
      v87 = *(_BYTE **)(a1 + 656);
    }
    else
    {
      *(_BYTE *)(a1 + 648) = v86 & 1;
      v87 = (_BYTE *)(a1 + 649);
    }
    *v87 = 0;
    v88 = *(_QWORD *)(a1 + 680);
    if ((v88 & 1) != 0)
    {
      *(_QWORD *)(a1 + 680) = 1;
      v89 = *(_BYTE **)(a1 + 688);
    }
    else
    {
      *(_BYTE *)(a1 + 680) = v88 & 1;
      v89 = (_BYTE *)(a1 + 681);
    }
    *v89 = 0;
    v90 = *(_QWORD *)(a1 + 712);
    if ((v90 & 1) != 0)
    {
      *(_QWORD *)(a1 + 712) = 1;
      v91 = *(_BYTE **)(a1 + 720);
    }
    else
    {
      *(_BYTE *)(a1 + 712) = v90 & 1;
      v91 = (_BYTE *)(a1 + 713);
    }
    *v91 = 0;
    v92 = *(_QWORD *)(a1 + 744);
    if ((v92 & 1) != 0)
    {
      *(_QWORD *)(a1 + 744) = 1;
      v93 = *(_BYTE **)(a1 + 752);
    }
    else
    {
      *(_BYTE *)(a1 + 744) = v92 & 1;
      v93 = (_BYTE *)(a1 + 745);
    }
    *v93 = 0;
    v94 = *(_QWORD *)(a1 + 776);
    if ((v94 & 1) != 0)
    {
      *(_QWORD *)(a1 + 776) = 1;
      v95 = *(_BYTE **)(a1 + 784);
    }
    else
    {
      *(_BYTE *)(a1 + 776) = v94 & 1;
      v95 = (_BYTE *)(a1 + 777);
    }
    v96 = (float *)(a1 + 436);
    *v95 = 0;
    v97 = *(float *)(a1 + 432);
    if (*(float *)(a1 + 440) > 0.0)
    {
      v98 = *v96;
      v96 = (float *)(a1 + 440);
      v97 = v97 + v98;
    }
    re::DynamicString::appendf((re::DynamicString *)(a1 + 480), "Sim: %.2f", v97);
    re::DynamicString::appendf((re::DynamicString *)(a1 + 512), "Ren: %.2f", *v96);
    if (*(float *)(a1 + 444) == 0.0)
      re::DynamicString::appendf((re::DynamicString *)(a1 + 544), "GPU: Off");
    else
      re::DynamicString::appendf((re::DynamicString *)(a1 + 544), "GPU: %.2f");
    re::DynamicString::appendf((re::DynamicString *)(a1 + 576), "FPS: %2.2f", *(float *)(a1 + 424));
    re::DynamicString::appendf((re::DynamicString *)(a1 + 608), "Mem [MB]: %.2f", (double)*(unint64_t *)(a1 + 448) * 0.0009765625 * 0.0009765625);
    v99 = v113.i64[0];
    if (!(v113.i64[1] | v41))
      goto LABEL_115;
    re::DynamicString::appendf((re::DynamicString *)(a1 + 640), "Allocs: +%llu/-%llu", v113.i64[1], v41);
    *(_QWORD *)(a1 + 880) += v113.i64[1] - v41;
    v100 = mach_absolute_time();
    v101 = v100;
    v102 = *(_QWORD *)(a1 + 896);
    if (!v102)
    {
      *(_QWORD *)(a1 + 896) = v100;
      v102 = v100;
    }
    v103 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    v99 = v113.i64[0];
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(&info))
      {
        v106 = NAN;
        v99 = v113.i64[0];
        goto LABEL_110;
      }
      LODWORD(v104) = info.numer;
      LODWORD(v105) = info.denom;
      v103 = (double)v104 / (double)v105;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v103;
      v99 = v113.i64[0];
    }
    v106 = v103 * (double)(v101 - v102);
LABEL_110:
    if (v106 / 1000000000.0 >= 1.0)
    {
      v107 = *(_QWORD *)(a1 + 808);
      if ((v107 & 1) != 0)
      {
        *(_QWORD *)(a1 + 808) = 1;
        v108 = *(_BYTE **)(a1 + 816);
      }
      else
      {
        *(_BYTE *)(a1 + 808) = v107 & 1;
        v108 = (_BYTE *)(a1 + 809);
      }
      *v108 = 0;
      *(_QWORD *)(a1 + 896) = v101;
      v109 = *(_QWORD *)(a1 + 880);
      *(_QWORD *)(a1 + 888) = v109;
      *(_QWORD *)(a1 + 880) = 0;
      *(_QWORD *)(a1 + 464) = v109;
      re::DynamicString::appendf((re::DynamicString *)(a1 + 800), "%+lld allocs/sec", v109);
      v99 = v113.i64[0];
    }
LABEL_115:
    v110 = v112.i64[1];
    if (v112.i64[0])
    {
      re::DynamicString::appendf((re::DynamicString *)(a1 + 704), "   (S): %llu", v112.i64[0]);
      v110 = v112.i64[1];
      v99 = v113.i64[0];
    }
    if (v110)
    {
      re::DynamicString::appendf((re::DynamicString *)(a1 + 736), "   (M): %llu", v110);
      v99 = v113.i64[0];
    }
    if (v42)
    {
      re::DynamicString::appendf((re::DynamicString *)(a1 + 768), "   (L): %llu", v42);
      v99 = v113.i64[0];
    }
    if (v99)
    {
      v111 = (double)v99 * 0.0009765625;
      re::DynamicString::appendf((re::DynamicString *)(a1 + 672), "  Size: %.2fKB", v111);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 12));
  }
}

void re::ProfilerMiniHUDProcessor::~ProfilerMiniHUDProcessor(re::ProfilerMiniHUDProcessor *this)
{
  re::ProfilerMiniHUDProcessor::~ProfilerMiniHUDProcessor(this);
  JUMPOUT(0x2276933B8);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;

  *(_QWORD *)this = &off_24ED7F7C0;
  v2 = *((_QWORD *)this + 100);
  if (v2)
  {
    if ((*((_BYTE *)this + 808) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *((_QWORD *)this + 102));
    *((_OWORD *)this + 50) = 0u;
    *((_OWORD *)this + 51) = 0u;
  }
  v3 = *((_QWORD *)this + 96);
  if (v3)
  {
    if ((*((_BYTE *)this + 776) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *((_QWORD *)this + 98));
    *((_OWORD *)this + 48) = 0u;
    *((_OWORD *)this + 49) = 0u;
  }
  v4 = *((_QWORD *)this + 92);
  if (v4)
  {
    if ((*((_BYTE *)this + 744) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, *((_QWORD *)this + 94));
    *((_OWORD *)this + 46) = 0u;
    *((_OWORD *)this + 47) = 0u;
  }
  v5 = *((_QWORD *)this + 88);
  if (v5)
  {
    if ((*((_BYTE *)this + 712) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v5 + 40))(v5, *((_QWORD *)this + 90));
    *((_OWORD *)this + 44) = 0u;
    *((_OWORD *)this + 45) = 0u;
  }
  v6 = *((_QWORD *)this + 84);
  if (v6)
  {
    if ((*((_BYTE *)this + 680) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v6 + 40))(v6, *((_QWORD *)this + 86));
    *((_OWORD *)this + 42) = 0u;
    *((_OWORD *)this + 43) = 0u;
  }
  v7 = *((_QWORD *)this + 80);
  if (v7)
  {
    if ((*((_BYTE *)this + 648) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v7 + 40))(v7, *((_QWORD *)this + 82));
    *((_OWORD *)this + 40) = 0u;
    *((_OWORD *)this + 41) = 0u;
  }
  v8 = *((_QWORD *)this + 76);
  if (v8)
  {
    if ((*((_BYTE *)this + 616) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v8 + 40))(v8, *((_QWORD *)this + 78));
    *((_OWORD *)this + 38) = 0u;
    *((_OWORD *)this + 39) = 0u;
  }
  v9 = *((_QWORD *)this + 72);
  if (v9)
  {
    if ((*((_BYTE *)this + 584) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v9 + 40))(v9, *((_QWORD *)this + 74));
    *((_OWORD *)this + 36) = 0u;
    *((_OWORD *)this + 37) = 0u;
  }
  v10 = *((_QWORD *)this + 68);
  if (v10)
  {
    if ((*((_BYTE *)this + 552) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v10 + 40))(v10, *((_QWORD *)this + 70));
    *((_OWORD *)this + 34) = 0u;
    *((_OWORD *)this + 35) = 0u;
  }
  v11 = *((_QWORD *)this + 64);
  if (v11)
  {
    if ((*((_BYTE *)this + 520) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v11 + 40))(v11, *((_QWORD *)this + 66));
    *((_OWORD *)this + 32) = 0u;
    *((_OWORD *)this + 33) = 0u;
  }
  v12 = *((_QWORD *)this + 60);
  if (v12)
  {
    if ((*((_BYTE *)this + 488) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v12 + 40))(v12, *((_QWORD *)this + 62));
    *((_OWORD *)this + 30) = 0u;
    *((_OWORD *)this + 31) = 0u;
  }
  v13 = *((_QWORD *)this + 49);
  if (v13)
  {
    if ((*((_BYTE *)this + 400) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v13 + 40))(v13, *((_QWORD *)this + 51));
    *(_OWORD *)((char *)this + 392) = 0u;
    *(_OWORD *)((char *)this + 408) = 0u;
  }
  v14 = *((_QWORD *)this + 45);
  if (v14)
  {
    if ((*((_BYTE *)this + 368) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v14 + 40))(v14, *((_QWORD *)this + 47));
    *(_OWORD *)((char *)this + 360) = 0u;
    *(_OWORD *)((char *)this + 376) = 0u;
  }
  v15 = *((_QWORD *)this + 41);
  if (v15)
  {
    if ((*((_BYTE *)this + 336) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v15 + 40))(v15, *((_QWORD *)this + 43));
    *(_OWORD *)((char *)this + 328) = 0u;
    *(_OWORD *)((char *)this + 344) = 0u;
  }
  v16 = *((_QWORD *)this + 37);
  if (v16)
  {
    if ((*((_BYTE *)this + 304) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v16 + 40))(v16, *((_QWORD *)this + 39));
    *(_OWORD *)((char *)this + 296) = 0u;
    *(_OWORD *)((char *)this + 312) = 0u;
  }
  v17 = *((_QWORD *)this + 33);
  if (v17)
  {
    if ((*((_BYTE *)this + 272) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v17 + 40))(v17, *((_QWORD *)this + 35));
    *(_OWORD *)((char *)this + 264) = 0u;
    *(_OWORD *)((char *)this + 280) = 0u;
  }
  v18 = *((_QWORD *)this + 29);
  if (v18)
  {
    if ((*((_BYTE *)this + 240) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v18 + 40))(v18, *((_QWORD *)this + 31));
    *(_OWORD *)((char *)this + 232) = 0u;
    *(_OWORD *)((char *)this + 248) = 0u;
  }
  v19 = *((_QWORD *)this + 25);
  if (v19)
  {
    if ((*((_BYTE *)this + 208) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v19 + 40))(v19, *((_QWORD *)this + 27));
    *(_OWORD *)((char *)this + 200) = 0u;
    *(_OWORD *)((char *)this + 216) = 0u;
  }
  v20 = *((_QWORD *)this + 21);
  if (v20)
  {
    if ((*((_BYTE *)this + 176) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v20 + 40))(v20, *((_QWORD *)this + 23));
    *(_OWORD *)((char *)this + 168) = 0u;
    *(_OWORD *)((char *)this + 184) = 0u;
  }
  v21 = *((_QWORD *)this + 17);
  if (v21)
  {
    if ((*((_BYTE *)this + 144) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v21 + 40))(v21, *((_QWORD *)this + 19));
    *(_OWORD *)((char *)this + 136) = 0u;
    *(_OWORD *)((char *)this + 152) = 0u;
  }
  v22 = *((_QWORD *)this + 13);
  if (v22)
  {
    if ((*((_BYTE *)this + 112) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v22 + 40))(v22, *((_QWORD *)this + 15));
    *(_OWORD *)((char *)this + 104) = 0u;
    *(_OWORD *)((char *)this + 120) = 0u;
  }
  v23 = *((_QWORD *)this + 9);
  if (v23)
  {
    if ((*((_BYTE *)this + 80) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v23 + 40))(v23, *((_QWORD *)this + 11));
    *(_OWORD *)((char *)this + 72) = 0u;
    *(_OWORD *)((char *)this + 88) = 0u;
  }
}

uint64_t re::ProfilerMiniHUDProcessor::willNeedEvents(re::ProfilerMiniHUDProcessor *this)
{
  return 0;
}

uint64_t re::ProfilerMiniHUDProcessor::willNeedStatistics(re::ProfilerMiniHUDProcessor *this)
{
  return 1;
}

uint64_t re::ProfilerMiniHUDProcessor::willNeedAttributions(re::ProfilerMiniHUDProcessor *this)
{
  return 0;
}

uint64_t re::ProfilerMiniHUDProcessor::willNeedMemoryStatistics(re::ProfilerMiniHUDProcessor *this)
{
  return 0;
}

float ___ZN2re13ProfilerUtils8timeBaseEv_block_invoke()
{
  __int128 v0;
  float result;
  mach_timebase_info info;

  mach_timebase_info(&info);
  *(_QWORD *)&v0 = info.numer;
  *((_QWORD *)&v0 + 1) = info.denom;
  result = *(float *)&info.numer;
  re::ProfilerUtils::s_timeBase = v0;
  return result;
}

re::ProfilerDetailedHUDProcessor *re::ProfilerDetailedHUDProcessor::ProfilerDetailedHUDProcessor(re::ProfilerDetailedHUDProcessor *this)
{
  _QWORD *v2;
  _anonymous_namespace_ *v3;
  _anonymous_namespace_ *v4;
  _anonymous_namespace_ *v5;
  _anonymous_namespace_ *v6;
  _anonymous_namespace_ *v7;

  *((_BYTE *)this + 8) = 0;
  *(_QWORD *)this = off_24ED7F870;
  *(_OWORD *)((char *)this + 12) = 0u;
  *(_OWORD *)((char *)this + 28) = 0u;
  *(_QWORD *)((char *)this + 44) = 0;
  *(_QWORD *)((char *)this + 52) = 0x7FFFFFFFLL;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 4) = 0u;
  v2 = (_QWORD *)((char *)this + 64);
  v3 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v2, 0);
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 6) = 0u;
  v4 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)this + 12, 0);
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 8) = 0u;
  v5 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)this + 16, 0);
  *((_OWORD *)this + 11) = 0u;
  *((_OWORD *)this + 10) = 0u;
  v6 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)this + 20, 0);
  *((_OWORD *)this + 13) = 0u;
  *((_OWORD *)this + 12) = 0u;
  v7 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)this + 24, 0);
  *((_OWORD *)this + 15) = 0u;
  *((_OWORD *)this + 14) = 0u;
  re::DynamicString::setCapacity((_QWORD *)this + 28, 0);
  *((_QWORD *)this + 33) = 0;
  *((_QWORD *)this + 34) = 0;
  *((_QWORD *)this + 32) = 5;
  *((_BYTE *)this + 280) = 0;
  getpid();
  memorystatus_control();
  *((_QWORD *)this + 34) = 0;
  return this;
}

void re::ProfilerDetailedHUDProcessor::process(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned int v6;
  _QWORD *i;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int *v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  int v26;
  uint64_t v27;
  _BYTE *v28;
  uint64_t v29;
  _BYTE *v30;
  unsigned int v31;
  unsigned int v32;
  uint64_t v33;
  float v34;
  unint64_t v35;
  double v36;
  unint64_t v37;
  unint64_t v38;
  double v39;
  uint64_t v40;
  uint64_t v41;
  unsigned int v42;
  float v43;
  unint64_t v44;
  double v45;
  unint64_t v46;
  unint64_t v47;
  double v48;
  uint64_t v49;
  uint64_t v50;
  unsigned int v51;
  float v52;
  unint64_t v53;
  double v54;
  unint64_t v55;
  unint64_t v56;
  double v57;
  uint64_t v58;
  uint64_t v59;
  unsigned int v60;
  float v61;
  unint64_t v62;
  double v63;
  unint64_t v64;
  unint64_t v65;
  double v66;
  uint64_t v67;
  uint64_t v68;
  unsigned int v69;
  float v70;
  unint64_t v71;
  double v72;
  unint64_t v73;
  unint64_t v74;
  double v75;
  uint64_t v76;
  uint64_t v77;
  unsigned int v78;
  float v79;
  unint64_t v80;
  double v81;
  unint64_t v82;
  unint64_t v83;
  double v84;
  uint64_t v85;
  uint64_t v86;
  unsigned int v87;
  float v88;
  unint64_t v89;
  double v90;
  unint64_t v91;
  unint64_t v92;
  uint64_t v93;
  uint64_t v94;
  unsigned int v95;
  float v96;
  unint64_t v97;
  double v98;
  unint64_t v99;
  unint64_t v100;
  double v101;
  uint64_t v102;
  uint64_t v103;
  unsigned int v104;
  float v105;
  unint64_t v106;
  double v107;
  unint64_t v108;
  unint64_t v109;
  double v110;
  uint64_t v111;
  uint64_t v112;
  unsigned int v113;
  float v114;
  unint64_t v115;
  double v116;
  unint64_t v117;
  unint64_t v118;
  double v119;
  uint64_t v120;
  uint64_t v121;
  unsigned int v122;
  float v123;
  unint64_t v124;
  double v125;
  unint64_t v126;
  unint64_t v127;
  double v128;
  uint64_t v129;
  uint64_t v130;
  unsigned int v131;
  float v132;
  unint64_t v133;
  double v134;
  unint64_t v135;
  unint64_t v136;
  uint64_t v137;
  uint64_t v138;
  unsigned int v139;
  float v140;
  unint64_t v141;
  double v142;
  unint64_t v143;
  unint64_t v144;
  double v145;
  uint64_t v146;
  uint64_t v147;
  unsigned int v148;
  float v149;
  unint64_t v150;
  double v151;
  unint64_t v152;
  unint64_t v153;
  uint64_t v154;
  uint64_t v155;
  unsigned int v156;
  float v157;
  unint64_t v158;
  double v159;
  unint64_t v160;
  unint64_t v161;
  uint64_t v162;
  uint64_t v163;
  unsigned int v164;
  float v165;
  unint64_t v166;
  double v167;
  unint64_t v168;
  unint64_t v169;
  double v170;
  uint64_t v171;
  uint64_t v172;
  unsigned int v173;
  float v174;
  unint64_t v175;
  double v176;
  unint64_t v177;
  unint64_t v178;
  double v179;
  uint64_t v180;
  uint64_t v181;
  unsigned int v182;
  float v183;
  unint64_t v184;
  double v185;
  unint64_t v186;
  unint64_t v187;
  uint64_t v188;
  uint64_t v189;
  unsigned int v190;
  float v191;
  unint64_t v192;
  double v193;
  unint64_t v194;
  unint64_t v195;
  uint64_t v196;
  uint64_t v197;
  unsigned int v198;
  float v199;
  unint64_t v200;
  double v201;
  unint64_t v202;
  unint64_t v203;
  uint64_t v204;
  uint64_t v205;
  unsigned int v206;
  float v207;
  unint64_t v208;
  double v209;
  unint64_t v210;
  unint64_t v211;
  double v212;
  uint64_t v213;
  uint64_t v214;
  unsigned int v215;
  float v216;
  unint64_t v217;
  double v218;
  unint64_t v219;
  unint64_t v220;
  uint64_t v221;
  uint64_t v222;
  unsigned int v223;
  float v224;
  unint64_t v225;
  double v226;
  unint64_t v227;
  unint64_t v228;
  double v229;
  float v230;
  float v231;
  uint64_t v232;
  uint64_t v233;
  unsigned int v234;
  float v235;
  float v236;
  float v237;
  unint64_t v238;
  double v239;
  unint64_t v240;
  unint64_t v241;
  double v242;
  float v243;
  double v244;
  double v245;
  double v246;
  uint64_t v247;
  uint64_t v248;
  unsigned int v249;
  float v250;
  float v251;
  float v252;
  float v253;
  float v254;
  float v255;
  float v256;
  float v257;
  float v258;
  float v259;
  unint64_t v260;
  double v261;
  double v262;
  unint64_t v263;
  unint64_t v264;
  double v265;
  double v266;
  double v267;
  float v268;
  float v269;
  float v270;
  float v271;
  float v272;
  float v273;
  uint64_t v274;
  uint64_t v275;
  unsigned int v276;
  float v277;
  float v278;
  float v279;
  float v280;
  unint64_t v281;
  double v282;
  double v283;
  float v284;
  float v285;
  unint64_t v286;
  unint64_t v287;
  float v288;
  uint64_t v289;
  uint64_t v290;
  uint64_t v291;
  unsigned int v292;
  float v293;
  float v294;
  float v295;
  unint64_t v296;
  BOOL v297;
  double v298;
  double v299;
  unint64_t v300;
  uint64_t v301;
  unsigned int v302;
  unsigned int v303;
  unsigned int v304;
  float v305;
  unsigned int v306;
  float v307;
  float v308;
  unsigned int v309;
  uint64_t v310;
  uint64_t v311;
  unsigned int v312;
  unsigned int v313;
  uint64_t v314;
  float v315;
  float v316;
  uint64_t v317;
  uint64_t v318;
  unsigned int v319;
  float v320;
  unint64_t v321;
  double v322;
  unint64_t v323;
  unint64_t v324;
  double v325;
  uint64_t v326;
  uint64_t v327;
  unsigned int v328;
  float v329;
  unint64_t v330;
  double v331;
  unint64_t v332;
  unint64_t v333;
  double v334;
  uint64_t v335;
  uint64_t v336;
  unsigned int v337;
  float v338;
  unint64_t v339;
  double v340;
  unint64_t v341;
  unint64_t v342;
  double v343;
  uint64_t v344;
  uint64_t v345;
  unsigned int v346;
  float v347;
  float v348;
  unint64_t v349;
  double v350;
  double v351;
  unint64_t v352;
  unint64_t v353;
  double v354;
  double v355;
  float v356;
  uint64_t v357;
  uint64_t v358;
  unsigned int v359;
  double v360;
  float v361;
  unint64_t v362;
  double v363;
  unint64_t v364;
  unint64_t v365;
  double v366;
  float v367;
  uint64_t v368;
  uint64_t v369;
  unsigned int v370;
  float v371;
  unint64_t v372;
  double v373;
  unint64_t v374;
  unint64_t v375;
  double v376;
  float v377;
  uint64_t v378;
  uint64_t v379;
  unsigned int v380;
  float v381;
  unint64_t v382;
  double v383;
  unint64_t v384;
  unint64_t v385;
  double v386;
  float v387;
  uint64_t v388;
  uint64_t v389;
  unsigned int v390;
  float v391;
  unint64_t v392;
  double v393;
  unint64_t v394;
  unint64_t v395;
  double v396;
  uint64_t v397;
  uint64_t v398;
  unsigned int v399;
  float v400;
  unint64_t v401;
  double v402;
  unint64_t v403;
  unint64_t v404;
  float v405;
  double v406;
  float v407;
  uint64_t v408;
  uint64_t v409;
  unsigned int v410;
  float v411;
  unint64_t v412;
  double v413;
  double v414;
  unint64_t v415;
  unint64_t v416;
  double v417;
  uint64_t v418;
  uint64_t v419;
  unsigned int v420;
  float v421;
  unint64_t v422;
  double v423;
  unint64_t v424;
  unint64_t v425;
  double v426;
  uint64_t v427;
  uint64_t v428;
  unsigned int v429;
  float v430;
  unint64_t v431;
  double v432;
  unint64_t v433;
  unint64_t v434;
  double v435;
  double v436;
  float v437;
  float v438;
  float v439;
  float v440;
  float v441;
  float v442;
  float v443;
  float v444;
  uint64_t v445;
  _BYTE *v446;
  uint64_t v447;
  _BYTE *v448;
  uint64_t v449;
  uint64_t v450;
  uint64_t v451;
  float v452;
  float v453;
  unsigned int v454;
  uint64_t v455;
  uint64_t v456;
  uint64_t v457;
  unsigned int v458;
  uint64_t v459;
  uint64_t v460;
  unsigned int v461;
  unint64_t v462;
  uint64_t v463;
  uint64_t v464;
  uint64_t v465;
  float v466;
  float v467;
  unsigned int v468;
  uint64_t v469;
  uint64_t v470;
  unint64_t v471;
  uint64_t v472;
  uint64_t v473;
  uint64_t v474;
  float v475;
  float v476;
  float v477;
  unsigned int v478;
  uint64_t v479;
  unsigned int v480;
  unsigned int v481;
  uint64_t v482;
  unint64_t v483;
  uint64_t v484;
  uint64_t v485;
  uint64_t v486;
  float v487;
  float v488;
  float v489;
  unsigned int v490;
  uint64_t v491;
  unsigned int v492;
  unsigned int v493;
  uint64_t v494;
  unint64_t v495;
  uint64_t v496;
  uint64_t v497;
  uint64_t v498;
  float v499;
  float v500;
  float v501;
  unsigned int v502;
  uint64_t v503;
  unsigned int v504;
  unsigned int v505;
  uint64_t v506;
  uint64_t v507;
  uint64_t v508;
  unsigned int v509;
  unint64_t v510;
  uint64_t v511;
  uint64_t v512;
  uint64_t v513;
  float v514;
  float v515;
  unsigned int v516;
  uint64_t v517;
  uint64_t v518;
  uint64_t v519;
  uint64_t v520;
  unsigned int v521;
  unint64_t v522;
  uint64_t v523;
  uint64_t v524;
  uint64_t v525;
  float v526;
  float v527;
  unsigned int v528;
  uint64_t v529;
  uint64_t v530;
  unint64_t v531;
  uint64_t v532;
  uint64_t v533;
  uint64_t v534;
  float v535;
  float v536;
  unsigned int v537;
  uint64_t v538;
  uint64_t v539;
  unint64_t v540;
  uint64_t v541;
  uint64_t v542;
  uint64_t v543;
  float v544;
  float v545;
  unsigned int v546;
  uint64_t v547;
  uint64_t v548;
  unint64_t v549;
  uint64_t v550;
  uint64_t v551;
  uint64_t v552;
  float v553;
  float v554;
  unsigned int v555;
  uint64_t v556;
  uint64_t v557;
  unint64_t v558;
  uint64_t v559;
  uint64_t v560;
  uint64_t v561;
  float v562;
  float v563;
  unsigned int v564;
  uint64_t v565;
  unint64_t v566;
  uint64_t v567;
  uint64_t v568;
  unsigned int v569;
  unsigned int v570;
  unsigned int v571;
  float v572;
  unint64_t v573;
  uint64_t v574;
  uint64_t v575;
  _BYTE *v576;
  void *v577;
  unint64_t v578;
  uint64_t v579;
  _BYTE *v580;
  uint64_t v581;
  uint64_t v582;
  uint64_t v583;
  unsigned int v584;
  float v585;
  double v586;
  unsigned int v587;
  unsigned int v588;
  unint64_t v589;
  uint64_t v590;
  uint64_t v591;
  uint64_t v592;
  float v593;
  float v594;
  unsigned int v595;
  uint64_t v596;
  uint64_t v597;
  unint64_t v598;
  uint64_t v599;
  uint64_t v600;
  uint64_t v601;
  float v602;
  float v603;
  unsigned int v604;
  uint64_t v605;
  unint64_t v606;
  uint64_t v607;
  uint64_t v608;
  unsigned int v609;
  unsigned int v610;
  unsigned int v611;
  float v612;
  unint64_t v613;
  uint64_t v614;
  double v615;
  double v616;
  double v617;
  float v618;
  double v619;
  float v620;
  double v621;
  double v622;
  double v623;
  double v624;
  double v625;
  double v626;
  double v627;
  double v628;
  double v629;
  double v630;
  double v631;
  float v632;
  float v633;
  double v634;
  float v635;
  double v636;
  float v637;
  float v638;
  double v639;
  float v640;
  double v641;
  float v642;
  mach_timebase_info info[2];
  _BYTE v644[40];
  uint64_t v645;
  char v646;

  ++*(_QWORD *)(a1 + 264);
  if (!*(_BYTE *)(a1 + 280))
  {
    *(_OWORD *)&info[0].numer = 0u;
    memset(v644, 0, 20);
    *(_QWORD *)&v644[20] = 0x7FFFFFFFLL;
    re::HashTable<re::ProfilerStatistic,re::FrameStats::CollectedStatistics,re::Hash<re::ProfilerStatistic>,re::EqualTo<re::ProfilerStatistic>,true,false>::operator=(a1 + 16, (uint64_t *)info);
    re::HashTable<unsigned long long,re::ecs2::RenderPassGroupBoundsInfo,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)info);
    v6 = 0;
    do
    {
      v646 = v6;
      info[0] = (mach_timebase_info)0xFF7FFFFF7F7FFFFFLL;
      info[1] = 0;
      *(_QWORD *)v644 = 0;
      *(_OWORD *)&v644[8] = xmmword_226192590;
      *(_OWORD *)&v644[24] = xmmword_2261925A0;
      v645 = 0;
      re::HashTable<re::ProfilerStatistic,re::FrameStats::CollectedStatistics,re::Hash<re::ProfilerStatistic>,re::EqualTo<re::ProfilerStatistic>,true,false>::addNew(a1 + 16, &v646, (re::FrameStats::CollectedStatistics *)info);
    }
    while (v6++ < 0x9C);
    *(_BYTE *)(a1 + 280) = 1;
  }
  v9 = *(_QWORD **)a4;
  for (i = *(_QWORD **)(a4 + 8); v9 != i; ++v9)
  {
    v10 = 0;
    v11 = *v9 + 64;
    do
    {
      v12 = (unint64_t *)(v11 + (v10 << 6));
      v13 = v12[3];
      if (v13)
      {
        v14 = v12[2];
        if (v14)
        {
          if (*(_QWORD *)(a1 + 16))
          {
            v15 = 0x94D049BB133111EBLL * ((0xBF58476D1CE4E5B9 * v10) ^ ((0xBF58476D1CE4E5B9 * v10) >> 27));
            v16 = (v15 ^ (v15 >> 31)) % *(unsigned int *)(a1 + 40);
            v17 = *(_QWORD *)(a1 + 32);
            v18 = *(unsigned int *)(*(_QWORD *)(a1 + 24) + 4 * v16);
            if ((_DWORD)v18 != 0x7FFFFFFF)
            {
              while (v10 != *(unsigned __int8 *)(v17 + 80 * v18 + 12))
              {
                v18 = *(_DWORD *)(v17 + 80 * v18 + 8) & 0x7FFFFFFF;
                if (v18 == 0x7FFFFFFF)
                  goto LABEL_16;
              }
              goto LABEL_17;
            }
          }
          else
          {
            v17 = *(_QWORD *)(a1 + 32);
          }
LABEL_16:
          LODWORD(v18) = 0x7FFFFFFF;
LABEL_17:
          re::FrameStats::CollectedStatistics::addGroupValues((re::FrameStats::CollectedStatistics *)(v17 + 80 * v18 + 16), (float)v14, (float)v13, (float)*v12, (float)*(unint64_t *)(v11 + (v10 << 6) + 8));
        }
      }
      ++v10;
    }
    while (v10 != 157);
  }
  if (!(*(_QWORD *)(a1 + 264) % *(_QWORD *)(a1 + 256)))
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 12));
    v19 = *(unsigned int *)(a1 + 48);
    if ((_DWORD)v19)
    {
      v20 = 0;
      v21 = (int *)(*(_QWORD *)(a1 + 32) + 8);
      while (1)
      {
        v22 = *v21;
        v21 += 20;
        if (v22 < 0)
          break;
        if (v19 == ++v20)
        {
          LODWORD(v20) = *(_DWORD *)(a1 + 48);
          break;
        }
      }
    }
    else
    {
      LODWORD(v20) = 0;
    }
    if ((_DWORD)v19 != (_DWORD)v20)
    {
      v23 = v20;
      do
      {
        v24 = *(_QWORD *)(a1 + 32) + 80 * v23;
        *(_OWORD *)(v24 + 40) = *(_OWORD *)(v24 + 16);
        *(_DWORD *)(v24 + 56) = *(_DWORD *)(v24 + 32);
        *(_OWORD *)(v24 + 16) = xmmword_2261925B0;
        *(_DWORD *)(v24 + 32) = 0;
        if (v19 <= (int)v20 + 1)
          v25 = v20 + 1;
        else
          v25 = v19;
        v26 = v20;
        while (1)
        {
          v23 = (v26 + 1);
          if (v25 - 1 == v26)
            break;
          ++v26;
          LODWORD(v20) = v23;
          if ((*(_DWORD *)(*(_QWORD *)(a1 + 32) + 80 * v23 + 8) & 0x80000000) != 0)
            goto LABEL_37;
        }
        LODWORD(v20) = v25;
LABEL_37:
        ;
      }
      while ((_DWORD)v19 != (_DWORD)v20);
    }
    v27 = *(_QWORD *)(a1 + 72);
    if ((v27 & 1) != 0)
    {
      *(_QWORD *)(a1 + 72) = 1;
      v28 = *(_BYTE **)(a1 + 80);
    }
    else
    {
      *(_BYTE *)(a1 + 72) = v27 & 1;
      v28 = (_BYTE *)(a1 + 73);
    }
    *v28 = 0;
    v29 = *(_QWORD *)(a1 + 104);
    if ((v29 & 1) != 0)
    {
      *(_QWORD *)(a1 + 104) = 1;
      v30 = *(_BYTE **)(a1 + 112);
    }
    else
    {
      *(_BYTE *)(a1 + 104) = v29 & 1;
      v30 = (_BYTE *)(a1 + 105);
    }
    *v30 = 0;
    v31 = 0x7FFFFFFF;
    if (*(_QWORD *)(a1 + 16))
    {
      v32 = *(_DWORD *)(*(_QWORD *)(a1 + 24) + 4 * (0x5692161D100B05E5uLL % *(unsigned int *)(a1 + 40)));
      if (v32 != 0x7FFFFFFF)
      {
        v33 = *(_QWORD *)(a1 + 32);
        v31 = *(_DWORD *)(*(_QWORD *)(a1 + 24) + 4 * (0x5692161D100B05E5uLL % *(unsigned int *)(a1 + 40)));
        if (*(_BYTE *)(v33 + 80 * v32 + 12) != 1)
        {
          while (1)
          {
            v31 = *(_DWORD *)(v33
                            + 80
                            * *(unsigned int *)(*(_QWORD *)(a1 + 24)
                                              + 4 * (0x5692161D100B05E5uLL % *(unsigned int *)(a1 + 40)))
                            + 8) & 0x7FFFFFFF;
            if (v31 == 0x7FFFFFFF)
              break;
            if (*(_BYTE *)(v33 + 80 * v31 + 12) == 1)
              goto LABEL_51;
          }
          v31 = 0x7FFFFFFF;
        }
      }
    }
LABEL_51:
    v34 = *(float *)(*(_QWORD *)(a1 + 32) + 80 * v31 + 48);
    v35 = *(_QWORD *)(a1 + 256);
    v36 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        v39 = NAN;
        goto LABEL_56;
      }
      LODWORD(v37) = info[0].numer;
      LODWORD(v38) = info[0].denom;
      v36 = (double)v37 / (double)v38;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v36;
    }
    v39 = v36 * (double)(unint64_t)(float)(v34 / (float)v35);
LABEL_56:
    if (*(_QWORD *)(a1 + 16))
    {
      v40 = *(_QWORD *)(a1 + 32);
      v41 = *(unsigned int *)(*(_QWORD *)(a1 + 24) + 4 * (0xDBD238973A2B148ALL % *(unsigned int *)(a1 + 40)));
      v42 = 0x7FFFFFFF;
      if ((_DWORD)v41 != 0x7FFFFFFF)
      {
        if (*(_BYTE *)(v40 + 80 * v41 + 12) == 2)
        {
LABEL_61:
          v42 = v41;
        }
        else
        {
          while (1)
          {
            LODWORD(v41) = *(_DWORD *)(v40 + 80 * v41 + 8) & 0x7FFFFFFF;
            v42 = 0x7FFFFFFF;
            if ((_DWORD)v41 == 0x7FFFFFFF)
              break;
            if (*(_BYTE *)(v40 + 80 * v41 + 12) == 2)
              goto LABEL_61;
          }
        }
      }
    }
    else
    {
      v40 = *(_QWORD *)(a1 + 32);
      v42 = 0x7FFFFFFF;
    }
    v43 = *(float *)(v40 + 80 * v42 + 48);
    v44 = *(_QWORD *)(a1 + 256);
    v45 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        v48 = NAN;
        goto LABEL_68;
      }
      LODWORD(v46) = info[0].numer;
      LODWORD(v47) = info[0].denom;
      v45 = (double)v46 / (double)v47;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v45;
    }
    v48 = v45 * (double)(unint64_t)(float)(v43 / (float)v44);
LABEL_68:
    if (*(_QWORD *)(a1 + 16))
    {
      v49 = *(_QWORD *)(a1 + 32);
      v50 = *(unsigned int *)(*(_QWORD *)(a1 + 24) + 4 * (0x1E535EEDE31428F0uLL % *(unsigned int *)(a1 + 40)));
      v51 = 0x7FFFFFFF;
      if ((_DWORD)v50 != 0x7FFFFFFF)
      {
        if (*(_BYTE *)(v49 + 80 * v50 + 12) == 3)
        {
LABEL_73:
          v51 = v50;
        }
        else
        {
          while (1)
          {
            LODWORD(v50) = *(_DWORD *)(v49 + 80 * v50 + 8) & 0x7FFFFFFF;
            v51 = 0x7FFFFFFF;
            if ((_DWORD)v50 == 0x7FFFFFFF)
              break;
            if (*(_BYTE *)(v49 + 80 * v50 + 12) == 3)
              goto LABEL_73;
          }
        }
      }
    }
    else
    {
      v49 = *(_QWORD *)(a1 + 32);
      v51 = 0x7FFFFFFF;
    }
    v52 = *(float *)(v49 + 80 * v51 + 48);
    v53 = *(_QWORD *)(a1 + 256);
    v54 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        v57 = NAN;
        goto LABEL_80;
      }
      LODWORD(v55) = info[0].numer;
      LODWORD(v56) = info[0].denom;
      v54 = (double)v55 / (double)v56;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v54;
    }
    v57 = v54 * (double)(unint64_t)(float)(v52 / (float)v53);
LABEL_80:
    if (*(_QWORD *)(a1 + 16))
    {
      v58 = *(_QWORD *)(a1 + 32);
      v59 = *(unsigned int *)(*(_QWORD *)(a1 + 24) + 4 * (0xB7A4712C74562914 % *(unsigned int *)(a1 + 40)));
      v60 = 0x7FFFFFFF;
      if ((_DWORD)v59 != 0x7FFFFFFF)
      {
        if (*(_BYTE *)(v58 + 80 * v59 + 12) == 4)
        {
LABEL_85:
          v60 = v59;
        }
        else
        {
          while (1)
          {
            LODWORD(v59) = *(_DWORD *)(v58 + 80 * v59 + 8) & 0x7FFFFFFF;
            v60 = 0x7FFFFFFF;
            if ((_DWORD)v59 == 0x7FFFFFFF)
              break;
            if (*(_BYTE *)(v58 + 80 * v59 + 12) == 4)
              goto LABEL_85;
          }
        }
      }
    }
    else
    {
      v58 = *(_QWORD *)(a1 + 32);
      v60 = 0x7FFFFFFF;
    }
    v61 = *(float *)(v58 + 80 * v60 + 48);
    v62 = *(_QWORD *)(a1 + 256);
    v63 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        v66 = NAN;
        goto LABEL_92;
      }
      LODWORD(v64) = info[0].numer;
      LODWORD(v65) = info[0].denom;
      v63 = (double)v64 / (double)v65;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v63;
    }
    v66 = v63 * (double)(unint64_t)(float)(v61 / (float)v62);
LABEL_92:
    v641 = v66;
    if (*(_QWORD *)(a1 + 16))
    {
      v67 = *(_QWORD *)(a1 + 32);
      v68 = *(unsigned int *)(*(_QWORD *)(a1 + 24) + 4 * (0xB6BF613DBEBB45DCLL % *(unsigned int *)(a1 + 40)));
      v69 = 0x7FFFFFFF;
      if ((_DWORD)v68 != 0x7FFFFFFF)
      {
        if (*(_BYTE *)(v67 + 80 * v68 + 12) == 5)
        {
LABEL_97:
          v69 = v68;
        }
        else
        {
          while (1)
          {
            LODWORD(v68) = *(_DWORD *)(v67 + 80 * v68 + 8) & 0x7FFFFFFF;
            v69 = 0x7FFFFFFF;
            if ((_DWORD)v68 == 0x7FFFFFFF)
              break;
            if (*(_BYTE *)(v67 + 80 * v68 + 12) == 5)
              goto LABEL_97;
          }
        }
      }
    }
    else
    {
      v67 = *(_QWORD *)(a1 + 32);
      v69 = 0x7FFFFFFF;
    }
    v70 = *(float *)(v67 + 80 * v69 + 48);
    v71 = *(_QWORD *)(a1 + 256);
    v72 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        v75 = NAN;
        goto LABEL_104;
      }
      LODWORD(v73) = info[0].numer;
      LODWORD(v74) = info[0].denom;
      v72 = (double)v73 / (double)v74;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v72;
    }
    v75 = v72 * (double)(unint64_t)(float)(v70 / (float)v71);
LABEL_104:
    if (*(_QWORD *)(a1 + 16))
    {
      v76 = *(_QWORD *)(a1 + 32);
      v77 = *(unsigned int *)(*(_QWORD *)(a1 + 24) + 4 * (0xD17707977078336CLL % *(unsigned int *)(a1 + 40)));
      v78 = 0x7FFFFFFF;
      if ((_DWORD)v77 != 0x7FFFFFFF)
      {
        if (*(_BYTE *)(v76 + 80 * v77 + 12) == 6)
        {
LABEL_109:
          v78 = v77;
        }
        else
        {
          while (1)
          {
            LODWORD(v77) = *(_DWORD *)(v76 + 80 * v77 + 8) & 0x7FFFFFFF;
            v78 = 0x7FFFFFFF;
            if ((_DWORD)v77 == 0x7FFFFFFF)
              break;
            if (*(_BYTE *)(v76 + 80 * v77 + 12) == 6)
              goto LABEL_109;
          }
        }
      }
    }
    else
    {
      v76 = *(_QWORD *)(a1 + 32);
      v78 = 0x7FFFFFFF;
    }
    v79 = *(float *)(v76 + 80 * v78 + 48);
    v80 = *(_QWORD *)(a1 + 256);
    v81 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        v84 = NAN;
        goto LABEL_116;
      }
      LODWORD(v82) = info[0].numer;
      LODWORD(v83) = info[0].denom;
      v81 = (double)v82 / (double)v83;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v81;
    }
    v84 = v81 * (double)(unint64_t)(float)(v79 / (float)v80);
LABEL_116:
    v639 = v84;
    if (*(_QWORD *)(a1 + 16))
    {
      v85 = *(_QWORD *)(a1 + 32);
      v86 = *(unsigned int *)(*(_QWORD *)(a1 + 24) + 4 * (0x12AE30237B17DF14uLL % *(unsigned int *)(a1 + 40)));
      v87 = 0x7FFFFFFF;
      if ((_DWORD)v86 != 0x7FFFFFFF)
      {
        if (*(_BYTE *)(v85 + 80 * v86 + 12) == 7)
        {
LABEL_121:
          v87 = v86;
        }
        else
        {
          while (1)
          {
            LODWORD(v86) = *(_DWORD *)(v85 + 80 * v86 + 8) & 0x7FFFFFFF;
            v87 = 0x7FFFFFFF;
            if ((_DWORD)v86 == 0x7FFFFFFF)
              break;
            if (*(_BYTE *)(v85 + 80 * v86 + 12) == 7)
              goto LABEL_121;
          }
        }
      }
    }
    else
    {
      v85 = *(_QWORD *)(a1 + 32);
      v87 = 0x7FFFFFFF;
    }
    v88 = *(float *)(v85 + 80 * v87 + 48);
    v89 = *(_QWORD *)(a1 + 256);
    v90 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        v636 = NAN;
        goto LABEL_128;
      }
      LODWORD(v91) = info[0].numer;
      LODWORD(v92) = info[0].denom;
      v90 = (double)v91 / (double)v92;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v90;
    }
    v636 = v90 * (double)(unint64_t)(float)(v88 / (float)v89);
LABEL_128:
    if (*(_QWORD *)(a1 + 16))
    {
      v93 = *(_QWORD *)(a1 + 32);
      v94 = *(unsigned int *)(*(_QWORD *)(a1 + 24) + 4 * (0x826C6ABF7FDD5AD7 % *(unsigned int *)(a1 + 40)));
      v95 = 0x7FFFFFFF;
      if ((_DWORD)v94 != 0x7FFFFFFF)
      {
        if (*(_BYTE *)(v93 + 80 * v94 + 12) == 9)
        {
LABEL_133:
          v95 = v94;
        }
        else
        {
          while (1)
          {
            LODWORD(v94) = *(_DWORD *)(v93 + 80 * v94 + 8) & 0x7FFFFFFF;
            v95 = 0x7FFFFFFF;
            if ((_DWORD)v94 == 0x7FFFFFFF)
              break;
            if (*(_BYTE *)(v93 + 80 * v94 + 12) == 9)
              goto LABEL_133;
          }
        }
      }
    }
    else
    {
      v93 = *(_QWORD *)(a1 + 32);
      v95 = 0x7FFFFFFF;
    }
    v96 = *(float *)(v93 + 80 * v95 + 48);
    v97 = *(_QWORD *)(a1 + 256);
    v98 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        v101 = NAN;
        goto LABEL_140;
      }
      LODWORD(v99) = info[0].numer;
      LODWORD(v100) = info[0].denom;
      v98 = (double)v99 / (double)v100;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v98;
    }
    v101 = v98 * (double)(unint64_t)(float)(v96 / (float)v97);
LABEL_140:
    v634 = v101;
    if (*(_QWORD *)(a1 + 16))
    {
      v102 = *(_QWORD *)(a1 + 32);
      v103 = *(unsigned int *)(*(_QWORD *)(a1 + 24) + 4 * (0x75C8519A9320579uLL % *(unsigned int *)(a1 + 40)));
      v104 = 0x7FFFFFFF;
      if ((_DWORD)v103 != 0x7FFFFFFF)
      {
        if (*(_BYTE *)(v102 + 80 * v103 + 12) == 10)
        {
LABEL_145:
          v104 = v103;
        }
        else
        {
          while (1)
          {
            LODWORD(v103) = *(_DWORD *)(v102 + 80 * v103 + 8) & 0x7FFFFFFF;
            v104 = 0x7FFFFFFF;
            if ((_DWORD)v103 == 0x7FFFFFFF)
              break;
            if (*(_BYTE *)(v102 + 80 * v103 + 12) == 10)
              goto LABEL_145;
          }
        }
      }
    }
    else
    {
      v102 = *(_QWORD *)(a1 + 32);
      v104 = 0x7FFFFFFF;
    }
    v105 = *(float *)(v102 + 80 * v104 + 48);
    v106 = *(_QWORD *)(a1 + 256);
    v107 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        v110 = NAN;
        goto LABEL_152;
      }
      LODWORD(v108) = info[0].numer;
      LODWORD(v109) = info[0].denom;
      v107 = (double)v108 / (double)v109;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v107;
    }
    v110 = v107 * (double)(unint64_t)(float)(v105 / (float)v106);
LABEL_152:
    v621 = v110;
    if (*(_QWORD *)(a1 + 16))
    {
      v111 = *(_QWORD *)(a1 + 32);
      v112 = *(unsigned int *)(*(_QWORD *)(a1 + 24) + 4 * (0xD56B1FBB9CEBA9E8 % *(unsigned int *)(a1 + 40)));
      v113 = 0x7FFFFFFF;
      if ((_DWORD)v112 != 0x7FFFFFFF)
      {
        if (*(_BYTE *)(v111 + 80 * v112 + 12) == 8)
        {
LABEL_157:
          v113 = v112;
        }
        else
        {
          while (1)
          {
            LODWORD(v112) = *(_DWORD *)(v111 + 80 * v112 + 8) & 0x7FFFFFFF;
            v113 = 0x7FFFFFFF;
            if ((_DWORD)v112 == 0x7FFFFFFF)
              break;
            if (*(_BYTE *)(v111 + 80 * v112 + 12) == 8)
              goto LABEL_157;
          }
        }
      }
    }
    else
    {
      v111 = *(_QWORD *)(a1 + 32);
      v113 = 0x7FFFFFFF;
    }
    v114 = *(float *)(v111 + 80 * v113 + 48);
    v115 = *(_QWORD *)(a1 + 256);
    v116 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        v119 = NAN;
        goto LABEL_164;
      }
      LODWORD(v117) = info[0].numer;
      LODWORD(v118) = info[0].denom;
      v116 = (double)v117 / (double)v118;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v116;
    }
    v119 = v116 * (double)(unint64_t)(float)(v114 / (float)v115);
LABEL_164:
    v619 = v119;
    if (*(_QWORD *)(a1 + 16))
    {
      v120 = *(_QWORD *)(a1 + 32);
      v121 = *(unsigned int *)(*(_QWORD *)(a1 + 24) + 4 * (0x3462D848F53ABB6DuLL % *(unsigned int *)(a1 + 40)));
      v122 = 0x7FFFFFFF;
      if ((_DWORD)v121 != 0x7FFFFFFF)
      {
        if (*(_BYTE *)(v120 + 80 * v121 + 12) == 11)
        {
LABEL_169:
          v122 = v121;
        }
        else
        {
          while (1)
          {
            LODWORD(v121) = *(_DWORD *)(v120 + 80 * v121 + 8) & 0x7FFFFFFF;
            v122 = 0x7FFFFFFF;
            if ((_DWORD)v121 == 0x7FFFFFFF)
              break;
            if (*(_BYTE *)(v120 + 80 * v121 + 12) == 11)
              goto LABEL_169;
          }
        }
      }
    }
    else
    {
      v120 = *(_QWORD *)(a1 + 32);
      v122 = 0x7FFFFFFF;
    }
    v123 = *(float *)(v120 + 80 * v122 + 48);
    v124 = *(_QWORD *)(a1 + 256);
    v125 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        v128 = NAN;
        goto LABEL_176;
      }
      LODWORD(v126) = info[0].numer;
      LODWORD(v127) = info[0].denom;
      v125 = (double)v126 / (double)v127;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v125;
    }
    v128 = v125 * (double)(unint64_t)(float)(v123 / (float)v124);
LABEL_176:
    if (*(_QWORD *)(a1 + 16))
    {
      v129 = *(_QWORD *)(a1 + 32);
      v130 = *(unsigned int *)(*(_QWORD *)(a1 + 24) + 4 * (0x37BE58E8D7213BBCuLL % *(unsigned int *)(a1 + 40)));
      v131 = 0x7FFFFFFF;
      if ((_DWORD)v130 != 0x7FFFFFFF)
      {
        if (*(_BYTE *)(v129 + 80 * v130 + 12) == 12)
        {
LABEL_181:
          v131 = v130;
        }
        else
        {
          while (1)
          {
            LODWORD(v130) = *(_DWORD *)(v129 + 80 * v130 + 8) & 0x7FFFFFFF;
            v131 = 0x7FFFFFFF;
            if ((_DWORD)v130 == 0x7FFFFFFF)
              break;
            if (*(_BYTE *)(v129 + 80 * v130 + 12) == 12)
              goto LABEL_181;
          }
        }
      }
    }
    else
    {
      v129 = *(_QWORD *)(a1 + 32);
      v131 = 0x7FFFFFFF;
    }
    v132 = *(float *)(v129 + 80 * v131 + 48);
    v133 = *(_QWORD *)(a1 + 256);
    v134 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        v615 = NAN;
        goto LABEL_188;
      }
      LODWORD(v135) = info[0].numer;
      LODWORD(v136) = info[0].denom;
      v134 = (double)v135 / (double)v136;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v134;
    }
    v615 = v134 * (double)(unint64_t)(float)(v132 / (float)v133);
LABEL_188:
    if (*(_QWORD *)(a1 + 16))
    {
      v137 = *(_QWORD *)(a1 + 32);
      v138 = *(unsigned int *)(*(_QWORD *)(a1 + 24) + 4 * (0xDCFA9555B5F881D1 % *(unsigned int *)(a1 + 40)));
      v139 = 0x7FFFFFFF;
      if ((_DWORD)v138 != 0x7FFFFFFF)
      {
        if (*(_BYTE *)(v137 + 80 * v138 + 12) == 13)
        {
LABEL_193:
          v139 = v138;
        }
        else
        {
          while (1)
          {
            LODWORD(v138) = *(_DWORD *)(v137 + 80 * v138 + 8) & 0x7FFFFFFF;
            v139 = 0x7FFFFFFF;
            if ((_DWORD)v138 == 0x7FFFFFFF)
              break;
            if (*(_BYTE *)(v137 + 80 * v138 + 12) == 13)
              goto LABEL_193;
          }
        }
      }
    }
    else
    {
      v137 = *(_QWORD *)(a1 + 32);
      v139 = 0x7FFFFFFF;
    }
    v140 = *(float *)(v137 + 80 * v139 + 48);
    v141 = *(_QWORD *)(a1 + 256);
    v142 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    v617 = v128;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        v145 = NAN;
        goto LABEL_200;
      }
      LODWORD(v143) = info[0].numer;
      LODWORD(v144) = info[0].denom;
      v142 = (double)v143 / (double)v144;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v142;
    }
    v145 = v142 * (double)(unint64_t)(float)(v140 / (float)v141);
LABEL_200:
    if (*(_QWORD *)(a1 + 16))
    {
      v146 = *(_QWORD *)(a1 + 32);
      v147 = *(unsigned int *)(*(_QWORD *)(a1 + 24) + 4 * (0x255C6046F62FBE29uLL % *(unsigned int *)(a1 + 40)));
      v148 = 0x7FFFFFFF;
      if ((_DWORD)v147 != 0x7FFFFFFF)
      {
        if (*(_BYTE *)(v146 + 80 * v147 + 12) == 14)
        {
LABEL_205:
          v148 = v147;
        }
        else
        {
          while (1)
          {
            LODWORD(v147) = *(_DWORD *)(v146 + 80 * v147 + 8) & 0x7FFFFFFF;
            v148 = 0x7FFFFFFF;
            if ((_DWORD)v147 == 0x7FFFFFFF)
              break;
            if (*(_BYTE *)(v146 + 80 * v147 + 12) == 14)
              goto LABEL_205;
          }
        }
      }
    }
    else
    {
      v146 = *(_QWORD *)(a1 + 32);
      v148 = 0x7FFFFFFF;
    }
    v149 = *(float *)(v146 + 80 * v148 + 48);
    v150 = *(_QWORD *)(a1 + 256);
    v151 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        v629 = NAN;
        goto LABEL_212;
      }
      LODWORD(v152) = info[0].numer;
      LODWORD(v153) = info[0].denom;
      v151 = (double)v152 / (double)v153;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v151;
    }
    v629 = v151 * (double)(unint64_t)(float)(v149 / (float)v150);
LABEL_212:
    if (*(_QWORD *)(a1 + 16))
    {
      v154 = *(_QWORD *)(a1 + 32);
      v155 = *(unsigned int *)(*(_QWORD *)(a1 + 24) + 4 * (0x392754934EA1539uLL % *(unsigned int *)(a1 + 40)));
      v156 = 0x7FFFFFFF;
      if ((_DWORD)v155 != 0x7FFFFFFF)
      {
        if (*(_BYTE *)(v154 + 80 * v155 + 12) == 15)
        {
LABEL_217:
          v156 = v155;
        }
        else
        {
          while (1)
          {
            LODWORD(v155) = *(_DWORD *)(v154 + 80 * v155 + 8) & 0x7FFFFFFF;
            v156 = 0x7FFFFFFF;
            if ((_DWORD)v155 == 0x7FFFFFFF)
              break;
            if (*(_BYTE *)(v154 + 80 * v155 + 12) == 15)
              goto LABEL_217;
          }
        }
      }
    }
    else
    {
      v154 = *(_QWORD *)(a1 + 32);
      v156 = 0x7FFFFFFF;
    }
    v157 = *(float *)(v154 + 80 * v156 + 48);
    v158 = *(_QWORD *)(a1 + 256);
    v159 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        v628 = NAN;
        goto LABEL_224;
      }
      LODWORD(v160) = info[0].numer;
      LODWORD(v161) = info[0].denom;
      v159 = (double)v160 / (double)v161;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v159;
    }
    v628 = v159 * (double)(unint64_t)(float)(v157 / (float)v158);
LABEL_224:
    if (*(_QWORD *)(a1 + 16))
    {
      v162 = *(_QWORD *)(a1 + 32);
      v163 = *(unsigned int *)(*(_QWORD *)(a1 + 24) + 4 * (0xD9844BCECCA4A8BDLL % *(unsigned int *)(a1 + 40)));
      v164 = 0x7FFFFFFF;
      if ((_DWORD)v163 != 0x7FFFFFFF)
      {
        if (*(_BYTE *)(v162 + 80 * v163 + 12) == 16)
        {
LABEL_229:
          v164 = v163;
        }
        else
        {
          while (1)
          {
            LODWORD(v163) = *(_DWORD *)(v162 + 80 * v163 + 8) & 0x7FFFFFFF;
            v164 = 0x7FFFFFFF;
            if ((_DWORD)v163 == 0x7FFFFFFF)
              break;
            if (*(_BYTE *)(v162 + 80 * v163 + 12) == 16)
              goto LABEL_229;
          }
        }
      }
    }
    else
    {
      v162 = *(_QWORD *)(a1 + 32);
      v164 = 0x7FFFFFFF;
    }
    v165 = *(float *)(v162 + 80 * v164 + 48);
    v166 = *(_QWORD *)(a1 + 256);
    v167 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        v170 = NAN;
        goto LABEL_236;
      }
      LODWORD(v168) = info[0].numer;
      LODWORD(v169) = info[0].denom;
      v167 = (double)v168 / (double)v169;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v167;
    }
    v170 = v167 * (double)(unint64_t)(float)(v165 / (float)v166);
LABEL_236:
    v624 = v170;
    if (*(_QWORD *)(a1 + 16))
    {
      v171 = *(_QWORD *)(a1 + 32);
      v172 = *(unsigned int *)(*(_QWORD *)(a1 + 24) + 4 * (0x302B8631721C51BEuLL % *(unsigned int *)(a1 + 40)));
      v173 = 0x7FFFFFFF;
      if ((_DWORD)v172 != 0x7FFFFFFF)
      {
        if (*(_BYTE *)(v171 + 80 * v172 + 12) == 17)
        {
LABEL_241:
          v173 = v172;
        }
        else
        {
          while (1)
          {
            LODWORD(v172) = *(_DWORD *)(v171 + 80 * v172 + 8) & 0x7FFFFFFF;
            v173 = 0x7FFFFFFF;
            if ((_DWORD)v172 == 0x7FFFFFFF)
              break;
            if (*(_BYTE *)(v171 + 80 * v172 + 12) == 17)
              goto LABEL_241;
          }
        }
      }
    }
    else
    {
      v171 = *(_QWORD *)(a1 + 32);
      v173 = 0x7FFFFFFF;
    }
    v174 = *(float *)(v171 + 80 * v173 + 48);
    v175 = *(_QWORD *)(a1 + 256);
    v176 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        v179 = NAN;
        goto LABEL_248;
      }
      LODWORD(v177) = info[0].numer;
      LODWORD(v178) = info[0].denom;
      v176 = (double)v177 / (double)v178;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v176;
    }
    v179 = v176 * (double)(unint64_t)(float)(v174 / (float)v175);
LABEL_248:
    v625 = v179;
    if (*(_QWORD *)(a1 + 16))
    {
      v180 = *(_QWORD *)(a1 + 32);
      v181 = *(unsigned int *)(*(_QWORD *)(a1 + 24) + 4 * (0xE34A1ED09841F857 % *(unsigned int *)(a1 + 40)));
      v182 = 0x7FFFFFFF;
      if ((_DWORD)v181 != 0x7FFFFFFF)
      {
        if (*(_BYTE *)(v180 + 80 * v181 + 12) == 19)
        {
LABEL_253:
          v182 = v181;
        }
        else
        {
          while (1)
          {
            LODWORD(v181) = *(_DWORD *)(v180 + 80 * v181 + 8) & 0x7FFFFFFF;
            v182 = 0x7FFFFFFF;
            if ((_DWORD)v181 == 0x7FFFFFFF)
              break;
            if (*(_BYTE *)(v180 + 80 * v181 + 12) == 19)
              goto LABEL_253;
          }
        }
      }
    }
    else
    {
      v180 = *(_QWORD *)(a1 + 32);
      v182 = 0x7FFFFFFF;
    }
    v183 = *(float *)(v180 + 80 * v182 + 48);
    v184 = *(_QWORD *)(a1 + 256);
    v185 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        v626 = NAN;
        goto LABEL_260;
      }
      LODWORD(v186) = info[0].numer;
      LODWORD(v187) = info[0].denom;
      v185 = (double)v186 / (double)v187;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v185;
    }
    v626 = v185 * (double)(unint64_t)(float)(v183 / (float)v184);
LABEL_260:
    if (*(_QWORD *)(a1 + 16))
    {
      v188 = *(_QWORD *)(a1 + 32);
      v189 = *(unsigned int *)(*(_QWORD *)(a1 + 24) + 4 * (0xEB90A3352640AF2uLL % *(unsigned int *)(a1 + 40)));
      v190 = 0x7FFFFFFF;
      if ((_DWORD)v189 != 0x7FFFFFFF)
      {
        if (*(_BYTE *)(v188 + 80 * v189 + 12) == 20)
        {
LABEL_265:
          v190 = v189;
        }
        else
        {
          while (1)
          {
            LODWORD(v189) = *(_DWORD *)(v188 + 80 * v189 + 8) & 0x7FFFFFFF;
            v190 = 0x7FFFFFFF;
            if ((_DWORD)v189 == 0x7FFFFFFF)
              break;
            if (*(_BYTE *)(v188 + 80 * v189 + 12) == 20)
              goto LABEL_265;
          }
        }
      }
    }
    else
    {
      v188 = *(_QWORD *)(a1 + 32);
      v190 = 0x7FFFFFFF;
    }
    v191 = *(float *)(v188 + 80 * v190 + 48);
    v192 = *(_QWORD *)(a1 + 256);
    v193 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        v616 = NAN;
        goto LABEL_272;
      }
      LODWORD(v194) = info[0].numer;
      LODWORD(v195) = info[0].denom;
      v193 = (double)v194 / (double)v195;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v193;
    }
    v616 = v193 * (double)(unint64_t)(float)(v191 / (float)v192);
LABEL_272:
    if (*(_QWORD *)(a1 + 16))
    {
      v196 = *(_QWORD *)(a1 + 32);
      v197 = *(unsigned int *)(*(_QWORD *)(a1 + 24) + 4 * (0xD633B1846FAF2B49 % *(unsigned int *)(a1 + 40)));
      v198 = 0x7FFFFFFF;
      if ((_DWORD)v197 != 0x7FFFFFFF)
      {
        if (*(_BYTE *)(v196 + 80 * v197 + 12) == 21)
        {
LABEL_277:
          v198 = v197;
        }
        else
        {
          while (1)
          {
            LODWORD(v197) = *(_DWORD *)(v196 + 80 * v197 + 8) & 0x7FFFFFFF;
            v198 = 0x7FFFFFFF;
            if ((_DWORD)v197 == 0x7FFFFFFF)
              break;
            if (*(_BYTE *)(v196 + 80 * v197 + 12) == 21)
              goto LABEL_277;
          }
        }
      }
    }
    else
    {
      v196 = *(_QWORD *)(a1 + 32);
      v198 = 0x7FFFFFFF;
    }
    v199 = *(float *)(v196 + 80 * v198 + 48);
    v200 = *(_QWORD *)(a1 + 256);
    v201 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        v627 = NAN;
        goto LABEL_284;
      }
      LODWORD(v202) = info[0].numer;
      LODWORD(v203) = info[0].denom;
      v201 = (double)v202 / (double)v203;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v201;
    }
    v627 = v201 * (double)(unint64_t)(float)(v199 / (float)v200);
LABEL_284:
    if (*(_QWORD *)(a1 + 16))
    {
      v204 = *(_QWORD *)(a1 + 32);
      v205 = *(unsigned int *)(*(_QWORD *)(a1 + 24) + 4 * (0x378A5760BE593CA5uLL % *(unsigned int *)(a1 + 40)));
      v206 = 0x7FFFFFFF;
      if ((_DWORD)v205 != 0x7FFFFFFF)
      {
        if (*(_BYTE *)(v204 + 80 * v205 + 12) == 23)
        {
LABEL_289:
          v206 = v205;
        }
        else
        {
          while (1)
          {
            LODWORD(v205) = *(_DWORD *)(v204 + 80 * v205 + 8) & 0x7FFFFFFF;
            v206 = 0x7FFFFFFF;
            if ((_DWORD)v205 == 0x7FFFFFFF)
              break;
            if (*(_BYTE *)(v204 + 80 * v205 + 12) == 23)
              goto LABEL_289;
          }
        }
      }
    }
    else
    {
      v204 = *(_QWORD *)(a1 + 32);
      v206 = 0x7FFFFFFF;
    }
    v207 = *(float *)(v204 + 80 * v206 + 48);
    v208 = *(_QWORD *)(a1 + 256);
    v209 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    v631 = v39;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        v212 = NAN;
        goto LABEL_296;
      }
      LODWORD(v210) = info[0].numer;
      LODWORD(v211) = info[0].denom;
      v209 = (double)v210 / (double)v211;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v209;
    }
    v212 = v209 * (double)(unint64_t)(float)(v207 / (float)v208);
LABEL_296:
    if (*(_QWORD *)(a1 + 16))
    {
      v213 = *(_QWORD *)(a1 + 32);
      v214 = *(unsigned int *)(*(_QWORD *)(a1 + 24) + 4 * (0xFD95FA4DB404DD7BLL % *(unsigned int *)(a1 + 40)));
      v215 = 0x7FFFFFFF;
      if ((_DWORD)v214 != 0x7FFFFFFF)
      {
        if (*(_BYTE *)(v213 + 80 * v214 + 12) == 22)
        {
LABEL_301:
          v215 = v214;
        }
        else
        {
          while (1)
          {
            LODWORD(v214) = *(_DWORD *)(v213 + 80 * v214 + 8) & 0x7FFFFFFF;
            v215 = 0x7FFFFFFF;
            if ((_DWORD)v214 == 0x7FFFFFFF)
              break;
            if (*(_BYTE *)(v213 + 80 * v214 + 12) == 22)
              goto LABEL_301;
          }
        }
      }
    }
    else
    {
      v213 = *(_QWORD *)(a1 + 32);
      v215 = 0x7FFFFFFF;
    }
    v216 = *(float *)(v213 + 80 * v215 + 48);
    v217 = *(_QWORD *)(a1 + 256);
    v218 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        v623 = NAN;
        goto LABEL_308;
      }
      LODWORD(v219) = info[0].numer;
      LODWORD(v220) = info[0].denom;
      v218 = (double)v219 / (double)v220;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v218;
    }
    v623 = v218 * (double)(unint64_t)(float)(v216 / (float)v217);
LABEL_308:
    if (*(_QWORD *)(a1 + 16))
    {
      v221 = *(_QWORD *)(a1 + 32);
      v222 = *(unsigned int *)(*(_QWORD *)(a1 + 24) + 4 * (0x968A5BA23473FAFFLL % *(unsigned int *)(a1 + 40)));
      v223 = 0x7FFFFFFF;
      if ((_DWORD)v222 != 0x7FFFFFFF)
      {
        if (*(_BYTE *)(v221 + 80 * v222 + 12) == 91)
        {
LABEL_313:
          v223 = v222;
        }
        else
        {
          while (1)
          {
            LODWORD(v222) = *(_DWORD *)(v221 + 80 * v222 + 8) & 0x7FFFFFFF;
            v223 = 0x7FFFFFFF;
            if ((_DWORD)v222 == 0x7FFFFFFF)
              break;
            if (*(_BYTE *)(v221 + 80 * v222 + 12) == 91)
              goto LABEL_313;
          }
        }
      }
    }
    else
    {
      v221 = *(_QWORD *)(a1 + 32);
      v223 = 0x7FFFFFFF;
    }
    v224 = *(float *)(v221 + 80 * v223 + 48);
    v225 = *(_QWORD *)(a1 + 256);
    v226 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    v630 = v145;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        v229 = NAN;
        goto LABEL_320;
      }
      LODWORD(v227) = info[0].numer;
      LODWORD(v228) = info[0].denom;
      v226 = (double)v227 / (double)v228;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v226;
    }
    v229 = v226 * (double)(unint64_t)(float)(v224 / (float)v225);
LABEL_320:
    if (*(_QWORD *)(a1 + 16))
    {
      v232 = *(_QWORD *)(a1 + 32);
      v233 = *(unsigned int *)(*(_QWORD *)(a1 + 24) + 4 * (0xDE295D82F964F296 % *(unsigned int *)(a1 + 40)));
      v234 = 0x7FFFFFFF;
      if ((_DWORD)v233 != 0x7FFFFFFF)
      {
        if (*(_BYTE *)(v232 + 80 * v233 + 12) == 92)
        {
LABEL_325:
          v234 = v233;
        }
        else
        {
          while (1)
          {
            LODWORD(v233) = *(_DWORD *)(v232 + 80 * v233 + 8) & 0x7FFFFFFF;
            v234 = 0x7FFFFFFF;
            if ((_DWORD)v233 == 0x7FFFFFFF)
              break;
            if (*(_BYTE *)(v232 + 80 * v233 + 12) == 92)
              goto LABEL_325;
          }
        }
      }
    }
    else
    {
      v232 = *(_QWORD *)(a1 + 32);
      v234 = 0x7FFFFFFF;
    }
    v231 = v57 / 1000000.0;
    v230 = v48 / 1000000.0;
    v236 = v230 + v231;
    v237 = *(float *)(v232 + 80 * v234 + 48);
    v238 = *(_QWORD *)(a1 + 256);
    v239 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        v242 = NAN;
        goto LABEL_332;
      }
      LODWORD(v240) = info[0].numer;
      LODWORD(v241) = info[0].denom;
      v239 = (double)v240 / (double)v241;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v239;
    }
    v242 = v239 * (double)(unint64_t)(float)(v237 / (float)v238);
LABEL_332:
    v244 = v621 / 1000000.0;
    v245 = v229 / 1000000.0;
    v246 = v242 / 1000000.0;
    if (*(_QWORD *)(a1 + 16))
    {
      v247 = *(_QWORD *)(a1 + 32);
      v248 = *(unsigned int *)(*(_QWORD *)(a1 + 24) + 4 * (0xFEBD6A4FBD0A7802 % *(unsigned int *)(a1 + 40)));
      v249 = 0x7FFFFFFF;
      if ((_DWORD)v248 != 0x7FFFFFFF)
      {
        if (*(_BYTE *)(v247 + 80 * v248 + 12) == 93)
        {
LABEL_337:
          v249 = v248;
        }
        else
        {
          while (1)
          {
            LODWORD(v248) = *(_DWORD *)(v247 + 80 * v248 + 8) & 0x7FFFFFFF;
            v249 = 0x7FFFFFFF;
            if ((_DWORD)v248 == 0x7FFFFFFF)
              break;
            if (*(_BYTE *)(v247 + 80 * v248 + 12) == 93)
              goto LABEL_337;
          }
        }
      }
    }
    else
    {
      v247 = *(_QWORD *)(a1 + 32);
      v249 = 0x7FFFFFFF;
    }
    v250 = v639 / 1000000.0;
    v243 = v75 / 1000000.0;
    v235 = v641 / 1000000.0;
    v251 = (float)(v236 + v235) + v243;
    v252 = v619 / 1000000.0;
    v642 = v252;
    v253 = v617 / 1000000.0;
    v254 = v244;
    v255 = v615 / 1000000.0;
    v256 = v212 / 1000000.0;
    v640 = v256;
    v257 = v245;
    v258 = v246;
    v259 = *(float *)(v247 + 80 * v249 + 48);
    v260 = *(_QWORD *)(a1 + 256);
    v261 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    v262 = v636 / 1000000.0;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      v637 = v244;
      if (mach_timebase_info(info))
      {
        v265 = NAN;
        v267 = v631;
        v266 = v634;
        v253 = v617 / 1000000.0;
        v254 = v637;
        goto LABEL_344;
      }
      LODWORD(v263) = info[0].numer;
      LODWORD(v264) = info[0].denom;
      v261 = (double)v263 / (double)v264;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v261;
      v253 = v617 / 1000000.0;
      v254 = v637;
    }
    v265 = v261 * (double)(unint64_t)(float)(v259 / (float)v260);
    v267 = v631;
    v266 = v634;
LABEL_344:
    v269 = v265 / 1000000.0;
    v270 = v257 + v258;
    v620 = v253;
    v271 = (float)(v253 + v255) + v640;
    v272 = 0.0;
    if (v642 > 0.0)
    {
      v273 = v254;
    }
    else
    {
      v272 = v271;
      v273 = v271;
    }
    if (*(_QWORD *)(a1 + 16))
    {
      v274 = *(_QWORD *)(a1 + 32);
      v275 = *(unsigned int *)(*(_QWORD *)(a1 + 24) + 4 * (0xFFCB5C99F6AA8871 % *(unsigned int *)(a1 + 40)));
      v276 = 0x7FFFFFFF;
      if ((_DWORD)v275 != 0x7FFFFFFF)
      {
        if (*(_BYTE *)(v274 + 80 * v275 + 12) == 18)
        {
LABEL_352:
          v276 = v275;
        }
        else
        {
          while (1)
          {
            LODWORD(v275) = *(_DWORD *)(v274 + 80 * v275 + 8) & 0x7FFFFFFF;
            v276 = 0x7FFFFFFF;
            if ((_DWORD)v275 == 0x7FFFFFFF)
              break;
            if (*(_BYTE *)(v274 + 80 * v275 + 12) == 18)
              goto LABEL_352;
          }
        }
      }
    }
    else
    {
      v274 = *(_QWORD *)(a1 + 32);
      v276 = 0x7FFFFFFF;
    }
    v277 = v266 / 1000000.0;
    v268 = v262;
    v278 = (float)(v251 + v250) + v268;
    v279 = v270 + v269;
    v280 = *(float *)(v274 + 80 * v276 + 48);
    v281 = *(_QWORD *)(a1 + 256);
    v282 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    v283 = v267 / 1000000.0;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      v632 = v279;
      v284 = v277;
      v285 = v272;
      if (mach_timebase_info(info))
      {
        v622 = NAN;
        v272 = v285;
        v277 = v284;
        v255 = v615 / 1000000.0;
        v279 = v632;
        goto LABEL_359;
      }
      LODWORD(v286) = info[0].numer;
      LODWORD(v287) = info[0].denom;
      v282 = (double)v286 / (double)v287;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v282;
      v272 = v285;
      v277 = v284;
      v255 = v615 / 1000000.0;
      v279 = v632;
    }
    v622 = v282 * (double)(unint64_t)(float)(v280 / (float)v281);
LABEL_359:
    v288 = v283;
    v289 = *(_QWORD *)(a1 + 16);
    v618 = v255;
    if (v289)
    {
      v290 = *(_QWORD *)(a1 + 32);
      v291 = *(unsigned int *)(*(_QWORD *)(a1 + 24) + 4 * (0xD59EEF30DB86CAB8 % *(unsigned int *)(a1 + 40)));
      v292 = 0x7FFFFFFF;
      if ((_DWORD)v291 != 0x7FFFFFFF)
      {
        if (*(_BYTE *)(v290 + 80 * v291 + 12) == 24)
        {
LABEL_364:
          v292 = v291;
        }
        else
        {
          while (1)
          {
            LODWORD(v291) = *(_DWORD *)(v290 + 80 * v291 + 8) & 0x7FFFFFFF;
            v292 = 0x7FFFFFFF;
            if ((_DWORD)v291 == 0x7FFFFFFF)
              break;
            if (*(_BYTE *)(v290 + 80 * v291 + 12) == 24)
              goto LABEL_364;
          }
        }
      }
    }
    else
    {
      v290 = *(_QWORD *)(a1 + 32);
      v292 = 0x7FFFFFFF;
    }
    v293 = (float)(v277 - v254) + v279;
    v294 = (float)(v278 + v279) - v273;
    v295 = *(float *)(v290 + 80 * v292 + 48);
    v296 = *(_QWORD *)(a1 + 256);
    v297 = v288 <= 0.0;
    v298 = (float)(1000.0 / v288);
    if (v297)
      v299 = 0.0;
    else
      v299 = v298;
    v638 = v277;
    v635 = v278;
    if (v289)
    {
      v300 = *(unsigned int *)(a1 + 40);
      v301 = *(_QWORD *)(a1 + 24);
      v302 = *(_DWORD *)(v301 + 4 * (0x4F7ABB7627B74F52 % v300));
      v303 = 0x7FFFFFFF;
      v304 = 0x7FFFFFFF;
      if (v302 != 0x7FFFFFFF)
      {
        v304 = *(_DWORD *)(v301 + 4 * (0x4F7ABB7627B74F52 % v300));
        if (*(_BYTE *)(v290 + 80 * v302 + 12) != 29)
        {
          while (1)
          {
            v304 = *(_DWORD *)(v290 + 80 * *(unsigned int *)(v301 + 4 * (0x4F7ABB7627B74F52 % v300)) + 8) & 0x7FFFFFFF;
            if (v304 == 0x7FFFFFFF)
              break;
            if (*(_BYTE *)(v290 + 80 * v304 + 12) == 29)
              goto LABEL_377;
          }
          v304 = 0x7FFFFFFF;
        }
      }
LABEL_377:
      v309 = *(_DWORD *)(v301 + 4 * (0x724EA9269D42A72 % v300));
      if (v309 != 0x7FFFFFFF)
      {
        v303 = *(_DWORD *)(v301 + 4 * (0x724EA9269D42A72 % v300));
        if (*(_BYTE *)(v290 + 80 * v309 + 12) != 30)
        {
          while (1)
          {
            v303 = *(_DWORD *)(v290 + 80 * *(unsigned int *)(v301 + 4 * (0x724EA9269D42A72 % v300)) + 8) & 0x7FFFFFFF;
            if (v303 == 0x7FFFFFFF)
              break;
            if (*(_BYTE *)(v290 + 80 * v303 + 12) == 30)
              goto LABEL_383;
          }
          v303 = 0x7FFFFFFF;
        }
      }
LABEL_383:
      v310 = v290 + 80 * v304;
      v311 = v290 + 80 * v303;
      v312 = *(_DWORD *)(v301 + 4 * (0x540F172E046EF165 % v300));
      v306 = 0x7FFFFFFF;
      v313 = 0x7FFFFFFF;
      if (v312 != 0x7FFFFFFF)
      {
        v313 = *(_DWORD *)(v301 + 4 * (0x540F172E046EF165 % v300));
        if (*(_BYTE *)(v290 + 80 * v312 + 12) != 31)
        {
          while (1)
          {
            v313 = *(_DWORD *)(v290 + 80 * *(unsigned int *)(v301 + 4 * (0x540F172E046EF165 % v300)) + 8) & 0x7FFFFFFF;
            if (v313 == 0x7FFFFFFF)
              break;
            if (*(_BYTE *)(v290 + 80 * v313 + 12) == 31)
              goto LABEL_389;
          }
          v313 = 0x7FFFFFFF;
        }
      }
LABEL_389:
      v307 = *(float *)(v310 + 48);
      v308 = *(float *)(v311 + 48);
      v305 = *(float *)(v290 + 80 * v313 + 48);
      v314 = *(unsigned int *)(v301 + 4 * (0xADFB1EBB497FAD45 % v300));
      if ((_DWORD)v314 != 0x7FFFFFFF)
      {
        if (*(_BYTE *)(v290 + 80 * v314 + 12) == 32)
        {
LABEL_393:
          v306 = v314;
        }
        else
        {
          while (1)
          {
            LODWORD(v314) = *(_DWORD *)(v290 + 80 * v314 + 8) & 0x7FFFFFFF;
            v306 = 0x7FFFFFFF;
            if ((_DWORD)v314 == 0x7FFFFFFF)
              break;
            if (*(_BYTE *)(v290 + 80 * v314 + 12) == 32)
              goto LABEL_393;
          }
        }
      }
    }
    else
    {
      v305 = *(float *)(v290 + 0x27FFFFFFE0);
      v306 = 0x7FFFFFFF;
      v307 = v305;
      v308 = v305;
    }
    v315 = v293 - v272;
    v316 = *(float *)(v290 + 80 * v306 + 48);
    re::DynamicString::appendf((re::DynamicString *)(a1 + 64), "Frame Times (ms)\n");
    re::DynamicString::appendf((re::DynamicString *)(a1 + 64), "FPS: %.2f    Main Thread: %.2f\n", v299, v294);
    if (v642 > 0.0)
      re::DynamicString::appendf((re::DynamicString *)(a1 + 64), "Render Thread: %.2f\n", (float)((float)((float)(v642 - v620) - v618) - v640));
    re::DynamicString::appendf((re::DynamicString *)(a1 + 64), "GPU: %.2f\n", (float)((float)(v295 / (float)v296) / 1000000.0));
    re::DynamicString::appendf((re::DynamicString *)(a1 + 64), "Vtx: %.2f    Frg: %.2f\nRender Compute: %0.2f\nDeformer Compute: %0.2f\n", (double)(unint64_t)(float)((float)(v307 / (float)v296) / 1000000.0) / 1000000.0, (double)(unint64_t)(float)((float)(v308 / (float)v296) / 1000000.0) / 1000000.0, (double)(unint64_t)(float)((float)(v305 / (float)v296) / 1000000.0) / 1000000.0, (double)(unint64_t)(float)((float)(v316 / (float)v296) / 1000000.0) / 1000000.0);
    re::DynamicString::appendf((re::DynamicString *)(a1 + 96), "Engine CPU Breakdown (ms)\n");
    if (*(_QWORD *)(a1 + 16))
    {
      v317 = *(_QWORD *)(a1 + 32);
      v318 = *(unsigned int *)(*(_QWORD *)(a1 + 24) + 4 * (0x8AEB093D93E71BBFLL % *(unsigned int *)(a1 + 40)));
      v319 = 0x7FFFFFFF;
      if ((_DWORD)v318 != 0x7FFFFFFF)
      {
        if (*(_BYTE *)(v317 + 80 * v318 + 12) == 122)
        {
LABEL_401:
          v319 = v318;
        }
        else
        {
          while (1)
          {
            LODWORD(v318) = *(_DWORD *)(v317 + 80 * v318 + 8) & 0x7FFFFFFF;
            v319 = 0x7FFFFFFF;
            if ((_DWORD)v318 == 0x7FFFFFFF)
              break;
            if (*(_BYTE *)(v317 + 80 * v318 + 12) == 122)
              goto LABEL_401;
          }
        }
      }
    }
    else
    {
      v317 = *(_QWORD *)(a1 + 32);
      v319 = 0x7FFFFFFF;
    }
    v320 = *(float *)(v317 + 80 * v319 + 48);
    v321 = *(_QWORD *)(a1 + 256);
    v322 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        v325 = NAN;
        goto LABEL_408;
      }
      LODWORD(v323) = info[0].numer;
      LODWORD(v324) = info[0].denom;
      v322 = (double)v323 / (double)v324;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v322;
    }
    v325 = v322 * (double)(unint64_t)(float)(v320 / (float)v321);
LABEL_408:
    re::DynamicString::appendf((re::DynamicString *)(a1 + 96), "RenderGraph: %.2f    Render ECS: %.2f\n", (float)(v315 + v642), v325 / 1000000.0);
    if (*(_QWORD *)(a1 + 16))
    {
      v326 = *(_QWORD *)(a1 + 32);
      v327 = *(unsigned int *)(*(_QWORD *)(a1 + 24) + 4 * (0x786DD0AB972D849AuLL % *(unsigned int *)(a1 + 40)));
      v328 = 0x7FFFFFFF;
      if ((_DWORD)v327 != 0x7FFFFFFF)
      {
        if (*(_BYTE *)(v326 + 80 * v327 + 12) == 115)
        {
LABEL_413:
          v328 = v327;
        }
        else
        {
          while (1)
          {
            LODWORD(v327) = *(_DWORD *)(v326 + 80 * v327 + 8) & 0x7FFFFFFF;
            v328 = 0x7FFFFFFF;
            if ((_DWORD)v327 == 0x7FFFFFFF)
              break;
            if (*(_BYTE *)(v326 + 80 * v327 + 12) == 115)
              goto LABEL_413;
          }
        }
      }
    }
    else
    {
      v326 = *(_QWORD *)(a1 + 32);
      v328 = 0x7FFFFFFF;
    }
    v329 = *(float *)(v326 + 80 * v328 + 48);
    v330 = *(_QWORD *)(a1 + 256);
    v331 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        v334 = NAN;
        goto LABEL_420;
      }
      LODWORD(v332) = info[0].numer;
      LODWORD(v333) = info[0].denom;
      v331 = (double)v332 / (double)v333;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v331;
    }
    v334 = v331 * (double)(unint64_t)(float)(v329 / (float)v330);
LABEL_420:
    re::DynamicString::appendf((re::DynamicString *)(a1 + 96), "Deformations: %.2f\n", v334 / 1000000.0);
    if (*(_QWORD *)(a1 + 16))
    {
      v335 = *(_QWORD *)(a1 + 32);
      v336 = *(unsigned int *)(*(_QWORD *)(a1 + 24) + 4 * (0x3465840D39B46BB3uLL % *(unsigned int *)(a1 + 40)));
      v337 = 0x7FFFFFFF;
      if ((_DWORD)v336 != 0x7FFFFFFF)
      {
        if (*(unsigned __int8 *)(v335 + 80 * v336 + 12) == 150)
        {
LABEL_425:
          v337 = v336;
        }
        else
        {
          while (1)
          {
            LODWORD(v336) = *(_DWORD *)(v335 + 80 * v336 + 8) & 0x7FFFFFFF;
            v337 = 0x7FFFFFFF;
            if ((_DWORD)v336 == 0x7FFFFFFF)
              break;
            if (*(unsigned __int8 *)(v335 + 80 * v336 + 12) == 150)
              goto LABEL_425;
          }
        }
      }
    }
    else
    {
      v335 = *(_QWORD *)(a1 + 32);
      v337 = 0x7FFFFFFF;
    }
    v338 = *(float *)(v335 + 80 * v337 + 48);
    v339 = *(_QWORD *)(a1 + 256);
    v340 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        v343 = NAN;
        goto LABEL_432;
      }
      LODWORD(v341) = info[0].numer;
      LODWORD(v342) = info[0].denom;
      v340 = (double)v341 / (double)v342;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v340;
    }
    v343 = v340 * (double)(unint64_t)(float)(v338 / (float)v339);
LABEL_432:
    if (*(_QWORD *)(a1 + 16))
    {
      v344 = *(_QWORD *)(a1 + 32);
      v345 = *(unsigned int *)(*(_QWORD *)(a1 + 24) + 4 * (0xD12374540570B1A6 % *(unsigned int *)(a1 + 40)));
      v346 = 0x7FFFFFFF;
      if ((_DWORD)v345 != 0x7FFFFFFF)
      {
        if (*(unsigned __int8 *)(v344 + 80 * v345 + 12) == 130)
        {
LABEL_437:
          v346 = v345;
        }
        else
        {
          while (1)
          {
            LODWORD(v345) = *(_DWORD *)(v344 + 80 * v345 + 8) & 0x7FFFFFFF;
            v346 = 0x7FFFFFFF;
            if ((_DWORD)v345 == 0x7FFFFFFF)
              break;
            if (*(unsigned __int8 *)(v344 + 80 * v345 + 12) == 130)
              goto LABEL_437;
          }
        }
      }
    }
    else
    {
      v344 = *(_QWORD *)(a1 + 32);
      v346 = 0x7FFFFFFF;
    }
    v348 = *(float *)(v344 + 80 * v346 + 48);
    v349 = *(_QWORD *)(a1 + 256);
    v350 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    v351 = v343 / 1000000.0;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        v354 = NAN;
        goto LABEL_444;
      }
      LODWORD(v352) = info[0].numer;
      LODWORD(v353) = info[0].denom;
      v350 = (double)v352 / (double)v353;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v350;
    }
    v354 = v350 * (double)(unint64_t)(float)(v348 / (float)v349);
LABEL_444:
    v347 = v624 / 1000000.0;
    v355 = v347;
    v356 = v616 / 1000000.0;
    re::DynamicString::appendf((re::DynamicString *)(a1 + 96), "VFX RenderNode: %.2f    VFX ECS: %.2f\n", v351, v354 / 1000000.0);
    if (*(_QWORD *)(a1 + 16))
    {
      v357 = *(_QWORD *)(a1 + 32);
      v358 = *(unsigned int *)(*(_QWORD *)(a1 + 24) + 4 * (0x2D2898CE1F8CEF8EuLL % *(unsigned int *)(a1 + 40)));
      v359 = 0x7FFFFFFF;
      if ((_DWORD)v358 != 0x7FFFFFFF)
      {
        if (*(_BYTE *)(v357 + 80 * v358 + 12) == 125)
        {
LABEL_449:
          v359 = v358;
        }
        else
        {
          while (1)
          {
            LODWORD(v358) = *(_DWORD *)(v357 + 80 * v358 + 8) & 0x7FFFFFFF;
            v359 = 0x7FFFFFFF;
            if ((_DWORD)v358 == 0x7FFFFFFF)
              break;
            if (*(_BYTE *)(v357 + 80 * v358 + 12) == 125)
              goto LABEL_449;
          }
        }
      }
    }
    else
    {
      v357 = *(_QWORD *)(a1 + 32);
      v359 = 0x7FFFFFFF;
    }
    v360 = v625 / 1000000.0 + v355;
    v361 = *(float *)(v357 + 80 * v359 + 48);
    v362 = *(_QWORD *)(a1 + 256);
    v363 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        v366 = NAN;
        goto LABEL_456;
      }
      LODWORD(v364) = info[0].numer;
      LODWORD(v365) = info[0].denom;
      v363 = (double)v364 / (double)v365;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v363;
    }
    v366 = v363 * (double)(unint64_t)(float)(v361 / (float)v362);
LABEL_456:
    v367 = v360;
    re::DynamicString::appendf((re::DynamicString *)(a1 + 96), "Animation Update: %.2f    Animation ECS: %.2f\n", v356, v366 / 1000000.0);
    if (*(_QWORD *)(a1 + 16))
    {
      v368 = *(_QWORD *)(a1 + 32);
      v369 = *(unsigned int *)(*(_QWORD *)(a1 + 24) + 4 * (0xD94FA4A9067DC0C4 % *(unsigned int *)(a1 + 40)));
      v370 = 0x7FFFFFFF;
      if ((_DWORD)v369 != 0x7FFFFFFF)
      {
        if (*(_BYTE *)(v368 + 80 * v369 + 12) == 123)
        {
LABEL_461:
          v370 = v369;
        }
        else
        {
          while (1)
          {
            LODWORD(v369) = *(_DWORD *)(v368 + 80 * v369 + 8) & 0x7FFFFFFF;
            v370 = 0x7FFFFFFF;
            if ((_DWORD)v369 == 0x7FFFFFFF)
              break;
            if (*(_BYTE *)(v368 + 80 * v369 + 12) == 123)
              goto LABEL_461;
          }
        }
      }
    }
    else
    {
      v368 = *(_QWORD *)(a1 + 32);
      v370 = 0x7FFFFFFF;
    }
    v371 = *(float *)(v368 + 80 * v370 + 48);
    v372 = *(_QWORD *)(a1 + 256);
    v373 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        v376 = NAN;
        goto LABEL_468;
      }
      LODWORD(v374) = info[0].numer;
      LODWORD(v375) = info[0].denom;
      v373 = (double)v374 / (double)v375;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v373;
    }
    v376 = v373 * (double)(unint64_t)(float)(v371 / (float)v372);
LABEL_468:
    re::DynamicString::appendf((re::DynamicString *)(a1 + 96), "Network Update: %.2f    Network ECS: %.2f\n", v367, v376 / 1000000.0);
    if (*(_QWORD *)(a1 + 16))
    {
      v378 = *(_QWORD *)(a1 + 32);
      v379 = *(unsigned int *)(*(_QWORD *)(a1 + 24) + 4 * (0x8BC946409C88CB8FLL % *(unsigned int *)(a1 + 40)));
      v380 = 0x7FFFFFFF;
      if ((_DWORD)v379 != 0x7FFFFFFF)
      {
        if (*(_BYTE *)(v378 + 80 * v379 + 12) == 121)
        {
LABEL_473:
          v380 = v379;
        }
        else
        {
          while (1)
          {
            LODWORD(v379) = *(_DWORD *)(v378 + 80 * v379 + 8) & 0x7FFFFFFF;
            v380 = 0x7FFFFFFF;
            if ((_DWORD)v379 == 0x7FFFFFFF)
              break;
            if (*(_BYTE *)(v378 + 80 * v379 + 12) == 121)
              goto LABEL_473;
          }
        }
      }
    }
    else
    {
      v378 = *(_QWORD *)(a1 + 32);
      v380 = 0x7FFFFFFF;
    }
    v381 = *(float *)(v378 + 80 * v380 + 48);
    v382 = *(_QWORD *)(a1 + 256);
    v383 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        v386 = NAN;
        goto LABEL_480;
      }
      LODWORD(v384) = info[0].numer;
      LODWORD(v385) = info[0].denom;
      v383 = (double)v384 / (double)v385;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v383;
    }
    v386 = v383 * (double)(unint64_t)(float)(v381 / (float)v382);
LABEL_480:
    v377 = v626 / 1000000.0;
    re::DynamicString::appendf((re::DynamicString *)(a1 + 96), "Physics Engine: %.2f    Physics ECS: %.2f\n", v377, v386 / 1000000.0);
    if (*(_QWORD *)(a1 + 16))
    {
      v388 = *(_QWORD *)(a1 + 32);
      v389 = *(unsigned int *)(*(_QWORD *)(a1 + 24) + 4 * (0x178631649EA56D8AuLL % *(unsigned int *)(a1 + 40)));
      v390 = 0x7FFFFFFF;
      if ((_DWORD)v389 != 0x7FFFFFFF)
      {
        if (*(_BYTE *)(v388 + 80 * v389 + 12) == 120)
        {
LABEL_485:
          v390 = v389;
        }
        else
        {
          while (1)
          {
            LODWORD(v389) = *(_DWORD *)(v388 + 80 * v389 + 8) & 0x7FFFFFFF;
            v390 = 0x7FFFFFFF;
            if ((_DWORD)v389 == 0x7FFFFFFF)
              break;
            if (*(_BYTE *)(v388 + 80 * v389 + 12) == 120)
              goto LABEL_485;
          }
        }
      }
    }
    else
    {
      v388 = *(_QWORD *)(a1 + 32);
      v390 = 0x7FFFFFFF;
    }
    v391 = *(float *)(v388 + 80 * v390 + 48);
    v392 = *(_QWORD *)(a1 + 256);
    v393 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        v396 = NAN;
        goto LABEL_492;
      }
      LODWORD(v394) = info[0].numer;
      LODWORD(v395) = info[0].denom;
      v393 = (double)v394 / (double)v395;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v393;
    }
    v396 = v393 * (double)(unint64_t)(float)(v391 / (float)v392);
LABEL_492:
    v387 = v623 / 1000000.0;
    re::DynamicString::appendf((re::DynamicString *)(a1 + 96), "Audio Update: %.2f    Audio ECS: %.2f\n", v387, v396 / 1000000.0);
    if (*(_QWORD *)(a1 + 16))
    {
      v397 = *(_QWORD *)(a1 + 32);
      v398 = *(unsigned int *)(*(_QWORD *)(a1 + 24) + 4 * (0x89607B27DA843F55 % *(unsigned int *)(a1 + 40)));
      v399 = 0x7FFFFFFF;
      if ((_DWORD)v398 != 0x7FFFFFFF)
      {
        if (*(unsigned __int8 *)(v397 + 80 * v398 + 12) == 129)
        {
LABEL_497:
          v399 = v398;
        }
        else
        {
          while (1)
          {
            LODWORD(v398) = *(_DWORD *)(v397 + 80 * v398 + 8) & 0x7FFFFFFF;
            v399 = 0x7FFFFFFF;
            if ((_DWORD)v398 == 0x7FFFFFFF)
              break;
            if (*(unsigned __int8 *)(v397 + 80 * v398 + 12) == 129)
              goto LABEL_497;
          }
        }
      }
    }
    else
    {
      v397 = *(_QWORD *)(a1 + 32);
      v399 = 0x7FFFFFFF;
    }
    v400 = *(float *)(v397 + 80 * v399 + 48);
    v401 = *(_QWORD *)(a1 + 256);
    v402 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        v405 = v626 / 1000000.0;
        v406 = NAN;
        goto LABEL_504;
      }
      LODWORD(v403) = info[0].numer;
      LODWORD(v404) = info[0].denom;
      v402 = (double)v403 / (double)v404;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v402;
    }
    v405 = v626 / 1000000.0;
    v406 = v402 * (double)(unint64_t)(float)(v400 / (float)v401);
LABEL_504:
    v407 = v627 / 1000000.0;
    if (*(_QWORD *)(a1 + 16))
    {
      v408 = *(_QWORD *)(a1 + 32);
      v409 = *(unsigned int *)(*(_QWORD *)(a1 + 24) + 4 * (0xAF26563F2EC4C8E6 % *(unsigned int *)(a1 + 40)));
      v410 = 0x7FFFFFFF;
      if ((_DWORD)v409 != 0x7FFFFFFF)
      {
        if (*(unsigned __int8 *)(v408 + 80 * v409 + 12) == 128)
        {
LABEL_509:
          v410 = v409;
        }
        else
        {
          while (1)
          {
            LODWORD(v409) = *(_DWORD *)(v408 + 80 * v409 + 8) & 0x7FFFFFFF;
            v410 = 0x7FFFFFFF;
            if ((_DWORD)v409 == 0x7FFFFFFF)
              break;
            if (*(unsigned __int8 *)(v408 + 80 * v409 + 12) == 128)
              goto LABEL_509;
          }
        }
      }
    }
    else
    {
      v408 = *(_QWORD *)(a1 + 32);
      v410 = 0x7FFFFFFF;
    }
    v411 = *(float *)(v408 + 80 * v410 + 48);
    v412 = *(_QWORD *)(a1 + 256);
    v413 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    v414 = v406 / 1000000.0;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        v417 = NAN;
        goto LABEL_516;
      }
      LODWORD(v415) = info[0].numer;
      LODWORD(v416) = info[0].denom;
      v413 = (double)v415 / (double)v416;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v413;
    }
    v417 = v413 * (double)(unint64_t)(float)(v411 / (float)v412);
LABEL_516:
    re::DynamicString::appendf((re::DynamicString *)(a1 + 96), "Asset Update: %.2f    SU ECS: %.2f\n", v407, v414 + v417 / 1000000.0);
    if (*(_QWORD *)(a1 + 16))
    {
      v418 = *(_QWORD *)(a1 + 32);
      v419 = *(unsigned int *)(*(_QWORD *)(a1 + 24) + 4 * (0x584592B4271786AAuLL % *(unsigned int *)(a1 + 40)));
      v420 = 0x7FFFFFFF;
      if ((_DWORD)v419 != 0x7FFFFFFF)
      {
        if (*(_BYTE *)(v418 + 80 * v419 + 12) == 126)
        {
LABEL_521:
          v420 = v419;
        }
        else
        {
          while (1)
          {
            LODWORD(v419) = *(_DWORD *)(v418 + 80 * v419 + 8) & 0x7FFFFFFF;
            v420 = 0x7FFFFFFF;
            if ((_DWORD)v419 == 0x7FFFFFFF)
              break;
            if (*(_BYTE *)(v418 + 80 * v419 + 12) == 126)
              goto LABEL_521;
          }
        }
      }
    }
    else
    {
      v418 = *(_QWORD *)(a1 + 32);
      v420 = 0x7FFFFFFF;
    }
    v421 = *(float *)(v418 + 80 * v420 + 48);
    v422 = *(_QWORD *)(a1 + 256);
    v423 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        v426 = NAN;
        goto LABEL_528;
      }
      LODWORD(v424) = info[0].numer;
      LODWORD(v425) = info[0].denom;
      v423 = (double)v424 / (double)v425;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v423;
    }
    v426 = v423 * (double)(unint64_t)(float)(v421 / (float)v422);
LABEL_528:
    if (*(_QWORD *)(a1 + 16))
    {
      v427 = *(_QWORD *)(a1 + 32);
      v428 = *(unsigned int *)(*(_QWORD *)(a1 + 24) + 4 * (0xA09D66D4686AD125 % *(unsigned int *)(a1 + 40)));
      v429 = 0x7FFFFFFF;
      if ((_DWORD)v428 != 0x7FFFFFFF)
      {
        if (*(_BYTE *)(v427 + 80 * v428 + 12) == 127)
        {
LABEL_533:
          v429 = v428;
        }
        else
        {
          while (1)
          {
            LODWORD(v428) = *(_DWORD *)(v427 + 80 * v428 + 8) & 0x7FFFFFFF;
            v429 = 0x7FFFFFFF;
            if ((_DWORD)v428 == 0x7FFFFFFF)
              break;
            if (*(_BYTE *)(v427 + 80 * v428 + 12) == 127)
              goto LABEL_533;
          }
        }
      }
    }
    else
    {
      v427 = *(_QWORD *)(a1 + 32);
      v429 = 0x7FFFFFFF;
    }
    v430 = *(float *)(v427 + 80 * v429 + 48);
    v431 = *(_QWORD *)(a1 + 256);
    v432 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
    if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
    {
      if (mach_timebase_info(info))
      {
        v435 = NAN;
        goto LABEL_540;
      }
      LODWORD(v433) = info[0].numer;
      LODWORD(v434) = info[0].denom;
      v432 = (double)v433 / (double)v434;
      re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v432;
    }
    v435 = v432 * (double)(unint64_t)(float)(v430 / (float)v431);
LABEL_540:
    v436 = v426 / 1000000.0;
    v438 = v630 / 1000000.0;
    v439 = v629 / 1000000.0;
    v440 = v438 + v439;
    v441 = v628 / 1000000.0;
    v633 = v623 / 1000000.0;
    v442 = (float)((float)((float)((float)((float)((float)(v635 - (float)(v440 + v441)) - v367) - v405) - v356) - v407)
                 - v633)
         - v638;
    v443 = 0.0;
    if (v642 <= 0.0)
      v443 = v640;
    v444 = v442 - v443;
    re::DynamicString::appendf((re::DynamicString *)(a1 + 96), "Custom ECS: %.2f    Callback ECS: %.2f\n", v436, v435 / 1000000.0);
    v437 = v622 / 1000000.0;
    re::DynamicString::appendf((re::DynamicString *)(a1 + 96), "Update Callback: %.2f    Others: %.2f\n", v437, (float)(v444 - v437));
    v445 = *(_QWORD *)(a1 + 136);
    if ((v445 & 1) != 0)
    {
      *(_QWORD *)(a1 + 136) = 1;
      v446 = *(_BYTE **)(a1 + 144);
    }
    else
    {
      *(_BYTE *)(a1 + 136) = v445 & 1;
      v446 = (_BYTE *)(a1 + 137);
    }
    *v446 = 0;
    v447 = *(_QWORD *)(a1 + 168);
    if ((v447 & 1) != 0)
    {
      *(_QWORD *)(a1 + 168) = 1;
      v448 = *(_BYTE **)(a1 + 176);
    }
    else
    {
      *(_BYTE *)(a1 + 168) = v447 & 1;
      v448 = (_BYTE *)(a1 + 169);
    }
    *v448 = 0;
    re::DynamicString::appendf((re::DynamicString *)(a1 + 128), "Scene Draw Stats\n");
    if (*(_QWORD *)(a1 + 16))
    {
      v449 = *(_QWORD *)(a1 + 32);
      v450 = *(unsigned int *)(*(_QWORD *)(a1 + 24) + 4 * (0xC67949C3A864283CLL % *(unsigned int *)(a1 + 40)));
      if ((_DWORD)v450 == 0x7FFFFFFF || *(_BYTE *)(v449 + 80 * v450 + 12) == 34)
      {
        v451 = v449 + 80 * v450;
      }
      else
      {
        do
          LODWORD(v450) = *(_DWORD *)(v449 + 80 * v450 + 8) & 0x7FFFFFFF;
        while ((_DWORD)v450 != 0x7FFFFFFF && *(_BYTE *)(v449 + 80 * v450 + 12) != 34);
        v451 = v449 + 80 * v450;
      }
      v452 = (float)*(unint64_t *)(a1 + 256);
      v453 = *(float *)(v451 + 48) / v452;
      v455 = *(unsigned int *)(*(_QWORD *)(a1 + 24) + 4 * (0x43E7CEFC06C022BEuLL % *(unsigned int *)(a1 + 40)));
      v454 = 0x7FFFFFFF;
      if ((_DWORD)v455 != 0x7FFFFFFF)
      {
        if (*(_BYTE *)(v449 + 80 * v455 + 12) == 35)
        {
LABEL_560:
          v454 = v455;
        }
        else
        {
          while (1)
          {
            LODWORD(v455) = *(_DWORD *)(v449 + 80 * v455 + 8) & 0x7FFFFFFF;
            v454 = 0x7FFFFFFF;
            if ((_DWORD)v455 == 0x7FFFFFFF)
              break;
            if (*(_BYTE *)(v449 + 80 * v455 + 12) == 35)
              goto LABEL_560;
          }
        }
      }
    }
    else
    {
      v449 = *(_QWORD *)(a1 + 32);
      v452 = (float)*(unint64_t *)(a1 + 256);
      v453 = *(float *)(v449 + 0x27FFFFFFE0) / v452;
      v454 = 0x7FFFFFFF;
    }
    re::DynamicString::appendf((re::DynamicString *)(a1 + 128), "Meshes: %.0f    Draw Calls: %.0f\n", v453, (float)(*(float *)(v449 + 80 * v454 + 48) / v452));
    if (*(_QWORD *)(a1 + 16))
    {
      v456 = *(_QWORD *)(a1 + 32);
      v457 = *(unsigned int *)(*(_QWORD *)(a1 + 24) + 4 * (0xFF96B931ED5510E2 % *(unsigned int *)(a1 + 40)));
      v458 = 0x7FFFFFFF;
      if ((_DWORD)v457 != 0x7FFFFFFF)
      {
        if (*(_BYTE *)(v456 + 80 * v457 + 12) == 36)
        {
LABEL_566:
          v458 = v457;
        }
        else
        {
          while (1)
          {
            LODWORD(v457) = *(_DWORD *)(v456 + 80 * v457 + 8) & 0x7FFFFFFF;
            v458 = 0x7FFFFFFF;
            if ((_DWORD)v457 == 0x7FFFFFFF)
              break;
            if (*(_BYTE *)(v456 + 80 * v457 + 12) == 36)
              goto LABEL_566;
          }
        }
      }
    }
    else
    {
      v456 = *(_QWORD *)(a1 + 32);
      v458 = 0x7FFFFFFF;
    }
    re::DynamicString::appendf((re::DynamicString *)(a1 + 128), "Triangles Submitted: %.0f\n", (float)(*(float *)(v456 + 80 * v458 + 48) / (float)*(unint64_t *)(a1 + 256)));
    if (*(_QWORD *)(a1 + 16))
    {
      v459 = *(_QWORD *)(a1 + 32);
      v460 = *(unsigned int *)(*(_QWORD *)(a1 + 24) + 4 * (0x499EF488EF760E18uLL % *(unsigned int *)(a1 + 40)));
      v461 = 0x7FFFFFFF;
      if ((_DWORD)v460 != 0x7FFFFFFF)
      {
        if (*(_BYTE *)(v459 + 80 * v460 + 12) == 37)
        {
LABEL_573:
          v461 = v460;
        }
        else
        {
          while (1)
          {
            LODWORD(v460) = *(_DWORD *)(v459 + 80 * v460 + 8) & 0x7FFFFFFF;
            v461 = 0x7FFFFFFF;
            if ((_DWORD)v460 == 0x7FFFFFFF)
              break;
            if (*(_BYTE *)(v459 + 80 * v460 + 12) == 37)
              goto LABEL_573;
          }
        }
      }
    }
    else
    {
      v459 = *(_QWORD *)(a1 + 32);
      v461 = 0x7FFFFFFF;
    }
    re::DynamicString::appendf((re::DynamicString *)(a1 + 128), "Vertices Submitted: %.0f\n", (float)(*(float *)(v459 + 80 * v461 + 48) / (float)*(unint64_t *)(a1 + 256)));
    re::DynamicString::appendf((re::DynamicString *)(a1 + 128), "Lighting Stats \n");
    if (!*(_QWORD *)(a1 + 16))
    {
      v463 = *(_QWORD *)(a1 + 32);
      v466 = (float)*(unint64_t *)(a1 + 256);
      v467 = *(float *)(v463 + 0x27FFFFFFE0) / v466;
      v468 = 0x7FFFFFFF;
      goto LABEL_589;
    }
    v462 = *(unsigned int *)(a1 + 40);
    v464 = *(_QWORD *)(a1 + 24);
    v463 = *(_QWORD *)(a1 + 32);
    v465 = *(unsigned int *)(v464 + 4 * (0xD1F31274AB1CEA5ALL % v462));
    if ((_DWORD)v465 == 0x7FFFFFFF)
    {
      LODWORD(v465) = 0x7FFFFFFF;
    }
    else if (*(_BYTE *)(v463 + 80 * v465 + 12) != 95)
    {
      do
        LODWORD(v465) = *(_DWORD *)(v463 + 80 * v465 + 8) & 0x7FFFFFFF;
      while ((_DWORD)v465 != 0x7FFFFFFF && *(_BYTE *)(v463 + 80 * v465 + 12) != 95);
      v469 = v463 + 80 * v465;
LABEL_584:
      v466 = (float)*(unint64_t *)(a1 + 256);
      v467 = *(float *)(v469 + 48) / v466;
      v470 = *(unsigned int *)(v464 + 4 * (0xB283085A8C486789 % v462));
      v468 = 0x7FFFFFFF;
      if ((_DWORD)v470 != 0x7FFFFFFF)
      {
        if (*(_BYTE *)(v463 + 80 * v470 + 12) == 96)
        {
LABEL_588:
          v468 = v470;
        }
        else
        {
          while (1)
          {
            LODWORD(v470) = *(_DWORD *)(v463 + 80 * v470 + 8) & 0x7FFFFFFF;
            v468 = 0x7FFFFFFF;
            if ((_DWORD)v470 == 0x7FFFFFFF)
              break;
            if (*(_BYTE *)(v463 + 80 * v470 + 12) == 96)
              goto LABEL_588;
          }
        }
      }
LABEL_589:
      re::DynamicString::appendf((re::DynamicString *)(a1 + 128), "Total : %.0f (culled %.0f)\n", v467, (float)(*(float *)(v463 + 80 * v468 + 48) / v466));
      if (!*(_QWORD *)(a1 + 16))
      {
        v472 = *(_QWORD *)(a1 + 32);
        v475 = *(float *)(v472 + 0x27FFFFFFE0);
        v476 = (float)*(unint64_t *)(a1 + 256);
        v477 = v475 / v476;
        v478 = 0x7FFFFFFF;
        goto LABEL_609;
      }
      v471 = *(unsigned int *)(a1 + 40);
      v473 = *(_QWORD *)(a1 + 24);
      v472 = *(_QWORD *)(a1 + 32);
      v474 = *(unsigned int *)(v473 + 4 * (0xAEFF7D4B5B72EC99 % v471));
      if ((_DWORD)v474 == 0x7FFFFFFF)
      {
        LODWORD(v474) = 0x7FFFFFFF;
      }
      else if (*(_BYTE *)(v472 + 80 * v474 + 12) != 97)
      {
        do
          LODWORD(v474) = *(_DWORD *)(v472 + 80 * v474 + 8) & 0x7FFFFFFF;
        while ((_DWORD)v474 != 0x7FFFFFFF && *(_BYTE *)(v472 + 80 * v474 + 12) != 97);
        v479 = v472 + 80 * v474;
        goto LABEL_598;
      }
      v479 = v472 + 80 * v474;
LABEL_598:
      v476 = (float)*(unint64_t *)(a1 + 256);
      v477 = *(float *)(v479 + 48) / v476;
      v480 = *(_DWORD *)(v473 + 4 * (0x51B6E610EB969D89 % v471));
      v478 = 0x7FFFFFFF;
      v481 = 0x7FFFFFFF;
      if (v480 != 0x7FFFFFFF)
      {
        v481 = *(_DWORD *)(v473 + 4 * (0x51B6E610EB969D89 % v471));
        if (*(_BYTE *)(v472 + 80 * v480 + 12) != 103)
        {
          while (1)
          {
            v481 = *(_DWORD *)(v472 + 80 * *(unsigned int *)(v473 + 4 * (0x51B6E610EB969D89 % v471)) + 8) & 0x7FFFFFFF;
            if (v481 == 0x7FFFFFFF)
              break;
            if (*(_BYTE *)(v472 + 80 * v481 + 12) == 103)
              goto LABEL_604;
          }
          v481 = 0x7FFFFFFF;
        }
      }
LABEL_604:
      v475 = *(float *)(v472 + 80 * v481 + 48);
      v482 = *(unsigned int *)(v473 + 4 * (0xFADB7BDC13722E8ELL % v471));
      if ((_DWORD)v482 != 0x7FFFFFFF)
      {
        if (*(_BYTE *)(v472 + 80 * v482 + 12) == 104)
        {
LABEL_608:
          v478 = v482;
        }
        else
        {
          while (1)
          {
            LODWORD(v482) = *(_DWORD *)(v472 + 80 * v482 + 8) & 0x7FFFFFFF;
            v478 = 0x7FFFFFFF;
            if ((_DWORD)v482 == 0x7FFFFFFF)
              break;
            if (*(_BYTE *)(v472 + 80 * v482 + 12) == 104)
              goto LABEL_608;
          }
        }
      }
LABEL_609:
      re::DynamicString::appendf((re::DynamicString *)(a1 + 128), "Ambient : %.0f, Proxy : %.0f (culled %.0f)\n", v477, (float)(v475 / v476), (float)(*(float *)(v472 + 80 * v478 + 48) / v476));
      if (!*(_QWORD *)(a1 + 16))
      {
        v484 = *(_QWORD *)(a1 + 32);
        v487 = *(float *)(v484 + 0x27FFFFFFE0);
        v488 = (float)*(unint64_t *)(a1 + 256);
        v489 = v487 / v488;
        v490 = 0x7FFFFFFF;
        goto LABEL_629;
      }
      v483 = *(unsigned int *)(a1 + 40);
      v485 = *(_QWORD *)(a1 + 24);
      v484 = *(_QWORD *)(a1 + 32);
      v486 = *(unsigned int *)(v485 + 4 * (0x79CE5DC97509C089 % v483));
      if ((_DWORD)v486 == 0x7FFFFFFF)
      {
        LODWORD(v486) = 0x7FFFFFFF;
      }
      else if (*(_BYTE *)(v484 + 80 * v486 + 12) != 99)
      {
        do
          LODWORD(v486) = *(_DWORD *)(v484 + 80 * v486 + 8) & 0x7FFFFFFF;
        while ((_DWORD)v486 != 0x7FFFFFFF && *(_BYTE *)(v484 + 80 * v486 + 12) != 99);
        v491 = v484 + 80 * v486;
        goto LABEL_618;
      }
      v491 = v484 + 80 * v486;
LABEL_618:
      v488 = (float)*(unint64_t *)(a1 + 256);
      v489 = *(float *)(v491 + 48) / v488;
      v492 = *(_DWORD *)(v485 + 4 * (0x2731D9FDF756B334 % v483));
      v490 = 0x7FFFFFFF;
      v493 = 0x7FFFFFFF;
      if (v492 != 0x7FFFFFFF)
      {
        v493 = *(_DWORD *)(v485 + 4 * (0x2731D9FDF756B334 % v483));
        if (*(_BYTE *)(v484 + 80 * v492 + 12) != 100)
        {
          while (1)
          {
            v493 = *(_DWORD *)(v484 + 80 * *(unsigned int *)(v485 + 4 * (0x2731D9FDF756B334 % v483)) + 8) & 0x7FFFFFFF;
            if (v493 == 0x7FFFFFFF)
              break;
            if (*(_BYTE *)(v484 + 80 * v493 + 12) == 100)
              goto LABEL_624;
          }
          v493 = 0x7FFFFFFF;
        }
      }
LABEL_624:
      v487 = *(float *)(v484 + 80 * v493 + 48);
      v494 = *(unsigned int *)(v485 + 4 * (0xF2F8EDE6FA70BF5FLL % v483));
      if ((_DWORD)v494 != 0x7FFFFFFF)
      {
        if (*(_BYTE *)(v484 + 80 * v494 + 12) == 98)
        {
LABEL_628:
          v490 = v494;
        }
        else
        {
          while (1)
          {
            LODWORD(v494) = *(_DWORD *)(v484 + 80 * v494 + 8) & 0x7FFFFFFF;
            v490 = 0x7FFFFFFF;
            if ((_DWORD)v494 == 0x7FFFFFFF)
              break;
            if (*(_BYTE *)(v484 + 80 * v494 + 12) == 98)
              goto LABEL_628;
          }
        }
      }
LABEL_629:
      re::DynamicString::appendf((re::DynamicString *)(a1 + 128), "Point : %.0f (culled %.0f), Directional : %.0f\n", v489, (float)(v487 / v488), (float)(*(float *)(v484 + 80 * v490 + 48) / v488));
      if (!*(_QWORD *)(a1 + 16))
      {
        v496 = *(_QWORD *)(a1 + 32);
        v499 = *(float *)(v496 + 0x27FFFFFFE0);
        v500 = (float)*(unint64_t *)(a1 + 256);
        v501 = v499 / v500;
        v502 = 0x7FFFFFFF;
        goto LABEL_649;
      }
      v495 = *(unsigned int *)(a1 + 40);
      v497 = *(_QWORD *)(a1 + 24);
      v496 = *(_QWORD *)(a1 + 32);
      v498 = *(unsigned int *)(v497 + 4 * (0xA7D485D747130317 % v495));
      if ((_DWORD)v498 == 0x7FFFFFFF)
      {
        LODWORD(v498) = 0x7FFFFFFF;
      }
      else if (*(_BYTE *)(v496 + 80 * v498 + 12) != 101)
      {
        do
          LODWORD(v498) = *(_DWORD *)(v496 + 80 * v498 + 8) & 0x7FFFFFFF;
        while ((_DWORD)v498 != 0x7FFFFFFF && *(_BYTE *)(v496 + 80 * v498 + 12) != 101);
        v503 = v496 + 80 * v498;
        goto LABEL_638;
      }
      v503 = v496 + 80 * v498;
LABEL_638:
      v500 = (float)*(unint64_t *)(a1 + 256);
      v501 = *(float *)(v503 + 48) / v500;
      v504 = *(_DWORD *)(v497 + 4 * (0x973D7F79FC81E7F3 % v495));
      v502 = 0x7FFFFFFF;
      v505 = 0x7FFFFFFF;
      if (v504 != 0x7FFFFFFF)
      {
        v505 = *(_DWORD *)(v497 + 4 * (0x973D7F79FC81E7F3 % v495));
        if (*(_BYTE *)(v496 + 80 * v504 + 12) != 102)
        {
          while (1)
          {
            v505 = *(_DWORD *)(v496 + 80 * *(unsigned int *)(v497 + 4 * (0x973D7F79FC81E7F3 % v495)) + 8) & 0x7FFFFFFF;
            if (v505 == 0x7FFFFFFF)
              break;
            if (*(_BYTE *)(v496 + 80 * v505 + 12) == 102)
              goto LABEL_644;
          }
          v505 = 0x7FFFFFFF;
        }
      }
LABEL_644:
      v499 = *(float *)(v496 + 80 * v505 + 48);
      v506 = *(unsigned int *)(v497 + 4 * (0x168B5740BA2991FFLL % v495));
      if ((_DWORD)v506 != 0x7FFFFFFF)
      {
        if (*(_BYTE *)(v496 + 80 * v506 + 12) == 105)
        {
LABEL_648:
          v502 = v506;
        }
        else
        {
          while (1)
          {
            LODWORD(v506) = *(_DWORD *)(v496 + 80 * v506 + 8) & 0x7FFFFFFF;
            v502 = 0x7FFFFFFF;
            if ((_DWORD)v506 == 0x7FFFFFFF)
              break;
            if (*(_BYTE *)(v496 + 80 * v506 + 12) == 105)
              goto LABEL_648;
          }
        }
      }
LABEL_649:
      re::DynamicString::appendf((re::DynamicString *)(a1 + 128), "Spot : %.0f (culled %.0f), Area : %.0f\n", v501, (float)(v499 / v500), (float)(*(float *)(v496 + 80 * v502 + 48) / v500));
      if (*(_QWORD *)(a1 + 16))
      {
        v507 = *(_QWORD *)(a1 + 32);
        v508 = *(unsigned int *)(*(_QWORD *)(a1 + 24) + 4 * (0x17B1332CD96C043DuLL % *(unsigned int *)(a1 + 40)));
        v509 = 0x7FFFFFFF;
        if ((_DWORD)v508 != 0x7FFFFFFF)
        {
          if (*(_BYTE *)(v507 + 80 * v508 + 12) == 118)
          {
LABEL_654:
            v509 = v508;
          }
          else
          {
            while (1)
            {
              LODWORD(v508) = *(_DWORD *)(v507 + 80 * v508 + 8) & 0x7FFFFFFF;
              v509 = 0x7FFFFFFF;
              if ((_DWORD)v508 == 0x7FFFFFFF)
                break;
              if (*(_BYTE *)(v507 + 80 * v508 + 12) == 118)
                goto LABEL_654;
            }
          }
        }
      }
      else
      {
        v507 = *(_QWORD *)(a1 + 32);
        v509 = 0x7FFFFFFF;
      }
      re::DynamicString::appendf((re::DynamicString *)(a1 + 160), "Entities: %.0f\n", (float)(*(float *)(v507 + 80 * v509 + 48) / (float)*(unint64_t *)(a1 + 256)));
      re::DynamicString::appendf((re::DynamicString *)(a1 + 160), "Component Counts\n");
      if (!*(_QWORD *)(a1 + 16))
      {
        v511 = *(_QWORD *)(a1 + 32);
        v514 = (float)*(unint64_t *)(a1 + 256);
        v515 = *(float *)(v511 + 0x27FFFFFFE0) / v514;
        v516 = 0x7FFFFFFF;
        goto LABEL_670;
      }
      v510 = *(unsigned int *)(a1 + 40);
      v512 = *(_QWORD *)(a1 + 24);
      v511 = *(_QWORD *)(a1 + 32);
      v513 = *(unsigned int *)(v512 + 4 * (0x4A1033F1AB1B19DDLL % v510));
      if ((_DWORD)v513 == 0x7FFFFFFF)
      {
        LODWORD(v513) = 0x7FFFFFFF;
      }
      else if (*(_BYTE *)(v511 + 80 * v513 + 12) != 94)
      {
        do
          LODWORD(v513) = *(_DWORD *)(v511 + 80 * v513 + 8) & 0x7FFFFFFF;
        while ((_DWORD)v513 != 0x7FFFFFFF && *(_BYTE *)(v511 + 80 * v513 + 12) != 94);
        v517 = v511 + 80 * v513;
LABEL_665:
        v514 = (float)*(unint64_t *)(a1 + 256);
        v515 = *(float *)(v517 + 48) / v514;
        v518 = *(unsigned int *)(v512 + 4 * (0x2C81EA329AEABA69 % v510));
        v516 = 0x7FFFFFFF;
        if ((_DWORD)v518 != 0x7FFFFFFF)
        {
          if (*(_BYTE *)(v511 + 80 * v518 + 12) == 106)
          {
LABEL_669:
            v516 = v518;
          }
          else
          {
            while (1)
            {
              LODWORD(v518) = *(_DWORD *)(v511 + 80 * v518 + 8) & 0x7FFFFFFF;
              v516 = 0x7FFFFFFF;
              if ((_DWORD)v518 == 0x7FFFFFFF)
                break;
              if (*(_BYTE *)(v511 + 80 * v518 + 12) == 106)
                goto LABEL_669;
            }
          }
        }
LABEL_670:
        re::DynamicString::appendf((re::DynamicString *)(a1 + 160), "Meshes: %.0f, Shadows: %.0f\n", v515, (float)(*(float *)(v511 + 80 * v516 + 48) / v514));
        if (*(_QWORD *)(a1 + 16))
        {
          v519 = *(_QWORD *)(a1 + 32);
          v520 = *(unsigned int *)(*(_QWORD *)(a1 + 24) + 4 * (0xD1F31274AB1CEA5ALL % *(unsigned int *)(a1 + 40)));
          v521 = 0x7FFFFFFF;
          if ((_DWORD)v520 != 0x7FFFFFFF)
          {
            if (*(_BYTE *)(v519 + 80 * v520 + 12) == 95)
            {
LABEL_675:
              v521 = v520;
            }
            else
            {
              while (1)
              {
                LODWORD(v520) = *(_DWORD *)(v519 + 80 * v520 + 8) & 0x7FFFFFFF;
                v521 = 0x7FFFFFFF;
                if ((_DWORD)v520 == 0x7FFFFFFF)
                  break;
                if (*(_BYTE *)(v519 + 80 * v520 + 12) == 95)
                  goto LABEL_675;
              }
            }
          }
        }
        else
        {
          v519 = *(_QWORD *)(a1 + 32);
          v521 = 0x7FFFFFFF;
        }
        re::DynamicString::appendf((re::DynamicString *)(a1 + 160), "Lights: %.0f\n", (float)(*(float *)(v519 + 80 * v521 + 48) / (float)*(unint64_t *)(a1 + 256)));
        if (!*(_QWORD *)(a1 + 16))
        {
          v523 = *(_QWORD *)(a1 + 32);
          v526 = (float)*(unint64_t *)(a1 + 256);
          v527 = *(float *)(v523 + 0x27FFFFFFE0) / v526;
          v528 = 0x7FFFFFFF;
          goto LABEL_691;
        }
        v522 = *(unsigned int *)(a1 + 40);
        v524 = *(_QWORD *)(a1 + 24);
        v523 = *(_QWORD *)(a1 + 32);
        v525 = *(unsigned int *)(v524 + 4 * (0xD732B4173198B1FLL % v522));
        if ((_DWORD)v525 == 0x7FFFFFFF)
        {
          LODWORD(v525) = 0x7FFFFFFF;
        }
        else if (*(unsigned __int8 *)(v523 + 80 * v525 + 12) != 149)
        {
          do
            LODWORD(v525) = *(_DWORD *)(v523 + 80 * v525 + 8) & 0x7FFFFFFF;
          while ((_DWORD)v525 != 0x7FFFFFFF && *(unsigned __int8 *)(v523 + 80 * v525 + 12) != 149);
          v529 = v523 + 80 * v525;
LABEL_686:
          v526 = (float)*(unint64_t *)(a1 + 256);
          v527 = *(float *)(v529 + 48) / v526;
          v530 = *(unsigned int *)(v524 + 4 * (0xB3CC71E5DDF6EBC3 % v522));
          v528 = 0x7FFFFFFF;
          if ((_DWORD)v530 != 0x7FFFFFFF)
          {
            if (*(unsigned __int8 *)(v523 + 80 * v530 + 12) == 151)
            {
LABEL_690:
              v528 = v530;
            }
            else
            {
              while (1)
              {
                LODWORD(v530) = *(_DWORD *)(v523 + 80 * v530 + 8) & 0x7FFFFFFF;
                v528 = 0x7FFFFFFF;
                if ((_DWORD)v530 == 0x7FFFFFFF)
                  break;
                if (*(unsigned __int8 *)(v523 + 80 * v530 + 12) == 151)
                  goto LABEL_690;
              }
            }
          }
LABEL_691:
          re::DynamicString::appendf((re::DynamicString *)(a1 + 160), "VFX Scenes: %.0f, VFX Draw Calls: %.0f\n", v527, (float)(*(float *)(v523 + 80 * v528 + 48) / v526));
          if (!*(_QWORD *)(a1 + 16))
          {
            v532 = *(_QWORD *)(a1 + 32);
            v535 = (float)*(unint64_t *)(a1 + 256);
            v536 = *(float *)(v532 + 0x27FFFFFFE0) / v535;
            v537 = 0x7FFFFFFF;
            goto LABEL_705;
          }
          v531 = *(unsigned int *)(a1 + 40);
          v533 = *(_QWORD *)(a1 + 24);
          v532 = *(_QWORD *)(a1 + 32);
          v534 = *(unsigned int *)(v533 + 4 * (0x2427CEE8D2E4A800 % v531));
          if ((_DWORD)v534 == 0x7FFFFFFF)
          {
            LODWORD(v534) = 0x7FFFFFFF;
          }
          else if (*(unsigned __int8 *)(v532 + 80 * v534 + 12) != 143)
          {
            do
              LODWORD(v534) = *(_DWORD *)(v532 + 80 * v534 + 8) & 0x7FFFFFFF;
            while ((_DWORD)v534 != 0x7FFFFFFF && *(unsigned __int8 *)(v532 + 80 * v534 + 12) != 143);
            v538 = v532 + 80 * v534;
LABEL_700:
            v535 = (float)*(unint64_t *)(a1 + 256);
            v536 = *(float *)(v538 + 48) / v535;
            v539 = *(unsigned int *)(v533 + 4 * (0xA630657CB8C7F164 % v531));
            v537 = 0x7FFFFFFF;
            if ((_DWORD)v539 != 0x7FFFFFFF)
            {
              if (*(_BYTE *)(v532 + 80 * v539 + 12) == 48)
              {
LABEL_704:
                v537 = v539;
              }
              else
              {
                while (1)
                {
                  LODWORD(v539) = *(_DWORD *)(v532 + 80 * v539 + 8) & 0x7FFFFFFF;
                  v537 = 0x7FFFFFFF;
                  if ((_DWORD)v539 == 0x7FFFFFFF)
                    break;
                  if (*(_BYTE *)(v532 + 80 * v539 + 12) == 48)
                    goto LABEL_704;
                }
              }
            }
LABEL_705:
            re::DynamicString::appendf((re::DynamicString *)(a1 + 160), "AudioPlayers: %.0f, Network: %.0f\n", v536, (float)(*(float *)(v532 + 80 * v537 + 48) / v535));
            if (!*(_QWORD *)(a1 + 16))
            {
              v541 = *(_QWORD *)(a1 + 32);
              v544 = (float)*(unint64_t *)(a1 + 256);
              v545 = *(float *)(v541 + 0x27FFFFFFE0) / v544;
              v546 = 0x7FFFFFFF;
              goto LABEL_719;
            }
            v540 = *(unsigned int *)(a1 + 40);
            v542 = *(_QWORD *)(a1 + 24);
            v541 = *(_QWORD *)(a1 + 32);
            v543 = *(unsigned int *)(v542 + 4 * (0xCF4A7B3C48D45C4FLL % v540));
            if ((_DWORD)v543 == 0x7FFFFFFF)
            {
              LODWORD(v543) = 0x7FFFFFFF;
            }
            else if (*(_BYTE *)(v541 + 80 * v543 + 12) != 66)
            {
              do
                LODWORD(v543) = *(_DWORD *)(v541 + 80 * v543 + 8) & 0x7FFFFFFF;
              while ((_DWORD)v543 != 0x7FFFFFFF && *(_BYTE *)(v541 + 80 * v543 + 12) != 66);
              v547 = v541 + 80 * v543;
LABEL_714:
              v544 = (float)*(unint64_t *)(a1 + 256);
              v545 = *(float *)(v547 + 48) / v544;
              v548 = *(unsigned int *)(v542 + 4 * (0xA46B02245B9F3AF4 % v540));
              v546 = 0x7FFFFFFF;
              if ((_DWORD)v548 != 0x7FFFFFFF)
              {
                if (*(_BYTE *)(v541 + 80 * v548 + 12) == 67)
                {
LABEL_718:
                  v546 = v548;
                }
                else
                {
                  while (1)
                  {
                    LODWORD(v548) = *(_DWORD *)(v541 + 80 * v548 + 8) & 0x7FFFFFFF;
                    v546 = 0x7FFFFFFF;
                    if ((_DWORD)v548 == 0x7FFFFFFF)
                      break;
                    if (*(_BYTE *)(v541 + 80 * v548 + 12) == 67)
                      goto LABEL_718;
                  }
                }
              }
LABEL_719:
              re::DynamicString::appendf((re::DynamicString *)(a1 + 160), "RigidBodies: %.0f    Active: %.0f\n", v545, (float)(*(float *)(v541 + 80 * v546 + 48) / v544));
              if (!*(_QWORD *)(a1 + 16))
              {
                v550 = *(_QWORD *)(a1 + 32);
                v553 = (float)*(unint64_t *)(a1 + 256);
                v554 = *(float *)(v550 + 0x27FFFFFFE0) / v553;
                v555 = 0x7FFFFFFF;
                goto LABEL_733;
              }
              v549 = *(unsigned int *)(a1 + 40);
              v551 = *(_QWORD *)(a1 + 24);
              v550 = *(_QWORD *)(a1 + 32);
              v552 = *(unsigned int *)(v551 + 4 * (0x21C2DD3F1FDB3325 % v549));
              if ((_DWORD)v552 == 0x7FFFFFFF)
              {
                LODWORD(v552) = 0x7FFFFFFF;
              }
              else if (*(_BYTE *)(v550 + 80 * v552 + 12) != 68)
              {
                do
                  LODWORD(v552) = *(_DWORD *)(v550 + 80 * v552 + 8) & 0x7FFFFFFF;
                while ((_DWORD)v552 != 0x7FFFFFFF && *(_BYTE *)(v550 + 80 * v552 + 12) != 68);
                v556 = v550 + 80 * v552;
LABEL_728:
                v553 = (float)*(unint64_t *)(a1 + 256);
                v554 = *(float *)(v556 + 48) / v553;
                v557 = *(unsigned int *)(v551 + 4 * (0x41956A36DBC51080 % v549));
                v555 = 0x7FFFFFFF;
                if ((_DWORD)v557 != 0x7FFFFFFF)
                {
                  if (*(_BYTE *)(v550 + 80 * v557 + 12) == 69)
                  {
LABEL_732:
                    v555 = v557;
                  }
                  else
                  {
                    while (1)
                    {
                      LODWORD(v557) = *(_DWORD *)(v550 + 80 * v557 + 8) & 0x7FFFFFFF;
                      v555 = 0x7FFFFFFF;
                      if ((_DWORD)v557 == 0x7FFFFFFF)
                        break;
                      if (*(_BYTE *)(v550 + 80 * v557 + 12) == 69)
                        goto LABEL_732;
                    }
                  }
                }
LABEL_733:
                re::DynamicString::appendf((re::DynamicString *)(a1 + 160), "Colliders: %.0f    Contacts: %.0f\n", v554, (float)(*(float *)(v550 + 80 * v555 + 48) / v553));
                if (!*(_QWORD *)(a1 + 16))
                {
                  v559 = *(_QWORD *)(a1 + 32);
                  v562 = (float)*(unint64_t *)(a1 + 256);
                  v563 = *(float *)(v559 + 0x27FFFFFFE0) / v562;
                  v564 = 0x7FFFFFFF;
                  goto LABEL_745;
                }
                v558 = *(unsigned int *)(a1 + 40);
                v560 = *(_QWORD *)(a1 + 24);
                v559 = *(_QWORD *)(a1 + 32);
                v561 = *(unsigned int *)(v560 + 4 * (0xCA4B25A23588FF96 % v558));
                if ((_DWORD)v561 != 0x7FFFFFFF)
                {
                  if (*(_BYTE *)(v559 + 80 * v561 + 12) == 110)
                  {
LABEL_740:
                    v562 = (float)*(unint64_t *)(a1 + 256);
                    v563 = *(float *)(v559 + 80 * v561 + 48) / v562;
                    v565 = *(unsigned int *)(v560 + 4 * (0xF2BAED4A618B76B9 % v558));
                    v564 = 0x7FFFFFFF;
                    if ((_DWORD)v565 != 0x7FFFFFFF)
                    {
                      if (*(_BYTE *)(v559 + 80 * v565 + 12) == 108)
                      {
LABEL_744:
                        v564 = v565;
                      }
                      else
                      {
                        while (1)
                        {
                          LODWORD(v565) = *(_DWORD *)(v559 + 80 * v565 + 8) & 0x7FFFFFFF;
                          v564 = 0x7FFFFFFF;
                          if ((_DWORD)v565 == 0x7FFFFFFF)
                            break;
                          if (*(_BYTE *)(v559 + 80 * v565 + 12) == 108)
                            goto LABEL_744;
                        }
                      }
                    }
LABEL_745:
                    re::DynamicString::appendf((re::DynamicString *)(a1 + 160), "MeshDeformations: %.0f, SkeletalPoses: %.0f\n", v563, (float)(*(float *)(v559 + 80 * v564 + 48) / v562));
                    if (*(_QWORD *)(a1 + 16))
                    {
                      v566 = *(unsigned int *)(a1 + 40);
                      v568 = *(_QWORD *)(a1 + 24);
                      v567 = *(_QWORD *)(a1 + 32);
                      v569 = *(_DWORD *)(v568 + 4 * (0x33CFFC116CF4F2F0 % v566));
                      v570 = 0x7FFFFFFF;
                      v571 = 0x7FFFFFFF;
                      if (v569 != 0x7FFFFFFF)
                      {
                        v571 = *(_DWORD *)(v568 + 4 * (0x33CFFC116CF4F2F0 % v566));
                        if (*(_BYTE *)(v567 + 80 * v569 + 12) != 116)
                        {
                          while (1)
                          {
                            v571 = *(_DWORD *)(v567
                                             + 80 * *(unsigned int *)(v568 + 4 * (0x33CFFC116CF4F2F0 % v566))
                                             + 8) & 0x7FFFFFFF;
                            if (v571 == 0x7FFFFFFF)
                              break;
                            if (*(_BYTE *)(v567 + 80 * v571 + 12) == 116)
                              goto LABEL_753;
                          }
                          v571 = 0x7FFFFFFF;
                        }
                      }
LABEL_753:
                      v572 = *(float *)(v567 + 80 * v571 + 48);
                      v573 = *(_QWORD *)(a1 + 256);
                      v574 = *(unsigned int *)(v568 + 4 * (0xEF08A61A384AADEELL % v566));
                      if ((_DWORD)v574 != 0x7FFFFFFF)
                      {
                        if (*(_BYTE *)(v567 + 80 * v574 + 12) == 117)
                        {
LABEL_757:
                          v570 = v574;
                        }
                        else
                        {
                          while (1)
                          {
                            LODWORD(v574) = *(_DWORD *)(v567 + 80 * v574 + 8) & 0x7FFFFFFF;
                            v570 = 0x7FFFFFFF;
                            if ((_DWORD)v574 == 0x7FFFFFFF)
                              break;
                            if (*(_BYTE *)(v567 + 80 * v574 + 12) == 117)
                              goto LABEL_757;
                          }
                        }
                      }
                    }
                    else
                    {
                      v567 = *(_QWORD *)(a1 + 32);
                      v572 = *(float *)(v567 + 0x27FFFFFFE0);
                      v573 = *(_QWORD *)(a1 + 256);
                      v570 = 0x7FFFFFFF;
                    }
                    re::DynamicString::appendf((re::DynamicString *)(a1 + 160), "ActiveDeformations: %.0f, Joints: %.0f\n", (float)(v572 / (float)v573), (float)(*(float *)(v567 + 80 * v570 + 48) / (float)v573));
                    info[0].numer = 93;
                    task_info(*MEMORY[0x24BDAEC58], 0x16u, re::ProfilerDetailedHUDProcessor::setMemoryPowerStatisticsData(void)::vmInfo, (mach_msg_type_number_t *)info);
                    v575 = *(_QWORD *)(a1 + 200);
                    if ((v575 & 1) != 0)
                    {
                      *(_QWORD *)(a1 + 200) = 1;
                      v576 = *(_BYTE **)(a1 + 208);
                    }
                    else
                    {
                      *(_BYTE *)(a1 + 200) = v575 & 1;
                      v576 = (_BYTE *)(a1 + 201);
                    }
                    *v576 = 0;
                    re::DynamicString::append((re::DynamicString *)(a1 + 192), "System Memory and Thermal Info\n", 0x1FuLL);
                    re::DynamicString::appendf((re::DynamicString *)(a1 + 192), "Engine Dirty Memory : %.2f\n", (float)((float)((float)(unint64_t)qword_255835864 * 0.00097656) * 0.00097656));
                    re::DynamicString::appendf((re::DynamicString *)(a1 + 192), "Engine Peak Dirty Memory : %.2f\n", (float)((float)((float)qword_25583587C * 0.00097656) * 0.00097656));
                    re::DynamicString::appendf((re::DynamicString *)(a1 + 192), "Process Memory Limit : %.2f\n", (float)((float)((float)*(unint64_t *)(a1 + 272) * 0.00097656) * 0.00097656));
                    objc_msgSend(MEMORY[0x24BDD1760], "processInfo");
                    v577 = (void *)objc_claimAutoreleasedReturnValue();
                    v578 = objc_msgSend(v577, "thermalState");

                    if (v578 > 2)
                      re::DynamicString::appendf((re::DynamicString *)(a1 + 192), "Thermal State: Critical\n");
                    else
                      re::DynamicString::appendf((re::DynamicString *)(a1 + 192), off_24ED7F8D0[v578]);
                    v579 = *(_QWORD *)(a1 + 232);
                    if ((v579 & 1) != 0)
                    {
                      *(_QWORD *)(a1 + 232) = 1;
                      v580 = *(_BYTE **)(a1 + 240);
                    }
                    else
                    {
                      *(_BYTE *)(a1 + 232) = v579 & 1;
                      v580 = (_BYTE *)(a1 + 233);
                    }
                    *v580 = 0;
                    re::DynamicString::append((re::DynamicString *)(a1 + 224), "Network Session Stats\n", 0x16uLL);
                    re::DynamicString::append((re::DynamicString *)(a1 + 224), "Sent/Recevived\n", 0xFuLL);
                    v581 = *(_QWORD *)(a1 + 16);
                    if (v581)
                    {
                      v582 = *(_QWORD *)(a1 + 32);
                      v583 = *(unsigned int *)(*(_QWORD *)(a1 + 24)
                                             + 4 * (0xB74FD707F0B39325 % *(unsigned int *)(a1 + 40)));
                      v584 = 0x7FFFFFFF;
                      if ((_DWORD)v583 != 0x7FFFFFFF)
                      {
                        if (*(_BYTE *)(v582 + 80 * v583 + 12) == 40)
                        {
LABEL_772:
                          v584 = v583;
                        }
                        else
                        {
                          while (1)
                          {
                            LODWORD(v583) = *(_DWORD *)(v582 + 80 * v583 + 8) & 0x7FFFFFFF;
                            v584 = 0x7FFFFFFF;
                            if ((_DWORD)v583 == 0x7FFFFFFF)
                              break;
                            if (*(_BYTE *)(v582 + 80 * v583 + 12) == 40)
                              goto LABEL_772;
                          }
                        }
                      }
                    }
                    else
                    {
                      v582 = *(_QWORD *)(a1 + 32);
                      v584 = 0x7FFFFFFF;
                    }
                    v585 = (float)*(unint64_t *)(a1 + 256);
                    v586 = (float)(*(float *)(v582 + 80 * v584 + 48) / v585) * 0.0009765625;
                    v587 = 0x7FFFFFFF;
                    if (v581)
                    {
                      v588 = *(_DWORD *)(*(_QWORD *)(a1 + 24) + 4 * (0x66D1ECF1BBB89D25uLL % *(unsigned int *)(a1 + 40)));
                      if (v588 != 0x7FFFFFFF)
                      {
                        v587 = *(_DWORD *)(*(_QWORD *)(a1 + 24)
                                         + 4 * (0x66D1ECF1BBB89D25uLL % *(unsigned int *)(a1 + 40)));
                        if (*(_BYTE *)(v582 + 80 * v588 + 12) != 41)
                        {
                          while (1)
                          {
                            v587 = *(_DWORD *)(v582
                                             + 80
                                             * *(unsigned int *)(*(_QWORD *)(a1 + 24)
                                                               + 4
                                                               * (0x66D1ECF1BBB89D25uLL % *(unsigned int *)(a1 + 40)))
                                             + 8) & 0x7FFFFFFF;
                            if (v587 == 0x7FFFFFFF)
                              break;
                            if (*(_BYTE *)(v582 + 80 * v587 + 12) == 41)
                              goto LABEL_781;
                          }
                          v587 = 0x7FFFFFFF;
                        }
                      }
                    }
LABEL_781:
                    re::DynamicString::appendf((re::DynamicString *)(a1 + 224), "Bytes [KB]: %.2f/%.2f\n", v586, (float)(*(float *)(v582 + 80 * v587 + 48) / v585) * 0.0009765625);
                    if (!*(_QWORD *)(a1 + 16))
                    {
                      v590 = *(_QWORD *)(a1 + 32);
                      v593 = (float)*(unint64_t *)(a1 + 256);
                      v594 = *(float *)(v590 + 0x27FFFFFFE0) / v593;
                      v595 = 0x7FFFFFFF;
                      goto LABEL_795;
                    }
                    v589 = *(unsigned int *)(a1 + 40);
                    v591 = *(_QWORD *)(a1 + 24);
                    v590 = *(_QWORD *)(a1 + 32);
                    v592 = *(unsigned int *)(v591 + 4 * (0xA759EA27D4727622 % v589));
                    if ((_DWORD)v592 == 0x7FFFFFFF)
                    {
                      LODWORD(v592) = 0x7FFFFFFF;
                    }
                    else if (*(_BYTE *)(v590 + 80 * v592 + 12) != 42)
                    {
                      do
                        LODWORD(v592) = *(_DWORD *)(v590 + 80 * v592 + 8) & 0x7FFFFFFF;
                      while ((_DWORD)v592 != 0x7FFFFFFF && *(_BYTE *)(v590 + 80 * v592 + 12) != 42);
                      v596 = v590 + 80 * v592;
LABEL_790:
                      v593 = (float)*(unint64_t *)(a1 + 256);
                      v594 = *(float *)(v596 + 48) / v593;
                      v597 = *(unsigned int *)(v591 + 4 * (0x4F0A61D9C798D8CALL % v589));
                      v595 = 0x7FFFFFFF;
                      if ((_DWORD)v597 != 0x7FFFFFFF)
                      {
                        if (*(_BYTE *)(v590 + 80 * v597 + 12) == 43)
                        {
LABEL_794:
                          v595 = v597;
                        }
                        else
                        {
                          while (1)
                          {
                            LODWORD(v597) = *(_DWORD *)(v590 + 80 * v597 + 8) & 0x7FFFFFFF;
                            v595 = 0x7FFFFFFF;
                            if ((_DWORD)v597 == 0x7FFFFFFF)
                              break;
                            if (*(_BYTE *)(v590 + 80 * v597 + 12) == 43)
                              goto LABEL_794;
                          }
                        }
                      }
LABEL_795:
                      re::DynamicString::appendf((re::DynamicString *)(a1 + 224), "Packets: %.0f/%.0f\n", v594, (float)(*(float *)(v590 + 80 * v595 + 48) / v593));
                      if (!*(_QWORD *)(a1 + 16))
                      {
                        v599 = *(_QWORD *)(a1 + 32);
                        v602 = (float)*(unint64_t *)(a1 + 256);
                        v603 = *(float *)(v599 + 0x27FFFFFFE0) / v602;
                        v604 = 0x7FFFFFFF;
LABEL_807:
                        re::DynamicString::appendf((re::DynamicString *)(a1 + 224), "Components: %.0f/%.0f\n", v603, (float)(*(float *)(v599 + 80 * v604 + 48) / v602));
                        if (*(_QWORD *)(a1 + 16))
                        {
                          v606 = *(unsigned int *)(a1 + 40);
                          v608 = *(_QWORD *)(a1 + 24);
                          v607 = *(_QWORD *)(a1 + 32);
                          v609 = *(_DWORD *)(v608 + 4 * (0x6F14AEC17CB2794BLL % v606));
                          v610 = 0x7FFFFFFF;
                          v611 = 0x7FFFFFFF;
                          if (v609 != 0x7FFFFFFF)
                          {
                            v611 = *(_DWORD *)(v608 + 4 * (0x6F14AEC17CB2794BLL % v606));
                            if (*(_BYTE *)(v607 + 80 * v609 + 12) != 46)
                            {
                              while (1)
                              {
                                v611 = *(_DWORD *)(v607
                                                 + 80 * *(unsigned int *)(v608 + 4 * (0x6F14AEC17CB2794BLL % v606))
                                                 + 8) & 0x7FFFFFFF;
                                if (v611 == 0x7FFFFFFF)
                                  break;
                                if (*(_BYTE *)(v607 + 80 * v611 + 12) == 46)
                                  goto LABEL_815;
                              }
                              v611 = 0x7FFFFFFF;
                            }
                          }
LABEL_815:
                          v612 = *(float *)(v607 + 80 * v611 + 48);
                          v613 = *(_QWORD *)(a1 + 256);
                          v614 = *(unsigned int *)(v608 + 4 * (0x5A9FF51BA33ADC1CLL % v606));
                          if ((_DWORD)v614 != 0x7FFFFFFF)
                          {
                            if (*(_BYTE *)(v607 + 80 * v614 + 12) == 47)
                            {
LABEL_819:
                              v610 = v614;
                            }
                            else
                            {
                              while (1)
                              {
                                LODWORD(v614) = *(_DWORD *)(v607 + 80 * v614 + 8) & 0x7FFFFFFF;
                                v610 = 0x7FFFFFFF;
                                if ((_DWORD)v614 == 0x7FFFFFFF)
                                  break;
                                if (*(_BYTE *)(v607 + 80 * v614 + 12) == 47)
                                  goto LABEL_819;
                              }
                            }
                          }
                        }
                        else
                        {
                          v607 = *(_QWORD *)(a1 + 32);
                          v612 = *(float *)(v607 + 0x27FFFFFFE0);
                          v613 = *(_QWORD *)(a1 + 256);
                          v610 = 0x7FFFFFFF;
                        }
                        re::DynamicString::appendf((re::DynamicString *)(a1 + 224), "Entities: %.0f/%.0f\n", (float)(v612 / (float)v613), (float)(*(float *)(v607 + 80 * v610 + 48) / (float)v613));
                        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 12));
                        return;
                      }
                      v598 = *(unsigned int *)(a1 + 40);
                      v600 = *(_QWORD *)(a1 + 24);
                      v599 = *(_QWORD *)(a1 + 32);
                      v601 = *(unsigned int *)(v600 + 4 * (0xFB2BF4996809BAF7 % v598));
                      if ((_DWORD)v601 != 0x7FFFFFFF)
                      {
                        if (*(_BYTE *)(v599 + 80 * v601 + 12) == 44)
                        {
LABEL_802:
                          v602 = (float)*(unint64_t *)(a1 + 256);
                          v603 = *(float *)(v599 + 80 * v601 + 48) / v602;
                          v605 = *(unsigned int *)(v600 + 4 * (0xBDBFB556329AEE83 % v598));
                          v604 = 0x7FFFFFFF;
                          if ((_DWORD)v605 != 0x7FFFFFFF)
                          {
                            if (*(_BYTE *)(v599 + 80 * v605 + 12) == 45)
                            {
LABEL_806:
                              v604 = v605;
                            }
                            else
                            {
                              while (1)
                              {
                                LODWORD(v605) = *(_DWORD *)(v599 + 80 * v605 + 8) & 0x7FFFFFFF;
                                v604 = 0x7FFFFFFF;
                                if ((_DWORD)v605 == 0x7FFFFFFF)
                                  break;
                                if (*(_BYTE *)(v599 + 80 * v605 + 12) == 45)
                                  goto LABEL_806;
                              }
                            }
                          }
                          goto LABEL_807;
                        }
                        while (1)
                        {
                          LODWORD(v601) = *(_DWORD *)(v599 + 80 * v601 + 8) & 0x7FFFFFFF;
                          if ((_DWORD)v601 == 0x7FFFFFFF)
                            break;
                          if (*(_BYTE *)(v599 + 80 * v601 + 12) == 44)
                            goto LABEL_802;
                        }
                      }
                      LODWORD(v601) = 0x7FFFFFFF;
                      goto LABEL_802;
                    }
                    v596 = v590 + 80 * v592;
                    goto LABEL_790;
                  }
                  while (1)
                  {
                    LODWORD(v561) = *(_DWORD *)(v559 + 80 * v561 + 8) & 0x7FFFFFFF;
                    if ((_DWORD)v561 == 0x7FFFFFFF)
                      break;
                    if (*(_BYTE *)(v559 + 80 * v561 + 12) == 110)
                      goto LABEL_740;
                  }
                }
                LODWORD(v561) = 0x7FFFFFFF;
                goto LABEL_740;
              }
              v556 = v550 + 80 * v552;
              goto LABEL_728;
            }
            v547 = v541 + 80 * v543;
            goto LABEL_714;
          }
          v538 = v532 + 80 * v534;
          goto LABEL_700;
        }
        v529 = v523 + 80 * v525;
        goto LABEL_686;
      }
      v517 = v511 + 80 * v513;
      goto LABEL_665;
    }
    v469 = v463 + 80 * v465;
    goto LABEL_584;
  }
}

